<!DOCTYPE html><html lang="en"><head><title>Help for package marked</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {marked}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#backward_prob'><p>Computes backward probabilities</p></a></li>
<li><a href='#cjs_admb'><p>Fitting function for CJS models</p></a></li>
<li><a href='#cjs_delta'><p>HMM Initial state distribution functions</p></a></li>
<li><a href='#cjs_gamma'><p>HMM Transition matrix functions</p></a></li>
<li><a href='#cjs_tmb'><p>Fitting function for CJS models</p></a></li>
<li><a href='#cjs.accumulate'><p>Accumulates common capture history values</p></a></li>
<li><a href='#cjs.hessian'><p>Compute variance-covariance matrix for fitted CJS model</p></a></li>
<li><a href='#cjs.initial'><p>Computes starting values for CJS p and Phi parameters</p></a></li>
<li><a href='#cjs.lnl'><p>Likelihood function for Cormack-Jolly-Seber model</p></a></li>
<li><a href='#coef.crm'><p>Extract coefficients</p></a></li>
<li><a href='#compute_matrices'><p>Compute HMM matrices</p></a></li>
<li><a href='#compute_real'><p>Compute estimates of real parameters</p></a></li>
<li><a href='#convert.link.to.real'><p>Convert link values to real parameters</p></a></li>
<li><a href='#create.dm'><p>Creates a design matrix for a parameter</p></a></li>
<li><a href='#create.dmdf'><p>Creates a dataframe with all the design data for a particular parameter in a</p>
crm model</a></li>
<li><a href='#create.fixed.matrix'><p>Create parameters with fixed matrix</p></a></li>
<li><a href='#create.links'><p>Creates a 0/1 vector for real parameters with sin link</p></a></li>
<li><a href='#crm'><p>Capture-recapture model fitting function</p></a></li>
<li><a href='#crm.wrapper'><p>Automation of model runs</p></a></li>
<li><a href='#deriv_inverse.link'><p>Derivatives of inverse of link function (internal use)</p></a></li>
<li><a href='#dipper'><p>Dipper capture-recapture data</p></a></li>
<li><a href='#dmat_hsmm2hmm'><p>Create expanded state-dependent observation matrix for HMM from HSMM</p></a></li>
<li><a href='#fix.parameters'><p>Fixing real parameters in crm models</p></a></li>
<li><a href='#function.wrapper'><p>Utility extract functions</p></a></li>
<li><a href='#global_decode'><p>Global decoding of HMM</p></a></li>
<li><a href='#hmmDemo'><p>HMM computation demo functions</p></a></li>
<li><a href='#HMMLikelihood'><p>Hidden Markov Model likelihood functions</p></a></li>
<li><a href='#hsmm2hmm'><p>Compute transition matrix for HMM from HSMM</p></a></li>
<li><a href='#initiate_pi'><p>Setup fixed values for pi in design data</p></a></li>
<li><a href='#inverse.link'><p>Inverse link functions (internal use)</p></a></li>
<li><a href='#js'><p>Fitting function for Jolly-Seber model using Schwarz-Arnason POPAN</p>
formulation</a></li>
<li><a href='#js.accumulate'><p>Accumulates common capture history values</p></a></li>
<li><a href='#js.hessian'><p>Compute variance-covariance matrix for fitted JS model</p></a></li>
<li><a href='#js.lnl'><p>Likelihood function for Jolly-Seber model using Schwarz-Arnason POPAN</p>
formulation</a></li>
<li><a href='#local_decode'><p>Local decoding of HMM</p></a></li>
<li><a href='#make.design.data'><p>Create design dataframes for crm</p></a></li>
<li><a href='#merge_design.covariates'><p>Merge time (occasion) and/or group specific covariates into design data</p></a></li>
<li><a href='#mixed.model.admb'><p>Mixed effect model contstruction</p></a></li>
<li><a href='#mscjs'><p>Fitting function for Multistate CJS models</p></a></li>
<li><a href='#mscjs_tmb'><p>Fitting function for Multistate CJS models with TMB</p></a></li>
<li><a href='#msld_tmb'><p>Fitting function for Multistate CJS live-dead models with TMB</p></a></li>
<li><a href='#mstrata'><p>Multistrata example data</p></a></li>
<li><a href='#mvms_design_data'><p>Multivariate Multistate (mvms) Design Data</p></a></li>
<li><a href='#mvms_dmat'><p>HMM Observation Probability matrix functions</p></a></li>
<li><a href='#mvmscjs'><p>Fitting function for Multivariate Multistate CJS with uncertainty models</p></a></li>
<li><a href='#mvmscjs_tmb'><p>TMB version: Fitting function for Multivariate Multistate CJS with uncertainty models</p></a></li>
<li><a href='#omega'><p>Compute 1 to k-step transition proportions</p></a></li>
<li><a href='#Paradise_shelduck'><p>Mulstistate Live-Dead Paradise Shelduck Data</p></a></li>
<li><a href='#Phi.mean'><p>Various utility parameter summary functions</p></a></li>
<li><a href='#predict.crm'><p>Compute estimates of real parameters</p></a></li>
<li><a href='#print.crm'><p>Print model results</p></a></li>
<li><a href='#print.crmlist'><p>Print model table from model list</p></a></li>
<li><a href='#probitCJS'><p>Perform MCMC analysis of a CJS model</p></a></li>
<li><a href='#proc.form'><p>Mixed effect model formula parser</p>
</p>
<p>Parses a mixed effect model in the lme4 structure of  ~fixed +(re1|g1) +...+(ren|gn)</p></a></li>
<li><a href='#process.ch'><p>Process release-recapture history data</p></a></li>
<li><a href='#process.data'><p>Process encounter history dataframe for MARK analysis</p></a></li>
<li><a href='#R_HMMLikelihood'><p>Hidden Markov Model Functions</p></a></li>
<li><a href='#resight.matrix'><p>Various utility functions</p></a></li>
<li><a href='#sealions'><p>Multivariate State example data</p></a></li>
<li><a href='#set_mvms'><p>Multivariate Multistate (mvms) Specification</p></a></li>
<li><a href='#set_scale'><p>Scaling functions</p></a></li>
<li><a href='#set.fixed'><p>Set fixed real parameter values in ddl</p></a></li>
<li><a href='#set.initial'><p>Set initial values</p></a></li>
<li><a href='#setup_admb'><p>ADMB setup</p></a></li>
<li><a href='#setup_tmb'><p>TMB setup</p></a></li>
<li><a href='#setup.model'><p>Defines model specific parameters (internal use)</p></a></li>
<li><a href='#setup.parameters'><p>Setup parameter structure specific to model (internal use)</p></a></li>
<li><a href='#simHMM'><p>Simulates data from Hidden Markov Model</p></a></li>
<li><a href='#skagit'><p>An example of the Mulstistrata (multi-state) model in which states are routes taken by migrating fish.</p></a></li>
<li><a href='#smsld_tmb'><p>Fitting function for Multistate CJS live-dead models with TMB</p></a></li>
<li><a href='#splitCH'><p>Split/collapse capture histories</p></a></li>
<li><a href='#tagloss'><p>Tag loss example</p></a></li>
<li><a href='#valid.parameters'><p>Determine validity of parameters for a model (internal use)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.2.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-13</td>
</tr>
<tr>
<td>Title:</td>
<td>Mark-Recapture Analysis for Survival and Abundance Estimation</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeff Laake &lt;jefflaake@gmail.com&gt;, Devin Johnson
    &lt;devin.johnson@noaa.gov&gt;, Paul Conn &lt;paul.conn@noaa.gov&gt;, example for simHMM
    from Jay Rotella</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeff Laake &lt;jefflaake@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for fitting various models to capture-recapture data
    including mixed-effects Cormack-Jolly-Seber(CJS) and multistate models and
    the multi-variate state model structure for survival
    estimation and POPAN structured Jolly-Seber models for abundance estimation.
    There are also Hidden Markov model (HMM) implementations of CJS and multistate
    models with and without state uncertainty and a simulation capability for HMM
    models.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), lme4, methods, parallel</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, utils, R2admb, truncnorm, coda, Matrix,
numDeriv, expm, Rcpp (&ge; 0.9.13), TMB, optimx (&ge; 2013.8.6),
data.table, knitr, kableExtra, bookdown</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>ADMB version 11 &lt;http://admb-project.org/&gt; for
use.admb=TRUE; see readme.txt</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-19 16:11:56 UTC; jeffl</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-19 17:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='backward_prob'>Computes backward probabilities</h2><span id='topic+backward_prob'></span>

<h3>Description</h3>

<p>Computes backward probability sequence for a set of capture histories
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backward_prob(object, ddl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="backward_prob_+3A_object">object</code></td>
<td>
<p>fitted crm model (must be an HMM model)</p>
</td></tr>
<tr><td><code id="backward_prob_+3A_ddl">ddl</code></td>
<td>
<p>design data list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of backward probabilities (one for each id, state, occasion)
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>References</h3>

<p>Zucchini, W. and I.L. MacDonald. 2009. Hidden Markov Models for Time Series: An Introduction using R. Chapman and Hall, Boca Raton, FL. See page 61.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#

# This example is excluded from testing to reduce package check time
# cormack-jolly-seber model
data(dipper)
mod=crm(dipper,model="hmmcjs")
backward_prob(mod)

</code></pre>

<hr>
<h2 id='cjs_admb'>Fitting function for CJS models</h2><span id='topic+cjs_admb'></span>

<h3>Description</h3>

<p>A function for computing MLEs for a specified Cormack-Jolly-Seber open
population capture-recapture model for processed dataframe <code>x</code> with
user specified formulas in <code>parameters</code> that create list of design
matrices <code>dml</code>. This function can be called directly but is most easily
called from <code><a href="#topic+crm">crm</a></code> that sets up needed arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cjs_admb(
  x,
  ddl,
  dml,
  model_data = NULL,
  parameters,
  accumulate = TRUE,
  initial = NULL,
  method,
  hessian = FALSE,
  debug = FALSE,
  chunk_size = 1e+07,
  refit,
  itnmax = NULL,
  control = NULL,
  scale,
  use.admb = FALSE,
  crossed = TRUE,
  compile = FALSE,
  extra.args = NULL,
  reml,
  clean = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cjs_admb_+3A_x">x</code></td>
<td>
<p>processed dataframe created by process.data</p>
</td></tr>
<tr><td><code id="cjs_admb_+3A_ddl">ddl</code></td>
<td>
<p>list of dataframes for design data; created by call to
<code><a href="#topic+make.design.data">make.design.data</a></code></p>
</td></tr>
<tr><td><code id="cjs_admb_+3A_dml">dml</code></td>
<td>
<p>list of design matrices created by <code><a href="#topic+create.dm">create.dm</a></code> from
formula and design data</p>
</td></tr>
<tr><td><code id="cjs_admb_+3A_model_data">model_data</code></td>
<td>
<p>a list of all the relevant data for fitting the model including
imat, Phi.dm,p.dm,Phi.fixed,p.fixed, and time.intervals. It is used to save values
and avoid accumulation again if the model was re-rerun with an additional call to cjs when
using autoscale or re-starting with initial values.  It is stored with returned model object.</p>
</td></tr>
<tr><td><code id="cjs_admb_+3A_parameters">parameters</code></td>
<td>
<p>equivalent to <code>model.parameters</code> in <code><a href="#topic+crm">crm</a></code></p>
</td></tr>
<tr><td><code id="cjs_admb_+3A_accumulate">accumulate</code></td>
<td>
<p>if TRUE will accumulate capture histories with common
value and with a common design matrix for Phi and p to speed up execution</p>
</td></tr>
<tr><td><code id="cjs_admb_+3A_initial">initial</code></td>
<td>
<p>list of initial values for parameters if desired; if each is a named vector
from previous run it will match to columns with same name</p>
</td></tr>
<tr><td><code id="cjs_admb_+3A_method">method</code></td>
<td>
<p>method to use for optimization; see <code>optim</code></p>
</td></tr>
<tr><td><code id="cjs_admb_+3A_hessian">hessian</code></td>
<td>
<p>if TRUE will compute and return the hessian</p>
</td></tr>
<tr><td><code id="cjs_admb_+3A_debug">debug</code></td>
<td>
<p>if TRUE will print out information for each iteration</p>
</td></tr>
<tr><td><code id="cjs_admb_+3A_chunk_size">chunk_size</code></td>
<td>
<p>specifies amount of memory to use in accumulating capture
histories; amount used is 8*chunk_size/1e6 MB (default 80MB)</p>
</td></tr>
<tr><td><code id="cjs_admb_+3A_refit">refit</code></td>
<td>
<p>non-zero entry to refit</p>
</td></tr>
<tr><td><code id="cjs_admb_+3A_itnmax">itnmax</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="cjs_admb_+3A_control">control</code></td>
<td>
<p>control string for optimization functions</p>
</td></tr>
<tr><td><code id="cjs_admb_+3A_scale">scale</code></td>
<td>
<p>vector of scale values for parameters</p>
</td></tr>
<tr><td><code id="cjs_admb_+3A_use.admb">use.admb</code></td>
<td>
<p>if TRUE creates data file for admbcjs.tpl and runs admb optimizer</p>
</td></tr>
<tr><td><code id="cjs_admb_+3A_crossed">crossed</code></td>
<td>
<p>if TRUE it uses cjs.tpl or cjs_reml.tpl if reml=FALSE or TRUE respectively; if FALSE, then it uses cjsre which can use Gauss-Hermite integration</p>
</td></tr>
<tr><td><code id="cjs_admb_+3A_compile">compile</code></td>
<td>
<p>if TRUE forces re-compilation of tpl file</p>
</td></tr>
<tr><td><code id="cjs_admb_+3A_extra.args">extra.args</code></td>
<td>
<p>optional character string that is passed to admb if use.admb==TRUE</p>
</td></tr>
<tr><td><code id="cjs_admb_+3A_reml">reml</code></td>
<td>
<p>if set to TRUE uses cjs_reml if crossed</p>
</td></tr>
<tr><td><code id="cjs_admb_+3A_clean">clean</code></td>
<td>
<p>if TRUE, deletes the tpl and executable files for amdb if use.admb=T</p>
</td></tr>
<tr><td><code id="cjs_admb_+3A_...">...</code></td>
<td>
<p>any remaining arguments are passed to additional parameters
passed to <code>optim</code> or <code><a href="#topic+cjs.lnl">cjs.lnl</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is easiest to call <code>cjs</code> through the function <code><a href="#topic+crm">crm</a></code>.
Details are explained there.
</p>
<p>Be cautious with this function at present.  It does not include many checks
to make sure values like fixed values will remain in the specified range of
the data.  Normally this would not be a big problem but because
<code><a href="#topic+cjs.lnl">cjs.lnl</a></code> calls an external FORTRAN subroutine, if it gets a
subscript out of bounds, it will cause R to terminate.  So make sure to save
your workspace frequently if you use this function in its current
implementation.
</p>


<h3>Value</h3>

<p>The resulting value of the function is a list with the class of
crm,cjs such that the generic functions print and coef can be used.
Elements are 1) beta: named vector of parameter estimatesm 2) lnl: -2*log
likelihood, 3) AIC: lnl + 2* number of parameters, 4) convergence: result from <code>optim</code>; if 0 <code>optim</code> thinks it
converged, 5) count:<code>optim</code> results of number of function
evaluations, 6) reals: dataframe of data and real Phi and p estimates for
each animal-occasion excluding those that occurred before release, 7) vcv:var-cov matrix of betas if hessian=TRUE was set.
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>References</h3>

<p>Pledger, S., K. H. Pollock, et al. (2003). Open
capture-recapture models with heterogeneity: I. Cormack-Jolly-Seber model.
Biometrics 59(4):786-794.
</p>

<hr>
<h2 id='cjs_delta'>HMM Initial state distribution functions</h2><span id='topic+cjs_delta'></span><span id='topic+mvmscjs_delta'></span>

<h3>Description</h3>

<p>Functions that compute the initial probability distribution for the states. 
Currently only CJS, MS models and MS models with state uncertainty are included and
these all use cjs_delta to assign a known state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cjs_delta(pars, m, F, T, start)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cjs_delta_+3A_pars">pars</code></td>
<td>
<p>list of real parameter matrices (id by occasion) for each type of parameter</p>
</td></tr>
<tr><td><code id="cjs_delta_+3A_m">m</code></td>
<td>
<p>number of states</p>
</td></tr>
<tr><td><code id="cjs_delta_+3A_f">F</code></td>
<td>
<p>initial occasion vector</p>
</td></tr>
<tr><td><code id="cjs_delta_+3A_t">T</code></td>
<td>
<p>number of occasions</p>
</td></tr>
<tr><td><code id="cjs_delta_+3A_start">start</code></td>
<td>
<p>matrix with values that are first occasion and for some CJS type models the state of first observation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2-d array of initial state probability vectors for each id
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>References</h3>

<p>Zucchini, W. and I.L. MacDonald. 2009. Hidden Markov Models for Time Series: An Introduction using R. Chapman and Hall, Boca Raton, FL. 275p.
</p>

<hr>
<h2 id='cjs_gamma'>HMM Transition matrix functions</h2><span id='topic+cjs_gamma'></span><span id='topic+ms_gamma'></span><span id='topic+ms2_gamma'></span>

<h3>Description</h3>

<p>Functions that compute the transition matrix for various models. Currently only CJS and MS models
are included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cjs_gamma(pars, m, F, T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cjs_gamma_+3A_pars">pars</code></td>
<td>
<p>list of real parameter values for each type of parameter</p>
</td></tr>
<tr><td><code id="cjs_gamma_+3A_m">m</code></td>
<td>
<p>number of states</p>
</td></tr>
<tr><td><code id="cjs_gamma_+3A_f">F</code></td>
<td>
<p>initial occasion vector</p>
</td></tr>
<tr><td><code id="cjs_gamma_+3A_t">T</code></td>
<td>
<p>number of occasions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of id and occasion-specific transition matrices - Gamma in Zucchini and MacDonald (2009)
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>References</h3>

<p>Zucchini, W. and I.L. MacDonald. 2009. Hidden Markov Models for Time Series: An Introduction using R. Chapman and Hall, Boca Raton, FL. 275p.
</p>

<hr>
<h2 id='cjs_tmb'>Fitting function for CJS models</h2><span id='topic+cjs_tmb'></span>

<h3>Description</h3>

<p>A function for computing MLEs for a specified Cormack-Jolly-Seber open
population capture-recapture model for processed dataframe <code>x</code> with
user specified formulas in <code>parameters</code> that create list of design
matrices <code>dml</code>. This function can be called directly but is most easily
called from <code><a href="#topic+crm">crm</a></code> that sets up needed arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cjs_tmb(
  x,
  ddl,
  dml,
  model_data = NULL,
  parameters,
  accumulate = TRUE,
  initial = NULL,
  method,
  hessian = FALSE,
  debug = FALSE,
  chunk_size = 1e+07,
  refit,
  itnmax = NULL,
  control = NULL,
  scale,
  crossed = TRUE,
  compile = TRUE,
  extra.args = NULL,
  reml,
  clean = FALSE,
  getreals = FALSE,
  prior = FALSE,
  prior.list = NULL,
  tmbfct = "f1",
  useHess = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cjs_tmb_+3A_x">x</code></td>
<td>
<p>processed dataframe created by process.data</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_ddl">ddl</code></td>
<td>
<p>list of dataframes for design data; created by call to
<code><a href="#topic+make.design.data">make.design.data</a></code></p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_dml">dml</code></td>
<td>
<p>list of design matrices created by <code><a href="#topic+create.dm">create.dm</a></code> from
formula and design data</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_model_data">model_data</code></td>
<td>
<p>a list of all the relevant data for fitting the model including
imat, Phi.dm,p.dm,Phi.fixed,p.fixed, and time.intervals. It is used to save values
and avoid accumulation again if the model was re-rerun with an additional call to cjs when
using autoscale or re-starting with initial values.  It is stored with returned model object.</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_parameters">parameters</code></td>
<td>
<p>equivalent to <code>model.parameters</code> in <code><a href="#topic+crm">crm</a></code></p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_accumulate">accumulate</code></td>
<td>
<p>if TRUE will accumulate capture histories with common
value and with a common design matrix for Phi and p to speed up execution</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_initial">initial</code></td>
<td>
<p>list of initial values for parameters if desired; if each is a named vector
from previous run it will match to columns with same name</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_method">method</code></td>
<td>
<p>method to use for optimization; see <code>optim</code></p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_hessian">hessian</code></td>
<td>
<p>if TRUE will compute and return the hessian</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_debug">debug</code></td>
<td>
<p>if TRUE will print out information for each iteration</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_chunk_size">chunk_size</code></td>
<td>
<p>specifies amount of memory to use in accumulating capture
histories; amount used is 8*chunk_size/1e6 MB (default 80MB)</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_refit">refit</code></td>
<td>
<p>non-zero entry to refit</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_itnmax">itnmax</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_control">control</code></td>
<td>
<p>control string for optimization functions</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_scale">scale</code></td>
<td>
<p>vector of scale values for parameters</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_crossed">crossed</code></td>
<td>
<p>if TRUE it uses cjs.tpl or cjs_reml.tpl if reml=FALSE or TRUE respectively; if FALSE, then it uses cjsre which can use Gauss-Hermite integration</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_compile">compile</code></td>
<td>
<p>if TRUE forces re-compilation of tpl file</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_extra.args">extra.args</code></td>
<td>
<p>optional character string that is passed to admb if use.admb==TRUE</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_reml">reml</code></td>
<td>
<p>if set to TRUE uses cjs_reml if crossed</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_clean">clean</code></td>
<td>
<p>if TRUE, deletes the tpl and executable files for amdb if use.admb=T</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_getreals">getreals</code></td>
<td>
<p>if TRUE, will compute real Phi and p values and std errors</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_prior">prior</code></td>
<td>
<p>if TRUE will expect vectors of prior values in list prior.list</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_prior.list">prior.list</code></td>
<td>
<p>which contains for normal distributions 1) mu_phi_prior: vector of mu values for phi_beta, 2) sigma_phi_prior: vector of sigma values for phi_beta,
3) mu_p_prior: vector of mu values for p_beta, 4) sigma_p_prior: vector of sigma values for p_beta, 5) random_mu_phi_prior: vector of mu values for ln sigma of random effects, 
6) random_sigma_phi_prior: vector of sigma values for ln sigma_phi, 7) random_mu_p_prior: vector of mu values for ln sigma_p, 8) random_sigma_p_prior: vector of sigma values for ln sigma_p.</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_tmbfct">tmbfct</code></td>
<td>
<p>either &quot;f1&quot; - default or &quot;f2&quot; - any random effects treated as fixed effects or &quot;f3&quot; fixed effects fixed at mode and no random effects.</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_usehess">useHess</code></td>
<td>
<p>if TRUE, the TMB hessian function is used for optimization; using hessian is typically slower with many parameters but can result in a better solution</p>
</td></tr>
<tr><td><code id="cjs_tmb_+3A_...">...</code></td>
<td>
<p>any remaining arguments are passed to additional parameters
passed to <code>optim</code> or <code><a href="#topic+cjs.lnl">cjs.lnl</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is easiest to call <code>cjs</code> through the function <code><a href="#topic+crm">crm</a></code>.
Details are explained there.
</p>
<p>Be cautious with this function at present.  It does not include many checks
to make sure values like fixed values will remain in the specified range of
the data.  Normally this would not be a big problem but because
<code><a href="#topic+cjs.lnl">cjs.lnl</a></code> calls an external FORTRAN subroutine, if it gets a
subscript out of bounds, it will cause R to terminate.  So make sure to save
your workspace frequently if you use this function in its current
implementation.
</p>


<h3>Value</h3>

<p>The resulting value of the function is a list with the class of
crm,cjs such that the generic functions print and coef can be used.
Elements are 1) beta: named vector of parameter estimatesm 2) lnl: -2*log
likelihood, 3) AIC: lnl + 2* number of parameters, 4) convergence: result from <code>optim</code>; if 0 <code>optim</code> thinks it
converged, 5) count:<code>optim</code> results of number of function
evaluations, 6) reals: dataframe of data and real Phi and p estimates for
each animal-occasion excluding those that occurred before release, 7) vcv:var-cov matrix of betas if hessian=TRUE was set.
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>References</h3>

<p>Pledger, S., K. H. Pollock, et al. (2003). Open
capture-recapture models with heterogeneity: I. Cormack-Jolly-Seber model.
Biometrics 59(4):786-794.
</p>

<hr>
<h2 id='cjs.accumulate'>Accumulates common capture history values</h2><span id='topic+cjs.accumulate'></span>

<h3>Description</h3>

<p>To speed up compuation, animals with the same capture history and design matrix are
accumulated and represented by a frequency. Computes starting values for Phi and p parameters from the
list of design matrices and the summarized data list including ch matrix and
first and last vectors. If any values are missing (NA) or abs(par)&gt;5, they are
set to 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cjs.accumulate(x, model_data, nocc, freq, chunk_size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cjs.accumulate_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="cjs.accumulate_+3A_model_data">model_data</code></td>
<td>
<p>list of design matrices, fixed parameters and time intervals all which can vary by animal</p>
</td></tr>
<tr><td><code id="cjs.accumulate_+3A_nocc">nocc</code></td>
<td>
<p>number of capture occasions</p>
</td></tr>
<tr><td><code id="cjs.accumulate_+3A_freq">freq</code></td>
<td>
<p>frequency of each capture history before accumulation</p>
</td></tr>
<tr><td><code id="cjs.accumulate_+3A_chunk_size">chunk_size</code></td>
<td>
<p>size that determines number of pieces of data/design matrix that are handled. Smaller chunk_size requires more
time but less memory. 1e7 is default set in cjs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modified model_data list that is accumulated
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>

<hr>
<h2 id='cjs.hessian'>Compute variance-covariance matrix for fitted CJS model</h2><span id='topic+cjs.hessian'></span>

<h3>Description</h3>

<p>A wrapper function that sets up call to hessian function to compute and then
invert the hessian.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cjs.hessian(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cjs.hessian_+3A_model">model</code></td>
<td>
<p>fitted CJS model from function crm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>variance-covariance matrix for specified model or the model
object with the stored vcv depending on whether the model has already been run
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>

<hr>
<h2 id='cjs.initial'>Computes starting values for CJS p and Phi parameters</h2><span id='topic+cjs.initial'></span>

<h3>Description</h3>

<p>Computes starting values for Phi and p parameters from the
list of design matrices and the summarized data list including ch matrix and
first and last vectors. If any values are missing (NA) or abs(par)&gt;5, they are
set to 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cjs.initial(dml, imat, link = "logit")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cjs.initial_+3A_dml">dml</code></td>
<td>
<p>design matrix list for Phi and p</p>
</td></tr>
<tr><td><code id="cjs.initial_+3A_imat">imat</code></td>
<td>
<p>list containing chmat, first and last</p>
</td></tr>
<tr><td><code id="cjs.initial_+3A_link">link</code></td>
<td>
<p>either &quot;logit&quot; (for cjs) or &quot;probit&quot; (for probitCJS)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of initial parameter estimates
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>

<hr>
<h2 id='cjs.lnl'>Likelihood function for Cormack-Jolly-Seber model</h2><span id='topic+cjs.lnl'></span>

<h3>Description</h3>

<p>For a given set of parameters and data, it computes -log Likelihood value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cjs.lnl(
  par,
  model_data,
  Phi.links = NULL,
  p.links = NULL,
  debug = FALSE,
  all = FALSE,
  cjsenv
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cjs.lnl_+3A_par">par</code></td>
<td>
<p>vector of parameter values</p>
</td></tr>
<tr><td><code id="cjs.lnl_+3A_model_data">model_data</code></td>
<td>
<p>a list that contains: 1)imat-list of vectors and matrices constructed by
<code><a href="#topic+process.ch">process.ch</a></code> from the capture history data, 2)Phi.dm design matrix for Phi constructed by <code><a href="#topic+create.dm">create.dm</a></code>,
3)p.dm design matrix for p constructed by <code><a href="#topic+create.dm">create.dm</a></code>,
4)Phi.fixed matrix with 3 columns: ch number(i), occasion number(j),
fixed value(f) to fix phi(i,j)=f, 5)p.fixed matrix with 3 columns: ch number(i), occasion number(j), and
6) time.intervals intervals of time between occasions if not all 1
fixed value(f) to fix p(i,j)=f</p>
</td></tr>
<tr><td><code id="cjs.lnl_+3A_phi.links">Phi.links</code></td>
<td>
<p>vector of links for each parameter</p>
</td></tr>
<tr><td><code id="cjs.lnl_+3A_p.links">p.links</code></td>
<td>
<p>vector of links for each parameter</p>
</td></tr>
<tr><td><code id="cjs.lnl_+3A_debug">debug</code></td>
<td>
<p>if TRUE will printout values of <code>par</code> and function value</p>
</td></tr>
<tr><td><code id="cjs.lnl_+3A_all">all</code></td>
<td>
<p>if TRUE, returns entire list rather than just lnl; can be used to
extract reals</p>
</td></tr>
<tr><td><code id="cjs.lnl_+3A_cjsenv">cjsenv</code></td>
<td>
<p>environment for cjs to update iteration counter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses a FORTRAN subroutine (cjs.f) to speed up computation of the likelihood but the
result can also be obtained wholly in R with a small loss in precision. See R code below.
The R and FORTRAN code uses the likelihood formulation of Pledger et al.(2003).
</p>
<pre>
get.p=function(beta,dm,nocc,Fplus) 
{
# compute p matrix from parameters (beta) and list of design matrices (dm) 
# created by function create.dm
  ps=cbind(rep(1,nrow(dm)/(nocc-1)),
     matrix(dm
  ps[Fplus==1]=plogis(ps[Fplus==1]) 
  return(ps) 
}
get.Phi=function(beta,dm,nocc,Fplus) 
{
# compute Phi matrix from parameters (beta) and list of design matrices (dm)
# created by function create.dm 
  Phis=cbind(rep(1,nrow(dm)/(nocc-1)),
     matrix(dm
  Phis[Fplus==1]=plogis(Phis[Fplus==1]) 
  return(Phis) 
}
#################################################################################
# cjs.lnl - computes likelihood for CJS using Pledger et al (2003)
# formulation for the likelihood. This code does not cope with fixed parameters or 
# loss on capture but could be modified to do so. Also, to work directly with cjs.r and
# cjs.accumulate call to process.ch would have to have all=TRUE to get Fplus and L.
# Arguments: 
# par             - vector of beta parameters 
# imat           - list of freq, indicator vector and matrices for ch data created by process.ch 
# Phi.dm         - list of design matrices; a dm for each capture history 
# p.dm           - list of design matrices; a dm for each capture history 
# debug          - if TRUE show iterations with par and -2lnl 
# time.intervals - intervals of time between occasions 
# Value: -LnL using
#################################################################################
cjs.lnl=function(par,model_data,Phi.links=NULL,p.links=NULL,debug=FALSE,all=FALSE) {
if(debug)cat("\npar = ",par)
#extract Phi and p parameters from par vector 
nphi=ncol(model_data$Phi.dm)
np=ncol(model_data$p.dm) 
beta.phi=par[1:nphi]
beta.p=par[(nphi+1):(nphi+np)] 
#construct parameter matrices (1 row for each capture history and a column 
 #for each occasion)
Phis=get.Phi(beta.phi,model_data$Phi.dm,nocc=ncol(model_data$imat$chmat),
                          model_data$imat$Fplus)
if(!is.null(model_data$time.intervals)) 
{
	exponent=cbind(rep(1,nrow(Phis)),model_data$time.intervals)
	Phis=Phis^exponent 
} 
ps=get.p(beta.p,model_data$p.dm,nocc=ncol(model_data$imat$chmat),
           model_data$imat$Fplus)
if(debug)cat("\npar = ",par)
# Compute probability of dying in interval from Phis
M=cbind((1-Phis)[,-1],rep(1,nrow(Phis)))
# compute cummulative survival from release across each subsequent time
# and the cummulative probability for detection (capture) across each time
Phi.cumprod=1-model_data$imat$Fplus + Phis*model_data$imat$Fplus 
cump=(1-model_data$imat$Fplus)+model_data$imat$Fplus*
         (model_data$imat$chmat*ps+(1-model_data$imat$chmat)*(1-ps))
for (i in 2:ncol(cump))
{
	Phi.cumprod[,i]=Phi.cumprod[,i-1]*Phi.cumprod[,i] 
	cump[,i]=cump[,i-1]*cump[,i] 
}
# compute prob of capture-history
pch=rowSums(model_data$imat$L*M*Phi.cumprod*cump)
lnl=-sum(model_data$imat$freq*log(pch))
if(debug)cat("\n-2lnl = ",2*lnl) 
return(lnl) 
} 
</pre>


<h3>Value</h3>

<p>either -log likelihood value if <code>all=FALSE</code> or the entire
list contents of the call to the FORTRAN subroutine if <code>all=TRUE</code>. The
latter is used from <code><a href="#topic+cjs_admb">cjs_admb</a></code> after optimization to extract the real
parameter estimates at the final beta values.
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>References</h3>

<p>Pledger, S., K. H. Pollock, et al. (2003). Open
capture-recapture models with heterogeneity: I. Cormack-Jolly-Seber model.
Biometrics 59(4):786-794.
</p>

<hr>
<h2 id='coef.crm'>Extract coefficients</h2><span id='topic+coef.crm'></span>

<h3>Description</h3>

<p>Extracts the beta coefficients from the model results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crm'
coef(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.crm_+3A_object">object</code></td>
<td>
<p>crm model result</p>
</td></tr>
<tr><td><code id="coef.crm_+3A_...">...</code></td>
<td>
<p>generic arguments not used here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a dataframe with estimates and standard
errors and confidence intervals if hessian=TRUE on model run.
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crm">crm</a></code>
</p>

<hr>
<h2 id='compute_matrices'>Compute HMM matrices</h2><span id='topic+compute_matrices'></span>

<h3>Description</h3>

<p>Computes gamma, dmat and delta (initial) matrices(arrays) and returns them in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_matrices(object, ddl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_matrices_+3A_object">object</code></td>
<td>
<p>fitted crm model (must be an HMM model)</p>
</td></tr>
<tr><td><code id="compute_matrices_+3A_ddl">ddl</code></td>
<td>
<p>design data list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with gamma, dmat and delta arrays
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>

<hr>
<h2 id='compute_real'>Compute estimates of real parameters</h2><span id='topic+compute_real'></span>

<h3>Description</h3>

<p>Computes real estimates and their var-cov for a particular parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_real(
  model,
  parameter,
  ddl = NULL,
  dml = NULL,
  unique = TRUE,
  vcv = FALSE,
  se = FALSE,
  chat = 1,
  subset = NULL,
  select = NULL,
  showDesign = FALSE,
  include = NULL,
  uselink = FALSE,
  merge = FALSE,
  unit_scale = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_real_+3A_model">model</code></td>
<td>
<p>model object</p>
</td></tr>
<tr><td><code id="compute_real_+3A_parameter">parameter</code></td>
<td>
<p>name of real parameter to be computed (eg &quot;Phi&quot; or &quot;p&quot;)</p>
</td></tr>
<tr><td><code id="compute_real_+3A_ddl">ddl</code></td>
<td>
<p>list of design data</p>
</td></tr>
<tr><td><code id="compute_real_+3A_dml">dml</code></td>
<td>
<p>design matrix list</p>
</td></tr>
<tr><td><code id="compute_real_+3A_unique">unique</code></td>
<td>
<p>TRUE if only unique values should be returned unless non-NULL subset is specified</p>
</td></tr>
<tr><td><code id="compute_real_+3A_vcv">vcv</code></td>
<td>
<p>logical; if TRUE, computes and returns v-c matrix of real estimates</p>
</td></tr>
<tr><td><code id="compute_real_+3A_se">se</code></td>
<td>
<p>logical; if TRUE, computes std errors and conf itervals of real estimates</p>
</td></tr>
<tr><td><code id="compute_real_+3A_chat">chat</code></td>
<td>
<p>over-dispersion value</p>
</td></tr>
<tr><td><code id="compute_real_+3A_subset">subset</code></td>
<td>
<p>logical expression using fields in real dataframe; if used gives all estimates which ignores unique=TRUE</p>
</td></tr>
<tr><td><code id="compute_real_+3A_select">select</code></td>
<td>
<p>character vector of field names in real that you want to include</p>
</td></tr>
<tr><td><code id="compute_real_+3A_showdesign">showDesign</code></td>
<td>
<p>if TRUE, show design matrix instead of data</p>
</td></tr>
<tr><td><code id="compute_real_+3A_include">include</code></td>
<td>
<p>vector of field names always to be included even when select or unique specified</p>
</td></tr>
<tr><td><code id="compute_real_+3A_uselink">uselink</code></td>
<td>
<p>default FALSE; if TRUE uses link values in evaluating uniqueness</p>
</td></tr>
<tr><td><code id="compute_real_+3A_merge">merge</code></td>
<td>
<p>default FALSE but if TRUE, the ddl for the parameter is merged (cbind) to the estimates but only if unique=FALSE</p>
</td></tr>
<tr><td><code id="compute_real_+3A_unit_scale">unit_scale</code></td>
<td>
<p>default TRUE, if FALSE any time scaled parameter (e.g. Phi,S) is scaled when computing real value such that it represents the length of the interval rather than a unit interval</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This code is complicated because it handles both the MCMC models and the likelihood models. The former is quite 
simple than the latter because all of the real computation is done by the model code and this function only computes 
summaries.  The likelihood model code is complicated primarily by the mlogit parameters which are computed in 2 stages:
1) log link and 2) summation to normalize. The mlogit is handled differently depending on the model.
For MS and JS models, one of the parameters is computed by subtraction (specified as addone==TRUE) whereas the
HMM models (addone=FALSE) specify a parameter for each cell and one is fixed by the user to 1. The latter is preferable
because it then provides an estimate and a std error for each parameter whereas the subtracted value is not provided for MS and JS.  
</p>
<p>This function differs from compute.real in RMark because it only computes the values for a single parameter whereas the function 
with the same name in RMark can compute estimates from multiple parameters (eg Phi and p).
</p>


<h3>Value</h3>

<p>A data frame (<code>real</code>) is returned if <code>vcv=FALSE</code>;
otherwise, a list is returned also containing vcv.real: </p>
<table role = "presentation">
<tr><td><code>real</code></td>
<td>
<p> data
frame containing estimates, and if vcv=TRUE it also contains
standard errors and confidence intervals</p>
</td></tr> <tr><td><code>vcv.real</code></td>
<td>
<p>variance-covariance matrix of
real estimates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dipper)
dipper.proc=process.data(dipper,model="cjs",begin.time=1)
dipper.ddl=make.design.data(dipper.proc)
mod.Phisex.pdot=crm(dipper.proc,dipper.ddl,
 model.parameters=list(Phi=list(formula=~sex+time),p=list(formula=~1)),hessian=TRUE)
xx=compute_real(mod.Phisex.pdot,"Phi",unique=TRUE,vcv=TRUE)
</code></pre>

<hr>
<h2 id='convert.link.to.real'>Convert link values to real parameters</h2><span id='topic+convert.link.to.real'></span>

<h3>Description</h3>

<p>Computes real parameters from link values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert.link.to.real(x, model = NULL, links = NULL, fixed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert.link.to.real_+3A_x">x</code></td>
<td>
<p>Link values to be converted to real parameters</p>
</td></tr>
<tr><td><code id="convert.link.to.real_+3A_model">model</code></td>
<td>
<p>model object</p>
</td></tr>
<tr><td><code id="convert.link.to.real_+3A_links">links</code></td>
<td>
<p>vector of character strings specifying links to use in
computation of reals</p>
</td></tr>
<tr><td><code id="convert.link.to.real_+3A_fixed">fixed</code></td>
<td>
<p>vector of fixed values for real parameters that are needed for
calculation of reals from mlogits when some are fixed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computation of the real parameter from the link value is relatively
straightforward for most links and the function <code><a href="#topic+inverse.link">inverse.link</a></code>
is used.  The only exception is parameters that use the <code>mlogit</code> link
which requires the transformation across sets of parameters.  This is a
convenience function that does the necessary work to convert from link to
real for any set of parameters.  The appropriate links are obtained from
<code>model$links</code> unless the argument <code>links</code> is specified and they
will over-ride those in <code>model</code>.
</p>


<h3>Value</h3>

<p>vector of real parameter values
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inverse.link">inverse.link</a></code>,<code><a href="#topic+compute_real">compute_real</a></code>
</p>

<hr>
<h2 id='create.dm'>Creates a design matrix for a parameter</h2><span id='topic+create.dm'></span><span id='topic+create.dml'></span>

<h3>Description</h3>

<p>Creates a design matrix using the design dataframe, a formula and any
intervals defined for time, cohort and age.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.dm(x, formula, time.bins=NULL, cohort.bins=NULL, age.bins=NULL, 
                  chunk_size=1e7, remove.intercept=NULL,remove.unused.columns=TRUE)
       
       create.dml(ddl,model.parameters,design.parameters,restrict=FALSE,
             chunk_size=1e7,use.admb=FALSE,remove.unused.columns=TRUE,simplify=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.dm_+3A_x">x</code></td>
<td>
<p>design dataframe created by <code><a href="#topic+create.dmdf">create.dmdf</a></code></p>
</td></tr>
<tr><td><code id="create.dm_+3A_formula">formula</code></td>
<td>
<p>formula for model in R format</p>
</td></tr>
<tr><td><code id="create.dm_+3A_time.bins">time.bins</code></td>
<td>
<p>any bins of time to collapse values</p>
</td></tr>
<tr><td><code id="create.dm_+3A_cohort.bins">cohort.bins</code></td>
<td>
<p>any bins of cohort to collapse values</p>
</td></tr>
<tr><td><code id="create.dm_+3A_age.bins">age.bins</code></td>
<td>
<p>any bins of cohort to collapse values</p>
</td></tr>
<tr><td><code id="create.dm_+3A_chunk_size">chunk_size</code></td>
<td>
<p>specifies amount of memory to use in creating design
matrices; amount used is 8*chunk_size/1e6 MB (default 80MB)</p>
</td></tr>
<tr><td><code id="create.dm_+3A_remove.intercept">remove.intercept</code></td>
<td>
<p>if TRUE, forces removal of intercept in design
matrix</p>
</td></tr>
<tr><td><code id="create.dm_+3A_remove.unused.columns">remove.unused.columns</code></td>
<td>
<p>if TRUE, unused columns are removed; otherwise they are left</p>
</td></tr>
<tr><td><code id="create.dm_+3A_ddl">ddl</code></td>
<td>
<p>Design data list which contains a list element for each parameter
type; if NULL it is created</p>
</td></tr>
<tr><td><code id="create.dm_+3A_design.parameters">design.parameters</code></td>
<td>
<p>Specification of any grouping variables for design
data for each parameter</p>
</td></tr>
<tr><td><code id="create.dm_+3A_model.parameters">model.parameters</code></td>
<td>
<p>List of model parameter specifications</p>
</td></tr>
<tr><td><code id="create.dm_+3A_restrict">restrict</code></td>
<td>
<p>if TRUE, only use design data with Time &gt;= Cohort</p>
</td></tr>
<tr><td><code id="create.dm_+3A_use.admb">use.admb</code></td>
<td>
<p>if TRUE uses mixed.model.admb for random effects; otherwise mixed.model</p>
</td></tr>
<tr><td><code id="create.dm_+3A_simplify">simplify</code></td>
<td>
<p>if TRUE simplies real parameter structure for some models; at this time it is not more efficient so ignore</p>
</td></tr>
</table>


<h3>Value</h3>

<p>create.dm returns a fixed effect design matrix constructed with the design dataframe and the
formula for a single parametre.  It excludes any columns that are all 0. create.dml returns a list with an element for
for each parameter with a sub-list for the fixed effect (fe) and random effects. The re structure depends
on switch use.admb. When TRUE, it contains a single design matrix (re.dm) and indices for random effects (re.indices).
When FALSE, it returns re.list which is a list with an element for each random component containing re.dm and indices for
that random effect (eg (1|id) + (1|time) would produce elements for id and time.
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>

<hr>
<h2 id='create.dmdf'>Creates a dataframe with all the design data for a particular parameter in a
crm model</h2><span id='topic+create.dmdf'></span>

<h3>Description</h3>

<p>Creates a dataframe with all the design data for a particular parameter in a
crm model which currently includes &quot;cjs&quot; or &quot;js&quot;.  These design data are
fundamentally different than the design data created for <code>mark</code> models
as explained below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.dmdf(x, parameter, time.varying = NULL, fields = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.dmdf_+3A_x">x</code></td>
<td>
<p>processed dataframe from function <code><a href="#topic+process.data">process.data</a></code></p>
</td></tr>
<tr><td><code id="create.dmdf_+3A_parameter">parameter</code></td>
<td>
<p>list with fields defining each values for each parameter;
as created by <code><a href="#topic+setup.parameters">setup.parameters</a></code></p>
</td></tr>
<tr><td><code id="create.dmdf_+3A_time.varying">time.varying</code></td>
<td>
<p>vector of field names that are time-varying for this
parameter</p>
</td></tr>
<tr><td><code id="create.dmdf_+3A_fields">fields</code></td>
<td>
<p>character vector containing field names for variables in x to
be included in design matrix dataframe; if NULL all other than ch are
included</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to be called from <code><a href="#topic+make.design.data">make.design.data</a></code>.
It takes the data in <code>x</code> and creates a dataframe with all of the data
needed to fit capture-recapture models (crm) which currently includes &quot;cjs&quot;
(Cormack-Jolly-Seber) or &quot;js&quot; (POPAN formulation of the Jolly-Seber model).
Before jumping into the details it is useful to have an understanding of the
differences between MARK (via the <code>mark in RMark</code> function) and the
package <code>mra</code> written by Trent McDonald and how they relate to the
implementation in <code><a href="#topic+cjs_admb">cjs_admb</a></code>.  With MARK, animals can be placed in
groups and the parameters for the model specified via PIMs (parameter
index matrices) link the parameters to the specific animals.  For
example, if for a particular group the <code>Phi</code> PIM is
</p>
<pre> 
  1 2 3 
    4 5 
      6 
</pre>
<p>Then animals in that group that were first caught/released on occasion 1
have the parameters 1,2,3 for the 3 occasions.  Those first caught/released
on occasion 2 have parameters 4 and 5 for occasions 2 and 3 and those first
caught/released on occasion 3 have parameter 6 for occasion 3.  Another
group of animals would have a different set of indices for the same set of
parameters so they could be discriminated.  Many people find this rather
confusing until they get used to it but even then if you have many different
groups and many occasions, then the indexing process is prone to error.
Thus, the rationale for RMark which automates the PIM construction and its
use is largely transparent to the user. What RMark does is to create a data
structure called design data that automatically assigns <code>design data</code>
to the indices in the PIM.  For example, 1 to 6 would be given the data used
to create that group and 1 to 3 would be assigned to cohort 1, ... and 1
would be assigned to occasion 1 and 2 and 4 would be assigned to occasion 2
etc.  It also creates an age field which follows the diagonals and can be
initialized with the intial age at the time of first capture which is group
specific.  With a formula and these design data a design matrix can be
constructed for the model where the row in the design matrix is the
parameter index (e.g., the first 6 rows would be for parameters 1 to 6 as
shown above).  That would be all good except for individual covariates which
are not group-specific.  MARK handles individual covariates by specifying
the covariate name (eg &quot;weight&quot;) as a string in the design matrix.  Then for
each capture history in plugs in the actual covariate values for that animal
to complete the design matrix for that animal. For more details see Laake
and Rexstad (2008).
</p>
<p>From a brief look at package <code>mra</code> and personal communication with
Trent McDonald, I give the following brief and possibly incorrect
description of the pacakge <code>mra</code> at the time of writing (28 Aug 2008).
In that package, the whole concept of PIMS is abandoned and instead
covariates are constructed for each occasion for each animal.  Thus, each
animal is effectively put in its own group and it has a parameter for each
occasion.  This novel approach is quite effective at blurring the lines
between design data and individual covariate data and it removes the needs
for PIMS because each animal (or unique capture history) has a real
parameter for each occasion.  The downside of the pacakge <code>mra</code> is that
every covariate is assumed to be time-varying and any factor variables like
<code>time</code> are coded manually as dummy variables for each level rather than
using the R facilities for handling factor variables in the formula to
create the design matrix.
</p>
<p>In the <code>crm,cjs_admb,js</code> functions in this package I have used basic idea in
<code>mra</code> but I have taken a different approach to model development that
allows for time-varying covariates but does not restrict each covariate to
be time-varying and factor variables are used as such which removes the need
to construct dummy variables; although the latter could still be used. First
an example is in order to explain how this all works. Consider the follwing
set of capture histories for small capture-recapture data set with 4 capture
occasions:
</p>
<pre> 1001 0111 0011 </pre>
<p>To relate the current structure to the concept of PIMS I define the
following matrix
</p>
<pre>

 1 2 3 
 4 5 6 
 7 8 9 
</pre>
<p>If you think of these as <code>Phi</code> parameter indices, then 1 to 3 are
survivals for the intervals 1-2,2-3,3-4 for animal 1, and 4-6 and 7-9 are
the same for animals 2 and 3.  This matrix would have a row for each animal.
Now you'll notice that for animal 2 parameter 4 is not needed and for animal
3, parameters 7 and 8 are not needed because they are prior to their entry
in the study.  While that is certainly true there is no harm in having them
and the advantage comes in being able to have a complete matrix in R rather
than having a triangular one.
</p>
<p>So now we are finally getting to the description of what this function does.
It constructs a dataframe with a row for each animal-occasion.  Following on
with the example above, depending on how the arguments are set the following
dataframe could be constructed:
</p>
<pre> 
              row time Time cohort Cohort age Age initial.age 
                1    1    0     1     0     0     0    0
                2    2    1     1     0     1     1    0 
                3    3    2     1     0     2     2    0 
                4    1    0     2     1     0     0    0 
                5    2    1     2     1     1     1    0 
                6    3    2     2     1     2     2    0 
                7    1    0     3     2     0     0    0
                8    2    1     3     2     1     1    0 
                9    3    2     3     2     2     2    0 
</pre>
<p>The fields starting with a lowercase character (time,cohort,age) are created
as factor variables and those with an uppercase are created as numeric
variables.  Note: the <code>age</code> field is bounded below by the minimum
<code>initial.age</code> to avoid creating factor levels with non-existent data
for occasions prior to first capture that are not used. For example, an
animal first caught on occasion 2 with an <code>initial.age=0</code> is
technically -1 on occasion 1 with a <code>time.interval</code> of 1. However, that
parameter would never be used in the model and we don't want a factor level
of -1.
</p>
<p>A formula of ~time would create a design matrix with 3 columns (one for each
factor level) and ~Time would create one with 2 columns with the first being
an intercept and the second with the numeric value of Time.
</p>
<p>Now here is the simplicity of it.  The following few expressions in R will
convert this dataframe into a matrix of real parameters (assuming
<code>beta=c(1,1,1)</code> that are structured like the square PIM matrix without
the use of PIMs.
</p>
<pre> 
nocc=4
x=data.frame(ch=c("1001","0111","0011"),stringsAsFactors=FALSE)
beta=c(1,1,1) 
x.proc=process.data(x,model="cjs")
Phi.dmdf=make.design.data(x.proc)$Phi 
Phi.dm=create.dm(Phi.dmdf,~time)
Phimat=matrix(plogis(Phi.dm
</pre>
<p>Note that the order of the columns for <code>Phi.dmdf</code> differs slightly from
what is shown above. Also, <code>plogis</code> is an R function that computes the
inverse-logit. Once you have the matrix of <code>Phi</code> and <code>p</code> values
the calculation of the likelihood is straightforward using the formulation
of Pledger et al. (2003) (see <code><a href="#topic+cjs.lnl">cjs.lnl</a></code>). The values in the
design dataframe are not limited to these fields.  The 2 arguments
<code>time.varying</code> and <code>fields</code> are vectors of character strings which
specify the names of the dataframe columns in <code>x</code> that should be
included. For example if <code>x</code> contained a field <code>sex</code> with the
values &quot;M&quot;,&quot;F&quot;,&quot;M&quot; for the 3 records in our example, and the argument
<code>fields=c("sex")</code> was used then a column named <code>sex</code> would be
included in design dataframe with the values
&quot;M&quot;,&quot;M&quot;,&quot;M&quot;,&quot;F&quot;,&quot;F&quot;,&quot;F&quot;,&quot;M&quot;,&quot;M&quot;,&quot;M&quot;.  The value of the column <code>sex</code> in
<code>x</code> is repeated for each of the occasions for that animal(capture
history). Now if the value of the field changes for each occasion then we
use the argument <code>time.varying</code> instead.  To differentiate the values
in the dataframe <code>x</code> the columns are named with an occasion number.
For example, if the variable was named <code>cov</code> and it was to be used for
<code>Phi</code>, then the variables would be named <code>cov1,cov2,cov3</code> in
<code>x</code>. Let's say that x was structured as follows:
</p>
<pre> 
ch   cov1 cov2 cov3 
1001   1   0     1 
0111   0   2     1 
0011   0   0     0 
</pre>
<p>If you specified the argument <code>time.varying=c("cov")</code> then in the
design dataframe a field named <code>cov</code> would be created and the values
would be <code>1,0,1,0,2,1,0,0,0</code>. Thus the value is both animal and
occasion specific.  Had the covariate been used for <code>p</code> then they would
be named <code>cov2,cov3,cov4</code> because the covariate is for those occasions
for <code>p</code> whereas for <code>Phi</code> the covariate is labelled with the
occasion that begins the interval.  Any number of fields can be specified in <code>fields</code> and
<code>time.varying</code> that are specified in <code>x</code>.
</p>
<p>The input dataframe <code>x</code> has a few minor requirements on its structure.
First, it must contain a field called <code>ch</code> which contains the
capture-history as a string.  Note that in general strings are converted to
factor variables by default when they are put into a dataframe but as shown
above that can be controlled by the argument <code>stringsAsFactors=FALSE</code>.
The capture history should be composed only of 0 or 1 and they should all be
the same length (at present no error checking on this). Although it is not
necessary, the dataframe can contain a field named <code>freq</code> which
specifies the frequency of that capture history.  If the value of
<code>freq</code> is negative then these are treated as loss on capture at the
final capture occasion (last 1).  If <code>freq</code> is missing then a value of
1 is assumed for all records.  Another optional field is <code>initial.age</code>
which specifies the age of the animal at the time it was first captured.
This field is used to construct the <code>age</code> and <code>Age</code> fields in the
design dataframe.  The default is to assume <code>initial.age=0</code> which means
the <code>age</code> is really time since first marked.  Any other fields in
<code>x</code> are user-specified and can be a combination of factor and numeric
variables that are either time-invariant or time-varying (and named
appropriately).
</p>
<p>The behavior of create.dmdf can vary depending on the values of begin.time and 
time.intervals. An explanation of these values and how they can be used is given 
in <code><a href="#topic+process.data">process.data</a></code>.
</p>


<h3>Value</h3>

<p>A dataframe with all of the individual covariate data and the
standard design data of time, Time, cohort, Cohort, age and Age; where
lowercase first letter implies a factor and uppercase is a numeric variable
for those variables.
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>References</h3>

<p>Laake, J. and E. Rexstad (2007). RMark &ndash; an alternative
approach to building linear models in MARK. Program MARK: A Gentle
Introduction. E. Cooch and G. C. White.
</p>
<p>Pledger, S., K. H. Pollock, et al. (2003). Open capture-recapture models
with heterogeneity: I. Cormack-Jolly-Seber model. Biometrics 59(4):786-794.
</p>

<hr>
<h2 id='create.fixed.matrix'>Create parameters with fixed matrix</h2><span id='topic+create.fixed.matrix'></span>

<h3>Description</h3>

<p>Creates fixed matrix in parameters from ddl$fix values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.fixed.matrix(ddl, parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.fixed.matrix_+3A_ddl">ddl</code></td>
<td>
<p>design data list</p>
</td></tr>
<tr><td><code id="create.fixed.matrix_+3A_parameters">parameters</code></td>
<td>
<p>parameter specififcation list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>parameters with fixed matrix set
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>

<hr>
<h2 id='create.links'>Creates a 0/1 vector for real parameters with sin link</h2><span id='topic+create.links'></span>

<h3>Description</h3>

<p>For each row in a given design matrix it assigns a value 1, if the columns
used in the design matrix are only used as an identity matrix (only one 1
and remaining columns all 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.links(dm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.links_+3A_dm">dm</code></td>
<td>
<p>design matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length=nrow(dm) with value of 0 except for rows that can
accommodate a sin link (identity design matrix).  This function is not
currently used because it has not been thoroughly tested.
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>

<hr>
<h2 id='crm'>Capture-recapture model fitting function</h2><span id='topic+crm'></span>

<h3>Description</h3>

<p>Fits user specified models to some types of capture-recapture wholly in R
and not with MARK.  A single function that processes data, creates the
design data, makes the crm model and runs it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crm(
  data,
  ddl = NULL,
  begin.time = 1,
  model = "CJS",
  title = "",
  model.parameters = list(),
  design.parameters = list(),
  initial = NULL,
  groups = NULL,
  time.intervals = NULL,
  debug = FALSE,
  method = NULL,
  hessian = FALSE,
  accumulate = TRUE,
  chunk_size = 1e+07,
  control = list(),
  refit = 1,
  itnmax = 5000,
  scale = NULL,
  run = TRUE,
  burnin = 100,
  iter = 1000,
  use.admb = FALSE,
  use.tmb = FALSE,
  crossed = NULL,
  reml = FALSE,
  compile = FALSE,
  extra.args = NULL,
  strata.labels = NULL,
  clean = NULL,
  save.matrices = FALSE,
  simplify = FALSE,
  getreals = FALSE,
  real.ids = NULL,
  check = FALSE,
  prior = FALSE,
  prior.list = NULL,
  useHess = FALSE,
  optimize = TRUE,
  unit_scale = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crm_+3A_data">data</code></td>
<td>
<p>Either the raw data which is a dataframe with at least one
column named ch (a character field containing the capture history) or a
processed dataframe</p>
</td></tr>
<tr><td><code id="crm_+3A_ddl">ddl</code></td>
<td>
<p>Design data list which contains a list element for each parameter
type; if NULL it is created</p>
</td></tr>
<tr><td><code id="crm_+3A_begin.time">begin.time</code></td>
<td>
<p>Time of first capture(release) occasion</p>
</td></tr>
<tr><td><code id="crm_+3A_model">model</code></td>
<td>
<p>Type of c-r model (eg, &quot;cjs&quot;, &quot;js&quot;)</p>
</td></tr>
<tr><td><code id="crm_+3A_title">title</code></td>
<td>
<p>Optional title; not used at present</p>
</td></tr>
<tr><td><code id="crm_+3A_model.parameters">model.parameters</code></td>
<td>
<p>List of model parameter specifications</p>
</td></tr>
<tr><td><code id="crm_+3A_design.parameters">design.parameters</code></td>
<td>
<p>Specification of any grouping variables for design
data for each parameter</p>
</td></tr>
<tr><td><code id="crm_+3A_initial">initial</code></td>
<td>
<p>Optional list of named vectors of initial values for beta parameters or a previously
run model</p>
</td></tr>
<tr><td><code id="crm_+3A_groups">groups</code></td>
<td>
<p>Vector of names factor variables for creating groups</p>
</td></tr>
<tr><td><code id="crm_+3A_time.intervals">time.intervals</code></td>
<td>
<p>Intervals of time between the capture occasions</p>
</td></tr>
<tr><td><code id="crm_+3A_debug">debug</code></td>
<td>
<p>if TRUE, shows optimization output</p>
</td></tr>
<tr><td><code id="crm_+3A_method">method</code></td>
<td>
<p>optimization method</p>
</td></tr>
<tr><td><code id="crm_+3A_hessian">hessian</code></td>
<td>
<p>if TRUE, computes v-c matrix using hessian</p>
</td></tr>
<tr><td><code id="crm_+3A_accumulate">accumulate</code></td>
<td>
<p>if TRUE, like capture-histories are accumulated to reduce
computation</p>
</td></tr>
<tr><td><code id="crm_+3A_chunk_size">chunk_size</code></td>
<td>
<p>specifies amount of memory to use in accumulating capture
histories and design matrices; amount used is 8*chunk_size/1e6 MB (default
80MB)</p>
</td></tr>
<tr><td><code id="crm_+3A_control">control</code></td>
<td>
<p>control string for optimization functions</p>
</td></tr>
<tr><td><code id="crm_+3A_refit">refit</code></td>
<td>
<p>non-zero entry to refit</p>
</td></tr>
<tr><td><code id="crm_+3A_itnmax">itnmax</code></td>
<td>
<p>maximum number of iterations for optimization</p>
</td></tr>
<tr><td><code id="crm_+3A_scale">scale</code></td>
<td>
<p>vector of scale values for parameters</p>
</td></tr>
<tr><td><code id="crm_+3A_run">run</code></td>
<td>
<p>if TRUE, it runs model; otherwise if FALSE can be used to test model build components</p>
</td></tr>
<tr><td><code id="crm_+3A_burnin">burnin</code></td>
<td>
<p>number of iterations for mcmc burnin; specified default not realistic for actual use</p>
</td></tr>
<tr><td><code id="crm_+3A_iter">iter</code></td>
<td>
<p>number of iterations after burnin for mcmc (not realistic default)</p>
</td></tr>
<tr><td><code id="crm_+3A_use.admb">use.admb</code></td>
<td>
<p>if TRUE uses ADMB for cjs, mscjs or mvms models</p>
</td></tr>
<tr><td><code id="crm_+3A_use.tmb">use.tmb</code></td>
<td>
<p>if TRUE runs TMB for cjs, mscjs or mvms models</p>
</td></tr>
<tr><td><code id="crm_+3A_crossed">crossed</code></td>
<td>
<p>if TRUE it uses cjs.tpl or cjs_reml.tpl if reml=FALSE or TRUE respectively; if FALSE, then it uses cjsre which can use Gauss-Hermite integration</p>
</td></tr>
<tr><td><code id="crm_+3A_reml">reml</code></td>
<td>
<p>if TRUE uses restricted maximum likelihood</p>
</td></tr>
<tr><td><code id="crm_+3A_compile">compile</code></td>
<td>
<p>if TRUE forces re-compilation of tpl file</p>
</td></tr>
<tr><td><code id="crm_+3A_extra.args">extra.args</code></td>
<td>
<p>optional character string that is passed to admb if use.admb==TRUE</p>
</td></tr>
<tr><td><code id="crm_+3A_strata.labels">strata.labels</code></td>
<td>
<p>labels for strata used in capture history; they are converted to numeric in the order listed. Only needed to specify unobserved strata. For any unobserved strata p=0..</p>
</td></tr>
<tr><td><code id="crm_+3A_clean">clean</code></td>
<td>
<p>if TRUE, deletes the tpl and executable files for amdb if use.admb=T</p>
</td></tr>
<tr><td><code id="crm_+3A_save.matrices">save.matrices</code></td>
<td>
<p>for HMM models this option controls whether the gamma,dmat and delta matrices are saved in the model object</p>
</td></tr>
<tr><td><code id="crm_+3A_simplify">simplify</code></td>
<td>
<p>if TRUE, design matrix is simplified to unique valus including fixed values</p>
</td></tr>
<tr><td><code id="crm_+3A_getreals">getreals</code></td>
<td>
<p>if TRUE, compute real values and std errors for TMB models; may want to set as FALSE until model selection is complete</p>
</td></tr>
<tr><td><code id="crm_+3A_real.ids">real.ids</code></td>
<td>
<p>vector of id values for which real parameters should be output with std error information for TMB models; if NULL all ids used</p>
</td></tr>
<tr><td><code id="crm_+3A_check">check</code></td>
<td>
<p>if TRUE values of gamma, dmat and delta are checked to make sure the values are valid with initial parameter values.</p>
</td></tr>
<tr><td><code id="crm_+3A_prior">prior</code></td>
<td>
<p>if TRUE will expect vectors of prior values in list prior.list; currently only implemented for cjsre_tmb</p>
</td></tr>
<tr><td><code id="crm_+3A_prior.list">prior.list</code></td>
<td>
<p>which contains list of prior parameters that will be model dependent</p>
</td></tr>
<tr><td><code id="crm_+3A_usehess">useHess</code></td>
<td>
<p>if TRUE, the TMB hessian function is used for optimization; using hessian is typically slower with many parameters but can result in a better solution</p>
</td></tr>
<tr><td><code id="crm_+3A_optimize">optimize</code></td>
<td>
<p>if TRUE, optimizes to get parameter estimates; set to FALSE to extract estimates of ADREPORTed values only</p>
</td></tr>
<tr><td><code id="crm_+3A_unit_scale">unit_scale</code></td>
<td>
<p>default TRUE, if FALSE any time scaled parameter (e.g. Phi,S) is scaled when computing real value such that it represents the length of the interval rather than a unit interval</p>
</td></tr>
<tr><td><code id="crm_+3A_...">...</code></td>
<td>
<p>optional arguments passed to js or cjs and optimx</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is operationally similar to the function <code>mark in RMark</code>
in that is is a shell that calls several other functions to perform the
following steps: 1) <code><a href="#topic+process.data">process.data</a></code> to setup data and parameters
and package them into a list (processed data),2)
<code><a href="#topic+make.design.data">make.design.data</a></code> to create the design data for each parameter
in the specified model, 3) <code><a href="#topic+create.dm">create.dm</a></code> to create the design
matrices for each parameter based on the formula provided for each
parameter, 4) call to the specific function for model fitting. As with <code>mark</code> the calling
arguments for <code>crm</code> are a compilation of the calling arguments for each
of the functions it calls (with some arguments renamed to avoid conflicts).
expects to find a value for <code>ddl</code>.  Likewise, if the data have not been
processed, then <code>ddl</code> should be NULL.  This dual calling structure
allows either a single call approach for each model or alternatively the preferred method
where the data area processed and the design data (<code>ddl</code>) created once and
then a whole series of models can be analyzed without repeating those steps.
</p>
<p>There are some optional arguments that can be used to set initial values and
control other aspects of the optimization.  The optimization is done with
the R package/function <code>optimx</code> and the arguments <code>method</code> and
<code>hessian</code> are described with the help for that function.  In addition,
any arguments not matching those in the fitting functions (eg <code>cjs_admb</code>) are passed to
<code>optimx</code> allowing any of the other parameters to be set.  If you set
<code>debug=TRUE</code>, then at each function evaluation (<code><a href="#topic+cjs.lnl">cjs.lnl</a></code>
the current values of the parameters and -2*log-likelihood value are output.
</p>
<p>In the current implementation, a logit link is used to constrain the
parameters in the unit interval (0,1) except for probability of entry which
uses an mlogit and N which uses a log link. For the probitCJS model, a probit link is
used for the parameters. These could be generalized to
use other link functions. Following the notation of MARK, the parameters in
the link space are referred to as <code>beta</code> and those in the actual
parameter space of <code>Phi</code> and <code>p</code> as reals.
</p>
<p>Initial values can be set in 2 ways.  1) Define a list of named vectors with 
the initial beta parameter values (eg logit link) in <code>initial</code>. 
The names of the vectors should be the parameter names in the model. Any unspecified
values are set to 0. 2) Specify a previously run model for initial. The code will match the names of the
current design matrix to the names in <code>beta</code> and use the appropriate
initial values. Any non-specified values are set to 0.  If no value is specified for initial,
all beta are started at a value of 0, except for the CJS model which attempts to use a glm approach to
setting starting values. If the glm fails then they are set to 0.
</p>
<p>If you have a study with unequal time intervals between capture occasions,
then these can be specified with the argument <code>time.intervals</code>.
</p>
<p>The argument <code>accumulate</code> defaults to <code>TRUE</code>.  When it is
<code>TRUE</code> it will accumulate common capture histories that also have
common design and common fixed values (see below) for the parameters.  This
will speed up the analysis because in the calculation of the likelihood
(<code><a href="#topic+cjs.lnl">cjs.lnl</a></code> it loops over the unique values. In general the
default will be the best unless you have many capture histories and are
using many individual covariate(s) in the formula that would make each entry
unique. In that case there will be no effect of accumulation but the code
will still try to accumulate. In that particular case by setting
<code>accumulate=FALSE</code> you can skip the code run for accumulation.
</p>
<p>Most of the arguments controlling the fitted model are contained in lists in
the arguments <code>model.parameters</code> and <code>design.parameters</code> which are
similar to their counterparts in <code>mark inb RMark</code>. Each is a named list
with the names being the parameters in the model (e.g., Phi and p in &quot;cjs&quot;
and &quot;Phi&quot;,&quot;p&quot;,&quot;pent&quot;,&quot;N&quot; in &quot;js&quot;). Each named element is also a list
containing various values defining the design data and model for the
parameter. The elements of <code>model.parameters</code> can include
<code>formula</code> which is an R formula to create the design matrix for the
parameter and <code>fixed</code> is a matrix of fixed values as described below.
The elements of <code>design.parameters</code> can include <code>time.varying</code>,
<code>fields</code>, <code>time.bins</code>,<code>age.bins</code>, and <code>cohort.bins</code>. See
<code><a href="#topic+create.dmdf">create.dmdf</a></code> for a description of the first 2 and
<code><a href="#topic+create.dm">create.dm</a></code> for a description of the last 3.
</p>
<p>Real parameters can be set to fixed values using <code>fixed=x</code> where x is a
matrix with 3 columns and any number of rows.  The first column specifies
the particular animal (capture history) as the row number in the dataframe
<code>x</code>.  The second specifies the capture occasion number for the real
parameter to be fixed.  For <code>Phi</code> and <code>pent</code> these are 1 to
<code>nocc</code>-1 and for <code>p</code> they are 2 to <code>nocc</code> for &quot;cjs&quot; and 1 to
<code>nocc</code> for &quot;js&quot;. This difference is due to the parameter labeling by
the beginning of the interval for Phi (e.g., survival from occasion 1 to 2)
and by the occasion for <code>p</code>.  For &quot;cjs&quot; <code>p</code> is not estimated for
occasion 1. The third element in the row is the real value in the closed
unit interval [0,1] for the fixed parameter.  This approach is completely
general allowing you to fix a particular real parameter for a specific
animal and occasion but it is a bit kludgy. Alternatively, you can set fixed
values by specifying values for a field called fix in the design data for a parameter.
If the value of fix is NA the parameter is estimated and if it is not NA then the real
parameter is fixed at that value.  If you also specify fixed as decribed above, they will over-ride any 
values you have also set with fix in the design data. To set all of the real values for a
particular occasion you can use the following example with the dipper data
as a template:
</p>
<p><code>model.parameters=list(Phi=list(formula=~1,</code>
<code>fixed=cbind(1:nrow(dipper),rep(2,nrow(dipper)),rep(1,nrow(dipper)))))</code>
</p>
<p>The above sets <code>Phi</code> to 1 for the interval between occasions 2 and 3
for all animals. 
</p>
<p>Alternatively, you could do as follows:
</p>
<p>data(dipper)
dp=process.data(dipper)
ddl=make.design.data(dp)
ddl$Phi$fix=ifelse(ddl$Phi$time==2,1,NA)
</p>
<p>At present there is no modification of the parameter count
to address fixing of real parameters except that if by fixing reals, a beta is not needed in the design it will be dropped.
For example, if you were to use ~time for Phi with survival fixed to 1 for time 2, then then beta for that time would not
be included.
</p>
<p>To use ADMB (use.admb=TRUE), you need to install: 1) the R package R2admb, 2) ADMB, and 3) a C++ compiler (I recommend gcc compiler).
The following are instructions for installation with Windows. For other operating systems see (<a href="http://www.admb-project.org/">http://www.admb-project.org/</a>) and 
(<a href="https://www.admb-project.org/tools/gcc/">https://www.admb-project.org/tools/gcc/</a>). 
</p>
<p>Windows Instructions:
</p>
<p>1) In R use install.packages function or choose Packages/Install Packages from menu and select R2admb.
</p>
<p>2) Install ADMB 11: <a href="https://www.admb-project.org/downloads/">https://www.admb-project.org/downloads/</a>. Put the software in C:/admb to
avoid problems with spaces in directory name and for the function below to work.
</p>
<p>3) Install gcc compiler from: <a href="https://www.admb-project.org/tools/gcc/">https://www.admb-project.org/tools/gcc/</a>. Put in c:/MinGW
</p>
<p>I use the following function in R to setup R2admb to access ADMB rather than adding to my path so gcc versions
with Rtools don't conflict. 
</p>
<pre>
prepare_admb=function()
{
  Sys.setenv(PATH = paste("c:/admb/bin;c:admb/utilities;c:/MinGW/bin;", 
        Sys.getenv("PATH"), sep = ";"))
    Sys.setenv(ADMB_HOME = "c:/admb")
    invisible()
}
</pre>
<p>To use different locations you'll need to change the values used above
</p>
<p>Before running crm with use.admb=T, execute the function prepare_admb().  You could put this function or the code it 
contains in your .First or .Rprofile so it runs each time you start R.
</p>


<h3>Value</h3>

<p>crm model object with class=(&quot;crm&quot;,submodel), eg &quot;CJS&quot;.
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cjs_admb">cjs_admb</a></code>, <code><a href="#topic+js">js</a></code>,
<code><a href="#topic+make.design.data">make.design.data</a></code>,<code><a href="#topic+process.data">process.data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
# cormack-jolly-seber model
# fit cjs models with crm
data(dipper)
dipper.proc=process.data(dipper,model="cjs",begin.time=1)
dipper.ddl=make.design.data(dipper.proc)
mod.Phit.pt=crm(dipper.proc,dipper.ddl,
   model.parameters=list(Phi=list(formula=~time),p=list(formula=~time)))
mod.Phit.pt
mod.Phisex.pdot=crm(dipper.proc,dipper.ddl,
   model.parameters=list(Phi=list(formula=~sex),p=list(formula=~1)))
mod.Phisex.pdot
# demo initial value setting
mod.Phisex.ptime=crm(dipper.proc,dipper.ddl,
   model.parameters=list(Phi=list(formula=~sex),p=list(formula=~time)),initial=mod.Phit.pt)
mod.Phisex.ptime
mod.Phisex.ptime=crm(dipper.proc,dipper.ddl,
   model.parameters=list(Phi=list(formula=~sex),p=list(formula=~time)),initial=list(Phi=0,p=0))
mod.Phisex.ptime

## if you have RMark installed you can use this code to run the same models 
## by removing the comment symbol
#library(RMark)
#data(dipper)
#mod0=mark(dipper,
#model.parameters=list(Phi=list(formula=~time),p=list(formula=~time)),output=FALSE)
#summary(mod0,brief=TRUE)
#mod1=mark(dipper,
#model.parameters=list(Phi=list(formula=~1),p=list(formula=~1)),output=FALSE)
#summary(mod1,brief=TRUE)
#mod2&lt;-mark(dipper,groups="sex",
#model.parameters=list(Phi=list(formula=~sex),p=list(formula=~1)),output=FALSE)
#summary(mod2,brief=TRUE)
# jolly seber model
crm(dipper,model="js",groups="sex",
   model.parameters=list(pent=list(formula=~sex),N=list(formula=~sex)),accumulate=FALSE)
# examples showing use of unit.scale
dipper.proc=process.data(dipper,model="cjs",begin.time=1,time.intervals=c(.1,.2,.3,.4,.5,.6))
dipper.ddl=make.design.data(dipper.proc)
mod.Phit.p=crm(dipper.proc,dipper.ddl,
               model.parameters=list(Phi=list(formula=~time),p=list(formula=~1)),
               hessian=TRUE,unit_scale=TRUE)
mod.Phit.p
mod.Phit.p$results$reals

dipper.proc=process.data(dipper,model="cjs",begin.time=1,time.intervals=c(.1,.2,.3,.4,.5,.6))
dipper.ddl=make.design.data(dipper.proc)
mod.Phit.p=crm(dipper.proc,dipper.ddl,
               model.parameters=list(Phi=list(formula=~time),p=list(formula=~1)),
               hessian=TRUE,unit_scale=FALSE)
mod.Phit.p
mod.Phit.p$results$reals

# This example is excluded from testing to reduce package check time
# if you have RMark installed you can use this code to run the same models 
# by removing the comment 
#data(dipper)
#data(mstrata)
#mark(dipper,model.parameters=list(p=list(formula=~time)),output=FALSE)$results$beta
#mark(mstrata,model="Multistrata",model.parameters=list(p=list(formula=~1),
# S=list(formula=~1),Psi=list(formula=~-1+stratum:tostratum)),
# output=FALSE)$results$beta
#mod=mark(dipper,model="POPAN",groups="sex",
#   model.parameters=list(pent=list(formula=~sex),N=list(formula=~sex)))
#summary(mod)
#CJS example with hmm
crm(dipper,model="hmmCJS",model.parameters = list(p = list(formula = ~time)))
##MSCJS example with hmm
data(mstrata)
ms=process.data(mstrata,model="hmmMSCJS",strata.labels=c("A","B","C"))
ms.ddl=make.design.data(ms)
ms.ddl$Psi$fix=NA
ms.ddl$Psi$fix[ms.ddl$Psi$stratum==ms.ddl$Psi$tostratum]=1
crm(ms,ms.ddl,model.parameters=list(Psi=list(formula=~-1+stratum:tostratum)))

}
</code></pre>

<hr>
<h2 id='crm.wrapper'>Automation of model runs</h2><span id='topic+crm.wrapper'></span><span id='topic+create.model.list'></span><span id='topic+model.table'></span><span id='topic+load.model'></span><span id='topic+rerun_crm'></span><span id='topic+crmlist_fromfiles'></span>

<h3>Description</h3>

<p>Some functions that help automate running a set of crm models based on parameter
specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crm.wrapper(model.list,data,ddl=NULL,models=NULL,base="",
              external=TRUE,run=TRUE,env=NULL,replace=FALSE,...)

        create.model.list(parameters)

        model.table(model.list)

        load.model(x)
 
        crmlist_fromfiles(filenames=NULL,external=TRUE)

        rerun_crm(data,ddl,model.list,method=NULL,modelnums=NULL,initial=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crm.wrapper_+3A_model.list">model.list</code></td>
<td>
<p>matrix of model names contained in the environment of models function; each row is a model and each column is for a parameter and the value is formula name</p>
</td></tr>
<tr><td><code id="crm.wrapper_+3A_data">data</code></td>
<td>
<p>Either the raw data which is a dataframe with at least one
column named ch (a character field containing the capture history) or a
processed dataframe. For rerun_crm this should be the processed dataframe</p>
</td></tr>
<tr><td><code id="crm.wrapper_+3A_ddl">ddl</code></td>
<td>
<p>Design data list which contains a list element for each parameter
type; if NULL it is created; For rerun_crm, must be the same ddl as used with original run can cannot be NULL</p>
</td></tr>
<tr><td><code id="crm.wrapper_+3A_models">models</code></td>
<td>
<p>a function with a defined environment with model specifications as variables; values of model.list are some or all of those variables</p>
</td></tr>
<tr><td><code id="crm.wrapper_+3A_base">base</code></td>
<td>
<p>base value for model names</p>
</td></tr>
<tr><td><code id="crm.wrapper_+3A_external">external</code></td>
<td>
<p>if TRUE, model results are stored externally; otherwise they are stored in crmlist</p>
</td></tr>
<tr><td><code id="crm.wrapper_+3A_run">run</code></td>
<td>
<p>if TRUE, fit models; otherwise just create dml to test if model data are correct for formula</p>
</td></tr>
<tr><td><code id="crm.wrapper_+3A_env">env</code></td>
<td>
<p>environment to find model specifications if not parent.frame</p>
</td></tr>
<tr><td><code id="crm.wrapper_+3A_replace">replace</code></td>
<td>
<p>if TRUE replace any existing externally saved model</p>
</td></tr>
<tr><td><code id="crm.wrapper_+3A_...">...</code></td>
<td>
<p>aditional arguments passed to crm; for rerun_crm can be used to set hessian=TRUE for specific models after they have been run</p>
</td></tr>
<tr><td><code id="crm.wrapper_+3A_parameters">parameters</code></td>
<td>
<p>character vector of parameter names</p>
</td></tr>
<tr><td><code id="crm.wrapper_+3A_x">x</code></td>
<td>
<p>filename of externally stored model</p>
</td></tr>
<tr><td><code id="crm.wrapper_+3A_method">method</code></td>
<td>
<p>vector of methods to use for optimization if different that previous run in rerun_crm</p>
</td></tr>
<tr><td><code id="crm.wrapper_+3A_modelnums">modelnums</code></td>
<td>
<p>model numbers to be re-run instead of those that did not covnerge</p>
</td></tr>
<tr><td><code id="crm.wrapper_+3A_initial">initial</code></td>
<td>
<p>either a fitted crm model or the model number in model.list to use for starting values</p>
</td></tr>
<tr><td><code id="crm.wrapper_+3A_filenames">filenames</code></td>
<td>
<p>for non-Windows machine, vector of filenames for external files must be specifed in crmlist_fromfiles including .rda extension</p>
</td></tr>
</table>


<h3>Details</h3>

<p>create.model.list creates all combinations of model specifications for the specified
set of parameters.  In the calling environment it looks for objects named parameter.xxxxxx where xxxxxx can
be anything. It creates a matrix with a column for each parameter and as many rows 
needed to create all combinations. This can be used as input to crm.wrapper.
</p>
<p>crm.wrapper runs a sequence of crm models by constructing the call with the arguments
and the parameter specifications.  The parameter specifications can either be in the
local environment or in the environment of the named function models. The advantage of the
latter is that it is self-contained such that sets of parameter specifications can
be selected without possibility of being over-written or accidentally changed whereas 
with the former the set must be identified via a script and any in the environment will
be used which requires removing/recreating the set to be used.
</p>


<h3>Value</h3>

<p>create.model.list returns a matrix for crm.wrapper; crm.wrapper runs and stores models externally and retrurns a list of model results
and a model selection table; load.model returns model object that is stored externally
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crm">crm</a></code>
</p>

<hr>
<h2 id='deriv_inverse.link'>Derivatives of inverse of link function (internal use)</h2><span id='topic+deriv_inverse.link'></span><span id='topic+deriv.inverse.link'></span>

<h3>Description</h3>

<p>Computes derivatives of inverse of link functions (real estimates) with
respect to the beta parameters which are used for delta method computation
of the var-cov matrix of real parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deriv_inverse.link(real, x, link)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deriv_inverse.link_+3A_real">real</code></td>
<td>
<p>Vector of values of real parameters</p>
</td></tr>
<tr><td><code id="deriv_inverse.link_+3A_x">x</code></td>
<td>
<p>Matrix of design values</p>
</td></tr>
<tr><td><code id="deriv_inverse.link_+3A_link">link</code></td>
<td>
<p>Type of link function (e.g., &quot;logit&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: that function was renamed to deriv_inverse.link to avoid S3 generic
class conflicts. The derivatives of the inverse of the link functions are
simple computations using the real values and the design matrix values.  The
body of the function is as follows:
</p>
<pre>switch(link, logit=x*real*(1-real), log=x*real,
loglog=-real*x*log(real), cloglog=-log(1-real)*x*(1-real), identity=x,
mlogit=x*real*(1-real)) </pre>


<h3>Value</h3>

<p>Vector of derivative values computed at values of real parameters
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inverse.link">inverse.link</a></code>, <code><a href="#topic+compute_real">compute_real</a></code>
</p>

<hr>
<h2 id='dipper'>Dipper capture-recapture data</h2><span id='topic+dipper'></span>

<h3>Description</h3>

<p>A capture-recapture data set on European dippers from France that
accompanies MARK as an example analysis using the CJS and POPAN models.  The
dipper data set was orginally described as an example by Lebreton et al
(1992).
</p>


<h3>Format</h3>

<p>A data frame with 294 observations on the following 2 variables.
</p>
 <dl>
<dt>ch</dt><dd><p>a character vector containing the encounter history of
each bird</p>
</dd> <dt>sex</dt><dd><p>the sex of the bird: a factor with levels
<code>Female</code> <code>Male</code></p>
</dd> </dl>



<h3>Details</h3>

<p>This is a data set that accompanies program MARK as an example for CJS and
POPAN analyses.  The data can be stratified using sex as a grouping
variable.  The functions <code>run.dipper</code>, <code>run.dipper.alternate</code>,
<code>run.dipper.popan</code> defined below in the examples mimic the models used
in the dbf file that accompanies MARK. Note that the models used in the MARK
example use PIM coding with the sin link function which is often better at
identifying the number of estimable parameters.  The approach used in the R
code uses design matrices and cannot use the sin link and is less capable at
counting parameters.  These differences are illustrated by comparing the
results of <code>run.dipper</code> and <code>run.dipper.alternate</code> which fit the
same set of &quot;CJS&quot; models.  The latter fits the models with constraints on
some parameters to achieve identifiability and the former does not. Although
it does not influence the selection of the best model it does infleunce
parameter counts and AIC ordering of some of the less competitive models. In
using design matrices it is best to constrain parameters that are confounded
(e.g., last occasion parameters in Phi(t)p(t) CJS model) when possible to
achieve more reliable counts of the number of estimable parameters.
</p>
<p>Note that the covariate &quot;sex&quot; defined in dipper has values &quot;Male&quot; and
&quot;Female&quot;.  It cannot be used directly in a formula for MARK without using it
do define groups because MARK.EXE will be unable to read in a covariate with
non-numeric values.  By using <code>groups="sex"</code> in the call the
<code><a href="#topic+process.data">process.data</a></code> a factor &quot;sex&quot; field is created that can be used
in the formula.  Alternatively, a new covariate could be defined in the data
with say values 0 for Female and 1 for Male and this could be used without
defining groups because it is numeric.  This can be done easily by
translating the values of the coded variables to a numeric variable.  Factor
variables are numbered 1..k for k levels in alphabetic order.  Since Female
&lt; Male in alphabetic order then it is level 1 and Male is level 2.  So the
following will create a numeric sex covariate.
</p>
<pre> dipper$numeric.sex=as.numeric(dipper$sex)-1 </pre>


<h3>Source</h3>

<p>Lebreton, J.-D., K. P. Burnham, J. Clobert, and D. R. Anderson.
1992. Modeling survival and testing biological hypotheses using marked
animals: case studies and recent advances. Ecol. Monogr. 62:67-118.
</p>

<hr>
<h2 id='dmat_hsmm2hmm'>Create expanded state-dependent observation matrix for HMM from HSMM</h2><span id='topic+dmat_hsmm2hmm'></span>

<h3>Description</h3>

<p>Creates expanded state-dependent matrix for HMM from aggregated state-dependent observation
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmat_hsmm2hmm(dmat, mv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dmat_hsmm2hmm_+3A_dmat">dmat</code></td>
<td>
<p>state-dependent observation matrix for aggregated states</p>
</td></tr>
<tr><td><code id="dmat_hsmm2hmm_+3A_mv">mv</code></td>
<td>
<p>vector of dwell time distribution lengths</p>
</td></tr>
</table>


<h3>Value</h3>

<p>expanded state-dependent observation matrix for hmm to approximate hsmm
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>

<hr>
<h2 id='fix.parameters'>Fixing real parameters in crm models</h2><span id='topic+fix.parameters'></span>

<h3>Description</h3>

<p>Creates matrix with appropriate structure for fixing real parameters in a
crm model for a specified set of capture histories and occasions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix.parameters(x, subset = NULL, occasions, values)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fix.parameters_+3A_x">x</code></td>
<td>
<p>processed data list</p>
</td></tr>
<tr><td><code id="fix.parameters_+3A_subset">subset</code></td>
<td>
<p>logical expression for set of animals; used in subset function</p>
</td></tr>
<tr><td><code id="fix.parameters_+3A_occasions">occasions</code></td>
<td>
<p>vector of occasion numbers</p>
</td></tr>
<tr><td><code id="fix.parameters_+3A_values">values</code></td>
<td>
<p>either single or vector of values; if latter, must match
length of occasions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with 3 columns: 1) animal row number, 2) occasion, 3) value
for real parameter
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>

<hr>
<h2 id='function.wrapper'>Utility extract functions</h2><span id='topic+function.wrapper'></span><span id='topic+fx.aic'></span><span id='topic+fx.par.count'></span>

<h3>Description</h3>

<p>Several functions have been added to extract components from externally saved crm models
function.wrapper accepts a character string for a model, loads it and then runs the specified
function on it. Currently, only 2 functions have been defined: fx.aic to compute aic and
fx.par.count to extract parameter count. Currently parameters other than x (eg chat) are passed through
the environment. Possibly could have used ...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>function.wrapper(x,fx,base="",...)

       fx.aic(x) 

       fx.par.count(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="function.wrapper_+3A_x">x</code></td>
<td>
<p>character string for the model stored as external object (.rda)</p>
</td></tr>
<tr><td><code id="function.wrapper_+3A_fx">fx</code></td>
<td>
<p>function to be called for each model</p>
</td></tr>
<tr><td><code id="function.wrapper_+3A_base">base</code></td>
<td>
<p>base name for models</p>
</td></tr>
<tr><td><code id="function.wrapper_+3A_...">...</code></td>
<td>
<p>additional values that are added to environment of fx (eg chat for fx.aic)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>extracted value defined by function
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>

<hr>
<h2 id='global_decode'>Global decoding of HMM</h2><span id='topic+global_decode'></span>

<h3>Description</h3>

<p>Computes sequence of state predictions for each individual
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_decode(object, ddl = NULL, state.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="global_decode_+3A_object">object</code></td>
<td>
<p>fitted crm model (must be an HMM model)</p>
</td></tr>
<tr><td><code id="global_decode_+3A_ddl">ddl</code></td>
<td>
<p>design data list; will be computed if NULL</p>
</td></tr>
<tr><td><code id="global_decode_+3A_state.names">state.names</code></td>
<td>
<p>names for states used to label output; if NULL uses strata.labels + Dead state</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of state predictions
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>References</h3>

<p>Zucchini, W. and I.L. MacDonald. 2009. Hidden Markov Models for Time Series: An Introduction using R. Chapman and Hall, Boca Raton, FL. See page 82.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#

# This example is excluded from testing to reduce package check time
# cormack-jolly-seber model
data(dipper)
mod=crm(dipper,model="hmmcjs")
global_decode(mod)

</code></pre>

<hr>
<h2 id='hmmDemo'>HMM computation demo functions</h2><span id='topic+hmmDemo'></span>

<h3>Description</h3>

<p>Uses fitted hmm model to construct HMM state vectors alpha and phi for demonstration purposes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmmDemo(object, ddl = NULL, state.names = NULL, obs.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hmmDemo_+3A_object">object</code></td>
<td>
<p>fitted hmm model</p>
</td></tr>
<tr><td><code id="hmmDemo_+3A_ddl">ddl</code></td>
<td>
<p>design dat list; if NULL it is created</p>
</td></tr>
<tr><td><code id="hmmDemo_+3A_state.names">state.names</code></td>
<td>
<p>names for states used to label output; if NULL uses strata.labels + Dead state</p>
</td></tr>
<tr><td><code id="hmmDemo_+3A_obs.names">obs.names</code></td>
<td>
<p>names for observations used to label output; if NULL uses ObsLevels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hmm demo list which includes 1) lnl - the log-likelihood value, 2) alpha - forward probabilities,
3) beta - backward probabilities, 4) phi - scaled forward probabilities, 5) v- intermediate calculation for phi,
6) dmat - 3-d array with observation probability matrix for each occasion, 7) gamma - 3-d array with state transition probability
matrix for each occasion, 8) stateprob - predicted state probabilities, 9) local_decode - state predictions for each occasion and individual, 
10) global_decode - state predictions for entire sequence for each individual.
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This example is excluded from testing to reduce package check time
# cormack-jolly-seber model
data(dipper)
mod=crm(dipper,model="hmmcjs")
x=hmmDemo(mod,state.names=c("Alive","Dead"),obs.names=c("Missed","Seen"))
par(mfrow=c(2,1))
barplot(t(x$alpha[45,,]),beside=TRUE,names.arg=x$chforwardstrings)
barplot(t(x$phi[45,,]),beside=TRUE,names.arg=x$chforwardstrings)
# multi-state example showing state predictions
data(mstrata)
mod=crm(mstrata,model="hmmMSCJS",strata.labels=c("A","B","C"))
#' x=hmmDemo(mod)
# state predictions are normalized by likelihood value which = rowSums(alpha*beta)
cat(paste("\nrowsums = ",rowSums(x$alpha[45,,]*x$beta[45,,],na.rm=TRUE)[2],
   "which matches likelihood value",exp(x$lnl[45]),"\n"))
# state predictions given the data
x$stateprob[45,,]

</code></pre>

<hr>
<h2 id='HMMLikelihood'>Hidden Markov Model likelihood functions</h2><span id='topic+HMMLikelihood'></span><span id='topic+reals'></span><span id='topic+hmm.lnl'></span>

<h3>Description</h3>

<p>Function HMMLikelihood computes the log-likelihood via hmm.lnl which is a wrapper for the
FORTRAN code hmm_like.f.  The function HMMlikelihood is called from optimizer and it in turn calls hmm.lnl after
setting up parameters.
</p>
<p>For an R version of the HMMLikelihood and related code see <code><a href="#topic+R_HMMLikelihood">R_HMMLikelihood</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HMMLikelihood(par,type,xx,xstart,mx,T,freq=1,fct_dmat,fct_gamma,fct_delta,ddl,
                         dml,parameters,debug=FALSE,return.mat=FALSE,sup=NULL,check=FALSE)
       reals(ddl,dml,parameters,parlist,indices=NULL)
       hmm.lnl(x,start,m,T,dmat,gamma,delta,freq,debug)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HMMLikelihood_+3A_par">par</code></td>
<td>
<p>vector of parameter values for log-likelihood evaluation</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_type">type</code></td>
<td>
<p>vector of parameter names used to split par vector into types</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_xx">xx</code></td>
<td>
<p>matrix of observed sequences (row:id; column:occasion/time); xx used instead of x to avoid conflict in optimx</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_xstart">xstart</code></td>
<td>
<p>for each ch, the first non-zero x value and the occasion of the first non-zero value; ; xstart used instead of start to avoid conflict in optimx</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_mx">mx</code></td>
<td>
<p>number of states; mx used instead of m to avoid conflict in optimx</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_t">T</code></td>
<td>
<p>number of occasions; sequence length</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_freq">freq</code></td>
<td>
<p>vector of history frequencies or 1</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_fct_dmat">fct_dmat</code></td>
<td>
<p>function to create D from parameters</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_fct_gamma">fct_gamma</code></td>
<td>
<p>function to create gamma - transition matrix</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_fct_delta">fct_delta</code></td>
<td>
<p>function to create initial state distribution</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_ddl">ddl</code></td>
<td>
<p>design data list of parameters for each id</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_dml">dml</code></td>
<td>
<p>list of design matrices; one entry for each parameter; each entry contains fe and re for fixed and random effects</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_parameters">parameters</code></td>
<td>
<p>formulas for each parameter type</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_debug">debug</code></td>
<td>
<p>if TRUE, print out par values and -log-likelihood</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_return.mat">return.mat</code></td>
<td>
<p>If TRUE, returns list of transition, observation and delta arrays.</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_sup">sup</code></td>
<td>
<p>list of supplemental information that may be needed by the function but only needs to be computed once; currently only used for MVMS models for dmat</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_check">check</code></td>
<td>
<p>if TRUE, checks validity of gamma, dmat and delta to look for any errors</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_x">x</code></td>
<td>
<p>same as xx but for call to hmm.lnl</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_m">m</code></td>
<td>
<p>same as mx but for call to hmm.lnl</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_dmat">dmat</code></td>
<td>
<p>observation probability matrices</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_gamma">gamma</code></td>
<td>
<p>transition matrices</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_delta">delta</code></td>
<td>
<p>initial distribution</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_parlist">parlist</code></td>
<td>
<p>list of parameter strings used to split par vector</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_start">start</code></td>
<td>
<p>same as xstart but for hmm.lnl</p>
</td></tr>
<tr><td><code id="HMMLikelihood_+3A_indices">indices</code></td>
<td>
<p>specific indices for computation unless NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>HMMLikelihood returns log-likelihood for a single sequence and
hmm.lnl returns the negative log-likelihood value for each capture history. reals
returns either the column dimension of design matrix for parameter or the real parameter vector
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>References</h3>

<p>Zucchini, W. and I.L. MacDonald. 2009. Hidden Markov Models for Time Series: An Introduction using R. Chapman and Hall, Boca Raton, FL. 275p.
</p>


<h3>See Also</h3>

<p>R_HMMLikelihood
</p>

<hr>
<h2 id='hsmm2hmm'>Compute transition matrix for HMM from HSMM</h2><span id='topic+hsmm2hmm'></span>

<h3>Description</h3>

<p>Computes expanded transition matrix for HMM from aggregated state transition
matrix and dwell time distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsmm2hmm(omega, dm, eps = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hsmm2hmm_+3A_omega">omega</code></td>
<td>
<p>transition matrix for aggregated states</p>
</td></tr>
<tr><td><code id="hsmm2hmm_+3A_dm">dm</code></td>
<td>
<p>list of dwell time distribution vectors; each list element is vector of dwell time probabilities in order of aggregated states</p>
</td></tr>
<tr><td><code id="hsmm2hmm_+3A_eps">eps</code></td>
<td>
<p>epsilon value for setting small probabilities to 0; anything less than eps is set to exactly 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>transition matrix for hmm to approximate hsmm
</p>


<h3>Author(s)</h3>

<p>Walter Zucchini
</p>

<hr>
<h2 id='initiate_pi'>Setup fixed values for pi in design data</h2><span id='topic+initiate_pi'></span>

<h3>Description</h3>

<p>Creates field fix in pi design data and either sets to NA to be estimated
or 1 if intercept or 0 if not possible. It uses observed data at initial
entry to decide the appropriate fix values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initiate_pi(data, ddl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initiate_pi_+3A_data">data</code></td>
<td>
<p>Processed data list; resulting value from process.data</p>
</td></tr>
<tr><td><code id="initiate_pi_+3A_ddl">ddl</code></td>
<td>
<p>design data list created by make.design.data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible that the state will be known for some individuals
and unknown for others.  The function initiate_pi modifies the design data for pi by adding
the field fix which can be used to fix the value of pi for an individual with known state
at release. It also sets up the mlogit structure for pi by setting one of the fixed values to 1
such that the value for pi is computed by subtraction.  By default it chooses the first factor level
of each of the state variables that is unknown.  If some of the state variables are known but others are not, 
it sets fix to 0 for the values of the known state variables that don't match the known value.  
</p>
<p>For example, with a bivariate case with first state A,B or C and second variable 1 or 2.  Only the second
variable can be unknown. There are 6 possible combinations of the state variables: A1,A2,B2,B2,C1,C2.
Assume a capture history is 0,Au,0,B1,B2.  There will be 6 records in the design data for this record
with strata A1,A2,B2,B2,C1,C2. The occ (occasion field) will be 2 because pi is only for the first occasion.
After running initiate_pi, the fix values will be 1,NA,0,0,0,0.  A1 will be the intercept and computed 
by subtraction (fix=1), the value for A2 will be estimated (NA) and all of the others
are not possible (0) because it is known to be in A.
</p>
<p>If both can be uncertain, and the capture history was  0,uu,0,B1,B2, then the fix values will be
1,NA,NA,NA,NA,NA. With a mix of partially known and completely unknown the formulation for the mlogit could
get complicated making it difficult to specify an understandable formula because the restrictions on the
mlogit will change, so think hard and long about what you are doing.  It may be necessary to construct &quot;multiple&quot; formula
in the sense that you use indicator variables (0/1) as interactions.
</p>


<h3>Value</h3>

<p>ddl with fix field added to pi dataframe
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>

<hr>
<h2 id='inverse.link'>Inverse link functions (internal use)</h2><span id='topic+inverse.link'></span>

<h3>Description</h3>

<p>Computes values of inverse of link functions for real estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverse.link(x, link)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inverse.link_+3A_x">x</code></td>
<td>
<p>Matrix of design values multiplied by the vector of the beta
parameter values</p>
</td></tr>
<tr><td><code id="inverse.link_+3A_link">link</code></td>
<td>
<p>Type of link function (e.g., &quot;logit&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse of the link function is the real parameter value. They are
simple functions of <code>X*Beta</code> where <code>X</code> is the design matrix values
and <code>Beta</code> is the vector of link function parameters. The body of the
function is as follows:
</p>
<pre>switch(link, logit=exp(x)/(1+exp(x)), log=exp(x),
loglog=exp(-exp(-x)), cloglog=1-exp(-exp(x)), identity=x,
mlogit=exp(x)/(1+sum(exp(x))) ) </pre>
<p>The <code>link="mlogit"</code> only works if the set of real parameters are
limited to those within the set of parameters with that specific link.  For
example, in POPAN, the <code>pent</code> parameters are of type &quot;mlogit&quot; so the
probabilities sum to 1.  However, if there are several groups then each
group will have a different set of <code>pent</code> parameters which are
identified by a different grouping of the &quot;mlogit&quot; parameters (i.e.,
&quot;mlogit(1)&quot; for group 1, &quot;mlogit(2)&quot; for group 2 etc).  Thus, in computing
real parameter values (see <code><a href="#topic+compute_real">compute_real</a></code>) which may have
varying links, those with &quot;mlogit&quot; are not used with this function using
<code>link="mlogit"</code>.  Instead, the link is temporarily altered to be of
type &quot;log&quot; (i.e., inverse=exp(x)) and then summed over sets with a common
value for &quot;mlogit(j)&quot; to construct the inverse for &quot;mlogit&quot; as
<code>exp(x)/(1+sum(exp(x))</code>.
</p>


<h3>Value</h3>

<p>Vector of real values computed from <code>x=X*Beta</code>
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_real">compute_real</a></code>,<code><a href="#topic+deriv_inverse.link">deriv_inverse.link</a></code>
</p>

<hr>
<h2 id='js'>Fitting function for Jolly-Seber model using Schwarz-Arnason POPAN
formulation</h2><span id='topic+js'></span>

<h3>Description</h3>

<p>A function for computing MLEs for a specified Jolly-Seber open population
capture-recapture model for processed dataframe <code>x</code> with user specified
formulas in <code>parameters</code> that create list of design matrices
<code>dml</code>. This function can be called directly but is most easily called
from <code><a href="#topic+crm">crm</a></code> that sets up needed arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>js(
  x,
  ddl,
  dml,
  model_data = NULL,
  parameters,
  accumulate = TRUE,
  initial = NULL,
  method = "BFGS",
  hessian = FALSE,
  debug = FALSE,
  chunk_size = 1e+07,
  refit,
  itnmax = NULL,
  control = NULL,
  scale,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="js_+3A_x">x</code></td>
<td>
<p>processed dataframe created by process.data</p>
</td></tr>
<tr><td><code id="js_+3A_ddl">ddl</code></td>
<td>
<p>list of dataframes for design data; created by call to
<code><a href="#topic+make.design.data">make.design.data</a></code></p>
</td></tr>
<tr><td><code id="js_+3A_dml">dml</code></td>
<td>
<p>list of design matrices created by <code><a href="#topic+create.dm">create.dm</a></code> from
formula and design data</p>
</td></tr>
<tr><td><code id="js_+3A_model_data">model_data</code></td>
<td>
<p>a list of all the relevant data for fitting the model including
imat, Phi.dm,p.dm,Phi.fixed,p.fixed, and time.intervals. It is used to save values
and avoid accumulation again if the model was re-rerun with an additional call to js when
using autoscale or re-starting with initial values.  It is stored with returned model object.</p>
</td></tr>
<tr><td><code id="js_+3A_parameters">parameters</code></td>
<td>
<p>equivalent to <code>model.parameters</code> in <code><a href="#topic+crm">crm</a></code></p>
</td></tr>
<tr><td><code id="js_+3A_accumulate">accumulate</code></td>
<td>
<p>if TRUE will accumulate capture histories with common
value and with a common design matrix for Phi and p to speed up execution</p>
</td></tr>
<tr><td><code id="js_+3A_initial">initial</code></td>
<td>
<p>initial values for parameters if desired; if named vector
from previous run it will match to columns with same name</p>
</td></tr>
<tr><td><code id="js_+3A_method">method</code></td>
<td>
<p>method to use for optimization; see <code>optimx</code></p>
</td></tr>
<tr><td><code id="js_+3A_hessian">hessian</code></td>
<td>
<p>if TRUE will compute and return the hessian</p>
</td></tr>
<tr><td><code id="js_+3A_debug">debug</code></td>
<td>
<p>if TRUE will print out information for each iteration</p>
</td></tr>
<tr><td><code id="js_+3A_chunk_size">chunk_size</code></td>
<td>
<p>specifies amount of memory to use in accumulating capture
histories; amount used is 8*chunk_size/1e6 MB (default 80MB)</p>
</td></tr>
<tr><td><code id="js_+3A_refit">refit</code></td>
<td>
<p>non-zero entry to refit</p>
</td></tr>
<tr><td><code id="js_+3A_itnmax">itnmax</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="js_+3A_control">control</code></td>
<td>
<p>control string for optimization functions</p>
</td></tr>
<tr><td><code id="js_+3A_scale">scale</code></td>
<td>
<p>vector of scale values for parameters</p>
</td></tr>
<tr><td><code id="js_+3A_...">...</code></td>
<td>
<p>any remaining arguments are passed to additional parameters
passed to <code>optimx</code> or <code><a href="#topic+js.lnl">js.lnl</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is easiest to call <code>js</code> through the function <code><a href="#topic+crm">crm</a></code>.
Details are explained there.
</p>
<p>Be cautious with this function at present.  It does not include many checks
to make sure values like fixed values will remain in the specified range of
the data.  Normally this would not be a big problem but because
<code><a href="#topic+js.lnl">js.lnl</a></code> calls an external FORTRAN subroutine via
<code><a href="#topic+cjs.lnl">cjs.lnl</a></code>, if it gets a subscirpt out of bounds, it will cause R
to terminate.  So make sure to save your workspace frequently if you use
this function in its current implementation.
</p>


<h3>Value</h3>

<p>The resulting value of the function is a list with the class of
crm,js such that the generic functions print and coef can be used.
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>named vector of parameter estimates</p>
</td></tr> <tr><td><code>lnl</code></td>
<td>
<p>-2*log
likelihood</p>
</td></tr> <tr><td><code>AIC</code></td>
<td>
<p>lnl + 2* number of parameters</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>result from <code>optimx</code>; if 0 <code>optimx</code> thinks it
converged</p>
</td></tr> <tr><td><code>count</code></td>
<td>
<p><code>optimx</code> results of number of function
evaluations</p>
</td></tr> <tr><td><code>reals</code></td>
<td>
<p>dataframe of data and real Phi and p estimates for
each animal-occasion excluding those that occurred before release</p>
</td></tr>
<tr><td><code>vcv</code></td>
<td>
<p>var-cov matrix of betas if hessian=TRUE was set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>References</h3>

<p>Schwarz, C. J., and A. N. Arnason. 1996. A general methodology
for the analysis of capture-recapture experiments in open populations.
Biometrics 52:860-873.
</p>

<hr>
<h2 id='js.accumulate'>Accumulates common capture history values</h2><span id='topic+js.accumulate'></span>

<h3>Description</h3>

<p>To speed up compuation, animals with the same capture history and design matrix are
accumulated and represented by a frequency. Computes starting values for Phi and p parameters from the
list of design matrices and the summarized data list including ch matrix and
first and last vectors. If any values are missing (NA) or abs(par)&gt;5, they are
set to 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>js.accumulate(x, model_data, nocc, freq, chunk_size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="js.accumulate_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="js.accumulate_+3A_model_data">model_data</code></td>
<td>
<p>list of design matrices, fixed parameters and time intervals all which can vary by animal</p>
</td></tr>
<tr><td><code id="js.accumulate_+3A_nocc">nocc</code></td>
<td>
<p>number of capture occasions</p>
</td></tr>
<tr><td><code id="js.accumulate_+3A_freq">freq</code></td>
<td>
<p>frequency of each capture history before accumulation</p>
</td></tr>
<tr><td><code id="js.accumulate_+3A_chunk_size">chunk_size</code></td>
<td>
<p>size that determines number of pieces of data/design matrix that are handled. Smaller chunk_size requires more
time but less memory. 1e7 is default set in cjs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modified model_data list that is accumulated
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>

<hr>
<h2 id='js.hessian'>Compute variance-covariance matrix for fitted JS model</h2><span id='topic+js.hessian'></span>

<h3>Description</h3>

<p>A wrapper function that sets up call to hessian function to compute and then
invert the hessian.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>js.hessian(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="js.hessian_+3A_model">model</code></td>
<td>
<p>fitted JS model from function crm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>variance-covariance matrix for specified model or the model
object with the stored vcv depending on whether the model has already been run
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>

<hr>
<h2 id='js.lnl'>Likelihood function for Jolly-Seber model using Schwarz-Arnason POPAN
formulation</h2><span id='topic+js.lnl'></span>

<h3>Description</h3>

<p>For a given set of parameters and data, it computes -2*log Likelihood value
but does not include data factorials. Factorials for unmarked are not needed
but are included in final result by <code><a href="#topic+js">js</a></code> so the result matches
output from MARK for the POPAN model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>js.lnl(par, model_data, debug = FALSE, nobstot, jsenv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="js.lnl_+3A_par">par</code></td>
<td>
<p>vector of parameter values</p>
</td></tr>
<tr><td><code id="js.lnl_+3A_model_data">model_data</code></td>
<td>
<p>a list that contains: 1)imat-list of vectors and matrices constructed by
<code><a href="#topic+process.ch">process.ch</a></code> from the capture history data, 2)Phi.dm design matrix for Phi constructed by <code><a href="#topic+create.dm">create.dm</a></code>,
3)p.dm design matrix for p constructed by <code><a href="#topic+create.dm">create.dm</a></code>, 4)pent.dm design matrix for probability of entry constructed by <code><a href="#topic+create.dm">create.dm</a></code>,
5) N.dm design matrix for estimates of number of animals not caught from
super-population constructed by <code><a href="#topic+create.dm">create.dm</a></code>,
6)Phi.fixed matrix with 3 columns: ch number(i), occasion number(j),
fixed value(f) to fix phi(i,j)=f, 7) p.fixed matrix with 3 columns: ch number(i), occasion number(j), 
8) pent.fixed matrix with 3 columns: ch number(i), occasion number(j), fixed value(f) to fix pent(i,j)=f, and
9) time.intervals intervals of time between occasions if not all 1
fixed value(f) to fix p(i,j)=f</p>
</td></tr>
<tr><td><code id="js.lnl_+3A_debug">debug</code></td>
<td>
<p>if TRUE will printout values of <code>par</code> and function value</p>
</td></tr>
<tr><td><code id="js.lnl_+3A_nobstot">nobstot</code></td>
<td>
<p>number of unique caught at least once by group if applicable</p>
</td></tr>
<tr><td><code id="js.lnl_+3A_jsenv">jsenv</code></td>
<td>
<p>environment for js to update iteration counter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions uses <code><a href="#topic+cjs.lnl">cjs.lnl</a></code> and then supplements with the
remaining calculations to compute the likelihood for the POPAN formulation
(Arnason and Schwarz 1996) of the Jolly-Seber model.
</p>


<h3>Value</h3>

<p>-log likelihood value, excluding data (ui) factorials which are added in js after optimization to match MARK
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>References</h3>

<p>Schwarz, C. J., and A. N. Arnason. 1996. A general methodology
for the analysis of capture-recapture experiments in open populations.
Biometrics 52:860-873.
</p>

<hr>
<h2 id='local_decode'>Local decoding of HMM</h2><span id='topic+local_decode'></span>

<h3>Description</h3>

<p>Computes state predictions one at a time for each occasion for each individual
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_decode(object, ddl = NULL, state.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_decode_+3A_object">object</code></td>
<td>
<p>fitted crm model (must be an HMM model)</p>
</td></tr>
<tr><td><code id="local_decode_+3A_ddl">ddl</code></td>
<td>
<p>design data list</p>
</td></tr>
<tr><td><code id="local_decode_+3A_state.names">state.names</code></td>
<td>
<p>names for states used to label output; if NULL uses strata.labels + Dead state</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of state predictions
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>References</h3>

<p>Zucchini, W. and I.L. MacDonald. 2009. Hidden Markov Models for Time Series: An Introduction using R. Chapman and Hall, Boca Raton, FL. See page 80.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#

# This example is excluded from testing to reduce package check time
# cormack-jolly-seber model
data(dipper)
mod=crm(dipper,model="hmmcjs")
local_decode(mod)

</code></pre>

<hr>
<h2 id='make.design.data'>Create design dataframes for crm</h2><span id='topic+make.design.data'></span>

<h3>Description</h3>

<p>For each type of parameter in the analysis model (e.g, p, Phi), this
function creates design data for model fitting from the original data. 
These design data expand the original data record for a single(freq=1)/multiple(freq&gt;1) individuals
to many records where each record is for a single occasion. The design data can
be specific to the parameter and a list of design data frames are returned with a dataframe
for each parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.design.data(data, parameters = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.design.data_+3A_data">data</code></td>
<td>
<p>Processed data list; resulting value from process.data</p>
</td></tr>
<tr><td><code id="make.design.data_+3A_parameters">parameters</code></td>
<td>
<p>Optional list containing a list for each type of parameter
(list of lists); each parameter list is named with the parameter name (eg
Phi); each parameter list can contain vectors named age.bins,time.bins and
cohort.bins, time.varying, and static </p>

<table>
<tr>
 <td style="text-align: left;"> <code>age.bins</code> </td><td style="text-align: left;"> bins
for binning ages</td>
</tr>
<tr>
 <td style="text-align: left;"> <code>time.bins</code> </td><td style="text-align: left;"> bins for binning times</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cohort.bins</code> </td><td style="text-align: left;"> bins for binning cohorts</td>
</tr>
<tr>
 <td style="text-align: left;"> <code>time.varying</code> </td><td style="text-align: left;">
vector of field names that are time varying for this parameter</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>static</code> </td><td style="text-align: left;"> vector of field names that are to be included that are
not time varying for this parameter</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>
</td></tr>
</table>


<h3>Details</h3>

<p>For each record in the design data, default data fields are created based on the model. For example,
for CJS, the default fields include cohort, age, time which are factor variables and Cohort, Age, and Time
which are numeric versions of the same fields.  The values of these can be altered by values of 
begin.time, time.intervals and initial.ages set in the call to <code><a href="#topic+process.data">process.data</a></code>. In addition if groups are identifed the
grouping factor variables are added to the design data. Any other fields in the data are repeated on each record
for the animal(s) (eg weight), unless they are defined as time.varying in which case the fields should be named
with the convention xn where x is the base name for the variable and n is the time value (eg, td1999, td2000,...).
For time varying fields the variable name in the design data is the base name and the value for the record is
the one for that occasion(time). The variables can be refined for each parameter by including argument static with the
character vector of static fields to include.
</p>
<p>After creating design data, you can create a field in the dataframe for a parameter named fix and it can be assigned values
at the real parameter for that occasion/id will be fixed at the value. For parameters that are not supposed to be fixed, the field
fix should be assigned NA.  For example, ddl$Phi$fix=ifelse(ddl$Phi$time==2,1,NA) will assign all real Phi values to 1 for the interval
beginning at time 2. If there is no field fix, then no parameters are fixed.  For mlogit parameters, a fix field is added automatically and
the value 1 is specified for the stratum that is supposed to be computed by subtraction and the remainder are set to NA.  If some Psi are not possible
then those values can be changed to 0.
</p>
<p>The following variable names are reserved and should not be used in the data:
occ,age,time,cohort,Age,Time,Cohort,Y,Z,initial.age,begin.time,time.interval,fix
</p>


<h3>Value</h3>

<p>The function value is a list of data frames. The list contains a
data frame for each type of parameter in the model (e.g., Phi and p for
CJS).  The names of the list elements are the parameter names (e.g., Phi).
The structure of the dataframe depends on the calling arguments and the
model &amp; data structure. In addition the value of parameters argument is saved as design.parameters.
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>See Also</h3>

<p><code><a href="#topic+process.data">process.data</a></code>,<code><a href="#topic+merge_design.covariates">merge_design.covariates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This example is excluded from testing to reduce package check time
data(dipper)
dipper.proc=process.data(dipper)
ddl=make.design.data(dipper.proc)

</code></pre>

<hr>
<h2 id='merge_design.covariates'>Merge time (occasion) and/or group specific covariates into design data</h2><span id='topic+merge_design.covariates'></span><span id='topic+merge.design.covariates'></span>

<h3>Description</h3>

<p>Adds new design data fields from a dataframe into a design data list
(<code>ddl</code>) by matching via time and/or group field in the design data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_design.covariates(ddl, df, bygroup = FALSE, bytime = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_design.covariates_+3A_ddl">ddl</code></td>
<td>
<p>current design dataframe for a specific parameter and not the
entire design data list (ddl)</p>
</td></tr>
<tr><td><code id="merge_design.covariates_+3A_df">df</code></td>
<td>
<p>dataframe with time(occasion) and/or group-specific data</p>
</td></tr>
<tr><td><code id="merge_design.covariates_+3A_bygroup">bygroup</code></td>
<td>
<p>logical; if TRUE, then a field named <code>group</code> should be
in <code>df</code> and the values can then be group specific.</p>
</td></tr>
<tr><td><code id="merge_design.covariates_+3A_bytime">bytime</code></td>
<td>
<p>logical; if TRUE, then a field named <code>time</code> should be in
<code>df</code> and the values can then be time specific.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Design data can be added to the parameter specific design dataframes with R
commands.  This function simplifies the process by enabling the merging of a
dataframe with a time and/or group field and one or more time and/or group
specific covariates into the design data list for a specific model
parameter. This is a replacement for the older function
<code>merge.occasion.data</code>. Unlike the older function, it uses the R
function <code><a href="base.html#topic+merge">merge</a></code> but before merging it makes sure all of the
fields exist and that you are not merging data that already exists in the
design data.  It also maintains the row names in the case where design data
have been deleted prior to merging the design covariate data.
</p>
<p>If <code>bytime=TRUE</code>,the dataframe <code>df</code> must have a field named
<code>time</code> that matches 1-1 for each value of <code>time</code> in the design
data list (<code>ddl</code>).  All fields in <code>df</code> (other than time/group) are
added to the design data.  If you set <code>bygroup=TRUE</code> and have a field
named <code>group</code> in <code>df</code> and its values match the group fields in the
design data then group-specific values can be assigned for each time if
<code>bytime=TRUE</code>. If <code>bygroup=TRUE</code> and <code>bytime=FALSE</code> then it
matches by group and not by time.
</p>


<h3>Value</h3>

<p>Design dataframe (for a particular parameter) with new fields added.
See <code><a href="#topic+make.design.data">make.design.data</a></code> for a description of the design data list
structure. The return value is only one element in the list rather than the
entire list as with the older function <code>merge.occasion.data</code>.
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.design.data">make.design.data</a></code>, <code><a href="#topic+process.data">process.data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dipper)
dipper.proc=process.data(dipper)
ddl=make.design.data(dipper.proc)
df=data.frame(time=c(1:7),effort=c(10,5,2,8,1,2,3))
# note that the value for time 1 is superfluous for CJS but not for POPAN
# the value 10 will not appear in the summary because there is no p for time 1
summary(ddl$p)
ddl$p=merge_design.covariates(ddl$p,df)
summary(ddl$p)
#Statement below will create an error because a value for time 7 not given
#ddl=merge.occasion.data(dipper.proc,ddl,"p",data.frame(time=c(1:6),effort=c(10,5,2,8,1,2)))
#
# Assign group-specific values
#

data(dipper)
dipper.proc=process.data(dipper)
ddl=make.design.data(dipper.proc)
df=data.frame(time=c(1:7),effort=c(10,5,2,8,1,2,3))
# note that the value for time 1 is superfluous for CJS but not for POPAN
# the value 10 will not appear in the summary because there is no p for time 1
summary(ddl$p)
ddl$p=merge_design.covariates(ddl$p,df)
summary(ddl$p)
#Statement below will create an error because a value for time 7 not given
#ddl=merge.occasion.data(dipper.proc,ddl,"p",data.frame(time=c(1:6),effort=c(10,5,2,8,1,2)))
#
# Assign group-specific values
#
dipper.proc=process.data(dipper,groups="sex")
ddl=make.design.data(dipper.proc)
df=data.frame(group=c(rep("Female",6),rep("Male",6)),time=rep(c(2:7),2),
		effort=c(10,5,2,8,1,2,3,20,10,4,16,2))
merge_design.covariates(ddl$p,df,bygroup=TRUE)

</code></pre>

<hr>
<h2 id='mixed.model.admb'>Mixed effect model contstruction</h2><span id='topic+mixed.model.admb'></span><span id='topic+mixed.model'></span><span id='topic+mixed.model.dat'></span><span id='topic+reindex'></span>

<h3>Description</h3>

<p>Functions that develop structures needed for a mixed effect model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixed.model.admb(formula,data)

       mixed.model(formula,data,indices=FALSE)

       mixed.model.dat(x,con,idonly,n)

       reindex(x,id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixed.model.admb_+3A_formula">formula</code></td>
<td>
<p>formula for mixed effect mode in the form used in lme4; ~fixed +(re1|g1) +...+(ren|gn)</p>
</td></tr>
<tr><td><code id="mixed.model.admb_+3A_data">data</code></td>
<td>
<p>dataframe used to construct the design matrices from the formula</p>
</td></tr>
<tr><td><code id="mixed.model.admb_+3A_x">x</code></td>
<td>
<p>list structure created by mixed.model.admb</p>
</td></tr>
<tr><td><code id="mixed.model.admb_+3A_con">con</code></td>
<td>
<p>connection to data file which contents will be appended</p>
</td></tr>
<tr><td><code id="mixed.model.admb_+3A_id">id</code></td>
<td>
<p>vector of factor values used to split the data up by individual capture history</p>
</td></tr>
<tr><td><code id="mixed.model.admb_+3A_idonly">idonly</code></td>
<td>
<p>TRUE, if random effects not crossed</p>
</td></tr>
<tr><td><code id="mixed.model.admb_+3A_n">n</code></td>
<td>
<p>number of capture history records</p>
</td></tr>
<tr><td><code id="mixed.model.admb_+3A_indices">indices</code></td>
<td>
<p>if TRUE, outputs structure with indices into dm for random effects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>mixed.model.admb - creates design matrices and supporting index matrices
for use of mixed model in ADMB
</p>
<p>mixed.model - creates design matrices and supporting index matrices
in an alternate list format that is not as easily used in ADMB
</p>
<p>mixed.model.dat - writes to data file (con) for fixed and random effect stuctures
</p>
<p>reindex - creates indices for random effects that are specific to the individual capture
history; it takes re.indices, splits them by id and creates
a ragged array by id (used.indices) with the unique values for that id. index.counts is the number
of indices per id to read in ragged array. It then changes re.indices to be an index
to the indices within the id from 1 to the number of indices within the id.
</p>


<h3>Value</h3>

<p>mixed.model.admb returns a list with elements re.dm, a combined design matrix for all of the random effects; and 
re.indices, matrix of indices into a single vector of random effects to be applied to the 
design matrix location.
mixed.model returns a list (re.list) with an element for each random effect structure. The contents
are a standard design matrix (re.dm) if indices==FALSE and a re.dm and re.indices which matches the 
structure of mixed.model.admb. mixed.model will be more useful with R than ADMB.
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>

<hr>
<h2 id='mscjs'>Fitting function for Multistate CJS models</h2><span id='topic+mscjs'></span>

<h3>Description</h3>

<p>A function for computing MLEs for a Multi-state Cormack-Jolly-Seber open
population capture-recapture model for processed dataframe <code>x</code> with
user specified formulas in <code>parameters</code> that create list of design
matrices <code>dml</code>. This function can be called directly but is most easily
called from <code><a href="#topic+crm">crm</a></code> that sets up needed arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mscjs(
  x,
  ddl,
  dml,
  model_data = NULL,
  parameters,
  accumulate = TRUE,
  initial = NULL,
  method,
  hessian = FALSE,
  debug = FALSE,
  chunk_size = 1e+07,
  refit,
  itnmax = NULL,
  control = NULL,
  scale,
  re = FALSE,
  compile = FALSE,
  extra.args = "",
  clean = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mscjs_+3A_x">x</code></td>
<td>
<p>processed dataframe created by process.data</p>
</td></tr>
<tr><td><code id="mscjs_+3A_ddl">ddl</code></td>
<td>
<p>list of dataframes for design data; created by call to
<code><a href="#topic+make.design.data">make.design.data</a></code></p>
</td></tr>
<tr><td><code id="mscjs_+3A_dml">dml</code></td>
<td>
<p>list of design matrices created by <code><a href="#topic+create.dm">create.dm</a></code> from
formula and design data</p>
</td></tr>
<tr><td><code id="mscjs_+3A_model_data">model_data</code></td>
<td>
<p>a list of all the relevant data for fitting the model including
imat, S.dm,p.dm,Psi.dm,S.fixed,p.fixed,Psi.fixed and time.intervals. It is used to save values
and avoid accumulation again if the model was re-rerun with an additional call to cjs when
using autoscale or re-starting with initial values.  It is stored with returned model object.</p>
</td></tr>
<tr><td><code id="mscjs_+3A_parameters">parameters</code></td>
<td>
<p>equivalent to <code>model.parameters</code> in <code><a href="#topic+crm">crm</a></code></p>
</td></tr>
<tr><td><code id="mscjs_+3A_accumulate">accumulate</code></td>
<td>
<p>if TRUE will accumulate capture histories with common
value and with a common design matrix for S and p to speed up execution</p>
</td></tr>
<tr><td><code id="mscjs_+3A_initial">initial</code></td>
<td>
<p>list of initial values for parameters if desired; if each is a named vector
from previous run it will match to columns with same name</p>
</td></tr>
<tr><td><code id="mscjs_+3A_method">method</code></td>
<td>
<p>method to use for optimization; see <code>optim</code></p>
</td></tr>
<tr><td><code id="mscjs_+3A_hessian">hessian</code></td>
<td>
<p>if TRUE will compute and return the hessian</p>
</td></tr>
<tr><td><code id="mscjs_+3A_debug">debug</code></td>
<td>
<p>if TRUE will print out information for each iteration</p>
</td></tr>
<tr><td><code id="mscjs_+3A_chunk_size">chunk_size</code></td>
<td>
<p>specifies amount of memory to use in accumulating capture
histories; amount used is 8*chunk_size/1e6 MB (default 80MB)</p>
</td></tr>
<tr><td><code id="mscjs_+3A_refit">refit</code></td>
<td>
<p>non-zero entry to refit</p>
</td></tr>
<tr><td><code id="mscjs_+3A_itnmax">itnmax</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="mscjs_+3A_control">control</code></td>
<td>
<p>control string for optimization functions</p>
</td></tr>
<tr><td><code id="mscjs_+3A_scale">scale</code></td>
<td>
<p>vector of scale values for parameters</p>
</td></tr>
<tr><td><code id="mscjs_+3A_re">re</code></td>
<td>
<p>if TRUE creates random effect model admbcjsre.tpl and runs admb optimizer</p>
</td></tr>
<tr><td><code id="mscjs_+3A_compile">compile</code></td>
<td>
<p>if TRUE forces re-compilation of tpl file</p>
</td></tr>
<tr><td><code id="mscjs_+3A_extra.args">extra.args</code></td>
<td>
<p>optional character string that is passed to admb</p>
</td></tr>
<tr><td><code id="mscjs_+3A_clean">clean</code></td>
<td>
<p>if TRUE, deletes the tpl and executable files for amdb</p>
</td></tr>
<tr><td><code id="mscjs_+3A_...">...</code></td>
<td>
<p>not currently used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is easiest to call <code>mscjs</code> through the function <code><a href="#topic+crm">crm</a></code>.
Details are explained there.
</p>


<h3>Value</h3>

<p>The resulting value of the function is a list with the class of
crm,cjs such that the generic functions print and coef can be used.
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>named vector of parameter estimates</p>
</td></tr> <tr><td><code>lnl</code></td>
<td>
<p>-2*log
likelihood</p>
</td></tr> <tr><td><code>AIC</code></td>
<td>
<p>lnl + 2* number of parameters</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>result from <code>optim</code>; if 0 <code>optim</code> thinks it
converged</p>
</td></tr> <tr><td><code>count</code></td>
<td>
<p><code>optim</code> results of number of function
evaluations</p>
</td></tr> <tr><td><code>reals</code></td>
<td>
<p>dataframe of data and real S and p estimates for
each animal-occasion excluding those that occurred before release</p>
</td></tr>
<tr><td><code>vcv</code></td>
<td>
<p>var-cov matrix of betas if hessian=TRUE was set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>References</h3>

<p>Ford, J. H., M. V. Bravington, and J. Robbins. 2012. Incorporating individual variability into mark-recapture models. Methods in Ecology and Evolution 3:1047-1054.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# this example requires admb
# The same example is in the RMark package and it is included here to
# illustrate the differences in the handling of mlogit parameters between RMark 
# and marked.  The MARK software handles parameters like Psi which must sum to 1
# by excluding one of the cells that is used as a reference cell and is computed by
# subtracting the other cell values from 1 so the total sums to 1.  This is often
# handled with an mlogit parameter in which the cell values are exp(beta) and the
# reference cell is set to 1 and the values are divided by the sum across the cells
# so the resulting values are probabilities that sum to 1. In marked, instead of removing
# one of the cells, all are included and the user must select which should be the
# reference cell by setting the value fix=1 for that cell and others are NA so they are
# estimated. For transition parameters like Psi, the default design data is setup so 
# that the probability of remaining in the cell (stratum=tostratum) is the reference cell
# and fix set to 1.  Thus, this means 2 changes are needed to the script in RMark.
# The first is to remove the statement skagit.ddl$Psi$fix=NA because that over-rides
# the default fix values.  The other is to add
# skagit.ddl$Psi$fix[skagit.ddl$Psi$stratum=="B"&amp;skagit.ddl$Psi$tostratum=="B"&amp;
#  skagit.ddl$Psi$time==5]=0
# to change the value from 1 to 0 which forces movement from B to A in the interval 5 to 6. If
# this is not done then Psi B to B=Psi B to A=0.5 because each is 1 and when they are normalized
# they are divided by the sum which is 2 (1/2).
if(!is(try(setup_admb("mscjs")),"try-error"))
{
data(skagit)
skagit.processed=process.data(skagit,model="Mscjs",groups=c("tag"),strata.labels=c("A","B"))
skagit.ddl=make.design.data(skagit.processed)
#
# p
#
# Can't be seen at 5A or 2B,6B (the latter 2 don't exist)
skagit.ddl$p$fix=ifelse((skagit.ddl$p$stratum=="A"&amp;skagit.ddl$p$time==5) | 
(skagit.ddl$p$stratum=="B"&amp;skagit.ddl$p$time%in%c(2,6)),0,NA)
# Estimated externally from current data to allow estimation of survival at last interval
skagit.ddl$p$fix[skagit.ddl$p$tag=="v7"&amp;skagit.ddl$p$time==6&amp;skagit.ddl$p$stratum=="A"]=0.687
skagit.ddl$p$fix[skagit.ddl$p$tag=="v9"&amp;skagit.ddl$p$time==6&amp;skagit.ddl$p$stratum=="A"]=0.975
#
# Psi
#
# only 3 possible transitions are A to B at time interval 2 to 3 and 
# for time interval 3 to 4 from A to B and from B to A
# rest are fixed values
############ change for RMark to marked; remove next line
#skagit.ddl$Psi$fix=NA
# stay in A for intervals 1-2, 4-5 and 5-6
skagit.ddl$Psi$fix[skagit.ddl$Psi$stratum=="A"&amp;
 skagit.ddl$Psi$tostratum=="B"&amp;skagit.ddl$Psi$time%in%c(1,4,5)]=0
# stay in B for interval 4-5
skagit.ddl$Psi$fix[skagit.ddl$Psi$stratum=="B"&amp;skagit.ddl$Psi$tostratum=="A"
 &amp;skagit.ddl$Psi$time==4]=0
# leave B to go to A for interval 5-6
skagit.ddl$Psi$fix[skagit.ddl$Psi$stratum=="B"&amp;skagit.ddl$Psi$tostratum=="A"&amp;
skagit.ddl$Psi$time==5]=1
############ change for RMark to marked; add next line to set B to B to 0 otherwise it has
############ been set to 1 by default which would make psi B to B = psi B to A = 0.5
skagit.ddl$Psi$fix[skagit.ddl$Psi$stratum=="B"&amp;skagit.ddl$Psi$tostratum=="B"&amp;
skagit.ddl$Psi$time==5]=0
# "stay" in B for interval 1-2 and 2-3 because none will be in B
skagit.ddl$Psi$fix[skagit.ddl$Psi$stratum=="B"&amp;skagit.ddl$Psi$tostratum=="A"&amp;
skagit.ddl$Psi$time%in%1:2]=0
# 
# S
#
# None in B, so fixing S to 1
skagit.ddl$S$fix=ifelse(skagit.ddl$S$stratum=="B"&amp;skagit.ddl$S$time%in%c(1,2),1,NA)
skagit.ddl$S$fix[skagit.ddl$S$stratum=="A"&amp;skagit.ddl$S$time==4]=1
# fit model
p.timexstratum.tag=list(formula=~time:stratum+tag,remove.intercept=TRUE)
Psi.sxtime=list(formula=~-1+stratum:time)
S.stratumxtime=list(formula=~-1+stratum:time)
#
mod1=crm(skagit.processed,skagit.ddl,
model.parameters=list(S=S.stratumxtime,p= p.timexstratum.tag,Psi=Psi.sxtime),hessian=TRUE)
if(!is(mod1,"try-error")) mod1
} 
</code></pre>

<hr>
<h2 id='mscjs_tmb'>Fitting function for Multistate CJS models with TMB</h2><span id='topic+mscjs_tmb'></span>

<h3>Description</h3>

<p>A function for computing MLEs for a Multi-state Cormack-Jolly-Seber open
population capture-recapture model for processed dataframe <code>x</code> with
user specified formulas in <code>parameters</code> that create list of design
matrices <code>dml</code>. This function can be called directly but is most easily
called from <code><a href="#topic+crm">crm</a></code> that sets up needed arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mscjs_tmb(
  x,
  ddl,
  fullddl,
  dml,
  model_data = NULL,
  parameters,
  accumulate = TRUE,
  initial = NULL,
  method,
  hessian = FALSE,
  debug = FALSE,
  chunk_size = 1e+07,
  refit,
  itnmax = NULL,
  control = NULL,
  scale,
  re = FALSE,
  compile = FALSE,
  extra.args = "",
  clean = TRUE,
  getreals = FALSE,
  useHess = FALSE,
  savef = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mscjs_tmb_+3A_x">x</code></td>
<td>
<p>processed dataframe created by process.data</p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_ddl">ddl</code></td>
<td>
<p>list of simplified dataframes for design data; created by call to
<code><a href="#topic+make.design.data">make.design.data</a></code></p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_fullddl">fullddl</code></td>
<td>
<p>list of complete dataframes for design data; created by call to
<code><a href="#topic+make.design.data">make.design.data</a></code></p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_dml">dml</code></td>
<td>
<p>list of design matrices created by <code><a href="#topic+create.dm">create.dm</a></code> from
formula and design data</p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_model_data">model_data</code></td>
<td>
<p>a list of all the relevant data for fitting the model including
imat, S.dm,p.dm,Psi.dm,S.fixed,p.fixed,Psi.fixed and time.intervals. It is used to save values
and avoid accumulation again if the model was re-rerun with an additional call to cjs when
using autoscale or re-starting with initial values.  It is stored with returned model object.</p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_parameters">parameters</code></td>
<td>
<p>equivalent to <code>model.parameters</code> in <code><a href="#topic+crm">crm</a></code></p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_accumulate">accumulate</code></td>
<td>
<p>if TRUE will accumulate capture histories with common
value and with a common design matrix all parameters to speed up execution</p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_initial">initial</code></td>
<td>
<p>list of initial values for parameters if desired; if each is a named vector
from previous run it will match to columns with same name</p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_method">method</code></td>
<td>
<p>method to use for optimization; see <code>optim</code></p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_hessian">hessian</code></td>
<td>
<p>if TRUE will compute and return the hessian</p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_debug">debug</code></td>
<td>
<p>if TRUE will print out information for each iteration</p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_chunk_size">chunk_size</code></td>
<td>
<p>specifies amount of memory to use in accumulating capture
histories; amount used is 8*chunk_size/1e6 MB (default 80MB)</p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_refit">refit</code></td>
<td>
<p>non-zero entry to refit</p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_itnmax">itnmax</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_control">control</code></td>
<td>
<p>control string for optimization functions</p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_scale">scale</code></td>
<td>
<p>vector of scale values for parameters</p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_re">re</code></td>
<td>
<p>if TRUE creates random effect model admbcjsre.tpl and runs admb optimizer</p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_compile">compile</code></td>
<td>
<p>if TRUE forces re-compilation of tpl file</p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_extra.args">extra.args</code></td>
<td>
<p>optional character string that is passed to tmb</p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_clean">clean</code></td>
<td>
<p>if TRUE, deletes the dll and recompiles</p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_getreals">getreals</code></td>
<td>
<p>if TRUE, compute real values and std errors for TMB models; may want to set as FALSE until model selection is complete</p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_usehess">useHess</code></td>
<td>
<p>if TRUE, the TMB hessian function is used for optimization; using hessian is typically slower with many parameters but can result in a better solution</p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_savef">savef</code></td>
<td>
<p>if TRUE, save the makeAdFun result from TMB to report real values and matrices</p>
</td></tr>
<tr><td><code id="mscjs_tmb_+3A_...">...</code></td>
<td>
<p>not currently used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is easiest to call <code>mscjs_tmb</code> through the function <code><a href="#topic+crm">crm</a></code>.
Details are explained there.
</p>


<h3>Value</h3>

<p>The resulting value of the function is a list with the class of
crm,cjs such that the generic functions print and coef can be used.
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>named vector of parameter estimates</p>
</td></tr> <tr><td><code>lnl</code></td>
<td>
<p>-2*log
likelihood</p>
</td></tr> <tr><td><code>AIC</code></td>
<td>
<p>lnl + 2* number of parameters</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>result from <code>optim</code>; if 0 <code>optim</code> thinks it
converged</p>
</td></tr> <tr><td><code>count</code></td>
<td>
<p><code>optim</code> results of number of function
evaluations</p>
</td></tr> <tr><td><code>reals</code></td>
<td>
<p>dataframe of data and real S and p estimates for
each animal-occasion excluding those that occurred before release</p>
</td></tr>
<tr><td><code>vcv</code></td>
<td>
<p>var-cov matrix of betas if hessian=TRUE was set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeff Laak
</p>


<h3>References</h3>

<p>Ford, J. H., M. V. Bravington, and J. Robbins. 2012. Incorporating individual variability into mark-recapture models. Methods in Ecology and Evolution 3:1047-1054.
</p>

<hr>
<h2 id='msld_tmb'>Fitting function for Multistate CJS live-dead models with TMB</h2><span id='topic+msld_tmb'></span>

<h3>Description</h3>

<p>A function for computing MLEs for a Multi-state Cormack-Jolly-Seber open
population capture-recapture with dead recoveries for processed dataframe <code>x</code> with
user specified formulas in <code>parameters</code> that create list of design
matrices <code>dml</code>. This function can be called directly but is most easily
called from <code><a href="#topic+crm">crm</a></code> that sets up needed arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msld_tmb(
  x,
  ddl,
  dml,
  model_data = NULL,
  parameters,
  accumulate = TRUE,
  initial = NULL,
  method,
  hessian = FALSE,
  debug = FALSE,
  chunk_size = 1e+07,
  refit,
  itnmax = NULL,
  control = NULL,
  scale,
  re = FALSE,
  compile = FALSE,
  extra.args = "",
  clean = FALSE,
  getreals = FALSE,
  useHess = FALSE,
  savef = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msld_tmb_+3A_x">x</code></td>
<td>
<p>processed dataframe created by process.data</p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_ddl">ddl</code></td>
<td>
<p>list of simplified dataframes for design data; created by call to
<code><a href="#topic+make.design.data">make.design.data</a></code></p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_dml">dml</code></td>
<td>
<p>list of design matrices created by <code><a href="#topic+create.dm">create.dm</a></code> from
formula and design data</p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_model_data">model_data</code></td>
<td>
<p>a list of all the relevant data for fitting the model including
imat, S.dm,r.dm,p.dm,Psi.dm,S.fixed,r.fixed,p.fixed,Psi.fixed and time.intervals. It is used to save values
and avoid accumulation again if the model was re-rerun with an additional call to cjs when
using autoscale or re-starting with initial values.  It is stored with returned model object.</p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_parameters">parameters</code></td>
<td>
<p>equivalent to <code>model.parameters</code> in <code><a href="#topic+crm">crm</a></code></p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_accumulate">accumulate</code></td>
<td>
<p>if TRUE will accumulate capture histories with common
value and with a common design matrix for all parameters speed up execution</p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_initial">initial</code></td>
<td>
<p>list of initial values for parameters if desired; if each is a named vector
from previous run it will match to columns with same name</p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_method">method</code></td>
<td>
<p>method to use for optimization; see <code>optim</code></p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_hessian">hessian</code></td>
<td>
<p>if TRUE will compute and return the hessian</p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_debug">debug</code></td>
<td>
<p>if TRUE will print out information for each iteration</p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_chunk_size">chunk_size</code></td>
<td>
<p>specifies amount of memory to use in accumulating capture
histories; amount used is 8*chunk_size/1e6 MB (default 80MB)</p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_refit">refit</code></td>
<td>
<p>non-zero entry to refit</p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_itnmax">itnmax</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_control">control</code></td>
<td>
<p>control string for optimization functions</p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_scale">scale</code></td>
<td>
<p>vector of scale values for parameters</p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_re">re</code></td>
<td>
<p>if TRUE creates random effect model admbcjsre.tpl and runs admb optimizer</p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_compile">compile</code></td>
<td>
<p>if TRUE forces re-compilation of tpl file</p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_extra.args">extra.args</code></td>
<td>
<p>optional character string that is passed to tmb</p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_clean">clean</code></td>
<td>
<p>if TRUE, deletes the dll and recompiles</p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_getreals">getreals</code></td>
<td>
<p>if TRUE, compute real values and std errors for TMB models; may want to set as FALSE until model selection is complete</p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_usehess">useHess</code></td>
<td>
<p>if TRUE, the TMB hessian function is used for optimization; using hessian is typically slower with many parameters but can result in a better solution</p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_savef">savef</code></td>
<td>
<p>if TRUE, save optimization function in model for reporting</p>
</td></tr>
<tr><td><code id="msld_tmb_+3A_...">...</code></td>
<td>
<p>not currently used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is easiest to call <code>msld_tmb</code> through the function <code><a href="#topic+crm">crm</a></code>.
Details are explained there.
</p>


<h3>Value</h3>

<p>The resulting value of the function is a list with the class of
crm,cjs such that the generic functions print and coef can be used.
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>named vector of parameter estimates</p>
</td></tr> <tr><td><code>lnl</code></td>
<td>
<p>-2*log
likelihood</p>
</td></tr> <tr><td><code>AIC</code></td>
<td>
<p>lnl + 2* number of parameters</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>result from <code>optim</code>; if 0 <code>optim</code> thinks it
converged</p>
</td></tr> <tr><td><code>count</code></td>
<td>
<p><code>optim</code> results of number of function
evaluations</p>
</td></tr> <tr><td><code>reals</code></td>
<td>
<p>dataframe of data and real S and p estimates for
each animal-occasion excluding those that occurred before release</p>
</td></tr>
<tr><td><code>vcv</code></td>
<td>
<p>var-cov matrix of betas if hessian=TRUE was set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeff Laak
</p>

<hr>
<h2 id='mstrata'>Multistrata example data</h2><span id='topic+mstrata'></span>

<h3>Description</h3>

<p>An example data set which appears to be simulated data that accompanies MARK
as an example analysis using the Multistrata model.
</p>


<h3>Format</h3>

<p>A data frame with 255 observations on the following 2 variables.
</p>
 <dl>
<dt>ch</dt><dd><p>a character vector containing the encounter history of
each bird with strata</p>
</dd> <dt>freq</dt><dd><p>the number of birds with that capture
history</p>
</dd> </dl>



<h3>Details</h3>

<p>This is a data set that accompanies program MARK as an example for the
Multistrata model and is also in the RMark pacakge. Here I use it to show the 
3 ways models can be fitted to multistrata data. The model MSCJS is not run because it
requires ADMB or the exe constructed from ADMB which is not available if downloaded from CRAN.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mstrata)
ms1=process.data(mstrata,model="MSCJS",strata.labels=c("A","B","C"))
ms1.ddl=make.design.data(ms1)
# following requires ADMB or the exe constructed from ADMB and links set for ADMB
# remove comments if you have admb
#mod1=try(crm(ms1,ms1.ddl,model.parameters=list(Psi=list(formula=~-1+stratum:tostratum),
#                                               p=list(formula=~time)),hessian=TRUE))
#mod1
# file.remove("multistate.std")
ms2=process.data(mstrata,model="hmmMSCJS",strata.labels=c("A","B","C"))
ms2.ddl=make.design.data(ms2)
# uses R/Fortran code with hmmMSCJS
mod2=crm(ms2,ms2.ddl,model.parameters=list(Psi=list(formula=~-1+stratum:tostratum),
                                           p=list(formula=~time)),hessian=TRUE)
mod2
# strata.labels for MVMS models must be specified as a list because more than one variable
# can be used
ms3=process.data(mstrata,model="MVMSCJS",strata.labels=list(state=c("A","B","C")))
ms3.ddl=make.design.data(ms3)
ms3.ddl$delta$fix=1
# uses R/Fortran code with MVMSCJS
mod3=crm(ms3,ms3.ddl,model.parameters=list(Psi=list(formula=~-1+stratum:tostratum),
                                           p=list(formula=~time)),hessian=TRUE)
mod3
# requires admb; remove comments if you have admb
#mod4=crm(ms3,ms3.ddl,model.parameters=list(Psi=list(formula=~-1+stratum:tostratum),
#                                           p=list(formula=~time)),hessian=TRUE,use.admb=TRUE)
#mod4
#file.remove("mvms.std")
# uses TMB with mvmscjs -remove comment to use
#mod5=crm(ms3,ms3.ddl,model.parameters=list(Psi=list(formula=~-1+stratum:tostratum),
#                                          p=list(formula=~time)),hessian=TRUE,use.tmb=TRUE)
#mod5
unlink("*.cpp")
unlink("*.o")
unlink("symbols.rds")

</code></pre>

<hr>
<h2 id='mvms_design_data'>Multivariate Multistate (mvms) Design Data</h2><span id='topic+mvms_design_data'></span>

<h3>Description</h3>

<p>Creates a dataframe with design data for MvMS model for a single occasion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvms_design_data(df.states, df = NULL, transition = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvms_design_data_+3A_df.states">df.states</code></td>
<td>
<p>dataframe of states created from set_mvms</p>
</td></tr>
<tr><td><code id="mvms_design_data_+3A_df">df</code></td>
<td>
<p>is dataframe of observations; provided for parameter delta in which both state and observation are needed in design data</p>
</td></tr>
<tr><td><code id="mvms_design_data_+3A_transition">transition</code></td>
<td>
<p>if TRUE, creates design data for a state transition (from to); otherwise just state variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe to be used with design data for mvms model
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=set_mvms(list(location=c("A","B","C"),repro_status=c("N","P","u")))
mvms_design_data(x$df.states)
mvms_design_data(x$df.states,transition=FALSE)

</code></pre>

<hr>
<h2 id='mvms_dmat'>HMM Observation Probability matrix functions</h2><span id='topic+mvms_dmat'></span><span id='topic+cjs_dmat'></span><span id='topic+ms_dmat'></span><span id='topic+ums_dmat'></span><span id='topic+ums2_dmat'></span>

<h3>Description</h3>

<p>Functions that compute the probability matrix of the observations given the state for various models. 
Currently only CJS, MS models and MS models with state uncertainty are included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvms_dmat(pars, m, F, T, sup)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvms_dmat_+3A_pars">pars</code></td>
<td>
<p>list of real parameter matrices (id by occasion) for each type of parameter</p>
</td></tr>
<tr><td><code id="mvms_dmat_+3A_m">m</code></td>
<td>
<p>number of states</p>
</td></tr>
<tr><td><code id="mvms_dmat_+3A_f">F</code></td>
<td>
<p>initial occasion vector</p>
</td></tr>
<tr><td><code id="mvms_dmat_+3A_t">T</code></td>
<td>
<p>number of occasions</p>
</td></tr>
<tr><td><code id="mvms_dmat_+3A_sup">sup</code></td>
<td>
<p>list of supplemental information that may be needed by the function but only needs to be computed once</p>
</td></tr>
</table>


<h3>Value</h3>

<p>4-d array of id and occasion-specific observation probability matrices - state-dependent distributions in Zucchini and MacDonald (2009)
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>References</h3>

<p>Zucchini, W. and I.L. MacDonald. 2009. Hidden Markov Models for Time Series: An Introduction using R. Chapman and Hall, Boca Raton, FL. 275p.
</p>

<hr>
<h2 id='mvmscjs'>Fitting function for Multivariate Multistate CJS with uncertainty models</h2><span id='topic+mvmscjs'></span>

<h3>Description</h3>

<p>A function for computing MLEs for MVMS models following Johnson et al (2015)  via ADMB. It works very much like mscjs but with more parameters. While this function is for fitting the model via ADMB, the
documentation contained here is also relevant when this type of model is fitted with optimx and FORTRAN code (use.admb=F).
</p>
<p>It is easiest to call this function or any model built in <code>marked</code> through the function <code><a href="#topic+crm">crm</a></code>.
This function has been exported but to fit a model it should be called through the crm function
which does some testing of the arguments to avoid errors and sets up the calling arguments appropriately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvmscjs(
  x,
  ddl,
  fullddl,
  dml,
  model_data = NULL,
  parameters,
  accumulate = TRUE,
  initial = NULL,
  method,
  hessian = FALSE,
  debug = FALSE,
  chunk_size = 1e+07,
  refit,
  itnmax = NULL,
  control = NULL,
  scale,
  re = FALSE,
  compile = FALSE,
  extra.args = "",
  clean = TRUE,
  sup,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvmscjs_+3A_x">x</code></td>
<td>
<p>processed dataframe created by process.data</p>
</td></tr>
<tr><td><code id="mvmscjs_+3A_ddl">ddl</code></td>
<td>
<p>list of dataframes for design data; created by call to
<code><a href="#topic+make.design.data">make.design.data</a></code> and then simplified</p>
</td></tr>
<tr><td><code id="mvmscjs_+3A_fullddl">fullddl</code></td>
<td>
<p>list of dataframes for design data prior to simplification</p>
</td></tr>
<tr><td><code id="mvmscjs_+3A_dml">dml</code></td>
<td>
<p>list of design matrices created by <code><a href="#topic+create.dm">create.dm</a></code> from
formula and design data</p>
</td></tr>
<tr><td><code id="mvmscjs_+3A_model_data">model_data</code></td>
<td>
<p>a list of all the relevant data for fitting the model including
imat, Phi.dm,p.dm,Psi.dm,Phi.fixed,p.fixed,Psi.fixed and time.intervals. It is used to save values
and avoid accumulation again if the model was re-rerun with an additional call to cjs when
using autoscale or re-starting with initial values.  It is stored with returned model object.</p>
</td></tr>
<tr><td><code id="mvmscjs_+3A_parameters">parameters</code></td>
<td>
<p>equivalent to <code>model.parameters</code> in <code><a href="#topic+crm">crm</a></code></p>
</td></tr>
<tr><td><code id="mvmscjs_+3A_accumulate">accumulate</code></td>
<td>
<p>if TRUE will accumulate capture histories with common
value and with a common design matrix for S and p to speed up execution</p>
</td></tr>
<tr><td><code id="mvmscjs_+3A_initial">initial</code></td>
<td>
<p>list of initial values for parameters if desired; if each is a named vector
from previous run it will match to columns with same name</p>
</td></tr>
<tr><td><code id="mvmscjs_+3A_method">method</code></td>
<td>
<p>method to use for optimization; see <code>optim</code></p>
</td></tr>
<tr><td><code id="mvmscjs_+3A_hessian">hessian</code></td>
<td>
<p>if TRUE will compute and return the hessian</p>
</td></tr>
<tr><td><code id="mvmscjs_+3A_debug">debug</code></td>
<td>
<p>if TRUE will print out information for each iteration</p>
</td></tr>
<tr><td><code id="mvmscjs_+3A_chunk_size">chunk_size</code></td>
<td>
<p>specifies amount of memory to use in accumulating capture
histories; amount used is 8*chunk_size/1e6 MB (default 80MB)</p>
</td></tr>
<tr><td><code id="mvmscjs_+3A_refit">refit</code></td>
<td>
<p>non-zero entry to refit</p>
</td></tr>
<tr><td><code id="mvmscjs_+3A_itnmax">itnmax</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="mvmscjs_+3A_control">control</code></td>
<td>
<p>control string for optimization functions</p>
</td></tr>
<tr><td><code id="mvmscjs_+3A_scale">scale</code></td>
<td>
<p>vector of scale values for parameters</p>
</td></tr>
<tr><td><code id="mvmscjs_+3A_re">re</code></td>
<td>
<p>if TRUE creates random effect model admbcjsre.tpl and runs admb optimizer</p>
</td></tr>
<tr><td><code id="mvmscjs_+3A_compile">compile</code></td>
<td>
<p>if TRUE forces re-compilation of tpl file</p>
</td></tr>
<tr><td><code id="mvmscjs_+3A_extra.args">extra.args</code></td>
<td>
<p>optional character string that is passed to admb if use.admb==TRUE</p>
</td></tr>
<tr><td><code id="mvmscjs_+3A_clean">clean</code></td>
<td>
<p>if TRUE, deletes the tpl and executable files for amdb if use.admb=T</p>
</td></tr>
<tr><td><code id="mvmscjs_+3A_sup">sup</code></td>
<td>
<p>supplemental index values for constructing mvms model</p>
</td></tr>
<tr><td><code id="mvmscjs_+3A_...">...</code></td>
<td>
<p>not currently used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mvmscjs model is quite flexible but also quite complex. Prior to using this model, read Johnson et al. (2015) 
and particularly Supplement B which goes through the code used in the analysis of Johnson et al. (2015).
Supplement B is useful but there have been a number of changes to the code since the paper was written and it is far from complete.
The documentation here will fill in some of those blanks.
</p>
<p>There are 5 classes of parameters in an mvms model. They are 1)Phi - survival probability, 2) p-capture probability, 3) Psi - state transition
probabilities, 4) delta - certainty/uncertainty state probabilities, 5) pi - initial state probability. The final
class pi was described in Johnson et al. (2015) but was not implemented in <code>marked</code> at the time the paper was written. However, with 
the sealions example, the initial state is known for all releases and pi is not relevant.
</p>
<p>Before I jump into a description of each parameter, I'll describe some characteristics that are common to all of the 
parameters. First, all of the parameters are probabilities and thus must be in the unit interval. To accomplish this
each of the parameters uses either a logit or mlogit (multinomial logit) link function.
</p>
<p>A logit link is log(theta/(1-theta))= a+bx... where theta is the probability (called a real parameter in <code>MARK</code> terminology) 
and a+bx... is the set of covariates (e.g. x) and working parameters (a,b) that are unbounded.  Working parameters are called beta parameters in 
<code>MARK</code> terminology. The inverse logit link is  1/(1+exp(-a-bx)) for this simple example and it can be computed from
the plogis function in R (plogis(a+bx)). A largish negative value of the link (eg -5) mean theta will be nearly 0 and
and a largish positive value (+5) means theta is nearly 1.
</p>
<p>The mlogit link is simply an extension of the logit link for more than 2 classes.  For example, the logit link for survival is
for the 2 classes alive/dead.  I'll use the logit link as a simple example to describe the way mlogit links are formed in <code>marked</code>.
If survival is Phi=1/(1+exp(-a))=exp(a)/(1+exp(a)) then mortality is 1-Phi = 1-exp(a)/(1+exp(a))= 1/(1+exp(a)). Imagine that we
have 2 link values a - for survival and b - for mortality.  Then we can rewrite the inverse logit function for Phi as exp(a)/(exp(b)+exp(a))
and then 1-Phi = exp(b)/(exp(b)+exp(a)). It is obvious that Phi+1-Phi=1 which must be the case.  Now, if you actually tried to fit a model
with both a and b the parameters a and b are not uniquely identifiable because there is only one parameter Phi. One of the values must be a 
reference cell which means the value is fixed.  Typically we assume b=0 which yields exp(0)=1 and we get the logit link.
</p>
<p>Now consider 3 classes (A,B,C) and we'll use the link values a,b,c for a generic parameter theta. As with the 2 class example, the
probabilities are theta(A)=exp(a)/(exp(a)+exp(b)+exp(c)),  theta(B)=exp(b)/(exp(a)+exp(b)+exp(c)) and theta(C)=exp(c)/(exp(a)+exp(b)+exp(c)).
As before theta(A)+theta(B)+theta(C)=1 but for a multinomial with 3 classes there are only 2 free estimable parameters due to the constraint that they have to sum to 1.
Just as with the example above, a reference cell must be selected.  If we chose B as the reference cell then b=0 and the probabilities become
theta(A)=exp(a)/(exp(a)+1+exp(c)),  theta(B)=1/(exp(a)+1+exp(c)) and theta(C)=exp(c)/(exp(a)+1+exp(c)). This extends to an k-class multinomial where
k-1 parameters are freely estimable and 1 must be fixed.
</p>
<p>For parameters with logit links there is an obvious choice for the reference cell.  For example, for survival probability we are interested in
describing the parameters that affect survival, so we use death as the reference cell which is computed by subtraction (1-Phi). Likewise, for
capture (sighting) probability we use not caught (1-p) as the reference cell.  For mlogit links, there is not always an obvious choice for a
reference cell and it can be an advantageous to allow the reference cell to be flexible and user-defined.
</p>
<p>To understand how to set the reference cell, you should review the material in the help file for create.dmdf and Supplement B of Johnson et al. (2015) 
which describes the design data but I'll give a brief description here. All model building in the <code>marked</code> package revolves around the design data. 
If the design data are incorrect the model will be incorrect. Briefly, the design data contain the data for the parameter model, 
providing the maximum structure from which specific models can be built.. For example, for p there are M-1 records for each of the I individuals and M occasions
(note that if the data are accumulated then an &quot;individual&quot; is actually a unique set of capture history and covariate data that represents &quot;freq&quot; animals). 
Thus, capture probability could be allowed to differ for each occasion, individual, age, strata, or any combination thereof.  In practice, such a model would
be overparameterized, but this structure allows maximum flexibility; users still need to use formula to provide specific constraints to reduce the number of 
parameters to a reasonable level. With this design data approach essentially there is a place holder for each possible p and any or all of those values 
can be fixed to a real value. 
</p>
<p>&quot;Real&quot; parameters can be fixed by adding a field called fix to the design data for a parameter. The value of fix should be either NA if 
the parameter is to be estimated or it should be the value of the real parameter (inverse link value). For example, we could fix the capture probability 
for time 2 to be 0 for all individuals at time 2 or at time 2 in strata B because there was no capture effort.  Or you could fix p=0 for an individual at a time
because it was temporarily removed. Or you could fix p=1 for a set of individuals that were always recaptured via telemetry.
</p>
<p>Now let's go back to the mlogit parameters. There is an important difference between the way <code>marked</code> and <code>RMark/MARK</code> work 
with regard to mlogit parameters like Psi for state transition probabilities. An mlogit parameter is one in which the 
sum of the probabilities is 1. For Psi, if I'm in stratum A and can go to B or C or remain in A, the probabilities A to A, A to B and A to C must sum to 1 because that is
all of the possibilities. In <code>RMark/MARK</code> the design data would only contain 2 records which are determined 
based on what you select as subtract.stratum. If subtract.stratum was set as A for the A stratum, the design 
data for Psi would only contain records for A to B and A to C. The value for A to A would be computed by 
subtraction and is the reference cell.
</p>
<p>By contrast, in <code>marked</code>, all 3 records are in the design data and to set the transition from A to A as the reference cell (computed by subtraction) 
the value of fix is set to 1. So if fix is the inverse logit value why is it being
set to 1 for the mlogit?  Because the link for these parameters is actually a log-link and the inverse link is exp(link).
So the link value is fixed to 0 and the inverse link (&quot;real value&quot;) is exp(0)=1. The mlogit parameter is constructed
by dividing each exp() value by the sum of the exp() values across the set defining the possible classes for the multinomial. 
Following along with the example, 
</p>
<pre>
Psi_AtoB=exp(beta_AtoB)/(1+exp(beta_AtoB)+exp(beta_AtoC))
Psi_AtoC=exp(beta_AtoC)/(1+exp(beta_AtoB)+exp(beta_AtoC)) and
Psi_AtoA=1-Psi_AtoB-Psi_AtoC = 1/(1+exp(beta_AtoB)+exp(beta_AtoC)). 
</pre>
<p>The &quot;appropriate&quot; set will depend on the mlogit parameter and the data/model structure.
</p>
<p>I used this structure for several reasons. First, you get a real parameter estimate for the subtracted stratum which you don't get in <code>RMark/MARK</code>. 
Secondly, you can change the value to be subtracted at will and it is not fixed across the entire model fit,
but you do have to be careful when specifying the model when you do that because the formula specifies the 
parameters for those that are not fixed. Finally, you can change the reference cell simply by modifying the value of fix, 
whereas with the subtract.stratum approach the design data would have to be recreated which can take some time with large data sets.
</p>
<p>Next I'll briefly describe each parameter in the model and its link function structure.
</p>
<p>Phi
&mdash;&ndash;
Phi is survival probability in the model. Survival probability is also called S in the straight multi-state model. In retrospect I wish I had stayed with 
S but I didn't.  In capture-recapture Phi is usually reserved for apparent survival rate which might include permanent emigration. 
With a multi-state model, the presumption is that &quot;all&quot; states are covered and animals can't emigrate permanently to some 
unobservable state.  Whether that is true or not is always a question. Anyhow I use Phi for survival in <code>mvmscjs</code> models.
</p>
<p>Phi uses a logit link (log(Phi/(1-Phi))= a+bx...) to relate survival to any covariates which have parameter values
across the entire real line.  Phi is what I call an interval parameter in that it describes the probability of surviving 
during an interval of time between sampling occasions. The design data for interval parameters are describe in terms of
the time and age of the animal at the beginning of the interval.  For example, if occasions are at time 1,2,...J there
will be J-1 data records for each individual with time values 1,...,J-1.
</p>
<p>p
&mdash;&ndash;
p is recapture/resighting probability.  While I'll often fall back and call it capture or sighting probability, technically it is
recapture or resighting because this model is based on a Cormack-Jolly-Seber (CJS) formulation which does not model initial &quot;capture&quot;
probability and only models events after they are marked and released. p also uses the logit link and it is an occasion parameter because
it describes an event associated with an occasion. Because they are &quot;recaptures&quot;, there are J-1 design data records for
each individual at times 2,...,J. 
</p>
<p>An example of using fix for p is given in the sealions example.  For the data, there was no survey effort in stratum A for the last occasion.
</p>
<pre>
ddl$p$fix = ifelse(ddl$p$Time==17 &amp; ddl$p$area=="A", 0, ddl$p$fix)
</pre>
<p>Psi
&mdash;&ndash;
Psi describes the transition probabilities of moving between states. For each individual at each occasion for each of the possible states,
it is formulated as a multinomial with a cell probability for movement from the state to all of the other possible states and remaining in the
in the same state. Thus if there are M states, then there are M*M records for each individual for each of the J-1 intervals. It is treated as
interval parameter with movement occurring between occasions but after survival.  If an animal is in state A it survives and moves to state B with
probability Phi_A*Psi_AtoB. If those were to be reversed you could use a trick proposed by Bill Kendall of adding dummy occasions between each real set
of occasions and fixing real parameters. For example using the first 2 occasions with data A0, the data would become A00 with 3 occasions. For the
first interval all the Phis would be fixed to 1 and Psi_AtoB would be estimated. For occasion 2, all the ps would be fixed to 0 because there are no observations and
for the second interval all the Psi's should be fixed so it will remain in the same state (eg. Psi_AtoA=1 and Psi_Atox=0).
</p>
<p>This can get rather involved when you have more than 1 variable describing the states which is the whole purpose of the
multi-variate multi-state model. It just needs some careful thought.  As an example, here are some of the columns of the design data for the first interval for
the first individual for stratum A&ndash; which for this example is area A with missing left and right tags. There are 8 records because
there are 8 possible strata - 2 areas *2 left tag states * 2 right tag states.
</p>
<pre>
&gt; head(ddl$Psi[,c(1:10,20),],8)
 id occ stratum tostratum area ltag rtag toarea toltag tortag fix
  1   1     A--       A--    A    -    -      A      -      -   1
  1   1     A--       A-+    A    -    -      A      -      +   0
  1   1     A--       A+-    A    -    -      A      +      -   0
  1   1     A--       A++    A    -    -      A      +      +   0
  1   1     A--       S--    A    -    -      S      -      -  NA
  1   1     A--       S-+    A    -    -      S      -      +   0
  1   1     A--       S+-    A    -    -      S      +      -   0
  1   1     A--       S++    A    -    -      S      +      +   0
</pre>
<p>When the design data are created, it creates fields based on the definition of strata.labels in the call to process.data. For this 
example it was  strata.labels=list(area=c(&quot;A&quot;,&quot;S&quot;),ltag=c(&quot;+&quot;,&quot;-&quot;,&quot;u&quot;),rtag=c(&quot;+&quot;,&quot;-&quot;,&quot;u&quot;))).  The design data include a
stratum and tostratum field which are the concatenated values of all the variables defining the states. In addition field and tofield
variables are created for each strata variables.  Here the fields are area,ltag,rtag and the tofields are toarea,toltag and tortag.
Each simply partitions the stratum and tostratum fields.  Note that if only a single variable is used to define the strata.labels the
the design data will only contain a stratum and tostratum fields.
</p>
<p>Now, when the design data are initially created for Psi, it creates the field fix and assigns the value NA to all values except for
the record in which stratum=tostratum which gets the value of fix=1 making it the reference cell. Those are the default values and it is up to you to change as needed.
In this case almost all of the Psi values are fixed to 0 because they cannot occur. The only possible movement is from A&ndash; to S&ndash; because
all of the other transitions would have it gaining tags that have already been lost.  As another example, the stratum A++ would have all of
the values of fix=NA except for tostratum=A++ which would be fixed to 1.
</p>
<p>delta
&mdash;&ndash;
delta is the probability of being certain or uncertain about each state variable for a given stratum. The definition can change based on 
how you define the reference cell. For delta, the number of records depends on the structure of strata.labels and the number of 
state variables and how many state variables can be uncertain.  Below are the design data for a single stratum for a single individual and occasion from the sealions
example.
</p>
<pre>

id occ stratum area ltag rtag obs.area obs.ltag obs.rtag obs.ltag.u obs.rtag.u
1   1     A--    A    -    -        A        -        -          0          0
1   1     A--    A    -    -        A        -        u          0          1
1   1     A--    A    -    -        A        u        -          1          0
1   1     A--    A    -    -        A        u        u          1          1
</pre>
<p>For this example, the area is certain but the left tag and right tag status can be uncertain. The above data are for the stratum
A&ndash;. Each field used to define the states has a field value and an obs.field value (eg., ltag, obs.ltag). The fields obs.ltag.u and obs.rtag.u were created in code 
after the call to make.design.data (see ?sealions). There would be a set like these for each of the 8 possible stratum value for id=1 and occ=1. Because each tag status can be either 
known or uncertain there are 2*2 records and the sum of the 4 cell probabilities must sum to 1. The easiest way to do that is
by specifying fix=1 for one of the cells and assigning the other 3 fix=NA so they are estimated. If you set fix=1 for the first record (observation A&ndash;),
then the parameters for delta are describing the probability of being uncertain. Whereas, if you set fix=1 for the fourth record (observation Auu) then
the parameters for delta are describing the probability of being certain.
</p>
<p>Now the use of fix is not required to set a reference cell because you can accomplish the same thing by defining the formula for
delta such that the link value is 0 for one of the cells.  For example, the formula for delta in the example is
</p>
<pre>
  ~ -1 + obs.ltag.u + obs.rtag.u + obs.ltag.u:obs.rtag.u)
</pre>
<p>The numeric value of obs.ltag.u + obs.rtag.u + obs.ltag.u*obs.rtag.u (: equivalent to mulitplication here) is 0 for the first record and -1 in the
formula specifies that there shouldn't be an intercept. Thus regardless of the 3 beta values for delta, the link value for the 
first record is 0 and the inverse link value is exp(0)=1 which is equivalent to setting fix=1 for the first record to set it as the reference cell.
If you run the sealions example with the current version of the software it will give the message:
</p>
<pre>
 No values provided for fix for delta. At least need to set a reference cell
</pre>
<p>Messages like this are warnings and do not stop the model from being fitted because as shown above it is possible to set the reference cell with an appropriate formula.
If a reference cell is not set the beta estimates are not all identifiable.  Symptoms include troubles with optimization, different starting values giving different
beta estimates for the parameter with the same likelihood value, and most easily seen is large standard errors for all of the beta estimates involved.
</p>
<p>pi
&mdash;&ndash;
pi is the probability of being in a state for the initial occasion. It is only used when there is one or more individual capture histories have an uncertain (u) 
state variable value for the initial occasion of the capture history. For the sealions example, all are released in the state S++ so there was no uncertainty.
</p>
<p>The design data for pi includes a record for each possible stratum for each individual.  For the sealions example, the following are the
design data for the first individual:
</p>
<pre>
 id occ stratum area ltag rtag fix
  1   1     A--    A    -    -   0
  1   1     A-+    A    -    +   0
  1   1     A+-    A    +    -   0
  1   1     A++    A    +    +   0
  1   1     S--    S    -    -   0
  1   1     S-+    S    -    +   0
  1   1     S+-    S    +    -   0
  1   1     S++    S    +    +   1
</pre>
<p>When the design data are created the code recognizes that the initial value for this individual capture history is known for all of
the strata values so it assigns 0 to the strata that are not the initial value and 1 for the strata that is the initial value.
</p>
<p>To demonstrate what is obtained when there is uncertainty I modified one of the S++ values to Suu and this is the resulting design data 
</p>
<pre>
 id occ stratum area ltag rtag fix
 335   1     A--    A    -    -   0
 335   1     A-+    A    -    +   0
 335   1     A+-    A    +    -   0
 335   1     A++    A    +    +   0
 335   1     S--    S    -    -   1
 335   1     S-+    S    -    +  NA
 335   1     S+-    S    +    -  NA
 335   1     S++    S    +    +  NA
</pre>
<p>All of the fix values for area A are still 0 because area is certain and it is in area S.  However, each tag status is uncertain
so there are 4 possible true values. S&ndash; is set to the reference cell by default and the other 3 would be estimated.
</p>
<p>There is a subtlety to the definition of pi that should be understood. The structure of the default design data for pi means that pi is the conditional 
probability of being in a state given there is uncertainty and that an animal is first observed in that period. In other words, it is the probability of 
being in states just for the records that have uncertainty and are first observed at a given time. For the sealions, consider having released 1/4 of the 
animals in A with all certain tag status and for the 3/4 released in S neither tag status was known. In that case pi would only relate to S and the proportion
given both tags will possibly be less in S than in both areas combined. However, if you defined fix for all records as above the estimated pi would apply to 
the whole set. 
</p>
<p>The mvmscjs model is constructed as a hidden Markov model as described in Johnson et al. (2015).  As such the 5 parameter classes (Phi,p,Psi,delta and pi)
are used to construct the matrices gamma (eq 2.13 in Johnson et al. (2015)),  dmat (eq 2.14 in Johnson et al. (2015)) and delta which is called pi in Johnson et al. (2015).
In the code I used the name delta for the matrix which has I rows and M colums because the symbol delta is used in Zucchini et al's book on HMMs. So think of delta
as the matrix and pi as the values in each row of the matrix. I should have used pi as the matrix as well to avoid confusion between the delta parameters and the
matrix delta for initial values.
</p>
<p>One other difference between the coding and Johnson et al. (2015) is that
the 0 observation in dmat is the last row in Jonhson et al (2015) and it is the first row in the code.  Likewise, for gamma the death state
is the last row in Johnson et al. (2015) and the first row in the code. In Johnson et al. (2015) dmat and gamma are matrices but in the code they are
4-d arrays where the first 2 dimensions are individuals and occasions and the last 2 dimensions are the matrices defined in Johnson et al. (2015).
</p>
<p>Johnson et al. (2015) show delta being used for each occasion including the initial release occasion.  In fact, design data for delta are created for
each occasion. But in constructing the formula there is one exception that you need to understand.  If the initial values are either all certain or
all uncertain then formula for delta is not used for that initial release because all values of dmat are either 0 or 1.
</p>
<p>If these matrices are setup incorrectly the optimization will likely fail. In general, that is all handled by the code but it is
possible to mess up the values in those matrices if the values of fix are incorrectly defined.  One place where this can occur is if
the value of fix=0 for all records defining a multinomial because when it normalizes to sum to 1, it will produce a NaN due to 0/0.
To prevent problems the function HMMLikelihood with the argument check=TRUE is run before attempting the optimization. With the starting 
parameter values it checks to make sure that the columns of dmat sum to 1 and the rows of gamma sum to 1 and all values of pi in delta sum to 1.
If any of these fail outside of rounding error, the program will issue errors showing the problematic records and values and will stop.
</p>
<p>Unobservable states can be included in the data structure and model but you must be careful in constructing formulas. Keep in
mind that there are no observations for unobservable states. That states the obvious but it can be easily forgotten when constructing
formulas.  For an easy example, consider a univariate example with area defining states.  Will assume that we have areas A,B and C that
are observable and X which is unobservable.  For Psi you can have transitions to and from the X and the other states. Obviously, you'll need to
set fix=0 for p for X because it can't be seen. Also, if you were to set the formula for Phi to be ~stratum there are no data in X so it will not be able to
estimate survival in X. So don't do that.  Likewise, the unobservable state value X should not be in a formula for delta because it represents
certainty/uncertainty of state variables for observations and there are no observations in X. Also, because this is a CJS formulation that is
conditional on the first release (observation), the formula for pi cannot include X, again because there are no observations. 
</p>
<p>To avoid including parameters for levels of a factor for unobservable state values, the easiest approach is to set fix values for the
design data rows for the unobservable states.  For example, if fix=0 for p for stratum X, then ~stratum could be used in the formula
and it would have an intercept and parameters for B and C.  The stratum level X would be excluded because all rows of the resulting
design matrix with fixed values are set to 0 and then any columns which have all 0 values are dropped which would drop the X factor level.
Another approach is to define a different variable that excludes the factor level. Note that this approach would not work to set p=0 for 
the unobservable state. Assume in addition to area we had another variable to define states and it could be uncertain. If we thought
that the uncertainty in that variable was related to area, we could use a formula for delta like ~-1+notX:area where notX was a variable
with value 1 when the area was not X and was 0 when area was X.  This would result in parameters for A,B and C but not X. A similar approach
would be to create 0/1 dummy variables A,B,C which were 1 when the record was for area=A,B,C respectively and 0 otherwise. Then you could
use the delta formula ~-1+A+B+C specifically excluding X.  It is not important for X to have a value for delta because there are no observations
for X and if you look at the last row (observation =0) in eq 2.14 in Johnson et al. (2015) you'll see is 1-p and doesn't use delta.
</p>
<p><code>marked</code> doesn't include any specific robust design models because they can be relatively easily handled by fixing real parameters.
In a standard closed multi-state robust design, during the secondary periods Phi=1 and Psi_AtoA= 1 for all states (no transitions).
Any variation can be created simply by fixing the appropriate parameters. For example, with the sealions example, you might allow
transitions between areas but assume no transitions for tag status.
</p>


<h3>Value</h3>

<p>The resulting value of the function is a list with the class of
crm,cjs such that the generic functions print and coef can be used.
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>named vector of parameter estimates</p>
</td></tr> <tr><td><code>lnl</code></td>
<td>
<p>-2*log
likelihood</p>
</td></tr> <tr><td><code>AIC</code></td>
<td>
<p>lnl + 2* number of parameters</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>result from <code>optim</code>; if 0 <code>optim</code> thinks it
converged</p>
</td></tr> <tr><td><code>count</code></td>
<td>
<p><code>optim</code> results of number of function
evaluations</p>
</td></tr> <tr><td><code>reals</code></td>
<td>
<p>dataframe of data and real S and p estimates for
each animal-occasion excluding those that occurred before release</p>
</td></tr>
<tr><td><code>vcv</code></td>
<td>
<p>var-cov matrix of betas if hessian=TRUE was set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>References</h3>

<p>Johnson, D. S., J. L. Laake, S. R. Melin, and DeLong, R.L. 2015. Multivariate State Hidden Markov Models for Mark-Recapture Data. 31:233-244.
</p>

<hr>
<h2 id='mvmscjs_tmb'>TMB version: Fitting function for Multivariate Multistate CJS with uncertainty models</h2><span id='topic+mvmscjs_tmb'></span>

<h3>Description</h3>

<p>A function for computing MLEs for MVMS models following Johnson et al (2015)  via TMB. It works very much like mscjs but with more parameters. While this function is for fitting the model via ADMB, the
documentation contained here is also relevant when this type of model is fitted with optimx and FORTRAN code (use.admb=FALSE, use.tmb=FALSE).
</p>
<p>It is easiest to call this function or any model built in <code>marked</code> through the function <code><a href="#topic+crm">crm</a></code>.
This function has been exported but to fit a model it should be called through the crm function
which does some testing of the arguments to avoid errors and sets up the calling arguments appropriately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvmscjs_tmb(
  x,
  ddl,
  fullddl,
  dml,
  model_data = NULL,
  parameters,
  accumulate = TRUE,
  initial = NULL,
  method,
  hessian = FALSE,
  debug = FALSE,
  chunk_size = 1e+07,
  refit,
  itnmax = NULL,
  control = NULL,
  re = FALSE,
  compile = FALSE,
  clean = TRUE,
  sup,
  getreals = FALSE,
  real.ids = NULL,
  useHess = FALSE,
  optimize = TRUE,
  vcv = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvmscjs_tmb_+3A_x">x</code></td>
<td>
<p>processed dataframe created by process.data</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_ddl">ddl</code></td>
<td>
<p>list of dataframes for design data; created by call to
<code><a href="#topic+make.design.data">make.design.data</a></code> and then simplified</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_fullddl">fullddl</code></td>
<td>
<p>list of dataframes for design data prior to simplification</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_dml">dml</code></td>
<td>
<p>list of design matrices created by <code><a href="#topic+create.dm">create.dm</a></code> from formula and design data</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_model_data">model_data</code></td>
<td>
<p>a list of all the relevant data for fitting the model including
imat, Phi.dm,p.dm,Psi.dm,Phi.fixed,p.fixed,Psi.fixed and time.intervals. It is stored with returned model object.</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_parameters">parameters</code></td>
<td>
<p>equivalent to <code>model.parameters</code> in <code><a href="#topic+crm">crm</a></code></p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_accumulate">accumulate</code></td>
<td>
<p>if TRUE will accumulate capture histories with common
value and with a common design matrix for S and p to speed up execution</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_initial">initial</code></td>
<td>
<p>list of initial values for parameters if desired; if each is a named vector
from previous run it will match to columns with same name</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_method">method</code></td>
<td>
<p>method to use for optimization; see <code>optim</code></p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_hessian">hessian</code></td>
<td>
<p>if TRUE will compute and return the hessian</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_debug">debug</code></td>
<td>
<p>if TRUE will print out information for each iteration</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_chunk_size">chunk_size</code></td>
<td>
<p>specifies amount of memory to use in accumulating capture
histories; amount used is 8*chunk_size/1e6 MB (default 80MB)</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_refit">refit</code></td>
<td>
<p>non-zero entry to refit</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_itnmax">itnmax</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_control">control</code></td>
<td>
<p>control string for optimization functions</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_re">re</code></td>
<td>
<p>currently ignored</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_compile">compile</code></td>
<td>
<p>if TRUE forces re-compilation of cpp file</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_clean">clean</code></td>
<td>
<p>if TRUE, deletes the cpp and dll for tmb if use.tmb=TRUE</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_sup">sup</code></td>
<td>
<p>supplemental index values for constructing mvms model; these are defined in the crm code</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_getreals">getreals</code></td>
<td>
<p>if TRUE, compute real values and std errors for TMB models; may want to set as FALSE until model selection is complete</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_real.ids">real.ids</code></td>
<td>
<p>vector of id values for which real parameters should be output with std error information</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_usehess">useHess</code></td>
<td>
<p>if TRUE, the TMB hessian function is used for optimization; using hessian is typically slower with many parameters but can result in a better solution</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_optimize">optimize</code></td>
<td>
<p>if TRUE, optimizes to get parameter estimates; set to FALSE to extract estimates of ADREPORTed values only</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_vcv">vcv</code></td>
<td>
<p>if TRUE, computes var-covariance matrix of ADREPORTed values</p>
</td></tr>
<tr><td><code id="mvmscjs_tmb_+3A_...">...</code></td>
<td>
<p>not currently used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mvmscjs model is quite flexible but also quite complex. Prior to using this model, read Johnson et al. (2015) 
and particularly Supplement B which goes through the code used in the analysis of Johnson et al. (2015).
Supplement B is useful but there have been a number of changes to the code since the paper was written and it is far from complete.
The documentation here will fill in some of those blanks.
</p>
<p>There are 5 classes of parameters in an mvms model. They are 1)Phi - survival probability, 2) p-capture probability, 3) Psi - state transition
probabilities, 4) delta - certainty/uncertainty state probabilities, 5) pi - initial state probability. The final
class pi was described in Johnson et al. (2015) but was not implemented in <code>marked</code> at the time the paper was written. However, with 
the sealions example, the initial state is known for all releases and pi is not relevant.
</p>
<p>Before I jump into a description of each parameter, I'll describe some characteristics that are common to all of the 
parameters. First, all of the parameters are probabilities and thus must be in the unit interval. To accomplish this
each of the parameters uses either a logit or mlogit (multinomial logit) link function.
</p>
<p>A logit link is log(theta/(1-theta))= a+bx... where theta is the probability (called a real parameter in <code>MARK</code> terminology) 
and a+bx... is the set of covariates (e.g. x) and working parameters (a,b) that are unbounded.  Working parameters are called beta parameters in 
<code>MARK</code> terminology. The inverse logit link is  1/(1+exp(-a-bx)) for this simple example and it can be computed from
the plogis function in R (plogis(a+bx)). A largish negative value of the link (eg -5) mean theta will be nearly 0 and
and a largish positive value (+5) means theta is nearly 1.
</p>
<p>The mlogit link is simply an extension of the logit link for more than 2 classes.  For example, the logit link for survival is
for the 2 classes alive/dead.  I'll use the logit link as a simple example to describe the way mlogit links are formed in <code>marked</code>.
If survival is Phi=1/(1+exp(-a))=exp(a)/(1+exp(a)) then mortality is 1-Phi = 1-exp(a)/(1+exp(a))= 1/(1+exp(a)). Imagine that we
have 2 link values a - for survival and b - for mortality.  Then we can rewrite the inverse logit function for Phi as exp(a)/(exp(b)+exp(a))
and then 1-Phi = exp(b)/(exp(b)+exp(a)). It is obvious that Phi+1-Phi=1 which must be the case.  Now, if you actually tried to fit a model
with both a and b the parameters a and b are not uniquely identifiable because there is only one parameter Phi. One of the values must be a 
reference cell which means the value is fixed.  Typically we assume b=0 which yields exp(0)=1 and we get the logit link.
</p>
<p>Now consider 3 classes (A,B,C) and we'll use the link values a,b,c for a generic parameter theta. As with the 2 class example, the
probabilities are theta(A)=exp(a)/(exp(a)+exp(b)+exp(c)),  theta(B)=exp(b)/(exp(a)+exp(b)+exp(c)) and theta(C)=exp(c)/(exp(a)+exp(b)+exp(c)).
As before theta(A)+theta(B)+theta(C)=1 but for a multinomial with 3 classes there are only 2 free estimable parameters due to the constraint that they have to sum to 1.
Just as with the example above, a reference cell must be selected.  If we chose B as the reference cell then b=0 and the probabilities become
theta(A)=exp(a)/(exp(a)+1+exp(c)),  theta(B)=1/(exp(a)+1+exp(c)) and theta(C)=exp(c)/(exp(a)+1+exp(c)). This extends to an k-class multinomial where
k-1 parameters are freely estimable and 1 must be fixed.
</p>
<p>For parameters with logit links there is an obvious choice for the reference cell.  For example, for survival probability we are interested in
describing the parameters that affect survival, so we use death as the reference cell which is computed by subtraction (1-Phi). Likewise, for
capture (sighting) probability we use not caught (1-p) as the reference cell.  For mlogit links, there is not always an obvious choice for a
reference cell and it can be an advantageous to allow the reference cell to be flexible and user-defined.
</p>
<p>To understand how to set the reference cell, you should review the material in the help file for create.dmdf and Supplement B of Johnson et al. (2015) 
which describes the design data but I'll give a brief description here. All model building in the <code>marked</code> package revolves around the design data. 
If the design data are incorrect the model will be incorrect. Briefly, the design data contain the data for the parameter model, 
providing the maximum structure from which specific models can be built.. For example, for p there are M-1 records for each of the I individuals and M occasions
(note that if the data are accumulated then an &quot;individual&quot; is actually a unique set of capture history and covariate data that represents &quot;freq&quot; animals). 
Thus, capture probability could be allowed to differ for each occasion, individual, age, strata, or any combination thereof.  In practice, such a model would
be overparameterized, but this structure allows maximum flexibility; users still need to use formula to provide specific constraints to reduce the number of 
parameters to a reasonable level. With this design data approach essentially there is a place holder for each possible p and any or all of those values 
can be fixed to a real value. 
</p>
<p>&quot;Real&quot; parameters can be fixed by adding a field called fix to the design data for a parameter. The value of fix should be either NA if 
the parameter is to be estimated or it should be the value of the real parameter (inverse link value). For example, we could fix the capture probability 
for time 2 to be 0 for all individuals at time 2 or at time 2 in strata B because there was no capture effort.  Or you could fix p=0 for an individual at a time
because it was temporarily removed. Or you could fix p=1 for a set of individuals that were always recaptured via telemetry.
</p>
<p>Now let's go back to the mlogit parameters. There is an important difference between the way <code>marked</code> and <code>RMark/MARK</code> work 
with regard to mlogit parameters like Psi for state transition probabilities. An mlogit parameter is one in which the 
sum of the probabilities is 1. For Psi, if I'm in stratum A and can go to B or C or remain in A, the probabilities A to A, A to B and A to C must sum to 1 because that is
all of the possibilities. In <code>RMark/MARK</code> the design data would only contain 2 records which are determined 
based on what you select as subtract.stratum. If subtract.stratum was set as A for the A stratum, the design 
data for Psi would only contain records for A to B and A to C. The value for A to A would be computed by 
subtraction and is the reference cell.
</p>
<p>By contrast, in <code>marked</code>, all 3 records are in the design data and to set the transition from A to A as the reference cell (computed by subtraction) 
the value of fix is set to 1. So if fix is the inverse logit value why is it being
set to 1 for the mlogit?  Because the link for these parameters is actually a log-link and the inverse link is exp(link).
So the link value is fixed to 0 and the inverse link (&quot;real value&quot;) is exp(0)=1. The mlogit parameter is constructed
by dividing each exp() value by the sum of the exp() values across the set defining the possible classes for the multinomial. 
Following along with the example, 
</p>
<pre>
Psi_AtoB=exp(beta_AtoB)/(1+exp(beta_AtoB)+exp(beta_AtoC))
Psi_AtoC=exp(beta_AtoC)/(1+exp(beta_AtoB)+exp(beta_AtoC)) and
Psi_AtoA=1-Psi_AtoB-Psi_AtoC = 1/(1+exp(beta_AtoB)+exp(beta_AtoC)). 
</pre>
<p>The &quot;appropriate&quot; set will depend on the mlogit parameter and the data/model structure.
</p>
<p>I used this structure for several reasons. First, you get a real parameter estimate for the subtracted stratum which you don't get in <code>RMark/MARK</code>. 
Secondly, you can change the value to be subtracted at will and it is not fixed across the entire model fit,
but you do have to be careful when specifying the model when you do that because the formula specifies the 
parameters for those that are not fixed. Finally, you can change the reference cell simply by modifying the value of fix, 
whereas with the subtract.stratum approach the design data would have to be recreated which can take some time with large data sets.
</p>
<p>Next I'll briefly describe each parameter in the model and its link function structure.
</p>
<p>Phi
&mdash;&ndash;
Phi is survival probability in the model. Survival probability is also called S in the straight multi-state model. In retrospect I wish I had stayed with 
S but I didn't.  In capture-recapture Phi is usually reserved for apparent survival rate which might include permanent emigration. 
With a multi-state model, the presumption is that &quot;all&quot; states are covered and animals can't emigrate permanently to some 
unobservable state.  Whether that is true or not is always a question. Anyhow I use Phi for survival in <code>mvmscjs</code> models.
</p>
<p>Phi uses a logit link (log(Phi/(1-Phi))= a+bx...) to relate survival to any covariates which have parameter values
across the entire real line.  Phi is what I call an interval parameter in that it describes the probability of surviving 
during an interval of time between sampling occasions. The design data for interval parameters are describe in terms of
the time and age of the animal at the beginning of the interval.  For example, if occasions are at time 1,2,...J there
will be J-1 data records for each individual with time values 1,...,J-1.
</p>
<p>p
&mdash;&ndash;
p is recapture/resighting probability.  While I'll often fall back and call it capture or sighting probability, technically it is
recapture or resighting because this model is based on a Cormack-Jolly-Seber (CJS) formulation which does not model initial &quot;capture&quot;
probability and only models events after they are marked and released. p also uses the logit link and it is an occasion parameter because
it describes an event associated with an occasion. Because they are &quot;recaptures&quot;, there are J-1 design data records for
each individual at times 2,...,J. 
</p>
<p>An example of using fix for p is given in the sealions example.  For the data, there was no survey effort in stratum A for the last occasion.
</p>
<pre>
ddl$p$fix = ifelse(ddl$p$Time==17 &amp; ddl$p$area=="A", 0, ddl$p$fix)
</pre>
<p>Psi
&mdash;&ndash;
Psi describes the transition probabilities of moving between states. For each individual at each occasion for each of the possible states,
it is formulated as a multinomial with a cell probability for movement from the state to all of the other possible states and remaining in the
in the same state. Thus if there are M states, then there are M*M records for each individual for each of the J-1 intervals. It is treated as
interval parameter with movement occurring between occasions but after survival.  If an animal is in state A it survives and moves to state B with
probability Phi_A*Psi_AtoB. If those were to be reversed you could use a trick proposed by Bill Kendall of adding dummy occasions between each real set
of occasions and fixing real parameters. For example using the first 2 occasions with data A0, the data would become A00 with 3 occasions. For the
first interval all the Phis would be fixed to 1 and Psi_AtoB would be estimated. For occasion 2, all the ps would be fixed to 0 because there are no observations and
for the second interval all the Psi's should be fixed so it will remain in the same state (eg. Psi_AtoA=1 and Psi_Atox=0).
</p>
<p>This can get rather involved when you have more than 1 variable describing the states which is the whole purpose of the
multi-variate multi-state model. It just needs some careful thought.  As an example, here are some of the columns of the design data for the first interval for
the first individual for stratum A&ndash; which for this example is area A with missing left and right tags. There are 8 records because
there are 8 possible strata - 2 areas *2 left tag states * 2 right tag states.
</p>
<pre>
&gt; head(ddl$Psi[,c(1:10,20),],8)
 id occ stratum tostratum area ltag rtag toarea toltag tortag fix
  1   1     A--       A--    A    -    -      A      -      -   1
  1   1     A--       A-+    A    -    -      A      -      +   0
  1   1     A--       A+-    A    -    -      A      +      -   0
  1   1     A--       A++    A    -    -      A      +      +   0
  1   1     A--       S--    A    -    -      S      -      -  NA
  1   1     A--       S-+    A    -    -      S      -      +   0
  1   1     A--       S+-    A    -    -      S      +      -   0
  1   1     A--       S++    A    -    -      S      +      +   0
</pre>
<p>When the design data are created, it creates fields based on the definition of strata.labels in the call to process.data. For this 
example it was  strata.labels=list(area=c(&quot;A&quot;,&quot;S&quot;),ltag=c(&quot;+&quot;,&quot;-&quot;,&quot;u&quot;),rtag=c(&quot;+&quot;,&quot;-&quot;,&quot;u&quot;))).  The design data include a
stratum and tostratum field which are the concatenated values of all the variables defining the states. In addition field and tofield
variables are created for each strata variables.  Here the fields are area,ltag,rtag and the tofields are toarea,toltag and tortag.
Each simply partitions the stratum and tostratum fields.  Note that if only a single variable is used to define the strata.labels the
the design data will only contain a stratum and tostratum fields.
</p>
<p>Now, when the design data are initially created for Psi, it creates the field fix and assigns the value NA to all values except for
the record in which stratum=tostratum which gets the value of fix=1 making it the reference cell. Those are the default values and it is up to you to change as needed.
In this case almost all of the Psi values are fixed to 0 because they cannot occur. The only possible movement is from A&ndash; to S&ndash; because
all of the other transitions would have it gaining tags that have already been lost.  As another example, the stratum A++ would have all of
the values of fix=NA except for tostratum=A++ which would be fixed to 1.
</p>
<p>delta
&mdash;&ndash;
delta is the probability of being certain or uncertain about each state variable for a given stratum. The definition can change based on 
how you define the reference cell. For delta, the number of records depends on the structure of strata.labels and the number of 
state variables and how many state variables can be uncertain.  Below are the design data for a single stratum for a single individual and occasion from the sealions
example.
</p>
<pre>

id occ stratum area ltag rtag obs.area obs.ltag obs.rtag obs.ltag.u obs.rtag.u
1   1     A--    A    -    -        A        -        -          0          0
1   1     A--    A    -    -        A        -        u          0          1
1   1     A--    A    -    -        A        u        -          1          0
1   1     A--    A    -    -        A        u        u          1          1
</pre>
<p>For this example, the area is certain but the left tag and right tag status can be uncertain. The above data are for the stratum
A&ndash;. Each field used to define the states has a field value and an obs.field value (eg., ltag, obs.ltag). The fields obs.ltag.u and obs.rtag.u were created in code 
after the call to make.design.data (see ?sealions). There would be a set like these for each of the 8 possible stratum value for id=1 and occ=1. Because each tag status can be either 
known or uncertain there are 2*2 records and the sum of the 4 cell probabilities must sum to 1. The easiest way to do that is
by specifying fix=1 for one of the cells and assigning the other 3 fix=NA so they are estimated. If you set fix=1 for the first record (observation A&ndash;),
then the parameters for delta are describing the probability of being uncertain. Whereas, if you set fix=1 for the fourth record (observation Auu) then
the parameters for delta are describing the probability of being certain.
</p>
<p>Now the use of fix is not required to set a reference cell because you can accomplish the same thing by defining the formula for
delta such that the link value is 0 for one of the cells.  For example, the formula for delta in the example is
</p>
<pre>
  ~ -1 + obs.ltag.u + obs.rtag.u + obs.ltag.u:obs.rtag.u)
</pre>
<p>The numeric value of obs.ltag.u + obs.rtag.u + obs.ltag.u*obs.rtag.u (: equivalent to mulitplication here) is 0 for the first record and -1 in the
formula specifies that there shouldn't be an intercept. Thus regardless of the 3 beta values for delta, the link value for the 
first record is 0 and the inverse link value is exp(0)=1 which is equivalent to setting fix=1 for the first record to set it as the reference cell.
If you run the sealions example with the current version of the software it will give the message:
</p>
<pre>
 No values provided for fix for delta. At least need to set a reference cell
</pre>
<p>Messages like this are warnings and do not stop the model from being fitted because as shown above it is possible to set the reference cell with an appropriate formula.
If a reference cell is not set the beta estimates are not all identifiable.  Symptoms include troubles with optimization, different starting values giving different
beta estimates for the parameter with the same likelihood value, and most easily seen is large standard errors for all of the beta estimates involved.
</p>
<p>pi
&mdash;&ndash;
pi is the probability of being in a state for the initial occasion. It is only used when there is one or more individual capture histories have an uncertain (u) 
state variable value for the initial occasion of the capture history. For the sealions example, all are released in the state S++ so there was no uncertainty.
</p>
<p>The design data for pi includes a record for each possible stratum for each individual.  For the sealions example, the following are the
design data for the first individual:
</p>
<pre>
 id occ stratum area ltag rtag fix
  1   1     A--    A    -    -   0
  1   1     A-+    A    -    +   0
  1   1     A+-    A    +    -   0
  1   1     A++    A    +    +   0
  1   1     S--    S    -    -   0
  1   1     S-+    S    -    +   0
  1   1     S+-    S    +    -   0
  1   1     S++    S    +    +   1
</pre>
<p>When the design data are created the code recognizes that the initial value for this individual capture history is known for all of
the strata values so it assigns 0 to the strata that are not the initial value and 1 for the strata that is the initial value.
</p>
<p>To demonstrate what is obtained when there is uncertainty I modified one of the S++ values to Suu and this is the resulting design data 
</p>
<pre>
 id occ stratum area ltag rtag fix
 335   1     A--    A    -    -   0
 335   1     A-+    A    -    +   0
 335   1     A+-    A    +    -   0
 335   1     A++    A    +    +   0
 335   1     S--    S    -    -   1
 335   1     S-+    S    -    +  NA
 335   1     S+-    S    +    -  NA
 335   1     S++    S    +    +  NA
</pre>
<p>All of the fix values for area A are still 0 because area is certain and it is in area S.  However, each tag status is uncertain
so there are 4 possible true values. S&ndash; is set to the reference cell by default and the other 3 would be estimated.
</p>
<p>There is a subtlety to the definition of pi that should be understood. The structure of the default design data for pi means that pi is the conditional 
probability of being in a state given there is uncertainty and that an animal is first observed in that period. In other words, it is the probability of 
being in states just for the records that have uncertainty and are first observed at a given time. For the sealions, consider having released 1/4 of the 
animals in A with all certain tag status and for the 3/4 released in S neither tag status was known. In that case pi would only relate to S and the proportion
given both tags will possibly be less in S than in both areas combined. However, if you defined fix for all records as above the estimated pi would apply to 
the whole set. 
</p>
<p>The mvmscjs model is constructed as a hidden Markov model as described in Johnson et al. (2015).  As such the 5 parameter classes (Phi,p,Psi,delta and pi)
are used to construct the matrices gamma (eq 2.13 in Johnson et al. (2015)),  dmat (eq 2.14 in Johnson et al. (2015)) and delta which is called pi in Johnson et al. (2015).
In the code I used the name delta for the matrix which has I rows and M colums because the symbol delta is used in Zucchini et al's book on HMMs. So think of delta
as the matrix and pi as the values in each row of the matrix. I should have used pi as the matrix as well to avoid confusion between the delta parameters and the
matrix delta for initial values.
</p>
<p>One other difference between the coding and Johnson et al. (2015) is that
the 0 observation in dmat is the last row in Jonhson et al (2015) and it is the first row in the code.  Likewise, for gamma the death state
is the last row in Johnson et al. (2015) and the first row in the code. In Johnson et al. (2015) dmat and gamma are matrices but in the code they are
4-d arrays where the first 2 dimensions are individuals and occasions and the last 2 dimensions are the matrices defined in Johnson et al. (2015).
</p>
<p>Johnson et al. (2015) show delta being used for each occasion including the initial release occasion.  In fact, design data for delta are created for
each occasion. But in constructing the formula there is one exception that you need to understand.  If the initial values are either all certain or
all uncertain then formula for delta is not used for that initial release because all values of dmat are either 0 or 1.
</p>
<p>If these matrices are setup incorrectly the optimization will likely fail. In general, that is all handled by the code but it is
possible to mess up the values in those matrices if the values of fix are incorrectly defined.  One place where this can occur is if
the value of fix=0 for all records defining a multinomial because when it normalizes to sum to 1, it will produce a NaN due to 0/0.
To prevent problems the function HMMLikelihood with the argument check=TRUE is run before attempting the optimization. With the starting 
parameter values it checks to make sure that the columns of dmat sum to 1 and the rows of gamma sum to 1 and all values of pi in delta sum to 1.
If any of these fail outside of rounding error, the program will issue errors showing the problematic records and values and will stop.
</p>
<p>Unobservable states can be included in the data structure and model but you must be careful in constructing formulas. Keep in
mind that there are no observations for unobservable states. That states the obvious but it can be easily forgotten when constructing
formulas.  For an easy example, consider a univariate example with area defining states.  Will assume that we have areas A,B and C that
are observable and X which is unobservable.  For Psi you can have transitions to and from the X and the other states. Obviously, you'll need to
set fix=0 for p for X because it can't be seen. Also, if you were to set the formula for Phi to be ~stratum there are no data in X so it will not be able to
estimate survival in X. So don't do that.  Likewise, the unobservable state value X should not be in a formula for delta because it represents
certainty/uncertainty of state variables for observations and there are no observations in X. Also, because this is a CJS formulation that is
conditional on the first release (observation), the formula for pi cannot include X, again because there are no observations. 
</p>
<p>To avoid including parameters for levels of a factor for unobservable state values, the easiest approach is to set fix values for the
design data rows for the unobservable states.  For example, if fix=0 for p for stratum X, then ~stratum could be used in the formula
and it would have an intercept and parameters for B and C.  The stratum level X would be excluded because all rows of the resulting
design matrix with fixed values are set to 0 and then any columns which have all 0 values are dropped which would drop the X factor level.
Another approach is to define a different variable that excludes the factor level. Note that this approach would not work to set p=0 for 
the unobservable state. Assume in addition to area we had another variable to define states and it could be uncertain. If we thought
that the uncertainty in that variable was related to area, we could use a formula for delta like ~-1+notX:area where notX was a variable
with value 1 when the area was not X and was 0 when area was X.  This would result in parameters for A,B and C but not X. A similar approach
would be to create 0/1 dummy variables A,B,C which were 1 when the record was for area=A,B,C respectively and 0 otherwise. Then you could
use the delta formula ~-1+A+B+C specifically excluding X.  It is not important for X to have a value for delta because there are no observations
for X and if you look at the last row (observation =0) in eq 2.14 in Johnson et al. (2015) you'll see is 1-p and doesn't use delta.
</p>
<p><code>marked</code> doesn't include any specific robust design models because they can be relatively easily handled by fixing real parameters.
In a standard closed multi-state robust design, during the secondary periods Phi=1 and Psi_AtoA= 1 for all states (no transitions).
Any variation can be created simply by fixing the appropriate parameters. For example, with the sealions example, you might allow
transitions between areas but assume no transitions for tag status.
</p>


<h3>Value</h3>

<p>The resulting value of the function is a list with the class of
crm,cjs such that the generic functions print and coef can be used.
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>named vector of parameter estimates</p>
</td></tr> <tr><td><code>lnl</code></td>
<td>
<p>-2*log
likelihood</p>
</td></tr> <tr><td><code>AIC</code></td>
<td>
<p>lnl + 2* number of parameters</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>result from <code>optim</code>; if 0 <code>optim</code> thinks it
converged</p>
</td></tr> <tr><td><code>count</code></td>
<td>
<p><code>optim</code> results of number of function
evaluations</p>
</td></tr> <tr><td><code>reals</code></td>
<td>
<p>dataframe of data and real S and p estimates for
each animal-occasion excluding those that occurred before release</p>
</td></tr>
<tr><td><code>vcv</code></td>
<td>
<p>var-cov matrix of betas if hessian=TRUE was set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>References</h3>

<p>Johnson, D. S., J. L. Laake, S. R. Melin, and DeLong, R.L. 2015. Multivariate State Hidden Markov Models for Mark-Recapture Data. 31:233-244.
</p>

<hr>
<h2 id='omega'>Compute 1 to k-step transition proportions</h2><span id='topic+omega'></span>

<h3>Description</h3>

<p>Computes 1 to k-step forward transition proportions in each state with a single transition matrix or a 3-d array of transition matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omega(x, k = NULL, labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="omega_+3A_x">x</code></td>
<td>
<p>either a transition matrix, list of transition matrices or 3-d array ( a set of transition matrices)</p>
</td></tr>
<tr><td><code id="omega_+3A_k">k</code></td>
<td>
<p>if x is a transition matrix, this is number of steps 1 to k</p>
</td></tr>
<tr><td><code id="omega_+3A_labels">labels</code></td>
<td>
<p>labels for states except for last which is always dead and is added at end</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>

<hr>
<h2 id='Paradise_shelduck'>Mulstistate Live-Dead Paradise Shelduck Data</h2><span id='topic+Paradise_shelduck'></span><span id='topic+ps'></span>

<h3>Description</h3>

<p>Paradise shelduck recapture and recovery data in multistrata provided by Richard Barker and Gary White.
</p>


<h3>Format</h3>

<p>A data frame with 1704 observations of 3 variables 
</p>
 
<dl>
<dt>ch</dt><dd><p>a character vector containing the capture history (each is 2 character positions LD) for 6 occasions</p>
</dd>
<dt>freq</dt><dd><p>capture history frequency</p>
</dd> 
<dt>sex</dt><dd><p>Male or Female</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>References</h3>

<p>Barker, R.J, White,G.C, and M. McDougall. 2005. MOVEMENT OF PARADISE SHELDUCK BETWEEN MOLT SITES: 
A JOINT MULTISTATE-DEAD RECOVERY MARK–RECAPTURE MODEL. JOURNAL OF WILDLIFE MANAGEMENT 69(3):1194–1201.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# In the referenced article, there are 3 observable strata (A,B,C) and 3 unobservable 
# strata (D,E,F). This example is setup by default to use only the 3 observable strata
# to avoid problems with multiple modes in the likelihood.
# Code that uses all 6 strata are provided but commented out. 
# With unobservable strata, simulated annealing should
# be used (options="SIMANNEAL")
data("Paradise_shelduck")
# change sex reference level to Male to match design matrix used in MARK
ps$sex=relevel(ps$sex,"Male")
# Process data with MSLiveDead model using sex groups and specify only observable strata
ps_dp=process.data(ps,model="MSLD",groups="sex",strata.labels=c("A","B","C"))
# Process data with MSLiveDead model using sex groups and specify observable and 
# unboservable strata
# ps_dp=process.data(ps,model="MSLD",groups="sex",strata.labels=c("A","B","C","D","E","F"))
# Make design data and specify constant PIM for Psi to reduce parameter space. No time 
#variation was allowed in Psi in the article.
ddl=make.design.data(ps_dp)
# Fix p to 0 for unobservable strata (only needed if they are included)
ddl$p$fix=NA
ddl$p$fix[ddl$p$stratum%in%c("D","E","F")]=0
# Fix p to 0 for last occasion
ddl$p$fix[ddl$p$time%in%6:7]=0.0
# Fix survival to 0.5 for last interval to match MARK file (to avoid confounding)
ddl$S$fix=NA
ddl$S$fix[ddl$S$time==6]=0.5
# create site variable for survival which matches A with D, B with E and C with F 
ddl$S$site="A"
ddl$S$site[ddl$S$stratum%in%c("B","C")]=as.character(ddl$S$stratum[ddl$S$stratum%in%c("B","C")])
ddl$S$site[ddl$S$stratum%in%c("E")]="B"
ddl$S$site[ddl$S$stratum%in%c("F")]="C"
ddl$S$site=as.factor(ddl$S$site)
# create same site variable for recovery probability (r)
ddl$r$site="A"
ddl$r$site[ddl$r$stratum%in%c("B","C")]=as.character(ddl$r$stratum[ddl$r$stratum%in%c("B","C")])
ddl$r$site[ddl$r$stratum%in%c("E")]="B"
ddl$r$site[ddl$r$stratum%in%c("F")]="C"
ddl$r$site=as.factor(ddl$r$site)
# Specify formula used in MARK model
S.1=list(formula=~-1+sex+time+site)
p.1=list(formula=~-1+stratum:time)
r.1=list(formula=~-1+time+sex+site)
Psi.1=list(formula=~-1+stratum:tostratum)
# Run top model from paper but only for observable strata
# commented out to prevent dll being built - problem with CRAN check
#crmmod=crm(ps_dp,ddl,model.parameters=list(S=S.1,p=p.1,r=r.1,Psi=Psi.1),
#              method="nlminb",hessian=TRUE)
# Run top model from paper for all strata using simulated annealing (commented out)
# crmmod=crm(ps_dp,ddl,model.parameters=list(S=S.1,p=p.1,r=r.1,Psi=Psi.1),
#                     method="SANN",itnmax=6e6,hessian=TRUE)
unlink("*.cpp")
unlink("*.o")
unlink("symbols.rds")

</code></pre>

<hr>
<h2 id='Phi.mean'>Various utility parameter summary functions</h2><span id='topic+Phi.mean'></span><span id='topic+p.mean'></span><span id='topic+Phi.boxplot'></span><span id='topic+p.boxplot'></span>

<h3>Description</h3>

<p>Several functions have been added to compute mean values and boxplots of values. Currently
they have only been defined for Phi and p for cjs and they are not generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Phi.mean(x,age=0,time=NULL,age.bins=NULL,age.levels=NULL)

       p.mean(x,age=0,time=NULL,age.bins=NULL,age.levels=NULL)

       Phi.boxplot(x,age=0,time=NULL,sex=NULL)

       p.boxplot(x,age=0,time=NULL,sex=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Phi.mean_+3A_x">x</code></td>
<td>
<p>dataframe of reals contained in model</p>
</td></tr>
<tr><td><code id="Phi.mean_+3A_age">age</code></td>
<td>
<p>at which Phi or p should be shown across time</p>
</td></tr>
<tr><td><code id="Phi.mean_+3A_time">time</code></td>
<td>
<p>at which Phi or p should be shown across ages</p>
</td></tr>
<tr><td><code id="Phi.mean_+3A_age.bins">age.bins</code></td>
<td>
<p>bins for age in which values are summarized</p>
</td></tr>
<tr><td><code id="Phi.mean_+3A_age.levels">age.levels</code></td>
<td>
<p>labels for age.bins</p>
</td></tr>
<tr><td><code id="Phi.mean_+3A_sex">sex</code></td>
<td>
<p>for which Phi or p should be shown across ages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of labelled values for Phi.mean and p.mean or boxplot object
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>

<hr>
<h2 id='predict.crm'>Compute estimates of real parameters</h2><span id='topic+predict.crm'></span>

<h3>Description</h3>

<p>Computes real estimates and their var-cov for a particular subset of 
parameters. The argument newdata may not work with all models. A better approach to 
compute real estimates for a subset of values or a new set of values is to specify a limited 
range of the values in ddl for each parameter. Make sure to include a complete set of values that spans
the factor levels and individual covariates used in the formulas for the model object or you will receive an
error that the number of columns in the design matrix does not match the number of beta parameters.  You cannot 
change the levels of any factor variable or modify the design data in anyway that changes the design matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crm'
predict(object,newdata=NULL,ddl=NULL,parameter=NULL,unique=TRUE,
                   vcv=FALSE,se=FALSE,chat=1,subset=NULL,select=NULL,
                   real.ids=NULL,merge=FALSE,unit_scale=TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.crm_+3A_object">object</code></td>
<td>
<p>model object;</p>
</td></tr>
<tr><td><code id="predict.crm_+3A_newdata">newdata</code></td>
<td>
<p>a dataframe for crm</p>
</td></tr>
<tr><td><code id="predict.crm_+3A_ddl">ddl</code></td>
<td>
<p>list of dataframes for design data; if specified forces computation even if estimates are in model object</p>
</td></tr>
<tr><td><code id="predict.crm_+3A_parameter">parameter</code></td>
<td>
<p>name of real parameter to be computed (eg &quot;Phi&quot;)</p>
</td></tr>
<tr><td><code id="predict.crm_+3A_unique">unique</code></td>
<td>
<p>TRUE if only unique values should be returned; if TRUE forces computation even if estimates are in model object</p>
</td></tr>
<tr><td><code id="predict.crm_+3A_vcv">vcv</code></td>
<td>
<p>logical; if TRUE, computes and returns v-c matrix of real estimates; if TRUE forces computation even if estimates are in model object</p>
</td></tr>
<tr><td><code id="predict.crm_+3A_se">se</code></td>
<td>
<p>logical; if TRUE, computes std errors and conf itervals of real estimates</p>
</td></tr>
<tr><td><code id="predict.crm_+3A_chat">chat</code></td>
<td>
<p>over-dispersion value</p>
</td></tr>
<tr><td><code id="predict.crm_+3A_subset">subset</code></td>
<td>
<p>logical expression using fields in real dataframe</p>
</td></tr>
<tr><td><code id="predict.crm_+3A_select">select</code></td>
<td>
<p>character vector of field names in real that you want to include</p>
</td></tr>
<tr><td><code id="predict.crm_+3A_real.ids">real.ids</code></td>
<td>
<p>animal ids passed to TMB code for computation of real parameter values</p>
</td></tr>
<tr><td><code id="predict.crm_+3A_merge">merge</code></td>
<td>
<p>default FALSE but if TRUE, the ddl for the parameter is merged (cbind) to the estimates</p>
</td></tr>
<tr><td><code id="predict.crm_+3A_unit_scale">unit_scale</code></td>
<td>
<p>default TRUE, if FALSE any time scaled parameter (e.g. Phi,S) is scaled when computing real value such that it represents the length of the interval rather than a unit interval</p>
</td></tr>
<tr><td><code id="predict.crm_+3A_...">...</code></td>
<td>
<p>generic arguments not used here</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the real estimates are in the model object and se and vcv are FALSE and ddl not specified, 
the code will simply pull the values from the model object.
</p>


<h3>Value</h3>

<p>A data frame (<code>real</code>) is returned if <code>vcv=FALSE</code>;
otherwise, a list is returned also containing vcv.real: </p>
<table role = "presentation">
<tr><td><code>real</code></td>
<td>
<p> data
frame containing estimates, and if vcv=TRUE it also contains
standard errors and confidence intervals</p>
</td></tr> <tr><td><code>vcv.real</code></td>
<td>
<p>variance-covariance matrix of
real estimates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dipper)
dipper.proc=process.data(dipper,model="cjs",begin.time=1)
dipper.ddl=make.design.data(dipper.proc)
mod.Phisex.pdot=crm(dipper.proc,dipper.ddl,
   model.parameters=list(Phi=list(formula=~sex+time),p=list(formula=~1)),hessian=TRUE)
xx=predict(mod.Phisex.pdot,ddl=dipper.ddl)
xx
xx=predict(mod.Phisex.pdot,newdata=dipper[c(1,23),],vcv=TRUE)
xx
</code></pre>

<hr>
<h2 id='print.crm'>Print model results</h2><span id='topic+print.crm'></span>

<h3>Description</h3>

<p>Provides a printed simple summary of the model results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crm'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.crm_+3A_x">x</code></td>
<td>
<p>crm model result or list of model results</p>
</td></tr>
<tr><td><code id="print.crm_+3A_...">...</code></td>
<td>
<p>generic arguments not used here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints a simple summary of the model to the screen and returns NULL.
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crm">crm</a></code>
</p>

<hr>
<h2 id='print.crmlist'>Print model table from model list</h2><span id='topic+print.crmlist'></span>

<h3>Description</h3>

<p>Print model table from model list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crmlist'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.crmlist_+3A_x">x</code></td>
<td>
<p>list of model results</p>
</td></tr>
<tr><td><code id="print.crmlist_+3A_...">...</code></td>
<td>
<p>generic arguments not used here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crm">crm</a></code>
</p>

<hr>
<h2 id='probitCJS'>Perform MCMC analysis of a CJS model</h2><span id='topic+probitCJS'></span>

<h3>Description</h3>

<p>Takes design data list created with the function <a href="#topic+make.design.data">make.design.data</a> for model &quot;probitCJS&quot; 
and draws a sample from the posterior distribution using a Gibbs sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probitCJS(
  ddl,
  dml,
  parameters,
  design.parameters,
  burnin,
  iter,
  initial = NULL,
  imat = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="probitCJS_+3A_ddl">ddl</code></td>
<td>
<p>list of dataframes for design data; created by call to
<code><a href="#topic+make.design.data">make.design.data</a></code></p>
</td></tr>
<tr><td><code id="probitCJS_+3A_dml">dml</code></td>
<td>
<p>list of design matrices created by <code><a href="#topic+create.dm">create.dm</a></code> from
formula and design data</p>
</td></tr>
<tr><td><code id="probitCJS_+3A_parameters">parameters</code></td>
<td>
<p>A model specification list with a list for Phi and p containing a 
formula and optionally a prior specification which is a named list. See 'Priors' section below.</p>
</td></tr>
<tr><td><code id="probitCJS_+3A_design.parameters">design.parameters</code></td>
<td>
<p>Specification of any grouping variables for design
data for each parameter</p>
</td></tr>
<tr><td><code id="probitCJS_+3A_burnin">burnin</code></td>
<td>
<p>number of iteration to initially discard for MCMC burnin</p>
</td></tr>
<tr><td><code id="probitCJS_+3A_iter">iter</code></td>
<td>
<p>number of iteration to run the Gibbs sampler for following burnin</p>
</td></tr>
<tr><td><code id="probitCJS_+3A_initial">initial</code></td>
<td>
<p>A named list (Phi,p). If null and imat is not null, uses cjs.initial to create initial values; otherwise assigns 0</p>
</td></tr>
<tr><td><code id="probitCJS_+3A_imat">imat</code></td>
<td>
<p>A list of vectors and matrices constructed by <code><a href="#topic+process.ch">process.ch</a></code> from the capture history data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with MCMC iterations and summarized output:
</p>
<table role = "presentation">
<tr><td><code>beta.mcmc</code></td>
<td>
<p>list with elements Phi and p which contain MCMC iterations for each beta parameter</p>
</td></tr> 
<tr><td><code>real.mcmc</code></td>
<td>
<p>list with elements Phi and p which contain MCMC iterations for each real parameter</p>
</td></tr> 
<tr><td><code>beta</code></td>
<td>
<p>list with elements Phi and p which contain summary of MCMC iterations for each beta parameter</p>
</td></tr> 
<tr><td><code>reals</code></td>
<td>
<p>list with elements Phi and p which contain summary of MCMC iterations for each real parameter</p>
</td></tr>
</table>


<h3>Prior distribution specification</h3>

<p>The prior distributions used in <code>probitCJS</code> are multivariate normal with mean mu a
and variance tau*(X'X)^(-1) on the probit scale for fixed effects. The matrix X is 
the design matrix based on the model specification (located in <code>parameters$Phi$formula</code> and
<code>parameters$p$formula</code> respectively). Priors for random effect variance 
components are inverse gamma with shape parameter 'a' and rate parameter 'b'. Currently, 
the default values are mu=0 and tau=0.01 for phi and p parameters. For all randome effects
deault values are a=2 and b=1.0E-4. In addition to the variance component each random effect
can be specified with a known unscaled covariance matrix, Q,  if random effects are correlated.
For example, to obtain a random walk model for a serially correlated effect see 
Examples section below. To specify different hyper-parameters for the prior distributions, it must be done 
in the <code>parameters</code> list. See the Examples section for changing the prior distributions. Note that a and b can be
vectors and the Qs are specified via a list in order of the random effects specified in the 
model statements.
</p>


<h3>Author(s)</h3>

<p>Devin Johnson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This example is excluded from testing to reduce package check time
# Analysis of the female dipper data
data(dipper)
dipper=dipper[dipper$sex=="Female",]
# following example uses unrealistically low values for burnin and 
# iteration to reduce package testing time
fit1 = crm(dipper,model="probitCJS",model.parameters=list(Phi=list(formula=~time),
 p=list(formula=~time)), burnin=100, iter=1000)
fit1
# Real parameter summary
fit1$results$reals

# Changing prior distributions:
fit2 = crm(dipper,model="probitCJS",
   model.parameters=list(
     Phi=list(formula=~time, prior=list(mu=rep(0,6), tau=1/2.85^2)),
     p=list(formula=~time, prior=list(mu=rep(0,6), tau=1/2.85^2))
   ), burnin=100, iter=1000)
fit2
# Real parameter summary
fit2$results$reals

# Creating a Q matrix for random walk effect for 6 recapture occasions
A=1.0*(as.matrix(dist(1:6))==1)
Q = diag(apply(A,1,sum))-A

# Fit a RW survival process
fit3 = crm(dipper,model="probitCJS",
   model.parameters=list(
     Phi=list(
       formula=~(1|time), 
       prior=list(mu=0, tau=1/2.85^2, re=list(a=2, b=1.0E-4, Q=list(Q)))
       ),
     p=list(formula=~time, prior=list(mu=rep(0,6), tau=1/2.85^2))
   ), burnin=100, iter=1000)
fit3
# Real parameter summary (Not calculated for random effects yet)
fit3$results$reals


</code></pre>

<hr>
<h2 id='proc.form'>Mixed effect model formula parser
Parses a mixed effect model in the lme4 structure of  ~fixed +(re1|g1) +...+(ren|gn)</h2><span id='topic+proc.form'></span>

<h3>Description</h3>

<p>Mixed effect model formula parser
</p>
<p>Parses a mixed effect model in the lme4 structure of  ~fixed +(re1|g1) +...+(ren|gn)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proc.form(f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="proc.form_+3A_f">f</code></td>
<td>
<p>formula for mixed effect mode in the form used in lme4; ~fixed +(re1|g1) +...+(ren|gn)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements fix.model and re.model. fix.model contains the formula for the fixed effects;
re.model contains elements sub, the grouping formula and model the design formula for the
random effect. Each formula is of type character and must be wrapped with as.formula in use with model.matrix
</p>


<h3>Author(s)</h3>

<p>Devin Johnson &lt;devin.johnson@noaa.gov&gt;
</p>

<hr>
<h2 id='process.ch'>Process release-recapture history data</h2><span id='topic+process.ch'></span>

<h3>Description</h3>

<p>Creates needed constructs from the release-recapture history.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process.ch(ch, freq = NULL, all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process.ch_+3A_ch">ch</code></td>
<td>
<p>Vector of character strings; each character string is 
composed of either a constant length sequence of single characters (01001) or 
the character string can be comma separated if more than a single 
character is used (1S,1W,0,2W). If comma separated, each string must contain a constant
number of elements.</p>
</td></tr>
<tr><td><code id="process.ch_+3A_freq">freq</code></td>
<td>
<p>Optional vector of frequencies for ch; if missing assumed to be
a; if &lt;0 indicates a loss on capture</p>
</td></tr>
<tr><td><code id="process.ch_+3A_all">all</code></td>
<td>
<p>FALSE is okay for cjs unless R code used to compute lnl instead of
FORTRAN; must be true for js because it returns additional quantities needed for entry prob.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>nocc</code></td>
<td>
<p>number of capture occasions</p>
</td></tr> <tr><td><code>freq</code></td>
<td>
<p>absolute value
of frequency for each ch</p>
</td></tr> <tr><td><code>first</code></td>
<td>
<p>vector of occasion numbers for first
1</p>
</td></tr> <tr><td><code>last</code></td>
<td>
<p>vector of occasion numbers for last 1</p>
</td></tr> <tr><td><code>loc</code></td>
<td>
<p>vector of
indicators of a loss on capture if set to 1</p>
</td></tr> <tr><td><code>chmat</code></td>
<td>
<p>capture history
matrix</p>
</td></tr> <tr><td><code>FtoL</code></td>
<td>
<p>1's from first (1) to last (1) and 0's elsewhere; only
if all==TRUE</p>
</td></tr> <tr><td><code>Fplus</code></td>
<td>
<p>1's from occasion after first (1) to nocc(last
occasion); only if all==TRUE</p>
</td></tr> <tr><td><code>Lplus</code></td>
<td>
<p>1's from occasion after last (1)
to nocc; only if all==TRUE</p>
</td></tr> <tr><td><code>L</code></td>
<td>
<p>1's from last (1) to nocc; only if
all==TRUE</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>

<hr>
<h2 id='process.data'>Process encounter history dataframe for MARK analysis</h2><span id='topic+process.data'></span><span id='topic+accumulate_data'></span>

<h3>Description</h3>

<p>Prior to analyzing the data, this function initializes several variables
(e.g., number of capture occasions, time intervals) that are often specific
to the capture-recapture model being fitted to the data.  It also is used to
1) define groups in the data that represent different levels of one or morestrata.labels
factor covariates (e.g., sex), 2) define time intervals between capture
occasions (if not 1), and 3) create an age structure for the data, if any.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process.data(data,begin.time=1,model="CJS",mixtures=1,groups=NULL,
                       allgroups=FALSE,age.var=NULL,initial.ages=c(0), 
                       time.intervals=NULL,nocc=NULL,accumulate=TRUE,
                       strata.labels=NULL)

         accumulate_data(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process.data_+3A_data">data</code></td>
<td>
<p>A data frame with at least one field named <code>ch</code> which is
the capture (encounter) history stored as a character string. <code>data</code>
can also have a field <code>freq</code> which is the number of animals with that
capture history. The default structure is freq=1 and it need not be included
in the dataframe. <code>data</code> can also contain an arbitrary number of
covariates specific to animals with that capture history.</p>
</td></tr>
<tr><td><code id="process.data_+3A_begin.time">begin.time</code></td>
<td>
<p>Time of first capture occasion or vector of times if
different for each group</p>
</td></tr>
<tr><td><code id="process.data_+3A_model">model</code></td>
<td>
<p>Type of analysis model.</p>
</td></tr>
<tr><td><code id="process.data_+3A_mixtures">mixtures</code></td>
<td>
<p>Number of mixtures in closed capture models with
heterogeneity</p>
</td></tr>
<tr><td><code id="process.data_+3A_groups">groups</code></td>
<td>
<p>Vector of factor variable names (in double quotes) in
<code>data</code> that will be used to create groups in the data. A group is
created for each unique combination of the levels of the factor variables in
the list.</p>
</td></tr>
<tr><td><code id="process.data_+3A_allgroups">allgroups</code></td>
<td>
<p>Logical variable; if TRUE, all groups are created from
factors defined in <code>groups</code> even if there are no observations in the
group</p>
</td></tr>
<tr><td><code id="process.data_+3A_age.var">age.var</code></td>
<td>
<p>An index in vector <code>groups</code> for a variable (if any) for
age</p>
</td></tr>
<tr><td><code id="process.data_+3A_initial.ages">initial.ages</code></td>
<td>
<p>A vector of initial ages that contains a value for each
level of the age variable <code>groups[age.var]</code>; if the data contain an initial.age field then it will be used instead.</p>
</td></tr>
<tr><td><code id="process.data_+3A_time.intervals">time.intervals</code></td>
<td>
<p>Vector of lengths of time between capture occasions or matrix of time intervals with a row for each animal and column for each interval between occasions.</p>
</td></tr>
<tr><td><code id="process.data_+3A_nocc">nocc</code></td>
<td>
<p>number of occasions for Nest type; either nocc or time.intervals
must be specified</p>
</td></tr>
<tr><td><code id="process.data_+3A_accumulate">accumulate</code></td>
<td>
<p>if TRUE, aggregates data with same values and creates freq field for count of records</p>
</td></tr>
<tr><td><code id="process.data_+3A_strata.labels">strata.labels</code></td>
<td>
<p>labels for strata used in capture history; they are converted to numeric in the order listed. Only needed to specify unobserved strata; for any unobserved strata p=0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For examples of <code>data</code>, see <code><a href="#topic+dipper">dipper</a></code>. The structure of the
encounter history and the analysis depends on the analysis model to some
extent. Thus, it is necessary to process a dataframe with the encounter
history (<code>ch</code>) and a chosen <code>model</code> to define the relevant values.
For example, number of capture occasions (<code>nocc</code>) is automatically
computed based on the length of the encounter history (<code>ch</code>) in
<code>data</code>. 
The default time interval is unit time (1) and if this is
adequate, the function will assign the appropriate length.  A processed data
frame can only be analyzed using the model that was specified.  The
<code>model</code> value is used by the functions <code><a href="#topic+make.design.data">make.design.data</a></code>
and <code><a href="#topic+crm">crm</a></code> to define the model structure as it relates to the
data. Thus, if the data are going to be analysed with different underlying
models, create different processed data sets with the model name as an
extension.  For example, <code>dipper.cjs=process.data(dipper)</code>.
</p>
<p>This function will report inconsistencies in the lengths of the capture
history values and when invalid entries are given in the capture history.
</p>
<p>The argument <code>begin.time</code> specifies the time for the first capture
occasion and not the first time the particular animal was caught or releaed.  This is used in creating the levels of the time factor variable
in the design data and for labelling parameters. If the <code>begin.time</code>
varies by group, enter a vector of times with one for each group. It will add a field
begin.time to the data with the value for each individual.  You can also specify a
begin.time field in the data allowing each animal to have a unique begin.time. Note that
the time values for survivals are based on the beginning of the survival
interval and capture probabilities are labeled based on the time of the
capture occasion.  Likewise, age labels for survival are the ages at the
beginning times of the intervals and for capture probabilities it is the age
at the time of capture/recapture. 
</p>
<p>The time.intervals argument can either be a vector of lengths of times for each interval between occasions
that is constant for all animals or a matrix which has a row for each animal and a column for each
interval which lets the intervals vary by animals. These intervals are used to construct the design data
and are used for the field time.interval which is used to adjust parameters like Phi and S to a constant per
unit time interval (eg annual survival rates). On occasion it can be useful to leave the time.interval to 
remain at default of 1 or some other vector of time.intervals to construct the design data and then modify the 
time.interval value in the design data.  For example, assume that cohort marking and release is done between
sampling occasions.  The initial survival from release to the next sampling occasion may vary by release
cohort, but the remainder of the surivivals are between sampling occasions.  In that case it is easier to 
let time.interval=1 (assuming unit interval (eg year) between sampling occasions but then modifying ddl$Phi$time.interval
to the value for the first interval after each release to be the partial year from release to next sampling occasion. In
this way everything is labelled with annual quantities but the first partial year survival is adjusted to an annual rate.
</p>
<p>Note that if you specify time.intervals as a matrix, then accumulate is set to FALSE so that the number of 
rows in the data can be checked against the number of rows in the time.intervals matrix and thus data cannot be
accumulated because at present it doesn't use values of time.intervals to determine which records can be accumulated.
</p>
<p><code>groups</code> is a vector of variable names that are contained in
<code>data</code>.  Each must be a factor variable. A group is created for each
unique combination of the levels of the factor variables.  For
example <code>groups=c("sex","ageclass","region")</code> creates
groups defined by the levels of <code>sex</code>, <code>ageclass</code> and <code>region</code>.
the code will only use groups that have 1 or more capture histories unless <code>allgroups=TRUE</code>.
</p>
<p>The argument <code>age.var=2</code> specifies that the second grouping variable in
<code>groups</code> represents an age variable.  It could have been named
something different than ageclass but it should not be named age as that is reserved in marked. 
<code>initial.age</code> specifies that the age at first capture of the age levels. For example
initial.age=0:2 specifies that the initial.ages are 0,1 and 2 for the age class levels 
designated as 1,2,3. The actual ages
for the age classes do not have to be sequential or ordered, but ordering
will cause less confusion.  Thus levels 1,2,3 could represent initial ages
of 0,4,6 or 6,0,4. The default for <code>initial.age</code>
is 0 for each group, in which case, <code>age</code> represents time since marking
(first capture) rather than the actual age of the animal. If the data contains an initial.age field
then it overrides any other values and lets each animal have a unique initial.age at first capture/release.
</p>
<p>The following variable names are reserved and should not be used in the data:
id (animal id)
ch(capture history)
freq (number of animals with that ch/data)
occ,age,time,cohort,Age,Time,Cohort,time.interval,fix
</p>


<h3>Value</h3>

<p>from <code>process.data</code> processed.data (a list with the following elements)
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>original raw dataframe with group factor variable added if
groups were defined</p>
</td></tr> 
<tr><td><code>model</code></td>
<td>
<p>type of analysis model (eg, &quot;cjs&quot; or &quot;js&quot;)</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>a dataframe of frequencies (same # of rows
as data, number of columns is the number of groups in the data. The column
names are the group labels representing the unique groups that have one or
more capture histories.</p>
</td></tr> 
<tr><td><code>nocc</code></td>
<td>
<p>number of capture occasions</p>
</td></tr>
<tr><td><code>time.intervals</code></td>
<td>
<p>length of time intervals between capture occasions</p>
</td></tr>
<tr><td><code>begin.time</code></td>
<td>
<p>time of first capture occasion</p>
</td></tr> 
<tr><td><code>initial.ages</code></td>
<td>
<p>an initial age for
each group in the data; Note that this is not the original argument but is a
vector with the initial age for each group. </p>
</td></tr>
<tr><td><code>group.covariates</code></td>
<td>
<p>factor covariates used to define groups</p>
</td></tr>
</table>
<p>from accumulate_data a dataframe with same column structure as argument with addition of freq (if not any)
and reduced to unique rows with freq accumulating number of records.
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dipper">dipper</a></code>,<code><a href="#topic+crm">crm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(dipper)
dipper.process=process.data(dipper,groups="sex")
# create some artificial age data as an example
dipper$ageclass=factor(c(rep("A",100),rep("J",194)))
dipper.process=process.data(dipper,groups=c("sex","ageclass"),age.var=2,initial.ages=c(1,0))

</code></pre>

<hr>
<h2 id='R_HMMLikelihood'>Hidden Markov Model Functions</h2><span id='topic+R_HMMLikelihood'></span><span id='topic+loglikelihood'></span>

<h3>Description</h3>

<p>R implementation of HMMs described in processed report except function HMMLikelihood renamed to R_HMMLikelihood and changed to compute
values for all capture histories and return  lnl, alpha, phi, v, dmat, and gamma values. loglikelihood is called with a fitted hmm model
and then computes the gamma,dmat and delta matrices and calls R_HMMLikelihood function. These are not used by the fitting code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R_HMMLikelihood(x,first,m,T,dmat,gamma,delta)
       loglikelihood(object,ddl=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R_HMMLikelihood_+3A_x">x</code></td>
<td>
<p>single observed sequence (capture history)</p>
</td></tr>
<tr><td><code id="R_HMMLikelihood_+3A_first">first</code></td>
<td>
<p>occasion to initiate likelihood calculation for sequence</p>
</td></tr>
<tr><td><code id="R_HMMLikelihood_+3A_m">m</code></td>
<td>
<p>number of states</p>
</td></tr>
<tr><td><code id="R_HMMLikelihood_+3A_t">T</code></td>
<td>
<p>number of occasions; sequence length</p>
</td></tr>
<tr><td><code id="R_HMMLikelihood_+3A_dmat">dmat</code></td>
<td>
<p>observation probability matrices</p>
</td></tr>
<tr><td><code id="R_HMMLikelihood_+3A_gamma">gamma</code></td>
<td>
<p>transition matrices</p>
</td></tr>
<tr><td><code id="R_HMMLikelihood_+3A_delta">delta</code></td>
<td>
<p>initial distribution</p>
</td></tr>
<tr><td><code id="R_HMMLikelihood_+3A_object">object</code></td>
<td>
<p>fitted hmm model</p>
</td></tr>
<tr><td><code id="R_HMMLikelihood_+3A_ddl">ddl</code></td>
<td>
<p>design data list; will be computed if NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>both return log-likelihood, alpha, v and phi arrays
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>References</h3>

<p>Zucchini, W. and I.L. MacDonald. 2009. Hidden Markov Models for Time Series: An Introduction using R. Chapman and Hall, Boca Raton, FL. 275p. See page 45.
</p>

<hr>
<h2 id='resight.matrix'>Various utility functions</h2><span id='topic+resight.matrix'></span><span id='topic+naive.survival'></span><span id='topic+mcmc_mode'></span>

<h3>Description</h3>

<p>Several functions have been added to help visualize data including resight.matrix
which provides for each cohort the number of releases on the diagonal and the number 
resighted on each occasion in the upper-triangular matrix. naive.survival
provides a naive survival estimate at each time for each cohort.  The estimate for
time i is the number resighted at time i+1 or later divided by the number seen at time i or later.
These values should be interpreted cautiously because they are influenced by capture probability in
year i but it is useful to identify particularly high or low survival values. Functions Phi.mean
and p.mean compute average real parameter values Phi or p across time for a single age or across ages for a
single time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resight.matrix(x)

       naive.survival(x)
      
       mcmc_mode(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resight.matrix_+3A_x">x</code></td>
<td>
<p>processed data list - result from process.data in marked or real estimates from fitted model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of values with cohort and year labels
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>

<hr>
<h2 id='sealions'>Multivariate State example data</h2><span id='topic+sealions'></span>

<h3>Description</h3>

<p>An example data set using California sea lions to demonstrate the Multivariate
state model with 3 variables defining the states : area, ltag and rtag.  The left tag (ltag) and
right tag (rtag) variables can be unknown.
#'
</p>


<h3>Format</h3>

<p>A data frame with 485 observations on the following 3 variables.
</p>
 <dl>
<dt>ch</dt><dd><p>a character vector of 3-character values for each occasion separated by commas.</p>
</dd> 
<dt>sex</dt><dd><p>the sex of the sea lion designated as F or M</p>
</dd>
<dt>weight</dt><dd><p>the anomaly of the weight from the sex-specific mean</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
### Load packages ###
# The splines package is only necessary for fitting b-spline curves used in the paper
# It is not required for the multivate models in the marked package
library(splines)

# Get data
data(sealions)

# Process data for multivariate models in marked
dp=process.data(sealions,model="mvmscjs",
  strata.labels=list(area=c("A","S"),ltag=c("+","-","u"),rtag=c("+","-","u")))

### Make design data
ddl=make.design.data(dp)

# Create pup variable for Phi
ddl$Phi$pup=ifelse(ddl$Phi$Age==0,1,0)
ddl$Phi$sex=factor(ddl$Phi$sex)

# Detection model
# Set final year (2014)  p=0 (no resight data) for ANI
ddl$p$fix = ifelse(ddl$p$Time==17 &amp; ddl$p$area=="A", 0, ddl$p$fix)

# Delta model
# create indicator variables for 'unknown' tag observations
ddl$delta$obs.ltag.u = ifelse(ddl$delta$obs.ltag=="u", 1, 0)
ddl$delta$obs.rtag.u = ifelse(ddl$delta$obs.rtag=="u", 1, 0)

# Psi model
# Set Psi to 0 for cases which are not possible - missing tag to having tag
ddl$Psi$fix[as.character(ddl$Psi$ltag)=="-"&amp;as.character(ddl$Psi$toltag)=="+"]=0
ddl$Psi$fix[as.character(ddl$Psi$rtag)=="-"&amp;as.character(ddl$Psi$tortag)=="+"]=0
# Create indicator variables for transitioning between states
ddl$Psi$AtoS=ifelse(ddl$Psi$area=="A"&amp;ddl$Psi$toarea=="S",1,0)  # ANI to SMI movement
ddl$Psi$StoA=ifelse(ddl$Psi$area=="S"&amp;ddl$Psi$toarea=="A",1,0)  # SMI to ANI movement
ddl$Psi$lpm=ifelse(ddl$Psi$ltag=="+"&amp;ddl$Psi$toltag=="-",1,0)   # Losing left tag
ddl$Psi$rpm=ifelse(ddl$Psi$rtag=="+"&amp;ddl$Psi$tortag=="-",1,0)   # Losing right tag
ddl$Psi$sex=factor(ddl$Psi$sex)

# formulas
Psi.1=list(formula=~-1+ AtoS:sex + AtoS:sex:bs(Age) + StoA:sex + StoA:sex:bs(Age) + 
                     I(lpm+rpm) +I(lpm+rpm):Age + lpm:rpm)
p.1=list(formula=~-1+time:area)
delta.1=list(formula= ~ -1 + obs.ltag.u + obs.rtag.u + obs.ltag.u:obs.rtag.u)
Phi.1=list(formula=~sex*bs(Age)+pup:weight+area)

# Fit model with TMB; remove comments to try
 #mod=crm(dp,ddl,model.parameters=list(Psi=Psi.1,p=p.1,delta=delta.1,Phi=Phi.1),
 #use.tmb=TRUE,method="nlminb",hessian=TRUE)

</code></pre>

<hr>
<h2 id='set_mvms'>Multivariate Multistate (mvms) Specification</h2><span id='topic+set_mvms'></span>

<h3>Description</h3>

<p>Creates list data structure from mvms specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_mvms(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_mvms_+3A_x">x</code></td>
<td>
<p>a multivariate multistate (mvms) specification as described above</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Accepts a mvms specification which is a list with named character vectors and
optionally a vector named exclude. The length of the list (except for exclude)
is the multivariate dimension. The name of each dimension is the list element name.  
Each character vector specifies the one character labels for the states of that dimension and optionally a 
reserved character &quot;u&quot; to specify that there is state uncertainty for that
dimension. The name vector exclude can be used to remove variable combinations that cannot 
occur in the data.
</p>
<p>The code tests to make sure that the input mvms specification is of the correct 
structure and it stops with an error message if not. The code returns a list
structure with a number of elements described under return value below.
</p>


<h3>Value</h3>

<p>a list with the following elements: 1) mvms - the input specification,
2) nd - the number of dimensions, 3) df - the dataframe containing all combinations 
of observations across dimensions including uncertain states, 4) df.states - the dataframe with all
combinations of states across dimensions, 5) uncertain - boolean vector with nd elements
indicating whether there is uncertainy in states for each dimension.
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set_mvms(list(location=c("A","B","C"),repro_status=c("N","P","u"),exclude=c("CP")))
</code></pre>

<hr>
<h2 id='set_scale'>Scaling functions</h2><span id='topic+set_scale'></span><span id='topic+scale_dm'></span><span id='topic+scale_par'></span><span id='topic+unscale_par'></span>

<h3>Description</h3>

<p>Set scale, scale dm and scale/unscale parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_scale(pars,model_data,scale)
 
        scale_dm(model_data,scale)

         scale_par(par,scale)

         unscale_par(par,scale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_scale_+3A_pars">pars</code></td>
<td>
<p>character vector of parameter names</p>
</td></tr>
<tr><td><code id="set_scale_+3A_model_data">model_data</code></td>
<td>
<p>list of data/design objects</p>
</td></tr>
<tr><td><code id="set_scale_+3A_scale">scale</code></td>
<td>
<p>list or vector of parameter scales</p>
</td></tr>
<tr><td><code id="set_scale_+3A_par">par</code></td>
<td>
<p>list of parameter vectors or vector of parameter values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of scale values for set_scale, model.data with scaled design matrices for scale_dm,
vector of scaled parameter values for scale_par, and list of unscaled parameter vectors for unscale_par
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>

<hr>
<h2 id='set.fixed'>Set fixed real parameter values in ddl</h2><span id='topic+set.fixed'></span>

<h3>Description</h3>

<p>Merges fixed real parameter values in parameter specification with those specified with fix in the 
design data list and returns the fixed values in the design data list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.fixed(ddl, parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.fixed_+3A_ddl">ddl</code></td>
<td>
<p>design data list</p>
</td></tr>
<tr><td><code id="set.fixed_+3A_parameters">parameters</code></td>
<td>
<p>parameter specififcation list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>design data list with fixed values
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>

<hr>
<h2 id='set.initial'>Set initial values</h2><span id='topic+set.initial'></span>

<h3>Description</h3>

<p>Sets initial values specified in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.initial(pars, dml, initial)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.initial_+3A_pars">pars</code></td>
<td>
<p>character vector of parameter names</p>
</td></tr>
<tr><td><code id="set.initial_+3A_dml">dml</code></td>
<td>
<p>list of design matrices created by <code><a href="#topic+create.dm">create.dm</a></code> from
formula and design data</p>
</td></tr>
<tr><td><code id="set.initial_+3A_initial">initial</code></td>
<td>
<p>list of vectors for parameter initial values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of initial values for each parameter in the model
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>

<hr>
<h2 id='setup_admb'>ADMB setup</h2><span id='topic+setup_admb'></span>

<h3>Description</h3>

<p>Sets up executable for the tpl file by looking for exe in package directory or
compiles tpl file in local directory (clean=F) of from package directory.
If admb cannot be found will attempt to run prepare_admb function (if exists) to
establish connections for compilation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_admb(tpl, compile = FALSE, clean = TRUE, safe = TRUE, re = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setup_admb_+3A_tpl">tpl</code></td>
<td>
<p>character string for admb template file</p>
</td></tr>
<tr><td><code id="setup_admb_+3A_compile">compile</code></td>
<td>
<p>if TRUE forces re-compilation of tpl file</p>
</td></tr>
<tr><td><code id="setup_admb_+3A_clean">clean</code></td>
<td>
<p>if TRUE, deletes the tpl and executable files for amdb in local directory</p>
</td></tr>
<tr><td><code id="setup_admb_+3A_safe">safe</code></td>
<td>
<p>can be used to set safe mode for admb</p>
</td></tr>
<tr><td><code id="setup_admb_+3A_re">re</code></td>
<td>
<p>uses admb-re if TRUE for random effects</p>
</td></tr>
</table>

<hr>
<h2 id='setup_tmb'>TMB setup</h2><span id='topic+setup_tmb'></span>

<h3>Description</h3>

<p>Sets up executable for the .cpp file (tpl) by looking for exe in package directory or
compiles cpp file in local directory (clean=FALSE) of from package directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_tmb(tpl, clean = FALSE, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setup_tmb_+3A_tpl">tpl</code></td>
<td>
<p>character string for admb template file</p>
</td></tr>
<tr><td><code id="setup_tmb_+3A_clean">clean</code></td>
<td>
<p>if TRUE, deletes the tpl (.cpp) and executable files in local directory and copies from package directory</p>
</td></tr>
<tr><td><code id="setup_tmb_+3A_debug">debug</code></td>
<td>
<p>if TRUE, writes out debug line values in code</p>
</td></tr>
</table>

<hr>
<h2 id='setup.model'>Defines model specific parameters (internal use)</h2><span id='topic+setup.model'></span><span id='topic+setupHMM'></span>

<h3>Description</h3>

<p>Compares <code>model</code>, the name of the type of model (eg &quot;CJS&quot;) to the list
of acceptable models to determine if it is supported and then creates some
global fields specific to that type of model that are used to modify the
operation of the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup.model(model, nocc, mixtures = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setup.model_+3A_model">model</code></td>
<td>
<p>name of model type (must be in vector <code>valid.models</code>)</p>
</td></tr>
<tr><td><code id="setup.model_+3A_nocc">nocc</code></td>
<td>
<p>length of capture history string</p>
</td></tr>
<tr><td><code id="setup.model_+3A_mixtures">mixtures</code></td>
<td>
<p>number of mixtures</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, the structure of the different types of models (e.g.,
&quot;CJS&quot;,&quot;Recovery&quot;,...etc) are very similar with some minor exceptions.  This
function is not intended to be called directly by the user but it is
documented to enable other models to be added.  This function is called by
other functions to validate and setup model specific parameters.  For
example, for live/dead models, the length of the capture history is twice
the number of capture occasions and the number of time intervals equals the
number of capture occasions because the final interval is included with dead
recoveries.  Whereas, for recapture models, the length of the capture
history is the number of capture occasions and the number of time intervals
is 1 less than the number of occasions.  This function validates that the
model is valid and sets up some parameters specific to the model that are
used in the code.
</p>


<h3>Value</h3>

<p>model.list - a list with following elements </p>
<table role = "presentation">
<tr><td><code>etype</code></td>
<td>
<p>encounter
type string for MARK input; typically same as model</p>
</td></tr> <tr><td><code>nocc</code></td>
<td>
<p>number of
capture occasions</p>
</td></tr> <tr><td><code>num</code></td>
<td>
<p>number of time intervals relative to number of
occasions (0 or -1)</p>
</td></tr> <tr><td><code>mixtures</code></td>
<td>
<p>number of mixtures if any</p>
</td></tr>
<tr><td><code>derived</code></td>
<td>
<p>logical; TRUE if model produces derived estimates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setup.parameters">setup.parameters</a></code>, <code><a href="#topic+valid.parameters">valid.parameters</a></code>
</p>

<hr>
<h2 id='setup.parameters'>Setup parameter structure specific to model (internal use)</h2><span id='topic+setup.parameters'></span>

<h3>Description</h3>

<p>Defines list of parameters used in the specified type of model
(<code>model</code>) and adds default values for each parameter to the list of
user specified values (eg formula, link etc).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup.parameters(
  model,
  parameters = list(),
  nocc = NULL,
  check = FALSE,
  number.of.groups = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setup.parameters_+3A_model">model</code></td>
<td>
<p>type of model (&quot;CJS&quot;, &quot;Burnham&quot; etc)</p>
</td></tr>
<tr><td><code id="setup.parameters_+3A_parameters">parameters</code></td>
<td>
<p>list of model parameter specifications</p>
</td></tr>
<tr><td><code id="setup.parameters_+3A_nocc">nocc</code></td>
<td>
<p>number of occasions (value only specified if needed)</p>
</td></tr>
<tr><td><code id="setup.parameters_+3A_check">check</code></td>
<td>
<p>if TRUE only the vector of parameter names is returned
<code>par.list</code></p>
</td></tr>
<tr><td><code id="setup.parameters_+3A_number.of.groups">number.of.groups</code></td>
<td>
<p>number of groups defined for data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value depends on the argument <code>check</code>. If it is TRUE
then the return value is a vector of the names of the parameters used in the
specified type of model. For example, if <code>model="CJS"</code> then the return
value is <code>c("Phi","p")</code>.  This is used by the function
<code><a href="#topic+valid.parameters">valid.parameters</a></code> to make sure that parameter specifications
are valid for the model (i.e., specifying recovery rate r for &quot;CJS&quot; would
give an error).  If the function is called with the default of
<code>check=FALSE</code>, the function returns a list of parameter specifications
which is a modification of the argument <code>parameters</code> which adds
parameters not specified and default values for all types of parameters that
were not specified. The list length and names of the list elements depends
on the type of model. Each element of the list is itself a list with varying
numbers of elements which depend on the type of parameter although some
elements are the same for all parameters.  Below the return value list is
shown generically with parameters named p1,...,pk.  </p>

<table>
<tr>
 <td style="text-align: left;"> <code>p1</code>
</td><td style="text-align: left;"> List of specifications for parameter 1 </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>p2</code> </td><td style="text-align: left;"> List of
specifications for parameter 2 </td>
</tr>
<tr>
 <td style="text-align: left;"> . </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> .  </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> .  </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>pk</code> </td><td style="text-align: left;"> List of specifications for parameter k </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>The elements for each parameter list all include: </p>

<table>
<tr>
 <td style="text-align: left;"> <code>begin</code>
</td><td style="text-align: left;"> 0 or 1; beginning time for the first </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> parameter relative to
first occasion </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>num</code> </td><td style="text-align: left;"> 0 or -1; number of parameters relative to
</td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> number of occassions </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>type</code> </td><td style="text-align: left;"> type of PIM structure;
either "Triang" or "Square" </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>formula</code> </td><td style="text-align: left;"> formula for parameter
model (e.g., <code>~time</code>) </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>link</code> </td><td style="text-align: left;"> link function for parameter
(e.g., <code>"logit"</code>) </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>and may include: </p>

<table>
<tr>
 <td style="text-align: left;"> <code>share</code> </td><td style="text-align: left;"> only valid for p in closed
capture models; </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> if TRUE p and c models shared </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>mix</code> </td><td style="text-align: left;">
only valid for closed capture heterogeneity </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> models; if TRUE
mixtures are used </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>rows</code> </td><td style="text-align: left;"> only valid for closed capture
heterogeneity models </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>fixed</code> </td><td style="text-align: left;"> fixed values specified by user
and </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> not used modified in this function </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setup.model">setup.model</a></code>,<code><a href="#topic+valid.parameters">valid.parameters</a></code>
</p>

<hr>
<h2 id='simHMM'>Simulates data from Hidden Markov Model</h2><span id='topic+simHMM'></span>

<h3>Description</h3>

<p>Creates a set of data from a specified HMM model for capture-recapture data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simHMM(
  data,
  ddl = NULL,
  begin.time = 1,
  model = "hmmCJS",
  title = "",
  model.parameters = list(),
  design.parameters = list(),
  initial = NULL,
  groups = NULL,
  time.intervals = NULL,
  accumulate = TRUE,
  strata.labels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simHMM_+3A_data">data</code></td>
<td>
<p>Either the raw data which is a dataframe with at least one column named ch (a character field containing the capture history) or a processed dataframe</p>
</td></tr>
<tr><td><code id="simHMM_+3A_ddl">ddl</code></td>
<td>
<p>Design data list which contains a list element for each parameter type; if NULL it is created</p>
</td></tr>
<tr><td><code id="simHMM_+3A_begin.time">begin.time</code></td>
<td>
<p>Time of first capture(release) occasion</p>
</td></tr>
<tr><td><code id="simHMM_+3A_model">model</code></td>
<td>
<p>Type of c-r model</p>
</td></tr>
<tr><td><code id="simHMM_+3A_title">title</code></td>
<td>
<p>Optional title; not used at present</p>
</td></tr>
<tr><td><code id="simHMM_+3A_model.parameters">model.parameters</code></td>
<td>
<p>List of model parameter specifications</p>
</td></tr>
<tr><td><code id="simHMM_+3A_design.parameters">design.parameters</code></td>
<td>
<p>Specification of any grouping variables for design data for each parameter</p>
</td></tr>
<tr><td><code id="simHMM_+3A_initial">initial</code></td>
<td>
<p>Optional list (by parameter type) of initial values for beta parameters (e.g., initial=list(Phi=0.3,p=-2)</p>
</td></tr>
<tr><td><code id="simHMM_+3A_groups">groups</code></td>
<td>
<p>Vector of names of factor variables for creating groups</p>
</td></tr>
<tr><td><code id="simHMM_+3A_time.intervals">time.intervals</code></td>
<td>
<p>Intervals of time between the capture occasions</p>
</td></tr>
<tr><td><code id="simHMM_+3A_accumulate">accumulate</code></td>
<td>
<p>if TRUE, like capture-histories are accumulated to reduce computation</p>
</td></tr>
<tr><td><code id="simHMM_+3A_strata.labels">strata.labels</code></td>
<td>
<p>labels for strata used in capture history; they are converted to numeric in the order listed. Only needed to specify unobserved strata. For any unobserved strata p=0..</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The specification for the simulation includes a set of data with at least 2 unique ch and freq value to 
specify the number of ch values to simulate that start at the specified occasion. For example, 
1000 50
0100 50
0010 50
would simulate 150 capture histories with 50 starting at each of occasions 1 2 and 3. The data can also 
contain other fields used to generate the model probabilities and each row can have freq=1 to use individual
covariates. Either a dataframe (data) is provided and it is processed and the design data list are created
or the processed dataframe and design data list are provided. Formula for the model parameters for generating 
the data are provided in model.parameters and parameter values are provided in initial.
</p>


<h3>Value</h3>

<p>dataframe with simulated data
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate phi(.) p(.) with 1000 Females and 100 males, 3 occasions all released on first occasion
df=simHMM(data.frame(ch=c("100","110"),sex=factor(c("F","M")),freq=c(1000,100),
   stringsAsFactors=FALSE))
df=simHMM(data.frame(ch=rep("100",100),u=rnorm(100,0,1),freq=rep(1,100),
  stringsAsFactors=FALSE),
  model.parameters=list(Phi=list(formula=~u),p=list(formula=~time)),
   initial=list(Phi=c(1,1),p=c(0,1)))
df=simHMM(data.frame(ch=c("1000","0100","0010"),freq=rep(50,3),stringsAsFactors=FALSE),
  model.parameters=list(Phi=list(formula=~1),p=list(formula=~time)),
    initial=list(Phi=c(1),p=c(0,1,2)))

######################################################################## 
# Example developed by Jay Rotella, Montana State University
# example of using the 'simHMM' function in 'marked' package for
#  a multi-state model with 3 states

# simulate a single release cohort of 1000 animals with 1 release from 
#  each of the 3 states for 10 recapture occasions; 
# Note: at least 2 unique ch are needed in simHMM
simd &lt;- data.frame(ch = c("A0000000000", "B0000000000", "C0000000000"),
	freq = c(1000, 1000, 1000),
	stringsAsFactors = FALSE)

# define simulation/fitting model; default for non-specified parameters is ~1
# but all are listed here. For the formula for Psi, the -1 is necessary to remove
# the intercept which is not needed and would be redundant. 
# The formula '~ -1 + stratum:tostratum' is often appropriate for multi-state
# transitions as it allows different values for Psi depending on 
# the current state (state at time t) and the new state (state at t+1). 
modelspec &lt;- list(
	S = list(formula = ~ -1 + stratum),
	# by presenting the formula for S as '~-1+stratum', it is possible to 
	# present the desired survival rates directly for each group in the 
	# simulations (see how 'initial' is created below) for this simple
	# scenario where survival varies by stratum but no other covariates
	p = list(formula = ~ 1),
	Psi = list(formula =  ~ -1 + stratum:tostratum))

# process data with A,B,C strata
sd &lt;- process.data(simd,
	model = "hmmMSCJS",
	strata.labels = c("A", "B", "C"))

# create design data
ddl &lt;- make.design.data(sd)
# view design data (especially important for seeing which order to present
#  beta values used to set probabilities for various transitions)
head(model.matrix(~stratum, ddl$S))
head(model.matrix(~-1+stratum:tostratum, ddl$Psi), 9)

# set initial parameter values for model S=~stratum, p=~1, Psi=~stratum:tostratum
initial &lt;- list(S = c(log(0.8/0.2), log(0.6/0.4), log(0.5/0.5)),
	p = log(0.6/0.4),
	# order of presentation is BA, CA, AB, CB, AC, BC
	# Note: values for AA, BB, CC are obtained by subtraction
	Psi = c(log(0.2/0.6), log(0.3/0.1),   # Psi(BA) &amp; Psi(CA)
			log(0.3/0.5), log(0.6/0.1),   # Psi(AB) &amp; Psi(CB)
			log(0.2/0.5), log(0.2/0.6)))  # Psi(AC) &amp; Psi(BC)
# The desired probabilties for the transition matrix for Psi are as follows
#        To:
# From:    A   B    C
#    A   .5   .3   .2
#    B   .2   .6   .2
#    C   .3   .6   .4
# The values in the list above are obtained using the transitions AA, BB, CC
#  as reference values in the denominator of log-odds calculations. 
# For example, to achieve the desired probabilities for the transition 
#  from A to B use log(0.3/0.5) and from A to C use log(0.2/0.5)
# exp(log(0.3/0.5))/(1 + exp(log(0.3/0.5)) + exp(log(0.2/0.5))) = 0.3
# exp(log(0.2/0.5))/(1 + exp(log(0.3/0.5)) + exp(log(0.2/0.5))) = 0.2
# Note:           1/(1 + exp(log(0.3/0.5)) + exp(log(0.2/0.5))) = 0.5

# call simmHMM to get a single realization
realization &lt;- simHMM(sd, ddl, model.parameters = modelspec, 
		initial = initial)

# using that realization, process data and make design data
# note that the analysis can also use model="MSCJS" in marked or "Multistrata" in RMark
# it is only the simulation that requires specification as an HMM.
sd &lt;- process.data(realization, model = "hmmMSCJS",
	strata.labels = c("A","B","C"))
rddl &lt;- make.design.data(sd)

# fit model
m &lt;- crm(sd, rddl, model.parameters = modelspec,
	hessian = TRUE)

# model output
m$results$beta
initial
m$results$reals

</code></pre>

<hr>
<h2 id='skagit'>An example of the Mulstistrata (multi-state) model in which states are routes taken by migrating fish.</h2><span id='topic+skagit'></span>

<h3>Description</h3>

<p>An example of the Mulstistrata (multi-state) model in which states are routes taken by migrating fish.
</p>


<h3>Format</h3>

<p>A data frame with 100 observations on the following 2 variables.
</p>
 <dl>
<dt>ch</dt><dd><p>capture history</p>
</dd> 
<dt>tag</dt><dd><p>tag type v7 or v9</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Megan Moore &lt;megan.moore at noaa.gov&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There are just two states which correspond to route A and route B. There are 6 occasions
# which are the locations rather than times. After release at 1=A there is no movement 
# between states for the first segment, fish are migrating downriver together and all pass 2A. 
# Then after occasion 2, migrants go down the North Fork (3A) or the South Fork (3B), 
# which both empty into Skagit Bay. Once in saltwater, they can go north to Deception Pass (4A)
# or South to a receiver array exiting South Skagit Bay (4B). Fish in route A can then only go
# to the Strait of Juan de Fuca, while fish in route B must pass by Admiralty Inlet (5B). 
# Then both routes end with the array at the Strait of Juan de Fuca.
#
#       1A
#        |
#        2A
#      /     \
#    3A        3B
#   /  \      /  \ 
# 4A   4B    4A  4B       
#  |     \    /   |
#   5A    5B  5A   5B
#      \   \   /    /
#            6
# 
# from 3A and 3B they can branch to either 4A or 4B; branches merge at 6  
# 5A does not exist so p=0; only survival from 4A to 6 can be 
# estimated which is done by setting survival from 4A to 5A to 1 and
# estimating survival from 5A to 6 which is then total survival from 4A to 6.

# See help for mscjs for an example that explains difference between marked and RMark
# with regard to treatment of mlogit parameters like Psi.
</code></pre>

<hr>
<h2 id='smsld_tmb'>Fitting function for Multistate CJS live-dead models with TMB</h2><span id='topic+smsld_tmb'></span>

<h3>Description</h3>

<p>A function for computing MLEs for a Multi-state Cormack-Jolly-Seber open
population capture-recapture with dead recoveries for processed dataframe <code>x</code> with
user specified formulas in <code>parameters</code> that create list of design
matrices <code>dml</code>. This function can be called directly but is most easily
called from <code><a href="#topic+crm">crm</a></code> that sets up needed arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smsld_tmb(
  x,
  ddl,
  dml,
  model_data = NULL,
  parameters,
  accumulate = TRUE,
  initial = NULL,
  method,
  hessian = FALSE,
  debug = FALSE,
  chunk_size = 1e+07,
  refit,
  itnmax = NULL,
  control = NULL,
  scale,
  re = FALSE,
  compile = FALSE,
  extra.args = "",
  clean = FALSE,
  getreals = FALSE,
  useHess = FALSE,
  savef = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smsld_tmb_+3A_x">x</code></td>
<td>
<p>processed dataframe created by process.data</p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_ddl">ddl</code></td>
<td>
<p>list of simplified dataframes for design data; created by call to
<code><a href="#topic+make.design.data">make.design.data</a></code></p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_dml">dml</code></td>
<td>
<p>list of design matrices created by <code><a href="#topic+create.dm">create.dm</a></code> from
formula and design data</p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_model_data">model_data</code></td>
<td>
<p>a list of all the relevant data for fitting the model including
imat, S.dm,r.dm,p.dm,Psi.dm,S.fixed,r.fixed,p.fixed,Psi.fixed and time.intervals. It is used to save values
and avoid accumulation again if the model was re-rerun with an additional call to cjs when
using autoscale or re-starting with initial values.  It is stored with returned model object.</p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_parameters">parameters</code></td>
<td>
<p>equivalent to <code>model.parameters</code> in <code><a href="#topic+crm">crm</a></code></p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_accumulate">accumulate</code></td>
<td>
<p>if TRUE will accumulate capture histories with common
value and with a common design matrix for all parameters speed up execution</p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_initial">initial</code></td>
<td>
<p>list of initial values for parameters if desired; if each is a named vector
from previous run it will match to columns with same name</p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_method">method</code></td>
<td>
<p>method to use for optimization; see <code>optim</code></p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_hessian">hessian</code></td>
<td>
<p>if TRUE will compute and return the hessian</p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_debug">debug</code></td>
<td>
<p>if TRUE will print out information for each iteration</p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_chunk_size">chunk_size</code></td>
<td>
<p>specifies amount of memory to use in accumulating capture
histories; amount used is 8*chunk_size/1e6 MB (default 80MB)</p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_refit">refit</code></td>
<td>
<p>non-zero entry to refit</p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_itnmax">itnmax</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_control">control</code></td>
<td>
<p>control string for optimization functions</p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_scale">scale</code></td>
<td>
<p>vector of scale values for parameters</p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_re">re</code></td>
<td>
<p>if TRUE creates random effect model admbcjsre.tpl and runs admb optimizer</p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_compile">compile</code></td>
<td>
<p>if TRUE forces re-compilation of tpl file</p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_extra.args">extra.args</code></td>
<td>
<p>optional character string that is passed to tmb</p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_clean">clean</code></td>
<td>
<p>if TRUE, deletes the dll and recompiles</p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_getreals">getreals</code></td>
<td>
<p>if TRUE, compute real values and std errors for TMB models; may want to set as FALSE until model selection is complete</p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_usehess">useHess</code></td>
<td>
<p>if TRUE, the TMB hessian function is used for optimization; using hessian is typically slower with many parameters but can result in a better solution</p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_savef">savef</code></td>
<td>
<p>if TRUE, save optimization function in model for reporting</p>
</td></tr>
<tr><td><code id="smsld_tmb_+3A_...">...</code></td>
<td>
<p>not currently used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is easiest to call <code>msld_tmb</code> through the function <code><a href="#topic+crm">crm</a></code>.
Details are explained there.
</p>


<h3>Value</h3>

<p>The resulting value of the function is a list with the class of
crm,cjs such that the generic functions print and coef can be used.
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>named vector of parameter estimates</p>
</td></tr> <tr><td><code>lnl</code></td>
<td>
<p>-2*log
likelihood</p>
</td></tr> <tr><td><code>AIC</code></td>
<td>
<p>lnl + 2* number of parameters</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>result from <code>optim</code>; if 0 <code>optim</code> thinks it
converged</p>
</td></tr> <tr><td><code>count</code></td>
<td>
<p><code>optim</code> results of number of function
evaluations</p>
</td></tr> <tr><td><code>reals</code></td>
<td>
<p>dataframe of data and real S and p estimates for
each animal-occasion excluding those that occurred before release</p>
</td></tr>
<tr><td><code>vcv</code></td>
<td>
<p>var-cov matrix of betas if hessian=TRUE was set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeff Laak
</p>

<hr>
<h2 id='splitCH'>Split/collapse capture histories</h2><span id='topic+splitCH'></span><span id='topic+collapseCH'></span>

<h3>Description</h3>

<p>splitCH will split a character string vector of capture histories into a matrix. The ch can either be single character or
comma separated string. The matrix is appended to the original data set (data) if one is 
specified. Will handle character and numeric values in ch. Results will differ depending on content of ch. collapseCH will collapse a
capture history matrix back into a character vector. Argument can either be a capture history matrix (chmat) or a dataframe (data)
that contains fields with a specified prefix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitCH(x="ch", data=NULL, prefix="Time")
 
        collapseCH(chmat=NULL, data=NULL, prefix="Time", collapse="")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splitCH_+3A_x">x</code></td>
<td>
<p>A vector containing the character strings of capture histories or the column number or name in the data set <code>data</code></p>
</td></tr>
<tr><td><code id="splitCH_+3A_data">data</code></td>
<td>
<p>A data frame containing columnwith value in x if x indicates a column in a data frame</p>
</td></tr>
<tr><td><code id="splitCH_+3A_prefix">prefix</code></td>
<td>
<p>first portion of field names for split ch</p>
</td></tr>
<tr><td><code id="splitCH_+3A_chmat">chmat</code></td>
<td>
<p>capture history matrix</p>
</td></tr>
<tr><td><code id="splitCH_+3A_collapse">collapse</code></td>
<td>
<p>in collapseCH the separator for ch string; defaults to &quot;&quot; but &quot;,&quot; also useful if multi-characters are used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame if data specified and a matrix if vector ch is specified
</p>


<h3>Author(s)</h3>

<p>Devin Johnson; Jeff Laake
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dipper)
# following returns a matrix
chmat=splitCH(dipper$ch)
# following returns the original dataframe with the ch split into columns
newdipper=splitCH(data=dipper)
# following collapses chmat
ch=collapseCH(chmat)
# following finds fields in newdipper and creates ch
newdipper$ch=NULL
newdipper=collapseCH(data=newdipper)
</code></pre>

<hr>
<h2 id='tagloss'>Tag loss example</h2><span id='topic+tagloss'></span>

<h3>Description</h3>

<p>A simulated data set of double tag loss with 1/2 of the animals with a 
permanent mark. The data are simulated with tag-specific loss rates and
dependence.
</p>


<h3>Format</h3>

<p>A data frame with 1000 observations on the following 2 variables.
</p>
 <dl>
<dt>ch</dt><dd><p>a character vector containing the encounter history of
each bird</p>
</dd> <dt>perm</dt><dd><p>a factor variable indicating whether the animal is 
permanently marked (&quot;yes&quot;) or not (&quot;no&quot;) </p>
</dd></dl>



<h3>Note</h3>


<p>Data were simulated with the following code:
</p>
<pre>
# simulate some double-tag data for 1000 animals
 
# over 5 cohorts and 6 sampling occasions; loss rate varies 

# across tags and tag loss is dependent (beta=3)
set.seed(299811)
simdata=simHMM(data=data.frame(ch=c("++,0,0,0,0,0","0,++,0,0,0,0","0,0,++,0,0,0",
						             "0,0,0,++,0,0","0,0,0,0,++,+-"),
				                     freq=rep(1000/5,5)),model="hmmcjs2tl",
		                             model.parameters=list(tau=list(formula=~tag1+tag2+tag1:tag2)),
				                     initial=list(Phi=log(9),p=log(.666),tau=c(-2,-1,3)))

# treat every other animal as permanently marked;
# 00 observations are possible
simdata$perm=as.factor(rep(c("no","yes"),500))
# for non-permanently marked animals change 
# "--" observations to "0" because 
# they could not be detected
simdata$ch[simdata$perm=="no"]=gsub("--","0",simdata$ch[simdata$perm=="no"])
# save data
tagloss=simdata
save(tagloss,file="tagloss.rda")
</pre>



<h3>Examples</h3>

<pre><code class='language-R'>
# This example is excluded from testing to reduce package check time
# get data; the beta parameters used to simulate the data were
# Phi: 2.197, p: -0.4064  Tau:-2,-1,3
data(tagloss)
# process data with double-tag CJS model and use perm field to create groups; 
# one half are permanently marked
dp=process.data(tagloss,model="hmmcjs2tl",groups="perm")
# create default design data
ddl=make.design.data(dp)
#set p=0 when the animal is not permanently marked if it goes to state 00 (both tags lost)
#which is equivalent to tag1=1 and tag2=1. The tag1, tag2 fields are created as part of default
#design data for p and tau.
#For p, there are 4 records for each occasion for each animal. The records are 
#for the 4 possible tag loss states: 11,10,01,00. For the first occasion an animal was
#seen, p=1 (fix=1).
tail(ddl$p)
#For tau, there are 4 records for each occasion for each animal. The records are 
#for the 4 possible tag loss states: 11,10,01,00. For state 11, tau=1 (fix=1) because
#a multinomial logit is used for this model. One of the values need to be fixed to 1
#to make the parameters identifiable because the probabilities sum to 1 for the 
#transitions to the tag states. 
tail(ddl$tau)
# For Phi there is a single record per occasion(interval) per animal.
tail(ddl$Phi)
# Animals that are not permanently marked cannot be seen in state 00 which is the 
# same as tag1==1 &amp; tag2==1
ddl$p$fix[ddl$p$perm=="no"&amp;ddl$p$tag1==1&amp;ddl$p$tag2==1]=0
# First fit a model assuming tag loss does not vary for the 2 tags. In that case,
# the probability is beta for a single loss and 2*beta for double loss. We get that
# model using I(tag1+tag2) which has values 0,1,2. Note that for the tau 
# parameter the intercept is removed automatically. Also tag loss is independent in this
# model.
mod0=crm(dp,ddl,model.parameters=list(tau=list(formula=~I(tag1+tag2))),
        initial=list(Phi=2,p=.3,tau=c(-1)),hessian=TRUE,save.matrices=TRUE)
# now fit a model allowing different loss rates for each tag but still independent
mod1=crm(dp,ddl,model.parameters=list(tau=list(formula=~tag1+tag2)),
        initial=list(Phi=2,p=.3,tau=c(-2,-1)),hessian=TRUE,save.matrices=TRUE)
# now fit the model that was used to generate the data with dependence
mod2=crm(dp,ddl,model.parameters=list(tau=list(formula=~tag1+tag2+tag1:tag2)),
        initial=list(Phi=2,p=.3,tau=c(-2,-1,3)),hessian=TRUE,save.matrices=TRUE)
# Now treat all as not permanently marked
tagloss$ch=gsub("--","0",tagloss$ch)
dp=process.data(tagloss,model="hmmcjs2tl")
ddl=make.design.data(dp)
ddl$p$fix[ddl$p$tag1==1&amp;ddl$p$tag2==1]=0
mod3=crm(dp,ddl,model.parameters=list(tau=list(formula=~tag1+tag2)),
        initial=list(Phi=2,p=.3,tau=c(-2,-1)),hessian=TRUE,save.matrices=TRUE)
# Model 2 is the best model but note that even though the tag loss model is
# incorrect in models 0 and 1 which assume independence, the survival estimate is
# only slightly less than for model 2. The model compensates by increasing the indiviudal
# tag loss rates to explain the observed 00's with the permanently marked animals.  Thus, if
# if you have enough marked animals you could end up with little bias in survival even if you 
# have the wrong tag loss model.
mod0
mod1
mod2
# Note in model 3, even though tag-loss specific rates are estimated correctly
# survival is biased low because tag loss was dependent in simulating data
# but was assumed to be independent in fitted model and because there are no -- observations,
# the model assumes what are unobserved excess 00's are dead, so the survival estimate will be
# negatively biased. Note the data are different and AIC not comparable to other models.
mod3
if(require(expm))
{
   tag_status=function(k,x) 
   {
	    mat=t(sapply(1:k,function(k,x) (x%^%k)[1,] ,x=x))
	    colnames(mat)=c("11","10","01","00","Dead")
	    rownames(mat)=1:k
	    return(mat)
    }
    par(mfrow=c(1,4))
    barplot(t(tag_status(4,mod0$results$mat$gamma[1,1,,])),
     beside=TRUE,ylim=c(0,1),main="mod0",legend.text=c("11","10","01","00","Dead"),
     args.legend=list(x=20,y=.9)) 
    barplot(t(tag_status(4,mod1$results$mat$gamma[1,1,,])),beside=TRUE,
                  ylim=c(0,1),main="mod1")
    barplot(t(tag_status(4,mod2$results$mat$gamma[1,1,,])),beside=TRUE,
                  ylim=c(0,1),main="mod2")
    barplot(t(tag_status(4,mod3$results$mat$gamma[1,1,,])),beside=TRUE,
                   ylim=c(0,1),main="mod3")
}
unlink("*.cpp")
unlink("*.o")
unlink("symbols.rds")

</code></pre>

<hr>
<h2 id='valid.parameters'>Determine validity of parameters for a model (internal use)</h2><span id='topic+valid.parameters'></span>

<h3>Description</h3>

<p>Checks to make sure specified parameters are valid for a particular type of
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valid.parameters(model, parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="valid.parameters_+3A_model">model</code></td>
<td>
<p>type of c-r model (&quot;CJS&quot;, &quot;Burnham&quot; etc)</p>
</td></tr>
<tr><td><code id="valid.parameters_+3A_parameters">parameters</code></td>
<td>
<p>vector of parameter names (for example &quot;Phi&quot; or &quot;p&quot; or
&quot;S&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical; TRUE if all parameters are acceptable and FALSE otherwise
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setup.parameters">setup.parameters</a></code>, <code><a href="#topic+setup.model">setup.model</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
