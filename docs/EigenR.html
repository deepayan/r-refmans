<!DOCTYPE html><html><head><title>Help for package EigenR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EigenR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Eigen_absdet'><p>Absolute value of the determinant</p></a></li>
<li><a href='#Eigen_chol'><p>Cholesky decomposition of a matrix</p></a></li>
<li><a href='#Eigen_cos'><p>Matrix cosine</p></a></li>
<li><a href='#Eigen_cosh'><p>Matrix hyperbolic cosine</p></a></li>
<li><a href='#Eigen_det'><p>Determinant of a matrix</p></a></li>
<li><a href='#Eigen_exp'><p>Exponential of a matrix</p></a></li>
<li><a href='#Eigen_inverse'><p>Inverse of a matrix</p></a></li>
<li><a href='#Eigen_isInjective'><p>Check injectivity</p></a></li>
<li><a href='#Eigen_isInvertible'><p>Check invertibility</p></a></li>
<li><a href='#Eigen_isSurjective'><p>Check surjectivity</p></a></li>
<li><a href='#Eigen_kernel'><p>Kernel of a matrix</p></a></li>
<li><a href='#Eigen_kernelDimension'><p>Dimension of kernel</p></a></li>
<li><a href='#Eigen_log'><p>Logarithm of a matrix</p></a></li>
<li><a href='#Eigen_logabsdet'><p>Logarithm of the absolute value of the determinant</p></a></li>
<li><a href='#Eigen_lsSolve'><p>Linear least-squares problems</p></a></li>
<li><a href='#Eigen_pinverse'><p>Pseudo-inverse of a matrix</p></a></li>
<li><a href='#Eigen_pow'><p>Matricial power</p></a></li>
<li><a href='#Eigen_QR'><p>QR decomposition of a matrix</p></a></li>
<li><a href='#Eigen_range'><p>Range of a matrix</p></a></li>
<li><a href='#Eigen_rank'><p>Rank of a matrix</p></a></li>
<li><a href='#Eigen_sin'><p>Matrix sine</p></a></li>
<li><a href='#Eigen_sinh'><p>Matrix hyperbolic sine</p></a></li>
<li><a href='#Eigen_sqrt'><p>Square root of a matrix</p></a></li>
<li><a href='#Eigen_UtDU'><p>'UtDU' decomposition of a matrix</p></a></li>
<li><a href='#SparseMatrix'><p>Sparse matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Complex Matrix Algebra with 'Eigen'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Stéphane Laurent</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stéphane Laurent &lt;laurent_step@outlook.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Matrix algebra using the 'Eigen' C++ library: determinant, rank, inverse, pseudo-inverse, kernel and image, QR decomposition, Cholesky decomposition, linear least-squares problems. Also provides matrix functions such as exponential, logarithm, power, sine and cosine. Complex matrices are supported.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.5)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stla/EigenR">https://github.com/stla/EigenR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stla/EigenR/issues">https://github.com/stla/EigenR/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-17 12:37:49 UTC; SDL96354</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-18 09:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Eigen_absdet'>Absolute value of the determinant</h2><span id='topic+Eigen_absdet'></span>

<h3>Description</h3>

<p>Absolute value of the determinant of a real matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_absdet(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_absdet_+3A_m">M</code></td>
<td>
<p>a <em>real</em> square matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The absolute value of the determinant of <code>M</code>.
</p>


<h3>Note</h3>

<p>'Eigen_absdet(M)' is not faster than 'abs(Eigen_det(M))'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(666L)
M &lt;- matrix(rpois(25L, 1), 5L, 5L)
Eigen_absdet(M)
</code></pre>

<hr>
<h2 id='Eigen_chol'>Cholesky decomposition of a matrix</h2><span id='topic+Eigen_chol'></span>

<h3>Description</h3>

<p>Cholesky decomposition of a symmetric or Hermitian matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_chol(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_chol_+3A_m">M</code></td>
<td>
<p>a square symmetric/Hermitian positive-definite matrix or 
<code><a href="#topic+SparseMatrix">SparseMatrix</a></code>, real/complex</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Symmetry is not checked; only the lower triangular part of 
<code>M</code> is used.
</p>


<h3>Value</h3>

<p>The upper triangular factor of the Cholesky decomposition of 
<code>M</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- rbind(c(5,1), c(1,3))
U &lt;- Eigen_chol(M)
t(U) %*% U # this is `M`
# a Hermitian example:
A &lt;- rbind(c(1,1i), c(1i,2))
( M &lt;- A %*% t(Conj(A)) )
try(chol(M)) # fails
U &lt;- Eigen_chol(M) 
t(Conj(U)) %*% U # this is `M`
# a sparse example
M &lt;- asSparseMatrix(diag(1:5))
Eigen_chol(M)
</code></pre>

<hr>
<h2 id='Eigen_cos'>Matrix cosine</h2><span id='topic+Eigen_cos'></span>

<h3>Description</h3>

<p>Matrix cosine of a real or complex square matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_cos(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_cos_+3A_m">M</code></td>
<td>
<p>a square matrix, real or complex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix cosine of <code>M</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(EigenR)
M &lt;- toeplitz(c(1,2,3))
cosM &lt;- Eigen_cos(M) 
sinM &lt;- Eigen_sin(M)
cosM %*% cosM + sinM %*% sinM # identity matrix
</code></pre>

<hr>
<h2 id='Eigen_cosh'>Matrix hyperbolic cosine</h2><span id='topic+Eigen_cosh'></span>

<h3>Description</h3>

<p>Matrix hyperbolic cosine of a real or complex square matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_cosh(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_cosh_+3A_m">M</code></td>
<td>
<p>a square matrix, real or complex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix hyperbolic cosine of <code>M</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(EigenR)
M &lt;- toeplitz(c(1,2,3))
Eigen_cosh(M)
(Eigen_exp(M) + Eigen_exp(-M)) / 2 # identical
</code></pre>

<hr>
<h2 id='Eigen_det'>Determinant of a matrix</h2><span id='topic+Eigen_det'></span>

<h3>Description</h3>

<p>Determinant of a real or complex matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_det(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_det_+3A_m">M</code></td>
<td>
<p>a square matrix or <code><a href="#topic+SparseMatrix">SparseMatrix</a></code>, real or complex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The determinant of <code>M</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(666)
M &lt;- matrix(rpois(25, 1), 5L, 5L)
Eigen_det(M)
# determinants of complex matrices are supported:
Eigen_det(M + 1i * M)
# as well as determinants of sparse matrices:
Eigen_det(asSparseMatrix(M))
Eigen_det(asSparseMatrix(M + 1i * M))
</code></pre>

<hr>
<h2 id='Eigen_exp'>Exponential of a matrix</h2><span id='topic+Eigen_exp'></span>

<h3>Description</h3>

<p>Exponential of a real or complex square matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_exp(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_exp_+3A_m">M</code></td>
<td>
<p>a square matrix, real or complex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The exponential of <code>M</code>.
</p>

<hr>
<h2 id='Eigen_inverse'>Inverse of a matrix</h2><span id='topic+Eigen_inverse'></span>

<h3>Description</h3>

<p>Inverse of a real or complex matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_inverse(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_inverse_+3A_m">M</code></td>
<td>
<p>an invertible square matrix, real or complex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The inverse matrix of <code>M</code>.
</p>

<hr>
<h2 id='Eigen_isInjective'>Check injectivity</h2><span id='topic+Eigen_isInjective'></span>

<h3>Description</h3>

<p>Checks whether a matrix represents an injective linear map 
(i.e. has trivial kernel).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_isInjective(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_isInjective_+3A_m">M</code></td>
<td>
<p>a matrix, real or complex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Boolean value indicating whether <code>M</code> represents an injective 
linear map.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(666L)
M &lt;- matrix(rpois(35L, 1), 5L, 7L)
Eigen_isInjective(M)
</code></pre>

<hr>
<h2 id='Eigen_isInvertible'>Check invertibility</h2><span id='topic+Eigen_isInvertible'></span>

<h3>Description</h3>

<p>Checks whether a matrix is invertible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_isInvertible(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_isInvertible_+3A_m">M</code></td>
<td>
<p>a matrix, real or complex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Boolean value indicating whether <code>M</code> is invertible.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(666L)
M &lt;- matrix(rpois(25L, 1), 5L, 5L)
Eigen_isInvertible(M)
</code></pre>

<hr>
<h2 id='Eigen_isSurjective'>Check surjectivity</h2><span id='topic+Eigen_isSurjective'></span>

<h3>Description</h3>

<p>Checks whether a matrix represents a surjective linear map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_isSurjective(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_isSurjective_+3A_m">M</code></td>
<td>
<p>a matrix, real or complex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Boolean value indicating whether <code>M</code> represents a surjective 
linear map.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(666L)
M &lt;- matrix(rpois(35L, 1), 7L, 5L)
Eigen_isSurjective(M)
</code></pre>

<hr>
<h2 id='Eigen_kernel'>Kernel of a matrix</h2><span id='topic+Eigen_kernel'></span>

<h3>Description</h3>

<p>Kernel (null-space) of a real or complex matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_kernel(M, method = "COD")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_kernel_+3A_m">M</code></td>
<td>
<p>a matrix, real or complex</p>
</td></tr>
<tr><td><code id="Eigen_kernel_+3A_method">method</code></td>
<td>
<p>one of <code>"COD"</code> or <code>"LU"</code>; the faster method depends 
on the size of the matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A basis of the kernel of <code>M</code>. With <code>method = "COD"</code>, the 
basis is orthonormal, while it is not with <code>method = "LU"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(666)
M &lt;- matrix(rgamma(30L, 12, 1), 10L, 3L)
M &lt;- cbind(M, M[,1]+M[,2], M[,2]+2*M[,3])
# basis of the kernel of `M`:
Eigen_kernel(M, method = "LU")
# orthonormal basis of the kernel of `M`:
Eigen_kernel(M, method = "COD")
</code></pre>

<hr>
<h2 id='Eigen_kernelDimension'>Dimension of kernel</h2><span id='topic+Eigen_kernelDimension'></span>

<h3>Description</h3>

<p>Dimension of the kernel of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_kernelDimension(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_kernelDimension_+3A_m">M</code></td>
<td>
<p>a matrix, real or complex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer, the dimension of the kernel of <code>M</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Eigen_isInjective">Eigen_isInjective</a></code>, <code><a href="#topic+Eigen_kernel">Eigen_kernel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(666L)
M &lt;- matrix(rpois(35L, 1), 5L, 7L)
Eigen_kernelDimension(M)
</code></pre>

<hr>
<h2 id='Eigen_log'>Logarithm of a matrix</h2><span id='topic+Eigen_log'></span>

<h3>Description</h3>

<p>Logarithm of a real or complex square matrix, when possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_log(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_log_+3A_m">M</code></td>
<td>
<p>a square matrix, real or complex</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The logarithm of a matrix does not always exist. 
See <a href="https://eigen.tuxfamily.org/dox/unsupported/group__MatrixFunctions__Module.html#title7">matrix logarithm</a>.
</p>


<h3>Value</h3>

<p>The logarithm of <code>M</code>.
</p>

<hr>
<h2 id='Eigen_logabsdet'>Logarithm of the absolute value of the determinant</h2><span id='topic+Eigen_logabsdet'></span>

<h3>Description</h3>

<p>Logarithm of the absolute value of the determinant of a real 
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_logabsdet(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_logabsdet_+3A_m">M</code></td>
<td>
<p>a <em>real</em> square matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The logarithm of the absolute value of the determinant of <code>M</code>.
</p>


<h3>Note</h3>

<p>'Eigen_logabsdet(M)' is not faster than 'log(abs(Eigen_det(M)))'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(666L)
M &lt;- matrix(rpois(25L, 1), 5L, 5L)
Eigen_logabsdet(M)
</code></pre>

<hr>
<h2 id='Eigen_lsSolve'>Linear least-squares problems</h2><span id='topic+Eigen_lsSolve'></span>

<h3>Description</h3>

<p>Solves a linear least-squares problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_lsSolve(A, b, method = "cod")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_lsSolve_+3A_a">A</code></td>
<td>
<p>a <code>n*p</code> matrix, real or complex</p>
</td></tr>
<tr><td><code id="Eigen_lsSolve_+3A_b">b</code></td>
<td>
<p>a vector of length <code>n</code> or a matrix with <code>n</code> rows, 
real or complex</p>
</td></tr>
<tr><td><code id="Eigen_lsSolve_+3A_method">method</code></td>
<td>
<p>the method used to solve the problem, either <code>"svd"</code> 
(based on the SVD decomposition) or <code>"cod"</code> (based on the 
complete orthogonal decomposition)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The solution <code>X</code> of the least-squares problem <code>AX ~= b</code> 
(similar to <code>lm.fit(A, b)$coefficients</code>). This is a matrix if 
<code>b</code> is a matrix, or a vector if <code>b</code> is a vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(129)
n &lt;- 7; p &lt;- 2
A &lt;- matrix(rnorm(n * p), n, p)
b &lt;- rnorm(n)
lsfit &lt;- Eigen_lsSolve(A, b)
b - A %*% lsfit # residuals
</code></pre>

<hr>
<h2 id='Eigen_pinverse'>Pseudo-inverse of a matrix</h2><span id='topic+Eigen_pinverse'></span>

<h3>Description</h3>

<p>Pseudo-inverse of a real or complex matrix 
(Moore-Penrose generalized inverse).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_pinverse(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_pinverse_+3A_m">M</code></td>
<td>
<p>a matrix, real or complex, not necessarily square</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The pseudo-inverse matrix of <code>M</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(EigenR)
M &lt;- rbind(
  toeplitz(c(3, 2, 1)), 
  toeplitz(c(4, 5, 6))
)
Mplus &lt;- Eigen_pinverse(M)
all.equal(M, M %*% Mplus %*% M)
all.equal(Mplus, Mplus %*% M %*% Mplus)
#' a complex matrix
A &lt;- M + 1i * M[, c(3L, 2L, 1L)]
Aplus &lt;- Eigen_pinverse(A)
AAplus &lt;- A %*% Aplus
all.equal(AAplus, t(Conj(AAplus))) #' `A %*% Aplus` is Hermitian
AplusA &lt;- Aplus %*% A
all.equal(AplusA, t(Conj(AplusA))) #' `Aplus %*% A` is Hermitian
</code></pre>

<hr>
<h2 id='Eigen_pow'>Matricial power</h2><span id='topic+Eigen_pow'></span>

<h3>Description</h3>

<p>Matricial power of a real or complex square matrix, when possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_pow(M, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_pow_+3A_m">M</code></td>
<td>
<p>a square matrix, real or complex</p>
</td></tr>
<tr><td><code id="Eigen_pow_+3A_p">p</code></td>
<td>
<p>a number, real or complex, the power exponent</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The power is defined with the help of the exponential and the 
logarithm. See <a href="https://eigen.tuxfamily.org/dox/unsupported/group__MatrixFunctions__Module.html#title8">matrix power</a>.
</p>


<h3>Value</h3>

<p>The matrix <code>M</code> raised at the power <code>p</code>.
</p>

<hr>
<h2 id='Eigen_QR'>QR decomposition of a matrix</h2><span id='topic+Eigen_QR'></span>

<h3>Description</h3>

<p>QR decomposition of a real or complex matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_QR(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_QR_+3A_m">M</code></td>
<td>
<p>a matrix, real or complex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the <code>Q</code> matrix and the <code>R</code> matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- cbind(c(1,2,3), c(4,5,6))
x &lt;- Eigen_QR(M)
x$Q %*% x$R
</code></pre>

<hr>
<h2 id='Eigen_range'>Range of a matrix</h2><span id='topic+Eigen_range'></span>

<h3>Description</h3>

<p>Range (column-space, image, span) of a real or complex matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_range(M, method = "QR")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_range_+3A_m">M</code></td>
<td>
<p>a matrix, real or complex</p>
</td></tr>
<tr><td><code id="Eigen_range_+3A_method">method</code></td>
<td>
<p>one of <code>"LU"</code>, <code>"QR"</code>, or <code>"COD"</code>; the 
<code>"LU"</code> method is faster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A basis of the range of <code>M</code>. With <code>method = "LU"</code>, the 
basis is not orthonormal, while it is with <code>method = "QR"</code> and 
<code>method = "COD"</code>.
</p>

<hr>
<h2 id='Eigen_rank'>Rank of a matrix</h2><span id='topic+Eigen_rank'></span>

<h3>Description</h3>

<p>Rank of a real or complex matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_rank(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_rank_+3A_m">M</code></td>
<td>
<p>a matrix, real or complex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The rank of <code>M</code>.
</p>

<hr>
<h2 id='Eigen_sin'>Matrix sine</h2><span id='topic+Eigen_sin'></span>

<h3>Description</h3>

<p>Matrix sine of a real or complex square matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_sin(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_sin_+3A_m">M</code></td>
<td>
<p>a square matrix, real or complex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix sine of <code>M</code>.
</p>

<hr>
<h2 id='Eigen_sinh'>Matrix hyperbolic sine</h2><span id='topic+Eigen_sinh'></span>

<h3>Description</h3>

<p>Matrix hyperbolic sine of a real or complex square matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_sinh(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_sinh_+3A_m">M</code></td>
<td>
<p>a square matrix, real or complex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix hyperbolic sine of <code>M</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(EigenR)
M &lt;- toeplitz(c(1,2,3))
Eigen_sinh(M)
(Eigen_exp(M) - Eigen_exp(-M)) / 2  # identical
</code></pre>

<hr>
<h2 id='Eigen_sqrt'>Square root of a matrix</h2><span id='topic+Eigen_sqrt'></span>

<h3>Description</h3>

<p>Square root of a real or complex square matrix, when possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_sqrt(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_sqrt_+3A_m">M</code></td>
<td>
<p>a square matrix, real or complex</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://eigen.tuxfamily.org/dox/unsupported/group__MatrixFunctions__Module.html#title12">matrix square root</a>.
</p>


<h3>Value</h3>

<p>A square root of <code>M</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Rotation matrix over 60 degrees:
M &lt;- cbind(c(cos(pi/3), sin(pi/3)), c(-sin(pi/3), cos(pi/3)))
# Its square root, the rotation matrix over 30 degrees:
Eigen_sqrt(M)
</code></pre>

<hr>
<h2 id='Eigen_UtDU'>'UtDU' decomposition of a matrix</h2><span id='topic+Eigen_UtDU'></span>

<h3>Description</h3>

<p>Cholesky-'UtDU' decomposition of a symmetric or Hermitian matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen_UtDU(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_UtDU_+3A_m">M</code></td>
<td>
<p>a square symmetric/Hermitian positive or negative semidefinite 
matrix, real/complex</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Symmetry is not checked; only the lower triangular part of 
<code>M</code> is used.
</p>


<h3>Value</h3>

<p>The Cholesky-'UtDU' decomposition of <code>M</code> in a list 
(see example).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(1:5, (1:5)^2), 5, 2)
x &lt;- cbind(x, x[, 1] + 3*x[, 2])
M &lt;- crossprod(x)
UtDU &lt;- Eigen_UtDU(M)
U &lt;- UtDU$U
D &lt;- UtDU$D
perm &lt;- UtDU$perm
UP &lt;- U[, perm]
t(UP) %*% diag(D) %*% UP # this is `M`
</code></pre>

<hr>
<h2 id='SparseMatrix'>Sparse matrix</h2><span id='topic+SparseMatrix'></span><span id='topic+print.SparseMatrix'></span><span id='topic+asSparseMatrix'></span>

<h3>Description</h3>

<p>Constructs a sparse matrix, real or complex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SparseMatrix(i, j, Mij, nrows, ncols)

## S3 method for class 'SparseMatrix'
print(x, ...)

asSparseMatrix(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseMatrix_+3A_i">i</code>, <code id="SparseMatrix_+3A_j">j</code></td>
<td>
<p>indices of the non-zero coefficients</p>
</td></tr>
<tr><td><code id="SparseMatrix_+3A_mij">Mij</code></td>
<td>
<p>values of the non-zero coefficients; must be a vector of the same 
length as <code>i</code> and <code>j</code> or a single number which will be recycled</p>
</td></tr>
<tr><td><code id="SparseMatrix_+3A_nrows">nrows</code>, <code id="SparseMatrix_+3A_ncols">ncols</code></td>
<td>
<p>dimensions of the matrix</p>
</td></tr>
<tr><td><code id="SparseMatrix_+3A_x">x</code></td>
<td>
<p>a <code>SparseMatrix</code> object</p>
</td></tr>
<tr><td><code id="SparseMatrix_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="SparseMatrix_+3A_m">M</code></td>
<td>
<p>a matrix, real or complex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the class <code>SparseMatrix</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(666)
( M &lt;- matrix(rpois(50L, 1), 10L, 5L) )
asSparseMatrix(M)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
