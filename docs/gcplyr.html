<!DOCTYPE html><html><head><title>Help for package gcplyr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gcplyr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#auc'><p>Calculate area under the curve</p></a></li>
<li><a href='#block_tidydesign'><p>Turn tidydesign into block format</p></a></li>
<li><a href='#calc_deriv'><p>Calculate derivatives of vector of data</p></a></li>
<li><a href='#doubling_time'><p>Calculate doubling time equivalent of per-capita growth rate</p></a></li>
<li><a href='#example_design_tidy'><p>Design for example growth curve data</p>
</p>
<p>A tidy-shaped dataset with the experimental design (i.e. plate layout)</p>
for the example data included with <code>gcplyr</code>.</a></li>
<li><a href='#example_widedata'><p>Example noisy growth curve data in wide format</p></a></li>
<li><a href='#example_widedata_noiseless'><p>Example growth curve data in wide format</p></a></li>
<li><a href='#extr_val'><p>Extract parts of an object</p></a></li>
<li><a href='#ExtremaFunctions'><p>Find local extrema of a numeric vector</p></a></li>
<li><a href='#first_peak'><p>Find the first local maxima of a numeric vector</p></a></li>
<li><a href='#from_excel'><p>A function that converts base-26 Excel-style letters to numbers</p></a></li>
<li><a href='#gc_smooth.spline'><p>Fit a Smoothing Spline</p></a></li>
<li><a href='#import_blockdesigns'><p>Import blockdesigns</p></a></li>
<li><a href='#import_blockmeasures'><p>Import blockmeasures</p></a></li>
<li><a href='#lag_time'><p>Calculate lag time</p></a></li>
<li><a href='#make_design'><p>Make design data.frame(s)</p></a></li>
<li><a href='#make_designpattern'><p>Make design pattern</p></a></li>
<li><a href='#make_example'><p>Create R objects or files as seen in vignette examples</p></a></li>
<li><a href='#make_tidydesign'><p>Make tidy design data.frames</p></a></li>
<li><a href='#makemethod_train_smooth_data'><p>Create method argument for <code>caret::train</code> of growth curve smoothers</p></a></li>
<li><a href='#merge_dfs'><p>Collapse a list of dataframes, or merge two dataframes together</p></a></li>
<li><a href='#MinMaxGC'><p>Maxima and Minima</p></a></li>
<li><a href='#MovingWindowFunctions'><p>Moving window smoothing</p></a></li>
<li><a href='#paste_blocks'><p>Paste a list of blocks into a single block</p></a></li>
<li><a href='#predict_interpolation'><p>Predict data by linear interpolation from existing data</p></a></li>
<li><a href='#print_df'><p>Nicely print the contents of a data.frame</p></a></li>
<li><a href='#read_blocks'><p>Read blockmeasures</p></a></li>
<li><a href='#read_tidys'><p>Read tidy-shaped files</p></a></li>
<li><a href='#read_wides'><p>Read wides</p></a></li>
<li><a href='#separate_tidy'><p>Separate a column into multiple columns</p></a></li>
<li><a href='#smooth_data'><p>Smooth data</p></a></li>
<li><a href='#solve_linear'><p>Return missing information about a line</p></a></li>
<li><a href='#ThresholdFunctions'><p>Find point(s) when a numeric vector crosses some threshold</p></a></li>
<li><a href='#to_excel'><p>A function that converts numbers into base-26 Excel-style letters</p></a></li>
<li><a href='#train_smooth_data'><p>Test efficacy of different smoothing parameters</p></a></li>
<li><a href='#trans_block_to_wide'><p>Transform blocks to wides</p></a></li>
<li><a href='#trans_wide_to_tidy'><p>Pivot widemeasures longer</p></a></li>
<li><a href='#uninterleave'><p>Uninterleave list</p></a></li>
<li><a href='#WhichMinMaxGC'><p>Where is the Min() or Max() or first TRUE or FALSE?</p></a></li>
<li><a href='#write_blocks'><p>Write block designs to csv</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Wrangle and Analyze Growth Curve Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.9.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-11</td>
</tr>
<tr>
<td>Description:</td>
<td>Easy wrangling and model-free analysis of
    microbial growth curve data, as commonly output by plate readers.
    Tools for reshaping common plate reader outputs into 'tidy' formats and
    merging them with design information, making data easy to work with using 
    'gcplyr' and other packages. Also streamlines common growth curve
    processing steps, like smoothing and calculating derivatives, and
    facilitates model-free characterization and analysis of growth data.
    See methods at <a href="https://mikeblazanin.github.io/gcplyr/">https://mikeblazanin.github.io/gcplyr/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mikeblazanin.github.io/gcplyr/">https://mikeblazanin.github.io/gcplyr/</a>,
<a href="https://github.com/mikeblazanin/gcplyr/">https://github.com/mikeblazanin/gcplyr/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, rlang, stats, tidyr, tools, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>caret, cowplot, ggplot2, knitr, lubridate, mgcv, readxl,
rmarkdown, testthat (&ge; 3.0.0), xlsx</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-11 17:43:22 UTC; mikeb</td>
</tr>
<tr>
<td>Author:</td>
<td>Mike Blazanin <a href="https://orcid.org/0000-0003-4630-6235"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mike Blazanin &lt;mikeblazanin@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-11 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='auc'>Calculate area under the curve</h2><span id='topic+auc'></span>

<h3>Description</h3>

<p>This function takes a vector of <code>x</code> and <code>y</code> values
and returns a scalar for the area under the curve, calculated using 
the trapezoid rule
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc(
  x,
  y,
  xlim = NULL,
  blank = 0,
  subset = NULL,
  na.rm = TRUE,
  neg.rm = FALSE,
  warn_xlim_out_of_range = TRUE,
  warn_negative_y = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auc_+3A_x">x</code></td>
<td>
<p>Numeric vector of x values</p>
</td></tr>
<tr><td><code id="auc_+3A_y">y</code></td>
<td>
<p>Numeric vector of y values</p>
</td></tr>
<tr><td><code id="auc_+3A_xlim">xlim</code></td>
<td>
<p>Vector, of length 2, delimiting the x range over which the
area under the curve should be calculated (where NA can be
provided for the area to be calculated from the start or to
the end of the data)</p>
</td></tr>
<tr><td><code id="auc_+3A_blank">blank</code></td>
<td>
<p>Value to be subtracted from <code>y</code> values before calculating
area under the curve</p>
</td></tr>
<tr><td><code id="auc_+3A_subset">subset</code></td>
<td>
<p>A vector of logical values indicating which x and y values
should be included (TRUE) or excluded (FALSE).</p>
</td></tr>
<tr><td><code id="auc_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether missing values should be removed</p>
</td></tr>
<tr><td><code id="auc_+3A_neg.rm">neg.rm</code></td>
<td>
<p>a logical indicating whether <code>y</code> values below zero should 
be treated as zeros. If <code>FALSE</code>, area under the curve
for negative <code>y</code> values will be calculated normally,
effectively subtracting from the returned value.</p>
</td></tr>
<tr><td><code id="auc_+3A_warn_xlim_out_of_range">warn_xlim_out_of_range</code></td>
<td>
<p>logical whether warning should be issued when 
xlim is lower than the lowest x value or higher
than the highest x value.</p>
</td></tr>
<tr><td><code id="auc_+3A_warn_negative_y">warn_negative_y</code></td>
<td>
<p>logical whether warning should be issued when 
<code>neg.rm == FALSE</code> but some y values are below 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar for the total area under the curve
</p>

<hr>
<h2 id='block_tidydesign'>Turn tidydesign into block format</h2><span id='topic+block_tidydesign'></span>

<h3>Description</h3>

<p>This function allows users to convert designs created with tidydesign
into a block format for easy output to csv for inclusion in lab notebooks,
etc in a human-readable format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_tidydesign(
  tidydesign,
  collapse = NULL,
  wellnames_sep = "_",
  wellnames_colname = "Well"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block_tidydesign_+3A_tidydesign">tidydesign</code></td>
<td>
<p>A tidydesign data.frame (e.g. as created by make_tidydesign)</p>
</td></tr>
<tr><td><code id="block_tidydesign_+3A_collapse">collapse</code></td>
<td>
<p>NULL or a string to use for concatenating design elements
together. If NULL each design column will be put into its
own block. If a string, that string will be used to <code>paste</code>
together all design elements and all design elements will
be returned in a single block</p>
</td></tr>
<tr><td><code id="block_tidydesign_+3A_wellnames_sep">wellnames_sep</code></td>
<td>
<p>A string used when concatenating rownames and column
names to create well names</p>
</td></tr>
<tr><td><code id="block_tidydesign_+3A_wellnames_colname">wellnames_colname</code></td>
<td>
<p>Header for newly-created column containing the
well names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of blockdesign data.frames (if <code>collapse</code> is not
<code>NULL</code> the list is of length 1
</p>

<hr>
<h2 id='calc_deriv'>Calculate derivatives of vector of data</h2><span id='topic+calc_deriv'></span>

<h3>Description</h3>

<p>Provided a vector of y values, this function returns either the plain
or per-capita difference or derivative between sequential values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_deriv(
  y,
  x = NULL,
  return = "derivative",
  percapita = FALSE,
  x_scale = 1,
  blank = NULL,
  subset_by = NULL,
  window_width = NULL,
  window_width_n = NULL,
  window_width_frac = NULL,
  window_width_n_frac = NULL,
  trans_y = "linear",
  na.rm = TRUE,
  warn_ungrouped = TRUE,
  warn_logtransform_warnings = TRUE,
  warn_logtransform_infinite = TRUE,
  warn_window_toosmall = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_deriv_+3A_y">y</code></td>
<td>
<p>Data to calculate difference or derivative of</p>
</td></tr>
<tr><td><code id="calc_deriv_+3A_x">x</code></td>
<td>
<p>Vector of x values provided as a simple numeric.</p>
</td></tr>
<tr><td><code id="calc_deriv_+3A_return">return</code></td>
<td>
<p>One of c(&quot;difference&quot;, &quot;derivative&quot;) for whether the
differences in <code>y</code> should be returned, or the
derivative of <code>y</code> with respect to <code>x</code></p>
</td></tr>
<tr><td><code id="calc_deriv_+3A_percapita">percapita</code></td>
<td>
<p>When percapita = TRUE, the per-capita difference or
derivative is returned</p>
</td></tr>
<tr><td><code id="calc_deriv_+3A_x_scale">x_scale</code></td>
<td>
<p>Numeric to scale x by in derivative calculation
</p>
<p>Set x_scale to the ratio of the units of 
x to the desired units. E.g. if x is in seconds, but the 
desired derivative is in units of /minute, set 
<code>x_scale = 60</code> (since there are 60 seconds in 1 minute).</p>
</td></tr>
<tr><td><code id="calc_deriv_+3A_blank">blank</code></td>
<td>
<p>y-value associated with a &quot;blank&quot; where the density is 0.
Is required when <code>percapita = TRUE</code>.
</p>
<p>If a vector of blank values is specified, blank values are
assumed to be in the same order as unique(subset_by)</p>
</td></tr>
<tr><td><code id="calc_deriv_+3A_subset_by">subset_by</code></td>
<td>
<p>An optional vector as long as <code>y</code>. 
<code>y</code> will be split by the unique values of this vector 
and the derivative for each group will be calculated 
independently of the others.
</p>
<p>This provides an internally-implemented approach similar
to <code>dplyr::group_by</code> and <code>dplyr::mutate</code></p>
</td></tr>
<tr><td><code id="calc_deriv_+3A_window_width">window_width</code>, <code id="calc_deriv_+3A_window_width_n">window_width_n</code>, <code id="calc_deriv_+3A_window_width_frac">window_width_frac</code>, <code id="calc_deriv_+3A_window_width_n_frac">window_width_n_frac</code></td>
<td>
<p>Set how many data points are used to determine
the slope at each point.
</p>
<p>When all are <code>NULL</code>, <code>calc_deriv</code> 
calculates the difference or derivative
of each point with the next point, appending
<code>NA</code> at the end.
</p>
<p>When one or multiple are specified, a linear regression 
is fit to all points in the window to determine the 
slope.
</p>
<p><code>window_width_n</code> specifies the width of the
window in number of data points. <code>window_width</code>
specifies the width of the window in units of <code>x</code>.
<code>window_width_n_frac</code> specifies the width of the
window as a fraction of the total number of data points.
</p>
<p>When using multiple window specifications at the same 
time, windows are conservative. Points 
included in each window will meet all of the 
<code>window_width</code>, <code>window_width_n</code>, and
<code>window_width_n_frac</code>.
</p>
<p>A value of <code>window_width_n = 3</code> or 
<code>window_width_n = 5</code> is often a good default.</p>
</td></tr>
<tr><td><code id="calc_deriv_+3A_trans_y">trans_y</code></td>
<td>
<p>One of <code>c("linear", "log")</code> specifying the
transformation of y-values.
</p>
<p><code>'log'</code> is only available when calculating per-capita
derivatives using a fitting approach (when non-default 
values are specified for <code>window_width</code> or 
<code>window_width_n</code>).
</p>
<p>For per-capita growth expected to be exponential or 
nearly-exponential, <code>"log"</code> is recommended, since 
exponential growth is linear when log-transformed. However, 
log-transformations must be used with care, since y-values 
at or below 0 will become undefined and results will be 
more sensitive to incorrect values of <code>blank</code>.</p>
</td></tr>
<tr><td><code id="calc_deriv_+3A_na.rm">na.rm</code></td>
<td>
<p>logical whether NA's should be removed before analyzing</p>
</td></tr>
<tr><td><code id="calc_deriv_+3A_warn_ungrouped">warn_ungrouped</code></td>
<td>
<p>logical whether warning should be issued when
<code>smooth_data</code> is being called on ungrouped data
and <code>subset_by = NULL</code>.</p>
</td></tr>
<tr><td><code id="calc_deriv_+3A_warn_logtransform_warnings">warn_logtransform_warnings</code></td>
<td>
<p>logical whether warning should be issued 
when log(y) produced warnings.</p>
</td></tr>
<tr><td><code id="calc_deriv_+3A_warn_logtransform_infinite">warn_logtransform_infinite</code></td>
<td>
<p>logical whether warning should be issued 
when log(y) produced infinite values that will
be treated as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="calc_deriv_+3A_warn_window_toosmall">warn_window_toosmall</code></td>
<td>
<p>logical whether warning should be issued 
when only one data point is in the window
set by <code>window_width_n</code>, 
<code>window_width</code>, or <code>window_width_n_frac</code>,
and so <code>NA</code> will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For per-capita derivatives, <code>trans_y = 'linear'</code> and
<code>trans_y = 'log'</code> approach the same value as time resolution
increases. 
</p>
<p>For instance, let's assume exponential growth <code class="reqn">N = e^rt</code> with 
per-capita growth rate <code class="reqn">r</code>.
</p>
<p>With <code>trans_y = 'linear'</code>, note that <code class="reqn">dN/dt = r e^rt = r N</code>. 
So we can calculate per-capita growth rate as <code class="reqn">r = dN/dt * 1/N</code>. 
</p>
<p>With <code>trans_y = 'log'</code>, note that <code class="reqn">log(N) = log(e^rt) = rt</code>.
So we can calculate per-capita growth rate as the slope of a linear
fit of <code class="reqn">log(N)</code> against time, <code class="reqn">r = log(N)/t</code>.
</p>


<h3>Value</h3>

<p>A vector of values for the plain (if <code>percapita = FALSE</code>)
or per-capita (if <code>percapita = TRUE</code>) difference 
(if <code>return = "difference"</code>) or derivative 
(if <code>return = "derivative"</code>) between <code>y</code> values. Vector
will be the same length as <code>y</code>,  with <code>NA</code> values 
at the ends
</p>

<hr>
<h2 id='doubling_time'>Calculate doubling time equivalent of per-capita growth rate</h2><span id='topic+doubling_time'></span>

<h3>Description</h3>

<p>Provided a vector of per-capita growth rates, this function returns 
the vector of equivalent doubling times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doubling_time(y, x_scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doubling_time_+3A_y">y</code></td>
<td>
<p>Vector of per-capita derivative data to calculate the 
equivalent doubling time of</p>
</td></tr>
<tr><td><code id="doubling_time_+3A_x_scale">x_scale</code></td>
<td>
<p>Numeric to scale per-capita derivative values by
</p>
<p>Set x_scale to the ratio of the the units of 
y to the desired units. E.g. if y is in per-second, but the 
desired doubling time is in minutes, <code>x_scale = 60</code> 
(since there are 60 seconds in 1 minute).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of values for the doubling time equivalent to the
per-capita growth rate supplied for <code>y</code>
</p>

<hr>
<h2 id='example_design_tidy'>Design for example growth curve data
A tidy-shaped dataset with the experimental design (i.e. plate layout)
for the example data included with <code>gcplyr</code>.</h2><span id='topic+example_design_tidy'></span>

<h3>Description</h3>

<p>Wells A1...A8 through F1...F8 contain 48 different
simulated bacterial strains growing alone. Wells G1...G8 through L1...L8
contain the same 48 bacterial strains in an identical layout, but this
time growing in the presence of a phage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_design_tidy
</code></pre>


<h3>Format</h3>

<p>A dataframe with 96 rows and 3 variables:
</p>

<dl>
<dt>Well</dt><dd><p>The well of the plate</p>
</dd>
<dt>Bacteria_strain</dt><dd><p>The numbered bacterial strain growing in each well</p>
</dd>
<dt>Phage</dt><dd><p>Whether or not the bacteria were simulated growing with phages</p>
</dd>
</dl>


<hr>
<h2 id='example_widedata'>Example noisy growth curve data in wide format</h2><span id='topic+example_widedata'></span>

<h3>Description</h3>

<p>A dataset containing example growth of 96 wells of simulated bacteria
or bacteria and phages
</p>
<p>Wells A1...A8 through F1...F8 contain 48 different
simulated bacterial strains growing alone. Wells G1...G8 through L1...L8
contain the same 48 bacterial strains in an identical layout, but this
time growing in the presence of a phage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_widedata
</code></pre>


<h3>Format</h3>

<p>A dataframe with 97 rows and 97 variables:
</p>

<dl>
<dt>time</dt><dd><p>time, in seconds, since growth curve began</p>
</dd>
<dt>A1, A2...H11, H12</dt><dd><p>bacterial density in the given well</p>
</dd>
</dl>



<h3>Details</h3>

<p>Bacterial populations exhibit diauxic growth as they approach their
carrying capacity, and they also evolve resistance in the face of 
selection from the phage population.
</p>
<p>This data includes some simulated noise to approximate the noise generated
during data collection by plate readers
</p>

<hr>
<h2 id='example_widedata_noiseless'>Example growth curve data in wide format</h2><span id='topic+example_widedata_noiseless'></span>

<h3>Description</h3>

<p>A dataset containing example growth of 96 wells of simulated bacteria
or bacteria and phages
</p>
<p>Wells A1...A8 through F1...F8 contain 48 different
simulated bacterial strains growing alone. Wells G1...G8 through L1...L8
contain the same 48 bacterial strains in an identical layout, but this
time growing in the presence of a phage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_widedata_noiseless
</code></pre>


<h3>Format</h3>

<p>A dataframe with 97 rows and 97 variables:
</p>

<dl>
<dt>time</dt><dd><p>time, in seconds, since growth curve began</p>
</dd>
<dt>A1, A2...H11, H12</dt><dd><p>bacterial density in the given well</p>
</dd>
</dl>



<h3>Details</h3>

<p>Bacterial populations exhibit diauxic growth as they approach their
carrying capacity, and they also evolve resistance in the face of 
selection from the phage population.
</p>
<p>This data does not include any simulated noise
</p>

<hr>
<h2 id='extr_val'>Extract parts of an object</h2><span id='topic+extr_val'></span>

<h3>Description</h3>

<p>A wrapper for <code>[</code> with handling of NA's for use in
<code>dplyr::summarize()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extr_val(x, i, allNA_NA = TRUE, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extr_val_+3A_x">x</code></td>
<td>
<p>object from which to extract element(s)</p>
</td></tr>
<tr><td><code id="extr_val_+3A_i">i</code></td>
<td>
<p>index specifying element to extract.</p>
</td></tr>
<tr><td><code id="extr_val_+3A_allna_na">allNA_NA</code></td>
<td>
<p>logical indicating whether <code>NA</code> should be returned
when <code>all(is.na(i)) == TRUE</code>.</p>
</td></tr>
<tr><td><code id="extr_val_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether missing index values should be 
removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>all_NA = FALSE</code> and <code>na.rm = FALSE</code>, identical to 
<code>x[i]</code>.
</p>
<p>If <code>all_NA = FALSE</code> and <code>na.rm = TRUE</code>, identical to
<code>x[i[!is.na(i)]]</code>.
</p>
<p>If <code>all_NA = TRUE</code>, identical to <code>x[i]</code> unless 
<code>all(is.na(i)) == TRUE</code>, in which case returns <code>NA</code>
</p>

<hr>
<h2 id='ExtremaFunctions'>Find local extrema of a numeric vector</h2><span id='topic+ExtremaFunctions'></span><span id='topic+find_local_extrema'></span><span id='topic+first_maxima'></span><span id='topic+first_minima'></span>

<h3>Description</h3>

<p>These functions take a vector of <code>y</code> values and identify local extrema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_local_extrema(
  y,
  x = NULL,
  window_width = NULL,
  window_width_n = NULL,
  window_height = NULL,
  window_width_frac = NULL,
  window_width_n_frac = NULL,
  return = "index",
  return_maxima = TRUE,
  return_minima = TRUE,
  return_endpoints = TRUE,
  subset = NULL,
  na.rm = TRUE,
  width_limit = NULL,
  width_limit_n = NULL,
  height_limit = NULL
)

first_maxima(
  y,
  x = NULL,
  window_width = NULL,
  window_width_n = NULL,
  window_height = NULL,
  window_width_frac = NULL,
  window_width_n_frac = 0.2,
  return = "index",
  return_endpoints = TRUE,
  ...
)

first_minima(
  y,
  x = NULL,
  window_width = NULL,
  window_width_n = NULL,
  window_height = NULL,
  window_width_frac = NULL,
  window_width_n_frac = 0.2,
  return = "index",
  return_endpoints = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExtremaFunctions_+3A_y">y</code></td>
<td>
<p>Numeric vector of y values in which to identify local extrema</p>
</td></tr>
<tr><td><code id="ExtremaFunctions_+3A_x">x</code></td>
<td>
<p>Optional numeric vector of corresponding x values</p>
</td></tr>
<tr><td><code id="ExtremaFunctions_+3A_window_width">window_width</code>, <code id="ExtremaFunctions_+3A_window_width_n">window_width_n</code>, <code id="ExtremaFunctions_+3A_window_height">window_height</code>, <code id="ExtremaFunctions_+3A_window_width_frac">window_width_frac</code>, <code id="ExtremaFunctions_+3A_window_width_n_frac">window_width_n_frac</code></td>
<td>
<p>Arguments that set the width/height of the window used to
search for local extrema.
</p>
<p><code>window_width</code> is in units of <code>x</code>.
</p>
<p><code>window_width_n</code> is in units of number of data points.
</p>
<p><code>window_height</code> is the maximum change in <code>y</code> 
a single extrema-search step is allowed to take.
</p>
<p><code>window_width_n_frac</code> is as a fraction of the total
number of data points.
</p>
<p>For example, the function will not pass a peak or valley
more than <code>window_width_n</code> data points wide, nor
a peak/valley taller or deeper than <code>window_height</code>.
</p>
<p>A narrower width will be more sensitive to narrow local 
maxima/minima, while a wider width will be less sensitive 
to local maxima/minima. A smaller height will be more 
sensitive to shallow local maxima/minima, while a larger 
height will be less sensitive to shallow maxima/minima.</p>
</td></tr>
<tr><td><code id="ExtremaFunctions_+3A_return">return</code></td>
<td>
<p>One of c(&quot;index&quot;, &quot;x&quot;, &quot;y&quot;), determining whether the function
will return the index, x value, or y value associated with the
identified extremas</p>
</td></tr>
<tr><td><code id="ExtremaFunctions_+3A_return_maxima">return_maxima</code>, <code id="ExtremaFunctions_+3A_return_minima">return_minima</code></td>
<td>
<p>logical for which classes of local extrema
to return</p>
</td></tr>
<tr><td><code id="ExtremaFunctions_+3A_return_endpoints">return_endpoints</code></td>
<td>
<p>Should the first and last values in <code>y</code>
be included if they are in the returned 
vector of extrema?</p>
</td></tr>
<tr><td><code id="ExtremaFunctions_+3A_subset">subset</code></td>
<td>
<p>A vector of logical values indicating which x and y values
should be included (TRUE) or excluded (FALSE).
</p>
<p>If <code>return = "index"</code>, index will be for the whole 
vector and not the subset of the vector</p>
</td></tr>
<tr><td><code id="ExtremaFunctions_+3A_na.rm">na.rm</code></td>
<td>
<p>logical whether NA's should be removed before analyzing</p>
</td></tr>
<tr><td><code id="ExtremaFunctions_+3A_width_limit">width_limit</code></td>
<td>
<p>Deprecated, use <code>window_width</code> instead</p>
</td></tr>
<tr><td><code id="ExtremaFunctions_+3A_width_limit_n">width_limit_n</code></td>
<td>
<p>Deprecated, use <code>window_width_n</code> instead</p>
</td></tr>
<tr><td><code id="ExtremaFunctions_+3A_height_limit">height_limit</code></td>
<td>
<p>Deprecated, use <code>window_height</code> instead</p>
</td></tr>
<tr><td><code id="ExtremaFunctions_+3A_...">...</code></td>
<td>
<p>(for <code>first_maxima</code> and <code>first_minima</code>), other 
parameters to pass to <code>find_local_extrema</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>find_local_extrema</code>, one of <code>window_width</code>, 
<code>window_width_n</code>, <code>window_height</code>, or <code>window_width_n_frac</code>
must be provided.
</p>
<p>For <code>first_minima</code> or <code>first_maxima</code>, set 
<code>window_width_n_frac = NULL</code> to override default width behavior.
</p>
<p>If multiple of <code>window_width</code>, <code>window_width_n</code>,
<code>window_height</code>, or <code>window_width_n_frac</code> are provided, steps 
are limited conservatively (a single step must meet all criteria).
</p>
<p>In the case of exact ties in <code>y</code> values within a window, only the 
first local extrema is returned.
</p>


<h3>Value</h3>

<p><code>find_local_extrema</code> returns a vector corresponding to all the 
found local extrema.
</p>
<p><code>first_maxima</code> returns only the first maxima, so is a shortcut for 
<code>find_local_extrema(return_maxima = TRUE, return_minima = FALSE)[1]</code>
</p>
<p><code>first_minima</code> returns only the first minima, so is a shortcut for
<code>find_local_extrema(return_maxima = FALSE, return_minima = TRUE)[1]</code>
</p>
<p>If <code>return = "index"</code>, the returned value(s) are the indices
corresponding to local extrema in the data
</p>
<p>If <code>return = "x"</code>, the returned value(s) are the x value(s) 
corresponding to local extrema in the data
</p>
<p>If <code>return = "y"</code>, the returned value(s) are the y value(s)
corresponding to local extrema in the data
</p>

<hr>
<h2 id='first_peak'>Find the first local maxima of a numeric vector</h2><span id='topic+first_peak'></span>

<h3>Description</h3>

<p>This function has been deprecated in favor of the identical new 
function <code>first_maxima</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first_peak(
  y,
  x = NULL,
  window_width = NULL,
  window_width_n = NULL,
  window_height = NULL,
  return = "index",
  return_endpoints = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first_peak_+3A_y">y</code></td>
<td>
<p>Numeric vector of y values in which to identify local extrema</p>
</td></tr>
<tr><td><code id="first_peak_+3A_x">x</code></td>
<td>
<p>Optional numeric vector of corresponding x values</p>
</td></tr>
<tr><td><code id="first_peak_+3A_window_width">window_width</code></td>
<td>
<p>Width of the window (in units of <code>x</code>) used to
search for local extrema. A narrower width will be more
sensitive to narrow local maxima/minima, while a wider
width will be less sensitive to local maxima/minima.</p>
</td></tr>
<tr><td><code id="first_peak_+3A_window_width_n">window_width_n</code></td>
<td>
<p>The maximum number of data points a single 
extrema-search step is allowed to take. For example,
when maxima-finding, the function will not pass
a valley consisting of more than <code>window_width_n</code>
data points.
</p>
<p>A smaller <code>window_width_n</code> will be more sensitive 
to narrow local maxima/minima, while a larger 
<code>window_width_n</code> will be less sensitive to 
narrow local maxima/minima.
</p>
<p>If not provided, defaults to ~0.2*length(y)</p>
</td></tr>
<tr><td><code id="first_peak_+3A_window_height">window_height</code></td>
<td>
<p>The maximum change in <code>y</code> a single extrema-search
step is allowed to take.  For example, when 
maxima-finding, the function will not pass a
valley deeper than <code>window_height</code>.
</p>
<p>A smaller <code>window_height</code> will be more sensitive 
to shallow local maxima/minima, while a larger 
<code>window_height</code> will be less sensitive to 
shallow maxima/minima.</p>
</td></tr>
<tr><td><code id="first_peak_+3A_return">return</code></td>
<td>
<p>One of c(&quot;index&quot;, &quot;x&quot;, &quot;y&quot;), determining whether the function
will return the index, x value, or y value associated with the
first maxima in y values</p>
</td></tr>
<tr><td><code id="first_peak_+3A_return_endpoints">return_endpoints</code></td>
<td>
<p>Should the first or last value in <code>y</code>
be allowed to be returned?</p>
</td></tr>
<tr><td><code id="first_peak_+3A_...">...</code></td>
<td>
<p>Other parameters to pass to <code>find_local_extrema</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a vector of <code>y</code> values and returns the index
(by default) of the first local maxima. It serves as a shortcut
for <code>find_local_extrema(return_maxima = TRUE, return_minima = FALSE)[1]</code>
</p>
<p>If none of <code>window_width</code>, <code>window_width_n</code>, or 
<code>window_height</code> are provided, default value of <code>window_width_n</code>
will be used.
</p>


<h3>Value</h3>

<p>If <code>return = "index"</code>, a vector of indices corresponding 
to local extrema in the data
</p>
<p>If <code>return = "x"</code>, a vector of x values corresponding
to local extrema in the data
</p>
<p>If <code>return = "y"</code>, a vector of y values corresponding
to local extrema in the data
</p>


<h3>See Also</h3>

<p>[first_maxima()]
</p>

<hr>
<h2 id='from_excel'>A function that converts base-26 Excel-style letters to numbers</h2><span id='topic+from_excel'></span>

<h3>Description</h3>

<p>A function that converts base-26 Excel-style letters to numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from_excel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="from_excel_+3A_x">x</code></td>
<td>
<p>A vector of column names in Excel-style base-26 letter format
(any values that are already in base-10 will be returned as-is)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of numbers in base-10
</p>

<hr>
<h2 id='gc_smooth.spline'>Fit a Smoothing Spline</h2><span id='topic+gc_smooth.spline'></span>

<h3>Description</h3>

<p>This function is a wrapper for <code>stats::smooth.spline</code>, which fits 
a cubic smoothing spline to the supplied data, but includes the option
to remove <code>NA</code> values, and returns values in the original order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gc_smooth.spline(x, y = NULL, ..., na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gc_smooth.spline_+3A_x">x</code></td>
<td>
<p>A vector giving the values of the predictor variable.</p>
</td></tr>
<tr><td><code id="gc_smooth.spline_+3A_y">y</code></td>
<td>
<p>A vector giving the values of the response variable. If <code>y</code> is
missing or <code>NULL</code>, the responses are assumed to be specified
by <code>x</code>, with <code>x</code> the index vector.</p>
</td></tr>
<tr><td><code id="gc_smooth.spline_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>stats::smooth.spline</code>.</p>
</td></tr>
<tr><td><code id="gc_smooth.spline_+3A_na.rm">na.rm</code></td>
<td>
<p>logical whether NA's should be removed before analyzing.
Required to be TRUE if any <code>x</code> or <code>y</code> values are NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>stats::smooth.spline</code>
</p>


<h3>Value</h3>

<p>Similar to <code>stats::smooth.spline</code>, an object of class 
&quot;<code>smooth.spline</code>&quot; with many components. Differs in that
x, y, and w have NA's at any indices where <code>x</code> or <code>y</code> were 
NA in the inputs, and x, y, and w are returned to match the input 
<code>x</code> in order and length
</p>

<hr>
<h2 id='import_blockdesigns'>Import blockdesigns</h2><span id='topic+import_blockdesigns'></span>

<h3>Description</h3>

<p>Function to import block-shaped designs from files and return tidy designs.
This function acts as a wrapper that calls <code>read_blocks</code>, 
<code>paste_blocks</code>, <code>trans_block_to_wide</code>, <code>trans_wide_to_tidy</code>, 
and <code>separate_tidys</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_blockdesigns(
  files,
  block_names = NULL,
  block_name_header = "block_name",
  join_designs = TRUE,
  sep = NULL,
  values_colname = "Designs",
  keep_blocknames = !join_designs,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_blockdesigns_+3A_files">files</code></td>
<td>
<p>A vector of filepaths relative to the current working directory
where each filepath is a single plate read to be read by
<code>read_blocks</code>.</p>
</td></tr>
<tr><td><code id="import_blockdesigns_+3A_block_names">block_names</code></td>
<td>
<p>Vector of names corresponding to each design element (each
block). Inferred from filenames, if not specified.
</p>
<p>When <code>keep_blocknames = TRUE</code>, a column with the column
name specified by <code>block_name_header</code> will contain these
names.
</p>
<p>When <code>join_designs = TRUE</code>, the <code>block_names</code> are
also used as the output column names for each separated
design column.</p>
</td></tr>
<tr><td><code id="import_blockdesigns_+3A_block_name_header">block_name_header</code></td>
<td>
<p>When <code>keep_blocknames = TRUE</code>, the column name of the
column containing the <code>block_names</code>.</p>
</td></tr>
<tr><td><code id="import_blockdesigns_+3A_join_designs">join_designs</code></td>
<td>
<p>logical indicating whether blocks (if there are multiple)
should be treated as describing the same plate (and so joined
as columns in the tidy output). If <code>FALSE</code>, will be 
treated as describing different plates (and so joined as
rows in the tidy output).</p>
</td></tr>
<tr><td><code id="import_blockdesigns_+3A_sep">sep</code></td>
<td>
<p>If designs have been pasted together, this specifies the
string they should be split apart by via <code>separate_tidy</code>.</p>
</td></tr>
<tr><td><code id="import_blockdesigns_+3A_values_colname">values_colname</code></td>
<td>
<p>When <code>join_designs = FALSE</code>, the column name
of the column that will contain all the design values.</p>
</td></tr>
<tr><td><code id="import_blockdesigns_+3A_keep_blocknames">keep_blocknames</code></td>
<td>
<p>logical indicating whether the column containing
<code>block_names</code> (or those inferred from file names) should
be retained in the output. By default, blocknames are retained
only if <code>join_designs = FALSE</code>.</p>
</td></tr>
<tr><td><code id="import_blockdesigns_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code>read_blocks</code>, 
<code>paste_blocks</code>, <code>trans_block_to_wide</code>,
<code>trans_wide_to_tidy</code>, or <code>separate_tidy</code>.
</p>
<p>See Details for more information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Common arguments that you may want to provide via <code>...</code>
include:
</p>
<p><code>startrow</code>, <code>endrow</code>, <code>startcol</code>, <code>endcol</code>, 
<code>sheet</code> - specifying the location of design information 
inside <code>files</code> to <code>read_blocks</code>.
</p>
<p><code>wellnames_sep</code> - specifying what character (or &quot;&quot; for 
none) should be used when pasting together the rownames and
column names. Note that this should be chosen to match
the well names in your measures.
</p>
<p>Note that <code>import_blockdesigns</code> cannot currently handle
metadata specified via the <code>metadata</code> argument of
<code>read_blocks</code>.
</p>
<p>If you find yourself needing more control, you can run the 
steps manually, first reading with <code>read_blocks</code>,
pasting as needed with <code>paste_blocks</code>, 
transforming to tidy with <code>trans_block_to_wide</code> and
<code>trans_wide_to_tidy</code>, and separating as needed with
<code>separate_tidys</code>.
</p>


<h3>Value</h3>

<p>A tidy-shaped <code>data.frame</code> containing the design information
from <code>files</code>. This always includes a &quot;Well&quot; column. 
</p>
<p>If <code>keep_blocknames = TRUE</code>, this includes a column with the
column name specified by <code>block_name_header</code> and containing
<code>block_names</code> (or those inferred from file names).
</p>
<p>If <code>join_designs = TRUE</code>, each block has been joined as a
column, with the columns named according to <code>block_names</code> 
(or inferred from file names) and containing the contents of 
each corresponding block. If <code>join_designs = FALSE</code>, each
block has been joined as rows, with a single column with the
name specified by <code>values_colnames</code> containing the
contents of all the blocks.
</p>

<hr>
<h2 id='import_blockmeasures'>Import blockmeasures</h2><span id='topic+import_blockmeasures'></span>

<h3>Description</h3>

<p>Function to import blockmeasures from files and return widemeasures
This function acts as a wrapper to call <code>read_blocks</code>, 
<code>uninterleave</code>, then <code>trans_block_to_wide</code> in one go
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_blockmeasures(
  files,
  num_plates = 1,
  plate_names = NULL,
  wellnames_sep = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_blockmeasures_+3A_files">files</code></td>
<td>
<p>Vector of filenames (as strings), each of which is a 
block-shaped file containing measures data. File formats
can be .csv, .xls, or .xlsx</p>
</td></tr>
<tr><td><code id="import_blockmeasures_+3A_num_plates">num_plates</code></td>
<td>
<p>Number of plates. If multiple plates uninterleave will be
used to separate blockmeasures into those plates accordingly</p>
</td></tr>
<tr><td><code id="import_blockmeasures_+3A_plate_names">plate_names</code></td>
<td>
<p>(optional) Names to put onto the plates when output</p>
</td></tr>
<tr><td><code id="import_blockmeasures_+3A_wellnames_sep">wellnames_sep</code></td>
<td>
<p>String to use as separator for well names between 
rowname and column name</p>
</td></tr>
<tr><td><code id="import_blockmeasures_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code>read_blocks</code>, <code>uninterleave</code>,
or <code>widen_blocks</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Common arguments that you may want to provide via <code>...</code>
include:
</p>
<p><code>startrow</code>, <code>endrow</code>, <code>startcol</code>, <code>endcol</code>, 
<code>sheet</code> - specifying the location of design information 
inside <code>files</code> to <code>read_blocks</code>
</p>
<p><code>metadata</code> - specifying metadata to <code>read_blocks</code>
</p>
<p>See help for <code>read_blocks</code> for more details
</p>
<p>If you find yourself needing more control, you can run the 
steps manually, first reading with <code>read_blocks</code>, 
separating plates as needed with <code>uninterleave</code>, 
then transforming to wide with <code>trans_block_to_wide</code>.
</p>


<h3>Value</h3>

<p>If <code>num_plates = 1</code>, a wide-shaped <code>data.frame</code>
containing the measures data.
</p>
<p>if <code>num_plates</code> is greater than one, a list of 
<code>data.frame</code>'s, where each <code>data.frame</code> is wide-shaped.
</p>

<hr>
<h2 id='lag_time'>Calculate lag time</h2><span id='topic+lag_time'></span>

<h3>Description</h3>

<p>Lag time is calculated by projecting a tangent line at the point
of maximum (per-capita) derivative backwards to find the time when it
intersects with the minimum y-value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lag_time(
  x = NULL,
  y = NULL,
  deriv = NULL,
  trans_y = "log",
  na.rm = TRUE,
  slope = NULL,
  x1 = NULL,
  y1 = NULL,
  y0 = NULL,
  warn_logtransform_warnings = TRUE,
  warn_logtransform_infinite = TRUE,
  warn_min_y_mismatch = TRUE,
  warn_multiple_maxderiv = TRUE,
  warn_one_lag = TRUE,
  warn_no_lag = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lag_time_+3A_x">x</code></td>
<td>
<p>Vector of x values (typically time)</p>
</td></tr>
<tr><td><code id="lag_time_+3A_y">y</code></td>
<td>
<p>Vector of y values (typically density)</p>
</td></tr>
<tr><td><code id="lag_time_+3A_deriv">deriv</code></td>
<td>
<p>Vector of derivative values (typically per-capita derivative)</p>
</td></tr>
<tr><td><code id="lag_time_+3A_trans_y">trans_y</code></td>
<td>
<p>One of <code>c("linear", "log")</code> specifying the
transformation of y-values.
</p>
<p><code>'log'</code> is the default, producing calculations of
lag time assuming a transition to exponential growth
</p>
<p><code>'linear'</code> is available for alternate uses</p>
</td></tr>
<tr><td><code id="lag_time_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether missing values or values that
become <code>NA</code> or infinite during log-transformation should 
be removed</p>
</td></tr>
<tr><td><code id="lag_time_+3A_slope">slope</code></td>
<td>
<p>Slope to project from x1,y1 to y0 (typically per-capita growth
rate). If not provided, will be calculated as <code>max(deriv)</code></p>
</td></tr>
<tr><td><code id="lag_time_+3A_x1">x1</code></td>
<td>
<p>x value (typically time) to project slope from. If not provided,
will be calculated as <code>x[which.max(deriv)]</code>.</p>
</td></tr>
<tr><td><code id="lag_time_+3A_y1">y1</code></td>
<td>
<p>y value (typically density) to project slope from. If not provided,
will be calculated as <code>y[which.max(deriv)]</code>.</p>
</td></tr>
<tr><td><code id="lag_time_+3A_y0">y0</code></td>
<td>
<p>y value (typically density) to find intersection of slope from
x1, y1 with. If not provided, will be calculated as <code>min(y)</code></p>
</td></tr>
<tr><td><code id="lag_time_+3A_warn_logtransform_warnings">warn_logtransform_warnings</code></td>
<td>
<p>logical whether warning should be issued 
when log(y) produced warnings.</p>
</td></tr>
<tr><td><code id="lag_time_+3A_warn_logtransform_infinite">warn_logtransform_infinite</code></td>
<td>
<p>logical whether warning should be issued 
when log(y) produced infinite values that will
be treated as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="lag_time_+3A_warn_min_y_mismatch">warn_min_y_mismatch</code></td>
<td>
<p>logical whether warning should be issued when 
<code>min(y)</code> does not equal 
<code>min(y[!is.na(x)])</code>.</p>
</td></tr>
<tr><td><code id="lag_time_+3A_warn_multiple_maxderiv">warn_multiple_maxderiv</code></td>
<td>
<p>logical whether warning should be issued when 
there are multiple points in <code>deriv</code> that
are tied for the highest, and only the first
will be used.</p>
</td></tr>
<tr><td><code id="lag_time_+3A_warn_one_lag">warn_one_lag</code></td>
<td>
<p>logical whether warning should be issued when 
some, but not all, inputs are vectorized, and
only one lag time value will be returned.</p>
</td></tr>
<tr><td><code id="lag_time_+3A_warn_no_lag">warn_no_lag</code></td>
<td>
<p>logical whether warning should be issued when calculated
lag time is less than the minimum value of x</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For most typical uses, simply supply <code>x</code>, <code>y</code>, and <code>deriv</code>
(using the per-capita derivative and <code>trans_y = 'log'</code>).
</p>
<p>Advanced users may wish to use alternate values for the slope, origination
point, or minimum y-value. In that case, values can be supplied to
<code>slope</code>, <code>x1</code>, <code>y1</code>, and/or <code>y0</code>, which will override
the default calculations. If and only if all of <code>slope</code>, <code>x1</code>, 
<code>y1</code>, and <code>y0</code> are provided, <code>lag_time</code> is vectorized on
their inputs and will return a vector of lag time values.
</p>


<h3>Value</h3>

<p>Typically a scalar of the lag time in units of x. See Details for
cases when value will be a vector.
</p>

<hr>
<h2 id='make_design'>Make design data.frame(s)</h2><span id='topic+make_design'></span>

<h3>Description</h3>

<p>This is a function to easily input experimental design elements
for later merging with read data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_design(
  nrows = NULL,
  ncols = NULL,
  block_row_names = NULL,
  block_col_names = NULL,
  block_name_header = "block_name",
  output_format = "tidy",
  wellnames_numeric = FALSE,
  wellnames_sep = "",
  wellnames_colname = "Well",
  colnames_first = FALSE,
  lookup_tbl_start = 1,
  pattern_split = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_design_+3A_nrows">nrows</code>, <code id="make_design_+3A_ncols">ncols</code></td>
<td>
<p>Number of rows and columns in the plate data</p>
</td></tr>
<tr><td><code id="make_design_+3A_block_row_names">block_row_names</code>, <code id="make_design_+3A_block_col_names">block_col_names</code></td>
<td>
<p>Names of the rows, columns
of the plate blockmeasures data</p>
</td></tr>
<tr><td><code id="make_design_+3A_block_name_header">block_name_header</code></td>
<td>
<p>The name of the field containing the
<code>block_names</code></p>
</td></tr>
<tr><td><code id="make_design_+3A_output_format">output_format</code></td>
<td>
<p>One of c(&quot;blocks&quot;, &quot;blocks_pasted&quot;, &quot;wide&quot;, &quot;tidy&quot;)
denoting the format of the resulting data.frame
</p>
<p>For easy merging with tidymeasures, leave as default
of 'tidy'. 
</p>
<p>For human-readability to confirm design
is correct, choose 'blocks' or 'blocks_pasted'. 
</p>
<p>For writing to block-shaped file(s), choose 'blocks' or
'blocks_pasted'.</p>
</td></tr>
<tr><td><code id="make_design_+3A_wellnames_numeric">wellnames_numeric</code></td>
<td>
<p>If <code>block_row_names</code> or <code>block_col_names</code>
are not specified, then names will be generated
automatically according to <code>wellnames_numeric</code>.
</p>
<p>If <code>wellnames_numeric</code> is TRUE, rows and columns
will be numbered with &quot;R&quot; and &quot;C&quot; prefixes, respectively.
</p>
<p>If <code>wellnames_numeric</code> is FALSE, rows will be
lettered A through Z, while columns will be numbered</p>
</td></tr>
<tr><td><code id="make_design_+3A_wellnames_sep">wellnames_sep</code></td>
<td>
<p>A string used when concatenating rownames and column
names to create well names, when 
<code>output_format = "wide"</code> or 
<code>output_format = "tidy"</code></p>
</td></tr>
<tr><td><code id="make_design_+3A_wellnames_colname">wellnames_colname</code></td>
<td>
<p>Header for newly-created column containing the
well names, when <code>output_format = "tidy"</code></p>
</td></tr>
<tr><td><code id="make_design_+3A_colnames_first">colnames_first</code></td>
<td>
<p>When wellnames are created for 
<code>output_format = "wide"</code> or 
<code>output_format = "tidy"</code> by <code>paste</code>-ing the
rownames and column names, should the column names
come first.</p>
</td></tr>
<tr><td><code id="make_design_+3A_lookup_tbl_start">lookup_tbl_start</code></td>
<td>
<p>Value in the lookup table for the split pattern values
that corresponds to the first value in the vector.
</p>
<p>Lookup table by default is 
c(1,2,...,8,9,A,B,...Y,Z,a,b,...,y,z). If,
for example, lookup_tbl_start = &quot;A&quot;, then the lookup
table will now be c(A,B,...Y,Z,a,b,...,y,z)</p>
</td></tr>
<tr><td><code id="make_design_+3A_pattern_split">pattern_split</code></td>
<td>
<p>character to split pattern elements provided in
<code>...</code> by, if they're not already a vector</p>
</td></tr>
<tr><td><code id="make_design_+3A_...">...</code></td>
<td>
<p>Each <code>...</code> argument must be named, and must be a list with 
five elements:
</p>
<p>1. a vector of the values
</p>
<p>2. a vector of the rows the pattern should be applied to
</p>
<p>3. a vector of the columns the pattern should be applied to
</p>
<p>4. a string or vector denoting the pattern in which the
values should be filled into the rows and columns specified.
</p>
<p>If it's a string, will be split by <code>pattern_split</code>.
Pattern will be used as the indices of the values vector.
</p>
<p>0's refer to NA. The pattern will be recycled as necessary
to fill all the wells of the rows and columns specified.
</p>
<p>5. a logical for whether this pattern should be filled byrow</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that either <code>nrows</code> or <code>block_row_names</code> must be provided
and that either <code>ncols</code> or <code>block_col_names</code> must be provided
</p>


<h3>Value</h3>

<p>Depends on <code>output_format</code>:
</p>
<p>If <code>output_format = "blocks"</code>, a list of <code>data.frame</code>'s
where each <code>data.frame</code> is block-shaped containing the
information for a single design element
</p>
<p>If <code>output_format = "blocks_pasted"</code>, a single 
<code>data.frame</code> containing the <code>paste</code>-ed information
for all design elements
</p>
<p>If <code>output_format = "wide"</code>, a wide-shaped <code>data.frame</code>
containing all the design elements
</p>
<p>If <code>output_format = "tidy"</code>, a tidy-shaped <code>data.frame</code>
containing all the design elements
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_design(nrows = 8, ncols = 12,
            design_element_name = list(c("A", "B", "C"),
                                       2:7,
                                       2:11,
                                       "112301", 
                                       TRUE))
                          
## To be reminded what arguments are needed, use make_designpattern:
make_design(nrows = 8, ncols = 12,
            design_element_name = make_designpattern(
                 values = c("A", "B", "C"),
                 rows = 2:7, 
                 cols = 2:11,
                 pattern = "112301",
                 byrow = TRUE))              

</code></pre>

<hr>
<h2 id='make_designpattern'>Make design pattern</h2><span id='topic+make_designpattern'></span><span id='topic+mdp'></span>

<h3>Description</h3>

<p>A helper function for use with <code>make_design</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_designpattern(
  values,
  rows,
  cols,
  pattern = 1:length(values),
  byrow = TRUE
)

mdp(values, rows, cols, pattern = 1:length(values), byrow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_designpattern_+3A_values">values</code></td>
<td>
<p>Vector of values to use</p>
</td></tr>
<tr><td><code id="make_designpattern_+3A_rows">rows</code></td>
<td>
<p>Vector of rows where pattern applies</p>
</td></tr>
<tr><td><code id="make_designpattern_+3A_cols">cols</code></td>
<td>
<p>Vector of cols where pattern applies</p>
</td></tr>
<tr><td><code id="make_designpattern_+3A_pattern">pattern</code></td>
<td>
<p>Numeric pattern itself, where numbers refer to entries
in <code>values</code></p>
</td></tr>
<tr><td><code id="make_designpattern_+3A_byrow">byrow</code></td>
<td>
<p>logical for whether pattern should be created by row</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list(values, rows, cols, pattern, byrow)</code>
</p>


<h3>See Also</h3>

<p>[gcplyr::make_design()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_design(nrows = 8, ncols = 12,
            design_element_name = make_designpattern(
                 values = c("A", "B", "C"),
                 rows = 2:7, 
                 cols = 2:11,
                 pattern = "112301",
                 byrow = TRUE))

</code></pre>

<hr>
<h2 id='make_example'>Create R objects or files as seen in vignette examples</h2><span id='topic+make_example'></span>

<h3>Description</h3>

<p>This function makes it easy to generate R objects or files that are
created in the vignette examples. Note that this function should not
be counted on to produce the same output across different versions of
<code>gcplyr</code>, as it will be frequently changed to match the examples
in the vignettes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_example(vignette, example, dir = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_example_+3A_vignette">vignette</code></td>
<td>
<p>Number of the vignette the example object or file is created in.</p>
</td></tr>
<tr><td><code id="make_example_+3A_example">example</code></td>
<td>
<p>Number of the example the object or file is created in.</p>
</td></tr>
<tr><td><code id="make_example_+3A_dir">dir</code></td>
<td>
<p>The directory files should be saved into.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R object, or the names of the files if files have been written
</p>

<hr>
<h2 id='make_tidydesign'>Make tidy design data.frames</h2><span id='topic+make_tidydesign'></span>

<h3>Description</h3>

<p>This is a function to easily input experimental design elements
for later merging with read data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_tidydesign(
  nrows = NULL,
  ncols = NULL,
  block_row_names = NULL,
  block_col_names = NULL,
  wellnames_sep = "",
  wellnames_colname = "Well",
  wellnames_Excel = TRUE,
  lookup_tbl_start = 1,
  pattern_split = "",
  colnames_first = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_tidydesign_+3A_nrows">nrows</code>, <code id="make_tidydesign_+3A_ncols">ncols</code></td>
<td>
<p>Number of rows and columns in the plate data</p>
</td></tr>
<tr><td><code id="make_tidydesign_+3A_block_row_names">block_row_names</code>, <code id="make_tidydesign_+3A_block_col_names">block_col_names</code></td>
<td>
<p>Names of the rows, columns
of the plate blockmeasures data</p>
</td></tr>
<tr><td><code id="make_tidydesign_+3A_wellnames_sep">wellnames_sep</code></td>
<td>
<p>A string used when concatenating rownames and column
names to create well names</p>
</td></tr>
<tr><td><code id="make_tidydesign_+3A_wellnames_colname">wellnames_colname</code></td>
<td>
<p>Header for newly-created column containing the
well names</p>
</td></tr>
<tr><td><code id="make_tidydesign_+3A_wellnames_excel">wellnames_Excel</code></td>
<td>
<p>If <code>block_row_names</code> or <code>block_col_names</code>
are not specified, should rows and columns be named
using Excel-style base-26 lettering for rows
and numbering for columns? If FALSE, rows and columns
will be numbered with &quot;R&quot; and &quot;C&quot; prefix.</p>
</td></tr>
<tr><td><code id="make_tidydesign_+3A_lookup_tbl_start">lookup_tbl_start</code></td>
<td>
<p>Value in the lookup table for the split pattern values
that corresponds to the first value in the vector.
</p>
<p>Lookup table by default is 
c(1,2,...,8,9,A,B,...Y,Z,a,b,...,y,z). If,
for example, lookup_tbl_start = &quot;A&quot;, then the lookup
table will now be c(A,B,...Y,Z,a,b,...,y,z)</p>
</td></tr>
<tr><td><code id="make_tidydesign_+3A_pattern_split">pattern_split</code></td>
<td>
<p>character to split pattern elements provided in
<code>...</code> by</p>
</td></tr>
<tr><td><code id="make_tidydesign_+3A_colnames_first">colnames_first</code></td>
<td>
<p>In the wellnames created by <code>paste</code>-ing the
rownames and column names, should the column names
come first</p>
</td></tr>
<tr><td><code id="make_tidydesign_+3A_...">...</code></td>
<td>
<p>Each <code>...</code> argument must be a list with five elements:
</p>
<p>1. a vector of the values
</p>
<p>2. a vector of the rows the pattern should be applied to
</p>
<p>3. a vector of the columns the pattern should be applied to
</p>
<p>4. a string of the pattern itself, where numbers refer to
the indices in the values vector
</p>
<p>0's refer to NA
</p>
<p>This pattern will be split using pattern_split, which
defaults to every character
</p>
<p>5. a logical for whether this pattern should be filled byrow</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that either <code>nrows</code> or <code>block_row_names</code> must be provided
and that either <code>ncols</code> or <code>block_col_names</code> must be provided
</p>
<p>Examples:
my_example &lt;- make_tidydesign(nrows = 8, ncols = 12,
design_element_name = list(c(&quot;Value1&quot;, &quot;Value2&quot;, &quot;Value3&quot;),
rowstart:rowend, colstart:colend,
&quot;111222333000&quot;, TRUE)
To make it easier to pass arguments, use make_designpattern:
my_example &lt;- make_tidydesign(nrows = 8, ncols = 12,
design_element_name = make_designpattern(values = c(&quot;L&quot;, &quot;G&quot;, &quot;C&quot;),
rows = 2:7, cols = 2:11,
pattern = &quot;11223300&quot;,
byrow = TRUE))
</p>


<h3>Value</h3>

<p>a tidy-shaped <code>data.frame</code> containing all the design elements
</p>

<hr>
<h2 id='makemethod_train_smooth_data'>Create method argument for <code>caret::train</code> of growth curve smoothers</h2><span id='topic+makemethod_train_smooth_data'></span>

<h3>Description</h3>

<p>This function generates a list which is compatible to be used as the
<code>method</code> argument to <code>caret::train</code>. This enables users to
call <code>caret::train</code> directly themselves with <code>smooth_data</code>
smoothing functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makemethod_train_smooth_data(sm_method, tuneGrid = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makemethod_train_smooth_data_+3A_sm_method">sm_method</code></td>
<td>
<p>Argument specifying which smoothing method should
be used. Options include &quot;moving-average&quot;, &quot;moving-median&quot;, 
&quot;loess&quot;, &quot;gam&quot;, and &quot;smooth.spline&quot;.</p>
</td></tr>
<tr><td><code id="makemethod_train_smooth_data_+3A_tunegrid">tuneGrid</code></td>
<td>
<p>A data frame with possible tuning value. The columns should 
be named the same as the tuning parameters.
</p>
<p>Note that, when using <code>caret::train</code>, the tuneGrid
must be passed both to this function as well as directly
to <code>caret::train</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that can be used as the method argument to
<code>caret::train</code>. Contains elements:
<code>library</code>, <code>type</code>, <code>prob</code>, <code>fit</code>,
<code>parameters</code>, <code>grid</code>, <code>fit</code>, and <code>predict</code>.
</p>
<p>See documentation on using a custom model model in 
<code>caret::train</code> for more details.
</p>

<hr>
<h2 id='merge_dfs'>Collapse a list of dataframes, or merge two dataframes together</h2><span id='topic+merge_dfs'></span>

<h3>Description</h3>

<p>This function is essentially a wrapper for a <code>dplyr</code> mutate join
(by default, a <a href="dplyr.html#topic+full_join">full_join</a>). The most typical use of this 
function is to merge designs with measures data, or to use the collapse 
functionality to merge a list of dataframes into a single dataframe.
Merging is done by column names that match between <code>x</code> and <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_dfs(
  x,
  y = NULL,
  by = NULL,
  drop = FALSE,
  collapse = FALSE,
  names_to = NA,
  join = "full",
  warn_morerows = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_dfs_+3A_x">x</code></td>
<td>
<p>First data.frame, or list of data frames, to be joined</p>
</td></tr>
<tr><td><code id="merge_dfs_+3A_y">y</code></td>
<td>
<p>Second data.frame, or list of data frames, to be joined</p>
</td></tr>
<tr><td><code id="merge_dfs_+3A_by">by</code></td>
<td>
<p>A character vector of variables to join by, passed directly
to the join function</p>
</td></tr>
<tr><td><code id="merge_dfs_+3A_drop">drop</code></td>
<td>
<p>Should only <code>complete_cases</code> of the resulting
data.frame be returned?</p>
</td></tr>
<tr><td><code id="merge_dfs_+3A_collapse">collapse</code></td>
<td>
<p>A logical indicating whether x or y is a list containing
data frames that should be merged together before
being merged with the other</p>
</td></tr>
<tr><td><code id="merge_dfs_+3A_names_to">names_to</code></td>
<td>
<p>Column name for where <code>names(x)</code> or <code>names(y)</code> 
will be entered in if <code>collapse = TRUE</code>.
</p>
<p>If a value of <code>NA</code> then <code>names(x)</code> or 
<code>names(y)</code> will not be put into a column in the
returned data.frame</p>
</td></tr>
<tr><td><code id="merge_dfs_+3A_join">join</code></td>
<td>
<p>Type of join used to merge <code>x</code> and <code>y</code>. Options
are 'full' (default), 'inner', 'left', and 'right'.
</p>

<ul>
<li><p> A <code>full</code> join keeps all observations in <code>x</code> and 
<code>y</code>
</p>
</li>
<li><p> A <code>left</code> join keeps all observations in <code>x</code>
</p>
</li>
<li><p> A <code>right</code> join keeps all observations in <code>y</code>
</p>
</li>
<li><p> An <code>inner</code> join only keeps observations found in
both <code>x</code> and <code>y</code> (inner joins are not appropriate
in most cases because observations are frequently dropped).
</p>
</li></ul>

<p>See <a href="dplyr.html#topic+full_join">full_join</a>, <a href="dplyr.html#topic+left_join">left_join</a>, 
<a href="dplyr.html#topic+right_join">right_join</a>, or <a href="dplyr.html#topic+inner_join">inner_join</a> for 
more details</p>
</td></tr>
<tr><td><code id="merge_dfs_+3A_warn_morerows">warn_morerows</code></td>
<td>
<p>logical, should a warning be passed when the output
has more rows than x and more rows than y?</p>
</td></tr>
<tr><td><code id="merge_dfs_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to the underlying join function. See 
<a href="dplyr.html#topic+full_join">full_join</a>, <a href="dplyr.html#topic+left_join">left_join</a>, 
<a href="dplyr.html#topic+right_join">right_join</a>, or <a href="dplyr.html#topic+inner_join">inner_join</a> for options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame containing merged output of <code>x</code> and
<code>y</code>
</p>

<hr>
<h2 id='MinMaxGC'>Maxima and Minima</h2><span id='topic+MinMaxGC'></span><span id='topic+max_gc'></span><span id='topic+min_gc'></span>

<h3>Description</h3>

<p>Returns the maxima and minima of the input values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_gc(..., na.rm = TRUE, allmissing_NA = TRUE)

min_gc(..., na.rm = TRUE, allmissing_NA = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MinMaxGC_+3A_...">...</code></td>
<td>
<p>numeric or character arguments</p>
</td></tr>
<tr><td><code id="MinMaxGC_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether missing values should be removed.</p>
</td></tr>
<tr><td><code id="MinMaxGC_+3A_allmissing_na">allmissing_NA</code></td>
<td>
<p>a logical indicating whether <code>NA</code> should be
returned when there are no non-missing arguments
passed to <code>min</code> or <code>max</code> (often because
<code>na.rm = TRUE</code> but all values are <code>NA</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are wrappers for <code>min</code> and <code>max</code>,
with the additional argument <code>allmissing_NA</code>.
</p>


<h3>Value</h3>

<p>If <code>allmissing_NA = FALSE</code>, identical to <code>min</code> or 
<code>max</code>.
</p>
<p>If <code>allmissing_NA = TRUE</code>, identical to <code>min</code> or 
<code>max</code> except that, in cases where <code>min</code> or 
<code>max</code> would return an infinite value and raise a warning because
there are no non-missing arguments, <code>min_gc</code> and
<code>max_gc</code> return <code>NA</code>
</p>

<hr>
<h2 id='MovingWindowFunctions'>Moving window smoothing</h2><span id='topic+MovingWindowFunctions'></span><span id='topic+moving_average'></span><span id='topic+moving_median'></span>

<h3>Description</h3>

<p>These functions use a moving window to smooth data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moving_average(
  formula = NULL,
  data = NULL,
  x = NULL,
  y = NULL,
  window_width_n = NULL,
  window_width = NULL,
  window_width_n_frac = NULL,
  window_width_frac = NULL,
  na.rm = TRUE,
  warn_nonnumeric_sort = TRUE
)

moving_median(
  formula = NULL,
  data = NULL,
  x = NULL,
  y = NULL,
  window_width_n = NULL,
  window_width = NULL,
  window_width_n_frac = NULL,
  window_width_frac = NULL,
  na.rm = TRUE,
  warn_nonnumeric_sort = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MovingWindowFunctions_+3A_formula">formula</code></td>
<td>
<p>Formula specifying the numeric response (density) 
and numeric predictor (time).</p>
</td></tr>
<tr><td><code id="MovingWindowFunctions_+3A_data">data</code></td>
<td>
<p>Dataframe containing variables in <code>formula</code></p>
</td></tr>
<tr><td><code id="MovingWindowFunctions_+3A_x">x</code></td>
<td>
<p>A vector of predictor values to smooth along (e.g. time)</p>
</td></tr>
<tr><td><code id="MovingWindowFunctions_+3A_y">y</code></td>
<td>
<p>A vector of response values to be smoothed (e.g. density).</p>
</td></tr>
<tr><td><code id="MovingWindowFunctions_+3A_window_width_n">window_width_n</code></td>
<td>
<p>Number of data points wide the moving window is
(therefore, must be an odd number of points)</p>
</td></tr>
<tr><td><code id="MovingWindowFunctions_+3A_window_width">window_width</code></td>
<td>
<p>Width of the moving window (in units of <code>x</code>)</p>
</td></tr>
<tr><td><code id="MovingWindowFunctions_+3A_window_width_n_frac">window_width_n_frac</code></td>
<td>
<p>Width of the window (as a fraction of the total
number of data points).</p>
</td></tr>
<tr><td><code id="MovingWindowFunctions_+3A_window_width_frac">window_width_frac</code></td>
<td>
<p>Width of the window (as a fraction of the range of
<code>x</code>)</p>
</td></tr>
<tr><td><code id="MovingWindowFunctions_+3A_na.rm">na.rm</code></td>
<td>
<p>logical whether NA's should be removed before analyzing</p>
</td></tr>
<tr><td><code id="MovingWindowFunctions_+3A_warn_nonnumeric_sort">warn_nonnumeric_sort</code></td>
<td>
<p>logical whether warning should be issued when 
predictor variable that data is sorted by is 
non-numeric.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either <code>x</code> and <code>y</code> or <code>formula</code> and <code>data</code>
must be provided.
</p>
<p>Values of <code>NULL</code> or <code>NA</code> will be ignored for any of
<code>window_width_n</code>, <code>window_width</code>,
<code>window_width_n_frac</code>, or <code>window_width_frac</code>
</p>


<h3>Value</h3>

<p>Vector of smoothed data, with NA's appended at both ends
</p>

<hr>
<h2 id='paste_blocks'>Paste a list of blocks into a single block</h2><span id='topic+paste_blocks'></span>

<h3>Description</h3>

<p>This function uses <code>paste</code> to concatenate the same-location entries
of a list of data.frames together (i.e. all the first row-first column
values are pasted together, all the second row-first column values are
pasted together, etc.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paste_blocks(blocks, sep = "_", nested_metadata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paste_blocks_+3A_blocks">blocks</code></td>
<td>
<p>Blocks, either a single data.frame or a list of
data.frames</p>
</td></tr>
<tr><td><code id="paste_blocks_+3A_sep">sep</code></td>
<td>
<p>String to use as separator for output pasted values</p>
</td></tr>
<tr><td><code id="paste_blocks_+3A_nested_metadata">nested_metadata</code></td>
<td>
<p>A logical indicating the existence of nested metadata
in the <code>blockmeasures</code> list, e.g. as is typically
output by <code>read_blocks</code>. If NULL, will attempt to
infer existence of nested metadata</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If nested_metadata = TRUE (or is inferred to be TRUE), a list
containing a list containing: 1. a <code>data.frame</code> with the
pasted data values from <code>blocks</code>, and 2. a vector with the 
pasted metadata values from <code>blocks</code>
</p>
<p>If nested_metadata = FALSE (or is inferred to be FALSE), a list
containing <code>data.frame</code>'s with the pasted values from
<code>blocks</code>
</p>

<hr>
<h2 id='predict_interpolation'>Predict data by linear interpolation from existing data</h2><span id='topic+predict_interpolation'></span>

<h3>Description</h3>

<p>Predict data by linear interpolation from existing data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_interpolation(
  x,
  y,
  newdata,
  extrapolate_predictions = TRUE,
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_interpolation_+3A_x">x</code></td>
<td>
<p>A vector of known predictor values.</p>
</td></tr>
<tr><td><code id="predict_interpolation_+3A_y">y</code></td>
<td>
<p>A vector of known response values.</p>
</td></tr>
<tr><td><code id="predict_interpolation_+3A_newdata">newdata</code></td>
<td>
<p>A vector of new predictor values for which the response
value will be predicted</p>
</td></tr>
<tr><td><code id="predict_interpolation_+3A_extrapolate_predictions">extrapolate_predictions</code></td>
<td>
<p>Boolean indicating whether values of <code>newdata</code> that are 
out of the domain of <code>x</code> should be predicted (by 
extrapolating the slope from the endpoints of <code>x</code>). If
<code>FALSE</code>, such values will be returned as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="predict_interpolation_+3A_na.rm">na.rm</code></td>
<td>
<p>logical whether NA's should be removed before making predictions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of response values for each predictor value in 
<code>newdata</code>
</p>

<hr>
<h2 id='print_df'>Nicely print the contents of a data.frame</h2><span id='topic+print_df'></span>

<h3>Description</h3>

<p>This function uses <code>write.table</code> to print the input <code>data.frame</code>
in a nicely-formatted manner that is easy to read
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_df(x, col.names = FALSE, row.names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_df_+3A_x">x</code></td>
<td>
<p>The <code>data.frame</code> to be printed</p>
</td></tr>
<tr><td><code id="print_df_+3A_col.names">col.names</code></td>
<td>
<p>Boolean for whether column names should be printed</p>
</td></tr>
<tr><td><code id="print_df_+3A_row.names">row.names</code></td>
<td>
<p>Boolean for whether row names should be printed</p>
</td></tr>
</table>

<hr>
<h2 id='read_blocks'>Read blockmeasures</h2><span id='topic+read_blocks'></span>

<h3>Description</h3>

<p>A function that reads block measures into the R environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_blocks(
  files,
  filetype = NULL,
  startrow = NULL,
  endrow = NULL,
  startcol = NULL,
  endcol = NULL,
  sheet = NULL,
  metadata = NULL,
  block_names = NULL,
  block_names_header = "block_name",
  block_names_dot = FALSE,
  block_names_path = TRUE,
  block_names_ext = FALSE,
  header = NA,
  sider = NA,
  wellnames_numeric = FALSE,
  na.strings = c("NA", ""),
  extension,
  block_name_header,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_blocks_+3A_files">files</code></td>
<td>
<p>A vector of filepaths relative to the current working directory
where each filepath is a single plate read</p>
</td></tr>
<tr><td><code id="read_blocks_+3A_filetype">filetype</code></td>
<td>
<p>(optional) the type(s) of the files. Options include:
</p>
<p>&quot;csv&quot;, &quot;xls&quot;, or &quot;xlsx&quot;.
</p>
<p>&quot;tbl&quot; or &quot;table&quot; to use <code>read.table</code> to read the file,
&quot;csv2&quot; to use <code>read.csv2</code>, &quot;delim&quot; to 
use <code>read.delim</code>, or &quot;delim2&quot; to use <code>read.delim2</code>.
</p>
<p>If none provided, <code>read_blocks</code> will infer filetype(s) 
from the extension(s) in <code>files</code>. When extension is 
not &quot;csv&quot;, &quot;xls&quot;, or &quot;xlsx&quot;, will use &quot;table&quot;.</p>
</td></tr>
<tr><td><code id="read_blocks_+3A_startrow">startrow</code>, <code id="read_blocks_+3A_endrow">endrow</code>, <code id="read_blocks_+3A_startcol">startcol</code>, <code id="read_blocks_+3A_endcol">endcol</code></td>
<td>
<p>(optional) the rows and columns where 
the measures data are located in <code>files</code>.
</p>
<p>Can be a vector or list the same length as <code>files</code>, or
a single value that applies to all <code>files</code>. Values
can be numeric or a string that will be automatically
converted to numeric by <code>from_excel</code>.
</p>
<p>If not provided, data is presumed to begin on the first
row and column of the file(s) and end on the last row and
column of the file(s).</p>
</td></tr>
<tr><td><code id="read_blocks_+3A_sheet">sheet</code></td>
<td>
<p>(optional) If data is in .xls or .xlsx files, which sheet it 
is located on. Defaults to the first sheet if not specified</p>
</td></tr>
<tr><td><code id="read_blocks_+3A_metadata">metadata</code></td>
<td>
<p>(optional) non-spectrophotometric data that should be 
associated with each read blockmeasures. A named list where 
each item in the list is either: a vector of length 2, or
a list containing two vectors. 
</p>
<p>In the former case, each vector should provide the row and 
column where the metadata is located in all of the
blockmeasures input files.
</p>
<p>In the latter case, the first vector should provide the rows
where the metadata is located in each of the corresponding
input files, and the second vector should provide the 
columns where the metadata is located in each of the
corresponding input files. (This case is typically used 
when reading multiple blocks from a single file.)</p>
</td></tr>
<tr><td><code id="read_blocks_+3A_block_names">block_names</code></td>
<td>
<p>(optional) vector of names corresponding to each plate
in <code>files</code>. If not provided, block_names are inferred
from the filenames</p>
</td></tr>
<tr><td><code id="read_blocks_+3A_block_names_header">block_names_header</code></td>
<td>
<p>The name of the metadata field containing the
<code>block_names</code></p>
</td></tr>
<tr><td><code id="read_blocks_+3A_block_names_dot">block_names_dot</code></td>
<td>
<p>If block_names are inferred from filenames, should 
the leading './' (if any) be retained</p>
</td></tr>
<tr><td><code id="read_blocks_+3A_block_names_path">block_names_path</code></td>
<td>
<p>If block_names are inferred from filenames, should 
the path (if any) be retained</p>
</td></tr>
<tr><td><code id="read_blocks_+3A_block_names_ext">block_names_ext</code></td>
<td>
<p>If block_names are inferred from filenames, should 
the file extension (if any) be retained</p>
</td></tr>
<tr><td><code id="read_blocks_+3A_header">header</code></td>
<td>
<p><code>TRUE</code>, <code>FALSE</code>, or <code>NA</code>, or a vector of
such values, indicating whether the file(s) contains the
column names as its first line. If <code>header = NA</code>
will attempt to infer the presence of column names. If
<code>header = FALSE</code> or no column names are inferred when 
<code>header = NA</code>, column names will be generated
automatically according to <code>wellnames_numeric</code></p>
</td></tr>
<tr><td><code id="read_blocks_+3A_sider">sider</code></td>
<td>
<p><code>TRUE</code>, <code>FALSE</code>, or <code>NA</code>, or a vector of
such values, indicating whether the file(s) contains the
row names as its first column. If <code>sider = NA</code>
will attempt to infer the presence of row names. If
<code>sider = FALSE</code> or no row names are inferred when 
<code>sider = NA</code>, row names will be generated
automatically according to <code>wellnames_numeric</code></p>
</td></tr>
<tr><td><code id="read_blocks_+3A_wellnames_numeric">wellnames_numeric</code></td>
<td>
<p>If row names and column names are not provided in the
input dataframe as specified by <code>header</code>
and <code>sider</code>, then names will be generated
automatically according to <code>wellnames_numeric</code>.
</p>
<p>If <code>wellnames_numeric</code> is TRUE, rows and columns
will be numbered with &quot;R&quot; and &quot;C&quot; prefixes, respectively.
</p>
<p>If <code>wellnames_numeric</code> is FALSE, rows will be
lettered A through Z, while columns will be numbered</p>
</td></tr>
<tr><td><code id="read_blocks_+3A_na.strings">na.strings</code></td>
<td>
<p>A character vector of strings which are to be interpreted
as <code>NA</code> values by <code>utils::read.csv</code>,
<code>readxl::read_xls</code>, <code>readxl::read_xlsx</code>,
or <code>utils::read.table</code></p>
</td></tr>
<tr><td><code id="read_blocks_+3A_extension">extension</code></td>
<td>
<p>Allowed for backward compatibility; <code>filetype</code> is
now the preferred argument name.</p>
</td></tr>
<tr><td><code id="read_blocks_+3A_block_name_header">block_name_header</code></td>
<td>
<p>Allowed for backward compatibility; 
<code>block_names_header</code> is now the preferred argument name.</p>
</td></tr>
<tr><td><code id="read_blocks_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>utils::read.csv</code>,
<code>readxl::read_xls</code>, <code>readxl::read_xlsx</code>,
or <code>utils::read.table</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For metadata, <code>read_blocks</code> can handle an arbitrary number of additional
pieces of information to extract from each blockcurve file as metadata.
These pieces of information are specified as a named list of vectors
where each vector is the c(row, column) where the information is to be
pulled from in the input files.
</p>
<p>This metadata is returned as the second list element of each
blockcurve, e.g.:
</p>
<p>[[1]] [1] &quot;data&quot; #1 [2] &quot;metadata&quot;  [2][1] name #1
</p>
<p>[2][2] date-time #1
</p>
<p>[2][3] temp #1
</p>
<p>[[2]] [1] &quot;data&quot; #2 [2] &quot;metadata&quot;  [2][1] name #2
</p>
<p>[2][2] date-time #2
</p>
<p>[2][3] temp #2
</p>
<p>...
</p>
<p>Calling <code>uninterleave</code> on the output of read_blocks works on block data
and the associated metadata because uninterleave operates on the highest 
level entries of the list (the [[1]] [[2]] level items), 
leaving the meta-data associated with the block data
</p>
<p><code>trans_block_to_wide</code> integrates this metadata into the
wide-shaped dataframe it produces
</p>


<h3>Value</h3>

<p>A list where each entry is a list containing the block data frame
followed by the block_names (or filenames, if block_names is not 
provided) and any specified metadata.
</p>

<hr>
<h2 id='read_tidys'>Read tidy-shaped files</h2><span id='topic+read_tidys'></span>

<h3>Description</h3>

<p>A function that imports tidy-shaped files into R. Largely acts as a
wrapper for <code>utils::read.csv</code>, <code>readxl::read_xls</code>,
<code>readxl::read_xls</code>, or <code>readxl::read_xlsx</code>, but can handle
multiple files at once and has additional options for taking subsets 
of rows/columns rather than the entire file and for adding filename 
or run names as an added column in the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_tidys(
  files,
  filetype = NULL,
  startrow = NULL,
  endrow = NULL,
  startcol = NULL,
  endcol = NULL,
  sheet = NULL,
  run_names = NULL,
  run_names_header = NULL,
  run_names_dot = FALSE,
  run_names_path = TRUE,
  run_names_ext = FALSE,
  na.strings = c("NA", ""),
  extension,
  names_to_col,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_tidys_+3A_files">files</code></td>
<td>
<p>A vector of filepaths (relative to current working directory)
where each one is a tidy-shaped data file</p>
</td></tr>
<tr><td><code id="read_tidys_+3A_filetype">filetype</code></td>
<td>
<p>(optional) the type(s) of the files. Options include:
</p>
<p>&quot;csv&quot;, &quot;xls&quot;, or &quot;xlsx&quot;.
</p>
<p>&quot;tbl&quot; or &quot;table&quot; to use <code>read.table</code> to read the file,
&quot;csv2&quot; to use <code>read.csv2</code>, &quot;delim&quot; to 
use <code>read.delim</code>, or &quot;delim2&quot; to use <code>read.delim2</code>.
</p>
<p>If none provided, <code>read_tidys</code> will infer filetype(s) 
from the extension(s) in <code>files</code>. When extension is 
not &quot;csv&quot;, &quot;xls&quot;, or &quot;xlsx&quot;, will use &quot;table&quot;.</p>
</td></tr>
<tr><td><code id="read_tidys_+3A_startrow">startrow</code>, <code id="read_tidys_+3A_endrow">endrow</code>, <code id="read_tidys_+3A_startcol">startcol</code>, <code id="read_tidys_+3A_endcol">endcol</code></td>
<td>
<p>(optional) the rows and columns where 
the data are located in <code>files</code>.
</p>
<p>Can be a vector or list the same length as <code>files</code>, or
a single value that applies to all <code>files</code>. Values
can be numeric or a string that will be automatically
converted to numeric by <code>from_excel</code>.
</p>
<p>If not provided, data is presumed to begin on the first
row and column of the file(s) and end on the last row and
column of the file(s).</p>
</td></tr>
<tr><td><code id="read_tidys_+3A_sheet">sheet</code></td>
<td>
<p>The sheet of the input files where data is located (if input
files are .xls or .xlsx). If not specified defaults to the first</p>
</td></tr>
<tr><td><code id="read_tidys_+3A_run_names">run_names</code></td>
<td>
<p>Names to give the tidy files read in. By default uses the
file names if not specified. These names may be added
to the resulting data frame depending on the value of
the <code>names_to_col</code> argument</p>
</td></tr>
<tr><td><code id="read_tidys_+3A_run_names_header">run_names_header</code></td>
<td>
<p>Should the run names (provided in <code>run_names</code>
or inferred from <code>files</code>) be added as a column to the
output? 
</p>
<p>If <code>run_names_header</code> is TRUE, they will be added with
the column name &quot;run_name&quot;
</p>
<p>If <code>run_names_header</code> is FALSE, they will not be added.
</p>
<p>If <code>run_names_header</code> is a string, they will be added
and the column name will be the string specified
for <code>run_names_header</code>.
</p>
<p>If <code>run_names_header</code> is NULL, they only will be 
added if there are multiple tidy data.frames being read.
In which case, the column name will be &quot;run_name&quot;</p>
</td></tr>
<tr><td><code id="read_tidys_+3A_run_names_dot">run_names_dot</code></td>
<td>
<p>If run_names are inferred from filenames, should 
the leading './' (if any) be retained</p>
</td></tr>
<tr><td><code id="read_tidys_+3A_run_names_path">run_names_path</code></td>
<td>
<p>If run_names are inferred from filenames, should 
the path (if any) be retained</p>
</td></tr>
<tr><td><code id="read_tidys_+3A_run_names_ext">run_names_ext</code></td>
<td>
<p>If run_names are inferred from filenames, should 
the file extension (if any) be retained</p>
</td></tr>
<tr><td><code id="read_tidys_+3A_na.strings">na.strings</code></td>
<td>
<p>A character vector of strings which are to be interpreted
as <code>NA</code> values by <code>utils::read.csv</code>,
<code>readxl::read_xls</code>, <code>readxl::read_xlsx</code>,
or <code>utils::read.table</code></p>
</td></tr>
<tr><td><code id="read_tidys_+3A_extension">extension</code></td>
<td>
<p>Allowed for backward compatibility; <code>filetype</code> is
now the preferred argument name.</p>
</td></tr>
<tr><td><code id="read_tidys_+3A_names_to_col">names_to_col</code></td>
<td>
<p>Allowed for backward compatibility; 
<code>run_names_header</code> is now the preferred argument name.</p>
</td></tr>
<tr><td><code id="read_tidys_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>utils::read.csv</code>,
<code>readxl::read_xls</code>, <code>readxl::read_xlsx</code>, or
<code>utils::read.table</code>
sheet</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>startrow</code>, <code>endrow</code>, <code>startcol</code>, <code>endcol</code>, 
<code>sheet</code> and <code>filetype</code> can either be a single value that 
applies for all files or vectors or lists the same length as <code>files</code>
</p>
<p>Note that the startrow is always assumed to be a header
</p>


<h3>Value</h3>

<p>A dataframe containing a single tidy data.frame, or
A list of tidy-shaped data.frames named by filename
</p>

<hr>
<h2 id='read_wides'>Read wides</h2><span id='topic+read_wides'></span>

<h3>Description</h3>

<p>A function that imports widemeasures in files into the R environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_wides(
  files,
  filetype = NULL,
  startrow = NULL,
  endrow = NULL,
  startcol = NULL,
  endcol = NULL,
  header = TRUE,
  sheet = NULL,
  run_names = NULL,
  run_names_header = "file",
  run_names_dot = FALSE,
  run_names_path = TRUE,
  run_names_ext = FALSE,
  metadata = NULL,
  na.strings = c("NA", ""),
  extension,
  names_to_col,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_wides_+3A_files">files</code></td>
<td>
<p>A vector of filepaths (relative to current working directory)
where each one is a widemeasures set of data</p>
</td></tr>
<tr><td><code id="read_wides_+3A_filetype">filetype</code></td>
<td>
<p>(optional) the type(s) of the files. Options include:
</p>
<p>&quot;csv&quot;, &quot;xls&quot;, or &quot;xlsx&quot;.
</p>
<p>&quot;tbl&quot; or &quot;table&quot; to use <code>read.table</code> to read the file,
&quot;csv2&quot; to use <code>read.csv2</code>, &quot;delim&quot; to 
use <code>read.delim</code>, or &quot;delim2&quot; to use <code>read.delim2</code>.
</p>
<p>If none provided, <code>read_wides</code> will infer filetype(s) 
from the extension(s) in <code>files</code>. When extension is 
not &quot;csv&quot;, &quot;xls&quot;, or &quot;xlsx&quot;, will use &quot;table&quot;.</p>
</td></tr>
<tr><td><code id="read_wides_+3A_startrow">startrow</code>, <code id="read_wides_+3A_endrow">endrow</code>, <code id="read_wides_+3A_startcol">startcol</code>, <code id="read_wides_+3A_endcol">endcol</code></td>
<td>
<p>(optional) the rows and columns where 
the data are located in <code>files</code>.
</p>
<p>Can be a vector or list the same length as <code>files</code>, or
a single value that applies to all <code>files</code>. Values
can be numeric or a string that will be automatically
converted to numeric by <code>from_excel</code>.
</p>
<p>If not provided, data is presumed to begin on the first
row and column of the file(s) and end on the last row and
column of the file(s).</p>
</td></tr>
<tr><td><code id="read_wides_+3A_header">header</code></td>
<td>
<p>logical for whether there is a header in the data. If FALSE
columns are simply numbered. If TRUE, the first row of the
data (<code>startrow</code> if specified) is used 
as the column names</p>
</td></tr>
<tr><td><code id="read_wides_+3A_sheet">sheet</code></td>
<td>
<p>The sheet of the input files where data is located (if input
files are .xls or .xlsx). If not specified defaults to the first
sheet</p>
</td></tr>
<tr><td><code id="read_wides_+3A_run_names">run_names</code></td>
<td>
<p>Names to give the widemeasures read in. By default uses the
file names if not specified</p>
</td></tr>
<tr><td><code id="read_wides_+3A_run_names_header">run_names_header</code></td>
<td>
<p>Should the run names (provided in <code>run_names</code>
or inferred from <code>files</code>) be added as a column to 
the widemeasures? If <code>run_names_header</code> is NULL, 
they will not be. If <code>run_names_header</code> is a string, 
that string will be the column header for the column 
where the names will be stored</p>
</td></tr>
<tr><td><code id="read_wides_+3A_run_names_dot">run_names_dot</code></td>
<td>
<p>If run_names are inferred from filenames, should 
the leading './' (if any) be retained</p>
</td></tr>
<tr><td><code id="read_wides_+3A_run_names_path">run_names_path</code></td>
<td>
<p>If run_names are inferred from filenames, should 
the path (if any) be retained</p>
</td></tr>
<tr><td><code id="read_wides_+3A_run_names_ext">run_names_ext</code></td>
<td>
<p>If run_names are inferred from filenames, should 
the file extension (if any) be retained</p>
</td></tr>
<tr><td><code id="read_wides_+3A_metadata">metadata</code></td>
<td>
<p>(optional) non-spectrophotometric data that should be 
associated with each read widemeasures. A named list where 
each item in the list is either: a vector of length 2, or
a list containing two vectors. 
</p>
<p>In the former case, each vector should provide the row and 
column where the metadata is located in all of the
blockmeasures input files.
</p>
<p>In the latter case, the first vector should provide the rows
where the metadata is located in each of the corresponding
input files, and the second vector should provide the 
columns where the metadata is located in each of the
corresponding input files. (This case is typically used 
when reading multiple blocks from a single file.)</p>
</td></tr>
<tr><td><code id="read_wides_+3A_na.strings">na.strings</code></td>
<td>
<p>A character vector of strings which are to be interpreted
as <code>NA</code> values by <code>utils::read.csv</code>,
<code>readxl::read_xls</code>, <code>readxl::read_xlsx</code>,
or <code>utils::read.table</code></p>
</td></tr>
<tr><td><code id="read_wides_+3A_extension">extension</code></td>
<td>
<p>Allowed for backward compatibility; <code>filetype</code> is
now the preferred argument name.</p>
</td></tr>
<tr><td><code id="read_wides_+3A_names_to_col">names_to_col</code></td>
<td>
<p>Allowed for backward compatibility; 
<code>run_names_header</code> is now the preferred argument name.</p>
</td></tr>
<tr><td><code id="read_wides_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>utils::read.csv</code>,
<code>readxl::read_xls</code>, <code>readxl::read_xlsx</code>, or
<code>utils::read.table</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>startrow, endrow, startcol, endcol, timecol, sheet and filetype 
can either be a single value that applies for all files or
vectors or lists the same length as <code>files</code>,
</p>


<h3>Value</h3>

<p>A dataframe containing a single widemeasures, or
A list of widemeasures named by filename
</p>

<hr>
<h2 id='separate_tidy'>Separate a column into multiple columns</h2><span id='topic+separate_tidy'></span>

<h3>Description</h3>

<p>This function is primarily a wrapper for <code>tidyr::separate</code>, which
turns a single character column into multiple columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate_tidy(
  data,
  col,
  into = NULL,
  sep = "_",
  coerce_NA = TRUE,
  na.strings = "NA",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_tidy_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="separate_tidy_+3A_col">col</code></td>
<td>
<p>Column name or position</p>
</td></tr>
<tr><td><code id="separate_tidy_+3A_into">into</code></td>
<td>
<p>A character vector of the new column names. Use <code>NA</code> to
omit the variable in the output.
</p>
<p>If NULL, <code>separate_gc</code> will attempt to infer the new
column names from the column name of <code>col</code></p>
</td></tr>
<tr><td><code id="separate_tidy_+3A_sep">sep</code></td>
<td>
<p>Separator between columns passed to <code>tidyr::separate</code>:
</p>
<p>If character, <code>sep</code> is interpreted as a regular expression.
</p>
<p>If numeric, <code>sep</code> is interpreted as character positions
to split at. Positive values start at 1 at the far-left of the
string; negative values start at -1 at the far-right of the
string. The length of <code>sep</code> should be one less than 
<code>into</code></p>
</td></tr>
<tr><td><code id="separate_tidy_+3A_coerce_na">coerce_NA</code></td>
<td>
<p>logical dictating if strings matching any of 
<code>na.strings</code> will be coerced into  <code>NA</code> values 
after separating.</p>
</td></tr>
<tr><td><code id="separate_tidy_+3A_na.strings">na.strings</code></td>
<td>
<p>A character vector of strings which are to be interpreted
as <code>NA</code> values if <code>coerce_NA == TRUE</code></p>
</td></tr>
<tr><td><code id="separate_tidy_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>tidyr::separate</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing new columns in the place of <code>col</code>
</p>

<hr>
<h2 id='smooth_data'>Smooth data</h2><span id='topic+smooth_data'></span>

<h3>Description</h3>

<p>This function calls other functions to smooth growth curve data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_data(
  ...,
  x = NULL,
  y = NULL,
  sm_method,
  subset_by = NULL,
  return_fitobject = FALSE,
  warn_ungrouped = TRUE,
  warn_gam_no_s = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_data_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>stats::loess</code>, <code>mgcv::gam</code>,
<code>moving_average</code>, <code>moving_median</code>, or 
<code>stats::smooth.spline</code>. Typically includes tuning 
parameter(s), which in some cases are required.
See Details for more information.</p>
</td></tr>
<tr><td><code id="smooth_data_+3A_x">x</code></td>
<td>
<p>An (often optional) vector of predictor values to smooth along 
(e.g. time)</p>
</td></tr>
<tr><td><code id="smooth_data_+3A_y">y</code></td>
<td>
<p>A vector of response values to be smoothed (e.g. density). If NULL,
<code>formula</code> and <code>data</code> *must* be provided via <code>...</code></p>
</td></tr>
<tr><td><code id="smooth_data_+3A_sm_method">sm_method</code></td>
<td>
<p>Argument specifying which smoothing method should
be used to smooth data. Options include 
&quot;moving-average&quot;, &quot;moving-median&quot;, &quot;loess&quot;, &quot;gam&quot;,
and &quot;smooth.spline&quot;.</p>
</td></tr>
<tr><td><code id="smooth_data_+3A_subset_by">subset_by</code></td>
<td>
<p>An optional vector as long as <code>y</code>. 
<code>y</code> will be split by the unique values of this vector 
and the smoothed data for each group will be calculated 
independently of the others.
</p>
<p>This provides an internally-implemented approach similar
to <code>dplyr::group_by</code> and <code>dplyr::mutate</code></p>
</td></tr>
<tr><td><code id="smooth_data_+3A_return_fitobject">return_fitobject</code></td>
<td>
<p>logical whether entire object returned
by fitting function should be returned. If FALSE,
just fitted values are returned.</p>
</td></tr>
<tr><td><code id="smooth_data_+3A_warn_ungrouped">warn_ungrouped</code></td>
<td>
<p>logical whether warning should be issued when
<code>smooth_data</code> is being called on ungrouped data
and <code>subset_by = NULL</code>.</p>
</td></tr>
<tr><td><code id="smooth_data_+3A_warn_gam_no_s">warn_gam_no_s</code></td>
<td>
<p>logical whether warning should be issued when gam is 
used without <code>s()</code> in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>moving_average</code> and <code>moving_median</code>, 
passing <code>window_width</code> or <code>window_width_n</code> via 
<code>...</code> is required. <code>window_width</code> sets the width
of the moving window in units of <code>x</code>, while 
<code>window_width_n</code> sets the width in units of number
of data points. Larger values for either will produce more 
&quot;smoothed&quot; data.
</p>
<p>For <code>loess</code>, the <code>span</code> argument sets the fraction of
data points that should be included in each calculation. It's
typically best to specify, since the default of 0.75 is often
too large for growth curves data. Larger values of <code>span</code> 
will produce more more &quot;smoothed&quot; data
</p>
<p>For <code>gam</code>, both arguments to <code>gam</code> and <code>s</code> can
be provided via <code>...</code>. Most frequently, the <code>k</code> 
argument to <code>s</code> sets the number of &quot;knots&quot; the
spline-fitting can use. Smaller values will be more &quot;smoothed&quot;.
</p>
<p>When using <code>sm_method = "gam"</code>, advanced users may also modify 
other parameters of <code>s()</code>, including the smoothing basis 
<code>bs</code>. These bases can be thin plate (<code>bs = "tp"</code>, 
the default), cubic regressions (<code>bs = "cr"</code>), or many other 
options (see <code>?mcgv::s</code>). I recommend leaving the default 
thin plate regressions, whose main drawback is that they are 
computationally intensive to calculate. For growth curves data, 
this is unlikely to be relevant.
</p>
<p>As an alternative to passing <code>y</code>, for more advanced needs 
with <code>loess</code> or <code>gam</code>, <code>formula</code> and <code>data</code> 
can be passed to <code>smooth_data</code> via the <code>...</code> argument 
(in lieu of <code>y</code>).
</p>
<p>In this case, the formula should specify the response (e.g. density) 
and predictors. For <code>gam</code> smoothing, the formula should
typically be of the format: y ~ s(x), which uses 
<code>mgcv::s</code> to smooth the data. The data argument should be a 
<code>data.frame</code> containing the variables in the formula.
In such cases, <code>subset_by</code> can still be specified as a vector
with length <code>nrow(data)</code>
</p>


<h3>Value</h3>

<p>If <code>return_fitobject == FALSE:</code>
</p>
<p>A vector, the same length as <code>y</code>, with the now-smoothed y values
</p>
<p>If <code>return_fitobject == TRUE:</code>
</p>
<p>A list the same length as unique(subset_by) where each element is
an object of the same class as returned by the smoothing method
(typically a named list-like object)
</p>

<hr>
<h2 id='solve_linear'>Return missing information about a line</h2><span id='topic+solve_linear'></span>

<h3>Description</h3>

<p>Takes a set of inputs that is sufficient information to infer a line
and then returns information not provided (either the slope, an x point
on the line, or a y point on the line)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_linear(
  x1,
  y1,
  x2 = NULL,
  y2 = NULL,
  x3 = NULL,
  y3 = NULL,
  m = NULL,
  named = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve_linear_+3A_x1">x1</code>, <code id="solve_linear_+3A_y1">y1</code></td>
<td>
<p>A point on the line</p>
</td></tr>
<tr><td><code id="solve_linear_+3A_x2">x2</code>, <code id="solve_linear_+3A_y2">y2</code></td>
<td>
<p>An additional point on the line</p>
</td></tr>
<tr><td><code id="solve_linear_+3A_x3">x3</code>, <code id="solve_linear_+3A_y3">y3</code></td>
<td>
<p>An additional point on the line</p>
</td></tr>
<tr><td><code id="solve_linear_+3A_m">m</code></td>
<td>
<p>The slope of the line</p>
</td></tr>
<tr><td><code id="solve_linear_+3A_named">named</code></td>
<td>
<p>logical indicating whether the returned value(s)
should be named according to what they are (m, x2, y2,
x3, or y3)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that there is no requirement that 
<code>x1</code> &lt; <code>x2</code> &lt; <code>x3</code>: the points can be in any order 
along the line.
</p>
<p><code>solve_linear</code> works with vectors of all inputs to solve
multiple lines at once, where the <code>i</code>th element of each 
argument corresponds to the <code>i</code>th output. Note that all
lines must be missing the same information. Input vectors
will be recycled as necessary.
</p>


<h3>Value</h3>

<p>A named vector with the missing information from the line:
</p>
<p>If <code>m</code> and <code>x2</code> are provided, <code>y2</code> will be returned
</p>
<p>If <code>m</code> and <code>y2</code> are provided, <code>x2</code> will be returned
</p>
<p>If <code>x2</code> and <code>y2</code> are provided, but neither <code>x3</code> nor 
<code>y3</code> are provided, <code>m</code> will be returned
</p>
<p>If <code>x2</code> and <code>y2</code> are provided and one of <code>x3</code> or 
<code>y3</code> are provided, the other (<code>y3</code> or <code>x3</code>) will be 
returned
</p>

<hr>
<h2 id='ThresholdFunctions'>Find point(s) when a numeric vector crosses some threshold</h2><span id='topic+ThresholdFunctions'></span><span id='topic+find_threshold_crosses'></span><span id='topic+first_below'></span><span id='topic+first_above'></span>

<h3>Description</h3>

<p>These functions take a vector of <code>y</code> values and identify points where
the <code>y</code> values cross some <code>threshold</code> y value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_threshold_crosses(
  y,
  x = NULL,
  threshold,
  return = "index",
  return_rising = TRUE,
  return_falling = TRUE,
  return_endpoints = TRUE,
  subset = NULL,
  na.rm = TRUE
)

first_below(
  y,
  x = NULL,
  threshold,
  return = "index",
  return_endpoints = TRUE,
  ...
)

first_above(
  y,
  x = NULL,
  threshold,
  return = "index",
  return_endpoints = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ThresholdFunctions_+3A_y">y</code></td>
<td>
<p>Numeric vector of y values in which to identify threshold
crossing event(s)</p>
</td></tr>
<tr><td><code id="ThresholdFunctions_+3A_x">x</code></td>
<td>
<p>Optional numeric vector of corresponding x values</p>
</td></tr>
<tr><td><code id="ThresholdFunctions_+3A_threshold">threshold</code></td>
<td>
<p>Threshold y value of interest</p>
</td></tr>
<tr><td><code id="ThresholdFunctions_+3A_return">return</code></td>
<td>
<p>One of <code>c("index", "x")</code>, determining whether the function
will return the <code>index</code> or <code>x</code> value associated with the
threshold-crossing event.
</p>
<p>If <code>index</code>, it will refer to the data point immediately after
the crossing event.
</p>
<p>If <code>x</code>, it will use linear interpolation and the data
points immediately before and after the threshold-crossing
to return the exact <code>x</code> value when the threshold crossing
occurred</p>
</td></tr>
<tr><td><code id="ThresholdFunctions_+3A_return_rising">return_rising</code></td>
<td>
<p>logical for whether crossing events where <code>y</code>
rises above <code>threshold</code> should be returned</p>
</td></tr>
<tr><td><code id="ThresholdFunctions_+3A_return_falling">return_falling</code></td>
<td>
<p>logical for whether crossing events where <code>y</code>
falls below <code>threshold</code> should be returned</p>
</td></tr>
<tr><td><code id="ThresholdFunctions_+3A_return_endpoints">return_endpoints</code></td>
<td>
<p>logical for whether startpoint should be returned
when the startpoint is above <code>threshold</code> and
<code>return_rising = TRUE</code>, or when the startpoint is
below <code>threshold</code> and <code>return_falling = TRUE</code></p>
</td></tr>
<tr><td><code id="ThresholdFunctions_+3A_subset">subset</code></td>
<td>
<p>A vector of logical values indicating which x and y values
should be included (TRUE) or excluded (FALSE).
</p>
<p>If <code>return = "index"</code>, index will be for the whole 
vector and not the subset of the vector</p>
</td></tr>
<tr><td><code id="ThresholdFunctions_+3A_na.rm">na.rm</code></td>
<td>
<p>logical whether NA's should be removed before analyzing.
If <code>return = 'index'</code>, indices will refer to the original
<code>y</code> vector *including* <code>NA</code> values</p>
</td></tr>
<tr><td><code id="ThresholdFunctions_+3A_...">...</code></td>
<td>
<p>(for <code>first_above</code> and <code>first_below</code>) other arguments 
to pass to <code>find_threshold_crosses</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>find_threshold_crosses</code> returns a vector corresponding to all the 
threshold crossings.
</p>
<p><code>first_above</code> returns only the first time the <code>y</code> values
rise above the threshold, so is a shortcut for 
<code>find_threshold_crosses(return_rising = TRUE, return_falling = FALSE)[1]</code>
</p>
<p><code>first_below</code> returns only the first time the <code>y</code> values
fall below the threshold, so is a shortcut for 
<code>find_threshold_crosses(return_rising = FALSE, return_falling = TRUE)[1]</code>
</p>
<p>If <code>return = "index"</code>, the returned value(s) are the indices
immediately following threshold crossing(s)
</p>
<p>If <code>return = "x"</code>, the returned value(s) are the x value(s) 
corresponding to threshold crossing(s)
</p>
<p>If no threshold-crossings are detected that meet the criteria, will
return <code>NA</code>
</p>

<hr>
<h2 id='to_excel'>A function that converts numbers into base-26 Excel-style letters</h2><span id='topic+to_excel'></span>

<h3>Description</h3>

<p>A function that converts numbers into base-26 Excel-style letters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_excel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_excel_+3A_x">x</code></td>
<td>
<p>A vector of numbers in base-10</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of letters in Excel-style base-26 format
</p>

<hr>
<h2 id='train_smooth_data'>Test efficacy of different smoothing parameters</h2><span id='topic+train_smooth_data'></span>

<h3>Description</h3>

<p>This function is based on <code>caret::train</code>, which runs models
(in our case different smoothing algorithms) on data across different 
parameter values (in our case different smoothness parameters).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train_smooth_data(
  ...,
  x = NULL,
  y = NULL,
  sm_method,
  preProcess = NULL,
  weights = NULL,
  metric = ifelse(is.factor(y), "Accuracy", "RMSE"),
  maximize = ifelse(metric %in% c("RMSE", "logLoss", "MAE", "logLoss"), FALSE, TRUE),
  trControl = caret::trainControl(method = "cv"),
  tuneGrid = NULL,
  tuneLength = ifelse(trControl$method == "none", 1, 3),
  return_trainobject = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="train_smooth_data_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>smooth_data</code>. These arguments cannot
overlap with any of those to be tuned.</p>
</td></tr>
<tr><td><code id="train_smooth_data_+3A_x">x</code></td>
<td>
<p>A vector of predictor values to smooth along (e.g. time)</p>
</td></tr>
<tr><td><code id="train_smooth_data_+3A_y">y</code></td>
<td>
<p>A vector of response values to be smoothed (e.g. density).</p>
</td></tr>
<tr><td><code id="train_smooth_data_+3A_sm_method">sm_method</code></td>
<td>
<p>Argument specifying which smoothing method should
be used. Options include &quot;moving-average&quot;, &quot;moving-median&quot;, 
&quot;loess&quot;, &quot;gam&quot;, and &quot;smooth.spline&quot;.</p>
</td></tr>
<tr><td><code id="train_smooth_data_+3A_preprocess">preProcess</code></td>
<td>
<p>A string vector that defines a pre-processing of the
predictor data. The default is no pre-processing.
See <code>caret::train</code> for more details.</p>
</td></tr>
<tr><td><code id="train_smooth_data_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of case weights. This argument currently
does not affect any <code>train_smooth_data</code> models.</p>
</td></tr>
<tr><td><code id="train_smooth_data_+3A_metric">metric</code></td>
<td>
<p>A string that specifies what summary metric will be
used to select the optimal model. By default, possible
values are &quot;RMSE&quot; and &quot;Rsquared&quot; for regression.
See <code>caret::train</code> for more details.</p>
</td></tr>
<tr><td><code id="train_smooth_data_+3A_maximize">maximize</code></td>
<td>
<p>A logical: should the metric be maximized or minimized?</p>
</td></tr>
<tr><td><code id="train_smooth_data_+3A_trcontrol">trControl</code></td>
<td>
<p>A list of values that define how this function acts.
See <code>caret::train</code> and <code>caret::trainControl</code>
for more details.</p>
</td></tr>
<tr><td><code id="train_smooth_data_+3A_tunegrid">tuneGrid</code></td>
<td>
<p>A data frame with possible tuning values, or a named list
containing vectors with possible tuning values. If a data 
frame, the columns should be named the same as the tuning 
parameters. If a list, the elements of the list should be
named the same as the tuning parameters. If a list,
<code>expand.grid</code> will be used to make all possible
combinations of tuning parameter values.</p>
</td></tr>
<tr><td><code id="train_smooth_data_+3A_tunelength">tuneLength</code></td>
<td>
<p>An integer denoting the amount of granularity in
the tuning parameter grid. By default, this argument
is the number of levels for each tuning parameter that
should be generated. If <code>trControl</code> has the option
<code>search = "random"</code>, this is the maximum number
of tuning parameter combinations that will be generated
by the random search. (NOTE: If given, this argument
must be named.)</p>
</td></tr>
<tr><td><code id="train_smooth_data_+3A_return_trainobject">return_trainobject</code></td>
<td>
<p>A logical indicating whether the entire result
of <code>caret::train</code> should be returned, or
only the <code>results</code> element.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>caret::train</code> for more information.
</p>
<p>The default method is k-fold cross-validation 
(<code>trControl = caret::trainControl(method = "cv")</code>). 
</p>
<p>For less variable, but more computationally costly, cross-validation,
users may choose to increase the number of folds. This can be
done by altering the <code>number</code> argument in 
<code>caret::trainControl</code>, or by setting <code>method = "LOOCV"</code> 
for leave one out cross-validation where the number of folds is 
equal to the number of data points. 
</p>
<p>For less variable, but more computationally costly, cross-validation,
users may alternatively choose <code>method = "repeatedcv"</code> for 
repeated k-fold cross-validation.
</p>
<p>For more control, advanced users may wish to call 
<code>caret::train</code> directly, using <code>makemethod_train_smooth_data</code> to 
specify the <code>method</code> argument.
</p>


<h3>Value</h3>

<p>If <code>return_trainobject = FALSE</code> (the default), a data frame
with the values of all tuning parameter combinations and the
training error rate for each combination (i.e. the <code>results</code>
element of the output of <code>caret::train</code>).
</p>
<p>If <code>return_trainobject = TRUE</code>, the output of <code>caret::train</code>
</p>

<hr>
<h2 id='trans_block_to_wide'>Transform blocks to wides</h2><span id='topic+trans_block_to_wide'></span>

<h3>Description</h3>

<p>Takes blocks and returns them in a wide format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans_block_to_wide(
  blocks,
  wellnames_sep = "",
  nested_metadata = NULL,
  colnames_first = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trans_block_to_wide_+3A_blocks">blocks</code></td>
<td>
<p>Blocks, either a single data.frame or a list of
data.frames</p>
</td></tr>
<tr><td><code id="trans_block_to_wide_+3A_wellnames_sep">wellnames_sep</code></td>
<td>
<p>String to use as separator for well names between 
rowname and column name (ordered according to
<code>colnames_first</code></p>
</td></tr>
<tr><td><code id="trans_block_to_wide_+3A_nested_metadata">nested_metadata</code></td>
<td>
<p>A logical indicating the existence of nested metadata
in the <code>blockmeasures</code> list, e.g. as is typically
output by <code>read_blocks</code>. If NULL, will attempt to
infer existence of nested metadata</p>
</td></tr>
<tr><td><code id="trans_block_to_wide_+3A_colnames_first">colnames_first</code></td>
<td>
<p>In the wellnames created by <code>paste</code>-ing the
rownames and column names, should the column names
come first</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single widemeasures data.frame
</p>

<hr>
<h2 id='trans_wide_to_tidy'>Pivot widemeasures longer</h2><span id='topic+trans_wide_to_tidy'></span>

<h3>Description</h3>

<p>Essentially a wrapper for tidyr::pivot_longer that works on both a single
widemeasures as well as a list of widemeasures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans_wide_to_tidy(
  wides,
  data_cols = NA,
  id_cols = NA,
  names_to = "Well",
  values_to = "Measurements",
  values_to_numeric = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trans_wide_to_tidy_+3A_wides">wides</code></td>
<td>
<p>A single widemeasures data.frame, or a list of widemeasures
data.frame's</p>
</td></tr>
<tr><td><code id="trans_wide_to_tidy_+3A_data_cols">data_cols</code>, <code id="trans_wide_to_tidy_+3A_id_cols">id_cols</code></td>
<td>
<p>Specifies which columns have data vs are ID's
(in <code>tidyr::pivot_longer</code> parlance). Each can be
a single vector (which will be applied for all
widemeasures) or a list of vectors, with each
vector corresponding to the same-index widemeasure
in <code>widemeasures</code>
</p>
<p>Entries that are NA in the list will not be used
</p>
<p>If neither data_cols nor id_cols are specified,
user must provide arguments to tidyr::pivot_longer
via <code>...</code> for at least the <code>cols</code> argument
and these arguments provided via <code>...</code> will
be used for all <code>widemeasures</code> data.frame's</p>
</td></tr>
<tr><td><code id="trans_wide_to_tidy_+3A_names_to">names_to</code>, <code id="trans_wide_to_tidy_+3A_values_to">values_to</code></td>
<td>
<p>Specifies the output column names created by
tidyr::pivot_longer. Each can be provided as vectors
the same length as <code>widemeasures</code>
Note that if neither data_cols nor id_cols</p>
</td></tr>
<tr><td><code id="trans_wide_to_tidy_+3A_values_to_numeric">values_to_numeric</code></td>
<td>
<p>logical indicating whether values will be coerced
to numeric. See below for when this may be
overridden by arguments passed in <code>...</code></p>
</td></tr>
<tr><td><code id="trans_wide_to_tidy_+3A_...">...</code></td>
<td>
<p>Other functions to be passed to <code>tidyr::pivot_longer</code>
Note that including values_transform here will override the
behavior of values_to_numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pivoted longer data.frame (if <code>widemeasures</code> is a single data.frame)
or list of pivoted longer data.frame's (if <code>widemeasures</code> is
a list of data.frame's)
</p>

<hr>
<h2 id='uninterleave'>Uninterleave list</h2><span id='topic+uninterleave'></span>

<h3>Description</h3>

<p>Takes a list that is actually interleaved elements from multiple sources
and uninterleaves them into the separate sources. For instance, a list of 
blockmeasures that actually corresponds to two different plates can be 
split into two lists, each of the blockmeasures corresponding to a single 
plate. Uninterleave assumes that the desired sub-groups are perfectly
interleaved in the input (e.g. items belong to sub-groups 1,2,3,1,2,3,...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uninterleave(interleaved_list, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uninterleave_+3A_interleaved_list">interleaved_list</code></td>
<td>
<p>A list of R objects</p>
</td></tr>
<tr><td><code id="uninterleave_+3A_n">n</code></td>
<td>
<p>How many output sub lists there should be (i.e. how many groups
the interleaved list should be divided into)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists of R objects
</p>

<hr>
<h2 id='WhichMinMaxGC'>Where is the Min() or Max() or first TRUE or FALSE?</h2><span id='topic+WhichMinMaxGC'></span><span id='topic+which_min_gc'></span><span id='topic+which_max_gc'></span>

<h3>Description</h3>

<p>Determines the location, i.e. index, of the (first) minimum or maximum of
a numeric (or logical) vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_min_gc(x, empty_NA = TRUE)

which_max_gc(x, empty_NA = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WhichMinMaxGC_+3A_x">x</code></td>
<td>
<p>numeric (logical, integer, or double) vector or an <code>R</code> object
for which the internal coercion to double works whose min or max
is searched for.</p>
</td></tr>
<tr><td><code id="WhichMinMaxGC_+3A_empty_na">empty_NA</code></td>
<td>
<p>logical, indicating if an empty value should be returned
as <code>NA</code> (the default) or as <code>integer(0</code>) (the
same as <code>which.min</code> and <code>which.max</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are wrappers for <code>which.min</code> and <code>which.max</code>,
with the additional argument <code>empty_NA</code>.
</p>


<h3>Value</h3>

<p>If <code>empty_NA = FALSE</code>, identical to <code>which.min</code> or 
<code>which.max</code>
</p>
<p>If <code>empty_NA = TRUE</code>, identical to <code>which.min</code> or 
<code>which.max</code> except that, in cases where <code>which.min</code> or 
<code>which.max</code> would return <code>integer(0)</code>, <code>which_min_gc</code> and
<code>which_max_gc</code> return <code>NA</code>
</p>

<hr>
<h2 id='write_blocks'>Write block designs to csv</h2><span id='topic+write_blocks'></span>

<h3>Description</h3>

<p>This function writes block-shaped lists (as created by
<code>read_blocks</code> or <code>make_design</code>) to csv files, including
both <code>data</code> and <code>metadata</code> in a variety of output formats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_blocks(
  blocks,
  file,
  output_format = "multiple",
  block_name_location = NULL,
  block_name_header = "block_name",
  paste_sep = "_",
  filename_sep = "_",
  na = "",
  dir = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_blocks_+3A_blocks">blocks</code></td>
<td>
<p>list of block-shaped data to be written to file</p>
</td></tr>
<tr><td><code id="write_blocks_+3A_file">file</code></td>
<td>
<p><code>NULL</code>, a character string naming a file to write to, or a 
vector of character strings naming files to write to. 
</p>
<p>A file name is required when <code>output_format = "single"</code>
</p>
<p>A file name can be specified when <code>output_format = "pasted"</code>,
or <code>file</code> can be set to <code>NULL</code> as long as 
<code>block_name_location = "filename"</code> (where pasted 
<code>block_name</code> metadata will be used for the file name)
</p>
<p>File names can be specified when <code>output_format = "multiple"</code>,
or <code>file</code> can be set to <code>NULL</code> as long as 
<code>block_name_location = "filename"</code> (where the 
<code>block_name</code> metadata will be used for the file names)</p>
</td></tr>
<tr><td><code id="write_blocks_+3A_output_format">output_format</code></td>
<td>
<p>One of &quot;single&quot;, &quot;pasted&quot;, &quot;multiple&quot;.
</p>
<p>&quot;single&quot; will write all blocks into a single
csv file, with an empty row between successive
blocks.
</p>
<p>&quot;pasted&quot; will paste all blocks together using a
<code>paste_sep</code>, and then write that now-pasted
block to a single csv file.
</p>
<p>&quot;multiple&quot; will write each block to its own csv file.</p>
</td></tr>
<tr><td><code id="write_blocks_+3A_block_name_location">block_name_location</code></td>
<td>
<p>Either <code>NULL</code>, 'filename' or 'file'.
</p>
<p>If <code>NULL</code>, <code>block_name_location</code> will 
be automatically selected based on 
<code>output_format</code>. For 
<code>output_format = 'single'</code> and 
<code>output_format = 'pasted'</code>, 
<code>block_name_location</code> defaults to 'file'.
For <code>output_format = 'multiple'</code>, 
<code>block_name_location</code> defaults to 'filename'
</p>
<p>If 'filename', the <code>block_name</code> metadata 
will be used as the output file name(s) when
no file name(s) are provided, or appended to
file name(s) when they have been provided.
</p>
<p>If 'file', the <code>block_name</code> metadata will be
included as a row in the output file.</p>
</td></tr>
<tr><td><code id="write_blocks_+3A_block_name_header">block_name_header</code></td>
<td>
<p>The name of the field containing the
<code>block_names</code></p>
</td></tr>
<tr><td><code id="write_blocks_+3A_paste_sep">paste_sep</code></td>
<td>
<p>When <code>output_format = 'pasted'</code>, what character
will be used to paste together blocks.</p>
</td></tr>
<tr><td><code id="write_blocks_+3A_filename_sep">filename_sep</code></td>
<td>
<p>What character will be used to paste together 
filenames when block_name_location = 'filename'.</p>
</td></tr>
<tr><td><code id="write_blocks_+3A_na">na</code></td>
<td>
<p>The string to use for missing values in the data.</p>
</td></tr>
<tr><td><code id="write_blocks_+3A_dir">dir</code></td>
<td>
<p>The directory that file(s) will be written into. When 
<code>dir = NULL</code>, writes to the current working directory.
(Can only be used when <code>file = NULL</code>)</p>
</td></tr>
<tr><td><code id="write_blocks_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>write.table</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, but R objects are written to files
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
