<!DOCTYPE html><html><head><title>Help for package drtmle</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {drtmle}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adaptive_iptw'><p>Compute asymptotically linear IPTW estimators with super learning</p>
for the propensity score</a></li>
<li><a href='#average_est_cov_list'><p>Helper function for averaging lists of estimates</p>
generated in the main <code>for</code> loop of <code>drtmle</code></a></li>
<li><a href='#average_ic_list'><p>Helper function to average convergence results and drtmle</p>
influence function estimates over multiple fits</a></li>
<li><a href='#ci'><p>Compute confidence intervals for drtmle and adaptive_iptw@</p></a></li>
<li><a href='#ci.adaptive_iptw'><p>Confidence intervals for adaptive_iptw objects</p></a></li>
<li><a href='#ci.drtmle'><p>Confidence intervals for drtmle objects</p></a></li>
<li><a href='#drtmle'><p>TMLE estimate of the average treatment effect with doubly-robust inference</p></a></li>
<li><a href='#estimateG'><p>estimateG</p></a></li>
<li><a href='#estimateG_loop'><p>estimateG_loop</p></a></li>
<li><a href='#estimategrn'><p>estimategrn</p></a></li>
<li><a href='#estimategrn_loop'><p>estimategrn_loop</p></a></li>
<li><a href='#estimateQ'><p>estimateQ</p></a></li>
<li><a href='#estimateQ_loop'><p>estimateQ_loop</p></a></li>
<li><a href='#estimateQrn'><p>estimateQrn</p></a></li>
<li><a href='#estimateQrn_loop'><p>estimateQrn_loop</p></a></li>
<li><a href='#eval_Diptw'><p>Evaluate usual influence function of IPTW</p></a></li>
<li><a href='#eval_Diptw_g'><p>Evaluate extra piece of the influence function for the IPTW</p></a></li>
<li><a href='#eval_Dstar'><p>Evaluate usual efficient influence function</p></a></li>
<li><a href='#eval_Dstar_g'><p>Evaluate extra piece of efficient influence function resulting from</p>
misspecification of outcome regression</a></li>
<li><a href='#eval_Dstar_Q'><p>Evaluate extra piece of efficient influence function resulting from</p>
misspecification of propensity score</a></li>
<li><a href='#extract_models'><p>Help function to extract models from fitted object</p></a></li>
<li><a href='#fluctuateG'><p>fluctuateG</p></a></li>
<li><a href='#fluctuateQ'><p>fluctuateQ</p></a></li>
<li><a href='#fluctuateQ1'><p>fluctuateQ1</p></a></li>
<li><a href='#fluctuateQ2'><p>fluctuateQ2</p></a></li>
<li><a href='#make_validRows'><p>Make list of rows in each validation fold.</p></a></li>
<li><a href='#partial_cv_preds'><p>Helper function to properly format partially cross-validated predictions</p>
from a fitted super learner.</a></li>
<li><a href='#plot.drtmle'><p>Plot reduced dimension regression fits</p></a></li>
<li><a href='#predict.SL.npreg'><p>Predict method for SL.npreg</p></a></li>
<li><a href='#print.adaptive_iptw'><p>Print the output of a <code>"adaptive_iptw"</code> object.</p></a></li>
<li><a href='#print.ci.adaptive_iptw'><p>Print the output of ci.adaptive_iptw</p></a></li>
<li><a href='#print.ci.drtmle'><p>Print the output of ci.drtmle</p></a></li>
<li><a href='#print.drtmle'><p>Print the output of a <code>"drtmle"</code> object.</p></a></li>
<li><a href='#print.wald_test.adaptive_iptw'><p>Print the output of wald_test.adaptive_iptw</p></a></li>
<li><a href='#print.wald_test.drtmle'><p>Print the output of wald_test.drtmle</p></a></li>
<li><a href='#reorder_list'><p>Helper function to reorder lists according to cvFolds</p></a></li>
<li><a href='#SL.npreg'><p>Super learner wrapper for kernel regression</p></a></li>
<li><a href='#tmp_method.CC_LS'><p>Temporary fix for convex combination method mean squared error</p>
Relative to existing implementation, we reduce the tolerance at which
we declare predictions from a given algorithm the same as another</a></li>
<li><a href='#tmp_method.CC_nloglik'><p>Temporary fix for convex combination method negative log-likelihood loss</p>
Relative to existing implementation, we reduce the tolerance at which
we declare predictions from a given algorithm the same as another.
Note that because of the way <code>SuperLearner</code> is structure, one needs to
install the optimization software separately.</a></li>
<li><a href='#wald_test'><p>Wald tests for drtmle and adaptive_iptw objects</p></a></li>
<li><a href='#wald_test.adaptive_iptw'><p>Wald tests for adaptive_iptw objects</p></a></li>
<li><a href='#wald_test.drtmle'><p>Wald tests for drtmle objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Doubly-Robust Nonparametric Estimation and Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Targeted minimum loss-based estimators of counterfactual means and
    causal effects that are doubly-robust with respect both to consistency and
    asymptotic normality (Benkeser et al (2017), &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasx053">doi:10.1093/biomet/asx053</a>&gt;; MJ
    van der Laan (2014), &lt;<a href="https://doi.org/10.1515%2Fijb-2012-0038">doi:10.1515/ijb-2012-0038</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>SuperLearner, np, future.apply</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, gam, quadprog, nloptr, parallel,
foreach, stringi</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/benkeser/drtmle">https://github.com/benkeser/drtmle</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/benkeser/drtmle/issues">https://github.com/benkeser/drtmle/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-29 16:57:50 UTC; dbenkes</td>
</tr>
<tr>
<td>Author:</td>
<td>David Benkeser <a href="https://orcid.org/0000-0002-1019-8343"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Nima Hejazi <a href="https://orcid.org/0000-0002-7127-2789"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Benkeser &lt;benkeser@emory.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-05 19:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adaptive_iptw'>Compute asymptotically linear IPTW estimators with super learning
for the propensity score</h2><span id='topic+adaptive_iptw'></span>

<h3>Description</h3>

<p>Compute asymptotically linear IPTW estimators with super learning
for the propensity score
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptive_iptw(W, A, Y, DeltaY = as.numeric(!is.na(Y)),
  DeltaA = as.numeric(!is.na(A)), stratify = FALSE, family = if (all(Y
  %in% c(0, 1))) {     stats::binomial() } else {     stats::gaussian() },
  a_0 = unique(A[!is.na(A)]), SL_g = NULL, glm_g = NULL, SL_Qr = NULL,
  glm_Qr = NULL, returnModels = TRUE, verbose = FALSE, maxIter = 2,
  tolIC = 1/length(Y), tolg = 0.01, cvFolds = 1, gn = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaptive_iptw_+3A_w">W</code></td>
<td>
<p>A <code>data.frame</code> of named covariates</p>
</td></tr>
<tr><td><code id="adaptive_iptw_+3A_a">A</code></td>
<td>
<p>A <code>numeric</code> vector of binary treatment assignment (assumed to
be equal to 0 or 1)</p>
</td></tr>
<tr><td><code id="adaptive_iptw_+3A_y">Y</code></td>
<td>
<p>A <code>numeric</code> numeric of continuous or binary outcomes.</p>
</td></tr>
<tr><td><code id="adaptive_iptw_+3A_deltay">DeltaY</code></td>
<td>
<p>A <code>numeric</code> indicator of missing outcome (assumed to be
equal to 0 if missing 1 if observed)</p>
</td></tr>
<tr><td><code id="adaptive_iptw_+3A_deltaa">DeltaA</code></td>
<td>
<p>A <code>numeric</code> indicator of missing treatment (assumed to be
equal to 0 if missing 1 if observed)</p>
</td></tr>
<tr><td><code id="adaptive_iptw_+3A_stratify">stratify</code></td>
<td>
<p>A <code>logical</code> indicating whether to estimate the missing
outcome regression separately for observations with different levels of
<code>A</code> (if <code>TRUE</code>) or to pool across <code>A</code> (if <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="adaptive_iptw_+3A_family">family</code></td>
<td>
<p>A <code>family</code> object equal to either <code>binomial()</code> or
<code>gaussian()</code>, to be passed to the <code>SuperLearner</code> or <code>glm</code>
function.</p>
</td></tr>
<tr><td><code id="adaptive_iptw_+3A_a_0">a_0</code></td>
<td>
<p>A vector of <code>numeric</code> treatment values at which to return
marginal mean estimates.</p>
</td></tr>
<tr><td><code id="adaptive_iptw_+3A_sl_g">SL_g</code></td>
<td>
<p>A vector of characters describing the super learner library to be
used for each of the propensity score regressions (<code>DeltaA</code>, <code>A</code>,
and <code>DeltaY</code>). To use the same library for each of the regressions (or
if there is no missing data in <code>A</code> nor <code>Y</code>), a single library may
be input. See <code>link{SuperLearner::SuperLearner}</code> for details on how
super learner libraries can be specified.</p>
</td></tr>
<tr><td><code id="adaptive_iptw_+3A_glm_g">glm_g</code></td>
<td>
<p>A list of characters describing the formulas to be used
for each of the propensity score regressions (<code>DeltaA</code>, <code>A</code>, and
<code>DeltaY</code>). To use the same formula for each of the regressions (or if
there is no missing data in <code>A</code> nor <code>Y</code>), a single character
formula may be input.</p>
</td></tr>
<tr><td><code id="adaptive_iptw_+3A_sl_qr">SL_Qr</code></td>
<td>
<p>A vector of characters or a list describing the Super Learner
library to be used for the reduced-dimension outcome regression.</p>
</td></tr>
<tr><td><code id="adaptive_iptw_+3A_glm_qr">glm_Qr</code></td>
<td>
<p>A character describing a formula to be used in the call to
<code>glm</code> for reduced-dimension outcome regression. Ignored if
<code>SL_Qr!=NULL</code>. The formula should use the variable name <code>'gn'</code>.</p>
</td></tr>
<tr><td><code id="adaptive_iptw_+3A_returnmodels">returnModels</code></td>
<td>
<p>A logical indicating whether to return model fits for the
propensity score and reduced-dimension regressions.</p>
</td></tr>
<tr><td><code id="adaptive_iptw_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating whether to print status updates.</p>
</td></tr>
<tr><td><code id="adaptive_iptw_+3A_maxiter">maxIter</code></td>
<td>
<p>A numeric that sets the maximum number of iterations the TMLE
can perform in its fluctuation step.</p>
</td></tr>
<tr><td><code id="adaptive_iptw_+3A_tolic">tolIC</code></td>
<td>
<p>A numeric that defines the stopping criteria based on the
empirical mean of the influence function.</p>
</td></tr>
<tr><td><code id="adaptive_iptw_+3A_tolg">tolg</code></td>
<td>
<p>A numeric indicating the minimum value for estimates of the
propensity score.</p>
</td></tr>
<tr><td><code id="adaptive_iptw_+3A_cvfolds">cvFolds</code></td>
<td>
<p>A numeric equal to the number of folds to be used in
cross-validated fitting of nuisance parameters. If <code>cvFolds = 1</code>, no
cross-validation is used.</p>
</td></tr>
<tr><td><code id="adaptive_iptw_+3A_gn">gn</code></td>
<td>
<p>An optional list of propensity score estimates. If specified, the
function will ignore the nuisance parameter estimation specified by
<code>SL_g</code> and <code>glm_g</code>. The entries in the list should correspond to
the propensity for the observed values of <code>W</code>, with order determined by
the input to <code>a_0</code> (e.g., if <code>a_0 = c(0,1)</code> then <code>gn[[1]]</code>
should be propensity of <code>A</code> = 0 and <code>gn[[2]]</code> should be propensity
of <code>A</code> = 1).</p>
</td></tr>
<tr><td><code id="adaptive_iptw_+3A_...">...</code></td>
<td>
<p>Other options (not currently used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"adaptive_iptw"</code>.
</p>

<dl>
<dt><code>iptw_tmle</code></dt><dd><p>A <code>list</code> of point estimates and
covariance matrix for the IPTW estimator based on a targeted
propensity score. </p>
</dd>
<dt><code>iptw_tmle_nuisance</code></dt><dd><p>A <code>list</code> of the final TMLE estimates
of the propensity score (<code>$gnStar</code>) and reduced-dimension
regression (<code>$QrnStar</code>) evaluated at the observed data values.</p>
</dd>
<dt><code>iptw_os</code></dt><dd><p>A <code>list</code> of point estimates and covariance matrix
for the one-step correct IPTW estimator.</p>
</dd>
<dt><code>iptw_os_nuisance</code></dt><dd><p>A <code>list</code> of the initial estimates of the
propensity score and reduced-dimension regression evaluated at the
observed data values.</p>
</dd>
<dt><code>iptw</code></dt><dd><p>A <code>list</code> of point estimates for the standard IPTW
estimator. No estimate of the covariance matrix is provided because
theory does not support asymptotic Normality of the IPTW estimator if
super learning is used to estimate the propensity score.</p>
</dd>
<dt><code>gnMod</code></dt><dd><p>The fitted object for the propensity score. Returns
<code>NULL</code> if <code>returnModels = FALSE</code>.</p>
</dd>
<dt><code>QrnMod</code></dt><dd><p>The fitted object for the reduced-dimension regression
that guards against misspecification of the outcome regression.
Returns <code>NULL</code> if <code>returnModels = FALSE</code>.</p>
</dd>
<dt><code>a_0</code></dt><dd><p>The treatment levels that were requested for computation
of covariate-adjusted means.</p>
</dd>
<dt><code>call</code></dt><dd><p>The call to <code>adaptive_iptw</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># load super learner
library(SuperLearner)
# simulate data
set.seed(123456)
n &lt;- 100
W &lt;- data.frame(W1 = runif(n), W2 = rnorm(n))
A &lt;- rbinom(n, 1, plogis(W$W1 - W$W2))
Y &lt;- rbinom(n, 1, plogis(W$W1 * W$W2 * A))
# fit iptw with maxIter = 1 to run fast

fit1 &lt;- adaptive_iptw(
  W = W, A = A, Y = Y, a_0 = c(1, 0),
  SL_g = c("SL.glm", "SL.mean", "SL.step"),
  SL_Qr = "SL.npreg", maxIter = 1
)

</code></pre>

<hr>
<h2 id='average_est_cov_list'>Helper function for averaging lists of estimates
generated in the main <code>for</code> loop of <code>drtmle</code></h2><span id='topic+average_est_cov_list'></span>

<h3>Description</h3>

<p>Helper function for averaging lists of estimates
generated in the main <code>for</code> loop of <code>drtmle</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average_est_cov_list(est_cov_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="average_est_cov_list_+3A_est_cov_list">est_cov_list</code></td>
<td>
<p>A list with named entries <code>est</code> and <code>cov</code></p>
</td></tr>
</table>

<hr>
<h2 id='average_ic_list'>Helper function to average convergence results and drtmle
influence function estimates over multiple fits</h2><span id='topic+average_ic_list'></span>

<h3>Description</h3>

<p>Helper function to average convergence results and drtmle
influence function estimates over multiple fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average_ic_list(ic_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="average_ic_list_+3A_ic_list">ic_list</code></td>
<td>
<p>List of influence function estimates</p>
</td></tr>
</table>

<hr>
<h2 id='ci'>Compute confidence intervals for drtmle and adaptive_iptw@</h2><span id='topic+ci'></span>

<h3>Description</h3>

<p>Compute confidence intervals for drtmle and adaptive_iptw@
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to method</p>
</td></tr>
</table>

<hr>
<h2 id='ci.adaptive_iptw'>Confidence intervals for adaptive_iptw objects</h2><span id='topic+ci.adaptive_iptw'></span>

<h3>Description</h3>

<p>Estimate confidence intervals for objects of class <code>"adaptive_iptw"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adaptive_iptw'
ci(object, est = c("iptw_tmle"), level = 0.95, contrast = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci.adaptive_iptw_+3A_object">object</code></td>
<td>
<p>An object of class <code>"adaptive_iptw"</code></p>
</td></tr>
<tr><td><code id="ci.adaptive_iptw_+3A_est">est</code></td>
<td>
<p>A vector indicating for which estimators to return a
confidence interval. Possible estimators include the TMLE IPTW
(<code>"iptw_tmle"</code>, recommended), the one-step IPTW
(<code>"iptw_os"</code>, not recommended), the standard IPTW
(<code>"iptw"</code>, recommended only for comparison to the other two estimators).</p>
</td></tr>
<tr><td><code id="ci.adaptive_iptw_+3A_level">level</code></td>
<td>
<p>The nominal coverage probability of the desired confidence
interval (should be between 0 and 1). Default computes 95\
intervals.</p>
</td></tr>
<tr><td><code id="ci.adaptive_iptw_+3A_contrast">contrast</code></td>
<td>
<p>Specifies the parameter for which to return confidence
intervals. If <code>contrast=NULL</code>, then confidence intervals for the
marginal means are computed. If instead, <code>contrast</code> is a numeric vector
of ones, negative ones, and zeros to define linear combinations of the
various means (e.g., to estimate an average treatment effect, see example).
Finally, <code>contrast</code> can be a list with named functions <code>f</code>,
<code>f_inv</code>, <code>h</code>, and <code>fh_grad</code>. The first two functions should
take as input argument <code>eff</code>. Respectively, these specify which
transformation of the effect measure to compute the confidence interval for
and the inverse transformation to put the confidence interval back on the
original scale. The function <code>h</code> defines the contrast to be estimated
and should take as input <code>est</code>, a vector of the same length as
<code>object$a_0</code>, and output the desired contrast. The function
<code>fh_grad</code> is the gradient of the function <code>h</code>. See examples and
vignette for more information.</p>
</td></tr>
<tr><td><code id="ci.adaptive_iptw_+3A_...">...</code></td>
<td>
<p>Other options (not currently used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"ci.adaptive_iptw"</code> with point estimates and
confidence intervals of the specified level.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load super learner
library(SuperLearner)
# fit adaptive_iptw
set.seed(123456)
n &lt;- 200
W &lt;- data.frame(W1 = runif(n), W2 = rnorm(n))
A &lt;- rbinom(n, 1, plogis(W$W1 - W$W2))
Y &lt;- rbinom(n, 1, plogis(W$W1 * W$W2 * A))

fit1 &lt;- adaptive_iptw(
  W = W, A = A, Y = Y, a_0 = c(1, 0),
  SL_g = c("SL.glm", "SL.mean", "SL.step"),
  SL_Qr = "SL.glm"
)

# get confidence intervals for each mean
ci_mean &lt;- ci(fit1)

# get confidence intervals for ATE
ci_ATE &lt;- ci(fit1, contrast = c(1, -1))

# get confidence intervals for risk ratio
# by inputting own contrast function
# this computes CI on log scale and back transforms
myContrast &lt;- list(
  f = function(eff) {
    log(eff)
  },
  f_inv = function(eff) {
    exp(eff)
  },
  h = function(est) {
    est[1] / est[2]
  },
  fh_grad = function(est) {
    c(1 / est[1], -1 / est[2])
  }
)
ci_RR &lt;- ci(fit1, contrast = myContrast)
</code></pre>

<hr>
<h2 id='ci.drtmle'>Confidence intervals for drtmle objects</h2><span id='topic+ci.drtmle'></span>

<h3>Description</h3>

<p>Confidence intervals for drtmle objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drtmle'
ci(object, est = c("drtmle"), level = 0.95, contrast = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci.drtmle_+3A_object">object</code></td>
<td>
<p>An object of class <code>"drtmle"</code></p>
</td></tr>
<tr><td><code id="ci.drtmle_+3A_est">est</code></td>
<td>
<p>A vector indicating for which estimators to return a
confidence interval. Possible estimators include the TMLE with doubly robust
inference (<code>"drtmle"</code>, recommended), the AIPTW with additional
correction for misspecification (<code>"aiptw_c"</code>, not recommended), the
standard TMLE (<code>"tmle"</code>, recommended only for comparison to &quot;drtmle&quot;),
the standard AIPTW (<code>"aiptw"</code>, recommended only for comparison to
&quot;drtmle&quot;), and G-computation (<code>"gcomp"</code>, not recommended).</p>
</td></tr>
<tr><td><code id="ci.drtmle_+3A_level">level</code></td>
<td>
<p>The nominal coverage probability of the desired confidence
interval (should be between 0 and 1). Default computes 95\
intervals.</p>
</td></tr>
<tr><td><code id="ci.drtmle_+3A_contrast">contrast</code></td>
<td>
<p>Specifies the parameter for which to return confidence
intervals. If <code>contrast=NULL</code>, then confidence intervals for the
marginal means are computed. If instead, <code>contrast</code> is a numeric vector
of ones, negative ones, and zeros to define linear combinations of the
various means (e.g., to estimate an average treatment effect, see example).
Finally, <code>contrast</code> can be a list with named functions <code>f</code>,
<code>f_inv</code>, <code>h</code>, and <code>fh_grad</code>. The first two functions should
take as input argument <code>eff</code>. Respectively, these specify which
transformation of the effect measure to compute the confidence interval for
and the inverse transformation to put the confidence interval back on the
original scale. The function <code>h</code> defines the contrast to be estimated
and should take as input <code>est</code>, a vector of the same length as
<code>object$a_0</code>, and output the desired contrast. The function
<code>fh_grad</code> is the gradient of the function <code>h</code>. See examples and
vignette for more information.</p>
</td></tr>
<tr><td><code id="ci.drtmle_+3A_...">...</code></td>
<td>
<p>Other options (not currently used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"ci.drtmle"</code> with point estimates and
confidence intervals of the specified level.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load super learner
library(SuperLearner)
# simulate data
set.seed(123456)
n &lt;- 100
W &lt;- data.frame(W1 = runif(n), W2 = rnorm(n))
A &lt;- rbinom(n, 1, plogis(W$W1 - W$W2))
Y &lt;- rbinom(n, 1, plogis(W$W1 * W$W2 * A))

# fit drtmle with maxIter = 1 to run fast
fit1 &lt;- drtmle(
  W = W, A = A, Y = Y, a_0 = c(1, 0),
  family = binomial(),
  stratify = FALSE,
  SL_Q = c("SL.glm", "SL.mean"),
  SL_g = c("SL.glm", "SL.mean"),
  SL_Qr = "SL.npreg",
  SL_gr = "SL.npreg", maxIter = 1
)

# get confidence intervals for each mean
ci_mean &lt;- ci(fit1)

# get confidence intervals for ATE
ci_ATE &lt;- ci(fit1, contrast = c(1, -1))

# get confidence intervals for risk ratio by
# computing CI on log scale and back-transforming
myContrast &lt;- list(
  f = function(eff) {
    log(eff)
  },
  f_inv = function(eff) {
    exp(eff)
  },
  h = function(est) {
    est[1] / est[2]
  },
  fh_grad = function(est) {
    c(1 / est[1], -1 / est[2])
  }
)
ci_RR &lt;- ci(fit1, contrast = myContrast)

</code></pre>

<hr>
<h2 id='drtmle'>TMLE estimate of the average treatment effect with doubly-robust inference</h2><span id='topic+drtmle'></span>

<h3>Description</h3>

<p>TMLE estimate of the average treatment effect with doubly-robust inference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drtmle(Y, A, W, DeltaA = as.numeric(!is.na(A)),
  DeltaY = as.numeric(!is.na(Y)), a_0 = unique(A[!is.na(A)]), family = if
  (all(Y %in% c(0, 1))) {     stats::binomial() } else {    
  stats::gaussian() }, stratify = FALSE, SL_Q = NULL, SL_g = NULL,
  SL_Qr = NULL, SL_gr = NULL, n_SL = 1, avg_over = "drtmle",
  se_cv = "none", se_cvFolds = ifelse(se_cv == "partial", 10, 1),
  targeted_se = se_cv != "partial", glm_Q = NULL, glm_g = NULL,
  glm_Qr = NULL, glm_gr = NULL, adapt_g = FALSE, guard = c("Q", "g"),
  reduction = "univariate", returnModels = FALSE, returnNuisance = TRUE,
  cvFolds = 1, maxIter = 3, tolIC = 1/length(Y), tolg = 0.01,
  verbose = FALSE, Qsteps = 2, Qn = NULL, gn = NULL,
  use_future = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drtmle_+3A_y">Y</code></td>
<td>
<p>A <code>numeric</code> continuous or binary outcomes.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_a">A</code></td>
<td>
<p>A <code>numeric</code> vector of discrete-valued treatment assignment.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_w">W</code></td>
<td>
<p>A <code>data.frame</code> of named covariates.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_deltaa">DeltaA</code></td>
<td>
<p>A <code>numeric</code> vector of missing treatment indicator (assumed
to be equal to 0 if missing 1 if observed).</p>
</td></tr>
<tr><td><code id="drtmle_+3A_deltay">DeltaY</code></td>
<td>
<p>A <code>numeric</code> vector of missing outcome indicator (assumed
to be equal to 0 if missing 1 if observed).</p>
</td></tr>
<tr><td><code id="drtmle_+3A_a_0">a_0</code></td>
<td>
<p>A <code>numeric</code> vector of fixed treatment values at which to
return marginal mean estimates.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_family">family</code></td>
<td>
<p>A <code>family</code> object equal to either <code>binomial()</code> or
<code>gaussian()</code>, to be passed to the <code>SuperLearner</code> or <code>glm</code>
function.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_stratify">stratify</code></td>
<td>
<p>A <code>boolean</code> indicating whether to estimate the outcome
regression separately for different values of <code>A</code> (if <code>TRUE</code>) or
to pool across <code>A</code> (if <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="drtmle_+3A_sl_q">SL_Q</code></td>
<td>
<p>A vector of characters or a list describing the Super Learner
library to be used for the outcome regression. See
<code><a href="SuperLearner.html#topic+SuperLearner">SuperLearner</a></code> for details.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_sl_g">SL_g</code></td>
<td>
<p>A vector of characters describing the super learner library to be
used for each of the propensity score regressions (<code>DeltaA</code>, <code>A</code>,
and <code>DeltaY</code>). To use the same library for each of the regressions (or
if there is no missing data in <code>A</code> nor <code>Y</code>), a single library may
be input. See <code><a href="SuperLearner.html#topic+SuperLearner">SuperLearner</a></code> for details on how
super learner libraries can be specified.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_sl_qr">SL_Qr</code></td>
<td>
<p>A vector of characters or a list describing the Super Learner
library to be used for the reduced-dimension outcome regression.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_sl_gr">SL_gr</code></td>
<td>
<p>A vector of characters or a list describing the Super Learner
library to be used for the reduced-dimension propensity score.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_n_sl">n_SL</code></td>
<td>
<p>Number of repeated Super Learners to run (default 1) for the
each nuisance parameter. Repeat Super Learners more times to obtain more stable
inference.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_avg_over">avg_over</code></td>
<td>
<p>If multiple Super Learners are run, on which scale should the
results be aggregated. Options include: <code>"SL"</code> =
repeated nuisance parameter estimates are averaged before subsequently
generating a single vector of point estimates based on the averaged models;
<code>"drtmle"</code> = repeated vectors of point estimates are generated and
averaged. Both can be specified, recognizing that this adds considerable
computational expense. In this case, the final estimates are the average
of <code>n_SL</code> point estimates where each is built by averaging <code>n_SL</code>
fits. If <code>NULL</code>, no averaging is performed (in which case <code>n_SL</code>
should be set equal to 1).</p>
</td></tr>
<tr><td><code id="drtmle_+3A_se_cv">se_cv</code></td>
<td>
<p>Should cross-validated nuisance parameter estimates be used
for computing standard errors?
Options are <code>"none"</code> = no cross-validation is performed; <code>"partial"</code> =
only applicable if Super Learner is used for nuisance parameter estimates;
<code>"full"</code> = full cross-validation is performed. See vignette for further
details. Ignored if <code>cvFolds &gt; 1</code>, since then
cross-validated nuisance parameter estimates are used by default and it is
assumed that you want full cross-validated standard errors.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_se_cvfolds">se_cvFolds</code></td>
<td>
<p>If cross-validated nuisance parameter estimates are used
to compute standard errors, how many folds should be used in this computation.
If <code>se_cv = "partial"</code>, then this option sets the number of folds used
by the <code>SuperLearner</code> fitting procedure.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_targeted_se">targeted_se</code></td>
<td>
<p>A boolean indicating whether the targeted nuisance
parameters should be used in standard error computation or the initial
estimators. If <code>se_cv</code> is not set to <code>"none"</code>, this option is
ignored and standard errors are computed based on non-targeted, cross-validated
nuisance parameter fits.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_glm_q">glm_Q</code></td>
<td>
<p>A character describing a formula to be used in the call to
<code>glm</code> for the outcome regression. Ignored if <code>SL_Q!=NULL</code>.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_glm_g">glm_g</code></td>
<td>
<p>A list of characters describing the formulas to be used
for each of the propensity score regressions (<code>DeltaA</code>, <code>A</code>, and
<code>DeltaY</code>). To use the same formula for each of the regressions (or if
there are no missing data in <code>A</code> nor <code>Y</code>), a single character
formula may be input. In general the formulas can reference any variable in
<code>colnames(W)</code>, unless <code>adapt_g = TRUE</code> in which case the formulas
should reference variables <code>QaW</code> where <code>a</code> takes values in <code>a_0</code>.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_glm_qr">glm_Qr</code></td>
<td>
<p>A character describing a formula to be used in the call to
<code>glm</code> for reduced-dimension outcome regression. Ignored if
<code>SL_Qr!=NULL</code>. The formula should use the variable name <code>'gn'</code>.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_glm_gr">glm_gr</code></td>
<td>
<p>A character describing a formula to be used in the call to
<code>glm</code> for the reduced-dimension propensity score. Ignored if
<code>SL_gr!=NULL</code>. The formula should use the variable name <code>'Qn'</code> and
<code>'gn'</code> if <code>reduction='bivariate'</code> and <code>'Qn'</code> otherwise.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_adapt_g">adapt_g</code></td>
<td>
<p>A boolean indicating whether the propensity score should be
outcome adaptive. If <code>TRUE</code> then the propensity score is estimated as the
regression of <code>A</code> onto covariates <code>QaW</code> for <code>a</code> in each value
contained in <code>a_0</code>. See vignette for more details.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_guard">guard</code></td>
<td>
<p>A character vector indicating what pattern of misspecifications
to guard against. If <code>guard</code> contains <code>"Q"</code>, then the TMLE guards
against misspecification of the outcome regression by estimating the
reduced-dimension outcome regression specified by <code>glm_Qr</code> or
<code>SL_Qr</code>. If <code>guard</code> contains <code>"g"</code> then the TMLE
(additionally) guards against misspecification of the propensity score by
estimating the reduced-dimension propensity score specified by <code>glm_gr</code>
or <code>SL_gr</code>. If <code>guard</code> is set to <code>NULL</code>, then only standard TMLE
and one-step estimators are computed.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_reduction">reduction</code></td>
<td>
<p>A character equal to <code>"univariate"</code> for a univariate
misspecification correction (default) or <code>"bivariate"</code> for the
bivariate version.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_returnmodels">returnModels</code></td>
<td>
<p>A boolean indicating whether to return model fits for the
outcome regression, propensity score, and reduced-dimension regressions.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_returnnuisance">returnNuisance</code></td>
<td>
<p>A boolean indicating whether to return the estimated
nuisance regressions evaluated on the observed data. Defaults to <code>TRUE</code>.
If <code>n_SL</code> is large and <code>"drtmle"</code> is in <code>avg_over</code>, then
consider setting to <code>FALSE</code> in order to reduce size of resultant object.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_cvfolds">cvFolds</code></td>
<td>
<p>A numeric equal to the number of folds to be used in
cross-validated fitting of nuisance parameters. If <code>cvFolds = 1</code>, no
cross-validation is used. Alternatively, <code>cvFolds</code> may be entered as a
vector of fold assignments for observations, in which case its length should
be the same length as <code>Y</code>.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_maxiter">maxIter</code></td>
<td>
<p>A numeric that sets the maximum number of iterations the TMLE
can perform in its fluctuation step.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_tolic">tolIC</code></td>
<td>
<p>A numeric that defines the stopping criteria based on the
empirical mean of the influence function.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_tolg">tolg</code></td>
<td>
<p>A numeric indicating the minimum value for estimates of the
propensity score.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_verbose">verbose</code></td>
<td>
<p>A boolean indicating whether to print status updates.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_qsteps">Qsteps</code></td>
<td>
<p>A numeric equal to 1 or 2 indicating whether the fluctuation
submodel for the outcome regression should be fit using a single
minimization (<code>Qsteps = 1</code>) or a backfitting-type minimization
(<code>Qsteps=2</code>). The latter was found to be more stable in simulations and
is the default.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_qn">Qn</code></td>
<td>
<p>An optional list of outcome regression estimates. If specified, the
function will ignore the nuisance parameter estimation specified by
<code>SL_Q</code> and <code>glm_Q</code>. The entries in the list should correspond to
the outcome regression evaluated at <code>A</code> and the observed values of
<code>W</code>, with order determined by the input to <code>a_0</code> (e.g., if
<code>a_0 = c(0, 1)</code> then <code>Qn[[1]]</code> should be outcome regression at
<code>A</code> = 0 and <code>Qn[[2]]</code> should be outcome regression at
<code>A</code> = 1).</p>
</td></tr>
<tr><td><code id="drtmle_+3A_gn">gn</code></td>
<td>
<p>An optional list of propensity score estimates. If specified, the
function will ignore the nuisance parameter estimation specified by
<code>SL_g</code> and <code>glm_g</code>. The entries in the list should correspond to
the propensity for the observed values of <code>W</code>, with order determined by
the input to <code>a_0</code> (e.g., if <code>a_0 = c(0,1)</code> then <code>gn[[1]]</code>
should be propensity of <code>A</code> = 0 and <code>gn[[2]]</code> should be propensity
of <code>A</code> = 1).</p>
</td></tr>
<tr><td><code id="drtmle_+3A_use_future">use_future</code></td>
<td>
<p>Boolean indicating whether to use <code>future_lapply</code> or
instead to just use lapply. The latter can be easier to run down errors.</p>
</td></tr>
<tr><td><code id="drtmle_+3A_...">...</code></td>
<td>
<p>Other options (not currently used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"drtmle"</code>.
</p>

<dl>
<dt><code>drtmle</code></dt><dd><p>A <code>list</code> of doubly-robust point estimates and
a doubly-robust covariance matrix</p>
</dd>
<dt><code>nuisance_drtmle</code></dt><dd><p>A <code>list</code> of the final TMLE estimates of
the outcome regression (<code>$QnStar</code>), propensity score
(<code>$gnStar</code>), and reduced-dimension regressions (<code>$QrnStar</code>,
<code>$grnStar</code>) evaluated at the observed data values.</p>
</dd>
<dt><code>ic_drtmle</code></dt><dd><p>A <code>list</code> of the empirical mean of the efficient
influence function (<code>$eif</code>) and the extra pieces of the influence
function resulting from misspecification. All should be smaller than
<code>tolIC</code> (unless <code>maxIter</code> was reached first). Also includes
a matrix of the influence function values at the estimated nuisance
parameters evaluated at the observed data.</p>
</dd>
<dt><code>aiptw_c</code></dt><dd><p>A <code>list</code> of doubly-robust point estimates and
a non-doubly-robust covariance matrix. Theory does not guarantee
performance of inference for these estimators, but simulation studies
showed they often perform adequately.</p>
</dd>
<dt><code>nuisance_aiptw</code></dt><dd><p>A <code>list</code> of the initial estimates of the
outcome regression, propensity score, and reduced-dimension
regressions evaluated at the observed data values.</p>
</dd>
<dt><code>tmle</code></dt><dd><p>A <code>list</code> of doubly-robust point estimates and
non-doubly-robust covariance for the standard TMLE estimator.</p>
</dd>
<dt><code>aiptw</code></dt><dd><p>A <code>list</code> of doubly-robust point estimates and
non-doubly-robust covariance matrix for the standard AIPTW estimator.</p>
</dd>
<dt><code>gcomp</code></dt><dd><p>A <code>list</code> of non-doubly-robust point estimates and
non-doubly-robust covariance matrix for the standard G-computation
estimator. If super learner is used there is no guarantee of correct
inference for this estimator.</p>
</dd>
<dt><code>QnMod</code></dt><dd><p>The fitted object for the outcome regression. Returns
<code>NULL</code> if <code>returnModels = FALSE</code>.</p>
</dd>
<dt><code>gnMod</code></dt><dd><p>The fitted object for the propensity score. Returns
<code>NULL</code> if <code>returnModels = FALSE</code>.</p>
</dd>
<dt><code>QrnMod</code></dt><dd><p>The fitted object for the reduced-dimension regression
that guards against misspecification of the outcome regression.
Returns <code>NULL</code> if <code>returnModels = FALSE</code>.</p>
</dd>
<dt><code>grnMod</code></dt><dd><p>The fitted object for the reduced-dimension regression
that guards against misspecification of the propensity score. Returns
<code>NULL</code> if <code>returnModels = FALSE</code>.</p>
</dd>
<dt><code>a_0</code></dt><dd><p>The treatment levels that were requested for computation
of covariate-adjusted means.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># load super learner
library(SuperLearner)
# simulate data
set.seed(123456)
n &lt;- 100
W &lt;- data.frame(W1 = runif(n), W2 = rnorm(n))
A &lt;- rbinom(n, 1, plogis(W$W1 - W$W2))
Y &lt;- rbinom(n, 1, plogis(W$W1 * W$W2 * A))
# A quick example of drtmle:
# We note that more flexible super learner libraries
# are available, and that we recommend the user use more flexible
# libraries for SL_Qr and SL_gr for general use.
fit1 &lt;- drtmle(
  W = W, A = A, Y = Y, a_0 = c(1, 0),
  family = binomial(),
  stratify = FALSE,
  SL_Q = c("SL.glm", "SL.mean", "SL.glm.interaction"),
  SL_g = c("SL.glm", "SL.mean", "SL.glm.interaction"),
  SL_Qr = "SL.glm",
  SL_gr = "SL.glm", maxIter = 1
)
</code></pre>

<hr>
<h2 id='estimateG'>estimateG</h2><span id='topic+estimateG'></span>

<h3>Description</h3>

<p>Function to estimate propensity score
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateG(A, W, DeltaY, DeltaA, SL_g, glm_g, a_0, tolg, stratify = FALSE,
  validRows = NULL, verbose = FALSE, returnModels = FALSE, Qn = NULL,
  adapt_g = FALSE, se_cv = "none", se_cvFolds = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateG_+3A_a">A</code></td>
<td>
<p>A vector of binary treatment assignment (assumed to be equal to 0 or
1)</p>
</td></tr>
<tr><td><code id="estimateG_+3A_w">W</code></td>
<td>
<p>A <code>data.frame</code> of named covariates</p>
</td></tr>
<tr><td><code id="estimateG_+3A_deltay">DeltaY</code></td>
<td>
<p>Indicator of missing outcome (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="estimateG_+3A_deltaa">DeltaA</code></td>
<td>
<p>Indicator of missing treatment (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="estimateG_+3A_sl_g">SL_g</code></td>
<td>
<p>A vector of characters describing the super learner library to be
used for each of the regression (<code>DeltaA</code>, <code>A</code>, and
<code>DeltaY</code>). To use the same regression for each of the regressions (or
if there is no missing data in <code>A</code> nor <code>Y</code>), a single library may
be input.</p>
</td></tr>
<tr><td><code id="estimateG_+3A_glm_g">glm_g</code></td>
<td>
<p>A character describing a formula to be used in the call to
<code>glm</code> for the propensity score.</p>
</td></tr>
<tr><td><code id="estimateG_+3A_a_0">a_0</code></td>
<td>
<p>A vector of fixed treatment values at which to return marginal
mean estimates.</p>
</td></tr>
<tr><td><code id="estimateG_+3A_tolg">tolg</code></td>
<td>
<p>A numeric indicating the minimum value for estimates of the
propensity score.</p>
</td></tr>
<tr><td><code id="estimateG_+3A_stratify">stratify</code></td>
<td>
<p>A <code>boolean</code> indicating whether to estimate the missing
outcome regression separately for observations with <code>A</code> equal to 0/1
(if <code>TRUE</code>) or to pool across <code>A</code> (if <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="estimateG_+3A_validrows">validRows</code></td>
<td>
<p>A <code>list</code> of length <code>cvFolds</code> containing the row
indexes of observations to include in validation fold.</p>
</td></tr>
<tr><td><code id="estimateG_+3A_verbose">verbose</code></td>
<td>
<p>A boolean indicating whether to print status updates.</p>
</td></tr>
<tr><td><code id="estimateG_+3A_returnmodels">returnModels</code></td>
<td>
<p>A boolean indicating whether to return model fits for the
outcome regression, propensity score, and reduced-dimension regressions.</p>
</td></tr>
<tr><td><code id="estimateG_+3A_qn">Qn</code></td>
<td>
<p>A <code>list</code> of estimates of the outcome regression for each value
in <code>a_0</code>. Only needed if <code>adapt_g = TRUE</code>.</p>
</td></tr>
<tr><td><code id="estimateG_+3A_adapt_g">adapt_g</code></td>
<td>
<p>A boolean indicating whether propensity score is adaptive
to outcome regression.</p>
</td></tr>
<tr><td><code id="estimateG_+3A_se_cv">se_cv</code></td>
<td>
<p>Should cross-validated nuisance parameter estimates be used
for computing standard errors?
Options are <code>"none"</code> = no cross-validation is performed; <code>"partial"</code> =
only applicable if Super Learner is used for nuisance parameter estimates;
<code>"full"</code> = full cross-validation is performed. See vignette for further
details. Ignored if <code>cvFolds &gt; 1</code>, since then
cross-validated nuisance parameter estimates are used by default and it is
assumed that you want full cross-validated standard errors.</p>
</td></tr>
<tr><td><code id="estimateG_+3A_se_cvfolds">se_cvFolds</code></td>
<td>
<p>If cross-validated nuisance parameter estimates are used
to compute standard errors, how many folds should be used in this computation.
If <code>se_cv = "partial"</code>, then this option sets the number of folds used
by the <code>SuperLearner</code> fitting procedure.</p>
</td></tr>
</table>

<hr>
<h2 id='estimateG_loop'>estimateG_loop</h2><span id='topic+estimateG_loop'></span>

<h3>Description</h3>

<p>Helper function to clean up internals of <code>drtmle</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateG_loop(validRows, A, W, DeltaA, DeltaY, tolg, verbose, stratify,
  returnModels, SL_g, glm_g, a_0, Qn, adapt_g, use_future, se_cv = "none",
  se_cvFolds = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateG_loop_+3A_validrows">validRows</code></td>
<td>
<p>A <code>list</code> of length <code>cvFolds</code> containing the row
indexes of observations to include in validation fold.</p>
</td></tr>
<tr><td><code id="estimateG_loop_+3A_a">A</code></td>
<td>
<p>A vector of binary treatment assignment (assumed to be equal to 0 or
1)</p>
</td></tr>
<tr><td><code id="estimateG_loop_+3A_w">W</code></td>
<td>
<p>A <code>data.frame</code> of named covariates</p>
</td></tr>
<tr><td><code id="estimateG_loop_+3A_deltaa">DeltaA</code></td>
<td>
<p>Indicator of missing treatment (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="estimateG_loop_+3A_deltay">DeltaY</code></td>
<td>
<p>Indicator of missing outcome (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="estimateG_loop_+3A_tolg">tolg</code></td>
<td>
<p>A numeric indicating the minimum value for estimates of the
propensity score.</p>
</td></tr>
<tr><td><code id="estimateG_loop_+3A_verbose">verbose</code></td>
<td>
<p>A boolean indicating whether to print status updates.</p>
</td></tr>
<tr><td><code id="estimateG_loop_+3A_stratify">stratify</code></td>
<td>
<p>A <code>boolean</code> indicating whether to estimate the missing
outcome regression separately for observations with <code>A</code> equal to 0/1
(if <code>TRUE</code>) or to pool across <code>A</code> (if <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="estimateG_loop_+3A_returnmodels">returnModels</code></td>
<td>
<p>A boolean indicating whether to return model fits for the
outcome regression, propensity score, and reduced-dimension regressions.</p>
</td></tr>
<tr><td><code id="estimateG_loop_+3A_sl_g">SL_g</code></td>
<td>
<p>A vector of characters describing the super learner library to be
used for each of the regression (<code>DeltaA</code>, <code>A</code>, and
<code>DeltaY</code>). To use the same regression for each of the regressions (or
if there is no missing data in <code>A</code> nor <code>Y</code>), a single library may
be input.</p>
</td></tr>
<tr><td><code id="estimateG_loop_+3A_glm_g">glm_g</code></td>
<td>
<p>A character describing a formula to be used in the call to
<code>glm</code> for the propensity score.</p>
</td></tr>
<tr><td><code id="estimateG_loop_+3A_a_0">a_0</code></td>
<td>
<p>A vector of fixed treatment values at which to return marginal
mean estimates.</p>
</td></tr>
<tr><td><code id="estimateG_loop_+3A_qn">Qn</code></td>
<td>
<p>A <code>list</code> of estimates of the outcome regression for each value
in <code>a_0</code>. Only needed if <code>adapt_g = TRUE</code>.</p>
</td></tr>
<tr><td><code id="estimateG_loop_+3A_adapt_g">adapt_g</code></td>
<td>
<p>A boolean indicating whether propensity score is adaptive
to outcome regression.</p>
</td></tr>
<tr><td><code id="estimateG_loop_+3A_use_future">use_future</code></td>
<td>
<p>Should <code>future</code> be used for parallelization?</p>
</td></tr>
<tr><td><code id="estimateG_loop_+3A_se_cv">se_cv</code></td>
<td>
<p>Should cross-validated nuisance parameter estimates be used
for computing standard errors?
Options are <code>"none"</code> = no cross-validation is performed; <code>"partial"</code> =
only applicable if Super Learner is used for nuisance parameter estimates;
<code>"full"</code> = full cross-validation is performed. See vignette for further
details. Ignored if <code>cvFolds &gt; 1</code>, since then
cross-validated nuisance parameter estimates are used by default and it is
assumed that you want full cross-validated standard errors.</p>
</td></tr>
<tr><td><code id="estimateG_loop_+3A_se_cvfolds">se_cvFolds</code></td>
<td>
<p>If cross-validated nuisance parameter estimates are used
to compute standard errors, how many folds should be used in this computation.
If <code>se_cv = "partial"</code>, then this option sets the number of folds used
by the <code>SuperLearner</code> fitting procedure.</p>
</td></tr>
</table>

<hr>
<h2 id='estimategrn'>estimategrn</h2><span id='topic+estimategrn'></span>

<h3>Description</h3>

<p>Estimates the reduced dimension regressions necessary for the additional
fluctuations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimategrn(Y, A, W, DeltaA, DeltaY, Qn, gn, SL_gr, tolg, glm_gr, a_0,
  reduction, returnModels, validRows)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimategrn_+3A_y">Y</code></td>
<td>
<p>A vector of continuous or binary outcomes.</p>
</td></tr>
<tr><td><code id="estimategrn_+3A_a">A</code></td>
<td>
<p>A vector of binary treatment assignment (assumed to be equal to 0 or
1).</p>
</td></tr>
<tr><td><code id="estimategrn_+3A_w">W</code></td>
<td>
<p>A <code>data.frame</code> of named covariates.</p>
</td></tr>
<tr><td><code id="estimategrn_+3A_deltaa">DeltaA</code></td>
<td>
<p>Indicator of missing treatment (assumed to be equal to 0 if
missing 1 if observed).</p>
</td></tr>
<tr><td><code id="estimategrn_+3A_deltay">DeltaY</code></td>
<td>
<p>Indicator of missing outcome (assumed to be equal to 0 if
missing 1 if observed).</p>
</td></tr>
<tr><td><code id="estimategrn_+3A_qn">Qn</code></td>
<td>
<p>A list of outcome regression estimates evaluated on observed data.</p>
</td></tr>
<tr><td><code id="estimategrn_+3A_gn">gn</code></td>
<td>
<p>A list of propensity regression estimates evaluated on observed
data.</p>
</td></tr>
<tr><td><code id="estimategrn_+3A_sl_gr">SL_gr</code></td>
<td>
<p>A vector of characters or a list describing the Super Learner
library to be used for the reduced-dimension propensity score.</p>
</td></tr>
<tr><td><code id="estimategrn_+3A_tolg">tolg</code></td>
<td>
<p>A numeric indicating the minimum value for estimates of the
propensity score.</p>
</td></tr>
<tr><td><code id="estimategrn_+3A_glm_gr">glm_gr</code></td>
<td>
<p>A character describing a formula to be used in the call to
<code>glm</code> for the second reduced-dimension regression. Ignored if
<code>SL_gr!=NULL</code>.</p>
</td></tr>
<tr><td><code id="estimategrn_+3A_a_0">a_0</code></td>
<td>
<p>A list of fixed treatment values .</p>
</td></tr>
<tr><td><code id="estimategrn_+3A_reduction">reduction</code></td>
<td>
<p>A character equal to <code>'univariate'</code> for a univariate
misspecification correction or <code>'bivariate'</code> for the bivariate version.</p>
</td></tr>
<tr><td><code id="estimategrn_+3A_returnmodels">returnModels</code></td>
<td>
<p>A boolean indicating whether to return model fits for the
outcome regression, propensity score, and reduced-dimension regressions.</p>
</td></tr>
<tr><td><code id="estimategrn_+3A_validrows">validRows</code></td>
<td>
<p>A <code>list</code> of length <code>cvFolds</code> containing the row
indexes of observations to include in validation fold.</p>
</td></tr>
</table>

<hr>
<h2 id='estimategrn_loop'>estimategrn_loop</h2><span id='topic+estimategrn_loop'></span>

<h3>Description</h3>

<p>Helper function to clean up the internal code of <code>drtmle</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimategrn_loop(validRows, Y, A, W, DeltaA, DeltaY, tolg, Qn, gn, glm_gr,
  SL_gr, a_0, reduction, returnModels, use_future)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimategrn_loop_+3A_validrows">validRows</code></td>
<td>
<p>A <code>list</code> of length <code>cvFolds</code> containing the row
indexes of observations to include in validation fold.</p>
</td></tr>
<tr><td><code id="estimategrn_loop_+3A_y">Y</code></td>
<td>
<p>A vector of continuous or binary outcomes.</p>
</td></tr>
<tr><td><code id="estimategrn_loop_+3A_a">A</code></td>
<td>
<p>A vector of binary treatment assignment (assumed to be equal to 0 or
1).</p>
</td></tr>
<tr><td><code id="estimategrn_loop_+3A_w">W</code></td>
<td>
<p>A <code>data.frame</code> of named covariates.</p>
</td></tr>
<tr><td><code id="estimategrn_loop_+3A_deltaa">DeltaA</code></td>
<td>
<p>Indicator of missing treatment (assumed to be equal to 0 if
missing 1 if observed).</p>
</td></tr>
<tr><td><code id="estimategrn_loop_+3A_deltay">DeltaY</code></td>
<td>
<p>Indicator of missing outcome (assumed to be equal to 0 if
missing 1 if observed).</p>
</td></tr>
<tr><td><code id="estimategrn_loop_+3A_tolg">tolg</code></td>
<td>
<p>A numeric indicating the minimum value for estimates of the
propensity score.</p>
</td></tr>
<tr><td><code id="estimategrn_loop_+3A_qn">Qn</code></td>
<td>
<p>A list of outcome regression estimates evaluated on observed data.</p>
</td></tr>
<tr><td><code id="estimategrn_loop_+3A_gn">gn</code></td>
<td>
<p>A list of propensity regression estimates evaluated on observed
data.</p>
</td></tr>
<tr><td><code id="estimategrn_loop_+3A_glm_gr">glm_gr</code></td>
<td>
<p>A character describing a formula to be used in the call to
<code>glm</code> for the second reduced-dimension regression. Ignored if
<code>SL_gr!=NULL</code>.</p>
</td></tr>
<tr><td><code id="estimategrn_loop_+3A_sl_gr">SL_gr</code></td>
<td>
<p>A vector of characters or a list describing the Super Learner
library to be used for the reduced-dimension propensity score.</p>
</td></tr>
<tr><td><code id="estimategrn_loop_+3A_a_0">a_0</code></td>
<td>
<p>A list of fixed treatment values .</p>
</td></tr>
<tr><td><code id="estimategrn_loop_+3A_reduction">reduction</code></td>
<td>
<p>A character equal to <code>'univariate'</code> for a univariate
misspecification correction or <code>'bivariate'</code> for the bivariate version.</p>
</td></tr>
<tr><td><code id="estimategrn_loop_+3A_returnmodels">returnModels</code></td>
<td>
<p>A boolean indicating whether to return model fits for the
outcome regression, propensity score, and reduced-dimension regressions.</p>
</td></tr>
<tr><td><code id="estimategrn_loop_+3A_use_future">use_future</code></td>
<td>
<p>Should <code>future</code> be used to parallelize?</p>
</td></tr>
</table>

<hr>
<h2 id='estimateQ'>estimateQ</h2><span id='topic+estimateQ'></span>

<h3>Description</h3>

<p>Function to estimate initial outcome regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateQ(Y, A, W, DeltaA, DeltaY, SL_Q, glm_Q, a_0, stratify, family,
  verbose = FALSE, returnModels = FALSE, se_cv = "none",
  se_cvFolds = 10, validRows = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateQ_+3A_y">Y</code></td>
<td>
<p>A vector of continuous or binary outcomes.</p>
</td></tr>
<tr><td><code id="estimateQ_+3A_a">A</code></td>
<td>
<p>A vector of binary treatment assignment (assumed to be equal to 0 or
1).</p>
</td></tr>
<tr><td><code id="estimateQ_+3A_w">W</code></td>
<td>
<p>A <code>data.frame</code> of named covariates.</p>
</td></tr>
<tr><td><code id="estimateQ_+3A_deltaa">DeltaA</code></td>
<td>
<p>Indicator of missing treatment (assumed to be equal to 0 if
missing 1 if observed).</p>
</td></tr>
<tr><td><code id="estimateQ_+3A_deltay">DeltaY</code></td>
<td>
<p>Indicator of missing outcome (assumed to be equal to 0 if
missing 1 if observed).</p>
</td></tr>
<tr><td><code id="estimateQ_+3A_sl_q">SL_Q</code></td>
<td>
<p>A vector of characters or a list describing the Super Learner
library to be used for the outcome regression.</p>
</td></tr>
<tr><td><code id="estimateQ_+3A_glm_q">glm_Q</code></td>
<td>
<p>A character describing a formula to be used in the call to
<code>glm</code> for the outcome regression.</p>
</td></tr>
<tr><td><code id="estimateQ_+3A_a_0">a_0</code></td>
<td>
<p>A list of fixed treatment values</p>
</td></tr>
<tr><td><code id="estimateQ_+3A_stratify">stratify</code></td>
<td>
<p>A <code>boolean</code> indicating whether to estimate the outcome
regression separately for observations with <code>A</code> equal to 0/1 (if
<code>TRUE</code>) or to pool across <code>A</code> (if <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="estimateQ_+3A_family">family</code></td>
<td>
<p>A character passed to <code>SuperLearner</code></p>
</td></tr>
<tr><td><code id="estimateQ_+3A_verbose">verbose</code></td>
<td>
<p>A boolean indicating whether to print status updates.</p>
</td></tr>
<tr><td><code id="estimateQ_+3A_returnmodels">returnModels</code></td>
<td>
<p>A boolean indicating whether to return model fits for the
outcome regression, propensity score, and reduced-dimension regressions.</p>
</td></tr>
<tr><td><code id="estimateQ_+3A_se_cv">se_cv</code></td>
<td>
<p>Should cross-validated nuisance parameter estimates be used
for computing standard errors?
Options are <code>"none"</code> = no cross-validation is performed; <code>"partial"</code> =
only applicable if Super Learner is used for nuisance parameter estimates;
<code>"full"</code> = full cross-validation is performed. See vignette for further
details. Ignored if <code>cvFolds &gt; 1</code>, since then
cross-validated nuisance parameter estimates are used by default and it is
assumed that you want full cross-validated standard errors.</p>
</td></tr>
<tr><td><code id="estimateQ_+3A_se_cvfolds">se_cvFolds</code></td>
<td>
<p>If cross-validated nuisance parameter estimates are used
to compute standard errors, how many folds should be used in this computation.
If <code>se_cv = "partial"</code>, then this option sets the number of folds used
by the <code>SuperLearner</code> fitting procedure.</p>
</td></tr>
<tr><td><code id="estimateQ_+3A_validrows">validRows</code></td>
<td>
<p>A <code>list</code> of length <code>cvFolds</code> containing the row
indexes of observations to include in validation fold.</p>
</td></tr>
<tr><td><code id="estimateQ_+3A_...">...</code></td>
<td>
<p>Additional arguments (not currently used)</p>
</td></tr>
</table>

<hr>
<h2 id='estimateQ_loop'>estimateQ_loop</h2><span id='topic+estimateQ_loop'></span>

<h3>Description</h3>

<p>A helper loop function to clean up the internals of <code>drtmle</code>
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateQ_loop(validRows, Y, A, W, DeltaA, DeltaY, verbose, returnModels, SL_Q,
  a_0, stratify, glm_Q, family, use_future, se_cv, se_cvFolds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateQ_loop_+3A_validrows">validRows</code></td>
<td>
<p>A <code>list</code> of length <code>cvFolds</code> containing the row
indexes of observations to include in validation fold.</p>
</td></tr>
<tr><td><code id="estimateQ_loop_+3A_y">Y</code></td>
<td>
<p>A vector of continuous or binary outcomes.</p>
</td></tr>
<tr><td><code id="estimateQ_loop_+3A_a">A</code></td>
<td>
<p>A vector of binary treatment assignment (assumed to be equal to 0 or
1)</p>
</td></tr>
<tr><td><code id="estimateQ_loop_+3A_w">W</code></td>
<td>
<p>A <code>data.frame</code> of named covariates</p>
</td></tr>
<tr><td><code id="estimateQ_loop_+3A_deltaa">DeltaA</code></td>
<td>
<p>Indicator of missing treatment (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="estimateQ_loop_+3A_deltay">DeltaY</code></td>
<td>
<p>Indicator of missing outcome (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="estimateQ_loop_+3A_verbose">verbose</code></td>
<td>
<p>A boolean indicating whether to print status updates.</p>
</td></tr>
<tr><td><code id="estimateQ_loop_+3A_returnmodels">returnModels</code></td>
<td>
<p>A boolean indicating whether to return model fits for the
outcome regression, propensity score, and reduced-dimension regressions.</p>
</td></tr>
<tr><td><code id="estimateQ_loop_+3A_sl_q">SL_Q</code></td>
<td>
<p>A vector of characters or a list describing the Super Learner
library to be used for the outcome regression. See
<code><a href="SuperLearner.html#topic+SuperLearner">SuperLearner</a></code> for details.</p>
</td></tr>
<tr><td><code id="estimateQ_loop_+3A_a_0">a_0</code></td>
<td>
<p>A list of fixed treatment values.</p>
</td></tr>
<tr><td><code id="estimateQ_loop_+3A_stratify">stratify</code></td>
<td>
<p>A <code>boolean</code> indicating whether to estimate the outcome
regression separately for different values of <code>A</code> (if <code>TRUE</code>) or
to pool across <code>A</code> (if <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="estimateQ_loop_+3A_glm_q">glm_Q</code></td>
<td>
<p>A character describing a formula to be used in the call to
<code>glm</code> for the outcome regression. Ignored if <code>SL_Q!=NULL</code>.</p>
</td></tr>
<tr><td><code id="estimateQ_loop_+3A_family">family</code></td>
<td>
<p>Should be gaussian() unless called from adaptive_iptw with
binary <code>Y</code>.</p>
</td></tr>
<tr><td><code id="estimateQ_loop_+3A_use_future">use_future</code></td>
<td>
<p>Boolean indicating whether to use <code>future_lapply</code> or
instead to just use lapply. The latter can be easier to run down errors.</p>
</td></tr>
<tr><td><code id="estimateQ_loop_+3A_se_cv">se_cv</code></td>
<td>
<p>Should cross-validated nuisance parameter estimates be used
for computing standard errors?
Options are <code>"none"</code> = no cross-validation is performed; <code>"partial"</code> =
only applicable if Super Learner is used for nuisance parameter estimates;
<code>"full"</code> = full cross-validation is performed. See vignette for further
details. Ignored if <code>cvFolds &gt; 1</code>, since then
cross-validated nuisance parameter estimates are used by default and it is
assumed that you want full cross-validated standard errors.</p>
</td></tr>
<tr><td><code id="estimateQ_loop_+3A_se_cvfolds">se_cvFolds</code></td>
<td>
<p>If cross-validated nuisance parameter estimates are used
to compute standard errors, how many folds should be used in this computation.
If <code>se_cv = "partial"</code>, then this option sets the number of folds used
by the <code>SuperLearner</code> fitting procedure.</p>
</td></tr>
</table>

<hr>
<h2 id='estimateQrn'>estimateQrn</h2><span id='topic+estimateQrn'></span>

<h3>Description</h3>

<p>Estimates the reduced dimension regressions necessary for the
fluctuations of g
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateQrn(Y, A, W, DeltaA, DeltaY, Qn, gn, glm_Qr, SL_Qr,
  family = stats::gaussian(), a_0, returnModels, validRows = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateQrn_+3A_y">Y</code></td>
<td>
<p>A vector of continuous or binary outcomes.</p>
</td></tr>
<tr><td><code id="estimateQrn_+3A_a">A</code></td>
<td>
<p>A vector of binary treatment assignment (assumed to be equal to 0 or
1)</p>
</td></tr>
<tr><td><code id="estimateQrn_+3A_w">W</code></td>
<td>
<p>A <code>data.frame</code> of named covariates</p>
</td></tr>
<tr><td><code id="estimateQrn_+3A_deltaa">DeltaA</code></td>
<td>
<p>Indicator of missing treatment (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="estimateQrn_+3A_deltay">DeltaY</code></td>
<td>
<p>Indicator of missing outcome (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="estimateQrn_+3A_qn">Qn</code></td>
<td>
<p>A list of outcome regression estimates evaluated on observed data.
If NULL then 0 is used for all Qn (as is needed to estimate reduced
dimension regression for adaptive_iptw)</p>
</td></tr>
<tr><td><code id="estimateQrn_+3A_gn">gn</code></td>
<td>
<p>A list of propensity regression estimates evaluated on observed
data</p>
</td></tr>
<tr><td><code id="estimateQrn_+3A_glm_qr">glm_Qr</code></td>
<td>
<p>A character describing a formula to be used in the call to
<code>glm</code> for the first reduced-dimension regression. Ignored if
<code>SL_gr!=NULL</code>.</p>
</td></tr>
<tr><td><code id="estimateQrn_+3A_sl_qr">SL_Qr</code></td>
<td>
<p>A vector of characters or a list describing the Super Learner
library to be used for the first reduced-dimension regression.</p>
</td></tr>
<tr><td><code id="estimateQrn_+3A_family">family</code></td>
<td>
<p>Should be gaussian() unless called from adaptive_iptw with
binary <code>Y</code>.</p>
</td></tr>
<tr><td><code id="estimateQrn_+3A_a_0">a_0</code></td>
<td>
<p>A list of fixed treatment values.</p>
</td></tr>
<tr><td><code id="estimateQrn_+3A_returnmodels">returnModels</code></td>
<td>
<p>A boolean indicating whether to return model fits for the
outcome regression, propensity score, and reduced-dimension regressions.</p>
</td></tr>
<tr><td><code id="estimateQrn_+3A_validrows">validRows</code></td>
<td>
<p>A <code>list</code> of length <code>cvFolds</code> containing the row
indexes of observations to include in validation fold.</p>
</td></tr>
</table>

<hr>
<h2 id='estimateQrn_loop'>estimateQrn_loop</h2><span id='topic+estimateQrn_loop'></span>

<h3>Description</h3>

<p>Helper function to clean up internal code of <code>drtmle</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateQrn_loop(validRows, Y, A, W, DeltaA, DeltaY, Qn, gn, SL_Qr, glm_Qr,
  family, a_0, returnModels, use_future)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateQrn_loop_+3A_validrows">validRows</code></td>
<td>
<p>A <code>list</code> of length <code>cvFolds</code> containing the row
indexes of observations to include in validation fold.</p>
</td></tr>
<tr><td><code id="estimateQrn_loop_+3A_y">Y</code></td>
<td>
<p>A vector of continuous or binary outcomes.</p>
</td></tr>
<tr><td><code id="estimateQrn_loop_+3A_a">A</code></td>
<td>
<p>A vector of binary treatment assignment (assumed to be equal to 0 or
1)</p>
</td></tr>
<tr><td><code id="estimateQrn_loop_+3A_w">W</code></td>
<td>
<p>A <code>data.frame</code> of named covariates</p>
</td></tr>
<tr><td><code id="estimateQrn_loop_+3A_deltaa">DeltaA</code></td>
<td>
<p>Indicator of missing treatment (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="estimateQrn_loop_+3A_deltay">DeltaY</code></td>
<td>
<p>Indicator of missing outcome (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="estimateQrn_loop_+3A_qn">Qn</code></td>
<td>
<p>A list of outcome regression estimates evaluated on observed data.
If NULL then 0 is used for all Qn (as is needed to estimate reduced
dimension regression for adaptive_iptw)</p>
</td></tr>
<tr><td><code id="estimateQrn_loop_+3A_gn">gn</code></td>
<td>
<p>A list of propensity regression estimates evaluated on observed
data</p>
</td></tr>
<tr><td><code id="estimateQrn_loop_+3A_sl_qr">SL_Qr</code></td>
<td>
<p>A vector of characters or a list describing the Super Learner
library to be used for the first reduced-dimension regression.</p>
</td></tr>
<tr><td><code id="estimateQrn_loop_+3A_glm_qr">glm_Qr</code></td>
<td>
<p>A character describing a formula to be used in the call to
<code>glm</code> for the first reduced-dimension regression. Ignored if
<code>SL_gr!=NULL</code>.</p>
</td></tr>
<tr><td><code id="estimateQrn_loop_+3A_family">family</code></td>
<td>
<p>Should be gaussian() unless called from adaptive_iptw with
binary <code>Y</code>.</p>
</td></tr>
<tr><td><code id="estimateQrn_loop_+3A_a_0">a_0</code></td>
<td>
<p>A list of fixed treatment values.</p>
</td></tr>
<tr><td><code id="estimateQrn_loop_+3A_returnmodels">returnModels</code></td>
<td>
<p>A boolean indicating whether to return model fits for the
outcome regression, propensity score, and reduced-dimension regressions.</p>
</td></tr>
<tr><td><code id="estimateQrn_loop_+3A_use_future">use_future</code></td>
<td>
<p>Should <code>future</code> be used in the fitting process.</p>
</td></tr>
</table>

<hr>
<h2 id='eval_Diptw'>Evaluate usual influence function of IPTW</h2><span id='topic+eval_Diptw'></span>

<h3>Description</h3>

<p>Evaluate usual influence function of IPTW
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_Diptw(A, Y, DeltaA, DeltaY, gn, psi_n, a_0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_Diptw_+3A_a">A</code></td>
<td>
<p>A vector of binary treatment assignment (assumed to be equal to 0 or
1)</p>
</td></tr>
<tr><td><code id="eval_Diptw_+3A_y">Y</code></td>
<td>
<p>A numeric of continuous or binary outcomes.</p>
</td></tr>
<tr><td><code id="eval_Diptw_+3A_deltaa">DeltaA</code></td>
<td>
<p>Indicator of missing treatment (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="eval_Diptw_+3A_deltay">DeltaY</code></td>
<td>
<p>Indicator of missing outcome (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="eval_Diptw_+3A_gn">gn</code></td>
<td>
<p>List of estimated propensity scores evaluated at observations</p>
</td></tr>
<tr><td><code id="eval_Diptw_+3A_psi_n">psi_n</code></td>
<td>
<p>List of estimated ATEs</p>
</td></tr>
<tr><td><code id="eval_Diptw_+3A_a_0">a_0</code></td>
<td>
<p>Vector of values to return marginal mean</p>
</td></tr>
</table>

<hr>
<h2 id='eval_Diptw_g'>Evaluate extra piece of the influence function for the IPTW</h2><span id='topic+eval_Diptw_g'></span>

<h3>Description</h3>

<p>Evaluate extra piece of the influence function for the IPTW
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_Diptw_g(A, DeltaA, DeltaY, Qrn, gn, a_0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_Diptw_g_+3A_a">A</code></td>
<td>
<p>A vector of binary treatment assignment (assumed to be equal to 0 or
1)</p>
</td></tr>
<tr><td><code id="eval_Diptw_g_+3A_deltaa">DeltaA</code></td>
<td>
<p>Indicator of missing treatment (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="eval_Diptw_g_+3A_deltay">DeltaY</code></td>
<td>
<p>Indicator of missing outcome (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="eval_Diptw_g_+3A_qrn">Qrn</code></td>
<td>
<p>List of estimated reduced-dimension outcome regression evaluated
at observations</p>
</td></tr>
<tr><td><code id="eval_Diptw_g_+3A_gn">gn</code></td>
<td>
<p>List of estimated propensity scores evaluated at observations</p>
</td></tr>
<tr><td><code id="eval_Diptw_g_+3A_a_0">a_0</code></td>
<td>
<p>Vector of values to return marginal mean</p>
</td></tr>
</table>

<hr>
<h2 id='eval_Dstar'>Evaluate usual efficient influence function</h2><span id='topic+eval_Dstar'></span>

<h3>Description</h3>

<p>Evaluate usual efficient influence function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_Dstar(A, Y, DeltaY, DeltaA, Qn, gn, psi_n, a_0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_Dstar_+3A_a">A</code></td>
<td>
<p>A vector of binary treatment assignment (assumed to be equal to 0 or
1)</p>
</td></tr>
<tr><td><code id="eval_Dstar_+3A_y">Y</code></td>
<td>
<p>A numeric of continuous or binary outcomes.</p>
</td></tr>
<tr><td><code id="eval_Dstar_+3A_deltay">DeltaY</code></td>
<td>
<p>Indicator of missing outcome (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="eval_Dstar_+3A_deltaa">DeltaA</code></td>
<td>
<p>Indicator of missing treatment (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="eval_Dstar_+3A_qn">Qn</code></td>
<td>
<p>List of estimated outcome regression evaluated at observations</p>
</td></tr>
<tr><td><code id="eval_Dstar_+3A_gn">gn</code></td>
<td>
<p>List of estimated propensity scores evaluated at observations</p>
</td></tr>
<tr><td><code id="eval_Dstar_+3A_psi_n">psi_n</code></td>
<td>
<p>List of estimated ATEs</p>
</td></tr>
<tr><td><code id="eval_Dstar_+3A_a_0">a_0</code></td>
<td>
<p>Vector of values to return marginal mean</p>
</td></tr>
</table>

<hr>
<h2 id='eval_Dstar_g'>Evaluate extra piece of efficient influence function resulting from
misspecification of outcome regression</h2><span id='topic+eval_Dstar_g'></span>

<h3>Description</h3>

<p>Evaluate extra piece of efficient influence function resulting from
misspecification of outcome regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_Dstar_g(A, DeltaY, DeltaA, Qrn, gn, a_0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_Dstar_g_+3A_a">A</code></td>
<td>
<p>A vector of binary treatment assignment (assumed to be equal to 0 or
1)</p>
</td></tr>
<tr><td><code id="eval_Dstar_g_+3A_deltay">DeltaY</code></td>
<td>
<p>Indicator of missing outcome (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="eval_Dstar_g_+3A_deltaa">DeltaA</code></td>
<td>
<p>Indicator of missing treatment (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="eval_Dstar_g_+3A_qrn">Qrn</code></td>
<td>
<p>List of estimated reduced-dimension outcome regression evaluated
at observations</p>
</td></tr>
<tr><td><code id="eval_Dstar_g_+3A_gn">gn</code></td>
<td>
<p>List of estimated propensity scores evaluated at observations</p>
</td></tr>
<tr><td><code id="eval_Dstar_g_+3A_a_0">a_0</code></td>
<td>
<p>Vector of values to return marginal mean</p>
</td></tr>
</table>

<hr>
<h2 id='eval_Dstar_Q'>Evaluate extra piece of efficient influence function resulting from
misspecification of propensity score</h2><span id='topic+eval_Dstar_Q'></span>

<h3>Description</h3>

<p>Evaluate extra piece of efficient influence function resulting from
misspecification of propensity score
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_Dstar_Q(A, Y, DeltaY, DeltaA, Qn, gn, grn, a_0, reduction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_Dstar_Q_+3A_a">A</code></td>
<td>
<p>A vector of binary treatment assignment (assumed to be equal to 0 or
1)</p>
</td></tr>
<tr><td><code id="eval_Dstar_Q_+3A_y">Y</code></td>
<td>
<p>A numeric of continuous or binary outcomes.</p>
</td></tr>
<tr><td><code id="eval_Dstar_Q_+3A_deltay">DeltaY</code></td>
<td>
<p>Indicator of missing outcome (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="eval_Dstar_Q_+3A_deltaa">DeltaA</code></td>
<td>
<p>Indicator of missing treatment (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="eval_Dstar_Q_+3A_qn">Qn</code></td>
<td>
<p>List of estimated outcome regression evaluated at observations</p>
</td></tr>
<tr><td><code id="eval_Dstar_Q_+3A_gn">gn</code></td>
<td>
<p>List of estimated propensity scores evaluated at observations</p>
</td></tr>
<tr><td><code id="eval_Dstar_Q_+3A_grn">grn</code></td>
<td>
<p>List of estimated reduced-dimension propensity scores evaluated at
observations</p>
</td></tr>
<tr><td><code id="eval_Dstar_Q_+3A_a_0">a_0</code></td>
<td>
<p>Vector of values to return marginal mean</p>
</td></tr>
<tr><td><code id="eval_Dstar_Q_+3A_reduction">reduction</code></td>
<td>
<p>A character equal to <code>"univariate"</code> for a univariate
misspecification correction or <code>"bivariate"</code> for the bivariate version.</p>
</td></tr>
</table>

<hr>
<h2 id='extract_models'>Help function to extract models from fitted object</h2><span id='topic+extract_models'></span>

<h3>Description</h3>

<p>Help function to extract models from fitted object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_models(a_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_models_+3A_a_list">a_list</code></td>
<td>
<p>Structured list of nuisance parameters</p>
</td></tr>
</table>

<hr>
<h2 id='fluctuateG'>fluctuateG</h2><span id='topic+fluctuateG'></span>

<h3>Description</h3>

<p>Function called internally by drtmle to perform the fluctuation
of the initial estimator of g (i.e., solves the new estimating eqn that
results from misspecification of Q)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fluctuateG(Y, A, W, DeltaY, DeltaA, a_0, gn, Qrn, tolg, coefTol = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fluctuateG_+3A_y">Y</code></td>
<td>
<p>The outcome</p>
</td></tr>
<tr><td><code id="fluctuateG_+3A_a">A</code></td>
<td>
<p>The treatment</p>
</td></tr>
<tr><td><code id="fluctuateG_+3A_w">W</code></td>
<td>
<p>The covariates</p>
</td></tr>
<tr><td><code id="fluctuateG_+3A_deltay">DeltaY</code></td>
<td>
<p>Indicator of missing outcome (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="fluctuateG_+3A_deltaa">DeltaA</code></td>
<td>
<p>Indicator of missing treatment (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="fluctuateG_+3A_a_0">a_0</code></td>
<td>
<p>A list of fixed treatment values</p>
</td></tr>
<tr><td><code id="fluctuateG_+3A_gn">gn</code></td>
<td>
<p>A list of propensity regression estimates evaluated on observed
data</p>
</td></tr>
<tr><td><code id="fluctuateG_+3A_qrn">Qrn</code></td>
<td>
<p>A list of reduced-dimension regression estimates evaluated on
observed data</p>
</td></tr>
<tr><td><code id="fluctuateG_+3A_tolg">tolg</code></td>
<td>
<p>The lower bound on propensity score estimates</p>
</td></tr>
<tr><td><code id="fluctuateG_+3A_coeftol">coefTol</code></td>
<td>
<p>A tolerance level on the magnitude of the coefficient that
flags the result as potentially the result of numeric instability.</p>
</td></tr>
</table>

<hr>
<h2 id='fluctuateQ'>fluctuateQ</h2><span id='topic+fluctuateQ'></span>

<h3>Description</h3>

<p>Function called internally by drtmle to perform simultaneous fluctuation
of the initial estimator of Q (i.e., solves both EIF estimating eqn and
the new estimating eqn that results from misspecification of g)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fluctuateQ(Y, A, W, DeltaY, DeltaA, Qn, gn, grn, a_0, reduction,
  coefTol = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fluctuateQ_+3A_y">Y</code></td>
<td>
<p>The outcome</p>
</td></tr>
<tr><td><code id="fluctuateQ_+3A_a">A</code></td>
<td>
<p>The treatment</p>
</td></tr>
<tr><td><code id="fluctuateQ_+3A_w">W</code></td>
<td>
<p>The covariates</p>
</td></tr>
<tr><td><code id="fluctuateQ_+3A_deltay">DeltaY</code></td>
<td>
<p>Indicator of missing outcome (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="fluctuateQ_+3A_deltaa">DeltaA</code></td>
<td>
<p>Indicator of missing treatment (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="fluctuateQ_+3A_qn">Qn</code></td>
<td>
<p>A list of outcome regression estimates evaluated on observed data</p>
</td></tr>
<tr><td><code id="fluctuateQ_+3A_gn">gn</code></td>
<td>
<p>A list of propensity regression estimates evaluated on observed
data</p>
</td></tr>
<tr><td><code id="fluctuateQ_+3A_grn">grn</code></td>
<td>
<p>A list of reduced-dimension regression estimates evaluated on
observed data</p>
</td></tr>
<tr><td><code id="fluctuateQ_+3A_a_0">a_0</code></td>
<td>
<p>A list of fixed treatment values</p>
</td></tr>
<tr><td><code id="fluctuateQ_+3A_reduction">reduction</code></td>
<td>
<p>A character indicating what reduced dimension regression was
used.</p>
</td></tr>
<tr><td><code id="fluctuateQ_+3A_coeftol">coefTol</code></td>
<td>
<p>A tolerance level on the magnitude of the coefficient that
flags the result as potentially the result of numeric instability.</p>
</td></tr>
</table>

<hr>
<h2 id='fluctuateQ1'>fluctuateQ1</h2><span id='topic+fluctuateQ1'></span>

<h3>Description</h3>

<p>Function called internally by drtmle to perform the first fluctuation
of the initial estimator of Q (i.e., solves the original EIF estimating eqn)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fluctuateQ1(Y, A, W, DeltaA, DeltaY, Qn, gn, a_0, coefTol = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fluctuateQ1_+3A_y">Y</code></td>
<td>
<p>The outcome</p>
</td></tr>
<tr><td><code id="fluctuateQ1_+3A_a">A</code></td>
<td>
<p>The treatment</p>
</td></tr>
<tr><td><code id="fluctuateQ1_+3A_w">W</code></td>
<td>
<p>The covariates</p>
</td></tr>
<tr><td><code id="fluctuateQ1_+3A_deltaa">DeltaA</code></td>
<td>
<p>Indicator of missing treatment (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="fluctuateQ1_+3A_deltay">DeltaY</code></td>
<td>
<p>Indicator of missing outcome (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="fluctuateQ1_+3A_qn">Qn</code></td>
<td>
<p>A list of outcome regression estimates evaluated on observed data</p>
</td></tr>
<tr><td><code id="fluctuateQ1_+3A_gn">gn</code></td>
<td>
<p>A list of propensity regression estimates evaluated on observed data</p>
</td></tr>
<tr><td><code id="fluctuateQ1_+3A_a_0">a_0</code></td>
<td>
<p>A list of fixed treatment values</p>
</td></tr>
<tr><td><code id="fluctuateQ1_+3A_coeftol">coefTol</code></td>
<td>
<p>A tolerance level on the magnitude of the coefficient that
flags the result as potentially the result of numeric instability.</p>
</td></tr>
</table>

<hr>
<h2 id='fluctuateQ2'>fluctuateQ2</h2><span id='topic+fluctuateQ2'></span>

<h3>Description</h3>

<p>Function called internally by drtmle to perform the second fluctuation
of the initial estimator of Q (i.e., solves the new estimating eqn that
results from misspecification of g)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fluctuateQ2(Y, A, W, DeltaY, DeltaA, Qn, gn, grn, a_0, reduction,
  coefTol = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fluctuateQ2_+3A_y">Y</code></td>
<td>
<p>The outcome</p>
</td></tr>
<tr><td><code id="fluctuateQ2_+3A_a">A</code></td>
<td>
<p>The treatment</p>
</td></tr>
<tr><td><code id="fluctuateQ2_+3A_w">W</code></td>
<td>
<p>The covariates</p>
</td></tr>
<tr><td><code id="fluctuateQ2_+3A_deltay">DeltaY</code></td>
<td>
<p>Indicator of missing outcome (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="fluctuateQ2_+3A_deltaa">DeltaA</code></td>
<td>
<p>Indicator of missing treatment (assumed to be equal to 0 if
missing 1 if observed)</p>
</td></tr>
<tr><td><code id="fluctuateQ2_+3A_qn">Qn</code></td>
<td>
<p>A list of outcome regression estimates evaluated on observed data</p>
</td></tr>
<tr><td><code id="fluctuateQ2_+3A_gn">gn</code></td>
<td>
<p>A list of propensity regression estimates evaluated on observed
data</p>
</td></tr>
<tr><td><code id="fluctuateQ2_+3A_grn">grn</code></td>
<td>
<p>A list of reduced-dimension regression estimates evaluated on
observed data</p>
</td></tr>
<tr><td><code id="fluctuateQ2_+3A_a_0">a_0</code></td>
<td>
<p>A list of fixed treatment values</p>
</td></tr>
<tr><td><code id="fluctuateQ2_+3A_reduction">reduction</code></td>
<td>
<p>A character indicating what reduced dimension regression was
used.</p>
</td></tr>
<tr><td><code id="fluctuateQ2_+3A_coeftol">coefTol</code></td>
<td>
<p>A tolerance level on the magnitude of the coefficient that
flags the result as potentially the result of numeric instability.</p>
</td></tr>
</table>

<hr>
<h2 id='make_validRows'>Make list of rows in each validation fold.</h2><span id='topic+make_validRows'></span>

<h3>Description</h3>

<p>Make list of rows in each validation fold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_validRows(cvFolds, n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_validRows_+3A_cvfolds">cvFolds</code></td>
<td>
<p>Numeric number of cv folds</p>
</td></tr>
<tr><td><code id="make_validRows_+3A_n">n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code id="make_validRows_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>

<hr>
<h2 id='partial_cv_preds'>Helper function to properly format partially cross-validated predictions
from a fitted super learner.</h2><span id='topic+partial_cv_preds'></span>

<h3>Description</h3>

<p>Helper function to properly format partially cross-validated predictions
from a fitted super learner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial_cv_preds(fit_sl, a_0, W = NULL, family, include = NULL, easy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial_cv_preds_+3A_fit_sl">fit_sl</code></td>
<td>
<p>A fitted <code>SuperLearner</code> object with
<code>control$saveCVFitLibrary = TRUE</code></p>
</td></tr>
<tr><td><code id="partial_cv_preds_+3A_a_0">a_0</code></td>
<td>
<p>Treatment level to set. If <code>NULL</code>, assume this function
is being used to get partially cross-validated propensity score predictions.</p>
</td></tr>
<tr><td><code id="partial_cv_preds_+3A_w">W</code></td>
<td>
<p>A <code>data.frame</code> of named covariates.</p>
</td></tr>
<tr><td><code id="partial_cv_preds_+3A_family">family</code></td>
<td>
<p>Family of prediction model</p>
</td></tr>
<tr><td><code id="partial_cv_preds_+3A_include">include</code></td>
<td>
<p>A boolean vector indicating which observations were actually
used to fit the regression.</p>
</td></tr>
<tr><td><code id="partial_cv_preds_+3A_easy">easy</code></td>
<td>
<p>A boolean indicating whether the predictions can be
computed the &quot;easy&quot; way, i.e., based just on the Z matrix from SuperLearner.
This is possible for propensity score models when no missing data AND no
stratification.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.drtmle'>Plot reduced dimension regression fits</h2><span id='topic+plot.drtmle'></span>

<h3>Description</h3>

<p>Plot reduced dimension regression fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drtmle'
plot(x, nPoints = 500, ask = TRUE, a_0 = x$a_0[1], ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.drtmle_+3A_x">x</code></td>
<td>
<p>An object of class <code>"drtmle"</code></p>
</td></tr>
<tr><td><code id="plot.drtmle_+3A_npoints">nPoints</code></td>
<td>
<p>Number of points to plot lines (increase for less bumpy plot,
decrease for faster evaluation).</p>
</td></tr>
<tr><td><code id="plot.drtmle_+3A_ask">ask</code></td>
<td>
<p>Boolean indicating whether R should ask to show each plot</p>
</td></tr>
<tr><td><code id="plot.drtmle_+3A_a_0">a_0</code></td>
<td>
<p>For what value of a_0 should the plot be made for?</p>
</td></tr>
<tr><td><code id="plot.drtmle_+3A_...">...</code></td>
<td>
<p>More arguments passed to <code>plot</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># load super learner
library(SuperLearner)
# simulate data
set.seed(123456)
n &lt;- 100
W &lt;- data.frame(W1 = runif(n), W2 = rnorm(n))
A &lt;- rbinom(n, 1, plogis(W$W1 - W$W2))
Y &lt;- rbinom(n, 1, plogis(W$W1 * W$W2 * A))
# fit drtmle with maxIter = 1 to run fast

fit1 &lt;- drtmle(
  W = W, A = A, Y = Y, a_0 = c(1, 0),
  family = binomial(),
  stratify = FALSE,
  SL_Q = c("SL.glm", "SL.mean", "SL.glm.interaction"),
  SL_g = c("SL.glm", "SL.mean", "SL.glm.interaction"),
  SL_Qr = "SL.npreg", SL_gr = "SL.npreg",
  maxIter = 1, returnModels = TRUE
)
# plot the reduced-dimension regression fits (not run)

plot(fit1)

#
</code></pre>

<hr>
<h2 id='predict.SL.npreg'>Predict method for SL.npreg</h2><span id='topic+predict.SL.npreg'></span>

<h3>Description</h3>

<p>Method for predicting SL.npreg objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SL.npreg'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.SL.npreg_+3A_object">object</code></td>
<td>
<p>An object of class <code>"SL.npreg"</code>.</p>
</td></tr>
<tr><td><code id="predict.SL.npreg_+3A_newdata">newdata</code></td>
<td>
<p>The new data used to obtain predictions.</p>
</td></tr>
<tr><td><code id="predict.SL.npreg_+3A_...">...</code></td>
<td>
<p>Other arguments passed to predict.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># simulate data
set.seed(1234)
n &lt;- 100
X &lt;- data.frame(X1 = rnorm(n))
Y &lt;- X$X1 + rnorm(n)
# fit npreg
fit &lt;- SL.npreg(Y = Y, X = X, newX = X)
# predict on fit
newX &lt;- data.frame(X1 = c(-1, 0, 1))
pred &lt;- predict(fit$fit, newdata = newX)
#
</code></pre>

<hr>
<h2 id='print.adaptive_iptw'>Print the output of a <code>"adaptive_iptw"</code> object.</h2><span id='topic+print.adaptive_iptw'></span>

<h3>Description</h3>

<p>Print the output of a <code>"adaptive_iptw"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adaptive_iptw'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.adaptive_iptw_+3A_x">x</code></td>
<td>
<p>A <code>"adaptive_iptw"</code> object.</p>
</td></tr>
<tr><td><code id="print.adaptive_iptw_+3A_...">...</code></td>
<td>
<p>Other arguments (not used)</p>
</td></tr>
</table>

<hr>
<h2 id='print.ci.adaptive_iptw'>Print the output of ci.adaptive_iptw</h2><span id='topic+print.ci.adaptive_iptw'></span>

<h3>Description</h3>

<p>Print the output of ci.adaptive_iptw
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ci.adaptive_iptw'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ci.adaptive_iptw_+3A_x">x</code></td>
<td>
<p>An object of class ci.adaptive_iptw</p>
</td></tr>
<tr><td><code id="print.ci.adaptive_iptw_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round to</p>
</td></tr>
<tr><td><code id="print.ci.adaptive_iptw_+3A_...">...</code></td>
<td>
<p>Other options (not currently used)</p>
</td></tr>
</table>

<hr>
<h2 id='print.ci.drtmle'>Print the output of ci.drtmle</h2><span id='topic+print.ci.drtmle'></span>

<h3>Description</h3>

<p>Print the output of ci.drtmle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ci.drtmle'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ci.drtmle_+3A_x">x</code></td>
<td>
<p>An object of class ci.drtmle</p>
</td></tr>
<tr><td><code id="print.ci.drtmle_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round to</p>
</td></tr>
<tr><td><code id="print.ci.drtmle_+3A_...">...</code></td>
<td>
<p>Other options (not currently used)</p>
</td></tr>
</table>

<hr>
<h2 id='print.drtmle'>Print the output of a <code>"drtmle"</code> object.</h2><span id='topic+print.drtmle'></span>

<h3>Description</h3>

<p>Print the output of a <code>"drtmle"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drtmle'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.drtmle_+3A_x">x</code></td>
<td>
<p>A <code>"drtmle"</code> object</p>
</td></tr>
<tr><td><code id="print.drtmle_+3A_...">...</code></td>
<td>
<p>Other arguments (not used)</p>
</td></tr>
</table>

<hr>
<h2 id='print.wald_test.adaptive_iptw'>Print the output of wald_test.adaptive_iptw</h2><span id='topic+print.wald_test.adaptive_iptw'></span>

<h3>Description</h3>

<p>Print the output of wald_test.adaptive_iptw
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wald_test.adaptive_iptw'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.wald_test.adaptive_iptw_+3A_x">x</code></td>
<td>
<p>An object of class wald_test.adaptive_iptw</p>
</td></tr>
<tr><td><code id="print.wald_test.adaptive_iptw_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round to</p>
</td></tr>
<tr><td><code id="print.wald_test.adaptive_iptw_+3A_...">...</code></td>
<td>
<p>Other options (not currently used)</p>
</td></tr>
</table>

<hr>
<h2 id='print.wald_test.drtmle'>Print the output of wald_test.drtmle</h2><span id='topic+print.wald_test.drtmle'></span>

<h3>Description</h3>

<p>Print the output of wald_test.drtmle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wald_test.drtmle'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.wald_test.drtmle_+3A_x">x</code></td>
<td>
<p>An object of class wald_test.drtmle</p>
</td></tr>
<tr><td><code id="print.wald_test.drtmle_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round to</p>
</td></tr>
<tr><td><code id="print.wald_test.drtmle_+3A_...">...</code></td>
<td>
<p>Other options (not currently used)</p>
</td></tr>
</table>

<hr>
<h2 id='reorder_list'>Helper function to reorder lists according to cvFolds</h2><span id='topic+reorder_list'></span>

<h3>Description</h3>

<p>Helper function to reorder lists according to cvFolds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reorder_list(a_list, a_0, validRows, n_SL = 1, grn_ind = FALSE, n,
  for_se_cv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reorder_list_+3A_a_list">a_list</code></td>
<td>
<p>Structured list of nuisance parameters</p>
</td></tr>
<tr><td><code id="reorder_list_+3A_a_0">a_0</code></td>
<td>
<p>Treatment levels</p>
</td></tr>
<tr><td><code id="reorder_list_+3A_validrows">validRows</code></td>
<td>
<p>List of rows of data in validation data for
each split.</p>
</td></tr>
<tr><td><code id="reorder_list_+3A_n_sl">n_SL</code></td>
<td>
<p>Number of super learners. If &gt;1, then predictions
are averaged</p>
</td></tr>
<tr><td><code id="reorder_list_+3A_grn_ind">grn_ind</code></td>
<td>
<p>Structure of grn call is slightly different</p>
</td></tr>
<tr><td><code id="reorder_list_+3A_n">n</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code id="reorder_list_+3A_for_se_cv">for_se_cv</code></td>
<td>
<p>Is this being used to average over
cross-validated standard errors? Affects index of <code>a_list</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='SL.npreg'>Super learner wrapper for kernel regression</h2><span id='topic+SL.npreg'></span>

<h3>Description</h3>

<p>Kernel regression based on the <a href="https://CRAN.R-project.org/package=np">np</a>
package. Uses leave-one-out cross-validation to fit a kernel regression.
See <code>?npreg</code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SL.npreg(Y, X, newX, family = gaussian(), obsWeights = rep(1, length(Y)),
  rangeThresh = 1e-07, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SL.npreg_+3A_y">Y</code></td>
<td>
<p>A vector of outcomes.</p>
</td></tr>
<tr><td><code id="SL.npreg_+3A_x">X</code></td>
<td>
<p>A matrix or data.frame of training data predictors.</p>
</td></tr>
<tr><td><code id="SL.npreg_+3A_newx">newX</code></td>
<td>
<p>A test set of predictors.</p>
</td></tr>
<tr><td><code id="SL.npreg_+3A_family">family</code></td>
<td>
<p>Not used by the function directly, but ensures compatibility
with <code>SuperLearner</code>.</p>
</td></tr>
<tr><td><code id="SL.npreg_+3A_obsweights">obsWeights</code></td>
<td>
<p>Not used by the function directly, but ensures
compatibility with <code>SuperLearner</code>.</p>
</td></tr>
<tr><td><code id="SL.npreg_+3A_rangethresh">rangeThresh</code></td>
<td>
<p>If the the range of the outcomes is smaller than this
number, the method returns the empirical average of the outcomes. Used for
computational expediency and stability.</p>
</td></tr>
<tr><td><code id="SL.npreg_+3A_...">...</code></td>
<td>
<p>Other arguments (not currently used).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># simulate data
set.seed(1234)
n &lt;- 100
X &lt;- data.frame(X1 = rnorm(n))
Y &lt;- X$X1 + rnorm(n)
# fit npreg
fit &lt;- SL.npreg(Y = Y, X = X, newX = X)
#
</code></pre>

<hr>
<h2 id='tmp_method.CC_LS'>Temporary fix for convex combination method mean squared error
Relative to existing implementation, we reduce the tolerance at which
we declare predictions from a given algorithm the same as another</h2><span id='topic+tmp_method.CC_LS'></span>

<h3>Description</h3>

<p>Temporary fix for convex combination method mean squared error
Relative to existing implementation, we reduce the tolerance at which
we declare predictions from a given algorithm the same as another
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmp_method.CC_LS()
</code></pre>

<hr>
<h2 id='tmp_method.CC_nloglik'>Temporary fix for convex combination method negative log-likelihood loss
Relative to existing implementation, we reduce the tolerance at which
we declare predictions from a given algorithm the same as another.
Note that because of the way <code>SuperLearner</code> is structure, one needs to
install the optimization software separately.</h2><span id='topic+tmp_method.CC_nloglik'></span>

<h3>Description</h3>

<p>Temporary fix for convex combination method negative log-likelihood loss
Relative to existing implementation, we reduce the tolerance at which
we declare predictions from a given algorithm the same as another.
Note that because of the way <code>SuperLearner</code> is structure, one needs to
install the optimization software separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmp_method.CC_nloglik()
</code></pre>

<hr>
<h2 id='wald_test'>Wald tests for drtmle and adaptive_iptw objects</h2><span id='topic+wald_test'></span>

<h3>Description</h3>

<p>Wald tests for drtmle and adaptive_iptw objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wald_test(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wald_test_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to method</p>
</td></tr>
</table>

<hr>
<h2 id='wald_test.adaptive_iptw'>Wald tests for adaptive_iptw objects</h2><span id='topic+wald_test.adaptive_iptw'></span>

<h3>Description</h3>

<p>Wald tests for adaptive_iptw objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adaptive_iptw'
wald_test(object, est = c("iptw_tmle"), null = 0, contrast = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wald_test.adaptive_iptw_+3A_object">object</code></td>
<td>
<p>An object of class <code>"adaptive_iptw"</code></p>
</td></tr>
<tr><td><code id="wald_test.adaptive_iptw_+3A_est">est</code></td>
<td>
<p>A vector indicating for which estimators to return a confidence
interval. Possible estimators include the TMLE IPTW (<code>"iptw_tmle"</code>,
recommended), the one-step IPTW (<code>"iptw_os"</code>, not recommended), the
standard IPTW (<code>"iptw"</code>, recommended only for comparison to the other
two estimators).</p>
</td></tr>
<tr><td><code id="wald_test.adaptive_iptw_+3A_null">null</code></td>
<td>
<p>The null hypothesis value(s).</p>
</td></tr>
<tr><td><code id="wald_test.adaptive_iptw_+3A_contrast">contrast</code></td>
<td>
<p>This option specifies what parameter to return confidence
intervals for. If <code>contrast=NULL</code>, then test the null hypothesis that
the covariate-adjusted marginal means equal the value(s) specified in
<code>null</code>. <code>contrast</code> can also be a numeric vector of ones, negative
ones, and zeros to define linear combinations of the various means (e.g., to
estimate an average treatment effect, see examples). In this case, we test
the null hypothesis that the linear combination of means equals the value
specified in <code>null</code>. <code>contrast</code> can also be a list with named
functions <code>f</code>, <code>h</code>, and <code>fh_grad</code>. The function <code>f</code>
takes as input argument <code>eff</code> and specifies which transformation of the
effect measure to test. The function <code>h</code> defines the contrast to be
estimated and should take as input <code>est</code>, a vector of the same length
as <code>object$a_0</code>, and output the desired contrast. The function
<code>fh_grad</code> is the gradient of the function <code>h(f())</code>. The function
computes a test of the null hypothesis that <code>h(f(object$est)) = null</code>.
See examples.</p>
</td></tr>
<tr><td><code id="wald_test.adaptive_iptw_+3A_...">...</code></td>
<td>
<p>Other options (not currently used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"ci.adaptive_iptw"</code> with point estimates and
confidence intervals of the specified level.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load super learner
library(SuperLearner)
# fit adaptive_iptw
set.seed(123456)
n &lt;- 200
W &lt;- data.frame(W1 = runif(n), W2 = rnorm(n))
A &lt;- rbinom(n, 1, plogis(W$W1 - W$W2))
Y &lt;- rbinom(n, 1, plogis(W$W1 * W$W2 * A))

fit1 &lt;- adaptive_iptw(
  W = W, A = A, Y = Y, a_0 = c(1, 0),
  SL_g = c("SL.glm", "SL.mean", "SL.step"),
  SL_Qr = "SL.glm"
)

# get test that each mean = 0.5
test_mean &lt;- wald_test(fit1, null = 0.5)

# get test that the ATE = 0
ci_ATE &lt;- ci(fit1, contrast = c(1, -1), null = 0)

# get test for risk ratio = 1 on log scale
myContrast &lt;- list(
  f = function(eff) {
    log(eff)
  },
  f_inv = function(eff) {
    exp(eff)
  }, # not necessary
  h = function(est) {
    est[1] / est[2]
  },
  fh_grad = function(est) {
    c(1 / est[1], -1 / est[2])
  }
)
ci_RR &lt;- ci(fit1, contrast = myContrast, null = 1)
#
</code></pre>

<hr>
<h2 id='wald_test.drtmle'>Wald tests for drtmle objects</h2><span id='topic+wald_test.drtmle'></span>

<h3>Description</h3>

<p>Wald tests for drtmle objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drtmle'
wald_test(object, est = c("drtmle"), null = 0, contrast = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wald_test.drtmle_+3A_object">object</code></td>
<td>
<p>An object of class <code>"drtmle"</code></p>
</td></tr>
<tr><td><code id="wald_test.drtmle_+3A_est">est</code></td>
<td>
<p>A vector indicating for which estimators to return a
confidence interval. Possible estimators include the TMLE with doubly robust
inference (<code>"drtmle"</code>, recommended), the AIPTW with additional
correction for misspecification (<code>"aiptw_c"</code>, not recommended), the
standard TMLE (<code>"tmle"</code>, recommended only for comparison to &quot;drtmle&quot;),
the standard AIPTW (<code>"aiptw"</code>, recommended only for comparison to
&quot;drtmle&quot;), and G-computation (<code>"gcomp"</code>, not recommended).</p>
</td></tr>
<tr><td><code id="wald_test.drtmle_+3A_null">null</code></td>
<td>
<p>The null hypothesis value.</p>
</td></tr>
<tr><td><code id="wald_test.drtmle_+3A_contrast">contrast</code></td>
<td>
<p>This option specifies what parameter to return confidence
intervals for. If <code>contrast=NULL</code>, then test the null hypothesis that
the covariate-adjusted marginal means equal the value(s) specified in
<code>null</code>. <code>contrast</code> can also be a numeric vector of ones, negative
ones, and zeros to define linear combinations of the various means (e.g., to
estimate an average treatment effect, see examples). In this case, we test
the null hypothesis that the linear combination of means equals the value
specified in <code>null</code>. <code>contrast</code> can also be a list with named
functions <code>f</code>, <code>h</code>, and <code>fh_grad</code>. The function <code>f</code>
takes as input argument <code>eff</code> and specifies which transformation of the
effect measure to test. The function <code>h</code> defines the contrast to be
estimated and should take as input <code>est</code>, a vector of the same length
as <code>object$a_0</code>, and output the desired contrast. The function
<code>fh_grad</code> is the gradient of the function <code>h(f())</code>. The function
computes a test of the null hypothesis that <code>h(f(object$est)) = null</code>.
See examples.</p>
</td></tr>
<tr><td><code id="wald_test.drtmle_+3A_...">...</code></td>
<td>
<p>Other options (not currently used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"ci.drtmle"</code> with point estimates and
confidence intervals of the specified level.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load super learner
library(SuperLearner)
# simulate data
set.seed(123456)
n &lt;- 100
W &lt;- data.frame(W1 = runif(n), W2 = rnorm(n))
A &lt;- rbinom(n, 1, plogis(W$W1 - W$W2))
Y &lt;- rbinom(n, 1, plogis(W$W1 * W$W2 * A))
# fit drtmle with maxIter = 1 so runs fast
fit1 &lt;- drtmle(
  W = W, A = A, Y = Y, a_0 = c(1, 0),
  family = binomial(),
  stratify = FALSE,
  SL_Q = c("SL.glm", "SL.mean", "SL.glm.interaction"),
  SL_g = c("SL.glm", "SL.mean", "SL.glm.interaction"),
  SL_Qr = "SL.glm",
  SL_gr = "SL.glm", maxIter = 1
)
# get hypothesis test that each mean = 0.5
test_mean &lt;- wald_test(fit1, null = 0.5)

# get test that ATE = 0
test_ATE &lt;- wald_test(fit1, null = 0, contrast = c(1, -1))

# get test that risk ratio = 1, computing test on log scale
myContrast &lt;- list(
  f = function(eff) {
    log(eff)
  },
  f_inv = function(eff) {
    exp(eff)
  },
  h = function(est) {
    est[1] / est[2]
  },
  fh_grad = function(est) {
    c(1 / est[1], -1 / est[2])
  }
)
test_RR &lt;- wald_test(fit1, contrast = myContrast, null = 1)
#
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
