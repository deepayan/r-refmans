<!DOCTYPE html><html><head><title>Help for package rsetse</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rsetse}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#biconnected_network'><p>A simple network made of three bi-connected components</p></a></li>
<li><a href='#calc_spring_area'><p>Calculate the cross sectional area of the edge</p></a></li>
<li><a href='#calc_spring_constant'><p>Calculate the spring constant</p></a></li>
<li><a href='#calc_tension_strain'><p>Calculate line tension and strain from the topology and node embeddings</p></a></li>
<li><a href='#calc_tension_strain_hd'><p>Calculate line tension and strain from the topology and node embeddings for high dimensional feature networks</p></a></li>
<li><a href='#create_balanced_blocks'><p>Create balanced blocks</p></a></li>
<li><a href='#create_node_edge_df'><p>Create dataframe of node and aggregated edge embeddings</p></a></li>
<li><a href='#create_node_edge_df_hd'><p>Create dataframe of node and aggregated edge embeddings for high dimensional feature networks</p></a></li>
<li><a href='#generate_peels_network'><p>Create a random Peel network</p></a></li>
<li><a href='#mass_adjuster'><p>Mass adjuster</p></a></li>
<li><a href='#prepare_categorical_force'><p>Prepare categorical features for embedding</p></a></li>
<li><a href='#prepare_continuous_force'><p>Prepare continuous features for embedding</p></a></li>
<li><a href='#prepare_edges'><p>Prepare network edges</p></a></li>
<li><a href='#remove_small_components'><p>Remove small components</p></a></li>
<li><a href='#setse'><p>Basic SETSe embedding</p></a></li>
<li><a href='#setse_auto'><p>SETSe embedding with automatic drag and timestep selection</p></a></li>
<li><a href='#setse_auto_hd'><p>SETSe embedding with automatic drag and timestep selection for high-dimensional feature vectors</p></a></li>
<li><a href='#setse_bicomp'><p>SETSe embedding on each bi-connected component using setse_auto</p></a></li>
<li><a href='#setse_expanded'><p>SETSe embedding showing full convergence history</p></a></li>
<li><a href='#setse_shift'><p>setse algorithm with automatic timestep adjustment</p></a></li>
<li><a href='#tidyeval'><p>Tidy eval helpers</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Strain Elevation Tension Spring Embedding</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Description:</td>
<td>An R implementation for the Strain Elevation and
    Tension embedding algorithm from Bourne (2020)
    &lt;<a href="https://doi.org/10.1007%2Fs41109-020-00329-4">doi:10.1007/s41109-020-00329-4</a>&gt;. The package embeds graphs and
    networks using the Strain Elevation and Tension embedding (SETSe)
    algorithm. SETSe represents the network as a physical system, where
    edges are elastic, and nodes exert a force either up or down based on
    node features. SETSe positions the nodes vertically such that the
    tension in the edges of a node is equal and opposite to the force it
    exerts for all nodes in the network. The resultant structure can then
    be analysed by looking at the node elevation and the edge strain and
    tension. This algorithm works on weighted and unweighted networks as
    well as networks with or without explicit node features.  Edge
    elasticity can be created from existing edge weights or kept as a
    constant.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, Matrix, rlang (&ge; 0.1.2), igraph, purrr, tibble,
minpack.lm, magrittr, methods, stats</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, tidyr, ggplot2, ggraph, roxygen2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/JonnoB/rSETSe">https://github.com/JonnoB/rSETSe</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JonnoB/rSETSe/issues">https://github.com/JonnoB/rSETSe/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-06-11 09:42:10 UTC; jonno</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonathan Bourne <a href="https://orcid.org/0000-0003-2616-3716"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonathan Bourne &lt;jonathan.s.bourne@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-06-11 10:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='biconnected_network'>A simple network made of three bi-connected components</h2><span id='topic+biconnected_network'></span>

<h3>Description</h3>

<p>The data set can be used to explore simple different embeddings methods on a very simple graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biconnected_network
</code></pre>


<h3>Format</h3>

<p>An igraph network with 7 nodes and 19 edges which forms three biconnected components:
</p>

<dl>
<dt>edge_name</dt><dd><p>The name of the edge connecting the two vertices</p>
</dd>
<dt>weight</dt><dd><p>The edge weight connecting the two vertices. This value is 1000 for edges connecting nodes
A to D, it is 500 for edges connecting nodes E to G, it is 100 connecting nodes D and E</p>
</dd>
<dt>force</dt><dd><p>The force produced by each node. It was calculated by subtracting the mean node centrality for the network
from the node centrality</p>
</dd>
<dt>group</dt><dd><p>The group each node is in. This can be used to generate force if required</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: plot(biconnected_network)
</code></pre>

<hr>
<h2 id='calc_spring_area'>Calculate the cross sectional area of the edge</h2><span id='topic+calc_spring_area'></span>

<h3>Description</h3>

<p>This function adds the graph characteristic A which is the cross sectional area of the edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_spring_area(g, value, minimum_value, range)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_spring_area_+3A_g">g</code></td>
<td>
<p>an igraph object. The graph representing the network</p>
</td></tr>
<tr><td><code id="calc_spring_area_+3A_value">value</code></td>
<td>
<p>a character string. The name of the edge attribute that is used as value from which Area will be calculated</p>
</td></tr>
<tr><td><code id="calc_spring_area_+3A_minimum_value">minimum_value</code></td>
<td>
<p>a numeric value. Indicating the most thinnest edge</p>
</td></tr>
<tr><td><code id="calc_spring_area_+3A_range">range</code></td>
<td>
<p>a numeric value. This gives the range of A values above the minimum.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is pretty niche but calculates a cross sectional area of an edge.
This is useful when you wish to calculate the spring coefficient k using Young's modulus. 
The function coerces and edge characteristic to be within a certain range of values preventing
negative/zero/infinite values.
</p>


<h3>Value</h3>

<p>a igraph object with the new edge attribute &quot;Area&quot; for each edge
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 

library(igraph)
set.seed(234)
g_prep &lt;- generate_peels_network("A") %&gt;%
 set.edge.attribute(., name = "edge_characteristic", value = rep(1:16, each = 10))

g &lt;- calc_spring_area(g_prep, value = "edge_characteristic", minimum_value = 10, range = 20)

get.edge.attribute(g, "Area")

</code></pre>

<hr>
<h2 id='calc_spring_constant'>Calculate the spring constant</h2><span id='topic+calc_spring_constant'></span>

<h3>Description</h3>

<p>This function adds the graph characteristic k which is the spring constant for a given Area and Young's modulus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_spring_constant(g, youngs_mod = "E", A = "Area", distance = "distance")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_spring_constant_+3A_g">g</code></td>
<td>
<p>an igraph object. The graph representing the network</p>
</td></tr>
<tr><td><code id="calc_spring_constant_+3A_youngs_mod">youngs_mod</code></td>
<td>
<p>a character string. The Young's modulus of the edge. The default is E</p>
</td></tr>
<tr><td><code id="calc_spring_constant_+3A_a">A</code></td>
<td>
<p>a character string. The cross sectional area of the line. The default is A. see details on values of A</p>
</td></tr>
<tr><td><code id="calc_spring_constant_+3A_distance">distance</code></td>
<td>
<p>A character string. See details on values of distance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When A and distance are both set to 1 <code>k=E</code> and the spring constant is equivalent to Young's modulus. 
In this case there is no need to call this function as the edge weight representing youngs modulus can be used for k instead.
</p>
<p>The values A and distance are edge attributes referring to the cross-sectional area of the edge and the horizontal distance of the edge,
in other words the distance between the two nodes at each end of the edge. These values can be set to anything the user wishes, they may be
constant or not. However, consider carefully setting the values to anything else other than 1. There needs to be a clear reasoning
or the results will be meaningless. 
</p>
<p>For example setting the distance of an edge that represents an electrical cable to the distance
of the electrical cable will return very different results when compared to a constant of one. However, the physical distance between two points
does not necessarily have an impact on the loading of the line and so the results would not be interpretable. In contrast setting the distance
metric to be some function of the line resistance may have meaning and be appropriate. As a general rule distance and area should be set to 1.
</p>


<h3>Value</h3>

<p>and edge attribute called k with value <code>EA/distance</code>
</p>


<h3>See Also</h3>

<p>[calc_spring_area]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(igraph)
set.seed(234)
g_prep &lt;- generate_peels_network("A") %&gt;%
 set.edge.attribute(., name = "edge_characteristic", value = rep(1:16, each = 10)) %&gt;%
 #set some pretend Young's modulus value
 set.edge.attribute(., name = "E", value = rep(c(1e5, 5e5, 2e5, 3e5), each = 40)) %&gt;%
 #calculate the spring area from another edge characteristic
 calc_spring_area(., value = "edge_characteristic", minimum_value = 10, range = 20) %&gt;%
 prepare_edges() %&gt;%
 prepare_categorical_force(., node_names = "name", 
                    force_var = "class")

g &lt;- calc_spring_constant(g_prep, youngs_mod = "E", A = "Area", distance = "distance")




</code></pre>

<hr>
<h2 id='calc_tension_strain'>Calculate line tension and strain from the topology and node embeddings</h2><span id='topic+calc_tension_strain'></span>

<h3>Description</h3>

<p>This function calculates the line tension and strain characteristics for the edges in a graph.
It is called by default by all the embedding functions (SETSe_*) but is included here for completeness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_tension_strain(
  g,
  height_embeddings_df,
  distance = "distance",
  edge_name = "edge_name",
  k = "k"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_tension_strain_+3A_g">g</code></td>
<td>
<p>An igraph object of the network.</p>
</td></tr>
<tr><td><code id="calc_tension_strain_+3A_height_embeddings_df">height_embeddings_df</code></td>
<td>
<p>A data frame. This is the results of Create_stabilised_blocks or Find_network_balance</p>
</td></tr>
<tr><td><code id="calc_tension_strain_+3A_distance">distance</code></td>
<td>
<p>A character string. The name of the edge attribute that contains the distance between two nodes. The default is &quot;distance&quot;</p>
</td></tr>
<tr><td><code id="calc_tension_strain_+3A_edge_name">edge_name</code></td>
<td>
<p>A character string. The name of the edge attribute that contains the edge name. The default is &quot;edge_name&quot;.</p>
</td></tr>
<tr><td><code id="calc_tension_strain_+3A_k">k</code></td>
<td>
<p>A character string. The name of the edge attribute that contains the spring coefficient</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whilst the node embeddings dataframe contains the elevation of the setse algorithm this function produces a data frame that contains the Tension
and Strain. The dataframe that is returned contains a substantial amount of line information so reducing the number of variables may be
necessary if the data frame will be merged with previously generated data as there could be multiple columns of the same value.
This function is called by default at the end of all setse functions
</p>


<h3>Value</h3>

<p>The function returns a data frame of 7 columns. These columns are the edge name,
the change in elevation, The final distance between the two nodes (the hypotenuse of the original distance and the vertical distance), 
the spring constant k, the edge tension, the edge strain, and the mean elevation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(234) #set the random see for generating the network
g &lt;- generate_peels_network(type = "E")%&gt;%
prepare_edges(k = 500, distance = 1) %&gt;%
#prepare the network for a binary embedding
prepare_categorical_force(., node_names = "name",
                     force_var = "class") 
#embed the network using auto setse
embeddings &lt;- setse_auto(g, force = "class_A")
  
 edge_embeddings_df &lt;- calc_tension_strain(g, embeddings$node_embeddings)
 all.equal(embeddings$edge_embeddings, edge_embeddings_df) 
 
 
</code></pre>

<hr>
<h2 id='calc_tension_strain_hd'>Calculate line tension and strain from the topology and node embeddings for high dimensional feature networks</h2><span id='topic+calc_tension_strain_hd'></span>

<h3>Description</h3>

<p>This function calculates the line tension and strain characteristics for the edges in a graph.
It is called by default by all the embedding functions (SETSe_*) but is included here for completeness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_tension_strain_hd(
  g,
  height_embeddings_df,
  distance = "distance",
  edge_name = "edge_name",
  k = "k"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_tension_strain_hd_+3A_g">g</code></td>
<td>
<p>An igraph object of the network.</p>
</td></tr>
<tr><td><code id="calc_tension_strain_hd_+3A_height_embeddings_df">height_embeddings_df</code></td>
<td>
<p>A data frame. This is the results of Create_stabilised_blocks or Find_network_balance</p>
</td></tr>
<tr><td><code id="calc_tension_strain_hd_+3A_distance">distance</code></td>
<td>
<p>A character string. The name of the edge attribute that contains the distance between two nodes. The default is &quot;distance&quot;</p>
</td></tr>
<tr><td><code id="calc_tension_strain_hd_+3A_edge_name">edge_name</code></td>
<td>
<p>A character string. The name of the edge attribute that contains the edge name. The default is &quot;edge_name&quot;.</p>
</td></tr>
<tr><td><code id="calc_tension_strain_hd_+3A_k">k</code></td>
<td>
<p>A character string. The name of the edge attribute that contains the spring coefficient</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whilst the node embeddings dataframe contains the elevation of the setse algorithm this function produces a data frame that contains the Tension
and Strain. The dataframe that is returned contains a substantial amount of line information so reducing the number of variables may be
necessary if the data frame will be merged with previously generated data as there could be multiple columns of the same value.
This function is called by default at the end of all setse functions
</p>


<h3>Value</h3>

<p>The function returns a data frame of 7 columns. These columns are the edge name,
the change in elevation, The final distance between the two nodes (the hypotenuse of the original distance and the vertical distance), 
the spring constant k, the edge tension, the edge strain, and the mean elevation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- biconnected_network %&gt;%
 prepare_edges(., k = 1000) %&gt;%
 #prepare the continuous features as normal
 prepare_continuous_force(., node_names = "name", force_var = "force") %&gt;%
 #prepare the categorical features as normal
 prepare_categorical_force(., node_names = "name", force_var = "group")
  
 #embed them using the high dimensional function
 two_dimensional_embeddings &lt;- setse_auto_hd(g, force = c("group_A", "force"), k = "weight")
  
 edge_embeddings_df &lt;- calc_tension_strain_hd(g, two_dimensional_embeddings$node_embeddings)
 all.equal(two_dimensional_embeddings$edge_embeddings, edge_embeddings_df) 
 
 
</code></pre>

<hr>
<h2 id='create_balanced_blocks'>Create balanced blocks</h2><span id='topic+create_balanced_blocks'></span>

<h3>Description</h3>

<p>Separates the network into a series of bi-connected components that can be solved separately. 
Solving smaller subgraphs using the bi-connected component method reduces the risk of network divergence.
This function is seldom called independently of setse_bicomp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_balanced_blocks(g, force = "force", bigraph = bigraph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_balanced_blocks_+3A_g">g</code></td>
<td>
<p>An igraph object. The network for which embeddings will be found</p>
</td></tr>
<tr><td><code id="create_balanced_blocks_+3A_force">force</code></td>
<td>
<p>A character vector. The name of the node attribute that is the force exerted by the nodes</p>
</td></tr>
<tr><td><code id="create_balanced_blocks_+3A_bigraph">bigraph</code></td>
<td>
<p>A list. the list of biconnected components produced by the biconnected_components function.
This function take a non trivial amount of time on large graphs so this pass through minimises the function being called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When networks are separated into the bi-connected subgraphs or blocks. The overall network balance needs to be maintained. 
<code>create_balanced_blocks</code> maintains the balance by summing the net force across the all the nodes that are being removed from
the subgraph. Therefore a node that is an articulation point has a force value equal to the total of all the nodes on the adjacent
bi-connected component.
</p>


<h3>Value</h3>

<p>A list containing all the bi connected component where each component is balanced to have a net force of 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
#create a list of balanced network using the biconnected_network dataset
balanced_list &lt;-create_balanced_blocks(biconnected_network, 
bigraph = biconnected_components(biconnected_network))

#count the edges in each of the bi-components
sapply(balanced_list, ecount)

</code></pre>

<hr>
<h2 id='create_node_edge_df'>Create dataframe of node and aggregated edge embeddings</h2><span id='topic+create_node_edge_df'></span>

<h3>Description</h3>

<p>Aggregates edge strain and tension to node level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_node_edge_df(embeddings_data, function_names = c("mean", "median"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_node_edge_df_+3A_embeddings_data">embeddings_data</code></td>
<td>
<p>A list. The output of any of the setse embedding functions</p>
</td></tr>
<tr><td><code id="create_node_edge_df_+3A_function_names">function_names</code></td>
<td>
<p>A string vector. the names of the aggregation methods to be used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Often if can be useful to have edge data at node level, an example of this would be plotting
the node and tension or strain. To do this requires that the edge embeddings are aggregated somehow to node level
and joined to the appropriate node. This function takes as an argument the output of the setse embedding functions
and any number of aggregation functions to produce a dataframe that is convenient to use.
</p>


<h3>Value</h3>

<p>A dataframe with node names, node force, node elevation and strain and tension aggregated using the named functions.
The strain and tension columns are returned with names in the form &quot;strain_x&quot; where &quot;x&quot; is the name of the function used 
to aggregate. The total number of columns is dependent on the number of aggregation functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
embeddings_data &lt;- biconnected_network %&gt;%
 prepare_edges(.) %&gt;%
 prepare_continuous_force(., node_names = "name", force_var = "force") %&gt;%
 setse_auto(., k = "weight")

out &lt;- create_node_edge_df(embeddings_data, function_names = c("mean", "mode", "sum"))

</code></pre>

<hr>
<h2 id='create_node_edge_df_hd'>Create dataframe of node and aggregated edge embeddings for high dimensional feature networks</h2><span id='topic+create_node_edge_df_hd'></span>

<h3>Description</h3>

<p>Aggregates edge strain and tension to node level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_node_edge_df_hd(embeddings_data, function_names = c("mean", "median"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_node_edge_df_hd_+3A_embeddings_data">embeddings_data</code></td>
<td>
<p>A list. The output of any of the setse embedding functions</p>
</td></tr>
<tr><td><code id="create_node_edge_df_hd_+3A_function_names">function_names</code></td>
<td>
<p>A string vector. the names of the aggregation methods to be used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Often if can be useful to have edge data at node level, an example of this would be plotting
the node and tension or strain. To do this requires that the edge embeddings are aggregated somehow to node level
and joined to the appropriate node. This function takes as an argument the output of the setse embedding functions
and any number of aggregation functions to produce a dataframe that is convenient to use.
</p>


<h3>Value</h3>

<p>A dataframe with node names, node force, node elevation and strain and tension aggregated using the named functions.
The strain and tension columns are returned with names in the form &quot;strain_x&quot; where &quot;x&quot; is the name of the function used 
to aggregate. The total number of columns is dependent on the number of aggregation functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- biconnected_network %&gt;%
 prepare_edges(.) %&gt;%
 #prepare the continuous features as normal
 prepare_continuous_force(., node_names = "name", force_var = "force") %&gt;%
 #prepare the categorical features as normal
 prepare_categorical_force(., node_names = "name", force_var = "group")
  
 #embed them using the high dimensional function
 two_dimensional_embeddings &lt;- setse_auto_hd(g, force = c("group_A", "force"), k = "weight")

 out &lt;- create_node_edge_df_hd(two_dimensional_embeddings , 
  function_names = c("mean", "mode", "sum"))

</code></pre>

<hr>
<h2 id='generate_peels_network'>Create a random Peel network</h2><span id='topic+generate_peels_network'></span>

<h3>Description</h3>

<p>Creates an example of a network from Peel's quintet of the specified type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_peels_network(
  type,
  k_values = c(1000, 500, 100),
  single_component = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_peels_network_+3A_type">type</code></td>
<td>
<p>A character which is any of the capital letters A-E</p>
</td></tr>
<tr><td><code id="generate_peels_network_+3A_k_values">k_values</code></td>
<td>
<p>An integer vector. The spring constant for the edge types within sub class, within class but not sub-class,
between classes. The default value is 1000, 500, 100. This means the strongest connection is for nodes in the same
sub-class and the weakest connection is for nodes in different classes</p>
</td></tr>
<tr><td><code id="generate_peels_network_+3A_single_component">single_component</code></td>
<td>
<p>Logical. Guarantees a single component network. Set to TRUE as default</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates networks matching the 5 types described in Peel et al 2019 (doi: <a href="https://doi.org/10.1073/pnas.1713019115">10.1073/pnas.1713019115</a>). 
All networks have 40 nodes, 60 edges, two node classes and four node sub-classes. 
The connections between the are equal across all 5 types.
As a result all networks generated have identical assortativity. However, as the sub-classes have different connection
probability the structures produced by the networks are very different. When projected into SETSe space the network types
occupy there own area, see Bourne 2020 (doi: <a href="https://doi.org/10.1007/s41109-020-00329-4">10.1007/s41109-020-00329-4</a>) for details.
</p>


<h3>Value</h3>

<p>An igraph object that matches one of the 5 Peel's quintet types. The nodes are labeled with class and sub class.
The edges have attribute k which is the spring constant of the edge given relationship between the nodes the edge connects to
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(234)
g &lt;- generate_peels_network(type = "E")
plot(g)
</code></pre>

<hr>
<h2 id='mass_adjuster'>Mass adjuster</h2><span id='topic+mass_adjuster'></span>

<h3>Description</h3>

<p>This function adjusts the mass of the nodes so that the force in each direction over the mass for that direction 
produces an acceleration of 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mass_adjuster(g, force = "force", resolution_limit = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mass_adjuster_+3A_g">g</code></td>
<td>
<p>An igraph object. the network</p>
</td></tr>
<tr><td><code id="mass_adjuster_+3A_force">force</code></td>
<td>
<p>A character string. The name of the network attribute contain the network forces. Default is &quot;force&quot;</p>
</td></tr>
<tr><td><code id="mass_adjuster_+3A_resolution_limit">resolution_limit</code></td>
<td>
<p>logical. If the forces in the network are smaller than the square root of the machine floating point limit
then the mass is set to one. default is true</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can help stabilise the convergence of networks by preventing major imbalances between the force in the network
and the mass of the nodes. in certain cases acceleration can become very large or very small in 
if force and mass are not well parametrised. 
</p>
<p>This function means that if the network were reduced to two nodes where each node contained all the mass and all the force of
one of the two directions, then each node would have an acceleration of 1ms^-2
</p>
<p>The function can become important when using setse_bicomp as the force mass ratio of biconnection components can vary widely from
the total force mass ratio of the network.
</p>


<h3>Value</h3>

<p>A numeric value giving the adjusted mass of the nodes in the network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(234) #set the random see for generating the network

set.seed(234) #set the random see for generating the network
g &lt;- generate_peels_network(type = "E") %&gt;%
prepare_edges(k = 500, distance = 1) %&gt;%
#prepare the network for a binary embedding
prepare_categorical_force(., node_names = "name",
                     force_var = "class") 

mass_adjuster(g, force = "class_B", resolution_limit = TRUE)

</code></pre>

<hr>
<h2 id='prepare_categorical_force'>Prepare categorical features for embedding</h2><span id='topic+prepare_categorical_force'></span>

<h3>Description</h3>

<p>This function prepares a binary network for SETSe projection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_categorical_force(g, node_names, force_var, sum_to_one = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_categorical_force_+3A_g">g</code></td>
<td>
<p>an igraph object</p>
</td></tr>
<tr><td><code id="prepare_categorical_force_+3A_node_names">node_names</code></td>
<td>
<p>a character string. A vertex attribute which contains the node names.</p>
</td></tr>
<tr><td><code id="prepare_categorical_force_+3A_force_var">force_var</code></td>
<td>
<p>A vector of force attributes. This describes all the categorical force attributes of the network. 
All named attributes must be either character or factor attributes.</p>
</td></tr>
<tr><td><code id="prepare_categorical_force_+3A_sum_to_one">sum_to_one</code></td>
<td>
<p>Logical. whether the total positive force sums to 1, if FALSE the total is the sum of the positive cases</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The network takes in an igraph object and produces an undirected igraph object that can be used with the embedding functions.
</p>
<p>The purpose of the function is to easily be able to project categorical features using SETSe. The function creates new variables
where each variable represents one level of the categorical variables. For embedding only n-1 of the levels are needed.
</p>
<p>The function creates several variables of the format &quot;force_&quot;. Vertex attributes representing the force produced by each node 
for each categorical value, there will be n of these variables representing each level of the categorical values. The variable names 
will be the the name of the variable and the name of the level seperated by and underscore. For example, with a variable group and levels A and B, the created force variables will be
&quot;group_A&quot; and &quot;group_B&quot; The sum of these variables will be 0.
</p>


<h3>Value</h3>

<p>A network with the correct node attributes for the embeddings process.
</p>


<h3>See Also</h3>

<p><a href="#topic+setse">setse</a>, <a href="#topic+setse_auto">setse_auto</a>, <a href="#topic+setse_bicomp">setse_bicomp</a>, <a href="#topic+setse_auto_hd">setse_auto_hd</a>
</p>
<p>Other prepare_setse: 
<code><a href="#topic+prepare_continuous_force">prepare_continuous_force</a>()</code>,
<code><a href="#topic+prepare_edges">prepare_edges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(234) #set the random see for generating the network
g &lt;- generate_peels_network(type = "E")
embeddings &lt;- g %&gt;%
prepare_edges(k = 500, distance = 1) %&gt;%
#prepare the network for a binary embedding
prepare_categorical_force(., node_names = "name",
                     force_var = "class") %&gt;%
#embed the network using auto_setse
  setse_auto(., force = "class_A")

</code></pre>

<hr>
<h2 id='prepare_continuous_force'>Prepare continuous features for embedding</h2><span id='topic+prepare_continuous_force'></span>

<h3>Description</h3>

<p>This function prepares a continuous network for SETSe projection. The function works for networks with a single feature or
high-dimensional features.
The network takes in an igraph object and produces an undirected igraph object that can be used with the embedding functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_continuous_force(
  g,
  node_names,
  k = NULL,
  force_var,
  sum_to_one = TRUE,
  distance = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_continuous_force_+3A_g">g</code></td>
<td>
<p>an igraph object</p>
</td></tr>
<tr><td><code id="prepare_continuous_force_+3A_node_names">node_names</code></td>
<td>
<p>a character string. A vertex attribute which contains the node names.</p>
</td></tr>
<tr><td><code id="prepare_continuous_force_+3A_k">k</code></td>
<td>
<p>The spring constant. This value is either a numeric value giving the spring constant for all edges or NULL. If NULL is used 
the k value will not be added to the network. This is useful k is made through some other process.</p>
</td></tr>
<tr><td><code id="prepare_continuous_force_+3A_force_var">force_var</code></td>
<td>
<p>A character vector. This is the vector of node attributes to be used as the force variables.
All the attributes must be a numeric or integer value, and cannot have NA's. On a single variable embedding this is usually &quot;force&quot;</p>
</td></tr>
<tr><td><code id="prepare_continuous_force_+3A_sum_to_one">sum_to_one</code></td>
<td>
<p>Logical. whether the total positive force sums to 1, if FALSE the total is the sum of the positive cases</p>
</td></tr>
<tr><td><code id="prepare_continuous_force_+3A_distance">distance</code></td>
<td>
<p>a positive numeric value. The default is 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function subtracts the mean from all the values so that the system is balanced. If sum_to_one is true then everything is divided by
the absolute sum over two 
</p>
<p>The function adds the node attribute 'force' and the edge attribute 'k' unless k=NULL. The purpose of the function is to easily be able to 
project continuous networks using SETSe. 
</p>
<p>The function creates several variables
</p>

<ul>
<li><p> force: a vertex attribute representing the force produced by each node. The sum of this variable will be 0
</p>
</li>
<li><p> k: The spring constant representing the stiffness of the spring. 
</p>
</li>
<li><p> edge_name: the name of the edges. it takes the form &quot;from_to&quot; where &quot;from&quot; is the origin node and &quot;to&quot; is the destination node using the 
<a href="igraph.html#topic+as_data_frame">as_data_frame</a> function from igraph
</p>
</li></ul>



<h3>Value</h3>

<p>A network with the correct edge and node attributes for the embeddings process.
</p>


<h3>See Also</h3>

<p><a href="#topic+setse_auto_hd">setse_auto_hd</a>
</p>
<p>Other prepare_setse: 
<code><a href="#topic+prepare_categorical_force">prepare_categorical_force</a>()</code>,
<code><a href="#topic+prepare_edges">prepare_edges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>embeddings &lt;- biconnected_network %&gt;%
#prepare the network for a binary embedding
#k is already present in the data so is left null in the preparation function
prepare_edges(k = NULL, distance = 1) %&gt;%
prepare_continuous_force(., node_names = "name", force_var = "force") %&gt;%
#embed the network using auto_setse
#in the biconnected_network dataset the edge weights are used directly as k values
setse_auto(k = "weight")
</code></pre>

<hr>
<h2 id='prepare_edges'>Prepare network edges</h2><span id='topic+prepare_edges'></span>

<h3>Description</h3>

<p>This function helps prepare the network edges for embedding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_edges(g, k = NULL, distance = 1, create_edge_name = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_edges_+3A_g">g</code></td>
<td>
<p>an igraph object</p>
</td></tr>
<tr><td><code id="prepare_edges_+3A_k">k</code></td>
<td>
<p>The spring constant. This value is either a numeric value giving the spring constant for all edges or NULL. If NULL is used 
the k value will not be added to the network. This is useful k is made through some other process.</p>
</td></tr>
<tr><td><code id="prepare_edges_+3A_distance">distance</code></td>
<td>
<p>The spring constant. This value is either a numeric value giving the spring constant for all edges or NULL. If NULL is used 
the distance value will not be added to the network. This is useful distance is made through some other process.</p>
</td></tr>
<tr><td><code id="prepare_edges_+3A_create_edge_name">create_edge_name</code></td>
<td>
<p>Logical. Whether to create and edge name attribute or not.
</p>
<p>@details 
The function prepares the edge characteristics of the network so that they can be embedded using the SETSe_ family of functions.
</p>
<p>@return 
The function creates several variables
</p>

<ul>
<li><p> k: The spring constant representing the stiffness of the spring. 
</p>
</li>
<li><p> distance: The minimum distance between nodes. This is the distance between the parallel planes/hyper-planes.
</p>
</li>
<li><p> edge_name: the name of the edges. it takes the form &quot;from_to&quot; where &quot;from&quot; is the origin node and &quot;to&quot; is the destination node using the 
<a href="igraph.html#topic+as_data_frame">as_data_frame</a> function from igraph
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+setse">setse</a>, <a href="#topic+setse_auto">setse_auto</a>, <a href="#topic+setse_bicomp">setse_bicomp</a>, <a href="#topic+setse_auto_hd">setse_auto_hd</a>
</p>
<p>Other prepare_setse: 
<code><a href="#topic+prepare_categorical_force">prepare_categorical_force</a>()</code>,
<code><a href="#topic+prepare_continuous_force">prepare_continuous_force</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(234) #set the random see for generating the network
g &lt;- generate_peels_network(type = "E")
embeddings &lt;- g %&gt;%
prepare_edges(k = 500, distance = 1) %&gt;%
#prepare the network for a binary embedding
prepare_categorical_force(., node_names = "name",
                     force_var = "class") %&gt;%
#embed the network using auto setse
  setse_auto(., force = "class_A")
</code></pre>

<hr>
<h2 id='remove_small_components'>Remove small components</h2><span id='topic+remove_small_components'></span>

<h3>Description</h3>

<p>keep only the largest component of graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_small_components(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_small_components_+3A_g">g</code></td>
<td>
<p>An igraph object of the graph to embed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As setse only works on connected components this function removes all but the largest component. 
This is a helper function to quickly project a network with setse.
</p>


<h3>Value</h3>

<p>An igraph object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
set.seed(1284)
#generate a random erdos renyi graph with 100 nodes and 150 edges
g &lt;- erdos.renyi.game(n=100, p.or.m = 150, type = "gnm" )
#count the number of components
components(g)$no

#remove all but the largest component
g2 &lt;-remove_small_components(g)

#Now there is only 1 component
igraph::components(g2)$no

</code></pre>

<hr>
<h2 id='setse'>Basic SETSe embedding</h2><span id='topic+setse'></span>

<h3>Description</h3>

<p>Embeds/smooths a feature network using the basic SETSe algorithm. generally setse_auto or setse_bicomp is preferred.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setse(
  g,
  force = "force",
  distance = "distance",
  edge_name = "edge_name",
  k = "k",
  tstep = 0.02,
  mass = 1,
  max_iter = 20000,
  coef_drag = 1,
  tol = 1e-06,
  sparse = FALSE,
  two_node_solution = TRUE,
  sample = 1,
  static_limit = NULL,
  noisy_termination = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setse_+3A_g">g</code></td>
<td>
<p>An igraph object</p>
</td></tr>
<tr><td><code id="setse_+3A_force">force</code></td>
<td>
<p>A character string. This is the node attribute that contains the force the nodes exert on the network.</p>
</td></tr>
<tr><td><code id="setse_+3A_distance">distance</code></td>
<td>
<p>A character string. The edge attribute that contains the original/horizontal distance between nodes.</p>
</td></tr>
<tr><td><code id="setse_+3A_edge_name">edge_name</code></td>
<td>
<p>A character string. This is the edge attribute that contains the edge_name of the edges.</p>
</td></tr>
<tr><td><code id="setse_+3A_k">k</code></td>
<td>
<p>A character string. This is k for the moment don't change it.</p>
</td></tr>
<tr><td><code id="setse_+3A_tstep">tstep</code></td>
<td>
<p>A numeric. The time interval used to iterate through the network dynamics.</p>
</td></tr>
<tr><td><code id="setse_+3A_mass">mass</code></td>
<td>
<p>A numeric. This is the mass constant of the nodes in normalised networks this is set to 1.</p>
</td></tr>
<tr><td><code id="setse_+3A_max_iter">max_iter</code></td>
<td>
<p>An integer. The maximum number of iterations before stopping. Larger networks usually need more iterations.</p>
</td></tr>
<tr><td><code id="setse_+3A_coef_drag">coef_drag</code></td>
<td>
<p>A numeric.</p>
</td></tr>
<tr><td><code id="setse_+3A_tol">tol</code></td>
<td>
<p>A numeric. The tolerance factor for early stopping.</p>
</td></tr>
<tr><td><code id="setse_+3A_sparse">sparse</code></td>
<td>
<p>Logical. Whether or not the function should be run using sparse matrices. must match the actual matrix, this could prob be automated</p>
</td></tr>
<tr><td><code id="setse_+3A_two_node_solution">two_node_solution</code></td>
<td>
<p>Logical. The Newton-Raphson algo is used to find the correct angle</p>
</td></tr>
<tr><td><code id="setse_+3A_sample">sample</code></td>
<td>
<p>Integer. The dynamics will be stored only if the iteration number is a multiple of the sample. 
This can greatly reduce the size of the results file for large numbers of iterations. Must be a multiple of the max_iter</p>
</td></tr>
<tr><td><code id="setse_+3A_static_limit">static_limit</code></td>
<td>
<p>Numeric. The maximum value the static force can reach before the algorithm terminates early. This
prevents calculation in a diverging system. The value should be set to some multiple greater than one of the force in the system.
If left blank the static limit is twice the system absolute mean force.</p>
</td></tr>
<tr><td><code id="setse_+3A_noisy_termination">noisy_termination</code></td>
<td>
<p>Stop the process if the static force does not monotonically decrease.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the basic SETS embeddings algorithm, it outputs all elements of the embeddings as well as convergence dynamics. It is a
wrapper around the core SETS algorithm which requires data preparation and only produces node embeddings and network dynamics. 
There is little reason to use this function as <code><a href="#topic+setse_auto">setse_auto</a></code> and <code><a href="#topic+setse_bicomp">setse_bicomp</a></code> 
are faster and easier to use.
</p>


<h3>Value</h3>

<p>A list containing 4 dataframes.
</p>

<ol>
<li><p> The network dynamics describing several key figures of the network during the convergence process, this includes the static_force.
</p>
</li>
<li><p> The node embeddings. Includes all data on the nodes the forces exerted on them position and dynamics at simulation termination.
</p>
</li>
<li><p> time taken. the amount of time taken per component, includes the number of edges and nodes.
</p>
</li>
<li><p> The edge embeddings. Includes all data on the edges as well as the strain and tension values.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other setse: 
<code><a href="#topic+setse_auto_hd">setse_auto_hd</a>()</code>,
<code><a href="#topic+setse_auto">setse_auto</a>()</code>,
<code><a href="#topic+setse_bicomp">setse_bicomp</a>()</code>,
<code><a href="#topic+setse_expanded">setse_expanded</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(234) #set the random see for generating the network
g &lt;- generate_peels_network(type = "E")
embeddings &lt;- g %&gt;%
prepare_edges(k = 500, distance = 1) %&gt;%
#prepare the network for a binary embedding
prepare_categorical_force(., node_names = "name",
                     force_var = "class") %&gt;%
#embed the network using auto_setse
  setse(., force = "class_A")
</code></pre>

<hr>
<h2 id='setse_auto'>SETSe embedding with automatic drag and timestep selection</h2><span id='topic+setse_auto'></span>

<h3>Description</h3>

<p>Embeds/smooths a feature network using the SETSe algorithm automatically finding convergence parameters using a grid search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setse_auto(
  g,
  force = "force",
  distance = "distance",
  edge_name = "edge_name",
  k = "k",
  tstep = 0.02,
  mass = 1,
  max_iter = 1e+05,
  tol = 0.002,
  sparse = FALSE,
  hyper_iters = 100,
  hyper_tol = 0.01,
  hyper_max = 30000,
  drag_min = 0.01,
  drag_max = 100,
  tstep_change = 0.2,
  sample = 100,
  static_limit = NULL,
  verbose = FALSE,
  include_edges = TRUE,
  noisy_termination = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setse_auto_+3A_g">g</code></td>
<td>
<p>An igraph object</p>
</td></tr>
<tr><td><code id="setse_auto_+3A_force">force</code></td>
<td>
<p>A character string. This is the node attribute that contains the force the nodes exert on the network.</p>
</td></tr>
<tr><td><code id="setse_auto_+3A_distance">distance</code></td>
<td>
<p>A character string. The edge attribute that contains the original/horizontal distance between nodes.</p>
</td></tr>
<tr><td><code id="setse_auto_+3A_edge_name">edge_name</code></td>
<td>
<p>A character string. This is the edge attribute that contains the edge_name of the edges.</p>
</td></tr>
<tr><td><code id="setse_auto_+3A_k">k</code></td>
<td>
<p>A character string. This is k for the moment don't change it.</p>
</td></tr>
<tr><td><code id="setse_auto_+3A_tstep">tstep</code></td>
<td>
<p>A numeric. The time interval used to iterate through the network dynamics.</p>
</td></tr>
<tr><td><code id="setse_auto_+3A_mass">mass</code></td>
<td>
<p>A numeric. This is the mass constant of the nodes in normalised networks this is set to 1.</p>
</td></tr>
<tr><td><code id="setse_auto_+3A_max_iter">max_iter</code></td>
<td>
<p>An integer. The maximum number of iterations before stopping. Larger networks usually need more iterations.</p>
</td></tr>
<tr><td><code id="setse_auto_+3A_tol">tol</code></td>
<td>
<p>A numeric. The tolerance factor for early stopping.</p>
</td></tr>
<tr><td><code id="setse_auto_+3A_sparse">sparse</code></td>
<td>
<p>Logical. Whether or not the function should be run using sparse matrices. must match the actual matrix, this could prob be automated</p>
</td></tr>
<tr><td><code id="setse_auto_+3A_hyper_iters">hyper_iters</code></td>
<td>
<p>integer. The hyper parameter that determines the number of iterations allowed to find an acceptable convergence value.</p>
</td></tr>
<tr><td><code id="setse_auto_+3A_hyper_tol">hyper_tol</code></td>
<td>
<p>numeric. The convergence tolerance when trying to find the minimum value</p>
</td></tr>
<tr><td><code id="setse_auto_+3A_hyper_max">hyper_max</code></td>
<td>
<p>integer. The maximum number of iterations that SETSe will go through whilst searching for the minimum.</p>
</td></tr>
<tr><td><code id="setse_auto_+3A_drag_min">drag_min</code></td>
<td>
<p>integer. A power of ten. The lowest drag value to be used in the search</p>
</td></tr>
<tr><td><code id="setse_auto_+3A_drag_max">drag_max</code></td>
<td>
<p>integer. A power of ten. if the drag exceeds this value the tstep is reduced</p>
</td></tr>
<tr><td><code id="setse_auto_+3A_tstep_change">tstep_change</code></td>
<td>
<p>numeric. A value between 0 and 1 that determines how much the time step will be reduced by default value is 0.5</p>
</td></tr>
<tr><td><code id="setse_auto_+3A_sample">sample</code></td>
<td>
<p>Integer. The dynamics will be stored only if the iteration number is a multiple of the sample. 
This can greatly reduce the size of the results file for large numbers of iterations. Must be a multiple of the max_iter</p>
</td></tr>
<tr><td><code id="setse_auto_+3A_static_limit">static_limit</code></td>
<td>
<p>Numeric. The maximum value the static force can reach before the algorithm terminates early. This
prevents calculation in a diverging system. The value should be set to some multiple greater than one of the force in the system.
If left blank the static limit is the system absolute mean force.</p>
</td></tr>
<tr><td><code id="setse_auto_+3A_verbose">verbose</code></td>
<td>
<p>Logical. This value sets whether messages generated during the process are suppressed or not.</p>
</td></tr>
<tr><td><code id="setse_auto_+3A_include_edges">include_edges</code></td>
<td>
<p>logical. An optional variable on whether to calculate the edge tension and strain. Default is TRUE.
included for ease of integration into the bicomponent functions.</p>
</td></tr>
<tr><td><code id="setse_auto_+3A_noisy_termination">noisy_termination</code></td>
<td>
<p>Stop the process if the static force does not monotonically decrease.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is one of the most commonly used SETSe functions. It automatically selects the convergence time-step and drag values
to ensure efficient convergence.
</p>
<p>The noisy_termination parameter is used as in some cases the convergence process can get stuck in the noisy zone of SETSe space.
To prevent this the process is stopped early if the static force does not monotonically decrease.  On large networks this 
greatly speeds up the search for good parameter values. It increases the chance of successful convergence. 
More detail on auto-SETSe can be found in the paper &quot;The spring bounces back&quot; (Bourne 2020).
</p>


<h3>Value</h3>

<p>A list containing 5 dataframes.
</p>

<ol>
<li><p> The network dynamics describing several key figures of the network during the convergence process, this includes the static_force
</p>
</li>
<li><p> The node embeddings. Includes all data on the nodes the forces exerted on them position and dynamics at simulation termination
</p>
</li>
<li><p> time taken. the amount of time taken per component, includes the edge and nodes of each component
</p>
</li>
<li><p> The edge embeddings. Includes all data on the edges as well as the strain and tension values.
</p>
</li>
<li><p> memory_df A dataframe recording the iteration history of the convergence of each component.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other setse: 
<code><a href="#topic+setse_auto_hd">setse_auto_hd</a>()</code>,
<code><a href="#topic+setse_bicomp">setse_bicomp</a>()</code>,
<code><a href="#topic+setse_expanded">setse_expanded</a>()</code>,
<code><a href="#topic+setse">setse</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(234) #set the random see for generating the network
g &lt;- generate_peels_network(type = "E")
embeddings &lt;- g %&gt;%
prepare_edges(k = 500, distance = 1) %&gt;%
#prepare the network for a binary embedding
prepare_categorical_force(., node_names = "name",
                     force_var = "class") %&gt;%
#embed the network using auto_setse
  setse_auto(., force = "class_A")

</code></pre>

<hr>
<h2 id='setse_auto_hd'>SETSe embedding with automatic drag and timestep selection for high-dimensional feature vectors</h2><span id='topic+setse_auto_hd'></span>

<h3>Description</h3>

<p>Uses a grid search and a binary search to find appropriate convergence conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setse_auto_hd(
  g,
  force = "force",
  distance = "distance",
  edge_name = "edge_name",
  k = "k",
  tstep = 0.02,
  mass = 1,
  max_iter = 1e+05,
  tol = 0.002,
  sparse = FALSE,
  hyper_iters = 100,
  hyper_tol = 0.01,
  hyper_max = 30000,
  drag_min = 0.01,
  drag_max = 100,
  tstep_change = 0.2,
  sample = 100,
  static_limit = NULL,
  verbose = FALSE,
  include_edges = TRUE,
  noisy_termination = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setse_auto_hd_+3A_g">g</code></td>
<td>
<p>An igraph object</p>
</td></tr>
<tr><td><code id="setse_auto_hd_+3A_force">force</code></td>
<td>
<p>A character vector. These are the nodes attributes that contain the force the nodes exert on the network.</p>
</td></tr>
<tr><td><code id="setse_auto_hd_+3A_distance">distance</code></td>
<td>
<p>A character string. The edge attribute that contains the original/horizontal distance between nodes.</p>
</td></tr>
<tr><td><code id="setse_auto_hd_+3A_edge_name">edge_name</code></td>
<td>
<p>A character string. This is the edge attribute that contains the edge_name of the edges.</p>
</td></tr>
<tr><td><code id="setse_auto_hd_+3A_k">k</code></td>
<td>
<p>A character string. This is k for the moment don't change it.</p>
</td></tr>
<tr><td><code id="setse_auto_hd_+3A_tstep">tstep</code></td>
<td>
<p>A numeric. The time interval used to iterate through the network dynamics.</p>
</td></tr>
<tr><td><code id="setse_auto_hd_+3A_mass">mass</code></td>
<td>
<p>A numeric. This is the mass constant of the nodes in normalised networks this is set to 1.</p>
</td></tr>
<tr><td><code id="setse_auto_hd_+3A_max_iter">max_iter</code></td>
<td>
<p>An integer. The maximum number of iterations before stopping. Larger networks usually need more iterations.</p>
</td></tr>
<tr><td><code id="setse_auto_hd_+3A_tol">tol</code></td>
<td>
<p>A numeric. The tolerance factor for early stopping.</p>
</td></tr>
<tr><td><code id="setse_auto_hd_+3A_sparse">sparse</code></td>
<td>
<p>Logical. Whether or not the function should be run using sparse matrices. must match the actual matrix, this could prob be automated</p>
</td></tr>
<tr><td><code id="setse_auto_hd_+3A_hyper_iters">hyper_iters</code></td>
<td>
<p>integer. The hyper parameter that determines the number of iterations allowed to find an acceptable convergence value.</p>
</td></tr>
<tr><td><code id="setse_auto_hd_+3A_hyper_tol">hyper_tol</code></td>
<td>
<p>numeric. The convergence tolerance when trying to find the minimum value</p>
</td></tr>
<tr><td><code id="setse_auto_hd_+3A_hyper_max">hyper_max</code></td>
<td>
<p>integer. The maximum number of iterations that SETSe will go through whilst searching for the minimum.</p>
</td></tr>
<tr><td><code id="setse_auto_hd_+3A_drag_min">drag_min</code></td>
<td>
<p>integer. A power of ten. The lowest drag value to be used in the search</p>
</td></tr>
<tr><td><code id="setse_auto_hd_+3A_drag_max">drag_max</code></td>
<td>
<p>integer. A power of ten. if the drag exceeds this value the tstep is reduced</p>
</td></tr>
<tr><td><code id="setse_auto_hd_+3A_tstep_change">tstep_change</code></td>
<td>
<p>numeric. A value between 0 and 1 that determines how much the time step will be reduced by default value is 0.5</p>
</td></tr>
<tr><td><code id="setse_auto_hd_+3A_sample">sample</code></td>
<td>
<p>Integer. The dynamics will be stored only if the iteration number is a multiple of the sample. 
This can greatly reduce the size of the results file for large numbers of iterations. Must be a multiple of the max_iter</p>
</td></tr>
<tr><td><code id="setse_auto_hd_+3A_static_limit">static_limit</code></td>
<td>
<p>Numeric. The maximum value the static force can reach before the algorithm terminates early. This
prevents calculation in a diverging system. The value should be set to some multiple greater than one of the force in the system.
If left blank the static limit is the system absolute mean force.</p>
</td></tr>
<tr><td><code id="setse_auto_hd_+3A_verbose">verbose</code></td>
<td>
<p>Logical. This value sets whether messages generated during the process are suppressed or not.</p>
</td></tr>
<tr><td><code id="setse_auto_hd_+3A_include_edges">include_edges</code></td>
<td>
<p>logical. An optional variable on whether to calculate the edge tension and strain. Default is TRUE.
included for ease of integration into the bicomponent functions.</p>
</td></tr>
<tr><td><code id="setse_auto_hd_+3A_noisy_termination">noisy_termination</code></td>
<td>
<p>Stop the process if the static force does not monotonically decrease.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is one of the most commonly used SETSe functions. It automatically selects the convergence time-step and drag values
to ensure efficient convergence.
</p>
<p>The noisy_termination parameter is used as in some cases the convergence process can get stuck in the noisy zone of SETSe space.
To prevent this the process is stopped early if the static force does not monotonically decrease.  On large networks this 
greatly speeds up the search for good parameter values. It increases the chance of successful convergence. 
More detail on auto-SETSe can be found in the paper &quot;The spring bounces back&quot; (Bourne 2020).
</p>


<h3>Value</h3>

<p>A list of four elements. A data frame with the height embeddings of the network, a data frame of the edge embeddings, 
the convergence dynamics dataframe for the network as well as the search history for convergence criteria of the network
</p>


<h3>See Also</h3>

<p>Other setse: 
<code><a href="#topic+setse_auto">setse_auto</a>()</code>,
<code><a href="#topic+setse_bicomp">setse_bicomp</a>()</code>,
<code><a href="#topic+setse_expanded">setse_expanded</a>()</code>,
<code><a href="#topic+setse">setse</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- biconnected_network %&gt;%
 prepare_edges(.) %&gt;%
 #prepare the continuous features as normal
 prepare_continuous_force(., node_names = "name", force_var = "force") %&gt;%
 #prepare the categorical features as normal
 prepare_categorical_force(., node_names = "name", force_var = "group")
  
 #embed them using the high dimensional function
 two_dimensional_embeddings &lt;- setse_auto_hd(g, force = c("group_A", "force"), k = "weight")
                     

</code></pre>

<hr>
<h2 id='setse_bicomp'>SETSe embedding on each bi-connected component using setse_auto</h2><span id='topic+setse_bicomp'></span>

<h3>Description</h3>

<p>Embeds/smooths a feature network using the SETSe algorithm automatically finding convergence parameters using a grid search. In addition it breaks
the network into bi-connected component solves each sub-component inidividually and re-assembles them back into a single network. 
This is the most reliable method to perform SETSe embeddings and can be substantially quicker on certain network topologies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setse_bicomp(
  g,
  force = "force",
  distance = "distance",
  edge_name = "edge_name",
  k = "k",
  tstep = 0.02,
  tol = 0.01,
  max_iter = 20000,
  mass = NULL,
  sparse = FALSE,
  sample = 100,
  static_limit = NULL,
  hyper_iters = 100,
  hyper_tol = 0.1,
  hyper_max = 30000,
  drag_min = 0.01,
  drag_max = 100,
  tstep_change = 0.2,
  verbose = FALSE,
  noisy_termination = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setse_bicomp_+3A_g">g</code></td>
<td>
<p>An igraph object</p>
</td></tr>
<tr><td><code id="setse_bicomp_+3A_force">force</code></td>
<td>
<p>A character string. This is the node attribute that contains the force the nodes exert on the network.</p>
</td></tr>
<tr><td><code id="setse_bicomp_+3A_distance">distance</code></td>
<td>
<p>A character string. The edge attribute that contains the original/horizontal distance between nodes.</p>
</td></tr>
<tr><td><code id="setse_bicomp_+3A_edge_name">edge_name</code></td>
<td>
<p>A character string. This is the edge attribute that contains the edge_name of the edges.</p>
</td></tr>
<tr><td><code id="setse_bicomp_+3A_k">k</code></td>
<td>
<p>A character string. This is k for the moment don't change it.</p>
</td></tr>
<tr><td><code id="setse_bicomp_+3A_tstep">tstep</code></td>
<td>
<p>A numeric. The time interval used to iterate through the network dynamics.</p>
</td></tr>
<tr><td><code id="setse_bicomp_+3A_tol">tol</code></td>
<td>
<p>A numeric. The tolerance factor for early stopping.</p>
</td></tr>
<tr><td><code id="setse_bicomp_+3A_max_iter">max_iter</code></td>
<td>
<p>An integer. The maximum number of iterations before stopping. Larger networks usually need more iterations.</p>
</td></tr>
<tr><td><code id="setse_bicomp_+3A_mass">mass</code></td>
<td>
<p>A numeric. This is the mass constant of the nodes in normalised networks. 
Default is set to NULL and call mass_adjuster to set the mass for each biconnected component</p>
</td></tr>
<tr><td><code id="setse_bicomp_+3A_sparse">sparse</code></td>
<td>
<p>Logical. Whether sparse matrices will be used. This becomes valuable for larger networks</p>
</td></tr>
<tr><td><code id="setse_bicomp_+3A_sample">sample</code></td>
<td>
<p>Integer. The dynamics will be stored only if the iteration number is a multiple of the sample. 
This can greatly reduce the size of the results file for large numbers of iterations. Must be a multiple of the max_iter</p>
</td></tr>
<tr><td><code id="setse_bicomp_+3A_static_limit">static_limit</code></td>
<td>
<p>Numeric. The maximum value the static force can reach before the algorithm terminates early. This
prevents calculation in a diverging system. The value should be set to some multiple greater than one of the force in the system.
If left blank the static limit is the system absolute mean force.</p>
</td></tr>
<tr><td><code id="setse_bicomp_+3A_hyper_iters">hyper_iters</code></td>
<td>
<p>integer. The hyper parameter that determines the number of iterations allowed to find an acceptable convergence value.</p>
</td></tr>
<tr><td><code id="setse_bicomp_+3A_hyper_tol">hyper_tol</code></td>
<td>
<p>numeric. The convergence tolerance when trying to find the minimum value</p>
</td></tr>
<tr><td><code id="setse_bicomp_+3A_hyper_max">hyper_max</code></td>
<td>
<p>integer. The maximum number of iterations that SETSe will go through whilst searching for the minimum.</p>
</td></tr>
<tr><td><code id="setse_bicomp_+3A_drag_min">drag_min</code></td>
<td>
<p>integer. A power of ten. The lowest drag value to be used in the search</p>
</td></tr>
<tr><td><code id="setse_bicomp_+3A_drag_max">drag_max</code></td>
<td>
<p>integer. A power of ten. if the drag exceeds this value the tstep is reduced</p>
</td></tr>
<tr><td><code id="setse_bicomp_+3A_tstep_change">tstep_change</code></td>
<td>
<p>numeric. A value between 0 and 1 that determines how much the time step will be reduced by default value is 0.5</p>
</td></tr>
<tr><td><code id="setse_bicomp_+3A_verbose">verbose</code></td>
<td>
<p>Logical. This value sets whether messages generated during the process are suppressed or not.</p>
</td></tr>
<tr><td><code id="setse_bicomp_+3A_noisy_termination">noisy_termination</code></td>
<td>
<p>Stop the process if the static force does not monotonically decrease.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Embedding the network by solving each bi-connected component then re-assembling can be faster for larger graphs, graphs with many nodes of degree 2, 
or networks with a low clustering coefficient.
This is because although SETSe is very efficient the topology of larger graphs make them more difficult to converge.
Large graph tend to be made of 1 very large biconnected component and many very small biconnected components. As the mass of the 
system is concentrated in the major biconnected component smaller ones can be knocked around by minor movements of the largest component. This
can lead to long convergence times. By solving all biconnected components separately and then reassembling the block tree at the end,
the system can be converged considerably faster. 
</p>
<p>Setting mass to the absolute system force divided by the total nodes, often leads to faster convergence. As such
When mass is left to the default of NULL, the mean absolute force value is used.
</p>


<h3>Value</h3>

<p>A list containing 5 dataframes.
</p>

<ol>
<li><p> The node embeddings. Includes all data on the nodes the forces exerted on them position and dynamics at simulation termination
</p>
</li>
<li><p> The network dynamics describing several key figures of the network during the convergence process, this includes the static_force
</p>
</li>
<li><p> memory_df A dataframe recording the iteration history of the convergence of each component.
</p>
</li>
<li><p> Time taken. A data frame giving the time taken for the simulation as well as the number of nodes and edges. Node and edge data is given
as this may differ from the total number of nodes and edges in the network depending on the method used for convergence.
For example if setse_bicomp is used then some simulations may contain as little as two nodes and 1 edge
</p>
</li>
<li><p> The edge embeddings. Includes all data on the edges as well as the strain and tension values.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other setse: 
<code><a href="#topic+setse_auto_hd">setse_auto_hd</a>()</code>,
<code><a href="#topic+setse_auto">setse_auto</a>()</code>,
<code><a href="#topic+setse_expanded">setse_expanded</a>()</code>,
<code><a href="#topic+setse">setse</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(234) #set the random see for generating the network
g &lt;- generate_peels_network(type = "E")
embeddings &lt;- g %&gt;%
prepare_edges(k = 500, distance = 1) %&gt;%
#prepare the network for a binary embedding
prepare_categorical_force(., node_names = "name",
                     force_var = "class") %&gt;%
#embed the network
  setse_bicomp(., force = "class_A")
  
</code></pre>

<hr>
<h2 id='setse_expanded'>SETSe embedding showing full convergence history</h2><span id='topic+setse_expanded'></span>

<h3>Description</h3>

<p>This is a special case function of SETSe which keeps the history of all node movements during convergence0. It is useful for demonstrations,
or parametrising difficult networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setse_expanded(
  g,
  force = "force",
  distance = "distance",
  edge_name = "edge_name",
  k = "k",
  tstep = 0.02,
  mass = 1,
  max_iter = 20000,
  coef_drag = 1,
  tol = 1e-06,
  sparse = FALSE,
  verbose = TRUE,
  two_node_solution = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setse_expanded_+3A_g">g</code></td>
<td>
<p>An igraph object. The network</p>
</td></tr>
<tr><td><code id="setse_expanded_+3A_force">force</code></td>
<td>
<p>A character string</p>
</td></tr>
<tr><td><code id="setse_expanded_+3A_distance">distance</code></td>
<td>
<p>A character string. The name of the graph attribute that contains the graph distance</p>
</td></tr>
<tr><td><code id="setse_expanded_+3A_edge_name">edge_name</code></td>
<td>
<p>A character string. This is the edge attribute that contains the edge_name of the edges.</p>
</td></tr>
<tr><td><code id="setse_expanded_+3A_k">k</code></td>
<td>
<p>A character string. This is k for the moment don't change it.</p>
</td></tr>
<tr><td><code id="setse_expanded_+3A_tstep">tstep</code></td>
<td>
<p>A numeric. The time in seconds that elapses between each iteration</p>
</td></tr>
<tr><td><code id="setse_expanded_+3A_mass">mass</code></td>
<td>
<p>A numeric. The mass in kg of the nodes, this is arbitrary and commonly 1 is used.</p>
</td></tr>
<tr><td><code id="setse_expanded_+3A_max_iter">max_iter</code></td>
<td>
<p>An integer. The maximum number of iterations before terminating the simulation</p>
</td></tr>
<tr><td><code id="setse_expanded_+3A_coef_drag">coef_drag</code></td>
<td>
<p>A numeric. A multiplier used to tune the damping. Generally no need to twiddle</p>
</td></tr>
<tr><td><code id="setse_expanded_+3A_tol">tol</code></td>
<td>
<p>A numeric. Early termination. If the dynamics of the nodes fall below this value the algorithm will be classed as 
&quot;converged&quot; and the simulation terminates.</p>
</td></tr>
<tr><td><code id="setse_expanded_+3A_sparse">sparse</code></td>
<td>
<p>Logical. Whether or not the function should be run using sparse matrices. must match the actual matrix, this could prob be automated</p>
</td></tr>
<tr><td><code id="setse_expanded_+3A_verbose">verbose</code></td>
<td>
<p>Logical value. Whether the function should output messages or run quietly.</p>
</td></tr>
<tr><td><code id="setse_expanded_+3A_two_node_solution">two_node_solution</code></td>
<td>
<p>Logical. The Newton-Raphson algo is used to find the correct angle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe equivalent to the node_embeddings dataframe for the other SETSe methods. However, the dataframe includes a 
row for each node in each iteration of the simulation, as well as an additional column identifying the iteration number. 
This dataframe can be very large as it contains nxm rows where n is the number of nodes and m is the number of iterations in the simulation.
</p>


<h3>See Also</h3>

<p>Other setse: 
<code><a href="#topic+setse_auto_hd">setse_auto_hd</a>()</code>,
<code><a href="#topic+setse_auto">setse_auto</a>()</code>,
<code><a href="#topic+setse_bicomp">setse_bicomp</a>()</code>,
<code><a href="#topic+setse">setse</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g_prep &lt;- biconnected_network%&gt;%
prepare_edges(.) %&gt;%
prepare_continuous_force(., node_names = "name", force_var = "force", k = NULL) 

#the base configuration does not work
divergent_result &lt;- setse_expanded(g_prep, k = "weight", tstep = 0.1)

#with a smaller timestep the algorithm converges
convergent_result &lt;- setse_expanded(g_prep, k = "weight", tstep = 0.01)

## Not run: 
library(ggplot2)
#plot the results for a given node
convergent_result %&gt;%
 ggplot(aes(x = t, y = net_force, colour = node)) + geom_line()
#re-plot with divergent_result to see what it looks like

## End(Not run)
</code></pre>

<hr>
<h2 id='setse_shift'>setse algorithm with automatic timestep adjustment</h2><span id='topic+setse_shift'></span>

<h3>Description</h3>

<p>The basic setse function with added timestep adjustment. 
The time shift functionality automatically adjusts the timestep if the convergence process is noisy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setse_shift(
  g,
  force = "force",
  distance = "distance",
  edge_name = "edge_name",
  k = "k",
  tstep = 0.02,
  mass = 1,
  max_iter = 20000,
  coef_drag = 1,
  tol = 1e-06,
  sparse = FALSE,
  two_node_solution = TRUE,
  sample = 1,
  static_limit = NULL,
  tstep_change = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setse_shift_+3A_g">g</code></td>
<td>
<p>An igraph object</p>
</td></tr>
<tr><td><code id="setse_shift_+3A_force">force</code></td>
<td>
<p>A character string. This is the node attribute that contains the force the nodes exert on the network.</p>
</td></tr>
<tr><td><code id="setse_shift_+3A_distance">distance</code></td>
<td>
<p>A character string. The edge attribute that contains the original/horizontal distance between nodes.</p>
</td></tr>
<tr><td><code id="setse_shift_+3A_edge_name">edge_name</code></td>
<td>
<p>A character string. This is the edge attribute that contains the edge_name of the edges.</p>
</td></tr>
<tr><td><code id="setse_shift_+3A_k">k</code></td>
<td>
<p>A character string. This is k for the moment don't change it.</p>
</td></tr>
<tr><td><code id="setse_shift_+3A_tstep">tstep</code></td>
<td>
<p>A numeric. The time interval used to iterate through the network dynamics.</p>
</td></tr>
<tr><td><code id="setse_shift_+3A_mass">mass</code></td>
<td>
<p>A numeric. This is the mass constant of the nodes in normalised networks this is set to 1.</p>
</td></tr>
<tr><td><code id="setse_shift_+3A_max_iter">max_iter</code></td>
<td>
<p>An integer. The maximum number of iterations before stopping. Larger networks usually need more iterations.</p>
</td></tr>
<tr><td><code id="setse_shift_+3A_coef_drag">coef_drag</code></td>
<td>
<p>A numeric.</p>
</td></tr>
<tr><td><code id="setse_shift_+3A_tol">tol</code></td>
<td>
<p>A numeric. The tolerance factor for early stopping.</p>
</td></tr>
<tr><td><code id="setse_shift_+3A_sparse">sparse</code></td>
<td>
<p>Logical. Whether or not the function should be run using sparse matrices. must match the actual matrix, this could prob be automated</p>
</td></tr>
<tr><td><code id="setse_shift_+3A_two_node_solution">two_node_solution</code></td>
<td>
<p>Logical. The Newton-Raphson algo is used to find the correct angle</p>
</td></tr>
<tr><td><code id="setse_shift_+3A_sample">sample</code></td>
<td>
<p>Integer. The dynamics will be stored only if the iteration number is a multiple of the sample. 
This can greatly reduce the size of the results file for large numbers of iterations. Must be a multiple of the max_iter</p>
</td></tr>
<tr><td><code id="setse_shift_+3A_static_limit">static_limit</code></td>
<td>
<p>Numeric. The maximum value the static force can reach before the algorithm terminates early. This
prevents calculation in a diverging system. The value should be set to some multiple greater than one of the force in the system.
If left blank the static limit is twice the system absolute mean force.</p>
</td></tr>
<tr><td><code id="setse_shift_+3A_tstep_change">tstep_change</code></td>
<td>
<p>a numeric scaler. A value between 0 and one, the fraction the new timestep will be relative to the previous one
this can stop the momentum of the nodes forcing a divergence, but also can slow down the process. default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the basic SETS embeddings algorithm, it outputs all elements of the embeddings as well as convergence dynamics. It is a
wrapper around the core SETS algorithm which requires data preparation and only produces node embeddings and network dynamics. 
There is little reason to use this function as <code><a href="#topic+setse_auto">setse_auto</a></code> and <code><a href="#topic+setse_bicomp">setse_bicomp</a></code> 
are faster and easier to use.
</p>


<h3>Value</h3>

<p>A list of three elements. A data frame with the height embeddings of the network, a data frame of the edge embeddings
as well as the convergence dynamics dataframe for the network.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setse_auto">setse_auto</a></code> <code><a href="#topic+setse_bicomp">setse_bicomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
biconnected_network %&gt;%
prepare_continuous_force(., node_names = "name", force_var = "force") %&gt;%
#embed the network using setse
setse_shift(., k = "weight", tstep = 0.000029)

## End(Not run)
</code></pre>

<hr>
<h2 id='tidyeval'>Tidy eval helpers</h2><span id='topic+tidyeval'></span><span id='topic+expr'></span><span id='topic+enquo'></span><span id='topic+enquos'></span><span id='topic+sym'></span><span id='topic+syms'></span><span id='topic+.data'></span><span id='topic++3A+3D'></span><span id='topic+as_name'></span><span id='topic+as_label'></span>

<h3>Description</h3>


<ul>
<li> <p><code><a href="rlang.html#topic+sym">sym</a>()</code> creates a symbol from a string and
<code><a href="rlang.html#topic+sym">syms</a>()</code> creates a list of symbols from a
character vector.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+nse-defuse">enquo</a>()</code> and
<code><a href="rlang.html#topic+nse-defuse">enquos</a>()</code> delay the execution of one or
several function arguments. <code>enquo()</code> returns a single quoted
expression, which is like a blueprint for the delayed computation.
<code>enquos()</code> returns a list of such quoted expressions.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+nse-defuse">expr</a>()</code> quotes a new expression <em>locally</em>. It
is mostly useful to build new expressions around arguments
captured with <code><a href="#topic+enquo">enquo()</a></code> or <code><a href="#topic+enquos">enquos()</a></code>:
<code>expr(mean(!!enquo(arg), na.rm = TRUE))</code>.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+as_name">as_name</a>()</code> transforms a quoted variable name
into a string. Supplying something else than a quoted variable
name is an error.
</p>
<p>That's unlike <code><a href="rlang.html#topic+as_label">as_label</a>()</code> which also returns
a single string but supports any kind of R object as input,
including quoted function calls and vectors. Its purpose is to
summarise that object into a single label. That label is often
suitable as a default name.
</p>
<p>If you don't know what a quoted expression contains (for instance
expressions captured with <code>enquo()</code> could be a variable
name, a call to a function, or an unquoted constant), then use
<code>as_label()</code>. If you know you have quoted a simple variable
name, or would like to enforce this, use <code>as_name()</code>.
</p>
</li></ul>

<p>To learn more about tidy eval and how to use these tools, visit
<a href="https://tidyeval.tidyverse.org">https://tidyeval.tidyverse.org</a> and the
<a href="https://adv-r.hadley.nz/metaprogramming.html">Metaprogramming
section</a> of <a href="https://adv-r.hadley.nz">Advanced R</a>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
