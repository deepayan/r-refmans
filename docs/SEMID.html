<!DOCTYPE html><html lang="en"><head><title>Help for package SEMID</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SEMID}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SEMID-package'><p>SEMID package documentation.</p></a></li>
<li><a href='#ancestors'><p>All ancestors of a collection of nodes</p></a></li>
<li><a href='#ancestralID'><p>Determines which edges in a mixed graph are ancestralID-identifiable</p></a></li>
<li><a href='#ancestralIdentifyStep'><p>Perform one iteration of ancestral identification.</p></a></li>
<li><a href='#bidirectedComponents'><p>Get bidirected components of a mixed graph</p></a></li>
<li><a href='#children'><p>All children of a collection of nodes.</p></a></li>
<li><a href='#createAncestralIdentifier'><p>Create an ancestral identification function.</p></a></li>
<li><a href='#createEdgewiseIdentifier'><p>Create an edgewise identification function</p></a></li>
<li><a href='#createHtcIdentifier'><p>Create an htc identification function.</p></a></li>
<li><a href='#createIdentifierBaseCase'><p>Create an identifier base case</p></a></li>
<li><a href='#createLFHtcIdentifier'><p>Create a latent-factor half-trek critierion identification function.</p></a></li>
<li><a href='#createLFIdentifierBaseCase'><p>Create an latent identifier base case</p></a></li>
<li><a href='#createSimpleBiDirIdentifier'><p>Identify bidirected edges if all directed edges are identified</p></a></li>
<li><a href='#createTrekFlowGraph'><p>Helper function to create a flow graph.</p></a></li>
<li><a href='#createTrekSeparationIdentifier'><p>Create an trek separation identification function</p></a></li>
<li><a href='#createTrGraph'><p>Helper function to create a graph encoding trek reachable relationships.</p></a></li>
<li><a href='#descendants'><p>Get descendants of a collection of observed nodes</p></a></li>
<li><a href='#edgewiseID'><p>Determines which edges in a mixed graph are edgewiseID-identifiable</p></a></li>
<li><a href='#edgewiseIdentifyStep'><p>Perform one iteration of edgewise identification.</p></a></li>
<li><a href='#edgewiseTSID'><p>Determines which edges in a mixed graph are edgewiseID+TS identifiable</p></a></li>
<li><a href='#flowBetween'><p>Flow from one set of nodes to another.</p></a></li>
<li><a href='#FlowGraph'><p>Construct FlowGraph object</p></a></li>
<li><a href='#generalGenericID'><p>A general generic identification algorithm template.</p></a></li>
<li><a href='#getAncestors'><p>Get getAncestors of nodes in a graph.</p></a></li>
<li><a href='#getDescendants'><p>Get descendants of nodes in a graph.</p></a></li>
<li><a href='#getHalfTrekSystem'><p>Determines if a half-trek system exists in the mixed graph.</p></a></li>
<li><a href='#getMaxFlow'><p>Size of largest HT system Y satisfying the HTC for a node v except perhaps</p>
having |getParents(v)| &lt; |Y|.</a></li>
<li><a href='#getMixedCompForNode'><p>Get the mixed component of a node in a mixed subgraph.</p></a></li>
<li><a href='#getMixedGraph'><p>Get the corresponding mixed graph</p></a></li>
<li><a href='#getParents'><p>Get getParents of nodes in a graph.</p></a></li>
<li><a href='#getSiblings'><p>Get getSiblings of nodes in a graph.</p></a></li>
<li><a href='#getTrekSystem'><p>Determines if a trek system exists in the mixed graph.</p></a></li>
<li><a href='#globalID'><p>Determines whether a mixed graph is globally identifiable.</p></a></li>
<li><a href='#graphID'><p>Identifiability of linear structural equation models.</p></a></li>
<li><a href='#graphID.ancestralID'><p>Determine generic identifiability of an acyclic mixed graph using ancestral</p>
decomposition.</a></li>
<li><a href='#graphID.decompose'><p>Determine generic identifiability by Tian Decomposition and HTC</p></a></li>
<li><a href='#graphID.genericID'><p>Determine generic identifiability of a mixed graph.</p></a></li>
<li><a href='#graphID.htcID'><p>Determines if a mixed graph is HTC-identifiable.</p></a></li>
<li><a href='#graphID.main'><p>Helper function to handle a graph component.</p></a></li>
<li><a href='#graphID.nonHtcID'><p>Check for generic infinite-to-one via the half-trek criterion.</p></a></li>
<li><a href='#htcID'><p>Determines which edges in a mixed graph are HTC-identifiable.</p></a></li>
<li><a href='#htcIdentifyStep'><p>Perform one iteration of HTC identification.</p></a></li>
<li><a href='#htr'><p>Get all HTR nodes from a set of nodes in a graph.</p></a></li>
<li><a href='#htrFrom'><p>Half trek reachable nodes.</p></a></li>
<li><a href='#inducedSubgraph'><p>Get the induced subgraph on a collection of nodes</p></a></li>
<li><a href='#isSibling'><p>Are two nodes siblings?</p></a></li>
<li><a href='#L'><p>Get directed adjacency matrix.</p></a></li>
<li><a href='#LatentDigraph'><p>Construct a LatentDigraph object</p></a></li>
<li><a href='#LatentDigraphFixedOrder'><p>Construct LatentDigraphFixedOrder object</p></a></li>
<li><a href='#latentDigraphHasSimpleNumbering'><p>Checks that a LatentDigraph has appropriate node numbering</p></a></li>
<li><a href='#latentNodes'><p>Get all latent nodes in the graph.</p></a></li>
<li><a href='#lfhtcID'><p>Determines which edges in a latent digraph are LF-HTC-identifiable.</p></a></li>
<li><a href='#lfhtcIdentifyStep'><p>Perform one iteration of latent-factor HTC identification.</p></a></li>
<li><a href='#MixedGraph'><p>Construct MixedGraph object</p></a></li>
<li><a href='#mixedGraphHasSimpleNumbering'><p>Checks that a MixedGraph has appropriate node numbering</p></a></li>
<li><a href='#nodes'><p>Get all nodes in the graph.</p></a></li>
<li><a href='#numLatents'><p>Number of latent nodes in the graph.</p></a></li>
<li><a href='#numNodes'><p>Number of nodes in the graph.</p></a></li>
<li><a href='#numObserved'><p>Number of observed nodes in the graph.</p></a></li>
<li><a href='#O'><p>Get adjacency matrix for bidirected part.</p></a></li>
<li><a href='#observedNodes'><p>Get all observed nodes in the graph.</p></a></li>
<li><a href='#observedParents'><p>Get the observed parents on a collection of nodes</p></a></li>
<li><a href='#parents'><p>All parents of a collection of nodes.</p></a></li>
<li><a href='#plot.LatentDigraph'><p>Plots the latent digraph</p></a></li>
<li><a href='#plotLatentDigraph'><p>Plot a latent factor graph</p></a></li>
<li><a href='#plotMixedGraph'><p>Plot a mixed graph</p></a></li>
<li><a href='#print.GenericIDResult'><p>Prints a GenericIDResult object</p></a></li>
<li><a href='#print.LfhtcIDResult'><p>Prints a LfhtcIDResult object</p></a></li>
<li><a href='#print.SEMIDResult'><p>Prints a SEMIDResult object</p></a></li>
<li><a href='#semID'><p>Identifiability of linear structural equation models.</p></a></li>
<li><a href='#siblings'><p>All siblings of a collection of nodes</p></a></li>
<li><a href='#stronglyConnectedComponent'><p>Strongly connected component</p></a></li>
<li><a href='#subsetsOfSize'><p>Returns all subsets of a certain size</p></a></li>
<li><a href='#tianComponent'><p>Returns the Tian c-component of a node</p></a></li>
<li><a href='#tianDecompose'><p>Performs the tian decomposition on the mixed graph</p></a></li>
<li><a href='#tianIdentifier'><p>Identifies components in a tian decomposition</p></a></li>
<li><a href='#tianSigmaForComponent'><p>Globally identify the covariance matrix of a C-component</p></a></li>
<li><a href='#toEx'><p>Transforms a vector of node indices in the internal rep. into external numbering</p></a></li>
<li><a href='#toIn'><p>Transforms a vector of given node indices into their internal numbering</p></a></li>
<li><a href='#trekSeparationIdentifyStep'><p>Perform one iteration of trek separation identification.</p></a></li>
<li><a href='#trFrom'><p>Trek reachable nodes.</p></a></li>
<li><a href='#updateEdgeCapacities'><p>Update edge capacities.</p></a></li>
<li><a href='#updateVertexCapacities'><p>Update vertex capacities.</p></a></li>
<li><a href='#validateLatentNodesAreSources'><p>A helper function to validate that latent nodes in a LatentDigraph are sources.</p></a></li>
<li><a href='#validateMatrices'><p>A helper function to validate input matrices.</p></a></li>
<li><a href='#validateMatrix'><p>A helper function to validate an input matrix.</p></a></li>
<li><a href='#validateNodes'><p>A helper function to validate if input nodes are valid.</p></a></li>
<li><a href='#validateVarArgsEmpty'><p>A helper function to validate that there are no variable arguments</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Identifiability of Linear Structural Equation Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-07-19</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nils Sturma &lt;nils.sturma@tum.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides routines to check identifiability or non-identifiability
    of linear structural equation models as described in Drton, Foygel, and
    Sullivant (2011) &lt;<a href="https://doi.org/10.1214%2F10-AOS859">doi:10.1214/10-AOS859</a>&gt;, Foygel, Draisma, and Drton (2012) 
    &lt;<a href="https://doi.org/10.1214%2F12-AOS1012">doi:10.1214/12-AOS1012</a>&gt;, and other works. The routines are based on the graphical 
    representation of structural equation models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Lucaweihs/SEMID">https://github.com/Lucaweihs/SEMID</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Lucaweihs/SEMID/issues">https://github.com/Lucaweihs/SEMID/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>R.oo (&ge; 1.20.0), R.methodsS3, igraph (&ge; 1.0.1), R.utils (&ge;
2.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-19 12:11:35 UTC; nilssturma</td>
</tr>
<tr>
<td>Author:</td>
<td>Rina Foygel Barber [aut],
  Mathias Drton [aut],
  Luca Weihs [aut],
  Nils Sturma [cre, aut]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-19 14:00:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='SEMID-package'>SEMID package documentation.</h2><span id='topic+SEMID-package'></span><span id='topic+SEMID'></span>

<h3>Description</h3>

<p>SEMID provides a number of methods for testing the global/generic
identifiability of mixed graphs and latent-factor graphs.
</p>


<h3>Details</h3>

<p>The only functions you're likely to need from <span class="pkg">SEMID</span> are
<code><a href="#topic+semID">semID</a></code> and <code><a href="#topic+lfhtcID">lfhtcID</a></code>. A complete description of all package features, along
with examples, can be found at <a href="https://github.com/Lucaweihs/SEMID">https://github.com/Lucaweihs/SEMID</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###
# Checking the generic identifiability of parameters in a mixed graph.
###

# Mixed graphs are specified by their directed adjacency matrix L and
# bidirected adjacency matrix O.
L = t(matrix(
 c(0, 1, 1, 0, 0,
   0, 0, 1, 1, 1,
   0, 0, 0, 1, 0,
   0, 0, 0, 0, 1,
   0, 0, 0, 0, 0), 5, 5))

O = t(matrix(
 c(0, 0, 0, 1, 0,
   0, 0, 1, 0, 1,
   0, 0, 0, 0, 0,
   0, 0, 0, 0, 0,
   0, 0, 0, 0, 0), 5, 5)); O=O+t(O)

# Create a mixed graph object
graph = MixedGraph(L, O)

# We can plot what this mixed graph looks like, blue edges are directed
# red edges are bidirected.
plot(graph)

# Without using decomposition techniques we can't identify all nodes
# just using the half-trek criterion
htcID(graph, tianDecompose = FALSE)

# The edgewiseTSID function can show that all edges are generically
# identifiable without proprocessing with decomposition techniques
edgewiseTSID(graph, tianDecompose = FALSE)

# The above shows that all edges in the graph are generically identifiable.
# See the help of edgewiseTSID to find out more information about what
# else is returned by edgewiseTSID.

###
# Checking generic parameter identifiability using the generalGenericID
# function
###

L = t(matrix(
 c(0, 1, 0, 0, 0,
   0, 0, 0, 1, 1,
   0, 0, 0, 1, 0,
   0, 1, 0, 0, 1,
   0, 0, 0, 1, 0), 5, 5))

O = t(matrix(
 c(0, 0, 0, 0, 0,
   0, 0, 1, 0, 1,
   0, 0, 0, 1, 0,
   0, 0, 0, 0, 0,
   0, 0, 0, 0, 0), 5, 5)); O=O+t(O)

# Create a mixed graph object
graph = MixedGraph(L, O)

# Now lets define an "identification step" function corresponding to
# using the edgewise identification algorithm but with subsets
# controlled by 1.
restrictedEdgewiseIdentifyStep &lt;- function(mixedGraph,
                                            unsolvedParents,
                                            solvedParents,
                                            identifier) {
     return(edgewiseIdentifyStep(mixedGraph, unsolvedParents,
                                 solvedParents, identifier,
                                 subsetSizeControl = 1))
}

# Now we run an identification algorithm that iterates between the
# htc and the "restricted" edgewise identification algorithm
generalGenericID(graph, list(htcIdentifyStep,
                               restrictedEdgewiseIdentifyStep),
	                 tianDecompose = FALSE)

# We can do better (fewer unsolved parents) if we don't restrict the edgewise
# identifier algorithm as much
generalGenericID(graph, list(htcIdentifyStep, edgewiseIdentifyStep),
                  tianDecompose = FALSE)

###
# Checking the generic identifiability of parameters in a latent-factor graph.
###

# Latent digraphs are specified by their directed adjacency matrix L
library(SEMID)
L = matrix(c(0, 1, 0, 0, 0, 0,
             0, 0, 1, 0, 0, 0,
             0, 0, 0, 0, 0, 0,
             0, 0, 0, 0, 1, 0,
             0, 0, 0, 0, 0, 0,
             1, 1, 1, 1, 1, 0), 6, 6, byrow=TRUE)
observedNodes = seq(1,5)
latentNodes = c(6)

# Create the latent digraph object corresponding to L
g = LatentDigraph(L, observedNodes, latentNodes)

# Plot latent digraph
plot(g)

# We can identify all nodes by the latent-factor half-trek criterion
lfhtcID(g)

</code></pre>

<hr>
<h2 id='ancestors'>All ancestors of a collection of nodes</h2><span id='topic+ancestors'></span><span id='topic+ancestors.LatentDigraphFixedOrder'></span><span id='topic+ancestors.LatentDigraph'></span><span id='topic+ancestors.MixedGraph'></span>

<h3>Description</h3>

<p>Finds all the ancestors of a collection of nodes. These ancestors DO
include the nodes themselves (every node is considered an ancestor of itself).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ancestors(this, nodes, ...)

## S3 method for class 'LatentDigraphFixedOrder'
ancestors(this, nodes, includeObserved = T, includeLatents = T, ...)

## S3 method for class 'LatentDigraph'
ancestors(this, nodes, includeObserved = T, includeLatents = T, ...)

## S3 method for class 'MixedGraph'
ancestors(this, nodes, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ancestors_+3A_this">this</code></td>
<td>
<p>the graph object</p>
</td></tr>
<tr><td><code id="ancestors_+3A_nodes">nodes</code></td>
<td>
<p>the nodes from which to find all ancestors</p>
</td></tr>
<tr><td><code id="ancestors_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="ancestors_+3A_includeobserved">includeObserved</code></td>
<td>
<p>if TRUE includes observed nodes in the returned set.</p>
</td></tr>
<tr><td><code id="ancestors_+3A_includelatents">includeLatents</code></td>
<td>
<p>if TRUE includes latent nodes in the returned set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the ancestors of the nodes in the observed part of the graph.
</p>

<hr>
<h2 id='ancestralID'>Determines which edges in a mixed graph are ancestralID-identifiable</h2><span id='topic+ancestralID'></span>

<h3>Description</h3>

<p>Uses the an identification criterion of Drton and Weihs (2015); this version
of the algorithm is somewhat different from Drton and Weihs (2015) in that it
also works on cyclic graphs. The original version of the algorithm can be
found in the function <code><a href="#topic+graphID.ancestralID">graphID.ancestralID</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ancestralID(mixedGraph, tianDecompose = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ancestralID_+3A_mixedgraph">mixedGraph</code></td>
<td>
<p>a <code><a href="#topic+MixedGraph">MixedGraph</a></code> object representing the L-SEM.</p>
</td></tr>
<tr><td><code id="ancestralID_+3A_tiandecompose">tianDecompose</code></td>
<td>
<p>TRUE or FALSE determining whether or not the Tian
decomposition should be used before running the
current generic identification algorithm. In general
letting this be TRUE will make the algorithm faster and
more powerful.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>see the return of <code><a href="#topic+generalGenericID">generalGenericID</a></code>.
</p>

<hr>
<h2 id='ancestralIdentifyStep'>Perform one iteration of ancestral identification.</h2><span id='topic+ancestralIdentifyStep'></span>

<h3>Description</h3>

<p>A function that does one step through all the nodes in a mixed graph
and tries to determine if directed edge coefficients are generically
identifiable by leveraging decomposition by ancestral subsets. See
Algorithm 1 of Drton and Weihs (2015); this version of the algorithm
is somewhat different from Drton and Weihs (2015) in that it also works
on cyclic graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ancestralIdentifyStep(mixedGraph, unsolvedParents, solvedParents, identifier)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ancestralIdentifyStep_+3A_mixedgraph">mixedGraph</code></td>
<td>
<p>a <code><a href="#topic+MixedGraph">MixedGraph</a></code> object representing
the mixed graph.</p>
</td></tr>
<tr><td><code id="ancestralIdentifyStep_+3A_unsolvedparents">unsolvedParents</code></td>
<td>
<p>a list whose ith index is a vector of all the parents
j of i in G which for which the edge j-&gt;i is not yet known to be
generically identifiable.</p>
</td></tr>
<tr><td><code id="ancestralIdentifyStep_+3A_solvedparents">solvedParents</code></td>
<td>
<p>the complement of <code>unsolvedParents</code>, a list whose
ith index is a vector of all parents j of i for which the edge i-&gt;j
is known to be generically identifiable (perhaps by other algorithms).</p>
</td></tr>
<tr><td><code id="ancestralIdentifyStep_+3A_identifier">identifier</code></td>
<td>
<p>an identification function that must produce the
identifications corresponding to those in solved parents. That is
<code>identifier</code> should be a function taking a single argument Sigma
(any generically generated covariance matrix corresponding
to the mixed graph) and returns a list with two named arguments
</p>

<dl>
<dt>Lambda</dt><dd><p>denote the number of nodes in <code>mixedGraph</code> as n. Then
Lambda is an nxn matrix whose i,jth entry
</p>

<ol>
<li><p> equals 0 if i is not a parent of j,
</p>
</li>
<li><p> equals NA if i is a parent of j but <code>identifier</code> cannot
identify it generically,
</p>
</li>
<li><p> equals the (generically) unique value corresponding to the weight
along the edge i-&gt;j that was used to produce Sigma.
</p>
</li></ol>
</dd>
<dt>Omega</dt><dd><p>just as Lambda but for the bidirected edges in the mixed
graph</p>
</dd>
</dl>

<p>such that if j is in <code>solvedParents[[i]]</code> we must have that
Lambda[j,i] is not NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with four components:
</p>

<dl>
<dt><code>identifiedEdges</code></dt><dd><p>a matrix rx2 matrix where r is the number
of edges that where identified by this function call and
<code>identifiedEdges[i,1] -&gt; identifiedEdges[i,2]</code> was the ith edge
identified</p>
</dd>
<dt><code>unsolvedParents</code></dt><dd><p>as the input argument but updated with
any newly identified edges</p>
</dd>
<dt><code>solvedParents</code></dt><dd><p>as the input argument but updated with
any newly identified edges</p>
</dd>
<dt><code>identifier</code></dt><dd><p>as the input argument but updated with
any newly identified edges</p>
</dd>
</dl>



<h3>References</h3>

<p>Drton, M. and Weihs, L. (2015) Generic Identifiability of Linear
Structural Equation Models by Ancestor Decomposition. arXiv 1504.02992
</p>

<hr>
<h2 id='bidirectedComponents'>Get bidirected components of a mixed graph</h2><span id='topic+bidirectedComponents'></span>

<h3>Description</h3>

<p>Returns induced subgraphs of connected bidirected components with more than 1 node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bidirectedComponents(graph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bidirectedComponents_+3A_graph">graph</code></td>
<td>
<p>a <code><a href="#topic+MixedGraph">MixedGraph</a></code> object representing
the mixed graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list, where each object is a MixedGraph with at least two nodes.
</p>

<hr>
<h2 id='children'>All children of a collection of nodes.</h2><span id='topic+children'></span><span id='topic+children.LatentDigraphFixedOrder'></span><span id='topic+children.LatentDigraph'></span><span id='topic+children.MixedGraph'></span>

<h3>Description</h3>

<p>Returns all children of the collection (does not necessarily include the
input nodes themselves unless they are parents of one another).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>children(this, nodes, ...)

## S3 method for class 'LatentDigraphFixedOrder'
children(this, nodes, includeObserved = T, includeLatents = T, ...)

## S3 method for class 'LatentDigraph'
children(this, nodes, includeObserved = T, includeLatents = T, ...)

## S3 method for class 'MixedGraph'
children(this, nodes, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="children_+3A_this">this</code></td>
<td>
<p>the graph object.</p>
</td></tr>
<tr><td><code id="children_+3A_nodes">nodes</code></td>
<td>
<p>nodes the nodes of which to find the children</p>
</td></tr>
<tr><td><code id="children_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="children_+3A_includeobserved">includeObserved</code></td>
<td>
<p>if TRUE includes observed nodes in the returned set.</p>
</td></tr>
<tr><td><code id="children_+3A_includelatents">includeLatents</code></td>
<td>
<p>if TRUE includes latent nodes in the returned set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the observed children
</p>

<hr>
<h2 id='createAncestralIdentifier'>Create an ancestral identification function.</h2><span id='topic+createAncestralIdentifier'></span>

<h3>Description</h3>

<p>A helper function for <code><a href="#topic+ancestralIdentifyStep">ancestralIdentifyStep</a></code>, creates an identifier function
based on its given parameters. This created identifier function will
identify the directed edges from 'targets' to 'node.'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createAncestralIdentifier(
  idFunc,
  sources,
  targets,
  node,
  htrSources,
  ancestralSubset,
  cComponent
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createAncestralIdentifier_+3A_idfunc">idFunc</code></td>
<td>
<p>identification of edge coefficients often requires that other
edge coefficients already be identified. This argument should be a
function that produces all such identifications. The newly created
identifier function will return these identifications along with its
own.</p>
</td></tr>
<tr><td><code id="createAncestralIdentifier_+3A_sources">sources</code></td>
<td>
<p>the sources of the half-trek system.</p>
</td></tr>
<tr><td><code id="createAncestralIdentifier_+3A_targets">targets</code></td>
<td>
<p>the targets of the half-trek system (these should be the
parents of <code>node</code>).</p>
</td></tr>
<tr><td><code id="createAncestralIdentifier_+3A_node">node</code></td>
<td>
<p>the node for which all incoming edges are to be identified
(the tails of which are targets).</p>
</td></tr>
<tr><td><code id="createAncestralIdentifier_+3A_htrsources">htrSources</code></td>
<td>
<p>the nodes in sources which are half-trek reachable from
<code>node</code>. All incoming edges to these sources should be identified by
<code>idFunc</code> for the newly created identification function to work.</p>
</td></tr>
<tr><td><code id="createAncestralIdentifier_+3A_ancestralsubset">ancestralSubset</code></td>
<td>
<p>an ancestral subset of the graph containing <code>node</code>.</p>
</td></tr>
<tr><td><code id="createAncestralIdentifier_+3A_ccomponent">cComponent</code></td>
<td>
<p>a list corresponding to the connected component containing <code>node</code>
in the subgraph induced by <code>ancestralSubset</code>. See
<code><a href="#topic+tianDecompose">tianDecompose</a></code> for how such connected component lists are formed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an identification function
</p>

<hr>
<h2 id='createEdgewiseIdentifier'>Create an edgewise identification function</h2><span id='topic+createEdgewiseIdentifier'></span>

<h3>Description</h3>

<p>A helper function for <code><a href="#topic+edgewiseIdentifyStep">edgewiseIdentifyStep</a></code>, creates an
identifier function based on its given parameters. This created identifier
function will identify the directed edges from 'targets' to 'node.'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createEdgewiseIdentifier(
  idFunc,
  sources,
  targets,
  node,
  solvedNodeParents,
  sourceParentsToRemove
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createEdgewiseIdentifier_+3A_idfunc">idFunc</code></td>
<td>
<p>identification of edge coefficients often requires that other
edge coefficients already be identified. This argument should be a
function that produces all such identifications. The newly created
identifier function will return these identifications along with its
own.</p>
</td></tr>
<tr><td><code id="createEdgewiseIdentifier_+3A_sources">sources</code></td>
<td>
<p>the sources of the half-trek system.</p>
</td></tr>
<tr><td><code id="createEdgewiseIdentifier_+3A_targets">targets</code></td>
<td>
<p>the targets of the half-trek system (these should be the
parents of <code>node</code>).</p>
</td></tr>
<tr><td><code id="createEdgewiseIdentifier_+3A_node">node</code></td>
<td>
<p>the node for which all incoming edges are to be identified
(the tails of which are targets).</p>
</td></tr>
<tr><td><code id="createEdgewiseIdentifier_+3A_solvednodeparents">solvedNodeParents</code></td>
<td>
<p>the parents of node that have been solved</p>
</td></tr>
<tr><td><code id="createEdgewiseIdentifier_+3A_sourceparentstoremove">sourceParentsToRemove</code></td>
<td>
<p>a list of the parents of the sources that should
have their edge to their respect source removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an identification function
</p>

<hr>
<h2 id='createHtcIdentifier'>Create an htc identification function.</h2><span id='topic+createHtcIdentifier'></span>

<h3>Description</h3>

<p>A helper function for <code><a href="#topic+htcIdentifyStep">htcIdentifyStep</a></code>, creates an identifier
function based on its given parameters. This created identifier function will
identify the directed edges from 'targets' to 'node.'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createHtcIdentifier(idFunc, sources, targets, node, htrSources)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createHtcIdentifier_+3A_idfunc">idFunc</code></td>
<td>
<p>identification of edge coefficients often requires that other
edge coefficients already be identified. This argument should be a
function that produces all such identifications. The newly created
identifier function will return these identifications along with its
own.</p>
</td></tr>
<tr><td><code id="createHtcIdentifier_+3A_sources">sources</code></td>
<td>
<p>the sources of the half-trek system.</p>
</td></tr>
<tr><td><code id="createHtcIdentifier_+3A_targets">targets</code></td>
<td>
<p>the targets of the half-trek system (these should be the
parents of <code>node</code>).</p>
</td></tr>
<tr><td><code id="createHtcIdentifier_+3A_node">node</code></td>
<td>
<p>the node for which all incoming edges are to be identified
(the tails of which are targets).</p>
</td></tr>
<tr><td><code id="createHtcIdentifier_+3A_htrsources">htrSources</code></td>
<td>
<p>the nodes in sources which are half-trek reachable from
<code>node</code>. All incoming edges to these sources should be identified by
<code>idFunc</code> for the newly created identification function to work.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an identification function
</p>


<h3>References</h3>

<p>Foygel, R., Draisma, J., and Drton, M.  (2012) Half-trek criterion for
generic identifiability of linear structural equation models.
<em>Ann. Statist.</em> 40(3): 1682-1713.
</p>

<hr>
<h2 id='createIdentifierBaseCase'>Create an identifier base case</h2><span id='topic+createIdentifierBaseCase'></span>

<h3>Description</h3>

<p>Identifiers are functions that take as input a covariance matrix Sigma
corresponding to some mixed graph <code>G</code> and, from that covariance matrix,
identify some subset of the coefficients in the mixed graph <code>G</code>. This function
takes as input the matrices, <code>L</code> and <code>O</code>, defining <code>G</code> and creates an identifier
that does not identify any of the coefficients of <code>G</code>. This is useful as a
base case when building more complex identification functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createIdentifierBaseCase(L, O)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createIdentifierBaseCase_+3A_l">L</code></td>
<td>
<p>Adjacency matrix for the directed part of the path
diagram/mixed graph; an edge pointing from i to j is encoded as L[i,j]=1 and
the lack of an edge between i and j is encoded as L[i,j]=0. There should be
no directed self loops, i.e. no i such that L[i,i]=1.</p>
</td></tr>
<tr><td><code id="createIdentifierBaseCase_+3A_o">O</code></td>
<td>
<p>Adjacency matrix for the bidirected part of the path diagram/mixed
graph. Edges are encoded as for the L parameter. Again there should be no
self loops. Also this matrix will be coerced to be symmetric so it is only
necessary to specify an edge once, i.e. if O[i,j]=1 you may, but are not
required to, also have O[j,i]=1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that takes as input a covariance matrix compatible with
the mixed graph defined by <code>L</code>/<code>O</code> and returns a list with two
named components:
</p>

<dl>
<dt><code>Lambda</code></dt><dd><p>a matrix equal to <code>L</code> but with <code>NA</code> values instead of <code>1</code>s</p>
</dd>
<dt><code>Omega</code></dt><dd><p>a matrix equal to <code>O</code> but with <code>NA</code> values instead of <code>1</code>s</p>
</dd>
</dl>

<p>When building more complex identifiers these NAs will be replaced by the value that can be identified from Sigma.
</p>

<hr>
<h2 id='createLFHtcIdentifier'>Create a latent-factor half-trek critierion identification function.</h2><span id='topic+createLFHtcIdentifier'></span>

<h3>Description</h3>

<p>A helper function for <code><a href="#topic+lfhtcIdentifyStep">lfhtcIdentifyStep</a></code>, creates an identifier
function based on its given parameters. This created identifier function will
identify the directed edges from 'targets' to 'node.'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createLFHtcIdentifier(idFunc, v, Y, Z, parents, reachableY)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createLFHtcIdentifier_+3A_idfunc">idFunc</code></td>
<td>
<p>identification of edge coefficients often requires that other
edge coefficients already be identified. This argument should be a
function that produces all such identifications. The newly created
identifier function will return these identifications along with its
own.</p>
</td></tr>
<tr><td><code id="createLFHtcIdentifier_+3A_v">v</code></td>
<td>
<p>the node for which all incoming edges are to be identified
(the tails of which are targets).</p>
</td></tr>
<tr><td><code id="createLFHtcIdentifier_+3A_y">Y</code></td>
<td>
<p>the sources of the latent-factor half-trek system.</p>
</td></tr>
<tr><td><code id="createLFHtcIdentifier_+3A_z">Z</code></td>
<td>
<p>the nodes that are reached from Y via an latent-factor half-trek of the form
<code>y &lt;- h -&gt; z</code> where <code>h</code> is an element of L.</p>
</td></tr>
<tr><td><code id="createLFHtcIdentifier_+3A_parents">parents</code></td>
<td>
<p>the parents of node v.</p>
</td></tr>
<tr><td><code id="createLFHtcIdentifier_+3A_reachabley">reachableY</code></td>
<td>
<p>the nodes in Y which are latent-factor half-trek reachable
from Z or v  by avoiding the nodes in L. All incoming edges to these
nodes should be identified by idFunc the newly created identification function to work.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an identification function
</p>


<h3>References</h3>

<p>Barber, R. F., Drton, M., Sturma, N., and Weihs L. (2022).
Half-Trek Criterion for Identifiability of Latent Variable Models.
<em>arXiv preprint</em> arXiv:2201.04457
</p>

<hr>
<h2 id='createLFIdentifierBaseCase'>Create an latent identifier base case</h2><span id='topic+createLFIdentifierBaseCase'></span>

<h3>Description</h3>

<p>Identifiers are functions that take as input a covariance matrix Sigma
corresponding to some latent digraph <code>G</code> and, from that covariance matrix,
identify some subset of the coefficients coresponding to the direct causal effects
in the latent digraph <code>G</code>. This function
takes as input the digraph <code>G</code> and creates an identifier
that does not identify any of the direct causal effects. This is useful as a
base case when building more complex identification functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createLFIdentifierBaseCase(graph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createLFIdentifierBaseCase_+3A_graph">graph</code></td>
<td>
<p>a <code><a href="#topic+LatentDigraph">LatentDigraph</a></code> object representing
the latent-factor graph. All latent nodes in this graph should be
source nodes (i.e. have no parents).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that takes as input a covariance matrix compatible with
the latent digraph defined by <code>L</code> and returns a list with two
named components:
</p>

<dl>
<dt><code>Lambda</code></dt><dd><p>a matrix equal to the observed part of <code>graph$L()</code> but with <code>NA</code> values
instead of 1s</p>
</dd>
<dt><code>Omega</code></dt><dd><p>a matrix equal to <code>graph$O()</code> but with <code>NA</code> values for coefficients
not equal to zero.</p>
</dd>
</dl>

<p>When building more complex identifiers these NAs will be replaced
by the value that can be identified from the covariance matrix corresponding to <code>G</code>.
</p>

<hr>
<h2 id='createSimpleBiDirIdentifier'>Identify bidirected edges if all directed edges are identified</h2><span id='topic+createSimpleBiDirIdentifier'></span>

<h3>Description</h3>

<p>Creates an identifier function that assumes that all directed edges have
already been identified and then is able to identify all bidirected edges
simultaneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createSimpleBiDirIdentifier(idFunc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createSimpleBiDirIdentifier_+3A_idfunc">idFunc</code></td>
<td>
<p>an identifier function that identifies all directed edges</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new identifier function that identifies everything.
</p>

<hr>
<h2 id='createTrekFlowGraph'>Helper function to create a flow graph.</h2><span id='topic+createTrekFlowGraph'></span><span id='topic+createTrekFlowGraph.LatentDigraphFixedOrder'></span>

<h3>Description</h3>

<p>Helper function to create a flow graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTrekFlowGraph(this, ...)

## S3 method for class 'LatentDigraphFixedOrder'
createTrekFlowGraph(this, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createTrekFlowGraph_+3A_this">this</code></td>
<td>
<p>the graph object</p>
</td></tr>
<tr><td><code id="createTrekFlowGraph_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='createTrekSeparationIdentifier'>Create an trek separation identification function</h2><span id='topic+createTrekSeparationIdentifier'></span>

<h3>Description</h3>

<p>A helper function for <code><a href="#topic+trekSeparationIdentifyStep">trekSeparationIdentifyStep</a></code>, creates an
identifier function based on its given parameters. This created identifier
function will identify the directed edge from 'parent' to 'node.'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTrekSeparationIdentifier(
  idFunc,
  sources,
  targets,
  node,
  parent,
  solvedParents
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createTrekSeparationIdentifier_+3A_idfunc">idFunc</code></td>
<td>
<p>identification of edge coefficients often requires that other
edge coefficients already be identified. This argument should be a
function that produces all such identifications. The newly created
identifier function will return these identifications along with its
own.</p>
</td></tr>
<tr><td><code id="createTrekSeparationIdentifier_+3A_sources">sources</code></td>
<td>
<p>the sources of the half-trek system.</p>
</td></tr>
<tr><td><code id="createTrekSeparationIdentifier_+3A_targets">targets</code></td>
<td>
<p>the targets of the half-trek system (these should be the
parents of <code>node</code>).</p>
</td></tr>
<tr><td><code id="createTrekSeparationIdentifier_+3A_node">node</code></td>
<td>
<p>the node for which all incoming edges are to be identified
(the tails of which are targets).</p>
</td></tr>
<tr><td><code id="createTrekSeparationIdentifier_+3A_parent">parent</code></td>
<td>
<p>the parent of node for which the edge node -&gt; parent should
be generically identified.</p>
</td></tr>
<tr><td><code id="createTrekSeparationIdentifier_+3A_solvedparents">solvedParents</code></td>
<td>
<p>the parents of node that have been solved</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an identification function
</p>

<hr>
<h2 id='createTrGraph'>Helper function to create a graph encoding trek reachable relationships.</h2><span id='topic+createTrGraph'></span><span id='topic+createTrGraph.LatentDigraphFixedOrder'></span>

<h3>Description</h3>

<p>Helper function to create a graph encoding trek reachable relationships.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTrGraph(this, ...)

## S3 method for class 'LatentDigraphFixedOrder'
createTrGraph(this, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createTrGraph_+3A_this">this</code></td>
<td>
<p>the graph object</p>
</td></tr>
<tr><td><code id="createTrGraph_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='descendants'>Get descendants of a collection of observed nodes</h2><span id='topic+descendants'></span><span id='topic+descendants.LatentDigraphFixedOrder'></span><span id='topic+descendants.LatentDigraph'></span><span id='topic+descendants.MixedGraph'></span>

<h3>Description</h3>

<p>Finds all descendants of a collection of nodes, this DOES include the nodes
themselves (every node is considered a descendant of itself).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>descendants(this, nodes, ...)

## S3 method for class 'LatentDigraphFixedOrder'
descendants(this, nodes, includeObserved = T, includeLatents = T, ...)

## S3 method for class 'LatentDigraph'
descendants(this, nodes, includeObserved = T, includeLatents = T, ...)

## S3 method for class 'MixedGraph'
descendants(this, nodes, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="descendants_+3A_this">this</code></td>
<td>
<p>the graph object</p>
</td></tr>
<tr><td><code id="descendants_+3A_nodes">nodes</code></td>
<td>
<p>the nodes from which to get the descendants.</p>
</td></tr>
<tr><td><code id="descendants_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="descendants_+3A_includeobserved">includeObserved</code></td>
<td>
<p>if TRUE includes observed nodes in the returned set.</p>
</td></tr>
<tr><td><code id="descendants_+3A_includelatents">includeLatents</code></td>
<td>
<p>if TRUE includes latent nodes in the returned set.</p>
</td></tr>
</table>

<hr>
<h2 id='edgewiseID'>Determines which edges in a mixed graph are edgewiseID-identifiable</h2><span id='topic+edgewiseID'></span>

<h3>Description</h3>

<p>Uses the edgewise identification criterion of Weihs, Robeva, Robinson, et al.
(2017) to determine which edges in a mixed graph are generically
identifiable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgewiseID(mixedGraph, tianDecompose = T, subsetSizeControl = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edgewiseID_+3A_mixedgraph">mixedGraph</code></td>
<td>
<p>a <code><a href="#topic+MixedGraph">MixedGraph</a></code> object representing the L-SEM.</p>
</td></tr>
<tr><td><code id="edgewiseID_+3A_tiandecompose">tianDecompose</code></td>
<td>
<p>TRUE or FALSE determining whether or not the Tian
decomposition should be used before running the
current generic identification algorithm. In general
letting this be TRUE will make the algorithm faster and
more powerful.</p>
</td></tr>
<tr><td><code id="edgewiseID_+3A_subsetsizecontrol">subsetSizeControl</code></td>
<td>
<p>a positive integer (Inf allowed) which controls
the size of edgesets searched in the edgewiseID
algorithm. Suppose, for example, this has value 3.
Then if a node i has n parents, this will restrict
the algorithm to only look at subsets of the parents
of size 1,2,3 and n-2, n-1, n. Making this
parameter smaller means the algorithm will be faster
but less exhaustive (and hence less powerful).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>see the return of <code><a href="#topic+generalGenericID">generalGenericID</a></code>.
</p>

<hr>
<h2 id='edgewiseIdentifyStep'>Perform one iteration of edgewise identification.</h2><span id='topic+edgewiseIdentifyStep'></span>

<h3>Description</h3>

<p>A function that does one step through all the nodes in a mixed graph
and tries to identify new edge coefficients using the existence of
half-trek systems as described in Weihs, Robeva, Robinson, et al. (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgewiseIdentifyStep(
  mixedGraph,
  unsolvedParents,
  solvedParents,
  identifier,
  subsetSizeControl = Inf
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edgewiseIdentifyStep_+3A_mixedgraph">mixedGraph</code></td>
<td>
<p>a <code><a href="#topic+MixedGraph">MixedGraph</a></code> object representing
the mixed graph.</p>
</td></tr>
<tr><td><code id="edgewiseIdentifyStep_+3A_unsolvedparents">unsolvedParents</code></td>
<td>
<p>a list whose ith index is a vector of all the parents
j of i in G which for which the edge j-&gt;i is not yet known to be
generically identifiable.</p>
</td></tr>
<tr><td><code id="edgewiseIdentifyStep_+3A_solvedparents">solvedParents</code></td>
<td>
<p>the complement of <code>unsolvedParents</code>, a list whose
ith index is a vector of all parents j of i for which the edge i-&gt;j
is known to be generically identifiable (perhaps by other algorithms).</p>
</td></tr>
<tr><td><code id="edgewiseIdentifyStep_+3A_identifier">identifier</code></td>
<td>
<p>an identification function that must produce the
identifications corresponding to those in solved parents. That is
<code>identifier</code> should be a function taking a single argument Sigma
(any generically generated covariance matrix corresponding
to the mixed graph) and returns a list with two named arguments
</p>

<dl>
<dt>Lambda</dt><dd><p>denote the number of nodes in <code>mixedGraph</code> as n. Then
Lambda is an nxn matrix whose i,jth entry
</p>

<ol>
<li><p> equals 0 if i is not a parent of j,
</p>
</li>
<li><p> equals NA if i is a parent of j but <code>identifier</code> cannot
identify it generically,
</p>
</li>
<li><p> equals the (generically) unique value corresponding to the weight
along the edge i-&gt;j that was used to produce Sigma.
</p>
</li></ol>
</dd>
<dt>Omega</dt><dd><p>just as Lambda but for the bidirected edges in the mixed
graph</p>
</dd>
</dl>

<p>such that if j is in <code>solvedParents[[i]]</code> we must have that
Lambda[j,i] is not NA.</p>
</td></tr>
<tr><td><code id="edgewiseIdentifyStep_+3A_subsetsizecontrol">subsetSizeControl</code></td>
<td>
<p>a positive integer (Inf allowed) which controls
the size of edgesets searched in the edgewiseID
algorithm. Suppose, for example, this has value 3.
Then if a node i has n parents, this will restrict
the algorithm to only look at subsets of the parents
of size 1,2,3 and n-2, n-1, n. Making this
parameter smaller means the algorithm will be faster
but less exhaustive (and hence less powerful).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>see the return of <code><a href="#topic+htcIdentifyStep">htcIdentifyStep</a></code>.
</p>

<hr>
<h2 id='edgewiseTSID'>Determines which edges in a mixed graph are edgewiseID+TS identifiable</h2><span id='topic+edgewiseTSID'></span>

<h3>Description</h3>

<p>Uses the edgewise+TS identification criterion of Weihs, Robeva, Robinson, et
al. (2017) to determine which edges in a mixed graph are generically
identifiable. In particular this algorithm iterates between the half-trek,
edgewise, and trek-separation identification algorithms in an attempt to
identify as many edges as possible, this may be very slow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgewiseTSID(
  mixedGraph,
  tianDecompose = T,
  subsetSizeControl = 3,
  maxSubsetSize = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edgewiseTSID_+3A_mixedgraph">mixedGraph</code></td>
<td>
<p>a <code><a href="#topic+MixedGraph">MixedGraph</a></code> object representing the L-SEM.</p>
</td></tr>
<tr><td><code id="edgewiseTSID_+3A_tiandecompose">tianDecompose</code></td>
<td>
<p>TRUE or FALSE determining whether or not the Tian
decomposition should be used before running the
current generic identification algorithm. In general
letting this be TRUE will make the algorithm faster and
more powerful.</p>
</td></tr>
<tr><td><code id="edgewiseTSID_+3A_subsetsizecontrol">subsetSizeControl</code></td>
<td>
<p>a positive integer (Inf allowed) which controls
the size of edgesets searched in the edgewiseID
algorithm. Suppose, for example, this has value 3.
Then if a node i has n parents, this will restrict
the algorithm to only look at subsets of the parents
of size 1,2,3 and n-2, n-1, n. Making this
parameter smaller means the algorithm will be faster
but less exhaustive (and hence less powerful).</p>
</td></tr>
<tr><td><code id="edgewiseTSID_+3A_maxsubsetsize">maxSubsetSize</code></td>
<td>
<p>a positive integer which controls the maximum subset
size considered in the trek-separation identification
algorithm. Making this parameter smaller means the
algorithm will be faster but less exhaustive (and hence
less powerful).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>see the return of <code><a href="#topic+generalGenericID">generalGenericID</a></code>.
</p>

<hr>
<h2 id='flowBetween'>Flow from one set of nodes to another.</h2><span id='topic+flowBetween'></span><span id='topic+flowBetween.FlowGraph'></span>

<h3>Description</h3>

<p>Flow from one set of nodes to another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flowBetween(this, sources, sinks)

## S3 method for class 'FlowGraph'
flowBetween(this, sources, sinks)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flowBetween_+3A_this">this</code></td>
<td>
<p>the flow graph object</p>
</td></tr>
<tr><td><code id="flowBetween_+3A_sources">sources</code></td>
<td>
<p>the nodes from which flow should start.</p>
</td></tr>
<tr><td><code id="flowBetween_+3A_sinks">sinks</code></td>
<td>
<p>the nodes at which the flow should end.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two named components, <code>value</code> (the size of the
computed flow) and <code>activeSources</code> (a vector representing the
subset of sources which have non-zero flow out of them for the found
max-flow).
</p>

<hr>
<h2 id='FlowGraph'>Construct FlowGraph object</h2><span id='topic+FlowGraph'></span>

<h3>Description</h3>

<p>Creates an object representing a flow graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FlowGraph(L = matrix(0,1,1), vertexCaps = 1, edgeCaps = matrix(1,1,1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FlowGraph_+3A_l">L</code></td>
<td>
<p>the adjacency matrix for the flow graph. The (i,j)th of L should be
a 1 if there is an edge from i to j and 0 otherwise.</p>
</td></tr>
<tr><td><code id="FlowGraph_+3A_vertexcaps">vertexCaps</code></td>
<td>
<p>the capacity of the vertices in the flow graph, should
either be a single number or a vector whose ith entry is the capacity
of vertex i.</p>
</td></tr>
<tr><td><code id="FlowGraph_+3A_edgecaps">edgeCaps</code></td>
<td>
<p>the capacities of the edges in the the flow graph, should
be a matrix of the same dimensions as L with (i,j)th entry the
capacity of the i-&gt;j edge.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object representing the FlowGraph.
</p>

<hr>
<h2 id='generalGenericID'>A general generic identification algorithm template.</h2><span id='topic+generalGenericID'></span>

<h3>Description</h3>

<p>A function that encapsulates the general structure of our algorithms for
testing generic identifiability. Allows for various identification algorithms
to be used in concert, in particular it will use the identifier functions
in the list <code>idStepFunctions</code> sequentially until it can find no more
identifications. The step functions that are currently available for use
in <code>idStepFunctions</code> are
</p>

<ol>
<li><p> htcIdentifyStep,
</p>
</li>
<li><p> ancestralIdentifyStep,
</p>
</li>
<li><p> edgewiseIdentifyStep,
</p>
</li>
<li><p> trekSeparationIdentifyStep.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>generalGenericID(mixedGraph, idStepFunctions, tianDecompose = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generalGenericID_+3A_mixedgraph">mixedGraph</code></td>
<td>
<p>a <code><a href="#topic+MixedGraph">MixedGraph</a></code> object representing the L-SEM.</p>
</td></tr>
<tr><td><code id="generalGenericID_+3A_idstepfunctions">idStepFunctions</code></td>
<td>
<p>a list of identification step functions</p>
</td></tr>
<tr><td><code id="generalGenericID_+3A_tiandecompose">tianDecompose</code></td>
<td>
<p>TRUE or FALSE determining whether or not the Tian
decomposition should be used before running the
current generic identification algorithm. In general
letting this be TRUE will make the algorithm faster and
more powerful.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object of <a href="base.html#topic+class">class</a> '<code>GenericIDResult</code>,' this
object is just a list with 9 components:
</p>

<dl>
<dt><code>solvedParents</code></dt><dd><p>a list whose ith element contains a vector
containing the subsets of parents of node i for which the edge j-&gt;i could
be shown to be generically identifiable.</p>
</dd>
<dt><code>unsolvedParents</code></dt><dd><p>as for <code>solvedParents</code> but for the
unsolved parents.</p>
</dd>
<dt><code>solvedSiblings</code></dt><dd><p>as for <code>solvedParents</code> but for the
siblings of node i (i.e. the bidirected neighbors of i).</p>
</dd>
<dt><code>unsolvedSiblings</code></dt><dd><p>as for <code>solvedSilbings</code> but for the
unsolved siblings of node i (i.e. the bidirected neighbors of i).</p>
</dd>
<dt><code>identifier</code></dt><dd><p>a function that takes a (generic) covariance
matrix corresponding to the graph and identifies the edges parameters
from solvedParents and solvedSiblings. See <code><a href="#topic+htcIdentifyStep">htcIdentifyStep</a></code>
for a more in-depth discussion of identifier functions.</p>
</dd>
<dt><code>mixedGraph</code></dt><dd><p>a mixed graph object of the graph.</p>
</dd>
<dt><code>idStepFunctions</code></dt><dd><p>a list of functions used to generically
identify parameters. For instance, htcID uses the function
<code><a href="#topic+htcIdentifyStep">htcIdentifyStep</a></code> to identify edges.</p>
</dd>
<dt><code>tianDecompose</code></dt><dd><p>the argument tianDecompose.</p>
</dd>
<dt><code>call</code></dt><dd><p>the call made to this function.</p>
</dd>
</dl>


<hr>
<h2 id='getAncestors'>Get getAncestors of nodes in a graph.</h2><span id='topic+getAncestors'></span>

<h3>Description</h3>

<p>Get the getAncestors of a collection of nodes in a graph g, the getAncestors DO
include the the nodes themselves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAncestors(g, nodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAncestors_+3A_g">g</code></td>
<td>
<p>the graph (as an igraph).</p>
</td></tr>
<tr><td><code id="getAncestors_+3A_nodes">nodes</code></td>
<td>
<p>the nodes in the graph of which to get the getAncestors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sorted vector of all ancestor nodes.
</p>

<hr>
<h2 id='getDescendants'>Get descendants of nodes in a graph.</h2><span id='topic+getDescendants'></span>

<h3>Description</h3>

<p>Gets the descendants of a collection of nodes in a graph (all nodes that can
be reached by following directed edges from those nodes). Descendants DO
include the nodes themselves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDescendants(g, nodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDescendants_+3A_g">g</code></td>
<td>
<p>the graph (as an igraph).</p>
</td></tr>
<tr><td><code id="getDescendants_+3A_nodes">nodes</code></td>
<td>
<p>the nodes in the graph of which to get the descendants.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sorted vector of all descendants of nodes.
</p>

<hr>
<h2 id='getHalfTrekSystem'>Determines if a half-trek system exists in the mixed graph.</h2><span id='topic+getHalfTrekSystem'></span><span id='topic+getHalfTrekSystem.MixedGraph'></span><span id='topic+getTrekSystem.MixedGraph'></span>

<h3>Description</h3>

<p>Determines if a half-trek system exists in the mixed graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getHalfTrekSystem(this, fromNodes, toNodes, ...)

## S3 method for class 'MixedGraph'
getHalfTrekSystem(
  this,
  fromNodes,
  toNodes,
  avoidLeftNodes = integer(0),
  avoidRightNodes = integer(0),
  avoidRightEdges = integer(0),
  ...
)

## S3 method for class 'MixedGraph'
getTrekSystem(
  this,
  fromNodes,
  toNodes,
  avoidLeftNodes = integer(0),
  avoidRightNodes = integer(0),
  avoidLeftEdges = integer(0),
  avoidRightEdges = integer(0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getHalfTrekSystem_+3A_this">this</code></td>
<td>
<p>the mixed graph object</p>
</td></tr>
<tr><td><code id="getHalfTrekSystem_+3A_fromnodes">fromNodes</code></td>
<td>
<p>the nodes from which the half-trek system should start.
If length(fromNodes) &gt; length(toNodes) will find if there exists
any half-trek system from any subset of fromNodes of size
length(toNodes) to toNodes.</p>
</td></tr>
<tr><td><code id="getHalfTrekSystem_+3A_tonodes">toNodes</code></td>
<td>
<p>the nodes where the half-trek system should end.</p>
</td></tr>
<tr><td><code id="getHalfTrekSystem_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="getHalfTrekSystem_+3A_avoidleftnodes">avoidLeftNodes</code></td>
<td>
<p>a collection of nodes to avoid on the left</p>
</td></tr>
<tr><td><code id="getHalfTrekSystem_+3A_avoidrightnodes">avoidRightNodes</code></td>
<td>
<p>a collection of nodes to avoid on the right</p>
</td></tr>
<tr><td><code id="getHalfTrekSystem_+3A_avoidrightedges">avoidRightEdges</code></td>
<td>
<p>a collection of edges between observed noes
in the graph that should not be used on any right
hand side of any trek in the trek system.</p>
</td></tr>
<tr><td><code id="getHalfTrekSystem_+3A_avoidleftedges">avoidLeftEdges</code></td>
<td>
<p>a collection of edges between observed nodes
in the graph that should not be used on any right
hand side of any trek in the trek system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two named components, <code>systemExists</code> (TRUE if a
system exists, FALSE otherwise) and <code>activeFrom</code> (the subset
of fromNodes from which the maximal half-trek system was started).
</p>

<hr>
<h2 id='getMaxFlow'>Size of largest HT system Y satisfying the HTC for a node v except perhaps
having |getParents(v)| &lt; |Y|.</h2><span id='topic+getMaxFlow'></span>

<h3>Description</h3>

<p>For an input mixed graph H, constructs the Gflow graph as described in Foygel
et al. (2012) for a subgraph G of H. A max flow algorithm is then run on
Gflow to determine the largest half-trek system in G to a particular node's
getParents given a set of allowed nodes. Here G should consist of a bidirected
part and nodes which are not in the bidirected part but are a parent of some
node in the bidirected part. G should contain the node for which to compute
the max flow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMaxFlow(L, O, allowedNodes, biNodes, inNodes, node)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMaxFlow_+3A_l">L</code></td>
<td>
<p>Adjacency matrix for the directed part of the path
diagram/mixed graph; an edge pointing from i to j is encoded as L[i,j]=1 and
the lack of an edge between i and j is encoded as L[i,j]=0. There should be
no directed self loops, i.e. no i such that L[i,i]=1.</p>
</td></tr>
<tr><td><code id="getMaxFlow_+3A_o">O</code></td>
<td>
<p>Adjacency matrix for the bidirected part of the path diagram/mixed
graph. Edges are encoded as for the L parameter. Again there should be no
self loops. Also this matrix will be coerced to be symmetric so it is only
necessary to specify an edge once, i.e. if O[i,j]=1 you may, but are not
required to, also have O[j,i]=1.</p>
</td></tr>
<tr><td><code id="getMaxFlow_+3A_allowednodes">allowedNodes</code></td>
<td>
<p>the set of allowed nodes.</p>
</td></tr>
<tr><td><code id="getMaxFlow_+3A_binodes">biNodes</code></td>
<td>
<p>the set of nodes in the subgraph G which are part of the
bidirected part.</p>
</td></tr>
<tr><td><code id="getMaxFlow_+3A_innodes">inNodes</code></td>
<td>
<p>the nodes of the subgraph G which are not in the bidirected
part but are a parent of some node in the bidirected component.</p>
</td></tr>
<tr><td><code id="getMaxFlow_+3A_node">node</code></td>
<td>
<p>the node (as an integer) for which the maxflow the largest half
trek system</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See title.
</p>


<h3>References</h3>

<p>Foygel, R., Draisma, J., and Drton, M.  (2012) Half-trek criterion for
generic identifiability of linear structural equation models.
<em>Ann. Statist.</em> 40(3): 1682-1713.
</p>

<hr>
<h2 id='getMixedCompForNode'>Get the mixed component of a node in a mixed subgraph.</h2><span id='topic+getMixedCompForNode'></span>

<h3>Description</h3>

<p>For an input mixed graph H and set of nodes A, let GA be the subgraph of
H on the nodes A. This function returns the mixed component of GA containing
a specified node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMixedCompForNode(dG, bG, subNodes, node)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMixedCompForNode_+3A_dg">dG</code></td>
<td>
<p>a directed graph representing the directed part of the mixed graph.</p>
</td></tr>
<tr><td><code id="getMixedCompForNode_+3A_bg">bG</code></td>
<td>
<p>an undirected graph representing the undirected part of the mixed
graph.</p>
</td></tr>
<tr><td><code id="getMixedCompForNode_+3A_subnodes">subNodes</code></td>
<td>
<p>an ancestral set of nodes in the mixed graph, this set should
include the node for which the mixed component sould be found.</p>
</td></tr>
<tr><td><code id="getMixedCompForNode_+3A_node">node</code></td>
<td>
<p>the node for which the mixed component is found.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two named elements:
biNodes - the nodes of the mixed graph in the biDirected component
containing nodeName w.r.t the ancestral set of nodes
inNodes - the nodes in the graph which are not part of biNodes
but which are a parent of some node in biNodes.
</p>

<hr>
<h2 id='getMixedGraph'>Get the corresponding mixed graph</h2><span id='topic+getMixedGraph'></span><span id='topic+getMixedGraph.LatentDigraph'></span>

<h3>Description</h3>

<p>Only works for graphs where the latent nodes are source nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMixedGraph(this, ...)

## S3 method for class 'LatentDigraph'
getMixedGraph(this, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMixedGraph_+3A_this">this</code></td>
<td>
<p>the LatentDigraph object</p>
</td></tr>
<tr><td><code id="getMixedGraph_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='getParents'>Get getParents of nodes in a graph.</h2><span id='topic+getParents'></span>

<h3>Description</h3>

<p>Get the getParents of a collection of nodes in a graph g, the getParents DO include
the input nodes themselves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParents(g, nodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getParents_+3A_g">g</code></td>
<td>
<p>the graph (as an igraph).</p>
</td></tr>
<tr><td><code id="getParents_+3A_nodes">nodes</code></td>
<td>
<p>the nodes in the graph of which to get the getParents.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sorted vector of all parent nodes.
</p>

<hr>
<h2 id='getSiblings'>Get getSiblings of nodes in a graph.</h2><span id='topic+getSiblings'></span>

<h3>Description</h3>

<p>Get the getSiblings of a collection of nodes in a graph g, the getSiblings DO
include the input nodes themselves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSiblings(g, nodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSiblings_+3A_g">g</code></td>
<td>
<p>the graph (as an igraph).</p>
</td></tr>
<tr><td><code id="getSiblings_+3A_nodes">nodes</code></td>
<td>
<p>the nodes in the graph of which to get the getSiblings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sorted vector of all getSiblings of nodes.
</p>

<hr>
<h2 id='getTrekSystem'>Determines if a trek system exists in the mixed graph.</h2><span id='topic+getTrekSystem'></span><span id='topic+getTrekSystem.LatentDigraphFixedOrder'></span><span id='topic+getTrekSystem.LatentDigraph'></span>

<h3>Description</h3>

<p>Determines if a trek system exists in the mixed graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTrekSystem(
  this,
  fromNodes,
  toNodes,
  avoidLeftNodes = integer(0),
  avoidRightNodes = integer(0),
  avoidLeftEdges = integer(0),
  avoidRightEdges = integer(0),
  ...
)

## S3 method for class 'LatentDigraphFixedOrder'
getTrekSystem(
  this,
  fromNodes,
  toNodes,
  avoidLeftNodes = integer(0),
  avoidRightNodes = integer(0),
  avoidLeftEdges = integer(0),
  avoidRightEdges = integer(0),
  ...
)

## S3 method for class 'LatentDigraph'
getTrekSystem(
  this,
  fromNodes,
  toNodes,
  avoidLeftNodes = integer(0),
  avoidRightNodes = integer(0),
  avoidLeftEdges = integer(0),
  avoidRightEdges = integer(0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getTrekSystem_+3A_this">this</code></td>
<td>
<p>the graph object</p>
</td></tr>
<tr><td><code id="getTrekSystem_+3A_fromnodes">fromNodes</code></td>
<td>
<p>the start nodes</p>
</td></tr>
<tr><td><code id="getTrekSystem_+3A_tonodes">toNodes</code></td>
<td>
<p>the end nodes</p>
</td></tr>
<tr><td><code id="getTrekSystem_+3A_avoidleftnodes">avoidLeftNodes</code></td>
<td>
<p>a collection of nodes to avoid on the left</p>
</td></tr>
<tr><td><code id="getTrekSystem_+3A_avoidrightnodes">avoidRightNodes</code></td>
<td>
<p>a collection of nodes to avoid on the right</p>
</td></tr>
<tr><td><code id="getTrekSystem_+3A_avoidleftedges">avoidLeftEdges</code></td>
<td>
<p>a collection of edges between observed nodes
in the graph that should not be used on any right
hand side of any trek in the trek system.</p>
</td></tr>
<tr><td><code id="getTrekSystem_+3A_avoidrightedges">avoidRightEdges</code></td>
<td>
<p>a collection of edges between observed noes
in the graph that should not be used on any right
hand side of any trek in the trek system.</p>
</td></tr>
<tr><td><code id="getTrekSystem_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='globalID'>Determines whether a mixed graph is globally identifiable.</h2><span id='topic+globalID'></span>

<h3>Description</h3>

<p>Uses the criterion in Theorem 2 of the paper by Drton, Foygel and Sullivant (2011) to determine
whether a mixed graph is globally identifiable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>globalID(graph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="globalID_+3A_graph">graph</code></td>
<td>
<p>a <code><a href="#topic+MixedGraph">MixedGraph</a></code> object representing
the mixed graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the graph is globally identifiable, FALSE otherwise.
</p>


<h3>References</h3>

<p>Drton, M., Barber, R. F., and Sullivant S. (2011).
Half-Trek Criterion for Identifiability of Latent Variable Models.
Ann. Statist. 39 (2011), no. 2, 865&ndash;886 &lt;doi:10.1214/10-AOS859&gt;.
</p>

<hr>
<h2 id='graphID'>Identifiability of linear structural equation models.</h2><span id='topic+graphID'></span>

<h3>Description</h3>

<p>NOTE: <code>graphID</code> has been deprecated, use <code><a href="#topic+semID">semID</a></code> instead.
</p>
<p>This function checks global and generic identifiability of linear
structural equation models. For generic identifiability the function
checks a sufficient criterion as well as a necessary criterion but this
check may be inconclusive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphID(
  L,
  O,
  output.type = "matrix",
  file.name = NULL,
  decomp.if.acyclic = TRUE,
  test.globalID = TRUE,
  test.genericID = TRUE,
  test.nonID = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphID_+3A_l">L</code></td>
<td>
<p>Adjacency matrix for the directed part of the path
diagram/mixed graph; an edge pointing from i to j is encoded as L[i,j]=1 and
the lack of an edge between i and j is encoded as L[i,j]=0. There should be
no directed self loops, i.e. no i such that L[i,i]=1.</p>
</td></tr>
<tr><td><code id="graphID_+3A_o">O</code></td>
<td>
<p>Adjacency matrix for the bidirected part of the path diagram/mixed
graph. Edges are encoded as for the L parameter. Again there should be no
self loops. Also this matrix will be coerced to be symmetric so it is only
necessary to specify an edge once, i.e. if O[i,j]=1 you may, but are not
required to, also have O[j,i]=1.</p>
</td></tr>
<tr><td><code id="graphID_+3A_output.type">output.type</code></td>
<td>
<p>A character string indicating whether output is
printed ('matrix'), saved to a file ('file'), or returned as a list
('list') for further processing in R.</p>
</td></tr>
<tr><td><code id="graphID_+3A_file.name">file.name</code></td>
<td>
<p>A character string naming the output file.</p>
</td></tr>
<tr><td><code id="graphID_+3A_decomp.if.acyclic">decomp.if.acyclic</code></td>
<td>
<p>A logical value indicating whether an input graph
that is acyclic is to be decomposed before applying identifiability criteria.</p>
</td></tr>
<tr><td><code id="graphID_+3A_test.globalid">test.globalID</code></td>
<td>
<p>A logical value indicating whether or not global
identifiability is checked.</p>
</td></tr>
<tr><td><code id="graphID_+3A_test.genericid">test.genericID</code></td>
<td>
<p>A logical value indicating whether or not a sufficient
condition for generic identifiability is checked.</p>
</td></tr>
<tr><td><code id="graphID_+3A_test.nonid">test.nonID</code></td>
<td>
<p>A logical value indicating whether or not a condition
implying generic non-identifiability is checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list or printed matrix indicating the identifiability status of the
linear SEM given by the input graph.  Optionally the graph's
components are listed.
</p>
<p>With output.type = 'list', the function returns a list of components
for the graph.  Each list entry is again a list that indicates first
which nodes form the component and second whether the component forms
a mixed graph that is acyclic.  The next entries in the list show
HTC-identifiable nodes, meaning nodes v for which the coefficients for
all the directed edges pointing to v can be identified using the
methods from Foygel et al. (2012).  The HTC-identifiable nodes are
listed in the order in which they are found by the recursive
identification algorithm.  The last three list entries are
logical values that indicate whether or not the graph component is
generically identifiable, globally identifiable or not identifiable;
compare Drton et al. (2011) and Foygel et al. (2012).  In the latter
case the Jacobian of the parametrization does not have full rank.
</p>
<p>With output.type = 'matrix', a summary of the above
information is printed.
</p>


<h3>References</h3>

<p>Drton, M., Foygel, R., and Sullivant, S.  (2011) Global
identifiability of linear structural equation models. <em>Ann. Statist.</em>
39(2): 865-886.
</p>
<p>Foygel, R., Draisma, J., and Drton, M.  (2012) Half-trek criterion for
generic identifiability of linear structural equation models.
<em>Ann. Statist.</em> 40(3): 1682-1713.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
L = t(matrix(
  c(0, 1, 0, 0, 0,
    0, 0, 1, 0, 0,
    0, 0, 0, 1, 0,
    0, 0, 0, 0, 1,
    0, 0, 0, 0, 0), 5, 5))
O = t(matrix(
  c(0, 0, 1, 1, 0,
    0, 0, 0, 1, 1,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0), 5, 5))
O=O+t(O)
graphID(L,O)


## Examples from Foygel, Draisma &amp; Drton (2012)
demo(SEMID)

## End(Not run)
</code></pre>

<hr>
<h2 id='graphID.ancestralID'>Determine generic identifiability of an acyclic mixed graph using ancestral
decomposition.</h2><span id='topic+graphID.ancestralID'></span>

<h3>Description</h3>

<p>For an input, acyclic, mixed graph attempts to determine if the graph is
generically identifiable using decomposition by ancestral subsets. See
algorithm 1 of Drton and Weihs (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphID.ancestralID(L, O)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphID.ancestralID_+3A_l">L</code></td>
<td>
<p>Adjacency matrix for the directed part of the path
diagram/mixed graph; an edge pointing from i to j is encoded as L[i,j]=1 and
the lack of an edge between i and j is encoded as L[i,j]=0. There should be
no directed self loops, i.e. no i such that L[i,i]=1.</p>
</td></tr>
<tr><td><code id="graphID.ancestralID_+3A_o">O</code></td>
<td>
<p>Adjacency matrix for the bidirected part of the path diagram/mixed
graph. Edges are encoded as for the L parameter. Again there should be no
self loops. Also this matrix will be coerced to be symmetric so it is only
necessary to specify an edge once, i.e. if O[i,j]=1 you may, but are not
required to, also have O[j,i]=1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of nodes that could be determined to be generically
identifiable using the above algorithm.
</p>


<h3>References</h3>

<p>Drton, M. and Weihs, L. (2015) Generic Identifiability of Linear
Structural Equation Models by Ancestor Decomposition. arXiv 1504.02992
</p>

<hr>
<h2 id='graphID.decompose'>Determine generic identifiability by Tian Decomposition and HTC</h2><span id='topic+graphID.decompose'></span>

<h3>Description</h3>

<p>Split a graph into mixed Tian components and solve each separately
using the HTC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphID.decompose(
  L,
  O,
  decomp.if.acyclic = TRUE,
  test.globalID = TRUE,
  test.genericID = TRUE,
  test.nonID = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphID.decompose_+3A_l">L</code></td>
<td>
<p>Adjacency matrix for the directed part of the path
diagram/mixed graph; an edge pointing from i to j is encoded as L[i,j]=1 and
the lack of an edge between i and j is encoded as L[i,j]=0. There should be
no directed self loops, i.e. no i such that L[i,i]=1.</p>
</td></tr>
<tr><td><code id="graphID.decompose_+3A_o">O</code></td>
<td>
<p>Adjacency matrix for the bidirected part of the path diagram/mixed
graph. Edges are encoded as for the L parameter. Again there should be no
self loops. Also this matrix will be coerced to be symmetric so it is only
necessary to specify an edge once, i.e. if O[i,j]=1 you may, but are not
required to, also have O[j,i]=1.</p>
</td></tr>
<tr><td><code id="graphID.decompose_+3A_decomp.if.acyclic">decomp.if.acyclic</code></td>
<td>
<p>A logical value indicating whether an input graph
that is acyclic is to be decomposed before applying identifiability criteria.</p>
</td></tr>
<tr><td><code id="graphID.decompose_+3A_test.globalid">test.globalID</code></td>
<td>
<p>A logical value indicating whether or not global
identifiability is checked.</p>
</td></tr>
<tr><td><code id="graphID.decompose_+3A_test.genericid">test.genericID</code></td>
<td>
<p>A logical value indicating whether or not a sufficient
condition for generic identifiability is checked.</p>
</td></tr>
<tr><td><code id="graphID.decompose_+3A_test.nonid">test.nonID</code></td>
<td>
<p>A logical value indicating whether or not a condition
implying generic non-identifiability is checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two named components:
</p>
<p>1. Components - a list of lists. Each list represents one mixed Tian component
of the graph. Each list contains named components corresponding to which
nodes are in the component and results of various tests of
identifiability on the component (see the parameter descriptions).
</p>
<p>2. Decomp - true if a decomposition occured, false if not.
</p>

<hr>
<h2 id='graphID.genericID'>Determine generic identifiability of a mixed graph.</h2><span id='topic+graphID.genericID'></span>

<h3>Description</h3>

<p>If the directed part of input graph is cyclic then will check for generic
identifiability using the half-trek criterion. Otherwise will use the a
slightly stronger version of the half-trek criterion using ancestor
decompositions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphID.genericID(L, O)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphID.genericID_+3A_l">L</code></td>
<td>
<p>Adjacency matrix for the directed part of the path
diagram/mixed graph; an edge pointing from i to j is encoded as L[i,j]=1 and
the lack of an edge between i and j is encoded as L[i,j]=0. There should be
no directed self loops, i.e. no i such that L[i,i]=1.</p>
</td></tr>
<tr><td><code id="graphID.genericID_+3A_o">O</code></td>
<td>
<p>Adjacency matrix for the bidirected part of the path diagram/mixed
graph. Edges are encoded as for the L parameter. Again there should be no
self loops. Also this matrix will be coerced to be symmetric so it is only
necessary to specify an edge once, i.e. if O[i,j]=1 you may, but are not
required to, also have O[j,i]=1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of nodes that could be determined to be generically
identifiable.
</p>


<h3>References</h3>

<p>Foygel, R., Draisma, J., and Drton, M.  (2012) Half-trek criterion for
generic identifiability of linear structural equation models.
<em>Ann. Statist.</em> 40(3): 1682-1713.
</p>
<p>Drton, M. and Weihs, L. (2015) Generic Identifiability of Linear
Structural Equation Models by Ancestor Decomposition. arXiv 1504.02992
</p>

<hr>
<h2 id='graphID.htcID'>Determines if a mixed graph is HTC-identifiable.</h2><span id='topic+graphID.htcID'></span>

<h3>Description</h3>

<p>Uses the half-trek criterion of Foygel, Draisma, and Drton (2013) to check
if an input mixed graph is generically identifiable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphID.htcID(L, O)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphID.htcID_+3A_l">L</code></td>
<td>
<p>Adjacency matrix for the directed part of the path
diagram/mixed graph; an edge pointing from i to j is encoded as L[i,j]=1 and
the lack of an edge between i and j is encoded as L[i,j]=0. There should be
no directed self loops, i.e. no i such that L[i,i]=1.</p>
</td></tr>
<tr><td><code id="graphID.htcID_+3A_o">O</code></td>
<td>
<p>Adjacency matrix for the bidirected part of the path diagram/mixed
graph. Edges are encoded as for the L parameter. Again there should be no
self loops. Also this matrix will be coerced to be symmetric so it is only
necessary to specify an edge once, i.e. if O[i,j]=1 you may, but are not
required to, also have O[j,i]=1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of HTC-identifiable nodes.
</p>


<h3>References</h3>

<p>Foygel, R., Draisma, J., and Drton, M.  (2012) Half-trek criterion for
generic identifiability of linear structural equation models.
<em>Ann. Statist.</em> 40(3): 1682-1713.
</p>

<hr>
<h2 id='graphID.main'>Helper function to handle a graph component.</h2><span id='topic+graphID.main'></span>

<h3>Description</h3>

<p>Calls the other functions that determine identifiability status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphID.main(
  L,
  O,
  test.globalID = TRUE,
  test.genericID = TRUE,
  test.nonID = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphID.main_+3A_l">L</code></td>
<td>
<p>Adjacency matrix for the directed part of the path
diagram/mixed graph; an edge pointing from i to j is encoded as L[i,j]=1 and
the lack of an edge between i and j is encoded as L[i,j]=0. There should be
no directed self loops, i.e. no i such that L[i,i]=1.</p>
</td></tr>
<tr><td><code id="graphID.main_+3A_o">O</code></td>
<td>
<p>Adjacency matrix for the bidirected part of the path diagram/mixed
graph. Edges are encoded as for the L parameter. Again there should be no
self loops. Also this matrix will be coerced to be symmetric so it is only
necessary to specify an edge once, i.e. if O[i,j]=1 you may, but are not
required to, also have O[j,i]=1.</p>
</td></tr>
<tr><td><code id="graphID.main_+3A_test.globalid">test.globalID</code></td>
<td>
<p>A logical value indicating whether or not global
identifiability is checked.</p>
</td></tr>
<tr><td><code id="graphID.main_+3A_test.genericid">test.genericID</code></td>
<td>
<p>A logical value indicating whether or not a sufficient
condition for generic identifiability is checked.</p>
</td></tr>
<tr><td><code id="graphID.main_+3A_test.nonid">test.nonID</code></td>
<td>
<p>A logical value indicating whether or not a condition
implying generic non-identifiability is checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing named components of the results of various tests
desired based on the input parameters.
</p>

<hr>
<h2 id='graphID.nonHtcID'>Check for generic infinite-to-one via the half-trek criterion.</h2><span id='topic+graphID.nonHtcID'></span>

<h3>Description</h3>

<p>Checks if a mixed graph is infinite-to-one using the half-trek criterion
presented by Foygel, Draisma, and Drton (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphID.nonHtcID(L, O)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphID.nonHtcID_+3A_l">L</code></td>
<td>
<p>Adjacency matrix for the directed part of the path
diagram/mixed graph; an edge pointing from i to j is encoded as L[i,j]=1 and
the lack of an edge between i and j is encoded as L[i,j]=0. There should be
no directed self loops, i.e. no i such that L[i,i]=1.</p>
</td></tr>
<tr><td><code id="graphID.nonHtcID_+3A_o">O</code></td>
<td>
<p>Adjacency matrix for the bidirected part of the path diagram/mixed
graph. Edges are encoded as for the L parameter. Again there should be no
self loops. Also this matrix will be coerced to be symmetric so it is only
necessary to specify an edge once, i.e. if O[i,j]=1 you may, but are not
required to, also have O[j,i]=1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the graph could be determined to be generically
non-identifiable, FALSE if this test was inconclusive.
</p>


<h3>References</h3>

<p>Foygel, R., Draisma, J., and Drton, M.  (2012) Half-trek criterion for
generic identifiability of linear structural equation models.
<em>Ann. Statist.</em> 40(3): 1682-1713.
</p>

<hr>
<h2 id='htcID'>Determines which edges in a mixed graph are HTC-identifiable.</h2><span id='topic+htcID'></span>

<h3>Description</h3>

<p>Uses the half-trek criterion of Foygel, Draisma, and Drton (2012) determine
which edges in a mixed graph are generically identifiable. Depending on your
application it faster to use the <code><a href="#topic+graphID.htcID">graphID.htcID</a></code> function
instead of this one, this function has the advantage of returning additional
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>htcID(mixedGraph, tianDecompose = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="htcID_+3A_mixedgraph">mixedGraph</code></td>
<td>
<p>a <code><a href="#topic+MixedGraph">MixedGraph</a></code> object representing the L-SEM.</p>
</td></tr>
<tr><td><code id="htcID_+3A_tiandecompose">tianDecompose</code></td>
<td>
<p>TRUE or FALSE determining whether or not the Tian
decomposition should be used before running the
current generic identification algorithm. In general
letting this be TRUE will make the algorithm faster and
more powerful.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>see the return value of <code><a href="#topic+generalGenericID">generalGenericID</a></code>.
</p>


<h3>References</h3>

<p>Foygel, R., Draisma, J., and Drton, M.  (2012) Half-trek criterion for
generic identifiability of linear structural equation models.
<em>Ann. Statist.</em> 40(3): 1682-1713.
</p>
<p>Jin Tian. 2005. Identifying direct causal effects in linear models. In
<em>Proceedings of the 20th national conference on Artificial intelligence
- Volume 1</em> (AAAI'05), Anthony Cohn (Ed.), Vol. 1. AAAI Press 346-352.
</p>

<hr>
<h2 id='htcIdentifyStep'>Perform one iteration of HTC identification.</h2><span id='topic+htcIdentifyStep'></span>

<h3>Description</h3>

<p>A function that does one step through all the nodes in a mixed graph
and tries to identify new edge coefficients using the existence of
half-trek systems as described in Foygel, Draisma, Drton (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>htcIdentifyStep(mixedGraph, unsolvedParents, solvedParents, identifier)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="htcIdentifyStep_+3A_mixedgraph">mixedGraph</code></td>
<td>
<p>a <code><a href="#topic+MixedGraph">MixedGraph</a></code> object representing
the mixed graph.</p>
</td></tr>
<tr><td><code id="htcIdentifyStep_+3A_unsolvedparents">unsolvedParents</code></td>
<td>
<p>a list whose ith index is a vector of all the parents
j of i in G which for which the edge j-&gt;i is not yet known to be
generically identifiable.</p>
</td></tr>
<tr><td><code id="htcIdentifyStep_+3A_solvedparents">solvedParents</code></td>
<td>
<p>the complement of <code>unsolvedParents</code>, a list whose
ith index is a vector of all parents j of i for which the edge i-&gt;j
is known to be generically identifiable (perhaps by other algorithms).</p>
</td></tr>
<tr><td><code id="htcIdentifyStep_+3A_identifier">identifier</code></td>
<td>
<p>an identification function that must produce the
identifications corresponding to those in solved parents. That is
<code>identifier</code> should be a function taking a single argument Sigma
(any generically generated covariance matrix corresponding
to the mixed graph) and returns a list with two named arguments
</p>

<dl>
<dt>Lambda</dt><dd><p>denote the number of nodes in <code>mixedGraph</code> as n. Then
Lambda is an nxn matrix whose i,jth entry
</p>

<ol>
<li><p> equals 0 if i is not a parent of j,
</p>
</li>
<li><p> equals NA if i is a parent of j but <code>identifier</code> cannot
identify it generically,
</p>
</li>
<li><p> equals the (generically) unique value corresponding to the weight
along the edge i-&gt;j that was used to produce Sigma.
</p>
</li></ol>
</dd>
<dt>Omega</dt><dd><p>just as Lambda but for the bidirected edges in the mixed
graph</p>
</dd>
</dl>

<p>such that if j is in <code>solvedParents[[i]]</code> we must have that
Lambda[j,i] is not NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with four components:
</p>

<dl>
<dt><code>identifiedEdges</code></dt><dd><p>a matrix rx2 matrix where r is the number
of edges that where identified by this function call and
<code>identifiedEdges[i,1] -&gt; identifiedEdges[i,2]</code> was the ith edge
identified</p>
</dd>
<dt><code>unsolvedParents</code></dt><dd><p>as the input argument but updated with
any newly identified edges</p>
</dd>
<dt><code>solvedParents</code></dt><dd><p>as the input argument but updated with
any newly identified edges</p>
</dd>
<dt><code>identifier</code></dt><dd><p>as the input argument but updated with
any newly identified edges</p>
</dd>
</dl>



<h3>References</h3>

<p>Foygel, R., Draisma, J., and Drton, M.  (2012) Half-trek criterion for
generic identifiability of linear structural equation models.
<em>Ann. Statist.</em> 40(3): 1682-1713
</p>

<hr>
<h2 id='htr'>Get all HTR nodes from a set of nodes in a graph.</h2><span id='topic+htr'></span>

<h3>Description</h3>

<p>Gets all vertices in a graph that are half-trek reachable from a set of
nodes.
WARNING: Often the half-trek reachable nodes from a vertex v are defined to
not include the vertex v or its getSiblings. We DO NOT follow this convention,
the returned set will include input nodes and their getSiblings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>htr(dG, bG, nodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="htr_+3A_dg">dG</code></td>
<td>
<p>a directed graph representing the directed part of the mixed graph.</p>
</td></tr>
<tr><td><code id="htr_+3A_bg">bG</code></td>
<td>
<p>an undirected graph representing the undirected part of the mixed
graph.</p>
</td></tr>
<tr><td><code id="htr_+3A_nodes">nodes</code></td>
<td>
<p>the nodes in the graph of which to get the HTR nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sorted list of all half-trek reachable nodes.
</p>

<hr>
<h2 id='htrFrom'>Half trek reachable nodes.</h2><span id='topic+htrFrom'></span><span id='topic+htrFrom.MixedGraph'></span>

<h3>Description</h3>

<p>Half trek reachable nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>htrFrom(this, nodes, ...)

## S3 method for class 'MixedGraph'
htrFrom(
  this,
  nodes,
  avoidLeftNodes = integer(0),
  avoidRightNodes = integer(0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="htrFrom_+3A_this">this</code></td>
<td>
<p>the mixed graph object</p>
</td></tr>
<tr><td><code id="htrFrom_+3A_nodes">nodes</code></td>
<td>
<p>the nodes from which to get all half-trek reachable nodes.</p>
</td></tr>
<tr><td><code id="htrFrom_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="htrFrom_+3A_avoidleftnodes">avoidLeftNodes</code></td>
<td>
<p>a collection of nodes to avoid on the left</p>
</td></tr>
<tr><td><code id="htrFrom_+3A_avoidrightnodes">avoidRightNodes</code></td>
<td>
<p>a collection of nodes to avoid on the right</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of all nodes half-trek reachable from node.
</p>

<hr>
<h2 id='inducedSubgraph'>Get the induced subgraph on a collection of nodes</h2><span id='topic+inducedSubgraph'></span><span id='topic+inducedSubgraph.LatentDigraph'></span><span id='topic+inducedSubgraph.MixedGraph'></span>

<h3>Description</h3>

<p>Get the induced subgraph on a collection of nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inducedSubgraph(this, nodes, ...)

## S3 method for class 'LatentDigraph'
inducedSubgraph(this, nodes, ...)

## S3 method for class 'MixedGraph'
inducedSubgraph(this, nodes, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inducedSubgraph_+3A_this">this</code></td>
<td>
<p>the graph object</p>
</td></tr>
<tr><td><code id="inducedSubgraph_+3A_nodes">nodes</code></td>
<td>
<p>the nodes on which to create the induced subgraph.</p>
</td></tr>
<tr><td><code id="inducedSubgraph_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='isSibling'>Are two nodes siblings?</h2><span id='topic+isSibling'></span><span id='topic+isSibling.MixedGraph'></span>

<h3>Description</h3>

<p>Are two nodes siblings?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isSibling(this, node1, node2, ...)

## S3 method for class 'MixedGraph'
isSibling(this, node1, node2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isSibling_+3A_this">this</code></td>
<td>
<p>the mixed graph object</p>
</td></tr>
<tr><td><code id="isSibling_+3A_node1">node1</code></td>
<td>
<p>a node</p>
</td></tr>
<tr><td><code id="isSibling_+3A_node2">node2</code></td>
<td>
<p>a second node</p>
</td></tr>
<tr><td><code id="isSibling_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the nodes are siblings in the graph, FALSE otherwise
</p>

<hr>
<h2 id='L'>Get directed adjacency matrix.</h2><span id='topic+L'></span><span id='topic+L.LatentDigraphFixedOrder'></span><span id='topic+L.LatentDigraph'></span><span id='topic+L.MixedGraph'></span>

<h3>Description</h3>

<p>Get directed adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L(this, ...)

## S3 method for class 'LatentDigraphFixedOrder'
L(this, ...)

## S3 method for class 'LatentDigraph'
L(this, ...)

## S3 method for class 'MixedGraph'
L(this, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="L_+3A_this">this</code></td>
<td>
<p>the graph object</p>
</td></tr>
<tr><td><code id="L_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='LatentDigraph'>Construct a LatentDigraph object</h2><span id='topic+LatentDigraph'></span>

<h3>Description</h3>

<p>Creates an object representing a latent factor graph. The methods that are
currently available to be used on the latent factor graph include
</p>

<ol>
<li><p> numObserved
</p>
</li>
<li><p> numLatents
</p>
</li>
<li><p> numNodes
</p>
</li>
<li><p> toIn
</p>
</li>
<li><p> toEx
</p>
</li>
<li><p> L
</p>
</li>
<li><p> observedNodes
</p>
</li>
<li><p> latentNodes
</p>
</li>
<li><p> parents
</p>
</li>
<li><p> children
</p>
</li>
<li><p> ancestors
</p>
</li>
<li><p> descendants
</p>
</li>
<li><p> trFrom
</p>
</li>
<li><p> getTrekSystem
</p>
</li>
<li><p> inducedSubgraph
</p>
</li>
<li><p> stronglyConnectedComponent
</p>
</li>
<li><p> plot
</p>
</li>
<li><p> observedParents
</p>
</li>
<li><p> getMixedGraph
</p>
</li></ol>

<p>see the individual function documentation for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LatentDigraph(L = matrix(0,1,1),
                     observedNodes = seq(1, length = nrow(L)),
                     latentNodes = integer(0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LatentDigraph_+3A_l">L</code></td>
<td>
<p>see <code><a href="#topic+graphID">graphID</a></code> for the appropriate form of L.</p>
</td></tr>
<tr><td><code id="LatentDigraph_+3A_observednodes">observedNodes</code></td>
<td>
<p>a vector of positive integers representing
the vertex numbers of the observed nodes. These will correspond,
in order, to the first length(observedNodes) rows of L.</p>
</td></tr>
<tr><td><code id="LatentDigraph_+3A_latentnodes">latentNodes</code></td>
<td>
<p>a vector of positive integers representing
the vertex numbers of the latent nodes. These will correspond,
in order, to the last length(latentNodes) rows of L.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object representing the LatentDigraph
</p>

<hr>
<h2 id='LatentDigraphFixedOrder'>Construct LatentDigraphFixedOrder object</h2><span id='topic+LatentDigraphFixedOrder'></span>

<h3>Description</h3>

<p>Creates an object representing a directed graph with some number of
nodes which are latent (unobserved).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LatentDigraphFixedOrder(L = matrix(0,1,1), numObserved = nrow(L))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LatentDigraphFixedOrder_+3A_l">L</code></td>
<td>
<p>see <code><a href="#topic+graphID">graphID</a></code> for the appropriate form of L. The
first numObserved rows of L correspond to the observed nodes in the
graph, all other nodes are considered unobserved.</p>
</td></tr>
<tr><td><code id="LatentDigraphFixedOrder_+3A_numobserved">numObserved</code></td>
<td>
<p>a non-negative integer representing the number of observed
nodes in the graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object representing the LatentDigraphFixedOrder
</p>

<hr>
<h2 id='latentDigraphHasSimpleNumbering'>Checks that a LatentDigraph has appropriate node numbering</h2><span id='topic+latentDigraphHasSimpleNumbering'></span>

<h3>Description</h3>

<p>Checks that the input latent digraph has nodes numbered from 1
to latentDigraph$numObserved()+latentDigraph$numLatents(). The first latentDigraph$numObserved()
nodes correspond to the observed nodes in the graph, all other nodes are considered unobserved.
Throws an error if this is not true.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latentDigraphHasSimpleNumbering(graph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="latentDigraphHasSimpleNumbering_+3A_graph">graph</code></td>
<td>
<p>a <code><a href="#topic+LatentDigraph">LatentDigraph</a></code> object representing
the latent-factor graph. All latent nodes in this graph should be
source nodes (i.e. have no parents).</p>
</td></tr>
</table>

<hr>
<h2 id='latentNodes'>Get all latent nodes in the graph.</h2><span id='topic+latentNodes'></span><span id='topic+latentNodes.LatentDigraph'></span>

<h3>Description</h3>

<p>Get all latent nodes in the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latentNodes(this, ...)

## S3 method for class 'LatentDigraph'
latentNodes(this, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="latentNodes_+3A_this">this</code></td>
<td>
<p>the graph object</p>
</td></tr>
<tr><td><code id="latentNodes_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='lfhtcID'>Determines which edges in a latent digraph are LF-HTC-identifiable.</h2><span id='topic+lfhtcID'></span>

<h3>Description</h3>

<p>Uses the latent-factor half-trek criterion to determine
which edges in a latent digraph are generically identifiable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfhtcID(graph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lfhtcID_+3A_graph">graph</code></td>
<td>
<p>a <code><a href="#topic+LatentDigraph">LatentDigraph</a></code> object representing
the latent-factor graph. All latent nodes in this graph should be
source nodes (i.e. have no parents).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with 8 components:
</p>

<dl>
<dt><code>solvedParents</code></dt><dd><p>a list whose ith element contains a vector
containing the subsets of parents of node i for which the edge j-&gt;i could
be shown to be generically identifiable.</p>
</dd>
<dt><code>unsolvedParents</code></dt><dd><p>as for <code>solvedParents</code> but for the
unsolved parents.</p>
</dd>
<dt><code>identifier</code></dt><dd><p>a function that takes a (generic) covariance
matrix corresponding to the graph and identifies the edges parameters
from solvedParents and solvedSiblings. See <code><a href="#topic+htcIdentifyStep">htcIdentifyStep</a></code>
for a more in-depth discussion of identifier functions.</p>
</dd>
<dt><code>graph</code></dt><dd><p>a latent digraph object of the graph.</p>
</dd>
<dt><code>call</code></dt><dd><p>the call made to this function.</p>
</dd>
<dt><code>activeFroms</code></dt><dd><p>list. If node i is solved then the ith index
is a vector containing the nodes Y otherwise it is empty.</p>
</dd>
<dt><code>Zs</code></dt><dd><p>list. If node i is solved then the ith index is a
vector containing the nodes Z otherwise it is empty.</p>
</dd>
<dt><code>Ls</code></dt><dd><p>list. If node i is solved then the ith index is a
vector containing the nodes L otherwise it is empty.</p>
</dd>
</dl>



<h3>References</h3>

<p>Barber, R. F., Drton, M., Sturma, N., and Weihs L. (2022).
Half-Trek Criterion for Identifiability of Latent Variable Models.
Ann. Statist. 50(6):3174&ndash;3196. &lt;doi:10.1214/22-AOS2221&gt;.
</p>

<hr>
<h2 id='lfhtcIdentifyStep'>Perform one iteration of latent-factor HTC identification.</h2><span id='topic+lfhtcIdentifyStep'></span>

<h3>Description</h3>

<p>A function that does one step through all the nodes in a latent-factor graph
and tries to identify new edge coefficients using the existence of
latent-factor half-trek systems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfhtcIdentifyStep(
  graph,
  unsolvedParents,
  solvedParents,
  activeFroms,
  Zs,
  Ls,
  identifier,
  subsetSizeControl = Inf
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lfhtcIdentifyStep_+3A_graph">graph</code></td>
<td>
<p>a <code><a href="#topic+LatentDigraph">LatentDigraph</a></code> object representing
the latent-factor graph. All latent nodes in this graph should be
source nodes (i.e. have no parents).</p>
</td></tr>
<tr><td><code id="lfhtcIdentifyStep_+3A_unsolvedparents">unsolvedParents</code></td>
<td>
<p>a list whose ith index is a vector of all the parents
j of i in the graph which for which the edge j-&gt;i is not yet known to be
generically identifiable.</p>
</td></tr>
<tr><td><code id="lfhtcIdentifyStep_+3A_solvedparents">solvedParents</code></td>
<td>
<p>the complement of <code>unsolvedParents</code>, a list whose
ith index is a vector of all parents j of i for which the edge i-&gt;j
is known to be generically identifiable (perhaps by other algorithms).</p>
</td></tr>
<tr><td><code id="lfhtcIdentifyStep_+3A_activefroms">activeFroms</code></td>
<td>
<p>list. If node i is solved then the ith index is a vector
containing the nodes Y otherwise it is empty.</p>
</td></tr>
<tr><td><code id="lfhtcIdentifyStep_+3A_zs">Zs</code></td>
<td>
<p>list. If node i is solved then the ith index is a vector
containing the nodes Z otherwise it is empty.</p>
</td></tr>
<tr><td><code id="lfhtcIdentifyStep_+3A_ls">Ls</code></td>
<td>
<p>list. If node i is solved then the ith index is a vector
containing the nodes Z otherwise it is empty.</p>
</td></tr>
<tr><td><code id="lfhtcIdentifyStep_+3A_identifier">identifier</code></td>
<td>
<p>an identification function that must produce the
identifications corresponding to those in solved parents. That is
<code>identifier</code> should be a function taking a single argument Sigma
(any generically generated covariance matrix corresponding
to the latent-factor graph) and returns a list with two named arguments</p>
</td></tr>
<tr><td><code id="lfhtcIdentifyStep_+3A_subsetsizecontrol">subsetSizeControl</code></td>
<td>
<p>the largest subset of latent nodes to consider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with four components:
</p>

<dl>
<dt><code>identifiedEdges</code></dt><dd><p>a matrix rx2 matrix where r is the number
of edges that where identified by this function call and
<code>identifiedEdges[i,1] -&gt; identifiedEdges[i,2]</code> was the ith edge
identified</p>
</dd>
<dt><code>unsolvedParents</code></dt><dd><p>as the input argument but updated with
any newly identified edges</p>
</dd>
<dt><code>solvedParents</code></dt><dd><p>as the input argument but updated with
any newly identified edges</p>
</dd>
<dt><code>identifier</code></dt><dd><p>as the input argument but updated with
any newly identified edges</p>
</dd>
<dt><code>activeFroms</code></dt><dd><p>as the input argument but updated with
any newly solved node</p>
</dd>
<dt><code>Zs</code></dt><dd><p>as the input argument but updated with
any newly solved node</p>
</dd>
<dt><code>Ls</code></dt><dd><p>as the input argument but updated with
any newly solved node</p>
</dd>
</dl>



<h3>References</h3>

<p>Barber, R. F., Drton, M., Sturma, N., and Weihs L. (2022).
Half-Trek Criterion for Identifiability of Latent Variable Models.
<em>arXiv preprint</em> arXiv:2201.04457
</p>

<hr>
<h2 id='MixedGraph'>Construct MixedGraph object</h2><span id='topic+MixedGraph'></span>

<h3>Description</h3>

<p>Creates an object representing a mixed graph. The methods that are currently
available to be used on the mixed graph include
</p>

<ol>
<li><p> ancestors
</p>
</li>
<li><p> descendants
</p>
</li>
<li><p> parents
</p>
</li>
<li><p> siblings
</p>
</li>
<li><p> isSibling
</p>
</li>
<li><p> htrFrom
</p>
</li>
<li><p> trFrom
</p>
</li>
<li><p> getHalfTrekSystem
</p>
</li>
<li><p> getTrekSystem
</p>
</li>
<li><p> inducedSubgraph
</p>
</li>
<li><p> L
</p>
</li>
<li><p> O
</p>
</li>
<li><p> nodes
</p>
</li>
<li><p> numNodes
</p>
</li>
<li><p> stronglyConnectedComponent
</p>
</li>
<li><p> tianComponent
</p>
</li>
<li><p> tianDecompose
</p>
</li></ol>

<p>see the individual function documentation for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MixedGraph(
  L = matrix(0, 1, 1),
  O = matrix(0, 1, 1),
  vertexNums = seq(1, length = nrow(L))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MixedGraph_+3A_l">L</code></td>
<td>
<p>see <code><a href="#topic+graphID">graphID</a></code> for the appropriate form of L.</p>
</td></tr>
<tr><td><code id="MixedGraph_+3A_o">O</code></td>
<td>
<p>as for L.</p>
</td></tr>
<tr><td><code id="MixedGraph_+3A_vertexnums">vertexNums</code></td>
<td>
<p>the labeling of the vertices in the graph in the order
of the rows of L and O. Labels must be positive integers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object representing the MixedGraph
</p>

<hr>
<h2 id='mixedGraphHasSimpleNumbering'>Checks that a MixedGraph has appropriate node numbering</h2><span id='topic+mixedGraphHasSimpleNumbering'></span>

<h3>Description</h3>

<p>Checks that the input mixed graph has vertices are numbered from 1
to mixedGraph$numNodes(). Throws an error if they are not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixedGraphHasSimpleNumbering(mixedGraph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixedGraphHasSimpleNumbering_+3A_mixedgraph">mixedGraph</code></td>
<td>
<p>the mixed graph object</p>
</td></tr>
</table>

<hr>
<h2 id='nodes'>Get all nodes in the graph.</h2><span id='topic+nodes'></span><span id='topic+nodes.MixedGraph'></span>

<h3>Description</h3>

<p>Get all nodes in the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodes(this, ...)

## S3 method for class 'MixedGraph'
nodes(this, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nodes_+3A_this">this</code></td>
<td>
<p>the mixed graph object</p>
</td></tr>
<tr><td><code id="nodes_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='numLatents'>Number of latent nodes in the graph.</h2><span id='topic+numLatents'></span><span id='topic+numLatents.LatentDigraphFixedOrder'></span><span id='topic+numLatents.LatentDigraph'></span>

<h3>Description</h3>

<p>Number of latent nodes in the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numLatents(this, ...)

## S3 method for class 'LatentDigraphFixedOrder'
numLatents(this, ...)

## S3 method for class 'LatentDigraph'
numLatents(this, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numLatents_+3A_this">this</code></td>
<td>
<p>the graph object</p>
</td></tr>
<tr><td><code id="numLatents_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='numNodes'>Number of nodes in the graph.</h2><span id='topic+numNodes'></span><span id='topic+numNodes.LatentDigraphFixedOrder'></span><span id='topic+numNodes.LatentDigraph'></span><span id='topic+numNodes.MixedGraph'></span>

<h3>Description</h3>

<p>Number of nodes in the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numNodes(this, ...)

## S3 method for class 'LatentDigraphFixedOrder'
numNodes(this, ...)

## S3 method for class 'LatentDigraph'
numNodes(this, ...)

## S3 method for class 'MixedGraph'
numNodes(this, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numNodes_+3A_this">this</code></td>
<td>
<p>the graph object</p>
</td></tr>
<tr><td><code id="numNodes_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='numObserved'>Number of observed nodes in the graph.</h2><span id='topic+numObserved'></span><span id='topic+numObserved.LatentDigraphFixedOrder'></span><span id='topic+numObserved.LatentDigraph'></span>

<h3>Description</h3>

<p>Number of observed nodes in the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numObserved(this, ...)

## S3 method for class 'LatentDigraphFixedOrder'
numObserved(this, ...)

## S3 method for class 'LatentDigraph'
numObserved(this, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numObserved_+3A_this">this</code></td>
<td>
<p>the graph object</p>
</td></tr>
<tr><td><code id="numObserved_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='O'>Get adjacency matrix for bidirected part.</h2><span id='topic+O'></span><span id='topic+O.MixedGraph'></span>

<h3>Description</h3>

<p>Get adjacency matrix for bidirected part.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>O(this, ...)

## S3 method for class 'MixedGraph'
O(this, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="O_+3A_this">this</code></td>
<td>
<p>the mixed graph object</p>
</td></tr>
<tr><td><code id="O_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='observedNodes'>Get all observed nodes in the graph.</h2><span id='topic+observedNodes'></span><span id='topic+observedNodes.LatentDigraph'></span>

<h3>Description</h3>

<p>Get all observed nodes in the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>observedNodes(this, ...)

## S3 method for class 'LatentDigraph'
observedNodes(this, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="observedNodes_+3A_this">this</code></td>
<td>
<p>the graph object</p>
</td></tr>
<tr><td><code id="observedNodes_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='observedParents'>Get the observed parents on a collection of nodes</h2><span id='topic+observedParents'></span><span id='topic+observedParents.LatentDigraph'></span>

<h3>Description</h3>

<p>Get the observed parents on a collection of nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>observedParents(this, nodes, ...)

## S3 method for class 'LatentDigraph'
observedParents(this, nodes, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="observedParents_+3A_this">this</code></td>
<td>
<p>the graph object</p>
</td></tr>
<tr><td><code id="observedParents_+3A_nodes">nodes</code></td>
<td>
<p>the nodes on which to get the observed parents</p>
</td></tr>
<tr><td><code id="observedParents_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='parents'>All parents of a collection of nodes.</h2><span id='topic+parents'></span><span id='topic+parents.LatentDigraphFixedOrder'></span><span id='topic+parents.LatentDigraph'></span><span id='topic+parents.MixedGraph'></span>

<h3>Description</h3>

<p>Returns all parents of the collection (does not necessarily include the
input nodes themselves unless they are parents of one another).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parents(this, nodes, ...)

## S3 method for class 'LatentDigraphFixedOrder'
parents(this, nodes, includeObserved = T, includeLatents = T, ...)

## S3 method for class 'LatentDigraph'
parents(this, nodes, includeObserved = T, includeLatents = T, ...)

## S3 method for class 'MixedGraph'
parents(this, nodes, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parents_+3A_this">this</code></td>
<td>
<p>the graph object.</p>
</td></tr>
<tr><td><code id="parents_+3A_nodes">nodes</code></td>
<td>
<p>nodes the nodes of which to find the parents.</p>
</td></tr>
<tr><td><code id="parents_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="parents_+3A_includeobserved">includeObserved</code></td>
<td>
<p>if TRUE includes observed nodes in the returned set.</p>
</td></tr>
<tr><td><code id="parents_+3A_includelatents">includeLatents</code></td>
<td>
<p>if TRUE includes latent nodes in the returned set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the observed parents.
</p>

<hr>
<h2 id='plot.LatentDigraph'>Plots the latent digraph</h2><span id='topic+plot.LatentDigraph'></span><span id='topic+plot.MixedGraph'></span>

<h3>Description</h3>

<p>Plots the latent digraph
</p>
<p>Plots the mixed graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LatentDigraph'
plot(x, ...)

## S3 method for class 'MixedGraph'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.LatentDigraph_+3A_x">x</code></td>
<td>
<p>the mixed graph object</p>
</td></tr>
<tr><td><code id="plot.LatentDigraph_+3A_...">...</code></td>
<td>
<p>additional plotting arguments. Currently ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='plotLatentDigraph'>Plot a latent factor graph</h2><span id='topic+plotLatentDigraph'></span>

<h3>Description</h3>

<p>Given an adjacency matrix representing the directed edges in a latent
factor graph, plots a representation of the graph. The latent nodes
should come last in L and the vertex labels should only be given for the
observed nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLatentDigraph(L, observedNodes, latentNodes, main = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotLatentDigraph_+3A_l">L</code></td>
<td>
<p>Adjacency matrix for the directed part of the path
diagram/mixed graph; an edge pointing from i to j is encoded as L[i,j]=1 and
the lack of an edge between i and j is encoded as L[i,j]=0. There should be
no directed self loops, i.e. no i such that L[i,i]=1.</p>
</td></tr>
<tr><td><code id="plotLatentDigraph_+3A_observednodes">observedNodes</code></td>
<td>
<p>a vector of positive integers representing
the vertex numbers of the observed nodes. These will correspond,
in order, to the first length(observedNodes) rows of L.</p>
</td></tr>
<tr><td><code id="plotLatentDigraph_+3A_latentnodes">latentNodes</code></td>
<td>
<p>a vector of positive integers representing
the vertex numbers of the latent nodes. These will correspond,
in order, to the last length(latentNodes) rows of L.</p>
</td></tr>
<tr><td><code id="plotLatentDigraph_+3A_main">main</code></td>
<td>
<p>the plot title.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object representing the LatentDigraph
</p>

<hr>
<h2 id='plotMixedGraph'>Plot a mixed graph</h2><span id='topic+plotMixedGraph'></span>

<h3>Description</h3>

<p>Given adjacency matrices representing the directed and bidirected portions
of a mixed graph, plots a representation of the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMixedGraph(L, O, main = "", vertexLabels = 1:nrow(L))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotMixedGraph_+3A_l">L</code></td>
<td>
<p>Adjacency matrix for the directed part of the path
diagram/mixed graph; an edge pointing from i to j is encoded as L[i,j]=1 and
the lack of an edge between i and j is encoded as L[i,j]=0. There should be
no directed self loops, i.e. no i such that L[i,i]=1.</p>
</td></tr>
<tr><td><code id="plotMixedGraph_+3A_o">O</code></td>
<td>
<p>Adjacency matrix for the bidirected part of the path diagram/mixed
graph. Edges are encoded as for the L parameter. Again there should be no
self loops. Also this matrix will be coerced to be symmetric so it is only
necessary to specify an edge once, i.e. if O[i,j]=1 you may, but are not
required to, also have O[j,i]=1.</p>
</td></tr>
<tr><td><code id="plotMixedGraph_+3A_main">main</code></td>
<td>
<p>the plot title.</p>
</td></tr>
<tr><td><code id="plotMixedGraph_+3A_vertexlabels">vertexLabels</code></td>
<td>
<p>labels to use for the vertices.</p>
</td></tr>
</table>

<hr>
<h2 id='print.GenericIDResult'>Prints a GenericIDResult object</h2><span id='topic+print.GenericIDResult'></span>

<h3>Description</h3>

<p>Prints a GenericIDResult object as returned by
<code><a href="#topic+generalGenericID">generalGenericID</a></code>. Invisibly returns its argument via
<code><a href="base.html#topic+invisible">invisible</a>(x)</code> as most print functions do.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GenericIDResult'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.GenericIDResult_+3A_x">x</code></td>
<td>
<p>the GenericIDResult object</p>
</td></tr>
<tr><td><code id="print.GenericIDResult_+3A_...">...</code></td>
<td>
<p>optional parameters, currently unused.</p>
</td></tr>
</table>

<hr>
<h2 id='print.LfhtcIDResult'>Prints a LfhtcIDResult object</h2><span id='topic+print.LfhtcIDResult'></span>

<h3>Description</h3>

<p>Prints a LfhtcIDResult object as returned by
<code><a href="#topic+lfhtcID">lfhtcID</a></code>. Invisibly returns its argument via
<code><a href="base.html#topic+invisible">invisible</a>(x)</code> as most print functions do.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LfhtcIDResult'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.LfhtcIDResult_+3A_x">x</code></td>
<td>
<p>the LfhtcIDResult object</p>
</td></tr>
<tr><td><code id="print.LfhtcIDResult_+3A_...">...</code></td>
<td>
<p>optional parameters, currently unused.</p>
</td></tr>
</table>

<hr>
<h2 id='print.SEMIDResult'>Prints a SEMIDResult object</h2><span id='topic+print.SEMIDResult'></span>

<h3>Description</h3>

<p>Prints a SEMIDResult object as returned by
<code><a href="#topic+semID">semID</a></code>. Invisibly returns its argument via
<code><a href="base.html#topic+invisible">invisible</a>(x)</code> as most print functions do.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SEMIDResult'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.SEMIDResult_+3A_x">x</code></td>
<td>
<p>the SEMIDResult object</p>
</td></tr>
<tr><td><code id="print.SEMIDResult_+3A_...">...</code></td>
<td>
<p>optional parameters, currently unused.</p>
</td></tr>
</table>

<hr>
<h2 id='semID'>Identifiability of linear structural equation models.</h2><span id='topic+semID'></span>

<h3>Description</h3>

<p>This function can be used to check global and generic identifiability of
linear structural equation models (L-SEMs). In particular, this function
takes a <code><a href="#topic+MixedGraph">MixedGraph</a></code> object corresponding to the L-SEM and
checks different conditions known for global and generic identifiability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semID(
  mixedGraph,
  testGlobalID = TRUE,
  testGenericNonID = TRUE,
  genericIdStepFunctions = list(htcIdentifyStep),
  tianDecompose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semID_+3A_mixedgraph">mixedGraph</code></td>
<td>
<p>a <code><a href="#topic+MixedGraph">MixedGraph</a></code> object representing the L-SEM.</p>
</td></tr>
<tr><td><code id="semID_+3A_testglobalid">testGlobalID</code></td>
<td>
<p>TRUE or FALSE if the graph should be tested for global
identifiability. This uses the <code><a href="#topic+globalID">globalID</a></code>
function.</p>
</td></tr>
<tr><td><code id="semID_+3A_testgenericnonid">testGenericNonID</code></td>
<td>
<p>TRUE of FALSE if the graph should be tested for
generic non-identifiability, that is, if for every generic choice
of parameters for the L-SEM there are infinitely many
other choices that lead to the same covariance matrix. This currently
uses the <code><a href="#topic+graphID.nonHtcID">graphID.nonHtcID</a></code> function.</p>
</td></tr>
<tr><td><code id="semID_+3A_genericidstepfunctions">genericIdStepFunctions</code></td>
<td>
<p>a list of the generic identifier step functions
that should be used for testing generic identifiability. See
<code><a href="#topic+generalGenericID">generalGenericID</a></code> for a discussion of such functions. If
this list is empty then generic identifiability is not tested. By
default this will (only) run the half-trek criterion (see
<code><a href="#topic+htcIdentifyStep">htcIdentifyStep</a></code>) for generic identifiability.</p>
</td></tr>
<tr><td><code id="semID_+3A_tiandecompose">tianDecompose</code></td>
<td>
<p>TRUE or FALSE if the mixed graph should be Tian
decomposed before running the identification algorithms
(when appropriate). In general letting this be TRUE will
make the algorithm faster and more powerful. Note that
this is a version of the Tian decomposition that works
also with cyclic graphs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object of <a href="base.html#topic+class">class</a> '<code>SEMIDResult</code>,' this
object is just a list with 6 components:
</p>

<dl>
<dt><code>isGlobalID</code></dt><dd><p>If testGlobalID == TRUE, then TRUE or FALSE if
the graph is globally identifiable. If testGlobalID == FALSE then NA.</p>
</dd>
<dt><code>isGenericNonID</code></dt><dd><p>If testGenericNonID == TRUE, then TRUE if the
graph is generically non-identifiable or FALSE the test is inconclusive.
If testGenericNonID == FALSE then NA.</p>
</dd>
<dt><code>genericIDResult</code></dt><dd><p>If length(genericIdStepFunctions) != 0 then
a <code>GenericIDResult</code> object as returned by
<code><a href="#topic+generalGenericID">generalGenericID</a></code>. Otherwise a list of length 0.</p>
</dd>
<dt><code>mixedGraph</code></dt><dd><p>the inputted mixed graph object.</p>
</dd>
<dt><code>tianDecompose</code></dt><dd><p>the argument tianDecompose.</p>
</dd>
<dt><code>call</code></dt><dd><p>the call made to this function.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
L = t(matrix(
  c(0, 1, 0, 0, 0,
    0, 0, 1, 0, 0,
    0, 0, 0, 1, 0,
    0, 0, 0, 0, 1,
    0, 0, 0, 0, 0), 5, 5))
O = t(matrix(
  c(0, 0, 1, 1, 0,
    0, 0, 0, 1, 1,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0), 5, 5))
O = O + t(O)
graph = MixedGraph(L,O)
semID(graph)

## Examples from Foygel, Draisma &amp; Drton (2012)
demo(SEMID)

## End(Not run)
</code></pre>

<hr>
<h2 id='siblings'>All siblings of a collection of nodes</h2><span id='topic+siblings'></span><span id='topic+siblings.MixedGraph'></span>

<h3>Description</h3>

<p>All siblings of a collection of nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>siblings(this, nodes, ...)

## S3 method for class 'MixedGraph'
siblings(this, nodes, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="siblings_+3A_this">this</code></td>
<td>
<p>the mixed graph object</p>
</td></tr>
<tr><td><code id="siblings_+3A_nodes">nodes</code></td>
<td>
<p>a vector of nodes of which to find the siblings.</p>
</td></tr>
<tr><td><code id="siblings_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of all of the siblings.
</p>

<hr>
<h2 id='stronglyConnectedComponent'>Strongly connected component</h2><span id='topic+stronglyConnectedComponent'></span><span id='topic+stronglyConnectedComponent.LatentDigraphFixedOrder'></span><span id='topic+stronglyConnectedComponent.LatentDigraph'></span><span id='topic+stronglyConnectedComponent.MixedGraph'></span>

<h3>Description</h3>

<p>Get the strongly connected component for a node i in the graph the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stronglyConnectedComponent(this, node, ...)

## S3 method for class 'LatentDigraphFixedOrder'
stronglyConnectedComponent(this, node, ...)

## S3 method for class 'LatentDigraph'
stronglyConnectedComponent(this, node, ...)

## S3 method for class 'MixedGraph'
stronglyConnectedComponent(this, node, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stronglyConnectedComponent_+3A_this">this</code></td>
<td>
<p>the graph object</p>
</td></tr>
<tr><td><code id="stronglyConnectedComponent_+3A_node">node</code></td>
<td>
<p>the node for which to get the strongly connected component.</p>
</td></tr>
<tr><td><code id="stronglyConnectedComponent_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='subsetsOfSize'>Returns all subsets of a certain size</h2><span id='topic+subsetsOfSize'></span>

<h3>Description</h3>

<p>For an input vector x, returns in a list, the collection of all subsets
of x of size k.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetsOfSize(x, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subsetsOfSize_+3A_x">x</code></td>
<td>
<p>a vector from which to get subsets</p>
</td></tr>
<tr><td><code id="subsetsOfSize_+3A_k">k</code></td>
<td>
<p>the size of the subsets returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of all subsets of x of a given size k
</p>

<hr>
<h2 id='tianComponent'>Returns the Tian c-component of a node</h2><span id='topic+tianComponent'></span><span id='topic+tianComponent.MixedGraph'></span>

<h3>Description</h3>

<p>Returns the Tian c-component of a node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tianComponent(this, node)

## S3 method for class 'MixedGraph'
tianComponent(this, node)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tianComponent_+3A_this">this</code></td>
<td>
<p>the mixed graph object</p>
</td></tr>
<tr><td><code id="tianComponent_+3A_node">node</code></td>
<td>
<p>the node for which to return its c-component</p>
</td></tr>
</table>

<hr>
<h2 id='tianDecompose'>Performs the tian decomposition on the mixed graph</h2><span id='topic+tianDecompose'></span><span id='topic+tianDecompose.MixedGraph'></span>

<h3>Description</h3>

<p>Uses the Tian decomposition to break the mixed graph into c-components.
These c-components are slightly different than those from Tian (2005)
in that if they graph is not acyclic the bidirected components are
combined whenever they are connected by a directed loop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tianDecompose(this)

## S3 method for class 'MixedGraph'
tianDecompose(this)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tianDecompose_+3A_this">this</code></td>
<td>
<p>the mixed graph object</p>
</td></tr>
</table>


<h3>References</h3>

<p>Jin Tian. 2005. Identifying direct causal effects in linear models. In
<em>Proceedings of the 20th national conference on Artificial intelligence
- Volume 1</em> (AAAI'05), Anthony Cohn (Ed.), Vol. 1. AAAI Press 346-352.
</p>

<hr>
<h2 id='tianIdentifier'>Identifies components in a tian decomposition</h2><span id='topic+tianIdentifier'></span>

<h3>Description</h3>

<p>Creates an identification function which combines the identification
functions created on a collection of c-components into a identification
for the full mixed graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tianIdentifier(idFuncs, cComponents)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tianIdentifier_+3A_idfuncs">idFuncs</code></td>
<td>
<p>a list of identifier functions for the c-components</p>
</td></tr>
<tr><td><code id="tianIdentifier_+3A_ccomponents">cComponents</code></td>
<td>
<p>the c-components of the mixed graph as returned by
<code><a href="#topic+tianDecompose">tianDecompose</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new identifier function
</p>

<hr>
<h2 id='tianSigmaForComponent'>Globally identify the covariance matrix of a C-component</h2><span id='topic+tianSigmaForComponent'></span>

<h3>Description</h3>

<p>The Tian decomposition of a mixed graph G allows one to globally identify
the covariance matrices Sigma' of special subgraphs of G called c-components.
This function takes the covariance matrix Sigma corresponding to G and
a collection of node sets which specify the c-component, and returns the
Sigma' corresponding to the c-component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tianSigmaForComponent(Sigma, internal, incoming, topOrder)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tianSigmaForComponent_+3A_sigma">Sigma</code></td>
<td>
<p>the covariance matrix for the mixed graph G</p>
</td></tr>
<tr><td><code id="tianSigmaForComponent_+3A_internal">internal</code></td>
<td>
<p>an integer vector corresponding to the vertices of the
C-component that are in the bidirected equivalence classes (if the
graph is not-acyclic then these equivalence classes must be enlarged
by combining two bidirected components if there are two vertices, one
in each component, that are simultaneously on the same directed cycle).</p>
</td></tr>
<tr><td><code id="tianSigmaForComponent_+3A_incoming">incoming</code></td>
<td>
<p>the parents of vertices in internal that are not in the set
internal themselves</p>
</td></tr>
<tr><td><code id="tianSigmaForComponent_+3A_toporder">topOrder</code></td>
<td>
<p>a topological ordering of c(internal, incoming) with respect
to the graph G. For vertices in a strongly connected component the
ordering is allowed to be arbitrary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the new Sigma corresponding to the c-component
</p>

<hr>
<h2 id='toEx'>Transforms a vector of node indices in the internal rep. into external numbering</h2><span id='topic+toEx'></span><span id='topic+toEx.LatentDigraph'></span><span id='topic+toEx.MixedGraph'></span>

<h3>Description</h3>

<p>Transforms a vector of node indices in the internal rep. into external numbering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toEx(this, nodes, ...)

## S3 method for class 'LatentDigraph'
toEx(this, nodes, ...)

## S3 method for class 'MixedGraph'
toEx(this, nodes, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="toEx_+3A_this">this</code></td>
<td>
<p>the graph object</p>
</td></tr>
<tr><td><code id="toEx_+3A_nodes">nodes</code></td>
<td>
<p>the nodes to transform</p>
</td></tr>
<tr><td><code id="toEx_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='toIn'>Transforms a vector of given node indices into their internal numbering</h2><span id='topic+toIn'></span><span id='topic+toIn.LatentDigraph'></span><span id='topic+toIn.MixedGraph'></span>

<h3>Description</h3>

<p>Transforms a vector of given node indices into their internal numbering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toIn(this, nodes, ...)

## S3 method for class 'LatentDigraph'
toIn(this, nodes, ...)

## S3 method for class 'MixedGraph'
toIn(this, nodes, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="toIn_+3A_this">this</code></td>
<td>
<p>the graph object</p>
</td></tr>
<tr><td><code id="toIn_+3A_nodes">nodes</code></td>
<td>
<p>the nodes to transform</p>
</td></tr>
<tr><td><code id="toIn_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='trekSeparationIdentifyStep'>Perform one iteration of trek separation identification.</h2><span id='topic+trekSeparationIdentifyStep'></span>

<h3>Description</h3>

<p>A function that does one step through all the nodes in a mixed graph
and tries to identify new edge coefficients using trek-separation as
described in Weihs, Robeva, Robinson, et al. (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trekSeparationIdentifyStep(
  mixedGraph,
  unsolvedParents,
  solvedParents,
  identifier,
  maxSubsetSize = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trekSeparationIdentifyStep_+3A_mixedgraph">mixedGraph</code></td>
<td>
<p>a <code><a href="#topic+MixedGraph">MixedGraph</a></code> object representing
the mixed graph.</p>
</td></tr>
<tr><td><code id="trekSeparationIdentifyStep_+3A_unsolvedparents">unsolvedParents</code></td>
<td>
<p>a list whose ith index is a vector of all the parents
j of i in G which for which the edge j-&gt;i is not yet known to be
generically identifiable.</p>
</td></tr>
<tr><td><code id="trekSeparationIdentifyStep_+3A_solvedparents">solvedParents</code></td>
<td>
<p>the complement of <code>unsolvedParents</code>, a list whose
ith index is a vector of all parents j of i for which the edge i-&gt;j
is known to be generically identifiable (perhaps by other algorithms).</p>
</td></tr>
<tr><td><code id="trekSeparationIdentifyStep_+3A_identifier">identifier</code></td>
<td>
<p>an identification function that must produce the
identifications corresponding to those in solved parents. That is
<code>identifier</code> should be a function taking a single argument Sigma
(any generically generated covariance matrix corresponding
to the mixed graph) and returns a list with two named arguments
</p>

<dl>
<dt>Lambda</dt><dd><p>denote the number of nodes in <code>mixedGraph</code> as n. Then
Lambda is an nxn matrix whose i,jth entry
</p>

<ol>
<li><p> equals 0 if i is not a parent of j,
</p>
</li>
<li><p> equals NA if i is a parent of j but <code>identifier</code> cannot
identify it generically,
</p>
</li>
<li><p> equals the (generically) unique value corresponding to the weight
along the edge i-&gt;j that was used to produce Sigma.
</p>
</li></ol>
</dd>
<dt>Omega</dt><dd><p>just as Lambda but for the bidirected edges in the mixed
graph</p>
</dd>
</dl>

<p>such that if j is in <code>solvedParents[[i]]</code> we must have that
Lambda[j,i] is not NA.</p>
</td></tr>
<tr><td><code id="trekSeparationIdentifyStep_+3A_maxsubsetsize">maxSubsetSize</code></td>
<td>
<p>a positive integer which controls the maximum subset
size considered in the trek-separation identification
algorithm. Making this parameter smaller means the
algorithm will be faster but less exhaustive (and hence
less powerful).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>see the return of <code><a href="#topic+htcIdentifyStep">htcIdentifyStep</a></code>.
</p>

<hr>
<h2 id='trFrom'>Trek reachable nodes.</h2><span id='topic+trFrom'></span><span id='topic+trFrom.LatentDigraphFixedOrder'></span><span id='topic+trFrom.LatentDigraph'></span><span id='topic+trFrom.MixedGraph'></span>

<h3>Description</h3>

<p>Gets all nodes that are trek reachable from a collection of nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trFrom(this, nodes, ...)

## S3 method for class 'LatentDigraphFixedOrder'
trFrom(
  this,
  nodes,
  avoidLeftNodes = integer(0),
  avoidRightNodes = integer(0),
  includeObserved = T,
  includeLatents = T,
  ...
)

## S3 method for class 'LatentDigraph'
trFrom(
  this,
  nodes,
  avoidLeftNodes = integer(0),
  avoidRightNodes = integer(0),
  includeObserved = T,
  includeLatents = T,
  ...
)

## S3 method for class 'MixedGraph'
trFrom(
  this,
  nodes,
  avoidLeftNodes = integer(0),
  avoidRightNodes = integer(0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trFrom_+3A_this">this</code></td>
<td>
<p>the graph object</p>
</td></tr>
<tr><td><code id="trFrom_+3A_nodes">nodes</code></td>
<td>
<p>the nodes from which to find trek-reachable nodes.</p>
</td></tr>
<tr><td><code id="trFrom_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="trFrom_+3A_avoidleftnodes">avoidLeftNodes</code></td>
<td>
<p>a collection of nodes to avoid on the left</p>
</td></tr>
<tr><td><code id="trFrom_+3A_avoidrightnodes">avoidRightNodes</code></td>
<td>
<p>a collection of nodes to avoid on the right</p>
</td></tr>
<tr><td><code id="trFrom_+3A_includeobserved">includeObserved</code></td>
<td>
<p>if TRUE includes observed nodes in the returned set.</p>
</td></tr>
<tr><td><code id="trFrom_+3A_includelatents">includeLatents</code></td>
<td>
<p>if TRUE includes latent nodes in the returned set.</p>
</td></tr>
</table>

<hr>
<h2 id='updateEdgeCapacities'>Update edge capacities.</h2><span id='topic+updateEdgeCapacities'></span><span id='topic+updateEdgeCapacities.FlowGraph'></span>

<h3>Description</h3>

<p>Update edge capacities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateEdgeCapacities(this, edges, newCaps)

## S3 method for class 'FlowGraph'
updateEdgeCapacities(this, edges, newCaps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="updateEdgeCapacities_+3A_this">this</code></td>
<td>
<p>the flow graph object</p>
</td></tr>
<tr><td><code id="updateEdgeCapacities_+3A_edges">edges</code></td>
<td>
<p>the vertices to update (as a 2xr matrix with ith row
corresponding to the edge edges[1,i]-&gt;edges[2,i].</p>
</td></tr>
<tr><td><code id="updateEdgeCapacities_+3A_newcaps">newCaps</code></td>
<td>
<p>the new capacities for the edges</p>
</td></tr>
</table>

<hr>
<h2 id='updateVertexCapacities'>Update vertex capacities.</h2><span id='topic+updateVertexCapacities'></span><span id='topic+updateVertexCapacities.FlowGraph'></span>

<h3>Description</h3>

<p>Update vertex capacities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateVertexCapacities(this, vertices, newCaps)

## S3 method for class 'FlowGraph'
updateVertexCapacities(this, vertices, newCaps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="updateVertexCapacities_+3A_this">this</code></td>
<td>
<p>the flow graph object</p>
</td></tr>
<tr><td><code id="updateVertexCapacities_+3A_vertices">vertices</code></td>
<td>
<p>the vertices to update.</p>
</td></tr>
<tr><td><code id="updateVertexCapacities_+3A_newcaps">newCaps</code></td>
<td>
<p>the new capacities for the vertices.</p>
</td></tr>
</table>

<hr>
<h2 id='validateLatentNodesAreSources'>A helper function to validate that latent nodes in a LatentDigraph are sources.</h2><span id='topic+validateLatentNodesAreSources'></span>

<h3>Description</h3>

<p>Produces an error if not all latent nodes are sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateLatentNodesAreSources(graph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validateLatentNodesAreSources_+3A_graph">graph</code></td>
<td>
<p>the LatentDigraph</p>
</td></tr>
</table>

<hr>
<h2 id='validateMatrices'>A helper function to validate input matrices.</h2><span id='topic+validateMatrices'></span>

<h3>Description</h3>

<p>This helper function validates that the two input matrices, L and O, are of
the appropriate form to be interpreted by the other functions. In particular
they should be square matrices of 1's and 0's with all 0's along their
diagonals. We do not require O to be symmetric here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateMatrices(L, O)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validateMatrices_+3A_l">L</code></td>
<td>
<p>See above description.</p>
</td></tr>
<tr><td><code id="validateMatrices_+3A_o">O</code></td>
<td>
<p>See above description.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function has no return value.
</p>

<hr>
<h2 id='validateMatrix'>A helper function to validate an input matrix.</h2><span id='topic+validateMatrix'></span>

<h3>Description</h3>

<p>This helper function validates that an input matrix, L, is of the
the appropriate form to be interpreted by the other functions. In particular
it should be square matrix of 1's and 0's with all 0's along its
diagonal. If any of the above conditions is not met, this function will
throw an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateMatrix(L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validateMatrix_+3A_l">L</code></td>
<td>
<p>See above description.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>

<hr>
<h2 id='validateNodes'>A helper function to validate if input nodes are valid.</h2><span id='topic+validateNodes'></span>

<h3>Description</h3>

<p>Produces an error if outside bounds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateNodes(nodes, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validateNodes_+3A_nodes">nodes</code></td>
<td>
<p>the input nodes, expected to be from the collection
1:(number of nodes in the graph)</p>
</td></tr>
<tr><td><code id="validateNodes_+3A_numnodes">numNodes</code></td>
<td>
<p>the number of observed nodes in the graph.</p>
</td></tr>
</table>

<hr>
<h2 id='validateVarArgsEmpty'>A helper function to validate that there are no variable arguments</h2><span id='topic+validateVarArgsEmpty'></span>

<h3>Description</h3>

<p>Produces an error if there are variable arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateVarArgsEmpty(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validateVarArgsEmpty_+3A_...">...</code></td>
<td>
<p>the variable arguments</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
