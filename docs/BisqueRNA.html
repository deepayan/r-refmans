<!DOCTYPE html><html><head><title>Help for package BisqueRNA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BisqueRNA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CalculateSCCellProportions'><p>Calculate cell proportions based on single-cell data</p></a></li>
<li><a href='#CorTri'><p>Correlate columns of data frame</p></a></li>
<li><a href='#CountsToCPM'><p>Convert counts data in Expression Set to counts per million (CPM)</p></a></li>
<li><a href='#EstimatePCACellTypeProportions'><p>Estimate cell type proportions using first PC of expression matrix</p></a></li>
<li><a href='#FilterUnexpressedGenes'><p>Remove genes in Expression Set with zero expression in all samples</p></a></li>
<li><a href='#FilterZeroVarianceGenes'><p>Remove genes in Expression Set with zero variance across samples</p></a></li>
<li><a href='#GenerateSCReference'><p>Generate reference profile for cell types identified in single-cell data</p></a></li>
<li><a href='#GetCTP'><p>Return cell type proportions from bulk</p></a></li>
<li><a href='#GetNumGenes'><p>Get number of genes to use with no weighted information</p></a></li>
<li><a href='#GetNumGenesWeighted'><p>Get number of genes to use with weighted PCA</p></a></li>
<li><a href='#GetOverlappingGenes'><p>Find overlapping genes in single-cell data, bulk data, and marker genes</p></a></li>
<li><a href='#GetOverlappingSamples'><p>Find overlapping samples in single-cell and bulk data</p></a></li>
<li><a href='#GetUniqueMarkers'><p>Get unique markers present in only 1 cell type</p></a></li>
<li><a href='#MarkerBasedDecomposition'><p>Performs marker-based decomposition of bulk expression using marker genes</p></a></li>
<li><a href='#ReferenceBasedDecomposition'><p>Performs reference-based decomposition of bulk expression using single-cell</p>
data</a></li>
<li><a href='#SemisupervisedTransformBulk'><p>Transforms bulk expression of a gene using only single-cell data</p></a></li>
<li><a href='#SeuratToExpressionSet'><p>Converts Seurat object to Expression Set</p></a></li>
<li><a href='#SimulateBarcode'><p>Simulate barcode for decomposition illustration</p></a></li>
<li><a href='#SimulateData'><p>Simulate data for decomposition illustration</p></a></li>
<li><a href='#SupervisedTransformBulk'><p>Transforms bulk expression of a gene given overlapping data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Decomposition of Bulk Expression with Single-Cell Sequencing</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools to accurately estimate cell type abundances 
    from heterogeneous bulk expression. A reference-based method utilizes
    single-cell information to generate a signature matrix and transformation
    of bulk expression for accurate regression based estimates. A marker-based
    method utilizes known cell-specific marker genes to measure relative
    abundances across samples.
    For more details, see Jew and Alvarez et al (2019) &lt;<a href="https://doi.org/10.1101%2F669911">doi:10.1101/669911</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>false</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>Biobase, limSolve, methods, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Seurat, plyr, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.biorxiv.org/content/10.1101/669911v1">https://www.biorxiv.org/content/10.1101/669911v1</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cozygene/bisque/issues">https://github.com/cozygene/bisque/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-23 20:57:46 UTC; bjew</td>
</tr>
<tr>
<td>Author:</td>
<td>Brandon Jew [aut, cre],
  Marcus Alvarez [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brandon Jew &lt;brandon.jew@ucla.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-23 21:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='CalculateSCCellProportions'>Calculate cell proportions based on single-cell data</h2><span id='topic+CalculateSCCellProportions'></span>

<h3>Description</h3>

<p>Returns proportion of each cell type out of total cells for each individual
in the single-cell Expression Set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateSCCellProportions(sc.eset, subject.names, cell.types)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateSCCellProportions_+3A_sc.eset">sc.eset</code></td>
<td>
<p>Expression Set with single-cell data</p>
</td></tr>
<tr><td><code id="CalculateSCCellProportions_+3A_subject.names">subject.names</code></td>
<td>
<p>A character string. Name of phenoData attribute in 
sc.eset that indicates individual ID.</p>
</td></tr>
<tr><td><code id="CalculateSCCellProportions_+3A_cell.types">cell.types</code></td>
<td>
<p>A character string. Name of phenoData attribute in sc.eset
that indicates cell type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sc.props Matrix. Cell proportions with number of cell types rows 
by number of individuals columns
</p>

<hr>
<h2 id='CorTri'>Correlate columns of data frame</h2><span id='topic+CorTri'></span>

<h3>Description</h3>

<p>This function runs correlation between markers of a data frame or matrix, 
returning the values of the lower/upper triangular of the correlation matrix
in a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CorTri(x, method = "pearson")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CorTri_+3A_x">x</code></td>
<td>
<p>Data frame or matrix. Column vectors are correlated</p>
</td></tr>
<tr><td><code id="CorTri_+3A_method">method</code></td>
<td>
<p>Character string. Name of method passed to cor. 
Pearson by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cors Numeric vector. Correlation coefficients of pairs
</p>

<hr>
<h2 id='CountsToCPM'>Convert counts data in Expression Set to counts per million (CPM)</h2><span id='topic+CountsToCPM'></span>

<h3>Description</h3>

<p>Convert counts data in Expression Set to counts per million (CPM)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CountsToCPM(eset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CountsToCPM_+3A_eset">eset</code></td>
<td>
<p>Expression Set containing counts assay data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>eset Expression Set containing CPM assay data
</p>

<hr>
<h2 id='EstimatePCACellTypeProportions'>Estimate cell type proportions using first PC of expression matrix</h2><span id='topic+EstimatePCACellTypeProportions'></span>

<h3>Description</h3>

<p>Estimate cell type proportions using first PC of expression matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstimatePCACellTypeProportions(x, weighted = FALSE, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EstimatePCACellTypeProportions_+3A_x">x</code></td>
<td>
<p>A sample by gene bulk expression matrix. Genes should be marker
genes</p>
</td></tr>
<tr><td><code id="EstimatePCACellTypeProportions_+3A_weighted">weighted</code></td>
<td>
<p>Boolean. If weighted=TRUE, multiply scaled gene expression by
gene weights</p>
</td></tr>
<tr><td><code id="EstimatePCACellTypeProportions_+3A_w">w</code></td>
<td>
<p>Numeric vector. Weights of genes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ret List. Attribute <strong>pcs</strong> contains matrix of PCs, where PC1
should be used as estimates for cell type abundances
Attribute <strong>sdev</strong> contains eigenvalues of eigendecomposition of
var-covar matrix. The 1st eigenvalue should explain most of the variance.
Attribute <strong>genes</strong> contains names of genes.
</p>

<hr>
<h2 id='FilterUnexpressedGenes'>Remove genes in Expression Set with zero expression in all samples</h2><span id='topic+FilterUnexpressedGenes'></span>

<h3>Description</h3>

<p>Remove genes in Expression Set with zero expression in all samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FilterUnexpressedGenes(eset, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FilterUnexpressedGenes_+3A_eset">eset</code></td>
<td>
<p>Expression Set</p>
</td></tr>
<tr><td><code id="FilterUnexpressedGenes_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Print logging info</p>
</td></tr>
</table>


<h3>Value</h3>

<p>eset Expression Set with zero expression genes removed
</p>

<hr>
<h2 id='FilterZeroVarianceGenes'>Remove genes in Expression Set with zero variance across samples</h2><span id='topic+FilterZeroVarianceGenes'></span>

<h3>Description</h3>

<p>Remove genes in Expression Set with zero variance across samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FilterZeroVarianceGenes(eset, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FilterZeroVarianceGenes_+3A_eset">eset</code></td>
<td>
<p>Expression Set</p>
</td></tr>
<tr><td><code id="FilterZeroVarianceGenes_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Print logging info</p>
</td></tr>
</table>


<h3>Value</h3>

<p>eset Expression Set with zero variance genes removed
</p>

<hr>
<h2 id='GenerateSCReference'>Generate reference profile for cell types identified in single-cell data</h2><span id='topic+GenerateSCReference'></span>

<h3>Description</h3>

<p>Averages expression within each cell type across all samples to use as 
reference profile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateSCReference(sc.eset, cell.types)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenerateSCReference_+3A_sc.eset">sc.eset</code></td>
<td>
<p>Expression Set with single-cell data</p>
</td></tr>
<tr><td><code id="GenerateSCReference_+3A_cell.types">cell.types</code></td>
<td>
<p>A character string. Name of phenoData attribute in sc.eset
that indicates cell type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sc.ref Matrix. Reference profile with number of gene rows by number
of cell types columns.
</p>

<hr>
<h2 id='GetCTP'>Return cell type proportions from bulk</h2><span id='topic+GetCTP'></span>

<h3>Description</h3>

<p>Calculate cell type proportions from a data frame containing bulk expression
values. Uses PCA (weighted or regular) to estimate relative proportions
within each cell type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetCTP(
  bulk,
  cell_types,
  markers,
  ct_col,
  gene_col,
  min_gene,
  max_gene,
  weighted,
  w_col,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetCTP_+3A_bulk">bulk</code></td>
<td>
<p>Expression Set containing bulk data</p>
</td></tr>
<tr><td><code id="GetCTP_+3A_cell_types">cell_types</code></td>
<td>
<p>Character vector. Names of cell types.</p>
</td></tr>
<tr><td><code id="GetCTP_+3A_markers">markers</code></td>
<td>
<p>Data frame with columns specifying cluster and gene,
and optionally a column for weights, typically the fold-change of the gene.
Important that the genes for each cell type are row-sorted by signficance.</p>
</td></tr>
<tr><td><code id="GetCTP_+3A_ct_col">ct_col</code></td>
<td>
<p>Character string. Column name specifying cluster/cell type
corresponding to each marker gene in <strong>markers</strong>.</p>
</td></tr>
<tr><td><code id="GetCTP_+3A_gene_col">gene_col</code></td>
<td>
<p>Character string. Column name specifying gene names in
<strong>markers</strong>.</p>
</td></tr>
<tr><td><code id="GetCTP_+3A_min_gene">min_gene</code></td>
<td>
<p>Numeric. Min number of genes to use for each cell type.</p>
</td></tr>
<tr><td><code id="GetCTP_+3A_max_gene">max_gene</code></td>
<td>
<p>Numeric. Max number of genes to use for each cell type.</p>
</td></tr>
<tr><td><code id="GetCTP_+3A_weighted">weighted</code></td>
<td>
<p>Boolean. Whether to use weights for gene prioritization</p>
</td></tr>
<tr><td><code id="GetCTP_+3A_w_col">w_col</code></td>
<td>
<p>Character string. Column name for weights, such as &quot;avg_logFC&quot;,
in <strong>markers</strong></p>
</td></tr>
<tr><td><code id="GetCTP_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Whether to print log info during decomposition.
Errors will be printed regardless.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A List. Slot <strong>cors</strong> contains list of vectors with correlation
coefficients. Slot <strong>ctps</strong> contains list of CTP objects returned by
GetCTP
</p>

<hr>
<h2 id='GetNumGenes'>Get number of genes to use with no weighted information</h2><span id='topic+GetNumGenes'></span>

<h3>Description</h3>

<p>Get number of genes to use with no weighted information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetNumGenes(x, min.gene = 25, max.gene = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetNumGenes_+3A_x">x</code></td>
<td>
<p>Numeric Matrix. A sample by gene expression matrix containing the
marker genes.</p>
</td></tr>
<tr><td><code id="GetNumGenes_+3A_min.gene">min.gene</code></td>
<td>
<p>Numeric. Minimum number of genes to consider as markers.</p>
</td></tr>
<tr><td><code id="GetNumGenes_+3A_max.gene">max.gene</code></td>
<td>
<p>Numeric. Maximum number of genes to consider as markers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>best.n Numeric. Number of genes to use
</p>

<hr>
<h2 id='GetNumGenesWeighted'>Get number of genes to use with weighted PCA</h2><span id='topic+GetNumGenesWeighted'></span>

<h3>Description</h3>

<p>Get number of genes to use with weighted PCA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetNumGenesWeighted(x, w, min.gene = 25, max.gene = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetNumGenesWeighted_+3A_x">x</code></td>
<td>
<p>Numeric Matrix. A sample by gene expression matrix containing the
marker genes.</p>
</td></tr>
<tr><td><code id="GetNumGenesWeighted_+3A_w">w</code></td>
<td>
<p>Numeric Vector. The weights of the genes that correspond to the
columns of x.</p>
</td></tr>
<tr><td><code id="GetNumGenesWeighted_+3A_min.gene">min.gene</code></td>
<td>
<p>Numeric. Minimum number of genes to consider as markers.</p>
</td></tr>
<tr><td><code id="GetNumGenesWeighted_+3A_max.gene">max.gene</code></td>
<td>
<p>Numeric. Maximum number of genes to consider as markers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>best.n Numeric. Number of genes to use
</p>

<hr>
<h2 id='GetOverlappingGenes'>Find overlapping genes in single-cell data, bulk data, and marker genes</h2><span id='topic+GetOverlappingGenes'></span>

<h3>Description</h3>

<p>Find overlapping genes in single-cell data, bulk data, and marker genes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetOverlappingGenes(sc.eset, bulk.eset, markers, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetOverlappingGenes_+3A_sc.eset">sc.eset</code></td>
<td>
<p>Expression Set with single-cell data</p>
</td></tr>
<tr><td><code id="GetOverlappingGenes_+3A_bulk.eset">bulk.eset</code></td>
<td>
<p>Expression Set with bulk data</p>
</td></tr>
<tr><td><code id="GetOverlappingGenes_+3A_markers">markers</code></td>
<td>
<p>Character vector. List of relevant marker genes</p>
</td></tr>
<tr><td><code id="GetOverlappingGenes_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Print logging info</p>
</td></tr>
</table>


<h3>Value</h3>

<p>overlapping.genes Character vector. List of genes found in markers
and both datasets.
</p>

<hr>
<h2 id='GetOverlappingSamples'>Find overlapping samples in single-cell and bulk data</h2><span id='topic+GetOverlappingSamples'></span>

<h3>Description</h3>

<p>Find overlapping samples in single-cell and bulk data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetOverlappingSamples(sc.eset, bulk.eset, subject.names, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetOverlappingSamples_+3A_sc.eset">sc.eset</code></td>
<td>
<p>Expression Set with single-cell data</p>
</td></tr>
<tr><td><code id="GetOverlappingSamples_+3A_bulk.eset">bulk.eset</code></td>
<td>
<p>Expression Set with bulk data</p>
</td></tr>
<tr><td><code id="GetOverlappingSamples_+3A_subject.names">subject.names</code></td>
<td>
<p>A character string. Name of phenoData attribute in
sc.eset that indicates individual ID (that would be found in bulk.eset
if overlapping)</p>
</td></tr>
<tr><td><code id="GetOverlappingSamples_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Print logging info</p>
</td></tr>
</table>


<h3>Value</h3>

<p>samples A list with attributes <em>overlapping</em> and
<em>remaining</em>. Each attribute refers to a character vector that lists
the samples found in both datasets and samples found only in bulk,
respectively
</p>

<hr>
<h2 id='GetUniqueMarkers'>Get unique markers present in only 1 cell type</h2><span id='topic+GetUniqueMarkers'></span>

<h3>Description</h3>

<p>Given a data frame of marker genes for cell types, 
returns a new data frame with non-unique markers removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetUniqueMarkers(x, gene_col = "gene")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetUniqueMarkers_+3A_x">x</code></td>
<td>
<p>Data frame. Contains column with marker gene names</p>
</td></tr>
<tr><td><code id="GetUniqueMarkers_+3A_gene_col">gene_col</code></td>
<td>
<p>Character string. Name of the column that contains
the marker genes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x Data frame. Markers with non-unique markers removed
</p>

<hr>
<h2 id='MarkerBasedDecomposition'>Performs marker-based decomposition of bulk expression using marker genes</h2><span id='topic+MarkerBasedDecomposition'></span>

<h3>Description</h3>

<p>Estimates relative abundances of cell types from PCA-based decomposition.
Uses a list of marker genes to subset the expression data, and returns the 
first PC of each sub-matrix as the cell type fraction estimates.
Optionally, weights for each marker gene can be used to prioritize genes
that are highly expressed in the given cell type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MarkerBasedDecomposition(
  bulk.eset,
  markers,
  ct_col = "cluster",
  gene_col = "gene",
  min_gene = 5,
  max_gene = 200,
  weighted = FALSE,
  w_col = "avg_logFC",
  unique_markers = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MarkerBasedDecomposition_+3A_bulk.eset">bulk.eset</code></td>
<td>
<p>Expression Set. Normalized bulk expression data.</p>
</td></tr>
<tr><td><code id="MarkerBasedDecomposition_+3A_markers">markers</code></td>
<td>
<p>Data frame with columns specifying cluster and gene,
and optionally a column for weights, typically the fold-change of the gene.
Important that the genes for each cell type are row-sorted by signficance.</p>
</td></tr>
<tr><td><code id="MarkerBasedDecomposition_+3A_ct_col">ct_col</code></td>
<td>
<p>Character string. Column name specifying cluster/cell type
corresponding to each marker gene in <strong>markers</strong>.</p>
</td></tr>
<tr><td><code id="MarkerBasedDecomposition_+3A_gene_col">gene_col</code></td>
<td>
<p>Character string. Column name specifying gene names in
<strong>markers</strong>.</p>
</td></tr>
<tr><td><code id="MarkerBasedDecomposition_+3A_min_gene">min_gene</code></td>
<td>
<p>Numeric. Min number of genes to use for each cell type.</p>
</td></tr>
<tr><td><code id="MarkerBasedDecomposition_+3A_max_gene">max_gene</code></td>
<td>
<p>Numeric. Max number of genes to use for each cell type.</p>
</td></tr>
<tr><td><code id="MarkerBasedDecomposition_+3A_weighted">weighted</code></td>
<td>
<p>Boolean. Whether to use weights for gene prioritization</p>
</td></tr>
<tr><td><code id="MarkerBasedDecomposition_+3A_w_col">w_col</code></td>
<td>
<p>Character string. Column name for weights, such as &quot;avg_logFC&quot;,
in <strong>markers</strong></p>
</td></tr>
<tr><td><code id="MarkerBasedDecomposition_+3A_unique_markers">unique_markers</code></td>
<td>
<p>Boolean. If TRUE, subset markers to include only genes 
that are markers for only one cell type</p>
</td></tr>
<tr><td><code id="MarkerBasedDecomposition_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Whether to print log info during decomposition.
Errors will be printed regardless.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this method expects the input bulk data to be normalized, unlike
the reference-based method.
</p>


<h3>Value</h3>

<p>A List. Slot <strong>bulk.props</strong> contains estimated relative cell
type abundances. Slot <strong>var.explained</strong> contains variance explained by
first 20 PCs for cell type marker genes. Slot <strong>genes.used</strong> contains
vector of genes used for decomposition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Biobase)
sim.data &lt;- SimulateData(n.ind=10, n.genes=100, n.cells=100,
                         cell.types=c("Neurons", "Astrocytes", "Microglia"),
                         avg.props=c(.5, .3, .2))
res &lt;- MarkerBasedDecomposition(sim.data$bulk.eset, sim.data$markers, weighted=FALSE)
estimated.cell.proportions &lt;- res$bulk.props

</code></pre>

<hr>
<h2 id='ReferenceBasedDecomposition'>Performs reference-based decomposition of bulk expression using single-cell
data</h2><span id='topic+ReferenceBasedDecomposition'></span>

<h3>Description</h3>

<p>Generates a reference profile based on single-cell data. Learns a
transformation of bulk expression based on observed single-cell proportions
and performs  NNLS regression on these transformed values to estimate cell
proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReferenceBasedDecomposition(
  bulk.eset,
  sc.eset,
  markers = NULL,
  cell.types = "cellType",
  subject.names = "SubjectName",
  use.overlap = TRUE,
  verbose = TRUE,
  old.cpm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReferenceBasedDecomposition_+3A_bulk.eset">bulk.eset</code></td>
<td>
<p>Expression Set containin bulk data. No PhenoData required
but if overlapping option used, IDs returned by sampleNames(bulk.eset) 
should match those found in sc.eset phenoData individual labels.</p>
</td></tr>
<tr><td><code id="ReferenceBasedDecomposition_+3A_sc.eset">sc.eset</code></td>
<td>
<p>Expression Set containing single-cell data. PhenoData of this
Expression Set should contain cell type and individual labels for each
cell. Names of these fields specified by arguments below.</p>
</td></tr>
<tr><td><code id="ReferenceBasedDecomposition_+3A_markers">markers</code></td>
<td>
<p>Structure, such as character vector, containing marker genes
to be used in decomposition. 'base::unique(base::unlist(markers))' should
return a simple vector containing each gene name. If no argument or NULL
provided, the method will use all available genes for decomposition.</p>
</td></tr>
<tr><td><code id="ReferenceBasedDecomposition_+3A_cell.types">cell.types</code></td>
<td>
<p>Character string. Name of phenoData attribute in sc.eset
indicating cell type label for each cell</p>
</td></tr>
<tr><td><code id="ReferenceBasedDecomposition_+3A_subject.names">subject.names</code></td>
<td>
<p>Character string. Name of phenoData attribute in sc.eset
indicating individual label for each cell</p>
</td></tr>
<tr><td><code id="ReferenceBasedDecomposition_+3A_use.overlap">use.overlap</code></td>
<td>
<p>Boolean. Whether to use and expect overlapping samples 
in decomposition.</p>
</td></tr>
<tr><td><code id="ReferenceBasedDecomposition_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Whether to print log info during decomposition.
Errors will be printed regardless.</p>
</td></tr>
<tr><td><code id="ReferenceBasedDecomposition_+3A_old.cpm">old.cpm</code></td>
<td>
<p>Prior to version 1.0.4 (updated in July 2020), the package
converted counts to CPM after subsetting the marker genes. Github user
randel pointed out that the order of these operations should be switched.
Thanks randel! This option is provided for replication of older BisqueRNA
but should be enabled, especially for small marker gene sets.
We briefly tested this change on the cortex and adipose datasets.
The original and new order of operations produce estimates that have an
average correlation of 0.87 for the cortex and 0.84 for the adipose within
each cell type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Expects read counts for both datasets, as they will be converted to 
counts per million (CPM). Two options available: Use overlapping indivudals
found in both single-cell and bulk datasets to learn transformation or 
learn transformation from single-cell alone. The overlapping option is
expected to have better performance.
</p>


<h3>Value</h3>

<p>A list. Slot <strong>bulk.props</strong> contains a matrix of cell type
proportion estimates with cell types as rows and individuals as columns.
Slot <strong>sc.props</strong> contains a matrix of cell type proportions 
estimated directly from counting single-cell data. 
Slot <strong>rnorm</strong> contains Euclidean norm of the residuals for each
individual's proportion estimates. Slot <strong>genes.used</strong> contains
vector of genes used in decomposition. Slot <strong>transformed.bulk</strong>
contains the transformed bulk expression used for decomposition. These
values are generated by applying a linear transformation to the CPM
expression.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Biobase)
sim.data &lt;- SimulateData(n.ind=10, n.genes=100, n.cells=100,
                         cell.types=c("Neurons", "Astrocytes", "Microglia"),
                         avg.props=c(.5, .3, .2))
sim.data$sc.eset &lt;- sim.data$sc.eset[,sim.data$sc.eset$SubjectName %in% as.character(6:10)]
res &lt;- ReferenceBasedDecomposition(sim.data$bulk.eset, sim.data$sc.eset)
estimated.cell.proportions &lt;- res$bulk.props

</code></pre>

<hr>
<h2 id='SemisupervisedTransformBulk'>Transforms bulk expression of a gene using only single-cell data</h2><span id='topic+SemisupervisedTransformBulk'></span>

<h3>Description</h3>

<p>For a specific gene, this function learns a transformation of
the bulk expression to match the distribution produced
by the single-cell based reference and observed single-cell based cell
proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SemisupervisedTransformBulk(gene, Y.train, X.pred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SemisupervisedTransformBulk_+3A_gene">gene</code></td>
<td>
<p>Character string. Gene name that corresponds to row in Y.train</p>
</td></tr>
<tr><td><code id="SemisupervisedTransformBulk_+3A_y.train">Y.train</code></td>
<td>
<p>Numeric Matrix. Number of gene rows by number of overlapping
individuals columns. Contains weighted sum of reference profile by 
single-cell based cell proportion estimates for each individual</p>
</td></tr>
<tr><td><code id="SemisupervisedTransformBulk_+3A_x.pred">X.pred</code></td>
<td>
<p>Numeric Matrix. Number of gene rows by number of remaining
individuals columns. Contains observed bulk expression for each individual
to be transformed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Y.pred Numeric Matrix. One row for given gene by number of remaining
individuals columns. Contains transformed bulk expression for each
individual.
</p>

<hr>
<h2 id='SeuratToExpressionSet'>Converts Seurat object to Expression Set</h2><span id='topic+SeuratToExpressionSet'></span>

<h3>Description</h3>

<p>'SeuratToExpressionSet()' returns an Expression Set with phenotype data
indicating cell type (cellType) and individual (SubjectName) for each cell
in a Seurat object. Raw counts data is used for assay data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SeuratToExpressionSet(
  seurat.object,
  delimiter,
  position,
  version = c("v2", "v3")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SeuratToExpressionSet_+3A_seurat.object">seurat.object</code></td>
<td>
<p>Seurat object with attributes <em>raw.data</em>,
<em>ident</em>, and <em>cell.names</em></p>
</td></tr>
<tr><td><code id="SeuratToExpressionSet_+3A_delimiter">delimiter</code></td>
<td>
<p>Character to split cell names with to find individual ID.</p>
</td></tr>
<tr><td><code id="SeuratToExpressionSet_+3A_position">position</code></td>
<td>
<p>Integer indicating 1-indexed position of individual ID after
splitting cell name with <em>delimiter</em>.</p>
</td></tr>
<tr><td><code id="SeuratToExpressionSet_+3A_version">version</code></td>
<td>
<p>Character string. Either &quot;v2&quot; or &quot;v3. Seurat version used to
create Seurat object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the <em>Seurat</em> and <em>Biobase</em> libraries should be attached
before running this function. The <em>delimiter</em> and <em>position</em> 
arguments are used to infer the individual ID from the cell ID. For example,
a delimiter of &quot;-&quot; and position of &quot;2&quot; indicates that the individual ID for
the cell ID <strong>ACTG-2</strong> would be <strong>2</strong>.
</p>


<h3>Value</h3>

<p>sc.eset Expression set containing relevant phenotype and individual
data, <em>cellType</em> and <em>SubjectName</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  library(Seurat)
  library(Biobase)

  # We make a class to emulate a Seurat v2 object for illustration only
  setClass("testSeuratv2", representation(cell.names = "character",
                                          ident = "character",
                                          raw.data = "matrix"))
  sc.counts &lt;- matrix(0,nrow=3,ncol=3)
  # These barcodes correspond to a delimiter of "-" and position 2 for individual id.
  test.cell.names &lt;- c("ATCG-1", "TAGC-2", "GTCA-3")
  test.ident &lt;- c("cell type a", "cell type b", "cell type c")
  names(test.ident) &lt;- test.cell.names
  colnames(sc.counts) &lt;- test.cell.names
  test.seurat.obj &lt;- new("testSeuratv2",
                         cell.names=test.cell.names,
                         ident=test.ident,
                         raw.data=sc.counts)

  single.cell.expression.set &lt;- SeuratToExpressionSet(test.seurat.obj, delimiter='-',
                                                      position=2, version="v2")


</code></pre>

<hr>
<h2 id='SimulateBarcode'>Simulate barcode for decomposition illustration</h2><span id='topic+SimulateBarcode'></span>

<h3>Description</h3>

<p>Generates a nucleotide barcode similar to those generated by
10x chromium sequencing platforms for illustration purposes.
Generates barcode and individual ID separated by '-' delimiter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateBarcode(index, individual, barcode.length)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimulateBarcode_+3A_index">index</code></td>
<td>
<p>Integer. Index of cell ID from 0 to barcode.length to the
fourth power. Will generate a unique nucleotide barcode for each
index.</p>
</td></tr>
<tr><td><code id="SimulateBarcode_+3A_individual">individual</code></td>
<td>
<p>Character. ID of individual that the cell is from.</p>
</td></tr>
<tr><td><code id="SimulateBarcode_+3A_barcode.length">barcode.length</code></td>
<td>
<p>Integer. Length of nucleotide barcode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulated barcode for cell from an individual
</p>

<hr>
<h2 id='SimulateData'>Simulate data for decomposition illustration</h2><span id='topic+SimulateData'></span>

<h3>Description</h3>

<p>Simulates bulk and single-cell expression, as well as marker genes and
true proportions that can be used as an example of decomposition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateData(n.ind, n.genes, n.cells, cell.types, avg.props)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimulateData_+3A_n.ind">n.ind</code></td>
<td>
<p>Integer. Number of individuals to simulate</p>
</td></tr>
<tr><td><code id="SimulateData_+3A_n.genes">n.genes</code></td>
<td>
<p>Integer. Number of genes to simulate</p>
</td></tr>
<tr><td><code id="SimulateData_+3A_n.cells">n.cells</code></td>
<td>
<p>Integer. Number of cells per individual for single-cell data</p>
</td></tr>
<tr><td><code id="SimulateData_+3A_cell.types">cell.types</code></td>
<td>
<p>Character vector. List of cell types to simulate</p>
</td></tr>
<tr><td><code id="SimulateData_+3A_avg.props">avg.props</code></td>
<td>
<p>Numeric vector. List of average proportions for given 
cell types. Should be same length as cell.types and sum to 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with simulated single-cell in slot 'sc.eset' and bulk in
'bulk.eset', as well as true proportions in 'props' and marker genes
in 'markers'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Biobase)
sim.data &lt;- SimulateData(n.ind=10, n.genes=100, n.cells=100,
                         cell.types=c("Neurons", "Astrocytes", "Microglia"),
                         avg.props=c(.5, .3, .2))

</code></pre>

<hr>
<h2 id='SupervisedTransformBulk'>Transforms bulk expression of a gene given overlapping data</h2><span id='topic+SupervisedTransformBulk'></span>

<h3>Description</h3>

<p>For a specific gene, this function uses linear regression to learn a
transformation of the bulk expression to match the values produced
by the single-cell based reference and observed single-cell based cell
proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SupervisedTransformBulk(gene, Y.train, X.train, X.pred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SupervisedTransformBulk_+3A_gene">gene</code></td>
<td>
<p>Character string. Gene name that corresponds to row in Y.train</p>
</td></tr>
<tr><td><code id="SupervisedTransformBulk_+3A_y.train">Y.train</code></td>
<td>
<p>Numeric Matrix. Number of gene rows by number of overlapping
individuals columns. Contains weighted sum of reference profile by 
single-cell based cell proportion estimates for each individual</p>
</td></tr>
<tr><td><code id="SupervisedTransformBulk_+3A_x.train">X.train</code></td>
<td>
<p>Numeric Matrix. Number of gene rows by number of overlapping
individuals columns. Contains observed bulk expression for each individual</p>
</td></tr>
<tr><td><code id="SupervisedTransformBulk_+3A_x.pred">X.pred</code></td>
<td>
<p>Numeric Matrix. Number of gene rows by number of remaining
individuals columns. Contains observed bulk expression for each individual
to be transformed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a linear transformation cannot be learned for a gene (zero variance in
observed bulk or single-cell based weighted sums), a vector of NaNs will 
be returned of the expected length (length of X.pred)
</p>


<h3>Value</h3>

<p>Y.pred Numeric Matrix. One row for given gene by number of remaining
individuals columns. Contains transformed bulk expression for each
individual.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
