<!DOCTYPE html><html><head><title>Help for package binfunest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {binfunest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#B2BConvert'><p>B2BConvert Converts a function of SNR into one of SNR, B2B, and Offset.</p></a></li>
<li><a href='#BERDFc'><p>An example <code>BERDF</code> dataframe created by <code>simsigs()</code>, a function in a</p>
forthcoming package <code>coherent</code>.</a></li>
<li><a href='#binfunest-package'><p>Package <code>B2BQ</code> will estimate an offset and B2B &quot;Q&quot; of a communications</p>
system performance.</a></li>
<li><a href='#mleB2B'><p>mleB2B  Estimates Back-to-Back &quot;Q&quot; and Offsets to a bit error rate function.</p></a></li>
<li><a href='#Theoretical'><p>Theoretical error rate functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimates Parameters of Functions Driving Binomial Random
Variables</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Philip Shea &lt;philshea@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides maximum likelihood estimates of the 
    performance parameters that drive a binomial distribution of observed 
    errors, and takes full advantage of zero error observations. High performance 
    communications systems typically have inherent noise sources and other 
    performance limitations that need to be estimated. Measurements made at 
    high signal to noise ratios typically result in zero 
    errors due to limitation in available measurement time. Package includes 
    theoretical performance functions for common modulation schemes (Proakis, 
    "Digital Communications" (1995, &lt;ISBN:0-07-051726-6&gt;)), polarization shifted 
    QPSK (Agrell &amp; Karlsson (2009, &lt;<a href="https://doi.org/10.1109%2FJLT.2009.2029064">doi:10.1109/JLT.2009.2029064</a>&gt;)), and utility 
    functions to work with the performance functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>pracma, stats, stats4</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/PhilShea/binfunest">https://github.com/PhilShea/binfunest</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/PhilShea/binfunest/issues">https://github.com/PhilShea/binfunest/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-08 13:14:30 UTC; phils</td>
</tr>
<tr>
<td>Author:</td>
<td>Philip Shea <a href="https://orcid.org/0000-0001-5460-9987"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-09 07:32:57 UTC</td>
</tr>
</table>
<hr>
<h2 id='B2BConvert'>B2BConvert Converts a function of SNR into one of SNR, B2B, and Offset.</h2><span id='topic+B2BConvert'></span>

<h3>Description</h3>

<p>Creates a function <code>f( -dB( undB( -s) + undB( -B2B)) - offset)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B2BConvert(f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B2BConvert_+3A_f">f</code></td>
<td>
<p>A function of a single argument <code>f( s)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that all quantities are assumed to be in Decibels.
</p>


<h3>Value</h3>

<p>A function of three arguments <code>f( s, B2B, offset)</code>..
</p>


<h3>Examples</h3>

<pre><code class='language-R'>QPSKdB.B2B &lt;- B2BConvert( QPSKdB)

</code></pre>

<hr>
<h2 id='BERDFc'>An example <code>BERDF</code> dataframe created by <code>simsigs()</code>, a function in a
forthcoming package <code>coherent</code>.</h2><span id='topic+BERDFc'></span>

<h3>Description</h3>

<p><code>BERDF</code> is a standard <code>R</code> data frame created by the <code>simsigs()</code> function in
the forthcoming <code>coherent</code> package.  The observations have been <code>condense</code>d
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BERDFc
</code></pre>


<h3>Format</h3>

<p>A dataframe with the following fields:
</p>

<dl>
<dt>Name</dt><dd><p>Name of constellation used to create the record.</p>
</dd>
<dt>SNR</dt><dd><p>The SNR in Decibles of the observation.</p>
</dd>
<dt>Bps</dt><dd><p>The number of bits per symbol.  The number of bits in a
simulation run is <code>Bps * N</code></p>
</dd>
<dt>NoisePower</dt><dd><p>The actual noise power in the simulation run.  Since
the noise is randomly generated, this is a stochastic item.</p>
</dd>
<dt>N</dt><dd><p>The number of symbols in the simulation run.</p>
</dd>
<dt>SER</dt><dd><p>The number of symbols errors observed in the simulation run.</p>
</dd>
<dt>BER</dt><dd><p>The number of bit errors observed in the simulation run.</p>
</dd>
</dl>


<hr>
<h2 id='binfunest-package'>Package <code>B2BQ</code> will estimate an offset and B2B &quot;Q&quot; of a communications
system performance.</h2><span id='topic+binfunest'></span><span id='topic+binfunest-package'></span>

<h3>Description</h3>

<p>Provides maximum likelihood estimates of the performance parameters that drive a binomial distribution of observed errors, and takes full advantage of zero error observations. High performance communications systems typically have inherent noise sources and other performance limitations that need to be estimated. Measurements made at high signal to noise ratios typically result in zero errors due to limitation in available measurement time. Package includes theoretical performance functions for common modulation schemes (Proakis, &quot;Digital Communications&quot; (1995, &lt;ISBN:0-07-051726-6&gt;)), polarization shifted QPSK (Agrell &amp; Karlsson (2009, <a href="https://doi.org/10.1109/JLT.2009.2029064">doi:10.1109/JLT.2009.2029064</a>)), and utility functions to work with the performance functions.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Philip Shea <a href="mailto:philshea@gmail.com">philshea@gmail.com</a> (<a href="https://orcid.org/0000-0001-5460-9987">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/PhilShea/binfunest">https://github.com/PhilShea/binfunest</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/PhilShea/binfunest/issues">https://github.com/PhilShea/binfunest/issues</a>
</p>
</li></ul>


<hr>
<h2 id='mleB2B'>mleB2B  Estimates Back-to-Back &quot;Q&quot; and Offsets to a bit error rate function.</h2><span id='topic+mleB2B'></span>

<h3>Description</h3>

<p>Bit error counts modeled as independent binary decisions result in a
log-likelihood dependent on the bit error probability.  This function
inserts the supplied bit error probability function into the binomial
log-likelihood function, and passes that to <a href="stats4.html#topic+mle">stats4::mle</a>, which ultimately
calls <a href="stats.html#topic+optim">stats::optim</a>.  The function will optimize a binomial probability
of the form $r = N * P( x_1, x_2, ..., x_n, a_1, a_2, ... a_k)$, where the
$x_i$ are variables from <code>data</code>, and the $a_j$ are parameters to be
estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mleB2B(data = NULL, Errors, N, f, fparms, start, method = "Nelder-Mead", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mleB2B_+3A_data">data</code></td>
<td>
<p>a data frame or list with named components. If a list, each
component must be the same length (just like a data frame). This is not
checked, so usual rules of recycling will apply.  Partial matching not
performed, so you must use full column names.</p>
</td></tr>
<tr><td><code id="mleB2B_+3A_errors">Errors</code></td>
<td>
<p>A vector of error counts, or a string identifying a column of
<code>data</code> from which to draw the error counts</p>
</td></tr>
<tr><td><code id="mleB2B_+3A_n">N</code></td>
<td>
<p>A single number, or a vector of the same length as
<code>data</code>, or a string identifying a column of <code>data</code> specifying the number
of trials used to measure the error counts
in <code>Errors</code>.  If a single number, then that number is used as the number
of trials for all error counts.</p>
</td></tr>
<tr><td><code id="mleB2B_+3A_f">f</code></td>
<td>
<p>A function that predicts the probability of errors.</p>
</td></tr>
<tr><td><code id="mleB2B_+3A_fparms">fparms</code></td>
<td>
<p>a list of named components that are the arguments of <code>f</code>.
Each component can be a string, a single number, or a vector. If a
string that names a column of <code>data</code>, that column will be used,
otherwise the string will be passed to <code>f</code>.  Note the potential for
errors if a column name was misspelled. A single number or vector
will be passed to <code>f</code>. Between <code>fparms</code>, <code>start</code>, and function defaults,
all parameters that need to be supplied to <code>f</code> should be specified, and
(except for defaults) not duplicated.</p>
</td></tr>
<tr><td><code id="mleB2B_+3A_start">start</code></td>
<td>
<p>Named list of initial values for the parameters of <code>f</code> to be
estimated.</p>
</td></tr>
<tr><td><code id="mleB2B_+3A_method">method</code></td>
<td>
<p>Optimization method.  See <code><a href="stats.html#topic+optim">stats::optim()</a></code>.</p>
</td></tr>
<tr><td><code id="mleB2B_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to <a href="stats4.html#topic+mle">mle</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates the parameters identified in <code>start</code> in the
constructed call to <code>f</code>. For a function <code>f</code> of the form
<code>fun( SNR, x2, x3, B2B, offset)</code>
A call of the form
</p>
<p><code>
mleB2B( data=df, Errors="r", N="trials", f=fun,
        fparm=list( SNR="s", x2=1, x3="noise"), start=list(B2B=1, offset=2))
</code>
</p>
<p>will construct a call to <code>mle</code> of the form:
</p>
<p><code>
mle( minuslogl=ll, start=start, nobs=length( Errors), method=method)</code>
</p>
<p>where the function <code>ll</code> is defined as
</p>
<p><code>
  ll &lt;- function( a, b) -sum( dbinom( df$r, df$n,
                fun( SNR=df$s, x2=1, x3=df$noise, B2B=B2B, offset=offset),
                log=TRUE))
</code>
</p>


<h3>Value</h3>

<p>An object of class <a href="stats4.html#topic+mle-class">stats4::mle</a> with the parameters
identified in <code>start</code> estimated.
</p>


<h3>See Also</h3>

<p><code><a href="stats4.html#topic+mle">stats4::mle()</a></code>, <code><a href="stats.html#topic+optim">stats::optim()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>QPSKdB.B2B &lt;- B2BConvert( QPSKdB)
O1 &lt;- 3
B1 &lt;- 16
s &lt;- 0:20
N &lt;- 1000000
r &lt;- rbinom( length( s), N, QPSKdB.B2B( s, B1, O1))
df &lt;- data.frame( Errors=r, SNR=s, N=N)
llsb2 &lt;- function( b2b, offset)
         -sum( dbinom( r, N, QPSKdB.B2B( s, b2b, offset), log=TRUE))
mle1 &lt;- stats4::mle( llsb2, start=c( b2b=20, offset=0), nobs=length(s),
                     method="Nelder-Mead")
est1 &lt;-  mleB2B( data=df, Errors="Errors", N=N, f=QPSKdB.B2B,
                 fparms=list( x="SNR"), start=c(b2b=20, offset=0))

</code></pre>

<hr>
<h2 id='Theoretical'>Theoretical error rate functions</h2><span id='topic+Theoretical'></span><span id='topic+is.wholenumber'></span><span id='topic+dB'></span><span id='topic+undB'></span><span id='topic+Q_'></span><span id='topic+Q_Inv'></span><span id='topic+QPSKdB'></span><span id='topic+DQPSKdB'></span><span id='topic+DQPSKDDdB'></span><span id='topic+PSQPSKdB'></span><span id='topic+MPSKdB'></span><span id='topic+MPSKdB.8'></span><span id='topic+QAMdB.8.star'></span><span id='topic+QAMdB'></span><span id='topic+QAMdB.16'></span><span id='topic+mod_Inv'></span><span id='topic+mod_InvV'></span>

<h3>Description</h3>

<p>Functions to calculate the theoretical performance of common modulation
formats.  Includes the functions <code>dB (x)</code> (returns <code style="white-space: pre;">&#8288;10log10(x)&#8288;</code>), <code>undB(x)</code>
(reverses <code>dB(x)</code>), <code>Q_( x)</code> (Markum's Q function), and <code>Q_Inv(x)</code>
(returns the
SNR in Decibels to get probability x).  Also includes <code>mod_Inv</code>, which returns
the SNR required for a the function <code>f</code> to reach the supplied BER (bit
error rate, or bit error probability).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.wholenumber(x, tol = sqrt(.Machine$double.eps))

dB(x)

undB(x)

Q_(x)

Q_Inv(perr)

QPSKdB(x)

DQPSKdB(x)

DQPSKDDdB(x)

PSQPSKdB(x)

MPSKdB(x, M)

MPSKdB.8(x)

QAMdB.8.star(x)

QAMdB(x, M)

QAMdB.16(x)

mod_Inv(f, perr, guess = Q_Inv(perr))

mod_InvV(f, pv, offset = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Theoretical_+3A_x">x</code></td>
<td>
<p>a real number</p>
</td></tr>
<tr><td><code id="Theoretical_+3A_tol">tol</code></td>
<td>
<p>the tolerance to test x with.</p>
</td></tr>
<tr><td><code id="Theoretical_+3A_perr">perr</code></td>
<td>
<p>a probability of a bit error.</p>
</td></tr>
<tr><td><code id="Theoretical_+3A_m">M</code></td>
<td>
<p>The integer number of symbols &gt; 4.</p>
</td></tr>
<tr><td><code id="Theoretical_+3A_f">f</code></td>
<td>
<p>a function (usually a BER function).</p>
</td></tr>
<tr><td><code id="Theoretical_+3A_guess">guess</code></td>
<td>
<p>a guess for the <code>perr</code> (the default usually works).</p>
</td></tr>
<tr><td><code id="Theoretical_+3A_pv">pv</code></td>
<td>
<p>a vector of BERs.</p>
</td></tr>
<tr><td><code id="Theoretical_+3A_offset">offset</code></td>
<td>
<p>an offset in Decibels for guesses in <code>mod_InvV</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rest of the functions return the probability of a bit error given the
SNR in Decibels.
</p>

<ul>
<li> <p><code>QPSKdB</code> is Quadrature Phase shift keyed: two bits per symbol.
</p>
</li>
<li> <p><code>DQPSK</code> is differentially detected differentially coded QPSK.
</p>
</li>
<li> <p><code>DQPSKDDdB</code> is differentially detected differential QPSK (coherently
detected but differentially decoded. See <code>DQPSK</code> above.
</p>
</li>
<li> <p><code>PSQPSKdB</code> is polarization-shifted QPSK: it is dual pole, but only
one pole is active at any one time, thus supplying three bits per
symbol. (See Agrell &amp; Karlsson (2009, DOI:10.1109/JLT.2009.2029064)).
</p>
</li>
<li> <p><code>MPSKdB(x, M)</code> is generic M-ary phase shift keying of <code>M</code> points in a circle.
</p>
</li>
<li> <p><code>MPSKdB.8</code> simply returns <code>MPSKdB(x, 8)</code>
</p>
</li>
<li> <p><code>QAMdB.8.star</code> is the optimal star configuration of 8-ary Quadrature
Amplitude Modulation (QAM), such that
the legs are at <code class="reqn">\pm1</code> and <code class="reqn">\pm(1+\sqrt3)</code>.
</p>
</li>
<li> <p><code>QAMdB(x, M)</code> is generic rectangular QAM constellation of <code>M</code> points.
</p>
</li>
<li> <p><code>QAMdB.16</code> Returns the BER for the rectangular QAM constellation according to
Proakis Eq. 5-2-80.
</p>
</li>
<li> <p><code>mod_Inv</code> will take a function <code>f(x)</code> and return the x such that
<code>f(x)==perr</code>
but it does this based on the <code>log( f(x))</code> and the <code>log( perr)</code>, so
<code>f(x)&gt;0</code>.
</p>
</li>
<li> <p><code>mod_InvV</code> is a vectorized version (give it a vector of BERs and it returns a
vector of SNRs).
</p>
</li></ul>



<h3>Value</h3>

<p><code>is.wholenumber(x)</code> returns <code>TRUE</code> if <code>c-round(x) &lt; tol</code>.
</p>
<p><code>dB(x)</code> returns <code>10*log10(x)</code>
</p>
<p><code>undB(x)</code> returns <code>10^(x/10)</code>
</p>
<p><code>Q_Inv(x)</code> returns <code>2*dB( -qnorm(x))</code>, which is the
SNR (in Decibels) required to get a probability of error of x.
Q_Inv( Q_( undB( x/2))) = x and Q_( undB( Q_Inv( x)/2))=x
</p>
<p><code> mod_Inv( f, x)</code> returns a list with the SNR in Decibels to
reach the BER
<code>perr</code> such that <code>f( mod_Inv( f, x)$x) = x</code>.
The returned list has elements
<code>$x</code> as the SNR and
<code>$fval</code> as the function value.
</p>


<h3>See Also</h3>

<p><code><a href="pracma.html#topic+fzero">pracma::fzero()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dB( 10) # == 10
undB( 20) # == 100
Q_Inv( Q_( undB( 10/2))) # = 10
Q_( undB( Q_Inv( 0.001)/2)) # = 0.001

mod_Inv( QPSKdB, QPSKdB( 7)) # yields 7

mod_InvV(QPSKdB, QPSKdB(c(6,7)))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
