<!DOCTYPE html><html lang="en"><head><title>Help for package CircularSilhouette</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CircularSilhouette}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#circular.sil'><p>Calculating Silhouette on Circular Data Clusters</p></a></li>
<li><a href='#estimate.period'><p>Estimating the Period of Noisy Periodical Data</p></a></li>
<li><a href='#fast.sil'><p>Calculating Silhouette on Linear Data Clusters</p></a></li>
<li><a href='#find.num.of.clusters'><p>Finding an Optimal Number of Circular Data Clusters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Silhouette on Circular or Linear Data Clusters</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Yinong Chen <a href="https://orcid.org/0000-0003-1641-1712"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Tathagata Debnath <a href="https://orcid.org/0000-0001-6445-275X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Andrew Cai [aut],
  Joe Song <a href="https://orcid.org/0000-0002-6883-6547"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joe Song &lt;joemsong@cs.nmsu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculating silhouette information for clusters on
 circular or linear data using fast algorithms. These algorithms run in
 linear time on sorted data, in contrast to quadratic time by the
 definition of silhouette. When used together with the fast and optimal
 circular clustering method FOCC (Debnath &amp; Song 2021)
 &lt;<a href="https://doi.org/10.1109%2FTCBB.2021.3077573">doi:10.1109/TCBB.2021.3077573</a>&gt; implemented in R package 'OptCirClust',
 circular silhouette can be maximized to find the optimal number of
 circular clusters; it can also be used to estimate the period of noisy
 periodical data.</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>OptCirClust, Rcpp (&ge; 1.0.7), Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cluster, ggplot2, knitr, rmarkdown, testthat (&ge; 3.0.0),
graphics</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-22 19:38:16 UTC; joesong</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-27 07:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='circular.sil'>Calculating Silhouette on Circular Data Clusters</h2><span id='topic+circular.sil'></span>

<h3>Description</h3>

<p>A fast linear-time algorithm to calculate silhouette information on
circular data with cluster labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circular.sil(O, cluster, Circumference, method = c("linear", "quadratic"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circular.sil_+3A_o">O</code></td>
<td>
<p>a numeric vector of circular data points</p>
</td></tr>
<tr><td><code id="circular.sil_+3A_cluster">cluster</code></td>
<td>
<p>an integer vector of cluster labels for each point</p>
</td></tr>
<tr><td><code id="circular.sil_+3A_circumference">Circumference</code></td>
<td>
<p>a numeric value giving the circumference of the
circle</p>
</td></tr>
<tr><td><code id="circular.sil_+3A_method">method</code></td>
<td>
<p>a character value to specify the algorithm to calculate
the silhouette information. The default value is <code>"linear"</code>,
indicating a fast linear time algorithm for calculating circular
silhouette. The option of <code>"quadratic"</code> is provided for
testing and comparison, not meant for production use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>method</code> takes the value of <code>"linear"</code>
(default), the
silhouette information on circular data is calculated by a fast
linear-time algorithm; if <code>method</code> is <code>"quadratic"</code>,
a quadratic-time algorithm is used instead to calculate silhouette
by definition. There is an overhead of sorting <code class="reqn">O(n \log n)</code> if the
input data are not sorted.
</p>
<p>One important assumption is that a cluster cannot be contained in
another cluster in the input cluster labels.
</p>


<h3>Value</h3>

<p>The function returns a numeric value of the average
silhouette information calculated on the input circular data
clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>O &lt;- c(-1.2, -2, -3, -2.5, 1, 0.8, 1.5, 1.2)
cluster &lt;- c(1, 1, 1, 1, 2, 2, 2, 2)
circular.sil(O, cluster, 3)

</code></pre>

<hr>
<h2 id='estimate.period'>Estimating the Period of Noisy Periodical Data</h2><span id='topic+estimate.period'></span>

<h3>Description</h3>

<p>By performing circular clustering and calculating circular
silhouette, the function estimates the period of periodical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate.period(x, possible.periods = diff(range(x))/2^(1:5), ks = 2:10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate.period_+3A_x">x</code></td>
<td>
<p>a numeric vector of data points that are one-dimensional,
noisy, periodical</p>
</td></tr>
<tr><td><code id="estimate.period_+3A_possible.periods">possible.periods</code></td>
<td>
<p>a numeric vector representing a set of
period values to evaluate</p>
</td></tr>
<tr><td><code id="estimate.period_+3A_ks">ks</code></td>
<td>
<p>a numeric vector of numbers of clusters within one period</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user can estimate a period by providing the number of
clusters within one period and a set of periods for examination.
An optimal circular clustering algorithm
<code><a href="OptCirClust.html#topic+CirClust">CirClust</a></code> in R package <span class="pkg">OptCirClust</span>
is used to cluster the periodical data. The algorithm converts the
periodical data to circular data of a circumference equal to twice
the tested period. Then circular silhouette information for
each circumference and number of clusters are computed to find the
maximum silhouette information. The half of circumference giving
maximum silhouette information is selected to be the estimated period.
</p>
<p>The possible periods provided by the function should be close to the
true period. This is not ideal and we are improving the design to be
more robust.
</p>


<h3>Value</h3>

<p>The function returns a numeric value representing the
estimated period.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(OptCirClust)
x=c(40,41,42,50,51,52,60,61,62,70,71,72,80,81,82,90,91,92)
x &lt;- x + rnorm(length(x))
clusterrange=c(2:5)
periodrange=c(80:120)/10
period&lt;-estimate.period(x, periodrange, clusterrange)
cat("The estimated period is", period, "\n")
plot(x, rep(1, length(x)), type="h", col="purple",
     ylab="", xlab="Noisy periodic data",
     main="Period estimation",
     sub=paste("Estimated period =", period))
k &lt;- (max(x) - min(x)) %/% period
abline(v=min(x)+period/2 + period * (0:k), lty="dashed", col="green3")

</code></pre>

<hr>
<h2 id='fast.sil'>Calculating Silhouette on Linear Data Clusters</h2><span id='topic+fast.sil'></span>

<h3>Description</h3>

<p>A fast linear-time algorithm to calculate silhouette information on
one-dimensional data with cluster labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast.sil(x, cluster)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast.sil_+3A_x">x</code></td>
<td>
<p>a numeric vector of one-dimensional points</p>
</td></tr>
<tr><td><code id="fast.sil_+3A_cluster">cluster</code></td>
<td>
<p>an integer vector of cluster labels for each point</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The silhouette information on one-dimensional data is
calculated in linear time here, instead of quadratic time by
definition. There is an overhead of sorting <code class="reqn">O(n \log n)</code> if the
input data are not sorted.
</p>


<h3>Value</h3>

<p>The function returns a numeric value of the average
silhouette information calculated on the input data clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(-1.2, -2, -3, -2.5, 1, 0.8, 1.5, 1.2)
cluster &lt;- c(1, 1, 1, 1, 2, 2, 2, 2)
fast.sil(x, cluster)


</code></pre>

<hr>
<h2 id='find.num.of.clusters'>Finding an Optimal Number of Circular Data Clusters</h2><span id='topic+find.num.of.clusters'></span>

<h3>Description</h3>

<p>An optimal number of clusters is selected on circular data such that
the number maximizes the circular silhouette information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.num.of.clusters(O, Circumference, ks = 2:10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.num.of.clusters_+3A_o">O</code></td>
<td>
<p>a numeric vector of coordinates of data points along a circle.</p>
</td></tr>
<tr><td><code id="find.num.of.clusters_+3A_circumference">Circumference</code></td>
<td>
<p>a numeric value giving the circumference of the
circle</p>
</td></tr>
<tr><td><code id="find.num.of.clusters_+3A_ks">ks</code></td>
<td>
<p>an integer vector representing possible choices for the
number of clusters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the circular clustering algorithm in the R package
<span class="pkg">OptCirClust</span> (Debnath and Song 2021), we will examine every value of <code class="reqn">k</code> in the given
choices of number of clusters. We select a <code class="reqn">k</code> that maximizes the
circular silhouette information.
</p>


<h3>Value</h3>

<p>The function returns an integer number that is optimal in
maximizing circular silhouette.
</p>


<h3>References</h3>

<p>Debnath T, Song M (2021).
&ldquo;Fast optimal circular clustering and applications on round genomes.&rdquo;
<em>IEEE/ACM Transactions on Computational Biology and Bioinformatics</em>.
doi: <a href="https://doi.org/10.1109/TCBB.2021.3077573">10.1109/TCBB.2021.3077573</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(OptCirClust)
Circumference=100
O=c(99,0,1,2,3,15,16,17,20,50,55,53,70,72,73,69)
K_range=c(2:8)
k &lt;- find.num.of.clusters(O, Circumference, K_range)
result_FOCC &lt;- CirClust(O, k, Circumference, method = "FOCC")
opar &lt;- par(mar=c(0,0,2,0))
plot(result_FOCC, cex=0.5, main="Optimal number of clusters",
     sub=paste("Optimal k =", k))
par(opar)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
