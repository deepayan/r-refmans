<!DOCTYPE html><html><head><title>Help for package HDInterval</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HDInterval}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hdi'>
<p>Highest (Posterior) Density Interval</p></a></li>
<li><a href='#inverseCDF'>
<p>Inverse Cumulative Density Function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Highest (Posterior) Density Intervals</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-16</td>
</tr>
<tr>
<td>Suggests:</td>
<td>coda</td>
</tr>
<tr>
<td>Description:</td>
<td>A generic function and a set of methods to calculate highest density intervals for a variety of classes of objects which can specify a probability density distribution, including MCMC output, fitted density objects, and functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-16 11:50:31 UTC; User</td>
</tr>
<tr>
<td>Author:</td>
<td>Ngumbang Juat [cre],
  Mike Meredith [aut],
  John Kruschke [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ngumbang Juat &lt;ngumbangjuat@hotmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-17 18:10:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='hdi'>
Highest (Posterior) Density Interval
</h2><span id='topic+HDInterval'></span><span id='topic+hdi'></span><span id='topic+hdi.default'></span><span id='topic+hdi.function'></span><span id='topic+hdi.matrix'></span><span id='topic+hdi.data.frame'></span><span id='topic+hdi.list'></span><span id='topic+hdi.density'></span><span id='topic+hdi.mcmc'></span><span id='topic+hdi.mcarray'></span><span id='topic+hdi.mcmc.list'></span><span id='topic+hdi.bugs'></span><span id='topic+hdi.jagsUI'></span><span id='topic+hdi.rjags'></span><span id='topic+hdi.runjags'></span>

<h3>Description</h3>

<p>Calculate the highest density interval (HDI) for a probability distribution for a given probability mass. This is often applied to a Bayesian posterior distribution and is then termed &quot;highest posterior density interval&quot;, but can be applied to any distribution, including priors.
</p>
<p>The function is an S3 generic, with methods for a range of input objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdi(object, credMass = 0.95, ...)

## Default S3 method:
hdi(object, credMass = 0.95, ...)

## S3 method for class 'function'
hdi(object, credMass = 0.95, tol, ...)

## S3 method for class 'matrix'
hdi(object, credMass = 0.95, ...)

## S3 method for class 'data.frame'
hdi(object, credMass = 0.95, ...)

## S3 method for class 'list'
hdi(object, credMass = 0.95, ...)

## S3 method for class 'density'
hdi(object, credMass = 0.95, allowSplit=FALSE, ...)

## S3 method for class 'mcmc'
hdi(object, credMass = 0.95, ...)  

## S3 method for class 'mcmc.list'
hdi(object, credMass = 0.95, ...)  

## S3 method for class 'mcarray'
hdi(object, credMass = 0.95, ...)  

## S3 method for class 'bugs'
hdi(object, credMass = 0.95, ...)  

## S3 method for class 'jagsUI'
hdi(object, credMass = 0.95, ...)  

## S3 method for class 'rjags'
hdi(object, credMass = 0.95, ...)  

## S3 method for class 'runjags'
hdi(object, credMass = 0.95, ...)  

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hdi_+3A_object">object</code></td>
<td>

<p>an object specifying the target distribution; see Details.
</p>
</td></tr>
<tr><td><code id="hdi_+3A_credmass">credMass</code></td>
<td>

<p>a scalar [0, 1] specifying the mass within the credible interval.
</p>
</td></tr>
<tr><td><code id="hdi_+3A_tol">tol</code></td>
<td>

<p>the desired accuracy; see <code><a href="stats.html#topic+optimize">optimize</a></code>; default is 1e-8.
</p>
</td></tr>
<tr><td><code id="hdi_+3A_allowsplit">allowSplit</code></td>
<td>

<p>only available for objects of class <code>density</code>; if FALSE and the proper HDI is discontinuous, a single credible interval is returned, but this is not HDI; see Value.
</p>
</td></tr>
<tr><td><code id="hdi_+3A_...">...</code></td>
<td>

<p>named parameters to be passed to other methods; see Examples.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The HDI is the interval which contains the required mass such that all points within the interval have a higher probability density than points outside the interval.
</p>
<p><img src="../help/figures/HDIskew.jpg" alt="HDIskew.jpg" />
</p>
<p>In contrast, a symmetric density interval defined by (eg.) the 10% and 90% quantiles may include values with lower probability than those excluded.
</p>
<p>For a distribution that is not severely multimodal, the HDI is the narrowest interval containing the specified mass, and the <code>hdi</code> function actually returns the narrowest interval. This does not always work properly for multimodel densities, where the HDI may be discontinuous (the horizontal black line in the  Figure below). The single interval returned by <code>hdi</code> (the blue line) may incorrectly include values between the modes with low probability density. The <code>density</code> method with <code>allowSplit = TRUE</code> gives separate limits for discontinuous HDIs.
</p>
<p><img src="../help/figures/HDIbimodal.jpg" alt="HDIbimodal.jpg" />
</p>
<p>The default method expects a vector representing draws from the target distribution, such as is produced by an MCMC process. Missing values are silently ignored; if the vector has no non-missing values, NAs are returned.
</p>
<p>The <code>matrix</code> and <code>data.frame</code> methods expect an object with vectors of the above type for each parameter in columns. The result is a matrix with parameters in columns and rows with the upper and lower limits of the HDI.
</p>
<p>The <code>list</code> method is a wrapper for <code>lapply(object, hdi, ...)</code>. It is intended for output from <code>rjags::jags.samples</code> which returns a list of <code>mcarray</code> objects.
</p>
<p>The <code>mcmc.list</code>, <code>mcmc</code> and <code>mcarray</code> methods expect objects of the respective types as defined in package <span class="pkg">coda</span>.
</p>
<p>The packages <span class="pkg">R2winbugs</span> and <span class="pkg">R2openbugs</span> produce <code>bugs</code> objects; <span class="pkg">R2jags</span> produces <code>rjags</code>; <span class="pkg">jagsUI</span> produces <code>jagsUI</code>; <span class="pkg">runjags</span> produces <code>runjags</code>. For the <span class="pkg">rjags</span> package, <code>rjags::coda.samples</code> produces a <code>mcmc.list</code> object and <code>rjags::jags.samples</code> produces a list of <code>mcarray</code> objects.
</p>
<p>None of the above use interpolation: the values returned correspond to specific values in the data object, and will be conservative (ie, too wide rather than too narrow). Results thus depend on the random draws, and will be unstable if few values are provided. For a 95% HDI, 10,000 independent draws are recommended; a smaller number will be adequate for a 80% HDI, many more for a 99% HDI.
</p>
<p>The function method requires the name for the inverse cumulative density function (ICDF) of the distribution; standard R functions for this have a <code>q-</code> prefix, eg. <code>qbeta</code>. Arguments required by the ICDF must be specified by their (abbreviated) names; see the examples.
</p>


<h3>Value</h3>

<p>a vector of length 2 or a 2-row matrix with the lower and upper limits of the HDI, with an attribute &quot;credMass&quot;.
</p>
<p>The <code>density</code> method with <code>allowSplit=TRUE</code> produces a matrix with a row for each component of a discontinuous HDI and columns for begin and end. It has an additional attribute &quot;height&quot; giving the probability density at the limits of the HDI.
</p>


<h3>Author(s)</h3>

<p>Mike Meredith and John Kruschke. Code for <code>hdi.function</code> based on <code>hpd</code> by Greg Snow, corrected by John Kruschke.
</p>


<h3>References</h3>

<p>Kruschke, J. K. 2011. <em>Doing Bayesian data analysis: a tutorial with R and BUGS.</em> Elsevier, Amsterdam, section 3.3.5.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for a vector:
tst &lt;- rgamma(1e5, 2.5, 2)
hdi(tst)
hdi(tst, credMass=0.8)
# For comparison, the symmetrical 80% CrI:
quantile(tst, c(0.1,0.9))

# for a density:
dens &lt;- density(tst)
hdi(dens, credMass=0.8)

# Now a data frame:
tst &lt;- data.frame(mu = rnorm(1e4, 4, 1), sigma = rlnorm(1e4))
hdi(tst, 0.8)
apply(tst, 2, quantile, c(0.1,0.9))
tst$txt &lt;- LETTERS[1:25]
hdi(tst, 0.8)

# For a function:
hdi(qgamma, 0.8, shape=2.5, rate=2)
# and the symmetrical 80% CrI:
qgamma(c(0.1, 0.9), 2.5, 2)

# A multimodal distribution:
set.seed(2020)
tst2 &lt;- c(rnorm(500, 30, 3), rnorm(200, 50, 1.5), 60 + rexp(200, 0.1))
hist(tst2, breaks = 100, freq=FALSE)
(hdiMC &lt;- hdi(tst2))
segments(hdiMC[1], 0, hdiMC[2], 0, lwd=4, col='red', lend='butt')
# This is a valid 95% CrI, but not a Highest Density Interval

dens2 &lt;- density(tst2, bw="SJ") # not the default for 'bw', see ?density
lines(dens2, lwd=2, col='blue')
(hdiD &lt;- hdi(dens2, allowSplit=TRUE))
(ht &lt;- attr(hdiD, "height"))
segments(hdiD[, 1], ht, hdiD[, 2], ht, lwd=4, col='blue', lend='butt')
# This is the correct 95% HDI.
</code></pre>

<hr>
<h2 id='inverseCDF'>
Inverse Cumulative Density Function
</h2><span id='topic+inverseCDF'></span>

<h3>Description</h3>

<p>Given a cumulative density function, calculates the quantiles coresponding to given probabilities, ie, &quot;converts&quot; a CDF to an ICDF. The function method for <code>hdi</code> requires an ICDF, which is not always available for custom distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverseCDF(p, CDF, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inverseCDF_+3A_p">p</code></td>
<td>

<p>a vector of probabilities. Values less than 1e6 will be replaced with 1e6 and values greater than (1 - 1e-6) will be replaced with (1 - 1e-6), without a warning.
</p>
</td></tr>
<tr><td><code id="inverseCDF_+3A_cdf">CDF</code></td>
<td>

<p>a cumulative density function; standard CDFs in R begin with <code>p-</code>, eg, <code>pnorm</code>.
</p>
</td></tr>
<tr><td><code id="inverseCDF_+3A_...">...</code></td>
<td>

<p>named parameters to be passed to the CDF function; see Examples; <code>log.p</code> and <code>lower.tail</code> are not supported and generate an error.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses a search algorithm to find the value of <code>q</code> which corresponds to <code>p</code>. This suffers from imprecision, especially for sections of the CDF which are relatively flat, as is usually the case close to p = 0 or 1.
</p>


<h3>Value</h3>

<p>a vector of the same length as <code>p</code> with the corresponding quantiles.
</p>


<h3>Author(s)</h3>

<p>Mike Meredith
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Try with pgamma/qgamma
inverseCDF(c(0.025, 0.975), pgamma, shape=2.5, rate=2) # 95% interval
qgamma(c(0.025, 0.975), shape=2.5, rate=2) # for comparison
inverseCDF(c(0, 1), pgamma, shape=2.5, rate=2) # nonsense, fixed internally...
inverseCDF(c(1e-6, 1 - 1e-6), pgamma, shape=2.5, rate=2) # ...same.

# Plug inverseCDF into hdi, need to specify the CDF
hdi(inverseCDF, CDF=pgamma, shape=2.5, rate=2)
hdi(qgamma, shape=2.5, rate=2) # for comparison

# for a custom density, here a mixture of normals
# the PDF
dmixg &lt;- function(x)
  0.6 * dnorm(x, 0, 1) + 0.4 * dnorm(x, 4, 2^0.5)
curve(dmixg, -5, 10)
# and the CDF
pmixg &lt;- function(q)
  0.6 * pnorm(q, 0, 1) + 0.4 * pnorm(q, 4, 2^0.5)
curve(pmixg, -5, 10)
# Now plug into inverseCDF and hdi
inverseCDF(c(0.025, 0.975), pmixg)
hdi(inverseCDF, CDF=pmixg)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
