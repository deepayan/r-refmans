<!DOCTYPE html><html><head><title>Help for package SIMplyBee</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SIMplyBee}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SIMplyBee-package'><p>SIMplyBee: 'AlphaSimR' Extension for Simulating Honeybee Populations and Breeding Programmes</p></a></li>
<li><a href='#addCastePop'><p>Add caste individuals to the colony</p></a></li>
<li><a href='#buildUp'><p>Build up Colony or MultiColony object by adding (raising) workers and drones</p></a></li>
<li><a href='#c+2CNULLOrPop-method'><p>Combine a NULL and AlphaSimR population</p></a></li>
<li><a href='#calcBeeGRMIbd'><p>Calculate Genomic Relatedness Matrix (GRM) for honeybees from</p>
Identical By Descent genomic data</a></li>
<li><a href='#calcBeeGRMIbs'><p>Calculate Genomic Relatedness Matrix (GRM) for honeybees from</p>
Identical By State genomic data</a></li>
<li><a href='#calcColonyValue'><p>Calculate colony value(s)</p></a></li>
<li><a href='#calcInheritanceCriterion'><p>Calculate the inheritance criterion</p></a></li>
<li><a href='#calcPerformanceCriterion'><p>Calculate the performance criterion</p></a></li>
<li><a href='#calcQueensPHomBrood'><p>The expected proportion and a realised number of csd homozygous brood</p></a></li>
<li><a href='#calcSelectionCriterion'><p>Calculate the selection criterion</p></a></li>
<li><a href='#collapse'><p>Collapse</p></a></li>
<li><a href='#Colony-class'><p>Honeybee colony</p></a></li>
<li><a href='#combine'><p>Combine two colony objects</p></a></li>
<li><a href='#combineBeeGametes'><p>Create diploid gametes from a mated queen</p></a></li>
<li><a href='#combineBeeGametesHaploDiploid'><p>Create diploid gametes from a mated queen</p></a></li>
<li><a href='#createCastePop'><p>Creates caste population individuals from the colony</p></a></li>
<li><a href='#createColony'><p>Create a new Colony</p></a></li>
<li><a href='#createDCA'><p>Create a drone congregation area (DCA)</p></a></li>
<li><a href='#createMatingStationDCA'><p>Create a DCA of drones at a mating stations</p></a></li>
<li><a href='#createMultiColony'><p>Create MultiColony object</p></a></li>
<li><a href='#createRandomCrossPlan'><p>Create a cross plan by randomly sampling drones for each queen</p>
from a drone population</a></li>
<li><a href='#cross'><p>Cross (mate) virgin queen(s) as a population, of a colony, or</p>
of all given colonies</a></li>
<li><a href='#downsize'><p>Reduce number of workers and remove all drones and virgin queens from</p>
a Colony or MultiColony object</a></li>
<li><a href='#downsizePUnif'><p>Sample the downsize proportion - proportion of removed workers in</p>
downsizing</a></li>
<li><a href='#editCsdLocus'><p>Edit the csd locus</p></a></li>
<li><a href='#getAa'><p>Access epistasis values of individuals in a caste</p></a></li>
<li><a href='#getBv'><p>Access breeding values of individuals in a caste</p></a></li>
<li><a href='#getCaste'><p>Report caste of an individual</p></a></li>
<li><a href='#getCasteId'><p>Get IDs of individuals of a caste, or ID of all members of colony</p></a></li>
<li><a href='#getCastePop'><p>Access individuals of a caste</p></a></li>
<li><a href='#getCasteSex'><p>Get sex of individuals of a caste, or sex of all members of colony</p></a></li>
<li><a href='#getCsdAlleles'><p>Get csd alleles</p></a></li>
<li><a href='#getCsdGeno'><p>Get genotypes from the csd locus</p></a></li>
<li><a href='#getDd'><p>Access dominance values of individuals in a caste</p></a></li>
<li><a href='#getEvents'><p>Report which colony events have occurred</p></a></li>
<li><a href='#getGv'><p>Access genetic values of individuals in a caste</p></a></li>
<li><a href='#getIbdHaplo'><p>Access IBD haplotypes of individuals in a caste</p></a></li>
<li><a href='#getId'><p>Get the colony ID</p></a></li>
<li><a href='#getLocation'><p>Get the colony location</p></a></li>
<li><a href='#getPheno'><p>Access phenotype values of individuals in a caste</p></a></li>
<li><a href='#getPooledGeno'><p>Get a pooled genotype from true genotypes</p></a></li>
<li><a href='#getQtlGeno'><p>Access QTL genotypes of individuals in a caste</p></a></li>
<li><a href='#getQtlHaplo'><p>Access QTL haplotypes of individuals in a caste</p></a></li>
<li><a href='#getQueenAge'><p>Get (calculate) the queen's age</p></a></li>
<li><a href='#getQueenYearOfBirth'><p>Access the queen's year of birth</p></a></li>
<li><a href='#getSegSiteGeno'><p>Access genotypes for all segregating sites of individuals in a</p>
caste</a></li>
<li><a href='#getSegSiteHaplo'><p>Access haplotypes for all segregating sites of individuals in a</p>
caste</a></li>
<li><a href='#getSnpGeno'><p>Access SNP array genotypes of individuals in a caste</p></a></li>
<li><a href='#getSnpHaplo'><p>Access SNP array haplotypes of individuals in a caste</p></a></li>
<li><a href='#hasCollapsed'><p>Test if colony has collapsed</p></a></li>
<li><a href='#hasSplit'><p>Test if colony has split</p></a></li>
<li><a href='#hasSuperseded'><p>Test if colony has superseded</p></a></li>
<li><a href='#hasSwarmed'><p>Test if colony has swarmed</p></a></li>
<li><a href='#isCaste'><p>Is individual a member of a specific caste</p></a></li>
<li><a href='#isCsdActive'><p>Is csd locus activated</p></a></li>
<li><a href='#isCsdHeterozygous'><p>Test if individuals are heterozygous at the csd locus</p></a></li>
<li><a href='#isDronesPresent'><p>Are drones present</p></a></li>
<li><a href='#isEmpty'><p>Check whether a population, colony or a multicolony</p>
object has no individuals within</a></li>
<li><a href='#isFathersPresent'><p>Are fathers present (=queen mated)</p></a></li>
<li><a href='#isGenoHeterozygous'><p>Test if a multilocus genotype is heterozygous</p></a></li>
<li><a href='#isNULLColonies'><p>Check which of the colonies in a multicolony are NULL</p></a></li>
<li><a href='#isProductive'><p>Test if colony is currently productive</p></a></li>
<li><a href='#isQueenPresent'><p>Is the queen present</p></a></li>
<li><a href='#isSimParamBee'><p>Test if x is a SimParamBee class object</p></a></li>
<li><a href='#isVirginQueensPresent'><p>Are virgin queen(s) present</p></a></li>
<li><a href='#isWorkersPresent'><p>Are workers present</p></a></li>
<li><a href='#mapCasteToColonyValue'><p>Map caste member (individual) values to a colony value</p></a></li>
<li><a href='#MultiColony-class'><p>Honeybee multicolony object</p></a></li>
<li><a href='#nCaste'><p>Level 0 function that returns the number of individuals of a caste in a</p>
colony</a></li>
<li><a href='#nColonies'><p>Number of colonies in a MultiColony object</p></a></li>
<li><a href='#nCsdAlleles'><p>Report the number of distinct csd alleles</p></a></li>
<li><a href='#nDronesPoisson'><p>Sample a number of drones</p></a></li>
<li><a href='#nFathersPoisson'><p>Sample a number of fathers</p></a></li>
<li><a href='#nVirginQueensPoisson'><p>Sample a number of virgin queens</p></a></li>
<li><a href='#nWorkersPoisson'><p>Sample a number of workers</p></a></li>
<li><a href='#pullCastePop'><p>Pull individuals from a caste in a colony</p></a></li>
<li><a href='#pullColonies'><p>Pull out some colonies from the MultiColony object</p></a></li>
<li><a href='#pullDroneGroupsFromDCA'><p>Pulls drone groups from a Drone Congregation Area (DCA)</p></a></li>
<li><a href='#pullInd'><p>Pull individuals from a population</p></a></li>
<li><a href='#reduceDroneGeno'><p>Reduce drones' genotype to a single haplotype</p></a></li>
<li><a href='#reduceDroneHaplo'><p>Reduce drone's double haplotypes to a single haplotype</p></a></li>
<li><a href='#removeCastePop'><p>Remove a proportion of caste individuals from a colony</p></a></li>
<li><a href='#removeColonies'><p>Remove some colonies from the MultiColony object</p></a></li>
<li><a href='#replaceCastePop'><p>Replace a proportion of caste individuals with new ones</p></a></li>
<li><a href='#reQueen'><p>Re-queen</p></a></li>
<li><a href='#resetEvents'><p>Reset colony events</p></a></li>
<li><a href='#selectColonies'><p>Select colonies from MultiColony object</p></a></li>
<li><a href='#setLocation'><p>Set colony location</p></a></li>
<li><a href='#setQueensYearOfBirth'><p>Set the queen's year of birth</p></a></li>
<li><a href='#SimParamBee'><p>Honeybee simulation parameters</p></a></li>
<li><a href='#simulateHoneyBeeGenomes'><p>Simulate the Honey bee genome</p></a></li>
<li><a href='#split'><p>Split colony in two MultiColony</p></a></li>
<li><a href='#splitPUnif'><p>Sample the split proportion - proportion of removed workers in a</p>
managed split</a></li>
<li><a href='#supersede'><p>Supersede</p></a></li>
<li><a href='#swarm'><p>Swarm</p></a></li>
<li><a href='#swarmPUnif'><p>Sample the swarm proportion - the proportion of workers that swarm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'AlphaSimR' Extension for Simulating Honeybee Populations and
Breeding Programmes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>An extension of the 'AlphaSimR' package
  (<a href="https://cran.r-project.org/package=AlphaSimR">https://cran.r-project.org/package=AlphaSimR</a>) for stochastic simulations of
  honeybee populations and breeding programmes. 'SIMplyBee' enables simulation of
  individual bees that form a colony, which includes a queen, fathers (drones
  the queen mated with), virgin queens, workers, and drones. Multiple colony can
  be merged into a population of colonies, such as an apiary or a whole country
  of colonies. Functions enable operations on castes, colony, or colonies, to
  ease 'R' scripting of whole populations. All 'AlphaSimR' functionality with
  respect to genomes and genetic and phenotype values is available and further
  extended for honeybees, including haplo-diploidy, complementary sex determiner
  locus, colony events (swarming, supersedure, etc.), and colony phenotype values.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/HighlanderLab/SIMplyBee">https://github.com/HighlanderLab/SIMplyBee</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, R6, stats, utils, extraDistr (&ge; 1.9.1)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), AlphaSimR (&ge; 1.3.2)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, ggplot2, testthat (&ge; 3.0.0), Matrix</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-14 20:31:26 UTC; jana</td>
</tr>
<tr>
<td>Author:</td>
<td>Jana Obšteter <a href="https://orcid.org/0000-0003-1511-3916"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Laura Strachan <a href="https://orcid.org/0000-0002-2569-0250"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Jernej Bubnič <a href="https://orcid.org/0000-0003-1362-3736"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Gregor Gorjanc <a href="https://orcid.org/0000-0001-8008-2787"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jana Obšteter &lt;obsteter.jana@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-15 09:20:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='SIMplyBee-package'>SIMplyBee: 'AlphaSimR' Extension for Simulating Honeybee Populations and Breeding Programmes</h2><span id='topic+SIMplyBee'></span><span id='topic+SIMplyBee-package'></span>

<h3>Description</h3>

<p>See the introductory vignette on using this package by running:
<code>vignette("Honeybee_biology", package="SIMplyBee")</code>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jana Obšteter <a href="mailto:obsteter.jana@gmail.com">obsteter.jana@gmail.com</a> (<a href="https://orcid.org/0000-0003-1511-3916">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Laura Strachan (<a href="https://orcid.org/0000-0002-2569-0250">ORCID</a>)
</p>
</li>
<li><p> Jernej Bubnič (<a href="https://orcid.org/0000-0003-1362-3736">ORCID</a>)
</p>
</li>
<li><p> Gregor Gorjanc (<a href="https://orcid.org/0000-0001-8008-2787">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/HighlanderLab/SIMplyBee">https://github.com/HighlanderLab/SIMplyBee</a>
</p>
</li></ul>


<hr>
<h2 id='addCastePop'>Add caste individuals to the colony</h2><span id='topic+addCastePop'></span><span id='topic+addWorkers'></span><span id='topic+addDrones'></span><span id='topic+addVirginQueens'></span>

<h3>Description</h3>

<p>Level 2 function that adds (raises) the specified number of
a specific caste individuals to a Colony or MultiColony object by producing
offspring from a mated queen. If there are already some individuals present
in the caste, new and present individuals are combined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addCastePop(
  x,
  caste = NULL,
  nInd = NULL,
  new = FALSE,
  exact = FALSE,
  year = NULL,
  simParamBee = NULL,
  ...
)

addWorkers(x, nInd = NULL, new = FALSE, exact = FALSE, simParamBee = NULL, ...)

addDrones(x, nInd = NULL, new = FALSE, simParamBee = NULL, ...)

addVirginQueens(
  x,
  nInd = NULL,
  new = FALSE,
  year = NULL,
  simParamBee = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addCastePop_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="addCastePop_+3A_caste">caste</code></td>
<td>
<p>character, &quot;workers&quot;, &quot;drones&quot;, or &quot;virginQueens&quot;</p>
</td></tr>
<tr><td><code id="addCastePop_+3A_nind">nInd</code></td>
<td>
<p>numeric or function, number of workers to be added, but see
<code>new</code>; if <code>NULL</code> then <code><a href="#topic+SimParamBee">SimParamBee</a>$nWorkers</code> is used.
If input is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>,
the input could also be a vector of the same length as the number of colonies. If
a single value is provided, the same value will be used for all the colonies.</p>
</td></tr>
<tr><td><code id="addCastePop_+3A_new">new</code></td>
<td>
<p>logical, should the number of individuals be added to the caste population
anew or should we only top-up the existing number of individuals to <code>nInd</code></p>
</td></tr>
<tr><td><code id="addCastePop_+3A_exact">exact</code></td>
<td>
<p>logical, only relevant when adding workers - if the csd locus is turned
on and exact is <code>TRUE</code>, we add the exact specified number of viable workers
(heterozygous at the csd locus)</p>
</td></tr>
<tr><td><code id="addCastePop_+3A_year">year</code></td>
<td>
<p>numeric, only relevant when adding virgin queens - year of birth for virgin queens</p>
</td></tr>
<tr><td><code id="addCastePop_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
<tr><td><code id="addCastePop_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>nInd</code> when this argument is a function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function increases queen's <code>nWorkers</code> and <code>nHomBrood</code>
counters.
</p>


<h3>Value</h3>

<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with
workers added
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>addWorkers()</code>: Add workers to a colony
</p>
</li>
<li> <p><code>addDrones()</code>: Add drones to a colony
</p>
</li>
<li> <p><code>addVirginQueens()</code>: Add virgin queens to a colony
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 5, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 100)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 5, nDrones = nFathersPoisson)

# Create and cross Colony and MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
apiary &lt;- createMultiColony(basePop[4:5], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[3:4])

#Here we show an example for workers, but same holds for drones and virgin queens!
# Add workers
addCastePop(colony, caste = "workers", nInd = 20)
# Or use a alias function
addWorkers(colony, nInd = 20)
# Same aliases exist for drones and virgin queens!

# If nInd is NULL, the functions uses the default in SP$nWorkers
# We can change this default
SP$nWorkers &lt;- 15
nWorkers(addWorkers(colony))
# nVirginQueens/nWorkers/nDrones will NOT vary between function calls when a constant is used

# Specify a function that will give a number
nWorkers(addWorkers(colony, nInd = nWorkersPoisson))
nWorkers(addWorkers(colony, nInd = nWorkersPoisson))
# nVirginQueens/nWorkers/nDrones will vary between function calls when a function is used

# Store a function or a value in the SP object
SP$nWorkers &lt;- nWorkersPoisson
(addWorkers(colony))
# nVirginQueens/nWorkers/nDrones will vary between function calls when a function is used

# Queen's counters
getMisc(getQueen(addWorkers(colony)))

# Add individuals to a MultiColony object
apiary &lt;- addWorkers(apiary)
# Add different number of workers to colonies
nWorkers(addWorkers(apiary, nInd = c(50, 100)))

</code></pre>

<hr>
<h2 id='buildUp'>Build up Colony or MultiColony object by adding (raising) workers and drones</h2><span id='topic+buildUp'></span>

<h3>Description</h3>

<p>Level 2 function that builds up a Colony or MultiColony object by adding
(raising) workers and drones usually in spring or after events such as split or
swarming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildUp(
  x,
  nWorkers = NULL,
  nDrones = NULL,
  new = TRUE,
  exact = FALSE,
  resetEvents = FALSE,
  simParamBee = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildUp_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="buildUp_+3A_nworkers">nWorkers</code></td>
<td>
<p>numeric or function, number of worker to add to the colony,
but see <code>new</code>; if <code>NULL</code> then <code><a href="#topic+SimParamBee">SimParamBee</a>$nWorkers</code>
is used. If input is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>,
the input could also be a vector of the same length as the number of colonies. If
a single value is provided, the same value will be applied to all the colonies.</p>
</td></tr>
<tr><td><code id="buildUp_+3A_ndrones">nDrones</code></td>
<td>
<p>numeric or function, number of drones to add to the colony,
but see <code>new</code>; if <code>NULL</code> then <code><a href="#topic+SimParamBee">SimParamBee</a>$nDrones</code>
is used. If input is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>,
the input could also be a vector of the same length as the number of colonies. If
a single value is provided, the same value will be applied to all the colonies.</p>
</td></tr>
<tr><td><code id="buildUp_+3A_new">new</code></td>
<td>
<p>logical, should the number of workers and drones be added anew or
should we only top-up the existing number of workers and drones to
<code>nWorkers</code> and <code>nDrones</code> (see details)</p>
</td></tr>
<tr><td><code id="buildUp_+3A_exact">exact</code></td>
<td>
<p>logical, if the csd locus is turned on and exact is <code>TRUE</code>,
create the exact specified number of only viable workers (heterozygous on
the csd locus)</p>
</td></tr>
<tr><td><code id="buildUp_+3A_resetevents">resetEvents</code></td>
<td>
<p>logical, call <code><a href="#topic+resetEvents">resetEvents</a></code> as part of the
build up</p>
</td></tr>
<tr><td><code id="buildUp_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
<tr><td><code id="buildUp_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>nWorkers</code> or <code>nDrones</code>
when these arguments are a function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function increases queen's <code>nWorkers</code>, <code>nHomBrood</code>,
and <code>nDrones</code> counters. It also turns production on.
</p>
<p>Argument <code>new</code> enables simulation of two common cases. First,
if you are modelling year-to-year cycle, you will likely want
<code>new = TRUE</code>, so that, say, in spring you will replace old (from last
year) workers and drones with the new ones. This is the case that we are
targeting and hence <code>new = TRUE</code> is default. Second, if you are
modelling shorter period cycles, you will likely want <code>new = FALSE</code> to
just top up the current workers and drones - you might also want to look at
<code><a href="#topic+replaceWorkers">replaceWorkers</a></code> and <code><a href="#topic+replaceDrones">replaceDrones</a></code>.
</p>
<p>TODO: Discuss on how to model day-to-day variation with <code>new = FALSE</code>.
We are not sure this is easy to achieve with current implementation
just now, but could be expanded.
https://github.com/HighlanderLab/SIMplyBee/issues/176
</p>


<h3>Value</h3>

<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with workers and
drones replaced or added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 4, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
isProductive(colony)
apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
isProductive(apiary)

# Build up
# Using defaults in SP$nWorkers &amp; SP$nDrones
(colony &lt;- buildUp(colony))
isProductive(colony)
# Build-up a MultiColony class
(apiary &lt;- buildUp(apiary))
isProductive(apiary)

# The user can also specify a function that will give a number
colony &lt;- removeWorkers(colony) # Remove workers to start from fresh
colony &lt;- removeDrones(colony) # Remove drones to start from fresh
buildUp(colony, nWorkers = nWorkersPoisson, nDrones = nDronesPoisson)
buildUp(colony, nWorkers = nWorkersPoisson, nDrones = nDronesPoisson)
# nWorkers and nDrones will vary between function calls when a function is used
# You can store these functions or a values in the SP object
SP$nWorkers &lt;- nWorkersPoisson
SP$nDrones &lt;- nDronesPoisson

# Specifying own number
colony &lt;- buildUp(colony, nWorkers = 100)
# Build up a MultiColony class
apiary &lt;- buildUp(apiary, nWorkers = 250)
# Build up with different numbers
apiary &lt;- buildUp(apiary, nWorkers = c(1000, 2000), nDrones = c(100, 150))
nWorkers(apiary)
nDrones(apiary)

# Queen's counters
getMisc(getQueen(buildUp(colony)))
</code></pre>

<hr>
<h2 id='c+2CNULLOrPop-method'>Combine a NULL and AlphaSimR population</h2><span id='topic+c+2CNULLOrPop-method'></span>

<h3>Description</h3>

<p>This combine <code>c()</code> method is a hack to combine NULL and an
AlphaSimR population object <code>c(NULL, pop)</code> (<code>c(pop, NULL)</code> works
already with AlphaSimR package code).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NULLOrPop'
c(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c+2B2CNULLOrPop-method_+3A_x">x</code></td>
<td>
<p>NULL or <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="c+2B2CNULLOrPop-method_+3A_...">...</code></td>
<td>
<p>list of NULL or <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> objects</p>
</td></tr>
</table>

<hr>
<h2 id='calcBeeGRMIbd'>Calculate Genomic Relatedness Matrix (GRM) for honeybees from
Identical By Descent genomic data</h2><span id='topic+calcBeeGRMIbd'></span>

<h3>Description</h3>

<p>Level 0 function that returns Genomic Relatedness Matrix (GRM)
for honeybees from Identical By Descent genomic data (tracked alleles
since the founders) - see references on the background theory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcBeeGRMIbd(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcBeeGRMIbd_+3A_x">x</code></td>
<td>
<p><code><a href="base.html#topic+matrix">matrix</a></code> of haplotypes/genomes with allele indicators
for the founders coded as 1, 2, ... Haplotypes/genome are in rows and sites
are in columns; no missing values are allowed (this is not checked!). Row
names are essential (formated as ind_genome as returned by AlphaSimR IBD
functions) to infer the individual and their ploidy (see examples)!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with a matrix of gametic relatedness coefficients (genome) and
a matrix of individual relatedness coefficients (indiv)
</p>


<h3>References</h3>

<p>Grossman and Eisen (1989) Inbreeding, coancestry, and covariance between
relatives for X-chromosomal loci. The Journal of Heredity,
<a href="https://doi.org//10.1093/oxfordjournals.jhered.a110812">doi:/10.1093/oxfordjournals.jhered.a110812</a>
</p>
<p>Fernando and Grossman (1989) Covariance between relatives for X-chromosomal
loci in a population in disequilibrium. Theoretical and Applied Genetics,
<a href="https://doi.org//10.1007/bf00305821">doi:/10.1007/bf00305821</a>
</p>
<p>Fernando and Grossman (1990) Genetic evaluation with autosomal
and X-chromosomal inheritance. Theoretical and Applied Genetics,
<a href="https://doi.org//10.1007/bf00224018">doi:/10.1007/bf00224018</a>
</p>
<p>Van Arendonk, Tier, and Kinghorn (1994) Use of multiple genetic markers in
prediction of breeding values. Genetics,
<a href="https://doi.org//10.1093/genetics/137.1.319">doi:/10.1093/genetics/137.1.319</a>
</p>
<p>Hill and Weir (2011) Variation in actual relationship as a consequence of
Mendelian sampling and linkage. Genetics Research,
<a href="https://doi.org//10.1017/s0016672310000480">doi:/10.1017/s0016672310000480</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 3, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
SP$setTrackRec(TRUE)
SP$setTrackPed(isTrackPed = TRUE)

basePop &lt;- createVirginQueens(founderGenomes)
drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 1, nDrones = nFathersPoisson)
colony &lt;- createColony(basePop[2])
colony &lt;- cross(x = colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)

haploQ &lt;- getQueenIbdHaplo(colony)
haploW &lt;- getWorkersIbdHaplo(colony)
haploD &lt;- getDronesIbdHaplo(colony)
SP$pedigree

haplo &lt;- rbind(haploQ, haploW, haploD)

GRMs &lt;- calcBeeGRMIbd(x = haplo)
# You can visualise this matrix with the image() functions from the "Matrix" package

# Inspect the diagonal of the relationship matrix between individuals
x &lt;- diag(GRMs$indiv)
hist(x)
summary(x)

 # Inspect the off-diagonal of the relationship matrix between individuals
x &lt;- GRMs$indiv[lower.tri(x = GRMs$indiv, diag = FALSE)]
hist(x)
summary(x)

ids &lt;- getCasteId(colony)
qI &lt;- ids$queen
wI &lt;- sort(ids$workers)
dI &lt;- sort(ids$drones)

qG &lt;- c(t(outer(X = qI, Y = 1:2, FUN = paste, sep = "_")))
wG &lt;- c(t(outer(X = wI, Y = 1:2, FUN = paste, sep = "_")))
dG &lt;- paste(dI, 1, sep = "_")

# Queen vs workers
GRMs$genome[wG, qG]
GRMs$indiv[wI, qI]

# Queen vs drones
GRMs$genome[dG, qG]
GRMs$indiv[dI, qI]

# Workers vs workers
GRMs$genome[wG, wG]
GRMs$indiv[wI, wI]

# Workers vs drones
GRMs$genome[dG, wG]
GRMs$indiv[dI, wI]
</code></pre>

<hr>
<h2 id='calcBeeGRMIbs'>Calculate Genomic Relatedness Matrix (GRM) for honeybees from
Identical By State genomic data</h2><span id='topic+calcBeeGRMIbs'></span><span id='topic+calcBeeAlleleFreq'></span>

<h3>Description</h3>

<p>Level 0 function that returns Genomic Relatedness Matrix (GRM)
for honeybees from Identical By State genomic data (bi-allelic SNP
represented as allele dosages) following the method for the sex X
chromosome (Druet and Legarra, 2020)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcBeeGRMIbs(x, sex, alleleFreq = NULL)

calcBeeAlleleFreq(x, sex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcBeeGRMIbs_+3A_x">x</code></td>
<td>
<p><code><a href="base.html#topic+matrix">matrix</a></code> of genotypes represented as allele dosage coded
as 0, 1, or 2 in females (queens or workers) and as 0 or 1 in males
(fathers or drones); individuals are in rows and sites are in columns; no
missing values are allowed (this is not checked - you will get NAs!)</p>
</td></tr>
<tr><td><code id="calcBeeGRMIbs_+3A_sex">sex</code></td>
<td>
<p>character vector denoting sex for individuals with genotypes in
<code>x</code> - <code>"F"</code> for female and <code>"M"</code> for male</p>
</td></tr>
<tr><td><code id="calcBeeGRMIbs_+3A_allelefreq">alleleFreq</code></td>
<td>
<p>numeric, vector of allele frequencies for the sites in
<code>x</code>; if <code>NULL</code>, then <code><a href="#topic+calcBeeAlleleFreq">calcBeeAlleleFreq</a></code> is used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of genomic relatedness coefficients
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>calcBeeAlleleFreq()</code>: Calculate allele frequencies from honeybee genotypes
</p>
</li></ul>


<h3>References</h3>

<p>Druet and Legarra (2020) Theoretical and empirical comparisons of
expected and realized relationships for the X-chromosome. Genetics
Selection Evolution, 52:50 <a href="https://doi.org//10.1186/s12711-020-00570-6">doi:/10.1186/s12711-020-00570-6</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 3, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
SP$setTrackRec(TRUE)
SP$setTrackPed(isTrackPed = TRUE)

basePop &lt;- createVirginQueens(founderGenomes)
drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 1, nDrones = nFathersPoisson)
colony &lt;- createColony(basePop[2])
colony &lt;- cross(x = colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)

geno &lt;- getSegSiteGeno(colony, collapse = TRUE)
sex &lt;- getCasteSex(x = colony, collapse = TRUE)

GRM &lt;- calcBeeGRMIbs(x = geno, sex = sex)
# You can visualise this matrix with the function image() from the package 'Matrix'

#Look at the diagonal at the relationship matrix
x &lt;- diag(GRM)
hist(x)
summary(x)

#Look at the off-diagonal at the relationship matrix
x &lt;- GRM[lower.tri(x = GRM, diag = FALSE)]
hist(x)
summary(x)

# Compare relationship between castes
ids &lt;- getCasteId(colony)
idQueen &lt;- ids$queen
idWorkers &lt;- ids$workers
idDrones &lt;- ids$drones

# Queen vs others
GRM[idQueen, idWorkers]
GRM[idQueen, idDrones]

# Workers vs worker
GRM[idWorkers, idWorkers]

# Workers vs drones
GRM[idWorkers, idDrones]

# Calculating allele frequencies ourselves (say, to "shift" base population)
aF &lt;- calcBeeAlleleFreq(x = geno, sex = sex)
hist(aF)
GRM2 &lt;- calcBeeGRMIbs(x = geno, sex = sex, alleleFreq = aF)
stopifnot(identical(GRM2, GRM))

# You can also create relationships with pooled genomes
pooledGenoW &lt;- getPooledGeno(getWorkersSegSiteGeno(colony),
                             type = "mean",
                             sex = getCasteSex(colony, caste="workers"))
queenGeno &lt;- getQueenSegSiteGeno(colony)
# Compute relationship between pooled workers genotype and the queen
calcBeeGRMIbs(x = rbind(queenGeno, pooledGenoW), sex = c("F","F"))
# You can now compare how this compare to relationships between the queen
# individual workers!
</code></pre>

<hr>
<h2 id='calcColonyValue'>Calculate colony value(s)</h2><span id='topic+calcColonyValue'></span><span id='topic+calcColonyPheno'></span><span id='topic+calcColonyGv'></span><span id='topic+calcColonyBv'></span><span id='topic+calcColonyDd'></span><span id='topic+calcColonyAa'></span>

<h3>Description</h3>

<p>Level 0 function that calculate value(s) of a colony.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcColonyValue(x, FUN = NULL, simParamBee = NULL, ...)

calcColonyPheno(x, FUN = mapCasteToColonyPheno, simParamBee = NULL, ...)

calcColonyGv(x, FUN = mapCasteToColonyGv, simParamBee = NULL, ...)

calcColonyBv(x, FUN = mapCasteToColonyBv, simParamBee = NULL, ...)

calcColonyDd(x, FUN = mapCasteToColonyDd, simParamBee = NULL, ...)

calcColonyAa(x, FUN = mapCasteToColonyAa, simParamBee = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcColonyValue_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="calcColonyValue_+3A_fun">FUN</code></td>
<td>
<p>function, that calculates colony value from values of
colony members</p>
</td></tr>
<tr><td><code id="calcColonyValue_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
<tr><td><code id="calcColonyValue_+3A_...">...</code></td>
<td>
<p>other arguments of <code>FUN</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with one value or a row of values when <code>x</code> is
<code><a href="#topic+Colony-class">Colony-class</a></code> and a row-named matrix when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>, where names are colony IDs
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>calcColonyPheno()</code>: Calculate colony phenotype value from caste individuals' phenotype values
</p>
</li>
<li> <p><code>calcColonyGv()</code>: Calculate colony genetic value from caste individuals' genetic values
</p>
</li>
<li> <p><code>calcColonyBv()</code>: Calculate colony breeding value from caste individuals' breeding values
</p>
</li>
<li> <p><code>calcColonyDd()</code>: Calculate colony dominance value from caste individuals' dominance values
</p>
</li>
<li> <p><code>calcColonyAa()</code>: Calculate colony epistasis value from caste individuals' epistasis value
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+mapCasteToColonyValue">mapCasteToColonyValue</a></code> as an example of <code>FUN</code>,
<code><a href="#topic+selectColonies">selectColonies</a></code> for example for to select colonies based
on these values, and
<code>vignette(topic = "QuantitativeGenetics", package = "SIMplyBee")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 5, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)

# Define two traits that collectively affect colony honey yield:
# 1) queen's effect on colony honey yield, say via pheromone secretion phenotype
# 2) workers' effect on colony honey yield, say via foraging ability phenotype
# The traits will have a negative genetic correlation of -0.5 and heritability
# of 0.25 (on an individual level)
nWorkers &lt;- 10
mean &lt;- c(10, 10 / nWorkers)
varA &lt;- c(1, 1 / nWorkers)
corA &lt;- matrix(data = c(
  1.0, -0.5,
  -0.5, 1.0
), nrow = 2, byrow = TRUE)
varE &lt;- c(3, 3 / nWorkers)
varA / (varA + varE)
SP$addTraitADE(nQtlPerChr = 100,
               mean = mean,
               var = varA, corA = corA,
               meanDD = 0.1, varDD = 0.2, corD = corA,
               relAA = 0.1, corAA = corA)
SP$setVarE(varE = varE)

basePop &lt;- createVirginQueens(founderGenomes)
drones &lt;- createDrones(x = basePop[1], nInd = 200)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create and cross Colony and MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(colony, nWorkers = nWorkers, nDrones = 3)
apiary &lt;- createMultiColony(basePop[3:5], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(apiary, nWorkers = nWorkers, nDrones = 3)

# Colony value - shorthand version
# (using the default mapCasteToColony*() functions - you can provide yours instead!)
# Phenotype value
calcColonyPheno(colony)
calcColonyPheno(apiary)
# Genetic value
calcColonyGv(colony)
calcColonyGv(apiary)

# Colony value - long version
# (using the default mapCasteToColony*() function - you can provide yours instead!)
calcColonyValue(colony, FUN = mapCasteToColonyPheno)
calcColonyValue(apiary, FUN = mapCasteToColonyPheno)

# Colony value - long version - using a function stored in SimParamBee (SP)
# (using the default mapCasteToColony*() function - you can provide yours instead!)
SP$colonyValueFUN &lt;- mapCasteToColonyPheno
calcColonyValue(colony)
calcColonyValue(apiary)

</code></pre>

<hr>
<h2 id='calcInheritanceCriterion'>Calculate the inheritance criterion</h2><span id='topic+calcInheritanceCriterion'></span>

<h3>Description</h3>

<p>Level 0 function that calculates the inheritance criterion as the
sum of the queen (maternal) and workers (direct) effect from the queen,
as defined by Du et al. (2021). This can be seen as the expected value
of drones from the queen or half the expected value of virgin queens from
the queen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcInheritanceCriterion(x, queenTrait = 1, workersTrait = 2, use = "gv")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcInheritanceCriterion_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code> or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="calcInheritanceCriterion_+3A_queentrait">queenTrait</code></td>
<td>
<p>numeric (column position) or character (column name), trait
that represents queen's effect on the colony value; if <code>NULL</code>
then this effect is 0</p>
</td></tr>
<tr><td><code id="calcInheritanceCriterion_+3A_workerstrait">workersTrait</code></td>
<td>
<p>numeric (column position) or character (column name), trait
that represents workers' effect on the colony value; if <code>NULL</code>
then this effect is 0</p>
</td></tr>
<tr><td><code id="calcInheritanceCriterion_+3A_use">use</code></td>
<td>
<p>character, the measure to use for the calculation, being
either &quot;gv&quot; (genetic value), &quot;ebv&quot; (estimated breeding value),
or &quot;pheno&quot; (phenotypic value)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer when <code>x</code> is
<code><a href="#topic+Colony-class">Colony-class</a></code> and a named list when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>, where names are colony IDs
</p>


<h3>References</h3>

<p>Du, M., et al. (2021) Short-term effects of controlled mating and selection
on the genetic variance of honeybee populations. Heredity 126, 733–747.
<a href="https://doi.org//10.1038/s41437-021-00411-2">doi:/10.1038/s41437-021-00411-2</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcSelectionCriterion">calcSelectionCriterion</a></code> and
<code><a href="#topic+calcPerformanceCriterion">calcPerformanceCriterion</a></code> and  as well as
<code>vignette(topic = "QuantitativeGenetics", package = "SIMplyBee")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
meanA &lt;- c(10, 10 / SP$nWorkers)
varA &lt;- c(1, 1 / SP$nWorkers)
corA &lt;- matrix(data = c( 1.0, -0.5,
                        -0.5,  1.0), nrow = 2, byrow = TRUE)
SP$addTraitA(nQtlPerChr = 100, mean = meanA, var = varA, corA = corA,
name = c("queenTrait", "workersTrait"))
varE &lt;- c(3, 3 / SP$nWorkers)
corE &lt;- matrix(data = c(1.0, 0.3,
                        0.3, 1.0), nrow = 2, byrow = TRUE)
SP$setVarE(varE = varE, corE = corE)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])

calcInheritanceCriterion(colony, queenTrait = 1, workersTrait = 2)
calcInheritanceCriterion(apiary, queenTrait = 1, workersTrait = 2)

apiary[[2]] &lt;- removeQueen(apiary[[2]])
calcInheritanceCriterion(apiary, queenTrait = 1, workersTrait = 2)

</code></pre>

<hr>
<h2 id='calcPerformanceCriterion'>Calculate the performance criterion</h2><span id='topic+calcPerformanceCriterion'></span>

<h3>Description</h3>

<p>Level 0 function that calculates the performance criterion as the
sum of the queen (maternal) effect from the queen and the workers (direct)
effect from her workers, as defined by Du et al. (2021). This can be seen
as the expected value of the colony.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcPerformanceCriterion(
  x,
  queenTrait = 1,
  workersTrait = 2,
  workersTraitFUN = sum,
  use = "gv"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcPerformanceCriterion_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="calcPerformanceCriterion_+3A_queentrait">queenTrait</code></td>
<td>
<p>numeric (column position) or character (column name), trait
that represents queen's effect on the colony value; if <code>NULL</code>
then this effect is 0</p>
</td></tr>
<tr><td><code id="calcPerformanceCriterion_+3A_workerstrait">workersTrait</code></td>
<td>
<p>numeric (column position) or character (column name), trait
that represents workers' effect on the colony value; if <code>NULL</code>
then this effect is 0</p>
</td></tr>
<tr><td><code id="calcPerformanceCriterion_+3A_workerstraitfun">workersTraitFUN</code></td>
<td>
<p>function, that will be applied to the workers effect
values of workers, default is sum (see examples), but note that the correct
function will depend on how you will setup simulation!</p>
</td></tr>
<tr><td><code id="calcPerformanceCriterion_+3A_use">use</code></td>
<td>
<p>character, the measure to use for the calculation, being
either &quot;gv&quot; (genetic value),&quot;ebv&quot; (estimated breeding value),
or &quot;pheno&quot; (phenotypic value)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer when <code>x</code> is
<code><a href="#topic+Colony-class">Colony-class</a></code> and a named list when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>, where names are colony IDs
</p>


<h3>References</h3>

<p>Du, M., et al. (2021) Short-term effects of controlled mating and selection
on the genetic variance of honeybee populations. Heredity 126, 733–747.
<a href="https://doi.org//10.1038/s41437-021-00411-2">doi:/10.1038/s41437-021-00411-2</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcSelectionCriterion">calcSelectionCriterion</a></code> and
<code><a href="#topic+calcInheritanceCriterion">calcInheritanceCriterion</a></code> and  as well as
<code>vignette(topic = "QuantitativeGenetics", package = "SIMplyBee")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
meanA &lt;- c(10, 10 / SP$nWorkers)
varA &lt;- c(1, 1 / SP$nWorkers)
corA &lt;- matrix(data = c( 1.0, -0.5,
                        -0.5,  1.0), nrow = 2, byrow = TRUE)
SP$addTraitA(nQtlPerChr = 100, mean = meanA, var = varA, corA = corA,
name = c("queenTrait", "workersTrait"))
varE &lt;- c(3, 3 / SP$nWorkers)
corE &lt;- matrix(data = c(1.0, 0.3,
                        0.3, 1.0), nrow = 2, byrow = TRUE)
SP$setVarE(varE = varE, corE = corE)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(colony)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(apiary)

calcPerformanceCriterion(colony, queenTrait = 1, workersTrait = 2, workersTraitFUN = sum)
calcPerformanceCriterion(apiary, queenTrait = 1, workersTrait = 2, workersTraitFUN = sum)

apiary[[2]] &lt;- removeQueen(apiary[[2]])
calcPerformanceCriterion(apiary, queenTrait = 1,
                         workersTrait = 2, workersTraitFUN = sum)

</code></pre>

<hr>
<h2 id='calcQueensPHomBrood'>The expected proportion and a realised number of csd homozygous brood</h2><span id='topic+calcQueensPHomBrood'></span><span id='topic+pHomBrood'></span><span id='topic+nHomBrood'></span>

<h3>Description</h3>

<p>Level 0 functions that calculate or report the proportion of csd
homozygous brood of a queen or a colony. The csd locus determines viability
of fertilised eggs (brood) - homozygous brood is removed by workers. These
functions 1) calculate the expected proportion of homozygous brood from the
csd allele of the queen and fathers, 2) report the expected proportion of
homozygous brood, or 3) report a realised number of homozygous brood due to
inheritance process. See <code>vignette(package = "SIMplyBee")</code> for more
details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcQueensPHomBrood(x)

pHomBrood(x)

nHomBrood(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcQueensPHomBrood_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, expected csd homozygosity named by colony id when <code>x</code>
is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>pHomBrood()</code>: Expected percentage of csd homozygous brood
of a queen / colony
</p>
</li>
<li> <p><code>nHomBrood()</code>: Realised number of csd homozygous brood
produced by a queen
</p>
</li></ul>


<h3>See Also</h3>

<p>Demo in the introductory vignette
<code>vignette("Honeybee_biology", package="SIMplyBee")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is a bit long example - the key is at the end!
founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 120, nDrones = 20)
colony &lt;- addVirginQueens(x = colony, nInd = 1)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 100, nDrones = 10)

# Virgin queen
try(calcQueensPHomBrood(basePop[5]))

# Queens of colony
calcQueensPHomBrood(colony)

# Queens of apiary
calcQueensPHomBrood(apiary)

# Inbreed virgin queen with her brothers to generate csd homozygous brood
colony2 &lt;- createColony(x = getVirginQueens(colony))
colony2 &lt;- cross(x = colony2, drones = pullDrones(x = colony, nInd = nFathersPoisson())[[1]])

# Calculate the expected csd homozygosity
calcQueensPHomBrood(getQueen(colony2))
pHomBrood(colony2)

# Evaluate a realised csd homozygosity
nHomBrood(addWorkers(colony2, nInd = 100))
nHomBrood(addWorkers(colony2, nInd = 100))
# nHomBrood will vary between function calls due to inheritance process
</code></pre>

<hr>
<h2 id='calcSelectionCriterion'>Calculate the selection criterion</h2><span id='topic+calcSelectionCriterion'></span>

<h3>Description</h3>

<p>Level 0 function that calculates the selection criterion as the
sum of workers (direct) and queen (maternal) effects of workers,
as defined by Du et al. (2021). This can be seen as the expected value
of virgin queens from the queen (as well as workers, but we would not be
selecting workers).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcSelectionCriterion(
  x,
  queenTrait = 1,
  queenTraitFUN = sum,
  workersTrait = 2,
  workersTraitFUN = sum,
  use = "gv"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcSelectionCriterion_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="calcSelectionCriterion_+3A_queentrait">queenTrait</code></td>
<td>
<p>numeric (column position) or character (column name), trait
that represents queen's effect on the colony value; if <code>NULL</code> then this contribution is 0</p>
</td></tr>
<tr><td><code id="calcSelectionCriterion_+3A_queentraitfun">queenTraitFUN</code></td>
<td>
<p>function, that will be applied to the queen effect
values of workers, default is sum (see examples), but note that the correct
function will depend on how you will setup simulation!</p>
</td></tr>
<tr><td><code id="calcSelectionCriterion_+3A_workerstrait">workersTrait</code></td>
<td>
<p>numeric (column position) or character (column name), trait
that represents workers' effect on the colony value; if <code>NULL</code> then this contribution is 0</p>
</td></tr>
<tr><td><code id="calcSelectionCriterion_+3A_workerstraitfun">workersTraitFUN</code></td>
<td>
<p>function, that will be applied to the workers effect
values of workers, default is sum (see examples), but note that the correct
function will depend on how you will setup simulation!</p>
</td></tr>
<tr><td><code id="calcSelectionCriterion_+3A_use">use</code></td>
<td>
<p>character, the measure to use for the calculation, being
either &quot;gv&quot; (genetic value), &quot;ebv&quot; (estimated breeding value),
or &quot;pheno&quot; (phenotypic value)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer when <code>x</code> is
<code><a href="#topic+Colony-class">Colony-class</a></code> and a named list when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>, where names are colony IDs
</p>


<h3>References</h3>

<p>Du, M., et al. (2021) Short-term effects of controlled mating and selection
on the genetic variance of honeybee populations. Heredity 126, 733–747.
<a href="https://doi.org//10.1038/s41437-021-00411-2">doi:/10.1038/s41437-021-00411-2</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcInheritanceCriterion">calcInheritanceCriterion</a></code> and
<code><a href="#topic+calcPerformanceCriterion">calcPerformanceCriterion</a></code> and  as well as
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
meanA &lt;- c(10, 10 / SP$nWorkers)
varA &lt;- c(1, 1 / SP$nWorkers)
corA &lt;- matrix(data = c( 1.0, -0.5,
                        -0.5,  1.0), nrow = 2, byrow = TRUE)
SP$addTraitA(nQtlPerChr = 100, mean = meanA, var = varA, corA = corA,
name = c("queenTrait", "workersTrait"))
varE &lt;- c(3, 3 / SP$nWorkers)
corE &lt;- matrix(data = c(1.0, 0.3,
                        0.3, 1.0), nrow = 2, byrow = TRUE)
SP$setVarE(varE = varE, corE = corE)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(colony)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(apiary)

calcSelectionCriterion(colony,
                       queenTrait = 1, queenTraitFUN = sum,
                       workersTrait = 2, workersTraitFUN = sum)
calcSelectionCriterion(apiary,
                       queenTrait = 1, queenTraitFUN = sum,
                       workersTrait = 2, workersTraitFUN = sum)

apiary[[2]] &lt;- removeQueen(apiary[[2]])
calcSelectionCriterion(apiary, queenTrait = 1,
                       workersTrait = 2, workersTraitFUN = sum)

</code></pre>

<hr>
<h2 id='collapse'>Collapse</h2><span id='topic+collapse'></span>

<h3>Description</h3>

<p>Level 2 function that collapses a Colony or MultiColony object
by setting the collapse event slot to <code>TRUE</code>. The production status
slot is also changed (to <code>FALSE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>You should use this function in an edge-case when you
want to indicate that the colony has collapsed, but you still want to
collect some values from the colony for a retrospective analysis.
It resembles a situation where the colony has collapsed, but dead
bees are still in the hive.
</p>


<h3>Value</h3>

<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with the collapse
event set to <code>TRUE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 10, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)
drones &lt;- createDrones(basePop[1], n = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = 10)

# Create Colony and MultiColony class
colony &lt;- createColony(x = basePop[1])
colony &lt;- cross(colony, drones = droneGroups[[1]])
apiary &lt;- createMultiColony(x = basePop[2:10], n = 9)
apiary &lt;- cross(apiary, drones = droneGroups[2:10])

# Collapse
hasCollapsed(colony)
colony &lt;- collapse(colony)
hasCollapsed(colony)

hasCollapsed(apiary)
tmp &lt;- pullColonies(apiary, n = 2)
tmp
apiaryLost &lt;- collapse(tmp$pulled)
hasCollapsed(apiaryLost)
apiaryLeft &lt;- tmp$remnant
hasCollapsed(apiaryLeft)
</code></pre>

<hr>
<h2 id='Colony-class'>Honeybee colony</h2><span id='topic+Colony-class'></span><span id='topic+isColony'></span><span id='topic+show+2CColony-method'></span><span id='topic+c+2CColonyOrNULL-method'></span>

<h3>Description</h3>

<p>An object holding honeybee colony
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isColony(x)

## S4 method for signature 'Colony'
show(object)

## S4 method for signature 'ColonyOrNULL'
c(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Colony-class_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code></p>
</td></tr>
<tr><td><code id="Colony-class_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code></p>
</td></tr>
<tr><td><code id="Colony-class_+3A_...">...</code></td>
<td>
<p><code>NULL</code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>isColony()</code>: Test if x is a Colony class object
</p>
</li>
<li> <p><code>show(Colony)</code>: Show colony object
</p>
</li>
<li> <p><code>c(ColonyOrNULL)</code>: Combine multiple colony objects
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>id</code></dt><dd><p>integer, unique ID of the colony</p>
</dd>
<dt><code>location</code></dt><dd><p>numeric, location of the colony (x, y)</p>
</dd>
<dt><code>queen</code></dt><dd><p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, the queen of the colony (we use
its misc slot for queen's age and drones (fathers) she mated with)</p>
</dd>
<dt><code>virginQueens</code></dt><dd><p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, virgin queens of the
colony</p>
</dd>
<dt><code>drones</code></dt><dd><p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, drones of the colony</p>
</dd>
<dt><code>workers</code></dt><dd><p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, workers of the colony</p>
</dd>
<dt><code>split</code></dt><dd><p>logical, has colony split</p>
</dd>
<dt><code>swarm</code></dt><dd><p>logical, has colony swarmed</p>
</dd>
<dt><code>supersedure</code></dt><dd><p>logical, has colony superseded</p>
</dd>
<dt><code>collapse</code></dt><dd><p>logical, has colony collapsed</p>
</dd>
<dt><code>production</code></dt><dd><p>logical, is colony productive</p>
</dd>
<dt><code>last_event</code></dt><dd><p>character, the last event of the colony TODO: revise https://github.com/HighlanderLab/SIMplyBee/issues/10</p>
</dd>
<dt><code>misc</code></dt><dd><p>list, available for storing extra information about the colony</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+createColony">createColony</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 4, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)
colony1 &lt;- createColony(x = basePop[2])
colony1 &lt;- cross(colony1, drones = droneGroups[[1]])
colony2 &lt;- createColony(x = basePop[3])
colony2 &lt;- cross(colony2, drones = droneGroups[[2]])
colony3 &lt;- createColony(x = basePop[4])
colony3 &lt;- cross(colony3, drones = droneGroups[[3]])

colony1
show(colony1)
is(colony1)
isColony(colony1)

apiary &lt;- c(colony1, colony2)
is(apiary)
isMultiColony(apiary)

c(apiary, colony3)
c(colony3, apiary)
</code></pre>

<hr>
<h2 id='combine'>Combine two colony objects</h2><span id='topic+combine'></span>

<h3>Description</h3>

<p>Level 2 function that combines two Colony or MultiColony objects
into one or
two colonies objects of the same length to one. For example, to combine a
weak and a strong colony (or MultiColony). Workers and drones of the weak
colony are added to the strong. User has to remove the weak colony (or
MultiColony) from the workspace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine(strong, weak)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_+3A_strong">strong</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="combine_+3A_weak">weak</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a combined <code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 10, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)
drones &lt;- createDrones(basePop[1], n = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = 10)

# Create weak and strong Colony and MultiColony class
colony1 &lt;- createColony(x = basePop[2])
colony1 &lt;- cross(colony1, drones = droneGroups[[1]])
colony2 &lt;- createColony(x = basePop[3])
colony2 &lt;- cross(colony2, drones = droneGroups[[2]])
apiary1 &lt;- createMultiColony(basePop[4:6], n = 3)
apiary1 &lt;- cross(apiary1, drones = droneGroups[3:5])
apiary2 &lt;- createMultiColony(basePop[7:9], n = 3)
apiary2 &lt;- cross(apiary2, drones = droneGroups[6:8])

# Build-up
colony1 &lt;- buildUp(x = colony1, nWorkers = 100, nDrones = 20)
colony2 &lt;- buildUp(x = colony2, nWorkers = 20, nDrones = 5)
apiary1 &lt;- buildUp(x = apiary1, nWorkers = 100, nDrones = 20)
apiary2 &lt;- buildUp(x = apiary2, nWorkers = 20, nDrones = 5)

# Combine
nWorkers(colony1); nWorkers(colony2)
nDrones(colony1); nDrones(colony2)
colony1 &lt;- combine(strong = colony1, weak = colony2)
nWorkers(colony1); nWorkers(colony2)
nDrones(colony1); nDrones(colony2)
rm(colony2)

nWorkers(apiary1); nWorkers(apiary2)
nDrones(apiary1); nDrones(apiary2)
apiary1 &lt;- combine(strong = apiary1, weak = apiary2)
nWorkers(apiary1); nWorkers(apiary2)
nDrones(apiary1); nDrones(apiary2)
rm(apiary2)
</code></pre>

<hr>
<h2 id='combineBeeGametes'>Create diploid gametes from a mated queen</h2><span id='topic+combineBeeGametes'></span>

<h3>Description</h3>

<p>Level 1 function that produces diploid offspring from a mated queen.
Queen is diploid, while drones are double haploids so we use AlphaSimR diploid
functionality to make this cross, but since drones are double haploids we
get the desired outcome. This is an utility function, and you most likely
want to use the <code><a href="#topic+cross">cross</a></code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineBeeGametes(queen, drones, nProgeny = 1, simParamBee = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineBeeGametes_+3A_queen">queen</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, with a single diploid individual</p>
</td></tr>
<tr><td><code id="combineBeeGametes_+3A_drones">drones</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, with one or more diploid (double
haploid) individual(s)</p>
</td></tr>
<tr><td><code id="combineBeeGametes_+3A_nprogeny">nProgeny</code></td>
<td>
<p>integer, number of progeny to create per cross</p>
</td></tr>
<tr><td><code id="combineBeeGametes_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> with diploid individuals
</p>
<p># Not exporting this function, since its just a helper
</p>

<hr>
<h2 id='combineBeeGametesHaploDiploid'>Create diploid gametes from a mated queen</h2><span id='topic+combineBeeGametesHaploDiploid'></span>

<h3>Description</h3>

<p>Level 1 function that produces diploid offspring from a mated queen.
Drones are haploid, while the queen is diploid, so we first generate gametes
(with recombination) from her and merge them with drone genomes (=gametes),
where we randomly re-sample drones to get the desired number of progeny.
This is an utility function, and you most likely want to use the
<code><a href="#topic+cross">cross</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineBeeGametesHaploDiploid(queen, drones, nProgeny = 1, simParamBee = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineBeeGametesHaploDiploid_+3A_queen">queen</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, with a single diploid individual</p>
</td></tr>
<tr><td><code id="combineBeeGametesHaploDiploid_+3A_drones">drones</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, with one or more haploid individual(s)</p>
</td></tr>
<tr><td><code id="combineBeeGametesHaploDiploid_+3A_nprogeny">nProgeny</code></td>
<td>
<p>integer, number of progeny to create per cross</p>
</td></tr>
<tr><td><code id="combineBeeGametesHaploDiploid_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This would be the right approach to handle haplo-diploid inheritance
in bees, but it causes a raft of downstream issues, since AlphaSimR assumes
that individuals have the same ploidy. Hence, we don't use this function.
</p>


<h3>Value</h3>

<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> with diploid individuals
</p>

<hr>
<h2 id='createCastePop'>Creates caste population individuals from the colony</h2><span id='topic+createCastePop'></span><span id='topic+createWorkers'></span><span id='topic+createDrones'></span><span id='topic+createVirginQueens'></span>

<h3>Description</h3>

<p>Level 1 function that creates the specified number of caste
individuals from the colony with a mated queens. If csd
locus is active, it takes it into account and any csd homozygotes are
removed and counted towards homozygous brood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createCastePop(
  x,
  caste = NULL,
  nInd = NULL,
  exact = TRUE,
  year = NULL,
  editCsd = TRUE,
  csdAlleles = NULL,
  simParamBee = NULL,
  ...
)

createWorkers(x, nInd = NULL, exact = FALSE, simParamBee = NULL, ...)

createDrones(x, nInd = NULL, simParamBee = NULL, ...)

createVirginQueens(
  x,
  nInd = NULL,
  year = NULL,
  editCsd = TRUE,
  csdAlleles = NULL,
  simParamBee = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createCastePop_+3A_x">x</code></td>
<td>
<p><code>link{MapPop-class}</code> (only if caste is &quot;virginQueens&quot;), or
<code>Pop</code> (only if caste is &quot;drones&quot;) or <code><a href="#topic+Colony-class">Colony-class</a></code>
or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="createCastePop_+3A_caste">caste</code></td>
<td>
<p>character, &quot;workers&quot;, &quot;drones&quot;, or &quot;virginQueens&quot;</p>
</td></tr>
<tr><td><code id="createCastePop_+3A_nind">nInd</code></td>
<td>
<p>numeric or function, number of caste individuals; if <code>NULL</code> then
<code><a href="#topic+SimParamBee">SimParamBee</a>$nWorkers</code>,  <code><a href="#topic+SimParamBee">SimParamBee</a>$nDrones</code>
or <code><a href="#topic+SimParamBee">SimParamBee</a>$nVirginQueens</code> is used depending on the caste;
only used when <code>x</code> is <code><a href="#topic+Colony-class">Colony-class</a></code> or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>, when <code>x</code> is <code>link{MapPop-class}</code>
all individuals in <code>x</code> are converted into virgin queens</p>
</td></tr>
<tr><td><code id="createCastePop_+3A_exact">exact</code></td>
<td>
<p>logical, only relevant when creating workers,
if the csd locus is active and exact is <code>TRUE</code>,
create the exactly specified number of viable workers (heterozygous on the
csd locus)</p>
</td></tr>
<tr><td><code id="createCastePop_+3A_year">year</code></td>
<td>
<p>numeric, year of birth for virgin queens</p>
</td></tr>
<tr><td><code id="createCastePop_+3A_editcsd">editCsd</code></td>
<td>
<p>logical (only active when <code>x</code> is <code>link{MapPop-class}</code>),
whether the csd locus should be edited to ensure heterozygosity at the csd
locus (to get viable virgin queens); see <code>csdAlleles</code></p>
</td></tr>
<tr><td><code id="createCastePop_+3A_csdalleles">csdAlleles</code></td>
<td>
<p><code>NULL</code> or list (only active when <code>x</code> is <code>link{MapPop-class}</code>);
If <code>NULL</code>, then the function samples a heterozygous csd genotype for
each virgin queen from all possible csd alleles.
If not <code>NULL</code>, the user provides a list of length <code>nInd</code> with each
node holding a matrix or a data.frame, each having two rows and n columns.
Each row must hold one csd haplotype (allele) that will be assigned to a
virgin queen. The n columns span the length of the csd locus as specified
in <code><a href="#topic+SimParamBee">SimParamBee</a></code>. The two csd alleles must be different to
ensure heterozygosity at the csd locus.</p>
</td></tr>
<tr><td><code id="createCastePop_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
<tr><td><code id="createCastePop_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>nInd</code> when this argument is a function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>when <code>x</code> is <code>link{MapPop-class}</code> returns
<code>virginQueens</code> (a <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>);
when <code>x</code> is <code><a href="#topic+Colony-class">Colony-class</a></code> returns
<code>virginQueens</code> (a <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>);
when <code>x</code> is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
return is a named list of <code>virginQueens</code> (a <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>);
named by colony ID
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>createWorkers()</code>: Create workers from a colony
</p>
</li>
<li> <p><code>createDrones()</code>: Create drones from a colony
</p>
</li>
<li> <p><code>createVirginQueens()</code>: Create virgin queens from a colony
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 4, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
SP$setTrackRec(TRUE)
SP$setTrackPed(isTrackPed = TRUE)

# Create virgin queens on a MapPop
basePop &lt;- createCastePop(founderGenomes, caste = "virginQueens")
# Or alias
createVirginQueens(founderGenomes)
# Same aliases exist for all the castes!!!

# Create drones on a Pop
drones &lt;- createDrones(x = basePop[1],  nInd = 200)
# Or create unequal number of drones from multiple virgin queens
drones &lt;- createDrones(basePop[1:2], nInd = c(100, 200))
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 3, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])

# Using default nInd in SP
colony@virginQueens &lt;- createVirginQueens(colony)
colony@workers &lt;- createWorkers(colony)$workers
colony@drones &lt;- createDrones(colony)
# Usually, you would use functions buildUp() or addCastePop()

# These populations hold individual information
# Example on the virgin queens (same holds for all castes!)
virginQueens &lt;- colony@virginQueens
virginQueens@id
virginQueens@sex
virginQueens@mother
virginQueens@father

# Specify own number
SP$nVirginQueens &lt;- 15
SP$nWorkers &lt;- 100
SP$nDrones &lt;- 10
createVirginQueens(colony)
createVirginQueens(apiary)
# Or creating unequal numbers
createVirginQueens(apiary, nInd = c(5, 10))
# nVirginQueens will NOT vary between function calls when a constant is used

# Specify a function that will give a number
createVirginQueens(colony, nInd = nVirginQueensPoisson)
createVirginQueens(apiary, nInd = nVirginQueensPoisson)
# No. of individuals will vary between function calls when a function is used

# Store a function or a value in the SP object
SP$nVirginQueens &lt;- nVirginQueensPoisson
createVirginQueens(colony)
createVirginQueens(colony)
createVirginQueens(apiary)
createVirginQueens(apiary)
# No. of individuals will vary between function calls when a function is used

# csd homozygosity - relevant when creating virgin queens
SP &lt;- SimParamBee$new(founderGenomes, csdChr = 1, nCsdAlleles = 8)
basePop &lt;- createVirginQueens(founderGenomes, editCsd = FALSE)
all(isCsdHeterozygous(basePop))

basePop &lt;- createVirginQueens(founderGenomes, editCsd = TRUE)
all(isCsdHeterozygous(basePop))
</code></pre>

<hr>
<h2 id='createColony'>Create a new Colony</h2><span id='topic+createColony'></span>

<h3>Description</h3>

<p>Level 2 function that creates a new <code><a href="#topic+Colony-class">Colony-class</a></code>
to initiate simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createColony(x = NULL, location = NULL, simParamBee = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createColony_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, one queen or virgin queen(s)</p>
</td></tr>
<tr><td><code id="createColony_+3A_location">location</code></td>
<td>
<p>numeric, location of the colony as <code>c(x, y)</code></p>
</td></tr>
<tr><td><code id="createColony_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new <code><a href="#topic+Colony-class">Colony-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 5, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)
drones &lt;- createDrones(x = basePop[1], nInd = 15)

# Create an empty Colony class
colony &lt;- createColony()

# Create Colony class with one or multiple virgin queens
colony1 &lt;- createColony(x = basePop[2])
colony1
colony2 &lt;- createColony(x = basePop[3:4])
colony2

# Create a mated Colony
colony1 &lt;- cross(colony1, drones = drones)
colony1
</code></pre>

<hr>
<h2 id='createDCA'>Create a drone congregation area (DCA)</h2><span id='topic+createDCA'></span>

<h3>Description</h3>

<p>Level 1 function that creates a population of drones from a Colony
or MultiColony.  Such a population is often referred to as a drone
congregation area (DCA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createDCA(x, nInd = NULL, removeFathers = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createDCA_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="createDCA_+3A_nind">nInd</code></td>
<td>
<p>numeric, number of random drones to pull from each colony,
if <code>NULL</code> all drones in a colony are pulled</p>
</td></tr>
<tr><td><code id="createDCA_+3A_removefathers">removeFathers</code></td>
<td>
<p>logical, removes <code>drones</code> that have already mated;
set to <code>FALSE</code> if you would like to get drones for mating with multiple
virgin queens, say via insemination</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In reality, drones leave the colony to mate. They die after that.
In this function we only get a copy of drones from <code>x</code>, for
computational efficiency and ease of use. However, any mating will change
the caste of drones to fathers, and they won't be available for future
matings (see <code><a href="#topic+cross">cross</a></code>). Not unless
<code>removeFathers = FALSE</code>.
</p>


<h3>Value</h3>

<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])

colony &lt;- addDrones(colony, nInd = 10)
createDCA(colony)
createDCA(colony, nInd = 10)@id

apiary &lt;- addDrones(apiary)
createDCA(apiary)
createDCA(apiary, nInd = 10)
</code></pre>

<hr>
<h2 id='createMatingStationDCA'>Create a DCA of drones at a mating stations</h2><span id='topic+createMatingStationDCA'></span>

<h3>Description</h3>

<p>Level 1 function that creates a DCA at a classical honeybee
mating station of several sister drone producing queens. The
functions first creates multiple drone producing queens (DPQs) from one colony;
and second, produces drones from the DPQs. All the created drones form a
DCA at a mating station.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createMatingStationDCA(
  colony,
  nDPQs = 20,
  nDronePerDPQ = NULL,
  simParamBee = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createMatingStationDCA_+3A_colony">colony</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> to produce drone producing queens from</p>
</td></tr>
<tr><td><code id="createMatingStationDCA_+3A_ndpqs">nDPQs</code></td>
<td>
<p>integer, the number of drone producing queens</p>
</td></tr>
<tr><td><code id="createMatingStationDCA_+3A_ndroneperdpq">nDronePerDPQ</code></td>
<td>
<p>integer, number of drones each DPQ contributed to the DCA</p>
</td></tr>
<tr><td><code id="createMatingStationDCA_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> with created drones resembling a DCA at a mating station
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 10, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)
drones &lt;- createDrones(basePop[1], n = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = 10)

# Create a colony and cross it
colony1 &lt;- createColony(x = basePop[2])
colony1 &lt;- cross(colony1, drones = droneGroups[[1]])

# Create a empty colony
colony2 &lt;- createColony(x = basePop[3])

# Create a mating station from colony1
matingStation &lt;- createMatingStationDCA(colony1, nDPQs = 20, nDronePerDPQ = 10)

# Cross colony2 on the mating station
fathers &lt;- pullDroneGroupsFromDCA(matingStation, n = 1, nDrones = 15)
colony2 &lt;- cross(colony2, drones = fathers[[1]])
nFathers(colony2)

</code></pre>

<hr>
<h2 id='createMultiColony'>Create MultiColony object</h2><span id='topic+createMultiColony'></span>

<h3>Description</h3>

<p>Level 3 function that creates a set of colonies. Usually to
start a simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createMultiColony(x = NULL, n = NULL, location = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createMultiColony_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, virgin queens or queens for the colonies
(selected at random if there are more than <code>n</code> in <code>Pop</code>, while
all are used when <code>n</code> is <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="createMultiColony_+3A_n">n</code></td>
<td>
<p>integer, number of colonies to create (if only <code>n</code> is
given then <code><a href="#topic+MultiColony-class">MultiColony-class</a></code> is created with <code>n</code>
<code>NULL</code>) individual colony - this is mostly useful for programming)</p>
</td></tr>
<tr><td><code id="createMultiColony_+3A_location">location</code></td>
<td>
<p>list, location of the colonies as <code>c(x, y)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When both <code>x</code> and <code>n</code> are <code>NULL</code>, then a
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with 0 colonies is created.
</p>


<h3>Value</h3>

<p><code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 3, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

# Create 2 empty (NULL) colonies
apiary &lt;- createMultiColony(n = 2)
apiary
apiary[[1]]
apiary[[2]]

# Create 2 virgin colonies
apiary &lt;- createMultiColony(x = basePop, n = 2) # specify n
apiary &lt;- createMultiColony(x = basePop[1:2]) # take all provided
apiary
apiary[[1]]
apiary[[2]]

# Create mated colonies by crossing
apiary &lt;- createMultiColony(x = basePop[1:2], n = 2)
drones &lt;- createDrones(x = basePop[3], n = 30)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 2, nDrones = 15)
apiary &lt;- cross(apiary, drones = droneGroups)
apiary
apiary[[1]]
apiary[[2]]
</code></pre>

<hr>
<h2 id='createRandomCrossPlan'>Create a cross plan by randomly sampling drones for each queen
from a drone population</h2><span id='topic+createRandomCrossPlan'></span>

<h3>Description</h3>

<p>Level 0 function that creates a cross plan by randomly sampling
a desired number of drones from a DCA and assigning them to either
virgin queen or colony ID
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createRandomCrossPlan(IDs, drones, nDrones)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createRandomCrossPlan_+3A_ids">IDs</code></td>
<td>
<p>numeric, IDs of either the virgin queens OR the colonies (can't have both
in the same cross plan!)</p>
</td></tr>
<tr><td><code id="createRandomCrossPlan_+3A_drones">drones</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, drone population available for mating (DCA)</p>
</td></tr>
<tr><td><code id="createRandomCrossPlan_+3A_ndrones">nDrones</code></td>
<td>
<p>integer or function, number of drones to be mated with each virgin
queen</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with names being virgin queen or colony input IDs with each
list element holding the IDs of selected drones
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 15, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)
drones &lt;- createDrones(basePop[1], n = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = 10)

# Create an apiary of colonies and cross it
apiary &lt;- createMultiColony(x = basePop[2:5])
apiary &lt;- cross(apiary, drones = droneGroups[1:4])
apiary &lt;- buildUp(apiary, nWorkers = 100, nDrones = 100)

# Create a DCA from the drones from the apiary
DCA &lt;- createDCA(apiary)
DCA # Inspect the DCA

# Create virgin queens, a virgin colony, and a virgin apiary
virginQueen1 &lt;- basePop[6]
virginQueen2 &lt;- basePop[7]
colony1 &lt;- createColony(basePop[8])
apiary1 &lt;- createMultiColony(basePop[9:11])

# Create a combined cross plan for mating the virgin queens (with virgin queen IDs)
crossPlanVirginQueens &lt;- createRandomCrossPlan(IDs = c(virginQueen1@id, virginQueen2@id),
                                               drones = DCA,
                                               nDrones = nFathersPoisson)

# Cross the virgin queens according to the cross plan
virginQueen1 &lt;- cross(virginQueen1, drones = DCA, crossPlan = crossPlanVirginQueens)
virginQueen2 &lt;- cross(virginQueen2, drones = DCA, crossPlan = crossPlanVirginQueens)

# Create a cross plan for mating the virgin colonies and the virgin apiary (with colony IDs)
crossPlanColonies &lt;- createRandomCrossPlan(IDs = getId(c(colony1, apiary1)),
                                           drones = DCA,
                                           nDrones = nFathersPoisson)

# Cross the colonies according to the cross plan
colony1 &lt;- cross(colony1, drones = DCA, crossPlan = crossPlanColonies)
apiary1 &lt;- cross(apiary1, drones = DCA, crossPlan = crossPlanColonies)
nFathers(colony1)
nFathers(apiary1)

# You can mate virgin queens and colonies in the same way on the mating stations's DCA
# Create a mating station from colony1
matingStationDCA &lt;- createMatingStationDCA(colony1, nDPQs = 20, nDronePerDPQ = 10)

# Create another virgin apiary
apiary2 &lt;- createMultiColony(basePop[12:14])

# Create a cross plan with colonyIDs for crossing the apiary on the mating station
crossPlanApiary &lt;- createRandomCrossPlan(IDs = getId(apiary2),
                                         drones = matingStationDCA,
                                         nDrones = nFathersPoisson)

# Cross the apiary
apiary2 &lt;- cross(apiary2, drones = matingStationDCA, crossPlan = crossPlanApiary)
nFathers(apiary2)

</code></pre>

<hr>
<h2 id='cross'>Cross (mate) virgin queen(s) as a population, of a colony, or
of all given colonies</h2><span id='topic+cross'></span>

<h3>Description</h3>

<p>Level 1 function that crosses (mates) a virgin queen to a group
of drones. The virgin queen(s) could be within a population (<code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>),
in a colony (<code><a href="#topic+Colony-class">Colony-class</a></code>), or multi-colony (<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>).
This function does not create any progeny, it only stores the mated drones
(fathers) so we can later create progeny as needed. When input is a
(<code><a href="#topic+Colony-class">Colony-class</a></code>) or  (<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>), one
virgin queens is selected at random, mated, and promoted to the queen of
the colony. Other virgin queens are destroyed. Mated drones (fathers) are
stored for producing progeny at a later stage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross(x, drones, crossPlan = NULL, checkMating = "error", simParamBee = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> or code<a href="#topic+Colony-class">Colony-class</a> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>,
one or more virgin queens / colonies to be mated;</p>
</td></tr>
<tr><td><code id="cross_+3A_drones">drones</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> or a list of <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>,
group(s) of drones that will be mated with virgin queen(s); if there is
more than one virgin queen, the user has to provide a list of drone
<code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>. For this, the user can use <code><a href="#topic+pullDroneGroupsFromDCA">pullDroneGroupsFromDCA</a></code></p>
</td></tr>
<tr><td><code id="cross_+3A_crossplan">crossPlan</code></td>
<td>
<p>named list with names being virgin queen or colony IDs with
each list element holding the IDs of selected drones. Also see
<code><a href="#topic+createRandomCrossPlan">createRandomCrossPlan</a></code>. If cross plan is <code>NULL</code>, we cross
each virgin queen with the element-wise element of <code>drones</code>, which
should be the same length as the number of virgin queens If the cross plan
is provided, the <code>drones</code> argument must be a single <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>.</p>
</td></tr>
<tr><td><code id="cross_+3A_checkmating">checkMating</code></td>
<td>
<p>character, throw a warning (when <code>checkMating = "warning"</code>),
or stop error (when <code>checkMating = "error"</code>) when some matings fail (see
Details)</p>
</td></tr>
<tr><td><code id="cross_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function changes caste for the mated drones to fathers, and
mated virgin queens to queens. See examples. This means that you can not
use these individuals in matings any more!
</p>
<p>If the supplied drone population is empty (has 0 individuals), which
can happen in edge cases or when <code><a href="#topic+nFathersPoisson">nFathersPoisson</a></code> is used
instead of <code><a href="#topic+nFathersTruncPoisson">nFathersTruncPoisson</a></code>, then mating of a virgin
queen will fail and she will stay virgin. This can happen for just a few
of many virgin queens, which can be annoying to track down, but you can use
<code><a href="#topic+isQueen">isQueen</a></code> or <code><a href="#topic+isVirginQueen">isVirginQueen</a></code> to find such virgin
queens. You can use <code>checkMating</code> to alert you about this situation.
</p>


<h3>Value</h3>

<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> with mated queen(s). The misc slot of the
queens contains additional information about the number of workers, drones,
and homozygous brood produced, and the expected percentage of csd homozygous
brood.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Colony-class">Colony-class</a></code> on how we store the fathers along the
queen.
</p>
<p>For crossing virgin queens according to a cross plan, see
<code><a href="#topic+createRandomCrossPlan">createRandomCrossPlan</a></code>.
For crossing virgin queens on a mating stations, see
<code><a href="#topic+createMatingStationDCA">createMatingStationDCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 20, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 200)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 8, nDrones = nFathersPoisson)

# If input is a Pop class of virgin queen(s)
virginQueen1 &lt;- basePop[2]
isQueen(virginQueen1)
(matedQueen1 &lt;- cross(
  x = virginQueen1,
  drones = droneGroups[[1]]
))

isQueen(virginQueen1)
isQueen(matedQueen1)
nFathers(matedQueen1)
isDrone(getFathers(matedQueen1))
isFather(getFathers(matedQueen1))

virginQueen2 &lt;- basePop[3]
(matedQueen2 &lt;- cross(
  x = virginQueen2,
  drones = droneGroups[[2]]
))

isQueen(virginQueen2)
isQueen(matedQueen2)
nFathers(matedQueen2)

matedQueens &lt;- cross(
  x = c(basePop[4], basePop[5]),
  drones = droneGroups[c(3, 4)]
)

isQueen(matedQueens)
nFathers(matedQueens)
getFathers(matedQueens)

# Inbred mated queen (mated with her own sons)
matedQueen3 &lt;- cross(
  x = basePop[1],
  drones = droneGroups[[5]]
)
# Check the expected csd homozygosity
pHomBrood(matedQueen3)

# If input is a Colony or MultiColony class
# Create Colony and MultiColony class
colony &lt;- createColony(basePop[6])
isVirginQueen(getVirginQueens(colony))
apiary &lt;- createMultiColony(basePop[7:8], n = 2)
all(isVirginQueen(mergePops(getVirginQueens(apiary))))

# Cross
colony &lt;- cross(colony, drones = droneGroups[[6]])
isQueenPresent(colony)
apiary &lt;- cross(apiary, drones = droneGroups[c(7, 8)])
all(isQueenPresent(apiary))
nFathers(apiary)

# Try mating with drones that were already used for mating
colony &lt;- createColony(basePop[9])
try((matedColony &lt;- cross(x = colony, drones = droneGroups[[1]])))
# Create new drones and mate the colony with them
drones &lt;- createDrones(x = basePop[1], nInd = 15)
all(isDrone(drones))
any(isFather(drones))
(matedColony &lt;- cross(x = colony, drones = drones))
isQueenPresent(matedColony)

</code></pre>

<hr>
<h2 id='downsize'>Reduce number of workers and remove all drones and virgin queens from
a Colony or MultiColony object</h2><span id='topic+downsize'></span>

<h3>Description</h3>

<p>Level 2 function that downsizes a Colony or MultiColony object
by removing a proportion of workers, all drones and all virgin queens.
Usually in the autumn, such an event occurs in preparation for the winter months.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downsize(x, p = NULL, use = "rand", new = FALSE, simParamBee = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="downsize_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="downsize_+3A_p">p</code></td>
<td>
<p>numeric, proportion of workers to be removed from the colony; if
<code>NULL</code> then <code><a href="#topic+SimParamBee">SimParamBee</a>$downsizeP</code> is used.
If input is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>,
the input could also be a vector of the same length as the number of colonies. If
a single value is provided, the same value will be applied to all the colonies</p>
</td></tr>
<tr><td><code id="downsize_+3A_use">use</code></td>
<td>
<p>character, all the options provided by <code><a href="AlphaSimR.html#topic+selectInd">selectInd</a></code>;
it guides the selection of workers that will be removed</p>
</td></tr>
<tr><td><code id="downsize_+3A_new">new</code></td>
<td>
<p>logical, should we remove all current workers and add a targeted
proportion anew (say, create winter workers)</p>
</td></tr>
<tr><td><code id="downsize_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
<tr><td><code id="downsize_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>p</code> when this argument is a
function</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with workers reduced and
drones/virgin queens removed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 4, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)
drones &lt;- createDrones(x = basePop[1], nInd = 100)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 3, nDrones = 12)

# Create and cross Colony and MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(colony)
apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(apiary)

# Downsize
colony &lt;- downsize(x = colony, new = TRUE, use = "rand")
colony
apiary &lt;- downsize(x = apiary, new = TRUE, use = "rand")
apiary[[1]]

# Downsize with different numbers
nWorkers(apiary); nDrones(apiary)
apiary &lt;- downsize(x = apiary, p = c(0.5, 0.1), new = TRUE, use = "rand")
nWorkers(apiary); nDrones(apiary)
</code></pre>

<hr>
<h2 id='downsizePUnif'>Sample the downsize proportion - proportion of removed workers in
downsizing</h2><span id='topic+downsizePUnif'></span>

<h3>Description</h3>

<p>Sample the downsize proportion - proportion of removed workers
in downsizing - used when <code>p = NULL</code> (see
<code><a href="#topic+SimParamBee">SimParamBee</a>$downsizeP</code>).
</p>
<p>This is just an example. You can provide your own functions that satisfy
your needs!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downsizePUnif(colony, n = 1, min = 0.8, max = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="downsizePUnif_+3A_colony">colony</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code></p>
</td></tr>
<tr><td><code id="downsizePUnif_+3A_n">n</code></td>
<td>
<p>integer, number of samples</p>
</td></tr>
<tr><td><code id="downsizePUnif_+3A_min">min</code></td>
<td>
<p>numeric, lower limit for <code>downsizePUnif</code></p>
</td></tr>
<tr><td><code id="downsizePUnif_+3A_max">max</code></td>
<td>
<p>numeric, upper limit for <code>downsizePUnif</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, downsize proportion
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimParamBee">SimParamBee</a></code> field <code>downsizeP</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>downsizePUnif()
downsizePUnif()
p &lt;- downsizePUnif(n = 1000)
hist(p, breaks = seq(from = 0, to = 1, by = 0.01), xlim = c(0, 1))
</code></pre>

<hr>
<h2 id='editCsdLocus'>Edit the csd locus</h2><span id='topic+editCsdLocus'></span>

<h3>Description</h3>

<p>Edits the csd locus in an entire population of individuals to
ensure heterozygosity. The user can provide a list of csd alleles for each
individual or, alternatively, the function samples a heterozygous genotype
for each individual from all possible csd alleles. The gv slot is
recalculated to reflect the any changes due to editing, but other slots
remain the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editCsdLocus(pop, alleles = NULL, simParamBee = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="editCsdLocus_+3A_pop">pop</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="editCsdLocus_+3A_alleles">alleles</code></td>
<td>
<p><code>NULL</code> or list;
If <code>NULL</code>, then the function samples a heterozygous csd genotype for
each virgin queen from all possible csd alleles.
If not <code>NULL</code>, the user provides a list of length <code>nInd</code> with each
node holding a matrix or a data.frame, each having two rows and n columns.
Each row must hold one csd haplotype (allele) that will be assigned to a
virgin queen. The n columns span the length of the csd locus as specified
in <code><a href="#topic+SimParamBee">SimParamBee</a></code>. The two csd alleles must be different to
ensure heterozygosity at the csd locus.</p>
</td></tr>
<tr><td><code id="editCsdLocus_+3A_simparambee">simParamBee</code></td>
<td>
<p>global simulation parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>
</p>

<hr>
<h2 id='getAa'>Access epistasis values of individuals in a caste</h2><span id='topic+getAa'></span><span id='topic+getQueenAa'></span><span id='topic+getFathersAa'></span><span id='topic+getVirginQueensAa'></span><span id='topic+getWorkersAa'></span><span id='topic+getDronesAa'></span>

<h3>Description</h3>

<p>Level 0 function that returns epistasis values of
individuals in a caste.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAa(x, caste = NULL, nInd = NULL, collapse = FALSE, simParamBee = NULL)

getQueenAa(x, collapse = FALSE, simParamBee = NULL)

getFathersAa(x, nInd = NULL, collapse = FALSE, simParamBee = NULL)

getVirginQueensAa(x, nInd = NULL, collapse = FALSE, simParamBee = NULL)

getWorkersAa(x, nInd = NULL, collapse = FALSE, simParamBee = NULL)

getDronesAa(x, nInd = NULL, collapse = FALSE, simParamBee = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAa_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="getAa_+3A_caste">caste</code></td>
<td>
<p>NULL or character, NULL when <code>x</code> is a <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>,
and character when <code>x</code> is a <code><a href="#topic+Colony-class">Colony-class</a></code> or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with the possible values of &quot;queen&quot;, &quot;fathers&quot;,
&quot;workers&quot;, &quot;drones&quot;, &quot;virginQueens&quot;, or &quot;all&quot;</p>
</td></tr>
<tr><td><code id="getAa_+3A_nind">nInd</code></td>
<td>
<p>numeric, number of individuals to access, if <code>NULL</code> all
individuals are accessed, otherwise a random sample</p>
</td></tr>
<tr><td><code id="getAa_+3A_collapse">collapse</code></td>
<td>
<p>logical, if the return value should be a single matrix
with epistatic values of all the individuals</p>
</td></tr>
<tr><td><code id="getAa_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of epistasis values when <code>x</code> is
<code><a href="#topic+Colony-class">Colony-class</a></code> and list of vectors of epistasis values when
<code>x</code> is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>, named by colony id when <code>x</code>
is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>
<p># Not exporting this function, since the theory behind it is not fully developed
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getQueenAa()</code>: Access epistasis value of the queen
</p>
</li>
<li> <p><code>getFathersAa()</code>: Access epistasis values of fathers
</p>
</li>
<li> <p><code>getVirginQueensAa()</code>: Access epistasis values of virgin queens
</p>
</li>
<li> <p><code>getWorkersAa()</code>: Access epistasis values of workers
</p>
</li>
<li> <p><code>getDronesAa()</code>: Access epistasis values of drones
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="AlphaSimR.html#topic+dd">dd</a></code> and
<code>vignette(topic = "QuantitativeGenetics", package = "SIMplyBee")</code>
</p>

<hr>
<h2 id='getBv'>Access breeding values of individuals in a caste</h2><span id='topic+getBv'></span><span id='topic+getQueenBv'></span><span id='topic+getFathersBv'></span><span id='topic+getVirginQueensBv'></span><span id='topic+getWorkersBv'></span><span id='topic+getDronesBv'></span>

<h3>Description</h3>

<p>Level 0 function that returns breeding values of individuals in
a caste.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBv(x, caste = NULL, nInd = NULL, collapse = FALSE, simParamBee = NULL)

getQueenBv(x, collapse = FALSE, simParamBee = NULL)

getFathersBv(x, nInd = NULL, collapse = FALSE, simParamBee = NULL)

getVirginQueensBv(x, nInd = NULL, collapse = FALSE, simParamBee = NULL)

getWorkersBv(x, nInd = NULL, collapse = FALSE, simParamBee = NULL)

getDronesBv(x, nInd = NULL, collapse = FALSE, simParamBee = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBv_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="getBv_+3A_caste">caste</code></td>
<td>
<p>NULL or character, NULL when <code>x</code> is a <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>,
and character when <code>x</code> is a <code><a href="#topic+Colony-class">Colony-class</a></code> or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with the possible values of &quot;queen&quot;, &quot;fathers&quot;,
&quot;workers&quot;, &quot;drones&quot;, &quot;virginQueens&quot;, or &quot;all&quot;</p>
</td></tr>
<tr><td><code id="getBv_+3A_nind">nInd</code></td>
<td>
<p>numeric, number of individuals to access, if <code>NULL</code> all
individuals are accessed, otherwise a random sample</p>
</td></tr>
<tr><td><code id="getBv_+3A_collapse">collapse</code></td>
<td>
<p>logical, if the return value should be a single matrix
with breeding valued of all the individuals</p>
</td></tr>
<tr><td><code id="getBv_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of breeding values when <code>x</code> is <code><a href="#topic+Colony-class">Colony-class</a></code>
and list of vectors of breeding values when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>, named by colony id when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>
<p># Not exporting this function, since the theory behind it is not fully developed
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getQueenBv()</code>: Access breeding value of the queen
</p>
</li>
<li> <p><code>getFathersBv()</code>: Access breeding values of fathers
</p>
</li>
<li> <p><code>getVirginQueensBv()</code>: Access breeding values of virgin queens
</p>
</li>
<li> <p><code>getWorkersBv()</code>: Access breeding values of workers
</p>
</li>
<li> <p><code>getDronesBv()</code>: Access breeding values of drones
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="AlphaSimR.html#topic+bv">bv</a></code> and
<code>vignette(topic = "QuantitativeGenetics", package = "SIMplyBee")</code>
</p>

<hr>
<h2 id='getCaste'>Report caste of an individual</h2><span id='topic+getCaste'></span>

<h3>Description</h3>

<p>Level 0 function that reports caste of an individual
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCaste(x, collapse = FALSE, simParamBee = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCaste_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="getCaste_+3A_collapse">collapse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the function will return a single
vector with caste information</p>
</td></tr>
<tr><td><code id="getCaste_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When x is <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, character of caste status; if you
get <code>NA</code> note that this is not supposed to happen. When x is
<code><a href="#topic+Colony-class">Colony-class</a></code>, list with character vectors (list is named with
caste). When x is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>, list of lists with
character vectors (list is named with colony id).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getCastePop">getCastePop</a></code> and <code><a href="#topic+getCasteId">getCasteId</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 20, nDrones = 5)
colony &lt;- addVirginQueens(colony, nInd = 5)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 10, nDrones = 2)
apiary &lt;- addVirginQueens(apiary, nInd = 4)

getCaste(getQueen(colony))
getCaste(getFathers(colony))
getCaste(getWorkers(colony))
getCaste(getDrones(colony))
getCaste(getVirginQueens(colony))

bees &lt;- c(
  getQueen(colony),
  getFathers(colony, nInd = 2),
  getWorkers(colony, nInd = 2),
  getDrones(colony, nInd = 2),
  getVirginQueens(colony, nInd = 2)
)
getCaste(bees)

getCaste(colony)
# Collapse information into a single vector
getCaste(colony, collapse = TRUE)
getCaste(apiary)

# Create a data.frame with id, colony, and caste information
(tmpC &lt;- getCaste(apiary[[1]]))
(tmpI &lt;- getCasteId(apiary[[1]]))
tmp &lt;- data.frame(caste = unlist(tmpC), id = unlist(tmpI))
head(tmp)
tail(tmp)

(tmpC &lt;- getCaste(apiary))
(tmpI &lt;- getCasteId(apiary))
(tmp &lt;- data.frame(caste = unlist(tmpC), id = unlist(tmpI)))
tmp$colony &lt;- sapply(
  X = strsplit(
    x = rownames(tmp), split = ".",
    fixed = TRUE
  ),
  FUN = function(z) z[[1]]
)
head(tmp)
tail(tmp)
</code></pre>

<hr>
<h2 id='getCasteId'>Get IDs of individuals of a caste, or ID of all members of colony</h2><span id='topic+getCasteId'></span>

<h3>Description</h3>

<p>Level 0 function that returns the ID individuals of a caste. To
get the individuals, use <code><a href="#topic+getCastePop">getCastePop</a></code>. To get individuals'
caste, use <code><a href="#topic+getCaste">getCaste</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCasteId(x, caste = "all", collapse = FALSE, simParamBee = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCasteId_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="getCasteId_+3A_caste">caste</code></td>
<td>
<p>character, &quot;queen&quot;, &quot;fathers&quot;, &quot;workers&quot;, &quot;drones&quot;,
&quot;virginQueens&quot;, or &quot;all&quot;</p>
</td></tr>
<tr><td><code id="getCasteId_+3A_collapse">collapse</code></td>
<td>
<p>logical, if all IDs should be returned as a single vector</p>
</td></tr>
<tr><td><code id="getCasteId_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>when <code>x</code> is <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> for <code>caste != "all"</code>
or list for <code>caste == "all"</code> with ID nodes named by caste;
when <code>x</code> is <code><a href="#topic+Colony-class">Colony-class</a></code> return is a named list of
<code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> for <code>caste != "all"</code>
or named list for <code>caste == "all"</code> indluding caste members IDs;
when <code>x</code> is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code> return is a named list of
<code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> for <code>caste != "all"</code> or named list of lists of
<code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> for <code>caste == "all"</code> indluding caste members IDs
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getCaste">getCaste</a></code>
</p>
<p><code><a href="#topic+getCastePop">getCastePop</a></code> and <code><a href="#topic+getCaste">getCaste</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 20, nDrones = 5)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 10, nDrones = 2)
apiary &lt;- addVirginQueens(apiary, nInd = 4)

getCasteId(x = drones)
getCasteId(x = colony)
getCasteId(x = apiary, caste = "workers")
getCasteId(x = apiary)
getCasteId(x = apiary, caste = "virginQueens")
# Get all IDs as a single vector
getCasteId(x = colony, caste = "all", collapse = TRUE)
getCasteId(x = apiary, caste = "workers", collapse = TRUE)
getCasteId(x = apiary, caste = "drones", collapse = TRUE)
getCasteId(x = apiary, caste = "all", collapse = TRUE)

# Create a data.frame with id, colony, and caste information
(tmpC &lt;- getCaste(apiary[[1]]))
(tmpI &lt;- getCasteId(apiary[[1]]))
tmp &lt;- data.frame(caste = unlist(tmpC), id = unlist(tmpI))
head(tmp)
tail(tmp)

(tmpC &lt;- getCaste(apiary))
(tmpI &lt;- getCasteId(apiary))
(tmp &lt;- data.frame(caste = unlist(tmpC), id = unlist(tmpI)))
tmp$colony &lt;- sapply(
  X = strsplit(
    x = rownames(tmp), split = ".",
    fixed = TRUE
  ),
  FUN = function(z) z[[1]]
)
head(tmp)
tail(tmp)
</code></pre>

<hr>
<h2 id='getCastePop'>Access individuals of a caste</h2><span id='topic+getCastePop'></span><span id='topic+getQueen'></span><span id='topic+getFathers'></span><span id='topic+getWorkers'></span><span id='topic+getDrones'></span><span id='topic+getVirginQueens'></span>

<h3>Description</h3>

<p>Level 1 function that returns individuals of a caste. These
individuals stay in the colony (compared to <code><a href="#topic+pullCastePop">pullCastePop</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCastePop(
  x,
  caste = "all",
  nInd = NULL,
  use = "rand",
  removeFathers = TRUE,
  collapse = FALSE
)

getQueen(x, collapse = FALSE)

getFathers(x, nInd = NULL, use = "rand", collapse = FALSE)

getWorkers(x, nInd = NULL, use = "rand", collapse = FALSE)

getDrones(x, nInd = NULL, use = "rand", removeFathers = TRUE, collapse = FALSE)

getVirginQueens(x, nInd = NULL, use = "rand", collapse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCastePop_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>,
exceptionally <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> for calling <code>getFathers</code>
on a queen population</p>
</td></tr>
<tr><td><code id="getCastePop_+3A_caste">caste</code></td>
<td>
<p>character, &quot;queen&quot;, &quot;fathers&quot;, &quot;workers&quot;, &quot;drones&quot;,
&quot;virginQueens&quot;, or &quot;all&quot;</p>
</td></tr>
<tr><td><code id="getCastePop_+3A_nind">nInd</code></td>
<td>
<p>numeric, number of individuals to access, if <code>NULL</code> all
individuals are accessed; if there are less individuals than requested,
we return the ones available - this can return <code>NULL</code>.
If input is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>,
the input could also be a vector of the same length as the number of colonies. If
a single value is provided, the same value will be applied to all the colonies.</p>
</td></tr>
<tr><td><code id="getCastePop_+3A_use">use</code></td>
<td>
<p>character, all options provided by <code><a href="AlphaSimR.html#topic+selectInd">selectInd</a></code> and
<code>"order"</code> that selects <code>1:nInd</code> individuals (meaning it always
returns at least one individual, even if <code>nInd = 0</code>)</p>
</td></tr>
<tr><td><code id="getCastePop_+3A_removefathers">removeFathers</code></td>
<td>
<p>logical, removes <code>drones</code> that have already mated;
set to <code>FALSE</code> if you would like to get drones for mating with multiple
virgin queens, say via insemination</p>
</td></tr>
<tr><td><code id="getCastePop_+3A_collapse">collapse</code></td>
<td>
<p>logical, whether to return a single merged population</p>
</td></tr>
</table>


<h3>Value</h3>

<p>when <code>x</code> is <code><a href="#topic+Colony-class">Colony-class</a></code> return is
<code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> for <code>caste != "all"</code> or list for <code>caste
  == "all"</code> with nodes named by caste; when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code> return is a named list of
<code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> for <code>caste != "all"</code> or named list of lists of
<code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> for <code>caste == "all"</code>. You can merge
all the populations in the list with <code><a href="AlphaSimR.html#topic+mergePops">mergePops</a></code> function.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getQueen()</code>: Access the queen
</p>
</li>
<li> <p><code>getFathers()</code>: Access fathers (drones the queen mated with)
</p>
</li>
<li> <p><code>getWorkers()</code>: Access workers
</p>
</li>
<li> <p><code>getDrones()</code>: Access drones
</p>
</li>
<li> <p><code>getVirginQueens()</code>: Access virgin queens
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+getQueen">getQueen</a></code>, <code><a href="#topic+getFathers">getFathers</a></code>,
<code><a href="#topic+getVirginQueens">getVirginQueens</a></code>, <code><a href="#topic+getWorkers">getWorkers</a></code>, and
<code><a href="#topic+getDrones">getDrones</a></code>
</p>
<p><code><a href="#topic+getCasteId">getCasteId</a></code> and <code><a href="#topic+getCaste">getCaste</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])

# Build-up and add virgin queens
colony &lt;- buildUp(x = colony)
apiary &lt;- buildUp(x = apiary)
colony &lt;- addVirginQueens(x = colony)
apiary &lt;- addVirginQueens(x = apiary)

# Get the queen of the colony
getCastePop(colony, caste = "queen")
getQueen(colony)

# Comparison of getCastePop() and getWorkers()
getCastePop(colony, caste = "workers")
getCastePop(colony, caste = "workers")
getCastePop(colony, caste = "workers", nInd = 2)
# Or aliases
getWorkers(colony)
# Same aliases exist for all the castes!

# Input is a MultiColony class - same behaviour as for the Colony!
getCastePop(apiary, caste = "queen")
# Or alias
getQueen(apiary)

# Sample individuals from all the castes
getCastePop(colony, nInd = 5, caste = "all")

# Get different number of workers per colony
getCastePop(apiary, caste = "workers", nInd = c(10, 20))
# Or alias
getWorkers(apiary, nInd = c(10, 20))

# Obtain individuals from MultiColony as a single population
getCastePop(apiary, caste = "queen", collapse = TRUE)
getQueen(apiary, collapse = TRUE)
getWorkers(apiary, nInd = 10, collapse = TRUE)
getDrones(apiary, nInd = 3, collapse = TRUE)
</code></pre>

<hr>
<h2 id='getCasteSex'>Get sex of individuals of a caste, or sex of all members of colony</h2><span id='topic+getCasteSex'></span>

<h3>Description</h3>

<p>Level 0 function that returns the sex individuals of a caste. To
get the individuals, use <code><a href="#topic+getCastePop">getCastePop</a></code>. To get individuals'
caste, use <code><a href="#topic+getCaste">getCaste</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCasteSex(x, caste = "all", collapse = FALSE, simParamBee = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCasteSex_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="getCasteSex_+3A_caste">caste</code></td>
<td>
<p>character, &quot;queen&quot;, &quot;fathers&quot;, &quot;workers&quot;, &quot;drones&quot;,
&quot;virginQueens&quot;, or &quot;all&quot;</p>
</td></tr>
<tr><td><code id="getCasteSex_+3A_collapse">collapse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the function will return a single
vector with sex information</p>
</td></tr>
<tr><td><code id="getCasteSex_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>when <code>x</code> is <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> for <code>caste != "all"</code>
or list for <code>caste == "all"</code> with sex nodes named by caste;
when <code>x</code> is <code><a href="#topic+Colony-class">Colony-class</a></code> return is a named list of
<code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> for <code>caste != "all"</code>
or named list for <code>caste == "all"</code> indluding caste members sexes;
when <code>x</code> is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code> return is a named list of
<code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> for <code>caste != "all"</code> or named list of lists of
<code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> for <code>caste == "all"</code> indluding caste members sexes
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getCaste">getCaste</a></code>
</p>
<p><code><a href="#topic+getCastePop">getCastePop</a></code> and <code><a href="#topic+getCaste">getCaste</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 20, nDrones = 5)
colony &lt;- addVirginQueens(colony, nInd = 5)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 10, nDrones = 2)
apiary &lt;- addVirginQueens(apiary, nInd = 4)

getCasteSex(x = drones)
getCasteSex(x = colony)
getCasteSex(x = apiary, caste = "workers")
getCasteSex(x = apiary)
getCasteSex(x = apiary, caste = "virginQueens")
# Collapse information into a single vector
getCasteSex(colony, caste = "all", collapse = TRUE)

# Create a data.frame with sex, colony, and caste information
(tmpC &lt;- getCaste(apiary[[1]]))
(tmpS &lt;- getCasteSex(apiary[[1]]))
(tmpI &lt;- getCasteId(apiary[[1]]))
tmp &lt;- data.frame(caste = unlist(tmpC), sex = unlist(tmpS), id = unlist(tmpI))
head(tmp)
tail(tmp)

(tmpC &lt;- getCaste(apiary))
(tmpS &lt;- getCasteSex(apiary))
(tmpI &lt;- getCasteId(apiary))
tmp &lt;- data.frame(caste = unlist(tmpC), sex = unlist(tmpS), id = unlist(tmpI))
tmp$colony &lt;- sapply(
  X = strsplit(
    x = rownames(tmp), split = ".",
    fixed = TRUE
  ),
  FUN = function(z) z[[1]]
)
head(tmp)
tail(tmp)
</code></pre>

<hr>
<h2 id='getCsdAlleles'>Get csd alleles</h2><span id='topic+getCsdAlleles'></span><span id='topic+getQueenCsdAlleles'></span><span id='topic+getFathersCsdAlleles'></span><span id='topic+getVirginQueensCsdAlleles'></span><span id='topic+getWorkersCsdAlleles'></span><span id='topic+getDronesCsdAlleles'></span>

<h3>Description</h3>

<p>Level 0 function that returns alleles from the csd locus. See
<code><a href="#topic+SimParamBee">SimParamBee</a></code> for more information about the csd locus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCsdAlleles(
  x,
  caste = NULL,
  nInd = NULL,
  allele = "all",
  dronesHaploid = TRUE,
  collapse = FALSE,
  unique = FALSE,
  simParamBee = NULL
)

getQueenCsdAlleles(
  x,
  allele = "all",
  unique = FALSE,
  collapse = FALSE,
  simParamBee = NULL
)

getFathersCsdAlleles(
  x,
  nInd = NULL,
  allele = "all",
  dronesHaploid = TRUE,
  unique = FALSE,
  collapse = FALSE,
  simParamBee = NULL
)

getVirginQueensCsdAlleles(
  x,
  nInd = NULL,
  allele = "all",
  unique = FALSE,
  collapse = FALSE,
  simParamBee = NULL
)

getWorkersCsdAlleles(
  x,
  nInd = NULL,
  allele = "all",
  unique = FALSE,
  collapse = FALSE,
  simParamBee = NULL
)

getDronesCsdAlleles(
  x,
  nInd = NULL,
  allele = "all",
  dronesHaploid = TRUE,
  unique = FALSE,
  collapse = FALSE,
  simParamBee = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCsdAlleles_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="getCsdAlleles_+3A_caste">caste</code></td>
<td>
<p>NULL or character, NULL when <code>x</code> is a <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>,
and character when <code>x</code> is a <code><a href="#topic+Colony-class">Colony-class</a></code> or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with the possible values of &quot;queen&quot;, &quot;fathers&quot;,
&quot;workers&quot;, &quot;drones&quot;, &quot;virginQueens&quot;, or &quot;all&quot;</p>
</td></tr>
<tr><td><code id="getCsdAlleles_+3A_nind">nInd</code></td>
<td>
<p>numeric, for how many individuals; if <code>NULL</code> all individuals
are taken; this can be useful as a test of sampling individuals</p>
</td></tr>
<tr><td><code id="getCsdAlleles_+3A_allele">allele</code></td>
<td>
<p>character, either &quot;all&quot; for both alleles or an integer for a
single allele, use a value of 1 for female allele and a value of 2 for male
allele</p>
</td></tr>
<tr><td><code id="getCsdAlleles_+3A_droneshaploid">dronesHaploid</code></td>
<td>
<p>logical, return haploid result for drones?</p>
</td></tr>
<tr><td><code id="getCsdAlleles_+3A_collapse">collapse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the function will return a set of
csd alleles across the entire population, colony, or multicolony (not
separately for each caste when <code>x</code> is a colony or each caste of
each colony when <code>x</code> is a multicolony. This is a way to get one single
object as an output across castes or colonies. Note this has nothing to do
with the colony collapse. It's like <code>paste(..., collapse = TRUE)</code>.
Default is <code>FALSE</code>. See examples about this behaviour.</p>
</td></tr>
<tr><td><code id="getCsdAlleles_+3A_unique">unique</code></td>
<td>
<p>logical, return only the unique set of csd alleles. This argument
interacts with <code>collapse</code>. Default is <code>FALSE</code>. See examples about
this behaviour.</p>
</td></tr>
<tr><td><code id="getCsdAlleles_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both collapse and unique are <code>TRUE</code>, the function returns a
unique set of csd alleles in the entire population, colony, or multicolony
</p>


<h3>Value</h3>

<p>matrix with haplotypes when <code>x</code> is <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, list
of matrices with haplotypes when <code>x</code> is <code><a href="#topic+Colony-class">Colony-class</a></code>
(list nodes named by caste) and list of a list of matrices with haplotypes
when <code>x</code> is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>, outer list is named by
colony id when <code>x</code> is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>; <code>NULL</code> when
<code>x</code> is <code>NULL</code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getQueenCsdAlleles()</code>: Access csd alleles of the queen
</p>
</li>
<li> <p><code>getFathersCsdAlleles()</code>: Access csd alleles of the fathers
</p>
</li>
<li> <p><code>getVirginQueensCsdAlleles()</code>: Access csd alleles of the virgin queens
</p>
</li>
<li> <p><code>getWorkersCsdAlleles()</code>: Access csd alleles of the workers
</p>
</li>
<li> <p><code>getDronesCsdAlleles()</code>: Access csd alleles of the drones
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes, nCsdAlleles = 5)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 6, nDrones = 3)

# Use getCsdAlleles on a Population
getCsdAlleles(getQueen(colony))
getCsdAlleles(getWorkers(colony))

# Use getCsdAlleles on a Colony
getCsdAlleles(colony)
getCsdAlleles(colony, caste = "queen")
getQueenCsdAlleles(colony)
getCsdAlleles(colony, caste = "workers")
getWorkersCsdAlleles(colony)
# Same aliases exist for all the castes!

getCsdAlleles(colony, unique = TRUE)
getCsdAlleles(colony, collapse = TRUE)
getCsdAlleles(colony, collapse = TRUE, unique = TRUE)

# Use getCsdAlleles on a MultiColony
getCsdAlleles(apiary)
getCsdAlleles(apiary, unique = TRUE)
getCsdAlleles(apiary, collapse = TRUE, unique = TRUE)
getCsdAlleles(apiary, nInd = 2)
</code></pre>

<hr>
<h2 id='getCsdGeno'>Get genotypes from the csd locus</h2><span id='topic+getCsdGeno'></span><span id='topic+getQueenCsdGeno'></span><span id='topic+getFathersCsdGeno'></span><span id='topic+getVirginQueensCsdGeno'></span><span id='topic+getWorkersCsdGeno'></span><span id='topic+getDronesCsdGeno'></span>

<h3>Description</h3>

<p>Level 0 function that returns genotypes from the csd locus. See
<code><a href="#topic+SimParamBee">SimParamBee</a></code> for more information about the csd locus and how
we have implemented it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCsdGeno(
  x,
  caste = NULL,
  nInd = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)

getQueenCsdGeno(x, collapse = FALSE, simParamBee = NULL)

getFathersCsdGeno(
  x,
  nInd = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)

getVirginQueensCsdGeno(x, nInd = NULL, collapse = FALSE, simParamBee = NULL)

getWorkersCsdGeno(x, nInd = NULL, collapse = FALSE, simParamBee = NULL)

getDronesCsdGeno(
  x,
  nInd = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCsdGeno_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="getCsdGeno_+3A_caste">caste</code></td>
<td>
<p>NULL or character, NULL when <code>x</code> is a <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>,
and character when <code>x</code> is a <code><a href="#topic+Colony-class">Colony-class</a></code> or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with the possible values of &quot;queen&quot;, &quot;fathers&quot;,
&quot;workers&quot;, &quot;drones&quot;, &quot;virginQueens&quot;, or &quot;all&quot;</p>
</td></tr>
<tr><td><code id="getCsdGeno_+3A_nind">nInd</code></td>
<td>
<p>numeric, for how many individuals; if <code>NULL</code> all individuals
are taken; this can be useful as a test of sampling individuals</p>
</td></tr>
<tr><td><code id="getCsdGeno_+3A_droneshaploid">dronesHaploid</code></td>
<td>
<p>logical, return haploid result for drones?</p>
</td></tr>
<tr><td><code id="getCsdGeno_+3A_collapse">collapse</code></td>
<td>
<p>logical, if the return value should be a single matrix
with haplotypes of all the individuals</p>
</td></tr>
<tr><td><code id="getCsdGeno_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned genotypes are spanning multiple bi-allelic SNP of
a non-recombining csd locus / haplotype. In most cases you will want to use
<code><a href="#topic+getCsdAlleles">getCsdAlleles</a></code>.
</p>


<h3>Value</h3>

<p>matrix with genotypes when <code>x</code> is <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, list
of matrices with genotypes when <code>x</code> is <code><a href="#topic+Colony-class">Colony-class</a></code>
(list nodes named by caste) and list of a list of matrices with genotypes
when <code>x</code> is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>, outer list is named by
colony id when <code>x</code> is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>; <code>NULL</code> when
<code>x</code> is <code>NULL</code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getQueenCsdGeno()</code>: Access csd genotypes of the queen
</p>
</li>
<li> <p><code>getFathersCsdGeno()</code>: Access csd genotypes of the fathers
</p>
</li>
<li> <p><code>getVirginQueensCsdGeno()</code>: Access csd genotypes of the virgin queens
</p>
</li>
<li> <p><code>getWorkersCsdGeno()</code>: Access csd genotypes of the virgin queens
</p>
</li>
<li> <p><code>getDronesCsdGeno()</code>: Access csd genotypes of the virgin queens
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)
colony &lt;- addVirginQueens(x = colony, nInd = 4)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 6, nDrones = 3)
apiary &lt;- addVirginQueens(x = apiary, nInd = 5)

# Use getCsdGeno on a Population
getCsdGeno(getQueen(colony))
getCsdGeno(getWorkers(colony))

# Using dronesHaploid = TRUE returns drones as haploids instead of double haploids
getCsdGeno(getDrones(colony), nInd = 3, dronesHaploid = TRUE)
# Using dronesHaploid = FALSE returns drones as double haploids
getCsdGeno(getDrones(colony), nInd = 3, dronesHaploid = FALSE)

# Use getCsdGeno on a Colony
getCsdGeno(colony)
getCsdGeno(colony, caste = "queen")
getQueenCsdGeno(colony)
getCsdGeno(colony, caste = "workers")
getWorkersCsdGeno(colony)
# Same aliases exist for all the castes!

# Use getCsdGeno on a MultiColony - same behaviour as for the Colony!
getCsdGeno(apiary)
getCsdGeno(apiary, nInd = 2)
</code></pre>

<hr>
<h2 id='getDd'>Access dominance values of individuals in a caste</h2><span id='topic+getDd'></span><span id='topic+getQueenDd'></span><span id='topic+getFathersDd'></span><span id='topic+getVirginQueensDd'></span><span id='topic+getWorkersDd'></span><span id='topic+getDronesDd'></span>

<h3>Description</h3>

<p>Level 0 function that returns dominance values of
individuals in a caste.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDd(x, caste = NULL, nInd = NULL, collapse = FALSE, simParamBee = NULL)

getQueenDd(x, collapse = FALSE, simParamBee = NULL)

getFathersDd(x, nInd = NULL, collapse = FALSE, simParamBee = NULL)

getVirginQueensDd(x, nInd = NULL, collapse = FALSE, simParamBee = NULL)

getWorkersDd(x, nInd = NULL, collapse = FALSE, simParamBee = NULL)

getDronesDd(x, nInd = NULL, collapse = FALSE, simParamBee = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDd_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="getDd_+3A_caste">caste</code></td>
<td>
<p>NULL or character, NULL when <code>x</code> is a <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>,
and character when <code>x</code> is a <code><a href="#topic+Colony-class">Colony-class</a></code> or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with the possible values of &quot;queen&quot;, &quot;fathers&quot;,
&quot;workers&quot;, &quot;drones&quot;, &quot;virginQueens&quot;, or &quot;all&quot;</p>
</td></tr>
<tr><td><code id="getDd_+3A_nind">nInd</code></td>
<td>
<p>numeric, number of individuals to access, if <code>NULL</code> all
individuals are accessed, otherwise a random sample</p>
</td></tr>
<tr><td><code id="getDd_+3A_collapse">collapse</code></td>
<td>
<p>logical, if the return value should be a single matrix
with dominance values of all the individuals</p>
</td></tr>
<tr><td><code id="getDd_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of dominance values when <code>x</code> is
<code><a href="#topic+Colony-class">Colony-class</a></code> and list of vectors of dominance values when
<code>x</code> is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>, named by colony id when <code>x</code>
is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>
<p># Not exporting this function, since the theory behind it is not fully developed
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getQueenDd()</code>: Access dominance value of the queen
</p>
</li>
<li> <p><code>getFathersDd()</code>: Access dominance values of fathers
</p>
</li>
<li> <p><code>getVirginQueensDd()</code>: Access dominance values of virgin queens
</p>
</li>
<li> <p><code>getWorkersDd()</code>: Access dominance values of workers
</p>
</li>
<li> <p><code>getDronesDd()</code>: Access dominance values of drones
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="AlphaSimR.html#topic+dd">dd</a></code> and
<code>vignette(topic = "QuantitativeGenetics", package = "SIMplyBee")</code>
</p>

<hr>
<h2 id='getEvents'>Report which colony events have occurred</h2><span id='topic+getEvents'></span>

<h3>Description</h3>

<p>Level 0 function that returns a matrix of logicals reporting the
status of the colony events. The events are: split, swarm, supersedure,
collapse, and production. These events impact colony status, strength, and
could also impact downstream phenotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEvents(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEvents_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of logicals, named by colony id when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)
colony &lt;- addVirginQueens(colony, nInd = 5)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 6, nDrones = 3)
apiary &lt;- addVirginQueens(apiary, nInd = 4)

getEvents(colony)
getEvents(apiary)

tmp &lt;- swarm(colony)
getEvents(tmp$swarm)
getEvents(tmp$remnant)

apiary &lt;- supersede(apiary)
getEvents(apiary)
</code></pre>

<hr>
<h2 id='getGv'>Access genetic values of individuals in a caste</h2><span id='topic+getGv'></span><span id='topic+getQueenGv'></span><span id='topic+getFathersGv'></span><span id='topic+getVirginQueensGv'></span><span id='topic+getWorkersGv'></span><span id='topic+getDronesGv'></span>

<h3>Description</h3>

<p>Level 0 function that returns genetic values of individuals
in a caste.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGv(x, caste = NULL, nInd = NULL, collapse = FALSE)

getQueenGv(x, collapse = FALSE)

getFathersGv(x, nInd = NULL, collapse = FALSE)

getVirginQueensGv(x, nInd = NULL, collapse = FALSE)

getWorkersGv(x, nInd = NULL, collapse = FALSE)

getDronesGv(x, nInd = NULL, collapse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGv_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="getGv_+3A_caste">caste</code></td>
<td>
<p>NULL or character, NULL when <code>x</code> is a <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>,
and character when <code>x</code> is a <code><a href="#topic+Colony-class">Colony-class</a></code> or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with the possible values of &quot;queen&quot;, &quot;fathers&quot;,
&quot;workers&quot;, &quot;drones&quot;, &quot;virginQueens&quot;, or &quot;all&quot;</p>
</td></tr>
<tr><td><code id="getGv_+3A_nind">nInd</code></td>
<td>
<p>numeric, number of individuals to access, if <code>NULL</code> all
individuals are accessed, otherwise a random sample</p>
</td></tr>
<tr><td><code id="getGv_+3A_collapse">collapse</code></td>
<td>
<p>logical, if the return value should be a single matrix
with genetic values of all the individuals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of phenotype values when <code>x</code> is <code><a href="#topic+Colony-class">Colony-class</a></code>
and list of vectors of genetic values when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>, named by colony id when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getQueenGv()</code>: Access genetic value of the queen
</p>
</li>
<li> <p><code>getFathersGv()</code>: Access genetic values of fathers
</p>
</li>
<li> <p><code>getVirginQueensGv()</code>: Access genetic values of virgin queens
</p>
</li>
<li> <p><code>getWorkersGv()</code>: Access genetic values of workers
</p>
</li>
<li> <p><code>getDronesGv()</code>: Access genetic values of drones
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="AlphaSimR.html#topic+gv">gv</a></code> and
<code>vignette(topic = "QuantitativeGenetics", package = "SIMplyBee")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 4, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
SP$addTraitA(nQtlPerChr = 10, var = 1)
SP$addSnpChip(5)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)
colony &lt;- addVirginQueens(x = colony, nInd = 5)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 6, nDrones = 3)
apiary &lt;- addVirginQueens(x = apiary, nInd = 5)

# Input is a population
getGv(x = getQueen(colony))
queens &lt;- getQueen(apiary, collapse = TRUE)
getGv(queens)

# Input is a colony
getGv(colony, caste = "queen")
getQueenGv(colony)

getGv(colony, caste = "workers")
getWorkersGv(colony)
# Same aliases exist for all the castes!

# Get genetic values for all individuals
getGv(colony, caste = "all")
# Get all genetic values in a single matrix
getGv(colony, caste = "all", collapse = TRUE)

# Input is a MultiColony - same behaviour as for the Colony!
getGv(apiary, caste = "queen")
getQueenGv(apiary)

# Get the genetic values of all individuals either by colony or in a single matrix
getGv(apiary, caste = "all")
getGv(apiary, caste = "all", collapse = TRUE)
</code></pre>

<hr>
<h2 id='getIbdHaplo'>Access IBD haplotypes of individuals in a caste</h2><span id='topic+getIbdHaplo'></span><span id='topic+getQueenIbdHaplo'></span><span id='topic+getFathersIbdHaplo'></span><span id='topic+getVirginQueensIbdHaplo'></span><span id='topic+getWorkersIbdHaplo'></span><span id='topic+getDronesIbdHaplo'></span>

<h3>Description</h3>

<p>Level 0 function that returns IBD (identity by descent)
haplotypes of individuals in a caste.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIbdHaplo(
  x,
  caste = NULL,
  nInd = NULL,
  chr = NULL,
  snpChip = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)

getQueenIbdHaplo(
  x,
  chr = NULL,
  snpChip = NULL,
  collapse = FALSE,
  simParamBee = NULL
)

getFathersIbdHaplo(
  x,
  nInd = NULL,
  chr = NULL,
  snpChip = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)

getVirginQueensIbdHaplo(
  x,
  nInd = NULL,
  chr = NULL,
  snpChip = NULL,
  collapse = FALSE,
  simParamBee = NULL
)

getWorkersIbdHaplo(
  x,
  nInd = NULL,
  chr = NULL,
  snpChip = NULL,
  collapse = FALSE,
  simParamBee = NULL
)

getDronesIbdHaplo(
  x,
  nInd = NULL,
  chr = NULL,
  snpChip = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIbdHaplo_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="getIbdHaplo_+3A_caste">caste</code></td>
<td>
<p>NULL or character, NULL when <code>x</code> is a <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>,
and character when <code>x</code> is a <code><a href="#topic+Colony-class">Colony-class</a></code> or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with the possible values of &quot;queen&quot;, &quot;fathers&quot;,
&quot;workers&quot;, &quot;drones&quot;, &quot;virginQueens&quot;, or &quot;all&quot;</p>
</td></tr>
<tr><td><code id="getIbdHaplo_+3A_nind">nInd</code></td>
<td>
<p>numeric, number of individuals to access, if <code>NULL</code> all
individuals are accessed, otherwise a random sample</p>
</td></tr>
<tr><td><code id="getIbdHaplo_+3A_chr">chr</code></td>
<td>
<p>numeric, chromosomes to retrieve, if <code>NULL</code>, all chromosome
are retrieved</p>
</td></tr>
<tr><td><code id="getIbdHaplo_+3A_snpchip">snpChip</code></td>
<td>
<p>integer, indicating which SNP array loci are to be retrieved,
if <code>NULL</code>, all sites are retrieved</p>
</td></tr>
<tr><td><code id="getIbdHaplo_+3A_droneshaploid">dronesHaploid</code></td>
<td>
<p>logical, return haploid result for drones?</p>
</td></tr>
<tr><td><code id="getIbdHaplo_+3A_collapse">collapse</code></td>
<td>
<p>logical, if the return value should be a single matrix
with haplotypes of all the individuals</p>
</td></tr>
<tr><td><code id="getIbdHaplo_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with haplotypes when <code>x</code> is <code><a href="#topic+Colony-class">Colony-class</a></code>
and list of matrices with haplotypes when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>, named by colony id when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getQueenIbdHaplo()</code>: Access IBD haplotype data of the queen
</p>
</li>
<li> <p><code>getFathersIbdHaplo()</code>: Access IBD haplotype data of fathers
</p>
</li>
<li> <p><code>getVirginQueensIbdHaplo()</code>: Access IBD haplotype data of virgin queens
</p>
</li>
<li> <p><code>getWorkersIbdHaplo()</code>: Access IBD haplotype data of workers
</p>
</li>
<li> <p><code>getDronesIbdHaplo()</code>: Access IBD haplotype data of drones
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+getIbdHaplo">getIbdHaplo</a></code> and <code><a href="AlphaSimR.html#topic+pullIbdHaplo">pullIbdHaplo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 4, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
SP$setTrackRec(TRUE)
SP$setTrackPed(isTrackPed = TRUE)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 200)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)
colony &lt;- addVirginQueens(x = colony, nInd = 5)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 6, nDrones = 3)
apiary &lt;- addVirginQueens(x = apiary, nInd = 5)

# Input is a population
getIbdHaplo(x = getQueen(colony))
queens &lt;- getQueen(apiary, collapse = TRUE)
getIbdHaplo(queens)

# Input is a colony
getIbdHaplo(x = colony, caste = "queen")
getQueenIbdHaplo(colony)

getIbdHaplo(colony, caste = "workers", nInd = 3)
getWorkersIbdHaplo(colony)
# Same aliases exist for all castes!

# Get haplotypes for all individuals
getIbdHaplo(colony, caste = "all")
# Get all haplotypes in a single matrix
getIbdHaplo(colony, caste = "all", collapse = TRUE)

# Input is a MultiColony
getIbdHaplo(x = apiary, caste = "queen")
getQueenIbdHaplo(apiary)
# Or collapse all the haplotypes into a single matrix
getQueenIbdHaplo(apiary, collapse = TRUE)

# Get the haplotypes of all individuals either by colony or in a single matrix
getIbdHaplo(apiary, caste = "all")
getIbdHaplo(apiary, caste = "all", collapse = TRUE)
</code></pre>

<hr>
<h2 id='getId'>Get the colony ID</h2><span id='topic+getId'></span>

<h3>Description</h3>

<p>Level 0 function that returns the colony ID. This is by
definition the ID of the queen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getId(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getId_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character, <code>NA</code> when queen not present
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])

getId(getQueen(colony)) # Pop class
getId(colony) # Colony Class
getId(apiary) # MultiColony Class

colony2 &lt;- removeQueen(colony)
getId(colony2)
</code></pre>

<hr>
<h2 id='getLocation'>Get the colony location</h2><span id='topic+getLocation'></span>

<h3>Description</h3>

<p>Level 0 function that returns the colony location as (x, y)
coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLocation(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLocation_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric with two values when <code>x</code> is <code><a href="#topic+Colony-class">Colony-class</a></code>
and a list of numeric with two values when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code> (list named after colonies); <code>c(NA, NA)</code>
when location not set
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])

getLocation(colony)
getLocation(apiary[[1]])
getLocation(apiary)

loc &lt;- c(123, 456)
colony &lt;- setLocation(colony, location = loc)
getLocation(colony)

loc1 &lt;- c(512, 722)
colony1 &lt;- setLocation(apiary[[1]], location = loc1)
getLocation(colony1)

loc2 &lt;- c(189, 357)
colony2 &lt;- setLocation(apiary[[2]], location = loc2)
getLocation(colony2)

getLocation(c(colony1, colony2))

# Assuming one location (as in bringing colonies to an apiary at a location!)
apiary &lt;- setLocation(apiary, location = loc1)
getLocation(apiary)

# Assuming different locations (so tmp is not an apiary in one location!)
tmp &lt;- setLocation(c(colony1, colony2), location = list(loc1, loc2))
getLocation(tmp)
</code></pre>

<hr>
<h2 id='getPheno'>Access phenotype values of individuals in a caste</h2><span id='topic+getPheno'></span><span id='topic+getQueenPheno'></span><span id='topic+getFathersPheno'></span><span id='topic+getVirginQueensPheno'></span><span id='topic+getWorkersPheno'></span><span id='topic+getDronesPheno'></span>

<h3>Description</h3>

<p>Level 0 function that returns phenotype values of individuals in a
caste.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPheno(x, caste = NULL, nInd = NULL, collapse = FALSE)

getQueenPheno(x, collapse = FALSE)

getFathersPheno(x, nInd = NULL, collapse = FALSE)

getVirginQueensPheno(x, nInd = NULL, collapse = FALSE)

getWorkersPheno(x, nInd = NULL, collapse = FALSE)

getDronesPheno(x, nInd = NULL, collapse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPheno_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="getPheno_+3A_caste">caste</code></td>
<td>
<p>NULL or character, NULL when <code>x</code> is a <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>,
and character when <code>x</code> is a <code><a href="#topic+Colony-class">Colony-class</a></code> or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with the possible values of &quot;queen&quot;, &quot;fathers&quot;,
&quot;workers&quot;, &quot;drones&quot;, &quot;virginQueens&quot;, or &quot;all&quot;</p>
</td></tr>
<tr><td><code id="getPheno_+3A_nind">nInd</code></td>
<td>
<p>numeric, number of individuals to access, if <code>NULL</code> all
individuals are accessed, otherwise a random sample</p>
</td></tr>
<tr><td><code id="getPheno_+3A_collapse">collapse</code></td>
<td>
<p>logical, if the return value should be a single matrix
with phenotypes of all the individuals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of genetic values when <code>x</code> is <code><a href="#topic+Colony-class">Colony-class</a></code>
and list of vectors of genetic values when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>, named by colony id when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getQueenPheno()</code>: Access phenotype value of the queen
</p>
</li>
<li> <p><code>getFathersPheno()</code>: Access phenotype values of fathers
</p>
</li>
<li> <p><code>getVirginQueensPheno()</code>: Access phenotype values of virgin queens
</p>
</li>
<li> <p><code>getWorkersPheno()</code>: Access phenotype values of workers
</p>
</li>
<li> <p><code>getDronesPheno()</code>: Access phenotype values of drones
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="AlphaSimR.html#topic+pheno">pheno</a></code> and
<code>vignette(topic = "QuantitativeGenetics", package = "SIMplyBee")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
SP$addTraitA(nQtlPerChr = 10, var = 1)
SP$setVarE(varE = 1)

basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)
colony &lt;- addVirginQueens(x = colony, nInd = 5)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 6, nDrones = 3)
apiary &lt;- addVirginQueens(x = apiary, nInd = 5)

# Input is a population
getPheno(x = getQueen(colony))
queens &lt;- getQueen(apiary, collapse = TRUE)
getPheno(queens)

# Input is a colony
getPheno(colony, caste = "queen")
getQueenPheno(colony)

getPheno(colony, caste = "fathers")
getPheno(colony, caste = "fathers", nInd = 2)
getPheno(colony, caste = "fathers", nInd = 2) # random sample!
getFathersPheno(colony)
getFathersPheno(colony, nInd = 2)

getPheno(colony, caste = "workers")
getWorkersPheno(colony)
# Same aliases exist for all the castes!!!

# Get phenotypes for all individuals
getPheno(colony, caste = "all")
# Get all phenotypes in a single matrix
getPheno(colony, caste = "all", collapse = TRUE)

# Input is a MultiColony - same behaviour as for the Colony!
getPheno(apiary, caste = "queen")
getQueenPheno(apiary)

# Get the phenotypes of all individuals either by colony or in a single matrix
getPheno(apiary, caste = "all")
getPheno(apiary, caste = "all", collapse = TRUE)
</code></pre>

<hr>
<h2 id='getPooledGeno'>Get a pooled genotype from true genotypes</h2><span id='topic+getPooledGeno'></span>

<h3>Description</h3>

<p>Level 0 function that returns a pooled genotype from true
genotypes to mimic genotyping of a pool of colony members.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPooledGeno(x, type = NULL, sex = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPooledGeno_+3A_x">x</code></td>
<td>
<p>matrix, true genotypes with individuals in rows and sites in columns</p>
</td></tr>
<tr><td><code id="getPooledGeno_+3A_type">type</code></td>
<td>
<p>character, &quot;mean&quot; for average genotype or &quot;count&quot; for the counts
of reference and alternative alleles</p>
</td></tr>
<tr><td><code id="getPooledGeno_+3A_sex">sex</code></td>
<td>
<p>character, vector of &quot;F&quot; and &quot;M&quot; to denote the sex of individuals
in <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector with average allele dosage when <code>type = "mean"</code>
and a two-row matrix with the counts of reference (1st row) and
alternative (2nd row) alleles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 3, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)

basePop &lt;- createVirginQueens(founderGenomes)
drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)
apiary &lt;- createMultiColony(basePop[2:3], n = 2)
apiary &lt;- cross(x = apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 6, nDrones = 3)
apiary &lt;- addVirginQueens(x = apiary, nInd = 5)

genoQ &lt;- getQueenSegSiteGeno(apiary[[1]])
genoF &lt;- getFathersSegSiteGeno(apiary[[1]])
genoW &lt;- getWorkersSegSiteGeno(apiary[[1]])
genoD &lt;- getDronesSegSiteGeno(apiary[[1]])
genoV &lt;- getVirginQueensSegSiteGeno(apiary[[1]])

# Pool of drones
sexD &lt;- getCasteSex(apiary[[1]], caste = "drones")
getPooledGeno(x = genoD, type = "count", sex = sexD)[, 1:10]
(poolD &lt;- getPooledGeno(x = genoD, type = "mean", sex = sexD))[, 1:10]
# ... compare to queen's genotype
genoQ[, 1:10]
plot(
  y = poolD, x = genoQ, ylim = c(0, 2), xlim = c(0, 2),
  ylab = "Average allele dosage in drones",
  xlab = "Allele dosage in the queen"
)

# As an exercise you could repeat the above with different numbers of drones!

# Pool of workers
getPooledGeno(x = genoW, type = "count")[, 1:10]
(poolW &lt;- getPooledGeno(x = genoW, type = "mean"))[, 1:10]
# ... compare to fathers' and queen's avearage genotype
sexF &lt;- getCasteSex(apiary[[1]], caste = "fathers")
sexQ &lt;- rep(x = "F", times = nrow(genoF))
sexFQ &lt;- c(sexF, sexQ)
genoFQ &lt;- rbind(genoF, genoQ[rep(x = 1, times = nrow(genoF)), ])
(poolFQ &lt;- getPooledGeno(x = genoFQ, type = "mean", sex = sexFQ))[, 1:10]
plot(
  y = poolW, x = poolFQ, ylim = c(0, 2), xlim = c(0, 2),
  ylab = "Average allele dosage in workers",
  xlab = "Average allele dosage in the queen and fathers"
)

# As an exercise you could repeat the above with different numbers of workers!

</code></pre>

<hr>
<h2 id='getQtlGeno'>Access QTL genotypes of individuals in a caste</h2><span id='topic+getQtlGeno'></span><span id='topic+getQueenQtlGeno'></span><span id='topic+getFathersQtlGeno'></span><span id='topic+getVirginQueensQtlGeno'></span><span id='topic+getWorkersQtlGeno'></span><span id='topic+getDronesQtlGeno'></span>

<h3>Description</h3>

<p>Level 0 function that returns QTL genotypes of individuals in a
caste.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getQtlGeno(
  x,
  caste = NULL,
  nInd = NULL,
  trait = 1,
  chr = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)

getQueenQtlGeno(x, trait = 1, chr = NULL, collapse = FALSE, simParamBee = NULL)

getFathersQtlGeno(
  x,
  nInd = NULL,
  trait = 1,
  chr = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)

getVirginQueensQtlGeno(
  x,
  nInd = NULL,
  trait = 1,
  chr = NULL,
  collapse = FALSE,
  simParamBee = NULL
)

getWorkersQtlGeno(
  x,
  nInd = NULL,
  trait = 1,
  chr = NULL,
  collapse = FALSE,
  simParamBee = NULL
)

getDronesQtlGeno(
  x,
  nInd = NULL,
  trait = 1,
  chr = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getQtlGeno_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="getQtlGeno_+3A_caste">caste</code></td>
<td>
<p>NULL or character, NULL when <code>x</code> is a <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>,
and character when <code>x</code> is a <code><a href="#topic+Colony-class">Colony-class</a></code> or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with the possible values of &quot;queen&quot;, &quot;fathers&quot;,
&quot;workers&quot;, &quot;drones&quot;, &quot;virginQueens&quot;, or &quot;all&quot;</p>
</td></tr>
<tr><td><code id="getQtlGeno_+3A_nind">nInd</code></td>
<td>
<p>numeric, number of individuals to access, if <code>NULL</code> all
individuals are accessed, otherwise a random sample</p>
</td></tr>
<tr><td><code id="getQtlGeno_+3A_trait">trait</code></td>
<td>
<p>numeric (trait position) or character (trait name), indicates
which trait's QTL genotypes to retrieve</p>
</td></tr>
<tr><td><code id="getQtlGeno_+3A_chr">chr</code></td>
<td>
<p>numeric, chromosomes to retrieve, if <code>NULL</code>, all chromosome
are retrieved</p>
</td></tr>
<tr><td><code id="getQtlGeno_+3A_droneshaploid">dronesHaploid</code></td>
<td>
<p>logical, return haploid result for drones?</p>
</td></tr>
<tr><td><code id="getQtlGeno_+3A_collapse">collapse</code></td>
<td>
<p>logical, if the return value should be a single matrix
with genotypes of all the individuals</p>
</td></tr>
<tr><td><code id="getQtlGeno_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with genotypes when <code>x</code> is <code><a href="#topic+Colony-class">Colony-class</a></code> and
list of matrices with genotypes when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>, named by colony id when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getQueenQtlGeno()</code>: Access QTL genotype data of the queen
</p>
</li>
<li> <p><code>getFathersQtlGeno()</code>: Access QTL genotype data of fathers
</p>
</li>
<li> <p><code>getVirginQueensQtlGeno()</code>: Access QTL genotype data of virgin queens
</p>
</li>
<li> <p><code>getWorkersQtlGeno()</code>: Access QTL genotype data of workers
</p>
</li>
<li> <p><code>getDronesQtlGeno()</code>: Access QTL genotype data of drones
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+getQtlGeno">getQtlGeno</a></code> and <code><a href="AlphaSimR.html#topic+pullQtlGeno">pullQtlGeno</a></code> as well as
<code>vignette(topic = "QuantitativeGenetics", package = "SIMplyBee")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 4, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
SP$addTraitA(nQtlPerChr = 10)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 200)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)
colony &lt;- addVirginQueens(x = colony, nInd = 5)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 6, nDrones = 3)
apiary &lt;- addVirginQueens(x = apiary, nInd = 5)

# Input is a population
getQtlGeno(x = getQueen(colony))
queens &lt;- getQueen(apiary, collapse = TRUE)
getQtlGeno(queens)

# Input is a colony
getQtlGeno(colony, caste = "queen")
getQueenQtlGeno(colony)

getQtlGeno(colony, caste = "workers", nInd = 3)
getWorkersQtlGeno(colony)
# Same aliases exist for all the castes!

# Get genotypes for all individuals
getQtlGeno(colony, caste = "all")
# Get all haplotypes in a single matrix
getQtlGeno(colony, caste = "all", collapse = TRUE)

# Input is a MultiColony - same behaviour as for the Colony!
getQtlGeno(apiary, caste = "queen")
getQueenQtlGeno(apiary)

# Get the genotypes of all individuals either by colony or in a single matrix
getQtlGeno(apiary, caste = "all")
getQtlGeno(apiary, caste = "all", collapse = TRUE)
</code></pre>

<hr>
<h2 id='getQtlHaplo'>Access QTL haplotypes of individuals in a caste</h2><span id='topic+getQtlHaplo'></span><span id='topic+getQueenQtlHaplo'></span><span id='topic+getFathersQtlHaplo'></span><span id='topic+getVirginQueensQtlHaplo'></span><span id='topic+getWorkersQtlHaplo'></span><span id='topic+getDronesQtlHaplo'></span>

<h3>Description</h3>

<p>Level 0 function that returns QTL haplotypes of individuals in a
caste.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getQtlHaplo(
  x,
  caste = NULL,
  nInd = NULL,
  trait = 1,
  haplo = "all",
  chr = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)

getQueenQtlHaplo(
  x,
  trait = 1,
  haplo = "all",
  chr = NULL,
  collapse = FALSE,
  simParamBee = NULL
)

getFathersQtlHaplo(
  x,
  nInd = NULL,
  trait = 1,
  haplo = "all",
  chr = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)

getVirginQueensQtlHaplo(
  x,
  nInd = NULL,
  trait = 1,
  haplo = "all",
  chr = NULL,
  collapse = FALSE,
  simParamBee = NULL
)

getWorkersQtlHaplo(
  x,
  nInd = NULL,
  trait = 1,
  haplo = "all",
  chr = NULL,
  collapse = FALSE,
  simParamBee = NULL
)

getDronesQtlHaplo(
  x,
  nInd = NULL,
  trait = 1,
  haplo = "all",
  chr = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getQtlHaplo_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="getQtlHaplo_+3A_caste">caste</code></td>
<td>
<p>NULL or character, NULL when <code>x</code> is a <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>,
and character when <code>x</code> is a <code><a href="#topic+Colony-class">Colony-class</a></code> or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with the possible values of &quot;queen&quot;, &quot;fathers&quot;,
&quot;workers&quot;, &quot;drones&quot;, &quot;virginQueens&quot;, or &quot;all&quot;</p>
</td></tr>
<tr><td><code id="getQtlHaplo_+3A_nind">nInd</code></td>
<td>
<p>numeric, number of individuals to access, if <code>NULL</code> all
individuals are accessed, otherwise a random sample</p>
</td></tr>
<tr><td><code id="getQtlHaplo_+3A_trait">trait</code></td>
<td>
<p>numeric (trait position) or character (trait name), indicates
which trait's QTL haplotypes to retrieve</p>
</td></tr>
<tr><td><code id="getQtlHaplo_+3A_haplo">haplo</code></td>
<td>
<p>character, either &quot;all&quot; for all haplotypes or an integer for a
single set of haplotypes, use a value of 1 for female haplotypes and a
value of 2 for male haplotypes</p>
</td></tr>
<tr><td><code id="getQtlHaplo_+3A_chr">chr</code></td>
<td>
<p>numeric, chromosomes to retrieve, if <code>NULL</code>, all chromosome
are retrieved</p>
</td></tr>
<tr><td><code id="getQtlHaplo_+3A_droneshaploid">dronesHaploid</code></td>
<td>
<p>logical, return haploid result for drones?</p>
</td></tr>
<tr><td><code id="getQtlHaplo_+3A_collapse">collapse</code></td>
<td>
<p>logical, if the return value should be a single matrix
with haplotypes of all the individuals</p>
</td></tr>
<tr><td><code id="getQtlHaplo_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with haplotypes when <code>x</code> is <code><a href="#topic+Colony-class">Colony-class</a></code>
and list of matrices with haplotypes when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>, named by colony id when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getQueenQtlHaplo()</code>: Access QTL haplotype data of the queen
</p>
</li>
<li> <p><code>getFathersQtlHaplo()</code>: Access QTL haplotype data of fathers
</p>
</li>
<li> <p><code>getVirginQueensQtlHaplo()</code>: Access QTL haplotype data of virgin queens
</p>
</li>
<li> <p><code>getWorkersQtlHaplo()</code>: Access QTL haplotype of workers
</p>
</li>
<li> <p><code>getDronesQtlHaplo()</code>: Access QTL haplotype data of drones
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+getQtlHaplo">getQtlHaplo</a></code> and <code><a href="AlphaSimR.html#topic+pullQtlHaplo">pullQtlHaplo</a></code> as well as
<code>vignette(topic = "QuantitativeGenetics", package = "SIMplyBee")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 4, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
SP$addTraitA(nQtlPerChr = 10)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 200)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)
colony &lt;- addVirginQueens(x = colony, nInd = 5)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 6, nDrones = 3)
apiary &lt;- addVirginQueens(x = apiary, nInd = 5)

# Input is a population
getQtlHaplo(x = getQueen(colony))
queens &lt;- getQueen(apiary, collapse = TRUE)
getQtlHaplo(queens)

# Input is a Colony
getQtlHaplo(colony, caste = "queen")
getQueenQtlHaplo(colony)

getQtlHaplo(colony, caste = "workers", nInd = 3)
getWorkersQtlHaplo(colony)
# Same aliases exist for all the castes!

# Get haplotypes for all individuals
getQtlHaplo(colony, caste = "all")
# Get all haplotypes in a single matrix
getQtlHaplo(colony, caste = "all", collapse = TRUE)

# Input is a MultiColony - same behaviour as for the Colony
getQtlHaplo(apiary, caste = "queen")
getQueenQtlHaplo(apiary)

# Get the haplotypes of all individuals either by colony or in a single matrix
getQtlHaplo(apiary, caste = "all")
getQtlHaplo(apiary, caste = "all", collapse = TRUE)

</code></pre>

<hr>
<h2 id='getQueenAge'>Get (calculate) the queen's age</h2><span id='topic+getQueenAge'></span>

<h3>Description</h3>

<p>Level 0 function that returns the queen's age.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getQueenAge(x, currentYear)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getQueenAge_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="getQueenAge_+3A_currentyear">currentYear</code></td>
<td>
<p>integer, current year</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, the age of the queen(s); named when theres is more
than one queen; <code>NA</code> if queen not present
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])

queen &lt;- getQueen(colony)
queen &lt;- setQueensYearOfBirth(queen, year = 2020)
getQueenAge(queen, currentYear = 2022)

colony &lt;- setQueensYearOfBirth(colony, year = 2021)
getQueenAge(colony, currentYear = 2022)

apiary &lt;- setQueensYearOfBirth(apiary, year = 2018)
getQueenAge(apiary, currentYear = 2022)
</code></pre>

<hr>
<h2 id='getQueenYearOfBirth'>Access the queen's year of birth</h2><span id='topic+getQueenYearOfBirth'></span>

<h3>Description</h3>

<p>Level 0 function that returns the queen's year of birth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getQueenYearOfBirth(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getQueenYearOfBirth_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> (one or more than one queen),
<code><a href="#topic+Colony-class">Colony-class</a></code> (one colony), or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code> (more colonies)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, the year of birth of the queen(s); named when theres is more
than one queen; <code>NA</code> if queen not present
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])

queen &lt;- getQueen(colony)
queen &lt;- setQueensYearOfBirth(queen, year = 2022)
getQueenYearOfBirth(queen)

getQueenYearOfBirth(getQueen(colony))
colony &lt;- setQueensYearOfBirth(colony, year = 2030)
getQueenYearOfBirth(colony)

apiary &lt;- setQueensYearOfBirth(apiary, year = 2022)
getQueenYearOfBirth(apiary)
</code></pre>

<hr>
<h2 id='getSegSiteGeno'>Access genotypes for all segregating sites of individuals in a
caste</h2><span id='topic+getSegSiteGeno'></span><span id='topic+getQueenSegSiteGeno'></span><span id='topic+getFathersSegSiteGeno'></span><span id='topic+getVirginQueensSegSiteGeno'></span><span id='topic+getWorkersSegSiteGeno'></span><span id='topic+getDronesSegSiteGeno'></span>

<h3>Description</h3>

<p>Level 0 function that returns genotypes for all segregating
sites of individuals in a caste.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSegSiteGeno(
  x,
  caste = NULL,
  nInd = NULL,
  chr = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)

getQueenSegSiteGeno(x, chr = NULL, collapse = FALSE, simParamBee = NULL)

getFathersSegSiteGeno(
  x,
  nInd = NULL,
  chr = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)

getVirginQueensSegSiteGeno(
  x,
  nInd = NULL,
  chr = NULL,
  collapse = FALSE,
  simParamBee = NULL
)

getWorkersSegSiteGeno(
  x,
  nInd = NULL,
  chr = NULL,
  collapse = FALSE,
  simParamBee = NULL
)

getDronesSegSiteGeno(
  x,
  nInd = NULL,
  chr = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSegSiteGeno_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="getSegSiteGeno_+3A_caste">caste</code></td>
<td>
<p>NULL or character, NULL when <code>x</code> is a <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>,
and character when <code>x</code> is a <code><a href="#topic+Colony-class">Colony-class</a></code> or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with the possible values of &quot;queen&quot;, &quot;fathers&quot;,
&quot;workers&quot;, &quot;drones&quot;, &quot;virginQueens&quot;, or &quot;all&quot;</p>
</td></tr>
<tr><td><code id="getSegSiteGeno_+3A_nind">nInd</code></td>
<td>
<p>numeric, number of individuals to access, if <code>NULL</code> all
individuals are accessed, otherwise a random sample</p>
</td></tr>
<tr><td><code id="getSegSiteGeno_+3A_chr">chr</code></td>
<td>
<p>numeric, chromosomes to retrieve, if <code>NULL</code>, all chromosome
are retrieved</p>
</td></tr>
<tr><td><code id="getSegSiteGeno_+3A_droneshaploid">dronesHaploid</code></td>
<td>
<p>logical, return haploid result for drones?</p>
</td></tr>
<tr><td><code id="getSegSiteGeno_+3A_collapse">collapse</code></td>
<td>
<p>logical, if the return value should be a single matrix
with genotypes of all the individuals</p>
</td></tr>
<tr><td><code id="getSegSiteGeno_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with genotypes when <code>x</code> is <code><a href="#topic+Colony-class">Colony-class</a></code> and
list of matrices with genotypes when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>, named by colony id when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getQueenSegSiteGeno()</code>: Access genotype data for all segregating sites of the queen
</p>
</li>
<li> <p><code>getFathersSegSiteGeno()</code>: Access genotype data for all segregating sites of fathers
</p>
</li>
<li> <p><code>getVirginQueensSegSiteGeno()</code>: Access genotype data for all segregating sites of virgin queens
</p>
</li>
<li> <p><code>getWorkersSegSiteGeno()</code>: Access genotype data for all segregating sites of workers
</p>
</li>
<li> <p><code>getDronesSegSiteGeno()</code>: Access genotype data for all segregating sites of drones
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+getSegSiteGeno">getSegSiteGeno</a></code> and <code><a href="AlphaSimR.html#topic+pullSegSiteGeno">pullSegSiteGeno</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 4, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)
colony &lt;- addVirginQueens(x = colony, nInd = 5)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 6, nDrones = 3)
apiary &lt;- addVirginQueens(x = apiary, nInd = 5)

# Input is a population
getSegSiteGeno(x = getQueen(colony))
queens &lt;- getQueen(apiary, collapse = TRUE)
getSegSiteGeno(queens)

# Input is a colony
getSegSiteGeno(colony, caste = "queen")
getQueenSegSiteGeno(colony)

getSegSiteGeno(colony, caste = "workers", nInd = 3)
getWorkersSegSiteGeno(colony)
# same aliases exist for all the castes!

# Get genotypes for all individuals
getSegSiteGeno(colony, caste = "all")
# Get all genotypes in a single matrix
getSegSiteGeno(colony, caste = "all", collapse = TRUE)

# Input is a MultiColony - same behaviour as for the Colony
getSegSiteGeno(apiary, caste = "queen")
getQueenSegSiteGeno(apiary)

# Get the genotypes of all individuals either by colony or in a single matrix
getSegSiteGeno(apiary, caste = "all")
getSegSiteGeno(apiary, caste = "all", collapse = TRUE)
</code></pre>

<hr>
<h2 id='getSegSiteHaplo'>Access haplotypes for all segregating sites of individuals in a
caste</h2><span id='topic+getSegSiteHaplo'></span><span id='topic+getQueenSegSiteHaplo'></span><span id='topic+getFathersSegSiteHaplo'></span><span id='topic+getVirginQueensSegSiteHaplo'></span><span id='topic+getWorkersSegSiteHaplo'></span><span id='topic+getDronesSegSiteHaplo'></span>

<h3>Description</h3>

<p>Level 0 function that returns haplotypes for all segregating
sites of individuals in a caste.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSegSiteHaplo(
  x,
  caste = NULL,
  nInd = NULL,
  haplo = "all",
  chr = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)

getQueenSegSiteHaplo(
  x,
  haplo = "all",
  chr = NULL,
  collapse = FALSE,
  simParamBee = NULL
)

getFathersSegSiteHaplo(
  x,
  nInd = NULL,
  haplo = "all",
  chr = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)

getVirginQueensSegSiteHaplo(
  x,
  nInd = NULL,
  haplo = "all",
  chr = NULL,
  collapse = FALSE,
  simParamBee = NULL
)

getWorkersSegSiteHaplo(
  x,
  nInd = NULL,
  haplo = "all",
  chr = NULL,
  collapse = FALSE,
  simParamBee = NULL
)

getDronesSegSiteHaplo(
  x,
  nInd = NULL,
  haplo = "all",
  chr = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSegSiteHaplo_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="getSegSiteHaplo_+3A_caste">caste</code></td>
<td>
<p>NULL or character, NULL when <code>x</code> is a <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>,
and character when <code>x</code> is a <code><a href="#topic+Colony-class">Colony-class</a></code> or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with the possible values of &quot;queen&quot;, &quot;fathers&quot;,
&quot;workers&quot;, &quot;drones&quot;, &quot;virginQueens&quot;, or &quot;all&quot;</p>
</td></tr>
<tr><td><code id="getSegSiteHaplo_+3A_nind">nInd</code></td>
<td>
<p>numeric, number of individuals to access, if <code>NULL</code> all
individuals are accessed, otherwise a random sample</p>
</td></tr>
<tr><td><code id="getSegSiteHaplo_+3A_haplo">haplo</code></td>
<td>
<p>character, either &quot;all&quot; for all haplotypes or an integer for a
single set of haplotypes, use a value of 1 for female haplotypes and a
value of 2 for male haplotypes</p>
</td></tr>
<tr><td><code id="getSegSiteHaplo_+3A_chr">chr</code></td>
<td>
<p>numeric, chromosomes to retrieve, if <code>NULL</code>, all chromosome
are retrieved</p>
</td></tr>
<tr><td><code id="getSegSiteHaplo_+3A_droneshaploid">dronesHaploid</code></td>
<td>
<p>logical, return haploid result for drones?</p>
</td></tr>
<tr><td><code id="getSegSiteHaplo_+3A_collapse">collapse</code></td>
<td>
<p>logical, if the return value should be a single matrix
with haplotypes of all the individuals</p>
</td></tr>
<tr><td><code id="getSegSiteHaplo_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with haplotypes when <code>x</code> is <code><a href="#topic+Colony-class">Colony-class</a></code>
and list of matrices with haplotypes when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>, named by colony id when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getQueenSegSiteHaplo()</code>: Access haplotype data for all segregating sites of the queen
</p>
</li>
<li> <p><code>getFathersSegSiteHaplo()</code>: Access haplotype data for all segregating sites of fathers
</p>
</li>
<li> <p><code>getVirginQueensSegSiteHaplo()</code>: Access haplotype data for all segregating sites of virgin queens
</p>
</li>
<li> <p><code>getWorkersSegSiteHaplo()</code>: Access haplotype data for all segregating sites of workers
</p>
</li>
<li> <p><code>getDronesSegSiteHaplo()</code>: Access haplotype data for all segregating sites of drones
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+getSegSiteHaplo">getSegSiteHaplo</a></code> and <code><a href="AlphaSimR.html#topic+pullSegSiteHaplo">pullSegSiteHaplo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 4, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)
colony &lt;- addVirginQueens(x = colony, nInd = 5)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 6, nDrones = 3)
apiary &lt;- addVirginQueens(x = apiary, nInd = 5)

# Input is a population
getSegSiteHaplo(x = getQueen(colony))
queens &lt;- getQueen(apiary, collapse = TRUE)
getSegSiteHaplo(queens)

# Input is a colony
getSegSiteHaplo(colony, caste = "queen")
getQueenSegSiteHaplo(colony)

getSegSiteHaplo(colony, caste = "workers", nInd = 3)
getWorkersSegSiteHaplo(colony)
#Same aliases exist for all the castes!

# Get haplotypes for all individuals
getSegSiteHaplo(colony, caste = "all")
# Get all haplotypes in a single matrix
getSegSiteHaplo(colony, caste = "all", collapse = TRUE)

#Input is a MultiColony - same behaviour as for the Colony!
getSegSiteHaplo(apiary, caste = "queen")
getQueenSegSiteHaplo(apiary)

# Get the haplotypes of all individuals either by colony or in a single matrix
getSegSiteHaplo(apiary, caste = "all")
getSegSiteHaplo(apiary, caste = "all", collapse = TRUE)
</code></pre>

<hr>
<h2 id='getSnpGeno'>Access SNP array genotypes of individuals in a caste</h2><span id='topic+getSnpGeno'></span><span id='topic+getQueenSnpGeno'></span><span id='topic+getFathersSnpGeno'></span><span id='topic+getVirginQueensSnpGeno'></span><span id='topic+getWorkersSnpGeno'></span><span id='topic+getDronesSnpGeno'></span>

<h3>Description</h3>

<p>Level 0 function that returns SNP array genotypes of individuals
in a caste.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSnpGeno(
  x,
  caste = NULL,
  nInd = NULL,
  snpChip = 1,
  chr = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)

getQueenSnpGeno(
  x,
  snpChip = 1,
  chr = NULL,
  collapse = FALSE,
  simParamBee = NULL
)

getFathersSnpGeno(
  x,
  nInd = NULL,
  snpChip = 1,
  chr = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)

getVirginQueensSnpGeno(
  x,
  nInd = NULL,
  snpChip = 1,
  chr = NULL,
  collapse = FALSE,
  simParamBee = NULL
)

getWorkersSnpGeno(
  x,
  nInd = NULL,
  snpChip = 1,
  chr = NULL,
  collapse = FALSE,
  simParamBee = NULL
)

getDronesSnpGeno(
  x,
  nInd = NULL,
  snpChip = 1,
  chr = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSnpGeno_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="getSnpGeno_+3A_caste">caste</code></td>
<td>
<p>NULL or character, NULL when <code>x</code> is a <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>,
and character when <code>x</code> is a <code><a href="#topic+Colony-class">Colony-class</a></code> or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with the possible values of &quot;queen&quot;, &quot;fathers&quot;,
&quot;workers&quot;, &quot;drones&quot;, &quot;virginQueens&quot;, or &quot;all&quot;</p>
</td></tr>
<tr><td><code id="getSnpGeno_+3A_nind">nInd</code></td>
<td>
<p>numeric, number of individuals to access, if <code>NULL</code> all
individuals are accessed, otherwise a random sample</p>
</td></tr>
<tr><td><code id="getSnpGeno_+3A_snpchip">snpChip</code></td>
<td>
<p>numeric, indicates which SNP array genotypes to retrieve</p>
</td></tr>
<tr><td><code id="getSnpGeno_+3A_chr">chr</code></td>
<td>
<p>numeric, chromosomes to retrieve, if <code>NULL</code>, all chromosome
are retrieved</p>
</td></tr>
<tr><td><code id="getSnpGeno_+3A_droneshaploid">dronesHaploid</code></td>
<td>
<p>logical, return haploid result for drones?</p>
</td></tr>
<tr><td><code id="getSnpGeno_+3A_collapse">collapse</code></td>
<td>
<p>logical, if the return value should be a single matrix
with genotypes of all the individuals</p>
</td></tr>
<tr><td><code id="getSnpGeno_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with genotypes when <code>x</code> is <code><a href="#topic+Colony-class">Colony-class</a></code> and
list of matrices with genotypes when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>, named by colony id when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getQueenSnpGeno()</code>: Access SNP array genotype data of the queen
</p>
</li>
<li> <p><code>getFathersSnpGeno()</code>: Access SNP array genotype data of fathers
</p>
</li>
<li> <p><code>getVirginQueensSnpGeno()</code>: Access SNP array genotype data of virgin queens
</p>
</li>
<li> <p><code>getWorkersSnpGeno()</code>: Access SNP array genotype data of workers
</p>
</li>
<li> <p><code>getDronesSnpGeno()</code>: Access SNP array genotype data of drones
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+getSnpGeno">getSnpGeno</a></code> and <code><a href="AlphaSimR.html#topic+pullSnpGeno">pullSnpGeno</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 4, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
SP$addSnpChip(nSnpPerChr = 5)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)
colony &lt;- addVirginQueens(x = colony, nInd = 5)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 6, nDrones = 3)
apiary &lt;- addVirginQueens(x = apiary, nInd = 5)

# Input is a population
getSnpGeno(x = getQueen(colony))
queens &lt;- getQueen(apiary, collapse = TRUE)
getSnpGeno(queens)

# Input is a colony
getSnpGeno(colony, caste = "queen")
getQueenSnpGeno(colony)

getSnpGeno(colony, caste = "workers", nInd = 3)
getWorkersSnpGeno(colony)
# Same aliases exist for all the castes!

# Get genotypes for all individuals
getSnpGeno(colony, caste = "all")
# Get all haplotypes in a single matrix
getSnpGeno(colony, caste = "all", collapse = TRUE)

# Input is a MultiColony - same behaviour as for the Colony!
getSnpGeno(apiary, caste = "queen")
getQueenSnpGeno(apiary)

# Get the haplotypes of all individuals either by colony or in a single matrix
getSnpGeno(apiary, caste = "all")
getSnpGeno(apiary, caste = "all", collapse = TRUE)
</code></pre>

<hr>
<h2 id='getSnpHaplo'>Access SNP array haplotypes of individuals in a caste</h2><span id='topic+getSnpHaplo'></span><span id='topic+getQueenSnpHaplo'></span><span id='topic+getFathersSnpHaplo'></span><span id='topic+getVirginQueensSnpHaplo'></span><span id='topic+getWorkersSnpHaplo'></span><span id='topic+getDronesSnpHaplo'></span>

<h3>Description</h3>

<p>Level 0 function that returns SNP array haplotypes of
individuals in a caste.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSnpHaplo(
  x,
  caste = NULL,
  nInd = NULL,
  snpChip = 1,
  haplo = "all",
  chr = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)

getQueenSnpHaplo(
  x,
  snpChip = 1,
  haplo = "all",
  chr = NULL,
  collapse = FALSE,
  simParamBee = NULL
)

getFathersSnpHaplo(
  x,
  nInd = NULL,
  snpChip = 1,
  haplo = "all",
  chr = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)

getVirginQueensSnpHaplo(
  x,
  nInd = NULL,
  snpChip = 1,
  haplo = "all",
  chr = NULL,
  collapse = FALSE,
  simParamBee = NULL
)

getWorkersSnpHaplo(
  x,
  nInd = NULL,
  snpChip = 1,
  haplo = "all",
  chr = NULL,
  collapse = FALSE,
  simParamBee = NULL
)

getDronesSnpHaplo(
  x,
  nInd = NULL,
  snpChip = 1,
  haplo = "all",
  chr = NULL,
  dronesHaploid = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSnpHaplo_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="getSnpHaplo_+3A_caste">caste</code></td>
<td>
<p>NULL or character, NULL when <code>x</code> is a <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>,
and character when <code>x</code> is a <code><a href="#topic+Colony-class">Colony-class</a></code> or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with the possible values of &quot;queen&quot;, &quot;fathers&quot;,
&quot;workers&quot;, &quot;drones&quot;, &quot;virginQueens&quot;, or &quot;all&quot;</p>
</td></tr>
<tr><td><code id="getSnpHaplo_+3A_nind">nInd</code></td>
<td>
<p>numeric, number of individuals to access, if <code>NULL</code> all
individuals are accessed, otherwise a random sample</p>
</td></tr>
<tr><td><code id="getSnpHaplo_+3A_snpchip">snpChip</code></td>
<td>
<p>numeric, indicates which SNP array haplotypes to retrieve</p>
</td></tr>
<tr><td><code id="getSnpHaplo_+3A_haplo">haplo</code></td>
<td>
<p>character, either &quot;all&quot; for all haplotypes or an integer for a
single set of haplotypes, use a value of 1 for female haplotypes and a
value of 2 for male haplotypes</p>
</td></tr>
<tr><td><code id="getSnpHaplo_+3A_chr">chr</code></td>
<td>
<p>numeric, chromosomes to retrieve, if <code>NULL</code>, all chromosome
are retrieved</p>
</td></tr>
<tr><td><code id="getSnpHaplo_+3A_droneshaploid">dronesHaploid</code></td>
<td>
<p>logical, return haploid result for drones?</p>
</td></tr>
<tr><td><code id="getSnpHaplo_+3A_collapse">collapse</code></td>
<td>
<p>logical, if the return value should be a single matrix
with haplotypes of all the individuals</p>
</td></tr>
<tr><td><code id="getSnpHaplo_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with haplotypes when <code>x</code> is <code><a href="#topic+Colony-class">Colony-class</a></code>
and list of matrices with haplotypes when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>, named by colony id when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getQueenSnpHaplo()</code>: Access SNP array haplotype data of the queen
</p>
</li>
<li> <p><code>getFathersSnpHaplo()</code>: Access SNP array haplotype data of fathers
</p>
</li>
<li> <p><code>getVirginQueensSnpHaplo()</code>: Access SNP array haplotype data of virgin queens
</p>
</li>
<li> <p><code>getWorkersSnpHaplo()</code>: Access SNP array haplotype of workers
</p>
</li>
<li> <p><code>getDronesSnpHaplo()</code>: Access SNP array haplotype data of drones
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+getSnpHaplo">getSnpHaplo</a></code> and <code><a href="AlphaSimR.html#topic+pullSnpHaplo">pullSnpHaplo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 4, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
SP$addSnpChip(nSnpPerChr = 5)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)
colony &lt;- addVirginQueens(x = colony, nInd = 5)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 6, nDrones = 3)
apiary &lt;- addVirginQueens(x = apiary, nInd = 5)

# Input is a population
getSnpHaplo(x = getQueen(colony))
queens &lt;- getQueen(apiary, collapse = TRUE)
getSnpHaplo(queens)

# Input is a colony
getSnpHaplo(colony, caste = "queen")
getQueenSnpHaplo(colony)

getSnpHaplo(colony, caste = "workers", nInd = 3)
getWorkersSnpHaplo(colony)
# Same aliases exist for all the castes!

# Get haplotypes for all individuals
getSnpHaplo(colony, caste = "all")
# Get all haplotypes in a single matrix
getSnpHaplo(colony, caste = "all", collapse = TRUE)

# Input is a MultiColony - same behaviour as for the Colony!
getSnpHaplo(apiary, caste = "queen")
getQueenSnpHaplo(apiary)

# Get the haplotypes of all individuals either by colony or in a single matrix
getSnpHaplo(apiary, caste = "all")
getSnpHaplo(apiary, caste = "all", collapse = TRUE)

</code></pre>

<hr>
<h2 id='hasCollapsed'>Test if colony has collapsed</h2><span id='topic+hasCollapsed'></span>

<h3>Description</h3>

<p>Level 0 function that returns colony collapse status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasCollapsed(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasCollapsed_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, named by colony id when <code>x</code> is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)
colony &lt;- addVirginQueens(colony, nInd = 5)

hasCollapsed(colony)
colony &lt;- collapse(colony)
hasCollapsed(colony)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 6, nDrones = 3)

hasCollapsed(apiary)
apiary &lt;- collapse(apiary)
hasCollapsed(apiary)
</code></pre>

<hr>
<h2 id='hasSplit'>Test if colony has split</h2><span id='topic+hasSplit'></span>

<h3>Description</h3>

<p>Level 0 function that returns colony split status. This will
obviously impact colony strength.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasSplit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasSplit_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, named by colony id when <code>x</code> is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 6, nDrones = 3)

hasSplit(colony)
tmp &lt;- split(colony)
hasSplit(tmp$split)
hasSplit(tmp$remnant)

hasSplit(apiary)
tmp2 &lt;- split(apiary)
hasSplit(tmp2$split)
hasSplit(tmp2$remnant)
</code></pre>

<hr>
<h2 id='hasSuperseded'>Test if colony has superseded</h2><span id='topic+hasSuperseded'></span>

<h3>Description</h3>

<p>Level 0 function that returns colony supersedure status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasSuperseded(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasSuperseded_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, named by colony id when <code>x</code> is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)
colony &lt;- addVirginQueens(colony, nInd = 5)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 6, nDrones = 3)

hasSuperseded(colony)
colony &lt;- supersede(colony)
hasSuperseded(colony)

hasSuperseded(apiary)
apiary &lt;- supersede(apiary)
hasSuperseded(apiary)
</code></pre>

<hr>
<h2 id='hasSwarmed'>Test if colony has swarmed</h2><span id='topic+hasSwarmed'></span>

<h3>Description</h3>

<p>Level 0 function that returns colony swarmed status. This will
obviously have major impact on the colony and its downstream events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasSwarmed(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasSwarmed_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, named by colony id when <code>x</code> is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)
colony &lt;- addVirginQueens(colony, nInd = 5)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 6, nDrones = 3)

hasSwarmed(colony)
tmp &lt;- swarm(colony)
hasSwarmed(tmp$swarm)
hasSwarmed(tmp$remnant)

hasSwarmed(apiary)
tmp2 &lt;- swarm(apiary)
hasSwarmed(tmp2$swarm)
hasSwarmed(tmp2$remnant)
</code></pre>

<hr>
<h2 id='isCaste'>Is individual a member of a specific caste</h2><span id='topic+isCaste'></span><span id='topic+isQueen'></span><span id='topic+isFather'></span><span id='topic+isWorker'></span><span id='topic+isDrone'></span><span id='topic+isVirginQueen'></span>

<h3>Description</h3>

<p>Level 0 function that tests if individuals are members of a
specific caste
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isCaste(x, caste, simParamBee = NULL)

isQueen(x, simParamBee = NULL)

isFather(x, simParamBee = NULL)

isWorker(x, simParamBee = NULL)

isDrone(x, simParamBee = NULL)

isVirginQueen(x, simParamBee = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isCaste_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="isCaste_+3A_caste">caste</code></td>
<td>
<p>character, one of &quot;queen&quot;, &quot;fathers&quot;, &quot;workers&quot;, &quot;drones&quot;, or
&quot;virginQueens&quot;; only single value is used</p>
</td></tr>
<tr><td><code id="isCaste_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>isQueen()</code>: Is individual a queen
</p>
</li>
<li> <p><code>isFather()</code>: Is individual a father
</p>
</li>
<li> <p><code>isWorker()</code>: Is individual a worker
</p>
</li>
<li> <p><code>isDrone()</code>: Is individual a drone
</p>
</li>
<li> <p><code>isVirginQueen()</code>: Is individual a virgin queen
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+isQueen">isQueen</a></code>, <code><a href="#topic+isFather">isFather</a></code>,
<code><a href="#topic+isVirginQueen">isVirginQueen</a></code>, <code><a href="#topic+isWorker">isWorker</a></code>, and
<code><a href="#topic+isDrone">isDrone</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 120, nDrones = 20)
colony &lt;- addVirginQueens(x = colony, nInd = 4)

isCaste(getQueen(colony), caste = "queen")
isCaste(getFathers(colony, nInd = 2), caste = "fathers")
isCaste(getWorkers(colony, nInd = 2), caste = "workers") # random sample!
isCaste(getDrones(colony, nInd = 2), caste = "drones")
isCaste(getVirginQueens(colony, nInd = 2), caste = "virginQueens")

bees &lt;- c(
  getQueen(colony),
  getFathers(colony, nInd = 2),
  getWorkers(colony, nInd = 2),
  getDrones(colony, nInd = 2),
  getVirginQueens(colony, nInd = 2)
)
isCaste(bees, caste = "queen")
isCaste(bees, caste = "fathers")
isCaste(bees, caste = "workers")
isCaste(bees, caste = "drones")
isCaste(bees, caste = "virginQueens")

isQueen(getQueen(colony))
isQueen(getFathers(colony, nInd = 2))

isFather(getQueen(colony))
isFather(getFathers(colony, nInd = 2))

isWorker(getQueen(colony))
isWorker(getFathers(colony, nInd = 2))
isWorker(getWorkers(colony, nInd = 2))

isDrone(getQueen(colony))
isDrone(getFathers(colony, nInd = 2))
isDrone(getDrones(colony, nInd = 2))

isVirginQueen(getQueen(colony))
isVirginQueen(getFathers(colony, nInd = 2))
isVirginQueen(getVirginQueens(colony, nInd = 2))

</code></pre>

<hr>
<h2 id='isCsdActive'>Is csd locus activated</h2><span id='topic+isCsdActive'></span>

<h3>Description</h3>

<p>Level 0 function that checks if the csd locus has been
activated. See <code><a href="#topic+SimParamBee">SimParamBee</a></code> for more information about the csd
locus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isCsdActive(simParamBee = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isCsdActive_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 3, nChr = 3, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes, csdChr = NULL)
isCsdActive()

SP &lt;- SimParamBee$new(founderGenomes)
isCsdActive()
</code></pre>

<hr>
<h2 id='isCsdHeterozygous'>Test if individuals are heterozygous at the csd locus</h2><span id='topic+isCsdHeterozygous'></span>

<h3>Description</h3>

<p>Level 0 function that returns if individuals of a population are
heterozygous at the csd locus. See <code><a href="#topic+SimParamBee">SimParamBee</a></code> for more
information about the csd locus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isCsdHeterozygous(pop, simParamBee = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isCsdHeterozygous_+3A_pop">pop</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="isCsdHeterozygous_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We could expand <code>isCsdHeterozygous</code> to work also with
<code><a href="#topic+Colony-class">Colony-class</a></code> and <code><a href="#topic+MultiColony-class">MultiColony-class</a></code> if needed
</p>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)
colony &lt;- addVirginQueens(x = colony, nInd = 4)

# Use isCsdHeterozygous on a Population
isCsdHeterozygous(getQueen(colony))
isCsdHeterozygous(getWorkers(colony))
</code></pre>

<hr>
<h2 id='isDronesPresent'>Are drones present</h2><span id='topic+isDronesPresent'></span>

<h3>Description</h3>

<p>Level 0 function that returns drones presence status (are they
present or not).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isDronesPresent(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isDronesPresent_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, named by colony id when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 120, nDrones = 20)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 100, nDrones = 10)

isDronesPresent(colony)
isDronesPresent(removeDrones(colony))
isDronesPresent(apiary)
isDronesPresent(removeDrones(apiary))
</code></pre>

<hr>
<h2 id='isEmpty'>Check whether a population, colony or a multicolony
object has no individuals within</h2><span id='topic+isEmpty'></span>

<h3>Description</h3>

<p>Check whether a population, colony or a multicolony
object has no individuals within.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isEmpty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isEmpty_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> or <code><a href="#topic+Colony-class">Colony-class</a></code> or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean when <code>x</code> is <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> or
<code><a href="#topic+Colony-class">Colony-class</a></code>, and named vector of boolean when
<code>x</code> is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 5, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

isEmpty(new(Class = "Pop"))
isEmpty(basePop[0])
isEmpty(basePop)

emptyColony &lt;- createColony()
nonEmptyColony &lt;- createColony(basePop[1])
isEmpty(emptyColony)
isEmpty(nonEmptyColony)

emptyApiary &lt;- createMultiColony(n = 3)
emptyApiary1 &lt;- c(createColony(), createColony())
emptyApiary2 &lt;- createMultiColony()
nonEmptyApiary &lt;- createMultiColony(basePop[2:5], n = 4)

isEmpty(emptyApiary)
isEmpty(emptyApiary1)
isEmpty(nonEmptyApiary)
isNULLColonies(emptyApiary)
isNULLColonies(emptyApiary1)
isNULLColonies(nonEmptyApiary)

nEmptyColonies(emptyApiary)
nEmptyColonies(emptyApiary1)
nEmptyColonies(nonEmptyApiary)
nNULLColonies(emptyApiary)
nNULLColonies(emptyApiary1)
nNULLColonies(nonEmptyApiary)

</code></pre>

<hr>
<h2 id='isFathersPresent'>Are fathers present (=queen mated)</h2><span id='topic+isFathersPresent'></span><span id='topic+areFathersPresent'></span>

<h3>Description</h3>

<p>Level 0 function that returns fathers presence status (are they
present or not, which means the queen is mated).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isFathersPresent(x)

areFathersPresent(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isFathersPresent_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, named by colony id when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>areFathersPresent()</code>: Are fathers present
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
isFathersPresent(colony)
apiary &lt;- createMultiColony(basePop[3:4], n = 2)
isFathersPresent(apiary)

colony &lt;- cross(colony, drones = droneGroups[[1]])
isFathersPresent(removeDrones(colony))

apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
isFathersPresent(removeDrones(apiary))
</code></pre>

<hr>
<h2 id='isGenoHeterozygous'>Test if a multilocus genotype is heterozygous</h2><span id='topic+isGenoHeterozygous'></span>

<h3>Description</h3>

<p>Level 0 function that returns heterozygote status for a
multilocus genotype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isGenoHeterozygous(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isGenoHeterozygous_+3A_x">x</code></td>
<td>
<p>integer or matrix, output from <code><a href="#topic+getCsdGeno">getCsdGeno</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
# Not exporting this function, since its just a helper
</p>

<hr>
<h2 id='isNULLColonies'>Check which of the colonies in a multicolony are NULL</h2><span id='topic+isNULLColonies'></span>

<h3>Description</h3>

<p>Check which of the colonies in a multicolony are NULL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isNULLColonies(multicolony)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isNULLColonies_+3A_multicolony">multicolony</code></td>
<td>
<p><code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named vector of boolean
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 5, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

emptyApiary &lt;- createMultiColony(n = 3)
emptyApiary1 &lt;- c(createColony(), createColony())
nonEmptyApiary &lt;- createMultiColony(basePop[2:5], n = 4)

isEmpty(emptyApiary)
isEmpty(emptyApiary1)
isEmpty(nonEmptyApiary)
isNULLColonies(emptyApiary)
isNULLColonies(emptyApiary1)
isNULLColonies(nonEmptyApiary)

nEmptyColonies(emptyApiary)
nEmptyColonies(emptyApiary1)
nEmptyColonies(nonEmptyApiary)
nNULLColonies(emptyApiary)
nNULLColonies(emptyApiary1)
nNULLColonies(nonEmptyApiary)

</code></pre>

<hr>
<h2 id='isProductive'>Test if colony is currently productive</h2><span id='topic+isProductive'></span>

<h3>Description</h3>

<p>Level 0 function that returns colony production status. This can
be used to decided if colony production can be simulated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isProductive(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isProductive_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, named by colony id when <code>x</code> is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])

isProductive(colony)
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)
isProductive(colony)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])

isProductive(apiary)
apiary &lt;- buildUp(x = apiary, nWorkers = 6, nDrones = 3)
isProductive(apiary)
</code></pre>

<hr>
<h2 id='isQueenPresent'>Is the queen present</h2><span id='topic+isQueenPresent'></span>

<h3>Description</h3>

<p>Level 0 function that returns queen's presence status (is she
present/alive or not).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isQueenPresent(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isQueenPresent_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, named by colony id when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 120, nDrones = 20)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 100, nDrones = 10)

isQueenPresent(colony)
isQueenPresent(apiary)

colony &lt;- removeQueen(colony)
isQueenPresent(colony)
</code></pre>

<hr>
<h2 id='isSimParamBee'>Test if x is a SimParamBee class object</h2><span id='topic+isSimParamBee'></span>

<h3>Description</h3>

<p>Test if x is a <code><a href="#topic+SimParamBee">SimParamBee</a></code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isSimParamBee(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isSimParamBee_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 2, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
isSimParamBee(SP)
</code></pre>

<hr>
<h2 id='isVirginQueensPresent'>Are virgin queen(s) present</h2><span id='topic+isVirginQueensPresent'></span><span id='topic+areVirginQueensPresent'></span>

<h3>Description</h3>

<p>Level 0 function that returns virgin queen(s) presence status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isVirginQueensPresent(x)

areVirginQueensPresent(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isVirginQueensPresent_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, named by colony id when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>areVirginQueensPresent()</code>: Are virgin queen(s) present
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- addVirginQueens(x = colony, nInd = 4)
isVirginQueensPresent(colony)
isVirginQueensPresent(pullVirginQueens(colony)$remnant)
isVirginQueensPresent(removeQueen(colony))

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 100, nDrones = 10)
isVirginQueensPresent(apiary)

tmp &lt;- swarm(x = apiary)
isVirginQueensPresent(tmp$swarm)
isVirginQueensPresent(tmp$remnant)
</code></pre>

<hr>
<h2 id='isWorkersPresent'>Are workers present</h2><span id='topic+isWorkersPresent'></span><span id='topic+areWorkersPresent'></span><span id='topic+areDronesPresent'></span>

<h3>Description</h3>

<p>Level 0 function that returns workers presence status (are they
present or not).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isWorkersPresent(x)

areWorkersPresent(x)

areDronesPresent(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isWorkersPresent_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, named by colony id when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>areWorkersPresent()</code>: Are workers present
</p>
</li>
<li> <p><code>areDronesPresent()</code>: Are drones present
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 120, nDrones = 20)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 100, nDrones = 10)

isWorkersPresent(colony)
isWorkersPresent(removeWorkers(colony))
isWorkersPresent(apiary)
isWorkersPresent(removeWorkers(apiary))
</code></pre>

<hr>
<h2 id='mapCasteToColonyValue'>Map caste member (individual) values to a colony value</h2><span id='topic+mapCasteToColonyValue'></span><span id='topic+mapCasteToColonyPheno'></span><span id='topic+mapCasteToColonyGv'></span><span id='topic+mapCasteToColonyBv'></span><span id='topic+mapCasteToColonyDd'></span><span id='topic+mapCasteToColonyAa'></span>

<h3>Description</h3>

<p>Maps caste member (individual) values to a colony value - for
phenotype, genetic, breeding, dominance, and epistasis values. This function
can be used as <code>FUN</code> argument in <code><a href="#topic+calcColonyValue">calcColonyValue</a></code>
function(s). It can also be saved in <code>SimParamBee$colonyValueFUN</code> as a
default function called by <code><a href="#topic+calcColonyValue">calcColonyValue</a></code> function(s).
</p>
<p>This is just an example - quite a flexible one! You can provide your
own &quot;caste functions&quot; that satisfy your needs within this mapping function
(see <code>queenFUN</code>, <code>workersFUN</code>, and <code>dronesFUN</code> below)
or provide a complete replacement of this mapping function! For example,
this mapping function does not cater for indirect (social) genetic effects
where colony individuals value impacts value of other colony individuals.
Note though that you can achieve this impact also via multiple correlated
traits, such as a queen and a workers trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapCasteToColonyValue(
  colony,
  value = "pheno",
  queenTrait = 1,
  queenFUN = function(x) x,
  workersTrait = 2,
  workersFUN = colSums,
  dronesTrait = NULL,
  dronesFUN = NULL,
  traitName = NULL,
  combineFUN = function(q, w, d) q + w,
  checkProduction = TRUE,
  notProductiveValue = 0,
  simParamBee = NULL
)

mapCasteToColonyPheno(colony, simParamBee = NULL, ...)

mapCasteToColonyGv(colony, checkProduction = FALSE, simParamBee = NULL, ...)

mapCasteToColonyBv(colony, checkProduction = FALSE, simParamBee = NULL, ...)

mapCasteToColonyDd(colony, checkProduction = FALSE, simParamBee = NULL, ...)

mapCasteToColonyAa(colony, checkProduction = FALSE, simParamBee = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapCasteToColonyValue_+3A_colony">colony</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code></p>
</td></tr>
<tr><td><code id="mapCasteToColonyValue_+3A_value">value</code></td>
<td>
<p>character, one of <code>pheno</code> or <code>gv</code></p>
</td></tr>
<tr><td><code id="mapCasteToColonyValue_+3A_queentrait">queenTrait</code></td>
<td>
<p>numeric (column position) or character (column name),
trait(s) that represents queen's contribution to colony value(s); if
<code>NULL</code> then this contribution is 0; you can pass more than one trait
here, but make sure that <code>combineFUN</code> works with these trait dimensions</p>
</td></tr>
<tr><td><code id="mapCasteToColonyValue_+3A_queenfun">queenFUN</code></td>
<td>
<p>function, function that will be applied to queen's value</p>
</td></tr>
<tr><td><code id="mapCasteToColonyValue_+3A_workerstrait">workersTrait</code></td>
<td>
<p>numeric (column position) or character (column name),
trait(s) that represents workers' contribution to colony value(s); if
<code>NULL</code> then this contribution is 0; you can pass more than one trait
here, but make sure that <code>combineFUN</code> works with these trait dimensions</p>
</td></tr>
<tr><td><code id="mapCasteToColonyValue_+3A_workersfun">workersFUN</code></td>
<td>
<p>function, function that will be applied to workers values</p>
</td></tr>
<tr><td><code id="mapCasteToColonyValue_+3A_dronestrait">dronesTrait</code></td>
<td>
<p>numeric (column position) or character (column name),
trait(s) that represents drones' contribution to colony value(s); if
<code>NULL</code> then this contribution is 0; you can pass more than one trait
here, but make sure that <code>combineFUN</code> works with these trait dimensions</p>
</td></tr>
<tr><td><code id="mapCasteToColonyValue_+3A_dronesfun">dronesFUN</code></td>
<td>
<p>function, function that will be applied to drone values</p>
</td></tr>
<tr><td><code id="mapCasteToColonyValue_+3A_traitname">traitName</code></td>
<td>
<p>the name of the colony trait(s), say, honeyYield; you can pass
more than one trait name here, but make sure to match them with
<code>combineFUN</code> trait dimensions</p>
</td></tr>
<tr><td><code id="mapCasteToColonyValue_+3A_combinefun">combineFUN</code></td>
<td>
<p>function that will combine the queen, worker, and drone
contributions - this function should be defined as <code>function(q, w, d)</code>
where <code>q</code> represents queen's, <code>q</code> represents workers', and
<code>d</code> represents drones' contribution.</p>
</td></tr>
<tr><td><code id="mapCasteToColonyValue_+3A_checkproduction">checkProduction</code></td>
<td>
<p>logical, does the value depend on the production
status of colony; if yes and production is <code>FALSE</code>, the return
is <code>notProductiveValue</code> - this will often make sense for colony
phenotype value only; you can pass more than one logical value here (one
per trait coming out of <code>combineFUN</code>)</p>
</td></tr>
<tr><td><code id="mapCasteToColonyValue_+3A_notproductivevalue">notProductiveValue</code></td>
<td>
<p>numeric, returned value when colony is not productive;
you can pass more than one logical value here (one per trait coming out of
<code>combineFUN</code>)</p>
</td></tr>
<tr><td><code id="mapCasteToColonyValue_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
<tr><td><code id="mapCasteToColonyValue_+3A_...">...</code></td>
<td>
<p>other arguments of <code>mapCasteToColonyValue</code> (for its aliases)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a utility/mapping function meant to be called by
<code><a href="#topic+calcColonyValue">calcColonyValue</a></code>. It only works on a single colony - use
<code><a href="#topic+calcColonyValue">calcColonyValue</a></code> to get Colony or MultiColony values.
</p>


<h3>Value</h3>

<p>numeric matrix with one value or a row of values
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>mapCasteToColonyPheno()</code>: Map caste member (individual) phenotype values to a colony phenotype value
</p>
</li>
<li> <p><code>mapCasteToColonyGv()</code>: Map caste member (individual) genetic values to a colony genetic value
</p>
</li>
<li> <p><code>mapCasteToColonyBv()</code>: Map caste member (individual) breeding values to a colony breeding value
</p>
</li>
<li> <p><code>mapCasteToColonyDd()</code>: Map caste member (individual) dominance values to a colony dominance value
</p>
</li>
<li> <p><code>mapCasteToColonyAa()</code>: Map caste member (individual) epistasis values to a colony epistasis value
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+SimParamBee">SimParamBee</a></code> field <code>colonyValueFUN</code> and functions
<code><a href="#topic+calcColonyValue">calcColonyValue</a></code>, <code><a href="#topic+calcColonyPheno">calcColonyPheno</a></code>,
<code><a href="#topic+calcColonyGv">calcColonyGv</a></code>, <code><a href="#topic+getEvents">getEvents</a></code>,
<code><a href="AlphaSimR.html#topic+pheno">pheno</a></code>, and <code><a href="AlphaSimR.html#topic+gv">gv</a></code>, as well as
<code>vignette(topic = "QuantitativeGenetics", package = "SIMplyBee")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 5, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)

# Define two traits that collectively affect colony honey yield:
# 1) queen's effect on colony honey yield, say via pheromone secretion phenotype
# 2) workers' effect on colony honey yield, say via foraging ability phenotype
# The traits will have a negative genetic correlation of -0.5 and heritability
# of 0.25 (on an individual level)
nWorkers &lt;- 10
mean &lt;- c(10, 10 / nWorkers)
varA &lt;- c(1, 1 / nWorkers)
corA &lt;- matrix(data = c(
  1.0, -0.5,
  -0.5, 1.0
), nrow = 2, byrow = TRUE)
varE &lt;- c(3, 3 / nWorkers)
varA / (varA + varE)
SP$addTraitADE(nQtlPerChr = 100,
               mean = mean,
               var = varA, corA = corA,
               meanDD = 0.1, varDD = 0.2, corD = corA,
               relAA = 0.1, corAA = corA)
SP$setVarE(varE = varE)

basePop &lt;- createVirginQueens(founderGenomes)
drones &lt;- createDrones(x = basePop[1], nInd = 10)
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = drones)
colony &lt;- buildUp(colony, nWorkers = nWorkers, nDrones = 3)

# Colony value
mapCasteToColonyPheno(colony)
mapCasteToColonyGv(colony)

# To understand where the above values come from, study the contents of
# mapCasteToColonyValue() and the values below:

# Phenotype values
getQueenPheno(colony)
getWorkersPheno(colony)

# Genetic values
getQueenGv(colony)
getWorkersGv(colony)

</code></pre>

<hr>
<h2 id='MultiColony-class'>Honeybee multicolony object</h2><span id='topic+MultiColony-class'></span><span id='topic+isMultiColony'></span><span id='topic+show+2CMultiColony-method'></span><span id='topic+c+2CMultiColony-method'></span><span id='topic+c+2CMultiColonyOrNULL-method'></span><span id='topic++5B+2CMultiColony+2CintegerOrNumericOrLogical-method'></span><span id='topic++5B+2CMultiColony+2Ccharacter-method'></span><span id='topic++5B+5B+2CMultiColony+2CintegerOrNumericOrLogical-method'></span><span id='topic++5B+5B+2CMultiColony+2Ccharacter-method'></span><span id='topic++5B+3C-+2CMultiColony+2CintegerOrNumericOrLogicalOrCharacter+2CANY+2CMultiColony-method'></span><span id='topic++5B+5B+3C-+2CMultiColony+2CintegerOrNumericOrLogicalOrCharacter+2CANY+2CColony-method'></span>

<h3>Description</h3>

<p>An object holding a collection of honeybee colonies. It behaves
like a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isMultiColony(x)

## S4 method for signature 'MultiColony'
show(object)

## S4 method for signature 'MultiColony'
c(x, ...)

## S4 method for signature 'MultiColonyOrNULL'
c(x, ...)

## S4 method for signature 'MultiColony,integerOrNumericOrLogical'
x[i, j, drop]

## S4 method for signature 'MultiColony,character'
x[i, j, drop]

## S4 method for signature 'MultiColony,integerOrNumericOrLogical'
x[[i]]

## S4 method for signature 'MultiColony,character'
x[[i]]

## S4 replacement method for signature 
## 'MultiColony,integerOrNumericOrLogicalOrCharacter,ANY,MultiColony'
x[i, j] &lt;- value

## S4 replacement method for signature 
## 'MultiColony,integerOrNumericOrLogicalOrCharacter,ANY,Colony'
x[[i, j]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultiColony-class_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="MultiColony-class_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="MultiColony-class_+3A_...">...</code></td>
<td>
<p><code>NULL</code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="MultiColony-class_+3A_i">i</code></td>
<td>
<p>integer, numeric, logical, or character, index or ID to select
a colony (see examples)</p>
</td></tr>
<tr><td><code id="MultiColony-class_+3A_j">j</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="MultiColony-class_+3A_drop">drop</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="MultiColony-class_+3A_value">value</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code> to
assign into <code>x</code> based on colony index or name <code>i</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+MultiColony-class">MultiColony-class</a></code> or <code><a href="#topic+Colony-class">Colony-class</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>isMultiColony()</code>: Test if x is a MultiColony class object
</p>
</li>
<li> <p><code>show(MultiColony)</code>: Show MultiColony object
</p>
</li>
<li> <p><code>c(MultiColony)</code>: Combine multiple Colony and MultiColony objects
</p>
</li>
<li> <p><code>c(MultiColonyOrNULL)</code>: Combine multiple Colony and MultiColony objects
</p>
</li>
<li> <p><code>x[i</code>: Extract a colony (one or more!) with an integer/numeric/logical index (position) (return <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>)
</p>
</li>
<li> <p><code>x[i</code>: Extract a colony (one or more!) with a character ID (name) (return <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>)
</p>
</li>
<li> <p><code>x[[i</code>: Extract a colony (just one!) with an integer/numeric/logical index (position) (return <code><a href="#topic+Colony-class">Colony-class</a></code>)
</p>
</li>
<li> <p><code>x[[i</code>: Extract a colony (just one!) with a character ID (name) (return <code><a href="#topic+Colony-class">Colony-class</a></code>)
</p>
</li>
<li> <p><code>`[`(x = MultiColony, i = integerOrNumericOrLogicalOrCharacter, j = ANY) &lt;- value</code>: Assign colonies into MultiColony
</p>
</li>
<li> <p><code>`[[`(x = MultiColony, i = integerOrNumericOrLogicalOrCharacter, j = ANY) &lt;- value</code>: Assign Colony into MultiColony
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>colonies</code></dt><dd><p>list, a collection of <code><a href="#topic+Colony-class">Colony-class</a></code> objects</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+createMultiColony">createMultiColony</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 10, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)
apiary &lt;- createMultiColony(basePop[1:6], n = 6)
apiary &lt;- cross(apiary, drones = droneGroups[1:6])
apiary
show(apiary)
is(apiary)
isMultiColony(apiary)

getId(apiary)
apiary[1]
getId(apiary[1])
getId(apiary["2"])
getId(apiary[2])
getId(apiary[-1])
getId(apiary[5])

getId(apiary)
getId(apiary[c(1, 3)])
getId(apiary[c("2", "4")])
getId(apiary[c(TRUE, FALSE, TRUE, FALSE)])
getId(apiary[c(TRUE, FALSE)]) # beware of recycling!
getId(apiary[c(5, 6)])
getId(apiary[c("6", "7")])

apiary[[1]]
apiary[["2"]]
apiary[[3]]
apiary[["4"]]
try(apiary[[6]])
apiary[["7"]]

getId(c(apiary[c(1, 3)], apiary[2]))
getId(c(apiary[2], apiary[c(1, 3)]))

getId(c(apiary[2], apiary[0]))
getId(c(apiary[0], apiary[2]))

getId(c(apiary[2], NULL))
getId(c(NULL, apiary[2]))

apiary1 &lt;- apiary[1:2]
apiary2 &lt;- apiary[3:4]
getId(apiary1)
getId(apiary2)
apiary1[[1]] &lt;- apiary2[[1]]
getId(apiary1)
try(apiary2[[1]] &lt;- apiary2[[2]])

apiary1 &lt;- apiary[1:2]
apiary2 &lt;- apiary[3:5]
getId(apiary1)
getId(apiary2)
apiary2[1:2] &lt;- apiary1
getId(apiary2)
try(apiary2[1] &lt;- apiary1)
try(apiary2[1:3] &lt;- apiary1)
try(apiary2[1:2] &lt;- apiary1[[1]])

apiary2 &lt;- apiary[3:5]
getId(apiary2)
try(apiary2[c("4", "5")] &lt;- apiary1)
try(apiary2[c("4", "5")] &lt;- apiary1)
</code></pre>

<hr>
<h2 id='nCaste'>Level 0 function that returns the number of individuals of a caste in a
colony</h2><span id='topic+nCaste'></span><span id='topic+nQueens'></span><span id='topic+nFathers'></span><span id='topic+nWorkers'></span><span id='topic+nDrones'></span><span id='topic+nVirginQueens'></span>

<h3>Description</h3>

<p>Returns the number of individuals of a caste in a colony
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nCaste(x, caste = "all")

nQueens(x)

nFathers(x)

nWorkers(x)

nDrones(x)

nVirginQueens(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nCaste_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="nCaste_+3A_caste">caste</code></td>
<td>
<p>character, &quot;queen&quot;, &quot;fathers&quot;, &quot;workers&quot;, &quot;drones&quot;,
&quot;virginQueens&quot;, or &quot;all&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>when <code>x</code> is <code><a href="#topic+Colony-class">Colony-class</a></code> return is integer for
<code>caste != "all"</code> or list for <code>caste == "all"</code> with nodes named
by caste; when <code>x</code> is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code> return is named
integer for <code>caste != "all"</code> or named list of lists for
<code>caste == "all"</code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>nQueens()</code>: Number of queens in a colony
</p>
</li>
<li> <p><code>nFathers()</code>: Number of fathers in a colony
</p>
</li>
<li> <p><code>nWorkers()</code>: Number of workers in a colony
</p>
</li>
<li> <p><code>nDrones()</code>: Number of drones in a colony
</p>
</li>
<li> <p><code>nVirginQueens()</code>: Number of virgin queens in a colony
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+nQueens">nQueens</a></code>, <code><a href="#topic+nFathers">nFathers</a></code>,
<code><a href="#topic+nVirginQueens">nVirginQueens</a></code>, <code><a href="#topic+nWorkers">nWorkers</a></code>, and
<code><a href="#topic+nDrones">nDrones</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 100, nDrones = 10)
colony &lt;- addVirginQueens(x = colony, nInd = 3)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 100, nDrones = 10)
apiary &lt;- addVirginQueens(x = apiary, nInd = 3)

# Check caste members
nCaste(colony, caste = "queen")
nCaste(colony, caste = "fathers")
nCaste(colony, caste = "virginQueens")
nCaste(colony, caste = "workers")
nCaste(colony, caste = "drones")
nCaste(colony, caste = "all")

nCaste(apiary, caste = "queen")
nCaste(apiary, caste = "fathers")
nCaste(apiary, caste = "virginQueens")
nCaste(apiary, caste = "workers")
nCaste(apiary, caste = "drones")
nCaste(apiary, caste = "all")

# Check number of queens
nQueens(colony)
nQueens(apiary)
apiary &lt;- removeQueen(apiary)
nQueens(apiary)

# Check number of fathers
nFathers(colony)
nFathers(apiary)

# Check number of workers
nWorkers(colony)
nWorkers(apiary)

# Check number of drones
nDrones(colony)
nDrones(apiary)

# Check number of virgin queens
nVirginQueens(colony)
nVirginQueens(apiary)

</code></pre>

<hr>
<h2 id='nColonies'>Number of colonies in a MultiColony object</h2><span id='topic+nColonies'></span><span id='topic+nNULLColonies'></span><span id='topic+nEmptyColonies'></span>

<h3>Description</h3>

<p>Level 0 function that returns the number of colonies in a
MultiColony object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nColonies(multicolony)

nNULLColonies(multicolony)

nEmptyColonies(multicolony)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nColonies_+3A_multicolony">multicolony</code></td>
<td>
<p><code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>nNULLColonies()</code>: Number of <code>NULL</code> colonies in a MultiColony object
</p>
</li>
<li> <p><code>nEmptyColonies()</code>: Number of empty colonies in a MultiColony object
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+nNULLColonies">nNULLColonies</a></code> and <code><a href="#topic+nEmptyColonies">nEmptyColonies</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 5, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

emptyApiary &lt;- createMultiColony(n = 3)
emptyApiary1 &lt;- c(createColony(), createColony())
nonEmptyApiary &lt;- createMultiColony(basePop[2:3], n = 2)

nColonies(nonEmptyApiary)
nColonies(emptyApiary)

isEmpty(emptyApiary)
isEmpty(emptyApiary1)
isEmpty(nonEmptyApiary)
isNULLColonies(emptyApiary)
isNULLColonies(emptyApiary1)
isNULLColonies(nonEmptyApiary)

nEmptyColonies(emptyApiary)
nEmptyColonies(emptyApiary1)
nEmptyColonies(nonEmptyApiary)
nNULLColonies(emptyApiary)
nNULLColonies(emptyApiary1)
nNULLColonies(nonEmptyApiary)

</code></pre>

<hr>
<h2 id='nCsdAlleles'>Report the number of distinct csd alleles</h2><span id='topic+nCsdAlleles'></span>

<h3>Description</h3>

<p>Level 0 function that returns the number of distinct csd alleles
in input. See <code><a href="#topic+SimParamBee">SimParamBee</a></code> for more information about the csd
locus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nCsdAlleles(x, collapse = FALSE, simParamBee = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nCsdAlleles_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="nCsdAlleles_+3A_collapse">collapse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the function will return the number
of distinct csd alleles in either the entire population, colony, or
multicolony. Note this has nothing to do with the colony collapse. It's
like <code>paste(..., collapse = TRUE)</code>. Default is <code>FALSE</code>. See
examples about this behaviour.Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="nCsdAlleles_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Queen has 2 distinct csd alleles, since she has to be heterozygous
to be viable. The same holds for individual virgin queens and workers, but
note that looking at csd genotypes of virgin queens or workers we are
looking at a sample of 1 csd allele from the queen and 1 csd allele from
their fathers, noting that homozygous genotypes are excluded. Therefore,
<code>nCsdAlleles()</code> from virgin queens and workers is a noisy realisation
of <code>nCsdAlleles()</code> from queens and fathers. For this reason, we also
report <code>nCsdAlleles()</code> from queens and fathers combined (see the
<code>queenAndFathers</code> list node) when <code>x</code> is
<code><a href="#topic+Colony-class">Colony-class</a></code>. This last measure is then the expected number
of csd alleles in a colony as opposed to realised number of csd alleles in
a sample of virgin queens and workers. Similarly as for virgin queens and
workers, <code>nCsdAlleles()</code> from drones gives a noisy realisation of
<code>nCsdAlleles()</code> from queens. The amount of noise will depend on the
number of individuals, so in most cases with reasonable number of
individuals there should be minimal amount of noise.
</p>


<h3>Value</h3>

<p>integer representing the number of distinct csd alleles when <code>x</code>
is <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> (or ), list of integer
when <code>x</code> is <code><a href="#topic+Colony-class">Colony-class</a></code> (list nodes named by caste) and
list of a list of integer when <code>x</code> is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>,
outer list is named by colony id when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>; the integer rep
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)
colony &lt;- addVirginQueens(x = colony, nInd = 4)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 6, nDrones = 3)
apiary &lt;- addVirginQueens(x = apiary, nInd = 5)

nCsdAlleles(getQueen(colony))
nCsdAlleles(getWorkers(colony))

nCsdAlleles(colony)
nCsdAlleles(colony, collapse = TRUE)

nCsdAlleles(apiary)
nCsdAlleles(apiary, collapse = TRUE)
</code></pre>

<hr>
<h2 id='nDronesPoisson'>Sample a number of drones</h2><span id='topic+nDronesPoisson'></span><span id='topic+nDronesTruncPoisson'></span><span id='topic+nDronesColonyPhenotype'></span>

<h3>Description</h3>

<p>Sample a number of drones - used when <code>nDrones = NULL</code>
(see <code><a href="#topic+SimParamBee">SimParamBee</a>$nDrones</code>).
</p>
<p>This is just an example. You can provide your own functions that satisfy
your needs!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nDronesPoisson(x, n = 1, average = 100)

nDronesTruncPoisson(x, n = 1, average = 100, lowerLimit = 0)

nDronesColonyPhenotype(
  x,
  queenTrait = 1,
  workersTrait = NULL,
  checkProduction = FALSE,
  lowerLimit = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nDronesPoisson_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> or <code><a href="#topic+Colony-class">Colony-class</a></code></p>
</td></tr>
<tr><td><code id="nDronesPoisson_+3A_n">n</code></td>
<td>
<p>integer, number of samples</p>
</td></tr>
<tr><td><code id="nDronesPoisson_+3A_average">average</code></td>
<td>
<p>numeric, average number of drones</p>
</td></tr>
<tr><td><code id="nDronesPoisson_+3A_lowerlimit">lowerLimit</code></td>
<td>
<p>numeric, returned numbers will be above this value</p>
</td></tr>
<tr><td><code id="nDronesPoisson_+3A_queentrait">queenTrait</code></td>
<td>
<p>numeric (column position) or character (column name), trait
that represents queen's effect on the colony phenotype (defined in
<code><a href="#topic+SimParamBee">SimParamBee</a></code> - see examples); if <code>0</code> then this effect is 0</p>
</td></tr>
<tr><td><code id="nDronesPoisson_+3A_workerstrait">workersTrait</code></td>
<td>
<p>numeric (column position) or character (column name), trait
that represents workers's effect on the colony phenotype (defined in
<code><a href="#topic+SimParamBee">SimParamBee</a></code> - see examples); if <code>0</code> then this effect is 0</p>
</td></tr>
<tr><td><code id="nDronesPoisson_+3A_checkproduction">checkProduction</code></td>
<td>
<p>logical, does the phenotype depend on the production
status of colony; if yes and production is not <code>TRUE</code>, the result is
above <code>lowerLimit</code></p>
</td></tr>
<tr><td><code id="nDronesPoisson_+3A_...">...</code></td>
<td>
<p>other arguments of <code><a href="#topic+mapCasteToColonyPheno">mapCasteToColonyPheno</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nDronesPoisson</code> samples from a Poisson distribution with a
given average, which can return a value 0.
</p>
<p><code>nDronesTruncPoisson</code> samples from a zero truncated Poisson
distribution.
</p>
<p><code>nDronesColonyPhenotype</code> returns a number (above <code>lowerLimit</code>) as
a function of colony phenotype, say queen's fecundity. Colony phenotype is
provided by <code><a href="#topic+mapCasteToColonyPheno">mapCasteToColonyPheno</a></code>. You need to set up
traits influencing the colony phenotype and their parameters (mean and
variances) via <code><a href="#topic+SimParamBee">SimParamBee</a></code> (see examples).
</p>
<p>When <code>x</code> is <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, only <code>workersTrait</code> is not
used, that is, only <code>queenTrait</code> is used.
</p>


<h3>Value</h3>

<p>numeric, number of drones
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>nDronesTruncPoisson()</code>: Sample a non-zero number of drones
</p>
</li>
<li> <p><code>nDronesColonyPhenotype()</code>: Sample a non-zero number of drones based on
colony phenotype, say queen's fecundity
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+SimParamBee">SimParamBee</a></code> field <code>nDrones</code> and
<code>vignette(topic = "QuantitativeGenetics", package = "SIMplyBee")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nDronesPoisson()
nDronesPoisson()
n &lt;- nDronesPoisson(n = 1000)
hist(n, breaks = seq(from = min(n), to = max(n)), xlim = c(0, 200))
table(n)

nDronesTruncPoisson()
nDronesTruncPoisson()
n &lt;- nDronesTruncPoisson(n = 1000)
hist(n, breaks = seq(from = min(n), to = max(n)), xlim = c(0, 200))
table(n)

# Example for nDronesColonyPhenotype()
founderGenomes &lt;- quickHaplo(nInd = 3, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
average &lt;- 100
h2 &lt;- 0.1
SP$addTraitA(nQtlPerChr = 100, mean = average, var = average * h2)
SP$setVarE(varE = average * (1 - h2))
basePop &lt;- createVirginQueens(founderGenomes)
drones &lt;- createDrones(x = basePop[1], nInd = 50)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 2, nDrones = 15)
colony1 &lt;- createColony(x = basePop[2])
colony2 &lt;- createColony(x = basePop[3])
colony1 &lt;- cross(colony1, drones = droneGroups[[1]])
colony2 &lt;- cross(colony2, drones = droneGroups[[2]])
colony1@queen@pheno
colony2@queen@pheno
createDrones(colony1, nInd = nDronesColonyPhenotype)
createDrones(colony2, nInd = nDronesColonyPhenotype)
</code></pre>

<hr>
<h2 id='nFathersPoisson'>Sample a number of fathers</h2><span id='topic+nFathersPoisson'></span><span id='topic+nFathersTruncPoisson'></span>

<h3>Description</h3>

<p>Sample a number of fathers - use when <code>nFathers = NULL</code>
(see <code><a href="#topic+SimParamBee">SimParamBee</a>$nFathers</code>).
</p>
<p>This is just an example. You can provide your own functions that satisfy
your needs!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nFathersPoisson(n = 1, average = 15)

nFathersTruncPoisson(n = 1, average = 15, lowerLimit = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nFathersPoisson_+3A_n">n</code></td>
<td>
<p>integer, number of samples</p>
</td></tr>
<tr><td><code id="nFathersPoisson_+3A_average">average</code></td>
<td>
<p>numeric, average number of fathers</p>
</td></tr>
<tr><td><code id="nFathersPoisson_+3A_lowerlimit">lowerLimit</code></td>
<td>
<p>numeric, returned numbers will be above this value</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nFathersPoisson</code> samples from a Poisson distribution, which
can return a value 0 (that would mean a failed queen mating).
</p>
<p><code>nFathersTruncPoisson</code> samples from a truncated Poisson distribution
(truncated at zero) to avoid failed matings.
</p>


<h3>Value</h3>

<p>numeric, number of fathers
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>nFathersTruncPoisson()</code>: Sample a non-zero number of fathers
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+SimParamBee">SimParamBee</a></code> field <code>nFathers</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nFathersPoisson()
nFathersPoisson()
n &lt;- nFathersPoisson(n = 1000)
hist(n, breaks = seq(from = min(n), to = max(n)), xlim = c(0, 40))
table(n)

nFathersTruncPoisson()
nFathersTruncPoisson()
n &lt;- nFathersTruncPoisson(n = 1000)
hist(n, breaks = seq(from = min(n), to = max(n)), xlim = c(0, 40))
table(n)
</code></pre>

<hr>
<h2 id='nVirginQueensPoisson'>Sample a number of virgin queens</h2><span id='topic+nVirginQueensPoisson'></span><span id='topic+nVirginQueensTruncPoisson'></span><span id='topic+nVirginQueensColonyPhenotype'></span>

<h3>Description</h3>

<p>Sample a number of virgin queens - used when
<code>nFathers = NULL</code> (see <code><a href="#topic+SimParamBee">SimParamBee</a>$nVirginQueens</code>).
</p>
<p>This is just an example. You can provide your own functions that satisfy
your needs!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nVirginQueensPoisson(colony, n = 1, average = 10)

nVirginQueensTruncPoisson(colony, n = 1, average = 10, lowerLimit = 0)

nVirginQueensColonyPhenotype(
  colony,
  queenTrait = 1,
  workersTrait = 2,
  checkProduction = FALSE,
  lowerLimit = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nVirginQueensPoisson_+3A_colony">colony</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code></p>
</td></tr>
<tr><td><code id="nVirginQueensPoisson_+3A_n">n</code></td>
<td>
<p>integer, number of samples</p>
</td></tr>
<tr><td><code id="nVirginQueensPoisson_+3A_average">average</code></td>
<td>
<p>numeric, average number of virgin queens</p>
</td></tr>
<tr><td><code id="nVirginQueensPoisson_+3A_lowerlimit">lowerLimit</code></td>
<td>
<p>numeric, returned numbers will be above this value</p>
</td></tr>
<tr><td><code id="nVirginQueensPoisson_+3A_queentrait">queenTrait</code></td>
<td>
<p>numeric (column position) or character (column name), trait
that represents queen's effect on the colony phenotype (defined in
<code><a href="#topic+SimParamBee">SimParamBee</a></code> - see examples); if <code>NULL</code> then this effect is 0</p>
</td></tr>
<tr><td><code id="nVirginQueensPoisson_+3A_workerstrait">workersTrait</code></td>
<td>
<p>numeric (column position) or character (column name), trait
that represents workers's effect on the colony phenotype (defined in
<code><a href="#topic+SimParamBee">SimParamBee</a></code> - see examples); if <code>NULL</code> then this effect is 0</p>
</td></tr>
<tr><td><code id="nVirginQueensPoisson_+3A_checkproduction">checkProduction</code></td>
<td>
<p>logical, does the phenotype depend on the production
status of colony; if yes and production is not <code>TRUE</code>, the result is
above <code>lowerLimit</code></p>
</td></tr>
<tr><td><code id="nVirginQueensPoisson_+3A_...">...</code></td>
<td>
<p>other arguments of <code><a href="#topic+mapCasteToColonyPheno">mapCasteToColonyPheno</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nVirginQueensPoisson</code> samples from a Poisson distribution,
which can return a value 0 (that would mean a colony will fail to raise a
single virgin queen after the queen swarms or dies).
</p>
<p><code>nVirginQueensTruncPoisson</code> samples from a truncated Poisson
distribution (truncated at zero) to avoid failure.
</p>
<p><code>nVirginQueensColonyPhenotype</code> returns a number (above
<code>lowerLimit</code>) as a function of colony phenotype, say swarming
tendency. Colony phenotype is provided by
<code><a href="#topic+mapCasteToColonyPheno">mapCasteToColonyPheno</a></code>. You need to set up traits
influencing the colony phenotype and their parameters (mean and variances)
via <code><a href="#topic+SimParamBee">SimParamBee</a></code> (see examples).
</p>


<h3>Value</h3>

<p>numeric, number of virgin queens
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>nVirginQueensTruncPoisson()</code>: Sample a non-zero number of virgin queens
</p>
</li>
<li> <p><code>nVirginQueensColonyPhenotype()</code>: Sample a non-zero number of virgin queens
based on colony's phenotype, say, swarming tendency
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+SimParamBee">SimParamBee</a></code> field <code>nVirginQueens</code> and
<code>vignette(topic = "QuantitativeGenetics", package = "SIMplyBee")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nVirginQueensPoisson()
nVirginQueensPoisson()
n &lt;- nVirginQueensPoisson(n = 1000)
hist(n, breaks = seq(from = min(n), to = max(n)), xlim = c(0, 30))
table(n)

nVirginQueensTruncPoisson()
nVirginQueensTruncPoisson()
n &lt;- nVirginQueensTruncPoisson(n = 1000)
hist(n, breaks = seq(from = min(n), to = max(n)), xlim = c(0, 30))
table(n)

# Example for nVirginQueensColonyPhenotype()
founderGenomes &lt;- quickHaplo(nInd = 3, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
# Setting trait scale such that mean is 10 split into queen and workers effects
meanP &lt;- c(5, 5 / SP$nWorkers)
# setup variances such that the total phenotype variance will match the mean
varA &lt;- c(3 / 2, 3 / 2 / SP$nWorkers)
corA &lt;- matrix(data = c(
  1.0, -0.5,
  -0.5, 1.0
), nrow = 2, byrow = TRUE)
varE &lt;- c(7 / 2, 7 / 2 / SP$nWorkers)
varA / (varA + varE)
varP &lt;- varA + varE
varP[1] + varP[2] * SP$nWorkers
SP$addTraitA(nQtlPerChr = 100, mean = meanP, var = varA, corA = corA)
SP$setVarE(varE = varE)
basePop &lt;- createVirginQueens(founderGenomes)
drones &lt;- createDrones(x = basePop[1], nInd = 50)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 2, nDrones = 15)
colony1 &lt;- createColony(x = basePop[2])
colony2 &lt;- createColony(x = basePop[3])
colony1 &lt;- cross(colony1, drones = droneGroups[[1]])
colony2 &lt;- cross(colony2, drones = droneGroups[[2]])
colony1 &lt;- buildUp(colony1)
colony2 &lt;- buildUp(colony2)
nVirginQueensColonyPhenotype(colony1)
nVirginQueensColonyPhenotype(colony2)
</code></pre>

<hr>
<h2 id='nWorkersPoisson'>Sample a number of workers</h2><span id='topic+nWorkersPoisson'></span><span id='topic+nWorkersTruncPoisson'></span><span id='topic+nWorkersColonyPhenotype'></span>

<h3>Description</h3>

<p>Sample a number of workers - used when <code>nInd = NULL</code>
(see <code><a href="#topic+SimParamBee">SimParamBee</a>$nWorkers</code>).
</p>
<p>This is just an example. You can provide your own functions that satisfy
your needs!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nWorkersPoisson(colony, n = 1, average = 100)

nWorkersTruncPoisson(colony, n = 1, average = 100, lowerLimit = 0)

nWorkersColonyPhenotype(
  colony,
  queenTrait = 1,
  workersTrait = NULL,
  checkProduction = FALSE,
  lowerLimit = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nWorkersPoisson_+3A_colony">colony</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code></p>
</td></tr>
<tr><td><code id="nWorkersPoisson_+3A_n">n</code></td>
<td>
<p>integer, number of samples</p>
</td></tr>
<tr><td><code id="nWorkersPoisson_+3A_average">average</code></td>
<td>
<p>numeric, average number of workers</p>
</td></tr>
<tr><td><code id="nWorkersPoisson_+3A_lowerlimit">lowerLimit</code></td>
<td>
<p>numeric, returned numbers will be above this value</p>
</td></tr>
<tr><td><code id="nWorkersPoisson_+3A_queentrait">queenTrait</code></td>
<td>
<p>numeric (column position) or character (column name), trait
that represents queen's effect on the colony phenotype (defined in
<code><a href="#topic+SimParamBee">SimParamBee</a></code> - see examples); if <code>0</code> then this effect is 0</p>
</td></tr>
<tr><td><code id="nWorkersPoisson_+3A_workerstrait">workersTrait</code></td>
<td>
<p>numeric (column position) or character (column name), trait
that represents workers's effect on the colony phenotype (defined in
<code><a href="#topic+SimParamBee">SimParamBee</a></code> - see examples); if <code>0</code> then this effect is 0</p>
</td></tr>
<tr><td><code id="nWorkersPoisson_+3A_checkproduction">checkProduction</code></td>
<td>
<p>logical, does the phenotype depend on the production
status of colony; if yes and production is not <code>TRUE</code>, the result is
above <code>lowerLimit</code></p>
</td></tr>
<tr><td><code id="nWorkersPoisson_+3A_...">...</code></td>
<td>
<p>other arguments of <code><a href="#topic+mapCasteToColonyPheno">mapCasteToColonyPheno</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nWorkersPoisson</code> samples from a Poisson distribution with a
given average, which can return a value 0. <code>nDronesTruncPoisson</code>
samples from a zero truncated Poisson distribution.
</p>
<p><code>nWorkersColonyPhenotype</code> returns a number (above <code>lowerLimit</code>)
as a function of colony phenotype, say queen's fecundity. Colony phenotype
is provided by <code><a href="#topic+mapCasteToColonyPheno">mapCasteToColonyPheno</a></code>. You need to set up
traits influencing the colony phenotype and their parameters (mean and
variances) via <code><a href="#topic+SimParamBee">SimParamBee</a></code> (see examples).
</p>


<h3>Value</h3>

<p>numeric, number of workers
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>nWorkersTruncPoisson()</code>: Sample a non-zero number of workers
</p>
</li>
<li> <p><code>nWorkersColonyPhenotype()</code>: Sample a non-zero number of workers based on
colony phenotype, say queen's fecundity
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+SimParamBee">SimParamBee</a></code> field <code>nWorkers</code> and
<code>vignette(topic = "QuantitativeGenetics", package = "SIMplyBee")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nWorkersPoisson()
nWorkersPoisson()
n &lt;- nWorkersPoisson(n = 1000)
hist(n, breaks = seq(from = min(n), to = max(n)), xlim = c(0, 200))
table(n)

nWorkersTruncPoisson()
nWorkersTruncPoisson()
n &lt;- nWorkersTruncPoisson(n = 1000)
hist(n, breaks = seq(from = min(n), to = max(n)), xlim = c(0, 200))
table(n)

# Example for nWorkersColonyPhenotype()
founderGenomes &lt;- quickHaplo(nInd = 3, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
average &lt;- 100
h2 &lt;- 0.1
SP$addTraitA(nQtlPerChr = 100, mean = average, var = average * h2)
SP$setVarE(varE = average * (1 - h2))
basePop &lt;- createVirginQueens(founderGenomes)
drones &lt;- createDrones(x = basePop[1], nInd = 50)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 2, nDrones = 15)
colony1 &lt;- createColony(x = basePop[2])
colony2 &lt;- createColony(x = basePop[3])
colony1 &lt;- cross(colony1, drones = droneGroups[[1]])
colony2 &lt;- cross(colony2, drones = droneGroups[[2]])
colony1@queen@pheno
colony2@queen@pheno
createWorkers(colony1, nInd = nWorkersColonyPhenotype)
createWorkers(colony2, nInd = nWorkersColonyPhenotype)
</code></pre>

<hr>
<h2 id='pullCastePop'>Pull individuals from a caste in a colony</h2><span id='topic+pullCastePop'></span><span id='topic+pullQueen'></span><span id='topic+pullWorkers'></span><span id='topic+pullDrones'></span><span id='topic+pullVirginQueens'></span>

<h3>Description</h3>

<p>Level 1 function that pulls individuals from a caste in a
colony. These individuals are removed from the colony (compared to
<code><a href="#topic+getCaste">getCaste</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pullCastePop(
  x,
  caste,
  nInd = NULL,
  use = "rand",
  removeFathers = TRUE,
  collapse = FALSE
)

pullQueen(x, collapse = FALSE)

pullWorkers(x, nInd = NULL, use = "rand", collapse = FALSE)

pullDrones(
  x,
  nInd = NULL,
  use = "rand",
  removeFathers = TRUE,
  collapse = FALSE
)

pullVirginQueens(x, nInd = NULL, use = "rand", collapse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pullCastePop_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="pullCastePop_+3A_caste">caste</code></td>
<td>
<p>character, &quot;queen&quot;, &quot;workers&quot;, &quot;drones&quot;, or &quot;virginQueens&quot;</p>
</td></tr>
<tr><td><code id="pullCastePop_+3A_nind">nInd</code></td>
<td>
<p>numeric, number of individuals to pull, if <code>NULL</code> all
individuals are pulled. If input is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>,
the input could also be a vector of the same length as the number of colonies. If
a single value is provided, the same value will be applied to all the colonies.</p>
</td></tr>
<tr><td><code id="pullCastePop_+3A_use">use</code></td>
<td>
<p>character, all options provided by <code><a href="AlphaSimR.html#topic+selectInd">selectInd</a></code></p>
</td></tr>
<tr><td><code id="pullCastePop_+3A_removefathers">removeFathers</code></td>
<td>
<p>logical, removes <code>drones</code> that have already mated;
set to <code>FALSE</code> if you would like to get drones for mating with multiple
virgin queens, say via insemination</p>
</td></tr>
<tr><td><code id="pullCastePop_+3A_collapse">collapse</code></td>
<td>
<p>logical, whether to return a single merged population
for the pulled individuals (does not affect the remnant colonies)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> and <code><a href="#topic+Colony-class">Colony-class</a></code>
when <code>x</code> is <code><a href="#topic+Colony-class">Colony-class</a></code> and list of (a list of
<code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> named by colony id) and
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code> when <code>x</code> is
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>pullQueen()</code>: Pull queen from a colony
</p>
</li>
<li> <p><code>pullWorkers()</code>: Pull workers from a colony
</p>
</li>
<li> <p><code>pullDrones()</code>: Pull drones from a colony
</p>
</li>
<li> <p><code>pullVirginQueens()</code>: Pull virgin queens from a colony
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+pullQueen">pullQueen</a></code>, <code><a href="#topic+pullVirginQueens">pullVirginQueens</a></code>,
<code><a href="#topic+pullWorkers">pullWorkers</a></code>, and <code><a href="#topic+pullDrones">pullDrones</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 100, nDrones = 10, exact = TRUE)
colony &lt;- addVirginQueens(x = colony, nInd = 3)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 100, nDrones = 10, exact = TRUE)
apiary &lt;- addVirginQueens(x = apiary, nInd = 3)

# pullCastePop on Colony class
# We can't pull the queen and leave the colony queenless
pullCastePop(colony, caste = "virginQueens")
pullCastePop(colony, caste = "virginQueens", nInd = 2)
# Or use aliases
pullVirginQueens(colony)
pullVirginQueens(colony, nInd = 2)
# Same aliases exist for all the castes!!!

# pullCastePop on MultiColony class - same behaviour as for the Colony!
pullCastePop(apiary, caste = "workers")
# Or pull out unequal number of workers from colonies
pullCastePop(apiary, caste = "workers", nInd = c(10, 20))
pullWorkers(apiary)
nWorkers(apiary)
nWorkers(pullWorkers(apiary)$remnant)


# Merge all the pulled populations into a single population
pullCastePop(apiary, caste = "queen", collapse = TRUE)
pullCastePop(apiary, caste = "virginQueens", collapse = TRUE)
</code></pre>

<hr>
<h2 id='pullColonies'>Pull out some colonies from the MultiColony object</h2><span id='topic+pullColonies'></span>

<h3>Description</h3>

<p>Level 3 function that pulls out some colonies
from the MultiColony based on colony ID or random selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pullColonies(
  multicolony,
  ID = NULL,
  n = NULL,
  p = NULL,
  by = NULL,
  pullTop = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pullColonies_+3A_multicolony">multicolony</code></td>
<td>
<p><code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="pullColonies_+3A_id">ID</code></td>
<td>
<p>character or numeric, ID of a colony (one or more) to be pulled
out</p>
</td></tr>
<tr><td><code id="pullColonies_+3A_n">n</code></td>
<td>
<p>numeric, number of colonies to select</p>
</td></tr>
<tr><td><code id="pullColonies_+3A_p">p</code></td>
<td>
<p>numeric, percentage of colonies pulled out (takes precedence
over <code>n</code>)</p>
</td></tr>
<tr><td><code id="pullColonies_+3A_by">by</code></td>
<td>
<p>matrix, matrix of values to select by with names being
colony IDs (can be obtained with <code><a href="#topic+calcColonyValue">calcColonyValue</a></code>.
If NULL, the colonies are pulled at random.
This parameter is used in combination
with <code>n</code> or <code>p</code> to determine the number of pulled colonies, and
<code>pullTop</code> to determine whether to pull the best or the worst colonies.</p>
</td></tr>
<tr><td><code id="pullColonies_+3A_pulltop">pullTop</code></td>
<td>
<p>logical, pull highest (lowest) values if <code>TRUE</code> (<code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with two <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>, the <code>pulled</code>
and the <code>remnant</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 5, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
mean &lt;- c(10, 10 / SP$nWorkers)
varA &lt;- c(1, 1 / SP$nWorkers)
corA &lt;- matrix(data = c(
  1.0, -0.5,
  -0.5, 1.0
), nrow = 2, byrow = TRUE)
varE &lt;- c(3, 3 / SP$nWorkers)
varA / (varA + varE)
SP$addTraitADE(nQtlPerChr = 100,
               mean = mean,
               var = varA, corA = corA,
               meanDD = 0.1, varDD = 0.2, corD = corA,
               relAA = 0.1, corAA = corA)
SP$setVarE(varE = varE)

basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1:4], nInd = 100)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = 10)
apiary &lt;- createMultiColony(basePop[2:5], n = 4)
apiary &lt;- cross(apiary, drones = droneGroups[1:4])
apiary &lt;- buildUp(apiary)
getId(apiary)

tmp &lt;- pullColonies(apiary, ID = c(1, 2))
getId(tmp$pulled)
getId(tmp$remnant)

tmp &lt;- pullColonies(apiary, ID = c("3", "4"))
getId(tmp$pulled)
getId(tmp$remnant)

tmp &lt;- pullColonies(apiary, n = 2)
getId(tmp$pulled)
getId(tmp$remnant)

tmp &lt;- pullColonies(apiary, p = 0.75)
getId(tmp$pulled)
getId(tmp$remnant)

# How to pull out colonies based on colony values?
colonyGv &lt;- calcColonyGv(apiary)
pullColonies(apiary, n = 1, by = colonyGv)
</code></pre>

<hr>
<h2 id='pullDroneGroupsFromDCA'>Pulls drone groups from a Drone Congregation Area (DCA)</h2><span id='topic+pullDroneGroupsFromDCA'></span>

<h3>Description</h3>

<p>Level 1 function that pulls drone groups from a Drone
Congregation Area (DCA) to use them later in mating. Within the function
drones are pulled (removed) from the DCA to reflect the fact that drones
die after mating, so they can't be present in the DCA anymore. Be careful
what you do with the DCA object outside function to avoid drone &quot;copies&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pullDroneGroupsFromDCA(DCA, n, nDrones = NULL, simParamBee = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pullDroneGroupsFromDCA_+3A_dca">DCA</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, population of drones</p>
</td></tr>
<tr><td><code id="pullDroneGroupsFromDCA_+3A_n">n</code></td>
<td>
<p>integer, number of drone groups to be created</p>
</td></tr>
<tr><td><code id="pullDroneGroupsFromDCA_+3A_ndrones">nDrones</code></td>
<td>
<p>numeric of function, number of drones that a virgin queen
mates with; if <code>NULL</code> then <code><a href="#topic+SimParamBee">SimParamBee</a>$nFathers</code> is used</p>
</td></tr>
<tr><td><code id="pullDroneGroupsFromDCA_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
<tr><td><code id="pullDroneGroupsFromDCA_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>nDrones</code> when this argument is a function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- addDrones(colony, nInd = 100)

# Create colony DCA
DCA &lt;- createDCA(colony)
pullDroneGroupsFromDCA(DCA, n = 4, nDrones = 5)
pullDroneGroupsFromDCA(DCA, n = 5, nDrones = nFathersPoisson)

</code></pre>

<hr>
<h2 id='pullInd'>Pull individuals from a population</h2><span id='topic+pullInd'></span>

<h3>Description</h3>

<p>Level 1 function that pulls individuals from a population and
update the population (these individuals don't stay in a population).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pullInd(pop, nInd = NULL, use = "rand")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pullInd_+3A_pop">pop</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="pullInd_+3A_nind">nInd</code></td>
<td>
<p>numeric, number of individuals to pull, if <code>NULL</code> pull all
individuals</p>
</td></tr>
<tr><td><code id="pullInd_+3A_use">use</code></td>
<td>
<p>character, all options provided by <code><a href="AlphaSimR.html#topic+selectInd">selectInd</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with a node <code>pulled</code> holding <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> of
pulled individuals and a node <code>remnant)</code> holding <code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>
of remaining individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 3, nChr = 1, segSites = 100)
SP &lt;- SimParam$new(founderGenomes)
basePop &lt;- newPop(founderGenomes)

pullInd(basePop, nInd = 2)
pullInd(basePop, nInd = 3)
pullInd(basePop)
</code></pre>

<hr>
<h2 id='reduceDroneGeno'>Reduce drones' genotype to a single haplotype</h2><span id='topic+reduceDroneGeno'></span>

<h3>Description</h3>

<p>Level 0 function that reduces drone's genotype to a single
haplotype, because we internally simulate them as diploid (doubled
haploid). This is an internal utility function that you likely don't need
to use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduceDroneGeno(geno, pop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduceDroneGeno_+3A_geno">geno</code></td>
<td>
<p><code><a href="methods.html#topic+matrix-class">matrix-class</a></code></p>
</td></tr>
<tr><td><code id="reduceDroneGeno_+3A_pop">pop</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with genotype as one haplotype per drone instead of two - the
order of individuals and the number of rows stays the same!
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 3, nChr = 1, segSites = 5)
SP &lt;- SimParamBee$new(founderGenomes, csdChr = NULL)
basePop &lt;- createVirginQueens(founderGenomes)
drones &lt;- createDrones(x = basePop[1], nInd = 2)

(tmp &lt;- getSegSiteGeno(drones))
reduceDroneGeno(geno = tmp, pop = drones)

(tmp &lt;- getSegSiteGeno(c(basePop, drones)))
reduceDroneGeno(geno = tmp, pop = c(basePop, drones))
</code></pre>

<hr>
<h2 id='reduceDroneHaplo'>Reduce drone's double haplotypes to a single haplotype</h2><span id='topic+reduceDroneHaplo'></span>

<h3>Description</h3>

<p>Level 0 function that returns one haplotype of drones, because
we internally simulate them as diploid (doubled haploid). This is an
internal utility function that you likely don't need to use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduceDroneHaplo(haplo, pop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduceDroneHaplo_+3A_haplo">haplo</code></td>
<td>
<p><code><a href="methods.html#topic+matrix-class">matrix-class</a></code></p>
</td></tr>
<tr><td><code id="reduceDroneHaplo_+3A_pop">pop</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>While this function is meant to work on male (drone) haplotypes, we
handle cases where the <code>haplo</code> matrix contains male and female
haplotypes, which is why you need to provide <code>pop</code>. We only reduce
haplotypes for males though.
</p>


<h3>Value</h3>

<p>matrix with one haplotype per drone instead of two - the order of
individuals stays the same, but there will be less rows!
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 3, nChr = 1, segSites = 5)
SP &lt;- SimParamBee$new(founderGenomes, csdChr = NULL)
basePop &lt;- createVirginQueens(founderGenomes)
drones &lt;- createDrones(x = basePop[1], nInd = 2)

(tmp &lt;- getSegSiteHaplo(drones))
reduceDroneHaplo(haplo = tmp, pop = drones)

(tmp &lt;- getSegSiteHaplo(c(basePop, drones)))
reduceDroneHaplo(haplo = tmp, pop = c(basePop, drones))
</code></pre>

<hr>
<h2 id='removeCastePop'>Remove a proportion of caste individuals from a colony</h2><span id='topic+removeCastePop'></span><span id='topic+removeQueen'></span><span id='topic+removeWorkers'></span><span id='topic+removeDrones'></span><span id='topic+removeVirginQueens'></span>

<h3>Description</h3>

<p>Level 2 function that removes a proportion of virgin queens of
a Colony or MultiColony object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeCastePop(
  x,
  caste = NULL,
  p = 1,
  use = "rand",
  addVirginQueens = FALSE,
  nVirginQueens = NULL,
  year = NULL,
  simParamBee = NULL
)

removeQueen(
  x,
  addVirginQueens = FALSE,
  nVirginQueens = NULL,
  year = NULL,
  simParamBee = NULL
)

removeWorkers(x, p = 1, use = "rand")

removeDrones(x, p = 1, use = "rand")

removeVirginQueens(x, p = 1, use = "rand")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeCastePop_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="removeCastePop_+3A_caste">caste</code></td>
<td>
<p>character, &quot;queen&quot;, &quot;workers&quot;, &quot;drones&quot;, or &quot;virginQueens&quot;</p>
</td></tr>
<tr><td><code id="removeCastePop_+3A_p">p</code></td>
<td>
<p>numeric, proportion to be removed; if input is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>,
the input could also be a vector of the same length as the number of colonies. If
a single value is provided, the same value will be applied to all the colonies</p>
</td></tr>
<tr><td><code id="removeCastePop_+3A_use">use</code></td>
<td>
<p>character, all the options provided by <code><a href="AlphaSimR.html#topic+selectInd">selectInd</a></code> -
guides selection of virgins queens that will stay when <code>p &lt; 1</code></p>
</td></tr>
<tr><td><code id="removeCastePop_+3A_addvirginqueens">addVirginQueens</code></td>
<td>
<p>logical, whether virgin queens should be added; only
used when removing the queen from the colony</p>
</td></tr>
<tr><td><code id="removeCastePop_+3A_nvirginqueens">nVirginQueens</code></td>
<td>
<p>integer, the number of virgin queens to be created in the
colony; only used when removing the queen from the colony. If <code>0</code>, no virgin
queens are added; If <code>NULL</code>, the value from <code>simParamBee$nVirginQueens</code>
is used</p>
</td></tr>
<tr><td><code id="removeCastePop_+3A_year">year</code></td>
<td>
<p>numeric, only relevant when adding virgin queens - year of birth for virgin queens</p>
</td></tr>
<tr><td><code id="removeCastePop_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code> without virgin queens
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>removeQueen()</code>: Remove queen from a colony
</p>
</li>
<li> <p><code>removeWorkers()</code>: Remove workers from a colony
</p>
</li>
<li> <p><code>removeDrones()</code>: Remove workers from a colony
</p>
</li>
<li> <p><code>removeVirginQueens()</code>: Remove virgin queens from a colony
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 5, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 100)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 5, nDrones = nFathersPoisson)

# Create and cross Colony and MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(colony)
apiary &lt;- createMultiColony(basePop[4:5], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[3:4])
apiary &lt;- buildUp(apiary)

# Remove workers
nWorkers(colony)
colony &lt;- removeCastePop(colony, caste = "workers", p = 0.3)
# or alias:
colony &lt;- removeWorkers(colony, p = 0.3)
# Same aliases exist for all the castes!!

nWorkers(apiary)
apiary &lt;- removeCastePop(apiary, caste = "workers", p = 0.3)
nWorkers(apiary)

# Remove different proportions
apiary &lt;- buildUp(apiary)
nWorkers(apiary)
nWorkers(removeWorkers(apiary, p = c(0.1, 0.5)))
</code></pre>

<hr>
<h2 id='removeColonies'>Remove some colonies from the MultiColony object</h2><span id='topic+removeColonies'></span>

<h3>Description</h3>

<p>Level 3 function that removes some colonies
from the MultiColony object based on their ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeColonies(
  multicolony,
  ID = NULL,
  n = NULL,
  p = NULL,
  by = NULL,
  removeTop = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeColonies_+3A_multicolony">multicolony</code></td>
<td>
<p><code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="removeColonies_+3A_id">ID</code></td>
<td>
<p>character or numeric, ID of a colony (one or more) to be
removed</p>
</td></tr>
<tr><td><code id="removeColonies_+3A_n">n</code></td>
<td>
<p>numeric, number of colonies to remove</p>
</td></tr>
<tr><td><code id="removeColonies_+3A_p">p</code></td>
<td>
<p>numeric, percentage of colonies removed (takes precedence
over <code>n</code>)</p>
</td></tr>
<tr><td><code id="removeColonies_+3A_by">by</code></td>
<td>
<p>matrix, matrix of values to select by with names being
colony IDs (can be obtained with <code><a href="#topic+calcColonyValue">calcColonyValue</a></code>.
If NULL, the colonies are removed at random.
This parameter is used in combination
with <code>n</code> or <code>p</code> to determine the number of removed colonies, and
<code>removeTop</code> to determine whether to remove the best or the worst colonies.</p>
</td></tr>
<tr><td><code id="removeColonies_+3A_removetop">removeTop</code></td>
<td>
<p>logical, remove highest (lowest) values if <code>TRUE</code> (<code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with some colonies removed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 5, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
mean &lt;- c(10, 10 / SP$nWorkers)
varA &lt;- c(1, 1 / SP$nWorkers)
corA &lt;- matrix(data = c(
  1.0, -0.5,
  -0.5, 1.0
), nrow = 2, byrow = TRUE)
varE &lt;- c(3, 3 / SP$nWorkers)
varA / (varA + varE)
SP$addTraitADE(nQtlPerChr = 100,
               mean = mean,
               var = varA, corA = corA,
               meanDD = 0.1, varDD = 0.2, corD = corA,
               relAA = 0.1, corAA = corA)
SP$setVarE(varE = varE)

basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1:4], nInd = 100)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = 10)
apiary &lt;- createMultiColony(basePop[2:5], n = 4)
apiary &lt;- cross(apiary, drones = droneGroups[1:4])
apiary &lt;- buildUp(apiary)
getId(apiary)

getId(removeColonies(apiary, ID = 1))
getId(removeColonies(apiary, ID = c("3", "4")))

nColonies(apiary)
apiary &lt;- removeColonies(apiary, ID = "2")
nColonies(apiary)

# How to remove colonies based on colony values?
# Obtain colony phenotype
colonyPheno &lt;- calcColonyPheno(apiary)
# Remove the worst colony
removeColonies(apiary, n = 1, by = colonyPheno)

</code></pre>

<hr>
<h2 id='replaceCastePop'>Replace a proportion of caste individuals with new ones</h2><span id='topic+replaceCastePop'></span><span id='topic+replaceWorkers'></span><span id='topic+replaceDrones'></span><span id='topic+replaceVirginQueens'></span>

<h3>Description</h3>

<p>Level 2 function that replaces a proportion of caste individuals
with new individuals from a Colony or MultiColony object. Useful after
events like season change, swarming, supersedure, etc. due to the short life span
honeybees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replaceCastePop(
  x,
  caste = NULL,
  p = 1,
  use = "rand",
  exact = TRUE,
  year = NULL,
  simParamBee = NULL
)

replaceWorkers(x, p = 1, use = "rand", exact = TRUE, simParamBee = NULL)

replaceDrones(x, p = 1, use = "rand", simParamBee = NULL)

replaceVirginQueens(x, p = 1, use = "rand", simParamBee = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replaceCastePop_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="replaceCastePop_+3A_caste">caste</code></td>
<td>
<p>character, &quot;workers&quot;, &quot;drones&quot;, or &quot;virginQueens&quot;</p>
</td></tr>
<tr><td><code id="replaceCastePop_+3A_p">p</code></td>
<td>
<p>numeric, proportion of caste individuals to be replaced with new ones;
if input is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>,
the input could also be a vector of the same length as the number of colonies. If
a single value is provided, the same value will be applied to all the colonies</p>
</td></tr>
<tr><td><code id="replaceCastePop_+3A_use">use</code></td>
<td>
<p>character, all the options provided by <code><a href="AlphaSimR.html#topic+selectInd">selectInd</a></code> -
guides selection of caste individuals that stay when <code>p &lt; 1</code></p>
</td></tr>
<tr><td><code id="replaceCastePop_+3A_exact">exact</code></td>
<td>
<p>logical, only relevant when adding workers - if the csd locus is turned
on and exact is <code>TRUE</code>, we replace the exact specified number of viable workers
(heterozygous at the csd locus). You probably want this set to TRUE since you want to
replace with the same number of workers.</p>
</td></tr>
<tr><td><code id="replaceCastePop_+3A_year">year</code></td>
<td>
<p>numeric, only relevant when replacing virgin queens,
year of birth for virgin queens</p>
</td></tr>
<tr><td><code id="replaceCastePop_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+Colony-class">Colony-class</a></code> or  or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with
replaced virgin queens
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>replaceWorkers()</code>: Replaces some workers in a colony
</p>
</li>
<li> <p><code>replaceDrones()</code>: Replaces some drones in a colony
</p>
</li>
<li> <p><code>replaceVirginQueens()</code>: Replaces some virgin queens in a colony
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 5, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 100)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 5, nDrones = nFathersPoisson)

# Create and cross Colony and MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
apiary &lt;- createMultiColony(basePop[4:5], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[3:4])

# Add individuals
colony &lt;- buildUp(colony, nWorkers = 5, nDrones = 2)
apiary &lt;- buildUp(apiary, nWorkers = 5, nDrones = 2)

# Replace workers in a colony
getCasteId(colony, caste = "workers")
colony &lt;- replaceCastePop(colony, caste = "workers", p = 0.5)
# You can also use an alias
replaceWorkers(colony, p = 0.5)
# Same aliases exist for all the castes!!!
getCasteId(colony, caste = "workers")

getCasteId(apiary, caste="workers")
apiary &lt;- replaceWorkers(apiary, p = 0.5)
getCasteId(apiary, caste="workers")
</code></pre>

<hr>
<h2 id='reQueen'>Re-queen</h2><span id='topic+reQueen'></span>

<h3>Description</h3>

<p>Level 2 function that re-queens a Colony or
MultiColony object by adding a mated or a virgin queen, removing the
previous queen, and changing the colony id to the new mated queen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reQueen(x, queen, removeVirginQueens = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reQueen_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="reQueen_+3A_queen">queen</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> with one individual that will be the
queen of the colony; if she is not mated, she will be added as a virgin
queen that will have to be mated later; test will be run if the individual
<code><a href="#topic+isVirginQueen">isVirginQueen</a></code> or <code><a href="#topic+isQueen">isQueen</a></code></p>
</td></tr>
<tr><td><code id="reQueen_+3A_removevirginqueens">removeVirginQueens</code></td>
<td>
<p>logical, remove existing virgin queens, default is
<code><a href="base.html#topic+TRUE">TRUE</a></code> since bee-keepers tend to remove any virgin queen cells
to ensure the provided queen prevails (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the provided queen is mated, then she is saved in the queen slot
of the colony. If she is not mated, then she is saved in the virgin queen
slot (replacing any existing virgin queens) and once she is mated will be
promoted to the queen of the colony.
</p>


<h3>Value</h3>

<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with new queen(s) (see details)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 12, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 200)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 7, nDrones = nFathersPoisson)

# Create and cross Colony and MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[2:3])

# Check queen and virgin queens IDs
getCasteId(colony, caste = "queen")
getCasteId(colony, caste = "virginQueens")
getCasteId(apiary, caste = "queen")
getCasteId(apiary, caste = "virginQueens")

# Requeen with virgin queens
virginQueens &lt;- basePop[5:8]
# Requeen a Colony class
colony &lt;- reQueen(colony, queen = virginQueens[1])
# Check queen and virgin queens IDs
getCasteId(colony, caste = "queen")
getCasteId(colony, caste = "virginQueens")

#' # Requeen with mated queens
matedQueens &lt;- cross(x = basePop[9:12], drones = droneGroups[4:7])
colony &lt;- reQueen(colony, queen = matedQueens[1])
# Check queen and virgin queens IDs
getCasteId(colony, caste = "queen")
getCasteId(colony, caste = "virginQueens")

# Requeen a MultiColony class
apiary &lt;- reQueen(apiary, queen = virginQueens[2:3])
# Check queen and virgin queens IDs
getCasteId(apiary, caste = "queen")
getCasteId(apiary, caste = "virginQueens")

</code></pre>

<hr>
<h2 id='resetEvents'>Reset colony events</h2><span id='topic+resetEvents'></span>

<h3>Description</h3>

<p>Level 2 function that resets the slots swarm, split,
supersedure, collapsed, and production to FALSE in a Colony or MultiColony object.
Useful at the end of a yearly cycle to reset the events, allowing the user to track
new events in a new year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resetEvents(x, collapse = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resetEvents_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="resetEvents_+3A_collapse">collapse</code></td>
<td>
<p>logical, reset the collapse event (only sensible in setting
up a new colony, which the default of <code>NULL</code> caters for; otherwise, a
collapsed colony should be left collapsed forever, unless you force
resetting this event with <code>collapse = TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with
events reset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 5, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 100)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 5, nDrones = nFathersPoisson)

# Create and cross Colony and MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
apiary &lt;- createMultiColony(basePop[4:5], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[3:4])

# Build-up - this sets Productive to TRUE
(colony &lt;- buildUp(colony, nWorkers = 100))
isProductive(colony)
resetEvents(colony)

apiary &lt;- buildUp(apiary, nWorkers = 100)
isProductive(apiary)
resetEvents(apiary)

# Split - this sets Split to TRUE
tmp &lt;- split(colony)
(split &lt;- tmp$split)
hasSplit(split)
resetEvents(split)
(remnant &lt;- tmp$remnant)
hasSplit(remnant)
resetEvents(remnant)

# Swarm - this sets Swarm to TRUE
tmp &lt;- swarm(colony)
(swarm &lt;- tmp$swarm)
hasSwarmed(swarm)
resetEvents(swarm)
(remnant &lt;- tmp$remnant)
hasSwarmed(remnant)
resetEvents(remnant)

# Supersede - this sets Supersede to TRUE
(tmp &lt;- supersede(colony))
hasSuperseded(tmp)
resetEvents(tmp)

# Collapse - this sets Collapse to TRUE
(tmp &lt;- collapse(colony))
hasCollapsed(tmp)
resetEvents(tmp)
resetEvents(tmp, collapse = TRUE)

# Same behaviour for MultiColony (example for the split)
tmp &lt;- split(apiary)
(splits &lt;- tmp$split)
hasSplit(splits[[1]])
resetEvents(splits)[[1]]
(remnants &lt;- tmp$remnant)
hasSplit(remnants[[1]])
resetEvents(remnants)[[1]]
</code></pre>

<hr>
<h2 id='selectColonies'>Select colonies from MultiColony object</h2><span id='topic+selectColonies'></span>

<h3>Description</h3>

<p>Level 3 function that selects colonies from
MultiColony object based on colony ID or random selection.
Whilst user can provide all three arguments ID, p and n, there is a priority
list: ID takes first priority. If no ID is provided, p takes precedence over n.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectColonies(
  multicolony,
  ID = NULL,
  n = NULL,
  p = NULL,
  by = NULL,
  selectTop = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectColonies_+3A_multicolony">multicolony</code></td>
<td>
<p><code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="selectColonies_+3A_id">ID</code></td>
<td>
<p>character or numeric, ID of a colony (one or more) to be
selected</p>
</td></tr>
<tr><td><code id="selectColonies_+3A_n">n</code></td>
<td>
<p>numeric, number of colonies to select</p>
</td></tr>
<tr><td><code id="selectColonies_+3A_p">p</code></td>
<td>
<p>numeric, percentage of colonies selected (takes precedence
over <code>n</code>)</p>
</td></tr>
<tr><td><code id="selectColonies_+3A_by">by</code></td>
<td>
<p>matrix, matrix of values to select by with names being
colony IDs (can be obtained with <code><a href="#topic+calcColonyValue">calcColonyValue</a></code>.
If NULL, the colonies are selected at random.
This parameter is used in combination
with <code>n</code> or <code>p</code> to determine the number of selected colonies, and
<code>selectTop</code> to determine whether to select the best or the worst colonies.</p>
</td></tr>
<tr><td><code id="selectColonies_+3A_selecttop">selectTop</code></td>
<td>
<p>logical, selects highest (lowest) values if <code>TRUE</code> (<code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with selected colonies
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 5, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
mean &lt;- c(10, 10 / SP$nWorkers)
varA &lt;- c(1, 1 / SP$nWorkers)
corA &lt;- matrix(data = c(
  1.0, -0.5,
  -0.5, 1.0
), nrow = 2, byrow = TRUE)
varE &lt;- c(3, 3 / SP$nWorkers)
varA / (varA + varE)
SP$addTraitADE(nQtlPerChr = 100,
               mean = mean,
               var = varA, corA = corA,
               meanDD = 0.1, varDD = 0.2, corD = corA,
               relAA = 0.1, corAA = corA)
SP$setVarE(varE = varE)

basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1:4], nInd = 100)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = 10)
apiary &lt;- createMultiColony(basePop[2:5], n = 4)
apiary &lt;- cross(apiary, drones = droneGroups[1:4])
apiary &lt;- buildUp(apiary)
getId(apiary)

getId(selectColonies(apiary, ID = 1))
getId(selectColonies(apiary, ID = c("3", "4")))
# ... alternative
getId(apiary[1])
getId(apiary[["4"]])

# Select a random number of colonies
selectColonies(apiary, n = 3)
# Select a percentage of colonies
selectColonies(apiary, p = 0.2)

# Since selection is random, you would get a different set of colonies with
# each function call
getId(selectColonies(apiary, p = 0.5))
getId(selectColonies(apiary, p = 0.5))

# How to select colonies based on colony values?
# Obtain colony phenotype
colonyPheno &lt;- calcColonyPheno(apiary)
# Select the best colony
selectColonies(apiary, n = 1, by = colonyPheno)

# Select the worst 2 colonies
selectColonies(apiary, n = 2, by = colonyPheno, selectTop = FALSE)

# Select best colony based on queen's genetic value for trait 1
queenGv &lt;- calcColonyGv(apiary, FUN = mapCasteToColonyGv, workersTrait = NULL)
selectColonies(apiary, n = 1, by = queenGv)

</code></pre>

<hr>
<h2 id='setLocation'>Set colony location</h2><span id='topic+setLocation'></span>

<h3>Description</h3>

<p>Level 2 function that to set a Colony or MultiColony object
location to (x, y) coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setLocation(x, location)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setLocation_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="setLocation_+3A_location">location</code></td>
<td>
<p>numeric or list, location to be set for the
<code><a href="#topic+Colony-class">Colony-class</a></code> or for <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>; when
numeric the same location will be set for all colonies; when list different
locations will be set for each colony - the list has to have the same
length at there are colonies in <code>x</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with set
location
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 10, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)
drones &lt;- createDrones(basePop[1], n = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = 10)

# Create Colony and MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
apiary &lt;- createMultiColony(basePop[3:8], n = 6)
apiary &lt;- cross(apiary, drones = droneGroups[2:7])

getLocation(colony)
getLocation(apiary)

loc1 &lt;- c(512, 722)
colony &lt;- setLocation(colony, location = loc1)
getLocation(colony)

# Assuming one location (as in bringing colonies to one place!)
apiary &lt;- setLocation(apiary, location = loc1)
getLocation(apiary)
</code></pre>

<hr>
<h2 id='setQueensYearOfBirth'>Set the queen's year of birth</h2><span id='topic+setQueensYearOfBirth'></span>

<h3>Description</h3>

<p>Level 1 function that sets the queen's year of birth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setQueensYearOfBirth(x, year)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setQueensYearOfBirth_+3A_x">x</code></td>
<td>
<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code> (one or more than one queen),
<code><a href="#topic+Colony-class">Colony-class</a></code> (one colony), or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code> (more colonies)</p>
</td></tr>
<tr><td><code id="setQueensYearOfBirth_+3A_year">year</code></td>
<td>
<p>integer, the year of the birth of the queen</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="AlphaSimR.html#topic+Pop-class">Pop-class</a></code>, <code><a href="#topic+Colony-class">Colony-class</a></code>, or
<code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with queens having the year of birth set
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(x = colony, drones = droneGroups[[1]])
apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])

# Example on Colony class
getQueenYearOfBirth(colony)
getQueenYearOfBirth(apiary)

queen1 &lt;- getQueen(colony)
queen1 &lt;- setQueensYearOfBirth(queen1, year = 2022)
getQueenYearOfBirth(queen1)

colony &lt;- setQueensYearOfBirth(colony, year = 2022)
getQueenYearOfBirth(colony)

apiary &lt;- setQueensYearOfBirth(apiary, year = 2022)
getQueenYearOfBirth(apiary)
</code></pre>

<hr>
<h2 id='SimParamBee'>Honeybee simulation parameters</h2><span id='topic+SimParamBee'></span>

<h3>Description</h3>

<p>Container for global honeybee simulation parameters. Saving this
object as <code>SP</code> will allow it to be accessed by SIMplyBee functions
without repeatedly (and annoyingly!) typing out
<code>someFun(argument, simParamBee = SP)</code>. <code>SimParamBee</code> inherits
from AlphaSimR <code><a href="AlphaSimR.html#topic+SimParam">SimParam</a></code>, so all <code><a href="AlphaSimR.html#topic+SimParam">SimParam</a></code> slots
and functions are available in addition to <code>SimParamBee</code>-specific
slots and functions. Some <code><a href="AlphaSimR.html#topic+SimParam">SimParam</a></code> functions could have
upgraded behaviour as documented in line with honeybee biology.
</p>


<h3>Details</h3>

<p>This documentation shows details specific to <code>SimParamBee</code>. We
suggest you also read all the options provided by the AlphaSimR
<code><a href="AlphaSimR.html#topic+SimParam">SimParam</a></code>. Below we show minimal usage cases for each
<code>SimParamBee</code> function.
</p>
<p>See also <code>vignette(package = "SIMplyBee")</code> for descriptions of how
SIMplyBee implements the specific honeybee biology.
</p>


<h3>Super class</h3>

<p><code><a href="AlphaSimR.html#topic+SimParam">AlphaSimR::SimParam</a></code> -&gt; <code>SimParamBee</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>nWorkers</code></dt><dd><p>numeric or function, a number of workers generated in a
colony - used in <code><a href="#topic+createWorkers">createWorkers</a></code>, <code><a href="#topic+addWorkers">addWorkers</a></code>,
<code><a href="#topic+buildUp">buildUp</a></code>.
</p>
<p>The default value is 100, that is, queen generates 100 workers - this
is for a down-scaled simulation (for efficiency) assuming that this
represents ~60,000 workers in a full/strong colony (Seeley, 2019). This
value is set in <code>SimParamBee$new()</code> to have a number to work with.
</p>
<p>You can change this setting to your needs!
</p>
<p>When <code>nWorkers</code> is a function, it should work with internals of
other functions. Therefore, the function MUST be defined like
<code>function(colony, arg = default) someCode </code>, that is, the first
argument MUST be <code>colony</code> and any following arguments MUST have a
default value.
For flexibility you can add ... argument to pass on any other argument.
See <code><a href="#topic+nWorkersPoisson">nWorkersPoisson</a></code>, <code><a href="#topic+nWorkersTruncPoisson">nWorkersTruncPoisson</a></code>,
or <code><a href="#topic+nWorkersColonyPhenotype">nWorkersColonyPhenotype</a></code> for examples.
</p>
<p>You can provide your own functions that satisfy your needs!</p>
</dd>
<dt><code>nDrones</code></dt><dd><p>numeric or function, a number of drones generated in a
colony - used in <code><a href="#topic+createDrones">createDrones</a></code>, <code><a href="#topic+addDrones">addDrones</a></code>,
<code><a href="#topic+buildUp">buildUp</a></code>.
</p>
<p>The default value is 100, that is, queen generates 100 drones - this is
for a down-scaled simulation (for efficiency) assuming that this
represents ~1,000 drones in a full/strong colony (Seeley, 2019). This
value is set in <code>SimParamBee$new()</code> to have a number to work with.
</p>
<p>You can change this setting to your needs!
</p>
<p>When <code>nDrones</code> is a function, it should work with internals of
other functions. Therefore, the function MUST be defined like
<code>function(x, arg = default) someCode </code>, that is, the first
argument MUST be <code>x</code> and any following arguments MUST have a
default value.
For flexibility you can add ... argument to pass on any other argument.
See <code><a href="#topic+nDronesPoisson">nDronesPoisson</a></code>, <code><a href="#topic+nDronesTruncPoisson">nDronesTruncPoisson</a></code>, or
<code><a href="#topic+nDronesColonyPhenotype">nDronesColonyPhenotype</a></code> for examples.
</p>
<p>You can provide your own functions that satisfy your needs!</p>
</dd>
<dt><code>nVirginQueens</code></dt><dd><p>numeric or function, a number of virgin queens
generated when a queen dies or other situations - used in
<code><a href="#topic+createVirginQueens">createVirginQueens</a></code> and <code><a href="#topic+addVirginQueens">addVirginQueens</a></code>.
</p>
<p>The default value is 10, that is, when the queen dies, workers generate
10 new virgin queens (Seeley, 2019). This value is set in
<code>SimParamBee$new()</code> to have a number to work with.
</p>
<p>You can change this setting to your needs!
</p>
<p>When <code>nVirginQueens</code> is a function, it should work with internals
of other functions. Therefore, the function MUST be defined like
<code>function(colony, arg = default) someCode </code>, that is, the first
argument MUST be <code>colony</code> and any following arguments MUST have a
default value.
For flexibility you can add ... argument to pass on any other argument.
See <code><a href="#topic+nVirginQueensPoisson">nVirginQueensPoisson</a></code>,
<code><a href="#topic+nVirginQueensTruncPoisson">nVirginQueensTruncPoisson</a></code>, or
<code><a href="#topic+nVirginQueensColonyPhenotype">nVirginQueensColonyPhenotype</a></code> for examples.
</p>
<p>You can provide your own functions that satisfy your needs!</p>
</dd>
<dt><code>nFathers</code></dt><dd><p>numeric or function, a number of drones a queen mates
with  - used in <code><a href="#topic+pullDroneGroupsFromDCA">pullDroneGroupsFromDCA</a></code>,
<code><a href="#topic+cross">cross</a></code>.
</p>
<p>The default value is 15, that is, a virgin queen mates on average with
15 drones (Seeley, 2019). This value is set in <code>SimParamBee$new()</code>
to have a number to work with.
</p>
<p>You can change this setting to your needs!
</p>
<p>When <code>nFathers</code> is a function, it should work with internals of
other functions. Therefore, the function MUST be defined like
<code>function(arg = default) someCode </code>, that is, any arguments MUST
have a default value. We did not use the <code>colony</code> argument here,
because <code>nFathers</code> likely does not depend on the colony. Let us
know if we are wrong!
For flexibility you can add ... argument to pass on any other argument.
See <code><a href="#topic+nFathersPoisson">nFathersPoisson</a></code> or
<code><a href="#topic+nFathersTruncPoisson">nFathersTruncPoisson</a></code> for examples.
</p>
<p>You can provide your own functions that satisfy your needs!</p>
</dd>
<dt><code>swarmP</code></dt><dd><p>numeric or a function, the swarm proportion - the proportion
of workers that leave with the old queen when the colony swarms - used
in <code><a href="#topic+swarm">swarm</a></code>.
</p>
<p>The default value is 0.50, that is, about a half of workers leave colony
in a swarm (Seeley, 2019). This value is set in <code>SimParamBee$new()</code>
to have a proportion to work with.
</p>
<p>You can change this setting to your needs!
</p>
<p>When <code>swarmP</code> is a function, it should work with internals of
other functions. Therefore, the function MUST be defined like
<code>function(colony, arg = default) someCode </code>, that is, the first
argument MUST be <code>colony</code> and any following arguments MUST have a
default value.
For flexibility you can add ... argument to pass on any other argument.
See <code><a href="#topic+swarmPUnif">swarmPUnif</a></code> for
examples.
</p>
<p>You can provide your own functions that satisfy your needs!</p>
</dd>
<dt><code>splitP</code></dt><dd><p>numeric or a function, the split proportion - the
proportion of workers removed in a managed split - used in
<code><a href="#topic+split">split</a></code>.
</p>
<p>The default value is 0.30, that is, about a third of workers is put into
a split colony from a strong colony (Seeley, 2019). This value is set
in <code>SimParamBee$new()</code> to have a proportion to work with.
</p>
<p>You can change this setting to your needs!
</p>
<p>When <code>splitP</code> is a function, it should work with internals of
other functions. Therefore, the function MUST be defined like
<code>function(colony, arg = default) someCode </code>, that is, the first
argument MUST be <code>colony</code> and any following arguments MUST have a
default value.
For flexibility you can add ... argument to pass on any other argument.
See <code><a href="#topic+splitPUnif">splitPUnif</a></code> or <code><a href="#topic+splitPColonyStrength">splitPColonyStrength</a></code> for
examples.
</p>
<p>You can provide your own functions that satisfy your needs!</p>
</dd>
<dt><code>downsizeP</code></dt><dd><p>numeric or a function, the downsize proportion - the
proportion of workers removed from the colony when downsizing, usually
in autumn - used in <code><a href="#topic+downsize">downsize</a></code>.
</p>
<p>The default value is 0.85, that is, a majority of workers die before
autumn or all die but some winter workers are created (Seeley, 2019).
This value is set in <code>SimParamBee$new()</code> to have a proportion to
work with.
</p>
<p>You can change this setting to your needs!
</p>
<p>When <code>downsizeP</code> is a function, it should work with internals of
other functions. Therefore, the function MUST be defined like
<code>function(colony, arg = default) someCode </code>, that is, the first
argument MUST be <code>colony</code> and any following arguments MUST have a
default value.
For flexibility you can add ... argument to pass on any other argument.
See <code><a href="#topic+downsizePUnif">downsizePUnif</a></code> for example.
</p>
<p>You can provide your own functions that satisfy your needs!</p>
</dd>
<dt><code>colonyValueFUN</code></dt><dd><p>function, to calculate colony values - used
in <code><a href="#topic+calcColonyValue">calcColonyValue</a></code> - see also <code><a href="#topic+calcColonyPheno">calcColonyPheno</a></code>
and <code><a href="#topic+calcColonyGv">calcColonyGv</a></code>.
</p>
<p>This function should work with internals of others functions -
therefore the function MUST be defined like <code>function(colony, arg
  = default) someCode </code>, that is, the first argument MUST be
<code>colony</code> and any following arguments MUST have a default value.
For flexibility you can add ... argument to pass on any other argument.
See <code><a href="#topic+mapCasteToColonyValue">mapCasteToColonyValue</a></code> for an example.
</p>
<p>You can provide your own functions that satisfy your needs!</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>caste</code></dt><dd><p>character, caste information for every individual ever
created; active only when <code>SP$setTrackPed(isTrackPed = TRUE)</code></p>
</dd>
<dt><code>lastColonyId</code></dt><dd><p>integer, ID of the last Colony object
created with <code><a href="#topic+createColony">createColony</a></code></p>
</dd>
<dt><code>csdChr</code></dt><dd><p>integer, chromosome of the csd locus</p>
</dd>
<dt><code>csdPos</code></dt><dd><p>numeric, starting position of the csd locus on the
<code>csdChr</code> chromosome (relative at the moment, but could be in base
pairs in the future)</p>
</dd>
<dt><code>nCsdAlleles</code></dt><dd><p>integer, number of possible csd alleles</p>
</dd>
<dt><code>nCsdSites</code></dt><dd><p>integer, number of segregating sites representing the
csd locus</p>
</dd>
<dt><code>csdPosStart</code></dt><dd><p>integer, starting position of the csd locus</p>
</dd>
<dt><code>csdPosStop</code></dt><dd><p>integer, ending position of the csd locus</p>
</dd>
<dt><code>version</code></dt><dd><p>list, versions of AlphaSimR and SIMplyBee packages used to
generate this object</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SimParamBee-new"><code>SimParamBee$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParamBee-addToCaste"><code>SimParamBee$addToCaste()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParamBee-changeCaste"><code>SimParamBee$changeCaste()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParamBee-updateLastColonyId"><code>SimParamBee$updateLastColonyId()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParamBee-clone"><code>SimParamBee$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="addSnpChip"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-addSnpChip'><code>AlphaSimR::SimParam$addSnpChip()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="addStructuredSnpChip"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-addStructuredSnpChip'><code>AlphaSimR::SimParam$addStructuredSnpChip()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="addToPed"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-addToPed'><code>AlphaSimR::SimParam$addToPed()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="addToRec"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-addToRec'><code>AlphaSimR::SimParam$addToRec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="addTraitA"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-addTraitA'><code>AlphaSimR::SimParam$addTraitA()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="addTraitAD"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-addTraitAD'><code>AlphaSimR::SimParam$addTraitAD()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="addTraitADE"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-addTraitADE'><code>AlphaSimR::SimParam$addTraitADE()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="addTraitADEG"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-addTraitADEG'><code>AlphaSimR::SimParam$addTraitADEG()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="addTraitADG"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-addTraitADG'><code>AlphaSimR::SimParam$addTraitADG()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="addTraitAE"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-addTraitAE'><code>AlphaSimR::SimParam$addTraitAE()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="addTraitAEG"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-addTraitAEG'><code>AlphaSimR::SimParam$addTraitAEG()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="addTraitAG"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-addTraitAG'><code>AlphaSimR::SimParam$addTraitAG()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="ibdHaplo"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-ibdHaplo'><code>AlphaSimR::SimParam$ibdHaplo()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="importTrait"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-importTrait'><code>AlphaSimR::SimParam$importTrait()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="manAddTrait"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-manAddTrait'><code>AlphaSimR::SimParam$manAddTrait()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="removeTrait"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-removeTrait'><code>AlphaSimR::SimParam$removeTrait()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="rescaleTraits"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-rescaleTraits'><code>AlphaSimR::SimParam$rescaleTraits()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="resetPed"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-resetPed'><code>AlphaSimR::SimParam$resetPed()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="restrSegSites"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-restrSegSites'><code>AlphaSimR::SimParam$restrSegSites()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="setCorE"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-setCorE'><code>AlphaSimR::SimParam$setCorE()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="setRecombRatio"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-setRecombRatio'><code>AlphaSimR::SimParam$setRecombRatio()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="setSexes"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-setSexes'><code>AlphaSimR::SimParam$setSexes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="setTrackPed"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-setTrackPed'><code>AlphaSimR::SimParam$setTrackPed()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="setTrackRec"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-setTrackRec'><code>AlphaSimR::SimParam$setTrackRec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="setVarE"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-setVarE'><code>AlphaSimR::SimParam$setVarE()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="switchFemaleMap"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-switchFemaleMap'><code>AlphaSimR::SimParam$switchFemaleMap()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="switchGenMap"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-switchGenMap'><code>AlphaSimR::SimParam$switchGenMap()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="switchMaleMap"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-switchMaleMap'><code>AlphaSimR::SimParam$switchMaleMap()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="switchTrait"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-switchTrait'><code>AlphaSimR::SimParam$switchTrait()</code></a></span></li>
<li><span class="pkg-link" data-pkg="AlphaSimR" data-topic="SimParam" data-id="updateLastId"><a href='../../AlphaSimR/html/SimParam.html#method-SimParam-updateLastId'><code>AlphaSimR::SimParam$updateLastId()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SimParamBee-new"></a>



<h4>Method <code>new()</code></h4>

<p>Starts the process of building a new simulation by creating
a new SimParamBee object and assigning a founder population of genomes
to the this object.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParamBee$new(
  founderPop,
  nWorkers = 100,
  nDrones = 100,
  nVirginQueens = 10,
  nFathers = 15,
  swarmP = 0.5,
  splitP = 0.3,
  downsizeP = 0.85,
  csdChr = 3,
  csdPos = 0.865,
  nCsdAlleles = 128,
  colonyValueFUN = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>founderPop</code></dt><dd><p><code><a href="AlphaSimR.html#topic+MapPop-class">MapPop-class</a></code>, founder population of
genomes</p>
</dd>
<dt><code>nWorkers</code></dt><dd><p>see <code><a href="#topic+SimParamBee">SimParamBee</a></code> field <code>nWorkers</code></p>
</dd>
<dt><code>nDrones</code></dt><dd><p>see <code><a href="#topic+SimParamBee">SimParamBee</a></code> field <code>nDrones</code></p>
</dd>
<dt><code>nVirginQueens</code></dt><dd><p>see <code><a href="#topic+SimParamBee">SimParamBee</a></code> field <code>nVirginQueens</code></p>
</dd>
<dt><code>nFathers</code></dt><dd><p>see <code><a href="#topic+SimParamBee">SimParamBee</a></code> field <code>nFathers</code></p>
</dd>
<dt><code>swarmP</code></dt><dd><p>see <code><a href="#topic+SimParamBee">SimParamBee</a></code> field <code>swarmP</code></p>
</dd>
<dt><code>splitP</code></dt><dd><p>see <code><a href="#topic+SimParamBee">SimParamBee</a></code> field <code>splitP</code></p>
</dd>
<dt><code>downsizeP</code></dt><dd><p>see <code><a href="#topic+SimParamBee">SimParamBee</a></code> field <code>downsizeP</code></p>
</dd>
<dt><code>csdChr</code></dt><dd><p>integer, chromosome that will carry the csd locus, by
default 3, but if there are less chromosomes (for a simplified
simulation), the locus is put on the last available chromosome (1 or
2); if <code>NULL</code> then csd locus is ignored in the simulation</p>
</dd>
<dt><code>csdPos</code></dt><dd><p>numeric, starting position of the csd locus on the
<code>csdChr</code> chromosome (relative at the moment, but could be in base
pairs in future)</p>
</dd>
<dt><code>nCsdAlleles</code></dt><dd><p>integer, number of possible csd alleles (this
determines how many segregating sites will be needed to represent the
csd locus from the underlying bi-allelic SNP; the minimum number of
bi-allelic SNP needed is <code>log2(nCsdAlleles)</code>); if set to <code>0</code>
then <code>csdChr=NULL</code> is triggered. By default we set <code>nCsdAlleles</code>
to 128, which is at the upper end of the reported number of csd alleles
(Lechner et al., 2014; Zareba et al., 2017; Bovo et al., 2021).</p>
</dd>
<dt><code>colonyValueFUN</code></dt><dd><p>see <code><a href="#topic+SimParamBee">SimParamBee</a></code> field <code>colonyValueFUN</code></p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>founderGenomes &lt;- quickHaplo(nInd = 10, nChr = 3, segSites = 10)
SP &lt;- SimParamBee$new(founderGenomes, nCsdAlleles = 2)

# We need enough segregating sites
try(SP &lt;- SimParamBee$new(founderGenomes, nCsdAlleles = 100))
founderGenomes &lt;- quickHaplo(nInd = 10, nChr = 3, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes, nCsdAlleles = 100)

# We can save the csd locus on chromosome 1 or 2, too, for quick simulations
founderGenomes &lt;- quickHaplo(nInd = 10, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes, nCsdAlleles = 100)
</pre>
</div>


<hr>
<a id="method-SimParamBee-addToCaste"></a>



<h4>Method <code>addToCaste()</code></h4>

<p>Store caste information (for internal use only!)
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParamBee$addToCaste(id, caste)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>character, individuals whose caste will be stored</p>
</dd>
<dt><code>caste</code></dt><dd><p>character, single &quot;Q&quot; for queens, &quot;W&quot; for workers, &quot;D&quot; for
drones, &quot;V&quot; for virgin queens, and &quot;F&quot; for fathers</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>founderGenomes &lt;- quickHaplo(nInd = 2, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
SP$setTrackPed(isTrackPed = TRUE)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 10)
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = drones)
colony &lt;- addWorkers(colony, nInd = 5)
colony &lt;- addDrones(colony, nInd = 5)
colony &lt;- addVirginQueens(colony, nInd = 2)

SP$pedigree
SP$caste
</pre>
</div>


<hr>
<a id="method-SimParamBee-changeCaste"></a>



<h4>Method <code>changeCaste()</code></h4>

<p>Change caste information (for internal use only!)
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParamBee$changeCaste(id, caste)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>character, individuals whose caste will be changed</p>
</dd>
<dt><code>caste</code></dt><dd><p>character, single &quot;Q&quot; for queens, &quot;W&quot; for workers, &quot;D&quot; for
drones, &quot;V&quot; for virgin queens, and &quot;F&quot; for fathers</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>founderGenomes &lt;- quickHaplo(nInd = 2, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
SP$setTrackPed(isTrackPed = TRUE)
basePop &lt;- createVirginQueens(founderGenomes)
SP$pedigree
SP$caste

drones &lt;- createDrones(x = basePop[1], nInd = 10)
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = drones)
SP$pedigree
SP$caste
</pre>
</div>


<hr>
<a id="method-SimParamBee-updateLastColonyId"></a>



<h4>Method <code>updateLastColonyId()</code></h4>

<p>A function to update the colony last
ID everytime we create a Colony-class with createColony.
For internal use only.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParamBee$updateLastColonyId()</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lastColonyId</code></dt><dd><p>integer, last colony ID assigned</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimParamBee-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParamBee$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Bovo et al. (2021) Application of Next Generation Semiconductor-Based
Sequencing for the Identification of Apis mellifera Complementary Sex
Determiner (csd) Alleles from Honey DNA. Insects, 12(10), 868.
<a href="https://doi.org//10.3390/insects12100868">doi:/10.3390/insects12100868</a>
</p>
<p>Lechner et al. (2014) Nucleotide variability at its limit? Insights into
the number and evolutionary dynamics of the sex-determining specificities
of the honey bee Apis mellifera Molecular Biology and Evolution, 31,
272-287. <a href="https://doi.org//10.1093/molbev/mst207">doi:/10.1093/molbev/mst207</a>
</p>
<p>Seeley (2019) The Lives of Bees: The Untold Story of the Honey
Bee in the Wild. Princeton: Princeton University Press.
<a href="https://doi.org//10.1515/9780691189383">doi:/10.1515/9780691189383</a>
</p>
<p>Zareba et al. (2017) Uneven distribution of complementary sex determiner
(csd) alleles in Apis mellifera population. Scientific Reports, 7, 2317.
<a href="https://doi.org//10.1038/s41598-017-02629-9">doi:/10.1038/s41598-017-02629-9</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `SimParamBee$new`
## ------------------------------------------------

founderGenomes &lt;- quickHaplo(nInd = 10, nChr = 3, segSites = 10)
SP &lt;- SimParamBee$new(founderGenomes, nCsdAlleles = 2)

# We need enough segregating sites
try(SP &lt;- SimParamBee$new(founderGenomes, nCsdAlleles = 100))
founderGenomes &lt;- quickHaplo(nInd = 10, nChr = 3, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes, nCsdAlleles = 100)

# We can save the csd locus on chromosome 1 or 2, too, for quick simulations
founderGenomes &lt;- quickHaplo(nInd = 10, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes, nCsdAlleles = 100)

## ------------------------------------------------
## Method `SimParamBee$addToCaste`
## ------------------------------------------------

founderGenomes &lt;- quickHaplo(nInd = 2, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
SP$setTrackPed(isTrackPed = TRUE)
basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 10)
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = drones)
colony &lt;- addWorkers(colony, nInd = 5)
colony &lt;- addDrones(colony, nInd = 5)
colony &lt;- addVirginQueens(colony, nInd = 2)

SP$pedigree
SP$caste

## ------------------------------------------------
## Method `SimParamBee$changeCaste`
## ------------------------------------------------

founderGenomes &lt;- quickHaplo(nInd = 2, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
SP$setTrackPed(isTrackPed = TRUE)
basePop &lt;- createVirginQueens(founderGenomes)
SP$pedigree
SP$caste

drones &lt;- createDrones(x = basePop[1], nInd = 10)
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = drones)
SP$pedigree
SP$caste
</code></pre>

<hr>
<h2 id='simulateHoneyBeeGenomes'>Simulate the Honey bee genome</h2><span id='topic+simulateHoneyBeeGenomes'></span>

<h3>Description</h3>

<p>Level 0 function that returns simulated honeybee genomes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateHoneyBeeGenomes(
  nMelN = 0L,
  nMelS = 0L,
  nCar = 0L,
  nLig = 0L,
  Ne = 170000L,
  ploidy = 2L,
  nChr = 16L,
  nSegSites = 100L,
  nBp = 225200000/16,
  genLen = 3.199121,
  mutRate = 3.4e-09,
  recRate = 2.3e-07,
  nThreads = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateHoneyBeeGenomes_+3A_nmeln">nMelN</code></td>
<td>
<p>integer, number of Apis mellifera mellifera North individuals to simulate</p>
</td></tr>
<tr><td><code id="simulateHoneyBeeGenomes_+3A_nmels">nMelS</code></td>
<td>
<p>integer, number of Apis mellifera mellifera South individuals to simulate</p>
</td></tr>
<tr><td><code id="simulateHoneyBeeGenomes_+3A_ncar">nCar</code></td>
<td>
<p>integer, number of Apis mellifera carnica individuals to simulate</p>
</td></tr>
<tr><td><code id="simulateHoneyBeeGenomes_+3A_nlig">nLig</code></td>
<td>
<p>integer, number of Apis mellifera ligustica individuals to simulate</p>
</td></tr>
<tr><td><code id="simulateHoneyBeeGenomes_+3A_ne">Ne</code></td>
<td>
<p>integer, effective size of the simulated population. Currently set to
170,000, according to Wallberg et al., 2014. Would discourage you to change it
since it is linked to the parameters of the demographic model we use for the simulation.
However, there might be some edge cases when using a different Ne is necessary,
but proceed with caution.</p>
</td></tr>
<tr><td><code id="simulateHoneyBeeGenomes_+3A_ploidy">ploidy</code></td>
<td>
<p>integer, the ploidy of the individuals</p>
</td></tr>
<tr><td><code id="simulateHoneyBeeGenomes_+3A_nchr">nChr</code></td>
<td>
<p>integer, number of chromosomes to simulate</p>
</td></tr>
<tr><td><code id="simulateHoneyBeeGenomes_+3A_nsegsites">nSegSites</code></td>
<td>
<p>integer, number of segregating sites to keep per chromosome</p>
</td></tr>
<tr><td><code id="simulateHoneyBeeGenomes_+3A_nbp">nBp</code></td>
<td>
<p>integer, base pair length of chromosome</p>
</td></tr>
<tr><td><code id="simulateHoneyBeeGenomes_+3A_genlen">genLen</code></td>
<td>
<p>numeric, genetic length of chromosome in Morgans</p>
</td></tr>
<tr><td><code id="simulateHoneyBeeGenomes_+3A_mutrate">mutRate</code></td>
<td>
<p>numeric, per base pair mutation rate</p>
</td></tr>
<tr><td><code id="simulateHoneyBeeGenomes_+3A_recrate">recRate</code></td>
<td>
<p>numeric, per base pair recombination rate</p>
</td></tr>
<tr><td><code id="simulateHoneyBeeGenomes_+3A_nthreads">nThreads</code></td>
<td>
<p>integer, if OpenMP is available, this will allow for simulating
chromosomes in parallel. If <code>NULL</code>, the number of threads is
automatically detected</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="AlphaSimR.html#topic+MapPop-class">MapPop-class</a></code>
</p>


<h3>References</h3>

<p>Wallberg, A., Bunikis, I., Pettersson, O.V. et al.
A hybrid de novo genome assembly of the honeybee, Apis mellifera,
with chromosome-length scaffolds. 2019, BMC Genomics 20:275.
<a href="https://doi.org//10.1186/s12864-019-5642-0">doi:/10.1186/s12864-019-5642-0</a>
</p>
<p>Beye M, Gattermeier I, Hasselmann M, et al. Exceptionally high levels
of recombination across the honey bee genome.
2006, Genome Res 16(11):1339-1344. <a href="https://doi.org//10.1101/gr.5680406">doi:/10.1101/gr.5680406</a>
</p>
<p>Wallberg, A., Han, F., Wellhagen, G. et al. A worldwide survey of
genome sequence variation provides insight into the evolutionary
history of the honeybee Apis mellifera.
2014, Nat Genet 46:1081–1088. <a href="https://doi.org//10.1038/ng.3077">doi:/10.1038/ng.3077</a>
</p>
<p>Yang S, Wang L, Huang J, Zhang X, Yuan Y, Chen JQ, Hurst LD, Tian D.
Parent-progeny sequencing indicates higher mutation rates in heterozygotes.
2015, Nature 523(7561):463-7. <a href="https://doi.org//10.1038/nature14649">doi:/10.1038/nature14649</a>.
</p>


<h3>See Also</h3>

<p>Due to the computational time and resources required to run this function,
we do not include an example here, but we demonstrate
its use in the Honeybee biology vignette.
</p>

<hr>
<h2 id='split'>Split colony in two MultiColony</h2><span id='topic+split'></span>

<h3>Description</h3>

<p>Level 2 function that splits a Colony or MultiColony object
into two new colonies to
prevent swarming (in managed situation). The remnant colony retains the
queen and a proportion of the workers and all drones. The split colony gets
the other part of the workers, which raise virgin queens, of which only one
prevails. Location of the split is the same as for the remnant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split(x, p = NULL, year = NULL, simParamBee = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="split_+3A_p">p</code></td>
<td>
<p>numeric, proportion of workers that will go to the split colony; if
<code>NULL</code> then <code><a href="#topic+SimParamBee">SimParamBee</a>$splitP</code> is used.
If input is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>,
the input could also be a vector of the same length as the number of colonies. If
a single value is provided, the same value will be applied to all the colonies</p>
</td></tr>
<tr><td><code id="split_+3A_year">year</code></td>
<td>
<p>numeric, year of birth for virgin queens</p>
</td></tr>
<tr><td><code id="split_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
<tr><td><code id="split_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>p</code> when this argument is a
function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with two  <code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>,
the <code>split</code> and the <code>remnant</code> (see the description what each colony holds!);
both outputs have the split even slot set do <code>TRUE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 10, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)
drones &lt;- createDrones(basePop[1], n = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = 10)

# Create Colony and MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
(colony &lt;- buildUp(colony, nWorkers = 100))
apiary &lt;- createMultiColony(basePop[3:8], n = 6)
apiary &lt;- cross(apiary, drones = droneGroups[2:7])
apiary &lt;- buildUp(apiary, nWorkers = 100)

# Split a colony
tmp &lt;- split(colony)
tmp$split
tmp$remnant

# Split all colonies in the apiary with p = 0.5 (50% of workers in each split)
tmp &lt;- split(apiary, p = 0.5)
tmp$split[[1]]
tmp$remnant[[1]]
# Split with different proportions
nWorkers(apiary)
tmp &lt;- split(apiary, p = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6))
nWorkers(tmp$split)
nWorkers(tmp$remnant)

# Split only specific colonies in the apiary
tmp &lt;- pullColonies(apiary, ID = c(4, 5))
# Split only the pulled colonies
(split(tmp$pulled, p = 0.5))
</code></pre>

<hr>
<h2 id='splitPUnif'>Sample the split proportion - proportion of removed workers in a
managed split</h2><span id='topic+splitPUnif'></span><span id='topic+splitPColonyStrength'></span>

<h3>Description</h3>

<p>Sample the split proportion - proportion of removed workers in a
managed split - used when <code>p = NULL</code> - (see
<code><a href="#topic+SimParamBee">SimParamBee</a>$splitP</code>).
</p>
<p>This is just an example. You can provide your own functions that satisfy
your needs!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitPUnif(colony, n = 1, min = 0.2, max = 0.4)

splitPColonyStrength(colony, n = 1, nWorkersFull = 100, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitPUnif_+3A_colony">colony</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code></p>
</td></tr>
<tr><td><code id="splitPUnif_+3A_n">n</code></td>
<td>
<p>integer, number of samples</p>
</td></tr>
<tr><td><code id="splitPUnif_+3A_min">min</code></td>
<td>
<p>numeric, lower limit for <code>splitPUnif</code></p>
</td></tr>
<tr><td><code id="splitPUnif_+3A_max">max</code></td>
<td>
<p>numeric, upper limit for <code>splitPUnif</code></p>
</td></tr>
<tr><td><code id="splitPUnif_+3A_nworkersfull">nWorkersFull</code></td>
<td>
<p>numeric, average number of workers in a full/strong
colony for <code>splitPColonyStrength</code> (actual number can go beyond this
value)</p>
</td></tr>
<tr><td><code id="splitPUnif_+3A_scale">scale</code></td>
<td>
<p>numeric, scaling of numbers in <code>splitPColonyStrength</code>
to avoid to narrow range when colonies have a large number of bees (in that
case change <code>nWorkersFull</code> too!)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>splitPUnif</code> samples from a uniform distribution between values
0.2 and 0.4 irrespective of colony strength.
</p>
<p><code>splitPColonyStrength</code> samples from a beta distribution with mean
<code>a / (a + b)</code>, where <code>a = nWorkers + nWorkersFull</code> and <code>b =
  nWorkers</code>. This beta sampling mimics larger splits for strong colonies and
smaller splits for weak colonies - see examples. This is just an example -
adapt to your needs!
</p>
<p>The <code>nWorkersFull</code> default value used in this function is geared
towards a situation where we simulate ~100 workers per colony (down-scaled
simulation for efficiency). If you simulate more workers, you should change
the default accordingly.
</p>


<h3>Value</h3>

<p>numeric, split proportion
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>splitPColonyStrength()</code>: Sample the split proportion - the proportion of
removed workers in a managed split based on the colony strength
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+SimParamBee">SimParamBee</a></code> field <code>splitP</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>splitPUnif()
splitPUnif()
p &lt;- splitPUnif(n = 1000)
hist(p, breaks = seq(from = 0, to = 1, by = 0.01), xlim = c(0, 1))

# Example for splitPColonyStrength()
founderGenomes &lt;- quickHaplo(nInd = 2, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)
drones &lt;- createDrones(x = basePop[1], nInd = 15)
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = drones)
colony &lt;- addWorkers(colony, nInd = 10)
nWorkers(colony) # weak colony
splitPColonyStrength(colony)
splitPColonyStrength(colony)
colony &lt;- addWorkers(colony, nInd = 100)
nWorkers(colony) # strong colony
splitPColonyStrength(colony)
splitPColonyStrength(colony)

# Logic behind splitPColonyStrength()
nWorkersFull &lt;- 100
nWorkers &lt;- 0:200
splitP &lt;- 1 - rbeta(
  n = length(nWorkers),
  shape1 = nWorkers + nWorkersFull,
  shape2 = nWorkers
)
plot(splitP ~ nWorkers, ylim = c(0, 1))
abline(v = nWorkersFull)
pKeep &lt;- 1 - splitP
plot(pKeep ~ nWorkers, ylim = c(0, 1))
abline(v = nWorkersFull)
</code></pre>

<hr>
<h2 id='supersede'>Supersede</h2><span id='topic+supersede'></span>

<h3>Description</h3>

<p>Level 2 function that supersedes a Colony or MultiColony object -
an event where the
queen dies. The workers and drones stay unchanged, but workers raise virgin
queens, of which only one prevails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supersede(x, year = NULL, nVirginQueens = NULL, simParamBee = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="supersede_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="supersede_+3A_year">year</code></td>
<td>
<p>numeric, year of birth for virgin queens</p>
</td></tr>
<tr><td><code id="supersede_+3A_nvirginqueens">nVirginQueens</code></td>
<td>
<p>integer, the number of virgin queens to be created in the
colony; of these one is randomly selected as the new virgin queen of the
remnant colony. If <code>NULL</code>, the value from <code>simParamBee$nVirginQueens</code>
is used</p>
</td></tr>
<tr><td><code id="supersede_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
<tr><td><code id="supersede_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>nVirginQueens</code> when this
argument is a function</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code> with the
supersede event set to <code>TRUE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 10, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)
drones &lt;- createDrones(basePop[1], n = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = 10)

# Create Colony and MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
(colony &lt;- buildUp(colony, nWorkers = 100))
apiary &lt;- createMultiColony(basePop[3:8], n = 6)
apiary &lt;- cross(apiary, drones = droneGroups[2:7])
apiary &lt;- buildUp(apiary, nWorkers = 100)

# Supersede a colony
isQueenPresent(colony)
isVirginQueensPresent(colony)
colony &lt;- supersede(colony)
isQueenPresent(colony)
isVirginQueensPresent(colony)

# Supersede all colonies in the apiary
isQueenPresent(colony)
isVirginQueensPresent(colony)
apiary1 &lt;- supersede(apiary)
isQueenPresent(colony)
isVirginQueensPresent(colony)

# Sample colonies from the apiary that will supersede (sample with probability of 0.2)
tmp &lt;- pullColonies(apiary, p = 0.2)
# Swarm only the pulled colonies
(supersede(tmp$pulled))
</code></pre>

<hr>
<h2 id='swarm'>Swarm</h2><span id='topic+swarm'></span>

<h3>Description</h3>

<p>Level 2 function that swarms a Colony or MultiColony object -
an event where the queen
leaves with a proportion of workers to create a new colony (the swarm). The
remnant colony retains the other proportion of workers and all drones, and
the workers raise virgin queens, of which only one prevails. Location of
the swarm is the same as for the remnant (for now).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swarm(x, p = NULL, year = NULL, nVirginQueens = NULL, simParamBee = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swarm_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code></p>
</td></tr>
<tr><td><code id="swarm_+3A_p">p</code></td>
<td>
<p>numeric, proportion of workers that will leave with the swarm colony;
if <code>NULL</code> then <code><a href="#topic+SimParamBee">SimParamBee</a>$swarmP</code> is used.
If input is <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>,
the input could also be a vector of the same length as the number of colonies. If
a single value is provided, the same value will be applied to all the colonies</p>
</td></tr>
<tr><td><code id="swarm_+3A_year">year</code></td>
<td>
<p>numeric, year of birth for virgin queens</p>
</td></tr>
<tr><td><code id="swarm_+3A_nvirginqueens">nVirginQueens</code></td>
<td>
<p>integer, the number of virgin queens to be created in the
colony; of these one is randomly selected as the new virgin queen of the
remnant colony. If <code>NULL</code>, the value from <code>simParamBee$nVirginQueens</code>
is used</p>
</td></tr>
<tr><td><code id="swarm_+3A_simparambee">simParamBee</code></td>
<td>
<p><code><a href="#topic+SimParamBee">SimParamBee</a></code>, global simulation parameters</p>
</td></tr>
<tr><td><code id="swarm_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>p</code> or <code>nVirginQueens</code>
when these arguments are functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with two <code><a href="#topic+Colony-class">Colony-class</a></code> or <code><a href="#topic+MultiColony-class">MultiColony-class</a></code>,
the <code>swarm</code> and the <code>remnant</code> (see the description what each colony holds!); both
outputs have the swarm event set to <code>TRUE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 50)
SP &lt;- SimParamBee$new(founderGenomes)
basePop &lt;- createVirginQueens(founderGenomes)
drones &lt;- createDrones(basePop[1], n = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = 10)

# Create Colony and MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
(colony &lt;- buildUp(colony, nWorkers = 100))
apiary &lt;- createMultiColony(basePop[3:8], n = 6)
apiary &lt;- cross(apiary, drones = droneGroups[2:7])
apiary &lt;- buildUp(apiary, nWorkers = 100)

# Swarm a colony
tmp &lt;- swarm(colony)
tmp$swarm
tmp$remnant

# Swarm all colonies in the apiary with p = 0.6 (60% of workers leave)
tmp &lt;- swarm(apiary, p = 0.6)
nWorkers(tmp$swarm)
nWorkers(tmp$remnant)
# Swarm with different proportions
nWorkers(apiary)
tmp &lt;- swarm(apiary, p = c(0.4, 0.6, 0.5, 0.5, 0.34, 0.56))
nWorkers(tmp$swarm)
nWorkers(tmp$remnant)

# Sample colonies from the apiary that will swarm (sample with probability of 0.2)
tmp &lt;- pullColonies(apiary, p = 0.2)
# Swarm only the pulled colonies
(swarm(tmp$pulled, p = 0.6))
</code></pre>

<hr>
<h2 id='swarmPUnif'>Sample the swarm proportion - the proportion of workers that swarm</h2><span id='topic+swarmPUnif'></span>

<h3>Description</h3>

<p>Sample the swarm proportion - the proportion of workers that
swarm - used when <code>p = NULL</code> (see <code><a href="#topic+SimParamBee">SimParamBee</a>$swarmP</code>).
</p>
<p>This is just an example. You can provide your own functions that satisfy
your needs!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swarmPUnif(colony, n = 1, min = 0.4, max = 0.6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swarmPUnif_+3A_colony">colony</code></td>
<td>
<p><code><a href="#topic+Colony-class">Colony-class</a></code></p>
</td></tr>
<tr><td><code id="swarmPUnif_+3A_n">n</code></td>
<td>
<p>integer, number of samples</p>
</td></tr>
<tr><td><code id="swarmPUnif_+3A_min">min</code></td>
<td>
<p>numeric, lower limit for <code>swarmPUnif</code></p>
</td></tr>
<tr><td><code id="swarmPUnif_+3A_max">max</code></td>
<td>
<p>numeric, upper limit for <code>swarmPUnif</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>swarmPUnif</code> samples from a uniform distribution between values
0.4 and 0.6 irrespective of colony strength.
</p>
<p>The <code>nWorkersFull</code> default value used in this function is geared
towards a situation where we simulate ~100 workers per colony (down-scaled
simulation for efficiency). If you simulate more workers, you should change
the default accordingly.
</p>


<h3>Value</h3>

<p>numeric, swarm proportion
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimParamBee">SimParamBee</a></code> field <code>swarmP</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>swarmPUnif()
swarmPUnif()
p &lt;- swarmPUnif(n = 1000)
hist(p, breaks = seq(from = 0, to = 1, by = 0.01), xlim = c(0, 1))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
