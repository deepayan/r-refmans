<!DOCTYPE html><html><head><title>Help for package gemma2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gemma2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calc_omega'><p>Calculate Omega matrices</p></a></li>
<li><a href='#calc_qi'><p>Calculate Qi (inverse of Q) and log determinant of Q</p></a></li>
<li><a href='#calc_sigma'><p>Calculate Sigma_ee and Sigma_uu matrices</p></a></li>
<li><a href='#calc_XHiY'><p>Calculate XHiY</p></a></li>
<li><a href='#center_kinship'><p>Center a relatedness matrix, after Zhou's GEMMA function CenterMatrix</p></a></li>
<li><a href='#eigen_proc'><p>Eigendecomposition procedure for Vg and Ve</p></a></li>
<li><a href='#eigen2'><p>Calculate eigendecomposition and return ordered eigenvalues and eigenvectors</p></a></li>
<li><a href='#gemma2'><p>gemma2</p></a></li>
<li><a href='#MphCalcLogL'><p>Calculate log likelihood</p></a></li>
<li><a href='#MphEM'><p>Perform expectation-maximization algorithm to infer Vg and Ve values for a pair of traits.</p></a></li>
<li><a href='#stagger_mats'><p>Stagger matrices within a larger, block-diagonal matrix</p></a></li>
<li><a href='#update_e'><p>Update E</p></a></li>
<li><a href='#update_u'><p>Update U matrix</p></a></li>
<li><a href='#update_v'><p>Update V_e and V_g</p></a></li>
<li><a href='#UpdateRL_B'><p>Update B for restricted log likelihood</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>GEMMA Multivariate Linear Mixed Model</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits a multivariate linear mixed effects model that uses a polygenic term, after Zhou &amp; Stephens (2014) (<a href="https://www.nature.com/articles/nmeth.2848">https://www.nature.com/articles/nmeth.2848</a>). Of particular interest is the estimation of variance components with restricted maximum likelihood (REML) methods. Genome-wide efficient mixed-model association (GEMMA), as implemented in the package 'gemma2', uses an expectation-maximization algorithm for variance components inference for use in quantitative trait locus studies.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/fboehm/gemma2">https://github.com/fboehm/gemma2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fboehm/gemma2/issues">https://github.com/fboehm/gemma2/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat, knitr, rmarkdown, readr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Matrix</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-24 15:35:11 UTC; fred</td>
</tr>
<tr>
<td>Author:</td>
<td>Frederick Boehm <a href="https://orcid.org/0000-0002-1644-5931"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Frederick Boehm &lt;frederick.boehm@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-24 16:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='calc_omega'>Calculate Omega matrices</h2><span id='topic+calc_omega'></span>

<h3>Description</h3>

<p>Calculate Omega matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_omega(eval, D_l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_omega_+3A_eval">eval</code></td>
<td>
<p>vector of eigenvalues from decomposition of relatedness matrix</p>
</td></tr>
<tr><td><code id="calc_omega_+3A_d_l">D_l</code></td>
<td>
<p>vector of length d_size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of length 2. First entry in the list is the symmetric matrix OmegaU. Second entry in the list is the symmetric matrix OmegaE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calc_omega(eval = 50:1, D_l = runif(2))
</code></pre>

<hr>
<h2 id='calc_qi'>Calculate Qi (inverse of Q) and log determinant of Q</h2><span id='topic+calc_qi'></span>

<h3>Description</h3>

<p>Calculate Qi (inverse of Q) and log determinant of Q
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_qi(eval, D_l, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_qi_+3A_eval">eval</code></td>
<td>
<p>vector of eigenvalues from decomposition of relatedness matrix</p>
</td></tr>
<tr><td><code id="calc_qi_+3A_d_l">D_l</code></td>
<td>
<p>vector of length d_size</p>
</td></tr>
<tr><td><code id="calc_qi_+3A_x">X</code></td>
<td>
<p>design matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of length two. First entry in the list is a symmetric numeric matrix, Qi, the inverse of the Q matrix. The second entry in the outputted list is the log determinant of the matrix Q for use in likelihood calculations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.matrix(readr::read_tsv(system.file("extdata",
"mouse100.cXX.txt",
package = "gemma2"),
col_names = FALSE)[, 1:100]) -&gt; kinship
eigen2(kinship) -&gt; e2_out
e2_out$values -&gt; eval
e2_out$vectors -&gt; U
eigen_proc(V_g = diag(c(1.91352, 0.530827)),
V_e = diag(c(0.320028, 0.561589))) -&gt; ep_out

calc_qi(eval = eval,
D_l = ep_out[[4]],
X = t(rep(1, 100)) %*% U)
</code></pre>

<hr>
<h2 id='calc_sigma'>Calculate Sigma_ee and Sigma_uu matrices</h2><span id='topic+calc_sigma'></span>

<h3>Description</h3>

<p>Calculate Sigma_ee and Sigma_uu matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_sigma(eval, D_l, X, OmegaU, OmegaE, UltVeh, Qi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_sigma_+3A_eval">eval</code></td>
<td>
<p>eigenvalues vector from decomposition of relatedness matrix</p>
</td></tr>
<tr><td><code id="calc_sigma_+3A_d_l">D_l</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="calc_sigma_+3A_x">X</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="calc_sigma_+3A_omegau">OmegaU</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="calc_sigma_+3A_omegae">OmegaE</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="calc_sigma_+3A_ultveh">UltVeh</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="calc_sigma_+3A_qi">Qi</code></td>
<td>
<p>inverse of Q matrix</p>
</td></tr>
</table>

<hr>
<h2 id='calc_XHiY'>Calculate XHiY</h2><span id='topic+calc_XHiY'></span>

<h3>Description</h3>

<p>Calculate XHiY
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_XHiY(eval, D_l, X, UltVehiY)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_XHiY_+3A_eval">eval</code></td>
<td>
<p>vector of eigenvalues from the decomposition of the relatedness matrix</p>
</td></tr>
<tr><td><code id="calc_XHiY_+3A_d_l">D_l</code></td>
<td>
<p>vector of length d_size</p>
</td></tr>
<tr><td><code id="calc_XHiY_+3A_x">X</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="calc_XHiY_+3A_ultvehiy">UltVehiY</code></td>
<td>
<p>a matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>readr::read_tsv(system.file("extdata",
"mouse100.pheno.txt",
package = "gemma2"),
col_names = FALSE) -&gt; pheno
phe16 &lt;- as.matrix(pheno[, c(1, 6)])
as.matrix(readr::read_tsv(system.file("extdata",
"mouse100.cXX.txt",
package = "gemma2"),
col_names = FALSE)[, 1:100]) -&gt; kinship
eigen2(kinship) -&gt; eout
eout$values -&gt; eval
eout$vectors -&gt; U
UltVehi &lt;- matrix(c(0, -1.76769, -1.334414, 0),
nrow = 2,
byrow = FALSE) # from output of eigen_proc()
calc_XHiY(eval = eval,
D_l = c(0.9452233, 5.9792268),
          X = rep(1, 100) %*% U,
          UltVehiY = UltVehi %*% t(phe16) %*% U
          )
</code></pre>

<hr>
<h2 id='center_kinship'>Center a relatedness matrix, after Zhou's GEMMA function CenterMatrix</h2><span id='topic+center_kinship'></span>

<h3>Description</h3>

<p>Center a relatedness matrix, after Zhou's GEMMA function CenterMatrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center_kinship(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center_kinship_+3A_mat">mat</code></td>
<td>
<p>a relatedness matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a centered relatedness matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>readr::read_tsv(system.file("extdata",
"mouse100.cXX.txt",
package = "gemma2"),
col_names = FALSE)[, 1:100] -&gt; kinship
e_out &lt;- eigen2(as.matrix(kinship))
center_kinship(as.matrix(kinship)) -&gt; kinship_centered
</code></pre>

<hr>
<h2 id='eigen_proc'>Eigendecomposition procedure for Vg and Ve</h2><span id='topic+eigen_proc'></span>

<h3>Description</h3>

<p>Eigendecomposition procedure for Vg and Ve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen_proc(V_g, V_e, tol = 1/10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigen_proc_+3A_v_g">V_g</code></td>
<td>
<p>a d_size by d_size covariance matrix</p>
</td></tr>
<tr><td><code id="eigen_proc_+3A_v_e">V_e</code></td>
<td>
<p>a d_size by d_size covariance matrix</p>
</td></tr>
<tr><td><code id="eigen_proc_+3A_tol">tol</code></td>
<td>
<p>a positive number indicating the tolerance for isSymmetric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list of length 4 containing the outputs of eigendecomposition procedure
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eigen_proc(diag(2), diag(2))

</code></pre>

<hr>
<h2 id='eigen2'>Calculate eigendecomposition and return ordered eigenvalues and eigenvectors</h2><span id='topic+eigen2'></span>

<h3>Description</h3>

<p>Calculate eigendecomposition and return ordered eigenvalues and eigenvectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen2(spd, decreasing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigen2_+3A_spd">spd</code></td>
<td>
<p>a semi-positive definite matrix</p>
</td></tr>
<tr><td><code id="eigen2_+3A_decreasing">decreasing</code></td>
<td>
<p>argument passed to order()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with 2 components, the eigenvalues and the eigenvectors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>readr::read_tsv(system.file("extdata",
"mouse100.cXX.txt",
package = "gemma2"),
col_names = FALSE)[, 1:100] -&gt; kinship
e_out &lt;- eigen2(as.matrix(kinship))
</code></pre>

<hr>
<h2 id='gemma2'>gemma2</h2><span id='topic+gemma2'></span>

<h3>Description</h3>

<p>We implement an expectation-maximization algorithm for multivariate variance components after the GEMMA software's algorithm.
</p>

<hr>
<h2 id='MphCalcLogL'>Calculate log likelihood</h2><span id='topic+MphCalcLogL'></span>

<h3>Description</h3>

<p>Calculate log likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MphCalcLogL(eval, D_l, Qi, UltVehiY, xHiy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MphCalcLogL_+3A_eval">eval</code></td>
<td>
<p>eigenvalues vector from decomposition of relatedness matrix</p>
</td></tr>
<tr><td><code id="MphCalcLogL_+3A_d_l">D_l</code></td>
<td>
<p>vector of eigenvalues from decomposition of Ve matrix</p>
</td></tr>
<tr><td><code id="MphCalcLogL_+3A_qi">Qi</code></td>
<td>
<p>inverse of Q matrix</p>
</td></tr>
<tr><td><code id="MphCalcLogL_+3A_ultvehiy">UltVehiY</code></td>
<td>
<p>matrix of (transformed) Y values</p>
</td></tr>
<tr><td><code id="MphCalcLogL_+3A_xhiy">xHiy</code></td>
<td>
<p>vector</p>
</td></tr>
</table>

<hr>
<h2 id='MphEM'>Perform expectation-maximization algorithm to infer Vg and Ve values for a pair of traits.</h2><span id='topic+MphEM'></span>

<h3>Description</h3>

<p>Perform expectation-maximization algorithm to infer Vg and Ve values for a pair of traits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MphEM(
  max_iter = 10000,
  max_prec = 1/1e+06,
  eval,
  X,
  Y,
  V_g,
  V_e,
  verbose_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MphEM_+3A_max_iter">max_iter</code></td>
<td>
<p>maximum number of iterations for EM algorithm</p>
</td></tr>
<tr><td><code id="MphEM_+3A_max_prec">max_prec</code></td>
<td>
<p>maximum precision for EM algorithm</p>
</td></tr>
<tr><td><code id="MphEM_+3A_eval">eval</code></td>
<td>
<p>vector of eigenvalues from relatedness matrix decomposition</p>
</td></tr>
<tr><td><code id="MphEM_+3A_x">X</code></td>
<td>
<p>design matrix. Typically contains founder allele dosages.</p>
</td></tr>
<tr><td><code id="MphEM_+3A_y">Y</code></td>
<td>
<p>matrix of phenotype values</p>
</td></tr>
<tr><td><code id="MphEM_+3A_v_g">V_g</code></td>
<td>
<p>genetic covariance matrix</p>
</td></tr>
<tr><td><code id="MphEM_+3A_v_e">V_e</code></td>
<td>
<p>error covariance matrix</p>
</td></tr>
<tr><td><code id="MphEM_+3A_verbose_output">verbose_output</code></td>
<td>
<p>logical indicating whether to output entire collection of intermediate values for all iterations. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of lists. Length of list corresponds to number of EM iterations
</p>

<hr>
<h2 id='stagger_mats'>Stagger matrices within a larger, block-diagonal matrix</h2><span id='topic+stagger_mats'></span>

<h3>Description</h3>

<p>Stagger matrices within a larger, block-diagonal matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stagger_mats(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stagger_mats_+3A_...">...</code></td>
<td>
<p>one or more matrices, separated by commas</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a block-diagonal matrix, with the inputted matrices as blocks on the diagonal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- matrix(rnorm(40000), ncol = 8)
block_diag &lt;- stagger_mats(foo, foo)
dim(foo)
dim(block_diag)
</code></pre>

<hr>
<h2 id='update_e'>Update E</h2><span id='topic+update_e'></span>

<h3>Description</h3>

<p>Update E
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_e(UltVehiY, UltVehiBX, UltVehiU)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_e_+3A_ultvehiy">UltVehiY</code></td>
<td>
<p>matrix of transformed Y values</p>
</td></tr>
<tr><td><code id="update_e_+3A_ultvehibx">UltVehiBX</code></td>
<td>
<p>matrix of transformed BX values</p>
</td></tr>
<tr><td><code id="update_e_+3A_ultvehiu">UltVehiU</code></td>
<td>
<p>matrix of transformed U values</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other expectation-maximization functions: 
<code><a href="#topic+UpdateRL_B">UpdateRL_B</a>()</code>,
<code><a href="#topic+update_u">update_u</a>()</code>,
<code><a href="#topic+update_v">update_v</a>()</code>
</p>

<hr>
<h2 id='update_u'>Update U matrix</h2><span id='topic+update_u'></span>

<h3>Description</h3>

<p>Update U matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_u(OmegaE, UltVehiY, UltVehiBX)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_u_+3A_omegae">OmegaE</code></td>
<td>
<p>the OmegaE matrix, calculated in calc_omega</p>
</td></tr>
<tr><td><code id="update_u_+3A_ultvehiy">UltVehiY</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="update_u_+3A_ultvehibx">UltVehiBX</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other expectation-maximization functions: 
<code><a href="#topic+UpdateRL_B">UpdateRL_B</a>()</code>,
<code><a href="#topic+update_e">update_e</a>()</code>,
<code><a href="#topic+update_v">update_v</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>readr::read_tsv(system.file("extdata",
"mouse100.pheno.txt",
package = "gemma2"),
col_names = FALSE) -&gt; pheno
phe16 &lt;- as.matrix(pheno[, c(1, 6)])
as.matrix(readr::read_tsv(system.file("extdata",
"mouse100.cXX.txt",
package = "gemma2"),
col_names = FALSE)[, 1:100]) -&gt; kinship
eigen2(kinship) -&gt; e2_out
e2_out$values -&gt; eval
e2_out$vectors -&gt; U
eigen_proc(V_g = diag(c(1.91352, 0.530827)),
V_e = diag(c(0.320028, 0.561589))) -&gt; ep_out
UltVehi &lt;- ep_out[[3]]
calc_omega(eval, ep_out$D_l) -&gt; co_out
update_u(OmegaE = co_out[[2]],
        UltVehiY = UltVehi %*% t(phe16),
        UltVehiBX = matrix(c(-0.71342, -0.824482),
        ncol = 1) %*% t(rep(1, 100))
)
</code></pre>

<hr>
<h2 id='update_v'>Update V_e and V_g</h2><span id='topic+update_v'></span>

<h3>Description</h3>

<p>Update V_e and V_g
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_v(eval, U, E, Sigma_uu, Sigma_ee, tol = 1/10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_v_+3A_eval">eval</code></td>
<td>
<p>vector of eigenvalues from eigendecomposition of relatedness matrix</p>
</td></tr>
<tr><td><code id="update_v_+3A_u">U</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="update_v_+3A_e">E</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="update_v_+3A_sigma_uu">Sigma_uu</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="update_v_+3A_sigma_ee">Sigma_ee</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="update_v_+3A_tol">tol</code></td>
<td>
<p>a positive number indicating tolerance to be passed to isSymmetric()</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other expectation-maximization functions: 
<code><a href="#topic+UpdateRL_B">UpdateRL_B</a>()</code>,
<code><a href="#topic+update_e">update_e</a>()</code>,
<code><a href="#topic+update_u">update_u</a>()</code>
</p>

<hr>
<h2 id='UpdateRL_B'>Update B for restricted log likelihood</h2><span id='topic+UpdateRL_B'></span>

<h3>Description</h3>

<p>Update B for restricted log likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UpdateRL_B(xHiy, Qi, d_size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UpdateRL_B_+3A_xhiy">xHiy</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="UpdateRL_B_+3A_qi">Qi</code></td>
<td>
<p>Q inverse matrix</p>
</td></tr>
<tr><td><code id="UpdateRL_B_+3A_d_size">d_size</code></td>
<td>
<p>number of traits</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other expectation-maximization functions: 
<code><a href="#topic+update_e">update_e</a>()</code>,
<code><a href="#topic+update_u">update_u</a>()</code>,
<code><a href="#topic+update_v">update_v</a>()</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
