<!DOCTYPE html><html><head><title>Help for package prefio</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {prefio}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#prefio-package'><p>prefio: Structures for Preference Data</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#adjacency'><p>Create an Adjacency Matrix for a set of Preferences</p></a></li>
<li><a href='#aggregate.preferences'><p>Aggregate Preferences</p></a></li>
<li><a href='#choices'><p>Choices Object</p></a></li>
<li><a href='#group'><p>Group Preferences</p></a></li>
<li><a href='#preferences'><p>Preferences Object</p></a></li>
<li><a href='#read_preflib'><p>Read Ordinal Preference Data From PrefLib</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#write_preflib'><p>Write Ordinal Preference Data to PrefLib Formats</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Structures for Preference Data</td>
</tr>
<tr>
<td>Description:</td>
<td>Convenient structures for creating, sourcing, reading, writing
  and manipulating ordinal preference data. Methods for writing to/from PrefLib
  formats. See Nicholas Mattei and Toby Walsh "PrefLib: A Library of Preference
  Data" (2013) &lt;<a href="https://doi.org/10.1007%2F978-3-642-41575-3_20">doi:10.1007/978-3-642-41575-3_20</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/fleverest/prefio/">https://github.com/fleverest/prefio/</a>,
<a href="https://fleverest.github.io/prefio/">https://fleverest.github.io/prefio/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fleverest/prefio/issues/">https://github.com/fleverest/prefio/issues/</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, magrittr, tidyr, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-07 12:05:34 UTC; dev</td>
</tr>
<tr>
<td>Author:</td>
<td>Floyd Everest <a href="https://orcid.org/0000-0002-2726-6736"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Heather Turner <a href="https://orcid.org/0000-0002-1256-3375"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Damjan Vukcevic <a href="https://orcid.org/0000-0001-7780-9586"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Floyd Everest &lt;me@floydeverest.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-07 12:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='prefio-package'>prefio: Structures for Preference Data</h2><span id='topic+prefio'></span><span id='topic+prefio-package'></span>

<h3>Description</h3>

<p>Convenient structures for creating, sourcing, reading, writing and manipulating ordinal preference data. Methods for writing to/from PrefLib formats. See Nicholas Mattei and Toby Walsh &quot;PrefLib: A Library of Preference Data&quot; (2013) <a href="https://doi.org/10.1007/978-3-642-41575-3_20">doi:10.1007/978-3-642-41575-3_20</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Floyd Everest <a href="mailto:me@floydeverest.com">me@floydeverest.com</a> (<a href="https://orcid.org/0000-0002-2726-6736">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Heather Turner <a href="mailto:ht@heatherturner.net">ht@heatherturner.net</a> (<a href="https://orcid.org/0000-0002-1256-3375">ORCID</a>)
</p>
</li>
<li><p> Damjan Vukcevic <a href="mailto:damjan@vukcevic.net">damjan@vukcevic.net</a> (<a href="https://orcid.org/0000-0001-7780-9586">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/fleverest/prefio/">https://github.com/fleverest/prefio/</a>
</p>
</li>
<li> <p><a href="https://fleverest.github.io/prefio/">https://fleverest.github.io/prefio/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/fleverest/prefio/issues/">https://github.com/fleverest/prefio/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='adjacency'>Create an Adjacency Matrix for a set of Preferences</h2><span id='topic+adjacency'></span>

<h3>Description</h3>

<p>Convert a set of preferences to an adjacency matrix summarising wins
and losses between pairs of items
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjacency(object, weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacency_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+preferences">preferences</a></code> object, or an object that can be
coerced by <code>as.preferences</code>.</p>
</td></tr>
<tr><td><code id="adjacency_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights for the preferences.</p>
</td></tr>
<tr><td><code id="adjacency_+3A_...">...</code></td>
<td>
<p>further arguments passed to/from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a <code>preferences</code> object with <code class="reqn">N</code> items, the adjacency
matrix is an <code class="reqn">N</code> by <code class="reqn">N</code> matrix, with element <code class="reqn">(i, j)</code> being the
number of times item <code class="reqn">i</code> wins over item <code class="reqn">j</code>. For example, in the
preferences {1} &gt; {3, 4} &gt; {2}, item 1 wins over items 2, 3, and 4,
while items 3 and 4 win over item 2.
</p>
<p>If <code>weights</code> is specified, the values in the adjacency matrix are the
weighted counts.
</p>


<h3>Value</h3>

<p>An <code class="reqn">N</code> by <code class="reqn">N</code> matrix, where <code class="reqn">N</code> is the number of
items.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(c(
  2, 1, 2, 1, 2,
  3, 2, 0, 0, 1,
  1, 0, 2, 2, 3
), nrow = 3, byrow = TRUE)
X &lt;- as.preferences(X, format = "ranking", item_names = LETTERS[1:5])
adjacency(X)

adjacency(X, weights = c(1, 1, 2))

</code></pre>

<hr>
<h2 id='aggregate.preferences'>Aggregate Preferences</h2><span id='topic+aggregate.preferences'></span><span id='topic+as.aggregated_preferences'></span><span id='topic++5B.aggregated_preferences'></span><span id='topic+frequencies'></span>

<h3>Description</h3>

<p>Aggregate <code>preferences</code>, returning an <code>aggregated_preferences</code> object of
the unique preferences and their frequencies. The frequencies can be
accessed via the function <code>frequencies()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'preferences'
aggregate(x, frequencies = NULL, ...)

as.aggregated_preferences(x, ...)

## S3 method for class 'aggregated_preferences'
x[i, j, ...]

frequencies(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate.preferences_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+preferences">preferences</a></code> object for <code>aggregate()</code>; an
object that can be coerced to an <code>aggregated_preferences</code> object for
<code>as.aggregated_preferences()</code>, otherwise an <code>aggregated_preferences</code>
object.</p>
</td></tr>
<tr><td><code id="aggregate.preferences_+3A_frequencies">frequencies</code></td>
<td>
<p>A vector of frequencies for preferences that have been
previously aggregated.</p>
</td></tr>
<tr><td><code id="aggregate.preferences_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently unused.</p>
</td></tr>
<tr><td><code id="aggregate.preferences_+3A_i">i</code></td>
<td>
<p>indices specifying preferences to extract.</p>
</td></tr>
<tr><td><code id="aggregate.preferences_+3A_j">j</code></td>
<td>
<p>indices specifying items to extract.</p>
</td></tr>
<tr><td><code id="aggregate.preferences_+3A_as.aggregated_preferences">as.aggregated_preferences</code></td>
<td>
<p>if <code>TRUE</code> create an
<code>aggregated_preferences</code> object from the indexed preferences Otherwise
index the underlying matrix of ranks and return in a data frame with the
corresponding frequencies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of class <code>aggregated_preferences</code>, with columns:
</p>

<dl>
<dt>preferences</dt><dd><p>A <code><a href="#topic+preferences">preferences</a></code> object of the unique
preferences</p>
</dd>
<dt>frequencies</dt><dd><p>The corresponding frequencies.</p>
</dd>
</dl>

<p>Methods are available for <code><a href="base.html#topic+rbind">rbind()</a></code> and <code><a href="base.html#topic+as.matrix">as.matrix()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a preferences object with duplicated preferences
R &lt;- matrix(c(
  1, 2, 0, 0,
  0, 1, 2, 3,
  2, 1, 1, 0,
  1, 2, 0, 0,
  2, 1, 1, 0,
  1, 0, 3, 2
), nrow = 6, byrow = TRUE)
colnames(R) &lt;- c("apple", "banana", "orange", "pear")
R &lt;- as.preferences(R, format = "ranking")

# aggregate the preferences
A &lt;- aggregate(R)

# Or pass `aggregate = TRUE` to `as.preferences`
A &lt;- as.preferences(R, aggregate = TRUE)

# Subsetting applies to the preferences, e.g. first two unique preferences
A[1:2]

# (partial) preferences projected to items 2-4 only
A[, 2:4]

# Project preferences onto their hightest ranking
A[, 1, by.rank = TRUE]

# convert to a matrix
as.matrix(A)
</code></pre>

<hr>
<h2 id='choices'>Choices Object</h2><span id='topic+choices'></span>

<h3>Description</h3>

<p>Convert a set of preferences to a list of choices, alternatives, and
preferences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choices(preferences, names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choices_+3A_preferences">preferences</code></td>
<td>
<p>a <code><a href="#topic+preferences">preferences</a></code> object, or an object that can be
coerced by <code>as.preferences</code>.</p>
</td></tr>
<tr><td><code id="choices_+3A_names">names</code></td>
<td>
<p>logical: if <code>TRUE</code> use the object names in the returned
<code>choices</code> object, else use object indices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of class <code>choices</code> with elements:
</p>

<dl>
<dt>choices</dt><dd><p>A list where each element represents the items chosen for a
single rank in the ordering.</p>
</dd>
<dt>alternatives</dt><dd><p>A list where each element represents the alternatives
(i.e. the set of remaining items to choose from) for a single rank.</p>
</dd>
<dt>ordering</dt><dd><p>A list where each element represents the ordering
that the choice belongs to.</p>
</dd>
</dl>

<p>The list stores the number of choices and the names of the objects as the
attributes <code>nchoices</code> and <code>objects</code> respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R &lt;- matrix(c(
  1, 2, 0, 0,
  4, 1, 2, 3,
  2, 1, 1, 1,
  1, 2, 3, 0,
  2, 1, 1, 0,
  1, 0, 3, 2
), nrow = 6, byrow = TRUE)
colnames(R) &lt;- c("apple", "banana", "orange", "pear")
R &lt;- preferences(R, format = "ranking")

actual_choices &lt;- choices(R, names = TRUE)
actual_choices[1:6, ]

coded_choices &lt;- choices(R, names = FALSE)
coded_choices[1:2, ]
as.data.frame(coded_choices)[1:2, ]
attr(coded_choices, "objects")

</code></pre>

<hr>
<h2 id='group'>Group Preferences</h2><span id='topic+group'></span><span id='topic+group.preferences'></span><span id='topic++5B.grouped_preferences'></span><span id='topic+format.grouped_preferences'></span>

<h3>Description</h3>

<p>Create an object of class <code>grouped_preferences</code> which associates a
group index with an object of class <code>preferences</code>. This allows the
preferences to be linked to covariates with group-specific values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group(x, ...)

## S3 method for class 'preferences'
group(x, index, ...)

## S3 method for class 'grouped_preferences'
x[i, j, ...]

## S3 method for class 'grouped_preferences'
format(x, max = 2L, width = 20L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+preferences">preferences</a></code> object for <code>group()</code>; otherwise a
<code>grouped_preferences</code> object.</p>
</td></tr>
<tr><td><code id="group_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to
<code><a href="#topic+as.preferences">as.preferences</a></code> by <code>grouped_preferences</code>; unused by
<code>format</code>.</p>
</td></tr>
<tr><td><code id="group_+3A_index">index</code></td>
<td>
<p>A numeric vector or a factor with length equal to the number of
preferences specifying the subject for each set.</p>
</td></tr>
<tr><td><code id="group_+3A_i">i</code></td>
<td>
<p>Indices specifying groups to extract, may be any data type accepted
by <code>[</code>.</p>
</td></tr>
<tr><td><code id="group_+3A_j">j</code></td>
<td>
<p>Indices specifying items to extract.
object, otherwise return a matrix/vector.</p>
</td></tr>
<tr><td><code id="group_+3A_max">max</code></td>
<td>
<p>The maximum number of preferences to format per subject.</p>
</td></tr>
<tr><td><code id="group_+3A_width">width</code></td>
<td>
<p>The maximum width in number of characters to format the
preferences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>grouped_preferences</code>, which is a vector of
of group IDs with the following attributes:
</p>
<table>
<tr><td><code>preferences</code></td>
<td>
<p> The <code>preferences</code> object.</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p> An index matching each preference set to each group ID.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# ungrouped preferences (5 preference sets, 4 items)
R &lt;- as.preferences(
  matrix(c(
    1, 2, 0, 0,
    0, 2, 1, 0,
    0, 0, 1, 2,
    2, 1, 0, 0,
    0, 1, 2, 3
  ), ncol = 4, byrow = TRUE),
  format = "ranking",
  item_names = LETTERS[1:4]
)
length(R)

# group preferences (first three in group 1, next two in group 2)
G &lt;- group(R, c(1, 1, 1, 2, 2))
length(G)

## by default up to 2 preference sets are shown per group, "..." indicates if
## there are further preferences
G
print(G, max = 1)

## select preferences from group 1
G[1, ]

## exclude item 3 from preferences
G[, -3]

## Project preferences in all groups to their first preference
G[, 1, by.rank = TRUE]

## preferences from group 2, excluding item 3
## - note group 2 becomes the first (and only) group
G[2, -3]

# Group preferences by a factor
G &lt;- group(R, factor(c("G1", "G1", "G1", "G2", "G2")))

G
print(G, max = 1)

## select preferences from group G1
G["G1"]

</code></pre>

<hr>
<h2 id='preferences'>Preferences Object</h2><span id='topic+preferences'></span><span id='topic++5B.preferences'></span><span id='topic+as.preferences'></span><span id='topic+as.preferences.grouped_preferences'></span><span id='topic+as.preferences.default'></span><span id='topic+as.preferences.matrix'></span><span id='topic+as.preferences.aggregated_preferences'></span><span id='topic+format.preferences'></span>

<h3>Description</h3>

<p>Create a <code>preferences</code> object for representing Ordinal Preference datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preferences(
  data,
  format = c("long", "ordering", "ranking"),
  id = NULL,
  rank = NULL,
  item = NULL,
  item_names = NULL,
  frequencies = NULL,
  aggregate = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'preferences'
x[i, j, ..., by.rank = FALSE, as.ordering = FALSE]

as.preferences(x, ...)

## S3 method for class 'grouped_preferences'
as.preferences(x, aggregate = FALSE, verbose = TRUE, ...)

## Default S3 method:
as.preferences(
  x,
  format = c("long", "ranking", "ordering"),
  id = NULL,
  item = NULL,
  rank = NULL,
  item_names = NULL,
  aggregate = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'matrix'
as.preferences(
  x,
  format = c("long", "ranking"),
  id = NULL,
  item = NULL,
  rank = NULL,
  item_names = NULL,
  aggregate = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'aggregated_preferences'
as.preferences(x, ...)

## S3 method for class 'preferences'
format(x, width = 40L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preferences_+3A_data">data</code></td>
<td>
<p>A data frame or matrix in one of three formats:
</p>

<dl>
<dt>&quot;ordering&quot;</dt><dd><p>Orderings must be a data frame with list-valued
columns. Each row represents an ordering of the items
from first to last, representing ties by a list of
vectors corresponding to the items.</p>
</dd>
<dt>&quot;ranking&quot;</dt><dd><p>Each row assigns a rank to each item, with columns
representing items.  Note that rankings will be converted
to 'dense' rankings in the output (see Details).</p>
</dd>
<dt>&quot;long&quot;</dt><dd><p>Three columns: an <code>id</code> column grouping the rows which
correspond to a single set of preferences, an
<code>item</code> column specifying (either by index or by
name) the item each row refers to, and a <code>rank</code>
column specifying the rank for the associated
item.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="preferences_+3A_format">format</code></td>
<td>
<p>The format of the data: one of &quot;ordering&quot;, &quot;ranking&quot;, or
&quot;long&quot; (see above). By default, <code>data</code> is assumed to be in &quot;long&quot; format.</p>
</td></tr>
<tr><td><code id="preferences_+3A_id">id</code></td>
<td>
<p>For <code>data</code> in long-format: the column representing the
preference set grouping.</p>
</td></tr>
<tr><td><code id="preferences_+3A_rank">rank</code></td>
<td>
<p>For <code>data</code> in long-format: the column representing the
rank for the associated item.</p>
</td></tr>
<tr><td><code id="preferences_+3A_item">item</code></td>
<td>
<p>For <code>data</code> in long-format: the column representing
the items by name or by index, in which case the
<code>item_names</code> parameter should also be passed, or the items will be named as
integers.</p>
</td></tr>
<tr><td><code id="preferences_+3A_item_names">item_names</code></td>
<td>
<p>The names of the full set of items. When loading data using
integer-valued indices in place of item names, the <code>item_names</code> character
vector should be in the correct order.</p>
</td></tr>
<tr><td><code id="preferences_+3A_frequencies">frequencies</code></td>
<td>
<p>An optional integer vector containing the number of
occurences of each preference. If provided, the method will return a
<code><a href="#topic+aggregate.preferences">aggregated_preferences</a></code> object with the
corresponding frequencies.</p>
</td></tr>
<tr><td><code id="preferences_+3A_aggregate">aggregate</code></td>
<td>
<p>If <code>TRUE</code>, aggregate the preferences via
<code><a href="#topic+aggregate.preferences">aggregate.preferences</a></code> before returning. This
returns an <code><a href="#topic+aggregate.preferences">aggregated_preferences</a></code> object.</p>
</td></tr>
<tr><td><code id="preferences_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, diagnostic messages will be sent to stdout.</p>
</td></tr>
<tr><td><code id="preferences_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="preferences_+3A_x">x</code></td>
<td>
<p>The <code>preferences</code> object to subset.</p>
</td></tr>
<tr><td><code id="preferences_+3A_i">i</code></td>
<td>
<p>The index of the preference-set to access.</p>
</td></tr>
<tr><td><code id="preferences_+3A_j">j</code></td>
<td>
<p>The item names or indices to project onto, e.g. if <code>j = 1</code> the
preferences will be projected only onto the first item; if <code>by.rank = TRUE</code>
<code>j</code> corresponds to the rank of the items to subset to, e.g. if <code>j = 1</code> then
preferences will be truncated to only contain their highest-preference.</p>
</td></tr>
<tr><td><code id="preferences_+3A_by.rank">by.rank</code></td>
<td>
<p>When <code>FALSE</code>, the index <code>j</code> corresponds to items, when true
the index corresponds to rank.</p>
</td></tr>
<tr><td><code id="preferences_+3A_as.ordering">as.ordering</code></td>
<td>
<p>When <code>FALSE</code>, returns a <code>preferences</code> object:
internally rows <code class="reqn">i</code> contain the ranking assigned to each item
in preference <code class="reqn">p_i</code>. When <code>TRUE</code>, returns a data frame where
columns group the items by rank.</p>
</td></tr>
<tr><td><code id="preferences_+3A_width">width</code></td>
<td>
<p>The width in number of characters to format each preference,
truncating by &quot;...&quot; when they are too long.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ordinal preferences can order every item, or they can order a subset. Some
ordinal preference datasets will contain ties between items at a given rank.
Hence, there are four distinct types of preferential data:
</p>

<dl>
<dt><code>soc</code></dt><dd><p>Strict Orders - Complete List</p>
</dd>
<dt><code>soi</code></dt><dd><p>Strict Orders - Incomplete List</p>
</dd>
<dt><code>toc</code></dt><dd><p>Orders with Ties - Complete List</p>
</dd>
<dt><code>toi</code></dt><dd><p>Orders with Ties - Incomplete List</p>
</dd>
</dl>

<p>The data type is stored alongside the <code>preferences</code> as an attribute
<code>attr(preferences, "preftype")</code>. The data type is determined automatically.
If every preference ranks every item, then the data type will be
&quot;soc&quot; or &quot;soi&quot;. Similarly, if no preference contains a tie the data type
will be &quot;toc&quot; or &quot;toi&quot;.
</p>
<p>A set of preferences can be represented either by <code>ranking</code> or by
<code>ordering</code>. These correspond to the two ways you can list a set of
preferences in a vector:
</p>

<dl>
<dt><code>ordering</code></dt><dd><p>The items are listed in order of most preferred to least
preferred, allowing for multiple items being in the
same place in the case of ties.</p>
</dd>
<dt><code>ranking</code></dt><dd><p>A rank is assigned to each item.  Conventionally, ranks are
integers in increasing order (with larger values
indicating lower preference), but they can be any
ordinal values.  Any given rankings will be converted
to 'dense' rankings: positive integers from 1 to some
maximum rank, with no gaps between ranks.</p>
</dd>
</dl>

<p>When reading preferences from an <code>ordering</code> matrix, the index on the
items is the order passed to the <code>item_names</code> parameter. When reading from
a <code>rankings</code> matrix, if no <code>item_names</code> are provided, the order is inferred
from the named columns.
</p>
<p>A <code>preferences</code> object can also be read from a long-format matrix, where
there are three columns: <code>id</code>, <code>item</code> and <code>rank</code>. The <code>id</code> variable groups
the rows of the matrix which correspond to a single set of preferences, which
the <code>item:rank</code>, pairs indicate how each item is ranked. When reading a
matrix from this format and no <code>item_names</code> parameter is passed, the order is
determined automatically.
</p>


<h3>Value</h3>

<p>By default, a <code>preferences</code> object, which is a data frame with
list-valued columns corresponding to preferences on the items. This may
be an ordering on subsets of the items in the case of ties, or a
potentially-partial strict ordering. In the case of partial or tied
preferences, some entries may be empty lists.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create rankings from data in long form

# Example long-form data
x &lt;- data.frame(
  id = c(rep(1:4, each = 4), 5, 5, 5),
  item = c(
    LETTERS[c(1:3, 3, 1:4, 2:5, 1:2, 1)], NA,
    LETTERS[3:5]
  ),
  rank = c(4:1, rep(NA, 4), 3:4, NA, NA, 1, 3, 4, 2, 2, 2, 3)
)

# * Set #1 has two different ranks for the same item (item C
# has rank 1 and 2). This item will be excluded from the preferences.
# * All ranks are missing in set #2, a technically valid partial ordering
# * Some ranks are missing in set #3, a perfectly valid partial ordering
# * Set #4 has inconsistent ranks for two items, and a rank with a
# missing item.
# * Set #5 is not a dense ranking. It will be converted to be dense and then
# inferred to be a regular partial ordering with ties.
split(x, x$rank)

# Creating a preferences object with this data will attempt to resolve these
# issues automatically, sending warnings when assumptions need to be made.
preferences(x, id = "id", item = "item", rank = "rank")

# Convert an existing matrix of rankings to a preferences object.
rnk &lt;- matrix(c(
  1, 2, 0, 0,
  4, 1, 2, 3,
  2, 1, 1, 1,
  1, 2, 3, 0,
  2, 1, 1, 0,
  1, 0, 3, 2
), nrow = 6, byrow = TRUE)
colnames(rnk) &lt;- c("apple", "banana", "orange", "pear")

rnk &lt;- as.preferences(rnk, format = "ranking")

# Convert an existing data frame of orderings to a preferences object.
e &lt;- character() # short-hand for empty ranks
ord &lt;- preferences(
  as.data.frame(
    rbind(
      list(1, 2, e, e), # apple, banana
      list("banana", "orange", "pear", "apple"),
      list(c("banana", "orange", "pear"), "apple", e, e),
      list("apple", "banana", "orange", e),
      list(c("banana", "orange"), "apple", e, e),
      list("apple", "pear", "orange", e)
    )
  ),
  format = "ordering",
  item_names = c("apple", "banana", "orange", "pear")
)

# Access the first three sets of preferences
ord[1:3, ]

# Truncate preferences to the top 2 ranks
ord[, 1:2, by_rank = TRUE]

# Exclude pear from the rankings
ord[, -4]

# Get the highest-ranked items and return as a data.frame of orderings
ord[, 1, by_rank = TRUE, as.ordering = TRUE]

# Convert the preferences to a ranking matrix
as.matrix(ord)

# Get the rank of apple in the third preference-set
as.matrix(ord)[3, 1]

# Get all the ranks assigned to apple as a vector
as.matrix(ord)[, "apple"]

</code></pre>

<hr>
<h2 id='read_preflib'>Read Ordinal Preference Data From PrefLib</h2><span id='topic+read_preflib'></span>

<h3>Description</h3>

<p>Read orderings from <code>.soc</code>, <code>.soi</code>, <code>.toc</code> or <code>.toi</code> files storing
ordinal preference data format as defined by
<a href="https://www.preflib.org/">{PrefLib}: A Library for Preferences</a>
into a <code>preferences</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_preflib(
  file,
  from_preflib = FALSE,
  preflib_url = "https://www.preflib.org/static/data"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_preflib_+3A_file">file</code></td>
<td>
<p>A preferential data file, conventionally with extension <code>.soc</code>,
<code>.soi</code>, <code>.toc</code> or <code>.toi</code> according to data type.</p>
</td></tr>
<tr><td><code id="read_preflib_+3A_from_preflib">from_preflib</code></td>
<td>
<p>A logical which, when <code>TRUE</code> will attempt to source
the file from PrefLib by adding the database <code>HTTP</code> prefix.</p>
</td></tr>
<tr><td><code id="read_preflib_+3A_preflib_url">preflib_url</code></td>
<td>
<p>The URL which will be preprended to <code>file</code>, if
<code>from_preflib</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that PrefLib refers to the items being ordered by &quot;alternatives&quot;.
</p>
<p>The file types supported are
</p>

<dl>
<dt>.soc</dt><dd><p>Strict Orders - Complete List</p>
</dd>
<dt>.soi</dt><dd><p>Strict Orders - Incomplete List</p>
</dd>
<dt>.toc</dt><dd><p>Orders with Ties - Complete List</p>
</dd>
<dt>.toi</dt><dd><p>Orders with Ties - Incomplete List</p>
</dd>
</dl>

<p>The numerically coded orderings and their frequencies are read into a
data frame, storing the item names as an attribute. The
<code>as.aggregated_preferences</code> method converts these to an
<code><a href="#topic+aggregate.preferences">aggregated_preferences</a></code> object with the
items labelled by name.
</p>
<p>A PrefLib file may be corrupt, in the sense that the ordered alternatives do
not match their names. In this case, the file can be read in as a data
frame (with a warning), but <code>as.aggregated_preferences</code> will throw an error.
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+aggregate.preferences">aggregated_preferences</a></code> object
containing the PrefLib data.
</p>


<h3>Note</h3>

<p>The Netflix and cities datasets used in the examples are from
Caragiannis et al (2017) and Bennet and Lanning (2007) respectively. These
data sets require a citation for re-use.
</p>


<h3>References</h3>

<p>Mattei, N. and Walsh, T. (2013) PrefLib: A Library of Preference Data.
<em>Proceedings of Third International Conference on Algorithmic Decision
Theory (ADT 2013)</em>. Lecture Notes in Artificial Intelligence, Springer.
</p>
<p>Bennett, J. and Lanning, S. (2007) The Netflix Prize.
<em>Proceedings of The KDD Cup and Workshops</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Can take a little while depending on speed of internet connection


# strict complete orderings of four films on Netflix
netflix &lt;- read_preflib("netflix/00004-00000138.soc", from_preflib = TRUE)
head(netflix)
names(netflix$preferences)

# strict incomplete orderings of 6 random cities from 36 in total
cities &lt;- read_preflib("cities/00034-00000001.soi", from_preflib = TRUE)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+str'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>utils</dt><dd><p><code><a href="utils.html#topic+str">str</a></code></p>
</dd>
</dl>

<hr>
<h2 id='write_preflib'>Write Ordinal Preference Data to PrefLib Formats</h2><span id='topic+write_preflib'></span>

<h3>Description</h3>

<p>Write <code>preferences</code> to <code>.soc</code>, <code>.soi</code>, <code>.toc</code> or <code>.toi</code> file types, as
defined by the PrefLib specification:
<a href="https://www.preflib.org/">{PrefLib}: A Library for Preferences</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_preflib(
  x,
  file = "",
  title = NULL,
  publication_date = NULL,
  modification_type = NULL,
  modification_date = NULL,
  description = NULL,
  relates_to = NULL,
  related_files = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_preflib_+3A_x">x</code></td>
<td>
<p>An <code>aggregated_preferences</code> object to write to file. If <code>x</code> is of a
different class, it attempts to coerce <code>x</code> into an <code>aggregated_preferences</code>
object via <code>as.aggregated_preferences()</code>.</p>
</td></tr>
<tr><td><code id="write_preflib_+3A_file">file</code></td>
<td>
<p>Either a character string naming the a file or a writeable,
open connection. The empty string <code>""</code> will write to stdout.</p>
</td></tr>
<tr><td><code id="write_preflib_+3A_title">title</code></td>
<td>
<p>The title of the data file, for instance the name of the
election represented in the data file. If not provided, we check for the
presence of <code>attr(x, "preflib")</code>, and if it exists we check for <code>TITLE</code>.</p>
</td></tr>
<tr><td><code id="write_preflib_+3A_publication_date">publication_date</code></td>
<td>
<p>The date at which the data file was published for the
first time. If not provided, we check for the presence of
<code>attr(x, "preflib")</code>, and if it exists we check for <code style="white-space: pre;">&#8288;PUBLICATION DATE&#8288;</code>.</p>
</td></tr>
<tr><td><code id="write_preflib_+3A_modification_type">modification_type</code></td>
<td>
<p>The modification type of the data: one of
<code>original</code>, <code>induced</code>, <code>imbued</code> or <code>synthetic</code> (see <code>Details</code>). If not
provided, we check for the presence of <code>attr(x, "preflib")</code>, and if it exists
we check for <code style="white-space: pre;">&#8288;MODIFICATION TYPE&#8288;</code>.</p>
</td></tr>
<tr><td><code id="write_preflib_+3A_modification_date">modification_date</code></td>
<td>
<p>The last time the data was modified. If not
provided, we check for the presence of <code>attr(x, "preflib")</code>, and if it exists
we check for <code style="white-space: pre;">&#8288;MODIFICATION DATE&#8288;</code>.</p>
</td></tr>
<tr><td><code id="write_preflib_+3A_description">description</code></td>
<td>
<p>A description of the data file, providing additional
information about it. If not provided, we check for the presence of
<code>attr(x, "preflib")</code>, and if it exists we check for <code>DESCRIPTION</code>.</p>
</td></tr>
<tr><td><code id="write_preflib_+3A_relates_to">relates_to</code></td>
<td>
<p>The name of the data file that the current file relates to,
typically the source file in case the current file has been derived from
another one. If not provided, we check for the presence of
<code>attr(x, "preflib")</code>, and if it exists we check for <code style="white-space: pre;">&#8288;RELATES TO&#8288;</code>.</p>
</td></tr>
<tr><td><code id="write_preflib_+3A_related_files">related_files</code></td>
<td>
<p>The list of all the data files related to this one,
comma separated. If not provided, we check for the presence of
<code>attr(x, "preflib")</code>, and if it exists we check for <code style="white-space: pre;">&#8288;RELATED FILES&#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The file types supported are
</p>

<dl>
<dt>.soc</dt><dd><p>Strict Orders - Complete List</p>
</dd>
<dt>.soi</dt><dd><p>Strict Orders - Incomplete List</p>
</dd>
<dt>.toc</dt><dd><p>Orders with Ties - Complete List</p>
</dd>
<dt>.toi</dt><dd><p>Orders with Ties - Incomplete List</p>
</dd>
</dl>

<p>The PrefLib format specification requires some additional metadata. Note
that the additional metadata required for the PrefLib specification is not
necessarily required for the <code>write_preflib</code> method; any missing fields
required by the PrefLib format will simply show &quot;NA&quot;.
</p>

<dl>
<dt>TITLE (required)</dt><dd>
<p>The title of the data file, for instance the year of the election
represented in the data file.
</p>
</dd>
<dt>DESCRIPTION (optional)</dt><dd>
<p>A description of the data file, providing additional information about it.
</p>
</dd>
<dt>RELATES TO (optional)</dt><dd>
<p>The name of the data file that the current file relates to, typically the
source file in case the current file has been derived from another one.
</p>
</dd>
<dt>RELATED FILES (optional)</dt><dd>
<p>The list of all the data files related to this one, comma separated.
</p>
</dd>
<dt>PUBLICATION DATE (required)</dt><dd>
<p>The date at which the data file was published for the first time.
</p>
</dd>
<dt>MODIFICATION TYPE (required)</dt><dd>
<p>The modification type of the data. One of:
</p>

<dl>
<dt>original</dt><dd><p>Data that has only been converted into a PrefLib format.</p>
</dd>
<dt>induced</dt><dd><p>Data that has been induced from another context. For
example, computing a pairwise relation from a set of strict
total orders. No assumptions have been made to create these
files, just a change in the expression language.</p>
</dd>
<dt>imbued</dt><dd><p>Data that has been imbued with extra information. For
example, extending an incomplete partial order by placing
all unranked candidates tied at the end.</p>
</dd>
<dt>synthetic</dt><dd><p>Data that has been generated artificially.</p>
</dd>
</dl>

</dd>
<dt>MODIFICATION DATE (optional)</dt><dd>
<p>The last time the data was modified.
</p>
</dd>
</dl>

<p>In addition to these fields, some required PrefLib fields will be generated
automatically depending on arguments to <code>write_preflib()</code> and the attributes
of the <code>aggregated_preferences</code> object being written to file:
</p>

<dl>
<dt>FILE NAME</dt><dd><p>The name of the output file.</p>
</dd>
<dt>DATA TYPE</dt><dd><p>The data type (one of <code>soc</code>, <code>soi</code>, <code>toc</code> or <code>toi</code>).</p>
</dd>
<dt>NUMBER ALTERNATIVES</dt><dd><p>The number of items.</p>
</dd>
<dt>ALTERNATIVE NAME <code>X</code></dt><dd><p>The name of each item, where <code>X</code> ranges from
<code>0</code> to <code>length(items)</code>.</p>
</dd>
<dt>NUMBER VOTERS</dt><dd><p>The total number of orderings.</p>
</dd>
<dt>NUMBER UNIQUE ORDERS</dt><dd><p>The number of distinct orderings.</p>
</dd>
</dl>

<p>Note that PrefLib refers to the items as &quot;alternatives&quot;.
The &quot;alternatives&quot; in the output file will be the same as the &quot;items&quot; in the
<code>aggregated_preferences</code> object.
</p>


<h3>Value</h3>

<p>No return value. Output will be written to file or stdout.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
