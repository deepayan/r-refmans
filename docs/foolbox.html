<!DOCTYPE html><html><head><title>Help for package foolbox</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {foolbox}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[.foolbox_rewrite_spec'><p>Provide list of rewrite transformations.</p></a></li>
<li><a href='#&lt;.foolbox_pipe'><p>This operator is used together with <code>rewrites</code> to transform a function</p>
after it is defined and before it is assigned to a name.</a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#add_call_callback'><p>Add a function-specific callback to the call callbacks.</p></a></li>
<li><a href='#add_topdown_callback'><p>Add a function-specific callback to the top-down callbacks.</p></a></li>
<li><a href='#annotate_assigned_symbols_callbacks'><p>Put attribute &quot;assigned_symbols&quot; on expressions bottom-up</p></a></li>
<li><a href='#annotate_bound_symbols_in_function'><p>Annotate sub-expressions with variables bound in their scope.</p></a></li>
<li><a href='#annotate_bound_variables_callbacks'><p>Propagate parameters and local variables top-down to assign attribute</p>
&quot;bound&quot; to all call expressions.</a></li>
<li><a href='#collect_assigned_symbols_in_expression'><p>Extracts all the symbols that appear on the left-hand side of an</p>
assignment.</a></li>
<li><a href='#collect_from_args'><p>Collect attributes set in the arguments to a call expression.</p></a></li>
<li><a href='#depth_first_analyse_expr'><p>Analyse an expression.</p></a></li>
<li><a href='#depth_first_analyse_function'><p>Analyse the body of function.</p></a></li>
<li><a href='#depth_first_rewrite_expr'><p>Transform an expression.</p></a></li>
<li><a href='#depth_first_rewrite_function'><p>Transform the body of function.</p></a></li>
<li><a href='#identity_rewrite_callback'><p>A callback that does not do any transformation.</p></a></li>
<li><a href='#make_with_callback'><p>Create a function for setting callbacks.</p></a></li>
<li><a href='#merge_bottomup'><p>Merge the results of several bottomup results.</p></a></li>
<li><a href='#nop_topdown_callback'><p>Top-down analysis callback.</p></a></li>
<li><a href='#remove_formal'><p>Remove a parameter from the formal parameters of a function.</p></a></li>
<li><a href='#remove_formal_'><p>Remove a parameter from the formal parameters of a function.</p></a></li>
<li><a href='#rewrite_callbacks'><p>Default expression-transformation callbacks.</p></a></li>
<li><a href='#rewrite_with'><p>Functions for applying a sequence of rewrites.</p></a></li>
<li><a href='#rewrites'><p>Object for setting up a transformation pipeline when defining functions</p></a></li>
<li><a href='#warning_flags'><p>Collection of warning flags used when traversing expressions.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Function Manipulation Toolbox</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functionality for manipulating functions and translating them
    in metaprogramming.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, rlang (&ge; 0.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat, knitr, rmarkdown, microbenchmark</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mailund/foolbox">https://github.com/mailund/foolbox</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mailund/foolbox/issues">https://github.com/mailund/foolbox/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-12-15 11:26:00 UTC; mailund</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Mailund [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Mailund &lt;mailund@birc.au.dk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-12-15 22:20:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B.foolbox_rewrite_spec'>Provide list of rewrite transformations.</h2><span id='topic++5B.foolbox_rewrite_spec'></span>

<h3>Description</h3>

<p>This subscript operator is used together with <code><a href="#topic+rewrites">rewrites</a></code> to specify
a sequence of transformations to apply to a new function we define.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'foolbox_rewrite_spec'
dummy[...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.foolbox_rewrite_spec_+3A_dummy">dummy</code></td>
<td>
<p>The dummy-table <code><a href="#topic+rewrites">rewrites</a></code>. It is only here because it
allows us to use subscripts as part of the domain-specific language.</p>
</td></tr>
<tr><td><code id="+2B5B.foolbox_rewrite_spec_+3A_...">...</code></td>
<td>
<p>A list of rewrite functions.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>&lt;.foolbox_pipe</code>
</p>
<p>rewrites
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is a very simple inline function that require we
# provide the function body as it should be inserted.
# For a more detailed version, see the Tutorial vignette.
inline &lt;- function(f, fn, body) {
   body &lt;- substitute(body)
   rewrite(f) %&gt;%
     rewrite_with(
         rewrite_callbacks() %&gt;%
           add_call_callback(fn, function(expr, ...) body)
     )
}

g &lt;- function(x) x**2
h &lt;- rewrites[inline(g,y**2)] &lt; function(y) y + g(y)
h

</code></pre>

<hr>
<h2 id='+26lt+3B.foolbox_pipe'>This operator is used together with <code><a href="#topic+rewrites">rewrites</a></code> to transform a function
after it is defined and before it is assigned to a name.</h2><span id='topic++3C.foolbox_pipe'></span>

<h3>Description</h3>

<p>This operator is used together with <code><a href="#topic+rewrites">rewrites</a></code> to transform a function
after it is defined and before it is assigned to a name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'foolbox_pipe'
pipe &lt; fn
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B26lt+2B3B.foolbox_pipe_+3A_pipe">pipe</code></td>
<td>
<p>A specificiation of a a pipeline of transformations provided
using the subscript operator to <code><a href="#topic+rewrites">rewrites()</a></code>.</p>
</td></tr>
<tr><td><code id="+2B26lt+2B3B.foolbox_pipe_+3A_fn">fn</code></td>
<td>
<p>The function we wish to transform.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>[.foolbox_rewrite_spec</code>
</p>
<p>rewrites
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is a very simple inline function that require we
# provide the function body as it should be inserted.
# For a more detailed version, see the Tutorial vignette.
inline &lt;- function(f, fn, body) {
   body &lt;- substitute(body)
   rewrite(f) %&gt;%
     rewrite_with(
         rewrite_callbacks() %&gt;%
           add_call_callback(fn, function(expr, ...) body)
     )
}

g &lt;- function(x) x**2
h &lt;- rewrites[inline(g,y**2)] &lt; function(y) y + g(y)
h

</code></pre>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='add_call_callback'>Add a function-specific callback to the call callbacks.</h2><span id='topic+add_call_callback'></span>

<h3>Description</h3>

<p>This function adds to the existing call callback, rather than replace it,
by putting a callback in front of it to be tested first. The callback will
be invoked when the traversal sees a call to a specific function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_call_callback(callbacks, fn, cb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_call_callback_+3A_callbacks">callbacks</code></td>
<td>
<p>The existing callbacks.</p>
</td></tr>
<tr><td><code id="add_call_callback_+3A_fn">fn</code></td>
<td>
<p>The function to which calls should be modified.</p>
</td></tr>
<tr><td><code id="add_call_callback_+3A_cb">cb</code></td>
<td>
<p>The callback function to invoke.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The callback that is installed will be called with the usual callback
arguments (which depend on context and user-provided information to
..., see <code><a href="#topic+rewrite_callbacks">rewrite_callbacks()</a></code> and <code><a href="#topic+analysis_callbacks">analysis_callbacks()</a></code>), and additionally
the next callback in line, through the parameter <code>next_cb</code>. This can be
used to propagate information through several callbacks in a pipe-like
fashion.
</p>


<h3>Value</h3>

<pre>     The updated callbacks.
</pre>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 2 + x
cb &lt;- rewrite_callbacks() %&gt;%
   add_call_callback(f, function(expr, ...) {
       quote(2 + x)
   })
tr_f &lt;- . %&gt;% rewrite() %&gt;% rewrite_with(cb)

g &lt;- function(y) y + f(y)
tr_f(g)

</code></pre>

<hr>
<h2 id='add_topdown_callback'>Add a function-specific callback to the top-down callbacks.</h2><span id='topic+add_topdown_callback'></span>

<h3>Description</h3>

<p>This function adds to the existing topdown callback, rather than replace it,
by putting a callback in front of it to be tested first. The callback will
be invoked when the traversal sees a call to a specific function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_topdown_callback(callbacks, fn, cb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_topdown_callback_+3A_callbacks">callbacks</code></td>
<td>
<p>The existing callbacks.</p>
</td></tr>
<tr><td><code id="add_topdown_callback_+3A_fn">fn</code></td>
<td>
<p>The function to which calls should be modified.</p>
</td></tr>
<tr><td><code id="add_topdown_callback_+3A_cb">cb</code></td>
<td>
<p>The callback function to invoke.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The callback that is installed will be called with the usual callback
arguments (which depend on context and user-provided information to
..., see <code><a href="#topic+rewrite_callbacks">rewrite_callbacks()</a></code> and <code><a href="#topic+analysis_callbacks">analysis_callbacks()</a></code>), and additionally
the next callback in line, through the parameter <code>next_cb</code>. This can be
used to propagate information through several callbacks in a pipe-like
fashion.
</p>


<h3>Value</h3>

<pre>     The updated callbacks.
</pre>

<hr>
<h2 id='annotate_assigned_symbols_callbacks'>Put attribute &quot;assigned_symbols&quot; on expressions bottom-up</h2><span id='topic+annotate_assigned_symbols_callbacks'></span>

<h3>Description</h3>

<p>Put attribute &quot;assigned_symbols&quot; on expressions bottom-up
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate_assigned_symbols_callbacks
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 7.</p>

<hr>
<h2 id='annotate_bound_symbols_in_function'>Annotate sub-expressions with variables bound in their scope.</h2><span id='topic+annotate_bound_symbols_in_function'></span>

<h3>Description</h3>

<p>Extracts all the symbols that appear on the left-hand side of an assignment
or as function parameters and annotate each sub-expression with those.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate_bound_symbols_in_function(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotate_bound_symbols_in_function_+3A_fn">fn</code></td>
<td>
<p>The function whose body we should analyse</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will annotate a function's body with two attributes for each
sub-expression in the body. Each <code>call</code> expression in the body will be
annotated with these two attributes:
</p>

<ul>
<li> <p><strong>assigned_symbols</strong>: Variables that appear to the left of an
assignment in a sub-expression of the call that is likely to
affect the scope of the call.
</p>
</li>
<li> <p><strong>bound</strong>: Variables that are either assigned to, thus potentially
local in the scope, or function parameters from an enclosing scope,
which will definitely be bound at this position.
</p>
</li></ul>

<p>Since R does not require that we declare local variables, and since the
variables that are assigned to a local scope depend on the runtime execution
of functions, we cannot determine with any certainty which variables will be
assigned to in any given scope at any given program point. So the best we can
do is figure out which variables are <em>potentially</em> assigned to. Which is what
this function does.
</p>
<p>The rules for when we are assigning to a local variable are a bit
complicated. For control structures, we can assume that assignments will
be to the local scope. People can change the implementation of these so it
isn't, but then they are only hurting themselves and deserve the extra
pain we can give them. For other call arguments, it gets a little more
complicated. With standard-evaluation, if we have an arrow assignment in a
function argument, then the assignment happens in the calling scope. So we
will assume this happens unless we are handling cases we know have NSE,
such as <code>with</code>. If an assignment is inside a block, however, we will
assume that NSE <em>is</em> in play, by default, and not consider it a local
assignment.
</p>


<h3>Value</h3>

<p>A function who's expressions are annotated with potentially local
variables.
</p>

<hr>
<h2 id='annotate_bound_variables_callbacks'>Propagate parameters and local variables top-down to assign attribute
&quot;bound&quot; to all call expressions.</h2><span id='topic+annotate_bound_variables_callbacks'></span>

<h3>Description</h3>

<p>Propagate parameters and local variables top-down to assign attribute
&quot;bound&quot; to all call expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate_bound_variables_callbacks
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 7.</p>

<hr>
<h2 id='collect_assigned_symbols_in_expression'>Extracts all the symbols that appear on the left-hand side of an
assignment.</h2><span id='topic+collect_assigned_symbols_in_expression'></span><span id='topic+collect_assigned_symbols_in_function'></span>

<h3>Description</h3>

<p>Since R does not require that we declare local variables, and since
the variables that are assigned to a local scope depend on the runtime
execution of functions, we cannot determine with any certainty which
variables will be assigned to in any given scope at any given program
point. So the best we can do is figure out which variables are
<em>potentially</em> assigned to. Which is what this function does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collect_assigned_symbols_in_expression(expr, env, params = list(),
  topdown = list())

collect_assigned_symbols_in_function(fun, topdown = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collect_assigned_symbols_in_expression_+3A_expr">expr</code></td>
<td>
<p>The expression to analyse</p>
</td></tr>
<tr><td><code id="collect_assigned_symbols_in_expression_+3A_env">env</code></td>
<td>
<p>Environment in which to look up symbols.</p>
</td></tr>
<tr><td><code id="collect_assigned_symbols_in_expression_+3A_params">params</code></td>
<td>
<p>Parameters for the function being analysed (if
these are needed).</p>
</td></tr>
<tr><td><code id="collect_assigned_symbols_in_expression_+3A_topdown">topdown</code></td>
<td>
<p>Information to pass top-down in the traversal.</p>
</td></tr>
<tr><td><code id="collect_assigned_symbols_in_expression_+3A_fun">fun</code></td>
<td>
<p>The function whose body we should analyse</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+collect_assigned_symbols_in_function">collect_assigned_symbols_in_function()</a></code> function reformats the collected
data into a character vector, removes duplications, and remove the
formal parameters of the function from the list, so those are not considered
local variables (rather, they are considered formals and presumably handled
elsewhere as such).
</p>


<h3>Value</h3>

<p>A list containing the symbols that were assigned to.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>collect_assigned_symbols_in_expression</code>: Analyse an expression.
</p>
</li>
<li> <p><code>collect_assigned_symbols_in_function</code>: Analyse the body of a function.
</p>
</li></ul>

<hr>
<h2 id='collect_from_args'>Collect attributes set in the arguments to a call expression.</h2><span id='topic+collect_from_args'></span>

<h3>Description</h3>

<p>Given a call expression <code>expr</code>, this function scans the arguments to the
call and extracts the attribute <code>attribute</code> from each where the
<code>condition</code> predicate evaluates to <code>TRUE</code>, and it concatenates all these.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collect_from_args(expr, attribute, condition = function(expr) TRUE,
  include_fun = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collect_from_args_+3A_expr">expr</code></td>
<td>
<p>The expression to process.</p>
</td></tr>
<tr><td><code id="collect_from_args_+3A_attribute">attribute</code></td>
<td>
<p>The attribute we want to collect from the arguments.</p>
</td></tr>
<tr><td><code id="collect_from_args_+3A_condition">condition</code></td>
<td>
<p>A predicate. Only arguments where the condition evaluates to
<code>TRUE</code> will be included in the result.</p>
</td></tr>
<tr><td><code id="collect_from_args_+3A_include_fun">include_fun</code></td>
<td>
<p>Include the first element in a call, i.e. the function
that will be called.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list or vector obtained by concatenating the attributes from
the arguments.
</p>

<hr>
<h2 id='depth_first_analyse_expr'>Analyse an expression.</h2><span id='topic+depth_first_analyse_expr'></span>

<h3>Description</h3>

<p>Traverses the expression <code>expr</code> depth-first and analyse it it using
<code>callbacks</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depth_first_analyse_expr(expr, callbacks, params = list(),
  topdown = list(), wflags = warning_flags(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depth_first_analyse_expr_+3A_expr">expr</code></td>
<td>
<p>An R expression</p>
</td></tr>
<tr><td><code id="depth_first_analyse_expr_+3A_callbacks">callbacks</code></td>
<td>
<p>List of callbacks to apply.</p>
</td></tr>
<tr><td><code id="depth_first_analyse_expr_+3A_params">params</code></td>
<td>
<p>Parameters of the function we are analysing. If we are
working on a raw expression, just use the default, which is an empty list.</p>
</td></tr>
<tr><td><code id="depth_first_analyse_expr_+3A_topdown">topdown</code></td>
<td>
<p>A list of additional information gathered in the traversal.</p>
</td></tr>
<tr><td><code id="depth_first_analyse_expr_+3A_wflags">wflags</code></td>
<td>
<p>Warning flags, see <code><a href="#topic+warning_flags">warning_flags()</a></code>.</p>
</td></tr>
<tr><td><code id="depth_first_analyse_expr_+3A_...">...</code></td>
<td>
<p>Additional data that will be passed along to callbacks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the last bottom-up traversal.
</p>


<h3>See Also</h3>

<p>analysis_callbacks
</p>
<p>identity_analysis_callback
</p>
<p>depth_first_analyse_function
</p>

<hr>
<h2 id='depth_first_analyse_function'>Analyse the body of function.</h2><span id='topic+depth_first_analyse_function'></span>

<h3>Description</h3>

<p>Traverses the body of <code>fn</code> and analyse it based on <code>callbacks</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depth_first_analyse_function(fn, callbacks, topdown = list(),
  wflags = warning_flags(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depth_first_analyse_function_+3A_fn">fn</code></td>
<td>
<p>A (closure) function.</p>
</td></tr>
<tr><td><code id="depth_first_analyse_function_+3A_callbacks">callbacks</code></td>
<td>
<p>List of callbacks to apply.</p>
</td></tr>
<tr><td><code id="depth_first_analyse_function_+3A_topdown">topdown</code></td>
<td>
<p>A list of additional information that will be considered
top-down in the traversal.</p>
</td></tr>
<tr><td><code id="depth_first_analyse_function_+3A_wflags">wflags</code></td>
<td>
<p>Warning flags, see <code><a href="#topic+warning_flags">warning_flags()</a></code>.</p>
</td></tr>
<tr><td><code id="depth_first_analyse_function_+3A_...">...</code></td>
<td>
<p>Additional data that will be passed along to callbacks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the last bottom-up call to a callback.
</p>


<h3>See Also</h3>

<p>depth_first_analyse_expr
</p>
<p>depth_first_rewrite_function
</p>
<p>analysis_callbacks
</p>

<hr>
<h2 id='depth_first_rewrite_expr'>Transform an expression.</h2><span id='topic+depth_first_rewrite_expr'></span>

<h3>Description</h3>

<p>Traverses the expression <code>expr</code> depth-first and transform it using <code>callbacks</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depth_first_rewrite_expr(expr, callbacks, params = list(),
  topdown = list(), wflags = warning_flags(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depth_first_rewrite_expr_+3A_expr">expr</code></td>
<td>
<p>An R expression</p>
</td></tr>
<tr><td><code id="depth_first_rewrite_expr_+3A_callbacks">callbacks</code></td>
<td>
<p>List of callbacks to apply.</p>
</td></tr>
<tr><td><code id="depth_first_rewrite_expr_+3A_params">params</code></td>
<td>
<p>Parameters of the function we are rewriting. If we are
working on a raw expression, just use the default, which is an empty list.</p>
</td></tr>
<tr><td><code id="depth_first_rewrite_expr_+3A_topdown">topdown</code></td>
<td>
<p>A list of additional information gathered in the traversal.</p>
</td></tr>
<tr><td><code id="depth_first_rewrite_expr_+3A_wflags">wflags</code></td>
<td>
<p>Warning flags, see <code><a href="#topic+warning_flags">warning_flags()</a></code>.</p>
</td></tr>
<tr><td><code id="depth_first_rewrite_expr_+3A_...">...</code></td>
<td>
<p>Additional data that will be passed along to callbacks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified expression.
</p>


<h3>See Also</h3>

<p>rewrite_callbacks
</p>
<p>identity_rewrite_callback
</p>
<p>depth_first_rewrite_function
</p>

<hr>
<h2 id='depth_first_rewrite_function'>Transform the body of function.</h2><span id='topic+depth_first_rewrite_function'></span>

<h3>Description</h3>

<p>Traverses the body of <code>fn</code> and rewrite it based on <code>callbacks</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depth_first_rewrite_function(fn, callbacks, topdown = list(),
  wflags = warning_flags(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depth_first_rewrite_function_+3A_fn">fn</code></td>
<td>
<p>A (closure) function.</p>
</td></tr>
<tr><td><code id="depth_first_rewrite_function_+3A_callbacks">callbacks</code></td>
<td>
<p>List of callbacks to apply.</p>
</td></tr>
<tr><td><code id="depth_first_rewrite_function_+3A_topdown">topdown</code></td>
<td>
<p>A list of additional information that will be considered
top-down in the traversal.</p>
</td></tr>
<tr><td><code id="depth_first_rewrite_function_+3A_wflags">wflags</code></td>
<td>
<p>Warning flags, see <code><a href="#topic+warning_flags">warning_flags()</a></code>.</p>
</td></tr>
<tr><td><code id="depth_first_rewrite_function_+3A_...">...</code></td>
<td>
<p>Additional data that will be passed along to callbacks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new function similar to <code>fn</code> but with a transformed body.
</p>


<h3>See Also</h3>

<p>depth_first_rewrite_expr
</p>
<p>rewrite_callbacks
</p>

<hr>
<h2 id='identity_rewrite_callback'>A callback that does not do any transformation.</h2><span id='topic+identity_rewrite_callback'></span><span id='topic+identity_analysis_callback'></span>

<h3>Description</h3>

<p>Callbacks have one required argument, <code>expr</code>, but will actually be called
with more. The additional named parameters are:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identity_rewrite_callback(expr, ...)

identity_analysis_callback(expr, bottomup, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identity_rewrite_callback_+3A_expr">expr</code></td>
<td>
<p>The expression to (not) transform.</p>
</td></tr>
<tr><td><code id="identity_rewrite_callback_+3A_...">...</code></td>
<td>
<p>Additional named parameters.</p>
</td></tr>
<tr><td><code id="identity_rewrite_callback_+3A_bottomup">bottomup</code></td>
<td>
<p>Information gathered depth-first in analysis callbacks. This
parameter is only passed to callbacks in analysis traversals and not
rewrite traversals.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><strong>env</strong>      The function environment of the function we are transforming
</p>
</li>
<li> <p><strong>params</strong>   The formal parameters of the function we are transforming
</p>
</li>
<li> <p><strong>topdown</strong>  Data passed top-down in the traversal.
</p>
</li>
<li> <p><strong>bottomup</strong> Data collected by depth-first traversals before a callback is
called. plus whatever the user provide to <code><a href="#topic+depth_first_rewrite_function">depth_first_rewrite_function()</a></code> or
<code><a href="#topic+depth_first_analyse_function">depth_first_analyse_function()</a></code>.
</p>
</li>
<li> <p><strong>next_cb</strong> A handle to call the next callback if more are installed. This
variable will be the callback that was in the callbacks list before this one
replaced it.
</p>
</li></ul>

<p>In bottom up analyses, the <code><a href="#topic+merge_bottomup">merge_bottomup()</a></code> function can be used to
collected the results of several recursive calls. When annotating
expressions, the <code><a href="#topic+collect_from_args">collect_from_args()</a></code> can be used in <code>call</code> callbacks to
extract annotation information from call arguments.
</p>


<h3>Value</h3>

<p><code>expr</code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>identity_rewrite_callback</code>: Identity for expression rewriting
</p>
</li>
<li> <p><code>identity_analysis_callback</code>: Identity for expression rewriting
</p>
</li></ul>


<h3>See Also</h3>

<p>merge_bottomup
</p>
<p>collect_from_args
</p>

<hr>
<h2 id='make_with_callback'>Create a function for setting callbacks.</h2><span id='topic+make_with_callback'></span>

<h3>Description</h3>

<p>Create a function for setting callbacks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_with_callback(cb_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_with_callback_+3A_cb_name">cb_name</code></td>
<td>
<p>The name of the callback to set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that can be used in a pipe to set a callback.
</p>

<hr>
<h2 id='merge_bottomup'>Merge the results of several bottomup results.</h2><span id='topic+merge_bottomup'></span>

<h3>Description</h3>

<p>The <code>bottomup</code> parameter in callbacks will be calculated for all parameters
of <code>call`` expressions. The parameter to the callbacks are thus a list of lists. This function merges these lists into one that contain a list for each named component in the </code>bottomup<code>parameter. If results are not named in the</code>bottomup' list, they are discarded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_bottomup(bottomup)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_bottomup_+3A_bottomup">bottomup</code></td>
<td>
<p>List of bottom up analysis results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vectors from <code>bottomup</code> are concatenated, so one level of lists
will be flattened. Use more lists, like <code>list(list(2), list(3))</code>
if you want to prevent this.
</p>


<h3>See Also</h3>

<p>depth_first_analyse_function
</p>
<p>depth_first_analyse_expr
</p>

<hr>
<h2 id='nop_topdown_callback'>Top-down analysis callback.</h2><span id='topic+nop_topdown_callback'></span>

<h3>Description</h3>

<p>Top-down analysis callback.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nop_topdown_callback(expr, topdown, skip, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nop_topdown_callback_+3A_expr">expr</code></td>
<td>
<p>The expression before we modify it.</p>
</td></tr>
<tr><td><code id="nop_topdown_callback_+3A_topdown">topdown</code></td>
<td>
<p>Information from further up the expression tree.</p>
</td></tr>
<tr><td><code id="nop_topdown_callback_+3A_skip">skip</code></td>
<td>
<p>An escape function. If called, the transformation
or analysis traversal will skip this expression
and continue at the sibling level.</p>
</td></tr>
<tr><td><code id="nop_topdown_callback_+3A_...">...</code></td>
<td>
<p>Additional data that might be passed along</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>topdown</code> information.
</p>

<hr>
<h2 id='remove_formal'>Remove a parameter from the formal parameters of a function.</h2><span id='topic+remove_formal'></span>

<h3>Description</h3>

<p>Remove a parameter from the formal parameters of a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_formal(fn, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_formal_+3A_fn">fn</code></td>
<td>
<p>A function we are modifying</p>
</td></tr>
<tr><td><code id="remove_formal_+3A_par">par</code></td>
<td>
<p>A parameter of <code>fn</code> (should be in <code>formals(fn)</code> and not be quoted)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified function equal to <code>fn</code> but with <code>par</code> removed from the formal
parameters.
</p>

<hr>
<h2 id='remove_formal_'>Remove a parameter from the formal parameters of a function.</h2><span id='topic+remove_formal_'></span>

<h3>Description</h3>

<p>Remove a parameter from the formal parameters of a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_formal_(fn, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_formal__+3A_fn">fn</code></td>
<td>
<p>A function we are modifying</p>
</td></tr>
<tr><td><code id="remove_formal__+3A_par">par</code></td>
<td>
<p>A parameter of <code>fn</code> (should be in <code>formals(fn)</code> and be quoted)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified function equal to <code>fn</code> but with <code>par</code> removed from the formal
parameters.
</p>

<hr>
<h2 id='rewrite_callbacks'>Default expression-transformation callbacks.</h2><span id='topic+rewrite_callbacks'></span><span id='topic+analysis_callbacks'></span><span id='topic+with_atomic_callback'></span><span id='topic+with_pairlist_callback'></span><span id='topic+with_symbol_callback'></span><span id='topic+with_primitive_callback'></span><span id='topic+with_call_callback'></span><span id='topic+with_topdown_pairlist_callback'></span><span id='topic+with_topdown_call_callback'></span>

<h3>Description</h3>

<p>Callbacks must be functions that take three arguments: The expression to
rewrite, the environment of the function we are rewriting (i.e. the
environment it is defined in, not the function call frame), and a list of
formal parameters of the function we are translating.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rewrite_callbacks()

analysis_callbacks()

with_atomic_callback(callbacks, fn)

with_pairlist_callback(callbacks, fn)

with_symbol_callback(callbacks, fn, include_missing = FALSE)

with_primitive_callback(callbacks, fn)

with_call_callback(callbacks, fn)

with_topdown_pairlist_callback(callbacks, fn)

with_topdown_call_callback(callbacks, fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rewrite_callbacks_+3A_callbacks">callbacks</code></td>
<td>
<p>The list of callbacks</p>
</td></tr>
<tr><td><code id="rewrite_callbacks_+3A_fn">fn</code></td>
<td>
<p>A function to install as a callback.</p>
</td></tr>
<tr><td><code id="rewrite_callbacks_+3A_include_missing">include_missing</code></td>
<td>
<p>For symbols, it is possible that the expression is
missing. This can happen in pair-lists if a function parameter does not
have a default argument. By default, the callback is not invoked on missing
expressions&ndash;there is very little you can do with them &ndash; but you can
include them by setting this parameter to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The flow of a depth-first traversal is as follows:
</p>
<p>For expressions that are atomic, i.e. are either atomic values, pairlists,
symbols, or primitives, the corresponding callback is called with the
expression. The callbacks are called with the expression, <code>expr</code>, the
environment of the function we are traversing, <code>env</code>, the parameters of that
function, <code>params</code>, information collected top-down in <code>topdown</code>, warning
flags through the <code>wflags</code> parameter, and any additional user-provided
arguments through <code>...</code>. If the callbacks are used in a rewrite traversal,
see <code><a href="#topic+depth_first_rewrite_function">depth_first_rewrite_function()</a></code>, they must return an expression. This
expression will be inserted as a substitute of the <code>expr</code> argument in the
function being rewritten. If the callback is part of an analysis, see
<code><a href="#topic+depth_first_analyse_function">depth_first_analyse_function()</a></code>, then it can return any data; what it
returns will be provided to the callbacks on the enclosing expression via the
<code>bottomup</code> parameter.
</p>
<p>For <code>call</code> expressions, the <code>topdown</code> callback is invoked before the call is
traversed. It is provided with the same arguments as the other callbacks and
in addition a thunk <code>skip</code> that it can use to prevent the depth-first
traversal to explore the call further. Whatever the <code>topdown</code> callback
returns will be provided to the call callback via the argument <code>topdown</code> it
it is called (i.e. if the <code>topdown</code> callback doesn't invoke <code>skip</code>).
</p>
<p>After the <code>topdown</code> callback is executed, if it doesn't call <code>skip</code>, the
<code>call</code> callback is called on the expression. It is called with the same
arguments as the other callbacks, and must return an expression if part of a
rewrite traversal or any collected information if part of an analysis
traversal.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>rewrite_callbacks</code>: Default callbacks for rewriting expressions
</p>
</li>
<li> <p><code>analysis_callbacks</code>: Default callbacks for analysing expressions
</p>
</li>
<li> <p><code>with_atomic_callback</code>: Set the atomic callback function.
</p>
</li>
<li> <p><code>with_pairlist_callback</code>: Set the pairlist callback function.
</p>
</li>
<li> <p><code>with_symbol_callback</code>: Set the symbol callback function.
</p>
</li>
<li> <p><code>with_primitive_callback</code>: Set the primitive callback function.
</p>
</li>
<li> <p><code>with_call_callback</code>: Set the call callback function.
</p>
</li>
<li> <p><code>with_topdown_pairlist_callback</code>: Set the topdown information-passing callback
function for pair-lists
</p>
</li>
<li> <p><code>with_topdown_call_callback</code>: Set the topdown information-passing callback
function for calls.
</p>
</li></ul>


<h3>See Also</h3>

<p>with_atomic_callback
</p>
<p>with_symbol_callback
</p>
<p>with_primitive_callback
</p>
<p>with_pairlist_callback
</p>
<p>with_call_callback
</p>
<p>with_topdown_pairlist_callback
</p>
<p>with_topdown_call_callback
</p>
<p>warning_flags
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 2 + x
cb &lt;- rewrite_callbacks() %&gt;%
   add_call_callback(f, function(expr, ...) {
       quote(2 + x)
   })
tr_f &lt;- . %&gt;% rewrite() %&gt;% rewrite_with(cb)

g &lt;- function(y) y + f(y)
tr_f(g)

collect_symbols &lt;- function(expr, ...) {
   list(symbols = as.character(expr))
}
callbacks &lt;- analysis_callbacks() %&gt;% with_symbol_callback(collect_symbols)
f %&gt;% analyse() %&gt;% analyse_with(callbacks)

</code></pre>

<hr>
<h2 id='rewrite_with'>Functions for applying a sequence of rewrites.</h2><span id='topic+rewrite_with'></span><span id='topic+rewrite'></span><span id='topic+analyse'></span><span id='topic+analyse_with'></span><span id='topic+rewrite_expr'></span><span id='topic+rewrite_expr_with'></span><span id='topic+analyse_expr'></span><span id='topic+analyse_expr_with'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+rewrite">rewrite()</a></code> function applies a series of transformations to an input
function, <code>fn</code> and returns the result. This result can then be used in a
pipeline of <code><a href="#topic+rewrite_with">rewrite_with()</a></code> calls for further analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rewrite_with(fn, callbacks, ...)

rewrite(fn)

analyse(fn)

analyse_with(fn, callbacks, ...)

rewrite_expr(expr)

rewrite_expr_with(expr, callbacks, ...)

analyse_expr(expr)

analyse_expr_with(expr, callbacks, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rewrite_with_+3A_fn">fn</code></td>
<td>
<p>The function to rewrite</p>
</td></tr>
<tr><td><code id="rewrite_with_+3A_callbacks">callbacks</code></td>
<td>
<p>The callbacks that should do the rewriting</p>
</td></tr>
<tr><td><code id="rewrite_with_+3A_...">...</code></td>
<td>
<p>Additional parameters passed along to the callbacks.</p>
</td></tr>
<tr><td><code id="rewrite_with_+3A_expr">expr</code></td>
<td>
<p>When invoked on expressions, in <code><a href="#topic+rewrite_expr">rewrite_expr()</a></code>, the expression
to rewrite.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The flow of transformations goes starts with <code><a href="#topic+rewrite">rewrite()</a></code> and is followed by a
series of <code><a href="#topic+rewrite_with">rewrite_with()</a></code> for additional rewrite callbacks. For analysis, it
starts with <code><a href="#topic+analyse">analyse()</a></code> and is followed by a pipeline of <code><a href="#topic+analyse_with">analyse_with()</a></code>.
</p>
<p>This functions will annotate a function's body with two attributes for each
sub-expression in the body. Each <code>call</code> expression in the body will be
annotated with these two attributes:
</p>

<ul>
<li> <p><strong>assigned_symbols</strong>: Variables that appear to the left of an
assignment in a sub-expression of the call that is likely to
affect the scope of the call.
</p>
</li>
<li> <p><strong>bound</strong>: Variables that are either assigned to, thus potentially
local in the scope, or function parameters from an enclosing scope,
which will definitely be bound at this position.
</p>
</li></ul>

<p>Since R does not require that we declare local variables, and since the
variables that are assigned to a local scope depend on the runtime execution
of functions, we cannot determine with any certainty which variables will be
assigned to in any given scope at any given program point. So the best we can
do is figure out which variables are <em>potentially</em> assigned to. Which is what
this function does.
</p>
<p>The rules for when we are assigning to a local variable are a bit
complicated. For control structures, we can assume that assignments will
be to the local scope. People can change the implementation of these so it
isn't, but then they are only hurting themselves and deserve the extra
pain we can give them. For other call arguments, it gets a little more
complicated. With standard-evaluation, if we have an arrow assignment in a
function argument, then the assignment happens in the calling scope. So we
will assume this happens unless we are handling cases we know have NSE,
such as <code>with</code>. If an assignment is inside a block, however, we will
assume that NSE <em>is</em> in play, by default, and not consider it a local
assignment.
</p>


<h3>Value</h3>

<p>A rewritten function
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>rewrite_with</code>: Apply <code>callbacks</code> over <code>fn</code> to rewrite it.
</p>
</li>
<li> <p><code>rewrite</code>: Function for starting a rewrite.
</p>
</li>
<li> <p><code>analyse</code>: Function for running analysis callbacks
</p>
</li>
<li> <p><code>analyse_with</code>: Apply <code>callbacks</code> over <code>fn</code> to analyse it.
</p>
</li>
<li> <p><code>rewrite_expr</code>: Expression version of <code><a href="#topic+rewrite">rewrite()</a></code>
</p>
</li>
<li> <p><code>rewrite_expr_with</code>: Expression version of <code><a href="#topic+rewrite_with">rewrite_with()</a></code>
</p>
</li>
<li> <p><code>analyse_expr</code>: Expression version of <code><a href="#topic+analyse">analyse()</a></code>
</p>
</li>
<li> <p><code>analyse_expr_with</code>: Expression version of <code><a href="#topic+analyse_with">analyse_with()</a></code>
</p>
</li></ul>


<h3>See Also</h3>

<p>rewrite_callbacks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 2 + x
cb &lt;- rewrite_callbacks() %&gt;%
   add_call_callback(f, function(expr, ...) {
       quote(2 + x)
   })
tr_f &lt;- . %&gt;% rewrite() %&gt;% rewrite_with(cb)

g &lt;- function(y) y + f(y)
tr_f(g)

collect_symbols &lt;- function(expr, ...) {
   list(symbols = as.character(expr))
}
callbacks &lt;- analysis_callbacks() %&gt;% with_symbol_callback(collect_symbols)
f %&gt;% analyse() %&gt;% analyse_with(callbacks)

</code></pre>

<hr>
<h2 id='rewrites'>Object for setting up a transformation pipeline when defining functions</h2><span id='topic+rewrites'></span>

<h3>Description</h3>

<p>Object for setting up a transformation pipeline when defining functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rewrites
</code></pre>


<h3>Format</h3>

<p>An object of class <code>foolbox_rewrite_spec</code> of length 1.</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is a very simple inline function that require we
# provide the function body as it should be inserted.
# For a more detailed version, see the Tutorial vignette.
# For a version that permits partial evaluation, see that vignette.
inline &lt;- function(f, fn, body) {
   body &lt;- substitute(body)
   rewrite(f) %&gt;%
     rewrite_with(
         rewrite_callbacks() %&gt;%
           add_call_callback(fn, function(expr, ...) body)
     )
}

g &lt;- function(x) x**2
h &lt;- rewrites[inline(g,y**2)] &lt; function(y) y + g(y)
h

</code></pre>

<hr>
<h2 id='warning_flags'>Collection of warning flags used when traversing expressions.</h2><span id='topic+warning_flags'></span><span id='topic+set_warn_on_unknown_function'></span><span id='topic+unset_warn_on_unknown_function'></span><span id='topic+set_warn_on_local_function'></span><span id='topic+unset_warn_on_local_function'></span>

<h3>Description</h3>

<p>These are flags for turning warnings on or off when traversing expression
trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warning_flags()

set_warn_on_unknown_function(flags)

unset_warn_on_unknown_function(flags)

set_warn_on_local_function(flags)

unset_warn_on_local_function(flags)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warning_flags_+3A_flags">flags</code></td>
<td>
<p>Used when setting or unsetting flags.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The flags can be provided to transformation and analysis functions, and be
set or unset by the <code>set_</code>/<code>unset_</code> functions. The meaning of the flags are:
</p>

<ul>
<li> <p><strong>warn_on_unknown_function:</strong> If you have installed a callback with
<code><a href="#topic+add_call_callback">add_call_callback()</a></code> or <code><a href="#topic+add_topdown_callback">add_topdown_callback()</a></code>, the traversal code will
check if a given call is to a known function installed by one of these. If
the function name of a call is not recognised as a function parameter or a
local variable, as annotated with <code><a href="#topic+annotate_bound_symbols_in_function">annotate_bound_symbols_in_function()</a></code>,
then the code will issue a warning if this flag is set. The warning behaviour
depends on whether <code><a href="#topic+annotate_bound_symbols_in_function">annotate_bound_symbols_in_function()</a></code> has analysed the
function. If it hasn't, then we only consider function parameters as local
variables. If it has, we have more information about the local variables, so
we can make the warnings more accurate. The flag is set by default.
</p>
</li>
<li> <p><strong>warn_on_local_function:</strong> If you have installed a callback with
<code><a href="#topic+add_call_callback">add_call_callback()</a></code> or <code><a href="#topic+add_topdown_callback">add_topdown_callback()</a></code>, the traversal code will
check if a given call is to a known function installed by one of these. If
you have installed a function that has a name-clash with a local variable,
and this flag is set, then you will get a warning. If you have annotated the
expression tree using <code><a href="#topic+annotate_bound_symbols_in_function">annotate_bound_symbols_in_function()</a></code>, then the
warning will be invoked both on local variables and function parameters; if
you have not annotated the expression tree, then it will only be invoked on
function arguments. The flag is set by default.
</p>
</li></ul>

<p>Since R is a very dynamic language, it is not possible to know which local
variables might refer to functions and which do not &ndash; and R will look for
functions if a variable is used as a call and potentially skip past a local
variable that refers to a non-function &ndash; so the warnings are based on
heuristics in identifying local variables and are conservative in the sense
that they assume that if a call is to a name that matches a local variable,
then it is the local variable that is being called.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>set_warn_on_unknown_function</code>: Enable warnings when encountering an unknown
function
</p>
</li>
<li> <p><code>unset_warn_on_unknown_function</code>: Disable warnings when encountering an unknown
function
</p>
</li>
<li> <p><code>set_warn_on_local_function</code>: Enable warnings when encountering a local variable
with a name that matches one installed for transformation.
</p>
</li>
<li> <p><code>unset_warn_on_local_function</code>: Disable warnings when encountering a local variable
with a name that matches one installed for transformation.
</p>
</li></ul>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
