<!DOCTYPE html><html><head><title>Help for package ddtlcm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ddtlcm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#a_t_one'><p>Compute divergence function</p></a></li>
<li><a href='#a_t_two'><p>Compute divergence function</p></a></li>
<li><a href='#add_leaf_branch'><p>Add a leaf branch to an existing tree tree_old</p></a></li>
<li><a href='#add_multichotomous_tip'><p>Add a leaf branch to an existing tree tree_old to make a multichotomus branch</p></a></li>
<li><a href='#add_one_sample'><p>Functions to simulate trees and node parameters from a DDT</p>
process.
Add a branch to an existing tree according to the branching process of DDT</a></li>
<li><a href='#add_root'><p>Add a singular root node to an existing nonsingular tree</p></a></li>
<li><a href='#attach_subtree'><p>Attach a subtree to a given DDT at a randomly selected location</p></a></li>
<li><a href='#compute_IC'><p>Compute information criteria for the DDT-LCM model</p></a></li>
<li><a href='#create_leaf_cor_matrix'><p>Create a tree-structured covariance matrix from a given tree</p></a></li>
<li><a href='#data_synthetic'><p>Synthetic data example</p></a></li>
<li><a href='#ddtlcm_fit'><p>MH-within-Gibbs sampler to sample from the full posterior</p>
distribution of DDT-LCM</a></li>
<li><a href='#ddtlcm-package'><p>ddtlcm: Latent Class Analysis with Dirichlet Diffusion Tree Process Prior</p></a></li>
<li><a href='#div_time'><p>Sample divergence time on an edge uv previously traversed by m(v) data points</p></a></li>
<li><a href='#draw_mnorm'><p>Efficiently sample multivariate normal using precision matrix</p>
from <code class="reqn">x ~ N(Q^{-1}a, Q^{-1})</code>, where <code class="reqn">Q^{-1}</code> is the precision matrix</a></li>
<li><a href='#exp_normalize'><p>Compute normalized probabilities: exp(x_i) / sum_j exp(x_j)</p></a></li>
<li><a href='#expit'><p>The expit function</p></a></li>
<li><a href='#H_n'><p>Harmonic series</p></a></li>
<li><a href='#initialize'><p>Initialize the MH-within-Gibbs algorithm for DDT-LCM</p></a></li>
<li><a href='#initialize_hclust'><p>Estimate an initial binary tree on latent classes using hclust()</p></a></li>
<li><a href='#initialize_poLCA'><p>Estimate an initial response profile from latent class model using poLCA()</p></a></li>
<li><a href='#initialize_randomLCM'><p>Provide a random initial response profile based on latent class mode</p></a></li>
<li><a href='#J_n'><p>Compute factor in the exponent of the divergence time distribution</p></a></li>
<li><a href='#log_expit'><p>Numerically accurately compute f(x) = log(x / (1/x)).</p></a></li>
<li><a href='#logit'><p>The logistic function</p></a></li>
<li><a href='#logllk_ddt'><p>Calculate loglikelihood of a DDT, including the tree structure and node parameters</p></a></li>
<li><a href='#logllk_ddt_lcm'><p>Calculate loglikelihood of the DDT-LCM</p></a></li>
<li><a href='#logllk_div_time_one'><p>Compute loglikelihood of divergence times for a(t) = c/(1-t)</p></a></li>
<li><a href='#logllk_div_time_two'><p>Compute loglikelihood of divergence times for a(t) = c/(1-t)^2</p></a></li>
<li><a href='#logllk_lcm'><p>Calculate loglikelihood of the latent class model, conditional on tree structure</p></a></li>
<li><a href='#logllk_location'><p>Compute log likelihood of parameters</p></a></li>
<li><a href='#logllk_tree_topology'><p>Compute loglikelihood of the tree topology</p></a></li>
<li><a href='#parameter_diet'><p>Parameters for the HCHS dietary recall data example</p></a></li>
<li><a href='#plot_tree_with_barplot'><p>Plot the MAP tree and class profiles (bar plot) of summarized DDT-LCM results</p></a></li>
<li><a href='#plot_tree_with_heatmap'><p>Plot the MAP tree and class profiles (heatmap) of summarized DDT-LCM results</p></a></li>
<li><a href='#plot.ddt_lcm'><p>Create trace plots of DDT-LCM parameters</p></a></li>
<li><a href='#plot.summary.ddt_lcm'><p>Plot the MAP tree and class profiles of summarized DDT-LCM results</p></a></li>
<li><a href='#predict.ddt_lcm'><p>Prediction of class memberships from posterior predictive distributions</p></a></li>
<li><a href='#predict.summary.ddt_lcm'><p>Prediction of class memberships from posterior summaries</p></a></li>
<li><a href='#print.ddt_lcm'><p>Print out setup of a ddt_lcm model</p></a></li>
<li><a href='#print.summary.ddt_lcm'><p>Print out summary of a ddt_lcm model</p></a></li>
<li><a href='#proposal_log_prob'><p>Calculate proposal likelihood</p></a></li>
<li><a href='#quiet'><p>Suppress print from cat()</p></a></li>
<li><a href='#random_detach_subtree'><p>Metropolis-Hasting algorithm for sampling tree topology and</p>
branch lengths from the DDT branching process.</a></li>
<li><a href='#reattach_point'><p>Attach a subtree to a given DDT at a randomly selected location</p></a></li>
<li><a href='#result_diet_1000iters'><p>Result of fitting DDT-LCM to a semi-synthetic data example</p></a></li>
<li><a href='#sample_c_one'><p>Sample divergence function parameter c for a(t) = c / (1-t) through Gibbs sampler</p></a></li>
<li><a href='#sample_c_two'><p>Sample divergence function parameter c for a(t) = c / (1-t)^2 through Gibbs sampler</p></a></li>
<li><a href='#sample_class_assignment'><p>Sample individual class assignments Z_i, i = 1, ..., N</p></a></li>
<li><a href='#sample_leaf_locations_pg'><p>Sample the leaf locations and Polya-Gamma auxilliary variables</p></a></li>
<li><a href='#sample_sigmasq'><p>Sample item group-specific variances through Gibbs sampler</p></a></li>
<li><a href='#sample_tree_topology'><p>Sample a new tree topology using Metropolis-Hastings through randomly</p>
detaching and re-attaching subtrees</a></li>
<li><a href='#simulate_DDT_tree'><p>Simulate a tree from a DDT process. Only the tree topology and branch lengths</p>
are simulated, without node parameters.</a></li>
<li><a href='#simulate_lcm_given_tree'><p>Simulate multivariate binary responses from a latent class model given a tree</p></a></li>
<li><a href='#simulate_lcm_response'><p>Simulate multivariate binary responses from a latent class model</p></a></li>
<li><a href='#simulate_parameter_on_tree'><p>Simulate node parameters along a given tree.</p></a></li>
<li><a href='#summary.ddt_lcm'><p>Summarize the output of a ddt_lcm model</p></a></li>
<li><a href='#WAIC'><p>Compute WAIC</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Latent Class Analysis with Dirichlet Diffusion Tree Process
Prior</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-26</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mengbing Li &lt;mengbing@umich.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a Bayesian algorithm for overcoming weak separation in Bayesian latent class analysis. 
    Reference: Li et al. (2023) &lt;<a href="https://arxiv.org/abs/2306.04700">arXiv:2306.04700</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 4.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape (&ge; 5.6-2), data.table (&ge; 1.14.4), extraDistr (&ge; 1.9.1),
ggplot2 (&ge; 3.4.0), ggpubr (&ge; 0.6.0), ggtext (&ge; 0.1.2),
ggtree (&ge; 3.4.0), label.switching (&ge; 1.8), matrixStats (&ge;
0.62.0), methods (&ge; 4.2.3), phylobase (&ge; 0.8.10), poLCA (&ge;
1.6.0.1), testthat (&ge; 3.1.7), truncnorm (&ge; 1.0-8), BayesLogit
(&ge; 2.1), Matrix (&ge; 1.5-1), Rdpack (&ge; 2.5), R.utils (&ge;
2.12.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, parallel, rmarkdown, xfun</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/limengbinggz/ddtlcm">https://github.com/limengbinggz/ddtlcm</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/limengbinggz/ddtlcm/issues">https://github.com/limengbinggz/ddtlcm/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-04 00:58:26 UTC; mengbing</td>
</tr>
<tr>
<td>Author:</td>
<td>Mengbing Li <a href="https://orcid.org/0000-0002-2264-8006"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre,
    aut],
  Briana Stephenson [ctb],
  Zhenke Wu <a href="https://orcid.org/0000-0001-7582-669X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-04 02:32:57 UTC</td>
</tr>
</table>
<hr>
<h2 id='a_t_one'>Compute divergence function</h2><span id='topic+a_t_one'></span><span id='topic+a_t_one_cum'></span><span id='topic+A_t_inv_one'></span>

<h3>Description</h3>

<p>Compute value, cumulative hazard, and inverse for divergence function <code class="reqn">a(t) = c / (1-t)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a_t_one(c, t)

a_t_one_cum(c, t)

A_t_inv_one(c, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="a_t_one_+3A_c">c</code></td>
<td>
<p>a positive number for the divergence hyperparameter. A larger value implies
earlier divergence on the tree</p>
</td></tr>
<tr><td><code id="a_t_one_+3A_t">t</code></td>
<td>
<p>a number in the interval (0, 1) indicating the divergence time</p>
</td></tr>
<tr><td><code id="a_t_one_+3A_y">y</code></td>
<td>
<p>a positive number to take inverse</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value and cumulative hazard return a positive number. The inverse function returns a number in the interval (0, 1).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>a_t_one()</code>: value of the divergence function
</p>
</li>
<li> <p><code>a_t_one_cum()</code>: cumulative hazard function
</p>
</li>
<li> <p><code>A_t_inv_one()</code>: inverse function
</p>
</li></ul>


<h3>See Also</h3>

<p>Other divergence functions: 
<code><a href="#topic+a_t_two">a_t_two</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a_t_one(1, 0.5)
a_t_one_cum(1, 0.5)
A_t_inv_one(1, 2)
</code></pre>

<hr>
<h2 id='a_t_two'>Compute divergence function</h2><span id='topic+a_t_two'></span><span id='topic+a_t_two_cum'></span><span id='topic+A_t_inv_two'></span>

<h3>Description</h3>

<p>Compute value, cumulative hazard, and inverse for divergence function <code class="reqn">a(t) = c / (1-t)^2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a_t_two(c, t)

a_t_two_cum(c, t)

A_t_inv_two(c, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="a_t_two_+3A_c">c</code></td>
<td>
<p>a positive number for the divergence hyperparameter. A larger value implies
earlier divergence on the tree</p>
</td></tr>
<tr><td><code id="a_t_two_+3A_t">t</code></td>
<td>
<p>a number in the interval (0, 1) indicating the divergence time</p>
</td></tr>
<tr><td><code id="a_t_two_+3A_y">y</code></td>
<td>
<p>a positive number to take inverse</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value and cumulative hazard return a positive number. The inverse function returns a number in the interval (0, 1).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>a_t_two()</code>: value of the divergence function
</p>
</li>
<li> <p><code>a_t_two_cum()</code>: cumulative hazard function
</p>
</li>
<li> <p><code>A_t_inv_two()</code>: inverse function
</p>
</li></ul>


<h3>See Also</h3>

<p>Other divergence functions: 
<code><a href="#topic+a_t_one">a_t_one</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a_t_two(1, 0.5)
a_t_two_cum(1, 0.5)
A_t_inv_two(1, 2)
</code></pre>

<hr>
<h2 id='add_leaf_branch'>Add a leaf branch to an existing tree tree_old</h2><span id='topic+add_leaf_branch'></span>

<h3>Description</h3>

<p>Add a leaf branch to an existing tree tree_old
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_leaf_branch(tree_old, div_t, new_leaf_label, where, position)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_leaf_branch_+3A_tree_old">tree_old</code></td>
<td>
<p>the original &quot;phylo&quot; tree (with K leaves) to which the leaf branch will be added</p>
</td></tr>
<tr><td><code id="add_leaf_branch_+3A_div_t">div_t</code></td>
<td>
<p>divergence time of the new branch</p>
</td></tr>
<tr><td><code id="add_leaf_branch_+3A_new_leaf_label">new_leaf_label</code></td>
<td>
<p>the label of the newly added leaf</p>
</td></tr>
<tr><td><code id="add_leaf_branch_+3A_where">where</code></td>
<td>
<p>node name of to which node in the existing tree the new leaf branch should connect to</p>
</td></tr>
<tr><td><code id="add_leaf_branch_+3A_position">position</code></td>
<td>
<p>the numerical location of the left side of the added branch</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &quot;phylo&quot; tree with K+1 leaves
</p>

<hr>
<h2 id='add_multichotomous_tip'>Add a leaf branch to an existing tree tree_old to make a multichotomus branch</h2><span id='topic+add_multichotomous_tip'></span>

<h3>Description</h3>

<p>Add a leaf branch to an existing tree tree_old to make a multichotomus branch
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_multichotomous_tip(tree_old, div_t, new_leaf_label, where)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_multichotomous_tip_+3A_tree_old">tree_old</code></td>
<td>
<p>the original &quot;phylo&quot; tree (with K leaves) to which the leaf branch will be added</p>
</td></tr>
<tr><td><code id="add_multichotomous_tip_+3A_div_t">div_t</code></td>
<td>
<p>divergence time of the new branch</p>
</td></tr>
<tr><td><code id="add_multichotomous_tip_+3A_new_leaf_label">new_leaf_label</code></td>
<td>
<p>the label of the newly added leaf</p>
</td></tr>
<tr><td><code id="add_multichotomous_tip_+3A_where">where</code></td>
<td>
<p>node name of to which node in the existing tree the new leaf branch should connect to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &quot;phylo&quot; tree with K+1 leaves that could possibly be multichotomus
</p>

<hr>
<h2 id='add_one_sample'>Functions to simulate trees and node parameters from a DDT
process.
Add a branch to an existing tree according to the branching process of DDT</h2><span id='topic+add_one_sample'></span>

<h3>Description</h3>

<p>Functions to simulate trees and node parameters from a DDT
process.
Add a branch to an existing tree according to the branching process of DDT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_one_sample(tree_old, c, c_order, theta, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_one_sample_+3A_tree_old">tree_old</code></td>
<td>
<p>a &quot;phylo&quot; object. The tree (K leaves) to which a new branch will be added.</p>
</td></tr>
<tr><td><code id="add_one_sample_+3A_c">c</code></td>
<td>
<p>hyparameter of divergence function a(t)</p>
</td></tr>
<tr><td><code id="add_one_sample_+3A_c_order">c_order</code></td>
<td>
<p>equals 1 (default) or 2 to choose divergence function
a(t) = c/(1-t) or c/(1-t)^2.</p>
</td></tr>
<tr><td><code id="add_one_sample_+3A_alpha">alpha</code>, <code id="add_one_sample_+3A_theta">theta</code></td>
<td>
<p>hyparameter of branching probability a(t) Gamma(m-alpha) / Gamma(m+1+theta)
Allowable range: 0 &lt;= beta &lt;= 1, and alpha &gt;= -2 beta
For DDT, alpha = theta = 0. For general multifurcating tree from a Pitman-Yor process,
specify positive values to alpha and theta. It is, however, recommended using alpha =
theta = 0 in inference because multifurcating trees have not been tested rigorously.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &quot;phylo&quot; object. A tree with K+1 leaves.
if t2 &gt; t1, then select which path to take, with probability proportional to the number of data
points that already traversed the path
</p>

<hr>
<h2 id='add_root'>Add a singular root node to an existing nonsingular tree</h2><span id='topic+add_root'></span>

<h3>Description</h3>

<p>Add a singular root node to an existing nonsingular tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_root(tree_old, root_edge_length, root_label, leaf_label)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_root_+3A_tree_old">tree_old</code></td>
<td>
<p>the original nonsingular &quot;phylo&quot; tree</p>
</td></tr>
<tr><td><code id="add_root_+3A_root_edge_length">root_edge_length</code></td>
<td>
<p>a number in (0, 1) representing the distance
between the new and the original root nodes</p>
</td></tr>
<tr><td><code id="add_root_+3A_root_label">root_label</code></td>
<td>
<p>a character label of the new root node</p>
</td></tr>
<tr><td><code id="add_root_+3A_leaf_label">leaf_label</code></td>
<td>
<p>a character label of the leaf node</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a singular &quot;phylo&quot; tree
</p>

<hr>
<h2 id='attach_subtree'>Attach a subtree to a given DDT at a randomly selected location</h2><span id='topic+attach_subtree'></span>

<h3>Description</h3>

<p>Attach a subtree to a given DDT at a randomly selected location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attach_subtree(
  subtree,
  tree_kept,
  detach_div_time,
  pa_detach_node_label,
  c,
  c_order = 1,
  theta = 0,
  alpha = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attach_subtree_+3A_subtree">subtree</code></td>
<td>
<p>subtree to attach to tree_kept</p>
</td></tr>
<tr><td><code id="attach_subtree_+3A_tree_kept">tree_kept</code></td>
<td>
<p>the tree to be attached to</p>
</td></tr>
<tr><td><code id="attach_subtree_+3A_detach_div_time">detach_div_time</code></td>
<td>
<p>divergence time of subtree when it was extracted from the original tree</p>
</td></tr>
<tr><td><code id="attach_subtree_+3A_pa_detach_node_label">pa_detach_node_label</code></td>
<td>
<p>label of the parent node of the detached node</p>
</td></tr>
<tr><td><code id="attach_subtree_+3A_c">c</code></td>
<td>
<p>hyparameter of divergence function a(t)</p>
</td></tr>
<tr><td><code id="attach_subtree_+3A_c_order">c_order</code></td>
<td>
<p>equals 1 (default) or 2 to choose divergence function</p>
</td></tr>
<tr><td><code id="attach_subtree_+3A_alpha">alpha</code>, <code id="attach_subtree_+3A_theta">theta</code></td>
<td>
<p>hyparameter of branching probability a(t) Gamma(m-alpha) / Gamma(m+1+theta)
For DDT, alpha = theta = 0. For general multifurcating tree from a Pitman-Yor process,
specify positive values to alpha and theta. It is, however, recommended using alpha =
theta = 0 in inference because multifurcating trees have not been tested rigorously.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other sample trees: 
<code><a href="#topic+random_detach_subtree">random_detach_subtree</a>()</code>,
<code><a href="#topic+reattach_point">reattach_point</a>()</code>
</p>

<hr>
<h2 id='compute_IC'>Compute information criteria for the DDT-LCM model</h2><span id='topic+compute_IC'></span>

<h3>Description</h3>

<p>Compute information criteria for the DDT-LCM model, including the Widely Applicable
Information Criterion (WAIC), and Deviance Information Criterion (DIC). WAIC and DIC are computed
using two different methods described in Gelman, Hwang, and Vehtari (2013), one based on (1) posterior
means and the other based on (2) posterior variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_IC(result, burnin = 5000, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_IC_+3A_result">result</code></td>
<td>
<p>a &quot;ddt_lcm&quot; object</p>
</td></tr>
<tr><td><code id="compute_IC_+3A_burnin">burnin</code></td>
<td>
<p>an integer specifying the number of burn-in iterations from MCMC chain</p>
</td></tr>
<tr><td><code id="compute_IC_+3A_ncores">ncores</code></td>
<td>
<p>an integer specifying the number of cores to compute marginal posterior log-likelihood
in parallel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list of the following elements
</p>

<dl>
<dt><code>WAIC_result</code></dt><dd><p>a list of WAIC-related results computed using the two methods</p>
</dd>
<dt><code>DIC1</code></dt><dd><p>DIC computed using method 1.</p>
</dd>
<dt><code>DIC2</code></dt><dd><p>DIC computed using method 2.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(result_diet_1000iters)
IC_result &lt;- compute_IC(result = result_diet_1000iters, burnin = 800, ncores = 1L)
</code></pre>

<hr>
<h2 id='create_leaf_cor_matrix'>Create a tree-structured covariance matrix from a given tree</h2><span id='topic+create_leaf_cor_matrix'></span>

<h3>Description</h3>

<p>Retrieve the covariance matrix of leaf nodes of a DDT tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_leaf_cor_matrix(tree_phylo4d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_leaf_cor_matrix_+3A_tree_phylo4d">tree_phylo4d</code></td>
<td>
<p>a &quot;phylo4d&quot; object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a K by K covariance matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the MAP tree structure obtained from the real HCHS/SOL data
data(data_synthetic)
# extract elements into the global environment
list2env(setNames(data_synthetic, names(data_synthetic)), envir = globalenv())
create_leaf_cor_matrix(tree_with_parameter)
</code></pre>

<hr>
<h2 id='data_synthetic'>Synthetic data example</h2><span id='topic+data_synthetic'></span>

<h3>Description</h3>

<p>This list contains one synthetic data with K = 3 latent classes.
The elements are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data_synthetic)
</code></pre>


<h3>Format</h3>

<p>A list with 8 elements
</p>


<h3>Details</h3>


<ul>
<li><p> tree_phylo. A &quot;phylo&quot; tree with K = 3 leaves.
</p>
</li>
<li><p> class_probability. A K-vector with entries between 0 and 1.
</p>
</li>
<li><p> item_membership_list. A list of G = 7 elements, where the g-th element contains the
indices of items belonging to major food group g.
</p>
</li>
<li><p> item_name_list. A list of G = 7 elements, where the g-th element contains the item
labels of items in major food group g, and the name of the g-th element is the major food
group label.
</p>
</li>
<li><p> Sigma_by_group. A G-vector greater than 0. The group-specific diffusion variances.
</p>
</li>
<li><p> response_matrix. A binary matrix with N = 100 rows and J = 80 columns. Each row contains
a multivariate binary response vector of a synthetic individual.
</p>
</li>
<li><p> response_prob. A K by J probability matrix. The k-th row contains the item response
probabilities of class k.
</p>
</li>
<li><p> tree_with_parameter. A <code>phylobase::phylo4d</code> object. Basically the tree_phylo embedded
with additional logit(response_prob) at the leaf nodes.
</p>
</li></ul>


<hr>
<h2 id='ddtlcm_fit'>MH-within-Gibbs sampler to sample from the full posterior
distribution of DDT-LCM</h2><span id='topic+ddtlcm_fit'></span>

<h3>Description</h3>

<p>Use DDT-LCM to estimate latent class and tree on class profiles for
multivariate binary outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddtlcm_fit(
  K,
  data,
  item_membership_list,
  total_iters = 5000,
  initials = list(),
  priors = list(),
  controls = list(),
  initialize_args = list(method_lcm = "random", method_dist = "euclidean", method_hclust
    = "ward.D", method_add_root = "min_cor", alpha = 0, theta = 0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddtlcm_fit_+3A_k">K</code></td>
<td>
<p>number of classes (integer)</p>
</td></tr>
<tr><td><code id="ddtlcm_fit_+3A_data">data</code></td>
<td>
<p>an NxJ matrix of multivariate binary responses, where
N is the number of individuals, and J is the number of granular items</p>
</td></tr>
<tr><td><code id="ddtlcm_fit_+3A_item_membership_list">item_membership_list</code></td>
<td>
<p>a list of G elements, where the g-th element contains the column
indices of <code>data</code> corresponding to items in major group g, and G is number of major item groups</p>
</td></tr>
<tr><td><code id="ddtlcm_fit_+3A_total_iters">total_iters</code></td>
<td>
<p>number of posterior samples to collect (integer)</p>
</td></tr>
<tr><td><code id="ddtlcm_fit_+3A_initials">initials</code></td>
<td>
<p>a named list of initial values of the following parameters:
</p>

<dl>
<dt><code>tree_phylo4d</code></dt><dd><p>a phylo4d object. The initial tree have K leaves (labeled as &quot;v1&quot; through &quot;vK&quot;),
1 singleton root node (labeled as &quot;u1&quot;), and K-1 internal nodes (labeled as &quot;u1&quot; through <code class="reqn">u_{K-1}</code>).
The tree also contains parameters for the leaf nodes and the root node (which
equals 0). The parameters for the internal nodes can be NAs because they will not be used in the
algorithm.</p>
</dd>
<dt><code>response_prob</code></dt><dd><p>a K by J matrix with entries between 0 and 1. The initial values for the
item response probabilities. They should equal to the expit-transformed leaf parameters of <code>tree_phylo4d</code>.</p>
</dd>
<dt><code>class_probability</code></dt><dd><p>a K-vector with entries between 0 and 1. The initial values for the class
probabilities. Entries should be nonzero and sum up to 1, or otherwise will be normalized</p>
</dd>
<dt><code>class_assignments</code></dt><dd><p>a N-vector with integer entries from 1, ..., K. The initial values for
individual class assignments.</p>
</dd>
<dt><code>Sigma_by_group</code></dt><dd><p>a G-vector greater than 0. The initial values for the group-specific diffusion
variances.</p>
</dd>
<dt><code>c</code></dt><dd><p>a value greater than 0. The initial values for the group-specific diffusion
variances.</p>
</dd>
</dl>

<p>Parameters not supplied with initial values will be initialized using the <code>initialize</code> function
with arguments in <code>initialize_args</code>.</p>
</td></tr>
<tr><td><code id="ddtlcm_fit_+3A_priors">priors</code></td>
<td>
<p>a named list of values of hyperparameters of priors. See the function
<code>initialize</code> for explanation.
</p>

<dl>
<dt><code>shape_sigma</code></dt><dd><p>a G-vector of positive values. The g-th element is the shape parameter for the
inverse-Gamma prior on diffusion variance parameter sigma_g^2. Default is rep(2, G).</p>
</dd>
<dt><code>rate_sigma</code></dt><dd><p>a G-vector of positive values. Rate parameter. See above. Default is rep(2, G).</p>
</dd>
<dt><code>prior_dirichlet</code></dt><dd><p>a K-vector with entries positive entries. The parameter of the Dirichlet prior
on class probability.</p>
</dd>
<dt><code>shape_c</code></dt><dd><p>a positive value. The shape parameter for the Gamma prior on divergence function
hyperparameter <code>c</code>. Default is 1.</p>
</dd>
<dt><code>rate_c</code></dt><dd><p>a positive value. The rate parameter for <code>c</code>. Default is 1.</p>
</dd>
<dt><code>a_pg</code></dt><dd><p>a positive value. The scale parameter for the generalized logistic distribution used in
the augmented Gibbs sampler for leaf parameters. Default is 1, corresponding to the standard logistic
distribution.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="ddtlcm_fit_+3A_controls">controls</code></td>
<td>
<p>a named list of control variables.
</p>

<dl>
<dt><code>fix_tree</code></dt><dd><p>a logical. If <code>TRUE</code> (default), the tree structure will be sampled in the algorithm. If <code>FALSE</code>,
the tree structure will be fixed at the initial input.</p>
</dd>
<dt><code>c_order</code></dt><dd><p>a numeric value. If <code>1</code>, the divergence function is <code class="reqn">a(t) = c/(1-t)</code>. If <code>2</code>, the divergence
function is <code class="reqn">a(t) = c/(1-t)^2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="ddtlcm_fit_+3A_initialize_args">initialize_args</code></td>
<td>
<p>a named list of initialization arguments. See the function
<code>initialize</code> for explanation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;ddt_lcm&quot;; a list containing the following elements:
</p>

<dl>
<dt><code>tree_samples</code></dt><dd><p>a list of information of the tree collected from the sampling algorithm, including:
<code>accept</code>: a binary vector where <code>1</code> indicates acceptance of the proposal tree and <code>0</code> indicates rejection.
<code>tree_list</code>: a list of posterior samples of the tree.
<code>dist_mat_list</code>: a list of tree-structured covariance matrices representing the marginal covariances
among the leaf parameters, integrating out the internal node parameters and all intermediate stochastic paths
in the DDT branching process.</p>
</dd>
<dt><code>response_probs_samples</code></dt><dd><p>a <code>total_iters</code> x <code>K</code> x <code>J</code> array of posterior samples of item response probabilities</p>
</dd>
<dt><code>class_probs_samples</code></dt><dd><p>a <code>K</code> x <code>total_iters</code> matrix of posterior samples of class probabilities</p>
</dd>
<dt><code>Z_samples</code></dt><dd><p>a <code>N</code> x <code>total_iters</code> integer matrix of posterior samples of individual class assignments</p>
</dd>
<dt><code>Sigma_by_group_samples</code></dt><dd><p>a <code>G</code> x <code>total_iters</code> matrix of posterior samples of diffusion variances</p>
</dd>
<dt><code>c_samples</code></dt><dd><p>a <code>total_iters</code> vector of posterior samples of divergence function hyperparameter</p>
</dd>
<dt><code>loglikelihood</code></dt><dd><p>a <code>total_iters</code> vector of log-likelihoods of the full model</p>
</dd>
<dt><code>loglikelihood_lcm</code></dt><dd><p>a <code>total_iters</code> vector of log-likelihoods of the LCM model only</p>
</dd>
<dt><code>setting</code></dt><dd><p>a list of model setup information, including: <code>K</code>, <code>item_membership_list</code>, and <code>G</code></p>
</dd>
<dt><code>controls</code></dt><dd><p>a list of model controls, including:
<code>fix_tree</code>: FALSE to perform MH sampling of the tree, TRUE to fix the tree at the initial input.
<code>c_order</code>: a numeric value of <code>1</code> or <code>2</code> (see Arguments))</p>
</dd>
<dt><code>data</code></dt><dd><p>the input data matrix</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># load the MAP tree structure obtained from the real HCHS/SOL data
data(data_synthetic)
# extract elements into the global environment
list2env(setNames(data_synthetic, names(data_synthetic)), envir = globalenv()) 
# run DDT-LCM
result &lt;- ddtlcm_fit(K = 3, data = response_matrix, item_membership_list, total_iters = 50)
</code></pre>

<hr>
<h2 id='ddtlcm-package'>ddtlcm: Latent Class Analysis with Dirichlet Diffusion Tree Process Prior</h2><span id='topic+ddtlcm'></span><span id='topic+ddtlcm-package'></span>

<h3>Description</h3>

<p>Implements a Bayesian algorithm for overcoming weak separation in Bayesian latent class analysis. Reference: Li et al. (2023) <a href="https://arxiv.org/abs/2306.04700">arXiv:2306.04700</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Mengbing Li <a href="mailto:mengbing@umich.edu">mengbing@umich.edu</a> (<a href="https://orcid.org/0000-0002-2264-8006">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Briana Stephenson <a href="mailto:bstephenson@hsph.harvard.edu">bstephenson@hsph.harvard.edu</a> [contributor]
</p>
</li>
<li><p> Zhenke Wu <a href="mailto:zhenkewu@umich.edu">zhenkewu@umich.edu</a> (<a href="https://orcid.org/0000-0001-7582-669X">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/limengbinggz/ddtlcm">https://github.com/limengbinggz/ddtlcm</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/limengbinggz/ddtlcm/issues">https://github.com/limengbinggz/ddtlcm/issues</a>
</p>
</li></ul>


<hr>
<h2 id='div_time'>Sample divergence time on an edge uv previously traversed by m(v) data points</h2><span id='topic+div_time'></span>

<h3>Description</h3>

<p>Sample divergence time on an edge uv previously traversed by m(v) data points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>div_time(t_u, m_v, c, c_order = 1, alpha = 0, theta = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="div_time_+3A_t_u">t_u</code></td>
<td>
<p>a number in the interval (0, 1) indicating the divergence time at node u</p>
</td></tr>
<tr><td><code id="div_time_+3A_m_v">m_v</code></td>
<td>
<p>an integer for the number of data points traversed through node v</p>
</td></tr>
<tr><td><code id="div_time_+3A_c">c</code></td>
<td>
<p>a positive number for the divergence hyperparameter. A larger value implies
earlier divergence on the tree</p>
</td></tr>
<tr><td><code id="div_time_+3A_c_order">c_order</code></td>
<td>
<p>equals 1 if using divergence function <code class="reqn">a(t) = c / (1-t)</code>, or 2 if
a(t) = c / (1-t)^2. Default is 1</p>
</td></tr>
<tr><td><code id="div_time_+3A_alpha">alpha</code>, <code id="div_time_+3A_theta">theta</code></td>
<td>
<p>hyparameter of branching probability a(t) Gamma(m-alpha) / Gamma(m+1+theta)
For DDT, alpha = theta = 0. For general multifurcating tree from a Pitman-Yor process,
specify positive values to alpha and theta. It is, however, recommended using alpha =
theta = 0 in inference because multifurcating trees have not been tested rigorously.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number in the interval (0, 1)
</p>

<hr>
<h2 id='draw_mnorm'>Efficiently sample multivariate normal using precision matrix
from <code class="reqn">x ~ N(Q^{-1}a, Q^{-1})</code>, where <code class="reqn">Q^{-1}</code> is the precision matrix</h2><span id='topic+draw_mnorm'></span>

<h3>Description</h3>

<p>Efficiently sample multivariate normal using precision matrix
from <code class="reqn">x ~ N(Q^{-1}a, Q^{-1})</code>, where <code class="reqn">Q^{-1}</code> is the precision matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_mnorm(precision_mat, precision_a_vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_mnorm_+3A_precision_mat">precision_mat</code></td>
<td>
<p>precision matrix Q of the multivariate normal distribution</p>
</td></tr>
<tr><td><code id="draw_mnorm_+3A_precision_a_vec">precision_a_vec</code></td>
<td>
<p>a vector a such that the mean of the multivariate normal distribution is
<code class="reqn">Q^{-1}a</code></p>
</td></tr>
</table>

<hr>
<h2 id='exp_normalize'>Compute normalized probabilities: exp(x_i) / sum_j exp(x_j)</h2><span id='topic+exp_normalize'></span>

<h3>Description</h3>

<p>Compute normalized probabilities: exp(x_i) / sum_j exp(x_j)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exp_normalize(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exp_normalize_+3A_x">x</code></td>
<td>
<p>a number or real-valued vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number or real-valued vector
</p>

<hr>
<h2 id='expit'>The expit function</h2><span id='topic+expit'></span>

<h3>Description</h3>

<p>The expit function: f(x) = exp(x) / (1+exp(x)), computed
in a way to avoid numerical underflow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expit_+3A_x">x</code></td>
<td>
<p>a value or a numeric vector between 0 and 1 (exclusive)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number or real-valued vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expit(0.2)
expit(c(-1, -0.3, 0.6))
</code></pre>

<hr>
<h2 id='H_n'>Harmonic series</h2><span id='topic+H_n'></span>

<h3>Description</h3>

<p>Harmonic series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H_n(k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="H_n_+3A_k">k</code></td>
<td>
<p>a positive integer</p>
</td></tr>
</table>

<hr>
<h2 id='initialize'>Initialize the MH-within-Gibbs algorithm for DDT-LCM</h2><span id='topic+initialize'></span>

<h3>Description</h3>

<p>Initialize the MH-within-Gibbs algorithm for DDT-LCM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialize(
  K,
  data,
  item_membership_list,
  c = 1,
  c_order = 1,
  method_lcm = "random",
  method_dist = "euclidean",
  method_hclust = "ward.D",
  method_add_root = "min_cor",
  fixed_initials = list(),
  fixed_priors = list(),
  alpha = 0,
  theta = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize_+3A_k">K</code></td>
<td>
<p>number of classes (integer)</p>
</td></tr>
<tr><td><code id="initialize_+3A_data">data</code></td>
<td>
<p>an NxJ matrix of multivariate binary responses, where
N is the number of individuals, and J is the number of granular items</p>
</td></tr>
<tr><td><code id="initialize_+3A_item_membership_list">item_membership_list</code></td>
<td>
<p>a list of G elements, where the g-th element contains the column
indices of <code>data</code> corresponding to items in major group g</p>
</td></tr>
<tr><td><code id="initialize_+3A_c">c</code></td>
<td>
<p>hyparameter of divergence function a(t)</p>
</td></tr>
<tr><td><code id="initialize_+3A_c_order">c_order</code></td>
<td>
<p>equals 1 (default) or 2 to choose divergence function
a(t) = c/(1-t) or c/(1-t)^2.</p>
</td></tr>
<tr><td><code id="initialize_+3A_method_lcm">method_lcm</code></td>
<td>
<p>a character. If <code>random</code> (default), the initial LCM parameters will be random values.
If <code>poLCA</code>, the initial LCM parameters will be EM algorithm estimates from the <code>poLCA</code> function.</p>
</td></tr>
<tr><td><code id="initialize_+3A_method_dist">method_dist</code></td>
<td>
<p>string specifying the distance measure to be used in dist().
This must be one of &quot;euclidean&quot; (defaults), &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot; or &quot;minkowski&quot;.
Any unambiguous substring can be given.</p>
</td></tr>
<tr><td><code id="initialize_+3A_method_hclust">method_hclust</code></td>
<td>
<p>string specifying the distance measure to be used in hclust().
This should be (an unambiguous abbreviation of) one of &quot;ward.D&quot; (defaults), &quot;ward.D2&quot;, &quot;single&quot;,
&quot;complete&quot;, &quot;average&quot; (= UPGMA), &quot;mcquitty&quot; (= WPGMA), &quot;median&quot; (= WPGMC) or
&quot;centroid&quot; (= UPGMC).</p>
</td></tr>
<tr><td><code id="initialize_+3A_method_add_root">method_add_root</code></td>
<td>
<p>string specifying the method to add the initial branch to the tree
output from hclust(). This should be one of &quot;min_cor&quot; (the absolute value of the minimum
between-class correlation; default) or &quot;sample_ddt&quot; (randomly sample a small divergence time from
the DDT process with c = 100)</p>
</td></tr>
<tr><td><code id="initialize_+3A_fixed_initials">fixed_initials</code></td>
<td>
<p>a named list of fixed initial values, including
the initial values for tree (&quot;phylo4d&quot;), response_prob, class_probability, class_assignments,
Sigma_by_group, and c. Default is NULL. See</p>
</td></tr>
<tr><td><code id="initialize_+3A_fixed_priors">fixed_priors</code></td>
<td>
<p>a named list of fixed prior hyperparameters, including the
the Gamma prior for <code>c</code>, inverse-Gamma prior for <code>sigma_g^2</code>, and Dirichlet prior
for <code>pi</code>. Moreover, we allow for a type III generalized logistic distribution such
that f(<code>eta</code>; a_pg) = <code>theta</code>. This becomes a standard logistic distribution when a_pg = 1. See
Dalla Valle, L., Leisen, F., Rossini, L., &amp; Zhu, W. (2021). A Pólya–Gamma sampler for a
generalized logistic regression. Journal of Statistical Computation and Simulation, 91(14), 2899-2916.
An example input list is
<code>list("shape_c" = 1, "rate_c" = 1, "shape_sigma" = rep(2, G), "rate_sigma" = rep(2, G), "a_pg" = 1.0)</code>, where
<code>G</code> is the number of major item groups. Default is NULL.</p>
</td></tr>
<tr><td><code id="initialize_+3A_alpha">alpha</code>, <code id="initialize_+3A_theta">theta</code></td>
<td>
<p>hyparameter of branching probability a(t) Gamma(m-alpha) / Gamma(m+1+theta)
For DDT, alpha = theta = 0</p>
</td></tr>
<tr><td><code id="initialize_+3A_...">...</code></td>
<td>
<p>optional arguments for the poLCA function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>phylo4d object of tree topology
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddtlcm_fit">ddtlcm_fit()</a></code>
</p>
<p>Other initialization functions: 
<code><a href="#topic+initialize_hclust">initialize_hclust</a>()</code>,
<code><a href="#topic+initialize_poLCA">initialize_poLCA</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the MAP tree structure obtained from the real HCHS/SOL data
data(data_synthetic)
# extract elements into the global environment
list2env(setNames(data_synthetic, names(data_synthetic)), envir = globalenv())
K &lt;- 3
G &lt;- length(item_membership_list)
fixed_initials &lt;- list("c" = 5)
fixed_priors &lt;- list("rate_sigma" = rep(3, G), "shape_c" = 2, "rate_c" = 2)
initials &lt;- initialize(K, data = response_matrix, item_membership_list,
  c=1, c_order=1, fixed_initials = fixed_initials, fixed_priors = fixed_priors)
</code></pre>

<hr>
<h2 id='initialize_hclust'>Estimate an initial binary tree on latent classes using hclust()</h2><span id='topic+initialize_hclust'></span>

<h3>Description</h3>

<p>Estimate an initial binary tree on latent classes using hclust()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialize_hclust(
  leaf_data,
  c,
  c_order = 1,
  method_dist = "euclidean",
  method_hclust = "ward.D",
  method_add_root = "min_cor",
  alpha = 0,
  theta = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize_hclust_+3A_leaf_data">leaf_data</code></td>
<td>
<p>a K by J matrix of <code class="reqn">logit(theta_{kj})</code></p>
</td></tr>
<tr><td><code id="initialize_hclust_+3A_c">c</code></td>
<td>
<p>hyparameter of divergence function a(t)</p>
</td></tr>
<tr><td><code id="initialize_hclust_+3A_c_order">c_order</code></td>
<td>
<p>equals 1 (default) or 2 to choose divergence function</p>
</td></tr>
<tr><td><code id="initialize_hclust_+3A_method_dist">method_dist</code></td>
<td>
<p>string specifying the distance measure to be used in dist().
This must be one of &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot; or &quot;minkowski&quot;.
Any unambiguous substring can be given.</p>
</td></tr>
<tr><td><code id="initialize_hclust_+3A_method_hclust">method_hclust</code></td>
<td>
<p>string specifying the distance measure to be used in hclust().
This should be (an unambiguous abbreviation of) one of &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;,
&quot;complete&quot;, &quot;average&quot; (= UPGMA), &quot;mcquitty&quot; (= WPGMA), &quot;median&quot; (= WPGMC) or
&quot;centroid&quot; (= UPGMC).</p>
</td></tr>
<tr><td><code id="initialize_hclust_+3A_method_add_root">method_add_root</code></td>
<td>
<p>string specifying the method to add the initial branch to the tree
output from hclust(). This should be one of &quot;min_cor&quot; (the absolute value of the minimum
between-class correlation) or &quot;sample_ddt&quot; (randomly sample a small divergence time from
the DDT process with a large c = 100)</p>
</td></tr>
<tr><td><code id="initialize_hclust_+3A_alpha">alpha</code>, <code id="initialize_hclust_+3A_theta">theta</code></td>
<td>
<p>hyparameter of branching probability a(t) Gamma(m-alpha) / Gamma(m+1+theta)
For DDT, alpha = theta = 0</p>
</td></tr>
<tr><td><code id="initialize_hclust_+3A_...">...</code></td>
<td>
<p>optional arguments for the poLCA function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>phylo4d object of tree topology
</p>


<h3>See Also</h3>

<p>Other initialization functions: 
<code><a href="#topic+initialize">initialize</a>()</code>,
<code><a href="#topic+initialize_poLCA">initialize_poLCA</a>()</code>
</p>

<hr>
<h2 id='initialize_poLCA'>Estimate an initial response profile from latent class model using poLCA()</h2><span id='topic+initialize_poLCA'></span>

<h3>Description</h3>

<p>Estimate an initial response profile from latent class model using poLCA()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialize_poLCA(K, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize_poLCA_+3A_k">K</code></td>
<td>
<p>number of latent classes</p>
</td></tr>
<tr><td><code id="initialize_poLCA_+3A_data">data</code></td>
<td>
<p>a N by J observed binary matrix, where the i,j-th element is the response
of item j for individual i</p>
</td></tr>
<tr><td><code id="initialize_poLCA_+3A_...">...</code></td>
<td>
<p>optional arguments for the poLCA function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a K by J probability matrix, the k,j-th entry being the response probability to item
j of an individual in class k
</p>


<h3>See Also</h3>

<p>Other initialization functions: 
<code><a href="#topic+initialize">initialize</a>()</code>,
<code><a href="#topic+initialize_hclust">initialize_hclust</a>()</code>
</p>

<hr>
<h2 id='initialize_randomLCM'>Provide a random initial response profile based on latent class mode</h2><span id='topic+initialize_randomLCM'></span>

<h3>Description</h3>

<p>Provide a random initial response profile based on latent class mode
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialize_randomLCM(K, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize_randomLCM_+3A_k">K</code></td>
<td>
<p>number of latent classes</p>
</td></tr>
<tr><td><code id="initialize_randomLCM_+3A_data">data</code></td>
<td>
<p>a N by J observed binary matrix, where the i,j-th element is the response
of item j for individual i</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a K by J probability matrix, the k,j-th entry being the response probability to item
j of an individual in class k
</p>

<hr>
<h2 id='J_n'>Compute factor in the exponent of the divergence time distribution</h2><span id='topic+J_n'></span>

<h3>Description</h3>

<p>Compute factor in the exponent of the divergence time distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>J_n(l, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="J_n_+3A_l">l</code></td>
<td>
<p>number of data points to the left</p>
</td></tr>
<tr><td><code id="J_n_+3A_r">r</code></td>
<td>
<p>number of data points to the right</p>
</td></tr>
</table>

<hr>
<h2 id='log_expit'>Numerically accurately compute f(x) = log(x / (1/x)).</h2><span id='topic+log_expit'></span>

<h3>Description</h3>

<p>Numerically accurately compute f(x) = log(x / (1/x)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_expit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_expit_+3A_x">x</code></td>
<td>
<p>a value or a numeric vector between 0 and 1 (exclusive)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number or real-valued vector
</p>

<hr>
<h2 id='logit'>The logistic function</h2><span id='topic+logit'></span>

<h3>Description</h3>

<p>The logit function: f(x) = log(x / (1/x)). Large absolute values of
x will be truncated to +/- 5 after logit transformation according to its sign.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_+3A_x">x</code></td>
<td>
<p>a value or a numeric vector between 0 and 1 (exclusive)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number or real-valued vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logit(0.2)
logit(c(0.2, 0.6, 0.95))
</code></pre>

<hr>
<h2 id='logllk_ddt'>Calculate loglikelihood of a DDT, including the tree structure and node parameters</h2><span id='topic+logllk_ddt'></span>

<h3>Description</h3>

<p>Calculate loglikelihood of a DDT, including the tree structure and node parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logllk_ddt(
  c,
  c_order,
  Sigma_by_group,
  tree_phylo4d,
  item_membership_list,
  tree_structure_old = NULL,
  dist_mat_old = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logllk_ddt_+3A_c">c</code></td>
<td>
<p>a positive number for the divergence hyperparameter. A larger value implies
earlier divergence on the tree</p>
</td></tr>
<tr><td><code id="logllk_ddt_+3A_c_order">c_order</code></td>
<td>
<p>equals 1 if using divergence function a(t) = c / (1-t), or 2 if
<code class="reqn">a(t) = c / (1-t)^2</code>. Default is 1</p>
</td></tr>
<tr><td><code id="logllk_ddt_+3A_sigma_by_group">Sigma_by_group</code></td>
<td>
<p>a vector of diffusion variances of G groups from the previous iteration</p>
</td></tr>
<tr><td><code id="logllk_ddt_+3A_tree_phylo4d">tree_phylo4d</code></td>
<td>
<p>a &quot;phylo4d&quot; object</p>
</td></tr>
<tr><td><code id="logllk_ddt_+3A_item_membership_list">item_membership_list</code></td>
<td>
<p>a list of G elements, where the g-th element contains the column
indices of <code>data</code> corresponding to items in major group g</p>
</td></tr>
<tr><td><code id="logllk_ddt_+3A_tree_structure_old">tree_structure_old</code></td>
<td>
<p>a list of at least named elements: loglikelihoods of the input tree topology
and divergence times. These can be directly obtained from the return of this function.
Default is NULL. If given a list, then computation of the loglikelihoods will be skipped to save time.
This is useful in the Metropolis-Hasting algorithm when the previous proposal is not accepted.</p>
</td></tr>
<tr><td><code id="logllk_ddt_+3A_dist_mat_old">dist_mat_old</code></td>
<td>
<p>a tree-structured covariance matrix from a given tree. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric of loglikelihood
</p>


<h3>See Also</h3>

<p>Other likelihood functions: 
<code><a href="#topic+logllk_ddt_lcm">logllk_ddt_lcm</a>()</code>,
<code><a href="#topic+logllk_div_time_one">logllk_div_time_one</a>()</code>,
<code><a href="#topic+logllk_div_time_two">logllk_div_time_two</a>()</code>,
<code><a href="#topic+logllk_lcm">logllk_lcm</a>()</code>,
<code><a href="#topic+logllk_location">logllk_location</a>()</code>,
<code><a href="#topic+logllk_tree_topology">logllk_tree_topology</a>()</code>
</p>

<hr>
<h2 id='logllk_ddt_lcm'>Calculate loglikelihood of the DDT-LCM</h2><span id='topic+logllk_ddt_lcm'></span>

<h3>Description</h3>

<p>Calculate loglikelihood of the DDT-LCM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logllk_ddt_lcm(
  c,
  Sigma_by_group,
  tree_phylo4d,
  item_membership_list,
  tree_structure_old = NULL,
  dist_mat_old = NULL,
  response_matrix,
  leaf_data,
  prior_class_probability,
  prior_dirichlet,
  ClassItem,
  Class_count
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logllk_ddt_lcm_+3A_c">c</code></td>
<td>
<p>a positive number for the divergence hyperparameter. A larger value implies
earlier divergence on the tree</p>
</td></tr>
<tr><td><code id="logllk_ddt_lcm_+3A_sigma_by_group">Sigma_by_group</code></td>
<td>
<p>a vector of diffusion variances of G groups</p>
</td></tr>
<tr><td><code id="logllk_ddt_lcm_+3A_tree_phylo4d">tree_phylo4d</code></td>
<td>
<p>a &quot;phylo4d&quot; object</p>
</td></tr>
<tr><td><code id="logllk_ddt_lcm_+3A_item_membership_list">item_membership_list</code></td>
<td>
<p>a list of G elements, where the g-th element contains the column
indices of <code>data</code> corresponding to items in major group g</p>
</td></tr>
<tr><td><code id="logllk_ddt_lcm_+3A_tree_structure_old">tree_structure_old</code></td>
<td>
<p>a list of at least named elements: loglikelihoods of the input tree topology
and divergence times. These can be directly obtained from the return of this function.
Default is NULL. If given a list, then computation of the loglikelihoods will be skipped to save time.
This is useful in the Metropolis-Hasting algorithm when the previous proposal is not accepted.</p>
</td></tr>
<tr><td><code id="logllk_ddt_lcm_+3A_dist_mat_old">dist_mat_old</code></td>
<td>
<p>a tree-structured covariance matrix from a given tree. Default is NULL.</p>
</td></tr>
<tr><td><code id="logllk_ddt_lcm_+3A_response_matrix">response_matrix</code></td>
<td>
<p>a N by J binary matrix, where the i,j-th element is the response
of item j for individual i</p>
</td></tr>
<tr><td><code id="logllk_ddt_lcm_+3A_leaf_data">leaf_data</code></td>
<td>
<p>a K by J matrix of <code class="reqn">logit(theta_kj)</code></p>
</td></tr>
<tr><td><code id="logllk_ddt_lcm_+3A_prior_class_probability">prior_class_probability</code></td>
<td>
<p>a length K vector, where the k-th element is the
probability of assigning an individual to class k. It does not have to sum up to 1</p>
</td></tr>
<tr><td><code id="logllk_ddt_lcm_+3A_prior_dirichlet">prior_dirichlet</code></td>
<td>
<p>a vector of length K. The Dirichlet prior of class probabilities</p>
</td></tr>
<tr><td><code id="logllk_ddt_lcm_+3A_classitem">ClassItem</code></td>
<td>
<p>a K by J matrix, where the k,j-th element counts the number of individuals
that belong to class k have a positive response to item j</p>
</td></tr>
<tr><td><code id="logllk_ddt_lcm_+3A_class_count">Class_count</code></td>
<td>
<p>a length K vector, where the k-th element counts the number of individuals
belonging to class k</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric of loglikelihood
</p>


<h3>See Also</h3>

<p>Other likelihood functions: 
<code><a href="#topic+logllk_ddt">logllk_ddt</a>()</code>,
<code><a href="#topic+logllk_div_time_one">logllk_div_time_one</a>()</code>,
<code><a href="#topic+logllk_div_time_two">logllk_div_time_two</a>()</code>,
<code><a href="#topic+logllk_lcm">logllk_lcm</a>()</code>,
<code><a href="#topic+logllk_location">logllk_location</a>()</code>,
<code><a href="#topic+logllk_tree_topology">logllk_tree_topology</a>()</code>
</p>

<hr>
<h2 id='logllk_div_time_one'>Compute loglikelihood of divergence times for a(t) = c/(1-t)</h2><span id='topic+logllk_div_time_one'></span>

<h3>Description</h3>

<p>Compute loglikelihood of divergence times for a(t) = c/(1-t)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logllk_div_time_one(c, l, r, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logllk_div_time_one_+3A_c">c</code></td>
<td>
<p>a positive number for the divergence hyperparameter. A larger value implies
earlier divergence on the tree</p>
</td></tr>
<tr><td><code id="logllk_div_time_one_+3A_l">l</code></td>
<td>
<p>number of data points to the left</p>
</td></tr>
<tr><td><code id="logllk_div_time_one_+3A_r">r</code></td>
<td>
<p>number of data points to the right</p>
</td></tr>
<tr><td><code id="logllk_div_time_one_+3A_t">t</code></td>
<td>
<p>a number in the interval (0, 1) indicating the divergence time</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other likelihood functions: 
<code><a href="#topic+logllk_ddt">logllk_ddt</a>()</code>,
<code><a href="#topic+logllk_ddt_lcm">logllk_ddt_lcm</a>()</code>,
<code><a href="#topic+logllk_div_time_two">logllk_div_time_two</a>()</code>,
<code><a href="#topic+logllk_lcm">logllk_lcm</a>()</code>,
<code><a href="#topic+logllk_location">logllk_location</a>()</code>,
<code><a href="#topic+logllk_tree_topology">logllk_tree_topology</a>()</code>
</p>

<hr>
<h2 id='logllk_div_time_two'>Compute loglikelihood of divergence times for a(t) = c/(1-t)^2</h2><span id='topic+logllk_div_time_two'></span>

<h3>Description</h3>

<p>Compute loglikelihood of divergence times for a(t) = c/(1-t)^2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logllk_div_time_two(c, l, r, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logllk_div_time_two_+3A_c">c</code></td>
<td>
<p>a positive number for the divergence hyperparameter. A larger value implies
earlier divergence on the tree</p>
</td></tr>
<tr><td><code id="logllk_div_time_two_+3A_l">l</code></td>
<td>
<p>number of data points to the left</p>
</td></tr>
<tr><td><code id="logllk_div_time_two_+3A_r">r</code></td>
<td>
<p>number of data points to the right</p>
</td></tr>
<tr><td><code id="logllk_div_time_two_+3A_t">t</code></td>
<td>
<p>a number in the interval (0, 1) indicating the divergence time</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other likelihood functions: 
<code><a href="#topic+logllk_ddt">logllk_ddt</a>()</code>,
<code><a href="#topic+logllk_ddt_lcm">logllk_ddt_lcm</a>()</code>,
<code><a href="#topic+logllk_div_time_one">logllk_div_time_one</a>()</code>,
<code><a href="#topic+logllk_lcm">logllk_lcm</a>()</code>,
<code><a href="#topic+logllk_location">logllk_location</a>()</code>,
<code><a href="#topic+logllk_tree_topology">logllk_tree_topology</a>()</code>
</p>

<hr>
<h2 id='logllk_lcm'>Calculate loglikelihood of the latent class model, conditional on tree structure</h2><span id='topic+logllk_lcm'></span>

<h3>Description</h3>

<p>Calculate loglikelihood of the latent class model, conditional on tree structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logllk_lcm(
  response_matrix,
  leaf_data,
  prior_class_probability,
  prior_dirichlet,
  ClassItem,
  Class_count
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logllk_lcm_+3A_response_matrix">response_matrix</code></td>
<td>
<p>a N by J binary matrix, where the i,j-th element is the response
of item j for individual i</p>
</td></tr>
<tr><td><code id="logllk_lcm_+3A_leaf_data">leaf_data</code></td>
<td>
<p>a K by J matrix of <code class="reqn">logit(theta_{kj})</code></p>
</td></tr>
<tr><td><code id="logllk_lcm_+3A_prior_class_probability">prior_class_probability</code></td>
<td>
<p>a length K vector, where the k-th element is the
probability of assigning an individual to class k. It does not have to sum up to 1</p>
</td></tr>
<tr><td><code id="logllk_lcm_+3A_prior_dirichlet">prior_dirichlet</code></td>
<td>
<p>a vector of length K. The Dirichlet prior of class probabilities</p>
</td></tr>
<tr><td><code id="logllk_lcm_+3A_classitem">ClassItem</code></td>
<td>
<p>a K by J matrix, where the k,j-th element counts the number of individuals
that belong to class k have a positive response to item j</p>
</td></tr>
<tr><td><code id="logllk_lcm_+3A_class_count">Class_count</code></td>
<td>
<p>a length K vector, where the k-th element counts the number of individuals
belonging to class k</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric of loglikelihood
</p>


<h3>See Also</h3>

<p>Other likelihood functions: 
<code><a href="#topic+logllk_ddt">logllk_ddt</a>()</code>,
<code><a href="#topic+logllk_ddt_lcm">logllk_ddt_lcm</a>()</code>,
<code><a href="#topic+logllk_div_time_one">logllk_div_time_one</a>()</code>,
<code><a href="#topic+logllk_div_time_two">logllk_div_time_two</a>()</code>,
<code><a href="#topic+logllk_location">logllk_location</a>()</code>,
<code><a href="#topic+logllk_tree_topology">logllk_tree_topology</a>()</code>
</p>

<hr>
<h2 id='logllk_location'>Compute log likelihood of parameters</h2><span id='topic+logllk_location'></span>

<h3>Description</h3>

<p>Compute the marginal log likelihood of the parameters on the leaves of a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logllk_location(
  tree_phylo4d,
  Sigma_by_group,
  item_membership_list,
  dist_mat = NULL,
  tol = 1e-07
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logllk_location_+3A_tree_phylo4d">tree_phylo4d</code></td>
<td>
<p>a &quot;phylo4d&quot; object</p>
</td></tr>
<tr><td><code id="logllk_location_+3A_sigma_by_group">Sigma_by_group</code></td>
<td>
<p>a vector of diffusion variances of G groups</p>
</td></tr>
<tr><td><code id="logllk_location_+3A_item_membership_list">item_membership_list</code></td>
<td>
<p>a list of G elements, where the g-th element contains the column
indices of <code>data</code> corresponding to items in major group g</p>
</td></tr>
<tr><td><code id="logllk_location_+3A_dist_mat">dist_mat</code></td>
<td>
<p>a tree-structured covariance matrix from a given tree. Default is NULL. If given
a matrix, then computation of the covariance matrix will be skipped to save time. This is useful
in the Metropolis-Hasting algorithm when the previous proposal is not accepted.</p>
</td></tr>
<tr><td><code id="logllk_location_+3A_tol">tol</code></td>
<td>
<p>a small number to prevent underflow when computing eigenvalues</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two elements: a numeric loglikelihood, a covariance matrix of the input tree
</p>


<h3>See Also</h3>

<p>Other likelihood functions: 
<code><a href="#topic+logllk_ddt">logllk_ddt</a>()</code>,
<code><a href="#topic+logllk_ddt_lcm">logllk_ddt_lcm</a>()</code>,
<code><a href="#topic+logllk_div_time_one">logllk_div_time_one</a>()</code>,
<code><a href="#topic+logllk_div_time_two">logllk_div_time_two</a>()</code>,
<code><a href="#topic+logllk_lcm">logllk_lcm</a>()</code>,
<code><a href="#topic+logllk_tree_topology">logllk_tree_topology</a>()</code>
</p>

<hr>
<h2 id='logllk_tree_topology'>Compute loglikelihood of the tree topology</h2><span id='topic+logllk_tree_topology'></span>

<h3>Description</h3>

<p>Compute loglikelihood of the tree topology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logllk_tree_topology(l, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logllk_tree_topology_+3A_l">l</code></td>
<td>
<p>number of data points to the left</p>
</td></tr>
<tr><td><code id="logllk_tree_topology_+3A_r">r</code></td>
<td>
<p>number of data points to the right</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other likelihood functions: 
<code><a href="#topic+logllk_ddt">logllk_ddt</a>()</code>,
<code><a href="#topic+logllk_ddt_lcm">logllk_ddt_lcm</a>()</code>,
<code><a href="#topic+logllk_div_time_one">logllk_div_time_one</a>()</code>,
<code><a href="#topic+logllk_div_time_two">logllk_div_time_two</a>()</code>,
<code><a href="#topic+logllk_lcm">logllk_lcm</a>()</code>,
<code><a href="#topic+logllk_location">logllk_location</a>()</code>
</p>

<hr>
<h2 id='parameter_diet'>Parameters for the HCHS dietary recall data example</h2><span id='topic+parameter_diet'></span>

<h3>Description</h3>

<p>A list of five variables containing the food items and parameter estimates obtained from
MCMC chains. The real multivariate binary dataset is not included for privacy.
The variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(parameter_diet)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 5.
</p>


<h3>Details</h3>


<ul>
<li><p> item_membership_list. A list of G = 7 elements, where the g-th element contains the
indices of items belonging to major food group g.
</p>
</li>
<li><p> item_name_list. A list of G = 7 elements, where the g-th element contains the item
labels of items in major food group g, and the name of the g-th element is the major food
group label.
</p>
</li>
<li><p> tree_phylo. The maximum a posterior tree estimate with K = 6 leaves obtained from the
real HCHS data. Class &quot;phylo&quot;.
</p>
</li>
<li><p> class_probability. A K-vector with entries between 0 and 1. The posterior mean estimate
for class probabilities obtained from the real HCHS data.
</p>
</li>
<li><p> Sigma_by_group. A G-vector greater than 0. The posterior mean estimate for group-specific
diffusion variances obtained from the real HCHS data.
</p>
</li></ul>



<h3>References</h3>

<p><a href="https://arxiv.org/abs/2306.04700">https://arxiv.org/abs/2306.04700</a>
</p>

<hr>
<h2 id='plot_tree_with_barplot'>Plot the MAP tree and class profiles (bar plot) of summarized DDT-LCM results</h2><span id='topic+plot_tree_with_barplot'></span>

<h3>Description</h3>

<p>Plot the MAP tree and class profiles (bar plot) of summarized DDT-LCM results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_tree_with_barplot(
  tree_with_parameter,
  response_prob,
  item_membership_list,
  item_name_list = NULL,
  class_probability = NULL,
  class_probability_lower = NULL,
  class_probability_higher = NULL,
  color_palette = c("#E69F00", "#56B4E9", "#009E73", "#000000", "#0072B2", "#D55E00",
    "#CC79A7", "#F0E442", "#999999"),
  return_separate_plots = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_tree_with_barplot_+3A_tree_with_parameter">tree_with_parameter</code></td>
<td>
<p>a &quot;phylo4d&quot; tree with node parameters</p>
</td></tr>
<tr><td><code id="plot_tree_with_barplot_+3A_response_prob">response_prob</code></td>
<td>
<p>a K by J matrix, where the k,j-th element is the response
probability of item j for individuals in class k</p>
</td></tr>
<tr><td><code id="plot_tree_with_barplot_+3A_item_membership_list">item_membership_list</code></td>
<td>
<p>a list of G elements, where the g-th element contains the
column indices of the observed data matrix corresponding to items in major group g</p>
</td></tr>
<tr><td><code id="plot_tree_with_barplot_+3A_item_name_list">item_name_list</code></td>
<td>
<p>a named list of G elements, where the g-th element contains a vector
of item names for items in <code>item_membership_list[[g]]</code>. The name of the g-th element is
the name of the major item group.</p>
</td></tr>
<tr><td><code id="plot_tree_with_barplot_+3A_class_probability">class_probability</code></td>
<td>
<p>a length K vector, where the k-th element is the
probability of assigning an individual to class k. It does not have to sum up to 1</p>
</td></tr>
<tr><td><code id="plot_tree_with_barplot_+3A_class_probability_lower">class_probability_lower</code></td>
<td>
<p>a length K vector, 2.5% quantile of posterior
the distribution.</p>
</td></tr>
<tr><td><code id="plot_tree_with_barplot_+3A_class_probability_higher">class_probability_higher</code></td>
<td>
<p>a length K vector, 97.5% quantile of posterior
the distribution.</p>
</td></tr>
<tr><td><code id="plot_tree_with_barplot_+3A_color_palette">color_palette</code></td>
<td>
<p>a vector of color names. Default is a color-blinded friendly palette.</p>
</td></tr>
<tr><td><code id="plot_tree_with_barplot_+3A_return_separate_plots">return_separate_plots</code></td>
<td>
<p>If FALSE (default), print the combined plot of MAP tree and
class profiles. If TRUE, return the tree plot, class profile plot, and data.table
used to create the plots in a list, without printing the combined plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object. A bar plot of item response probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the MAP tree structure obtained from the real HCHS/SOL data
data(data_synthetic)
# extract elements into the global environment
list2env(setNames(data_synthetic, names(data_synthetic)), envir = globalenv())
plot_tree_with_barplot(tree_with_parameter, response_prob, item_membership_list)
</code></pre>

<hr>
<h2 id='plot_tree_with_heatmap'>Plot the MAP tree and class profiles (heatmap) of summarized DDT-LCM results</h2><span id='topic+plot_tree_with_heatmap'></span>

<h3>Description</h3>

<p>Plot the MAP tree and class profiles (heatmap) of summarized DDT-LCM results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_tree_with_heatmap(
  tree_with_parameter,
  response_prob,
  item_membership_list
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_tree_with_heatmap_+3A_tree_with_parameter">tree_with_parameter</code></td>
<td>
<p>a &quot;phylo4d&quot; tree with node parameters</p>
</td></tr>
<tr><td><code id="plot_tree_with_heatmap_+3A_response_prob">response_prob</code></td>
<td>
<p>a K by J matrix, where the k,j-th element is the response
probability of item j for individuals in class k</p>
</td></tr>
<tr><td><code id="plot_tree_with_heatmap_+3A_item_membership_list">item_membership_list</code></td>
<td>
<p>a list of G elements, where the g-th element contains the
column indices of the observed data matrix corresponding to items in major group g</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object. A plot with the tree structure on the left and a heatmap
of item response probabilities on the right, with indication of item group
memberships beneath the heatmap.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the MAP tree structure obtained from the real HCHS/SOL data
data(data_synthetic)
# extract elements into the global environment
list2env(setNames(data_synthetic, names(data_synthetic)), envir = globalenv())
plot_tree_with_heatmap(tree_with_parameter, response_prob, item_membership_list)
</code></pre>

<hr>
<h2 id='plot.ddt_lcm'>Create trace plots of DDT-LCM parameters</h2><span id='topic+plot.ddt_lcm'></span>

<h3>Description</h3>

<p>Create trace plots of DDT-LCM parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ddt_lcm'
plot(
  x,
  parameter_names = c("responseprob_1,1,1", "classprob_1", "c", "diffusionvar_1"),
  burnin = 50,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ddt_lcm_+3A_x">x</code></td>
<td>
<p>a &quot;ddt_lcm&quot; object</p>
</td></tr>
<tr><td><code id="plot.ddt_lcm_+3A_parameter_names">parameter_names</code></td>
<td>
<p>a character vector to specify the parameters to be plotted. Each element can take the
be 1) of format &quot;parameter_index&quot; to plot specific parameters with specific indices, 2) of format &quot;parameter&quot;
to plot the parameters across all indices, or 3) equal to &quot;all&quot; to plot all parameters in the model. For 1),
the item response probabilities should be named &quot;responseprob_class,group,item&quot;; the class probabilities should be
named &quot;classprob_class&quot;; the divergence function parameter is &quot;c&quot;; the group-specific diffusion variances
should be named &quot;diffusionvar_group&quot;. For 2), &quot;responseprob&quot; to plot all item response probabilities;
&quot;classprob&quot; to plot all class probabilities; &quot;diffusionvar&quot; to plot all diffusion variances.</p>
</td></tr>
<tr><td><code id="plot.ddt_lcm_+3A_burnin">burnin</code></td>
<td>
<p>the number of posterior samples as burn-in, which will not be plotted.</p>
</td></tr>
<tr><td><code id="plot.ddt_lcm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to each method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULLs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(result_diet_1000iters)
# Plot "c" for the divergence function parameter; "diffusionvar_1" for diffusion variance of group 1
plot(x = result_diet_1000iters, parameter_names = c("c", "diffusionvar_1"), burnin = 500)
# Plot "responseprob_1,1,1" for the class 1 response probability of item 3 in major group 2
plot(x = result_diet_1000iters, parameter_names = "responseprob_1,1,1", burnin = 500)
# Plot "classprob_1" for the probability of being assigned to class 1
plot(x = result_diet_1000iters, parameter_names = "classprob_1", burnin = 500)
# plot all class probabilities
plot(x = result_diet_1000iters, parameter_names = "classprob", burnin = 500)
# plot all diffusion variances
plot(x = result_diet_1000iters, "diffusionvar", burnin = 500)
</code></pre>

<hr>
<h2 id='plot.summary.ddt_lcm'>Plot the MAP tree and class profiles of summarized DDT-LCM results</h2><span id='topic+plot.summary.ddt_lcm'></span>

<h3>Description</h3>

<p>Plot the MAP tree and class profiles of summarized DDT-LCM results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.ddt_lcm'
plot(
  x,
  log = TRUE,
  plot_option = c("all", "profile", "tree"),
  item_name_list = NULL,
  color_palette = c("#E69F00", "#56B4E9", "#009E73", "#000000", "#0072B2", "#D55E00",
    "#CC79A7", "#F0E442", "#999999"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.summary.ddt_lcm_+3A_x">x</code></td>
<td>
<p>a &quot;summary.ddt_lcm&quot; object</p>
</td></tr>
<tr><td><code id="plot.summary.ddt_lcm_+3A_log">log</code></td>
<td>
<p>Default argument passed to plot(). Not used.</p>
</td></tr>
<tr><td><code id="plot.summary.ddt_lcm_+3A_plot_option">plot_option</code></td>
<td>
<p>option to select which part of the plot to return. If &quot;all&quot;, return
the plot of MAP tree on the left and the plot of class profiles on the right. If &quot;profile&quot;,
only return the plot of class profiles. If &quot;tree&quot;, only return the plot of MAP tree.</p>
</td></tr>
<tr><td><code id="plot.summary.ddt_lcm_+3A_item_name_list">item_name_list</code></td>
<td>
<p>a named list of G elements, where the g-th element contains a vector
of item names for items in <code>item_membership_list[[g]]</code>. The name of the g-th element is
the name of the major item group.</p>
</td></tr>
<tr><td><code id="plot.summary.ddt_lcm_+3A_color_palette">color_palette</code></td>
<td>
<p>a vector of color names. Default is a color-blinded friendly palette.</p>
</td></tr>
<tr><td><code id="plot.summary.ddt_lcm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to each method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object. If plot_option is &quot;all&quot;, then a plot with maximum a posterior
tree structure on the left and a bar plot of item response probabilities (with 95%
credible intervals and class probabilities) on the right. If plot_option is
&quot;profile&quot;, then only a bar plot of item response probabilities. If plot_option is
&quot;tree&quot;, then only a plot of the tree structure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(result_diet_1000iters)
burnin &lt;- 500
summarized_result &lt;- summary(result_diet_1000iters, burnin, relabel = TRUE, be_quiet = TRUE)
plot(x = summarized_result, item_name_list = NULL, plot_option = "all")
</code></pre>

<hr>
<h2 id='predict.ddt_lcm'>Prediction of class memberships from posterior predictive distributions</h2><span id='topic+predict.ddt_lcm'></span>

<h3>Description</h3>

<p>Predict individual class memberships based on posterior predictive distributions.
For each posterior sample, let the class memberships be modal assignments. Then aggregate over
all posterior samples to obtain the most likely assigned classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ddt_lcm'
predict(object, data, burnin = 3000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ddt_lcm_+3A_object">object</code></td>
<td>
<p>a ddt_lcm object</p>
</td></tr>
<tr><td><code id="predict.ddt_lcm_+3A_data">data</code></td>
<td>
<p>an NxJ matrix of multivariate binary responses, where
N is the number of individuals, and J is the number of granular items</p>
</td></tr>
<tr><td><code id="predict.ddt_lcm_+3A_burnin">burnin</code></td>
<td>
<p>number of samples to discard from the posterior chain as burn-ins. Default is 3000.</p>
</td></tr>
<tr><td><code id="predict.ddt_lcm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to each method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the following named elements:
</p>

<dl>
<dt><code>class_assignments</code></dt><dd><p>an integer vector of individual predicted class memberships
taking values in 1, ..., K</p>
</dd>
<dt><code>predictive_probs</code></dt><dd><p>a N x K matrix of probabilities, where the (i,k)-th element
is the probability that the i-th individual is predicted to belong to class k.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(result_diet_1000iters)
burnin &lt;- 500
predicted &lt;- predict(result_diet_1000iters, result_diet_1000iters$data, burnin)
</code></pre>

<hr>
<h2 id='predict.summary.ddt_lcm'>Prediction of class memberships from posterior summaries</h2><span id='topic+predict.summary.ddt_lcm'></span>

<h3>Description</h3>

<p>Predict individual class memberships based on posterior summary (point estimates
of model parameters). The predicted class memberships are modal assignments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.ddt_lcm'
predict(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.summary.ddt_lcm_+3A_object">object</code></td>
<td>
<p>a &quot;summary.ddt_lcm&quot; object</p>
</td></tr>
<tr><td><code id="predict.summary.ddt_lcm_+3A_data">data</code></td>
<td>
<p>an NxJ matrix of multivariate binary responses, where
N is the number of individuals, and J is the number of granular items</p>
</td></tr>
<tr><td><code id="predict.summary.ddt_lcm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to each method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the following named elements:
</p>

<dl>
<dt><code>class_assignments</code></dt><dd><p>an integer vector of individual predicted class memberships
taking values in 1, ..., K</p>
</dd>
<dt><code>predictive_probs</code></dt><dd><p>a N x K matrix of probabilities, where the (i,k)-th element
is the probability that the i-th individual is predicted to belong to class k.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(result_diet_1000iters)
burnin &lt;- 500
summarized_result &lt;- summary(result_diet_1000iters, burnin, relabel = TRUE, be_quiet = TRUE)
predicted &lt;- predict(summarized_result, result_diet_1000iters$data)
</code></pre>

<hr>
<h2 id='print.ddt_lcm'>Print out setup of a ddt_lcm model</h2><span id='topic+print.ddt_lcm'></span>

<h3>Description</h3>

<p>Print out setup of a ddt_lcm model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ddt_lcm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ddt_lcm_+3A_x">x</code></td>
<td>
<p>a &quot;ddt_lcm&quot; object</p>
</td></tr>
<tr><td><code id="print.ddt_lcm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to each method</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other ddt_lcm results: 
<code><a href="#topic+print.summary.ddt_lcm">print.summary.ddt_lcm</a>()</code>,
<code><a href="#topic+summary.ddt_lcm">summary.ddt_lcm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(result_diet_1000iters)
print(result_diet_1000iters)
</code></pre>

<hr>
<h2 id='print.summary.ddt_lcm'>Print out summary of a ddt_lcm model</h2><span id='topic+print.summary.ddt_lcm'></span>

<h3>Description</h3>

<p>Print out summary of a ddt_lcm model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.ddt_lcm'
print(x, digits = 3L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.ddt_lcm_+3A_x">x</code></td>
<td>
<p>a &quot;summary.ddt_lcm&quot; object</p>
</td></tr>
<tr><td><code id="print.summary.ddt_lcm_+3A_digits">digits</code></td>
<td>
<p>integer indicating the number of decimal places (round) to be used.</p>
</td></tr>
<tr><td><code id="print.summary.ddt_lcm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to each method</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other ddt_lcm results: 
<code><a href="#topic+print.ddt_lcm">print.ddt_lcm</a>()</code>,
<code><a href="#topic+summary.ddt_lcm">summary.ddt_lcm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(result_diet_1000iters)
burnin &lt;- 500
summarized_result &lt;- summary(result_diet_1000iters, burnin, relabel = TRUE, be_quiet = TRUE)
print(summarized_result)
</code></pre>

<hr>
<h2 id='proposal_log_prob'>Calculate proposal likelihood</h2><span id='topic+proposal_log_prob'></span>

<h3>Description</h3>

<p>Given an old tree, propose a new tree and calculate the original
and proposal tree likelihood in the DDT process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proposal_log_prob(
  old_tree_phylo4,
  tree_kept,
  old_detach_pa_div_time,
  old_pa_detach_node_label,
  old_detach_node_label,
  new_div_time,
  new_attach_root,
  new_attach_to,
  c,
  c_order = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proposal_log_prob_+3A_old_tree_phylo4">old_tree_phylo4</code></td>
<td>
<p>the old &quot;phylo4&quot; object</p>
</td></tr>
<tr><td><code id="proposal_log_prob_+3A_tree_kept">tree_kept</code></td>
<td>
<p>the remaining &quot;phylo&quot; tree after detachment</p>
</td></tr>
<tr><td><code id="proposal_log_prob_+3A_old_detach_pa_div_time">old_detach_pa_div_time</code></td>
<td>
<p>a number in (0, 1) indicating the divergence time
of the detached node on the old tree</p>
</td></tr>
<tr><td><code id="proposal_log_prob_+3A_old_pa_detach_node_label">old_pa_detach_node_label</code></td>
<td>
<p>a character label of the parent of the detached node
on the old tree</p>
</td></tr>
<tr><td><code id="proposal_log_prob_+3A_old_detach_node_label">old_detach_node_label</code></td>
<td>
<p>a character label of the detached node
on the old tree</p>
</td></tr>
<tr><td><code id="proposal_log_prob_+3A_new_div_time">new_div_time</code></td>
<td>
<p>a number in (0, 1) indicating the divergence time at which
the detached subtree will be re-attached on the proposal tree</p>
</td></tr>
<tr><td><code id="proposal_log_prob_+3A_new_attach_root">new_attach_root</code>, <code id="proposal_log_prob_+3A_new_attach_to">new_attach_to</code></td>
<td>
<p>a character label of the starting and ending
nodes of the branch on the proposal tree, which the detached subtree will be re-attached to</p>
</td></tr>
<tr><td><code id="proposal_log_prob_+3A_c">c</code></td>
<td>
<p>hyparameter of divergence function a(t)</p>
</td></tr>
<tr><td><code id="proposal_log_prob_+3A_c_order">c_order</code></td>
<td>
<p>equals 1 (default) or 2 to choose divergence function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following elements:
</p>

<dl>
<dt><code>q_new</code></dt><dd><p>a &quot;phylo&quot; tree detached from the input tree</p>
</dd>
<dt><code>q_old</code></dt><dd><p>the remaining &quot;phylo&quot; tree after detachment</p>
</dd>
</dl>


<hr>
<h2 id='quiet'>Suppress print from cat()</h2><span id='topic+quiet'></span>

<h3>Description</h3>

<p>Suppress print from cat()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quiet(x, be_quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quiet_+3A_x">x</code></td>
<td>
<p>evaluation of a statement that may explicitly or implicitly involve cat()</p>
</td></tr>
<tr><td><code id="quiet_+3A_be_quiet">be_quiet</code></td>
<td>
<p>logical. TRUE to suppress print from cat(); FALSE to continue printing</p>
</td></tr>
</table>

<hr>
<h2 id='random_detach_subtree'>Metropolis-Hasting algorithm for sampling tree topology and
branch lengths from the DDT branching process.</h2><span id='topic+random_detach_subtree'></span>

<h3>Description</h3>

<p>Randomly detach a subtree from a given tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_detach_subtree(tree_phylo4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_detach_subtree_+3A_tree_phylo4">tree_phylo4</code></td>
<td>
<p>a &quot;phylo4&quot; object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following elements:
</p>

<dl>
<dt><code>tree_detached</code></dt><dd><p>a &quot;phylo&quot; tree detached from the input tree</p>
</dd>
<dt><code>tree_kept</code></dt><dd><p>the remaining &quot;phylo&quot; tree after detachment</p>
</dd>
<dt><code>pa_detach_node_label</code></dt><dd><p>a character label of the parent of the node
from which the detachment happens</p>
</dd>
<dt><code>pa_div_time</code></dt><dd><p>a number in (0, 1) indicating the divergence time of
the parent of the detached node</p>
</dd>
<dt><code>detach_div_time</code></dt><dd><p>a number in (0, 1) indicating the divergence time of the detached node</p>
</dd>
<dt><code>detach_node_label</code></dt><dd><p>a character label of the parent of the detached node</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other sample trees: 
<code><a href="#topic+attach_subtree">attach_subtree</a>()</code>,
<code><a href="#topic+reattach_point">reattach_point</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(phylobase)
# load the MAP tree structure obtained from the real HCHS/SOL data
data(data_synthetic)
# extract elements into the global environment
list2env(setNames(data_synthetic, names(data_synthetic)), envir = globalenv()) 
detachment &lt;- random_detach_subtree(extractTree(tree_with_parameter)) 
</code></pre>

<hr>
<h2 id='reattach_point'>Attach a subtree to a given DDT at a randomly selected location</h2><span id='topic+reattach_point'></span>

<h3>Description</h3>

<p>Attach a subtree to a given DDT at a randomly selected location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reattach_point(tree_kept, c, c_order = 1, theta = 0, alpha = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reattach_point_+3A_tree_kept">tree_kept</code></td>
<td>
<p>the tree to be attached to</p>
</td></tr>
<tr><td><code id="reattach_point_+3A_c">c</code></td>
<td>
<p>hyparameter of divergence function a(t)</p>
</td></tr>
<tr><td><code id="reattach_point_+3A_c_order">c_order</code></td>
<td>
<p>equals 1 (default) or 2 to choose divergence function
<code class="reqn">a(t) = c/(1-t) or c/(1-t)^2</code>.</p>
</td></tr>
<tr><td><code id="reattach_point_+3A_alpha">alpha</code>, <code id="reattach_point_+3A_theta">theta</code></td>
<td>
<p>hyparameter of branching probability a(t) Gamma(m-alpha) / Gamma(m+1+theta)
For DDT, alpha = theta = 0. For general multifurcating tree from a Pitman-Yor process,
specify positive values to alpha and theta. It is, however, recommended using alpha =
theta = 0 in inference because multifurcating trees have not been tested rigorously.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the following objects:
</p>

<dl>
<dt><code>div_time</code></dt><dd><p>a numeric value of newly sampled divergence time. Between 0 and 1.</p>
</dd>
<dt><code>root_node</code></dt><dd><p>a character. Label of the root node of <code>tree_kept</code>.</p>
</dd>
<dt><code>root_child</code></dt><dd><p>a character. Label of the child node of the root of <code>tree_kept</code>.</p>
</dd>
<dt><code>div_dist_to_root_child</code></dt><dd><p>a N-vector with integer entries from 1, ..., K. The initial values for
individual class assignments.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other sample trees: 
<code><a href="#topic+attach_subtree">attach_subtree</a>()</code>,
<code><a href="#topic+random_detach_subtree">random_detach_subtree</a>()</code>
</p>

<hr>
<h2 id='result_diet_1000iters'>Result of fitting DDT-LCM to a semi-synthetic data example</h2><span id='topic+result_diet_1000iters'></span>

<h3>Description</h3>

<p>This is a &quot;ddtlcm&quot; object obtained from running <code>ddtlcm_fit</code> to a semi-synthetic dataset with
1000 posterior samples (for the sake of time). See <code><a href="#topic+ddtlcm_fit">ddtlcm_fit</a></code> for description of
the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(result_diet_1000iters)
</code></pre>


<h3>Format</h3>

<p>A list with 8 elements
</p>

<hr>
<h2 id='sample_c_one'>Sample divergence function parameter c for a(t) = c / (1-t) through Gibbs sampler</h2><span id='topic+sample_c_one'></span>

<h3>Description</h3>

<p>Sample divergence function parameter c for a(t) = c / (1-t) through Gibbs sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_c_one(shape0, rate0, tree_structure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_c_one_+3A_shape0">shape0</code></td>
<td>
<p>shape of the Inverse-Gamma prior</p>
</td></tr>
<tr><td><code id="sample_c_one_+3A_rate0">rate0</code></td>
<td>
<p>rate of the Inverse-Gamma prior</p>
</td></tr>
<tr><td><code id="sample_c_one_+3A_tree_structure">tree_structure</code></td>
<td>
<p>a data.frame containing the divergence times and number of
data points to the left and right branches of internal nodes on the tree</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value of the newly sampled c
</p>

<hr>
<h2 id='sample_c_two'>Sample divergence function parameter c for a(t) = c / (1-t)^2 through Gibbs sampler</h2><span id='topic+sample_c_two'></span>

<h3>Description</h3>

<p>Sample divergence function parameter c for a(t) = c / (1-t)^2 through Gibbs sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_c_two(shape0, rate0, tree_structure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_c_two_+3A_shape0">shape0</code></td>
<td>
<p>shape of the Inverse-Gamma prior</p>
</td></tr>
<tr><td><code id="sample_c_two_+3A_rate0">rate0</code></td>
<td>
<p>rate of the Inverse-Gamma prior</p>
</td></tr>
<tr><td><code id="sample_c_two_+3A_tree_structure">tree_structure</code></td>
<td>
<p>a data.frame containing the divergence times and number of
data points to the left and right branches of internal nodes on the tree</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value of the newly sampled c
</p>

<hr>
<h2 id='sample_class_assignment'>Sample individual class assignments Z_i, i = 1, ..., N</h2><span id='topic+sample_class_assignment'></span>

<h3>Description</h3>

<p>Sample individual class assignments Z_i, i = 1, ..., N
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_class_assignment(
  data,
  leaf_data,
  a_pg,
  auxiliary_mat,
  class_probability
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_class_assignment_+3A_data">data</code></td>
<td>
<p>a N by J binary matrix, where the i,j-th element is the response
of item j for individual i</p>
</td></tr>
<tr><td><code id="sample_class_assignment_+3A_leaf_data">leaf_data</code></td>
<td>
<p>a K by J matrix of <code class="reqn">logit(theta_{kj})</code></p>
</td></tr>
<tr><td><code id="sample_class_assignment_+3A_a_pg">a_pg</code></td>
<td>
<p>a N by J matrix of hyperparameters of the generalized logistic distribution</p>
</td></tr>
<tr><td><code id="sample_class_assignment_+3A_auxiliary_mat">auxiliary_mat</code></td>
<td>
<p>a N by J matrix of truncated normal variables from previous iteration</p>
</td></tr>
<tr><td><code id="sample_class_assignment_+3A_class_probability">class_probability</code></td>
<td>
<p>a length K vector, where the k-th element is the
probability of assigning an individual to class k. It does not have to sum up to 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length N, where the i-th element is the class assignment of
individual i
</p>

<hr>
<h2 id='sample_leaf_locations_pg'>Sample the leaf locations and Polya-Gamma auxilliary variables</h2><span id='topic+sample_leaf_locations_pg'></span>

<h3>Description</h3>

<p>Sample the leaf locations and Polya-Gamma auxilliary variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_leaf_locations_pg(
  item_membership_list,
  dist_mat_old,
  Sigma_by_group,
  pg_mat,
  a_pg,
  auxiliary_mat,
  auxiliary_mat_range,
  class_assignments
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_leaf_locations_pg_+3A_item_membership_list">item_membership_list</code></td>
<td>
<p>a vector of G elements, each indicating the number of
items in this group</p>
</td></tr>
<tr><td><code id="sample_leaf_locations_pg_+3A_dist_mat_old">dist_mat_old</code></td>
<td>
<p>a list of leaf covariance matrix from the previous iteration. The list
has length G, the number of item groups</p>
</td></tr>
<tr><td><code id="sample_leaf_locations_pg_+3A_sigma_by_group">Sigma_by_group</code></td>
<td>
<p>a vector of length G, each denoting the variance of the
brownian motion</p>
</td></tr>
<tr><td><code id="sample_leaf_locations_pg_+3A_pg_mat">pg_mat</code></td>
<td>
<p>a K by J matrix of PG variables from the previous iteration</p>
</td></tr>
<tr><td><code id="sample_leaf_locations_pg_+3A_a_pg">a_pg</code></td>
<td>
<p>a N by J matrix of hyperparameters of the generalized logistic distribution</p>
</td></tr>
<tr><td><code id="sample_leaf_locations_pg_+3A_auxiliary_mat">auxiliary_mat</code></td>
<td>
<p>a N by J matrix of truncated normal variables from previous iteration</p>
</td></tr>
<tr><td><code id="sample_leaf_locations_pg_+3A_auxiliary_mat_range">auxiliary_mat_range</code></td>
<td>
<p>a list of two named elements: lb and ub. Each is an N by J
matrix of the lower/upper bounds of the truncated normal variables.</p>
</td></tr>
<tr><td><code id="sample_leaf_locations_pg_+3A_class_assignments">class_assignments</code></td>
<td>
<p>an integer vector of length N for the individual class assignments.
Each element takes value in 1, ..., K.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list of three matrices: the newly sampled leaf parameters, the Polya-gamma random variables,
and the auxiliary truncated normal variables
</p>

<hr>
<h2 id='sample_sigmasq'>Sample item group-specific variances through Gibbs sampler</h2><span id='topic+sample_sigmasq'></span>

<h3>Description</h3>

<p>Sample item group-specific variances through Gibbs sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_sigmasq(shape0, rate0, dist_mat, item_membership_list, locations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_sigmasq_+3A_shape0">shape0</code></td>
<td>
<p>a vector of G elements, each being the shape of the
Inverse-Gamma prior of group g</p>
</td></tr>
<tr><td><code id="sample_sigmasq_+3A_rate0">rate0</code></td>
<td>
<p>a vector of G elements, each being the rate of the
Inverse-Gamma prior of group g</p>
</td></tr>
<tr><td><code id="sample_sigmasq_+3A_dist_mat">dist_mat</code></td>
<td>
<p>a list, containing the KxK tree-structured matrix of leaf nodes,
where K is the number of leaves / latent classes, and SVD components</p>
</td></tr>
<tr><td><code id="sample_sigmasq_+3A_item_membership_list">item_membership_list</code></td>
<td>
<p>a vector of G elements, each indicating the number of
items in this group</p>
</td></tr>
<tr><td><code id="sample_sigmasq_+3A_locations">locations</code></td>
<td>
<p>a KxJ matrix of leaf parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of G elements, each being the newly sampled variance
of the latent location of this group
</p>

<hr>
<h2 id='sample_tree_topology'>Sample a new tree topology using Metropolis-Hastings through randomly
detaching and re-attaching subtrees</h2><span id='topic+sample_tree_topology'></span>

<h3>Description</h3>

<p>Sample a new tree topology using Metropolis-Hastings through randomly
detaching and re-attaching subtrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_tree_topology(
  tree_phylo4d_old,
  Sigma_by_group,
  item_membership_list,
  c,
  c_order = 1,
  tree_structure_old = NULL,
  dist_mat_old = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_tree_topology_+3A_tree_phylo4d_old">tree_phylo4d_old</code></td>
<td>
<p>a phylo4d object of tree from the previous iteration</p>
</td></tr>
<tr><td><code id="sample_tree_topology_+3A_sigma_by_group">Sigma_by_group</code></td>
<td>
<p>a vector of diffusion variances of G groups from the previous iteration</p>
</td></tr>
<tr><td><code id="sample_tree_topology_+3A_item_membership_list">item_membership_list</code></td>
<td>
<p>a vector of G elements, each indicating the number of
items in this group</p>
</td></tr>
<tr><td><code id="sample_tree_topology_+3A_c">c</code></td>
<td>
<p>hyparameter of divergence function a(t)</p>
</td></tr>
<tr><td><code id="sample_tree_topology_+3A_c_order">c_order</code></td>
<td>
<p>equals 1 (default) or 2 to choose divergence function</p>
</td></tr>
<tr><td><code id="sample_tree_topology_+3A_tree_structure_old">tree_structure_old</code></td>
<td>
<p>a data.frame of tree structure from the previous iteration. Each row
contains information of an internal node, including divergence times, number of data points
traveling through the left and right branches</p>
</td></tr>
<tr><td><code id="sample_tree_topology_+3A_dist_mat_old">dist_mat_old</code></td>
<td>
<p>a list of leaf covariance matrix from the previous iteration. The list has length
G, the number of item groups</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of G elements, each being the newly sampled variance
of the latent location of this group
</p>

<hr>
<h2 id='simulate_DDT_tree'>Simulate a tree from a DDT process. Only the tree topology and branch lengths
are simulated, without node parameters.</h2><span id='topic+simulate_DDT_tree'></span>

<h3>Description</h3>

<p>Simulate a tree from a DDT process. Only the tree topology and branch lengths
are simulated, without node parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_DDT_tree(K, c, c_order = 1, alpha = 0, theta = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_DDT_tree_+3A_k">K</code></td>
<td>
<p>number of leaves (classes) on the tree</p>
</td></tr>
<tr><td><code id="simulate_DDT_tree_+3A_c">c</code></td>
<td>
<p>hyparameter of divergence function a(t)</p>
</td></tr>
<tr><td><code id="simulate_DDT_tree_+3A_c_order">c_order</code></td>
<td>
<p>equals 1 (default) or 2 to choose divergence function
a(t) = c/(1-t) or c/(1-t)^2.</p>
</td></tr>
<tr><td><code id="simulate_DDT_tree_+3A_alpha">alpha</code>, <code id="simulate_DDT_tree_+3A_theta">theta</code></td>
<td>
<p>hyparameter of branching probability a(t) Gamma(m-alpha) / Gamma(m+1+theta)
For DDT, alpha = theta = 0. For general multifurcating tree from a Pitman-Yor process,
specify positive values to alpha and theta. It is, however, recommended using alpha =
theta = 0 in inference because multifurcating trees have not been tested rigorously.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A class &quot;phylo&quot; tree with K leaves. The leaf nodes are labeled &quot;v1&quot;, ..., &quot;vK&quot;,
root node &quot;u1&quot;, and internal nodes &quot;u2&quot;, ..., &quot;uK&quot;. Note that this tree does not contain
any node parameters.
</p>


<h3>References</h3>


<p>Knowles, D. A., &amp; Ghahramani, Z. (2014). Pitman yor diffusion trees for bayesian hierarchical
clustering. IEEE transactions on pattern analysis and machine intelligence, 37(2), 271-289.

</p>


<h3>See Also</h3>

<p>Other simulate DDT-LCM data: 
<code><a href="#topic+simulate_lcm_given_tree">simulate_lcm_given_tree</a>()</code>,
<code><a href="#topic+simulate_lcm_response">simulate_lcm_response</a>()</code>,
<code><a href="#topic+simulate_parameter_on_tree">simulate_parameter_on_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>K &lt;- 6
c &lt;- 5
c_order &lt;- 1
tree1 &lt;- simulate_DDT_tree(K, c, c_order)
tree2 &lt;- simulate_DDT_tree(K, c, c_order, alpha = 0.4, theta = 0.1)
tree3 &lt;- simulate_DDT_tree(K, c, c_order, alpha = 0.8, theta = 0.1)
</code></pre>

<hr>
<h2 id='simulate_lcm_given_tree'>Simulate multivariate binary responses from a latent class model given a tree</h2><span id='topic+simulate_lcm_given_tree'></span>

<h3>Description</h3>

<p>Generate multivariate binary responses from the following process:
For individual i = 1, ..., N,
<code class="reqn">Z_i ~ Categorical_K(prior_class_probability)</code>
For item j = 1, ..., J,
<code class="reqn">Y_{ij} | Z_i = k ~ Binomial(class_item_probability_{kj})</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_lcm_given_tree(
  tree_phylo,
  N,
  class_probability = 1,
  item_membership_list,
  Sigma_by_group = NULL,
  root_node_location = 0,
  seed_parameter = 1,
  seed_response = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_lcm_given_tree_+3A_tree_phylo">tree_phylo</code></td>
<td>
<p>a &quot;phylo&quot; tree with K leaves</p>
</td></tr>
<tr><td><code id="simulate_lcm_given_tree_+3A_n">N</code></td>
<td>
<p>number of individuals</p>
</td></tr>
<tr><td><code id="simulate_lcm_given_tree_+3A_class_probability">class_probability</code></td>
<td>
<p>a length K vector, where the k-th element is the
probability of assigning an individual to class k. It does not have to sum up to 1</p>
</td></tr>
<tr><td><code id="simulate_lcm_given_tree_+3A_item_membership_list">item_membership_list</code></td>
<td>
<p>a list of G elements, where the g-th element contains the
column indices of the observed data matrix corresponding to items in major group g</p>
</td></tr>
<tr><td><code id="simulate_lcm_given_tree_+3A_sigma_by_group">Sigma_by_group</code></td>
<td>
<p>a length-G vector for the posterior mean group-specific diffusion variances.</p>
</td></tr>
<tr><td><code id="simulate_lcm_given_tree_+3A_root_node_location">root_node_location</code></td>
<td>
<p>the coordinate of the root node parameter. By default, the node parameter
initiates at the origin so takes value 0. If a value, then the value will be repeated into a
length J vector. If a vector, it must be of length J.</p>
</td></tr>
<tr><td><code id="simulate_lcm_given_tree_+3A_seed_parameter">seed_parameter</code></td>
<td>
<p>an integer random seed to generate parameters given the tree</p>
</td></tr>
<tr><td><code id="simulate_lcm_given_tree_+3A_seed_response">seed_response</code></td>
<td>
<p>an integer random seed to generate multivariate binary observations from LCM</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list of the following elements:
</p>

<dl>
<dt><code>tree_with_parameter</code></dt><dd><p>a &quot;phylo4d&quot; tree with K leaves.</p>
</dd>
<dt><code>response_prob</code></dt><dd><p>a K by J matrix, where the k,j-th element is the response
probability of item j for individuals in class k</p>
</dd>
<dt><code>response_matrix</code></dt><dd><p>a K by J matrix with entries between 0 and 1 for the item
response probabilities.</p>
</dd>
<dt><code>class_probability</code></dt><dd><p>a K-vector with entries between 0 and 1 for the class
probabilities. Entries should be nonzero and sum up to 1, or otherwise will be normalized</p>
</dd>
<dt><code>class_assignments</code></dt><dd><p>a N-vector with integer entries from 1, ..., K. The initial values for
individual class assignments.</p>
</dd>
<dt><code>Sigma_by_group</code></dt><dd><p>a G-vector greater than 0. The initial values for the group-specific diffusion
variances.</p>
</dd>
<dt><code>c</code></dt><dd><p>a value greater than 0. The initial values for the group-specific diffusion
variances.</p>
</dd>
<dt><code>item_membership_list</code></dt><dd><p>same as input</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other simulate DDT-LCM data: 
<code><a href="#topic+simulate_DDT_tree">simulate_DDT_tree</a>()</code>,
<code><a href="#topic+simulate_lcm_response">simulate_lcm_response</a>()</code>,
<code><a href="#topic+simulate_parameter_on_tree">simulate_parameter_on_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the MAP tree structure obtained from the real HCHS/SOL data
data(parameter_diet)
# unlist the elements into variables in the global environment
list2env(setNames(parameter_diet, names(parameter_diet)), envir = globalenv()) 
# number of individuals
N &lt;- 496
# set random seed to generate node parameters given the tree
seed_parameter = 1
# set random seed to generate multivariate binary observations from LCM
seed_response = 1
# simulate data given the parameters
sim_data &lt;- simulate_lcm_given_tree(tree_phylo, N, 
                                    class_probability, item_membership_list, Sigma_by_group, 
                                    root_node_location = 0, seed_parameter = 1, seed_response = 1)
</code></pre>

<hr>
<h2 id='simulate_lcm_response'>Simulate multivariate binary responses from a latent class model</h2><span id='topic+simulate_lcm_response'></span>

<h3>Description</h3>

<p>Generate multivariate binary responses from the following process:
For individual i = 1, ..., N, draw <code class="reqn">Z_i</code> from Categorical distribution with prior class probability (length K).
For item j = 1, ..., J, given <code class="reqn">Z_i = k</code>, draw <code class="reqn">Y_{ij}</code> from Binomial with class-item probability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_lcm_response(N, response_prob, class_probability)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_lcm_response_+3A_n">N</code></td>
<td>
<p>number of individuals</p>
</td></tr>
<tr><td><code id="simulate_lcm_response_+3A_response_prob">response_prob</code></td>
<td>
<p>a K by J matrix, where the k,j-th element is the response
probability of item j for individuals in class k</p>
</td></tr>
<tr><td><code id="simulate_lcm_response_+3A_class_probability">class_probability</code></td>
<td>
<p>a length K vector, where the k-th element is the
probability of assigning an individual to class k. It does not have to sum up to 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list of the following elements:
</p>

<dl>
<dt><code>response_matrix</code></dt><dd><p>a K by J matrix with entries between <code>0</code> and <code>1</code> for the item
response probabilities.</p>
</dd>
<dt><code>class_probability</code></dt><dd><p>a K-vector with entries between 0 and 1 for the class
probabilities. Entries should be nonzero and sum up to 1, or otherwise will be normalized</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other simulate DDT-LCM data: 
<code><a href="#topic+simulate_DDT_tree">simulate_DDT_tree</a>()</code>,
<code><a href="#topic+simulate_lcm_given_tree">simulate_lcm_given_tree</a>()</code>,
<code><a href="#topic+simulate_parameter_on_tree">simulate_parameter_on_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># number of latent classes
K &lt;- 6
# number of items
J &lt;- 78
response_prob &lt;- matrix(runif(K*J), nrow = K)
class_probability &lt;- rep(1/K, K)
# number of individuals
N &lt;- 100
response_matrix &lt;- simulate_lcm_response(N, response_prob, class_probability)
</code></pre>

<hr>
<h2 id='simulate_parameter_on_tree'>Simulate node parameters along a given tree.</h2><span id='topic+simulate_parameter_on_tree'></span>

<h3>Description</h3>

<p>Simulate node parameters along a given tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_parameter_on_tree(
  tree_phylo,
  Sigma_by_group,
  item_membership_list,
  root_node_location = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_parameter_on_tree_+3A_tree_phylo">tree_phylo</code></td>
<td>
<p>a &quot;phylo&quot; object containing the tree topology and branch lengths</p>
</td></tr>
<tr><td><code id="simulate_parameter_on_tree_+3A_sigma_by_group">Sigma_by_group</code></td>
<td>
<p>a G-vector greater than 0. The initial values for the group-specific diffusion
variances</p>
</td></tr>
<tr><td><code id="simulate_parameter_on_tree_+3A_item_membership_list">item_membership_list</code></td>
<td>
<p>a list of G elements, where the g-th element contains the indices of
items in major group g</p>
</td></tr>
<tr><td><code id="simulate_parameter_on_tree_+3A_root_node_location">root_node_location</code></td>
<td>
<p>the coordinate of the root node parameter. By default, the node parameter
initiates at the origin so takes value 0. If a value, then the value will be repeated into a
length J vector. If a vector, it must be of length J.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A class &quot;phylo4d&quot; tree with K leaves with node parameters. The leaf nodes are labeled &quot;v1&quot;, ..., &quot;vK&quot;,
root node &quot;u1&quot;, and internal nodes &quot;u2&quot;, ..., &quot;uK&quot;.
</p>


<h3>See Also</h3>

<p>Other simulate DDT-LCM data: 
<code><a href="#topic+simulate_DDT_tree">simulate_DDT_tree</a>()</code>,
<code><a href="#topic+simulate_lcm_given_tree">simulate_lcm_given_tree</a>()</code>,
<code><a href="#topic+simulate_lcm_response">simulate_lcm_response</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
tr_txt &lt;- "(((v1:0.25, v2:0.25):0.65, v3:0.9):0.1);"
tree &lt;- read.tree(text = tr_txt)
tree$node.label &lt;- paste0("u", 1:Nnode(tree))
plot(tree, show.node.label = TRUE)
# create a list of item membership indices of 7 major groups
item_membership_list &lt;- list()
num_items_per_group &lt;- c(rep(10, 5), 15, 15)
G &lt;- length(num_items_per_group)
j &lt;- 0
for (g in 1:G) {
  item_membership_list[[g]] &lt;- (j+1):(j+num_items_per_group[g])
  j &lt;- j+num_items_per_group[g]
}
# variance of logit response probabilities of items in each group
Sigma_by_group &lt;- c(rep(0.6**2, 5), rep(2**2, 2)) #rep(1**2, G)
set.seed(50)
tree_with_parameter &lt;- simulate_parameter_on_tree(tree, Sigma_by_group, item_membership_list)
</code></pre>

<hr>
<h2 id='summary.ddt_lcm'>Summarize the output of a ddt_lcm model</h2><span id='topic+summary.ddt_lcm'></span>

<h3>Description</h3>

<p>Summarize the output of a ddt_lcm model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ddt_lcm'
summary(object, burnin = 3000, relabel = TRUE, be_quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ddt_lcm_+3A_object">object</code></td>
<td>
<p>a &quot;ddt_lcm&quot; object</p>
</td></tr>
<tr><td><code id="summary.ddt_lcm_+3A_burnin">burnin</code></td>
<td>
<p>number of samples to discard from the posterior chain as burn-ins. Default is 3000.</p>
</td></tr>
<tr><td><code id="summary.ddt_lcm_+3A_relabel">relabel</code></td>
<td>
<p>If TRUE, perform post-hoc label switching using the Equivalence Classes
Representatives (ECR) method to solve non-identifiability issue in mixture models. If FALSE,
no label switching algorithm will be performed.</p>
</td></tr>
<tr><td><code id="summary.ddt_lcm_+3A_be_quiet">be_quiet</code></td>
<td>
<p>If TRUE, do not print information during summarization. If FALSE, print label
switching information and model summary.</p>
</td></tr>
<tr><td><code id="summary.ddt_lcm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to each method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;summary.ddt_lcm&quot;; a list containing the following elements:
</p>

<dl>
<dt><code>tree_map</code></dt><dd><p>the MAP tree of &quot;phylo4d&quot; class</p>
</dd>
<dt><code>tree_Sigma</code></dt><dd><p>the tree-structured covariance matrix associated with <code>tree_map</code></p>
</dd>
<dt><code>response_probs_summary</code>, <code>class_probs_summary</code>, <code>Sigma_summary</code>, <code>c_summary</code></dt><dd>
<p>each is a matrix with 7 columns of summary statistics of posterior chains, including means, standard
deviation, and five quantiles. In particular, for the summary of item response probabilities,
each row name theta_k,g,j represents the response probability of a person in class k to consume item j in group g</p>
</dd>
<dt><code>max_llk_full</code></dt><dd><p>a numeric value of the maximum log-likelihood of the full model (tree and LCM)</p>
</dd>
<dt><code>max_llk_lcm</code></dt><dd><p>a numeric value of the maximum log-likelihood of the LCM only</p>
</dd>
<dt><code>Z_samples</code></dt><dd><p>a <code>N</code> x <code>total_iters</code> integer matrix of posterior samples of individual class assignments</p>
</dd>
<dt><code>Sigma_by_group_samples</code></dt><dd><p>a <code>G</code> x <code>total_iters</code> matrix of posterior samples of diffusion variances</p>
</dd>
<dt><code>c_samples</code></dt><dd><p>a <code>total_iters</code> vector of posterior samples of divergence function hyperparameter</p>
</dd>
<dt><code>loglikelihood</code></dt><dd><p>a <code>total_iters</code> vector of log-likelihoods of the full model</p>
</dd>
<dt><code>loglikelihood_lcm</code></dt><dd><p>a <code>total_iters</code> vector of log-likelihoods of the LCM model only</p>
</dd>
<dt><code>setting</code></dt><dd><p>a list of model setup information. See <code><a href="#topic+ddtlcm_fit">ddtlcm_fit</a></code></p>
</dd>
<dt><code>controls</code></dt><dd><p>a list of model controls. See <code><a href="#topic+ddtlcm_fit">ddtlcm_fit</a></code></p>
</dd>
<dt><code>data</code></dt><dd><p>the input data matrix</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other ddt_lcm results: 
<code><a href="#topic+print.ddt_lcm">print.ddt_lcm</a>()</code>,
<code><a href="#topic+print.summary.ddt_lcm">print.summary.ddt_lcm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the result of fitting semi-synthetic data with 1000 (for the sake of time) posterior samples
data(result_diet_1000iters)
summarized_result &lt;- summary(result_diet_1000iters, burnin = 500, relabel = TRUE, be_quiet = TRUE)
</code></pre>

<hr>
<h2 id='WAIC'>Compute WAIC</h2><span id='topic+WAIC'></span>

<h3>Description</h3>

<p>Compute the Widely Applicable Information Criterion (WAIC), also known
as the Widely Available Information Criterion or the Watanable-Akaike, of Watanabe (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WAIC(llk_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WAIC_+3A_llk_matrix">llk_matrix</code></td>
<td>
<p>a N x S matrix, where N is the number of individuals and S is the number of posterior samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
