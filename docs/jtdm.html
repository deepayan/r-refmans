<!DOCTYPE html><html lang="en"><head><title>Help for package jtdm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jtdm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#jtdm-package'><p>jtdm.</p></a></li>
<li><a href='#ellipse_plot'><p>Partial response curve of the pairwise most suitable community-level strategy and of the pairwise envelop of possible community-level strategy</p></a></li>
<li><a href='#get_sigma'><p>Get the inferred residual covariance matrix</p></a></li>
<li><a href='#getB'><p>Get the inferred regression coefficients</p></a></li>
<li><a href='#global'><p>Global</p></a></li>
<li><a href='#joint_trait_prob'><p>Computes joint probabilities.</p></a></li>
<li><a href='#joint_trait_prob_gradient'><p>Computes partial response curves of joint probabilities</p></a></li>
<li><a href='#jtdm_fit'><p>Fitting joint trait distribution models</p></a></li>
<li><a href='#jtdm_predict'><p>Predict method for joint trait distribution model</p></a></li>
<li><a href='#jtdmCV'><p>K-fold cross validation predictions and goodness of fit metrics</p></a></li>
<li><a href='#partial_response'><p>Computes and plots the trait-environment relationship of a given CWM trait and a given environmental variable</p></a></li>
<li><a href='#plot.jtdm_fit'><p>Plots the parameters of a fitted jtdm</p></a></li>
<li><a href='#summary.jtdm_fit'><p>Prints the summary of a fitted jtdm</p></a></li>
<li><a href='#X'><p>Site x environmental covariates dataset</p></a></li>
<li><a href='#Y'><p>Site x CWM traits dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Joint Modelling of Functional Traits</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-3</td>
</tr>
<tr>
<td>Description:</td>
<td>Fitting and analyzing a Joint Trait Distribution Model. The Joint Trait Distribution Model is implemented in the Bayesian framework using conjugate priors and posteriors, thus guaranteeing fast inference. In particular the package computes joint probabilities and multivariate confidence intervals, and enables the investigation of how they depend on the environment through partial response curves. The method implemented by the package is described in Poggiato et al. (2023) &lt;<a href="https://doi.org/10.1111%2Fgeb.13706">doi:10.1111/geb.13706</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggforce, mniw, mvtnorm, parallel, stats, utils, ggplot2,
gridExtra, reshape2</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/giopogg/jtdm">https://github.com/giopogg/jtdm</a>, <a href="https://giopogg.github.io/jtdm/">https://giopogg.github.io/jtdm/</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/giopogg/jtdm/issues">https://github.com/giopogg/jtdm/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, devtools</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-09 09:17:46 UTC; Giovanni</td>
</tr>
<tr>
<td>Author:</td>
<td>Giovanni Poggiato <a href="https://orcid.org/0000-0003-1957-9764"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Giovanni Poggiato &lt;giov.poggiato@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-09 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='jtdm-package'>jtdm.</h2><span id='topic+jtdm'></span><span id='topic+jtdm-package'></span>

<h3>Description</h3>

<p>Package to fit a Join Trait Distribution Model and to analyse its result to understand and predict the community-level strategy. See Poggiato et al. 2023 Global ecology and biogeography
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Giovanni Poggiato <a href="mailto:giov.poggiato@gmail.com">giov.poggiato@gmail.com</a> (<a href="https://orcid.org/0000-0003-1957-9764">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/giopogg/jtdm">https://github.com/giopogg/jtdm</a>
</p>
</li>
<li> <p><a href="https://giopogg.github.io/jtdm/">https://giopogg.github.io/jtdm/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/giopogg/jtdm/issues">https://github.com/giopogg/jtdm/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ellipse_plot'>Partial response curve of the pairwise most suitable community-level strategy and of the pairwise envelop of possible community-level strategy</h2><span id='topic+ellipse_plot'></span>

<h3>Description</h3>

<p>Partial response curve of the pairwise most suitable community-level strategy and of the pairwise envelop of possible community-level strategy. In order to build the response curve, the function builds a dataframe where the focal variable varies along a gradient and the other (non-focal) variables are fixed to their mean (but see FixX parameter for fixing non-focal variables to user-defined values). The chosen traits are specified in indexTrait. Then uses the jtdm_predict function to compute the most suitable community-level strategy and the residual covariance matrix to build the envelop of possible CWM combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipse_plot(
  m,
  indexGradient,
  indexTrait,
  FullPost = FALSE,
  grid.length = 20,
  FixX = NULL,
  confL = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ellipse_plot_+3A_m">m</code></td>
<td>
<p>a model fitted with <code>jtdm_fit</code></p>
</td></tr>
<tr><td><code id="ellipse_plot_+3A_indexgradient">indexGradient</code></td>
<td>
<p>The name (as specified in the column names of X) of the focal variable.</p>
</td></tr>
<tr><td><code id="ellipse_plot_+3A_indextrait">indexTrait</code></td>
<td>
<p>A vector of the two names (as specified in the column names of Y) containing the two (or more!) traits we want to compute the community level strategy of.</p>
</td></tr>
<tr><td><code id="ellipse_plot_+3A_fullpost">FullPost</code></td>
<td>
<p>If FullPost = TRUE, the function returns samples from the predictive distribution of joint probabilities. If FullPost= FALSE, joint probabilities are computed only using the posterior mean of the parameters.</p>
</td></tr>
<tr><td><code id="ellipse_plot_+3A_grid.length">grid.length</code></td>
<td>
<p>The number of points along the gradient of the focal variable. Default to 20 (which ensures a fair visualization).</p>
</td></tr>
<tr><td><code id="ellipse_plot_+3A_fixx">FixX</code></td>
<td>
<p>Optional. A parameter to specify the value to which non-focal variables are fixed. This can be useful for example if we have some categorical variables (e.g. forest vs meadows) and we want to obtain the partial response curve for a given value of the variable. It has to be a list of the length and names of the columns of X. For example, if the columns of X are &quot;MAT&quot;,&quot;MAP&quot;,&quot;Habitat&quot; and we want to fix &quot;Habitat&quot; to 1, then FixX=list(MAT=NULL,MAP=NULL,Habitat=1.). Default to NULL.</p>
</td></tr>
<tr><td><code id="ellipse_plot_+3A_confl">confL</code></td>
<td>
<p>The confidence level of the confidence ellipse (i.e. of the envelop of possible community-level strategies). Default is 0.95.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of the partial response curve of the pairwise most suitable community-level strategy and of the pairwise envelop of possible community-level strategy
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Y)  
data(X)  
# Short MCMC to obtain a fast example: results are unreliable !
m = jtdm_fit(Y=Y, X=X, formula=as.formula("~GDD+FDD+forest"),  sample = 1000)  

# plot the pairwise SLA-LNC partial response curve along the GDD gradient
ellipse_plot(m,indexTrait = c("SLA","LNC"),indexGradient="GDD")
#  plot the pairwise SLA-LNC partial response curve along the GDD gradient
#  in forest (i.e. when forest=1)
ellipse_plot(m,indexTrait = c("SLA","LNC"),indexGradient="GDD",
             FixX=list(GDD=NULL,FDD=NULL,forest=1))
</code></pre>

<hr>
<h2 id='get_sigma'>Get the inferred residual covariance matrix</h2><span id='topic+get_sigma'></span>

<h3>Description</h3>

<p>Get the samples from the posterior distribution of the residual covariance matrix, together with the posterior mean and quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sigma(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_sigma_+3A_m">m</code></td>
<td>
<p>a model fitted with <code>jtdm_fit</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>Ssamples</code></td>
<td>
<p> Sample from the posterior distribution of the residual covariance matrix. It is an array where the first two dimensions are the rows and columns of the matrix, and the third dimensions are the samples from the posterior distribution</p>
</td></tr>
<tr><td><code>Smean</code></td>
<td>
<p> Posterior mean of the residual covariance matrix.</p>
</td></tr>
<tr><td><code>Sq975</code>, <code>Sq025</code></td>
<td>
<p> 97.5% and 0.25% posterior quantiles of the residual covariance matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Y)  
data(X) 
# Short MCMC to obtain a fast example: results are unreliable !
m = jtdm_fit(Y=Y, X=X, formula=as.formula("~GDD+FDD+forest"), sample = 1000) 
# get the inferred residual covariance
Sigma =get_sigma(m)
</code></pre>

<hr>
<h2 id='getB'>Get the inferred regression coefficients</h2><span id='topic+getB'></span>

<h3>Description</h3>

<p>Get the samples from the posterior distribution of the regression coefficient matrix B, together with the posterior mean and quantiles. The regression coefficient matrix B is a matrix where the number of rows is defined by the number of traits that are modeled, and the number of columns is the number of columns of the matrix m$X (the number of explanatory variables after transformation via formula)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getB(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getB_+3A_m">m</code></td>
<td>
<p>a model fitted with <code>jtdm_fit</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>Bsamples</code></td>
<td>
<p>Sample from the posterior distribution of the regression coefficient matrix. It is an array where the first dimension is the number of traits, the second the number of columns in m$X (the number of variables after transformation via formula) and the third the number of MCMC samples.</p>
</td></tr>
<tr><td><code>Bmean</code></td>
<td>
<p>Posterior mean of the regression coefficient matrix.</p>
</td></tr>
<tr><td><code>Bq975</code>, <code>Bq025</code></td>
<td>
<p>97.5% and 0.25% posterior quantiles of the regression coefficient matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Y)  
data(X)
m = jtdm_fit(Y=Y, X=X, formula=as.formula("~GDD+FDD+forest"), sample = 1000) 
# get the inferred regression coefficients
B=getB(m)
</code></pre>

<hr>
<h2 id='global'>Global</h2><span id='topic+global'></span>

<h3>Description</h3>

<p>Declare global variables
</p>

<hr>
<h2 id='joint_trait_prob'>Computes joint probabilities.</h2><span id='topic+joint_trait_prob'></span>

<h3>Description</h3>

<p>Computes the joint probability of CWM traits in regions in the community-trait space specified by bounds and in sites specified in Xnew.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint_trait_prob(
  m,
  indexTrait,
  bounds,
  Xnew = NULL,
  FullPost = FALSE,
  samples = NULL,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joint_trait_prob_+3A_m">m</code></td>
<td>
<p>a model fitted with <code>jtdm_fit</code></p>
</td></tr>
<tr><td><code id="joint_trait_prob_+3A_indextrait">indexTrait</code></td>
<td>
<p>A vector of the names (as specified in the column names of Y) of the two (or more!) traits we want to compute the joint probabilities of.</p>
</td></tr>
<tr><td><code id="joint_trait_prob_+3A_bounds">bounds</code></td>
<td>
<p>The parameter to specify a region in the community-trait space where the function computes the joint probabilities of traits. It is a list of the length of &quot;indexTrait&quot;, each element of the list is a vector of length two. The vector represents the inferior and superior bounds of the region for the specified trait. For example, if we consider two traits, bounds=list(c(10,Inf),c(10,Inf)) corresponds to the region in the community-trait space where both traits both take values greater than 10.</p>
</td></tr>
<tr><td><code id="joint_trait_prob_+3A_xnew">Xnew</code></td>
<td>
<p>Optionally, a data frame in which to look for variables with which to predict. If omitted, the fitted linear predictors are used.</p>
</td></tr>
<tr><td><code id="joint_trait_prob_+3A_fullpost">FullPost</code></td>
<td>
<p>If FullPost = TRUE, the function returns samples from the predictive distribution of joint  probabilities, thus allowing the computation of credible intervals. If FullPost= FALSE, joint probabilities are computed only using the posterior mean of the parameters. FullPost cannot be equal to &quot;mean&quot; here.</p>
</td></tr>
<tr><td><code id="joint_trait_prob_+3A_samples">samples</code></td>
<td>
<p>Optional, default to NULL, only works when FullPost=FALSE. Defines the number of posterior samples to compute the posterior distribution of joint probabilities. Needs to be between 1 the total number of samples drawn from the posterior distribution.</p>
</td></tr>
<tr><td><code id="joint_trait_prob_+3A_parallel">parallel</code></td>
<td>
<p>Optional, only works when <code>FullPost = TRUE</code>. When <code>parallel = TRUE</code>, the function uses mclapply to parallelise the calculation of the posterior distribution joint probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is time consuming when <code>FullPost = TRUE</code>. Consider setting <code>parallel = TRUE</code> and/or to set <code>samples</code> to a value smaller than the total number of posterior samples .
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>PROBsamples</code></td>
<td>
<p>Samples from the posterior distribution of the joint probability.NULL if FullPost=FALSE. </p>
</td></tr>
<tr><td><code>PROBmean</code></td>
<td>
<p>Posterior mean of the joint probability.</p>
</td></tr>
<tr><td><code>PROBq975</code>, <code>PROBq025</code></td>
<td>
<p>97.5% and 0.25% posterior quantiles of the joint probability. NULL if FullPost=FALSE. </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Y)  
data(X)  
#We sample only few samples from the posterior in order to reduce
# the computational time of the examples.
#Increase the number of samples to obtain robust results
m = jtdm_fit(Y = Y, X = X, formula = as.formula("~GDD+FDD+forest"), sample = 10)  
# Compute probability of SLA and LNC to be joint-high at sites in the studies
joint = joint_trait_prob(m, indexTrait = c("SLA","LNC"),
                         bounds = list(c(mean(Y[,"SLA"]),Inf), c(mean(Y[,"SLA"]),Inf)),
                         FullPost = TRUE)
</code></pre>

<hr>
<h2 id='joint_trait_prob_gradient'>Computes partial response curves of joint probabilities</h2><span id='topic+joint_trait_prob_gradient'></span>

<h3>Description</h3>

<p>Computes the partial responses curves of joint probability of CWM traits as a function of a focal variable. The regions in which joint probabilities are computed are specified by bounds. In order to build the response curve, the function builds a dataframe where the focal variable varies along a gradient and the other (non-focal) variables are fixed to their mean (but see FixX parameter for fixing non-focal variables to user-defined values). Then, uses joint_trait_prob to compute the joint probability in these dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint_trait_prob_gradient(
  m,
  indexTrait,
  indexGradient,
  bounds,
  grid.length = 200,
  XFocal = NULL,
  FixX = NULL,
  FullPost = FALSE,
  samples = NULL,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joint_trait_prob_gradient_+3A_m">m</code></td>
<td>
<p>A model fitted with <code>jtdm_fit</code></p>
</td></tr>
<tr><td><code id="joint_trait_prob_gradient_+3A_indextrait">indexTrait</code></td>
<td>
<p>A vector of the names (as specified in the column names of Y) of the two (or more!) traits we want to compute the joint probabilities of.</p>
</td></tr>
<tr><td><code id="joint_trait_prob_gradient_+3A_indexgradient">indexGradient</code></td>
<td>
<p>The name (as specified in the column names of X) of the focal variable.</p>
</td></tr>
<tr><td><code id="joint_trait_prob_gradient_+3A_bounds">bounds</code></td>
<td>
<p>The parameter to specify a region in the community-trait space where the function computes the joint probabilities of traits. It is a list of the length of &quot;indexTrait&quot;, each element of the list is a vector of length two. The vector represents the inferior and superior bounds of the region for the specified trait. For example, if we consider two traits, bounds=list(c(10,Inf),c(10,Inf)) corresponds to the region in the community-trait space where both traits both take values greater than 10.</p>
</td></tr>
<tr><td><code id="joint_trait_prob_gradient_+3A_grid.length">grid.length</code></td>
<td>
<p>The number of points along the gradient of the focal variable. Default to 200.</p>
</td></tr>
<tr><td><code id="joint_trait_prob_gradient_+3A_xfocal">XFocal</code></td>
<td>
<p>Optional. A gradient of the focal variable provided by the user. If provided, the function will used this gradient instead of building a regular one. Default to NULL.</p>
</td></tr>
<tr><td><code id="joint_trait_prob_gradient_+3A_fixx">FixX</code></td>
<td>
<p>Optional. A parameter to specify the value to which non-focal variables are fixed. This can be useful for example if we have some categorical variables (e.g. forest vs meadows) and we want to obtain the partial response curve for a given value of the variable. It has to be a list of the length and names of the columns of X. For example, if the columns of X are &quot;MAT&quot;,&quot;MAP&quot;,&quot;Habitat&quot; and we want to fix &quot;Habitat&quot; to 1, then FixX=list(MAT=NULL,MAP=NULL,Habitat=1.). Default to NULL.</p>
</td></tr>
<tr><td><code id="joint_trait_prob_gradient_+3A_fullpost">FullPost</code></td>
<td>
<p>If FullPost = TRUE, the function returns samples from the predictive distribution of joint  probabilities, thus allowing the computation of credible intervals. If FullPost= FALSE, joint probabilities are computed only using the posterior mean of the parameters. FullPost cannot be equal to &quot;mean&quot; here.</p>
</td></tr>
<tr><td><code id="joint_trait_prob_gradient_+3A_samples">samples</code></td>
<td>
<p>Optional, default to NULL, only works when FullPost=FALSE. Defines the number of samples to compute the posterior distribution of joint probabilities. Needs to be between 1 the total number of samples drawn from the posterior distribution.</p>
</td></tr>
<tr><td><code id="joint_trait_prob_gradient_+3A_parallel">parallel</code></td>
<td>
<p>Optional, only works when FullPost = TRUE. When TRUE, the function uses mclapply to parallelise the calculation of the posterior distribution joint probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is time consuming when <code>FullPost = TRUE</code>. Consider setting <code>parallel = TRUE</code> and/or to set <code>samples</code> to a value smaller than the total number of posterior samples.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>GradProbssamples</code></td>
<td>
<p>Sample from the posterior distribution of the joint probability along the gradient. It is a vector whose length is the number of posterior samples. NULL if FullPost=FALSE. </p>
</td></tr>
<tr><td><code>GradProbsmean</code></td>
<td>
<p>Posterior mean of the joint probability along the gradient. </p>
</td></tr>
<tr><td><code>GradProbsq975</code>, <code>GradProbsq025</code></td>
<td>
<p>97.5% and 0.25% posterior quantiles of the joint probability along the gradient. NULL if FullPost=FALSE. </p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>The gradient of the focal variable built by the function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Y)  
data(X)  
# We sample only few samples from the posterior in order to reduce 
# the computational time of the examples.
# Increase the number of samples to obtain robust results
m = jtdm_fit(Y = Y, X = X, formula = as.formula("~GDD+FDD+forest"),  sample = 10)  
# Compute probability of SLA and LNC to be joint-high at sites in the studies

# Compute the joint probability of SLA and LNC 
# to be joint-high along the GDD gradient
joint = joint_trait_prob_gradient(m,indexTrait = c("SLA","LNC"), 
                                  indexGradient = "GDD",
                                  bounds = list(c(mean(Y[,"SLA"]),Inf),c(mean(Y[,"SLA"]),Inf)),
                                  FullPost = TRUE)
                                  
# Compute the joint probability of SLA and LNC to be joint-high along the
# GDD gradient when forest = 1 (i.e. in forests) 
joint = joint_trait_prob_gradient(m, indexTrait = c("SLA","LNC"),
                                  indexGradient = "GDD",
                                  bounds = list(c(mean(Y[,"SLA"]),Inf), c(mean(Y[,"SLA"]),Inf)),
                                  FixX = list(GDD = NULL, FDD = NULL, forest = 1),
                                  FullPost = TRUE)

</code></pre>

<hr>
<h2 id='jtdm_fit'>Fitting joint trait distribution models</h2><span id='topic+jtdm_fit'></span>

<h3>Description</h3>

<p>jtdm_fit is used to fit a Joint trait distribution model. Requires the response variable Y (the sites x traits matrix) and the explanatory variables X.This function samples from the posterior distribution of the parameters, which has been analytically determined. Therefore, there is no need for classical MCMC convergence checks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jtdm_fit(Y, X, formula, sample = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jtdm_fit_+3A_y">Y</code></td>
<td>
<p>The sites x traits matrix containing community (weighted) means of each trait at each site.</p>
</td></tr>
<tr><td><code id="jtdm_fit_+3A_x">X</code></td>
<td>
<p>The design matrix, i.e. sites x predictor matrix containing the value of each explanatory variable (e.g. the environmental conditions) at each site.</p>
</td></tr>
<tr><td><code id="jtdm_fit_+3A_formula">formula</code></td>
<td>
<p>An object of class &quot;formula&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of model specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="jtdm_fit_+3A_sample">sample</code></td>
<td>
<p>Number of samples from the posterior distribution. Since we sample from the exact posterior distribution, the number of samples is relative lower than MCMC samplers. As a rule of thumb, 1000 samples should provide correct inference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A formula has an implied intercept term. To remove this use either y ~ x - 1 or y ~ 0 + x. See formula for more details of allowed formulae.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p> An object of class &quot;jtdm_fit&quot;, containing the samples from the posterior distribution of the regression coefficients (B) and residual covariance matrix (Sigma), together with the likelihood of the model.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>A numeric vector of standard errors on parameters</p>
</td></tr>
<tr><td><code>X_raw</code></td>
<td>
<p>The design matrix specified as input</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The design matrix transformed as specified in formula</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The formula specified as input</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Y)  
data(X)  
m = jtdm_fit(Y = Y, X = X, formula = as.formula("~GDD+FDD+forest"), sample = 1000)  
</code></pre>

<hr>
<h2 id='jtdm_predict'>Predict method for joint trait distribution model</h2><span id='topic+jtdm_predict'></span>

<h3>Description</h3>

<p>Obtains predictions from a fitted joint trait distribution model and optionally computes their R squared and root mean square error (RMSE)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jtdm_predict(
  m = m,
  Xnew = NULL,
  Ynew = NULL,
  validation = FALSE,
  FullPost = "mean"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jtdm_predict_+3A_m">m</code></td>
<td>
<p>a model fitted with <code>jtdm_fit</code></p>
</td></tr>
<tr><td><code id="jtdm_predict_+3A_xnew">Xnew</code></td>
<td>
<p>optionally, a data frame in which to look for variables with which to predict. If omitted, the fitted linear predictors are used</p>
</td></tr>
<tr><td><code id="jtdm_predict_+3A_ynew">Ynew</code></td>
<td>
<p>Optional. The observed response variables at sites specified in Xnew. It is used to compute goodness of fit metrics when validation= T.</p>
</td></tr>
<tr><td><code id="jtdm_predict_+3A_validation">validation</code></td>
<td>
<p>boolean parameter to decide whether we want to compute goodness of fit measures. If true, then Ynew is needed.</p>
</td></tr>
<tr><td><code id="jtdm_predict_+3A_fullpost">FullPost</code></td>
<td>
<p>The type of predictions to be obtain. If FullPost = TRUE, the function returns samples from the predictive distribution, the credible intervals are thus the predictive credible interval. If FullPost=&quot;mean&quot;, the function computes the posterior distribution of the regression term <code class="reqn">BXnew</code>), i.e., classical credible intervals. If FullPost=FALSE, the function only returns the posterior mean of the regression term (<code class="reqn">BmeanXnew</code>), i.e., no credible intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To obtain a full assessment of the posterior distribution, the function should be ran with FullPost=TRUE, although this can be time consuming. FullPost=&quot;mean&quot; is used to compute partial response curves, while FullPost=FALSE is used to compute goodness of fit metrics.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>Pred</code></td>
<td>
<p>Sample from the posterior distribution of the posterior predictive distribution. It is an array where the first dimension is the number of sites in Xnew, the second is the number of traits modelled and the third the number of MCMC samples. NULL if FullPost=FALSE.</p>
</td></tr>
<tr><td><code>PredMean</code></td>
<td>
<p>Posterior mean of posterior predictive distribution </p>
</td></tr>
<tr><td><code>Predq975</code>, <code>Predq025</code></td>
<td>
<p>97.5% and 0.25% posterior quantiles of the posterior predictive distribution. NULL if FullPost=FALSE. </p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>R squared of predictions (squared Pearson correlation between Ynew and the predictions). NULL if validation=FALSE. </p>
</td></tr>
<tr><td><code>RMSE</code></td>
<td>
<p>Root square mean error between  squared of predictions. NULL if validation=FALSE.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Y)  
data(X)  
m = jtdm_fit(Y = Y, X = X, formula=as.formula("~GDD+FDD+forest"), sample = 1000)
# marginal predictions of traits in the sites of X
pred = jtdm_predict(m)
</code></pre>

<hr>
<h2 id='jtdmCV'>K-fold cross validation predictions and goodness of fit metrics</h2><span id='topic+jtdmCV'></span>

<h3>Description</h3>

<p>Run K-fold cross validation predictions of the model m on a specified dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jtdmCV(m, K = 5, sample = 1000, partition = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jtdmCV_+3A_m">m</code></td>
<td>
<p>a model fitted with <code>jtdm_fit</code></p>
</td></tr>
<tr><td><code id="jtdmCV_+3A_k">K</code></td>
<td>
<p>The number of folds of the K-fold cross validation</p>
</td></tr>
<tr><td><code id="jtdmCV_+3A_sample">sample</code></td>
<td>
<p>Number of samples from the posterior distribution. Since we sample from the exact posterior distribution, the number of samples is relative lower than MCMC samplers. As a rule of thumb, 1000 samples should provide correct inference.</p>
</td></tr>
<tr><td><code id="jtdmCV_+3A_partition">partition</code></td>
<td>
<p>A partition of the dataset specified by the user. It is a vector (whose length are the number of sites), where each element specifies the fold index of the site.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>Pred</code></td>
<td>
<p>Sample from the posterior predictive distribution in cross validation. It is an array where the first dimension is the number of sites in Xnew, the second is the number of traits modeled and the third the number of MCMC samples. NULL if FullPost=FALSE. </p>
</td></tr>
<tr><td><code>PredMean</code></td>
<td>
<p>Posterior mean of posterior predictive distribution in cross validation. </p>
</td></tr>
<tr><td><code>Predq975</code>, <code>Predq025</code></td>
<td>
<p>97.5% and 0.25% posterior quantiles of the posterior predictive distribution in cross validation. NULL if FullPost=FALSE. </p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>R squared of predictions in cross validation. </p>
</td></tr>
<tr><td><code>RMSE</code></td>
<td>
<p>Root square mean error between  squared of predictions in cross validation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Y)  
data(X)  
m = jtdm_fit(Y=Y, X=X, formula=as.formula("~GDD+FDD+forest"), sample = 1000)  
# Run 3-fold cross validation on m
pred = jtdmCV(m, K = 5, sample = 1000)
</code></pre>

<hr>
<h2 id='partial_response'>Computes and plots the trait-environment relationship of a given CWM trait and a given environmental variable</h2><span id='topic+partial_response'></span>

<h3>Description</h3>

<p>Computes and plots the trait-environment relationship of a given CWM trait and a focal environmental variable. In order to build the response curve, the function builds a dataframe where the focal environmental variable varies along a gradient and the other (non-focal) variables are fixed to their mean (but see FixX parameter for fixing non-focal variables to user-defined values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial_response(
  m,
  indexGradient,
  indexTrait,
  XFocal = NULL,
  grid.length = 200,
  FixX = NULL,
  FullPost = "mean"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partial_response_+3A_m">m</code></td>
<td>
<p>a model fitted with <code>jtdm_fit</code></p>
</td></tr>
<tr><td><code id="partial_response_+3A_indexgradient">indexGradient</code></td>
<td>
<p>The name (as specified in the column names of X) of the focal variable.</p>
</td></tr>
<tr><td><code id="partial_response_+3A_indextrait">indexTrait</code></td>
<td>
<p>The name (as specified in the column names of Y) of the focal trait.</p>
</td></tr>
<tr><td><code id="partial_response_+3A_xfocal">XFocal</code></td>
<td>
<p>Optional. A gradient of the focal variable provided by the user. If provided, the function will used this gradient instead of building a regular one. Default to NULL.</p>
</td></tr>
<tr><td><code id="partial_response_+3A_grid.length">grid.length</code></td>
<td>
<p>The number of points along the gradient of the focal variable. Default to 200.</p>
</td></tr>
<tr><td><code id="partial_response_+3A_fixx">FixX</code></td>
<td>
<p>Optional. A parameter to specify the value to which non-focal variables are fixed. This can be useful for example if we have some categorical variables (e.g. forest vs meadows) and we want to obtain the partial response curve for a given value of the variable. It has to be a list of the length and names of the columns of X. For example, if the columns of X are &quot;MAT&quot;,&quot;MAP&quot;,&quot;Habitat&quot; and we want to fix &quot;Habitat&quot; to 1, then FixX=list(MAT=NULL,MAP=NULL,Habitat=1.). Default to NULL.</p>
</td></tr>
<tr><td><code id="partial_response_+3A_fullpost">FullPost</code></td>
<td>
<p>The type of predictions to be obtain. If FullPost = TRUE, the function returns samples from the predictive distribution. If FullPost=&quot;mean&quot;, the function computes the posterior distribution of the regression term B%*%X). Default to &quot;mean&quot;, here FullPost cannot be FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>p</code></td>
<td>
<p>A plot of the trait-environment relationship.</p>
</td></tr>
<tr><td><code>predictions</code></td>
<td>
<p>A data frame containing the predicted trait-environmental relationships including the gradient of the focal environmental variable, mean trait predictions and quantiles (can be useful to code customized plot).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Y)  
data(X)  
# Short MCMC to obtain a fast example: results are unreliable !
m = jtdm_fit(Y=Y, X=X, formula=as.formula("~GDD+FDD+forest"), sample = 1000)  
# SLA-GDD relationship
plot = partial_response(m,indexGradient="GDD",indexTrait="SLA")
plot$p
# SLA-GDD relationship in forest (i.e. when forest=1)
plot = partial_response(m,indexGradient="GDD",indexTrait="SLA",
                        FixX=list(GDD=NULL,FDD=NULL,forest=1))
plot$p
</code></pre>

<hr>
<h2 id='plot.jtdm_fit'>Plots the parameters of a fitted jtdm</h2><span id='topic+plot.jtdm_fit'></span>

<h3>Description</h3>

<p>Plots the regression coefficients and covariance matrix of a fitted jtdm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jtdm_fit'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.jtdm_fit_+3A_x">x</code></td>
<td>
<p>a model fitted with <code>jtdm_fit</code></p>
</td></tr>
<tr><td><code id="plot.jtdm_fit_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the regression coefficients and covariance matrix of the fitted model
</p>


<h3>Author(s)</h3>

<p>Giovanni Poggiato
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Y)  
data(X)  
m = jtdm_fit(Y=Y, X=X, 
             formula=as.formula("~GDD+FDD+forest"), sample = 1000)  
plot(m)
</code></pre>

<hr>
<h2 id='summary.jtdm_fit'>Prints the summary of a fitted jtdm</h2><span id='topic+summary.jtdm_fit'></span>

<h3>Description</h3>

<p>Prints the summary of a fitted jtdm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jtdm_fit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.jtdm_fit_+3A_object">object</code></td>
<td>
<p>a model fitted with <code>jtdm_fit</code></p>
</td></tr>
<tr><td><code id="summary.jtdm_fit_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A printed summary of the fitted jtdm
</p>


<h3>Author(s)</h3>

<p>Giovanni Poggiato
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Y)  
data(X)  
m = jtdm_fit(Y=Y, X=X, 
             formula=as.formula("~GDD+FDD+forest"), sample = 1000)  
summary(m)
</code></pre>

<hr>
<h2 id='X'>Site x environmental covariates dataset</h2><span id='topic+X'></span>

<h3>Description</h3>

<p>Includes the Growing Degree Days (GDD) during the growing season and Freezing Degree Days (FDD) during the growing season averaged over the period 1989-2019
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(X)

data(X)
</code></pre>


<h3>Format</h3>

<p>A matrix
</p>


<h3>Author(s)</h3>

<p>Orchamp consortium
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(X)
</code></pre>

<hr>
<h2 id='Y'>Site x CWM traits dataset</h2><span id='topic+Y'></span>

<h3>Description</h3>

<p>A site x CWM traits dataset computed using pinpoint abundances of plants and species mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Y)
</code></pre>


<h3>Format</h3>

<p>A matrix
</p>


<h3>Author(s)</h3>

<p>Orchamp Consortium
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Y)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
