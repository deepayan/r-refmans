<!DOCTYPE html><html><head><title>Help for package neighbours</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {neighbours}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#neighbourfun'>
<p>Neighbourhood Functions</p></a></li>
<li><a href='#compare_vectors'>
<p>Compare Vectors</p></a></li>
<li><a href='#next_subset'>
<p>Select Next Subset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Neighbourhood Functions for Local-Search Algorithms</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-21</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Enrico Schumann &lt;es@enricoschumann.net&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Neighbourhood functions are key components of
  local-search algorithms such as Simulated Annealing or
  Threshold Accepting.  These functions take a solution and
  return a slightly-modified copy of it, i.e. a neighbour.
  The package provides a function neighbourfun() that
  constructs such neighbourhood functions, based on
  parameters such as admissible ranges for elements in a
  solution.  Supported are numeric and logical solutions.
  The algorithms were originally created for
  portfolio-optimisation applications, but can be used for
  other models as well.  Several recipes for neighbour
  computations are taken from "Numerical Methods and
  Optimization in Finance" by M. Gilli, D. Maringer and
  E. Schumann (2019, ISBN:978-0128150658).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://enricoschumann.net/R/packages/neighbours/">http://enricoschumann.net/R/packages/neighbours/</a> ,
<a href="https://sr.ht/~enricoschumann/neighbours/">https://sr.ht/~enricoschumann/neighbours/</a> ,
<a href="https://github.com/enricoschumann/neighbours">https://github.com/enricoschumann/neighbours</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>NMOF, quadprog, tinytest</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-21 15:17:40 UTC; es19</td>
</tr>
<tr>
<td>Author:</td>
<td>Enrico Schumann <a href="https://orcid.org/0000-0001-7601-6576"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-21 19:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='neighbourfun'>
Neighbourhood Functions
</h2><span id='topic+neighbourfun'></span><span id='topic+neighborfun'></span><span id='topic+neighbours'></span><span id='topic+neighbors'></span><span id='topic+neighbours-package'></span>

<h3>Description</h3>

<p>Create neighbourhood functions, including constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighbourfun(min = 0, max = 1, kmin = NULL, kmax = NULL,
             stepsize, sum = TRUE, random = TRUE, update = FALSE,
             type = "numeric", active = TRUE, length = NULL,
             A = NULL, ...)

neighborfun (min = 0, max = 1, kmin = NULL, kmax = NULL,
             stepsize, sum = TRUE, random = TRUE, update = FALSE,
             type = "numeric", active = TRUE, length = NULL,
             A = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighbourfun_+3A_min">min</code></td>
<td>
<p>a numeric vector. A scalar is recycled to <code>length</code>,
if specified.
</p>
</td></tr>
<tr><td><code id="neighbourfun_+3A_max">max</code></td>
<td>
<p>a numeric vector. A scalar is recycled to <code>length</code>,
if specified.
</p>
</td></tr>
<tr><td><code id="neighbourfun_+3A_kmin">kmin</code></td>
<td>
<p><code><a href="base.html#topic+NULL">NULL</a></code> or <code>integer</code>:
the minimum number of <code><a href="base.html#topic+TRUE">TRUE</a></code> values in logical vectors
</p>
</td></tr>
<tr><td><code id="neighbourfun_+3A_kmax">kmax</code></td>
<td>
<p><code><a href="base.html#topic+NULL">NULL</a></code> or <code>integer</code>:
the maximum number of <code><a href="base.html#topic+TRUE">TRUE</a></code> values in logical vectors
</p>
</td></tr>
<tr><td><code id="neighbourfun_+3A_stepsize">stepsize</code></td>
<td>
<p>numeric. For numeric neighbourhoods,
the (average) stepsize. For logical neighbourhoods,
the number of elements that are changed.
</p>
</td></tr>
<tr><td><code id="neighbourfun_+3A_sum">sum</code></td>
<td>
<p>logical or numeric.
If specified and of length 1, only zero-sum
changes will be applied to a numeric vector (i.e. the sum over all
elements in a solution remains unchanged).
</p>
</td></tr>
<tr><td><code id="neighbourfun_+3A_random">random</code></td>
<td>
<p>logical. Should the stepsize be random or fixed?
</p>
</td></tr>
<tr><td><code id="neighbourfun_+3A_active">active</code></td>
<td>
<p>a vector: either the positions of elements
that may be changed, or a logical vector. The default is a
length-one logical vector, which means that all
elements may be changed.
</p>
</td></tr>
<tr><td><code id="neighbourfun_+3A_update">update</code></td>
<td>
<p>either <code>logical</code> (the default
<code>FALSE</code>) or a string, specifying the type of
updating. Currently supported is <code>"Ax"</code>, in which
case the matrix <code>A</code> must be specified. See
Examples.</p>
</td></tr>
<tr><td><code id="neighbourfun_+3A_a">A</code></td>
<td>
<p>a numeric matrix</p>
</td></tr>
<tr><td><code id="neighbourfun_+3A_type">type</code></td>
<td>
<p>string: either <code>"numeric"</code>,
<code>"logical"</code> or <code>"permute"</code>
</p>
</td></tr>
<tr><td><code id="neighbourfun_+3A_length">length</code></td>
<td>

<p>integer: the length of a vector
</p>
</td></tr>
<tr><td><code id="neighbourfun_+3A_...">...</code></td>
<td>

<p>other arguments
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a closure with arguments <code>x</code>
and <code>...</code>, which can be used for local-search
algorithms.
</p>
<p>Three types of solution vectors are supported:
</p>

<dl>
<dt><code>numeric </code></dt><dd><p>a neighbour is created by adding
or subtracting typically small numbers to random
elements of a solution</p>
</dd>
<dt><code>logical</code> </dt><dd><p><code><a href="base.html#topic+TRUE">TRUE</a></code> and
<code><a href="base.html#topic+FALSE">FALSE</a> </code> values are switched</p>
</dd>
<dt><code>permute</code></dt><dd><p>elements of <code>x</code> are
exchanged. Works with atomic and generic vectors (aka
lists).</p>
</dd>
</dl>

<p><code>neighborfun</code> is an alias for <code>neighbourfun</code>.
</p>


<h3>Value</h3>

<p>A function (closure) with arguments <code>x</code> and
<code>...</code>.
</p>


<h3>Note on algorithms</h3>

<p>There are different strategies to implement constraints in
local-search algorithms, and ultimately only experiments
show which strategy works well for a given problem class.
The algorithms used by <code><a href="#topic+neighbourfun">neighbourfun</a></code> always
require a feasible initial solution, and then remain
within the space of feasible solutions. See Gilli et
al. (2019), Section 12.5, for a brief discussion.
</p>


<h3>Author(s)</h3>

<p>Maintainer: Enrico Schumann &lt;es@enricoschumann.net&gt;
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019) <em>Numerical
Methods and Optimization in Finance</em>. 2nd edition. Elsevier.<br />
<a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) <em>Financial Optimisation with R
(<span class="pkg">NMOF</span> Manual)</em>.<br />
<a href="http://enricoschumann.net/NMOF.htm#NMOFmanual">http://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>


<p>implementations of algorithms of the local-search family, such as
Simulated Annealing (<code><a href="NMOF.html#topic+SAopt">SAopt</a></code> in <span class="pkg">NMOF</span>) or
Threshold Accepting (<code><a href="NMOF.html#topic+TAopt">TAopt</a></code> in <span class="pkg">NMOF</span>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a LOGICAL neighbourhood
x &lt;- logical(8)
x[1:3] &lt;- TRUE

N &lt;- neighbourfun(type = "logical", kmin = 3, kmax = 3)

cat(ifelse(x, "o", "."), "  | initial solution ",
    sep = "", fill = TRUE)
for (i in 1:5) {
    x &lt;- N(x)
    cat(ifelse(x, "o", "."), sep = "", fill = TRUE)
}
## ooo.....  | initial solution
## oo....o.
## o...o.o.
## o.o.o...
## oo..o...
## oo....o.



## UPDATING a numeric neighbourhood
##   the vector is 'x' is used in the product 'Ax'
A &lt;- array(rnorm(100*25), dim = c(100, 25))
N &lt;- neighbourfun(type = "numeric",
                  stepsize = 0.05,
                  update = "Ax",
                  A = A)
x &lt;- rep(1/25, 25)
attr(x, "Ax") &lt;- A %*% x
for (i in 1:10)
    x &lt;- N(x, A)

all.equal(A %*% x, attr(x, "Ax"))



## a PERMUTATION neighbourhood
x &lt;- 1:5

N &lt;- neighbourfun(type = "permute")
N(x)
## [1] 1 2 5 4 3
##         ^   ^

N &lt;- neighbourfun(type = "permute", stepsize = 5)
N(x)

## 'x' is not restricted to integers
x &lt;- letters[1:5]
N(x)


## a useful way to STORE/SPECIFY PARAMETERS, e.g. in config files
settings &lt;- list(type = "numeric",
                 min = 0.0,
                 max = 0.2)
do.call(neighbourfun, settings)
</code></pre>

<hr>
<h2 id='compare_vectors'>
Compare Vectors
</h2><span id='topic+compare_vectors'></span>

<h3>Description</h3>

<p>Compare numeric or logical vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_vectors(..., sep = "", diff.char = "|")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_vectors_+3A_...">...</code></td>
<td>

<p>vectors of the same length
</p>
</td></tr>
<tr><td><code id="compare_vectors_+3A_sep">sep</code></td>
<td>

<p>a string
</p>
</td></tr>
<tr><td><code id="compare_vectors_+3A_diff.char">diff.char</code></td>
<td>

<p>a single character
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function compares vectors with one another. The
main purpose is to print a useful representation of
differences (and return differences, usually
invisibly).
</p>
<p>The function is still experimental and will likely change.
</p>


<h3>Value</h3>

<p>depends on how the function is called; typically a list
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+neighbourfun">neighbourfun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(5) &gt; 0.5
nb &lt;- neighbourfun(type = "logical")

compare_vectors(x, nb(x))
## 01010
##  |
## 00010
## The vectors differ in  1  place.

nb &lt;- neighbourfun(type = "logical", stepsize = 2)
compare_vectors(x, nb(x))
## 01010
## |   |
## 11011
## The vectors differ in  2  places.
</code></pre>

<hr>
<h2 id='next_subset'>
Select Next Subset
</h2><span id='topic+next_subset'></span>

<h3>Description</h3>

<p>Select next subset of size k from a set of size n.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>next_subset(a, n, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="next_subset_+3A_a">a</code></td>
<td>

<p>a numeric vector (integers)
</p>
</td></tr>
<tr><td><code id="next_subset_+3A_n">n</code></td>
<td>

<p>an integer: the size of the set to choose from
</p>
</td></tr>
<tr><td><code id="next_subset_+3A_k">k</code></td>
<td>

<p>an integer: the subset size
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a subset <em>a</em> of size <em>k</em> taken from a set
of size <em>n</em>, compute the next subset by alphabetical
order.
</p>
<p>Uses algorithm NEXKSB of Nijenhuis and Wilf (1975).
</p>


<h3>Value</h3>

<p>a numeric vector (the next subset) or <code><a href="base.html#topic+NULL">NULL</a></code>
(when there is no next subset)
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Nijenhuis, A. and Wilf, H. S. (1975)
<em>Combinatorial Algorithms for Computers and Calculators</em>.
Academic Press.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+choose">choose</a></code> computes the number of combinations<br />
<code><a href="utils.html#topic+combn">combn</a></code> creates all combinations<br />
<code><a href="base.html#topic+expand.grid">expand.grid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 4
k &lt;- 2
t(combn(n, k))
##      [,1] [,2]
## [1,]    1    2
## [2,]    1    3
## [3,]    1    4
## [4,]    2    3
## [5,]    2    4
## [6,]    3    4

a &lt;- 1:k
print(a)
while (!is.null(a))
    print(a &lt;- next_subset(a, n = n, k = k))
## [1] 1 2
## [1] 1 3
## [1] 1 4
## [1] 2 3
## [1] 2 4
## [1] 3 4
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
