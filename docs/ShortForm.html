<!DOCTYPE html><html><head><title>Help for package ShortForm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ShortForm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ShortForm'><p><code>ShortForm</code> package</p></a></li>
<li><a href='#.onAttach'><p>Package Attach Hook Function</p></a></li>
<li><a href='#ACO-class'><p>An S4 class for the Ant Colony Optimization Algorithm</p></a></li>
<li><a href='#add.param'><p>Adds a parameter to the given search table. Checks whether parameter</p>
is involved in any (in)equality constraints in a fitted lavaan model</a></li>
<li><a href='#antcolony.lavaan'><p>A function to implement the ant colony optimization algorithm for short form</p>
specification searches with the package lavaan.</a></li>
<li><a href='#antcolony.mplus'><p>A function to implement the ant colony optimization algorithm for short form</p>
specification searches, either using MPlus directly via
<code>system</code> calls or using Mplus indirectly with the package
MplusAutomation.</a></li>
<li><a href='#exampleAntModel'><p>Model syntax for the example in the <code>antcolony.lavaan</code> function.</p></a></li>
<li><a href='#modelCheck-class'><p>An S4 class for the modelCheck object</p></a></li>
<li><a href='#par.matches'><p>A series of internal functions used by the Tabu search.</p>
Directly accessing these functions is not advised unless you know what you are doing.</a></li>
<li><a href='#plot,ACO,ANY-method'><p>Plot method for class 'ACO'</p></a></li>
<li><a href='#plot,SA,ANY-method'><p>Plot method for class 'SA'</p></a></li>
<li><a href='#plot,TS,ANY-method'><p>Plot method for class 'TS'</p></a></li>
<li><a href='#refit.model'><p>Given a fitted lavaan model and a search table, refits the model using the search</p>
table as specifying what changes should be done (parameters fixed/freed).</a></li>
<li><a href='#SA-class'><p>An S4 class for the Simulated Annealing Algorithm</p></a></li>
<li><a href='#search.prep'><p>Given a fitted lavaan model (e.g., CFA), prepares a table that contains</p>
parameters that can be fixed/freed as part of a model specification search.</a></li>
<li><a href='#shortExampleAntModel'><p>Model syntax for the short example in the <code>antcolony.lavaan</code> function.</p></a></li>
<li><a href='#ShortFormStartup'><p>Create Package Startup Message</p></a></li>
<li><a href='#show,ACO-method'><p>Print method for class 'ACO'</p></a></li>
<li><a href='#show,SA-method'><p>Print method for class 'SA'</p></a></li>
<li><a href='#show,TS-method'><p>Print method for class 'TS'</p></a></li>
<li><a href='#simulated_test_data'><p>A simulated data set based on a standardized test.</p></a></li>
<li><a href='#simulatedAnnealing'><p>An adaptation of the simulated annealing algorithm for psychometric models.</p></a></li>
<li><a href='#summary,ACO-method'><p>Summary method for class 'ACO'</p></a></li>
<li><a href='#summary,SA-method'><p>Summary method for class 'SA'</p></a></li>
<li><a href='#summary,TS-method'><p>Summary method for class 'TS'</p></a></li>
<li><a href='#tabu.sem'><p>Given a fitted lavaan model, a search table, and an objective criterion,</p>
performs a Tabu model specification search. Currently only supports
neighbors that are 1 move away from the current model.</a></li>
<li><a href='#tabuShortForm'><p>Short Form Tabu Search</p></a></li>
<li><a href='#TS-class'><p>An S4 class for the Tabu Search Algorithm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Automatic Short Form Creation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-12</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs automatic creation of short forms of scales with an 
    ant colony optimization algorithm and a Tabu search. As implemented in the 
    package, the ant colony algorithm randomly selects items to build a model of 
    a specified length, then updates the probability of item selection according 
    to the fit of the best model within each set of searches. The algorithm 
    continues until the same items are selected by multiple ants a given number 
    of times in a row. On the other hand, the Tabu search changes one parameter at
    a time to be either free, constrained, or fixed while keeping track of the
    changes made and putting changes that result in worse fit in a "tabu" list
    so that the algorithm does not revisit them for some number of searches. 
    See Leite, Huang, &amp; Marcoulides (2008) &lt;<a href="https://doi.org/10.1080%2F00273170802285743">doi:10.1080/00273170802285743</a>&gt; for
    an applied example of the ant colony algorithm, and Marcoulides &amp; Falk (2018)
    &lt;<a href="https://doi.org/10.1080%2F10705511.2017.1409074">doi:10.1080/10705511.2017.1409074</a>&gt; for an applied example of the Tabu search.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="http://website-archive.mozilla.org/www.mozilla.org/mpl/MPL/1.0/">MPL version 1.0</a> | <a href="https://www.mozilla.org/en-US/MPL/1.1/">MPL version 1.1</a> | <a href="https://www.mozilla.org/en-US/MPL/2.0/">MPL version 2.0</a> [expanded from: LGPL (&ge; 2.0, &lt; 3) | Mozilla Public License]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, MplusAutomation (&ge; 0.7), rmarkdown, testthat</td>
</tr>
<tr>
<td>Imports:</td>
<td>lavaan (&ge; 0.5-22), ggplot2, ggrepel, tidyr, stringr, methods,
doSNOW, parallel, foreach</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/AnthonyRaborn/ShortForm">https://github.com/AnthonyRaborn/ShortForm</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/AnthonyRaborn/ShortForm/issues">https://github.com/AnthonyRaborn/ShortForm/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-13 04:08:48 UTC; chika</td>
</tr>
<tr>
<td>Author:</td>
<td>Anthony Raborn <a href="https://orcid.org/0000-0002-8083-4739"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Walter Leite [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anthony Raborn &lt;anthony.w.raborn@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-13 04:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ShortForm'><code>ShortForm</code> package</h2><span id='topic+ShortForm'></span><span id='topic+ShortForm-package'></span>

<h3>Description</h3>

<p>Automated Item Selection Algorithms for Short Forms
</p>


<h3>Details</h3>

<p>See the README on <a href="https://github.com/AnthonyRaborn/ShortForm#readme">GitHub</a> for more information.
</p>

<hr>
<h2 id='.onAttach'>Package Attach Hook Function</h2><span id='topic+.onAttach'></span>

<h3>Description</h3>

<p>Hook triggered when package attached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onAttach(lib, pkg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".onAttach_+3A_lib">lib</code></td>
<td>
<p>a character string giving the library directory where the package
defining the namespace was found</p>
</td></tr>
<tr><td><code id=".onAttach_+3A_pkg">pkg</code></td>
<td>
<p>a character string giving the name of the package</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Idea taken from https://github.com/ntguardian/MCHT/blob/master/R/StartupMessage.R
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ShortForm:::.onAttach(.libPaths()[1], "ShortForm")
</code></pre>

<hr>
<h2 id='ACO-class'>An S4 class for the Ant Colony Optimization Algorithm</h2><span id='topic+ACO-class'></span>

<h3>Description</h3>

<p>An S4 class for the Ant Colony Optimization Algorithm
</p>


<h3>Value</h3>

<p>An S4 object of class 'ACO'.
</p>


<h3>Slots</h3>


<dl>
<dt><code>function_call</code></dt><dd><p>The original function call.</p>
</dd>
<dt><code>summary</code></dt><dd><p>A summary 'data.frame' indicating the algorithm results for
each iteration.</p>
</dd>
<dt><code>final_solution</code></dt><dd><p>A 'matrix' with the final solution information, including
fit indices, selected items, and pheromone level.</p>
</dd>
<dt><code>best_model</code></dt><dd><p>A 'lavaan' object of the final solution.</p>
</dd>
<dt><code>best_syntax</code></dt><dd><p>A 'character' vector of the final solution model syntax.</p>
</dd>
<dt><code>runtime</code></dt><dd><p>A 'difftime' object of the total run time of the function.</p>
</dd>
</dl>

<hr>
<h2 id='add.param'>Adds a parameter to the given search table. Checks whether parameter
is involved in any (in)equality constraints in a fitted lavaan model</h2><span id='topic+add.param'></span>

<h3>Description</h3>

<p>Adds a parameter to the given search table. Checks whether parameter
is involved in any (in)equality constraints in a fitted lavaan model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.param(
  fitted.model,
  ptab,
  syntax,
  nullval = NULL,
  free = NULL,
  block = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.param_+3A_fitted.model">fitted.model</code></td>
<td>
<p>fitted lavaan model</p>
</td></tr>
<tr><td><code id="add.param_+3A_ptab">ptab</code></td>
<td>
<p>search table</p>
</td></tr>
<tr><td><code id="add.param_+3A_syntax">syntax</code></td>
<td>
<p>model.syntax specifying the parameter to add to the current table</p>
</td></tr>
<tr><td><code id="add.param_+3A_nullval">nullval</code></td>
<td>
<p>optional numeric value specifying what the parameter should be fixed to (when fixed)</p>
</td></tr>
<tr><td><code id="add.param_+3A_free">free</code></td>
<td>
<p>optional logical value specifying whether the parameter should initially be set free (or not)</p>
</td></tr>
<tr><td><code id="add.param_+3A_block">block</code></td>
<td>
<p>optional numeric value specifying the group number to which the parameter corresponds</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with lavaan-formatted parameter values.
</p>


<h3>Author(s)</h3>

<p>Carl F. Falk
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1080/10705511.2017.1409074">doi:10.1080/10705511.2017.1409074</a>
</p>


<h3>See Also</h3>

<p>Other Tabu Search: 
<code><a href="#topic+refit.model">refit.model</a>()</code>,
<code><a href="#topic+search.prep">search.prep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load simulation data and select columns used in this example
data(simulated_test_data)
tabuData &lt;- simulated_test_data[, c(1:10)]

# specify an improper model (improper because data is unidimensional)
tabuModel &lt;- "
Ability =~ Item1 + Item2 + Item3 + Item4
FakeAbility =~ Item5 + Item6 + Item7 + Item8
Ability ~ Outcome
FakeAbility ~ 0*Outcome"

# run the initial misspecified model for Tabu

init.model &lt;- lavaan::lavaan(
  model = tabuModel, data = tabuData,
  auto.var = TRUE, auto.fix.first = FALSE, std.lv = TRUE, auto.cov.lv.x = TRUE
)

# Use search.prep to prepare for the Tabu search
ptab &lt;- search.prep(fitted.model = init.model, loadings = TRUE, fcov = TRUE, errors = FALSE)

# add an additional (mispecified) parameter
additional.param &lt;- "Item1 ~~ 0.5*Item3"
ptab &lt;- add.param(fitted.model = init.model, ptab = ptab, syntax = additional.param)

# Perform Tabu Search
trial &lt;- tabu.sem(init.model = init.model, ptab = ptab, obj = AIC, niter = 2, tabu.size = 5)

## End(Not run)

</code></pre>

<hr>
<h2 id='antcolony.lavaan'>A function to implement the ant colony optimization algorithm for short form
specification searches with the package <a href="lavaan.html#topic+lavaan">lavaan</a>.</h2><span id='topic+antcolony.lavaan'></span>

<h3>Description</h3>

<p>The Ant Colony Optimization (ACO) algorithm (Dorigo &amp; Stutzle,
2004) can produce short forms of scales that are optimized with respect to
characteristics selected by the developer, such as model fit and predictive
relationships with other variables. The algorithm is based on the foraging
behavior of a group of ants, which start searching for food in a variety of
directions and then eventually all ants converge to the shortest distance to
the food source. This behavior occurs because ants leave a pheronome trail
behind as they search for food and ants in shorter paths leave stronger
pheronome trails, which are detected by other ants and that will lead them
to follow the shortest trail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>antcolony.lavaan(
  data = NULL,
  sample.cov = NULL,
  sample.nobs = NULL,
  ants = 20,
  evaporation = 0.9,
  antModel,
  list.items = NULL,
  full = NULL,
  i.per.f = NULL,
  factors = NULL,
  bifactor = NULL,
  steps = 50,
  lavaan.model.specs = list(model.type = "cfa", auto.var = T, estimator = "default",
    ordered = NULL, int.ov.free = TRUE, int.lv.free = FALSE, auto.fix.first = TRUE,
    auto.fix.single = TRUE, auto.var = TRUE, auto.cov.lv.x = TRUE, auto.th = TRUE,
    auto.delta = TRUE, auto.cov.y = TRUE, std.lv = F, group = NULL, group.label = NULL,
    group.equal = "loadings", group.partial = NULL, group.w.free = FALSE),
  pheromone.calculation = "gamma",
  fit.indices = c("cfi", "tli", "rmsea"),
  fit.statistics.test = "(cfi &gt; 0.95)&amp;(tli &gt; 0.95)&amp;(rmsea &lt; 0.06)",
  summaryfile = NULL,
  feedbackfile = NULL,
  max.run = 1000,
  parallel = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="antcolony.lavaan_+3A_data">data</code></td>
<td>
<p>The data being used in data frame format. Default value is
<code>null</code>. Only one of <code>data</code> or <code>sample.cov</code> should be used.</p>
</td></tr>
<tr><td><code id="antcolony.lavaan_+3A_sample.cov">sample.cov</code></td>
<td>
<p>The sample covariance matrix. See <a href="lavaan.html#topic+lavaan">lavaan</a> for
the specific format needed. Default value is <code>null</code>. Only one of
<code>data</code> or <code>sample.cov</code> should be used.</p>
</td></tr>
<tr><td><code id="antcolony.lavaan_+3A_sample.nobs">sample.nobs</code></td>
<td>
<p>A numeric value indicating the number of observations in
the sample covariance matrix. If <code>sample.cov</code> is used, this must be
filled in. Default value is <code>null</code>.</p>
</td></tr>
<tr><td><code id="antcolony.lavaan_+3A_ants">ants</code></td>
<td>
<p>A numeric value indicating the number of ants to send (e.g.,
number of short forms to evaluate) per iteration. Default value is 20.</p>
</td></tr>
<tr><td><code id="antcolony.lavaan_+3A_evaporation">evaporation</code></td>
<td>
<p>A numeric value which sets the percentage of the pheromone
that is retained after evaporation between steps of the algorithm. Default
value is 0.9, indicating 10
(0,1), exclusive.</p>
</td></tr>
<tr><td><code id="antcolony.lavaan_+3A_antmodel">antModel</code></td>
<td>
<p>The lavaan formatted model. See <a href="lavaan.html#topic+lavaan">lavaan</a> for more
details. Defaults to the default <a href="lavaan.html#topic+lavaan">lavaan</a> values. NOTE: Each factor
and/or regression needs to be specified on a single line. Newline breaks and
carriage returns WILL break the function.</p>
</td></tr>
<tr><td><code id="antcolony.lavaan_+3A_list.items">list.items</code></td>
<td>
<p>A list containing one or more character vectors of item
names for each factor, where each factor is a separate element of the list.
The items should be input in the order in which the factors are input in
<code>i.per.f</code> and <code>factors</code>.</p>
</td></tr>
<tr><td><code id="antcolony.lavaan_+3A_full">full</code></td>
<td>
<p>A numeric value indicating the total number of unique items in the
test or scale.</p>
</td></tr>
<tr><td><code id="antcolony.lavaan_+3A_i.per.f">i.per.f</code></td>
<td>
<p>Vector with number of items per factor (e.g. target number), in
the same order of <code>list.items</code> and <code>factors</code>.</p>
</td></tr>
<tr><td><code id="antcolony.lavaan_+3A_factors">factors</code></td>
<td>
<p>Character vector with names of factors in the same order of
<code>list.items</code> and <code>i.per.f</code>.</p>
</td></tr>
<tr><td><code id="antcolony.lavaan_+3A_bifactor">bifactor</code></td>
<td>
<p>Either the name of the factor that all of the chosen items
will load on (as character), or 'NULL' if the model is not a bifactor model.</p>
</td></tr>
<tr><td><code id="antcolony.lavaan_+3A_steps">steps</code></td>
<td>
<p>A numeric value that sets the stopping rule, which is the number
of ants in a row for which the model does not change.</p>
</td></tr>
<tr><td><code id="antcolony.lavaan_+3A_lavaan.model.specs">lavaan.model.specs</code></td>
<td>
<p>A list which contains the specifications for the
lavaan model. The default values are the defaults for lavaan to perform a
CFA. See <a href="lavaan.html#topic+lavaan">lavaan</a> for more details.</p>
</td></tr>
<tr><td><code id="antcolony.lavaan_+3A_pheromone.calculation">pheromone.calculation</code></td>
<td>
<p>A character string specifying the method for
calculating the pheromone strength. Must be one of &quot;<code>gamma</code>&quot;
(standardized latent regression coefficients), &quot;<code>beta</code>&quot;
(standardized observed regression coefficients), &quot;<code>regression</code>&quot;
(both latent and observed regression coefficients, if they exist)
or &quot;<code>variance</code>&quot; (proportion of
variance explained by model). You must specify the entire string. Default is
<code>gamma</code>.</p>
</td></tr>
<tr><td><code id="antcolony.lavaan_+3A_fit.indices">fit.indices</code></td>
<td>
<p>The fit indices (in lavaan format) extracted for model
optimization. See <a href="lavaan.html#topic+lavaan">lavaan</a> for more details.</p>
</td></tr>
<tr><td><code id="antcolony.lavaan_+3A_fit.statistics.test">fit.statistics.test</code></td>
<td>
<p>A character vector of the logical test being used
for model optimization. The default is <code>"(cfi &gt; 0.95)&amp;(tli &gt;
0.95)&amp;(rmsea &lt; 0.06)"</code>. The format for the logical test should match 1) the
names of the indices being used in <a href="lavaan.html#topic+lavaan">lavaan</a> and 2) the default
provided above. At least one fit index must be included.</p>
</td></tr>
<tr><td><code id="antcolony.lavaan_+3A_summaryfile">summaryfile</code></td>
<td>
<p>The name of the summary file generated. A .txt file is
suggested. Default is &quot;summary.txt&quot; and writes into the current working
directory. This file writes a line for each ant within each step and
includes (a) a vector of a 0/1 value for each item indicating whether the
item was selected by that ant, (b) the run number, (c) the count number, (d)
the ant number, and (e) the current pheromone level.</p>
</td></tr>
<tr><td><code id="antcolony.lavaan_+3A_feedbackfile">feedbackfile</code></td>
<td>
<p>The name of the feedback file generated. An .html file is
suggested. Default is &quot;iteration.html&quot; and writes into the current working
directory. This file saves the result of each run, which includes (a) the
run number, (b) the count number, (c) the ant number, (d) the step number
(if the current run is successful) or &quot;Failure&quot; (if the current run is
unsuccessful), and for successful runs (f) the chosen fit statistics (from
<code>fit.indices</code>), the average of the gammas and betas (standardized regression
coefficients), and the overall variance explained of the current run.</p>
</td></tr>
<tr><td><code id="antcolony.lavaan_+3A_max.run">max.run</code></td>
<td>
<p>The maximum number of ants to run before the algorithm stops.
This includes failed iterations as well. Default is 1000.</p>
</td></tr>
<tr><td><code id="antcolony.lavaan_+3A_parallel">parallel</code></td>
<td>
<p>An option for using parallel processing. If <code>TRUE</code>, the
function will utilize all available cores (up to the number of ants). Default
is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function sends a specified number of ants per iteration, which
randomly select items to build a model, then evaluates the model based on
pheromone levels. The pheromone levels are updated after each iteration
according to the best-fitting model of that iteration. The algorithm's
stopping rule is to end the search when a certain solution is the same for a
given number of ants in a row.
</p>
<p>PREPARATORY STEPS: For the ACO algorithm implementation for short for
selection, the following decisions are needed:
</p>
<p>1. Determine the target size for the short form.
</p>
<p>2. Determine which characteristics should be optimized.
</p>
<p>3. Define how the pheronome level will be computed: This is a function of
the characteristics of the short form that will be optimized. In Leite,
Huang and Marcoulides (2008), the pheromone level was zero if model fit
indices did not meet Hu and Bentler's (1999) suggested thresholds, and equal
to the sum of path coefficients of a predictor variable if model fit indices
met thresholds. Currently, the package only implements pheromone calculation
based on regression coefficients or variance explained, with user-selected
model fit index thresholds.
</p>
<p>4. Define how many short forms should be evaluated before the best-so-far
pheronome level is examined. Leite, Huang and Marcoulides (2008) used 10
short forms.
</p>
<p>5. Define the percentage of pheronome evaporation, if any. Leite, Huang and
Marcoulides (2008) used 5%.
</p>
<p>6. Define convergence criterion. Leite, Huang and Marcoulides (2008) set the
algorithm to converge if the short form did not improve in 100 x number of
short forms in step 4.
</p>
<p>IMPLEMENTATION: Once these decisions are made, the ACO algorithm selects
short forms with the following steps:
</p>
<p>Step 1. All items are assigned an initial weight of 1.
</p>
<p>Step 2. A set of n short forms is selected by sampling with probability
proportional to the item weights.
</p>
<p>Step 3. Fit the latent variable model to the n short forms.
</p>
<p>Step 4. Calculate the pheromone levels for the n short forms. Define the
best-so-far pheronome level (if iteration 1) or compare the current best
pheronome from the set of n short forms to the best-so-far pheronome.
</p>
<p>Step 5. If the pheromone level of the best short form from step 4 exceeds
the best-so-far pheronome level, update the best-so-far pheromone level and
add it to the current weight of the items of the best short form.
</p>
<p>Step 6. Return to step 2 until convergence criterion is reached.
</p>


<h3>Value</h3>

<p>A list with four elements: the first containing a named matrix with
final model's best fit indices, the final pheromone level (either the mean
of the standardized regression coefficients (gammas, betas, or both), or the mean variance
explained), and a series of 0/1 values indicating the items selected in the
final solution,  the second element containing tbe summary matrix of the
best fit statistic value(s) for each run, the items chosen for said best fit,
the mean gamma, beta, and variance explained for the best fit, and the item pheromone
levels after each run, the third containing the best-fitting lavaan model
object, and the fourth containing the best-fitting model syntax.
</p>


<h3>Author(s)</h3>

<p>Anthony W Raborn, <a href="mailto:anthony.w.raborn@gmail.com">anthony.w.raborn@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+antcolony.mplus">antcolony.mplus</a></code>
</p>
<p>Other Ant Colony Algorithms: 
<code><a href="#topic+antcolony.mplus">antcolony.mplus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a 3-factor example using the HolzingerSwineford1939 data from `lavaan`

# some changes to the default values
# notice that in this example we are recreating the original model
abilityShortForm &lt;- antcolony.lavaan(
  data = lavaan::HolzingerSwineford1939,
  ants = 2, evaporation = 0.7,
  antModel = " visual  =~ x1 + x2 + x3
             textual =~ x4 + x5 + x6
             speed   =~ x7 + x8 + x9 ",
  list.items = list(c(
    "x1",
    "x2", "x3"
  ), c("x4", "x5", "x6"), c("x7", "x8", "x9")), full = 9, i.per.f =
    c(3, 3, 3), factors = c("visual", "textual", "speed"), steps = 2, fit.indices =
    c("cfi"), fit.statistics.test = "(cfi &gt; 0.6)", summaryfile =
    NULL, feedbackfile = NULL, max.run = 2, parallel = FALSE
)
## Not run: 
# using simulated test data and the default values for lavaan.model.specs
# first, read in the original or "full" model
data(exampleAntModel) # a character vector for a lavaan model

# then, create the list of the items by the factors
# in this case, all items load onto the general 'Ability' factor
list.items &lt;- list(c(
  "Item1", "Item2", "Item3", "Item4", "Item5",
  "Item6", "Item7", "Item8", "Item9", "Item10",
  "Item11", "Item12", "Item13", "Item14", "Item15",
  "Item16", "Item17", "Item18", "Item19", "Item20",
  "Item21", "Item22", "Item23", "Item24", "Item25",
  "Item26", "Item27", "Item28", "Item29", "Item30",
  "Item31", "Item32", "Item33", "Item34", "Item35",
  "Item36", "Item37", "Item38", "Item39", "Item40",
  "Item41", "Item42", "Item43", "Item44", "Item45",
  "Item46", "Item47", "Item48", "Item49", "Item50",
  "Item51", "Item52", "Item53", "Item54", "Item55", "Item56"
))

# load the data
data(simulated_test_data)

# finally, call the function with some minor changes to the default values.
abilityShortForm &lt;- antcolony.lavaan(
  data = simulated_test_data,
  ants = 5, evaporation = 0.7, antModel = exampleAntModel,
  list.items = list.items, full = 56, i.per.f = 20,
  factors = "Ability", steps = 3, fit.indices = c("cfi", "rmsea"),
  fit.statistics.test = "(cfi &gt; 0.95)&amp;(rmsea &lt; 0.05)",
  summaryfile = "summary.txt",
  feedbackfile = "iteration.html",
  max.run = 500
)

abilityShortForm # print the results of the final short form

## End(Not run)
</code></pre>

<hr>
<h2 id='antcolony.mplus'>A function to implement the ant colony optimization algorithm for short form
specification searches, either using MPlus directly via
<code><a href="base.html#topic+system">system</a></code> calls or using Mplus indirectly with the package
<a href="MplusAutomation.html#topic+MplusAutomation">MplusAutomation</a>.</h2><span id='topic+antcolony.mplus'></span>

<h3>Description</h3>

<p>The Ant Colony Optimization (ACO) algorithm (Dorigo &amp; Stutzle,
2004) can produce short forms of scales that are optimized with respect to
characteristics selected by the developer, such as model fit and predictive
relationships with other variables. The algorithm is based on the foraging
behavior of a group of ants, which start searching for food in a variety of
directions and then eventually all ants converge to the shortest distance to
the food source. This behavior occurs because ants leave a pheromone trail
behind as they search for food and ants in shorter paths leave stronger
pheromone trails, which are detected by other ants and that will lead them to
follow the shortest trail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>antcolony.mplus(
  ants = 20,
  evaporation = 0.95,
  mplus = NULL,
  list.items = NULL,
  full = NULL,
  i.per.f = NULL,
  factors = NULL,
  steps = 50,
  max.run = 1000,
  resultfile = NULL,
  summaryfile = "summary.txt",
  min.CFI = 0.95,
  min.TLI = 0.95,
  max.RMSEA = 0.06,
  feedbackfile = "iteration.html",
  loc.gammas,
  loc.variances,
  predictors,
  var.predictors,
  Mplus.Automation = FALSE,
  dataOut = "tempModel.dat",
  modelOut = "tempModel.inp"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="antcolony.mplus_+3A_ants">ants</code></td>
<td>
<p>A numeric value indicating the number of ants to send send (short
forms to evaluate) per iteration. Default value is 20.</p>
</td></tr>
<tr><td><code id="antcolony.mplus_+3A_evaporation">evaporation</code></td>
<td>
<p>A numeric value which sets the percentage of the pheremone
that is retained after evaporation between steps of the algorithm. Default
value is 0.9, indicating 10
(0,1), exclusive.</p>
</td></tr>
<tr><td><code id="antcolony.mplus_+3A_mplus">mplus</code></td>
<td>
<p>When <code>Mplus.Automation=FALSE</code>, this is a character value
indicating the name of the MPlus input file without the file extension
&quot;.inp&quot;. If not in the current working directory, include the full file path
where it is located. This file will be changed during the ant colony search,
so it's suggested to make a backup of the original file before running the
function. When <code>Mplus.Automation=TRUE</code>, this is an object of class
<a href="MplusAutomation.html#topic+mplusObject">mplusObject</a> created by
<a href="MplusAutomation.html#topic+MplusAutomation">MplusAutomation</a> and containing the initial model.</p>
</td></tr>
<tr><td><code id="antcolony.mplus_+3A_list.items">list.items</code></td>
<td>
<p>A list containing one or more character vectors of item
names for each factor, where each factor is a separate element of the list.
The items should be input in the order in which the factors are input in
<code>i.per.f</code> and <code>factors</code>.</p>
</td></tr>
<tr><td><code id="antcolony.mplus_+3A_full">full</code></td>
<td>
<p>A numeric value indicating the total number of unique items in the
test or scale.</p>
</td></tr>
<tr><td><code id="antcolony.mplus_+3A_i.per.f">i.per.f</code></td>
<td>
<p>A vector with number of items per factor (e.g. target number),
in the same order of <code>list.items</code> and <code>factors</code>.</p>
</td></tr>
<tr><td><code id="antcolony.mplus_+3A_factors">factors</code></td>
<td>
<p>A character vector with the names of the factors in the same
order of <code>list.items</code> and <code>i.per.f</code>.</p>
</td></tr>
<tr><td><code id="antcolony.mplus_+3A_steps">steps</code></td>
<td>
<p>A numeric value that sets the stopping rule, which is the number
of ants in a row for which the model does not change.</p>
</td></tr>
<tr><td><code id="antcolony.mplus_+3A_max.run">max.run</code></td>
<td>
<p>The maximum number of ants to run before the algorithm stops.
This includes failed iterations as well. Default is 1000.</p>
</td></tr>
<tr><td><code id="antcolony.mplus_+3A_resultfile">resultfile</code></td>
<td>
<p>A character vector containing the file path where the MPlus
results for the current ant model is saved. If the file is not in the
current working directery, the full path must be specified. Not used when
<code>Mplus.Automation=FALSE</code>.</p>
</td></tr>
<tr><td><code id="antcolony.mplus_+3A_summaryfile">summaryfile</code></td>
<td>
<p>A character vector containing the name of the summary file
generated. A .txt file is suggested. Default is &quot;summary.txt&quot; and writes
into the current working directory. This file writes a line for each ant
within each step and includes (a) a vector of a 0/1 value for each item
indicating whether the item was selected by that ant, (b) the run number,
(c) the count number, (d) the ant number, and (e) the current pheromone
level.</p>
</td></tr>
<tr><td><code id="antcolony.mplus_+3A_min.cfi">min.CFI</code></td>
<td>
<p>A numeric value indicating the minimum CFI for &quot;acceptable&quot;
model fit. Models with CFI less than this value are automatically rejected.
Default is 0.95.</p>
</td></tr>
<tr><td><code id="antcolony.mplus_+3A_min.tli">min.TLI</code></td>
<td>
<p>A numeric value indicating the minimum TLI for &quot;acceptable&quot;
model fit. Models with TLI less than this value are automatically rejected.
Default is 0.95.</p>
</td></tr>
<tr><td><code id="antcolony.mplus_+3A_max.rmsea">max.RMSEA</code></td>
<td>
<p>A numeric value indicating the maximum RMSEA for &quot;acceptable&quot;
model fit. Models with RMSEA greater than this value are automatically
rejected. Default is 0.06</p>
</td></tr>
<tr><td><code id="antcolony.mplus_+3A_feedbackfile">feedbackfile</code></td>
<td>
<p>A character vector containing the name of the feedback
file generated. An .html file is suggested. Default is &quot;iteration.html&quot; and
writes into the current working directory. This file saves the result of
each run, which includes (a) the run number, (b) the count number, (c) the
ant number, (d) the step number (if the current run is successful) or
&quot;Failure&quot; (if the current run is unsuccessful), and for successful runs (f)
the value of CFI, TLI, and RMSEA fit indices, the average of the gammas
(standardized regression coefficients), and the overall variance explained
of the current run.</p>
</td></tr>
<tr><td><code id="antcolony.mplus_+3A_loc.gammas">loc.gammas</code></td>
<td>
<p>A numeric vector with the line numbers where the regression
coefficients of the MIMIC model start and end (locations). Not used with
<code>Mplus.Automation=TRUE</code></p>
</td></tr>
<tr><td><code id="antcolony.mplus_+3A_loc.variances">loc.variances</code></td>
<td>
<p>A numeric vector with the line numbers of the residual
variances of the latent factors. Not used with <code>Mplus.Automation=TRUE</code></p>
</td></tr>
<tr><td><code id="antcolony.mplus_+3A_predictors">predictors</code></td>
<td>
<p>Character vector with names of predictor variables, if any.</p>
</td></tr>
<tr><td><code id="antcolony.mplus_+3A_var.predictors">var.predictors</code></td>
<td>
<p>A numeric vector with variances of the predictor(s), if
any. Not used with <code>Mplus.Automation=TRUE</code></p>
</td></tr>
<tr><td><code id="antcolony.mplus_+3A_mplus.automation">Mplus.Automation</code></td>
<td>
<p>Logical. If <code>TRUE</code>, uses the
<code>MplusAutomation</code> package to modify the model as the algorithm
procedes. The &quot;mplus&quot; option will then be used as Defaults to <code>FALSE</code>
as it is in the process of being built.</p>
</td></tr>
<tr><td><code id="antcolony.mplus_+3A_dataout">dataOut</code></td>
<td>
<p>A character vector specifying the location and name of the data
file generated by <code>MplusAutomation</code> for each iteration of the
algorithm. Default is &quot;tempData.dat&quot; and saves to the current working
directory. When specifying the name, be sure to use a data format that Mplus
can read. You must change the working directory to the location in which
this file will be saved. Only used when <code>Mplus.Automation=TRUE</code>.</p>
</td></tr>
<tr><td><code id="antcolony.mplus_+3A_modelout">modelOut</code></td>
<td>
<p>A character vector specifying the location and name of the
Mplus model file generated by <code>MplusAutomation</code> for each iteration of
the algorithm. Default is &quot;tempModel.inp&quot; and saves to the current working
directory. When specifying the name of the model file, it must be a &quot;.inp&quot;
extension. You must change the working directory to the location in which
this file will be saved. Only used when <code>Mplus.Automation=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function sends a specified number of ants
per iteration, which randomly select items to build a model, then evaluates
the model based on pheromone levels. The pheromone levels are updated after
each iteration according to the best-fitting model of that iteration. The
algorithm's stopping rule is to end the search when a certain solution is the
same for a given number of ants in a row. When constructing the mplus dataset
and when <code>Mplus.Automation=FALSE</code>, make sure that items in 'categorical
are' and 'usevariables' are specifications that take the same number of lines
per short form.
</p>
<p>PREPARATORY STEPS: For the ACO algorithm implementation for short
for selection, the following decisions are needed:
</p>
<p>1. Determine the target size for the short form.
</p>
<p>2. Determine which characteristics should be optimized.
</p>
<p>3. Define how the pheromone level will be computed: This is a function of the
characteristics of the short form that will be optimized. In Leite, Huang and
Marcoulides (2008), the pheromone level was zero if model fit indices did
not meet Hu and Bentler's (1999) suggested thresholds, and equal to the sum of
path coefficients of a predictor variable if model fit indices met thresholds.
Currently, the package only implements pheromone calculation based on
regression coefficients or variance explained, with user-selected model fit
index thresholds.
</p>
<p>4. Define how many short forms should be evaluated before the best-so-far
pheromone level is examined. Leite, Huang and Marcoulides (2008) used 10 short
forms.
</p>
<p>5. Define the percentage of pheromone evaporation, if any. Leite, Huang and
Marcoulides (2008) used 5%.
</p>
<p>6. Define convergence criterion. Leite, Huang and Marcoulides (2008) set the
algorithm to converge if the short form did not improve in 100 x number of
short forms in step 4.
</p>
<p>IMPLEMENTATION: Once these decisions are made, the ACO algorithm
selects short forms with the following steps:
</p>
<p>Step 1. All items are assigned an initial weight of 1.
</p>
<p>Step 2. A set of n short forms is selected by sampling with probability
proportional to the items' weights.
</p>
<p>Step 3. Fit latent variable model to the n short forms.
</p>
<p>Step 4. Calculate the pheromone levels for the n short forms. Define the
best-so-far pheromone level (if iteration 1) or compare the current best
pheromone from the set of n short forms to the best-so-far pheromone.
</p>
<p>Step 5. If the pheromone level of the best short form from step 4 exceeds the
best-so-far pheromone level, update the best-so-far pheromone level and add it
to the current weight of the items of the best short form.
</p>
<p>Step 6. Return to step 2 until convergence criterion is reached.
</p>


<h3>Value</h3>

<p>A named matrix containing final model's best RMSEA, CFI, and TLI
values, the final pheromone level (the mean of the standardized regression
coefficients (gammas)), and a series of 0/1 values indicating the items
selected in the final solution.
</p>


<h3>Author(s)</h3>

<p>Walter Leite; Anthony W Raborn, <a href="mailto:anthony.w.raborn@gmail.com">anthony.w.raborn@gmail.com</a>
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1080/00273170802285743">doi:10.1080/00273170802285743</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+antcolony.lavaan">antcolony.lavaan</a></code>
</p>
<p>Other Ant Colony Algorithms: 
<code><a href="#topic+antcolony.lavaan">antcolony.lavaan</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# use MplusAutomation to find a 15-item short form of a simulated 56-item unidimensional test
# first, create the list of the items by the factors
# in this case, all items load onto the general 'Ability' factor
list.items &lt;- list(c(
  "Item1", "Item2", "Item3", "Item4", "Item5",
  "Item6", "Item7", "Item8", "Item9", "Item10",
  "Item11", "Item12", "Item13", "Item14", "Item15",
  "Item16", "Item17", "Item18", "Item19", "Item20",
  "Item21", "Item22", "Item23", "Item24", "Item25",
  "Item26", "Item27", "Item28", "Item29", "Item30",
  "Item31", "Item32", "Item33", "Item34", "Item35",
  "Item36", "Item37", "Item38", "Item39", "Item40",
  "Item41", "Item42", "Item43", "Item44", "Item45",
  "Item46", "Item47", "Item48", "Item49", "Item50",
  "Item51", "Item52", "Item53", "Item54", "Item55",
  "Item56"
))
# then, load the data
data(simulated_test_data)

# Create the mplusObject with MplusAutomation
# notice the explicit call of each item, instead of the shorthand "Item1-Item56"
initial.MplusAutomation.model &lt;- MplusAutomation::mplusObject(
  TITLE = "Trial ACO MpluAutomation with FERA 2016 Data;",
  MODEL = "Ability BY Item1 Item2 Item3 Item4 Item5
  Item6 Item7 Item8 Item9 Item10 Item11 Item12
  Item13 Item14 Item15 Item16 Item17 Item18
  Item19 Item20 Item21 Item22 Item23 Item24
  Item25 Item26 Item27 Item28 Item29 Item30
  Item31 Item32 Item33 Item34 Item35 Item36
  Item37 Item38 Item39 Item40 Item41 Item42
  Item43 Item44 Item45 Item46 Item47 Item48
  Item49 Item50 Item51 Item52 Item53 Item54
  Item55 Item56;",
  ANALYSIS = "ESTIMATOR = WLSMV;",
  VARIABLE = "CATEGORICAL = Item1 Item2 Item3 Item4 Item5
  Item6 Item7 Item8 Item9 Item10 Item11 Item12
  Item13 Item14 Item15 Item16 Item17 Item18
  Item19 Item20 Item21 Item22 Item23 Item24
  Item25 Item26 Item27 Item28 Item29 Item30
  Item31 Item32 Item33 Item34 Item35 Item36
  Item37 Item38 Item39 Item40 Item41 Item42
  Item43 Item44 Item45 Item46 Item47 Item48
  Item49 Item50 Item51 Item52 Item53 Item54
  Item55 Item56;",
  OUTPUT = "stdyx;",
  rdata = simulated_test_data
)

# finally, call the function with some minor changes to the default values.
abilityShortForm &lt;- antcolony.mplus(
  ants = 3, evaporation = 0.7,
  mplus = initial.MplusAutomation.model, list.items = list.items, full = 56,
  i.per.f = 15, factors = "Ability", steps = 3, max.run = 50, resultfile = NULL,
  summaryfile = "C:/Users/lordmaxwell/Desktop/summary.txt",
  min.CFI = 0.95, min.TLI = 0.95, max.RMSEA = 0.06,
  feedbackfile = "C:/Users/lordmaxwell/Desktop/iteration.html", Mplus.Automation = TRUE,
  dataOut = "exampleModel.dat",
  modelOut = "exampleModel.inp"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='exampleAntModel'>Model syntax for the example in the <code><a href="#topic+antcolony.lavaan">antcolony.lavaan</a></code> function.</h2><span id='topic+exampleAntModel'></span>

<h3>Description</h3>

<p>A character vector containing the model syntax used for the one factor, 56-item example in the <code><a href="#topic+antcolony.lavaan">antcolony.lavaan</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exampleAntModel
</code></pre>


<h3>Format</h3>

<p>A character vector.
</p>

<hr>
<h2 id='modelCheck-class'>An S4 class for the modelCheck object</h2><span id='topic+modelCheck-class'></span>

<h3>Description</h3>

<p>An S4 class for the modelCheck object
</p>


<h3>Value</h3>

<p>An S4 object of class 'ACO'.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model.output</code></dt><dd><p>A 'lavaan' object.</p>
</dd>
<dt><code>warnings</code></dt><dd><p>A 'character' vector of any warnings.</p>
</dd>
<dt><code>errors</code></dt><dd><p>A 'character' vector of any errors.</p>
</dd>
<dt><code>model.syntax</code></dt><dd><p>A 'character' vector of the modelCheck model syntax.</p>
</dd>
</dl>

<hr>
<h2 id='par.matches'>A series of internal functions used by the Tabu search.
Directly accessing these functions is not advised unless you know what you are doing.</h2><span id='topic+par.matches'></span>

<h3>Description</h3>

<p>A series of internal functions used by the Tabu search.
Directly accessing these functions is not advised unless you know what you are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par.matches(ptab, label, block = NULL)
</code></pre>

<hr>
<h2 id='plot+2CACO+2CANY-method'>Plot method for class 'ACO'</h2><span id='topic+plot+2CACO+2CANY-method'></span>

<h3>Description</h3>

<p>Plot method for class 'ACO'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ACO,ANY'
plot(x, y, type = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CACO+2B2CANY-method_+3A_x">x</code>, <code id="plot+2B2CACO+2B2CANY-method_+3A_y">y</code></td>
<td>
<p>An S4 object of class 'ACO'</p>
</td></tr>
<tr><td><code id="plot+2B2CACO+2B2CANY-method_+3A_type">type</code></td>
<td>
<p>A &lsquo;character' value specifying the plot type. One of '&rsquo;all''
(for all plots), ''pheromone'&lsquo;, '&rsquo;gamma'&lsquo;, '&rsquo;beta'&lsquo;, or '&rsquo;variance''.</p>
</td></tr>
<tr><td><code id="plot+2B2CACO+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='plot+2CSA+2CANY-method'>Plot method for class 'SA'</h2><span id='topic+plot+2CSA+2CANY-method'></span>

<h3>Description</h3>

<p>Plot method for class 'SA'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SA,ANY'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CSA+2B2CANY-method_+3A_x">x</code>, <code id="plot+2B2CSA+2B2CANY-method_+3A_y">y</code></td>
<td>
<p>An S4 object of class 'SA'.</p>
</td></tr>
<tr><td><code id="plot+2B2CSA+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='plot+2CTS+2CANY-method'>Plot method for class 'TS'</h2><span id='topic+plot+2CTS+2CANY-method'></span>

<h3>Description</h3>

<p>Plot method for class 'TS'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TS,ANY'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CTS+2B2CANY-method_+3A_x">x</code>, <code id="plot+2B2CTS+2B2CANY-method_+3A_y">y</code></td>
<td>
<p>An S4 object of class 'TS'.</p>
</td></tr>
<tr><td><code id="plot+2B2CTS+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='refit.model'>Given a fitted lavaan model and a search table, refits the model using the search
table as specifying what changes should be done (parameters fixed/freed).</h2><span id='topic+refit.model'></span>

<h3>Description</h3>

<p>This is not meant to be called explicitly as <a href="#topic+tabu.sem">tabu.sem</a> uses this
internally for model refitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refit.model(fitted.model, ptab)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="refit.model_+3A_fitted.model">fitted.model</code></td>
<td>
<p>fitted model of class lavaan</p>
</td></tr>
<tr><td><code id="refit.model_+3A_ptab">ptab</code></td>
<td>
<p>search table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>lavaan</code> if the new model fits, or an object of class <code>try-error</code> if the model update fails.
</p>


<h3>Author(s)</h3>

<p>Carl F. Falk
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1080/10705511.2017.1409074">doi:10.1080/10705511.2017.1409074</a>
</p>


<h3>See Also</h3>

<p>Other Tabu Search: 
<code><a href="#topic+add.param">add.param</a>()</code>,
<code><a href="#topic+search.prep">search.prep</a>()</code>
</p>

<hr>
<h2 id='SA-class'>An S4 class for the Simulated Annealing Algorithm</h2><span id='topic+SA-class'></span>

<h3>Description</h3>

<p>An S4 class for the Simulated Annealing Algorithm
</p>


<h3>Value</h3>

<p>An S4 object of class 'SA'.
</p>


<h3>Slots</h3>


<dl>
<dt><code>function_call</code></dt><dd><p>The original function call.</p>
</dd>
<dt><code>chains</code></dt><dd><p>The number of chains used.</p>
</dd>
<dt><code>chain_results</code></dt><dd><p>A 'matrix' (for multiple chains) or a 'list' (for a single chain) of the chain results.</p>
</dd>
<dt><code>all_fit</code></dt><dd><p>A summary 'vector' indicating the model fit results for
each iteration.</p>
</dd>
<dt><code>best_fit</code></dt><dd><p>The best model fit result using the selected 'fitStatistic'.</p>
</dd>
<dt><code>best_model</code></dt><dd><p>A 'modelCheck' object of the final solution.</p>
</dd>
<dt><code>best_syntax</code></dt><dd><p>A 'character' vector of the final solution model syntax.</p>
</dd>
<dt><code>runtime</code></dt><dd><p>A 'difftime' object of the total run time of the function.</p>
</dd>
</dl>

<hr>
<h2 id='search.prep'>Given a fitted lavaan model (e.g., CFA), prepares a table that contains
parameters that can be fixed/freed as part of a model specification search.</h2><span id='topic+search.prep'></span>

<h3>Description</h3>

<p>Given a fitted lavaan model (e.g., CFA), prepares a table that contains
parameters that can be fixed/freed as part of a model specification search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search.prep(fitted.model, loadings = TRUE, fcov = TRUE, errors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search.prep_+3A_fitted.model">fitted.model</code></td>
<td>
<p>- an object of class &quot;lavaan&quot; that contains the initially fitted model for the search</p>
</td></tr>
<tr><td><code id="search.prep_+3A_loadings">loadings</code></td>
<td>
<p>- a logical value that indicates whether cross-loadings will be part of the search</p>
</td></tr>
<tr><td><code id="search.prep_+3A_fcov">fcov</code></td>
<td>
<p>- a logical value indicating whether factor covariances will be part of the search</p>
</td></tr>
<tr><td><code id="search.prep_+3A_errors">errors</code></td>
<td>
<p>- a logical value indicating whether error covariances will be part of the search</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with lavaan-formatted parameter values.
</p>


<h3>Author(s)</h3>

<p>Carl F. Falk
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1080/10705511.2017.1409074">doi:10.1080/10705511.2017.1409074</a>
</p>


<h3>See Also</h3>

<p>Other Tabu Search: 
<code><a href="#topic+add.param">add.param</a>()</code>,
<code><a href="#topic+refit.model">refit.model</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load simulation data and select columns used in this example
data(simulated_test_data)
tabuData &lt;- simulated_test_data[, c(1:10)]

# specify an improper model (improper because data is unidimensional)
tabuModel &lt;- "
Ability =~ Item1 + Item2 + Item3 + Item4
FakeAbility =~ Item5 + Item6 + Item7 + Item8
Ability ~ Outcome
FakeAbility ~ 0*Outcome"

# run the initial misspecified model for Tabu

init.model &lt;- lavaan::lavaan(
  model = tabuModel, data = tabuData,
  auto.var = TRUE, auto.fix.first = FALSE, std.lv = TRUE, auto.cov.lv.x = TRUE
)

# Use search.prep to prepare for the Tabu search
ptab &lt;- search.prep(fitted.model = init.model, loadings = TRUE, fcov = TRUE, errors = FALSE)

# add an additional (mispecified) parameter
additional.param &lt;- "Item1 ~~ 0.5*Item3"
ptab &lt;- add.param(fitted.model = init.model, ptab = ptab, syntax = additional.param)

# Perform Tabu Search
trial &lt;- tabu.sem(init.model = init.model, ptab = ptab, obj = AIC, niter = 2, tabu.size = 5)

## End(Not run)
</code></pre>

<hr>
<h2 id='shortExampleAntModel'>Model syntax for the short example in the <code><a href="#topic+antcolony.lavaan">antcolony.lavaan</a></code> function.</h2><span id='topic+shortExampleAntModel'></span>

<h3>Description</h3>

<p>A character vector containing the model syntax used for the one factor, 15-item, example in the <code><a href="#topic+antcolony.lavaan">antcolony.lavaan</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shortExampleAntModel
</code></pre>


<h3>Format</h3>

<p>A character vector.
</p>

<hr>
<h2 id='ShortFormStartup'>Create Package Startup Message</h2><span id='topic+ShortFormStartup'></span>

<h3>Description</h3>

<p>Makes package startup message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ShortFormStartup()
</code></pre>


<h3>Details</h3>

<p>Idea taken from https://github.com/ntguardian/MCHT/blob/master/R/StartupMessage.R
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ShortForm:::ShortFormStartup()
</code></pre>

<hr>
<h2 id='show+2CACO-method'>Print method for class 'ACO'</h2><span id='topic+show+2CACO-method'></span>

<h3>Description</h3>

<p>Print method for class 'ACO'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ACO'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CACO-method_+3A_object">object</code></td>
<td>
<p>An S4 object of class 'ACO'</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CSA-method'>Print method for class 'SA'</h2><span id='topic+show+2CSA-method'></span>

<h3>Description</h3>

<p>Print method for class 'SA'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SA'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CSA-method_+3A_object">object</code></td>
<td>
<p>An S4 object of class 'SA'.</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CTS-method'>Print method for class 'TS'</h2><span id='topic+show+2CTS-method'></span>

<h3>Description</h3>

<p>Print method for class 'TS'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TS'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CTS-method_+3A_object">object</code></td>
<td>
<p>An S4 object of class 'TS'.</p>
</td></tr>
</table>

<hr>
<h2 id='simulated_test_data'>A simulated data set based on a standardized test.</h2><span id='topic+simulated_test_data'></span>

<h3>Description</h3>

<p>Simulated response patterns, abilities, and outcomes based on a uni-dimensional state-issued standardized test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulated_test_data
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 1000 rows and 58 columns.
</p>


<h3>Details</h3>

<p>@format A data frame of 1000 rows (observations) and 58 columns (variables):
</p>

<dl>
<dt>Outcome</dt><dd><p>a binary external criterion variable correlated with TrueAbility</p>
</dd>
<dt>TrueAbility</dt><dd><p>the simulated true ability parameter used to generate response patterns</p>
</dd>
<dt>Item1-Item56</dt><dd><p>binary responses to items generated using the TrueAbility parameters and simulated 3PL item parameters generated from the distribution of parameters estimated from a state-issued standardized test</p>
</dd>
</dl>


<hr>
<h2 id='simulatedAnnealing'>An adaptation of the simulated annealing algorithm for psychometric models.</h2><span id='topic+simulatedAnnealing'></span>

<h3>Description</h3>

<p>Simulated annealing mimics the physical process of annealing metals together. <a href="https://www.science.org/doi/10.1126/science.220.4598.671">Kirkpatrick et al. (1983)</a> introduces this analogy and demonstrates its use; the implementation here follows this demonstration closely, with some modifications to make it better suited for psychometric models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulatedAnnealing(
  initialModel,
  originalData,
  maxSteps,
  fitStatistic = "cfi",
  temperature = "linear",
  maximize = TRUE,
  Kirkpatrick = TRUE,
  randomNeighbor = TRUE,
  lavaan.model.specs = list(model.type = "cfa", auto.var = TRUE, estimator = "default",
    ordered = NULL, int.ov.free = TRUE, int.lv.free = FALSE, std.lv = TRUE,
    auto.fix.first = FALSE, auto.fix.single = TRUE, auto.cov.lv.x = TRUE, auto.th = TRUE,
    auto.delta = TRUE, auto.cov.y = TRUE),
  maxChanges = 5,
  restartCriteria = "consecutive",
  maximumConsecutive = 25,
  maxItems = NULL,
  items = NULL,
  bifactor = FALSE,
  setChains = 1,
  shortForm = T,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulatedAnnealing_+3A_initialmodel">initialModel</code></td>
<td>
<p>The initial model as a <code>character</code> vector with lavaan model.syntax.</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_originaldata">originalData</code></td>
<td>
<p>The original <code>data.frame</code> with variable names.</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_maxsteps">maxSteps</code></td>
<td>
<p>The number of iterations for which the algorithm will run.</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_fitstatistic">fitStatistic</code></td>
<td>
<p>Either a single model fit statistic produced by lavaan, or a user-defined fit statistic function.</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_temperature">temperature</code></td>
<td>
<p>Either an acceptable <code>character</code> value, or a user-defined temperature function. The acceptable values are &quot;linear&quot;, &quot;quadratic&quot;, or &quot;logistic&quot;.</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_maximize">maximize</code></td>
<td>
<p>Logical indicating if the goal is to maximize (<code>TRUE</code>) the fitStatistic for model selection.</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_kirkpatrick">Kirkpatrick</code></td>
<td>
<p>Either <code>TRUE</code> to use Kirkpatrick et al. (1983) acceptance probability, or a user-defined function for accepting proposed models.</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_randomneighbor">randomNeighbor</code></td>
<td>
<p>Either <code>TRUE</code> to use the included function for randomNeighbor selection, or a user-defined function for creating random models.</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_lavaan.model.specs">lavaan.model.specs</code></td>
<td>
<p>A <code>list</code> which contains the specifications for the
lavaan model. The default values are the defaults for lavaan to perform a
CFA. See <a href="lavaan.html#topic+lavaan">lavaan</a> for more details.</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_maxchanges">maxChanges</code></td>
<td>
<p>An <code>integer</code> value greater than 1 setting the maximum number of parameters to change within randomNeighbor. When creating a short form, should be no greater than the smallest reduction in items loading on one factor; e.g., when reducing a 2-factor scale from 10 items on each factor to 8 items on the first and 6 items on the second, maxChanges should be no greater than 2.</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_restartcriteria">restartCriteria</code></td>
<td>
<p>Either &quot;consecutive&quot; to restart after maxConsecutiveSelection times with the same model chosen in a row, or a user-defined function.</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_maximumconsecutive">maximumConsecutive</code></td>
<td>
<p>A positive <code>integer</code> value used with restartCriteria.</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_maxitems">maxItems</code></td>
<td>
<p>When creating a short form, a <code>vector</code> of the number of items per factor you want the short form to contain. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_items">items</code></td>
<td>
<p>A <code>character</code> vector of item names. Defaults to <code>NULL</code>. Ignored if <code>maxItems==FALSE</code>.</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_bifactor">bifactor</code></td>
<td>
<p>Logical. Indicates if the latent model is a bifactor model. If <code>TRUE</code>, assumes that the last latent variable in the provided model syntax is the bifactor (i.e., all of the retained items will be set to load on the last latent variable). Ignored if <code>maxItems==FALSE</code>.</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_setchains">setChains</code></td>
<td>
<p>Numeric. Sets the number of parallel chains to run. Default to <code>1</code>, which also sets the algorithm to run serially (e.g., on a single processor). Values greater than <code>1</code> result in the chains running on parallel processes using the <code>doSNOW</code> and <code>foreach</code> packages.</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_shortform">shortForm</code></td>
<td>
<p>Logical. Are you creating a short form (<code>TRUE</code>) or not (<code>FALSE</code>)? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to other functions. Not implemented for any of the included functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Outline of the Pieces of the Simulated Annealing Algorithm</strong>
</p>

<ul>
<li><p> initialModel &ndash; the initial, full form
</p>
</li>
<li><p> currentModel &ndash; the model of the current step
</p>
</li>
<li><p> maxSteps &ndash; the maximum number of steps (iterations)
</p>
</li>
<li><p> currentStep &ndash; the current step
</p>
</li>
<li><p> currentTemp &ndash; the current temperature. A function of the number of steps (such that temp = 0 at maxSteps), and values that control the shape of the overall temperature. A part of the function that determines the acceptance probability of newly &ndash; generated models
</p>
</li>
<li><p> randomNeighbor &ndash; a function that determines how the form is changed at each step. Should be able to change one or more parameters, and should have a way to control how many are changed.
</p>
</li>
<li><p> goal &ndash; a function that determines the &quot;goodness&quot; of the currentModel. Typically in SA goodness is defined as minimization! Sometimes called an energy function
</p>
</li>
<li><p> selectionFunction &ndash; a function that determines if a randomNeighbor change is accepted. Uses the goal function that determines the &quot;goodness&quot; of the currentModel and the &quot;goodness&quot; of the randomNeighbor, and the currentTemp to generate a probability of acceptance, then compares this probability to a Uniform(0,1) variable to determine if accepted or not. A standard version of this is:
<img src="../help/figures/SA-goal.jpg" alt="SA-goal.jpg" />
(Kirkpatrick et al., 1983)
</p>
</li>
<li><p> bestModel &ndash; the model with the best value of the goal function achieved so far
</p>
</li>
<li><p> bestGoal &ndash; the best value of the goal function achieved so far
</p>
</li>
<li><p> restartCriteria &ndash; if utilized, this would &quot;restart&quot; the SA process by changing currentModel to bestModel and continuing the process. Could be based on (1) the currentStep value, (2) the difference between goal(currentModel) and goal(bestModel), (3) randomness (i.e., could randomly restart, could randomly restart based on some values, etc), (4) other criteria.
</p>
</li></ul>



<h3>Value</h3>

<p>A named list: the 'bestModel' found, the 'bestFit', and 'allFit' values found by the algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(exampleAntModel)
data(simulated_test_data)
trial1 &lt;- simulatedAnnealing(
  initialModel = lavaan::cfa(
    model = exampleAntModel,
    data = simulated_test_data
  ),
  originalData = simulated_test_data, maxSteps = 3,
  fitStatistic = "rmsea", maximize = FALSE
)
summary(trial1) # shows the resulting model

trial2 &lt;- simulatedAnnealing(
  initialModel = exampleAntModel,
  originalData = simulated_test_data,
  maxSteps = 2, maxItems = 30, items = paste0("Item", 1:56)
)
summary(trial2) # shows the resulting model

## End(Not run)
</code></pre>

<hr>
<h2 id='summary+2CACO-method'>Summary method for class 'ACO'</h2><span id='topic+summary+2CACO-method'></span>

<h3>Description</h3>

<p>Summary method for class 'ACO'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ACO'
summary(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CACO-method_+3A_object">object</code></td>
<td>
<p>An S4 object of class 'ACO'</p>
</td></tr>
</table>

<hr>
<h2 id='summary+2CSA-method'>Summary method for class 'SA'</h2><span id='topic+summary+2CSA-method'></span>

<h3>Description</h3>

<p>Summary method for class 'SA'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SA'
summary(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CSA-method_+3A_object">object</code></td>
<td>
<p>An S4 object of class 'SA'.</p>
</td></tr>
</table>

<hr>
<h2 id='summary+2CTS-method'>Summary method for class 'TS'</h2><span id='topic+summary+2CTS-method'></span>

<h3>Description</h3>

<p>Summary method for class 'TS'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TS'
summary(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CTS-method_+3A_object">object</code></td>
<td>
<p>An S4 object of class 'TS'.</p>
</td></tr>
</table>

<hr>
<h2 id='tabu.sem'>Given a fitted lavaan model, a search table, and an objective criterion,
performs a Tabu model specification search. Currently only supports
neighbors that are 1 move away from the current model.</h2><span id='topic+tabu.sem'></span>

<h3>Description</h3>

<p>Given a fitted lavaan model, a search table, and an objective criterion,
performs a Tabu model specification search. Currently only supports
neighbors that are 1 move away from the current model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabu.sem(init.model, ptab, obj, niter = 30, tabu.size = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabu.sem_+3A_init.model">init.model</code></td>
<td>
<p>initial fitted model of class lavaan</p>
</td></tr>
<tr><td><code id="tabu.sem_+3A_ptab">ptab</code></td>
<td>
<p>search table (e.g., created by search.prep) that lists candidate
parameters that can be modified as part of the search and how the parameters
can be modified (fixed to what values)</p>
</td></tr>
<tr><td><code id="tabu.sem_+3A_obj">obj</code></td>
<td>
<p>objective function to be MINIMIZED. Any function that takes a
lavaan object as the sole argument and returns a numeric value can be used.</p>
</td></tr>
<tr><td><code id="tabu.sem_+3A_niter">niter</code></td>
<td>
<p>number of Tabu iterations to perform</p>
</td></tr>
<tr><td><code id="tabu.sem_+3A_tabu.size">tabu.size</code></td>
<td>
<p>size of Tabu list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three elements: best.obj, the numerical value of the best (minimal) objective function achieved; best.mod, the final lavaan model, and best.binvec, a data.frame of the lavaan-formatted parameter table for the final model.
</p>


<h3>Author(s)</h3>

<p>Carl F. Falk
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1080/10705511.2017.1409074">doi:10.1080/10705511.2017.1409074</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load simulation data and select columns used in this example
data(simulated_test_data)
tabuData &lt;- simulated_test_data[, c(1:10)]

# specify an improper model (improper because data is unidimensional)
tabuModel &lt;- "
Ability =~ Item1 + Item2 + Item3 + Item4
FakeAbility =~ Item5 + Item6 + Item7 + Item8
Ability ~ Outcome
FakeAbility ~ 0*Outcome"

# run the initial misspecified model for Tabu

init.model &lt;- lavaan::lavaan(
  model = tabuModel, data = tabuData,
  auto.var = TRUE, auto.fix.first = FALSE, std.lv = TRUE, auto.cov.lv.x = TRUE
)

# Use search.prep to prepare for the Tabu search
ptab &lt;- search.prep(fitted.model = init.model, loadings = TRUE, fcov = TRUE, errors = FALSE)

# Perform Tabu Search
trial &lt;- tabu.sem(init.model = init.model, ptab = ptab, obj = AIC, niter = 2, tabu.size = 5)
</code></pre>

<hr>
<h2 id='tabuShortForm'>Short Form Tabu Search</h2><span id='topic+tabuShortForm'></span>

<h3>Description</h3>

<p>Given an initial (full) lavaan model string, the original data, a criterion
function to minimize, and some additional specifications,
performs a Tabu model specification search. Currently only supports
neighbors that are 1 move away from the current model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabuShortForm(
  originalData,
  initialModel,
  numItems,
  criterion = function(x) {
     tryCatch(-lavaan::fitmeasures(object = x, fit.measures =
    "cfi"), error = function(e) Inf)
 },
  niter = 20,
  tabu.size = 5,
  lavaan.model.specs = list(int.ov.free = TRUE, int.lv.free = FALSE, std.lv = TRUE,
    auto.fix.first = FALSE, auto.fix.single = TRUE, auto.var = TRUE, auto.cov.lv.x =
    TRUE, auto.th = TRUE, auto.delta = TRUE, auto.cov.y = TRUE, ordered = NULL,
    model.type = "cfa", estimator = "default"),
  bifactor = FALSE,
  verbose = FALSE,
  parallel = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabuShortForm_+3A_originaldata">originalData</code></td>
<td>
<p>The original data frame with variable names.</p>
</td></tr>
<tr><td><code id="tabuShortForm_+3A_initialmodel">initialModel</code></td>
<td>
<p>The initial model (typically the full form) as a character vector with lavaan model.syntax.</p>
</td></tr>
<tr><td><code id="tabuShortForm_+3A_numitems">numItems</code></td>
<td>
<p>A numeric vector indicating the number of items to retain for each factor.</p>
</td></tr>
<tr><td><code id="tabuShortForm_+3A_criterion">criterion</code></td>
<td>
<p>A function calculating the objective criterion to minimize. Default is to use the built-in 'rmsea' value from 'lavaan::fitmeasures()'.</p>
</td></tr>
<tr><td><code id="tabuShortForm_+3A_niter">niter</code></td>
<td>
<p>A numeric value indicating the number of iterations (model specification selections)
to perform. Default is 50.</p>
</td></tr>
<tr><td><code id="tabuShortForm_+3A_tabu.size">tabu.size</code></td>
<td>
<p>A numeric value indicating the size of Tabu list. Default is 5.</p>
</td></tr>
<tr><td><code id="tabuShortForm_+3A_lavaan.model.specs">lavaan.model.specs</code></td>
<td>
<p>A list which contains the specifications for the
lavaan model. The default values are the defaults for lavaan to perform a
CFA. See <a href="lavaan.html#topic+lavaan">lavaan</a> for more details.</p>
</td></tr>
<tr><td><code id="tabuShortForm_+3A_bifactor">bifactor</code></td>
<td>
<p>Logical. Indicates if the latent model is a bifactor model. If 'TRUE', assumes that the last latent variable in the provided model syntax is the bifactor (i.e., all of the retained items will be set to load on the last latent variable).</p>
</td></tr>
<tr><td><code id="tabuShortForm_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If 'TRUE', prints out the initial short form and the selected short form at the end of each iteration.</p>
</td></tr>
<tr><td><code id="tabuShortForm_+3A_parallel">parallel</code></td>
<td>
<p>An option for using parallel processing. If <code>TRUE</code>, the 
function will utilize all available cores. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the best value of the objective function ('best.obj') and the best lavaan model object ('best.mod').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>shortAntModel &lt;- "
Ability =~ Item1 + Item2 + Item3 + Item4 + Item5 + Item6 + Item7 + Item8
Ability ~ Outcome
"

data(simulated_test_data)
tabuResult &lt;- tabuShortForm(
  initialModel = shortAntModel,
  originalData = simulated_test_data, numItems = 7,
  niter = 1, tabu.size = 3, parallel = FALSE
)
summary(tabuResult) # shows the resulting model
## Not run: 
# create simulation data from the `psych` package
# four factors, 12 items each, 48 total items
# factor loading matrix - not quite simple structure
fxMatrix &lt;-
  matrix(
    data = c(
      rep(x = c(.9, .7, .5, .3), times = 3),
      rep(0.2, times = 3 * 4 * 3), # first factor loadings

      rep(0.2, times = 3 * 4),
      rep(x = c(.9, .7, .5, .3), times = 3),
      rep(0.2, times = 3 * 4 * 2), # second factor loadings

      rep(0.2, times = 3 * 4 * 2),
      rep(x = c(.9, .7, .5, .3), times = 3),
      rep(0.2, times = 3 * 4), # third factor loadings

      rep(0.2, times = 3 * 4 * 3),
      rep(x = c(.9, .7, .5, .3), times = 3) # fourth factor loadings
    ),
    ncol = 4
  )
# factor correlation matrix - all factors uncorrelated
PhiMatrix &lt;-
  matrix(data = c(
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
  ), ncol = 4)
tabuData &lt;-
  psych::sim(
    fx = fxMatrix,
    Phi = PhiMatrix,
    n = 1000,
    raw = TRUE
  )$observed # observed is the simulated observed data

# NOTE: you must specify the model such that each factor is on a single line!
# otherwise, the algorithm will not work correctly!
tabuModel &lt;- "
Trait1 =~ Item1 + Item2 + Item3 + Item4 + Item5 + Item6 +
Item7 + Item8 + Item9 + Item10 + Item11 + Item12
Trait2 =~ Item13 + Item14 + Item15 + Item16 + Item17 +
Item18 + Item19 + Item20 + Item21 + Item22 + Item23 + Item24
Trait3 =~ Item25 + Item26 + Item27 + Item28 + Item29 + Item30 +
Item31 + Item32 + Item33 + Item34 + Item35 + Item36
Trait4 =~ Item37 + Item38 + Item39 + Item40 + Item41 +
Item42 + Item43 + Item44 + Item45 + Item46 + Item47 + Item48
"

colnames(tabuData) &lt;- paste0("Item", 1:48)
# specify the criterion function that the Tabu Search minimizes
# wrap this in a tryCatch in case a model does not converge!
# specify an appropriate error value: if minimizing, error value must be large
tabuCriterion &lt;- function(x) {
  tryCatch(lavaan::fitmeasures(object = x, fit.measures = "chisq"),
    error = function(e) Inf
  )
}

# use the tabuShortForm function
# reduce form to the best 12 items
tabuShort &lt;- tabuShortForm(
  initialModel = tabuModel, originalData = tabuData,
  numItems = c(3, 3, 3, 3),
  criterion = tabuCriterion,
  niter = 20, tabu.size = 10
)

## End(Not run)

</code></pre>

<hr>
<h2 id='TS-class'>An S4 class for the Tabu Search Algorithm</h2><span id='topic+TS-class'></span>

<h3>Description</h3>

<p>An S4 class for the Tabu Search Algorithm
</p>


<h3>Value</h3>

<p>An S4 object of class 'TS'.
</p>


<h3>Slots</h3>


<dl>
<dt><code>function_call</code></dt><dd><p>The original function call.</p>
</dd>
<dt><code>all_fit</code></dt><dd><p>A summary 'vector' indicating the model fit results for
each iteration.</p>
</dd>
<dt><code>best_fit</code></dt><dd><p>The best model fit result using the selected 'fitStatistic'. A numeric value or vector, possibly named.</p>
</dd>
<dt><code>best_model</code></dt><dd><p>A 'lavaan' object of the final solution.</p>
</dd>
<dt><code>best_syntax</code></dt><dd><p>A 'character' vector of the final solution model syntax.</p>
</dd>
<dt><code>runtime</code></dt><dd><p>A 'difftime' object of the total run time of the function.</p>
</dd>
<dt><code>final_tabu_list</code></dt><dd><p>The final list of Tabu models. Each element of the list is a 'lavaan' object.</p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
