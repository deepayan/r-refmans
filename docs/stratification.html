<!DOCTYPE html><html lang="en"><head><title>Help for package stratification</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stratification}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#stratification-package'><p> Collection of Functions for Univariate Stratification of Survey Populations</p></a></li>
<li><a href='#CochranHorganData'><p> Populations Analyzed in Gunning and Horgan (2004) and Cochran (1961)</p></a></li>
<li><a href='#MRTS'><p> Simulated Data from the Monthly Retail Trade Survey (MRTS) of Statistics Canada</p></a></li>
<li><a href='#SHS'><p> Data from the 2001 Survey of Household Spending (SHS), Statistics Canada</p></a></li>
<li><a href='#strata.bh'><p> Stratification of a Population Given a Set of Boundaries</p></a></li>
<li><a href='#strata.LH'><p> Generalized Lavallee-Hidiroglou Method of Strata Construction</p></a></li>
<li><a href='#strata.rule'><p> Non-Iterative Methods of Strata Construction</p></a></li>
<li><a href='#strata.tool'><p> Functions to Visualize Stratified Designs</p></a></li>
<li><a href='#Sweden'><p> The MU284 Population of Sweden Municipalities from Sarndal et al. (1992)</p></a></li>
<li><a href='#var.strata'><p> Anticipated Variances and RRMSE from a Stratified Design for a Survey Variable Y</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Univariate Stratification of Survey Populations</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2-7</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Louis-Paul Rivest [aut, cre],
  Sophie Baillargeon [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Louis-Paul Rivest &lt;Louis-Paul.Rivest@mat.ulaval.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Univariate stratification of survey populations with a generalization of the 
  Lavallee-Hidiroglou method of stratum construction. The generalized method takes into account 
  a discrepancy between the stratification variable and the survey variable. The determination 
  of the optimal boundaries also incorporate, if desired, an anticipated non-response, a take-all 
  stratum for large units, a take-none stratum for small units, and a certainty stratum to ensure 
  that some specific units are in the sample. The well known cumulative root frequency rule of 
  Dalenius and Hodges and the geometric rule of Gunning and Horgan are also implemented. </td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, stats, utils</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-06 17:28:16 UTC; Sophie</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-06 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='stratification-package'> Collection of Functions for Univariate Stratification of Survey Populations </h2><span id='topic+stratification-package'></span><span id='topic+stratification'></span>

<h3>Description</h3>

<p>This package contains various functions for univariate stratification of survey populations. The well known cumulative root frequency rule by Dalenius and Hodges (1959) and the geometric rule by Gunning and Horgan (2004) are implemented. However, the main function implements a generalized Lavallee-Hidiroglou (1988) method of strata construction. It can be used with Sethi's (1963) or Kozak's (2004) algorithm. The generalized method takes into account a discrepancy between the stratification variable <code class="reqn">X</code> and the survey variable <code class="reqn">Y</code>. The method can consider a loglinear model with mortality between the variables (Baillargeon, Rivest and Ferland, 2007). When Kozak's algorithm is used, two additional models are available: a heteroscedastic linear model and a random replacement model as in Rivest (2002). The optimal boundaries determination also incorporates, if desired, an anticipated non-response, a take-all stratum for the large units and a take-none stratum for the small units. Moreover, units can be forced to be part of the sample by specifying a certainty stratum. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> stratification</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.2-7</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-04-06</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><b>OVERWIEW OF THE FUNCTIONS</b><br />
</p>
<p>To determine the stratum sample sizes given a set of stratum boundaries: <code><a href="#topic+strata.bh">strata.bh</a></code> 
</p>
<p>To determine the stratum boundaries first and, in a second step, the stratum sample sizes:<br /> 
<code><a href="#topic+strata.cumrootf">strata.cumrootf</a></code>: cumulative root frequency method by Dalenius and Hodges (1959)<br />
<code><a href="#topic+strata.geo">strata.geo</a></code>: geometric method by Gunning and Horgan (2004)
</p>
<p>To determine the optimal stratum boundaries and sample sizes in a single step:<br />
<code><a href="#topic+strata.LH">strata.LH</a></code>: generalized Lavallee-Hidiroglou method with Sethi's (1963) or Kozak's (2004) algorithm<br />
</p>
<p>All these functions create an object of class &quot;strata&quot;, which can be visualized with the S3 methods <code><a href="#topic+print.strata">print.strata</a></code> and <code><a href="#topic+plot.strata">plot.strata</a></code>. One can also apply, with the function <code><a href="#topic+var.strata">var.strata</a></code>, a stratified design to a survey variable <code class="reqn">Y</code> different from the one used for the construction of the stratified design.<br />
</p>
<p><b>INFORMATION RELATIVE TO MANY FUNCTIONS</b><br />
</p>
<p>The functions <code><a href="#topic+strata.bh">strata.bh</a></code>, <code><a href="#topic+strata.cumrootf">strata.cumrootf</a></code>, <code><a href="#topic+strata.geo">strata.geo</a></code> and <code><a href="#topic+strata.LH">strata.LH</a></code> need to be given:<br />
<code>x</code>, the values of the stratification variable <code class="reqn">X</code>,<br />
<code>Ls</code>, the desired number of sampled strata,<br />
<code>alloc</code>, an allocation rule, and<br />
a target sample size <code>n</code> or a target level of precision <code>CV</code> for the survey estimator.<br /> 
However, for Sethi's (1963) algorithm, only a target <code>CV</code> can be given. To reach a target <code>n</code> using the generalized Lavallee-Hidiroglou method, Kozak's (2004) algorithm has to be used with the <code><a href="#topic+strata.LH">strata.LH</a></code> function.<br />   
</p>
<p>TYPE OF STRATUM<br />
In this package, four types of stratum exist: take-some, take-none, take-all and certainty. A take-some stratum is a stratum in which some units are sampled. A take-none stratum is a stratum for the smallest units in which no units are sampled. Its purpose is to ignore very small units. On the other hand, a take-all stratum is a stratum for the largest units in which every units are sampled. It allows to insure that the biggest units are in the sample. The following paragraph explains what the special stratum type called &ldquo;certainty&rdquo; is.<br />  
</p>
<p>DEFINITION OF THE CERTAINTY STRATUM<br />
It is possible to insure that some specific units are included in the sample with the argument <code>certain</code>. This argument is a vector containing the positions in the vector <code>x</code> of the units to be included with certainty in the sample. We say that these units form the certainty stratum. They are excluded from the population prior to the determination of the stratum boundaries, but they are accounted for in the calculation of the anticipated mean, the RRMSE, the total sample size and the optimization criteria. Essentially, these units form their own separate take-all stratum that is not subject to stratification. They do not have to be consecutive units according to the stratification variable, therefore their variance is meaningless. Non-response is not possible in the certainty stratum. The functions return a value named <code>certain.info</code> containing the number of units in the certainty stratum and their anticipated mean.<br />   
</p>
<p>NUMBER OF STRATA<br />
The <code>Ls</code> argument represents to the number of sampled strata. The term &ldquo;sampled strata&rdquo; refers to take-some and take-all strata only. Therefore, take-none and certain strata are not counted in <code>Ls</code>. If the stratified design does not have a take-none stratum then <code>Ls</code>=<code class="reqn">L</code> is the total number of strata, otherwise <code>Ls</code>=<code class="reqn">L-1</code>. In the total number of strata <code class="reqn">L</code>, the certainty stratum, if any, is not counted since we do not need to find its boundaries.<br />
</p>
<p>STRATUM NUMBERING<br />
Throughout the package, strata number 1 contains the smallest units and strata number <code class="reqn">L</code> the biggest ones. So every vector of boundaries contains numbers in ascending order. The function <code><a href="#topic+strata.bh">strata.bh</a></code> must be given boundaries <code>bh</code> fulfilling this condition. This remark also applies to the argument <code>initbh</code> of <code><a href="#topic+strata.LH">strata.LH</a></code> used to give initial boundaries for the optimization algorithm. If a take-none stratum is requested, it is always the first one. On the other hand, if a take-none stratum is requested, it is always the last one. <br />
</p>
<p>DEFINITION OF STRATUM BOUNDARIES<br />
Let's note <code class="reqn">b_0, b_1,\ldots, b_L</code> the stratum boundaries. Stratum <code class="reqn">h</code> contains all the
units with an <code class="reqn">X</code>-value in the interval <code class="reqn">[b_{h-1},b_h)</code> for <code class="reqn">h=1,\ldots,L</code> such that <code class="reqn">b_0=min(X)</code> and <code class="reqn">b_L=max(X)+1</code>, where
<code class="reqn">min(X)</code> and <code class="reqn">max(X)</code> are respectively the minimum and the maximum values of the stratification variable. The argument <code>bh</code> of <code>strata.bh</code>, the argument <code>initbh</code> of <code>strata.LH</code> and the output value <code>bh</code> of any function of the package <span class="pkg">stratification</span> with the prefix &quot;strata&quot; are length <code class="reqn">L-1</code> vectors of the boundaries <code class="reqn">b_1, b_2,\ldots, b_{L-1}</code>.<br />
</p>
<p>DETAILS ABOUT THE TAKE-NONE STRATUM<br />
A non empty take-none stratum induces a bias in the estimator of the mean of <code class="reqn">Y</code>, and the precision is measured by the relative root mean squared error (RRMSE), not by the coefficient of variation (CV). Regardless, in the functions the argument given to specify a target precision for the survey estimator is always named <code>CV</code>. However, in the output, the anticipated level of precision is named RRMSE for the functions accepting a <code>takenone</code> argument (<code><a href="#topic+strata.bh">strata.bh</a></code> and <code><a href="#topic+strata.LH">strata.LH</a></code>), and it is named CV for the other functions (<code><a href="#topic+strata.cumrootf">strata.cumrootf</a></code> and <code><a href="#topic+strata.geo">strata.geo</a></code>).
</p>
<p>When a <code>takenone</code> stratum is requested, one can specify a <code>bias.penalty</code> argument. We define the mean squared error for the estimator of the mean of <code class="reqn">Y</code> by <code class="reqn">MSE = (bias.penalty \times bias)^2 + variance</code>. It is sometimes possible to estimate the bias using the sum of the <code class="reqn">Y</code> values in the take-none stratum from administrative data. In this situation, it might be appropriate to set <code>bias.penalty</code> to a value lower than 1. This will typically enlarge the take-none stratum. The value given to <code>bias.penalty</code> depends on the confidence level we have in the bias estimate. By default, it is assumed that no bias estimate is available and the whole bias contributes to the MSE (<code>bias.penalty</code>=1).<br />
</p>
<p>SPECIFICATION OF THE ALLOCATION RULE<br />
The <code>alloc</code> argument must be a list containing the numeric objects <code>q1</code>, <code>q2</code> and <code>q3</code> which specify the allocation rule according to the general allocation scheme presented in Hidiroglou and Srinath (1993) 
</p>
<p style="text-align: center;"><code class="reqn">a_h = \frac{\gamma_h}{\sum_{\mbox{take-some}} \gamma_h} \qquad \mbox{where} \qquad     
\gamma_h=N_h^{2q_1}\bar{Y}_h^{2q_2}S_{yh}^{2q_3}.</code>
</p>

<p>Stratum sample sizes are calculated as :
</p>
<p style="text-align: center;"><code class="reqn">
{n_h}_{\mbox{nonint}} = \left\{ \begin{array}{ll}
0 &amp; \mbox{for take-none strata}\\
n \times a_h &amp; \mbox{for take-some strata}\\
N_h &amp; \mbox{for take-all strata}\end{array} \right.
</code>
</p>

<p>A proportional allocation is obtained when <code>q1</code>=0.5 and <code>q2</code>=<code>q3</code>=0,<br />
a power allocation is obtained when <code>q1</code>=<code>q2</code>=<code class="reqn">p/2</code> and <code>q3</code>=0, and<br />
a Neyman allocation (the default) is obtained when <code>q1</code>=<code>q3</code>=0.5 and <code>q2</code>=0.<br />
</p>
<p>ROUNDING of the stratum sample sizes <br />
Applying the allocation rule above gives real (non-integer) values for the sample sizes. These are named <code>nhnonint</code> in the package. The <code>nhnonint</code> values have to be rounded to get the integer sample sizes, named <code>nh</code> in the package. Here is how the rounding is done. If a target <code>CV</code> is requested, the values are simply rounded to the largest integer. However, if a target <code>n</code> is requested, the rounding is a little more complicated because the <code>nh</code> should sum to the target <code>n</code> and we do not want positive nh inferior to 1 to be rounded to zero. Therefore, we first round to 1 the positive nh inferior to 1. Then we calculate how many values (say <code>nup</code>) must be rounded to the largest integer and how many must be rounded to the smallest integer in order to fulfill the condition <code>sum(nh)=n</code>. We choose the <code>nup</code> values with the largest decimal part for the ceiling rounding, the other <code>nh</code> are rounded down.<br />    
</p>
<p>ADJUSTMENT FOR A TAKE-ALL STRATUM<br />
If, after applying the allocation rule, the stratified design contains at least one take-some stratum with <code class="reqn">{n_h}_{\mbox{nonint}} &gt; N_h</code>, the allocation is done again setting the take-some stratum with the largest units as a take-all stratum. This is done until <code class="reqn">{n_h}_{\mbox{nonint}} \leq N_h</code> for all the take-some strata or until there is only one take-some stratum left. This adjustment is done automatically throughout the package because the target n or CV might not be reached if one omits to do it. Only the function <code>strata.bh</code> allows not to do it (argument <code>takeall.adjust</code>).<br />
</p>
<p>Note: In special circumstances, the algorithm might result in more than one take-all stratum. If the non-response rate does not vary among the take-all strata, we can see them as forming one big take-all stratum. Otherwise, their boundaries influence the value of the optimization criteria (<code class="reqn">n</code> or <code class="reqn">CV</code>). So in the case of a varying non-response rate among the take-all strata, we cannot see them as forming one big take-all stratum.<br />
</p>
<p>SPECIFICATION OF A MODEL BETWEEN <code class="reqn">Y</code> AND <code class="reqn">X</code><br />
Every function can take into account a discrepancy between the stratification variable <code class="reqn">X</code> and the survey variable <code class="reqn">Y</code>. The functions <code><a href="#topic+strata.bh">strata.bh</a></code>, <code><a href="#topic+strata.cumrootf">strata.cumrootf</a></code> and <code><a href="#topic+strata.geo">strata.geo</a></code> perform allocation on the basis of anticipated moments whereas the <code><a href="#topic+strata.LH">strata.LH</a></code> function goes further; it determines the optimal boundaries considering the anticipated moments. The following models for the relationship between <code class="reqn">Y</code> and <code class="reqn">X</code> can be specified through the <code>model</code> and <code>model.control</code> arguments:<br />
</p>
<p><b>- loglinear model with mortality</b> (<code>model="loglinear"</code>):
</p>
<p style="text-align: center;"><code class="reqn">
 Y = \left\{ \begin{array}{ll}
\exp(\alpha + \mbox{\code{beta}} \ \log(X) + \mbox{\code{epsilon}}) &amp; \mbox{with probability } p_h\\
0 &amp; \mbox{with probability } 1-p_h \end{array} \right.
</code>
</p>

<p>where <code class="reqn">\mbox{\code{epsilon}} \sim N(0,\mbox{\code{sig2}})</code> is independent of <code class="reqn">X</code>. The parameter <code class="reqn">p_h</code>
is specified through <code>ph</code>, <code>ptakenone</code> and <code>pcertain</code> (elements of <code>model.control</code>). Note: The <code class="reqn">\alpha</code> parameter does not have to be specified because <code class="reqn">exp(\alpha)</code> is a multiplicative factor that has no impact on the outcome.<br />
</p>
<p><b>- heteroscedastic linear model</b> (<code>model="linear"</code>):
</p>
<p style="text-align: center;"><code class="reqn">
Y = \mbox{\code{beta}} X + \mbox{\code{epsilon}}
</code>
</p>

<p>where <code class="reqn">\mbox{\code{epsilon}} \sim N(0,\mbox{\code{sig2}} \ X^{\mbox{\code{gamma}}})</code>.<br />
</p>
<p><b>- random replacement model</b> (<code>model="random"</code>):
</p>
<p style="text-align: center;"><code class="reqn">
 Y = \left\{ \begin{array}{ll}
X &amp; \mbox{with probability } 1-\mbox{\code{epsilon}} \\
Xnew &amp; \mbox{with probability } \mbox{\code{epsilon}} \end{array} \right.
</code>
</p>

<p>where <code class="reqn">Xnew</code> is a random variable independent of <code class="reqn">X</code> having the same distribution than <code class="reqn">X</code>.<br />
</p>
<p>The <code>model.control</code> argument is a list that can supply any of the following model parameter:
</p>

<dl>
<dt><code>beta</code></dt><dd><p> A numeric: the slope of the &quot;loglinear&quot; or &quot;linear&quot; model. The default is 1. </p>
</dd>
<dt><code>sig2</code></dt><dd><p> A numeric: the variance parameter of the &quot;loglinear&quot; or &quot;linear&quot; model. The default is 0. </p>
</dd>
<dt><code>ph</code></dt><dd><p> A vector giving the survival rate in each of the <code>Ls</code> sampled strata for the &quot;loglinear&quot; model. A single number can be given if the rate doesn't vary among strata. The default is 1 in each stratum. </p>
</dd>
<dt><code>ptakenone</code></dt><dd><p> A numeric: the survival rate in the take-none stratum, if a take-none stratum is added to the stratified design. The default is 1. </p>
</dd>
<dt><code>pcertain</code></dt><dd><p> A numeric: the survival rate in the certainty stratum, if a certainty stratum is added to the stratified design. The default is 1. </p>
</dd>
<dt><code>gamma</code></dt><dd><p> A numeric: the exponent of <code class="reqn">X</code> in the residual variance of the &quot;linear&quot; model. The default is 0. </p>
</dd>
<dt><code>epsilon</code></dt><dd><p> A numeric: the probability that the <code class="reqn">Y</code>-value for a unit is equal to the <code class="reqn">X</code>-value for a randomly selected unit in the population. It concerns the &quot;random&quot; model only. The default is 0.<br /></p>
</dd>
</dl>

<p>Note: The default values of the parameters simplify any model to <code class="reqn">Y=X</code>. Therefore, the default is always to consider that there is no discrepancy between the stratification and the survey variables. The <code>model</code> argument even has the default value <code>"none"</code>, which also means <code class="reqn">Y=X</code>.
</p>


<h3>Author(s)</h3>

<p> Sophie Baillargeon <a href="mailto:Sophie.Baillargeon@mat.ulaval.ca">Sophie.Baillargeon@mat.ulaval.ca</a> and<br />
Louis-Paul Rivest <a href="mailto:Louis-Paul.Rivest@mat.ulaval.ca">Louis-Paul.Rivest@mat.ulaval.ca</a> </p>


<h3>References</h3>

<p>Baillargeon, S., Rivest, L.-P., Ferland, M. (2007). Stratification en enquetes entreprises : Une revue et quelques avancees. <em>Proceedings of the Survey Methods Section, 2007 SSC Annual Meeting</em>.
</p>
<p>Baillargeon, S. and Rivest, L.-P. (2009). A general algorithm for univariate stratification. <em>International Stratification Review</em>, <b>77</b>(3), 331-344.
</p>
<p>Baillargeon, S. and  Rivest L.-P. (2011). The construction of stratified designs in R with the package stratification. <em>Survey Methodology</em>, <b>37</b>(1), 53-65.
</p>
<p>Dalenius, T. and Hodges, J.L., Jr. (1959). Minimum variance stratification. <em>Journal of the American Statistical Association</em>, <b>54</b>, 88-101.
</p>
<p>Gunning, P. and Horgan, J.M. (2004). A new algorithm for the construction of stratum boundaries in skewed populations. <em>Survey Methodology</em>, <b>30</b>(2), 159-166.
</p>
<p>Hidiroglou, M.A. and Srinath, K.P. (1993). Problems associated with designing subannual business surveys. <em>Journal of Business &amp; Economic Statistics</em>, <b>11</b>, 397-405.
</p>
<p>Kozak, M. (2004). Optimal stratification using random search method in agricultural surveys. <em>Statistics in Transition</em>, <b>6</b>(5), 797-806.
</p>
<p>Lavallee, P. and Hidiroglou, M.A. (1988). On the stratification of skewed populations. <em>Survey Methodology</em>, <b>14</b>, 33-43.
</p>
<p>Rivest, L.-P. (2002). A generalization of the Lavallee and Hidiroglou algorithm for stratification in business surveys. <em>Survey Methodology</em>, <b>28</b>(2), 191-198.
</p>
<p>Sethi, V. K. (1963). A note on optimum stratification of populations for estimating the population means. <em>The Australian Journal of Statistics</em>, <b>5</b>, 20-33.
</p>

<hr>
<h2 id='CochranHorganData'> Populations Analyzed in Gunning and Horgan (2004) and Cochran (1961) </h2><span id='topic+Debtors'></span><span id='topic+UScities'></span><span id='topic+UScolleges'></span><span id='topic+USbanks'></span>

<h3>Description</h3>

<p>The first population <code>Debtors</code> is an accounting population of debtors in an Irish firm, detailed in Horgan (2003). The other populations are three of the skewed populations in Cochran (1961). These are:<br />
<code>UScities</code>: the population in thousands of US cities in 1940;<br />
<code>UScolleges</code>: the number of students in four-year US colleges in 1952-1953;<br />
<code>USbanks</code>: the resources in millions of dollars of large commercial US banks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Debtors
UScities
UScolleges
USbanks
</code></pre>


<h3>Format</h3>

<p>The formats of these data sets are, respectively:<br />
num [1:3369] 40 40 40 40 40 40 40 40 40 40 ...<br />
num [1:1038] 10 10 10 10 10 10 10 10 10 10 ...<br />
num [1:677] 200 201 202 202 207 210 211 213 215 217 ...<br />
num [1:357] 70 71 72 72 72 73 73 73 73 73 ...<br />
</p>


<h3>Source</h3>

<p>Jane M. Horgan
</p>


<h3>References</h3>

<p>Cochran, W.G. (1961). Comparison of methods for determining stratum boundaries. <em>Bulletin of the International Statistical Institute</em>, <b>32</b>(2), 345-358.
</p>
<p>Gunning, P. and Horgan, J.M. (2004). A new algorithm for the construction of stratum boundaries in skewed populations. <em>Survey Methodology</em>, <b>30</b>(2), 159-166.
</p>
<p>Horgan, J.M. (2003). A list sequential sampling scheme with applications in financial auditing. <em>IMA Journal of Management Mathematics</em>, <b>14</b>, 1-18.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Reproduction of the results in Table 4 and Table 7 part 3 (case L=5) of  
### Gunning and Horgan (2004). The differences in the nh come from different  
### rounding. The more important differences observed for the cumulative  
### root frequency method are due to the use of different numbers of classes.
strata.geo(x=Debtors, n=100, Ls=5, alloc=c(0.5,0,0.5))
strata.cumrootf(x=Debtors, n=100, Ls=5, alloc=c(0.5,0,0.5), nclass=40)
strata.LH(x=Debtors, CV=0.0360, Ls=5, alloc=c(0.5,0,0.5), takeall=1, algo="Sethi")

strata.geo(x=UScities, n=100, Ls=5, alloc=c(0.5,0,0.5))
strata.cumrootf(x=UScities, n=100, Ls=5, alloc=c(0.5,0,0.5), nclass=40)
strata.LH(x=UScities, CV=0.0144, Ls=5, alloc=c(0.5,0,0.5), takeall=1, algo="Sethi")

strata.geo(x=UScolleges, n=100, Ls=5, alloc=c(0.5,0,0.5))
strata.cumrootf(x=UScolleges, n=100, Ls=5, alloc=c(0.5,0,0.5), nclass=40)
strata.LH(x=UScolleges, CV=0.0184, Ls=5, alloc=c(0.5,0,0.5), takeall=1, algo="Sethi")

strata.geo(x=USbanks, n=100, Ls=5, alloc=c(0.5,0,0.5))
strata.cumrootf(x=USbanks, n=100, Ls=5, alloc=c(0.5,0,0.5), nclass=40)
strata.LH(x=USbanks, CV=0.0110, Ls=5, alloc=c(0.5,0,0.5), takeall=1, algo="Sethi")
</code></pre>

<hr>
<h2 id='MRTS'> Simulated Data from the Monthly Retail Trade Survey (MRTS) of Statistics Canada </h2><span id='topic+MRTS'></span>

<h3>Description</h3>

<p>This data set is a vector containing the simulated values of a realistic stratification variable: the size measure used for Canadian retailers in the Monthly Retail Trade Survey (MRTS) carried out by Statistics Canada. This size measure is created using a combination of independent survey data and three administrative variables from the corporation tax return. The MRTS aims at estimating sales from retailers, which are a key monthly indicator of consumer purchasing patterns in Canada.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MRTS</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:2000] 141 209 238 257 261 ...
</p>


<h3>Source</h3>

<p>The data set has been simulated with the command:<br />
<code>exp(rst(n=2000, location=9.7093354, scale=0.7885551,</code><br />
<code>shape=-0.6384867, df=5.6243544))</code>.<br />
The function <code>rst</code> comes from the package <span class="pkg">sn</span>. It generates random numbers for the skew-t distribution. The parameters of the distribution have been estimated with the assistance of Michel Ferland from Statistics Canada to be representative of the measure of size used in the MRTS.
</p>


<h3>References</h3>

<p>Baillargeon, S., Rivest, L.-P., Ferland, M. (2007). Stratification en enquetes entreprises : Une revue et quelques avancees. <em>Proceedings of the Survey Methods Section, 2007 SSC Annual Meeting</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Production of results similar to those in Table 1 of Baillargeon, Rivest
# and Ferland (2007). The results are not the same because calculations in
# the paper were conducted on real data whereas, for confidentiality reason, 
# the MRTS data included in the package is simulated.
geo &lt;- strata.geo(x=MRTS, CV=0.01, Ls=4, alloc=c(0.5,0,0.5))
geo
aRRMSE.geo &lt;- var.strata(geo, model="loglinear",
              model.control=list(beta=0.9, sig2=0.015, ph=c(0.8,0.9,0.95,1)))
aRRMSE.geo$RRMSE
plot(geo, logscale=TRUE)
# The geometric method does not perform well because of some small units

cumrootf &lt;- strata.cumrootf(x=MRTS, nclass=500, CV=0.01, Ls=4, alloc=c(0.5,0,0.5))
cumrootf
aRRMSE.cum &lt;- var.strata(cumrootf, rh=c(0.85,0.9,0.9,1), model="loglinear",
              model.control=list(beta=0.9, sig2=0.015, ph=c(0.8,0.9,0.95,1)))
aRRMSE.cum$RRMSE

LH &lt;- strata.LH(x=MRTS, CV=0.01, Ls=4, alloc=c(0.5,0,0.5), takeall=1, algo="Sethi")
LH
aRRMSE.LH &lt;- var.strata(LH, rh=c(0.85,0.9,0.9,1), model="loglinear",
             model.control=list(beta=0.9, sig2=0.015, ph=c(0.8,0.9,0.95,1)))
aRRMSE.LH$RRMSE

LH.full &lt;- strata.LH(x=MRTS, CV=0.01, Ls=4, alloc=c(0.5,0,0.5), takeall=1,
           algo="Sethi", rh=c(0.85,0.9,0.9,1), model="loglinear",
           model.control=list(beta=0.9, sig2=0.015, ph=c(0.8,0.9,0.95,1)))
LH.full
aRRMSE.LH.full &lt;- var.strata(LH.full, rh=c(0.85,0.9,0.9,1), model="loglinear",
                  model.control=list(beta=0.9, sig2=0.015, ph=c(0.8,0.9,0.95,1)))
aRRMSE.LH.full$RRMSE
</code></pre>

<hr>
<h2 id='SHS'> Data from the 2001 Survey of Household Spending (SHS), Statistics Canada </h2><span id='topic+SHS'></span>

<h3>Description</h3>

<p>This data set contains some variables from the 2001 Survey of Household Spending (SHS) carried out by Statistics Canada. The main purpose of this survey is to obtain detailed information about household spending during the reference year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SHS</code></pre>


<h3>Format</h3>

<p>A data frame with 16057 observations on the following 7 variables.
</p>

<dl>
<dt><code>CASEID</code></dt><dd><p>Identification number</p>
</dd>
<dt><code>WEIGHT</code></dt><dd><p>Weight at household level</p>
</dd>
<dt><code>PROVINCP</code></dt><dd><p>Province or territory code</p>
</dd>
<dt><code>URBRUR</code></dt><dd><p>Urban rural code</p>
</dd>
<dt><code>URBSIZEP</code></dt><dd><p>Size of area of residence code</p>
</dd>
<dt><code>HHINCTOT</code></dt><dd><p>Household income before taxes</p>
</dd>
<dt><code>M101</code></dt><dd><p>Household spending on recreation</p>
</dd>
</dl>



<h3>Details</h3>

<p>In this package, <code>HHINCTOT</code> is used as a stratification variable and <code>M101</code> as a survey variable.
</p>


<h3>Source</h3>

<p>Income Statistics Division, Statistics Canada.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Estimation of the response rate
X &lt;- SHS$HHINCTOT[SHS$HHINCTOT&gt;0]
Y &lt;- SHS$M101[SHS$HHINCTOT&gt;0]
Y[Y&lt;0] &lt;- 0
p&lt;-sum(Y&gt;0)/length(Y)

# Study of the relationship between X and Y for the active units
Xactive &lt;- SHS$HHINCTOT[SHS$HHINCTOT&gt;0&amp;SHS$M101&gt;0]
Yactive &lt;- SHS$M101[SHS$HHINCTOT&gt;0&amp;SHS$M101&gt;0]
plot(log(Xactive), log(Yactive))
# Extreme values are omitted for a more robust estimation
keep &lt;- Xactive/Yactive&gt;quantile(Xactive/Yactive,0.01)&amp;
        Xactive/Yactive&lt;quantile(Xactive/Yactive,0.99)    
plot(log(Xactive)[keep], log(Yactive)[keep])
reg &lt;- lm( log(Yactive)[keep]~log(Xactive)[keep] )
summary(reg)

# Stratification assuming X=Y
nomodel &lt;- strata.LH(x=X, CV=0.05, Ls=3, alloc=c(0.5,0,0.5), takeall=0, 
           model="none", algo.control=list(trymany=FALSE, rep=2))
nomodel
var.strata(nomodel, y=Y) # The target CV is far from being reached

# Stratification taking into account a loglinear model with mortality 
# between X and Y, using the estimated parameters values
model &lt;- strata.LH(x=X, CV=0.05, Ls=3, alloc=c(0.5,0,0.5), takeall=0,
         model="loglinear", model.control=list(beta=reg$coef[2],
         sig2=summary(reg)$sigma^2, ph=0.97), initbh=nomodel$bh,
         algo.control=list(trymany=FALSE, rep=2))
model
var.strata(model,y=Y) # The target CV is reached
</code></pre>

<hr>
<h2 id='strata.bh'> Stratification of a Population Given a Set of Boundaries </h2><span id='topic+strata.bh'></span>

<h3>Description</h3>

<p>The function <code>strata.bh</code> stratifies a population given a set of boundaries. It calculates the stratum sample sizes and the anticipated coefficient of variation or relative root mean squared error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strata.bh(x, bh, n = NULL, CV = NULL, Ls = 3, certain = NULL,
          alloc = list(q1 = 0.5, q2 = 0, q3 = 0.5), takenone = 0, 
          bias.penalty = 1, takeall = 0, takeall.adjust = TRUE, 
          rh = rep(1, Ls), model = c("none", "loglinear", "linear",
          "random"), model.control = list())      
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strata.bh_+3A_x">x</code></td>
<td>
<p> A vector containing the values of the stratification variable <code class="reqn">X</code> for every unit in the population. </p>
</td></tr>
<tr><td><code id="strata.bh_+3A_bh">bh</code></td>
<td>
<p> A vector of the <code class="reqn">L-1</code> stratum boundaries <code class="reqn">(b_1, b_2, \ldots, b_{L-1})</code> where <code class="reqn">L</code> is the total number of strata (excluding the certainty stratum, if any). Therefore, if <code>takenone=0</code> then <code class="reqn">L</code>=<code>Ls</code>, and if <code>takenone=1</code> then <code class="reqn">L</code>=<code>Ls</code>+1. </p>
</td></tr>
<tr><td><code id="strata.bh_+3A_n">n</code></td>
<td>
<p> A numeric: the target sample size. It has no default value. The argument <code>n</code> or the argument <code>CV</code> must be input. </p>
</td></tr>
<tr><td><code id="strata.bh_+3A_cv">CV</code></td>
<td>
<p> A numeric: the target coefficient of variation or relative root mean squared error if <code>takenone</code>=1. It has no default value. The argument <code>CV</code> or the argument <code>n</code> must be input. </p>
</td></tr>
<tr><td><code id="strata.bh_+3A_ls">Ls</code></td>
<td>
<p> A numeric: the number of sampled strata (take-none and certain strata are not counted in <code>Ls</code>). The default is 3. </p>
</td></tr>
<tr><td><code id="strata.bh_+3A_certain">certain</code></td>
<td>
<p> A vector giving the position, in the vector <code>x</code>, of the units that must be included in the sample (see <code><a href="#topic+stratification-package">stratification-package</a></code>). By default <code>certain</code> is <code>NULL</code>, which means that no units are a priori chosen to be in the sample. </p>
</td></tr>
<tr><td><code id="strata.bh_+3A_alloc">alloc</code></td>
<td>
<p> A list specifying the allocation scheme. The list must contain 3 numerics for the 3 exponents <code>q1</code>, <code>q2</code> and <code>q3</code> in the general allocation scheme (see <code><a href="#topic+stratification-package">stratification-package</a></code>). The default is Neyman allocation (<code>q1</code>=<code>q3</code>=0.5 and <code>q2</code>=0)</p>
</td></tr>
<tr><td><code id="strata.bh_+3A_takenone">takenone</code></td>
<td>
<p> A numeric: the number of take-none strata (0 or 1). The default is 0, i.e. no take-none stratum is included.</p>
</td></tr>
<tr><td><code id="strata.bh_+3A_bias.penalty">bias.penalty</code></td>
<td>
<p> A numeric between 0 and 1 giving the penalty for the bias in the anticipated mean squared error (MSE) of the survey estimator (see <code><a href="#topic+stratification-package">stratification-package</a></code>). This argument is relevant only if <code>takenone</code>=1. The default is 1.</p>
</td></tr>
<tr><td><code id="strata.bh_+3A_takeall">takeall</code></td>
<td>
<p> A numeric: the number of take-all strata (one of {0, 1, ..., <code>Ls</code>-1}). The default is 0, i.e. no take-all stratum is included.</p>
</td></tr>
<tr><td><code id="strata.bh_+3A_takeall.adjust">takeall.adjust</code></td>
<td>
<p> A logical. If <code>TRUE</code> (the default), when <code class="reqn">n_h &gt; N_h</code> for a take-some stratum, the <code>takeall</code> argument is increased by one and the allocation is carried out again. This is done as long as <code class="reqn">n_h \leq N_h</code> for every take-some stratum. If <code>FALSE</code>, no adjustment is made. Note: in other functions of the package <span class="pkg">stratification</span>, this adjustment is not optional; it is made automatically (see <code><a href="#topic+stratification-package">stratification-package</a></code>).</p>
</td></tr>
<tr><td><code id="strata.bh_+3A_rh">rh</code></td>
<td>
<p> A vector giving the anticipated response rates in each of the <code>Ls</code> sampled strata. A single number can be given if the rates do not vary among strata. The default is 1 in each stratum. </p>
</td></tr>
<tr><td><code id="strata.bh_+3A_model">model</code></td>
<td>
<p> A character string identifying the model used to describe the discrepancy between the stratification variable <code class="reqn">X</code> and the survey variable <code class="reqn">Y</code>. It can be <code>"none"</code> if one assumes <code class="reqn">Y=X</code>, <code>"loglinear"</code> for the loglinear model with mortality, <code>"linear"</code> for the heteroscedastic linear model or <code>"random"</code> for the random replacement model (see <code><a href="#topic+stratification-package">stratification-package</a></code> for a description of these models). The default is <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="strata.bh_+3A_model.control">model.control</code></td>
<td>
<p> A list of model parameters (see <code><a href="#topic+stratification-package">stratification-package</a></code>). The default values of the parameters correspond to the model <code class="reqn">Y=X</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Nh</code></td>
<td>
<p>A vector of length <code class="reqn">L</code> containing the population sizes <code class="reqn">N_h</code>, i.e. the number of units in each stratum.</p>
</td></tr>
<tr><td><code>nh</code></td>
<td>
<p>A vector of length <code class="reqn">L</code> containing the sample sizes <code class="reqn">n_h</code>, i.e. the number of units to sample in each stratum. See <code><a href="#topic+stratification-package">stratification-package</a></code> for information about the rounding used to get these integer values.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The total sample size (<code>sum(nh)</code>).</p>
</td></tr>
<tr><td><code>nhnonint</code></td>
<td>
<p>A vector of length <code class="reqn">L</code> containing the non-integer values of the sample sizes, obtained directly from applying the allocation rule (see <code><a href="#topic+stratification-package">stratification-package</a></code>).</p>
</td></tr>
<tr><td><code>certain.info</code></td>
<td>
<p>A vector giving statistics for the certainty stratum (see <code><a href="#topic+stratification-package">stratification-package</a></code>). It contains <code>Nc</code>, the number of units chosen a priori to be in the sample, and <code>meanc</code>, the anticipated mean of <code class="reqn">Y</code> for these units. </p>
</td></tr>
<tr><td><code>opti.nh</code></td>
<td>
<p>The final value of the criteria to optimize (either the total sample size <code class="reqn">n</code> if a target <code>CV</code> was given or the RRMSE if a target <code>n</code> was given) calculated with the integer stratum sample sizes <code>nh</code>.</p>
</td></tr>
<tr><td><code>opti.nhnonint</code></td>
<td>
<p>The final value of the criteria to optimize (either the total sample size <code class="reqn">n</code> if a target <code>CV</code> was given or the RRMSE if a target <code>n</code> was given) calculated with the non-integer stratum sample sizes <code>nhnonint</code>.</p>
</td></tr>
<tr><td><code>meanh</code></td>
<td>
<p>A vector of length <code class="reqn">L</code> containing the anticipated means of <code class="reqn">Y</code> in each stratum.</p>
</td></tr>
<tr><td><code>varh</code></td>
<td>
<p>A vector of length <code class="reqn">L</code> containing the anticipated variances of <code class="reqn">Y</code> in each stratum.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>A numeric: the anticipated global mean value of <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code>RMSE</code></td>
<td>
<p>A numeric: the root mean squared error (or standard error if <code>takenone</code>=0) of the anticipated global mean of <code class="reqn">Y</code>. This is defined as the squared root of: (<code>bias.penalty</code> x bias of the mean)^2 + variance of the mean.</p>
</td></tr>
<tr><td><code>RRMSE</code></td>
<td>
<p>A numeric: the anticipated relative root mean squared error (or coefficient of variation if <code>takenone</code>=0) for the mean of <code class="reqn">Y</code>, i.e. <code>RMSE</code> divided by <code>mean</code>. </p>
</td></tr>
<tr><td><code>relativebias</code></td>
<td>
<p>A numeric: the anticipated relative bias of the estimator, i.e. (<code>bias.penalty</code> x bias of the mean) divided by <code>mean</code>. If <code>takenone</code>=0, this numeric is zero. </p>
</td></tr>
<tr><td><code>propbiasMSE</code></td>
<td>
<p>A numeric: the proportion of the MSE attributable to the bias of the estimator, i.e. (<code>bias.penalty</code> x bias of the mean)^2 divided by the MSE of the <code>mean</code>. If <code>takenone</code>=0, this numeric is zero.</p>
</td></tr>
<tr><td><code>stratumID</code></td>
<td>
<p>A factor, having the same length as the input <code>x</code>, which values are either 1, 2, ..., <code class="reqn">L</code> or <code>"certain"</code>. The value <code>"certain"</code> is given to units a priori chosen to be in the sample. This factor identifies, for each observation, the stratum to which it has been assigned.</p>
</td></tr>  
<tr><td><code>takeall</code></td>
<td>
<p>The number of take-all strata in the final solution. Note: It is possible that <code class="reqn">n_h=N_h</code> for non take-all strata because the condition for an automatic addition of a take-all stratum is <code class="reqn">n_h&gt;N_h</code>. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The function call (object of class &quot;call&quot;).</p>
</td></tr>
<tr><td><code>date</code></td>
<td>
<p>A character string that contains the system date and time when the function ended. </p>
</td></tr>
<tr><td><code>args</code></td>
<td>
<p>A list of all the argument values input to the function or set by default. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Sophie Baillargeon <a href="mailto:Sophie.Baillargeon@mat.ulaval.ca">Sophie.Baillargeon@mat.ulaval.ca</a> and<br />
Louis-Paul Rivest <a href="mailto:Louis-Paul.Rivest@mat.ulaval.ca">Louis-Paul.Rivest@mat.ulaval.ca</a> </p>


<h3>References</h3>

<p>Baillargeon, S. and  Rivest L.-P. (2011). The construction of stratified designs in R with the package stratification. <em>Survey Methodology</em>, <b>37</b>(1), 53-65.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+print.strata">print.strata</a></code>, <code><a href="#topic+plot.strata">plot.strata</a></code>, <code><a href="#topic+strata.cumrootf">strata.cumrootf</a></code>, <code><a href="#topic+strata.geo">strata.geo</a></code>, <code><a href="#topic+strata.LH">strata.LH</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>adjust &lt;- strata.geo(x=USbanks, CV=0.01, Ls=4, alloc=c(0.35,0.35,0))
adjust
adjust$nhnonint
noadjust &lt;- strata.bh(x=USbanks, bh=adjust$bh, CV=0.01, Ls=4,
            alloc=c(0.35,0.35,0), takeall=0, takeall.adjust=FALSE)
noadjust
noadjust$nhnonint
# without the adjustment for a take-all stratum, n is smaller than
# with the adjustment, but the target CV is not reached.
</code></pre>

<hr>
<h2 id='strata.LH'> Generalized Lavallee-Hidiroglou Method of Strata Construction </h2><span id='topic+strata.LH'></span>

<h3>Description</h3>

<p>This function aims at constructing optimal strata with a generalized Lavallee-Hidiroglou (1998) method.
The function uses Kozak's (2004) algorithm by default, but it can also apply Sethi's (1963) algorithm (argument <code>algo="Sethi"</code>). The function can take into account a discrepancy between the stratification variable <code class="reqn">X</code> and the survey variable <code class="reqn">Y</code>. It can consider a loglinear model with mortality between the variables (Baillargeon and Rivest, 2009). With Kozak's algorithm, two additional models are implemented: an heteroscedastic linear model and a random replacement model as in Rivest (2002). The determination of the optimal boundaries also incorporates, if desired, an anticipated non-response, a take-all stratum for the large units, a take-none stratum for the small units, and a certainty stratum to ensure that some specific units are in the sample.<br /><br />
Sethi's algorithm is not used by default because it can be numerically unstable, especially with a take-none stratum. Better results were obtained with Kozak's algorithm in our numerical experiments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strata.LH(x, n = NULL, CV = NULL, Ls = 3, certain = NULL,
          alloc = list(q1 = 0.5, q2 = 0, q3 = 0.5), takenone = 0, 
          bias.penalty = 1, takeall = 0, rh = rep(1, Ls), 
          model = c("none", "loglinear", "linear", "random"), 
          model.control = list(), initbh = NULL, 
          algo = c("Kozak", "Sethi"), algo.control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strata.LH_+3A_x">x</code></td>
<td>
<p> A vector containing the values of the stratification variable <code class="reqn">X</code> for every unit in the population. </p>
</td></tr>
<tr><td><code id="strata.LH_+3A_n">n</code></td>
<td>
<p> A numeric: the target sample size. It has no default value. The argument <code>n</code> or the argument <code>CV</code> must be input. </p>
</td></tr>
<tr><td><code id="strata.LH_+3A_cv">CV</code></td>
<td>
<p> A numeric: the target coefficient of variation or relative root mean squared error if <code>takenone</code>=1. It has no default value. The argument <code>CV</code> or the argument <code>n</code> must be input. </p>
</td></tr>
<tr><td><code id="strata.LH_+3A_ls">Ls</code></td>
<td>
<p> A numeric: the number of sampled strata (take-none and certain strata are not counted in <code>Ls</code>). The default is 3. </p>
</td></tr>
<tr><td><code id="strata.LH_+3A_certain">certain</code></td>
<td>
<p> A vector giving the position, in the vector <code>x</code>, of the units that must be included in the sample (see <code><a href="#topic+stratification-package">stratification-package</a></code>). By default <code>certain</code> is <code>NULL</code>, which means that no units are chosen a priori to be in the sample. </p>
</td></tr>
<tr><td><code id="strata.LH_+3A_alloc">alloc</code></td>
<td>
<p> A list specifying the allocation scheme. The list must contain 3 numerics for the 3 exponents <code>q1</code>, <code>q2</code> and <code>q3</code> in the general allocation scheme (see <code><a href="#topic+stratification-package">stratification-package</a></code>). The default is Neyman allocation (<code>q1</code>=<code>q3</code>=0.5 and <code>q2</code>=0)</p>
</td></tr>
<tr><td><code id="strata.LH_+3A_takenone">takenone</code></td>
<td>
<p> A numeric: the number of take-none strata (0 or 1). The default is 0, i.e. no take-none stratum is included.</p>
</td></tr>
<tr><td><code id="strata.LH_+3A_bias.penalty">bias.penalty</code></td>
<td>
<p> A numeric between 0 and 1 giving the penalty for the bias in the anticipated mean squared error (MSE) of the survey estimator (see <code><a href="#topic+stratification-package">stratification-package</a></code>). This argument is relevant only if <code>takenone</code>=1. The default is 1.</p>
</td></tr>
<tr><td><code id="strata.LH_+3A_takeall">takeall</code></td>
<td>
<p> A numeric: the number of take-all strata (one of {0, 1, ..., <code>Ls</code>-1}). The default is 0, i.e. no take-all stratum is included.</p>
</td></tr>
<tr><td><code id="strata.LH_+3A_rh">rh</code></td>
<td>
<p> A vector giving the anticipated response rates in each of the <code>Ls</code> sampled strata. A single number can be given if the rates do not vary among strata. The default is 1 in each stratum. </p>
</td></tr>
<tr><td><code id="strata.LH_+3A_model">model</code></td>
<td>
<p> A character string identifying the model used to describe the discrepancy between the stratification variable <code class="reqn">X</code> and the survey variable <code class="reqn">Y</code>. It can be <code>"none"</code> if one assumes <code class="reqn">Y=X</code>, <code>"loglinear"</code> for the loglinear model with mortality, <code>"linear"</code> for the heteroscedastic linear model or <code>"random"</code> for the random replacement model (see <code><a href="#topic+stratification-package">stratification-package</a></code> for a description of these models). The default is <code>"none"</code>, so the original Lavallee-Hidiroglou (1998) method of strata construction is used. The last two models <code>"linear"</code> and <code>"random"</code> are only available with Kozak's algorithm.</p>
</td></tr>
<tr><td><code id="strata.LH_+3A_model.control">model.control</code></td>
<td>
<p> A list of model parameters (see <code><a href="#topic+stratification-package">stratification-package</a></code>). The default values of the parameters correspond to the model <code class="reqn">Y=X</code>. </p>
</td></tr>
<tr><td><code id="strata.LH_+3A_initbh">initbh</code></td>
<td>
<p> A vector of initial stratum boundaries  (see <b>Details</b>).</p>
</td></tr>  
<tr><td><code id="strata.LH_+3A_algo">algo</code></td>
<td>
<p> A character string identifying which optimization algorithm is to be used. It can be &quot;Kozak&quot; for Kozak's (2004) algorithm or &quot;Sethi&quot; for Sethi's (1963) algorithm (see <b>Details</b>). The default is &quot;Kozak&quot; because it performs better and offers more options than Sethi's algorithm. </p>
</td></tr>
<tr><td><code id="strata.LH_+3A_algo.control">algo.control</code></td>
<td>
<p> A list of parameters to control the optimization algorithm (see <b>Details</b>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CALCULATION OF THE OPTIMIZATION CRITERIA
</p>
<p>Kozak's and Sethi's algorithms aim at finding optimal stratum boundaries. This optimality refers to a criteria :<br />
the total sample size <code class="reqn">n</code> if a target <code>CV</code> was given<br />
the RRMSE if a target <code>n</code> was given (not available for Sethi's algorithm).<br />
This criteria, no matter if it is <code class="reqn">n</code> or the RRMSE, is a function of the stratum sample sizes, among others. But these stratum sample sizes can be non-integer (<code>nhnonint</code> obtained directly from applying the allocation rule) or integer (<code>nh</code> obtained from rounding the <code>nhnonint</code>), as mentioned in <code><a href="#topic+stratification-package">stratification-package</a></code>. The optimization criteria does not vary much depending on the sample size used, but it is not exactly the same. Let's call <code>opti.nh</code> the criteria calculated with <code>nh</code> and <code>opti.nhnonint</code> the criteria calculated with <code>nhnonint</code>. Optimizing based on <code>opti.nh</code> vs <code>opti.nhnonint</code> might not give the same result. In fact, according to our numerical tests, it is a little better to optimize based on <code>opti.nh</code>. This is logical since the sample sizes used in practice, to apply a stratified design, are the integer one. Therefore, as of version 2.1-0 of the package, Kozak's algorithm uses by default the integer sample sizes <code>nh</code> to calculate the optimization criteria (but it can also use <code>opti.nhnonint</code> by setting  <code>idopti="nhnonint"</code> in <code>algo.control</code>). However, Sethi's algorithm works with derivatives to perform optimization. Therefore, it does not treat the optimization as a discrete problem as Kozak's algorithm does. It can only work with a real optimization criteria, i.e. the criteria <code>opti.nhnonint</code> calculated with non-integer sample size. This is one more reason to favour Kozak's algorithm over Sethi's one.<br /><br />
</p>
<p>INITIAL STRATUM BOUNDARIES
</p>
<p>Both Kozak's and Sethi's algorithm are iterative and they need starting values. It can be given by the user with the <code>initbh</code> argument. If not given, the default initial boundaries are obtained with the function <code><a href="#topic+strata.cumrootf">strata.cumrootf</a></code> (cumulative root frequency method) for Kozak's algorithm. For Sethi's algorithm, the default value of <code>initbh</code> is the set of <code>Ls</code>-1 equidistant points along the range of the <code class="reqn">X</code>-values (arithmetic starting points of Gunning and Horgan (2007)). Let's define <code class="reqn">d=(max(X)-min(X))/Ls</code>, the arithmetic boundaries are <code class="reqn">b_h = min(X) + h \times d</code> for <code class="reqn">h=1,\ldots,Ls-1</code>. 
</p>
<p>The default initial boundaries are not the same for the two algorithms because Kozak's algorithm uses by default the criteria <code>opti.nh</code> whereas Sethi's algorithm can only use <code>opti.nhnonint</code>. In our numerical experiments with the criteria <code>opti.nh</code>, the cumulative root frequency boundaries performed a little better than geometric, arithmetic or robust boundaries (for a definition of theses boundaries, see details about the <code>trymany</code> algorithm parameter). On the other hand, the arithmetic boundaries had good performances (Baillargeon and Rivest 2009) with the criteria <code>opti.nhnonint</code>. Let's note however that we never found, in any of our numerical experiments, initial boundaries clearly better than others.
</p>
<p>The length of the vector <code>initbh</code> can be <code>Ls</code>-1 or <code class="reqn">L</code>-1, where <code class="reqn">L</code> is the total number of strata. When <code>takenone=0</code>, <code class="reqn">L</code>=<code>Ls</code> and it does not make any difference. But for a stratified design with a take-none stratum, it means that one can give as <code>initbh</code> argument the vector of initial boundaries <code class="reqn">(b_1, b_2, \ldots, b_{L-1})</code> or <code class="reqn">(b_2, \ldots, b_{L-1})</code>. In the second option, the upper boundary of the take-none stratum is not given. In that case, it is set by default to 
the first percentile of <code>x</code>. If this first percentile is equal to the minimum value of <code>x</code>, this initial 
boundary would lead to an empty take-none stratum. In that case, the initial boundary of the take-none stratum is 
rather set to the second smallest value of <code>x</code>.
</p>
<p>Sometimes, the specified initial boundaries are not suitable for Kozak's algorithm. As written below, this algorithm 
verifies at each iteration that the sampled strata contains at least <code>minNh</code> units and that they have positive 
sample sizes <code>nh</code>. If the initial boundaries do not meet these conditions, the initial optimization criteria is not comparable to the criteria for boundaries respecting the conditions. Therefore, in such a situation, a warning is produced and the algorithm is not run. <br /><br />  
</p>
<p>ALGORITHMS
</p>
<p><b>Sethi:</b> The formulas implemented for Sethi's algorithm are presented in Baillargeon, Rivest and Ferland (2007). As mentioned previously, this algorithm is available for a target CV only. Moreover, it works with derivatives to perform optimization. Therefore, it can only work with a real optimization criteria (<code>opti.nhnonint</code>).
</p>
<p><b>Kozak:</b> Kozak's algorithm is described in Kozak (2004). It starts at the initial boundaries <code>initbh</code> and at each iteration, it chooses a stratum boundary at random and a random modification for this boundary among the 2*<code>maxstep</code> possible alternatives. If this modification reduces the optimization criteria, creates sampled strata containing at least <code>minNh</code> units and leads to positive <code>nh</code>, it is accepted. Otherwise, the boundaries are not changed. If the boundaries remain unchanged for <code>maxstill</code> consecutive iterations, the algorithm has reached convergence and it stops.<br />
Kozak's (2004) used the condition <code>nh</code> &gt;= 2 instead of <code>nh</code> &gt; 0. We chose to modify this requirement because we noticed that more severe conditions sometimes prevented the algorithm from selecting a path leading to the optimal solution. According to our numerical experiments, if one sets a posteriori to 2 the <code>nh</code>'s that are equal to 1 at the end of the algorithm, the new sample size is smaller than or equal to the one obtained with the condition <code>nh</code> &gt;= 2.<br />
If no <code>initbh</code> argument is given, the algorithm is run with three different sets of initial boundaries (see details of the algorithm parameter <code>trymany</code>). If <code>initbh</code> is given, it uses these initial boundaries. Bot no matter how many initial boundaries are tried, the algorithm is run <code>rep</code> times with each. Running the algorithm many times helps having more stable results. Since the algorithm is random, two runs of the algorithm, event from the same starting point, can lead to different results. Setting <code>rep</code> to a large value and trying more than one set of initial boundaries increases the calculation time, but also increases the chance of finding the global minimum.  also helps in finding the global minimum. 
</p>
<p>The optimization of stratum boundaries given a target CV or a target <code class="reqn">n</code> is a discrete problem. The number of possible sets of boundaries is <code>choose(Nu-1,L-1)</code> when <code>takenone=0</code>, and <code>choose(Nu,L-1)</code> when <code>takenone=1</code>, where <code>Nu</code> stands for the number of unique values in the <code>x</code>-vector from which units in the certainty stratum, if any, heve been removed. When this number is not too large, trying them all is numerically possible. That's what the function <code>strata.LH</code> do, for Kozak's algorithm, when the number of possible solutions is lower than the <code>minsol</code> parameter in <code>algo.control</code>. This complete enumeration of all possible cases ensure that the global minimum is reached. 
</p>
<p>Note: Since version 2.2-0 of the package <span class="pkg">stratification</span>, the modified Kozak's algorithm, which is a non-random version of Kozak's algorithm, is no more available because it never performed as well as the original Kozak's algorithm in our numerical experiments.<br /><br />
</p>
<p>ALGORITHM PARAMETERS
</p>
<p>The <code>algo.control</code> argument is a list to supply any of the following parameters which control the algorithm. Sethi's algorithm only uses the first argument <code>maxiter</code>.
</p>

<dl>
<dt><code>maxiter</code></dt><dd><p> A numeric: the maximal number of iterations. The default is 500 for Sethi's algorithm and 10 000 for Kozak's. It is only used to prevent from infinite loops in case of non-convergence.  </p>
</dd>
<dt><code>minsol</code></dt><dd><p> A numeric for Kozak's algorithm only: if the number of possible sets of boundaries is lower than <code>minsol</code>, a complete enumeration of the solutions is performed instead of running the algorithm. Every set of boundaries is tried, which ensures that the global minimum is reached. The default value of <code>minsol</code> is 10 000. This parameter has to take a value between 2 and 2 000 000. </p>
</dd>
<dt><code>idopti</code></dt><dd><p> A character string for Kozak's algorithm only: this argument determines which stratum sample sizes are going to be used to calculate the optimization criteria. It can take the value <code>"nh"</code> (criteria calculated with the integer sample sizes <code>nh</code>) or <code>"nhnonint"</code> (criteria calculated with the non-integer sample sizes <code>nhnonint</code>). The default value is <code>"nh"</code> since it gives slightly better results than <code>idopti="nhnonint"</code> and also because the integer sample sizes are the ones used in practice. When a complete enumeration is performed, the criteria is automatically calculated with integer stratum sample sizes. Note: Prior to version 2.1-0 of the package <span class="pkg">stratification</span>, only the option <code>idopti="nhnonint"</code> was available (in fact the algorithm parameter <code>idopti</code> did not exist). </p>
</dd>
<dt><code>minNh</code></dt><dd><p> A numeric for Kozak's algorithm only: the minimum number of units required in each sampled stratum (no restriction is put on the take-none stratum, if included). <code>minNh</code> must be greater or equal to 2, which is the default. </p>
</dd>
<dt><code>maxstep</code></dt><dd><p> A numeric for Kozak's algorithm only: the maximal step for boundary modification (see the algorithm description above). The default is <code>Nu/10</code>, rounded up and truncated to 100 (<code>Nu</code> is the number of unique values in the <code>x</code>-vector from which units in the certainty stratum, if any, heve been removed). This default value is, for most populations, much larger than the initial suggestion by Kozak (2004) of a integer no bigger than 5. Our numerical experiments showed us that a <code>maxstep</code> value of about 3 (package <span class="pkg">stratification</span> initial default value) is adequate when the optimization criteria is calculated with non-integer stratum sample sizes (<code>opti.nhnonint</code>). However, when this criteria is calculated with integer stratum sample sizes (<code>opti.nh</code>), the algorithm never do worst and sometimes reaches an even lower optimization criteria with a larger <code>maxstep</code>. The parameter <code>maxstill</code> must be increased consequently (see below).  The downside of large <code>maxstep</code> and <code>maxstill</code> values is that many iterations are needed for the algorithm to converge, making it longer to run. We implemented a solution to this problem. This solution is based on the fact that when the algorithm is close to the solution, it can only accept boundaries modifications with small steps. The large steps are useful during the first iterations of the algorithm to let the boundaries move freely, but it becomes useless when convergence is close. Therefore, the values of <code>maxstep</code> and <code>maxstill</code> are brought down to 3 and 50, respectively, when new boundaries are accepted under these circumstances : the step in the boundary modification is lower than 3 in absolute value, more than 50 iterations without change happened before this change, the relative change in the optimization criteria is small. This rule is arbitrary, but it seems to work well so far. It gives results as good as without changing the values of <code>maxstep</code> and <code>maxstill</code>, but it runs much faster because it needs less iterations to converge.</p>
</dd>
<dt><code>maxstill</code></dt><dd><p> A numeric for Kozak's algorithm only: the maximal number of iterations without a change in the boundaries (see the algorithm description above). The default is <code>maxstep</code>*10, bounded between 50 and 500. It depends on the value of <code>maxstep</code> because we increased the default value of this parameter by making it a function of the number of unique values in the <code>x</code>-vector (see above). The upper bound of 500 ensures that the algorithm does not have to make too much iterations (which take time) to converge. </p>
</dd>
<dt><code>rep</code></dt><dd><p> A numeric for Kozak's algorithm only: the number of repetitions of the algorithm (see the algorithm description above). The default is 5. Since version 2.2-0 of the package <span class="pkg">stratification</span>, the option <code>rep="change"</code> has been replaced by the option <code>trymany=TRUE</code>.</p>
</dd>
<dt><code>trymany</code></dt><dd><p> A logical for Kozak's algorithm only: if <code>trymany=TRUE</code>, three sets of initial boundaries are tried instead of one. These boundaries are cumulative root frequency (Dalenius and Hodges, 1959), geometric (Gunning and Horgan, 2004) and robust ones. Robust boundaries were created in order to have boundaries respecting as often as possible the conditions imposed on boundaries in Kozak's algorithm: strata containing at least <code>minNh</code> units and positive <code>nh</code>. Robust boundaries give an empty take-none stratum if such a stratum is requested, take-all strata as small as possible, and take-some strata with approximately the same number of unique <code class="reqn">X</code>-values. When <code>trymany=TRUE</code>, the same values for the other algorithm parameters (the one given by the user or otherwise the default) are used for every set of initial boundaries. If <code>trymany=FALSE</code>, only the given or default (see above) initial boundaries are used. If a user give an <code>initbh</code> argument, but also select <code>trymany=TRUE</code>, the later is ignored and only the <code>initbh</code> initial boundaries are used.<br /><br /></p>
</dd>  
</dl>

<p>CONVERGENCE
</p>
<p>It is possible for the algorithm not to converge. In this case, a warning is printed. The only possible cause of non-convergence for Kozak's algorithm is to reach the maximum number of iterations before the stopping rule has been met. For the algorithm to converge, the argument <code>maxiter</code> has to be increased. On the other hand, non-convergence of Sethi's algorithm has several possible causes:
</p>

<ul>
<li><p> a division by zero caused by an empty stratum can occur ;
</p>
</li>
<li><p> a division by zero caused by a 0 stratum variance can occur ;
</p>
</li>
<li><p> the square root of a negative number (negative discriminant) can occur ;
</p>
</li>
<li><p> the maximum number of iterations can be reached (often because the algorithm is caught in a loop of non-optimal sets of boundaries).
</p>
</li></ul>

<p>If a non-convergence happens, the user can try to change the initial boundaries or the model parameters. The user can also choose to work with Kozak's algorithm which should converge given an appropriate maximum number of iterations.<br /><br />
</p>
<p>WARNING ABOUT LOCAL MINIMA
</p>
<p>Let's note that even if the algorithm converges, it is not guaranteed that it has reached a global minimum. Local minimum can occur both with Sethi's and Kozak's algorithms (Rivest and Baillargeon, 2009).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>bh</code></td>
<td>
<p>A vector of the <code class="reqn">L-1</code> optimal stratum boundaries found by the algorithm.</p>
</td></tr>
<tr><td><code>Nh</code></td>
<td>
<p>A vector of length <code class="reqn">L</code> containing the population sizes <code class="reqn">N_h</code>, i.e. the number of units in each stratum.</p>
</td></tr>
<tr><td><code>nh</code></td>
<td>
<p>A vector of length <code class="reqn">L</code> containing the sample sizes <code class="reqn">n_h</code>, i.e. the number of units to sample in each stratum. See <code><a href="#topic+stratification-package">stratification-package</a></code> for information about the rounding used to get these integer values.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The total sample size (<code>sum(nh)</code>).</p>
</td></tr>
<tr><td><code>nhnonint</code></td>
<td>
<p>A vector of length <code class="reqn">L</code> containing the non-integer values of the sample sizes, obtained directly from applying the allocation rule (see <code><a href="#topic+stratification-package">stratification-package</a></code>).</p>
</td></tr>
<tr><td><code>certain.info</code></td>
<td>
<p>A vector giving statistics for the certainty stratum (see <code><a href="#topic+stratification-package">stratification-package</a></code>). It contains <code>Nc</code>, the number of units chosen a priori to be in the sample, and <code>meanc</code>, the anticipated mean of <code class="reqn">Y</code> for these units. </p>
</td></tr>
<tr><td><code>opti.criteria</code></td>
<td>
<p>The final value of the criteria to optimize : either <code class="reqn">n</code> if a target <code>CV</code> was given or the RRMSE if a target <code>n</code> was given. If the algorithm parameter <code>idopti</code> takes the value <code>"nh"</code> (the default), the stratum sample sizes used for the calculation of this criteria are the integer ones (<code>nh</code>). If the algorithm parameter <code>idopti</code> takes the value <code>"nhnonint"</code>, the non-integer stratum sample sizes (<code>nhnonint</code>) are used. In other words, <code>idopti</code> determines here if <code>opti.criteria</code> is <code>opti.nh</code> or <code>opti.nhnonint</code>.</p>
</td></tr>
<tr><td><code>meanh</code></td>
<td>
<p>A vector of length <code class="reqn">L</code> containing the anticipated means of <code class="reqn">Y</code> in each stratum.</p>
</td></tr>
<tr><td><code>varh</code></td>
<td>
<p>A vector of length <code class="reqn">L</code> containing the anticipated variances of <code class="reqn">Y</code> in each stratum.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>A numeric: the anticipated global mean value of <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code>RMSE</code></td>
<td>
<p>A numeric: the root mean squared error (or standard error if <code>takenone</code>=0) of the anticipated global mean of <code class="reqn">Y</code>. This is defined as the squared root of: (<code>bias.penalty</code> x bias of the mean)^2 + variance of the mean.</p>
</td></tr>
<tr><td><code>RRMSE</code></td>
<td>
<p>A numeric: the anticipated relative root mean squared error (or coefficient of variation if <code>takenone</code>=0) for the mean of <code class="reqn">Y</code>, i.e. <code>RMSE</code> divided by <code>mean</code>. </p>
</td></tr>
<tr><td><code>relativebias</code></td>
<td>
<p>A numeric: the anticipated relative bias of the estimator, i.e. (<code>bias.penalty</code> x bias of the mean) divided by <code>mean</code>. If <code>takenone</code>=0, this numeric is zero. </p>
</td></tr>
<tr><td><code>propbiasMSE</code></td>
<td>
<p>A numeric: the proportion of the MSE attributable to the bias of the estimator, i.e. (<code>bias.penalty</code> x bias of the mean)^2 divided by the MSE of the <code>mean</code>. If <code>takenone</code>=0, this numeric is zero.</p>
</td></tr>
<tr><td><code>stratumID</code></td>
<td>
<p>A factor, having the same length as the input <code>x</code>, which values are either 1, 2, ..., <code class="reqn">L</code> or <code>"certain"</code>. The value <code>"certain"</code> is given to units a priori chosen to be in the sample. This factor identifies, for each observation, the stratum to which it has been assigned.</p>
</td></tr>  
<tr><td><code>takeall</code></td>
<td>
<p>The number of take-all strata in the final solution. Note: It is possible that <code class="reqn">n_h=N_h</code> for non take-all strata because the condition for an automatic addition of a take-all stratum is <code class="reqn">n_h&gt;N_h</code>. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The function call (object of class &quot;call&quot;).</p>
</td></tr>
<tr><td><code>date</code></td>
<td>
<p>A character string that contains the system date and time when the function ended. </p>
</td></tr>
<tr><td><code>args</code></td>
<td>
<p>A list of all the argument values input to the function or set by default. </p>
</td></tr>
<tr><td><code>iter.detail</code></td>
<td>
<p>Only if an iterative algorithm is run (thus not int the output when a complete enumeration is performed): a data frame giving, for each iteration of the algorithm:<br />
<code>"bh"</code>: the stratum boundaries;<br />
<code>"opti.nh"</code>: the value of the criteria to optimize calculated with integer stratum sample sizes (for Kozak's algorithm only);<br />
<code>"opti.nhnonint"</code>: the value of the criteria to optimize calculated with non-integer stratum sample sizes;<br />
<code>"takeall"</code>: the number of take-all strata for the corresponding boundaries, after making, if needed, an adjustment for non requested take-all strata;<br /> 
<code>"step"</code>: the step in the boundary modification (for Kozak's algorithm only);<br />
<code>"iter"</code>: the iteration identification number;<br /> 
<code>"run"</code>: the run identification number (for Kozak's algorithm only) because when <code>trymany=TRUE</code> or <code>rep</code>&gt;1 the algorithm is run more than once.<br />
For Kozak's algorithm, a row is added to <code>iter.detail</code> only for accepted boundaries, i.e. boundaries decreasing the optimization criteria while respecting the conditions on <code class="reqn">N_h</code> and <code class="reqn">n_h</code> (see <b>Details</b> for the algorithm description). </p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>Only if an iterative algorithm is run: the total number of iterations before convergence of the algorithm. For Kozak's algorithm, this number includes all the iterations, even the ones with discarded boundaries. <code>niter</code> is a vector if the algorithm was run more than once and if more than one run lead to the output solution. </p>
</td></tr>
<tr><td><code>converge</code></td>
<td>
<p>Only if an iterative algorithm is run: a logical indicating if the algorithm has converged (see <b>Details</b>). </p>
</td></tr>
<tr><td><code>run.detail</code></td>
<td>
<p>Only for Kozak's algorithm when it is run more than once: a data frame giving the final solution for every run of the algorithm. It contains, for each run:<br />
<code>"bh"</code>: the stratum boundaries at convergence;<br />
<code>"opti.nh"</code>: the value of the criteria to optimize calculated with integer stratum sample sizes;<br />
<code>"opti.nhnonint"</code>: the value of the criteria to optimize calculated with non-integer stratum sample sizes;<br />
<code>"takeall"</code>: the number of take-all strata for the corresponding boundaries, after making, if needed, an adjustment for non requested take-all strata;<br /> 
<code>"niter"</code>: the number of iterations of the algorithm;<br />
<code>"initbh.type"</code>: the type of initial boundaries requested (<code>"initbh"</code> for user-given boundaries, <code>"cumrootf"</code>, <code>"geo"</code> or <code>robust</code>);<br />
<code>"ibh"</code>: the initial boundaries used to run the algorithm;<br />
<code>"rep"</code>: the repetition number (because the algorithm is run <code>rep</code> times for each set of initial boundaries tried).<br />
When <code>trymany=TRUE</code>, if a set of initial boundaries do not meet the conditions on <code class="reqn">N_h</code> and <code class="reqn">n_h</code> (see <b>Details</b> for the algorithm description), the algorithm is not run with these boundaries and no rows are added to <code>run.detail</code>.</p>
</td></tr>
<tr><td><code>run.min</code></td>
<td>
<p>Only for Kozak's algorithm when it is run more than once: the identification number of every algorithm run leading to the optimal plan, i.e. the rows of <code>run.detail</code> containing the proposed solution. </p>
</td></tr>
<tr><td><code>sol.detail</code></td>
<td>
<p>Only for Kozak's algorithm when the number of possible sets of boundaries is lower than <code>minsol</code>: a data frame giving information for the possible solutions fulfilling the conditions <code class="reqn">N_h \geq</code> <code>minNh</code> and <code>nh</code> &gt; 0. It contains:<br />
<code>"bh"</code>: the stratum boundaries;<br />
<code>"Nh"</code>: the number of units in each stratum;<br />
<code>"opti.nh"</code>: the value of the criteria to optimize calculated with integer stratum sample sizes;<br />
<code>"opti.nhnonint"</code>: the value of the criteria to optimize calculated with non-integer stratum sample sizes;<br />
<code>"takeall"</code>: the number of take-all strata for the corresponding boundaries, after making, if needed, an adjustment for non requested take-all strata. </p>
</td></tr>
<tr><td><code>sol.min</code></td>
<td>
<p>Only for Kozak's algorithm when the number of possible sets of boundaries is lower than <code>minsol</code>: the rows of <code>sol.detail</code> containing the optimal solution.</p>
</td></tr>
<tr><td><code>nsol</code></td>
<td>
<p>Only for Kozak's algorithm : the number of possible sets of boundaries (see <b>Details</b>).</p>
</td></tr>   
</table>


<h3>Author(s)</h3>

<p> Sophie Baillargeon <a href="mailto:Sophie.Baillargeon@mat.ulaval.ca">Sophie.Baillargeon@mat.ulaval.ca</a> and<br />
Louis-Paul Rivest <a href="mailto:Louis-Paul.Rivest@mat.ulaval.ca">Louis-Paul.Rivest@mat.ulaval.ca</a> </p>


<h3>References</h3>

<p>Baillargeon, S., Rivest, L.-P., Ferland, M. (2007). Stratification en enquetes entreprises : Une revue et quelques avancees. <em>Proceedings of the Survey Methods Section, 2007 SSC Annual Meeting</em>.
</p>
<p>Baillargeon, S. and Rivest, L.-P. (2009). A general algorithm for univariate stratification. <em>International Stratification Review</em>, <b>77</b>(3), 331-344.
</p>
<p>Baillargeon, S. and  Rivest L.-P. (2011). The construction of stratified designs in R with the package stratification. <em>Survey Methodology</em>, <b>37</b>(1), 53-65.
</p>
<p>Dalenius, T. and Hodges, J.L., Jr. (1959). Minimum variance stratification. <em>Journal of the American Statistical Association</em>, <b>54</b>, 88-101.
</p>
<p>Gunning, P. and Horgan, J.M. (2004). A new algorithm for the construction of stratum boundaries in skewed populations. <em>Survey Methodology</em>, <b>30</b>(2), 159-166.
</p>
<p>Gunning, P. and Horgan, J.M. (2007). Improving the Lavallee and Hidiroglou algorithm for stratification of skewed populations. <em>Journal of Statistical Computation and Simulation</em>, <b>77</b>(4), 277-291.
</p>
<p>Kozak, M. (2004). Optimal stratification using random search method in agricultural surveys. <em>Statistics in Transition</em>, <b>6</b>(5), 797-806.
</p>
<p>Lavallee, P. and Hidiroglou, M.A. (1988). On the stratification of skewed populations. <em>Survey Methodology</em>, <b>14</b>, 33-43.
</p>
<p>Rivest, L.-P. (1999). Stratum jumpers: Can we avoid them? <em>Proceedings of the Section on Survey Methods Research of the American Statistical Association</em>, 64-72.
</p>
<p>Rivest, L.-P. (2002). A generalization of the Lavallee and Hidiroglou algorithm for stratification in business surveys. <em>Survey Methodology</em>, <b>28</b>(2), 191-198.
</p>
<p>Sethi, V. K. (1963). A note on optimum stratification of populations for estimating the population means. <em>The Australian Journal of Statistics</em>, <b>5</b>, 20-33.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+print.strata">print.strata</a></code>, <code><a href="#topic+plot.strata">plot.strata</a></code>, <code><a href="#topic+strata.cumrootf">strata.cumrootf</a></code>, <code><a href="#topic+strata.geo">strata.geo</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#########################################################
### Sethi's algorithm versus Kozak's algorithm

# LACK OF CONVERGENCE
# Here is an example of numerical difficulties met with Sethi but not with Kozak  
Sethi &lt;- strata.LH(x=UScities, CV=0.01, Ls=3, alloc=c(0.35,0.35,0), takenone=0, takeall=1,
         rh=1, model="loglinear", model.control=list(beta=1, sig2=0.5, ph=0.85), 
         algo="Sethi", algo.control=list(maxiter=20))
Sethi
Sethi$iter.detail[1:5,]
# Kozak's algorithm with arithmetic initial boundaries 
# (default initial boundaries for Sethi's algorithm) 
Kozak&lt;-strata.LH(x=UScities, initbh=c(18,27), CV=0.01, Ls=3, alloc=c(0.35,0.35,0),
       takenone=0, takeall=1, rh=1, model="loglinear",
       model.control=list(beta=1, sig2=0.5, ph=0.85), algo="Kozak")
Kozak
Kozak$iter.detail[Kozak$iter.detail[,"run"]==Kozak$run.min[1],]
# Looking at the iteration history for the optimization with Sethi and Kozak, 
# we see that the initial boundaries are very close from the optimal ones. 
# Kozak reaches very quickly a minimum. However, Sethi increases n instead of 
# minimizing it and afterwards it oscillates between two sets of boundaries 
# without converging.

# LOCAL MINIMUM
# In this example, Sethi's algorithm obviously reaches a local minimum since Kozak 
# proposes a much smaller n.
Sethi&lt;-strata.LH(x=UScities, CV=0.01, Ls=4, alloc=c(0.5,0,0), takenone=0, takeall=1, 
       rh=0.85, model="loglinear", model.control=list(beta=1.1, sig2=0, ph=1),
       algo="Sethi")
Sethi
Kozak&lt;-strata.LH(x=UScities, CV=0.01, Ls=4, alloc=c(0.5,0,0), takenone=0, takeall=1,
       rh=0.85, model="loglinear", model.control=list(beta=1.1, sig2=0, ph=1),
       algo="Kozak")
Kozak


#########################################################
### Take-none stratum

# As illustrated in the following example (presented in Baillargeon and Rivest 2011), 
# it is sometimes beneficial to include a take-none stratum in the stratified design 
# (possibly with a bias penalty lower than 1).
notn &lt;- strata.LH(x=MRTS, CV=0.1, Ls=3, alloc=c(0.5,0,0.5))
notn
tn1 &lt;- strata.LH(x=MRTS, CV=0.1, Ls=3, alloc=c(0.5,0,0.5), takenone=1)
tn1
tn0.5 &lt;- strata.LH(x=MRTS, CV=0.1, Ls=3, alloc=c(0.5,0,0.5), takenone=1, bias.penalty=0.5)
tn0.5

# Note: Sethi does not converge here. This occurs often with a take-none stratum.
tn1.Sethi &lt;- strata.LH(x=MRTS, CV=0.1, Ls=3, alloc=c(0.5,0,0.5), takenone=1, algo="Sethi")
tn1.Sethi


#########################################################
### Automatic detection of a take-all stratum

# # As in the following example, a beneficial take-all stratum is not always detected 
# # by the algorithm. Therefore, it is often a good idea to obtain a stratified design
# # with and without a take-all stratum and to compare the results.
# sans&lt;-strata.LH(x=UScities, n=300, Ls=3, alloc=c(0.35,0.35,0), takeall=0,
#       model="loglinear", model.control=list(beta=0.9, sig2=0, ph=1),
#       algo.control=list(trymany=FALSE))
# sans
# avec&lt;-strata.LH(x=UScities, n=300, Ls=3, alloc=c(0.35,0.35,0), takeall=1,
#       model="loglinear", model.control=list(beta=0.9,sig2=0,ph=1),
#       algo.control=list(trymany=FALSE))
# avec
# # We see that for the target sample size, the anticipated CV is 17% lower with a 
# # take-all stratum (0.01081053 vs 0.009002313).


#########################################################
### Models for the discrepancy between Y and X

# LOGLINEAR MODEL WITH MORTALITY: see help(Sweden)

# HETEROSCEDASTIC LINEAR MODEL:  We fix gamma=2.
beta.lin &lt;- mean(Sweden$RMT85/Sweden$REV84)
sig2.lin &lt;- var(Sweden$RMT85/Sweden$REV84)
strata.LH(x=Sweden$REV84, CV=0.05, Ls=5, alloc=c(0.5,0,0.5), takeall=1,
          model="linear", model.control=list(beta=beta.lin, sig2=sig2.lin, gamma=2),
          algo="Kozak")
# Verification of equation 3.6 of Rivest (2002)
beta.log &lt;- 1
sig2.log &lt;- log(1+sig2.lin/beta.lin^2)
strata.LH(x=Sweden$REV84, CV=0.05, Ls=5, alloc=c(0.5,0,0.5), takeall=1,
          model="loglinear", model.control=list(beta=beta.log, sig2=sig2.log, ph=1),
          algo="Kozak")
# The two models give the same stratified design.

# RANDOM REPLACEMENT MODEL: example in Rivest (1999)
strata.LH(x=Sweden$REV84, CV=0.05, Ls=5, alloc=c(0.5,0,0.5), takeall=1,
       model="none", algo="Sethi")     # Table 1 with a different rounding of the nh's
e0 &lt;- strata.LH(x=Sweden$REV84, CV=0.05, Ls=5, alloc=c(0.5,0,0.5), takeall=1,
       model="none", algo="Kozak")
e0                                    # Better than Sethi
var.strata(e0, y=Sweden$RMT85)
e0.001 &lt;- strata.LH(x=Sweden$REV84, CV=0.05, Ls=5, alloc=c(0.5,0,0.5), takeall=1,
          model="random", model.control=list(epsilon=0.011), algo="Kozak")
e0.001                          # Table 2 part 3 with a different rounding of the nh's
var.strata(e0.001 ,y=Sweden$RMT85)

</code></pre>

<hr>
<h2 id='strata.rule'> Non-Iterative Methods of Strata Construction </h2><span id='topic+strata.cumrootf'></span><span id='topic+strata.geo'></span>

<h3>Description</h3>

<p>These functions first determine boundaries to stratify a population. Then, in a second independent step, the sample sizes are calculated given a CV or the CV is computed given the total sample size. The function <code>strata.cumrootf</code> uses the cumulative root frequency method by Dalenius and Hodges (1959) and <code>strata.geo</code> uses the geometric method by Gunning and Horgan (2004). A model can be specified for the relationship between the stratification variable <code class="reqn">X</code> and the survey variable <code class="reqn">Y</code>, but this model has no impact on the first step of boundary determination. It only influences the calculation of the n or of the CV by the use of anticipated means and variances of <code class="reqn">Y</code> instead of the empirical means and variances of <code class="reqn">X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strata.cumrootf(x, n = NULL, CV = NULL, Ls = 3, certain = NULL, 
       alloc = list(q1 = 0.5, q2 = 0, q3 = 0.5), rh = rep(1, Ls), 
       model = c("none", "loglinear", "linear", "random"),
       model.control = list(), nclass = NULL)

strata.geo(x, n = NULL, CV = NULL, Ls = 3, certain=NULL,
       alloc = list(q1 = 0.5, q2 = 0, q3 = 0.5), rh = rep(1, Ls),
       model = c("none", "loglinear", "linear", "random"),
       model.control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strata.rule_+3A_x">x</code></td>
<td>
<p> A vector containing the values of the stratification variable <code class="reqn">X</code> for every unit in the population. </p>
</td></tr>
<tr><td><code id="strata.rule_+3A_n">n</code></td>
<td>
<p> A numeric: the target sample size. It has no default value. The argument <code>n</code> or the argument <code>CV</code> must be input. </p>
</td></tr>
<tr><td><code id="strata.rule_+3A_cv">CV</code></td>
<td>
<p> A numeric: the target coefficient of variation. It has no default value. The argument <code>CV</code> or the argument <code>n</code> must be input. </p>
</td></tr>
<tr><td><code id="strata.rule_+3A_ls">Ls</code></td>
<td>
<p> A numeric: the number of sampled strata (take-none and certain strata are not counted in <code>Ls</code>, but here no take-none stratum can be added to the stratified design so <code>Ls</code> is in fact always equal to <code class="reqn">L</code>). The default is 3. </p>
</td></tr>
<tr><td><code id="strata.rule_+3A_certain">certain</code></td>
<td>
<p> A vector giving the position, in the vector <code>x</code>, of the units that must be included in the sample (see <code><a href="#topic+stratification-package">stratification-package</a></code>). By default <code>certain</code> is <code>NULL</code>, which means that no units are chosen a priori to be in the sample. </p>
</td></tr>
<tr><td><code id="strata.rule_+3A_alloc">alloc</code></td>
<td>
<p> A list specifying the allocation scheme. The list must contain 3 numerics for the 3 exponents <code>q1</code>, <code>q2</code> and <code>q3</code> in the general allocation scheme (see <code><a href="#topic+stratification-package">stratification-package</a></code>). The default is Neyman allocation (<code>q1</code>=<code>q3</code>=0.5 and <code>q2</code>=0)</p>
</td></tr>
<tr><td><code id="strata.rule_+3A_rh">rh</code></td>
<td>
<p> A vector giving the anticipated response rates in each of the <code>Ls</code> sampled strata. A single number can be given if the rates do not vary among strata. The default is 1 in each stratum. </p>
</td></tr>
<tr><td><code id="strata.rule_+3A_model">model</code></td>
<td>
<p> A character string identifying the model used to describe the discrepancy between the stratification variable <code class="reqn">X</code> and the survey variable <code class="reqn">Y</code>. It can be <code>"none"</code> if one assumes <code class="reqn">Y=X</code>, <code>"loglinear"</code> for the loglinear model with mortality, <code>"linear"</code> for the heteroscedastic linear model or <code>"random"</code> for the random replacement model (see <code><a href="#topic+stratification-package">stratification-package</a></code> for a description of these models). The default is <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="strata.rule_+3A_model.control">model.control</code></td>
<td>
<p> A list of model parameters (see <code><a href="#topic+stratification-package">stratification-package</a></code>). The default values of the parameters correspond to the model <code class="reqn">Y=X</code>. </p>
</td></tr>
<tr><td><code id="strata.rule_+3A_nclass">nclass</code></td>
<td>
<p> A numeric for the cumulative root frequency method only: the number of classes (Dalenius and Hodges 1959). The default (see <b>Details</b>) is <code>min(Ls*15, Nu)</code> where <code>Nu</code> is the number of unique values in the <code>x</code>-vector from which units in the certainty stratum, if any, heve been removed. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The efficiency of the cumulative root frequency method depends on the number of classes <code>nclass</code> (see Dalenius and Hodges (1959) for a description of these classes). However, there is no theory about how to choose the best value for <code>nclass</code> (Hedlin 2000). This is a limit of the method.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>bh</code></td>
<td>
<p>A vector of the <code class="reqn">L-1</code> stratum boundaries proposed by the method.</p>
</td></tr>
<tr><td><code>nclassh</code></td>
<td>
<p> A vector for the cumulative root frequency method only: the number of classes in each stratum (Dalenius and Hodges 1959). </p>
</td></tr>
<tr><td><code>Nh</code></td>
<td>
<p>A vector of length <code class="reqn">L</code> containing the population sizes <code class="reqn">N_h</code>, i.e. the number of units in each stratum.</p>
</td></tr>
<tr><td><code>nh</code></td>
<td>
<p>A vector of length <code class="reqn">L</code> containing the sample sizes <code class="reqn">n_h</code>, i.e. the number of units to sample in each stratum. See <code><a href="#topic+stratification-package">stratification-package</a></code> for information about the rounding used to get these integer values.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The total sample size (<code>sum(nh)</code>).</p>
</td></tr>
<tr><td><code>nhnonint</code></td>
<td>
<p>A vector of length <code class="reqn">L</code> containing the non-integer values of the sample sizes, obtained directly from applying the allocation rule (see <code><a href="#topic+stratification-package">stratification-package</a></code>).</p>
</td></tr>
<tr><td><code>certain.info</code></td>
<td>
<p>A vector giving statistics for the certainty stratum (see <code><a href="#topic+stratification-package">stratification-package</a></code>). It contains <code>Nc</code>, the number of units chosen a priori to be in the sample, and <code>meanc</code>, the anticipated mean of <code class="reqn">Y</code> for these units. </p>
</td></tr>
<tr><td><code>opti.nh</code></td>
<td>
<p>The final value of the criteria to optimize (either the total sample size <code class="reqn">n</code> if a target <code>CV</code> was given or the RRMSE if a target <code>n</code> was given) calculated with the integer stratum sample sizes <code>nh</code>.</p>
</td></tr>
<tr><td><code>opti.nhnonint</code></td>
<td>
<p>The final value of the criteria to optimize (either the total sample size <code class="reqn">n</code> if a target <code>CV</code> was given or the RRMSE if a target <code>n</code> was given) calculated with the non-integer stratum sample sizes <code>nhnonint</code>.</p>
</td></tr>
<tr><td><code>meanh</code></td>
<td>
<p>A vector of length <code class="reqn">L</code> containing the anticipated means of <code class="reqn">Y</code> in each stratum.</p>
</td></tr>
<tr><td><code>varh</code></td>
<td>
<p>A vector of length <code class="reqn">L</code> containing the anticipated variances of <code class="reqn">Y</code> in each stratum.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>A numeric: the anticipated global mean value of <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code>stderr</code></td>
<td>
<p>A numeric: the standard error of the anticipated global mean of <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code>CV</code></td>
<td>
<p>The anticipated coefficient of variation for the mean of <code class="reqn">Y</code>, i.e. <code>stderr</code> divided <code>mean</code>. </p>
</td></tr>
<tr><td><code>stratumID</code></td>
<td>
<p>A factor, having the same length as the input <code>x</code>, which values are either 1, 2, ..., <code class="reqn">L</code> or <code>"certain"</code>. The value <code>"certain"</code> is given to units a priori chosen to be in the sample. This factor identifies, for each observation, the stratum to which it has been assigned.</p>
</td></tr>  
<tr><td><code>takeall</code></td>
<td>
<p>The number of take-all strata in the final solution. Note: It is possible that <code class="reqn">n_h=N_h</code> for non take-all strata because the condition for an automatic addition of a take-all stratum is <code class="reqn">n_h&gt;N_h</code>. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The function call (object of class &quot;call&quot;).</p>
</td></tr>
<tr><td><code>date</code></td>
<td>
<p>A character string that contains the system date and time when the function ended. </p>
</td></tr>
<tr><td><code>args</code></td>
<td>
<p>A list of all the argument values input to the function or set by default. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Sophie Baillargeon <a href="mailto:Sophie.Baillargeon@mat.ulaval.ca">Sophie.Baillargeon@mat.ulaval.ca</a> and<br />
Louis-Paul Rivest <a href="mailto:Louis-Paul.Rivest@mat.ulaval.ca">Louis-Paul.Rivest@mat.ulaval.ca</a> </p>


<h3>References</h3>

<p>Baillargeon, S. and  Rivest L.-P. (2011). The construction of stratified designs in R with the package stratification. <em>Survey Methodology</em>, <b>37</b>(1), 53-65.
</p>
<p>Dalenius, T. and Hodges, J.L., Jr. (1959). Minimum variance stratification. <em>Journal of the American Statistical Association</em>, <b>54</b>, 88-101.
</p>
<p>Gunning, P. and Horgan, J.M. (2004). A new algorithm for the construction of stratum boundaries in skewed populations. <em>Survey Methodology</em>, <b>30</b>(2), 159-166.
</p>
<p>Hedlin, D. (2000). A procedure for stratification by an extended Ekman rule. <em>Journal of Official Statistics</em>, <b>61</b>, 15-29.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+print.strata">print.strata</a></code>, <code><a href="#topic+plot.strata">plot.strata</a></code>, <code><a href="#topic+strata.LH">strata.LH</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example for strata.cumrootf
res &lt;- matrix(NA, nrow=20, ncol=2)
i &lt;- 1
for ( n in seq(100,2000,100)){
    cum &lt;- strata.cumrootf(x=MRTS, CV=0.01, Ls=4, alloc=c(0.5,0,0.5), nclass=n)
    res[i,] &lt;- c(n,cum$n)
    i &lt;- i + 1
}
plot(res, ylab="suggested sample size n", xlab="number of classes", main=expression(
     paste("Example of the effect of nclass on n for the cum",sqrt(f)," method")))

### Example for strata.geo
strata.geo(x=Sweden$REV84, CV=0.05, Ls=5, alloc=c(0.35,0.35,0), model="none")
strata.geo(x=Sweden$REV84, CV=0.05, Ls=5, alloc=c(0.35,0.35,0), model="loglinear",
       model.control=list(beta=1.058355, sig2=0.06593083, ph=1))
strata.geo(x=Sweden$REV84, CV=0.05, Ls=5, alloc=c(0.35,0.35,0), rh=0.85,
       model="loglinear", model.control=list(beta=1.058355, sig2=0.06593083, ph=1))
# When non-response or a model is added, the stratum boundaries do not change, 
# only the nh's do.

### Exemple of how a certainty stratum can be usefull with these methods
strata.cumrootf(x=Sweden$REV84, CV=0.05, Ls=4, alloc=c(0.35,0.35,0), model="none",
                nclass=50)
strata.cumrootf(x=sort(Sweden$REV84), CV=0.05, Ls=4, alloc=c(0.35,0.35,0), 
                certain=282:284, model="none", nclass=50)
# The certainty stratum is used here to ensure that the three large units in the
# Sweden$REV84 population are in the sample, since no take-all stratum can be forced 
# in the stratified design with the cumulative root frequency or geometric method.
# We see that this allows to reduce by more than half the suggested sample size n
# (47 vs 19). This example was presented in Baillargeon and Rivest (2011). 

</code></pre>

<hr>
<h2 id='strata.tool'> Functions to Visualize Stratified Designs </h2><span id='topic+print.strata'></span><span id='topic+plot.strata'></span>

<h3>Description</h3>

<p><code>print.strata</code> prints a &quot;strata&quot; object, presenting the stratification information into a table.<br />
</p>
<p><code>plot.strata</code> produces a histogram of the stratification variable <code class="reqn">X</code>, in which the stratification boundaries are drawn. A table with the <code>Nh</code> and <code>nh</code> values is also added at the top of the plot.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'strata'
print(x, ...)

## S3 method for class 'strata'
plot(x, logscale = FALSE, drop = 0, main = 
   paste("Graphical Representation of the Stratified Design", xname), 
   xlab, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strata.tool_+3A_x">x</code></td>
<td>
<p> An object of class &quot;strata&quot; to print or to plot. </p>
</td></tr>
<tr><td><code id="strata.tool_+3A_logscale">logscale</code></td>
<td>
<p> A logical indicating whether the <code class="reqn">X</code> axis should be represented on the log scale or not. The default is FALSE.</p>
</td></tr>
<tr><td><code id="strata.tool_+3A_drop">drop</code></td>
<td>
<p> A integer indicating how many of the largest values of <code class="reqn">X</code> should be omitted in the plot. This argument is useful when some large values of <code class="reqn">X</code> stretch the <code class="reqn">X</code> range too much. </p>
</td></tr>
<tr><td><code id="strata.tool_+3A_main">main</code></td>
<td>
<p> A character string giving the title of the plot. </p>
</td></tr>
<tr><td><code id="strata.tool_+3A_xlab">xlab</code></td>
<td>
<p> A character string naming the <code class="reqn">X</code> axis. </p>
</td></tr>
<tr><td><code id="strata.tool_+3A_...">...</code></td>
<td>
<p> Additional arguments affecting the print or the plot produced. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>When the object of class &quot;strata&quot; contains a certainty stratum, <code>plot.strata</code> removes from the data the units in this stratum before generating the histogram.</p>


<h3>Author(s)</h3>

<p> Sophie Baillargeon <a href="mailto:Sophie.Baillargeon@mat.ulaval.ca">Sophie.Baillargeon@mat.ulaval.ca</a> and<br />
Louis-Paul Rivest <a href="mailto:Louis-Paul.Rivest@mat.ulaval.ca">Louis-Paul.Rivest@mat.ulaval.ca</a> </p>


<h3>References</h3>

<p>Baillargeon, S. and  Rivest L.-P. (2011). The construction of stratified designs in R with the package stratification. <em>Survey Methodology</em>, <b>37</b>(1), 53-65.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+strata.bh">strata.bh</a></code>, <code><a href="#topic+strata.cumrootf">strata.cumrootf</a></code>, <code><a href="#topic+strata.geo">strata.geo</a></code>, <code><a href="#topic+strata.LH">strata.LH</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>cumrootf &lt;- strata.cumrootf(x=MRTS, CV=0.01, Ls=4, alloc=c(0.5,0,0.5), nclass=500)
print(cumrootf)
plot(cumrootf)
plot(cumrootf, drop=5)
plot(cumrootf, logscale=TRUE)
geo &lt;- strata.geo(x=MRTS, CV=0.01, Ls=4, alloc=c(0.5,0,0.5))
print(geo)
plot(geo, logscale=TRUE)
# The geometric method does not perform well because of some small units
LH &lt;- strata.LH(x=MRTS, CV=0.01, Ls=4, alloc=c(0.5,0,0.5), takeall=1)
print(LH)
plot(LH, logscale=TRUE)
</code></pre>

<hr>
<h2 id='Sweden'> The MU284 Population of Sweden Municipalities from Sarndal et al. (1992) </h2><span id='topic+Sweden'></span>

<h3>Description</h3>

<p>This data set comes from Sarndal et al.'s book (1992), Appendix B. It contains different variables that describe 284 municipalities in Sweden.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sweden</code></pre>


<h3>Format</h3>

<p>A data frame with 284 observations on the following 11 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>Identifier running from 1 to 284</p>
</dd>
<dt><code>P85</code></dt><dd><p>1985 population (in thousands)</p>
</dd>
<dt><code>P75</code></dt><dd><p>1975 population (in thousands)</p>
</dd>
<dt><code>RMT85</code></dt><dd><p>Revenues from the 1985 municipal taxation (in millions of kronor)</p>
</dd>
<dt><code>CS82</code></dt><dd><p>Number of Conservative seats in municipal council</p>
</dd>
<dt><code>SS82</code></dt><dd><p>Number of Social-Democratic seats in municipal council</p>
</dd>
<dt><code>S82</code></dt><dd><p>Total number of seats in municipal council</p>
</dd>
<dt><code>ME84</code></dt><dd><p>Number of municipal employees in 1984</p>
</dd>
<dt><code>REV84</code></dt><dd><p>Real estate values according to 1984 assessment (in millions of kronor)</p>
</dd>
<dt><code>REG</code></dt><dd><p>Geographic region indicator</p>
</dd>
<dt><code>CL</code></dt><dd><p>Cluster indicator (a cluster consists of a set of neighboring municipalities)</p>
</dd>
</dl>



<h3>Details</h3>

<p>In this package, <code>REV84</code> is used as a stratification variable and <code>RMT85</code> as a survey variable.
</p>


<h3>Source</h3>

<p>Sarndal, C. E., Swensson, B. and Wretman, J. (1992). <em>Model Assisted Survey Sampling</em>. Springer Verlag, New York.
</p>


<h3>References</h3>

<p>Rivest, L.-P. (2002). A generalization of the Lavallee and Hidiroglou algorithm for stratification in business surveys. <em>Survey Methodology</em>, <b>28</b>(2), 191-198.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- Sweden$REV84
Y &lt;- Sweden$RMT85

# Study of the relationship between X and Y
plot(log(X), log(Y))
# Extreme values are omitted for a more robust estimation
keep &lt;- X/Y&gt;quantile(X/Y,0.03)&amp;X/Y&lt;quantile(X/Y,0.97)
plot(log(X)[keep], log(Y)[keep])
reg&lt;-lm( log(Y)[keep]~log(X)[keep] )
summary(reg)

# Stratification assuming X=Y
nomodel &lt;- strata.LH(x=X, CV=0.05, Ls=3, alloc=c(0.5,0,0.5), takeall=1, model="none")
nomodel
var.strata(nomodel, y=Y) # The target CV is not reached

# Stratification taking into account a loglinear model between X and Y, 
# using the estimated parameters values
model &lt;- strata.LH(x=X, CV=0.05, Ls=3, alloc=c(0.5,0,0.5), takeall=1, model="loglinear",
        model.control=list(beta=reg$coef[2], sig2=summary(reg)$sigma^2, ph=1))
model
var.strata(model, y=Y) # The target CV is reached
</code></pre>

<hr>
<h2 id='var.strata'> Anticipated Variances and RRMSE from a Stratified Design for a Survey Variable Y </h2><span id='topic+var.strata'></span><span id='topic+print.var.strata'></span>

<h3>Description</h3>

<p><code>var.strata</code> calculates the anticipated means, variances and relative root mean squared error (RRMSE) obtained when applying a stratified design to a survey variable <code class="reqn">Y</code>. The variable <code class="reqn">Y</code> can be input or it can be defined from <code class="reqn">X</code> by a specified loglinear with mortality, heteroscedastic linear or random replacement model.<br />
</p>
<p><code>print.var.strata</code> prints a &quot;var.strata&quot; object, presenting the stratification information into a table. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.strata(strata, y = NULL, rh = strata$args$rh, rh.postcorr = 
           FALSE, model = c("none", "loglinear", "linear", "random"), 
           model.control = list())

## S3 method for class 'var.strata'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var.strata_+3A_strata">strata</code></td>
<td>
<p> An object of class &quot;strata&quot;, which represents a stratified design. </p>
</td></tr>
<tr><td><code id="var.strata_+3A_y">y</code></td>
<td>
<p> A vector containing the values of the survey variable <code class="reqn">Y</code> for every unit of the population, respecting the order of the units in the <code>x</code>-vector used to create <code>strata</code>. The default is that <code class="reqn">Y</code> is not given. </p>
</td></tr>
<tr><td><code id="var.strata_+3A_rh">rh</code></td>
<td>
<p> A vector giving the anticipated response rates in each of the <code>Ls</code> sampled strata. A single number can be given if the rates do not vary among strata. The default is to use the rates given in the <code>strata.bh</code> object. </p>
</td></tr>
<tr><td><code id="var.strata_+3A_rh.postcorr">rh.postcorr</code></td>
<td>
<p> A logical. If TRUE, a posterior correction for non-response is applied. This correction takes into account the non-response in the <code>strata.bh</code> object. It is only available when the stratified design <code>strata</code> had a target CV. The default is FALSE, i.e. no posterior correction is made (see <b>Details</b>). </p>
</td></tr>
<tr><td><code id="var.strata_+3A_model">model</code></td>
<td>
<p> A character string identifying the model used to describe the discrepancy between the stratification variable <code class="reqn">X</code> and the survey variable <code class="reqn">Y</code>. It can be <code>"none"</code> if one assumes <code class="reqn">Y=X</code>, <code>"loglinear"</code> for the loglinear model with mortality, <code>"linear"</code> for the heteroscedastic linear model or <code>"random"</code> for the random replacement model (see <code><a href="#topic+stratification-package">stratification-package</a></code> for a description of these models). The default is <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="var.strata_+3A_model.control">model.control</code></td>
<td>
<p> A list of model parameters (see <code><a href="#topic+stratification-package">stratification-package</a></code>). The default values of the parameters correspond to the model <code class="reqn">Y=X</code>. </p>
</td></tr>
<tr><td><code id="var.strata_+3A_x">x</code></td>
<td>
<p> An object of class &quot;var.strata&quot; to print. </p>
</td></tr>
<tr><td><code id="var.strata_+3A_...">...</code></td>
<td>
<p> Additional arguments affecting the print produced. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>POSTERIOR CORRECTION FOR NON-RESPONSE (with a target CV only<br />
</p>
<p>The optional posterior correction for non-response is done as follows. For each take-some stratum, <code class="reqn">n_h</code> is increased if the input <code>rh</code> is lower than the anticipated response rate in the <code>strata.bh</code> object, and <code class="reqn">n_h</code> is decreased if the input <code>rh</code> is higher than the anticipated response rate given when creating the <code>strata.bh</code> object. The modification of <code class="reqn">n_h</code> is done by multiplying it by <code>strata$args$rh/rh</code>.<br />
</p>
<p>The weakness of this posterior correction is that it cannot take into account non-response in a take-all stratum. In that stratum, <code class="reqn">n_h</code> cannot be increased since it is equal to <code class="reqn">N_h</code>. To correctly account for non-response in a take-all stratum, the boundary of the stratum has to be lowered. This is what the generalized Lavallee-Hidiroglou method does (<code><a href="#topic+strata.LH">strata.LH</a></code>).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>nh</code></td>
<td>
<p>A vector of length <code>L</code> containing the integer sample sizes <code class="reqn">n_h</code>, i.e. the number of units to sample in each stratum. This vector can be different than <code>strata$nh</code> if <code>rh.postcorr=TRUE</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The total sample size (<code>sum(nh)</code>). This number can be different than <code>strata$n</code> if <code>rh.postcorr=TRUE</code>.</p>
</td></tr>
<tr><td><code>nhnonint</code></td>
<td>
<p>A vector of length <code class="reqn">L</code> containing the non-integer values of the sample sizes. This vector can be different than <code>strata$nhnonint</code> if <code>rh.postcorr=TRUE</code>.</p>
</td></tr>
<tr><td><code>certain.info</code></td>
<td>
<p>A vector giving statistics for the certainty stratum (see <code><a href="#topic+stratification-package">stratification-package</a></code>). It contains <code>Nc</code>, the number of units chosen a priori to be in the sample, and <code>meanc</code>, the anticipated mean of <code class="reqn">Y</code> for these units. </p>
</td></tr>
<tr><td><code>meanh</code></td>
<td>
<p>A vector of length <code class="reqn">L</code> containing the anticipated means of <code class="reqn">Y</code> in each stratum.</p>
</td></tr>
<tr><td><code>varh</code></td>
<td>
<p>A vector of length <code class="reqn">L</code> containing the anticipated variances of <code class="reqn">Y</code> in each stratum.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>A numeric: the anticipated global mean value of <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code>RMSE</code></td>
<td>
<p>A numeric: the root mean squared error (or standard error if <code>strata$args$takenone</code>=0) of the anticipated global mean of <code class="reqn">Y</code>. This is defined as the squared root of: (<code>bias.penalty</code> x bias of the mean)^2 + variance of the mean.</p>
</td></tr>
<tr><td><code>RRMSE</code></td>
<td>
<p>A numeric: the anticipated relative root mean squared error (or coefficient of variation if  <code>strata$args$takenone</code>=0) for the mean of <code class="reqn">Y</code>, i.e. <code>RMSE</code> divided by <code>mean</code>. </p>
</td></tr>
<tr><td><code>relativebias</code></td>
<td>
<p>A numeric: the anticipated relative bias of the estimator, i.e. (<code>bias.penalty</code> x bias of the mean) divided by <code>mean</code>. If  <code>strata$args$takenone</code>=0, this numeric is zero. </p>
</td></tr>
<tr><td><code>propbiasMSE</code></td>
<td>
<p>A numeric: the proportion of the MSE attributable to the bias of the estimator, i.e. (<code>bias.penalty</code> x bias of the mean)^2 divided by the MSE of the <code>mean</code>. If  <code>strata$args$takenone</code>=0, this numeric is zero.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The function call (object of class &quot;call&quot;).</p>
</td></tr>
<tr><td><code>date</code></td>
<td>
<p>A character string that contains the system date and time when the function ended. </p>
</td></tr>
<tr><td><code>args</code></td>
<td>
<p>A list of all the arguments input to the function or used by default. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Sophie Baillargeon <a href="mailto:Sophie.Baillargeon@mat.ulaval.ca">Sophie.Baillargeon@mat.ulaval.ca</a> and<br />
Louis-Paul Rivest <a href="mailto:Louis-Paul.Rivest@mat.ulaval.ca">Louis-Paul.Rivest@mat.ulaval.ca</a> </p>


<h3>References</h3>

<p>Baillargeon, S. and  Rivest L.-P. (2011). The construction of stratified designs in R with the package stratification. <em>Survey Methodology</em>, <b>37</b>(1), 53-65.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+strata.bh">strata.bh</a></code>, <code><a href="#topic+strata.cumrootf">strata.cumrootf</a></code>, <code><a href="#topic+strata.geo">strata.geo</a></code>, <code><a href="#topic+strata.LH">strata.LH</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>nomodel &lt;- strata.LH(x=Sweden$REV84, CV=0.05, Ls=3, alloc=c(0.5,0,0.5),
          takeall=1, model="none")
# We can give a vector of the Y values for every unit in the population
var.strata(nomodel, y=Sweden$RMT85) 
# Or specify a model between X and Y
var.strata(nomodel, model="loglinear", model.control=list(beta=1.058355,
           sig2=0.06593083, ph=1))
# Compared to taking into account the model in the optimization
model &lt;- strata.LH(x=Sweden$REV84, CV=0.05, Ls=3, alloc=c(0.5,0,0.5),
         takeall=1, model="loglinear", model.control=list(beta=1.058355,
		     sig2=0.06593083, ph=1))
var.strata(model, y=Sweden$RMT85)

### Examples of posterior correction for non-response
LH &lt;- strata.LH(x=MRTS, CV=0.01, Ls=4, alloc=c(0.5,0,0.5), takeall=1)
LH
# Without non-response in the take-all strata
var.strata(LH, rh.postcorr=TRUE, rh=c(0.85,0.9,0.9,1))
strata.LH(x=MRTS, CV=0.01, Ls=4, alloc=c(0.5,0,0.5), takeall=1, rh=c(0.85,0.9,0.9,1))
# With non-response in the take-all strata
var.strata(LH, rh.postcorr=TRUE, rh=0.9)
strata.LH(x=MRTS, CV=0.01, Ls=4, alloc=c(0.5,0,0.5), takeall=1, rh=0.9)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
