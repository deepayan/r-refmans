<!DOCTYPE html><html><head><title>Help for package satellite</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {satellite}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#satellite-package'><p>Smorgasboard for remote sensing functions.</p></a></li>
<li><a href='#alignGeometry'><p>Align raster geometry between two data sets</p></a></li>
<li><a href='#brick'><p>Convert selected layers of a Satellite object to a RasterBrick</p></a></li>
<li><a href='#calcAtmosCorr'><p>Atmospheric correction of remote sensing data</p></a></li>
<li><a href='#calcDODN'><p>Compile dark object DN for given sensor band</p></a></li>
<li><a href='#calcEarthSunDist'><p>Compute earth-sun distance based on day of the year</p></a></li>
<li><a href='#calcPathRadDOS'><p>Compute path radiance based on the dark object method</p></a></li>
<li><a href='#calcTOAIrradModel'><p>Compute top of atmosphere solar irradiance for sensor bands using LUTs</p></a></li>
<li><a href='#calcTOAIrradRadRef'><p>Compute top of atmosphere solar irradiance using radiation vs. reflection</p></a></li>
<li><a href='#calcTOAIrradTable'><p>Get top of atmosphere solar irradiance using readily tabulated values</p></a></li>
<li><a href='#calcTopoCorr'><p>Correct for topographic effects.</p></a></li>
<li><a href='#compFilePathLandsat'><p>Get filename, bands and metadata file for Landsat 7 and 8 standard 1B/T format</p></a></li>
<li><a href='#compMetaLandsat'><p>Get calibration information from Landsat 8 standard level 1B/T filename</p></a></li>
<li><a href='#convRad2BT'><p>Convert a band's scaled counts to brightness temperature</p></a></li>
<li><a href='#convRad2Ref'><p>Convert a band's scaled counts or radiance values to reflectance</p></a></li>
<li><a href='#convRef2RadLinear'><p>Convert reflectance to radiance using linear function coefficients</p></a></li>
<li><a href='#convSC2Rad'><p>Convert a band's scaled counts to radiance</p></a></li>
<li><a href='#convSC2Ref'><p>Convert a band's scaled counts or radiance values to reflectance</p></a></li>
<li><a href='#crop'><p>Crop Satellite object</p></a></li>
<li><a href='#demTools'><p>Compute terrain characteristics from digital elevation models</p></a></li>
<li><a href='#extend'><p>Extend a Satellite object</p></a></li>
<li><a href='#l7'><p>Landsat 7 sample data</p></a></li>
<li><a href='#l8'><p>Landsat 8 sample data</p></a></li>
<li><a href='#lutInfo'><p>Get or access internal LUT values used by various functions</p></a></li>
<li><a href='#maskInvarFeatures'><p>Identify pseudo-invariant features from a satellite scene</p></a></li>
<li><a href='#names'><p>Get/set Satellite data layer names</p></a></li>
<li><a href='#plot'><p>Plot a Satellite object</p></a></li>
<li><a href='#satellite'><p>Create a Satellite object</p></a></li>
<li><a href='#Satellite-class'><p>An S4 class to represent a complete satellite dataset</p></a></li>
<li><a href='#SatelliteInfo-class'><p>An S4 class to represent a satellite data file</p></a></li>
<li><a href='#SatelliteLayers-class'><p>An S4 class to represent satellite data</p></a></li>
<li><a href='#SatelliteLog-class'><p>An S4 class to represent satellite log data</p></a></li>
<li><a href='#SatelliteMetaData-class'><p>An S4 class to represent satellite metadata</p></a></li>
<li><a href='#satInfo'><p>Get or access Satellite object information used by various functions</p></a></li>
<li><a href='#stack'><p>Convert selected layers of a Satellite object to a RasterStack</p></a></li>
<li><a href='#subset'><p>Subset of Satellite object data layers</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Handling and Manipulating Remote Sensing Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Nauss, Hanna Meyer, Tim Appelhans, Florian Detsch</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Florian Detsch &lt;fdetsch@web.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Herein, we provide a broad variety of functions which are useful
    for handling, manipulating, and visualizing satellite-based remote sensing 
    data. These operations range from mere data import and layer handling (eg 
    subsetting), over Raster* typical data wrangling (eg crop, extend), to more 
    sophisticated (pre-)processing tasks typically applied to satellite imagery 
    (eg atmospheric and topographic correction). This functionality is 
    complemented by a full access to the satellite layers' metadata at any 
    stage and the documentation of performed actions in a separate log file. 
    Currently available sensors include Landsat 4-5 (TM), 7 (ETM+), and 8 
    (OLI/TIRS Combined), and additional compatibility is ensured for the Landsat 
    Global Land Survey data set. </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/environmentalinformatics-marburg/satellite">https://github.com/environmentalinformatics-marburg/satellite</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/environmentalinformatics-marburg/satellite/issues">https://github.com/environmentalinformatics-marburg/satellite/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), raster, methods, utils, stats, grDevices,
graphics</td>
</tr>
<tr>
<td>Imports:</td>
<td>plyr, Rcpp (&ge; 0.10.3), terra, tools, stats4</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>devtools, knitr, testthat, rmarkdown</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-10 09:41:53 UTC; tim</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-10 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='satellite-package'>Smorgasboard for remote sensing functions.</h2><span id='topic+satellite-package'></span><span id='topic+satellitepackage'></span>

<h3>Description</h3>

<p>Smorgasbord for remote sensing functions
</p>


<h3>Details</h3>

<p>The package provides a variety of functions which are useful for 
handling, manipulating and visualizing remote sensing data.
</p>


<h3>Author(s)</h3>

<p>Thomas Nauss, Hanna Meyer, Florian Detsch, Tim Appelhans <br />
<br />
<em>Maintainer:</em> Florian Detsch <a href="mailto:fdetsch@web.de">fdetsch@web.de</a>
</p>


<h3>References</h3>

<p>Some functions are taken and/or adopted from Sarah C. Goslee 
(2011). Analyzing Remote Sensing Data in R: The landsat Package. Journal of 
Statistical Software, 43(4), 1-25, <a href="https://doi.org/10.18637/jss.v043.i04">doi:10.18637/jss.v043.i04</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/environmentalinformatics-marburg/satellite">https://github.com/environmentalinformatics-marburg/satellite</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/environmentalinformatics-marburg/satellite/issues">https://github.com/environmentalinformatics-marburg/satellite/issues</a>
</p>
</li></ul>


<hr>
<h2 id='alignGeometry'>Align raster geometry between two data sets</h2><span id='topic+alignGeometry'></span><span id='topic+alignGeometry+2CSatellite-method'></span><span id='topic+alignGeometry+2CRasterStack-method'></span><span id='topic+alignGeometry+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>Align raster data by bringing it in the same geometry and extent.
If the data set is not in the same projection as the template, the alignment
will be computed by reprojection. If the data has already the same
projection, the data set will be cropped and aggregated prior to resampling
in order to reduce computation time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Satellite'
alignGeometry(x, template, band_codes, type, method = c("bilinear", "ngb"))

## S4 method for signature 'RasterStack'
alignGeometry(x, template, method = c("bilinear", "ngb"))

## S4 method for signature 'RasterLayer'
alignGeometry(x, template, method = c("bilinear", "ngb"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alignGeometry_+3A_x">x</code></td>
<td>
<p>Satellite or Raster* object to be resampled.</p>
</td></tr>
<tr><td><code id="alignGeometry_+3A_template">template</code></td>
<td>
<p>Raster* or spatial data set from which geometry can be 
extracted.</p>
</td></tr>
<tr><td><code id="alignGeometry_+3A_band_codes">band_codes</code></td>
<td>
<p>Band ID(s) to be resampled. If not supplied and type is 
not given, too, all bands will be considered for resampling.</p>
</td></tr>
<tr><td><code id="alignGeometry_+3A_type">type</code></td>
<td>
<p>Type of bands (e.g. VIS, NIR) which should be considered. If not 
supplied, all types will be processed depending and bands to be processed can
be defined by band_codes.</p>
</td></tr>
<tr><td><code id="alignGeometry_+3A_method">method</code></td>
<td>
<p>Method for resampling; &quot;bilinear&quot; for bilinear interpolation 
(default) or &quot;ngb&quot; for nearest neighbor interpolation. See e.g. 
<code><a href="raster.html#topic+resample">resample</a></code>, <code><a href="raster.html#topic+projectRaster">projectRaster</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Satellite object with aligned geometries.
</p>
<p>raster::RasterStack object with aligned layers
</p>
<p>raster::RasterLayer object with aligned layer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("testdata/LC8", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC8*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)

alignGeometry(sat, template = getSatDataLayer(sat, "B008n"), 
               band_codes = "B001n")
</code></pre>

<hr>
<h2 id='brick'>Convert selected layers of a Satellite object to a RasterBrick</h2><span id='topic+brick'></span><span id='topic+brick+2CSatellite-method'></span>

<h3>Description</h3>

<p>Convert selected layers of a Satellite object to a RasterBrick
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Satellite'
brick(x, layer = names(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brick_+3A_x">x</code></td>
<td>
<p>an object of class 'Satellite'</p>
</td></tr>
<tr><td><code id="brick_+3A_layer">layer</code></td>
<td>
<p>character vector (bcde codes) or integer vector (index) of 
the layers to be stacked</p>
</td></tr>
<tr><td><code id="brick_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code><a href="#topic+brick">brick</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)

brck &lt;- brick(sat, c("B001n", "B002n", "B003n"))
brck

</code></pre>

<hr>
<h2 id='calcAtmosCorr'>Atmospheric correction of remote sensing data</h2><span id='topic+calcAtmosCorr'></span><span id='topic+calcAtmosCorr+2CSatellite-method'></span><span id='topic+calcAtmosCorr+2CRasterStack-method'></span><span id='topic+calcAtmosCorr+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>The function computes an atmospheric scattering correction and converts
the sensors digital numbers to reflectances using
</p>

<ul>
<li><p> absolute radiance correction
</p>
</li>
<li><p> DOS2: a dark object substraction model by Chavez (1996)
</p>
</li>
<li><p> DOS4: a dark object substratcion model by Moran et al. (1992)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Satellite'
calcAtmosCorr(x, model = c("DOS2", "DOS4"), esun_method = "RadRef")

## S4 method for signature 'RasterStack'
calcAtmosCorr(x, path_rad, esun, szen, model = c("DOS2", "DOS4"))

## S4 method for signature 'RasterLayer'
calcAtmosCorr(x, path_rad, esun, szen, model = c("DOS2", "DOS4"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcAtmosCorr_+3A_x">x</code></td>
<td>
<p>Satellite or Raster* object providing the radiance at the sensor.</p>
</td></tr>
<tr><td><code id="calcAtmosCorr_+3A_model">model</code></td>
<td>
<p>Model to be used to correct for 1% scattering (DOS2, DOS4).</p>
</td></tr>
<tr><td><code id="calcAtmosCorr_+3A_esun_method">esun_method</code></td>
<td>
<p>If x is a Satellite object, name of the method to be used 
to compute <code>esun</code> using one of <code><a href="#topic+calcTOAIrradRadRef">calcTOAIrradRadRef</a></code> 
(&quot;RadRef&quot;), <code><a href="#topic+calcTOAIrradTable">calcTOAIrradTable</a></code> (&quot;Table&quot;) or 
<code><a href="#topic+calcTOAIrradModel">calcTOAIrradModel</a></code> (&quot;Model&quot;).</p>
</td></tr>
<tr><td><code id="calcAtmosCorr_+3A_path_rad">path_rad</code></td>
<td>
<p>Path radiance, e.g. returned from 
<code><a href="#topic+calcPathRadDOS">calcPathRadDOS</a></code>.</p>
</td></tr>
<tr><td><code id="calcAtmosCorr_+3A_esun">esun</code></td>
<td>
<p>Actual (i.e. non-normalized) TOA solar irradiance, e.g. returned 
from <code><a href="#topic+calcTOAIrradRadRef">calcTOAIrradRadRef</a></code>, <code><a href="#topic+calcTOAIrradTable">calcTOAIrradTable</a></code> 
or <code><a href="#topic+calcTOAIrradModel">calcTOAIrradModel</a></code>.</p>
</td></tr>
<tr><td><code id="calcAtmosCorr_+3A_szen">szen</code></td>
<td>
<p>Sun zenith angle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a Satellite object is passed to the function, and if the required
pre-processing has not been performed already, the path radiance is computed 
based on a dark object's scaled count value using 
<code><a href="#topic+calcPathRadDOS">calcPathRadDOS</a></code> which will also take care of the TOA solar 
irradiance by calling <code><a href="#topic+calcTOAIrradModel">calcTOAIrradModel</a></code>, 
<code><a href="#topic+calcTOAIrradRadRef">calcTOAIrradRadRef</a></code> or <code><a href="#topic+calcTOAIrradTable">calcTOAIrradTable</a></code> 
(depending on <code>esun_method</code>) if necessary. The bands' scaled counts are 
converted to radiance using <code><a href="#topic+convSC2Rad">convSC2Rad</a></code>.
</p>
<p>The radiometric correction is based on a dark object approach using
either the DOS2 (Chavez 1996) or DOS4 (Moran et al. 1992) model.
</p>
<p>The minimum reflectance values for the dark object are identified using the
approximation of Chavez (1988, see <code><a href="#topic+calcPathRadDOS">calcPathRadDOS</a></code> for details).
</p>
<p>The estimated values of the solar irradiance required for the path radiance
can be computed by one of <code><a href="#topic+calcTOAIrradTable">calcTOAIrradTable</a></code> which is used to
get readily published values of ESun, <code><a href="#topic+calcTOAIrradRadRef">calcTOAIrradRadRef</a></code> which 
computes ESun based on the actual radiance and reflectance in the scene, or  
<code><a href="#topic+calcTOAIrradModel">calcTOAIrradModel</a></code> which computes ESun based on  look-up tables 
for the sensor's relative spectral response and solar irradiation spectral data.
</p>
<p>The atmospheric transmittance towards the sensor (Tv) is approximated by 
1.0 (DOS2, Chavez 1996) or Rayleigh scattering (DOS4, Moran et al. 1992).
</p>
<p>The atmospheric transmittance from the sun (Tz) is approximated by the 
cosine of the sun zenith angle (DOS2, Chavez 1996) or again using Rayleigh
scattering (DOS4, Moran et al. 1992).
</p>
<p>The downwelling diffuse irradiance is approximated by 0.0 (DOS2, Chavez 1996)
or the hemispherical integral of the path radiance (DOS4, Moran et al. 1992).
</p>
<p>Equations are taken from Song et al. (2001).
</p>


<h3>Value</h3>

<p>Satellite object with added atmospheric corrected layers
</p>
<p>raster::RasterStack object with atmospheric corrected layers
</p>
<p>raster::RasterLayer object with atmospheric corrected layer
</p>


<h3>References</h3>

<p>Chavez Jr PS (1988) An improved dark-object subtraction technique 
for atmospheric scattering correction of multispectral data. Remote Sensing 
of Environment 24/3, <a href="https://doi.org/10.1016/0034-4257%2888%2990019-3">doi:10.1016/0034-4257(88)90019-3</a>.
</p>
<p>Chavez Jr PS (1996) Image-based atmospheric corrections revisited and
improved. Photogrammetric Engineering and Remote Sensing 62/9,
available online at 
<a href="https://www.researchgate.net/publication/236769129_Image-Based_Atmospheric_Corrections_-_Revisited_and_Improved">https://www.researchgate.net/publication/236769129_Image-Based_Atmospheric_Corrections_-_Revisited_and_Improved</a>
</p>
<p>Goslee SC (2011) Analyzing Remote Sensing Data in R: The landsat 
Package. Journal of Statistical Software,43/4, 1-25, 
<a href="https://doi.org/10.18637/jss.v043.i04">doi:10.18637/jss.v043.i04</a>.
</p>
<p>Moran MS, Jackson RD, Slater PN, Teillet PM (1992) Evaluation of simplified
procedures for retrieval of land surface reflectance factors from satellite
sensor output.Remote Sensing of Environment 41/2-3, 169-184, 
<a href="https://doi.org/10.1016/0034-4257%2892%2990076-V">doi:10.1016/0034-4257(92)90076-V</a>.
</p>
<p>Song C, Woodcock CE, Seto KC, Lenney MP, Macomber SA (2001) Classification 
and Change Detection Using Landsat TM Data: When and How to Correct 
Atmospheric Effects? Remote Sensing of Environment 75/2, 
<a href="https://doi.org/10.1016/S0034-4257%2800%2900169-3">doi:10.1016/S0034-4257(00)00169-3</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)
sat_atmos &lt;- calcAtmosCorr(sat, model = "DOS2", esun_method = "RadRef")

bcde &lt;- "B002n"

sat &lt;- calcTOAIrradRadRef(sat, normalize = FALSE)

path_rad &lt;- calcPathRadDOS(x = min(getValues(getSatDataLayer(sat, bcde))),
                           bnbr = getSatLNBR(sat, bcde),
                           band_wls = 
                             data.frame(LMIN = 
                                          getSatLMIN(sat, 
                                                     getSatBCDESolar(sat)), 
                                        LMAX = 
                                          getSatLMAX(sat, 
                                                     getSatBCDESolar(sat))),
                           radm = getSatRADM(sat, getSatBCDESolar(sat)),
                           rada = getSatRADA(sat, getSatBCDESolar(sat)),
                           szen = getSatSZEN(sat, getSatBCDESolar(sat)),
                           esun = getSatESUN(sat, getSatBCDESolar(sat)),
                           model = "DOS2")

sensor_rad &lt;- convSC2Rad(x = getSatDataLayer(sat, bcde), 
                         mult = getSatRADM(sat, bcde), 
                         add = getSatRADA(sat, bcde), getSatSZEN(sat, bcde))

ref_atmos &lt;- calcAtmosCorr(x = sensor_rad,
                           path_rad = path_rad[names(path_rad) == bcde],
                           esun = getSatESUN(sat, bcde),
                           szen = getSatSZEN(sat, bcde), 
                           model = "DOS2")
                           
</code></pre>

<hr>
<h2 id='calcDODN'>Compile dark object DN for given sensor band</h2><span id='topic+calcDODN'></span><span id='topic+calcDODN+2CSatellite-method'></span><span id='topic+calcDODN+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>The function estimates the DN value of a &quot;dark object&quot; which is used for 
atmospheric correction using the DOS2 and DOS4 model. Therefore, the 
frequency distribution of the smallest 1% of the data values is analyzed 
and the value for which the first derivate has the absolute maximum is
taken as the DN for a dark object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Satellite'
calcDODN(x, bcde)

## S4 method for signature 'RasterLayer'
calcDODN(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcDODN_+3A_x">x</code></td>
<td>
<p>Satellite object or RasterLayer with sensor band data, e.g. returned 
by <code><a href="#topic+getSatDataLayer">getSatDataLayer</a></code>.</p>
</td></tr>
<tr><td><code id="calcDODN_+3A_bcde">bcde</code></td>
<td>
<p>If 'x' is a Satellite object, a band code as character.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The DN for a dark object is extracted from a histogram similar to
Chavez (1988).
</p>


<h3>Value</h3>

<p>Numeric value of the DN for the dark object.
</p>


<h3>References</h3>

<p>Chavez Jr PS (1988) An improved dark-object subtraction technique 
for atmospheric scattering correction of multispectral data. Remote Sensing 
of Environment 24/3, <a href="https://doi.org/10.1016/0034-4257%2888%2990019-3">doi:10.1016/0034-4257(88)90019-3</a>.
</p>


<h3>See Also</h3>

<p>The DN is used by <code><a href="#topic+calcPathRadDOS">calcPathRadDOS</a></code> for computing the 
path radiance based on the dark object method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)

calcDODN(sat, bcde = "B002n")
calcDODN(getSatDataLayer(sat, bcde = "B002n"))

</code></pre>

<hr>
<h2 id='calcEarthSunDist'>Compute earth-sun distance based on day of the year</h2><span id='topic+calcEarthSunDist'></span>

<h3>Description</h3>

<p>The earth-sun distance for a particular day of the year is computed based on
one of several empirical formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcEarthSunDist(date, formula = c("Spencer", "Mather", "ESA", "Duffie"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcEarthSunDist_+3A_date">date</code></td>
<td>
<p>Date of the sensor overpass; either a character string in a 
native date format (e.g. &quot;YYYY-MM-DD&quot;, see <code><a href="base.html#topic+as.Date">as.Date</a></code>) or a POSIX* 
object (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>).</p>
</td></tr>
<tr><td><code id="calcEarthSunDist_+3A_formula">formula</code></td>
<td>
<p>Formula to be applied, specified through the name of the 
author, i.e. one of &quot;Spencer&quot;, &quot;Mather&quot;, &quot;ESA&quot; or &quot;Duffie&quot; (see 'Details').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computation of earth-sun distance using formulas provided by
Spencer (1971), Mather (2005) or ESA. If <code>formula = "Duffie"</code>, the 
inverse squared relative earth&ndash;sun distance is returned as proposed by 
Duffie and Beckman (1980).
</p>


<h3>Value</h3>

<p>Numeric earth-sun distance (in AU) or, if <code>formula = "Duffie"</code>, 
the relative squared earth&ndash;sun distance on the given day.
</p>


<h3>References</h3>

<p>The formulas are taken from the following sources:
</p>

<ul>
<li><p> Spencer: Spencer JW (1971) Fourier series representation of the position of 
the sun. Search 2/5. Taken from 
<a href="https://goo.gl/lhi9UI">https://goo.gl/lhi9UI</a>. 
</p>
</li>
<li><p> Mather: Mather PM (2005) Computer Processing of Remotely-Sensed 
Images: An Introduction. Wiley: Chichester, ISBN: 978-0-470-02101-9, 
<a href="https://eu.wiley.com/WileyCDA/WileyTitle/productCd-0470021012.html">https://eu.wiley.com/WileyCDA/WileyTitle/productCd-0470021012.html</a>.
</p>
</li>
<li><p> ESA: ESA Earth Observation Quality Control: Landsat frequently asked questions. 
</p>
</li>
<li><p> Duffie: Duffie JA, Beckman WA (2013) Solar Engineering of Thermal 
Processes. Wiley: Hoboken, New Jersey, ISBN: 978-0-470-87366-3,
<a href="https://eu.wiley.com/WileyCDA/WileyTitle/productCd-0470873663.html">https://eu.wiley.com/WileyCDA/WileyTitle/productCd-0470873663.html</a>.
</p>
</li></ul>

<p>See also: Bird R, Riordan C (1984) Simple solar spectral model for direct and 
diffuse irradiance on horizontal and tilted planes at the Earth's surface for
cloudless atmospheres. Task No. 3434.10, Solar Energy Research Institute: 
Golden, Colorado, <a href="http://www.nrel.gov/docs/legosti/old/2436.pdf">http://www.nrel.gov/docs/legosti/old/2436.pdf</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calcEarthSunDist(date = "2015-01-01", formula = "Spencer") # absolute
calcEarthSunDist(date = "2015-01-01", formula = "Duffie")  # relative

</code></pre>

<hr>
<h2 id='calcPathRadDOS'>Compute path radiance based on the dark object method</h2><span id='topic+calcPathRadDOS'></span><span id='topic+calcPathRadDOS+2CSatellite-method'></span><span id='topic+calcPathRadDOS+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Compute an estimated path radiance for all sensor bands, which can then be 
used to roughly correct the radiance values for atmospheric scattering. Path 
radiance estimation is based on a dark object method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Satellite'
calcPathRadDOS(x, model = c("DOS2", "DOS4"), esun_method = "RadRef")

## S4 method for signature 'numeric'
calcPathRadDOS(
  x,
  bnbr,
  band_wls,
  radm,
  rada,
  szen,
  esun,
  model = c("DOS2", "DOS4"),
  scat_coef = c(-4, -2, -1, -0.7, -0.5),
  dos_adjust = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcPathRadDOS_+3A_x">x</code></td>
<td>
<p>A Satellite object or the value (scaled count) of a dark object in 
<code>bnbr</code> (e.g. minimum raw count of selected raster <code>bnbr</code>). If x is 
a Satellite object, the value is computed using <code><a href="#topic+calcDODN">calcDODN</a></code>.</p>
</td></tr>
<tr><td><code id="calcPathRadDOS_+3A_model">model</code></td>
<td>
<p>Model to be used to correct for 1% scattering (DOS2, DOS4; must 
be the same as used by <code><a href="#topic+calcAtmosCorr">calcAtmosCorr</a></code>).</p>
</td></tr>
<tr><td><code id="calcPathRadDOS_+3A_esun_method">esun_method</code></td>
<td>
<p>If x is a Satellite object, name of the method to be used 
to compute esun using one of <code><a href="#topic+calcTOAIrradRadRef">calcTOAIrradRadRef</a></code> (&quot;RadRef&quot;), 
<code><a href="#topic+calcTOAIrradTable">calcTOAIrradTable</a></code> (&quot;Table&quot;) or <code><a href="#topic+calcTOAIrradModel">calcTOAIrradModel</a></code>
(&quot;Model&quot;)</p>
</td></tr>
<tr><td><code id="calcPathRadDOS_+3A_bnbr">bnbr</code></td>
<td>
<p>Band number for which DNmin is valid.</p>
</td></tr>
<tr><td><code id="calcPathRadDOS_+3A_band_wls">band_wls</code></td>
<td>
<p>Band wavelengths to be corrected; <code>data.frame</code> with min 
(max) in first (second) column, see details.</p>
</td></tr>
<tr><td><code id="calcPathRadDOS_+3A_radm">radm</code></td>
<td>
<p>Multiplicative coefficient for radiance transformation (i.e. 
slope).</p>
</td></tr>
<tr><td><code id="calcPathRadDOS_+3A_rada">rada</code></td>
<td>
<p>Additive coefficient for radiance transformation (i.e. offset).</p>
</td></tr>
<tr><td><code id="calcPathRadDOS_+3A_szen">szen</code></td>
<td>
<p>Sun zenith angle.</p>
</td></tr>
<tr><td><code id="calcPathRadDOS_+3A_esun">esun</code></td>
<td>
<p>Actual (i.e. non-normalized) TOA solar irradiance, e.g. returned 
by <code><a href="#topic+calcTOAIrradRadRef">calcTOAIrradRadRef</a></code>, <code><a href="#topic+calcTOAIrradTable">calcTOAIrradTable</a></code> or 
<code><a href="#topic+calcTOAIrradModel">calcTOAIrradModel</a></code>.</p>
</td></tr>
<tr><td><code id="calcPathRadDOS_+3A_scat_coef">scat_coef</code></td>
<td>
<p>Scattering coefficient; defaults to -4.0.</p>
</td></tr>
<tr><td><code id="calcPathRadDOS_+3A_dos_adjust">dos_adjust</code></td>
<td>
<p>Assumed reflection for dark object adjustment; defaults to 0.01.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If x is a Satellite object, the minimum raw count value (x) is computed using
<code><a href="#topic+calcDODN">calcDODN</a></code>. If the TOA solar irradiance is not part of the 
Satellite object's metadata, it is computed using 
<code><a href="#topic+calcTOAIrradRadRef">calcTOAIrradRadRef</a></code>, <code><a href="#topic+calcTOAIrradTable">calcTOAIrradTable</a></code> or 
<code><a href="#topic+calcTOAIrradModel">calcTOAIrradModel</a></code>.
</p>
<p>The dark object subtraction approach is based on an approximation 
of the atmospheric path radiance (i.e. upwelling radiation which is 
scattered into the sensors field of view, aka haze) using the reflectance of a 
dark object (i.e. reflectance ~1%). 
</p>
<p>Chavez (1988) proposed a method which uses the dark object reflectance
in one band to predict the corresponding path radiances in all other 
<code>band_wls</code>. This is done using a relative radiance model which depends on 
the wavelength and overall atmospheric optical thickness (which is estimated 
based on the dark object's DN value). This has the advantage that the path 
radiance is actually correlated across different sensor <code>band_wls</code> and 
not computed individually for each band using independent dark objects. He 
proposed a relative radiance model which follows a wavelength dependent 
scattering that ranges from a power of -4 over -2, -1, -0.7 to -0.5 for very 
clear over clear, moderate, hazy to very hazy conditions. The relative 
factors are computed individually for each 1/1000 wavelength within each band 
range and subsequently averaged over the band as proposed by Goslee (2011).
</p>
<p>The atmospheric transmittance towards the sensor (Tv) is approximated by 
1.0 (DOS2, Chavez 1996) or Rayleigh scattering (DOS4, Moran et al. 1992)
</p>
<p>The atmospheric transmittance from the sun (Tz) is approximated by the 
cosine of the sun zenith angle (DOS2, Chavez 1996) or again using Rayleigh
scattering (DOS4, Moran et al. 1992).
</p>
<p>The downwelling diffuse irradiance is approximated by 0.0 (DOS2, Chavez 1996)
or the hemispherical integral of the path radiance (DOS4, Moran et al. 1992).
</p>
<p>Equations for the path radiance are taken from Song et al. (2001).
</p>
<p>For some sensors, the band wavelengths are already included. See
<code>lutInfo()[grepl("_BANDS", names(lutInfo()$META))]</code> if your sensor is
included. To retrieve a sensor, use <code>lutInfo()$&lt;Sensor ID&gt;_BANDS</code>.
</p>


<h3>Value</h3>

<p>Satellite object with path radiance for each band in the metadata
(W m-2 micrometer-1)
</p>
<p>Vector object with path radiance values for each band 
(W m-2 micrometer-1)
</p>


<h3>References</h3>

<p>Chavez Jr PS (1988) An improved dark-object subtraction technique 
for atmospheric scattering correction of multispectral data. Remote Sensing 
of Environment 24/3, <a href="https://doi.org/10.1016/0034-4257%2888%2990019-3">doi:10.1016/0034-4257(88)90019-3</a>.
</p>
<p>Chavez Jr PS (1996) Image-based atmospheric corrections revisited and
improved. Photogrammetric Engineering and Remote Sensing 62/9,
available online at 
<a href="https://www.researchgate.net/publication/236769129_Image-Based_Atmospheric_Corrections_-_Revisited_and_Improved">https://www.researchgate.net/publication/236769129_Image-Based_Atmospheric_Corrections_-_Revisited_and_Improved</a>.
</p>
<p>Goslee SC (2011) Analyzing Remote Sensing Data in R: The landsat 
Package. Journal of Statistical Software, 43/4, 1-25, 
<a href="https://doi.org/10.18637/jss.v043.i04">doi:10.18637/jss.v043.i04</a>.
</p>
<p>Moran MS, Jackson RD, Slater PN, Teillet PM (1992) Evlauation of simplified
procedures for rretrieval of land surface reflectane factors from satellite
sensor output.Remote Sensing of Environment 41/2-3, 169-184, 
<a href="https://doi.org/10.1016/0034-4257%2892%2990076-V">doi:10.1016/0034-4257(92)90076-V</a>.
</p>
<p>Song C, Woodcock CE, Seto KC, Lenney MP, Macomber SA (2001) Classification 
and Change Detection Using Landsat TM Data: When and How to Correct 
Atmospheric Effects? Remote Sensing of Environment 75/2, 
<a href="https://doi.org/10.1016/S0034-4257%2800%2900169-3">doi:10.1016/S0034-4257(00)00169-3</a>.
</p>
<p>If you refer to Sawyer and Stephen 2014, please note that eq. 5 is wrong.
</p>


<h3>See Also</h3>

<p>This function is used by <code><a href="#topic+calcAtmosCorr">calcAtmosCorr</a></code> to 
compute the path radiance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)
sat &lt;- calcTOAIrradModel(sat)

bds &lt;- "B002n"
val &lt;- calcPathRadDOS(x = min(getValues(getSatDataLayer(sat, bds))),
                      bnbr = getSatLNBR(sat, bds),
                      band_wls = data.frame(LMIN = getSatLMIN(sat, getSatBCDESolar(sat)),
                                            LMAX = getSatLMAX(sat, getSatBCDESolar(sat))),
                      radm = getSatRADM(sat, getSatBCDESolar(sat)),
                      rada = getSatRADA(sat, getSatBCDESolar(sat)),
                      szen = getSatSZEN(sat, getSatBCDESolar(sat)),
                      esun = getSatESUN(sat, getSatBCDESolar(sat)),
                      model = "DOS2",
                      scat_coef = -4)
val
</code></pre>

<hr>
<h2 id='calcTOAIrradModel'>Compute top of atmosphere solar irradiance for sensor bands using LUTs</h2><span id='topic+calcTOAIrradModel'></span><span id='topic+calcTOAIrradModel+2CSatellite-method'></span><span id='topic+calcTOAIrradModel+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>Compute mean extraterrestrial solar irradiance (ESun) using tabulated mean
solar spectral data and the band specific relative spectral response (rsr) 
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Satellite'
calcTOAIrradModel(x, model = "MNewKur", normalize = TRUE, esd)

## S4 method for signature 'data.frame'
calcTOAIrradModel(x, model = "MNewKur", normalize = TRUE, esd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcTOAIrradModel_+3A_x">x</code></td>
<td>
<p>A Satellite object or the relative spectral response function for 
the respective band as <code>data.frame</code> (see details for structure).</p>
</td></tr>
<tr><td><code id="calcTOAIrradModel_+3A_model">model</code></td>
<td>
<p>Tabulated solar radiation model to be used (one of 
MCebKur_MChKur, MNewKur,  MthKur, MoldKur, MODWherli_WMO, NN, see reference
on tabulated solar irradiance below).</p>
</td></tr>
<tr><td><code id="calcTOAIrradModel_+3A_normalize">normalize</code></td>
<td>
<p>Logical; if <code>TRUE</code>, ESun is normalized to mean 
earth-sun distance.</p>
</td></tr>
<tr><td><code id="calcTOAIrradModel_+3A_esd">esd</code></td>
<td>
<p>Earth-sun distance (AU, can be estimated using 
<code><a href="#topic+calcEarthSunDist">calcEarthSunDist</a></code>). If x is a Satellite object and esd is not 
supplied and necessary for normalization, it is tried to take it from the 
metadata, otherwise it is estimated by the day of the year using 
<code><a href="#topic+calcEarthSunDist">calcEarthSunDist</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computation of ESun is taken from Updike and Comp (2011).
</p>
<p>Tabulated values for mean earth-sun distance are taken from the 
data sources mentioned in the references. 
</p>
<p>If results should not be normalized to a mean earth-sun distance, the 
actual earth-sun distance is approximated by the day of the year using
<code><a href="#topic+calcEarthSunDist">calcEarthSunDist</a></code>.
</p>
<p>Relative spectral response values have to be supplied as a <code>data.frame</code>
which has at least the following three columns: (i) a column &quot;Band&quot; for the 
sensor band number (i.e. 1, 2, etc.), (ii) a column &quot;WAVELENGTH&quot; for the 
WAVELENGTH data in full nm steps, and (iii) a column &quot;RSR&quot; for the response 
information [0...1].
</p>


<h3>Value</h3>

<p>If x is a Satellite object, a Satellite object with ESun information 
added to the metadata; if x is a <code>data.frame</code>, a vector containing ESun
for the respective band(s).
</p>


<h3>References</h3>

<p>Updike T, Comp C (2011) Radiometric use of WorldView-2 imagery. 
Technical Note, available online at <a href="http://www.pancroma.com/downloads/Radiometric_Use_of_WorldView-2_Imagery.pdf">http://www.pancroma.com/downloads/Radiometric_Use_of_WorldView-2_Imagery.pdf</a>.
</p>
<p>Tabulated relative spectral response functions (nm-1) are taken from the
<a href="https://landsat.usgs.gov/spectral-characteristics-viewer">spectral viewer</a>
of the USGS Landsat FAQ.
</p>
<p>Tabulated solar irradiance (W m-2 nm-1) is taken from the 
<a href="http://rredc.nrel.gov/solar/spectra/am0/modtran.html">National Renewable 
Energy Laboratory</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcTOAIrradTable">calcTOAIrradTable</a></code> for tabulated solar irradiance
values from the literature or <code><a href="#topic+calcTOAIrradRadRef">calcTOAIrradRadRef</a></code> for the 
computation of the solar irradiance based on maximum radiation and reflection
values of the dataset.
</p>
<p>See <code><a href="#topic+calcEarthSunDist">calcEarthSunDist</a></code> for calculating the earth-sun
distance based on the day of the year which is called by this function if
ESun should be corrected for actual earth-sun distance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)
sat &lt;- calcTOAIrradModel(sat)
getSatESUN(sat)

lut &lt;- lutInfo()
calcTOAIrradModel(lut$L8_RSR, model = "MNewKur", normalize = FALSE, 
  esd = calcEarthSunDist("2015-01-01"))

</code></pre>

<hr>
<h2 id='calcTOAIrradRadRef'>Compute top of atmosphere solar irradiance using radiation vs. reflection</h2><span id='topic+calcTOAIrradRadRef'></span><span id='topic+calcTOAIrradRadRef+2CSatellite-method'></span><span id='topic+calcTOAIrradRadRef+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Compute extraterrestrial solar irradiance (ESun) using the actual
maximum radiation and reflection values within each band.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Satellite'
calcTOAIrradRadRef(x, normalize = TRUE, esd)

## S4 method for signature 'numeric'
calcTOAIrradRadRef(x, ref_max, normalize = TRUE, esd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcTOAIrradRadRef_+3A_x">x</code></td>
<td>
<p>A Satellite object or the maximum radiance of satellite 
band(s) as numeric object.</p>
</td></tr>
<tr><td><code id="calcTOAIrradRadRef_+3A_normalize">normalize</code></td>
<td>
<p>Logical; if <code>TRUE</code>, ESun is normalized to mean 
earth-sun distance.</p>
</td></tr>
<tr><td><code id="calcTOAIrradRadRef_+3A_esd">esd</code></td>
<td>
<p>Earth-sun distance (AU, can be estimated using 
<code><a href="#topic+calcEarthSunDist">calcEarthSunDist</a></code>). If x is a Satellite object and esd is not 
supplied and necessary for normalization, it is tried to take it from the 
metadata, otherwise it is estimated by the day of the year using 
<code><a href="#topic+calcEarthSunDist">calcEarthSunDist</a></code>.</p>
</td></tr>
<tr><td><code id="calcTOAIrradRadRef_+3A_ref_max">ref_max</code></td>
<td>
<p>Maximum reflextance of satellite band(s).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The actual solar irradiance is computed using the following formula 
taken from the GRASS GIS 
<a href="https://grass.osgeo.org/grass78/manuals/i.landsat.toar.html">i.landsat.toar</a> module
</p>
<p style="text-align: center;"><code class="reqn">ESun = (pi d^2) RADIANCE_MAXIMUM / REFLECTANCE_MAXIMUM</code>
</p>

<p>where d is the earth-sun distance (in AU) and RADIANCE_MAXIMUM
and REFLECTANCE_MAXIMUM are the maximum radiance and reflection values of the
respective band. All these parameters are taken from the scene's metadata
file if a Satellite object is passed to the function.
</p>
<p>By default, the resulting actual ESun will be normalized to a mean earth-sun 
distance to be compatible with other default results from 
<code><a href="#topic+calcTOAIrradTable">calcTOAIrradTable</a></code> or <code><a href="#topic+calcTOAIrradModel">calcTOAIrradModel</a></code>.
</p>


<h3>Value</h3>

<p>If x is a Satellite object, a Satellite object with ESun information 
added to the metadata; if x is numeric, a vector containing ESun for the 
respective band(s).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcTOAIrradTable">calcTOAIrradTable</a></code> for tabulated solar irradiance
values from the literature or <code><a href="#topic+calcTOAIrradModel">calcTOAIrradModel</a></code> for the 
computation of the solar irradiance based on look-up tables for the sensor's 
relative spectral response and solar irradiation spectral data.
</p>
<p>See <code><a href="#topic+calcEarthSunDist">calcEarthSunDist</a></code> for calculating the earth-sun
distance based on the day of the year which is called by this function if
ESun should be corrected for actual earth-sun distance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)  
sat &lt;- calcTOAIrradModel(sat)
getSatESUN(sat)

calcTOAIrradRadRef(x = getSatRadMax(sat, getSatBCDESolar(sat)), 
                   ref_max = getSatRefMax(sat, getSatBCDESolar(sat)), 
                   normalize = FALSE, 
                   esd = calcEarthSunDist("2015-01-01"))
                   
</code></pre>

<hr>
<h2 id='calcTOAIrradTable'>Get top of atmosphere solar irradiance using readily tabulated values</h2><span id='topic+calcTOAIrradTable'></span><span id='topic+calcTOAIrradTable+2CSatellite-method'></span><span id='topic+calcTOAIrradTable+2Cfactor-method'></span><span id='topic+calcTOAIrradTable+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Get mean extraterrestrial solar irradiance (ESun) using published values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Satellite'
calcTOAIrradTable(x, normalize = TRUE, esd)

## S4 method for signature 'factor'
calcTOAIrradTable(x, normalize = TRUE, esd)

## S4 method for signature 'character'
calcTOAIrradTable(x, normalize = TRUE, esd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcTOAIrradTable_+3A_x">x</code></td>
<td>
<p>A Satellite object or sensor id (&quot;LT4, LT5, LE7&quot;) as character.</p>
</td></tr>
<tr><td><code id="calcTOAIrradTable_+3A_normalize">normalize</code></td>
<td>
<p>Logical; if <code>TRUE</code>, ESun is normalized to mean 
earth-sun distance.</p>
</td></tr>
<tr><td><code id="calcTOAIrradTable_+3A_esd">esd</code></td>
<td>
<p>Earth-sun distance (AU, can be estimated using 
<code><a href="#topic+calcEarthSunDist">calcEarthSunDist</a></code>). If x is a Satellite object and esd is not 
supplied and necessary for normalization, it is tried to take it from the 
metadata, otherwise it is estimated by the day of the year using 
<code><a href="#topic+calcEarthSunDist">calcEarthSunDist</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently implemented sensors are Landsat 4, 5 and 7.
</p>
<p>If results should not be normalized to a mean earth-sun distance, the 
actual earth-sun distance is approximated by the day of the year using
<code><a href="#topic+calcEarthSunDist">calcEarthSunDist</a></code>.
</p>
<p>Please note that ESun values are not required for converting Landsat 8 data 
to reflectance as the corresponding metadata files provide coefficients 
necessary to convert digital numbers to radiance and reflectance (taken from 
<a href="https://www.gisagmaps.org/landsat-8-atco-guide/">https://www.gisagmaps.org/landsat-8-atco-guide/</a>.
</p>


<h3>Value</h3>

<p>Satellite object with ESun information added to the metadata
</p>
<p>Vector object containing ESun for the respective band(s)
</p>
<p>Vector object containing ESun for the respective band(s)
</p>


<h3>References</h3>

<p>Tabulated values of the solar irradiance for all Landsat sensors 
are taken from <a href="https://www.usgs.gov/landsat-missions/using-usgs-landsat-level-1-data-product">https://www.usgs.gov/landsat-missions/using-usgs-landsat-level-1-data-product</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcTOAIrradRadRef">calcTOAIrradRadRef</a></code> for the computation of the solar 
irradiance based on maximum radiation and reflection values of the dataset or
<code><a href="#topic+calcTOAIrradModel">calcTOAIrradModel</a></code> for the computation of the solar irradiance 
based on look-up tables for the sensor's relative spectral response and solar 
irradiation spectral data.
</p>
<p>See <code><a href="#topic+calcEarthSunDist">calcEarthSunDist</a></code> for calculating the earth-sun
distance based on the day of the year which is called by this function if
ESun should be corrected for actual earth-sun distance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LE07*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)
calcTOAIrradTable(sat)
 
calcTOAIrradTable(x = "LE7", normalize = FALSE, 
                  calcEarthSunDist("2015-01-01"))

</code></pre>

<hr>
<h2 id='calcTopoCorr'>Correct for topographic effects.</h2><span id='topic+calcTopoCorr'></span><span id='topic+calcTopoCorr+2CSatellite-method'></span><span id='topic+calcTopoCorr+2CRasterStackBrick-method'></span><span id='topic+calcTopoCorr+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>Correct for topographic effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Satellite'
calcTopoCorr(x, mask = TRUE)

## S4 method for signature 'RasterStackBrick'
calcTopoCorr(x, hillsh, cloudmask = NULL, ...)

## S4 method for signature 'RasterLayer'
calcTopoCorr(x, hillsh, cloudmask = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcTopoCorr_+3A_x">x</code></td>
<td>
<p><code>Satellite</code> or <code>Raster*</code> object.</p>
</td></tr>
<tr><td><code id="calcTopoCorr_+3A_mask">mask</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, the cloudmask from the 
<code>Satellite</code> object (if available) will be considered in the regression 
model.</p>
</td></tr>
<tr><td><code id="calcTopoCorr_+3A_hillsh">hillsh</code></td>
<td>
<p>A <code>RasterLayer</code> created with <code><a href="raster.html#topic+hillShade">hillShade</a></code>.</p>
</td></tr>
<tr><td><code id="calcTopoCorr_+3A_cloudmask">cloudmask</code></td>
<td>
<p>A <code>RasterLayer</code> in which clouds are masked with 
NA values, passed to <code><a href="raster.html#topic+mask">mask</a></code>.</p>
</td></tr>
<tr><td><code id="calcTopoCorr_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method of Civco (1989) is applied on atmospherically corrected bands 
(if not already available in the Satellite object, 
<code><a href="#topic+calcAtmosCorr">calcAtmosCorr</a></code> is performed with its default settings.):
First, an analytical hillshade image is created based on a DEM and sun 
elevation and sun zenith information from the metadata. A regression between
the hillshade (independent variable) and each channel is then calculated 
with consideration of a cloudmask (if available).
The regression coefficents are used to calibrate the hillshade raster 
(for each channel individually). 
Finally, the calibrated hillshade image is subtracted from the corresponding
channel and the mean value of the channel is added.
</p>


<h3>Value</h3>

<p>If x is a Satellite object, a Satellite object with added, 
topographic corrected layers; if x is a <code>raster::Raster*</code> object, a 
<code>raster::Raster*</code> object with converted layer(s).
</p>


<h3>References</h3>

<p>CIVCO, D.L. (1989): Topographic normalization of Landsat Thematic
Mapper digitalimagery. <em>Photogrammetric Engineering &amp; Remote Sensing</em>, 
55, 1303-1309.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)

## dem

files_dem &lt;- list.files(path, pattern = "DEM", full.names = TRUE)
DEM &lt;- raster(files_dem)

sat &lt;- addSatDataLayer(sat, data = DEM, info = NULL, bcde = "DEM", in_bcde="DEM")

## Not run: 
sat &lt;- calcTopoCorr(sat)

## End(Not run)
</code></pre>

<hr>
<h2 id='compFilePathLandsat'>Get filename, bands and metadata file for Landsat 7 and 8 standard 1B/T format</h2><span id='topic+compFilePathLandsat'></span><span id='topic+sortFilesLandsat'></span>

<h3>Description</h3>

<p>The function compiles the sensor, band, filename and metadata filename information
for standard level 1B/T Landsat files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compFilePathLandsat(files)

sortFilesLandsat(files, id = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compFilePathLandsat_+3A_files">files</code></td>
<td>
<p>Path and filename(s) of one or more Landsat band files or, 
alternatively, one or more Landsat metadata files.</p>
</td></tr>
<tr><td><code id="compFilePathLandsat_+3A_id">id</code></td>
<td>
<p><code>logical</code>, defaults to <code>FALSE</code>. Determines whether to 
return sorted band files (ie default) or sorting order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> containing filepaths, band numbers and metadata 
filepaths.
</p>
<p>If <code>id = FALSE</code> (default), sorted band files as 
<code>character</code>, else the corresponding sorting order as <code>integer</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>sortFilesLandsat()</code>: Sort Landsat band files in ascending order.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)

compFilePathLandsat(files)  

sortFilesLandsat(files)
sortFilesLandsat(files, id = TRUE) # indices

</code></pre>

<hr>
<h2 id='compMetaLandsat'>Get calibration information from Landsat 8 standard level 1B/T filename</h2><span id='topic+compMetaLandsat'></span>

<h3>Description</h3>

<p>The function scans a Lansat metadata file for various calibration 
and orbit coefficients as well as some sensor specific data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compMetaLandsat(files)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compMetaLandsat_+3A_files">files</code></td>
<td>
<p>Path and filename of the Landsat metadata file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> containing the following information for each 
band/layer: 
</p>

<ul>
<li><p> DATE date (e.g. 2013-07-07)
</p>
</li>
<li><p> SID sensor id (e.g. LC8)
</p>
</li>
<li><p> SENSOR sensor name (e.g. Landsat 8)
</p>
</li>
<li><p> SGRP sensor group (e.g. Landsat)
</p>
</li>
<li><p> BID band id (e.g. 7)
</p>
</li>
<li><p> BCDE band code (5 digit standard name, e.g B001n)
</p>
</li>
<li><p> SRES spatial resolution of the sensor band (e.g. 30 for 30 m x 30m)
</p>
</li>
<li><p> TYPE type of the sensor band regarding wavelength (e.g. VIS)
</p>
</li>
<li><p> SPECTRUM spectral range regarding radiation source (e.g. solar)
</p>
</li>
<li><p> CALIB type of applied calibration (e.g. SC for scaled counts)
</p>
</li>
<li><p> RID region id (e.g. R00001) for multi region Satellite objects
</p>
</li>
<li><p> RADA addtition coefficient for radiance conversion
</p>
</li>
<li><p> RADM multiplication coefficient for radiance conversion
</p>
</li>
<li><p> REFA addtition coefficient for reflectance conversion
</p>
</li>
<li><p> REFM multiplication coefficient for reflectance conversion
</p>
</li>
<li><p> BTK1 brightness temperature correction parameter
</p>
</li>
<li><p> BTK2 brightness temperature correction parameter
</p>
</li>
<li><p> SZEN sun zenith angle
</p>
</li>
<li><p> SAZM sun azimuth angle
</p>
</li>
<li><p> SELV sun elevation angle
</p>
</li>
<li><p> ESD earth-sun distance (AU)
</p>
</li>
<li><p> LMIN Minimum wavelength of the band (micrometer)
</p>
</li>
<li><p> LMAX Maximum wavelength of the band (micrometer)
</p>
</li>
<li><p> RADMIN Minimum radiance recorded by the band
</p>
</li>
<li><p> RADMAX Maximum radiance recorded by the band
</p>
</li>
<li><p> REFMIN Minimum reflectance recorded by the band
</p>
</li>
<li><p> REFMAX Maximum reflectance recorded by the band
</p>
</li>
<li><p> LNBR Layer number from 1 to n layers
</p>
</li>
<li><p> LAYER Layer name
</p>
</li>
<li><p> FILE Filepath of the data file
</p>
</li>
<li><p> METAFILE Filepath of the metadata file
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)
compMetaLandsat(files)

</code></pre>

<hr>
<h2 id='convRad2BT'>Convert a band's scaled counts to brightness temperature</h2><span id='topic+convRad2BT'></span><span id='topic+convRad2BT+2CSatellite-method'></span><span id='topic+convRad2BT+2CRasterStack-method'></span><span id='topic+convRad2BT+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>Convert a band's radiance values to brightness temperature without
any kind of atmospheric correction etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Satellite'
convRad2BT(x)

## S4 method for signature 'RasterStack'
convRad2BT(x, k1, k2)

## S4 method for signature 'RasterLayer'
convRad2BT(x, k1, k2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convRad2BT_+3A_x">x</code></td>
<td>
<p>An object of class Satellite, raster::RasterStack or 
raster::RasterLayer providing radiance values.</p>
</td></tr>
<tr><td><code id="convRad2BT_+3A_k1">k1</code>, <code id="convRad2BT_+3A_k2">k2</code></td>
<td>
<p>Temperature correction parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conversion functions are taken from USGS' Landsat 8 Data Users Handbook
which is available online at 
<a href="https://www.usgs.gov/landsat-missions/landsat-8-data-users-handbook">https://www.usgs.gov/landsat-missions/landsat-8-data-users-handbook</a>.
</p>


<h3>Value</h3>

<p>If x is a Satellite object, a Satellite object with added converted 
layers; <br />
if x is a <code>raster::Raster*</code> object, a <code>raster::Raster*</code> object with
converted layer(s).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcAtmosCorr">calcAtmosCorr</a></code> for converions of scaled counts 
to physical units including a scene-based atmospheric correction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)  
sat &lt;- convRad2BT(sat)

</code></pre>

<hr>
<h2 id='convRad2Ref'>Convert a band's scaled counts or radiance values to reflectance</h2><span id='topic+convRad2Ref'></span><span id='topic+convRad2Ref+2CSatellite-method'></span><span id='topic+convRad2Ref+2CRasterStack-method'></span><span id='topic+convRad2Ref+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>Convert a band's scaled counts to reflectance using a simple linear 
conversion without any kind of atmospheric correction etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Satellite'
convRad2Ref(x, szen_correction = "TRUE")

## S4 method for signature 'RasterStack'
convRad2Ref(x, mult, add, szen)

## S4 method for signature 'RasterLayer'
convRad2Ref(x, mult, add, szen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convRad2Ref_+3A_x">x</code></td>
<td>
<p>An object of class Satellite, raster::RasterStack or 
raster::RasterLayer providing radiance values.</p>
</td></tr>
<tr><td><code id="convRad2Ref_+3A_szen_correction">szen_correction</code></td>
<td>
<p>Logical; if <code>TRUE</code>, sun zenith correction is 
being applied.</p>
</td></tr>
<tr><td><code id="convRad2Ref_+3A_mult">mult</code></td>
<td>
<p>Multiplicative coefficient for value transformation (i.e. slope).</p>
</td></tr>
<tr><td><code id="convRad2Ref_+3A_add">add</code></td>
<td>
<p>Additive coefficient for value transformation (i.e. offset)</p>
</td></tr>
<tr><td><code id="convRad2Ref_+3A_szen">szen</code></td>
<td>
<p>Cosine of solar zenith angle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conversion functions are taken from USGS' Landsat 8 Data Users Handbook
which is available online at 
<a href="https://www.usgs.gov/landsat-missions/landsat-8-data-users-handbook">https://www.usgs.gov/landsat-missions/landsat-8-data-users-handbook</a>.
</p>
<p>If the sensor does not provide linear conversion coefficients for reflectance
computation, the reflectance is calculated using the solar irradiance 
following the functions taken from USGS' Landsat 7 manual, chapter 11.3.2,
which is available online at 
<a href="https://www.usgs.gov/media/files/landsat-7-data-users-handbook">https://www.usgs.gov/media/files/landsat-7-data-users-handbook</a>.
</p>


<h3>Value</h3>

<p>If x is a Satellite object, a Satellite object with added converted 
layers; <br />
if x is a <code>raster::Raster*</code> object, a <code>raster::Raster*</code> object with 
converted layer(s).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcAtmosCorr">calcAtmosCorr</a></code> for conversions of scaled counts 
to physical units including a scene-based atmospheric correction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)  
sat &lt;- convRad2Ref(sat)

# If you use a raster layer, supply required meta information
bcde &lt;- "B002n"
convRad2Ref(x = getSatDataLayer(sat, bcde),
            mult = getSatRADM(sat, bcde),
            add = getSatRADA(sat, bcde))

</code></pre>

<hr>
<h2 id='convRef2RadLinear'>Convert reflectance to radiance using linear function coefficients</h2><span id='topic+convRef2RadLinear'></span>

<h3>Description</h3>

<p>The function converts the reflectance (ref) back to radiance (rad) given that
linear conversion coefficients for both radiance and reflectance are 
available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convRef2RadLinear(band, refm, refa, radm, rada, szen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convRef2RadLinear_+3A_band">band</code></td>
<td>
<p>raster::RasterStack or raster::RasterLayer containing reflectance.</p>
</td></tr>
<tr><td><code id="convRef2RadLinear_+3A_refm">refm</code></td>
<td>
<p>Multiplication coefficient for reflectance conversion.</p>
</td></tr>
<tr><td><code id="convRef2RadLinear_+3A_refa">refa</code></td>
<td>
<p>Addtition coefficient for reflectance conversion.</p>
</td></tr>
<tr><td><code id="convRef2RadLinear_+3A_radm">radm</code></td>
<td>
<p>Multiplication coefficient for radiance conversion.</p>
</td></tr>
<tr><td><code id="convRef2RadLinear_+3A_rada">rada</code></td>
<td>
<p>Addition coefficient for radiance conversion.</p>
</td></tr>
<tr><td><code id="convRef2RadLinear_+3A_szen">szen</code></td>
<td>
<p>Sun zenith angle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conversion functions are taken from USGS' Landsat 8 Data Users
Handbook which is available online at 
<a href="https://www.usgs.gov/landsat-missions/landsat-8-data-users-handbook">https://www.usgs.gov/landsat-missions/landsat-8-data-users-handbook</a>.
</p>


<h3>Value</h3>

<p><code>raster::Raster*</code> object with converted values.
</p>

<hr>
<h2 id='convSC2Rad'>Convert a band's scaled counts to radiance</h2><span id='topic+convSC2Rad'></span><span id='topic+convSC2Rad+2CSatellite-method'></span><span id='topic+convSC2Rad+2CRasterStack-method'></span><span id='topic+convSC2Rad+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>Convert a band's scaled counts to radiance using a simple linear conversion 
without any kind of atmospheric correction etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Satellite'
convSC2Rad(x, szen_correction = "TRUE", subset = FALSE)

## S4 method for signature 'RasterStack'
convSC2Rad(x, mult, add, szen)

## S4 method for signature 'RasterLayer'
convSC2Rad(x, mult, add, szen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convSC2Rad_+3A_x">x</code></td>
<td>
<p>An object of class Satellite, raster::RasterStack or 
raster::RasterLayer providing scaled counts (DNs).</p>
</td></tr>
<tr><td><code id="convSC2Rad_+3A_szen_correction">szen_correction</code></td>
<td>
<p>Logical; if <code>TRUE</code>, sun zenith correction is 
being applied.</p>
</td></tr>
<tr><td><code id="convSC2Rad_+3A_subset">subset</code></td>
<td>
<p>Logical; if <code>TRUE</code>, all layers but the cropped 
ones are being dropped; if <code>FALSE</code> (default), cropped layers are appended to the 
Satellite object.</p>
</td></tr>
<tr><td><code id="convSC2Rad_+3A_mult">mult</code></td>
<td>
<p>Multiplicative coefficient for value transformation (i.e. slope).</p>
</td></tr>
<tr><td><code id="convSC2Rad_+3A_add">add</code></td>
<td>
<p>Additive coefficient for value transformation (i.e. offset).</p>
</td></tr>
<tr><td><code id="convSC2Rad_+3A_szen">szen</code></td>
<td>
<p>Cosine of solar zenith angle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conversion functions are taken from USGS' Landsat 8 Data Users Handbook
which is available online at 
<a href="https://www.usgs.gov/landsat-missions/landsat-8-data-users-handbook">https://www.usgs.gov/landsat-missions/landsat-8-data-users-handbook</a>.
</p>


<h3>Value</h3>

<p>If x is a Satellite object, a Satellite object with added converted 
layers; <br />
if x is a <code>raster::Raster*</code> object, a <code>raster::Raster*</code> object with
converted layer(s).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcAtmosCorr">calcAtmosCorr</a></code> for conversions of scaled counts 
to physical units including a scene-based atmospheric correction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)  
sat &lt;- convSC2Rad(sat)

# If you use a raster layer, supply required meta information
bcde &lt;- "B002n"
convSC2Rad(x = getSatDataLayer(sat, bcde),
           mult = getSatRADM(sat, bcde),
           add = getSatRADA(sat, bcde))

</code></pre>

<hr>
<h2 id='convSC2Ref'>Convert a band's scaled counts or radiance values to reflectance</h2><span id='topic+convSC2Ref'></span><span id='topic+convSC2Ref+2CSatellite-method'></span><span id='topic+convSC2Ref+2CRasterStack-method'></span><span id='topic+convSC2Ref+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>Convert a band's scaled counts to reflectance using a simple linear 
conversion without any kind of atmospheric correction etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Satellite'
convSC2Ref(x, szen_correction = "TRUE", subset = FALSE)

## S4 method for signature 'RasterStack'
convSC2Ref(x, mult, add, szen)

## S4 method for signature 'RasterLayer'
convSC2Ref(x, mult, add, szen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convSC2Ref_+3A_x">x</code></td>
<td>
<p>An object of class Satellite, raster::RasterStack or 
raster::RasterLayer providing scaled counts (DNs).</p>
</td></tr>
<tr><td><code id="convSC2Ref_+3A_szen_correction">szen_correction</code></td>
<td>
<p>Logical; if <code>TRUE</code>, sun zenith correction is 
being applied.</p>
</td></tr>
<tr><td><code id="convSC2Ref_+3A_subset">subset</code></td>
<td>
<p>Logical; if <code>TRUE</code>, all layers but the cropped 
ones are being dropped; if <code>FALSE</code> (default), cropped layers are appended to the 
Satellite object.</p>
</td></tr>
<tr><td><code id="convSC2Ref_+3A_mult">mult</code></td>
<td>
<p>Multiplicative coefficient for value transformation (i.e. slope).</p>
</td></tr>
<tr><td><code id="convSC2Ref_+3A_add">add</code></td>
<td>
<p>Additive coefficient for value transformation (i.e. offset).</p>
</td></tr>
<tr><td><code id="convSC2Ref_+3A_szen">szen</code></td>
<td>
<p>Cosine of solar zenith angle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conversion functions are taken from USGS' Landsat 8 Data Users Handbook
which is available online at 
<a href="https://www.usgs.gov/landsat-missions/landsat-8-data-users-handbook">https://www.usgs.gov/landsat-missions/landsat-8-data-users-handbook</a>.
</p>
<p>If the sensor does not provide linear conversion coefficients for reflectance
computation, the reflectance is calculated using the solar irradiance 
following the functions taken from USGS' Landsat 7 manual, chapter 11.3.2,
which is available online at 
<a href="https://www.usgs.gov/media/files/landsat-7-data-users-handbook">https://www.usgs.gov/media/files/landsat-7-data-users-handbook</a>.
</p>


<h3>Value</h3>

<p>If x is a Satellite object, a Satellite object with added converted 
layers; <br />
if x is a <code>raster::Raster*</code> object, a <code>raster::Raster*</code> object with
converted layer(s).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcAtmosCorr">calcAtmosCorr</a></code> for conversions of scaled counts 
to physical units including a scene-based atmospheric correction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)  
sat &lt;- convSC2Ref(sat)

# If you use a raster layer, supply required meta information
bcde &lt;- "B002n"
convSC2Ref(x = getSatDataLayer(sat, bcde),
           mult = getSatRADM(sat, bcde),
           add = getSatRADA(sat, bcde))

</code></pre>

<hr>
<h2 id='crop'>Crop Satellite object</h2><span id='topic+crop'></span><span id='topic+crop+2CSatellite-method'></span>

<h3>Description</h3>

<p>The function is a wrapper around the <code><a href="#topic+crop">crop</a></code> function to 
easily crop a Satellite object by an <code><a href="raster.html#topic+extent">extent</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Satellite'
crop(x, y, subset = TRUE, snap = "near")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crop_+3A_x">x</code></td>
<td>
<p>Satellite object.</p>
</td></tr>
<tr><td><code id="crop_+3A_y">y</code></td>
<td>
<p><code><a href="raster.html#topic+extent">extent</a></code> object.</p>
</td></tr>
<tr><td><code id="crop_+3A_subset">subset</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), all layers but the cropped 
ones are being dropped; if <code>FALSE</code>, cropped layers are appended to the 
Satellite object.</p>
</td></tr>
<tr><td><code id="crop_+3A_snap">snap</code></td>
<td>
<p>Direction towards which to align the extent as <code>character</code>. 
Available options are <code>"near"</code> (default), <code>"in"</code> and <code>"out"</code> 
(see <code><a href="raster.html#topic+alignExtent">alignExtent</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Crop layers of a Satellite object to the size of a given 
<code>raster::extent</code> object.
</p>


<h3>Value</h3>

<p>A Satellite object consisting of cropped layers only. If 
<code>subset = FALSE</code>, a Satellite object with the cropped layers appended.
</p>


<h3>References</h3>

<p>Please refer to the respective functions for references.
</p>


<h3>See Also</h3>

<p>This function is a wrapper for <code>raster::crop</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## sample data
path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)

## geographic extent of georg-gassmann-stadium (utm 32-n)
ext_ggs &lt;- raster::extent(484015, 484143, 5627835, 5628020)

## crop satellite object by specified extent
sat_ggs &lt;- crop(sat, ext_ggs)

plot(sat)
plot(sat_ggs)

## End(Not run)
</code></pre>

<hr>
<h2 id='demTools'>Compute terrain characteristics from digital elevation models</h2><span id='topic+demTools'></span><span id='topic+demTools+2CSatellite-method'></span><span id='topic+demTools+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>Compute terrain characteristics from digital elevation models (DEM) using 
<code>raster::terrain</code> or <code>raster::hillShade</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Satellite'
demTools(x, method = "hillShade", bcde = "DEM")

## S4 method for signature 'RasterLayer'
demTools(x, sunElev, sunAzim, method = "hillShade")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="demTools_+3A_x">x</code></td>
<td>
<p>A DEM provided as an object of class Satellite or RasterLayer.</p>
</td></tr>
<tr><td><code id="demTools_+3A_method">method</code></td>
<td>
<p>Currently &quot;slope&quot;, &quot;aspect&quot; and &quot;hillshade&quot; are implemented.</p>
</td></tr>
<tr><td><code id="demTools_+3A_bcde">bcde</code></td>
<td>
<p>The name of the DEM layer in the Satellite object.</p>
</td></tr>
<tr><td><code id="demTools_+3A_sunelev">sunElev</code></td>
<td>
<p>If <code>method = "hillShade"</code>, the elevation angle of the 
sun in degrees. See parameter <code>angle</code> in <code><a href="raster.html#topic+hillShade">hillShade</a></code>.</p>
</td></tr>
<tr><td><code id="demTools_+3A_sunazim">sunAzim</code></td>
<td>
<p>If <code>method = "hillShade"</code>, the sun azimuth angle in 
degree. See parameter <code>direction</code> in <code><a href="raster.html#topic+hillShade">hillShade</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If x is a Satellite object, a Satellite object with added layer containing calculated 
terrain information; if x is a <code>raster::RasterLayer</code> object, a 
<code>raster::RasterLayer</code> object with calculated terrain information.
</p>


<h3>See Also</h3>

<p><code>raster::terrain</code>, <code>raster::hillShade</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)

## dem
files_dem &lt;- list.files(path, pattern = "DEM", full.names = TRUE)
DEM &lt;- raster(files_dem)

sat &lt;- addSatDataLayer(sat, data = DEM, info = NULL, bcde = "DEM", in_bcde="DEM")
sat &lt;- demTools(sat)
</code></pre>

<hr>
<h2 id='extend'>Extend a Satellite object</h2><span id='topic+extend'></span><span id='topic+extend+2CSatellite-method'></span>

<h3>Description</h3>

<p>The function is a wrapper around <code><a href="raster.html#topic+extend">extend</a></code> to easily 
extend a Satellite object to a larger spatial extent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Satellite'
extend(x, y, subset = TRUE, value = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extend_+3A_x">x</code></td>
<td>
<p>Satellite object.</p>
</td></tr>
<tr><td><code id="extend_+3A_y">y</code></td>
<td>
<p>Target <code>Extent</code>, see <code><a href="raster.html#topic+extent">extent</a></code>.</p>
</td></tr>
<tr><td><code id="extend_+3A_subset">subset</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), all layers but the extended 
ones are being dropped, else the extended layers are appended to the initial
Satellite object.</p>
</td></tr>
<tr><td><code id="extend_+3A_value">value</code></td>
<td>
<p>Fill value assigned to new cells passed to 
<code><a href="raster.html#topic+extend">extend</a></code>, defaults to <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Satellite object consisting of extended layers only or, if 
<code>subset = FALSE</code>, a Satellite object with the extended layers appended.
</p>


<h3>See Also</h3>

<p>This function is a wrapper around <code><a href="raster.html#topic+extend">extend</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## sample data
path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)

## geographic extent of georg-gassmann-stadium (utm 32-n)
ext_ggs &lt;- raster::extent(482606.4, 482781.4, 5627239, 5627489)

## extend satellite object by specified extent
sat_ggs &lt;- extend(sat, ext_ggs)

plot(sat)
plot(sat_ggs)

## End(Not run)
</code></pre>

<hr>
<h2 id='l7'>Landsat 7 sample data</h2><span id='topic+l7'></span>

<h3>Description</h3>

<p>This dataset comes from the USGS. It contains part of the 
Landsat 7 scene LE07_L1TP_195025_20010730_20170204_01_T1 (Collection 1 
Level-1) from 2001-07-30 over Maburg, Germany.
</p>


<h3>Format</h3>

<p><code>RasterStack</code> with bands 1-8 (incl. QA) of 41 by 41 pixels.
</p>


<h3>Details</h3>

<p>Use of this data requires your agreement to the USGS regulations on 
using Landsat data.
</p>


<h3>Source</h3>

<p><a href="https://earthexplorer.usgs.gov/">https://earthexplorer.usgs.gov/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotRGB(l7, r = 3, b = 1, stretch = "hist")
</code></pre>

<hr>
<h2 id='l8'>Landsat 8 sample data</h2><span id='topic+l8'></span>

<h3>Description</h3>

<p>This dataset comes from the USGS. It contains part of the 
Landsat 8 scene LC08_L1TP_195025_20130707_20170503_01_T1 (Collection 1 
Level-1) from 2013-07-07 over Maburg, Germany.
</p>


<h3>Format</h3>

<p><code>RasterStack</code> with bands 1-7, 9-11 (incl. QA) of 41 by 41 pixels.
</p>


<h3>Details</h3>

<p>Use of this data requires your agreement to the USGS regulations on 
using Landsat data.
</p>


<h3>Source</h3>

<p><a href="https://earthexplorer.usgs.gov/">https://earthexplorer.usgs.gov/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotRGB(l8, r = 4, g = 3, b = 2, stretch = "hist") # true-color composite
plotRGB(l8, r = 5, g = 4, b = 3, stretch = "hist") # false-color composite
</code></pre>

<hr>
<h2 id='lutInfo'>Get or access internal LUT values used by various functions</h2><span id='topic+lutInfo'></span><span id='topic+lutInfoBandsFromSID'></span><span id='topic+lutInfoSensorFromSID'></span><span id='topic+lutInfoBCDEFromBID'></span><span id='topic+lutInfoBIDFromBCDE'></span><span id='topic+lutInfoRSRromSID'></span><span id='topic+lutInfoSIDfromFilename'></span><span id='topic+lutInfoSGRPfromFilename'></span>

<h3>Description</h3>

<p>Get internal look-up table (LUT) values from sysdata.rda which have been 
compiled using data-raw/lut_data.R. Metadata is stored in <code>lut$meta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lutInfo()

lutInfoBandsFromSID(sid)

lutInfoSensorFromSID(sid)

lutInfoBCDEFromBID(sid, bid)

lutInfoBIDFromBCDE(bcde, sid)

lutInfoRSRromSID(sid)

lutInfoSIDfromFilename(files)

lutInfoSGRPfromFilename(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lutInfo_+3A_sid">sid</code></td>
<td>
<p>Sensor id as returned e.g. from <code><a href="#topic+lutInfoSensorFromSID">lutInfoSensorFromSID</a></code>.</p>
</td></tr>
<tr><td><code id="lutInfo_+3A_bid">bid</code></td>
<td>
<p>Band id as returned e.g. from <code><a href="#topic+lutInfoBIDFromBCDE">lutInfoBIDFromBCDE</a></code>.</p>
</td></tr>
<tr><td><code id="lutInfo_+3A_bcde">bcde</code></td>
<td>
<p>Band code as returned e.g. from <code><a href="#topic+lutInfoBCDEFromBID">lutInfoBCDEFromBID</a></code>.</p>
</td></tr>
<tr><td><code id="lutInfo_+3A_files">files</code></td>
<td>
<p>Filename (or filepath) of one or more remote sensing data 
filenames</p>
</td></tr>
<tr><td><code id="lutInfo_+3A_file">file</code></td>
<td>
<p>Filename of a remote sensing data file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions above return the following information:
</p>

<ul>
<li> <p><code>lutInfoBandsFromSID</code> returns the band info block.
</p>
</li>
<li> <p><code>lutInfoBCDEFromBID</code> returns the band code.
</p>
</li>
<li> <p><code>lutInfoBIDFromBCDE</code> returns the band ids.
</p>
</li>
<li> <p><code>lutInfoRSRromSID</code> returns the relative spectral response (rsr) 
for the sensor.
</p>
</li>
<li> <p><code>lutInfoSensorFromSID</code> returns the sensor name.
</p>
</li></ul>

<p>The LUT contains the following band information taken, if not specified
otherwise, from the
<a href="https://www.usgs.gov/faqs/what-are-band-designations-landsat-satellites?qt-news_science_products=0#qt-news_science_products">USGS Landsat FAQ</a>:
</p>

<dl>
<dt>l4_band_wl</dt><dd><p>Minimum/maximum wavelength for Landsat 4 bands.</p>
</dd>
<dt>l5_band_wl</dt><dd><p>Minimum/maximum wavelength for Landsat 5 bands.</p>
</dd>
<dt>l7_band_wl</dt><dd><p>Minimum/maximum wavelength for Landsat 7 bands.</p>
</dd>
<dt>l8_band_wl</dt><dd><p>Minimum/maximum wavelength for Landsat 8 bands.</p>
</dd>
<dt>l7_rsr</dt><dd><p>Landat 7 rsr (nm-1) taken from the
<a href="https://landsat.usgs.gov/spectral-characteristics-viewer">spectral viewer</a>
of the USGS Landsat FAQ.</p>
</dd>
<dt>l8_rsr</dt><dd><p>Landat 8 rsr (nm-1) taken from the
<a href="https://landsat.usgs.gov/spectral-characteristics-viewer">spectral viewer</a>
of the USGS Landsat FAQ.</p>
</dd>
<dt>solar</dt><dd><p>Solar irradiance (W m-2 nm-1) taken from the 
<a href="http://rredc.nrel.gov/solar/spectra/am0/modtran.html">National Renewable 
Energy Laboratory</a>.</p>
</dd>
<dt>l7_esun</dt><dd><p>Tabulated ESun values from 
<a href="https://www.usgs.gov/media/files/landsat-7-data-users-handbook">tab 11.3 (Thuillier spectrum)</a>
of the Landsat7 handbook.</p>
</dd>
<dt>l5_esun, l4_esun</dt><dd><p>Tabulated ESun values from Chander G, Markham B 
(2003) Revised Landsat-5 TM radiometric calibration procedures and 
postcalibration dynamic ranges. IEEE Transaction on Geoscience and Remote 
Sensing 41/11, <a href="https://doi.org/10.1109/LGRS.2007.898285">doi:10.1109/LGRS.2007.898285</a>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>List containing several <code>data.frame</code> objects with LUT values.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>lutInfoBandsFromSID()</code>: 
</p>
</li>
<li> <p><code>lutInfoSensorFromSID()</code>: 
</p>
</li>
<li> <p><code>lutInfoBCDEFromBID()</code>: 
</p>
</li>
<li> <p><code>lutInfoBIDFromBCDE()</code>: 
</p>
</li>
<li> <p><code>lutInfoRSRromSID()</code>: 
</p>
</li>
<li> <p><code>lutInfoSIDfromFilename()</code>: 
</p>
</li>
<li> <p><code>lutInfoSGRPfromFilename()</code>: 
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>ls_li &lt;- lutInfo()
# str(ls_li)

</code></pre>

<hr>
<h2 id='maskInvarFeatures'>Identify pseudo-invariant features from a satellite scene</h2><span id='topic+maskInvarFeatures'></span><span id='topic+maskInvarFeatures+2CSatellite-method'></span><span id='topic+maskInvarFeatures+2CRasterStack-method'></span><span id='topic+maskInvarFeatures+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>Identify pseudo-invariant features from a satellite scene based on a 
vis, near infravis and short-wave infravis band.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Satellite'
maskInvarFeatures(x)

## S4 method for signature 'RasterStack'
maskInvarFeatures(x, quant = 0.01, id_vis = 1L, id_nir = 2L, id_swir = 3L)

## S4 method for signature 'RasterLayer'
maskInvarFeatures(x, nir, swir, quant = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maskInvarFeatures_+3A_x">x</code></td>
<td>
<p>A Satellite object or a <code>raster::RasterLayer</code> providing the 
sensor's vis band.</p>
</td></tr>
<tr><td><code id="maskInvarFeatures_+3A_quant">quant</code></td>
<td>
<p>A value v = [0...1] which is used to define the percentage
threshold values (thv) for invariant features (nir/vis ratio &lt; thv, 
swir band values &gt; 1-thv).</p>
</td></tr>
<tr><td><code id="maskInvarFeatures_+3A_id_vis">id_vis</code></td>
<td>
<p>Index of the visible band.</p>
</td></tr>
<tr><td><code id="maskInvarFeatures_+3A_id_nir">id_nir</code></td>
<td>
<p>Index of the near infravis band.</p>
</td></tr>
<tr><td><code id="maskInvarFeatures_+3A_id_swir">id_swir</code></td>
<td>
<p>Index of the short-wave infravis band.</p>
</td></tr>
<tr><td><code id="maskInvarFeatures_+3A_nir">nir</code></td>
<td>
<p>A <code>raster::RasterLayer</code> containing the sensor's nir band.</p>
</td></tr>
<tr><td><code id="maskInvarFeatures_+3A_swir">swir</code></td>
<td>
<p>A <code>raster::RasterLayer</code> containing the sensor's swir band.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Invariant features are identified as pixels which belong to the 
group of (i) the n lowest VIS/NIR ratios and of (ii) the highest n
SWIR values. The value of n is given by the parameter quant = [0...1].
</p>


<h3>Value</h3>

<p>If x is a Satellite object, a Satellite object with added layer; <br />
if x is a <code>raster::RasterLayer</code> object, a a <code>raster::RasterLayer</code> 
object with added layers (1 indicates invariant pixels, 0 otherwise).
</p>


<h3>References</h3>

<p>This function is taken and only slightly modified from the PIF
function by Sarah C. Goslee (2011). Analyzing Remote Sensing Data in R: The 
landsat Package. Journal of Statistical Software,43(4), 1-25, 
<a href="https://doi.org/10.18637/jss.v043.i04">doi:10.18637/jss.v043.i04</a>.
</p>
<p>The underlying theory has been published by Schott RJ, Salvaggio C and 
Volchok WJ (1988) Radiometric scene normalization using pseudoinvariant 
features. Remote Sensing of Environment 26/1, 
<a href="https://doi.org/10.1016/0034-4257%2888%2990116-2">doi:10.1016/0034-4257(88)90116-2</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)
sat &lt;- maskInvarFeatures(sat)

maskInvarFeatures(x = getSatDataLayer(sat, "B004n"), 
                  nir = getSatDataLayer(sat, "B005n"), 
                  swir = getSatDataLayer(sat, "B007n"))

## when dealing with a 'RasterStack'
rst &lt;- stack(files[c(6, 7, 9)])
maskInvarFeatures(rst)

</code></pre>

<hr>
<h2 id='names'>Get/set Satellite data layer names</h2><span id='topic+names'></span><span id='topic+names+2CSatellite-method'></span><span id='topic+names+3C-+2CSatellite-method'></span>

<h3>Description</h3>

<p>Get/set Satellite data layer names, i.e. the BCDE id.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Satellite'
names(x)

## S4 replacement method for signature 'Satellite'
names(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names_+3A_x">x</code></td>
<td>
<p>A Satellite object.</p>
</td></tr>
<tr><td><code id="names_+3A_value">value</code></td>
<td>
<p>Band codes of the individual data layers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Satellite data layer names as character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)
names(sat)
new_names &lt;- paste0(names(sat), "_test")
names(sat) &lt;- new_names
</code></pre>

<hr>
<h2 id='plot'>Plot a Satellite object</h2><span id='topic+plot'></span><span id='topic+plot+2CSatellite+2CANY-method'></span><span id='topic+plot+2CSatellite-method'></span>

<h3>Description</h3>

<p>This is the standard plotting routine for the 'Satellite' class. Layers are 
drawn either from the start (default; limited to a maximum of 16 sub-plots) 
or according to the speficied band codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Satellite,ANY'
plot(x, bcde = NULL, col = grDevices::grey.colors(100), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>A 'Satellite' object, usually returned by <code><a href="#topic+satellite">satellite</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_bcde">bcde</code></td>
<td>
<p>Band codes to be visualized, e.g. returned by 
<code><a href="#topic+getSatBCDE">getSatBCDE</a></code>. If not supplied, the initial (up to) 16 layers are 
being visualized.</p>
</td></tr>
<tr><td><code id="plot_+3A_col">col</code></td>
<td>
<p>Color scheme.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot.default">plot.default</a></code>, <code><a href="graphics.html#topic+par">par</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## sample data
path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)

## display data without quality flag layer
bds &lt;- getSatBCDE(sat)[1:11]
plot(sat, bcde = bds)

## End(Not run)

</code></pre>

<hr>
<h2 id='satellite'>Create a Satellite object</h2><span id='topic+satellite'></span><span id='topic+satellite+2Ccharacter-method'></span><span id='topic+satellite+2CRaster-method'></span><span id='topic+satellite+2Clist-method'></span>

<h3>Description</h3>

<p>Method to create a Satellite object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
satellite(x, meta, log)

## S4 method for signature 'Raster'
satellite(x, meta, log)

## S4 method for signature 'list'
satellite(x, meta, log)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="satellite_+3A_x">x</code></td>
<td>
<p>A vector of filenames, a (multi-layered) <code>Raster*</code> object or a 
<code>list</code> of single <code>RasterLayer</code> objects (see <code><a href="raster.html#topic+raster">raster</a></code>). 
In the latter case, be aware that bands must be arranged in ascending order 
(eg using <code><a href="#topic+sortFilesLandsat">sortFilesLandsat</a></code>).</p>
</td></tr>
<tr><td><code id="satellite_+3A_meta">meta</code></td>
<td>
<p>Optional metadata object (e.g. returned from 
<code><a href="#topic+compMetaLandsat">compMetaLandsat</a></code>). If 'x' is a satellite dataset and recognised
as &quot;Landsat&quot;, then the metadata is automatically extracted from the 
respective meta information file if both the satellite data and the metadata 
file follow the USGS Earth Explorer's naming convention.</p>
</td></tr>
<tr><td><code id="satellite_+3A_log">log</code></td>
<td>
<p>Optionally supply a log entry.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Satellite object consists of three data sections:
(i) a raster data section which holds the actual data values of the 
respective sensor bands, (ii) a metadata grid which holds meta information
for each sensor band (e.g. calibration coefficients, type of sensor band 
etc.) and (iii) a list of log information which records the processing 
history of the entire dataset.
</p>


<h3>Value</h3>

<p>A <code>Satellite</code> object.
</p>


<h3>See Also</h3>

<p>(i) <code><a href="#topic+compMetaLandsat">compMetaLandsat</a></code> to get more information about the
structure of the metadata component; (ii)
<a href="https://www.usgs.gov/faqs/what-naming-convention-landsat-collections-level-1-scenes?qt-news_science_products=0#qt-news_science_products">https://www.usgs.gov/faqs/what-naming-convention-landsat-collections-level-1-scenes?qt-news_science_products=0#qt-news_science_products</a> 
for detailed information about the naming conventions for Landsat scene 
identifiers; and (iii) <code><a href="#topic+sortFilesLandsat">sortFilesLandsat</a></code> for automated 
rearrangement of Landsat band files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 'character' input (i.e. filenames)
path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)

satellite(files)

## raster::RasterStack input
satellite(l8)

</code></pre>

<hr>
<h2 id='Satellite-class'>An S4 class to represent a complete satellite dataset</h2><span id='topic+Satellite-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a complete satellite dataset
</p>

<hr>
<h2 id='SatelliteInfo-class'>An S4 class to represent a satellite data file</h2><span id='topic+SatelliteInfo-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a satellite data file
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>name of the data file without extension</p>
</dd>
<dt><code>filepath</code></dt><dd><p>full path and file of the data file</p>
</dd>
<dt><code>path</code></dt><dd><p>path to the data file</p>
</dd>
<dt><code>file</code></dt><dd><p>filename incl. extension of the data file</p>
</dd>
<dt><code>extension</code></dt><dd><p>extension of the data file</p>
</dd>
</dl>

<hr>
<h2 id='SatelliteLayers-class'>An S4 class to represent satellite data</h2><span id='topic+SatelliteLayers-class'></span>

<h3>Description</h3>

<p>An S4 class to represent satellite data
</p>


<h3>Slots</h3>


<dl>
<dt><code>layers</code></dt><dd><p>a list object containing individual RasterLayer objects</p>
</dd>
</dl>

<hr>
<h2 id='SatelliteLog-class'>An S4 class to represent satellite log data</h2><span id='topic+SatelliteLog-class'></span>

<h3>Description</h3>

<p>An S4 class to represent satellite log data
</p>


<h3>Slots</h3>


<dl>
<dt><code>log</code></dt><dd><p>a list object containing information on individual processing steps</p>
</dd>
</dl>

<hr>
<h2 id='SatelliteMetaData-class'>An S4 class to represent satellite metadata</h2><span id='topic+SatelliteMetaData-class'></span>

<h3>Description</h3>

<p>An S4 class to represent satellite metadata
</p>


<h3>Slots</h3>


<dl>
<dt><code>meta</code></dt><dd><p>a data frame object containing the data</p>
</dd>
</dl>

<hr>
<h2 id='satInfo'>Get or access Satellite object information used by various functions</h2><span id='topic+satInfo'></span><span id='topic+getSatDataLayers'></span><span id='topic+getSatDataLayer'></span><span id='topic+getSatMeta'></span><span id='topic+getSatMetaBCDETemplate'></span><span id='topic+getSatLog'></span><span id='topic+setSatBCDE'></span><span id='topic+createSatBCDE'></span><span id='topic+addSatMetaParam'></span><span id='topic+addSatMetaEntry'></span><span id='topic+addSatLog'></span><span id='topic+addSatDataLayer'></span><span id='topic+addRasterMeta2Sat'></span><span id='topic+createRasterMetaData'></span><span id='topic+updateRasterMetaData'></span><span id='topic+countSatDataLayers'></span><span id='topic+getSatParam'></span><span id='topic+getSatBCDE'></span><span id='topic+getSatBID'></span><span id='topic+getSatSID'></span><span id='topic+getSatSensor'></span><span id='topic+getSatSensorGroup'></span><span id='topic+getSatSensorInfo'></span><span id='topic+getSatSpectrum'></span><span id='topic+getSatBCDESolar'></span><span id='topic+getSatBCDEThermal'></span><span id='topic+getSatXRes'></span><span id='topic+getSatYRes'></span><span id='topic+getSatRes'></span><span id='topic+getSatType'></span><span id='topic+getSatCalib'></span><span id='topic+getSatBCDEType'></span><span id='topic+getSatBCDEFromType'></span><span id='topic+getSatBCDEFromSpectrum'></span><span id='topic+getSatBCDESres'></span><span id='topic+getSatBCDECalib'></span><span id='topic+getSatBCDESolarCalib'></span><span id='topic+getSatBCDEThermalCalib'></span><span id='topic+getSatBandInfo'></span><span id='topic+getSatRadMax'></span><span id='topic+getSatRadMin'></span><span id='topic+getSatRefMax'></span><span id='topic+getSatRefMin'></span><span id='topic+getSatESD'></span><span id='topic+getSatESUN'></span><span id='topic+getSatSZEN'></span><span id='topic+getSatSAZM'></span><span id='topic+getSatSELV'></span><span id='topic+getSatMetaLayer'></span><span id='topic+getSatLayerfromData'></span><span id='topic+getSatLNBR'></span><span id='topic+getSatLMIN'></span><span id='topic+getSatLMAX'></span><span id='topic+getSatRADA'></span><span id='topic+getSatRADM'></span><span id='topic+getSatREFA'></span><span id='topic+getSatREFM'></span><span id='topic+getSatBTK1'></span><span id='topic+getSatBTK2'></span><span id='topic+getSatPRAD'></span><span id='topic+getSatDATE'></span><span id='topic+getSatProjection'></span>

<h3>Description</h3>

<p>Get information from class Satellite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSatDataLayers(sat, bcde = NULL)

getSatDataLayer(sat, bcde)

getSatMeta(sat, bcde)

getSatMetaBCDETemplate(sat, bcde)

getSatLog(sat)

setSatBCDE(sat, bcde)

createSatBCDE(sat, width = 3, flag = 0, prefix = "B", postfix = "n")

addSatMetaParam(sat, meta_param)

addSatMetaEntry(sat, meta_param)

addSatLog(
  sat,
  info = NA_character_,
  in_bcde = NA_character_,
  out_bcde = NA_character_
)

addSatDataLayer(sat, bcde, data, meta_param, info, in_bcde)

addRasterMeta2Sat(sat)

createRasterMetaData(rst)

updateRasterMetaData(sat, bcde)

countSatDataLayers(sat)

getSatParam(sat, param, bcde, return_bcde = TRUE)

getSatBCDE(sat, lnbr)

getSatBID(sat, bcde)

getSatSID(sat)

getSatSensor(sat)

getSatSensorGroup(sat)

getSatSensorInfo(sat)

getSatSpectrum(sat, bcde)

getSatBCDESolar(sat)

getSatBCDEThermal(sat)

getSatXRes(sat, bcde)

getSatYRes(sat, bcde)

getSatRes(sat, bcde)

getSatType(sat, bcde)

getSatCalib(sat, bcde)

getSatBCDEType(sat, bcde, type)

getSatBCDEFromType(sat, type = "VIS")

getSatBCDEFromSpectrum(sat, spectrum = "solar")

getSatBCDESres(sat, bcde, type)

getSatBCDECalib(sat, bcde, calib)

getSatBCDESolarCalib(sat, bcde, calib)

getSatBCDEThermalCalib(sat, bcde, calib)

getSatBandInfo(sat, bcde, return_calib = TRUE)

getSatRadMax(sat, bcde)

getSatRadMin(sat, bcde)

getSatRefMax(sat, bcde)

getSatRefMin(sat, bcde)

getSatESD(sat)

getSatESUN(sat, bcde)

getSatSZEN(sat, bcde)

getSatSAZM(sat, bcde)

getSatSELV(sat, bcde)

getSatMetaLayer(sat, bcde)

getSatLayerfromData(sat, bcde, nbr)

getSatLNBR(sat, bcde)

getSatLMIN(sat, bcde)

getSatLMAX(sat, bcde)

getSatRADA(sat, bcde)

getSatRADM(sat, bcde)

getSatREFA(sat, bcde)

getSatREFM(sat, bcde)

getSatBTK1(sat, bcde)

getSatBTK2(sat, bcde)

getSatPRAD(sat, bcde)

getSatDATE(sat, bcde)

getSatProjection(sat, bcde)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="satInfo_+3A_sat">sat</code></td>
<td>
<p>Satellite object (see <code><a href="#topic+satellite">satellite</a></code>).</p>
</td></tr>
<tr><td><code id="satInfo_+3A_bcde">bcde</code></td>
<td>
<p>Band code.</p>
</td></tr>
<tr><td><code id="satInfo_+3A_width">width</code>, <code id="satInfo_+3A_flag">flag</code></td>
<td>
<p>Field width and format modifier for automated creation of 
BCDE information, defaults to '3' and '0', respectively. See 
<code><a href="base.html#topic+formatC">formatC</a></code> for further details.</p>
</td></tr>
<tr><td><code id="satInfo_+3A_prefix">prefix</code>, <code id="satInfo_+3A_postfix">postfix</code></td>
<td>
<p>Prefix and postfix to be added to the created BCDE 
information.</p>
</td></tr>
<tr><td><code id="satInfo_+3A_meta_param">meta_param</code></td>
<td>
<p>Metadata parameters used to document new data layer</p>
</td></tr>
<tr><td><code id="satInfo_+3A_info">info</code></td>
<td>
<p>Log information added to metadata</p>
</td></tr>
<tr><td><code id="satInfo_+3A_in_bcde">in_bcde</code></td>
<td>
<p>BCDE of layer used as input dataset</p>
</td></tr>
<tr><td><code id="satInfo_+3A_out_bcde">out_bcde</code></td>
<td>
<p>BCDE of layer used as output dataset</p>
</td></tr>
<tr><td><code id="satInfo_+3A_data">data</code></td>
<td>
<p>Data layer of a Satellite object</p>
</td></tr>
<tr><td><code id="satInfo_+3A_rst">rst</code></td>
<td>
<p>Input raster::Raster* object from which to extract metadata.</p>
</td></tr>
<tr><td><code id="satInfo_+3A_param">param</code></td>
<td>
<p>Parameter of the metadata set (i.e. colname)</p>
</td></tr>
<tr><td><code id="satInfo_+3A_return_bcde">return_bcde</code></td>
<td>
<p>Return bcde as attribute (TRUE/FALSE)</p>
</td></tr>
<tr><td><code id="satInfo_+3A_lnbr">lnbr</code></td>
<td>
<p>Layer number</p>
</td></tr>
<tr><td><code id="satInfo_+3A_type">type</code></td>
<td>
<p>Type of the sensor band</p>
</td></tr>
<tr><td><code id="satInfo_+3A_spectrum">spectrum</code></td>
<td>
<p>Spectral region, e.g. &quot;solar&quot; or &quot;thermal&quot;.</p>
</td></tr>
<tr><td><code id="satInfo_+3A_calib">calib</code></td>
<td>
<p>Calibration information.</p>
</td></tr>
<tr><td><code id="satInfo_+3A_return_calib">return_calib</code></td>
<td>
<p>Return calibration information (TRUE/FALSE)</p>
</td></tr>
<tr><td><code id="satInfo_+3A_nbr">nbr</code></td>
<td>
<p>Return specific data layer selected by number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions are generally self-explaining in that sence that
<code>get*</code> returns the respective information and <code>set*</code> sets the
respective information from/in the Satellite object.
</p>
<p><code>addSatLog</code> adds a log entry to the Satellite object.
</p>


<h3>Value</h3>

<p>Objects of respective type (see <code><a href="#topic+satellite">satellite</a></code>).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getSatDataLayers()</code>: Return Satellite data layers
</p>
</li>
<li> <p><code>getSatDataLayer()</code>: Return Satellite data layer i
</p>
</li>
<li> <p><code>getSatMeta()</code>: Return Satellite object metadata
</p>
</li>
<li> <p><code>getSatMetaBCDETemplate()</code>: Return template for Satellite object metadata which is based on existing band
</p>
</li>
<li> <p><code>getSatLog()</code>: Return Satellite object log info
</p>
</li>
<li> <p><code>setSatBCDE()</code>: Set BCDE/data layer names of a Satellite object
</p>
</li>
<li> <p><code>createSatBCDE()</code>: If not supplied, automatically create BCDE names of a Satellite object
</p>
</li>
<li> <p><code>addSatMetaParam()</code>: Add additional or overwrite metainformation parameter to Satellite object
</p>
</li>
<li> <p><code>addSatMetaEntry()</code>: Add metainformation for an additional layer to Satellite object
</p>
</li>
<li> <p><code>addSatLog()</code>: Add new log entry to Satellite object
</p>
</li>
<li> <p><code>addSatDataLayer()</code>: Add new Satellite data layer
</p>
</li>
<li> <p><code>addRasterMeta2Sat()</code>: Add raster meta data to Satellite object meta data
</p>
</li>
<li> <p><code>createRasterMetaData()</code>: Create raster meta data
</p>
</li>
<li> <p><code>updateRasterMetaData()</code>: Create raster meta data
</p>
</li>
<li> <p><code>countSatDataLayers()</code>: Return number of Satellite data layers
</p>
</li>
<li> <p><code>getSatParam()</code>: Return parameter (general method implemented by the specific functions below)
</p>
</li>
<li> <p><code>getSatBCDE()</code>: Return Band code
</p>
</li>
<li> <p><code>getSatBID()</code>: Return Band IDs
</p>
</li>
<li> <p><code>getSatSID()</code>: Return sensor ID
</p>
</li>
<li> <p><code>getSatSensor()</code>: Return sensor
</p>
</li>
<li> <p><code>getSatSensorGroup()</code>: Return sensor group
</p>
</li>
<li> <p><code>getSatSensorInfo()</code>: Return sensor information
</p>
</li>
<li> <p><code>getSatSpectrum()</code>: Return spectrum
</p>
</li>
<li> <p><code>getSatBCDESolar()</code>: Return solar band codes
</p>
</li>
<li> <p><code>getSatBCDEThermal()</code>: Return thermal band codes
</p>
</li>
<li> <p><code>getSatXRes()</code>: Return sensor x resolution
</p>
</li>
<li> <p><code>getSatYRes()</code>: Return sensor y resolution
</p>
</li>
<li> <p><code>getSatRes()</code>: Return mean sensor resolution (mean of x and y res)
</p>
</li>
<li> <p><code>getSatType()</code>: Return sensor type
</p>
</li>
<li> <p><code>getSatCalib()</code>: Return calibration level
</p>
</li>
<li> <p><code>getSatBCDEType()</code>: Return TYPE band codes
</p>
</li>
<li> <p><code>getSatBCDEFromType()</code>: Return BCDE matching TYPE
</p>
</li>
<li> <p><code>getSatBCDEFromSpectrum()</code>: Return BCDE matching TYPE
</p>
</li>
<li> <p><code>getSatBCDESres()</code>: Return the mean of x and y resolution for band codes matching type
</p>
</li>
<li> <p><code>getSatBCDECalib()</code>: Return calibration level for band codes matching type
</p>
</li>
<li> <p><code>getSatBCDESolarCalib()</code>: Return calibration level for band codes machting type and are solar bands
</p>
</li>
<li> <p><code>getSatBCDEThermalCalib()</code>: Return calibration level for band codes machting type and are thermal bands
</p>
</li>
<li> <p><code>getSatBandInfo()</code>: Return band information
</p>
</li>
<li> <p><code>getSatRadMax()</code>: Return maximum radiance for bcde
</p>
</li>
<li> <p><code>getSatRadMin()</code>: Return minimum radiance for bcde
</p>
</li>
<li> <p><code>getSatRefMax()</code>: Return maximum reflectance for bcde
</p>
</li>
<li> <p><code>getSatRefMin()</code>: Return minimum reflectance for bcde
</p>
</li>
<li> <p><code>getSatESD()</code>: Return earth-sun distance
</p>
</li>
<li> <p><code>getSatESUN()</code>: Return actual solar TOA irradiance
</p>
</li>
<li> <p><code>getSatSZEN()</code>: Return sun zenith angle
</p>
</li>
<li> <p><code>getSatSAZM()</code>: Return sun azimuth angle
</p>
</li>
<li> <p><code>getSatSELV()</code>: Return Sun elevation
</p>
</li>
<li> <p><code>getSatMetaLayer()</code>: Return Layer name from metadata
</p>
</li>
<li> <p><code>getSatLayerfromData()</code>: Return Layer name from data layer
</p>
</li>
<li> <p><code>getSatLNBR()</code>: Return Layer number
</p>
</li>
<li> <p><code>getSatLMIN()</code>: Return minimum wavelength of the sensor band
</p>
</li>
<li> <p><code>getSatLMAX()</code>: Return maximum wavelength of the sensor band
</p>
</li>
<li> <p><code>getSatRADA()</code>: Return addition coefficient for SC to radiance conversion
</p>
</li>
<li> <p><code>getSatRADM()</code>: Return multiplicative coefficient for SC to radiance conversion
</p>
</li>
<li> <p><code>getSatREFA()</code>: Return addition coefficient for SC to reflectance
</p>
</li>
<li> <p><code>getSatREFM()</code>: Return multiplicative coefficient for SC to reflectance
</p>
</li>
<li> <p><code>getSatBTK1()</code>: Return calibration coefficent to convert SC to brightness temperature
</p>
</li>
<li> <p><code>getSatBTK2()</code>: Return calibration coefficent to convert SC to brightness temperature
</p>
</li>
<li> <p><code>getSatDATE()</code>: Return DATE
</p>
</li>
<li> <p><code>getSatProjection()</code>: Return projection
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># List of input files
path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)

# Raster stack l8
sat &lt;- satellite(l8)

</code></pre>

<hr>
<h2 id='stack'>Convert selected layers of a Satellite object to a RasterStack</h2><span id='topic+stack'></span><span id='topic+stack+2CSatellite-method'></span>

<h3>Description</h3>

<p>Convert selected layers of a Satellite object to a RasterStack
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Satellite'
stack(x, layer = names(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack_+3A_x">x</code></td>
<td>
<p>an object of class 'Satellite'</p>
</td></tr>
<tr><td><code id="stack_+3A_layer">layer</code></td>
<td>
<p>character vector (bcde codes) or integer vector (index) of 
the layers to be stacked</p>
</td></tr>
<tr><td><code id="stack_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code><a href="#topic+stack">stack</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)

stck &lt;- stack(sat, c("B001n", "B002n", "B003n"))
stck

</code></pre>

<hr>
<h2 id='subset'>Subset of Satellite object data layers</h2><span id='topic+subset'></span><span id='topic+subset+2CSatellite-method'></span><span id='topic++5B+5B+2CSatellite+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>Create a subset of data layers from a <code>Satellite</code> object and return it 
as a standalone <code>Satellite</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Satellite'
subset(x, sid, cid)

## S4 method for signature 'Satellite,ANY,ANY'
x[[i]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_+3A_x">x</code></td>
<td>
<p>Satellite object providing the source band(s) to be adjusted.</p>
</td></tr>
<tr><td><code id="subset_+3A_sid">sid</code></td>
<td>
<p>Band numbers or bcde which should be extracted</p>
</td></tr>
<tr><td><code id="subset_+3A_cid">cid</code></td>
<td>
<p>Calibration information used for subsetting (only works if sid is
not supplied to the function)</p>
</td></tr>
<tr><td><code id="subset_+3A_i">i</code></td>
<td>
<p>Layer index(es) for subsetting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Satellite object
</p>
<p>A Satellite object
</p>
<p>A Satellite object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## sample data
path &lt;- system.file("extdata", package = "satellite")
files &lt;- list.files(path, pattern = glob2rx("LC08*.TIF"), full.names = TRUE)
sat &lt;- satellite(files)

sat[[2:5]]
subset(sat, cid = "SC")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
