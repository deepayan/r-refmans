<!DOCTYPE html><html lang="en"><head><title>Help for package designit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {designit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#designit-package'><p>designit: Blocking and Randomization for Experimental Design</p></a></li>
<li><a href='#.datatable.aware'><p>Show that the package is designed to rely on data.table functionality</p></a></li>
<li><a href='#accept_leftmost_improvement'><p>Alternative acceptance function for multi-dimensional scores in which order (left to right, e.g. first to last) denotes relevance.</p></a></li>
<li><a href='#accept_strict_improvement'><p>Default acceptance function. Accept current score if and only if all elements are less than or equal than in best score</p>
and there's at least one improvement.</a></li>
<li><a href='#all_equal_df'><p>Compare two data.frames.</p></a></li>
<li><a href='#assign_from_table'><p>Distributes samples based on a sample sheet.</p></a></li>
<li><a href='#assign_in_order'><p>Distributes samples in order.</p></a></li>
<li><a href='#assign_random'><p>Assignment function which distributes samples randomly.</p></a></li>
<li><a href='#batch_container_from_table'><p>Creates a BatchContainer from a table</p>
(data.frame/tibble::tibble) containing sample and location information.</a></li>
<li><a href='#BatchContainer'><p>R6 Class representing a batch container.</p></a></li>
<li><a href='#BatchContainerDimension'><p>R6 Class representing a batch container dimension.</p></a></li>
<li><a href='#compile_possible_subgroup_allocation'><p>Compile list of all possible ways to assign levels of the allocation variable to a given set of subgroups</p></a></li>
<li><a href='#complete_random_shuffling'><p>Reshuffle sample indices completely randomly</p></a></li>
<li><a href='#drop_order'><p>Drop highest order interactions</p></a></li>
<li><a href='#extract_shuffle_params'><p>Extract relevant parameters from a generic shuffle function output</p></a></li>
<li><a href='#find_possible_block_allocations'><p>Internal function to generate possible subgroup combinations that add up to specific levels of an allocation variable</p></a></li>
<li><a href='#first_score_only'><p>Aggregation of scores: take first (primary) score only</p></a></li>
<li><a href='#form_homogeneous_subgroups'><p>Form groups and subgroups of 'homogeneous' samples as defined by certain variables and size constraints</p></a></li>
<li><a href='#generate_terms'><p>Generate <code>terms.object</code> (formula with attributes)</p></a></li>
<li><a href='#get_order'><p>Get highest order interaction</p></a></li>
<li><a href='#invivo_study_samples'><p>A sample list from an in vivo experiment with multiple treatments and 2 strains</p></a></li>
<li><a href='#invivo_study_treatments'><p>A treatment list together with additional constraints on the strain and sex of animals</p></a></li>
<li><a href='#L1_norm'><p>Aggregation of scores: L1 norm</p></a></li>
<li><a href='#L2s_norm'><p>Aggregation of scores: L2 norm squared</p></a></li>
<li><a href='#locations_table_from_dimensions'><p>Create locations table from dimensions and exclude table</p></a></li>
<li><a href='#longitudinal_subject_samples'><p>Subject sample list with group and time plus controls</p></a></li>
<li><a href='#make_colnames'><p>Make matrix column names unique.</p></a></li>
<li><a href='#mk_autoscale_function'><p>Create a function that transforms a current (multi-dimensional) score into a boxcox normalized one</p></a></li>
<li><a href='#mk_constant_swapping_function'><p>Create function to propose n pairwise swaps of samples on each call (n is a constant across iterations)</p></a></li>
<li><a href='#mk_dist_matrix'><p>Internal helper function to set up an (n m) x (n m) pairwise distance matrix for a plate with n rows and m columns</p></a></li>
<li><a href='#mk_exponentially_weighted_acceptance_func'><p>Alternative acceptance function for multi-dimensional scores with exponentially downweighted score improvements from left to right</p></a></li>
<li><a href='#mk_plate_scoring_functions'><p>Create a list of scoring functions (one per plate) that quantify the spatially homogeneous distribution of conditions across the plate</p></a></li>
<li><a href='#mk_simanneal_acceptance_func'><p>Generate acceptance function for an optimization protocol based on simulated annealing</p></a></li>
<li><a href='#mk_simanneal_temp_func'><p>Create a temperature function that returns the annealing temperature at a given step (iteration)</p></a></li>
<li><a href='#mk_subgroup_shuffling_function'><p>Created a shuffling function that permutes samples within certain subgroups of the container locations</p></a></li>
<li><a href='#mk_swapping_function'><p>Create function to propose swaps of samples on each call, either with a constant number of swaps or following</p>
a user defined protocol</a></li>
<li><a href='#multi_trt_day_samples'><p>Unbalanced treatment and time sample list</p></a></li>
<li><a href='#optimize_design'><p>Generic optimizer that can be customized by user provided functions for generating shuffles and progressing towards the minimal score</p></a></li>
<li><a href='#optimize_multi_plate_design'><p>Convenience wrapper to optimize a typical multi-plate design</p></a></li>
<li><a href='#osat_score'><p>Compute OSAT score for sample assignment.</p></a></li>
<li><a href='#osat_score_generator'><p>Convenience wrapper for the OSAT score</p></a></li>
<li><a href='#pairwise_swapping'><p>Proposes pairwise swap of samples on each call.</p></a></li>
<li><a href='#plate_effect_example'><p>Example dataset with a plate effect</p></a></li>
<li><a href='#plot_plate'><p>Plot plate layouts</p></a></li>
<li><a href='#random_score_variances'><p>Estimate the variance of individual scores by a series of completely random sample permutations</p></a></li>
<li><a href='#report_scores'><p>Helper function to print out one set of scores plus (if needed) aggregated values</p></a></li>
<li><a href='#sample_random_scores'><p>Sample scores from a number of completely random sample permutations</p></a></li>
<li><a href='#shrink_mat'><p>Shrinks a matrix with scores and adds an iteration column.</p></a></li>
<li><a href='#shuffle_grouped_data'><p>Generate in one go a shuffling function that produces permutations with specific constraints on multiple sample variables and group sizes fitting one specific allocation variable</p></a></li>
<li><a href='#shuffle_with_constraints'><p>Shuffling proposal function with constraints.</p></a></li>
<li><a href='#shuffle_with_subgroup_formation'><p>Compose shuffling function based on already available subgrouping and allocation information</p></a></li>
<li><a href='#simanneal_acceptance_prob'><p>Acceptance probability for a new solution</p></a></li>
<li><a href='#sum_scores'><p>Aggregation of scores: sum up all individual scores</p></a></li>
<li><a href='#update_batchcontainer'><p>Updates a batch container by permuting samples according to a shuffling</p></a></li>
<li><a href='#validate_samples'><p>Validates sample data.frame.</p></a></li>
<li><a href='#validate_subgrouping_object'><p>Validate subgroup object and stop with error message if not all required fields are there</p></a></li>
<li><a href='#worst_score'><p>Aggregation of scores: take the maximum (i.e. worst score only)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Blocking and Randomization for Experimental Design</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Intelligently assign samples to batches in order to reduce batch effects.
    Batch effects can have a significant impact on data analysis, especially
    when the assignment of samples to batches coincides with the contrast
    groups being studied. By defining a batch container and a scoring function
    that reflects the contrasts, this package allows users to assign samples in
    a way that minimizes the potential impact of batch effects on the
    comparison of interest. Among other functionality, we provide an
    implementation for OSAT score by Yan et al. (2012,
    &lt;<a href="https://doi.org/10.1186%2F1471-2164-13-689">doi:10.1186/1471-2164-13-689</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bedapub.github.io/designit/">https://bedapub.github.io/designit/</a>,
<a href="https://github.com/BEDApub/designit/">https://github.com/BEDApub/designit/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/BEDApub/designit/issues">https://github.com/BEDApub/designit/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang (&ge; 0.4.0), dplyr (&ge; 1.0.0), purrr, ggplot2, scales,
tibble, tidyr, assertthat, stringr, R6, data.table, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, roxygen2, pkgdown, knitr, markdown, rmarkdown, gt,
bench, OSAT, tidyverse, printr, devtools (&ge; 2.0.0), ggpattern,
cowplot, bestNormalize, here</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-19 09:27:56 UTC; davydovi</td>
</tr>
<tr>
<td>Author:</td>
<td>Iakov I. Davydov <a href="https://orcid.org/0000-0003-3510-3926"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Juliane Siebourg-Polster
    <a href="https://orcid.org/0000-0002-1759-3223"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cph],
  Guido Steiner [aut, cph],
  Konrad Rudolph <a href="https://orcid.org/0000-0002-9866-7051"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Jitao David Zhang <a href="https://orcid.org/0000-0002-3085-0909"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Balazs Banfai <a href="https://orcid.org/0000-0003-0422-7977"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  F. Hoffman-La Roche [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Iakov I. Davydov &lt;iakov.davydov@roche.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-21 14:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='designit-package'>designit: Blocking and Randomization for Experimental Design</h2><span id='topic+designit'></span><span id='topic+designit-package'></span>

<h3>Description</h3>

<p>Intelligently assign samples to batches in order to reduce batch effects. Batch effects can have a significant impact on data analysis, especially when the assignment of samples to batches coincides with the contrast groups being studied. By defining a batch container and a scoring function that reflects the contrasts, this package allows users to assign samples in a way that minimizes the potential impact of batch effects on the comparison of interest. Among other functionality, we provide an implementation for OSAT score by Yan et al. (2012, <a href="https://doi.org/10.1186/1471-2164-13-689">doi:10.1186/1471-2164-13-689</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Iakov I. Davydov <a href="mailto:iakov.davydov@roche.com">iakov.davydov@roche.com</a> (<a href="https://orcid.org/0000-0003-3510-3926">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Juliane Siebourg-Polster <a href="mailto:juliane.siebourg-polster@roche.com">juliane.siebourg-polster@roche.com</a> (<a href="https://orcid.org/0000-0002-1759-3223">ORCID</a>) [copyright holder]
</p>
</li>
<li><p> Guido Steiner <a href="mailto:guido.steiner@roche.com">guido.steiner@roche.com</a> [copyright holder]
</p>
</li>
<li><p> Jitao David Zhang <a href="mailto:jitao_david.zhang@roche.com">jitao_david.zhang@roche.com</a> (<a href="https://orcid.org/0000-0002-3085-0909">ORCID</a>) [copyright holder]
</p>
</li>
<li><p> Balazs Banfai <a href="mailto:balazs.banfai@roche.com">balazs.banfai@roche.com</a> (<a href="https://orcid.org/0000-0003-0422-7977">ORCID</a>) [copyright holder]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Konrad Rudolph <a href="mailto:konrad.rudolph@roche.com">konrad.rudolph@roche.com</a> (<a href="https://orcid.org/0000-0002-9866-7051">ORCID</a>) [contributor]
</p>
</li>
<li><p> F. Hoffman-La Roche [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://bedapub.github.io/designit/">https://bedapub.github.io/designit/</a>
</p>
</li>
<li> <p><a href="https://github.com/BEDApub/designit/">https://github.com/BEDApub/designit/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/BEDApub/designit/issues">https://github.com/BEDApub/designit/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.datatable.aware'>Show that the package is designed to rely on data.table functionality</h2><span id='topic+.datatable.aware'></span>

<h3>Description</h3>

<p>See <code><a href="data.table.html#topic+assign">data.table::let()</a></code> and
<code>vignette("datatable-importing", "data.table")</code>
section &quot;data.table in Imports but nothing imported&quot;.
</p>

<hr>
<h2 id='accept_leftmost_improvement'>Alternative acceptance function for multi-dimensional scores in which order (left to right, e.g. first to last) denotes relevance.</h2><span id='topic+accept_leftmost_improvement'></span>

<h3>Description</h3>

<p>Alternative acceptance function for multi-dimensional scores in which order (left to right, e.g. first to last) denotes relevance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accept_leftmost_improvement(current_score, best_score, ..., tolerance = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="accept_leftmost_improvement_+3A_current_score">current_score</code></td>
<td>
<p>One- or multi-dimensional score from the current optimizing iteration (double or vector of doubles)</p>
</td></tr>
<tr><td><code id="accept_leftmost_improvement_+3A_best_score">best_score</code></td>
<td>
<p>Best one- or multi-dimensional score found so far (double or vector of doubles)</p>
</td></tr>
<tr><td><code id="accept_leftmost_improvement_+3A_...">...</code></td>
<td>
<p>Ignored arguments that may be used by alternative acceptance functions</p>
</td></tr>
<tr><td><code id="accept_leftmost_improvement_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance value: When comparing score vectors from left to right, differences within +/- tol won't immediately
shortcut the comparison at this point, allowing improvement in a less important score to exhibit some influence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean, TRUE if current score should be taken as the new optimal score, FALSE otherwise
</p>

<hr>
<h2 id='accept_strict_improvement'>Default acceptance function. Accept current score if and only if all elements are less than or equal than in best score
and there's at least one improvement.</h2><span id='topic+accept_strict_improvement'></span>

<h3>Description</h3>

<p>Default acceptance function. Accept current score if and only if all elements are less than or equal than in best score
and there's at least one improvement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accept_strict_improvement(current_score, best_score, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="accept_strict_improvement_+3A_current_score">current_score</code></td>
<td>
<p>One- or multi-dimensional score from the current optimizing iteration (double or vector of doubles)</p>
</td></tr>
<tr><td><code id="accept_strict_improvement_+3A_best_score">best_score</code></td>
<td>
<p>Best one- or multi-dimensional score found so far (double or vector of doubles)</p>
</td></tr>
<tr><td><code id="accept_strict_improvement_+3A_...">...</code></td>
<td>
<p>Ignored arguments that may be used by alternative acceptance functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean, TRUE if current score should be taken as the new optimal score, FALSE otherwise
</p>

<hr>
<h2 id='all_equal_df'>Compare two data.frames.</h2><span id='topic+all_equal_df'></span>

<h3>Description</h3>

<p>This will convert factors to characters and disregard
row and column order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_equal_df(df1, df2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all_equal_df_+3A_df1">df1</code></td>
<td>
<p>first <code><a href="base.html#topic+data.frame">data.frame()</a></code> to compare</p>
</td></tr>
<tr><td><code id="all_equal_df_+3A_df2">df2</code></td>
<td>
<p>second <code>data.frame()</code> to compare</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code> in case differences are present
</p>

<hr>
<h2 id='assign_from_table'>Distributes samples based on a sample sheet.</h2><span id='topic+assign_from_table'></span>

<h3>Description</h3>

<p>Distributes samples based on a sample sheet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_from_table(batch_container, samples)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assign_from_table_+3A_batch_container">batch_container</code></td>
<td>
<p>Instance of BatchContainer class</p>
</td></tr>
<tr><td><code id="assign_from_table_+3A_samples">samples</code></td>
<td>
<p><code>data.frame</code> with samples (a sample sheet). This <code>data.frame</code>
(or <code>tibble::tibble()</code>) should contain samples together with their locations. No <code>.sample_id</code>
column can be present in the sample sheet. In <code>batch_container</code> already has samples assigned,
the function will check if samples in <code>batch_container</code> are identical to the ones in the
<code>samples</code> argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a new <code>BatchContainer</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bc &lt;- BatchContainer$new(
  dimensions = list(
    plate = 2,
    column = list(values = letters[1:3]),
    row = 3
  )
)

sample_sheet &lt;- tibble::tribble(
  ~plate, ~column, ~row, ~sampleID, ~group,
  1, "a", 1, 1, "TRT",
  1, "b", 2, 2, "CNTRL",
  2, "a", 1, 3, "TRT",
  2, "b", 2, 4, "CNTRL",
  2, "a", 3, 5, "TRT",
)
# assign samples from the sample sheet
bc &lt;- assign_from_table(bc, sample_sheet)

bc$get_samples(remove_empty_locations = TRUE)

</code></pre>

<hr>
<h2 id='assign_in_order'>Distributes samples in order.</h2><span id='topic+assign_in_order'></span>

<h3>Description</h3>

<p>First sample is assigned to the first location, second
sample is assigned to the second location, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_in_order(batch_container, samples = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assign_in_order_+3A_batch_container">batch_container</code></td>
<td>
<p>Instance of BatchContainer class</p>
</td></tr>
<tr><td><code id="assign_in_order_+3A_samples">samples</code></td>
<td>
<p>data.frame with samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a new <code>BatchContainer</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>samples &lt;- data.frame(sampId = 1:3, sampName = letters[1:3])
samples

bc &lt;- BatchContainer$new(dimensions = c("row" = 3, "column" = 2))
bc

set.seed(42)
# assigns samples randomly
bc &lt;- assign_random(bc, samples)
bc$get_samples()

# assigns samples in order
bc &lt;- assign_in_order(bc)
bc$get_samples()
</code></pre>

<hr>
<h2 id='assign_random'>Assignment function which distributes samples randomly.</h2><span id='topic+assign_random'></span>

<h3>Description</h3>

<p>Assignment function which distributes samples randomly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_random(batch_container, samples = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assign_random_+3A_batch_container">batch_container</code></td>
<td>
<p>Instance of BatchContainer class</p>
</td></tr>
<tr><td><code id="assign_random_+3A_samples">samples</code></td>
<td>
<p>data.frame with samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a new <code>BatchContainer</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>samples &lt;- data.frame(sampId = 1:3, sampName = letters[1:3])
samples

bc &lt;- BatchContainer$new(dimensions = c("row" = 3, "column" = 2))
bc

set.seed(42)
# assigns samples randomly
bc &lt;- assign_random(bc, samples)
bc$get_samples()

# assigns samples in order
bc &lt;- assign_in_order(bc)
bc$get_samples()
</code></pre>

<hr>
<h2 id='batch_container_from_table'>Creates a <a href="#topic+BatchContainer">BatchContainer</a> from a table
(<a href="base.html#topic+data.frame">data.frame</a>/<a href="tibble.html#topic+tibble">tibble::tibble</a>) containing sample and location information.</h2><span id='topic+batch_container_from_table'></span>

<h3>Description</h3>

<p>Creates a <a href="#topic+BatchContainer">BatchContainer</a> from a table
(<a href="base.html#topic+data.frame">data.frame</a>/<a href="tibble.html#topic+tibble">tibble::tibble</a>) containing sample and location information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batch_container_from_table(tab, location_cols)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="batch_container_from_table_+3A_tab">tab</code></td>
<td>
<p>A table with location and sample information.
Table rows with all <code>NA</code>s in sample information columns are treated as empty
locations.</p>
</td></tr>
<tr><td><code id="batch_container_from_table_+3A_location_cols">location_cols</code></td>
<td>
<p>Names of columns containing information about locations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+BatchContainer">BatchContainer</a> assigned samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- data.frame(
  row = rep(1:3, each = 3),
  column = rep(1:3, 3),
  sample_id = c(1, 2, 3, NA, 5, 6, 7, NA, 9)
)
bc &lt;- batch_container_from_table(tab, location_cols = c("row", "column"))
</code></pre>

<hr>
<h2 id='BatchContainer'>R6 Class representing a batch container.</h2><span id='topic+BatchContainer'></span>

<h3>Description</h3>

<p>Describes container dimensions and samples to container location assignment.
</p>


<h3>Details</h3>

<p>A typical workflow starts with creating a <code>BatchContainer</code>. Then
samples can be assigned to locations in that container.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>trace</code></dt><dd><p>Optimization trace, a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code></p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>scoring_f</code></dt><dd><p>Scoring functions used for optimization.
Each scoring function should receive a <a href="#topic+BatchContainer">BatchContainer</a>.
This function should return a floating
point score value for the assignment. This a list of functions.
Upon assignment a single function will be automatically converted to a list
In the later case each function is called.</p>
</dd>
<dt><code>has_samples</code></dt><dd><p>Returns TRUE if <code>BatchContainer</code> has samples.</p>
</dd>
<dt><code>has_samples_attr</code></dt><dd><p>Returns TRUE if <code>BatchContainer</code> has sample atrributes assigned.</p>
</dd>
<dt><code>n_locations</code></dt><dd><p>Returns number of locations in a <code>BatchContainer</code>.</p>
</dd>
<dt><code>n_dimensions</code></dt><dd><p>Returns number of dimensions in a <code>BatchContainer</code>.
This field cannot be assigned.</p>
</dd>
<dt><code>dimension_names</code></dt><dd><p><a href="base.html#topic+character">character</a> vector with dimension names.
This field cannot be assigned.</p>
</dd>
<dt><code>samples</code></dt><dd><p>Samples in the batch container.
When assigning data.frame should not have column named .sample_id column.</p>
</dd>
<dt><code>samples_attr</code></dt><dd><p>Extra attributes of samples. If set, this is included into
<code>BatchContainer$get_samples()</code> output.</p>
</dd>
<dt><code>assignment</code></dt><dd><p>Sample assignment vector. Should contain NAs for empty locations.
</p>
<p>Assigning this field is deprecated, please use <code style="white-space: pre;">&#8288;$move_samples()&#8288;</code> instead.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-BatchContainer-new"><code>BatchContainer$new()</code></a>
</p>
</li>
<li> <p><a href="#method-BatchContainer-get_samples"><code>BatchContainer$get_samples()</code></a>
</p>
</li>
<li> <p><a href="#method-BatchContainer-get_locations"><code>BatchContainer$get_locations()</code></a>
</p>
</li>
<li> <p><a href="#method-BatchContainer-move_samples"><code>BatchContainer$move_samples()</code></a>
</p>
</li>
<li> <p><a href="#method-BatchContainer-score"><code>BatchContainer$score()</code></a>
</p>
</li>
<li> <p><a href="#method-BatchContainer-copy"><code>BatchContainer$copy()</code></a>
</p>
</li>
<li> <p><a href="#method-BatchContainer-print"><code>BatchContainer$print()</code></a>
</p>
</li>
<li> <p><a href="#method-BatchContainer-scores_table"><code>BatchContainer$scores_table()</code></a>
</p>
</li>
<li> <p><a href="#method-BatchContainer-plot_trace"><code>BatchContainer$plot_trace()</code></a>
</p>
</li></ul>


<hr>
<a id="method-BatchContainer-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new BatchContainer object.
</p>


<h5>Usage</h5>

<div class="r"><pre>BatchContainer$new(locations_table, dimensions, exclude = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>locations_table</code></dt><dd><p>A table with available locations.</p>
</dd>
<dt><code>dimensions</code></dt><dd><p>A vector or list of dimensions. Every dimension
should have a name. Could be an integer vector of dimensions or
a named list. Every value of a list could be either dimension size
or parameters for
<a href="#topic+BatchContainerDimension">BatchContainerDimension$new()</a>.
Can be used as an alternative to passing <code>locations_table</code>.</p>
</dd>
<dt><code>exclude</code></dt><dd><p><a href="base.html#topic+data.frame">data.frame</a> with excluded locations of a container.
Only used together with dimensions.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>bc &lt;- BatchContainer$new(
  dimensions = list(
    "plate" = 3,
    "row" = list(values = letters[1:3]),
    "column" = list(values = c(1, 3))
  ),
  exclude = data.frame(plate = 1, row = "a", column = c(1, 3), stringsAsFactors = FALSE)
)

bc
</pre>
</div>


<hr>
<a id="method-BatchContainer-get_samples"></a>



<h4>Method <code>get_samples()</code></h4>

<p>Return table with samples and sample assignment.
</p>


<h5>Usage</h5>

<div class="r"><pre>BatchContainer$get_samples(
  assignment = TRUE,
  include_id = FALSE,
  remove_empty_locations = FALSE,
  as_tibble = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>assignment</code></dt><dd><p>Return sample assignment. If FALSE, only
samples table is returned, with out batch assignment.</p>
</dd>
<dt><code>include_id</code></dt><dd><p>Keep .sample_id in the table. Use <code>TRUE</code> for
lower overhead.</p>
</dd>
<dt><code>remove_empty_locations</code></dt><dd><p>Removes empty locations
from the result tibble.</p>
</dd>
<dt><code>as_tibble</code></dt><dd><p>Return <code><a href="tibble.html#topic+tibble">tibble</a></code>.
If <code>FALSE</code> returns <code><a href="data.table.html#topic+data.table">data.table</a></code>. This should have
lower overhead, as internally there is a cached <code><a href="data.table.html#topic+data.table">data.table</a></code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>table with samples and sample assignment.
</p>


<hr>
<a id="method-BatchContainer-get_locations"></a>



<h4>Method <code>get_locations()</code></h4>

<p>Get a table with all the locations in a <code>BatchContainer</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>BatchContainer$get_locations()</pre></div>



<h5>Returns</h5>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> with all the available locations.
</p>


<hr>
<a id="method-BatchContainer-move_samples"></a>



<h4>Method <code>move_samples()</code></h4>

<p>Move samples between locations
</p>
<p>This method can receive either <code>src</code> and <code>dst</code> or <code>locations_assignment</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>BatchContainer$move_samples(src, dst, location_assignment)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>src</code></dt><dd><p>integer vector of source locations</p>
</dd>
<dt><code>dst</code></dt><dd><p>integer vector of destination locations (the same length as <code>src</code>).</p>
</dd>
<dt><code>location_assignment</code></dt><dd><p>integer vector with location assignment.
The length of the vector should match the number of locations,
<code>NA</code> should be used for empty locations.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>BatchContainer</code>, invisibly
</p>


<hr>
<a id="method-BatchContainer-score"></a>



<h4>Method <code>score()</code></h4>

<p>Score current sample assignment,
</p>


<h5>Usage</h5>

<div class="r"><pre>BatchContainer$score(scoring)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>scoring</code></dt><dd><p>a function or a names list of scoring functions.
Each function should return a numeric vector.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Returns a named vector of all scoring functions values.
</p>


<hr>
<a id="method-BatchContainer-copy"></a>



<h4>Method <code>copy()</code></h4>

<p>Create an independent copy (clone) of a <code>BatchContainer</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>BatchContainer$copy()</pre></div>



<h5>Returns</h5>

<p>Returns a new <code>BatchContainer</code>
</p>


<hr>
<a id="method-BatchContainer-print"></a>



<h4>Method <code>print()</code></h4>

<p>Prints information about <code>BatchContainer</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>BatchContainer$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>not used.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-BatchContainer-scores_table"></a>



<h4>Method <code>scores_table()</code></h4>

<p>Return a table with scores from an optimization.
</p>


<h5>Usage</h5>

<div class="r"><pre>BatchContainer$scores_table(index = NULL, include_aggregated = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>optimization index, all by default</p>
</dd>
<dt><code>include_aggregated</code></dt><dd><p>include aggregated scores</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with scores
</p>


<hr>
<a id="method-BatchContainer-plot_trace"></a>



<h4>Method <code>plot_trace()</code></h4>

<p>Plot trace
</p>


<h5>Usage</h5>

<div class="r"><pre>BatchContainer$plot_trace(index = NULL, include_aggregated = FALSE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>optimization index, all by default</p>
</dd>
<dt><code>include_aggregated</code></dt><dd><p>include aggregated scores</p>
</dd>
<dt><code>...</code></dt><dd><p>not used.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> object
List of scoring functions.
Tibble with batch container locations.
Tibble with sample information and sample ids.
Sample attributes, a data.table.
Vector with assignment of sample ids to locations.
Cached data.table with samples assignment.
Validate sample assignment.
</p>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `BatchContainer$new`
## ------------------------------------------------

bc &lt;- BatchContainer$new(
  dimensions = list(
    "plate" = 3,
    "row" = list(values = letters[1:3]),
    "column" = list(values = c(1, 3))
  ),
  exclude = data.frame(plate = 1, row = "a", column = c(1, 3), stringsAsFactors = FALSE)
)

bc
</code></pre>

<hr>
<h2 id='BatchContainerDimension'>R6 Class representing a batch container dimension.</h2><span id='topic+BatchContainerDimension'></span>

<h3>Description</h3>

<p>R6 Class representing a batch container dimension.
</p>
<p>R6 Class representing a batch container dimension.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>name</code></dt><dd><p>dimension name.</p>
</dd>
<dt><code>values</code></dt><dd><p>vector of dimension values.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>size</code></dt><dd><p>Returns size of a dimension.</p>
</dd>
<dt><code>short_info</code></dt><dd><p>Returns a string summarizing the dimension.
E.g., &quot;mydim&lt;size=10&gt;&quot;.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-BatchContainerDimension-new"><code>BatchContainerDimension$new()</code></a>
</p>
</li>
<li> <p><a href="#method-BatchContainerDimension-clone"><code>BatchContainerDimension$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-BatchContainerDimension-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new BatchContainerDimension object.
</p>
<p>This is usually used implicitly via <code><a href="#topic+BatchContainer">BatchContainer$new()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>BatchContainerDimension$new(name, size = NULL, values = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Dimension name, a character string. Requiered.</p>
</dd>
<dt><code>size</code></dt><dd><p>Dimension size. Setting this implies that dimension values are 1:<code>size</code>.</p>
</dd>
<dt><code>values</code></dt><dd><p>Explicit list of dimension values. Could be numeric, character or factor.
</p>
<p>It is required to provide dimension namd and either size of values.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>plate_dimension &lt;- BatchContainerDimension$new("plate", size=3)
row_dimension &lt;- BatchContainerDimension$new("row", values = letters[1:3])
column_dimension &lt;- BatchContainerDimension$new("column", values = 1:3)

bc &lt;- BatchContainer$new(
  dimensions = list(plate_dimension, row_dimension, column_dimension),
  exclude = data.frame(plate = 1, row = "a", column = c(1, 3), stringsAsFactors = FALSE)
)

bc
</pre>
</div>


<hr>
<a id="method-BatchContainerDimension-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>BatchContainerDimension$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `BatchContainerDimension$new`
## ------------------------------------------------

plate_dimension &lt;- BatchContainerDimension$new("plate", size=3)
row_dimension &lt;- BatchContainerDimension$new("row", values = letters[1:3])
column_dimension &lt;- BatchContainerDimension$new("column", values = 1:3)

bc &lt;- BatchContainer$new(
  dimensions = list(plate_dimension, row_dimension, column_dimension),
  exclude = data.frame(plate = 1, row = "a", column = c(1, 3), stringsAsFactors = FALSE)
)

bc
</code></pre>

<hr>
<h2 id='compile_possible_subgroup_allocation'>Compile list of all possible ways to assign levels of the allocation variable to a given set of subgroups</h2><span id='topic+compile_possible_subgroup_allocation'></span>

<h3>Description</h3>

<p>All information needed to perform this function (primarily the number and size of subgroups plus the levels of the
allocation variable) are contained in and extracted from the subgroup object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compile_possible_subgroup_allocation(
  subgroup_object,
  fullTree = FALSE,
  maxCalls = 1e+06
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compile_possible_subgroup_allocation_+3A_subgroup_object">subgroup_object</code></td>
<td>
<p>A subgrouping object as returned by <code>form_homogeneous_subgroups()</code></p>
</td></tr>
<tr><td><code id="compile_possible_subgroup_allocation_+3A_fulltree">fullTree</code></td>
<td>
<p>Boolean: Enforce full search of the possibility tree, independent of the value of <code>maxCalls</code></p>
</td></tr>
<tr><td><code id="compile_possible_subgroup_allocation_+3A_maxcalls">maxCalls</code></td>
<td>
<p>Maximum number of recursive calls in the search tree, to avoid long run times with very large trees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of possible allocations; Each allocation is an integer vector of allocation levels that are assigned in that order to the subgroups with given sizes
</p>

<hr>
<h2 id='complete_random_shuffling'>Reshuffle sample indices completely randomly</h2><span id='topic+complete_random_shuffling'></span>

<h3>Description</h3>

<p>This function was just added to test early on the functionality of optimize_design() to accept a
permutation vector rather than a list with src and dst indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_random_shuffling(batch_container, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="complete_random_shuffling_+3A_batch_container">batch_container</code></td>
<td>
<p>The batch-container.</p>
</td></tr>
<tr><td><code id="complete_random_shuffling_+3A_...">...</code></td>
<td>
<p>Other params that are passed to a generic shuffling function (like the iteration number).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A random permutation of the sample assignment in the container.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("invivo_study_samples")
bc &lt;- BatchContainer$new(
  dimensions = c("plate" = 2, "column" = 5, "row" = 6)
)
scoring_f &lt;- osat_score_generator("plate", "Sex")
bc &lt;- optimize_design(
  bc, scoring = scoring_f, invivo_study_samples,
  max_iter = 100,
  shuffle_proposal_func = complete_random_shuffling
)
</code></pre>

<hr>
<h2 id='drop_order'>Drop highest order interactions</h2><span id='topic+drop_order'></span>

<h3>Description</h3>

<p>Drop highest order interactions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_order(.terms, m = -1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_order_+3A_.terms">.terms</code></td>
<td>
<p><code><a href="stats.html#topic+terms.object">terms.object</a></code></p>
</td></tr>
<tr><td><code id="drop_order_+3A_m">m</code></td>
<td>
<p>order of interaction (highest available if -1)</p>
</td></tr>
</table>

<hr>
<h2 id='extract_shuffle_params'>Extract relevant parameters from a generic shuffle function output</h2><span id='topic+extract_shuffle_params'></span>

<h3>Description</h3>

<p>Any shuffling function should return one of the following:
</p>

<ol>
<li><p> atomic index vector for a direct location assignment
</p>
</li>
<li><p> a list with src and dst vector
</p>
</li>
<li><p> a list with locations vector (for location assignment) and optional sample_attr data frame/tibble
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>extract_shuffle_params(shuffle, attributes_expected)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_shuffle_params_+3A_shuffle">shuffle</code></td>
<td>
<p>Return value of a shuffle function</p>
</td></tr>
<tr><td><code id="extract_shuffle_params_+3A_attributes_expected">attributes_expected</code></td>
<td>
<p>Logical; if TRUE, sample attributes are expected from the shuffling result and the
function dies if they are not provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function parses the output, performs a few checks and returns results in a simple-to-use list.
</p>


<h3>Value</h3>

<p>A list with components src, dst, location_assignment and samples_attr, depending on the output
of the specific shuffling function
</p>

<hr>
<h2 id='find_possible_block_allocations'>Internal function to generate possible subgroup combinations that add up to specific levels of an allocation variable</h2><span id='topic+find_possible_block_allocations'></span>

<h3>Description</h3>

<p>Internal function to generate possible subgroup combinations that add up to specific levels of an allocation variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_possible_block_allocations(
  block_sizes,
  group_nums,
  fullTree = FALSE,
  maxCalls = 1e+06
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_possible_block_allocations_+3A_block_sizes">block_sizes</code></td>
<td>
<p>(Integer) vector of sizes of the various subgroups that can be combined to form groups</p>
</td></tr>
<tr><td><code id="find_possible_block_allocations_+3A_group_nums">group_nums</code></td>
<td>
<p>Vector of sizes of the different groups to be formed</p>
</td></tr>
<tr><td><code id="find_possible_block_allocations_+3A_fulltree">fullTree</code></td>
<td>
<p>Boolean: Enforce full search of the possibility tree, independent of the value of <code>maxCalls</code></p>
</td></tr>
<tr><td><code id="find_possible_block_allocations_+3A_maxcalls">maxCalls</code></td>
<td>
<p>Maximum number of recursive calls in the search tree, to avoid long run times with very large trees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of possible allocations; Each allocation is an integer vector of allocation levels that are assigned in that order to the subgroups with sizes given by <code style="white-space: pre;">&#8288;block sizes&#8288;</code>
</p>

<hr>
<h2 id='first_score_only'>Aggregation of scores: take first (primary) score only</h2><span id='topic+first_score_only'></span>

<h3>Description</h3>

<p>This function enables comparison of the results of two scoring functions by just basing
the decision on the first element. This reflects the original behavior of the optimization
function, just evaluating the 'auxiliary' scores for the user's information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first_score_only(scores, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="first_score_only_+3A_scores">scores</code></td>
<td>
<p>A score or multiple component score vector</p>
</td></tr>
<tr><td><code id="first_score_only_+3A_...">...</code></td>
<td>
<p>Parameters to be ignored by this aggregation function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The aggregated score, i.e. the first element of a multiple-component score vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>first_score_only(c(1, 2, 3))
</code></pre>

<hr>
<h2 id='form_homogeneous_subgroups'>Form groups and subgroups of 'homogeneous' samples as defined by certain variables and size constraints</h2><span id='topic+form_homogeneous_subgroups'></span>

<h3>Description</h3>

<p>Form groups and subgroups of 'homogeneous' samples as defined by certain variables and size constraints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>form_homogeneous_subgroups(
  batch_container,
  allocate_var,
  keep_together_vars = c(),
  n_min = NA,
  n_max = NA,
  n_ideal = NA,
  subgroup_var_name = NULL,
  prefer_big_groups = TRUE,
  strict = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="form_homogeneous_subgroups_+3A_batch_container">batch_container</code></td>
<td>
<p>Batch container with all samples assigned that are to be grouped and sub-grouped</p>
</td></tr>
<tr><td><code id="form_homogeneous_subgroups_+3A_allocate_var">allocate_var</code></td>
<td>
<p>Name of a variable in the <code>samples</code> table to inform possible groupings, as (sub)group sizes must add up to the correct totals</p>
</td></tr>
<tr><td><code id="form_homogeneous_subgroups_+3A_keep_together_vars">keep_together_vars</code></td>
<td>
<p>Vector of column names in sample table; groups are formed by pooling samples with identical values of all those variables</p>
</td></tr>
<tr><td><code id="form_homogeneous_subgroups_+3A_n_min">n_min</code></td>
<td>
<p>Minimal number of samples in one sub(!)group; by default 1</p>
</td></tr>
<tr><td><code id="form_homogeneous_subgroups_+3A_n_max">n_max</code></td>
<td>
<p>Maximal number of samples in one sub(!)group; by default the size of the biggest group</p>
</td></tr>
<tr><td><code id="form_homogeneous_subgroups_+3A_n_ideal">n_ideal</code></td>
<td>
<p>Ideal number of samples in one sub(!)group; by default the floor or ceiling of <code>mean(n_min,n_max)</code>, depending on the setting of <code>prefer_big_groups</code></p>
</td></tr>
<tr><td><code id="form_homogeneous_subgroups_+3A_subgroup_var_name">subgroup_var_name</code></td>
<td>
<p>An optional column name for the subgroups which are formed (or NULL)</p>
</td></tr>
<tr><td><code id="form_homogeneous_subgroups_+3A_prefer_big_groups">prefer_big_groups</code></td>
<td>
<p>Boolean; indicating whether or not bigger subgroups should be preferred in case of several possibilities</p>
</td></tr>
<tr><td><code id="form_homogeneous_subgroups_+3A_strict">strict</code></td>
<td>
<p>Boolean; if TRUE, subgroup size constraints have to be met strictly, implying the possibility of finding no solution at all</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Subgroup object to be used in subsequent calls to <code>compile_possible_subgroup_allocation()</code>
</p>

<hr>
<h2 id='generate_terms'>Generate <code>terms.object</code> (formula with attributes)</h2><span id='topic+generate_terms'></span>

<h3>Description</h3>

<p>Generate <code>terms.object</code> (formula with attributes)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_terms(.tbl, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_terms_+3A_.tbl">.tbl</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="generate_terms_+3A_...">...</code></td>
<td>
<p>columns to skip (unquoted)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="stats.html#topic+terms.object">terms.object</a></code>
</p>

<hr>
<h2 id='get_order'>Get highest order interaction</h2><span id='topic+get_order'></span>

<h3>Description</h3>

<p>Get highest order interaction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_order(.terms)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_order_+3A_.terms">.terms</code></td>
<td>
<p><code><a href="stats.html#topic+terms.object">terms.object</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>highest order (numeric).
</p>

<hr>
<h2 id='invivo_study_samples'>A sample list from an in vivo experiment with multiple treatments and 2 strains</h2><span id='topic+invivo_study_samples'></span>

<h3>Description</h3>

<p>This sample list is intended to be used in connection with the <code>"invivo_study_treatments"</code> data object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(invivo_study_samples)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"tibble"</code>
</p>

<dl>
<dt>AnimalID</dt><dd><p>The animal IDs, i.e. unique identifiers for each animal</p>
</dd>
<dt>Strain</dt><dd><p>Strain (A or B)</p>
</dd>
<dt>Sex</dt><dd><p>Female (F) or Male (M)</p>
</dd>
<dt>BirthDate</dt><dd><p>Date of birth, not available for all the animals</p>
</dd>
<dt>Earmark</dt><dd><p>Markings to distinguish individual animals, applied on the left (L), right (R) or both(B) ears</p>
</dd>
<dt>ArrivalWeight</dt><dd><p>Initial body weight of the animal</p>
</dd>
<dt>Arrival weight Unit</dt><dd><p>Unit of the body weight, here: grams</p>
</dd>
<dt>Litter</dt><dd><p>The litter IDs, grouping offspring from one set of parents</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Guido Steiner
</p>

<hr>
<h2 id='invivo_study_treatments'>A treatment list together with additional constraints on the strain and sex of animals</h2><span id='topic+invivo_study_treatments'></span>

<h3>Description</h3>

<p>This treatment list is intended to be used in connection with the <code>"invivo_study_samples"</code> data object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(invivo_study_treatments)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"tibble"</code>
</p>

<dl>
<dt>Treatment</dt><dd><p>The treatment to be given to an individual animal (1-3, plus a few untreated cases)</p>
</dd>
<dt>Strain</dt><dd><p>Strain (A or B) - a constraint which kind of animal may receive the respective treatment</p>
</dd>
<dt>Sex</dt><dd><p>Female (F) or Male (M) - a constraint which kind of animal may receive the respective treatment</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Guido Steiner
</p>

<hr>
<h2 id='L1_norm'>Aggregation of scores: L1 norm</h2><span id='topic+L1_norm'></span>

<h3>Description</h3>

<p>This function enables comparison of the results of two scoring functions by calculating
an L1 norm (Manhattan distance from origin).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L1_norm(scores, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="L1_norm_+3A_scores">scores</code></td>
<td>
<p>A score or multiple component score vector</p>
</td></tr>
<tr><td><code id="L1_norm_+3A_...">...</code></td>
<td>
<p>Parameters to be ignored by this aggregation function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The L1 norm as an aggregated score.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L1_norm(c(2, 2))
</code></pre>

<hr>
<h2 id='L2s_norm'>Aggregation of scores: L2 norm squared</h2><span id='topic+L2s_norm'></span>

<h3>Description</h3>

<p>This function enables comparison of the results of two scoring functions by calculating
an L2 norm (euclidean distance from origin). Since this is only used for ranking solutions,
the squared L2 norm is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L2s_norm(scores, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="L2s_norm_+3A_scores">scores</code></td>
<td>
<p>A score or multiple component score vector</p>
</td></tr>
<tr><td><code id="L2s_norm_+3A_...">...</code></td>
<td>
<p>Parameters to be ignored by this aggregation function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The squared L2 norm as an aggregated score.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L2s_norm(c(2, 2))
</code></pre>

<hr>
<h2 id='locations_table_from_dimensions'>Create locations table from dimensions and exclude table</h2><span id='topic+locations_table_from_dimensions'></span>

<h3>Description</h3>

<p>Create locations table from dimensions and exclude table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locations_table_from_dimensions(dimensions, exclude)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locations_table_from_dimensions_+3A_dimensions">dimensions</code></td>
<td>
<p>A vector or list of dimensions. Every dimension
should have a name. Could be an integer vector of dimensions or
a named list. Every value of a list could be either dimension size
or parameters for <a href="#topic+BatchContainerDimension">BatchContainerDimension$new()</a>.</p>
</td></tr>
<tr><td><code id="locations_table_from_dimensions_+3A_exclude">exclude</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a> with excluded locations of a container.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with all the available locations.
</p>

<hr>
<h2 id='longitudinal_subject_samples'>Subject sample list with group and time plus controls</h2><span id='topic+longitudinal_subject_samples'></span>

<h3>Description</h3>

<p>A sample list with 9 columns as described below.
There are 3 types of records (rows) indicated by the <code>SampleType</code> variable.
Patient samples, controls and spike-in standards.
Patient samples were collected over up to 7 time points.
Controls and SpikeIns are QC samples for distribution of the samples on
96 well plates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(longitudinal_subject_samples)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"tibble"</code>
</p>

<dl>
<dt>SampleID</dt><dd><p>A unique sample identifier.</p>
</dd>
<dt>SampleType</dt><dd><p>Indicates whether the sample is a patient sample, control oder spike-in.</p>
</dd>
<dt>SubjectID</dt><dd><p>The subject identifier.</p>
</dd>
<dt>Group</dt><dd><p>Indicates the treatment group of a subject.</p>
</dd>
<dt>Week</dt><dd><p>Sampling time points in weeks of study.</p>
</dd>
<dt>Sex</dt><dd><p>Subject Sex, Female (F) or Male (M).</p>
</dd>
<dt>Age</dt><dd><p>Subject age.</p>
</dd>
<dt>BMI</dt><dd><p>Subject Body Mass Index.</p>
</dd>
<dt>SamplesPerSubject</dt><dd><p>Look up variable for the number of samples per subject.
This varies as not subject have samples from all weeks.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Juliane Siebourg
</p>

<hr>
<h2 id='make_colnames'>Make <a href="base.html#topic+matrix">matrix</a> column names unique.</h2><span id='topic+make_colnames'></span>

<h3>Description</h3>

<p>Make <a href="base.html#topic+matrix">matrix</a> column names unique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_colnames(m, prefix = "X")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_colnames_+3A_prefix">prefix</code></td>
<td>
<p>Prefix to add if column names are empty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="base.html#topic+matrix">matrix</a> with updated column names.
</p>

<hr>
<h2 id='mk_autoscale_function'>Create a function that transforms a current (multi-dimensional) score into a boxcox normalized one</h2><span id='topic+mk_autoscale_function'></span>

<h3>Description</h3>

<p>Create a function that transforms a current (multi-dimensional) score into a boxcox normalized one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mk_autoscale_function(
  batch_container,
  scoring,
  random_perm,
  use_boxcox = TRUE,
  sample_attributes_fixed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mk_autoscale_function_+3A_batch_container">batch_container</code></td>
<td>
<p>An instance of <a href="#topic+BatchContainer">BatchContainer</a>.</p>
</td></tr>
<tr><td><code id="mk_autoscale_function_+3A_scoring">scoring</code></td>
<td>
<p>A named <code><a href="base.html#topic+list">list()</a></code> of scoring function. Each function should
return a vector of non-zero length.</p>
</td></tr>
<tr><td><code id="mk_autoscale_function_+3A_random_perm">random_perm</code></td>
<td>
<p>Number of random sample permutations for the estimation of the scaling params.</p>
</td></tr>
<tr><td><code id="mk_autoscale_function_+3A_use_boxcox">use_boxcox</code></td>
<td>
<p>Logical; if TRUE and the <code>bestNormalize</code> package is available, boxcox transformations will be used to
normalize individual scores. If not possible, scores will just be transformed to a zero mean and unit standard deviation.</p>
</td></tr>
<tr><td><code id="mk_autoscale_function_+3A_sample_attributes_fixed">sample_attributes_fixed</code></td>
<td>
<p>Logical; if FALSE, simulate a shuffle function that alters sample attributes at each iteration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The transformation function for a new score vector
</p>

<hr>
<h2 id='mk_constant_swapping_function'>Create function to propose n pairwise swaps of samples on each call (n is a constant across iterations)</h2><span id='topic+mk_constant_swapping_function'></span>

<h3>Description</h3>

<p>This internal function is wrapped by mk_swapping_function()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mk_constant_swapping_function(n_swaps, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mk_constant_swapping_function_+3A_n_swaps">n_swaps</code></td>
<td>
<p>Number of swaps to be proposed (valid range is 1..floor(n_samples/2))</p>
</td></tr>
<tr><td><code id="mk_constant_swapping_function_+3A_quiet">quiet</code></td>
<td>
<p>Do not warn if number of swaps is too big.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function accepting batch container &amp; iteration number.
Return a list with length n vectors 'src' and 'dst', denoting source and destination index for
the swap operation on each call
</p>

<hr>
<h2 id='mk_dist_matrix'>Internal helper function to set up an (n m) x (n m) pairwise distance matrix for a plate with n rows and m columns</h2><span id='topic+mk_dist_matrix'></span>

<h3>Description</h3>

<p>Internal helper function to set up an (n m) x (n m) pairwise distance matrix for a plate with n rows and m columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mk_dist_matrix(
  plate_x = 12,
  plate_y = 8,
  dist = "minkowski",
  p = 2,
  penalize_lines = "soft"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mk_dist_matrix_+3A_plate_x">plate_x</code></td>
<td>
<p>Dimension of plate in x direction (i.e number of columns)</p>
</td></tr>
<tr><td><code id="mk_dist_matrix_+3A_plate_y">plate_y</code></td>
<td>
<p>Dimension of plate in y direction (i.e number of rows)</p>
</td></tr>
<tr><td><code id="mk_dist_matrix_+3A_dist">dist</code></td>
<td>
<p>Distance function as understood by <code>stats::dist()</code></p>
</td></tr>
<tr><td><code id="mk_dist_matrix_+3A_p">p</code></td>
<td>
<p>p parameter, used only if distance metric is 'minkowski'. Special cases: p=1 - Manhattan distance; p=2 - Euclidean distance</p>
</td></tr>
<tr><td><code id="mk_dist_matrix_+3A_penalize_lines">penalize_lines</code></td>
<td>
<p>How to penalize samples of the same group in one row or column of the plate. Valid options are:
'none' - there is no penalty and the pure distance metric counts, 'soft' - penalty will depend on the well distance within the
shared plate row or column, 'hard' - samples in the same row/column will score a zero distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The  matrix with pairwise distances between any wells on the plate
</p>

<hr>
<h2 id='mk_exponentially_weighted_acceptance_func'>Alternative acceptance function for multi-dimensional scores with exponentially downweighted score improvements from left to right</h2><span id='topic+mk_exponentially_weighted_acceptance_func'></span>

<h3>Description</h3>

<p>Alternative acceptance function for multi-dimensional scores with exponentially downweighted score improvements from left to right
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mk_exponentially_weighted_acceptance_func(
  kappa = 0.5,
  simulated_annealing = FALSE,
  temp_function = mk_simanneal_temp_func(T0 = 500, alpha = 0.8)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mk_exponentially_weighted_acceptance_func_+3A_kappa">kappa</code></td>
<td>
<p>Coefficient that determines how quickly the weights for the individual score improvements drop when going from left to right
(i.e. first to last score). Weight for the first score's delta is 1, then the original delta multiplied with kappa^(p-1) for the p'th score</p>
</td></tr>
<tr><td><code id="mk_exponentially_weighted_acceptance_func_+3A_simulated_annealing">simulated_annealing</code></td>
<td>
<p>Boolean; if TRUE, simulated annealing (SA) will be used to minimize the weighted improved score</p>
</td></tr>
<tr><td><code id="mk_exponentially_weighted_acceptance_func_+3A_temp_function">temp_function</code></td>
<td>
<p>In case SA is used, a temperature function that returns the annealing temperature for a certain iteration number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Acceptance function which returns TRUE if current score should be taken as the new optimal score, FALSE otherwise
</p>

<hr>
<h2 id='mk_plate_scoring_functions'>Create a list of scoring functions (one per plate) that quantify the spatially homogeneous distribution of conditions across the plate</h2><span id='topic+mk_plate_scoring_functions'></span>

<h3>Description</h3>

<p>Create a list of scoring functions (one per plate) that quantify the spatially homogeneous distribution of conditions across the plate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mk_plate_scoring_functions(
  batch_container,
  plate = NULL,
  row,
  column,
  group,
  p = 2,
  penalize_lines = "soft"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mk_plate_scoring_functions_+3A_batch_container">batch_container</code></td>
<td>
<p>Batch container (bc) with all columns that denote plate related information</p>
</td></tr>
<tr><td><code id="mk_plate_scoring_functions_+3A_plate">plate</code></td>
<td>
<p>Name of the bc column that holds the plate identifier (may be missing or NULL in case just one plate is used)</p>
</td></tr>
<tr><td><code id="mk_plate_scoring_functions_+3A_row">row</code></td>
<td>
<p>Name of the bc column that holds the plate row number (integer values starting at 1)</p>
</td></tr>
<tr><td><code id="mk_plate_scoring_functions_+3A_column">column</code></td>
<td>
<p>Name of the bc column that holds the plate column number (integer values starting at 1)</p>
</td></tr>
<tr><td><code id="mk_plate_scoring_functions_+3A_group">group</code></td>
<td>
<p>Name of the bc column that denotes a group/condition that should be distributed on the plate</p>
</td></tr>
<tr><td><code id="mk_plate_scoring_functions_+3A_p">p</code></td>
<td>
<p>p parameter for minkowski type of distance metrics. Special cases: p=1 - Manhattan distance; p=2 - Euclidean distance</p>
</td></tr>
<tr><td><code id="mk_plate_scoring_functions_+3A_penalize_lines">penalize_lines</code></td>
<td>
<p>How to penalize samples of the same group in one row or column of the plate. Valid options are:
'none' - there is no penalty and the pure distance metric counts, 'soft' - penalty will depend on the well distance within the
shared plate row or column, 'hard' - samples in the same row/column will score a zero distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of scoring functions, one per plate, that calculate a real valued measure for the quality of the group distribution (the lower the better).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("invivo_study_samples")
bc &lt;- BatchContainer$new(
  dimensions = c("column" = 6, "row" = 10)
)
bc &lt;- assign_random(bc, invivo_study_samples)
scoring_f &lt;- mk_plate_scoring_functions(
  bc,
  row = "row", column = "column", group = "Sex"
)
bc &lt;- optimize_design(bc, scoring = scoring_f, max_iter = 100)
plot_plate(bc$get_samples(), .col = Sex)

</code></pre>

<hr>
<h2 id='mk_simanneal_acceptance_func'>Generate acceptance function for an optimization protocol based on simulated annealing</h2><span id='topic+mk_simanneal_acceptance_func'></span>

<h3>Description</h3>

<p>Generate acceptance function for an optimization protocol based on simulated annealing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mk_simanneal_acceptance_func(
  temp_function = mk_simanneal_temp_func(T0 = 500, alpha = 0.8)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mk_simanneal_acceptance_func_+3A_temp_function">temp_function</code></td>
<td>
<p>A temperature function that returns the annealing temperature for a certain cycle k</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that takes parameters (<code>current_score</code>, <code>best_score</code>, <code>iteration</code>) for an optimization step and return a Boolean indicating whether the current solution should be accepted or dismissed. Acceptance probability of a worse solution decreases with annealing temperature.
</p>

<hr>
<h2 id='mk_simanneal_temp_func'>Create a temperature function that returns the annealing temperature at a given step (iteration)</h2><span id='topic+mk_simanneal_temp_func'></span>

<h3>Description</h3>

<p>Supported annealing types are currently &quot;Exponential multiplicative&quot;, &quot;Logarithmic multiplicative&quot;, &quot;Quadratic multiplicative&quot; and &quot;Linear multiplicative&quot;, each with dedicated constraints on alpha. For information, see http://what-when-how.com/artificial-intelligence/a-comparison-of-cooling-schedules-for-simulated-annealing-artificial-intelligence/
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mk_simanneal_temp_func(T0, alpha, type = "Quadratic multiplicative")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mk_simanneal_temp_func_+3A_t0">T0</code></td>
<td>
<p>Initial temperature at step 1 (when k=0)</p>
</td></tr>
<tr><td><code id="mk_simanneal_temp_func_+3A_alpha">alpha</code></td>
<td>
<p>Rate of cooling</p>
</td></tr>
<tr><td><code id="mk_simanneal_temp_func_+3A_type">type</code></td>
<td>
<p>Type of annealing protocol. Defaults to the quadratic multiplicative method which seems to perform well.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Temperature at cycle <code>k</code>.
</p>

<hr>
<h2 id='mk_subgroup_shuffling_function'>Created a shuffling function that permutes samples within certain subgroups of the container locations</h2><span id='topic+mk_subgroup_shuffling_function'></span>

<h3>Description</h3>

<p>If length(n_swaps)==1, the returned function may be called an arbitrary number of times.
If length(n_swaps)&gt;1 the returned function may be called length(n_swaps) timed before returning NULL, which would be the stopping criterion if all requested swaps have been exhausted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mk_subgroup_shuffling_function(
  subgroup_vars,
  restrain_on_subgroup_levels = c(),
  n_swaps = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mk_subgroup_shuffling_function_+3A_subgroup_vars">subgroup_vars</code></td>
<td>
<p>Column names of the variables that together define the relevant subgroups</p>
</td></tr>
<tr><td><code id="mk_subgroup_shuffling_function_+3A_restrain_on_subgroup_levels">restrain_on_subgroup_levels</code></td>
<td>
<p>Permutations can be forced to take place only within a level of the factor of the subgrouping variable. In this case, the user must pass only one subgrouping variable and a number of levels that together define the permuted subgroup.</p>
</td></tr>
<tr><td><code id="mk_subgroup_shuffling_function_+3A_n_swaps">n_swaps</code></td>
<td>
<p>Vector with number of swaps to be proposed in successive calls to the returned function (each value should be in valid range from 1..floor(n_locations/2))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function to return a list with length n vectors <code>src</code> and <code>dst</code>, denoting source and destination index for the swap operation, or <code>NULL</code> if the user provided a defined protocol for the number of swaps and the last iteration has been reached
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

bc &lt;- BatchContainer$new(
  dimensions = c(
    plate = 2,
    row = 4, col = 4
  )
)

bc &lt;- assign_in_order(bc, samples = tibble::tibble(
  Group = c(rep(c("Grp 1", "Grp 2", "Grp 3", "Grp 4"), each = 8)),
  ID = 1:32
))

# here we use a 2-step approach:
# 1. Assign samples to plates.
# 2. Arrange samples within plates.

# overview of sample assagnment before optimization
plot_plate(bc,
  plate = plate, row = row, column = col, .color = Group
)

# Step 1, assign samples to plates
scoring_f &lt;- osat_score_generator(
  batch_vars = c("plate"), feature_vars = c("Group")
)
bc &lt;- optimize_design(
  bc,
  scoring = scoring_f,
  max_iter = 10, # the real number of iterations should be bigger
  n_shuffle = 2,
  quiet = TRUE
)
plot_plate(
  bc,
  plate = plate, row = row, column = col, .color = Group
)

# Step 2, distribute samples within plates
scoring_f &lt;- mk_plate_scoring_functions(
  bc,
  plate = "plate", row = "row", column = "col", group = "Group"
)
bc &lt;- optimize_design(
  bc,
  scoring = scoring_f,
  max_iter = 50,
  shuffle_proposal_func = mk_subgroup_shuffling_function(subgroup_vars = c("plate")),
  aggregate_scores_func = L2s_norm,
  quiet = TRUE
)
plot_plate(bc,
  plate = plate, row = row, column = col, .color = Group
)
</code></pre>

<hr>
<h2 id='mk_swapping_function'>Create function to propose swaps of samples on each call, either with a constant number of swaps or following
a user defined protocol</h2><span id='topic+mk_swapping_function'></span>

<h3>Description</h3>

<p>If <code>length(n_swaps)==1</code>, the returned function may be called an arbitrary number of times.
If <code>length(n_swaps)&gt;1</code> and called without argument, the returned function may be called length(n_swaps) timed before returning NULL, which would be the stopping criterion if all requested swaps have been exhausted. Alternatively, the function may be called with an iteration number as the only argument, giving the user some freedom how to iterate over the sample swapping protocol.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mk_swapping_function(n_swaps = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mk_swapping_function_+3A_n_swaps">n_swaps</code></td>
<td>
<p>Vector with number of swaps to be proposed in successive calls to the returned function (each value should be in valid range from 1..<code>floor(n_samples/2)</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function to return a list with length n vectors <code>src</code> and <code>dst</code>, denoting source and destination index for the swap operation, or NULL if the user provided a defined protocol for the number of swaps and the last iteration has been reached.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("invivo_study_samples")
bc &lt;- BatchContainer$new(
  dimensions = c("plate" = 2, "column" = 5, "row" = 6)
)
scoring_f &lt;- osat_score_generator("plate", "Sex")
optimize_design(
  bc, scoring = scoring_f, invivo_study_samples,
  max_iter = 100,
  shuffle_proposal_func = mk_swapping_function(1)
)
</code></pre>

<hr>
<h2 id='multi_trt_day_samples'>Unbalanced treatment and time sample list</h2><span id='topic+multi_trt_day_samples'></span>

<h3>Description</h3>

<p>A sample list with 4 columns SampleName, Well, Time and Treatment
Not all treatments are avaliable at all time points.
All samples are placed on the same plate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(multi_trt_day_samples)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"tibble"</code>
</p>


<h3>Author(s)</h3>

<p>siebourj
</p>

<hr>
<h2 id='optimize_design'>Generic optimizer that can be customized by user provided functions for generating shuffles and progressing towards the minimal score</h2><span id='topic+optimize_design'></span>

<h3>Description</h3>

<p>Generic optimizer that can be customized by user provided functions for generating shuffles and progressing towards the minimal score
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize_design(
  batch_container,
  samples = NULL,
  scoring = NULL,
  n_shuffle = NULL,
  shuffle_proposal_func = NULL,
  acceptance_func = accept_strict_improvement,
  aggregate_scores_func = identity,
  check_score_variance = TRUE,
  autoscale_scores = FALSE,
  autoscaling_permutations = 100,
  autoscale_useboxcox = TRUE,
  sample_attributes_fixed = FALSE,
  max_iter = 10000,
  min_delta = NA,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimize_design_+3A_batch_container">batch_container</code></td>
<td>
<p>An instance of <code>BatchContainer</code>.</p>
</td></tr>
<tr><td><code id="optimize_design_+3A_samples">samples</code></td>
<td>
<p>A <code>data.frame</code> with sample information.
Should be <code>NULL</code> if the <code>BatchContainer</code> already has samples in it.</p>
</td></tr>
<tr><td><code id="optimize_design_+3A_scoring">scoring</code></td>
<td>
<p>Scoring function or a named <code><a href="base.html#topic+list">list()</a></code> of scoring functions.</p>
</td></tr>
<tr><td><code id="optimize_design_+3A_n_shuffle">n_shuffle</code></td>
<td>
<p>Vector of length 1 or larger, defining how many random sample
swaps should be performed in each iteration. If <code>length(n_shuffle)==1</code>,
this sets no limit to the number of iterations. Otherwise, the optimization
stops if the swapping protocol is exhausted.</p>
</td></tr>
<tr><td><code id="optimize_design_+3A_shuffle_proposal_func">shuffle_proposal_func</code></td>
<td>
<p>A user defined function to propose the next shuffling of samples.
Takes priority over n_shuffle if both are provided. The function is called with
a <a href="#topic+BatchContainer">BatchContainer</a> <code>bc</code> and an integer parameter <code>iteration</code> for the current iteration number,
allowing very flexible shuffling strategies.
Mapper syntax is supported (see <code><a href="purrr.html#topic+as_mapper">purrr::as_mapper()</a></code>).
The returned function must either return a list with fields <code>src</code>and <code>dst</code> (for pairwise sample swapping)
or a numeric vector with a complete re-assigned sample order.</p>
</td></tr>
<tr><td><code id="optimize_design_+3A_acceptance_func">acceptance_func</code></td>
<td>
<p>Alternative function to select a new score as the best one.
Defaults to strict improvement rule, i.e. all elements of a score have to be smaller or equal in order to accept the solution as better.
This may be replaced with an alternative acceptance function included in the package
(e.g. <code><a href="#topic+mk_simanneal_acceptance_func">mk_simanneal_acceptance_func()</a></code>) or a user provided function.
Mapper syntax is supported (see <code><a href="purrr.html#topic+as_mapper">purrr::as_mapper()</a></code>).</p>
</td></tr>
<tr><td><code id="optimize_design_+3A_aggregate_scores_func">aggregate_scores_func</code></td>
<td>
<p>A function to aggregate multiple scores AFTER (potential) auto-scaling and BEFORE acceptance evaluation.
If a function is passed, (multi-dimensional) scores will be transformed (often to a single double value) before calling the acceptance function.
E.g., see <code><a href="#topic+first_score_only">first_score_only()</a></code> or <code><a href="#topic+worst_score">worst_score()</a></code>.
Note that particular acceptance functions may require aggregation of a score to a single scalar in order to work, see for example those
generated by <code><a href="#topic+mk_simanneal_acceptance_func">mk_simanneal_acceptance_func()</a></code>.
Mapper syntax is supported (see <code><a href="purrr.html#topic+as_mapper">purrr::as_mapper()</a></code>).</p>
</td></tr>
<tr><td><code id="optimize_design_+3A_check_score_variance">check_score_variance</code></td>
<td>
<p>Logical: if TRUE, scores will be checked for variability under sample permutation
and the optimization is not performed if at least one subscore appears to have a zero variance.</p>
</td></tr>
<tr><td><code id="optimize_design_+3A_autoscale_scores">autoscale_scores</code></td>
<td>
<p>Logical: if TRUE, perform a transformation on the fly to equally scale scores
to a standard normal. This makes scores more directly comparable and easier to aggregate.</p>
</td></tr>
<tr><td><code id="optimize_design_+3A_autoscaling_permutations">autoscaling_permutations</code></td>
<td>
<p>How many random sample permutations should be done to estimate autoscaling parameters.
(Note: minimum will be 20, regardless of the specified value)</p>
</td></tr>
<tr><td><code id="optimize_design_+3A_autoscale_useboxcox">autoscale_useboxcox</code></td>
<td>
<p>Logical; if TRUE, use a boxcox transformation for the autoscaling if possible at all.
Requires installation of the <code>bestNormalize</code> package.</p>
</td></tr>
<tr><td><code id="optimize_design_+3A_sample_attributes_fixed">sample_attributes_fixed</code></td>
<td>
<p>Logical; if TRUE, sample shuffle function may generate altered sample attributes at each iteration.
This affects estimation of score distributions. (Parameter only relevant if shuffle function does introduce attributes!)</p>
</td></tr>
<tr><td><code id="optimize_design_+3A_max_iter">max_iter</code></td>
<td>
<p>Stop optimization after a maximum number of iterations,
independent from other stopping criteria (user defined shuffle proposal or min_delta).</p>
</td></tr>
<tr><td><code id="optimize_design_+3A_min_delta">min_delta</code></td>
<td>
<p>If not NA, optimization is stopped as soon as successive improvement (i.e. euclidean distance between score vectors
from current best and previously best solution) drops below min_delta.</p>
</td></tr>
<tr><td><code id="optimize_design_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE, suppress non-critical warnings or messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trace object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("invivo_study_samples")
bc &lt;- BatchContainer$new(
  dimensions = c("plate" = 2, "column" = 5, "row" = 6)
)
bc &lt;- optimize_design(bc, invivo_study_samples,
  scoring = osat_score_generator("plate", "Sex"),
  max_iter = 100
)
plot_plate(bc$get_samples(), .col = Sex)
</code></pre>

<hr>
<h2 id='optimize_multi_plate_design'>Convenience wrapper to optimize a typical multi-plate design</h2><span id='topic+optimize_multi_plate_design'></span>

<h3>Description</h3>

<p>The batch container will in the end contain the updated experimental layout
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize_multi_plate_design(
  batch_container,
  across_plates_variables = NULL,
  within_plate_variables = NULL,
  plate = "plate",
  row = "row",
  column = "column",
  n_shuffle = 1,
  max_iter = 1000,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimize_multi_plate_design_+3A_batch_container">batch_container</code></td>
<td>
<p>Batch container (bc) with all columns that denote plate related information</p>
</td></tr>
<tr><td><code id="optimize_multi_plate_design_+3A_across_plates_variables">across_plates_variables</code></td>
<td>
<p>Vector with bc column name(s) that denote(s) groups/conditions to be balanced across plates,
sorted by relative importance of the factors</p>
</td></tr>
<tr><td><code id="optimize_multi_plate_design_+3A_within_plate_variables">within_plate_variables</code></td>
<td>
<p>Vector with bc column name(s) that denote(s) groups/conditions to be spaced out within each plate,
sorted by relative importance of the factors</p>
</td></tr>
<tr><td><code id="optimize_multi_plate_design_+3A_plate">plate</code></td>
<td>
<p>Name of the bc column that holds the plate identifier</p>
</td></tr>
<tr><td><code id="optimize_multi_plate_design_+3A_row">row</code></td>
<td>
<p>Name of the bc column that holds the plate row number (integer values starting at 1)</p>
</td></tr>
<tr><td><code id="optimize_multi_plate_design_+3A_column">column</code></td>
<td>
<p>Name of the bc column that holds the plate column number (integer values starting at 1)</p>
</td></tr>
<tr><td><code id="optimize_multi_plate_design_+3A_n_shuffle">n_shuffle</code></td>
<td>
<p>Vector of length 1 or larger, defining how many random sample
swaps should be performed in each iteration. See <code><a href="#topic+optimize_design">optimize_design()</a></code>.</p>
</td></tr>
<tr><td><code id="optimize_multi_plate_design_+3A_max_iter">max_iter</code></td>
<td>
<p>Stop any of the optimization runs after this maximum number of iterations. See <code><a href="#topic+optimize_design">optimize_design()</a></code>.</p>
</td></tr>
<tr><td><code id="optimize_multi_plate_design_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE, suppress informative messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with named traces, one for each optimization step
</p>

<hr>
<h2 id='osat_score'>Compute OSAT score for sample assignment.</h2><span id='topic+osat_score'></span>

<h3>Description</h3>

<p>The OSAT score is intended to ensure even distribution of samples across
batches and is closely related to the chi-square test contingency table
(Yan et al. (2012) <a href="https://doi.org/10.1186/1471-2164-13-689">doi:10.1186/1471-2164-13-689</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osat_score(bc, batch_vars, feature_vars, expected_dt = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="osat_score_+3A_bc">bc</code></td>
<td>
<p><a href="#topic+BatchContainer">BatchContainer</a> with samples
or <code><a href="data.table.html#topic+data.table">data.table</a></code>/<a href="base.html#topic+data.frame">data.frame</a> where every row is a location
in a container and a sample in this location.</p>
</td></tr>
<tr><td><code id="osat_score_+3A_batch_vars">batch_vars</code></td>
<td>
<p><a href="base.html#topic+character">character</a> vector with batch variable names to take into account for the
score computation.</p>
</td></tr>
<tr><td><code id="osat_score_+3A_feature_vars">feature_vars</code></td>
<td>
<p><a href="base.html#topic+character">character</a> vector with sample variable names to take into account for
score computation.</p>
</td></tr>
<tr><td><code id="osat_score_+3A_expected_dt">expected_dt</code></td>
<td>
<p>A <code><a href="data.table.html#topic+data.table">data.table</a></code> with expected number of samples sample
variables and batch variables combination. This is not required, however it does not change
during the optimization process. So it is a good idea to cache this value.</p>
</td></tr>
<tr><td><code id="osat_score_+3A_quiet">quiet</code></td>
<td>
<p>Do not warn about <code>NA</code>s in feature columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two attributes: <code style="white-space: pre;">&#8288;$score&#8288;</code> (numeric score value), <code style="white-space: pre;">&#8288;$expected_dt&#8288;</code>
(expected counts <code>data.table</code> for reuse)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample_assignment &lt;- tibble::tribble(
  ~ID, ~SampleType, ~Sex, ~plate,
  1, "Case", "Female", 1,
  2, "Case", "Female", 1,
  3, "Case", "Male", 2,
  4, "Control", "Female", 2,
  5, "Control", "Female", 1,
  6, "Control", "Male", 2,
  NA, NA, NA, 1,
  NA, NA, NA, 2,
)

osat_score(sample_assignment,
  batch_vars = "plate",
  feature_vars = c("SampleType", "Sex")
)
</code></pre>

<hr>
<h2 id='osat_score_generator'>Convenience wrapper for the OSAT score</h2><span id='topic+osat_score_generator'></span>

<h3>Description</h3>

<p>This function wraps <code><a href="#topic+osat_score">osat_score()</a></code> in order to take full advantage of the speed gain without
managing the buffered objects in the user code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osat_score_generator(batch_vars, feature_vars, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="osat_score_generator_+3A_batch_vars">batch_vars</code></td>
<td>
<p><a href="base.html#topic+character">character</a> vector with batch variable names to take into account for the
score computation.</p>
</td></tr>
<tr><td><code id="osat_score_generator_+3A_feature_vars">feature_vars</code></td>
<td>
<p><a href="base.html#topic+character">character</a> vector with sample variable names to take into account for
score computation.</p>
</td></tr>
<tr><td><code id="osat_score_generator_+3A_quiet">quiet</code></td>
<td>
<p>Do not warn about <code>NA</code>s in feature columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that returns the OSAT score for a specific sample arrangement
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample_assignment &lt;- tibble::tribble(
  ~ID, ~SampleType, ~Sex, ~plate,
  1, "Case", "Female", 1,
  2, "Case", "Female", 1,
  3, "Case", "Male", 2,
  4, "Control", "Female", 2,
  5, "Control", "Female", 1,
  6, "Control", "Male", 2,
  NA, NA, NA, 1,
  NA, NA, NA, 2,
)

osat_scoring_function &lt;- osat_score_generator(
  batch_vars = "plate",
  feature_vars = c("SampleType", "Sex")
)

osat_scoring_function(sample_assignment)
</code></pre>

<hr>
<h2 id='pairwise_swapping'>Proposes pairwise swap of samples on each call.</h2><span id='topic+pairwise_swapping'></span>

<h3>Description</h3>

<p>This function will ensure that one of the locations is always non-empty. It should not
return trivial permutations (e.g., <code>src=c(1,2)</code> and <code>dst=c(1,2)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise_swapping(batch_container, iteration)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwise_swapping_+3A_batch_container">batch_container</code></td>
<td>
<p>The batch-container.</p>
</td></tr>
<tr><td><code id="pairwise_swapping_+3A_iteration">iteration</code></td>
<td>
<p>The current iteration number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function accepting batch container &amp; iteration number. It returns a list with length 1 vectors 'src' and 'dst', denoting source and destination index for the swap operation
</p>

<hr>
<h2 id='plate_effect_example'>Example dataset with a plate effect</h2><span id='topic+plate_effect_example'></span>

<h3>Description</h3>

<p>Here top and bottom row were both used as controls (in dilutions). The top
row however was affected differently than the bottom one. This makes
normalization virtually impossible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(plate_effect_example)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"tibble"</code>
</p>

<dl>
<dt>row</dt><dd><p>Plate row</p>
</dd>
<dt>column</dt><dd><p>Plate column</p>
</dd>
<dt>conc</dt><dd><p>Sample concentration</p>
</dd>
<dt>log_conc</dt><dd><p>Logarithm of sample concentration</p>
</dd>
<dt>treatment</dt><dd><p>Sample treatment</p>
</dd>
<dt>readout</dt><dd><p>Readout from experiment</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Balazs Banfai
</p>

<hr>
<h2 id='plot_plate'>Plot plate layouts</h2><span id='topic+plot_plate'></span>

<h3>Description</h3>

<p>Plot plate layouts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_plate(
  .tbl,
  plate = plate,
  row = row,
  column = column,
  .color,
  .alpha = NULL,
  .pattern = NULL,
  title = paste("Layout by", rlang::as_name(rlang::enquo(plate))),
  add_excluded = FALSE,
  rename_empty = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_plate_+3A_.tbl">.tbl</code></td>
<td>
<p>a <code><a href="tibble.html#topic+tibble">tibble</a></code> (or <code>data.frame</code>) with the samples assigned to locations.
Alternatively a <a href="#topic+BatchContainer">BatchContainter</a> with samples can be supplied here.</p>
</td></tr>
<tr><td><code id="plot_plate_+3A_plate">plate</code></td>
<td>
<p>optional dimension variable used for the plate ids</p>
</td></tr>
<tr><td><code id="plot_plate_+3A_row">row</code></td>
<td>
<p>the dimension variable used for the row ids</p>
</td></tr>
<tr><td><code id="plot_plate_+3A_column">column</code></td>
<td>
<p>the dimension variable used for the column ids</p>
</td></tr>
<tr><td><code id="plot_plate_+3A_.color">.color</code></td>
<td>
<p>the continuous or discrete variable to color by</p>
</td></tr>
<tr><td><code id="plot_plate_+3A_.alpha">.alpha</code></td>
<td>
<p>a continuous variable encoding transparency</p>
</td></tr>
<tr><td><code id="plot_plate_+3A_.pattern">.pattern</code></td>
<td>
<p>a discrete variable encoding tile pattern (needs ggpattern)</p>
</td></tr>
<tr><td><code id="plot_plate_+3A_title">title</code></td>
<td>
<p>string for the plot title</p>
</td></tr>
<tr><td><code id="plot_plate_+3A_add_excluded">add_excluded</code></td>
<td>
<p>flag to add excluded wells (in bc$exclude) to the plot.
A BatchContainer must be provided for this.</p>
</td></tr>
<tr><td><code id="plot_plate_+3A_rename_empty">rename_empty</code></td>
<td>
<p>whether NA entries in sample table should be renamed to 'empty'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the ggplot object
</p>


<h3>Author(s)</h3>

<p>siebourj
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nPlate &lt;- 3
nColumn &lt;- 4
nRow &lt;- 6

treatments &lt;- c("CTRL", "TRT1", "TRT2")
timepoints &lt;- c(1, 2, 3)


bc &lt;- BatchContainer$new(
  dimensions = list(
    plate = nPlate,
    column = list(values = letters[1:nColumn]),
    row = nRow
  )
)

sample_sheet &lt;- tibble::tibble(
  sampleID = 1:(nPlate * nColumn * nRow),
  Treatment = rep(treatments, each = floor(nPlate * nColumn * nRow) / length(treatments)),
  Timepoint = rep(timepoints, floor(nPlate * nColumn * nRow) / length(treatments))
)

# assign samples from the sample sheet
bc &lt;- assign_random(bc, samples = sample_sheet)

plot_plate(bc$get_samples(),
  plate = plate, column = column, row = row,
  .color = Treatment, .alpha = Timepoint
)


plot_plate(bc$get_samples(),
  plate = plate, column = column, row = row,
  .color = Treatment, .pattern = Timepoint
)

</code></pre>

<hr>
<h2 id='random_score_variances'>Estimate the variance of individual scores by a series of completely random sample permutations</h2><span id='topic+random_score_variances'></span>

<h3>Description</h3>

<p>Estimate the variance of individual scores by a series of completely random sample permutations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_score_variances(
  batch_container,
  scoring,
  random_perm,
  sample_attributes_fixed
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_score_variances_+3A_batch_container">batch_container</code></td>
<td>
<p>An instance of <code>BatchContainer</code>.</p>
</td></tr>
<tr><td><code id="random_score_variances_+3A_scoring">scoring</code></td>
<td>
<p>A named <code><a href="base.html#topic+list">list()</a></code> of scoring function. Each function should
return a vector of non-zero length.</p>
</td></tr>
<tr><td><code id="random_score_variances_+3A_random_perm">random_perm</code></td>
<td>
<p>Number of random sample permutations to be done.</p>
</td></tr>
<tr><td><code id="random_score_variances_+3A_sample_attributes_fixed">sample_attributes_fixed</code></td>
<td>
<p>Logical; if FALSE, simulate a shuffle function that alters sample attributes at each iteration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of length m (=dimensionality of score) with estimated variances of each subscore
</p>

<hr>
<h2 id='report_scores'>Helper function to print out one set of scores plus (if needed) aggregated values</h2><span id='topic+report_scores'></span>

<h3>Description</h3>

<p>Helper function to print out one set of scores plus (if needed) aggregated values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>report_scores(score, agg_score, iteration)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="report_scores_+3A_score">score</code></td>
<td>
<p>Vector of (non-aggregated) scores (may be a single value as well)</p>
</td></tr>
<tr><td><code id="report_scores_+3A_agg_score">agg_score</code></td>
<td>
<p>Vector of aggregated scores (may be a single value as well)</p>
</td></tr>
<tr><td><code id="report_scores_+3A_iteration">iteration</code></td>
<td>
<p>Iteration number</p>
</td></tr>
</table>

<hr>
<h2 id='sample_random_scores'>Sample scores from a number of completely random sample permutations</h2><span id='topic+sample_random_scores'></span>

<h3>Description</h3>

<p>Sample scores from a number of completely random sample permutations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_random_scores(
  batch_container,
  scoring,
  random_perm,
  sample_attributes_fixed
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_random_scores_+3A_batch_container">batch_container</code></td>
<td>
<p>An instance of <a href="#topic+BatchContainer">BatchContainer</a>.</p>
</td></tr>
<tr><td><code id="sample_random_scores_+3A_scoring">scoring</code></td>
<td>
<p>A named <code><a href="base.html#topic+list">list()</a></code> of scoring function. Each function should
return a vector of non-zero length.</p>
</td></tr>
<tr><td><code id="sample_random_scores_+3A_random_perm">random_perm</code></td>
<td>
<p>Number of random sample permutations to be done.</p>
</td></tr>
<tr><td><code id="sample_random_scores_+3A_sample_attributes_fixed">sample_attributes_fixed</code></td>
<td>
<p>Logical; if <code>FALSE</code>, simulate a shuffle function that alters sample attributes at each iteration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A score matrix with n (# of permutations) rows and m (dimensionality of score) columns.
</p>

<hr>
<h2 id='shrink_mat'>Shrinks a matrix with scores and adds an iteration column.</h2><span id='topic+shrink_mat'></span>

<h3>Description</h3>

<p>Shrinks a matrix with scores and adds an iteration column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrink_mat(m, last_iteration)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shrink_mat_+3A_m">m</code></td>
<td>
<p>input matrix</p>
</td></tr>
<tr><td><code id="shrink_mat_+3A_last_iteration">last_iteration</code></td>
<td>
<p>last iteration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> wrapped in a list
</p>

<hr>
<h2 id='shuffle_grouped_data'>Generate in one go a shuffling function that produces permutations with specific constraints on multiple sample variables and group sizes fitting one specific allocation variable</h2><span id='topic+shuffle_grouped_data'></span>

<h3>Description</h3>

<p>Generate in one go a shuffling function that produces permutations with specific constraints on multiple sample variables and group sizes fitting one specific allocation variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffle_grouped_data(
  batch_container,
  allocate_var,
  keep_together_vars = c(),
  keep_separate_vars = c(),
  n_min = NA,
  n_max = NA,
  n_ideal = NA,
  subgroup_var_name = NULL,
  report_grouping_as_attribute = FALSE,
  prefer_big_groups = FALSE,
  strict = TRUE,
  fullTree = FALSE,
  maxCalls = 1e+06
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shuffle_grouped_data_+3A_batch_container">batch_container</code></td>
<td>
<p>Batch container with all samples assigned that are to be grouped and sub-grouped</p>
</td></tr>
<tr><td><code id="shuffle_grouped_data_+3A_allocate_var">allocate_var</code></td>
<td>
<p>Name of a variable in the <code>samples</code> table to inform possible groupings, as (sub)group sizes must add up to the correct totals</p>
</td></tr>
<tr><td><code id="shuffle_grouped_data_+3A_keep_together_vars">keep_together_vars</code></td>
<td>
<p>Vector of column names in sample table; groups are formed by pooling samples with identical values of all those variables</p>
</td></tr>
<tr><td><code id="shuffle_grouped_data_+3A_keep_separate_vars">keep_separate_vars</code></td>
<td>
<p>Vector of column names in sample table; items with identical values in those variables will not be put into the same subgroup if at all possible</p>
</td></tr>
<tr><td><code id="shuffle_grouped_data_+3A_n_min">n_min</code></td>
<td>
<p>Minimal number of samples in one sub(!)group; by default 1</p>
</td></tr>
<tr><td><code id="shuffle_grouped_data_+3A_n_max">n_max</code></td>
<td>
<p>Maximal number of samples in one sub(!)group; by default the size of the biggest group</p>
</td></tr>
<tr><td><code id="shuffle_grouped_data_+3A_n_ideal">n_ideal</code></td>
<td>
<p>Ideal number of samples in one sub(!)group; by default the floor or ceiling of <code>mean(n_min,n_max)</code>, depending on the setting of <code>prefer_big_groups</code></p>
</td></tr>
<tr><td><code id="shuffle_grouped_data_+3A_subgroup_var_name">subgroup_var_name</code></td>
<td>
<p>An optional column name for the subgroups which are formed (or NULL)</p>
</td></tr>
<tr><td><code id="shuffle_grouped_data_+3A_report_grouping_as_attribute">report_grouping_as_attribute</code></td>
<td>
<p>Boolean, if TRUE, add an attribute table to the permutation functions' output, to be used in scoring during the design optimization</p>
</td></tr>
<tr><td><code id="shuffle_grouped_data_+3A_prefer_big_groups">prefer_big_groups</code></td>
<td>
<p>Boolean; indicating whether or not bigger subgroups should be preferred in case of several possibilities</p>
</td></tr>
<tr><td><code id="shuffle_grouped_data_+3A_strict">strict</code></td>
<td>
<p>Boolean; if TRUE, subgroup size constraints have to be met strictly, implying the possibility of finding no solution at all</p>
</td></tr>
<tr><td><code id="shuffle_grouped_data_+3A_fulltree">fullTree</code></td>
<td>
<p>Boolean: Enforce full search of the possibility tree, independent of the value of <code>maxCalls</code></p>
</td></tr>
<tr><td><code id="shuffle_grouped_data_+3A_maxcalls">maxCalls</code></td>
<td>
<p>Maximum number of recursive calls in the search tree, to avoid long run times with very large trees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Shuffling function that on each call returns an index vector for a valid sample permutation
</p>

<hr>
<h2 id='shuffle_with_constraints'>Shuffling proposal function with constraints.</h2><span id='topic+shuffle_with_constraints'></span>

<h3>Description</h3>

<p>Can be used with <code>optimize_design</code> to improve convergence speed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffle_with_constraints(src = TRUE, dst = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shuffle_with_constraints_+3A_src">src</code></td>
<td>
<p>Expression to define possible source locations in the samples/locations
table. Usually evaluated based on
<code>BatchContainer$get_samples(include_id = TRUE, as_tibble = FALSE)</code> as an environment
(see also <code>with()</code>). A single source location is selected from rows where the
expression evaluates to<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="shuffle_with_constraints_+3A_dst">dst</code></td>
<td>
<p>Expression to define possible destination locations in the
samples/locations table. Usually evaluated based on <code>BatchContainer$get_samples()</code> as an
environment.
Additionally a special variable <code>.src</code> is available in this environment which
describes the selected source row from the table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a function which accepts a <code>BatchContainer</code> and an iteration
number (<code>i</code>). This function returns a list with two names: <code>src</code> vector of length
2 and <code>dst</code> vector of length two. See <code><a href="#topic+BatchContainer">BatchContainer$move_samples()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(43)

samples &lt;- data.frame(
  id = 1:100,
  sex = sample(c("F", "M"), 100, replace = TRUE),
  group = sample(c("treatment", "control"), 100, replace = TRUE)
)

bc &lt;- BatchContainer$new(
  dimensions = c("plate" = 5, "position" = 25)
)

scoring_f &lt;- function(samples) {
  osat_score(
    samples,
    "plate",
    c("sex", "group")
  )$score
}

# in this example we treat all the positions in the plate as equal.
# when shuffling we enforce that source location is non-empty,
# and destination location has a different plate number
bc &lt;- optimize_design(
  bc,
  scoring = scoring_f,
  samples,
  shuffle_proposal = shuffle_with_constraints(
    # source is non-empty location
    !is.na(.sample_id),
    # destination has a different plate
    plate != .src$plate
  ),
  max_iter = 10
)
</code></pre>

<hr>
<h2 id='shuffle_with_subgroup_formation'>Compose shuffling function based on already available subgrouping and allocation information</h2><span id='topic+shuffle_with_subgroup_formation'></span>

<h3>Description</h3>

<p>Compose shuffling function based on already available subgrouping and allocation information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffle_with_subgroup_formation(
  subgroup_object,
  subgroup_allocations,
  keep_separate_vars = c(),
  report_grouping_as_attribute = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shuffle_with_subgroup_formation_+3A_subgroup_object">subgroup_object</code></td>
<td>
<p>A subgrouping object as returned by <code>form_homogeneous_subgroups()</code></p>
</td></tr>
<tr><td><code id="shuffle_with_subgroup_formation_+3A_subgroup_allocations">subgroup_allocations</code></td>
<td>
<p>A list of possible assignments of the allocation variable as returned by <code>compile_possible_subgroup_allocation()</code></p>
</td></tr>
<tr><td><code id="shuffle_with_subgroup_formation_+3A_keep_separate_vars">keep_separate_vars</code></td>
<td>
<p>Vector of column names in sample table; items with identical values in those variables will not be put into the same subgroup if at all possible</p>
</td></tr>
<tr><td><code id="shuffle_with_subgroup_formation_+3A_report_grouping_as_attribute">report_grouping_as_attribute</code></td>
<td>
<p>Boolean, if TRUE, add an attribute table to the permutation functions' output, to be used in scoring during the design optimization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Shuffling function that on each call returns an index vector for a valid sample permutation
</p>

<hr>
<h2 id='simanneal_acceptance_prob'>Acceptance probability for a new solution</h2><span id='topic+simanneal_acceptance_prob'></span>

<h3>Description</h3>

<p>A solution is always to be accepted if it leads to a lower score. Worse solutions should be accepted with a probability given by this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simanneal_acceptance_prob(current_score, best_score, temp, eps = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simanneal_acceptance_prob_+3A_current_score">current_score</code></td>
<td>
<p>Score from the current optimizing iteration (scalar value, double)</p>
</td></tr>
<tr><td><code id="simanneal_acceptance_prob_+3A_best_score">best_score</code></td>
<td>
<p>Score from the current optimizing iteration (scalar value, double)</p>
</td></tr>
<tr><td><code id="simanneal_acceptance_prob_+3A_temp">temp</code></td>
<td>
<p>Current value of annealing temperature</p>
</td></tr>
<tr><td><code id="simanneal_acceptance_prob_+3A_eps">eps</code></td>
<td>
<p>Small parameter eps(ilon), achieving that not always the new solution is taken when scores are exactly equal</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Probability with which to accept the new score as the best one
</p>

<hr>
<h2 id='sum_scores'>Aggregation of scores: sum up all individual scores</h2><span id='topic+sum_scores'></span>

<h3>Description</h3>

<p>Aggregation of scores: sum up all individual scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_scores(scores, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sum_scores_+3A_scores">scores</code></td>
<td>
<p>A score or multiple component score vector</p>
</td></tr>
<tr><td><code id="sum_scores_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean. Should NA values be ignored when obtaining the maximum? FALSE by default as ignoring NA values may render the sum meaningless.</p>
</td></tr>
<tr><td><code id="sum_scores_+3A_...">...</code></td>
<td>
<p>Parameters to be ignored by this aggregation function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The aggregated score, i.e. the sum of all indicidual scores.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sum_scores(c(3, 2, 1))
</code></pre>

<hr>
<h2 id='update_batchcontainer'>Updates a batch container by permuting samples according to a shuffling</h2><span id='topic+update_batchcontainer'></span>

<h3>Description</h3>

<p>As post-condition, the batch container is in a different state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_batchcontainer(bc, shuffle_params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_batchcontainer_+3A_bc">bc</code></td>
<td>
<p>The batch container to operate on.</p>
</td></tr>
<tr><td><code id="update_batchcontainer_+3A_shuffle_params">shuffle_params</code></td>
<td>
<p>Shuffling parameters as returned by <code><a href="#topic+extract_shuffle_params">extract_shuffle_params()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if sample attributes have been assigned, FALSE otherwise
</p>

<hr>
<h2 id='validate_samples'>Validates sample data.frame.</h2><span id='topic+validate_samples'></span>

<h3>Description</h3>

<p>Validates sample data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_samples(samples)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_samples_+3A_samples">samples</code></td>
<td>
<p>A <code>data.frame</code> having a sample annotation per row.</p>
</td></tr>
</table>

<hr>
<h2 id='validate_subgrouping_object'>Validate subgroup object and stop with error message if not all required fields are there</h2><span id='topic+validate_subgrouping_object'></span>

<h3>Description</h3>

<p>Validate subgroup object and stop with error message if not all required fields are there
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_subgrouping_object(subgroup_object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_subgrouping_object_+3A_subgroup_object">subgroup_object</code></td>
<td>
<p>Subgrouping object as returned by <code>form_homogeneous_subgroups()</code></p>
</td></tr>
</table>

<hr>
<h2 id='worst_score'>Aggregation of scores: take the maximum (i.e. worst score only)</h2><span id='topic+worst_score'></span>

<h3>Description</h3>

<p>This function enables comparison of the results of two scoring functions by just basing
the decision on the largest element. This corresponds to the infinity-norm in ML terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>worst_score(scores, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="worst_score_+3A_scores">scores</code></td>
<td>
<p>A score or multiple component score vector</p>
</td></tr>
<tr><td><code id="worst_score_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean. Should NA values be ignored when obtaining the maximum? FALSE by default as ignoring NA values may hide some issues with the provided scoring functions and also the aggregated value cannot be seen as the proper infinity norm anymore.</p>
</td></tr>
<tr><td><code id="worst_score_+3A_...">...</code></td>
<td>
<p>Parameters to be ignored by this aggregation function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The aggregated score, i.e. the value of the largest element in a multiple-component score vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>worst_score(c(3, 2, 1))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
