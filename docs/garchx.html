<!DOCTYPE html><html><head><title>Help for package garchx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {garchx}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.garchx'><p>Extraction functions for 'garchx' objects</p></a></li>
<li><a href='#garchx'><p>Estimate a GARCH-X model</p></a></li>
<li><a href='#garchx-package'><p>Flexible and Robust GARCH-X Modelling</p></a></li>
<li><a href='#garchxAvar'><p>Asymptotic Coefficient Covariance</p></a></li>
<li><a href='#garchxObjective'><p>Auxiliary functions</p></a></li>
<li><a href='#garchxSim'><p>Simulate from a GARCH-X model</p></a></li>
<li><a href='#gdiff'><p> Difference a vector or a matrix, with special treatment of zoo objects</p></a></li>
<li><a href='#glag'><p> Lag a vector or a matrix, with special treatment of <code>zoo</code> objects</p></a></li>
<li><a href='#refit'><p>Refit a model to new data</p></a></li>
<li><a href='#rmnorm'>
<p>Random number generation from the multivariate normal distribution</p></a></li>
<li><a href='#ttest0'><p>T-tests and Wald-tests under nullity</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Flexible and Robust GARCH-X Modelling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Genaro Sucarrat [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Genaro Sucarrat &lt;gsucarrat@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Flexible and robust estimation and inference of generalised autoregressive conditional heteroscedasticity (GARCH) models with covariates ('X') based on the results by Francq and Thieu (2018) &lt;<a href="https://doi.org/10.1017%2FS0266466617000512">doi:10.1017/S0266466617000512</a>&gt;. Coefficients can straightforwardly be set to zero by omission, and quasi maximum likelihood methods ensure estimates are generally consistent and inference valid, even when the standardised innovations are non-normal and/or dependent over time, see <a href="https://journal.r-project.org/archive/2021/RJ-2021-057/RJ-2021-057.pdf">https://journal.r-project.org/archive/2021/RJ-2021-057/RJ-2021-057.pdf</a> for an overview of the package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), methods, zoo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tvgarch, lgarch</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gsucarrat/garchx/issues">https://github.com/gsucarrat/garchx/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.sucarrat.net/">https://www.sucarrat.net/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-13 14:01:41 UTC; sucarrat</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-13 14:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.garchx'>Extraction functions for 'garchx' objects</h2><span id='topic+coef.garchx'></span><span id='topic+fitted.garchx'></span><span id='topic+logLik.garchx'></span><span id='topic+nobs.garchx'></span><span id='topic+predict.garchx'></span><span id='topic+print.garchx'></span><span id='topic+quantile.garchx'></span><span id='topic+residuals.garchx'></span><span id='topic+toLatex.garchx'></span><span id='topic+vcov.garchx'></span>

<h3>Description</h3>

<p>Extraction functions for objects of class 'garchx'</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'garchx'
coef(object, ...)
  ## S3 method for class 'garchx'
fitted(object, as.zoo = TRUE, ...)
  ## S3 method for class 'garchx'
logLik(object, ...)
  ## S3 method for class 'garchx'
nobs(object, ...)
  ## S3 method for class 'garchx'
predict(object, n.ahead = 10, newxreg = NULL,
    newindex = NULL, n.sim = NULL, verbose = FALSE, ...)
  ## S3 method for class 'garchx'
print(x, ...)
  ## S3 method for class 'garchx'
quantile(x, probs=0.025, names = TRUE, type = 7, as.zoo = TRUE, ...)
  ## S3 method for class 'garchx'
residuals(object, as.zoo = TRUE, ...)
  ## S3 method for class 'garchx'
toLatex(object, digits = 4, ...)
  ## S3 method for class 'garchx'
vcov(object, vcov.type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.garchx_+3A_object">object</code></td>
<td>
<p>an object of class 'garchx'</p>
</td></tr>
<tr><td><code id="coef.garchx_+3A_x">x</code></td>
<td>
<p>an object of class 'garchx'</p>
</td></tr>
<tr><td><code id="coef.garchx_+3A_as.zoo">as.zoo</code></td>
<td>
<p>logical. If <code>TRUE</code>, then the returned result is of class <code><a href="zoo.html#topic+zoo">zoo</a></code> </p>
</td></tr>
<tr><td><code id="coef.garchx_+3A_n.ahead">n.ahead</code></td>
<td>
<p><code>integer</code> that determines how many steps ahead predictions should be generated</p>
</td></tr>
<tr><td><code id="coef.garchx_+3A_newxreg">newxreg</code></td>
<td>
<p><code>vector</code> or <code>matrix</code> with the out-of-sample regressor values</p>
</td></tr>
<tr><td><code id="coef.garchx_+3A_newindex">newindex</code></td>
<td>
<p><code>zoo</code>-index for the out-of-sample predictions. If <code>NULL</code> (default), then <code>1:n.ahead</code> is used</p>
</td></tr>
<tr><td><code id="coef.garchx_+3A_n.sim">n.sim</code></td>
<td>
<p><code>NULL</code> or an <code>integer</code>, the number of simulations</p>
</td></tr>
<tr><td><code id="coef.garchx_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then the simulations - in addition to the predictions - are returned</p>
</td></tr>
<tr><td><code id="coef.garchx_+3A_probs">probs</code></td>
<td>
<p><code>vector</code> of probabilities</p>
</td></tr>
<tr><td><code id="coef.garchx_+3A_names">names</code></td>
<td>
<p><code>logical</code>, whether to return names or not</p>
</td></tr>
<tr><td><code id="coef.garchx_+3A_type">type</code></td>
<td>
<p><code>integer</code> that determines the algorithm used to compute the quantile, see <code><a href="stats.html#topic+quantile">quantile</a></code> </p>
</td></tr>
<tr><td><code id="coef.garchx_+3A_digits">digits</code></td>
<td>
<p><code>integer</code>, the number of digits in the printed LaTeX code</p>
</td></tr>
<tr><td><code id="coef.garchx_+3A_vcov.type">vcov.type</code></td>
<td>
<p><code>NULL</code> or a <code>character</code> that is (partially) matched to <code>"ordinary"</code> or <code>"robust"</code>. The robust coefficient-covariance is that of Francq and Thieu (2018).</p>
</td></tr>
<tr><td><code id="coef.garchx_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>coef:</code></td>
<td>
<p>numeric vector containing parameter estimates</p>
</td></tr>
<tr><td><code>fitted:</code></td>
<td>
<p>fitted conditional variance</p>
</td></tr>
<tr><td><code>logLik:</code></td>
<td>
<p>log-likelihood (normal density)</p>
</td></tr>
<tr><td><code>nobs:</code></td>
<td>
<p>the number of observations used in the estimation</p>
</td></tr>
<tr><td><code>predict:</code></td>
<td>
<p>a <code>vector</code> with the predictions (<code>verbose=FALSE</code>), or a <code>matrix</code> with both the predictions and the simulations (<code>verbose=TRUE</code>) </p>
</td></tr>
<tr><td><code>print:</code></td>
<td>
<p>print of the estimation results</p>
</td></tr>
<tr><td><code>quantile:</code></td>
<td>
<p>the fitted quantiles, i.e. the conditional standard deviation times the empirical quantile of the standardised innovations</p>
</td></tr>
<tr><td><code>residuals:</code></td>
<td>
<p>standardised residuals</p>
</td></tr>
<tr><td><code>vcov:</code></td>
<td>
<p>coefficient variance-covariance matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a>
</p>


<h3>References</h3>

<p>Christian Francq and Le Quien Thieu (2018): 'QML inference for volatility models with covariates', Econometric Theory, doi:10.1017/S0266466617000512
</p>


<h3>See Also</h3>

<p><code><a href="#topic+garchx">garchx</a></code>, <code><a href="#topic+garchxSim">garchxSim</a></code>, <code><a href="zoo.html#topic+zoo">zoo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##simulate from a garch(1,1):
set.seed(123)
y &lt;- garchxSim(1000)

##estimate garch(1,1) model:
mymod &lt;- garchx(y)

##print estimation results:
print(mymod)

##extract coefficients:
coef(mymod)

##extract and store conditional variances:
sigma2hat &lt;- fitted(mymod)

##extract log-likelihood:
logLik(mymod)

##extract and store standardised residuals:
etahat &lt;- residuals(mymod)

##extract coefficient variance-covariance matrix:
vcov(mymod)

##generate predictions:
predict(mymod)

</code></pre>

<hr>
<h2 id='garchx'>Estimate a GARCH-X model</h2><span id='topic+garchx'></span>

<h3>Description</h3>

<p>Quasi Maximum Likelihood (ML) estimation of a GARCH(q,p,r)-X model, where q is the GARCH order, p is the ARCH order, r is the asymmetry (or leverage) order and 'X' indicates that covariates can be included. Note that the underlying estimation theory assumes the covariates are stochastic. The estimation procedure will, in general, provide consistent estimates when the standardised innovations are not normal or independent (or both), see Francq and Thieu (2018). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>garchx(y, order = c(1,1), arch = NULL, garch = NULL, asym = NULL,
  xreg = NULL, vcov.type = c("ordinary", "robust"),
  initial.values = NULL, backcast.values = NULL, lower = 0,
  upper = +Inf, control = list(), hessian.control = list(),
  solve.tol = .Machine$double.eps, estimate = TRUE, c.code = TRUE,
  penalty.value = NULL, sigma2.min = .Machine$double.eps,
  objective.fun = 1, turbo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="garchx_+3A_y">y</code></td>
<td>
<p>numeric vector, time-series or <code><a href="zoo.html#topic+zoo">zoo</a></code> object. Missing values in the beginning and at the end of the series is allowed, as they are removed with the <code><a href="zoo.html#topic+na.trim">na.trim</a></code> command</p>
</td></tr>
<tr><td><code id="garchx_+3A_order">order</code></td>
<td>
<p>integer vector of length 1, 2 or 3, for example <code>c(1,1,1)</code>. The first entry controls the GARCH order, the second the ARCH order and the third the ASYM (asymmetry/leverage) order</p>
</td></tr>
<tr><td><code id="garchx_+3A_arch">arch</code></td>
<td>
<p><code>NULL</code> or numeric vector containing the ARCH-terms to include. Note: If not <code>NULL</code>, then the value of the <code>ARCH</code> argument overrides the value of the first entry in the <code>order</code> argument</p>
</td></tr>
<tr><td><code id="garchx_+3A_garch">garch</code></td>
<td>
<p><code>NULL</code> or numeric vector containing the GARCH-terms to include. Note: If not <code>NULL</code>, then the value of the <code>GARCH</code> argument overrides the value of the second entry in the <code>order</code> argument</p>
</td></tr>
<tr><td><code id="garchx_+3A_asym">asym</code></td>
<td>
<p><code>NULL</code> or numeric vector containing the ASYM-terms (asymmetry/leverage terms) to include. Note: If not <code>NULL</code>, then the value of the <code>ASYM</code> argument overrides the value of the third entry in the <code>order</code> argument</p>
</td></tr>
<tr><td><code id="garchx_+3A_xreg">xreg</code></td>
<td>
<p>numeric vector, time-series or <code><a href="zoo.html#topic+zoo">zoo</a></code> object. Missing values in the beginning and at the end of the series is allowed, as they are removed with the <code><a href="zoo.html#topic+na.trim">na.trim</a></code> command</p>
</td></tr>
<tr><td><code id="garchx_+3A_vcov.type">vcov.type</code></td>
<td>
<p><code>character</code>, either <code>"ordinary"</code> or <code>"robust"</code>, see <code><a href="#topic+vcov.garchx">vcov.garchx</a></code> </p>
</td></tr>
<tr><td><code id="garchx_+3A_initial.values">initial.values</code></td>
<td>
<p><code>NULL</code> or a numeric vector with the initial parameter values passed on to the optimisation routine, <code><a href="stats.html#topic+nlminb">nlminb</a></code>. If <code>NULL</code>, the default, then the values are chosen automatically</p>
</td></tr>
<tr><td><code id="garchx_+3A_backcast.values">backcast.values</code></td>
<td>
<p><code>NULL</code> or a non-negative numeric. The backcast value is used to initiate the forward recursion of the conditional variance. If <code>NULL</code> (default), then the value is chosen automatically (currently the average of <code>y</code> squared is used). If <code>backcast.values</code> is a non-negative numeric, then the initial recursion values are all set to this value</p>
</td></tr>
<tr><td><code id="garchx_+3A_lower">lower</code></td>
<td>
<p>numeric vector, either of length 1 or the number of parameters to be estimated, see <code><a href="stats.html#topic+nlminb">nlminb</a></code></p>
</td></tr>
<tr><td><code id="garchx_+3A_upper">upper</code></td>
<td>
<p>numeric vector, either of length 1 or the number of parameters to be estimated, see <code><a href="stats.html#topic+nlminb">nlminb</a></code></p>
</td></tr>
<tr><td><code id="garchx_+3A_control">control</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> passed on to the <code>control</code> argument of <code><a href="stats.html#topic+nlminb">nlminb</a></code></p>
</td></tr>
<tr><td><code id="garchx_+3A_hessian.control">hessian.control</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> passed on to the <code>control</code> argument of <code><a href="stats.html#topic+optimHess">optimHess</a></code></p>
</td></tr>
<tr><td><code id="garchx_+3A_solve.tol">solve.tol</code></td>
<td>
<p>numeric value passed on to the <code>tol</code> argument of <code><a href="Matrix.html#topic+solve">solve</a></code>, which is called whenever the coefficient variance-coariance matrix is computed. The value controls the toleranse for detecting linear dependence between columns when inverting a matrix</p>
</td></tr>
<tr><td><code id="garchx_+3A_estimate">estimate</code></td>
<td>
<p>logical, if <code>TRUE</code> then estimation is carried out. If <code>FALSE</code>, then the <code>initial.values</code> are used</p>
</td></tr>
<tr><td><code id="garchx_+3A_c.code">c.code</code></td>
<td>
<p>logical, if <code>TRUE</code> then compiled C code is used in the forward recursion</p>
</td></tr>
<tr><td><code id="garchx_+3A_penalty.value">penalty.value</code></td>
<td>
<p><code>NULL</code> (default) or a numeric value. If <code>NULL</code>, then the log-likelihood value associated with the initial values is used. Sometimes estimation can result in <code>NA</code> and/or <code>+/-Inf</code> values. The <code>penalty.value</code> is the value returned by the objective function <code><a href="#topic+garchxObjective">garchxObjective</a></code> in the presence of <code>NA</code> or <code>+/-Inf</code> values</p>
</td></tr>
<tr><td><code id="garchx_+3A_sigma2.min">sigma2.min</code></td>
<td>
<p>numeric with default <code>.Machine$double.eps</code>. To avoid taking taking the log of a very small value when computing the log-likelihood, <code>sigma2.min</code> is used as the lower bound of the fitted conditional variances, see the code of <code><a href="#topic+garchxObjective">garchxObjective</a></code> </p>
</td></tr>
<tr><td><code id="garchx_+3A_objective.fun">objective.fun</code></td>
<td>
<p>numeric, either 1 or 0</p>
</td></tr>
<tr><td><code id="garchx_+3A_turbo">turbo</code></td>
<td>
<p>logical. If <code>FALSE</code> (default), then the coefficient variance-covariance is computed during estimation, and the fitted values and residuals are attached to the returned object. If <code>TRUE</code>, then these operations are skipped, and hence estimation is faster. Note, however, that if <code>turbo</code> is set to <code>TRUE</code>, then the coefficient-covariance, fitted values and residuals can still be extracted subsequent to estimation with <code><a href="#topic+vcov.garchx">vcov.garchx</a></code>, <code><a href="#topic+fitted.garchx">fitted.garchx</a></code> and <code><a href="#topic+residuals.garchx">residuals.garchx</a></code>, respectively </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class 'garchx'</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>References</h3>

<p>Christian Francq and Le Quien Thieu (2018): 'QML inference for volatility models with covariates', Econometric Theory, doi:10.1017/S0266466617000512<br />
Christian Francq and Jean-Michel Zakoian (2019): 'GARCH Models', 2nd Edition, Wiley
</p>


<h3>See Also</h3>

<p><code><a href="#topic+garchxSim">garchxSim</a></code>, <code><a href="stats.html#topic+nlminb">nlminb</a></code>, <code><a href="stats.html#topic+optimHess">optimHess</a></code>, <code><a href="#topic+coef.garchx">coef.garchx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##simulate from a garch(1,1):
set.seed(123)
y &lt;- garchxSim(1000)

##estimate garch(1,1) model:
mymod &lt;- garchx(y)

##print estimation results:
print(mymod)

##extract coefficients:
coef(mymod)

##extract and store conditional variances:
sigma2hat &lt;- fitted(mymod)

##extract log-likelihood:
logLik(mymod)

##extract and store standardised residuals:
etahat &lt;- residuals(mymod)

##extract variance-covariance matrix:
vcov(mymod)

##generate predictions:
predict(mymod)

</code></pre>

<hr>
<h2 id='garchx-package'>Flexible and Robust GARCH-X Modelling</h2><span id='topic+garchx-package'></span>

<h3>Description</h3>

<p>Flexible and robust estimation and inference of GARCH(q,p,r)-X models, where q is the GARCH order, p is the ARCH order, r is the asymmetry or leverage order, and 'X' indicates that covariates can be included. Suitable subsets of the coefficients can be restriced to zero by omission, and Quasi Maximum Likelihood (QML) methods ensure estimates are generally consistent, even when the standardised innovations are non-normal and/or dependent.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
  Package: </td><td style="text-align: left;"> garchx</td>
</tr>
<tr>
 <td style="text-align: left;">
  Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
  Version: </td><td style="text-align: left;"> 1.5</td>
</tr>
<tr>
 <td style="text-align: left;">
  Date: </td><td style="text-align: left;"> 2022-09-13</td>
</tr>
<tr>
 <td style="text-align: left;">
  License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a><br /><br />
Maintainer: Genaro Sucarrat
</p>


<h3>See Also</h3>

<p><code><a href="#topic+garchxSim">garchxSim</a></code>, <code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+fitted">fitted</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code>, <code><a href="base.html#topic+print">print</a></code>, <code><a href="stats.html#topic+residuals">residuals</a></code>, <code><a href="stats.html#topic+vcov">vcov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##simulate from a garch(1,1):
set.seed(123)
y &lt;- garchxSim(1000)

##estimate garch(1,1) model:
mymod &lt;- garchx(y)
mymod

</code></pre>

<hr>
<h2 id='garchxAvar'>Asymptotic Coefficient Covariance</h2><span id='topic+garchxAvar'></span>

<h3>Description</h3>

<p>Compute the asymptotic coefficient-covariance of a GARCH(q,p,r)-X model by simulation. Note that the principles of how to use the <code>arch</code>, <code>garch</code>, <code>asym</code> and <code>xreg</code> arguments are the same as those of <code><a href="#topic+garchx">garchx</a></code> </p>


<h3>Usage</h3>

<pre><code class='language-R'>garchxAvar(pars, arch = NULL, garch = NULL, asym = NULL,
  xreg = NULL, vcov.type = c("ordinary", "robust"),
  innovations = NULL, Eeta4 = NULL, n = 1e+06, objective.fun = 1,
  seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="garchxAvar_+3A_pars">pars</code></td>
<td>
<p><code>vector</code> of parameters of length 1 or more. The first component contains the coefficient-value of the intercept, the next component(s) the ARCH-coefficient(s), and so on.</p>
</td></tr>
<tr><td><code id="garchxAvar_+3A_arch">arch</code></td>
<td>
<p><code>NULL</code> or integer <code>vector</code> with the lags of the ARCH-terms to include. Works in the same way as the <code>arch</code> argument in the <code><a href="#topic+garchx">garchx</a></code> function</p>
</td></tr>
<tr><td><code id="garchxAvar_+3A_garch">garch</code></td>
<td>
<p><code>NULL</code> or integer <code>vector</code> with the lags of the GARCH-terms. Works in the same way as the <code>garch</code> argument in the <code><a href="#topic+garchx">garchx</a></code> function</p>
</td></tr>
<tr><td><code id="garchxAvar_+3A_asym">asym</code></td>
<td>
<p><code>NULL</code> or integer <code>vector</code> with the lags of the asymmetry terms to include. Works in the same way as the <code>asym</code> argument in the <code><a href="#topic+garchx">garchx</a></code> function</p>
</td></tr>
<tr><td><code id="garchxAvar_+3A_xreg">xreg</code></td>
<td>
<p><code>NULL</code>, or a <code>vector</code> or <code>matrix</code> with the covariates of the model. Works in the same way as the <code>xreg</code> argument in the <code><a href="#topic+garchx">garchx</a></code> function</p>
</td></tr>
<tr><td><code id="garchxAvar_+3A_vcov.type">vcov.type</code></td>
<td>
<p><code>character</code> that determines the type of coefficient-covariance</p>
</td></tr>
<tr><td><code id="garchxAvar_+3A_innovations">innovations</code></td>
<td>
<p><code>NULL</code> or a <code>vector</code> with the standardised innovations to use. If <code>NULL</code>, then the innovations are standard normal</p>
</td></tr>
<tr><td><code id="garchxAvar_+3A_eeta4">Eeta4</code></td>
<td>
<p><code>numeric</code>, the fourth moment of the innovations. If <code>NULL</code>, then the value is estimated internally. Note: The value of Eeta4 is only used if <code>vcov.type = "ordinary"</code>, otherwise it is ignored </p>
</td></tr>
<tr><td><code id="garchxAvar_+3A_n">n</code></td>
<td>
<p>integer, the number of observations to use in the simulations</p>
</td></tr>
<tr><td><code id="garchxAvar_+3A_objective.fun">objective.fun</code></td>
<td>
<p>integer equal to 1 or 0 that determines the type of objective function to use, see the code of <code><a href="#topic+garchxObjective">garchxObjective</a></code> </p>
</td></tr>
<tr><td><code id="garchxAvar_+3A_seed">seed</code></td>
<td>
<p><code>NULL</code> or an integer that sets the seed (the value is passed on to <code><a href="base.html#topic+set.seed">set.seed</a></code>. Useful for reproducibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code></p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>References</h3>

<p>Christian Francq and Le Quien Thieu (2018): 'QML inference for volatility models with covariates', Econometric Theory, doi:10.1017/S0266466617000512
Christian Francq and Jean-Michel Zakoian (2019): 'GARCH Models', 2nd Edition, Wiley
</p>


<h3>See Also</h3>

<p><code><a href="#topic+garchx">garchx</a></code>, <code><a href="#topic+garchxSim">garchxSim</a></code>, <code><a href="#topic+vcov.garchx">vcov.garchx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##asymptotic coefficient-covariance of a garch(1,1)
##note: the estimate is rough, since n is small
intercept &lt;- 0.2
alpha &lt;- 0.1
beta &lt;- 0.8
pars &lt;- c(intercept, alpha, beta)
seed &lt;- 123 #for reproducibility
garchxAvar(pars, arch=1, garch=1, n=10000, seed=seed)

</code></pre>

<hr>
<h2 id='garchxObjective'>Auxiliary functions</h2><span id='topic+garchxObjective'></span><span id='topic+garchxRecursion'></span>

<h3>Description</h3>

<p>Auxiliary functions used in estimation. Not intended for the average user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  garchxObjective(pars, aux)
  garchxRecursion(pars, aux)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="garchxObjective_+3A_pars">pars</code></td>
<td>
<p>numeric vector of parameters</p>
</td></tr>
<tr><td><code id="garchxObjective_+3A_aux">aux</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> created by <code><a href="#topic+garchx">garchx</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>garchxObjective:</code></td>
<td>
<p>value of the objective function</p>
</td></tr>
<tr><td><code>garchxRecursion:</code></td>
<td>
<p>fitted conditional variance</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+garchx">garchx</a></code>, <code><a href="#topic+fitted.garchx">fitted.garchx</a></code>, <code><a href="#topic+residuals.garchx">residuals.garchx</a></code> 
</p>

<hr>
<h2 id='garchxSim'>Simulate from a GARCH-X model</h2><span id='topic+garchxSim'></span>

<h3>Description</h3>

<p>Simulate from a GARCH(q,p,r)-X model. Optionally, if <code>verbose=TRUE</code>, the conditional variance and innovations are also returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>garchxSim(n, intercept = 0.2, arch = 0.1, garch = 0.8, asym = NULL, xreg = NULL,
  innovations = NULL, backcast.values = list(), verbose = FALSE, as.zoo = TRUE,
  c.code = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="garchxSim_+3A_n">n</code></td>
<td>
<p>integer</p>
</td></tr>
<tr><td><code id="garchxSim_+3A_intercept">intercept</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="garchxSim_+3A_arch">arch</code></td>
<td>
<p><code>NULL</code> or numeric vector with the values of the ARCH-coefficients</p>
</td></tr>
<tr><td><code id="garchxSim_+3A_garch">garch</code></td>
<td>
<p><code>NULL</code> or numeric vector with the values of the GARCH-coefficients</p>
</td></tr>
<tr><td><code id="garchxSim_+3A_asym">asym</code></td>
<td>
<p><code>NULL</code> or numeric vector with the values of the asymmetry-coefficients</p>
</td></tr>
<tr><td><code id="garchxSim_+3A_xreg">xreg</code></td>
<td>
<p><code>NULL</code> or numeric vector with the values of the X-term</p>
</td></tr>
<tr><td><code id="garchxSim_+3A_innovations">innovations</code></td>
<td>
<p><code>NULL</code> or numeric vector with the innovations. If <code>NULL</code>, then standard normal innovations are generated with <code><a href="stats.html#topic+rnorm">rnorm</a></code></p>
</td></tr>
<tr><td><code id="garchxSim_+3A_backcast.values">backcast.values</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> with backcast values</p>
</td></tr>
<tr><td><code id="garchxSim_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code></p>
</td></tr>
<tr><td><code id="garchxSim_+3A_as.zoo">as.zoo</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> (default), then the returned object is of class <code><a href="zoo.html#topic+zoo">zoo</a></code></p>
</td></tr>
<tr><td><code id="garchxSim_+3A_c.code">c.code</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> (default), then compiled C code is used for the recursion (faster). Otherwise R code is used (slower)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector or matrix with the simulated values.
</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+garchx">garchx</a></code>, <code><a href="zoo.html#topic+zoo">zoo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##simulate from a garch(1,1):
y &lt;- garchxSim(1000)

##simulate from a garch(1,1) with asymmetry/leverage:
yy &lt;- garchxSim(1000, asym=0.1)

##simulate from a garch(1,1) w/user-provided backcast values:
yyy &lt;- garchxSim(1000, backcast.values=list(z2=1, sigma2=0.5))

</code></pre>

<hr>
<h2 id='gdiff'> Difference a vector or a matrix, with special treatment of zoo objects</h2><span id='topic+gdiff'></span>

<h3>Description</h3>

<p>Similar to the <code><a href="base.html#topic+diff">diff</a></code> function from the base package, but <code>gdiff</code> enables padding (e.g. <code>NA</code>s or 0s) of the lost entries. Contrary to the <code><a href="base.html#topic+diff">diff</a></code> function in the base package, however, the default in <code>gdiff</code> is to pad (with <code>NA</code>s). The <code>gdiff</code> function is particularly suited for <code><a href="zoo.html#topic+zoo">zoo</a></code> objects, since their indexing is retained
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdiff(x, lag = 1, pad = TRUE, pad.value = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdiff_+3A_x">x</code></td>
<td>
<p>a numeric vector or matrix</p>
</td></tr>
<tr><td><code id="gdiff_+3A_lag">lag</code></td>
<td>
<p>integer equal to the difference-length (the default is 1)</p>
</td></tr>
<tr><td><code id="gdiff_+3A_pad">pad</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), then the lost entries are padded with pad.value. If <code>FALSE</code>, then no padding is undertaken</p>
</td></tr>
<tr><td><code id="gdiff_+3A_pad.value">pad.value</code></td>
<td>
<p>numeric, the pad-value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or matrix with the differenced values</p>


<h3>Note</h3>

<p>Empty</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+diff">diff</a></code>, <code><a href="#topic+glag">glag</a></code>, <code><a href="stats.html#topic+lag">lag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##1st difference of a series:
x &lt;- rnorm(5)
gdiff(x)

##1st difference with no padding:
gdiff(x, pad=FALSE)

##1st difference retaining the original zoo-index ordering:
gdiff(as.zoo(x))

##1st difference of a matrix:
y &lt;- matrix(rnorm(8),4,2)
gdiff(y)

##2nd difference of the same matrix:
gdiff(y, lag=2)

</code></pre>

<hr>
<h2 id='glag'> Lag a vector or a matrix, with special treatment of <code><a href="zoo.html#topic+zoo">zoo</a></code> objects</h2><span id='topic+glag'></span>

<h3>Description</h3>

<p>Similar to the <code><a href="stats.html#topic+lag">lag</a></code> function from the <code>stats</code> package, but <code>glag</code> enables padding (e.g. NAs or 0s) of the lost entries. Contrary to the <code><a href="stats.html#topic+lag">lag</a></code> function in the stats package, however, the default in <code>glag</code> is to pad (with <code>NA</code>s). The <code>glag</code> is particularly suited for <code><a href="zoo.html#topic+zoo">zoo</a></code> objects, since their indexing is retained
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glag(x, k = 1, pad = TRUE, pad.value = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glag_+3A_x">x</code></td>
<td>
<p>a numeric vector or matrix</p>
</td></tr>
<tr><td><code id="glag_+3A_k">k</code></td>
<td>
<p>integer equal to the lag (the default is 1)</p>
</td></tr>
<tr><td><code id="glag_+3A_pad">pad</code></td>
<td>
<p>logical. If TRUE (default), then the lost entries are padded with pad.value. If FALSE, then no padding is undertaken</p>
</td></tr>
<tr><td><code id="glag_+3A_pad.value">pad.value</code></td>
<td>
<p>the pad-value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or matrix with the lagged values</p>


<h3>Note</h3>

<p>Empty</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lag">lag</a></code>, <code><a href="#topic+gdiff">gdiff</a></code>, <code><a href="base.html#topic+diff">diff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##lag series with NA for the missing entries:
x &lt;- rnorm(5)
glag(x)

##lag series with no padding:
x &lt;- rnorm(5)
glag(x, pad=FALSE)

##lag series and retain the original zoo-index ordering:
x &lt;- as.zoo(rnorm(5))
glag(x)

##lag two periods:
glag(x, k=2)

</code></pre>

<hr>
<h2 id='refit'>Refit a model to new data</h2><span id='topic+refit'></span><span id='topic+refit.garchx'></span>

<h3>Description</h3>

<p>Refit a model to new data, typically for cross-validation purposes. Re-estimation (<code>reestimate</code>) is optional (the default is <code>FALSE</code>).</p>


<h3>Usage</h3>

<pre><code class='language-R'>##generic:
refit(object, ...)

##S3 method for 'garchx' objects:
## S3 method for class 'garchx'
refit(object, newy = NULL, newxreg = NULL,
  backcast.value = NULL, reestimate = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="refit_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+garchx">garchx</a></code> </p>
</td></tr>
<tr><td><code id="refit_+3A_newy">newy</code></td>
<td>
<p>vector, the new 'y' data, see <code><a href="#topic+garchx">garchx</a></code> </p>
</td></tr>
<tr><td><code id="refit_+3A_newxreg">newxreg</code></td>
<td>
<p>the new 'xreg' data, if any, see <code><a href="#topic+garchx">garchx</a></code> </p>
</td></tr>
<tr><td><code id="refit_+3A_backcast.value">backcast.value</code></td>
<td>
<p><code>NULL</code> or a non-negative numeric, see <code><a href="#topic+garchx">garchx</a></code> </p>
</td></tr>
<tr><td><code id="refit_+3A_reestimate">reestimate</code></td>
<td>
<p>logical. If <code>FALSE</code> (default), then the estimates from <code>object</code> are used on the new data. If <code>TRUE</code>, then the model is re-estimated using the new data </p>
</td></tr>
<tr><td><code id="refit_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>refit.garchx</code> is a convenience function to facilitate cross-validation and related analyses. 
</p>


<h3>Value</h3>

<p>A list of class 'garchx'</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+garchx">garchx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##simulate from a garch(1,1):
set.seed(123)
y &lt;- garchxSim(1000)

##estimate garch(1,1) model:
mymod &lt;- garchx(y)

##new data (e.g. 'out-of-sample' or 'test' data):
yy &lt;- garchxSim(100)

##apply the estimates of 'mymod' on yy data:
refit(mymod, newy=yy)

</code></pre>

<hr>
<h2 id='rmnorm'>
Random number generation from the multivariate normal distribution
</h2><span id='topic+rmnorm'></span>

<h3>Description</h3>

<p>This function is a speed-optimised version of the <code><a href="#topic+rmnorm">rmnorm</a></code> function from the mnormt package of Adelchi Azzalini (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmnorm(n, mean = NULL, vcov = 1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmnorm_+3A_n">n</code></td>
<td>
<p>integer, the number of observations to generate</p>
</td></tr>
<tr><td><code id="rmnorm_+3A_mean">mean</code></td>
<td>
<p>numeric vector, i.e. the mean values</p>
</td></tr>
<tr><td><code id="rmnorm_+3A_vcov">vcov</code></td>
<td>
<p>numeric matrix, i.e. the variance-covariance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of n rows</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>References</h3>

<p>Adelchi Azzalini (2013): 'mnormt: The multivariate normal and t distributions', R package version 1.4-7, <a href="https://CRAN.R-project.org/package=mnormt">https://CRAN.R-project.org/package=mnormt</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##generate from univariate standardised normal:
z1 &lt;- rmnorm(100)

##generate from bivariate, independent standardised normal:
z2 &lt;- rmnorm(100, vcov=diag(c(1,1)))

##generate from bivariate, dependent standardised normal:
z3 &lt;- rmnorm(100, vcov=cbind(c(1,0.3),c(0.3,1)))
</code></pre>

<hr>
<h2 id='ttest0'>T-tests and Wald-tests under nullity</h2><span id='topic+ttest0'></span><span id='topic+waldtest0'></span>

<h3>Description</h3>

<p>The permissible parameter-space of GARCH-models is bounded from below by 0. This means non-standard inference is required when one or more parameters are 0 under the null hypothesis, a frequent situation in empirical applications. The functions <code>ttest0</code> and <code>waldtest0</code> perform t-tests and Wald-tests when one or more parameters is 0. In the latter test, the Wald-test, the critical values are obtained by simulation, see Francq and Thieu (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ttest0(x, k = NULL)
  waldtest0(x, r = 0, R = NULL, level = c(0.1,0.05,0.01),
    vcov.type = NULL, quantile.type = 7, n = 20000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ttest0_+3A_x">x</code></td>
<td>
<p>an object of class 'garchx'</p>
</td></tr>
<tr><td><code id="ttest0_+3A_k">k</code></td>
<td>
<p><code>NULL</code> (default) or a vector of integers with the coefficients to test. If <code>NULL</code>, then all coefficients apart from the intercepts are tested</p>
</td></tr>
<tr><td><code id="ttest0_+3A_r">r</code></td>
<td>
<p><code>vector</code> with restrictions</p>
</td></tr>
<tr><td><code id="ttest0_+3A_r">R</code></td>
<td>
<p><code>NULL</code> (default) or a full-rank <code>matrix</code>. If <code>NULL</code>, then <code>R</code> is specified such that a test of all coefficients - apart from the intercept - is equal to the restriction <code>r</code>. If <code>length(r)==1</code>, then it is recycled so that its dimension match that of <code>R</code> </p>
</td></tr>
<tr><td><code id="ttest0_+3A_level">level</code></td>
<td>
<p><code>vector</code> of significance levels whose critical values should be computed</p>
</td></tr>
<tr><td><code id="ttest0_+3A_vcov.type">vcov.type</code></td>
<td>
<p><code>NULL</code> or a <code>character</code> that determines the type of coefficient-covariance to use, see <code><a href="#topic+vcov.garchx">vcov.garchx</a></code> </p>
</td></tr>
<tr><td><code id="ttest0_+3A_quantile.type">quantile.type</code></td>
<td>
<p>integer, the algorithm used to compute the quantile, see <code><a href="stats.html#topic+quantile">quantile</a></code> </p>
</td></tr>
<tr><td><code id="ttest0_+3A_n">n</code></td>
<td>
<p><code>integer</code>, the numer of simulations used to estimate the critical values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ttest0</code> function performs a t-test of coefficient <code>k</code> with 0 as null. Under this null the parameter is on the boundary of the admissible parameter space, and so the distribution is non-standard under the null. The function <code>ttest0</code> returns the result(s) of these non-standard t-test(s), see Francq and Thieu (2018). If <code>k=NULL</code>, the default, then a test for each coefficient apart from the intercept is undertaken.
</p>
<p>The <code>waldtest0</code> function performs a Wald-test of the restrictions in <code>r</code>, when one or more of its elements are 0, see Francq and Thieu (2018).
</p>


<h3>Value</h3>

<table>
<tr><td><code>ttest0:</code></td>
<td>
<p>a <code>matrix</code> with the t-tests</p>
</td></tr>
<tr><td><code>waldtest0:</code></td>
<td>
<p>a <code>list</code> with the test-statistic and the critical values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a>
</p>


<h3>References</h3>

<p>Christian Francq and Le Quien Thieu (2018): 'QML inference for volatility models with covariates', Econometric Theory, doi:10.1017/S0266466617000512
</p>


<h3>See Also</h3>

<p><code><a href="#topic+garchx">garchx</a></code>, <code><a href="stats.html#topic+quantile">quantile</a></code>, <code><a href="#topic+vcov.garchx">vcov.garchx</a></code>, <code><a href="#topic+rmnorm">rmnorm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>##simulate and estimate a garch(1,1):
set.seed(123)
y &lt;- garchxSim(1000)
mymod &lt;- garchx(y)

##t-tests:
ttest0(mymod)

##wald-test:
waldtest0(mymod)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
