<!DOCTYPE html><html><head><title>Help for package GillespieSSA2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GillespieSSA2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compile_reactions'><p>Precompile the reactions</p></a></li>
<li><a href='#GillespieSSA2'><p><span class="pkg">GillespieSSA2</span>: Gillespie's Stochastic Simulation Algorithm for impatient people.</p></a></li>
<li><a href='#ode_em'><p>Euler-Maruyama method (EM)</p></a></li>
<li><a href='#plot_ssa'><p>Simple plotting of ssa output</p></a></li>
<li><a href='#port_reactions'><p>Port GillespieSSA parameters to GillespieSSA2</p></a></li>
<li><a href='#print.SSA_reaction'><p>Print various SSA objects</p></a></li>
<li><a href='#reaction'><p>Define a reaction</p></a></li>
<li><a href='#ssa'><p>Invoking the stochastic simulation algorithm</p></a></li>
<li><a href='#ssa_btl'><p>Binomial tau-leap method (BTL)</p></a></li>
<li><a href='#ssa_etl'><p>Explicit tau-leap method (ETL)</p></a></li>
<li><a href='#ssa_exact'><p>Exact method</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Gillespie's Stochastic Simulation Algorithm for Impatient People</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A fast, scalable, and versatile framework for
    simulating large systems with Gillespie's Stochastic Simulation
    Algorithm ('SSA').  This package is the spiritual successor to the
    'GillespieSSA' package originally written by Mario Pineda-Krch.
    Benefits of this package include major speed improvements (&gt;100x),
    easier to understand documentation, and many unit tests that try to
    ensure the package works as intended. Cannoodt and Saelens et al. (2021) 
    &lt;<a href="https://doi.org/10.1038%2Fs41467-021-24152-2">doi:10.1038/s41467-021-24152-2</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rcannood.github.io/GillespieSSA2/">https://rcannood.github.io/GillespieSSA2/</a>,
<a href="https://github.com/rcannood/GillespieSSA2">https://github.com/rcannood/GillespieSSA2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rcannood/GillespieSSA2/issues">https://github.com/rcannood/GillespieSSA2/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, dplyr, dynutils, Matrix, methods, purrr, Rcpp (&ge;
0.12.3), RcppXPtrUtils, readr, rlang, stringr, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, ggplot2, GillespieSSA, knitr, rmarkdown, testthat (&ge;
2.1.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-23 11:54:50 UTC; rcannood</td>
</tr>
<tr>
<td>Author:</td>
<td>Robrecht Cannoodt <a href="https://orcid.org/0000-0003-3641-729X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Wouter Saelens <a href="https://orcid.org/0000-0002-7114-6248"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robrecht Cannoodt &lt;rcannood@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-23 19:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='compile_reactions'>Precompile the reactions</h2><span id='topic+compile_reactions'></span>

<h3>Description</h3>

<p>By precompiling the reactions, you can run multiple SSA simulations repeatedly
without having to recompile the reactions every time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compile_reactions(
  reactions,
  state_ids,
  params,
  buffer_ids = NULL,
  hardcode_params = FALSE,
  fun_by = 10000L,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compile_reactions_+3A_reactions">reactions</code></td>
<td>
<p>'<a href="#topic+reaction">reaction</a>' A list of multiple <code><a href="#topic+reaction">reaction()</a></code> objects.</p>
</td></tr>
<tr><td><code id="compile_reactions_+3A_state_ids">state_ids</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> The names of the states in the correct order.</p>
</td></tr>
<tr><td><code id="compile_reactions_+3A_params">params</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[named numeric]&#8288;</code> Constants that are used in the propensity functions.</p>
</td></tr>
<tr><td><code id="compile_reactions_+3A_buffer_ids">buffer_ids</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> The order of any buffer calculations that are made as part of the propensity functions.</p>
</td></tr>
<tr><td><code id="compile_reactions_+3A_hardcode_params">hardcode_params</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical]&#8288;</code> Whether or not to hardcode the values of <code>params</code> in the compilation of the propensity functions.
Setting this to <code>TRUE</code> will result in a minor sacrifice in accuracy for a minor increase in performance.</p>
</td></tr>
<tr><td><code id="compile_reactions_+3A_fun_by">fun_by</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code> Combine this number of propensity functions into one function.</p>
</td></tr>
<tr><td><code id="compile_reactions_+3A_debug">debug</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical]&#8288;</code> Whether to print the resulting C++ code before compiling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects solely to be used by <code><a href="#topic+ssa">ssa()</a></code>.
</p>

<ul>
<li> <p><code>x[["state_change"]]</code>: A sparse matrix of reaction effects.
</p>
</li>
<li> <p><code>x[["reaction_ids"]]</code>: The names of the reactions.
</p>
</li>
<li> <p><code>x[["buffer_ids"]]</code>: A set of buffer variables found in the propensity functions.
</p>
</li>
<li> <p><code>x[["buffer_size"]]</code>: The minimum size of the buffer required.
</p>
</li>
<li> <p><code>x[["function_pointers"]]</code>: A list of compiled propensity functions.
</p>
</li>
<li> <p><code>x[["hardcode_params"]]</code>: Whether the parameters were hard coded into the source code.'
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
initial_state &lt;- c(prey = 1000, predators = 1000)
params &lt;- c(c1 = 10, c2 = 0.01, c3 = 10)
reactions &lt;- list(
  #        propensity function     effects                       name for reaction
  reaction(~c1 * prey,             c(prey = +1),                 "prey_up"),
  reaction(~c2 * prey * predators, c(prey = -1, predators = +1), "predation"),
  reaction(~c3 * predators,        c(predators = -1),            "pred_down")
)

compiled_reactions &lt;- compile_reactions(
  reactions = reactions,
  state_ids = names(initial_state),
  params = params
)

out &lt;-
  ssa(
    initial_state = initial_state,
    reactions = compiled_reactions,
    params = params,
    method = ssa_exact(),
    final_time = 5,
    census_interval = .001,
    verbose = TRUE
  )

plot_ssa(out)


</code></pre>

<hr>
<h2 id='GillespieSSA2'><span class="pkg">GillespieSSA2</span>: Gillespie's Stochastic Simulation Algorithm for impatient people.</h2><span id='topic+GillespieSSA2'></span><span id='topic+GillespieSSA2-package'></span>

<h3>Description</h3>

<p><span class="pkg">GillespieSSA2</span> is a fast, scalable, and versatile framework for simulating large systems with
Gillespie's Stochastic Simulation Algorithm (<abbr><span class="acronym">SSA</span></abbr>). This package is the spiritual successor to
the <span class="pkg">GillespieSSA</span> package originally written by Mario Pineda-Krch.
</p>


<h3>Details</h3>

<p>GillespieSSA2 has the following added benefits:
</p>

<ul>
<li><p> The whole algorithm is run in Rcpp which results in major speed improvements (&gt;100x).
Even your propensity functions (reactions) are being compiled to Rcpp!
</p>
</li>
<li><p> Parameters and variables have been renamed to make them easier to understand.
</p>
</li>
<li><p> Many unit tests try to ensure that the code works as intended.
</p>
</li></ul>

<p>The SSA methods currently implemented are: Exact (<code><a href="#topic+ssa_exact">ssa_exact()</a></code>), Explicit tau-leaping (<code><a href="#topic+ssa_etl">ssa_etl()</a></code>),
and the Binomial tau-leaping (<code><a href="#topic+ssa_btl">ssa_btl()</a></code>).
</p>


<h3>The stochastic simulation algorithm</h3>

<p>The stochastic simulation algorithm (<abbr><span class="acronym">SSA</span></abbr>) is a procedure for constructing
simulated trajectories of finite populations in continuous time.
If <code class="reqn">X_i(t)</code> is the number of individuals in population <code class="reqn">i</code>
(<code class="reqn">i = 1,\ldots,N</code>) at time <code class="reqn">t</code>,
the <abbr><span class="acronym">SSA</span></abbr> estimates the state vector
<code class="reqn"> \mathbf{X}(t) \equiv (X_1(t),\ldots,X_N(t)) </code>,
given that the system initially (at time <code class="reqn">t_0</code>)
was in state <code class="reqn">\mathbf{X}(t_0) = \mathbf{x_0}</code>.
</p>
<p>Reactions are single instantaneous events changing at least one of the populations (e.g.
birth, death, movement, collision, predation, infection, etc).
These cause the state of the system to change over time.
</p>
<p>The <abbr><span class="acronym">SSA</span></abbr> procedure samples the time <code class="reqn">\tau</code>
to the next reaction <code class="reqn">R_j</code> (<code class="reqn">j = 1,\ldots,M</code>)
and updates the system state <code class="reqn">\mathbf{X}(t)</code> accordingly.
</p>
<p>Each reaction <code class="reqn">R_j</code> is characterized mathematically by two quantities;
its state-change vector <code class="reqn">\bm{\nu_j}</code> and its propensity function <code class="reqn">a_j(\mathbf{x})</code>.
The state-change vector is defined as <code class="reqn">\bm{\nu}_j \equiv ( \nu_{1j},\ldots,\nu_{Nj} )</code>,
where <code class="reqn"> \nu_{ij} </code> is the change in the number of individuals in
population <code class="reqn">i</code> caused by one reaction of type <code class="reqn">j</code>.
The propensity function is defined as <code class="reqn">a_j(\mathbf{x})</code>, where
<code class="reqn">a_j(\mathbf{x})dt</code> is the probability that a particular
reaction <code class="reqn">j</code> will occur in the next infinitesimal time interval
<code class="reqn">\left[t,t+dt\right]</code>.
</p>


<h3>Contents of this package</h3>


<ul>
<li> <p><code><a href="#topic+ssa">ssa()</a></code>: The main entry point for running an <abbr><span class="acronym">SSA</span></abbr> simulation.
</p>
</li>
<li> <p><code><a href="#topic+plot_ssa">plot_ssa()</a></code>: A standard visualisation for generating an overview plot fo the output.
</p>
</li>
<li> <p><code><a href="#topic+ssa_exact">ssa_exact()</a></code>, <code><a href="#topic+ssa_etl">ssa_etl()</a></code>, <code><a href="#topic+ssa_btl">ssa_btl()</a></code>: Different <abbr><span class="acronym">SSA</span></abbr> algorithms.
</p>
</li>
<li> <p><code><a href="#topic+ode_em">ode_em()</a></code>: An <abbr><span class="acronym">ODE</span></abbr> algorithm.
</p>
</li>
<li> <p><code><a href="#topic+compile_reactions">compile_reactions()</a></code>: A function for precompiling the reactions.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ssa">ssa()</a></code> for more explanation on how to use <span class="pkg">GillespieSSA2</span>
</p>

<hr>
<h2 id='ode_em'>Euler-Maruyama method (EM)</h2><span id='topic+ode_em'></span>

<h3>Description</h3>

<p>Euler-Maruyama method implementation of the <abbr><span class="acronym">ODE</span></abbr>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ode_em(tau = 0.01, noise_strength = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ode_em_+3A_tau">tau</code></td>
<td>
<p>tau parameter</p>
</td></tr>
<tr><td><code id="ode_em_+3A_noise_strength">noise_strength</code></td>
<td>
<p>noise_strength parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of to be used by <code><a href="#topic+ssa">ssa()</a></code>.
</p>

<hr>
<h2 id='plot_ssa'>Simple plotting of ssa output</h2><span id='topic+plot_ssa'></span>

<h3>Description</h3>

<p>Provides basic functionally for simple and quick time series plot of simulation output from <code><a href="#topic+ssa">ssa()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ssa(
  ssa_out,
  state = TRUE,
  propensity = FALSE,
  buffer = FALSE,
  firings = FALSE,
  geom = c("point", "step")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_ssa_+3A_ssa_out">ssa_out</code></td>
<td>
<p>Data object returned by <code><a href="#topic+ssa">ssa()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_ssa_+3A_state">state</code></td>
<td>
<p>Whether or not to plot the state values.</p>
</td></tr>
<tr><td><code id="plot_ssa_+3A_propensity">propensity</code></td>
<td>
<p>Whether or not to plot the propensity values.</p>
</td></tr>
<tr><td><code id="plot_ssa_+3A_buffer">buffer</code></td>
<td>
<p>Whether or not to plot the buffer values.</p>
</td></tr>
<tr><td><code id="plot_ssa_+3A_firings">firings</code></td>
<td>
<p>Whether or not to plot the reaction firings values.</p>
</td></tr>
<tr><td><code id="plot_ssa_+3A_geom">geom</code></td>
<td>
<p>Which geom to use, must be one of <code>"point"</code>, <code>"step"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='port_reactions'>Port GillespieSSA parameters to GillespieSSA2</h2><span id='topic+port_reactions'></span>

<h3>Description</h3>

<p>This is a helper function to tranform GillesieSSA-style
paramters to GillespieSSA2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>port_reactions(x0, a, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="port_reactions_+3A_x0">x0</code></td>
<td>
<p>The <code>x0</code> parameter of <code><a href="GillespieSSA.html#topic+ssa">GillespieSSA::ssa()</a></code>.</p>
</td></tr>
<tr><td><code id="port_reactions_+3A_a">a</code></td>
<td>
<p>The <code>a</code> parameter of <code><a href="GillespieSSA.html#topic+ssa">GillespieSSA::ssa()</a></code>.</p>
</td></tr>
<tr><td><code id="port_reactions_+3A_nu">nu</code></td>
<td>
<p>The <code>nu</code> parameter of <code><a href="GillespieSSA.html#topic+ssa">GillespieSSA::ssa()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A set of <code><a href="#topic+reaction">reaction()</a></code>s to be used by <code><a href="#topic+ssa">ssa()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x0  &lt;- c(Y1 = 1000, Y2 = 1000)
a   &lt;- c("c1*Y1","c2*Y1*Y2","c3*Y2")
nu  &lt;- matrix(c(+1,-1,0,0,+1,-1),nrow=2,byrow=TRUE)
port_reactions(x0, a, nu)
</code></pre>

<hr>
<h2 id='print.SSA_reaction'>Print various SSA objects</h2><span id='topic+print.SSA_reaction'></span><span id='topic+print.SSA_method'></span>

<h3>Description</h3>

<p>Print various SSA objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SSA_reaction'
print(x, ...)

## S3 method for class 'SSA_method'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.SSA_reaction_+3A_x">x</code></td>
<td>
<p>An SSA reaction or SSA method</p>
</td></tr>
<tr><td><code id="print.SSA_reaction_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>

<hr>
<h2 id='reaction'>Define a reaction</h2><span id='topic+reaction'></span>

<h3>Description</h3>

<p>During an SSA simulation, at any infinitesimal time interval,
a reaction will occur with a probability defined according to its
propensity. If it does, then it will change the state vector according
to its effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reaction(propensity, effect, name = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reaction_+3A_propensity">propensity</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character/formula]&#8288;</code> A character or formula representation of the propensity function, written in C++.</p>
</td></tr>
<tr><td><code id="reaction_+3A_effect">effect</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[named integer vector]&#8288;</code> The change in state caused by this reaction.</p>
</td></tr>
<tr><td><code id="reaction_+3A_name">name</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> A name for this reaction (Optional). May only contain characters matching <code style="white-space: pre;">&#8288;[A-Za-z0-9_]&#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible to use 'buffer' values in order to speed up the computation
of the propensity functions. For instance, instead of <code>"(c3 * s1) / (1 + c3 * c1)"</code>,
it is possible to write <code>"buf = c3 * s1; buf / (buf + 1)"</code> instead.
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;[SSA_reaction]&#8288;</code> This object describes a single reaction as part of an SSA simulation. It contains the following member values:
</p>

<ul>
<li> <p><code>r[["propensity"]]</code>: The propensity function as a character.
</p>
</li>
<li> <p><code>r[["effect"]]</code>: The change in state caused by this reaction.
</p>
</li>
<li> <p><code>r[["name"]]</code>: The name of the reaction, <code>NA_character_</code> if no name was provided.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#        propensity                        effect
reaction(~ c1 * s1,                          c(s1 = -1))
reaction("c2 * s1 * s1",                     c(s1 = -2, s2 = +1))
reaction("buf = c3 * s1; buf / (buf + 1)",   c(s1 = +2))
</code></pre>

<hr>
<h2 id='ssa'>Invoking the stochastic simulation algorithm</h2><span id='topic+ssa'></span>

<h3>Description</h3>

<p>Main interface function to the implemented <abbr><span class="acronym">SSA</span></abbr> methods. Runs a
single realization of a predefined system. For a detailed explanation
on how to set up your first <abbr><span class="acronym">SSA</span></abbr> system, check the introduction
vignette: <code>vignette("an_introduction", package = "GillespieSSA2")</code>.
If you're transitioning from <span class="pkg">GillespieSSA</span> to <span class="pkg">GillespieSSA2</span>,
check out the corresponding vignette:
<code>vignette("converting_from_GillespieSSA", package = "GillespieSSA2")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssa(
  initial_state,
  reactions,
  final_time,
  params = NULL,
  method = ssa_exact(),
  census_interval = 0,
  stop_on_neg_state = TRUE,
  max_walltime = Inf,
  log_propensity = FALSE,
  log_firings = FALSE,
  log_buffer = FALSE,
  verbose = FALSE,
  console_interval = 1,
  sim_name = NA_character_,
  return_simulator = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssa_+3A_initial_state">initial_state</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[named numeric vector]&#8288;</code> The initial state to start the simulation with.</p>
</td></tr>
<tr><td><code id="ssa_+3A_reactions">reactions</code></td>
<td>
<p>A list of reactions, see <code><a href="#topic+reaction">reaction()</a></code>.</p>
</td></tr>
<tr><td><code id="ssa_+3A_final_time">final_time</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> The final simulation time.</p>
</td></tr>
<tr><td><code id="ssa_+3A_params">params</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[named numeric vector]&#8288;</code> Constant parameters to be used in the propensity functions.</p>
</td></tr>
<tr><td><code id="ssa_+3A_method">method</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[ssa_method]&#8288;</code>] Which SSA algorithm to use. Must be one of: <code><a href="#topic+ssa_exact">ssa_exact()</a></code>,
<code><a href="#topic+ssa_btl">ssa_btl()</a></code>, or <code><a href="#topic+ssa_etl">ssa_etl()</a></code>.</p>
</td></tr>
<tr><td><code id="ssa_+3A_census_interval">census_interval</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> The approximate interval between recording the state of the system.
Setting this parameter to <code>0</code> will cause each state to be recorded, and
to <code>Inf</code> will cause only the end state to be recorded.</p>
</td></tr>
<tr><td><code id="ssa_+3A_stop_on_neg_state">stop_on_neg_state</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical]&#8288;</code> Whether or not to stop the simulation when
the a negative value in the state has occured. This can occur, for instance, in the <code><a href="#topic+ssa_etl">ssa_etl()</a></code>
method.</p>
</td></tr>
<tr><td><code id="ssa_+3A_max_walltime">max_walltime</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> The maximum duration (in seconds) that the
simulation is allowed to run for before terminated.</p>
</td></tr>
<tr><td><code id="ssa_+3A_log_propensity">log_propensity</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical]&#8288;</code> Whether or not to store the propensity values at each census.</p>
</td></tr>
<tr><td><code id="ssa_+3A_log_firings">log_firings</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical]&#8288;</code> Whether or not to store number of firings of each reaction between censuses.</p>
</td></tr>
<tr><td><code id="ssa_+3A_log_buffer">log_buffer</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical]&#8288;</code> Whether or not to store the buffer at each census.</p>
</td></tr>
<tr><td><code id="ssa_+3A_verbose">verbose</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical]&#8288;</code> If <code>TRUE</code>, intermediary information pertaining to the simulation will be displayed.</p>
</td></tr>
<tr><td><code id="ssa_+3A_console_interval">console_interval</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> The approximate interval between intermediary information outputs.</p>
</td></tr>
<tr><td><code id="ssa_+3A_sim_name">sim_name</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> An optional name for the simulation.</p>
</td></tr>
<tr><td><code id="ssa_+3A_return_simulator">return_simulator</code></td>
<td>
<p>Whether to return the simulator itself, instead of the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Substantial improvements in speed and accuracy can be obtained by
adjusting the additional (and optional) <code>ssa</code> arguments. By default
<code>ssa</code> uses conservative parameters (o.a. <code><a href="#topic+ssa_exact">ssa_exact()</a></code>) which prioritise
computational accuracy over computational speed.
</p>
<p>Approximate methods (<code><a href="#topic+ssa_etl">ssa_etl()</a></code> and <code><a href="#topic+ssa_btl">ssa_btl()</a></code>) are not fool proof!
Some tweaking might be required for a stochastic model to run appropriately.
</p>


<h3>Value</h3>

<p>Returns a list containing the output of the simulation:
</p>

<ul>
<li> <p><code>out[["time"]]</code>: <code style="white-space: pre;">&#8288;[numeric]&#8288;</code> The simulation time at which a census was performed.
</p>
</li>
<li> <p><code>out[["state"]]</code>: <code style="white-space: pre;">&#8288;[numeric matrix]&#8288;</code> The number of individuals at those time points.
</p>
</li>
<li> <p><code>out[["propensity"]]</code>: <code style="white-space: pre;">&#8288;[numeric matrix]&#8288;</code> If <code>log_propensity</code> is <code>TRUE</code>, the propensity value of each reaction at each time point.
</p>
</li>
<li> <p><code>out[["firings"]]</code>: <code style="white-space: pre;">&#8288;[numeric matrix]&#8288;</code> If <code>log_firings</code> is <code>TRUE</code>, the number of firings between two time points.
</p>
</li>
<li> <p><code>out[["buffer"]]</code>: <code style="white-space: pre;">&#8288;[numeric matrix]&#8288;</code> If <code>log_buffer</code> is <code>TRUE</code>, the buffer values at each time point.
</p>
</li>
<li> <p><code>out[["stats"]]</code>: <code style="white-space: pre;">&#8288;[data frame]&#8288;</code> Various stats:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;$method&#8288;</code>: The name of the SSA method used.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$sim_name&#8288;</code>: The name of the simulation, if provided.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$sim_time_exceeded&#8288;</code>: Whether the simulation stopped because the final simulation time was reached.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$all_zero_state&#8288;</code>: Whether an extinction has occurred.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$negative_state&#8288;</code>: Whether a negative state has occurred. If an SSA method other than <code>ssa_etl()</code> is used, this indicates a mistake in the provided reaction effects.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$all_zero_propensity&#8288;</code>: Whether the simulation stopped because all propensity values are zero.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$negative_propensity&#8288;</code>: Whether a negative propensity value has occurred. If so, there is likely a mistake in the provided reaction propensity functions.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$walltime_exceeded&#8288;</code>: Whether the simulation stopped because the maximum execution time has been reached.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$walltime_elapsed&#8288;</code>: The duration of the simulation.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$num_steps&#8288;</code>: The number of steps performed.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$dtime_mean&#8288;</code>: The mean time increment per step.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$dtime_sd&#8288;</code>: THe standard deviation of time increments.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$firings_mean&#8288;</code>: The mean number of firings per step.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$firings_sd&#8288;</code>: The standard deviation of the number of firings.
</p>
</li></ul>

</li></ul>



<h3>See Also</h3>

<p><a href="#topic+GillespieSSA2">GillespieSSA2</a> for a high level explanation of the package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
initial_state &lt;- c(prey = 1000, predators = 1000)
params &lt;- c(c1 = 10, c2 = 0.01, c3 = 10)
reactions &lt;- list(
  #        propensity function     effects                       name for reaction
  reaction(~c1 * prey,             c(prey = +1),                 "prey_up"),
  reaction(~c2 * prey * predators, c(prey = -1, predators = +1), "predation"),
  reaction(~c3 * predators,        c(predators = -1),            "pred_down")
)

out &lt;-
  ssa(
    initial_state = initial_state,
    reactions = reactions,
    params = params,
    method = ssa_exact(),
    final_time = 5,
    census_interval = .001,
    verbose = TRUE
  )

plot_ssa(out)


</code></pre>

<hr>
<h2 id='ssa_btl'>Binomial tau-leap method (BTL)</h2><span id='topic+ssa_btl'></span>

<h3>Description</h3>

<p>Binomial tau-leap method implementation of the <abbr><span class="acronym">SSA</span></abbr> as described by Chatterjee et al. (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssa_btl(mean_firings = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssa_btl_+3A_mean_firings">mean_firings</code></td>
<td>
<p>A coarse-graining factor of how many firings will occur at each iteration on average.
Depending on the propensity functions, a value for <code>mean_firings</code> will result in warnings generated
and a loss of accuracy.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of to be used by <code><a href="#topic+ssa">ssa()</a></code>.
</p>


<h3>References</h3>

<p>Chatterjee A., Vlachos D.G., and Katsoulakis M.A. 2005. Binomial distribution based tau-leap accelerated stochastic simulation. J. Chem. Phys. 122:024112. doi: <a href="https://doi.org/10.1063/1.1833357">10.1063/1.1833357</a>.
</p>

<hr>
<h2 id='ssa_etl'>Explicit tau-leap method (ETL)</h2><span id='topic+ssa_etl'></span>

<h3>Description</h3>

<p>Explicit tau-leap method implementation of the <abbr><span class="acronym">SSA</span></abbr> as described by Gillespie (2001).
Note that this method does not attempt to select an appropriate value for tau, nor does it
implement estimated-midpoint technique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssa_etl(tau = 0.3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssa_etl_+3A_tau">tau</code></td>
<td>
<p>the step-size (default 0.3).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of to be used by <code><a href="#topic+ssa">ssa()</a></code>.
</p>


<h3>References</h3>

<p>Gillespie D.T. 2001. Approximate accelerated stochastic simulation of chemically reacting systems. J. Chem. Phys. 115:1716-1733. doi: <a href="https://doi.org/10.1063/1.1378322">10.1063/1.1378322</a>.
</p>

<hr>
<h2 id='ssa_exact'>Exact method</h2><span id='topic+ssa_exact'></span>

<h3>Description</h3>

<p>Exact method implementation of the <abbr><span class="acronym">SSA</span></abbr> as described by Gillespie (1977).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssa_exact()
</code></pre>


<h3>Value</h3>

<p>an object of to be used by <code><a href="#topic+ssa">ssa()</a></code>.
</p>


<h3>References</h3>

<p>Gillespie D.T. 1977. Exact stochastic simulation of coupled chemical reactions. J. Phys. Chem. 81:2340. doi: <a href="https://doi.org/10.1021/j100540a008">10.1021/j100540a008</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
