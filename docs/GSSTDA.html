<!DOCTYPE html><html><head><title>Help for package GSSTDA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GSSTDA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#case_tag'><p>Case-control vector</p></a></li>
<li><a href='#check_arg_mapper'><p>check_arg_mapper</p></a></li>
<li><a href='#check_filter_values'><p>check_filter_values</p></a></li>
<li><a href='#check_full_data'><p>check_full_data</p></a></li>
<li><a href='#check_gene_selection'><p>check_gene_selection</p></a></li>
<li><a href='#check_vectors'><p>check_vectors</p></a></li>
<li><a href='#clust_all_levels'><p>Get clusters for all data level</p></a></li>
<li><a href='#clust_lev'><p>Get clusters for a particular data level</p></a></li>
<li><a href='#compute_node_adjacency'><p>Computes the adjacency matrix.</p></a></li>
<li><a href='#cox_all_genes'><p>Survival analysis based on gene expression levels.</p></a></li>
<li><a href='#denoise_rectangular_matrix'><p>Rectangular Matrix Denoiser.</p></a></li>
<li><a href='#DGSA'><p>Disease-Specific Genomic Analysis</p></a></li>
<li><a href='#flatten_normal_tiss'><p>Flatten normal tissues</p></a></li>
<li><a href='#full_data'><p>Gene expression matrix</p></a></li>
<li><a href='#fun_to_int'><p>Marcenko-Pastur distribution to integrate.</p></a></li>
<li><a href='#gene_selection'><p>gene_selection</p></a></li>
<li><a href='#gene_selection_surv'><p>Gene selection based on variability and the relationship</p>
to survival.</a></li>
<li><a href='#generate_disease_component'><p>Generate disease component matrix.</p></a></li>
<li><a href='#geneSelection'><p>Gene selection and filter function</p></a></li>
<li><a href='#geneSelection.default'><p>gene_selection_classes.default</p></a></li>
<li><a href='#geneSelection.DGSA_object'><p>gene_selection_classes.DGSA_object</p></a></li>
<li><a href='#get_intervals_One_D'><p>Extract intervals from filter function output values.</p></a></li>
<li><a href='#get_lambda'><p>Computes lambda</p></a></li>
<li><a href='#get_mu_beta'><p>Get mu sub beta</p></a></li>
<li><a href='#get_omega'><p>Compute the omega value</p></a></li>
<li><a href='#GSSTDA'><p>Gene Structure Survival using Topological Data Analysis (GSSTDA).</p></a></li>
<li><a href='#levels_to_nodes'><p>Extract Information about Nodes</p></a></li>
<li><a href='#lp_norm_k_powers_surv'><p>Filtering function</p></a></li>
<li><a href='#map_to_color'><p>Map to color</p></a></li>
<li><a href='#mapper'><p>Mapper object</p></a></li>
<li><a href='#one_D_Mapper'><p>one_D_Mapper</p></a></li>
<li><a href='#plot_DGSA'><p>plot DGSA</p></a></li>
<li><a href='#plot_mapper'><p>Plot mapper</p></a></li>
<li><a href='#results_DGSA'><p>results DGSA</p></a></li>
<li><a href='#samples_in_levels'><p>Samples in levels</p></a></li>
<li><a href='#survival_event'><p>Survival event vector</p></a></li>
<li><a href='#survival_time'><p>Survival time vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Gene Structure Survival using Topological Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Mapper-based survival analysis with transcriptomics data is designed to carry out. 
			Mapper-based survival analysis is a modification of Progression Analysis of Disease (PAD) 
			where survival data is taken into account in the filtering function. More 
			details in: J. Fores-Martos, B. Suay-Garcia, R. Bosch-Romeu, M.C. Sanfeliu-Alonso, 
			A. Falco, J. Climent, "Progression Analysis of Disease with Survival (PAD-S) by SurvMap 
			identifies different prognostic subgroups of breast cancer in a large combined set of transcriptomics
			and methylation studies" &lt;<a href="https://doi.org/10.1101%2F2022.09.08.507080">doi:10.1101/2022.09.08.507080</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>DependsNote:</td>
<td>BioC (&gt;= 3.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>base, cluster, stats, survival, utils, visNetwork,
ComplexHeatmap, circlize, devtools</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>SuggestsNote:</td>
<td>BioC (&gt;= 3.0), Recommended: affy, oligoClasses, oligo,
GEOquery, DupChecker, arrayQualityMetrics, vctrs, frma,
a4Preproc, genefu, plyr, preprocessCore, hgu133plus2.db</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-06 12:55:15 UTC; Miriam_Esteve</td>
</tr>
<tr>
<td>Author:</td>
<td>Miriam Esteve <a href="https://orcid.org/0000-0002-5908-0581"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Raquel Bosch [aut],
  Jaume Forés <a href="https://orcid.org/0000-0002-9025-4877"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Joan Climent [aut],
  Antonio Falco [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Miriam Esteve &lt;miriam.estevecampello@uchceu.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-07 13:20:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='case_tag'>Case-control vector</h2><span id='topic+case_tag'></span>

<h3>Description</h3>

<p>Character vector of length 121 containing the group to which each
sample belongs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(case_tag, package = "GSSTDA")
</code></pre>


<h3>Format</h3>

<p>Character vector length 121.
</p>
<p>&quot;NT&quot;: control, sample from healthy tissue;
&quot;T&quot;: case, sample from neoplastic tissue.

</p>


<h3>Source</h3>

<p>The data are from the study GSE42568. Information extracted from
the file GSE42568_family.soft.gz available at
<a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE42568">https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE42568</a>.
</p>

<hr>
<h2 id='check_arg_mapper'>check_arg_mapper</h2><span id='topic+check_arg_mapper'></span>

<h3>Description</h3>

<p>Checking the arguments introduces in the <code>mapper</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_arg_mapper(
  full_data,
  filter_values,
  distance_type,
  clustering_type,
  linkage_type,
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_arg_mapper_+3A_full_data">full_data</code></td>
<td>
<p>Matrix with the columns of the input matrix
corresponding to the individuals belonging to the level.</p>
</td></tr>
<tr><td><code id="check_arg_mapper_+3A_filter_values">filter_values</code></td>
<td>
<p>Vector obtained after applying the filtering function
to the input matrix, i.e, a vector with the filtering function
values for each included sample.</p>
</td></tr>
<tr><td><code id="check_arg_mapper_+3A_distance_type">distance_type</code></td>
<td>
<p>Type of distance to be used for clustering.
Choose between correlation (&quot;cor&quot;) and euclidean (&quot;euclidean&quot;). &quot;cor&quot;
default option.</p>
</td></tr>
<tr><td><code id="check_arg_mapper_+3A_clustering_type">clustering_type</code></td>
<td>
<p>Type of clustering method. Choose between
&quot;hierarchical&quot; and &quot;PAM&quot; (“partition around medoids”) options.
&quot;hierarchical&quot; default option.</p>
</td></tr>
<tr><td><code id="check_arg_mapper_+3A_linkage_type">linkage_type</code></td>
<td>
<p>Linkage criteria used in hierarchical clustering.
Choose between &quot;single&quot; for single-linkage clustering, &quot;complete&quot; for
complete-linkage clustering or &quot;average&quot; for average linkage clustering
(or UPGMA). Only necessary for hierarchical clustering.
&quot;single&quot; default option.</p>
</td></tr>
<tr><td><code id="check_arg_mapper_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.
If <code>FALSE</code>, an error occurs in case of <code>NA</code> rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>optimal_clustering_mode</code>
</p>

<hr>
<h2 id='check_filter_values'>check_filter_values</h2><span id='topic+check_filter_values'></span>

<h3>Description</h3>

<p>Checking the filter_values introduces in the <code>mapper</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_filter_values(full_data, filter_values, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_filter_values_+3A_full_data">full_data</code></td>
<td>
<p>Matrix with the columns of the input matrix
corresponding to the individuals belonging to the level. This matrix could be the
genes_disease_component.</p>
</td></tr>
<tr><td><code id="check_filter_values_+3A_filter_values">filter_values</code></td>
<td>
<p>Vector obtained after applying the filtering function
to the input matrix, i.e, a vector with the filtering function
values for each included sample.</p>
</td></tr>
<tr><td><code id="check_filter_values_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.
If <code>FALSE</code>, an error occurs in case of <code>NA</code> rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>filter_value</code> and <code>full_data</code> without NAN's
</p>

<hr>
<h2 id='check_full_data'>check_full_data</h2><span id='topic+check_full_data'></span>

<h3>Description</h3>

<p>Checking the full_data introduces in the package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_full_data(full_data, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_full_data_+3A_full_data">full_data</code></td>
<td>
<p>Matrix with the columns of the input matrix
corresponding to the individuals belonging to the level.</p>
</td></tr>
<tr><td><code id="check_full_data_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.
If <code>FALSE</code>, an error occurs in case of <code>NA</code> rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return <code>full_data</code> without NAN's and as a matrix
</p>

<hr>
<h2 id='check_gene_selection'>check_gene_selection</h2><span id='topic+check_gene_selection'></span>

<h3>Description</h3>

<p>Checking the arguments introduces in the gene selection process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_gene_selection(num_genes, gen_select_type, percent_gen_select)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_gene_selection_+3A_num_genes">num_genes</code></td>
<td>
<p>Number of genes in the full_data</p>
</td></tr>
<tr><td><code id="check_gene_selection_+3A_gen_select_type">gen_select_type</code></td>
<td>
<p>Type of gene selection to be used. Choose between &quot;top_bot&quot; (top-botton)
and &quot;abs&quot; (absolute)</p>
</td></tr>
<tr><td><code id="check_gene_selection_+3A_percent_gen_select">percent_gen_select</code></td>
<td>
<p>Percentage of genes to be selected</p>
</td></tr>
</table>


<h3>Value</h3>

<p>num_gen_select Number of genes to be selected according to the percent_gen_select value
</p>

<hr>
<h2 id='check_vectors'>check_vectors</h2><span id='topic+check_vectors'></span>

<h3>Description</h3>

<p>Checking the <code>survival_time</code>, <code>survival_event</code> and <code>case_tag</code> introduces in the <code>GSSTDA</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_vectors(full_data, survival_time, survival_event, case_tag, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_vectors_+3A_full_data">full_data</code></td>
<td>
<p>The genes of the full_data (maybe remove by na.rm = TRUE)</p>
</td></tr>
<tr><td><code id="check_vectors_+3A_survival_time">survival_time</code></td>
<td>
<p>Time between disease diagnosis and death (if not dead until the end of follow-up).</p>
</td></tr>
<tr><td><code id="check_vectors_+3A_survival_event">survival_event</code></td>
<td>
<p><code>logical</code>. Whether the patient has died or not.</p>
</td></tr>
<tr><td><code id="check_vectors_+3A_case_tag">case_tag</code></td>
<td>
<p>The tag of the healthy patient (healthy or not).</p>
</td></tr>
<tr><td><code id="check_vectors_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.
If <code>FALSE</code>, an error occurs in case of <code>NA</code> rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>control_tag Return the tag of the healthy patient
</p>

<hr>
<h2 id='clust_all_levels'>Get clusters for all data level</h2><span id='topic+clust_all_levels'></span>

<h3>Description</h3>

<p>It performs the clustering of the samples in each
of the levels. That is to say, in each interval of values of the
filtering function, the samples with a value within that interval
are clustered using the proposed clustering algorithm and the
proposed method to determine the optimal number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clust_all_levels(
  full_data,
  samp_in_lev,
  distance_type,
  clustering_type,
  linkage_type,
  optimal_clustering_mode,
  num_bins_when_clustering
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clust_all_levels_+3A_full_data">full_data</code></td>
<td>
<p>Input data matrix whose columns are the individuals
and rows are the features.BR cambiar nombre.</p>
</td></tr>
<tr><td><code id="clust_all_levels_+3A_samp_in_lev">samp_in_lev</code></td>
<td>
<p>A list of character vectors with the individuals
included in each of the levels (i.e. each of the intervals of the values
of the filter functions). It is the output of the <code>samples_in_levels</code>
function.</p>
</td></tr>
<tr><td><code id="clust_all_levels_+3A_distance_type">distance_type</code></td>
<td>
<p>Type of distance to be used for clustering.
Choose between correlation (&quot;cor&quot;) and euclidean (&quot;euclidean&quot;).</p>
</td></tr>
<tr><td><code id="clust_all_levels_+3A_clustering_type">clustering_type</code></td>
<td>
<p>Type of clustering method. Choose between
&quot;hierarchical&quot; and &quot;PAM&quot; (“partition around medoids”) options.</p>
</td></tr>
<tr><td><code id="clust_all_levels_+3A_linkage_type">linkage_type</code></td>
<td>
<p>Linkage criteria used in hierarchical clustering.
Choose between &quot;single&quot; for single-linkage clustering, &quot;complete&quot; for
complete-linkage clustering or &quot;average&quot; for average linkage clustering
(or UPGMA). Only necessary for hierarchical clustering.</p>
</td></tr>
<tr><td><code id="clust_all_levels_+3A_optimal_clustering_mode">optimal_clustering_mode</code></td>
<td>
<p>Method for selection optimal number of
clusters. It is only necessary if the chosen type of algorithm is
hierarchical. In this case, choose between &quot;standard&quot; (the method used
in the original mapper article) or &quot;silhouette&quot;. In the case of the
PAM algorithm, the method will always be &quot;silhouette&quot;. &quot;silhouette&quot;</p>
</td></tr>
<tr><td><code id="clust_all_levels_+3A_num_bins_when_clustering">num_bins_when_clustering</code></td>
<td>
<p>Number of bins to generate the
histogram employed by the standard optimal number of cluster finder
method. Parameter not necessary if the &quot;optimal_clust_mode&quot; option
is &quot;silhouette&quot; or the &quot;clust_type&quot; is &quot;PAM&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of interger vectors. Each of the vectors contains information
about the nodes at each level and the individuals contained in them. The
names of the vector values are the names of the samples and the vector
values are the node number of that level to which the individual belongs.
</p>

<hr>
<h2 id='clust_lev'>Get clusters for a particular data level</h2><span id='topic+clust_lev'></span>

<h3>Description</h3>

<p>It performs clustering of the samples belonging to a particular level (to a
particular interval of the filter function) with the proposed clustering
algorithm and the proposed method to determine the optimal number
of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clust_lev(
  full_data_i,
  distance_type,
  clustering_type,
  linkage_type,
  optimal_clustering_mode,
  num_bins_when_clustering,
  level_name
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clust_lev_+3A_full_data_i">full_data_i</code></td>
<td>
<p>Matrix with the columns of the input matrix
corresponding to the individuals belonging to the level.</p>
</td></tr>
<tr><td><code id="clust_lev_+3A_distance_type">distance_type</code></td>
<td>
<p>Type of distance to be used for clustering.
Choose between correlation (&quot;cor&quot;) and euclidean (&quot;euclidean&quot;).</p>
</td></tr>
<tr><td><code id="clust_lev_+3A_clustering_type">clustering_type</code></td>
<td>
<p>Type of clustering method.
Choose between &quot;hierarchical&quot; and &quot;PAM&quot; (“partition around medoids”)
options.</p>
</td></tr>
<tr><td><code id="clust_lev_+3A_linkage_type">linkage_type</code></td>
<td>
<p>Linkage criteria used in hierarchical clustering.
Choose between &quot;single&quot; for single-linkage clustering, &quot;complete&quot; for
complete-linkage clustering or &quot;average&quot; for average linkage clustering
(or UPGMA). Only necessary for hierarchical clustering. The value provided
if the type of clustering chosen is hierarchical will be ignored</p>
</td></tr>
<tr><td><code id="clust_lev_+3A_optimal_clustering_mode">optimal_clustering_mode</code></td>
<td>
<p>Method for selection optimal number of
clusters. It is only necessary if the chosen type of algorithm is
hierarchical. In this case, choose between &quot;standard&quot; (the method used
in the original mapper article) or &quot;silhouette&quot;. In the case of the PAM
algorithm, the method will always be &quot;silhouette&quot;.</p>
</td></tr>
<tr><td><code id="clust_lev_+3A_num_bins_when_clustering">num_bins_when_clustering</code></td>
<td>
<p>Number of bins to generate the histogram
employed by the standard optimal number of cluster finder method.
Parameter not necessary if the &quot;optimal_clust_mode&quot; option is &quot;silhouette&quot;
or the &quot;clust_type&quot; is &quot;PAM&quot;.</p>
</td></tr>
<tr><td><code id="clust_lev_+3A_level_name">level_name</code></td>
<td>
<p>Name of the studied level. # ERROR No usado</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a interger vector with the samples included in each cluster
for the specific level analyzed. The names of the vector values are the
names of the samples and the vector values are the node number
to which the individual belongs.
</p>

<hr>
<h2 id='compute_node_adjacency'>Computes the adjacency matrix.</h2><span id='topic+compute_node_adjacency'></span>

<h3>Description</h3>

<p>It computes the adjacency matrix between nodes. Two nodes
are considered connected if they share at least one individual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_node_adjacency(nodes_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_node_adjacency_+3A_nodes_list">nodes_list</code></td>
<td>
<p>Output of the <code>levels_to_nodes</code> function. List of
character vectors. Each of the vectors contains the names of the
individuals at each node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a matrix of magnitude n nodes x n nodes that stores a
1 if there are shared samples in two given nodes and a 0 otherwise.
</p>

<hr>
<h2 id='cox_all_genes'>Survival analysis based on gene expression levels.</h2><span id='topic+cox_all_genes'></span>

<h3>Description</h3>

<p>It carries out univariate cox proportional hazard models for
the expression levels of each gene included in the provided dataset (case_disease_component)
and their link with relapse-free or overall survival.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cox_all_genes(case_disease_component, survival_time, survival_event)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cox_all_genes_+3A_case_disease_component">case_disease_component</code></td>
<td>
<p>Disease component matrix (output of the function
<code>generate_disease_component</code>) having selected only the columns
belonging to disease samples. The names of the rows must be the names of the genes.</p>
</td></tr>
<tr><td><code id="cox_all_genes_+3A_survival_time">survival_time</code></td>
<td>
<p>Numeric vector that includes time to the event information</p>
</td></tr>
<tr><td><code id="cox_all_genes_+3A_survival_event">survival_event</code></td>
<td>
<p>Numeric vector that indicates if relapse or death
have been produced (0 and 1s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the results of the application of proportional
hazard models using the expression levels of each gene as covariate.
The <code>coef</code> column corresponds to the regression coefficient; the
<code>exp_coef</code> column corresponds to the value of e^coef  (which is
interpreted as the odds ratio); the <code>se_coef</code> column corresponds
to the standard error of each coefficient; the <code>Z</code> column corresponds
to the value of coef/se_coef (the higher the Z value, the higher the
significance of the variable) and the <code>Pr_z</code> column corresponds to
the p-value for each Z value.
</p>

<hr>
<h2 id='denoise_rectangular_matrix'>Rectangular Matrix Denoiser.</h2><span id='topic+denoise_rectangular_matrix'></span>

<h3>Description</h3>

<p>It takes a rectangular matrix composed by the addition of
a signal matrix and a Gaussian noise matrix and returns a matrix of the same
dimension that is denoised through a Singular Value Decomposition
truncation process. The selection of the number of singular values is
chosen following the proposal by &quot;The optimal hard threshold
for singular values is <code class="reqn">\sqrt(4/ 3)</code>&quot;. It should be used after
the function <code>flatten_normal_tiss</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denoise_rectangular_matrix(matrix_flatten_normal_tiss)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="denoise_rectangular_matrix_+3A_matrix_flatten_normal_tiss">matrix_flatten_normal_tiss</code></td>
<td>
<p>A rectangular noisy matrix to denoise. It is return by
<code>flatten_normal_tiss</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A the normal space which has the same dimension denoised version of the matrix
returned by <code>flatten_normal_tiss</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
denoise_rectangular_matrix(matrix(c(1,2,3,4,5,2,3,1,2,3),ncol = 2))

</code></pre>

<hr>
<h2 id='DGSA'>Disease-Specific Genomic Analysis</h2><span id='topic+DGSA'></span>

<h3>Description</h3>

<p>Disease-Specific Genomic Analysis (DGSA).
This analysis, developed by Nicolau <em>et al.</em>, allows the calculation of
the &quot;disease component&quot; of a expression matrix which consists of, through
linear models, eliminating the part of the data  that is considered normal
or healthy and keeping only the component that is due to the disease. It
is intended to precede other techniques like classification or clustering.
For more information see <em>Disease-specific genomic analysis: identifying
the signature of pathologic biology</em> (doi: 10.1093/bioinformatics/btm033).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DGSA(full_data, survival_time, survival_event, case_tag, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DGSA_+3A_full_data">full_data</code></td>
<td>
<p>Input matrix whose columns correspond to the patients and
rows to the genes.</p>
</td></tr>
<tr><td><code id="DGSA_+3A_survival_time">survival_time</code></td>
<td>
<p>Numerical vector of the same length as the number of
columns of full_data. Patients must be in the same order as in full_data.
For the patients with tumour sample should be indicated the time between
disease diagnosis and death (if not dead until the end of follow-up)
and healthy patients must have an NA value.</p>
</td></tr>
<tr><td><code id="DGSA_+3A_survival_event">survival_event</code></td>
<td>
<p>Numerical vector of the same length as the number of
columns of full_data. Patients must be in the same order as in full_data.
For the patients with tumour sample should be indicated whether
the patient has died (1) or not (0). Only these values are valid
and healthy patients must have an NA value.</p>
</td></tr>
<tr><td><code id="DGSA_+3A_case_tag">case_tag</code></td>
<td>
<p>Character vector of the same length as the number of
columns of full_data. Patients must be in the same order as in full_data.
It must be indicated for each patient whether he/she is healthy or not.
One value should be used to indicate whether the patient is healthy and
another value should be used to indicate whether the patient's sample is
tumourous. The user will then be asked which one indicates whether
the patient is healthy. Only two values are valid in the vector in total.</p>
</td></tr>
<tr><td><code id="DGSA_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.
If <code>FALSE</code>, an error occurs in case of <code>NA</code> rows. TRUE default
option.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>DGSA</code> object. It contains: the <code>full_data</code> without NAN's
values, the <code>case_control</code> vector without NAN's values, the label
designated for healthy samples (<code>control_tag</code>), the matrix with the
normal space (linear space generated from normal tissue samples) and the
matrix of the disease components (the transformed full_data matrix from
which the normal component has been removed).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
DGSA_obj &lt;- DGSA(full_data,  survival_time, survival_event, case_tag)
</code></pre>

<hr>
<h2 id='flatten_normal_tiss'>Flatten normal tissues</h2><span id='topic+flatten_normal_tiss'></span>

<h3>Description</h3>

<p>Given a matrix containing the expression values of
<code>n</code> healthy tissue samples, it produces the flattened vector matrix
as reported in &quot;Disease-specific genomic analysis: identifying
the signature of pathology biology&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten_normal_tiss(normal_tiss)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten_normal_tiss_+3A_normal_tiss">normal_tiss</code></td>
<td>
<p>A normal tissue data gene expression matrix.
The columns should be the samples and the rows should be the genes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A gene expression matrix containing the flattened
version of the vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
normal_tissue_matrix &lt;- matrix(stats::rnorm(36), nrow=6)
flatten_normal_tiss(normal_tissue_matrix)

</code></pre>

<hr>
<h2 id='full_data'>Gene expression matrix</h2><span id='topic+full_data'></span>

<h3>Description</h3>

<p>Matrix containing gene expression profiling of 104 breast cancer and
17 normal breast biopsies. Expression profiling data by array
(platform HG-U133_Plus_2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(full_data, package = "GSSTDA")
</code></pre>


<h3>Format</h3>

<p>Gene expression matrix with  20825 rows and 121 columns.
</p>
<p>The columns correspond to the patients and the rows to
the genes. The column names correspond to the patient identifier
in GEO. The row names correspond to the gene names.

</p>


<h3>Details</h3>

<p>Normalized gene expression data GSE42568. Background correction,
summarization, and quantile normalization were carried out using the
fRMA method implemented in the <code>fRMA</code> package. Filtered probes that did
not target genes with valid gene id were filtered and  those probes
targeting the same gene were collapse by thanking those presenting the
highest row variance using the <code>WGCNA::collapseRows</code> function.
</p>


<h3>Source</h3>

<p>The data are from the study GSE42568 available in
<a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE42568">https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE42568</a>.
The data were processed as explained in the <code>details</code> section.
</p>

<hr>
<h2 id='fun_to_int'>Marcenko-Pastur distribution to integrate.</h2><span id='topic+fun_to_int'></span>

<h3>Description</h3>

<p>This function is an auxiliary function that includes
the Marcenco-Pastur function that has to be integrated to find the
upper bound of integration that produces and area of 1/2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun_to_int(t, bet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun_to_int_+3A_t">t</code></td>
<td>
<p>Parameter t.</p>
</td></tr>
<tr><td><code id="fun_to_int_+3A_bet">bet</code></td>
<td>
<p>Beta value. Aspect ratio of the input matrix,
<code class="reqn">\frac{m}{n}</code>, were m is the number of rows of the input
matrix and n the number of columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns the function value for a specific t and a particular
aspect ration m/n.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fun_to_int(1,0.3)
</code></pre>

<hr>
<h2 id='gene_selection'>gene_selection</h2><span id='topic+gene_selection'></span>

<h3>Description</h3>

<p>Private function to gene selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gene_selection(
  full_data,
  survival_time,
  survival_event,
  control_tag_cases,
  gen_select_type,
  num_gen_select
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gene_selection_+3A_full_data">full_data</code></td>
<td>
<p>Input matrix whose columns correspond to the patients and
rows to the genes.</p>
</td></tr>
<tr><td><code id="gene_selection_+3A_survival_time">survival_time</code></td>
<td>
<p>Numerical vector of the same length as the number of
columns of full_data. Patients must be in the same order as in full_data.
For the patients with tumour sample should be indicated the time between
disease diagnosis and death (if not dead until the end of follow-up)
and healthy patients must have an NA value.</p>
</td></tr>
<tr><td><code id="gene_selection_+3A_survival_event">survival_event</code></td>
<td>
<p>Numerical vector of the same length as the number of
columns of full_data. Patients must be in the same order as in full_data.
For the patients with tumour sample should be indicated whether
the patient has died (1) or not (0). Only these values are valid
and healthy patients must have an NA value.</p>
</td></tr>
<tr><td><code id="gene_selection_+3A_control_tag_cases">control_tag_cases</code></td>
<td>
<p>Character vector of the same length as the number of
columns of full_data. Patients must be in the same order as in full_data.
It must be indicated for each patient whether he/she is healthy or not.
One value should be used to indicate whether the patient is healthy and
another value should be used to indicate whether the patient's sample is
tumourous. The user will then be asked which one indicates whether
the patient is healthy. Only two values are valid in the vector in total.</p>
</td></tr>
<tr><td><code id="gene_selection_+3A_gen_select_type">gen_select_type</code></td>
<td>
<p>Option. Options on how to select the genes to be
used in the mapper. Select the &quot;Abs&quot; option, which means that the
genes with the highest absolute value are chosen, or the
&quot;Top_Bot&quot; option, which means that half of the selected
genes are those with the highest value (positive value, i.e.
worst survival prognosis) and the other half are those with the
lowest value (negative value, i.e. best prognosis). &quot;Top_Bot&quot; default option.</p>
</td></tr>
<tr><td><code id="gene_selection_+3A_num_gen_select">num_gen_select</code></td>
<td>
<p>Number of genes to be selected to be used in mapper.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>geneSelection_object</code>. It contains:
</p>

<ul>
<li><p> the <code>full_data</code> without NAN's values (<code>data</code>)
</p>
</li>
<li><p> the <code>cox_all_matrix</code> (a matrix with the results of the application of
proportional hazard models: with the regression coefficients, the odds ratios,
the standard errors of each coefficient, the Z values (coef/se_coef) and
the p-values for each Z value)
</p>
</li>
<li><p> a vector with the name of the selected genes
</p>
</li>
<li><p> the matrix of disease components with only the rows of the selected genes
(<code>genes_disease_component</code>)
</p>
</li>
<li><p> and the vector of the values of the filter function.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
gen_select_type &lt;- "Top_Bot"
percent_gen_select &lt;- 10
control_tag_cases &lt;- which(case_tag == "NT")
geneSelection_obj &lt;- gene_selection(full_data, survival_time, survival_event, control_tag_cases,
gen_select_type ="top_bot", num_gen_select = 10)
</code></pre>

<hr>
<h2 id='gene_selection_surv'>Gene selection based on variability and the relationship
to survival.</h2><span id='topic+gene_selection_surv'></span>

<h3>Description</h3>

<p>It selects genes for mapper based on the product of standard deviation
of the rows (genes) in the disease component matrix
plus one times the Z score obtained by fitting a cox proportional
hazard model to the level of each gene. For further information see
&quot;Topology based data analysis identifies a subgroup of breast cancers
with a unique mutational profile and excellent survival&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gene_selection_surv(
  case_disease_component,
  cox_all_matrix,
  gen_select_type,
  num_gen_select
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gene_selection_surv_+3A_case_disease_component">case_disease_component</code></td>
<td>
<p>Disease component matrix (output of the function
<code>generate_disease_component</code>) having selected only the columns
belonging to disease samples. The names of the rows must be the names of the genes.</p>
</td></tr>
<tr><td><code id="gene_selection_surv_+3A_cox_all_matrix">cox_all_matrix</code></td>
<td>
<p>Output from the <code>cox_all_genes</code> function. Data.frame with
information on the relationship between genes and survival.</p>
</td></tr>
<tr><td><code id="gene_selection_surv_+3A_gen_select_type">gen_select_type</code></td>
<td>
<p>Option. Select the &quot;Abs&quot; option, which means that the
genes with the highest absolute value are chosen, or the
&quot;Top_Bot&quot; option, which means that half of the selected
genes are those with the highest value (positive value, i.e.
worst survival prognosis) and the other half are those with the
lowest value (negative value, i.e. best prognosis).</p>
</td></tr>
<tr><td><code id="gene_selection_surv_+3A_num_gen_select">num_gen_select</code></td>
<td>
<p>Number of genes to be selected (those with the highest
product value).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with the names of the selected genes.
</p>

<hr>
<h2 id='generate_disease_component'>Generate disease component matrix.</h2><span id='topic+generate_disease_component'></span>

<h3>Description</h3>

<p>This function produces a disease component matrix
from an expression matrix and the denoised flattened matrix constructed
from &quot;healthy tissue data&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_disease_component(full_data, normal_space)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_disease_component_+3A_full_data">full_data</code></td>
<td>
<p>Input matrix whose columns correspond to the patients and
rows to the gens. Both tumour and healthy samples should be included.</p>
</td></tr>
<tr><td><code id="generate_disease_component_+3A_normal_space">normal_space</code></td>
<td>
<p>Denoised flattened matrix constructed from
&quot;healthy tissue data&quot;. Output of the function <code>denoise_rectangular_matrix</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Disease component matrix that contains the disease component
of the provided normal space
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
full_data &lt;- matrix(stats::rnorm(120),ncol=20)
normal_tissue &lt;- full_data[,11:20]
normal_tissue_f &lt;- flatten_normal_tiss(normal_tissue)
normal_tissue_f_d &lt;- denoise_rectangular_matrix(normal_tissue_f)
disease_component &lt;- generate_disease_component(full_data,normal_tissue_f_d)
</code></pre>

<hr>
<h2 id='geneSelection'>Gene selection and filter function</h2><span id='topic+geneSelection'></span>

<h3>Description</h3>

<p>Gene selection and calculation of filter function values.
After fitting a Cox proportional hazard model to each gene, this function
makes a selection of genes according to both their variability within
the database and their relationship with survival. Subsequently, with the
genes selected, the values of the filtering functions are calculated for
each patient. The filter function allows to summarise each vector of each
individual in a single data. This function takes into account the survival
associated with each gene. In particular, the implemented filter function
performs the vector magnitude in the [L_p] norm (as well as k powers
of this magnitude) of the vector resulting of weighting each element of
the column vector by the Z score obtained in the cox proportional
hazard model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geneSelection(data_object, gen_select_type, percent_gen_select, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geneSelection_+3A_data_object">data_object</code></td>
<td>
<p>Object with:
</p>

<ul>
<li><p> full_data Input matrix whose columns correspond to the patients and
rows to the genes.
</p>
</li>
<li><p> survival_time Numerical vector of the same length as the number of
columns of full_data. Patients must be in the same order as in full_data.
For the patients with tumour sample should be indicated the time between
disease diagnosis and death (if not dead until the end of follow-up)
and healthy patients must have an NA value.
</p>
</li>
<li><p> survival_event Numerical vector of the same length as the number of
columns of full_data. Patients must be in the same order as in full_data.
For the patients with tumour sample should be indicated whether
the patient has died (1) or not (0). Only these values are valid
and healthy patients must have an NA value.
</p>
</li>
<li><p> case_tag Character vector of the same length as the number of
columns of full_data. Patients must be in the same order as in full_data.
It must be indicated for each patient whether he/she is healthy or not.
One value should be used to indicate whether the patient is healthy and
another value should be used to indicate whether the patient's sample is
tumourous. The user will then be asked which one indicates whether
the patient is healthy. Only two values are valid in the vector in total.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geneSelection_+3A_gen_select_type">gen_select_type</code></td>
<td>
<p>Option. Options on how to select the genes to be
used in the mapper. Select the &quot;Abs&quot; option, which means that the
genes with the highest absolute value are chosen, or the
&quot;Top_Bot&quot; option, which means that half of the selected
genes are those with the highest value (positive value, i.e.
worst survival prognosis) and the other half are those with the
lowest value (negative value, i.e. best prognosis). &quot;Top_Bot&quot; default option.</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_percent_gen_select">percent_gen_select</code></td>
<td>
<p>Percentage (from zero to one hundred) of genes
to be selected to be used in mapper. 10 default option.</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.
If <code>FALSE</code>, an error occurs in case of <code>NA</code> rows. TRUE default
option.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>geneSelection_object</code>. It contains:
</p>

<ul>
<li><p> the <code>full_data</code> without NAN's values (<code>data</code>)
</p>
</li>
<li><p> the <code>cox_all_matrix</code> (a matrix with the results of the application of
proportional hazard models: with the regression coefficients, the odds ratios,
the standard errors of each coefficient, the Z values (coef/se_coef) and
the p-values for each Z value)
</p>
</li>
<li><p> a vector with the name of the selected genes
</p>
</li>
<li><p> the matrix of disease components with only the rows of the selected genes
(<code>genes_disease_component</code>)
</p>
</li>
<li><p> and the vector of the values of the filter function.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data_object &lt;- list("full_data" = full_data, "survival_time" = survival_time,
"survival_event" = survival_event, "case_tag" = case_tag)
class(data_object) &lt;- "data_object"
geneSelection_obj &lt;- geneSelection(data_object,
gen_select_type ="top_bot", percent_gen_select=10)
</code></pre>

<hr>
<h2 id='geneSelection.default'>gene_selection_classes.default</h2><span id='topic+geneSelection.default'></span>

<h3>Description</h3>

<p>Private function to select Gene without DGSA process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
geneSelection(data_object, gen_select_type, percent_gen_select, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geneSelection.default_+3A_data_object">data_object</code></td>
<td>
<p>Object with:
</p>

<ul>
<li><p> full_data Input matrix whose columns correspond to the patients and
rows to the genes.
</p>
</li>
<li><p> survival_time Numerical vector of the same length as the number of
columns of full_data. Patients must be in the same order as in full_data.
For the patients with tumour sample should be indicated the time between
disease diagnosis and death (if not dead until the end of follow-up)
and healthy patients must have an NA value.
</p>
</li>
<li><p> survival_event Numerical vector of the same length as the number of
columns of full_data. Patients must be in the same order as in full_data.
For the patients with tumour sample should be indicated whether
the patient has died (1) or not (0). Only these values are valid
and healthy patients must have an NA value.
</p>
</li>
<li><p> case_tag Character vector of the same length as the number of
columns of full_data. Patients must be in the same order as in full_data.
It must be indicated for each patient whether he/she is healthy or not.
One value should be used to indicate whether the patient is healthy and
another value should be used to indicate whether the patient's sample is
tumourous. The user will then be asked which one indicates whether
the patient is healthy. Only two values are valid in the vector in total.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geneSelection.default_+3A_gen_select_type">gen_select_type</code></td>
<td>
<p>Option. Options on how to select the genes to be
used in the mapper. Select the &quot;Abs&quot; option, which means that the
genes with the highest absolute value are chosen, or the
&quot;Top_Bot&quot; option, which means that half of the selected
genes are those with the highest value (positive value, i.e.
worst survival prognosis) and the other half are those with the
lowest value (negative value, i.e. best prognosis). &quot;Top_Bot&quot; default option.</p>
</td></tr>
<tr><td><code id="geneSelection.default_+3A_percent_gen_select">percent_gen_select</code></td>
<td>
<p>Percentage (from zero to one hundred) of genes
to be selected to be used in mapper. 10 default option.</p>
</td></tr>
<tr><td><code id="geneSelection.default_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.
If <code>FALSE</code>, an error occurs in case of <code>NA</code> rows. TRUE default
option.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>geneSelection</code> object. It contains: the full_data without NAN's values,
the control tag of the healthy patient, the matrix with the normal space and
the matrix of the disease components.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data_object &lt;- list("full_data" = full_data, "survival_time" = survival_time,
"survival_event" = survival_event, "case_tag" = case_tag)
class(data_object) &lt;- "data_object"
geneSelection_object &lt;- geneSelection(data_object, gen_select_type ="top_bot",
                                      percent_gen_select = 10)
</code></pre>

<hr>
<h2 id='geneSelection.DGSA_object'>gene_selection_classes.DGSA_object</h2><span id='topic+geneSelection.DGSA_object'></span>

<h3>Description</h3>

<p>Private function to select Gene with DGSA object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DGSA_object'
geneSelection(data_object, gen_select_type, percent_gen_select, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geneSelection.DGSA_object_+3A_data_object">data_object</code></td>
<td>
<p>DGSA object information</p>
</td></tr>
<tr><td><code id="geneSelection.DGSA_object_+3A_gen_select_type">gen_select_type</code></td>
<td>
<p>Option. Options on how to select the genes to be
used in the mapper. Select the &quot;Abs&quot; option, which means that the
genes with the highest absolute value are chosen, or the
&quot;Top_Bot&quot; option, which means that half of the selected
genes are those with the highest value (positive value, i.e.
worst survival prognosis) and the other half are those with the
lowest value (negative value, i.e. best prognosis). &quot;Top_Bot&quot; default option.</p>
</td></tr>
<tr><td><code id="geneSelection.DGSA_object_+3A_percent_gen_select">percent_gen_select</code></td>
<td>
<p>Percentage (from zero to one hundred) of genes
to be selected to be used in mapper. 10 default option.</p>
</td></tr>
<tr><td><code id="geneSelection.DGSA_object_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.
If <code>FALSE</code>, an error occurs in case of <code>NA</code> rows. TRUE default
option.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>geneSelection</code> object. It contains: the full_data without NAN's values,
the control tag of the healthy patient, the matrix with the normal space and
the matrix of the disease components.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
DGSA_obj &lt;- DGSA(full_data, survival_time, survival_event, case_tag, na.rm = "checked")

geneSelection_object &lt;- geneSelection(DGSA_obj, gen_select_type ="top_bot",
                                      percent_gen_select = 10)
</code></pre>

<hr>
<h2 id='get_intervals_One_D'>Extract intervals from filter function output values.</h2><span id='topic+get_intervals_One_D'></span>

<h3>Description</h3>

<p>It calculates the intervals of the given output values of a filter function
according to the given number and percentage of overlap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_intervals_One_D(filter_values, num_intervals, percent_overlap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_intervals_One_D_+3A_filter_values">filter_values</code></td>
<td>
<p>Vector obtained after applying the filtering function
to the input matrix, i.e, a vector with the filtering function
values for each included sample.</p>
</td></tr>
<tr><td><code id="get_intervals_One_D_+3A_num_intervals">num_intervals</code></td>
<td>
<p>Number of intervals to divide the filtering function
values in.</p>
</td></tr>
<tr><td><code id="get_intervals_One_D_+3A_percent_overlap">percent_overlap</code></td>
<td>
<p>Percentage of overlap between intervals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the set of intervals for the filtering function
values.
</p>

<hr>
<h2 id='get_lambda'>Computes lambda</h2><span id='topic+get_lambda'></span>

<h3>Description</h3>

<p>Computes the value of lambda as defined in: &quot;The Optimal
Hard Threshold for Singular Values is <code class="reqn">\sqrt(4/ 3)</code>&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_lambda(bet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_lambda_+3A_bet">bet</code></td>
<td>
<p>Beta value. Aspect ratio of the input matrix.  </p>
<p style="text-align: center;"><code class="reqn">\frac{m}{n}</code>
</p>
<p>,
were m is the number of rows of the input matrix and n the number of columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric. Lambda value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_lambda(0.3)
</code></pre>

<hr>
<h2 id='get_mu_beta'>Get mu sub beta</h2><span id='topic+get_mu_beta'></span>

<h3>Description</h3>

<p>This function identifies the upper bound of integration of the
Marcenko-Pastur distribution, as described in &quot;The Optimal Hard
Threshold for Singular Values is <code class="reqn">\sqrt(4/ 3)</code>&quot;. It explores 100
values in a given interval. Then it selects the values closest to 1/2
on the left and on the right. As the upper bound of integration,
if the distance between the left and right approximations is lower than
a given threshold (1e-10), it converges and the upper bound that produces
an area of 1/2 is defined as the mean of the left and right approximations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mu_beta(bet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mu_beta_+3A_bet">bet</code></td>
<td>
<p>Beta value. Aspect ratio of the input matrix, </p>
<p style="text-align: center;"><code class="reqn">\frac{m}{n}</code>
</p>
<p>,
were m is the number of rows of the input matrix and n the number of columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns the mu beta value. This is the upper limit of integration
where the Marcenko-Pastur distribution is equal to 1/2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_mu_beta(0.3)
</code></pre>

<hr>
<h2 id='get_omega'>Compute the omega value</h2><span id='topic+get_omega'></span>

<h3>Description</h3>

<p>It computes the omega value as described in &quot;The Optimal Hard
Threshold for Singular Values is <code class="reqn">\sqrt(4/ 3)</code>&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_omega(bet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_omega_+3A_bet">bet</code></td>
<td>
<p>Beta value. Aspect ratio of the input matrix, </p>
<p style="text-align: center;"><code class="reqn">\frac{m}{n}</code>
</p>
<p>,
were m is the number of rows of the input matrix and n the number of columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric. Omega value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_omega(0.3)
</code></pre>

<hr>
<h2 id='GSSTDA'>Gene Structure Survival using Topological Data Analysis (GSSTDA).</h2><span id='topic+GSSTDA'></span>

<h3>Description</h3>

<p>Gene Structure Survival using Topological Data Analysis.
This function implements an analysis for expression array data
based on the <em>Progression Analysis of Disease</em> developed by Nicolau
<em>et al.</em> (doi: 10.1073/pnas.1102826108) that allows the information
contained in an expression matrix to be condensed into a combinatory graph.
The novelty is that information on survival is integrated into the analysis.
</p>
<p>The analysis consists of 3 parts: a preprocessing of the data, the gene
selection and the filter function, and the mapper algorithm. The
preprocessing is specifically the Disease Specific Genomic Analysis (proposed
by Nicolau <em>et al.</em>) that consists of, through linear models, eliminating the
part of the data that is considered &quot;healthy&quot; and keeping only the component
that is due to the disease. The genes are then selected according to their
variability and whether they are related to survival and the values of the
filtering function for each patient are calculated taking into account the
survival associated with each gene. Finally, the mapper algorithm is applied
from the disease component matrix and the values of the filter function
obtaining a combinatory graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GSSTDA(
  full_data,
  survival_time,
  survival_event,
  case_tag,
  gen_select_type = "Top_Bot",
  percent_gen_select = 10,
  num_intervals = 5,
  percent_overlap = 40,
  distance_type = "cor",
  clustering_type = "hierarchical",
  num_bins_when_clustering = 10,
  linkage_type = "single",
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GSSTDA_+3A_full_data">full_data</code></td>
<td>
<p>Input matrix whose columns correspond to the patients and
rows to the genes.</p>
</td></tr>
<tr><td><code id="GSSTDA_+3A_survival_time">survival_time</code></td>
<td>
<p>Numerical vector of the same length as the number of
columns of full_data. Patients must be in the same order as in full_data.
For the patients with tumour sample should be indicated the time between
disease diagnosis and death (if not dead until the end of follow-up)
and healthy patients must have an NA value.</p>
</td></tr>
<tr><td><code id="GSSTDA_+3A_survival_event">survival_event</code></td>
<td>
<p>Numerical vector of the same length as the number of
columns of full_data. Patients must be in the same order as in full_data.
For the patients with tumour sample should be indicated whether
the patient has died (1) or not (0). Only these values are valid
and healthy patients must have an NA value.</p>
</td></tr>
<tr><td><code id="GSSTDA_+3A_case_tag">case_tag</code></td>
<td>
<p>Character vector of the same length as the number of
columns of full_data. Patients must be in the same order as in full_data.
It must be indicated for each patient whether he/she is healthy or not.
One value should be used to indicate whether the patient is healthy and
another value should be used to indicate whether the patient's sample is
tumourous. The user will then be asked which one indicates whether
the patient is healthy. Only two values are valid in the vector in total.</p>
</td></tr>
<tr><td><code id="GSSTDA_+3A_gen_select_type">gen_select_type</code></td>
<td>
<p>Option. Options on how to select the genes to be
used in the mapper. Select the &quot;Abs&quot; option, which means that the
genes with the highest absolute value are chosen, or the
&quot;Top_Bot&quot; option, which means that half of the selected
genes are those with the highest value (positive value, i.e.
worst survival prognosis) and the other half are those with the
lowest value (negative value, i.e. best prognosis). &quot;Top_Bot&quot; default option.</p>
</td></tr>
<tr><td><code id="GSSTDA_+3A_percent_gen_select">percent_gen_select</code></td>
<td>
<p>Percentage (from zero to one hundred) of genes
to be selected to be used in mapper. 10 default option.</p>
</td></tr>
<tr><td><code id="GSSTDA_+3A_num_intervals">num_intervals</code></td>
<td>
<p>Parameter for the mapper algorithm. Number of
intervals used to create the first sample partition based on
filtering values. 5 default option.</p>
</td></tr>
<tr><td><code id="GSSTDA_+3A_percent_overlap">percent_overlap</code></td>
<td>
<p>Parameter for the mapper algorithm. Percentage
of overlap between intervals. Expressed as a percentage. 40 default option.</p>
</td></tr>
<tr><td><code id="GSSTDA_+3A_distance_type">distance_type</code></td>
<td>
<p>Parameter for the mapper algorithm.
Type of distance to be used for clustering. Choose between correlation
(&quot;cor&quot;) and euclidean (&quot;euclidean&quot;). &quot;cor&quot; default option.</p>
</td></tr>
<tr><td><code id="GSSTDA_+3A_clustering_type">clustering_type</code></td>
<td>
<p>Parameter for the mapper algorithm. Type of
clustering method. Choose between &quot;hierarchical&quot; and &quot;PAM&quot;
(“partition around medoids”) options. &quot;hierarchical&quot; default option.</p>
</td></tr>
<tr><td><code id="GSSTDA_+3A_num_bins_when_clustering">num_bins_when_clustering</code></td>
<td>
<p>Parameter for the mapper algorithm.
Number of bins to generate the histogram employed by the standard
optimal number of cluster finder method. Parameter not necessary if the
&quot;optimal_clust_mode&quot; option is &quot;silhouette&quot; or the &quot;clust_type&quot; is &quot;PAM&quot;.
10 default option.</p>
</td></tr>
<tr><td><code id="GSSTDA_+3A_linkage_type">linkage_type</code></td>
<td>
<p>Parameter for the mapper algorithm. Linkage criteria
used in hierarchical clustering. Choose between &quot;single&quot; for single-linkage
clustering, &quot;complete&quot; for complete-linkage clustering or &quot;average&quot; for
average linkage clustering (or UPGMA). Only necessary for hierarchical
clustering. &quot;single&quot; default option.</p>
</td></tr>
<tr><td><code id="GSSTDA_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.
If <code>FALSE</code>, an error occurs in case of <code>NA</code> rows. TRUE default
option.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GSSTDA</code> object. It contains:
</p>

<ul>
<li><p> the matrix with the normal space <code>normal_space</code>,
</p>
</li>
<li><p> the matrix of the disease components normal_space <code>matrix_disease_component</code>,
</p>
</li>
<li><p> a matrix with the results of the application of proportional hazard models
for each gene (<code>cox_all_matrix)</code>,
</p>
</li>
<li><p> the genes selected for mapper <code>genes_disease_componen</code>,
</p>
</li>
<li><p> the matrix of the disease components with information from these genes only
<code>genes_disease_component</code>
</p>
</li>
<li><p> and a <code>mapper_obj</code> object. This <code>mapper_obj</code> object contains the
values of the intervals (interval_data), the samples included in each
interval (sample_in_level), information about the cluster to which the
individuals in each interval belong (clustering_all_levels), a list including
the individuals contained in each detected node (node_samples), their size
(node_sizes), the average of the filter function values of the individuals
of each node (node_average_filt) and the adjacency matrix linking the nodes
(adj_matrix). Moreover, information is provided on the number of nodes,
the average node size, the standard deviation of the node size, the number
of connections between nodes, the proportion of connections to all possible
connections and the number of ramifications.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
GSSTDA_object &lt;- GSSTDA(full_data,  survival_time, survival_event, case_tag,
                 gen_select_type="Top_Bot", percent_gen_select=10,
                 num_intervals = 4, percent_overlap = 50,
                 distance_type = "euclidean", num_bins_when_clustering = 8,
                 clustering_type = "hierarchical", linkage_type = "single")
</code></pre>

<hr>
<h2 id='levels_to_nodes'>Extract Information about Nodes</h2><span id='topic+levels_to_nodes'></span>

<h3>Description</h3>

<p>Extract the nodes information based on information about
clustering. The individuals who are part of each node are identified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>levels_to_nodes(clust_all_levels_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="levels_to_nodes_+3A_clust_all_levels_list">clust_all_levels_list</code></td>
<td>
<p>A list with information on the levels
obtained from the <code>clust_all_levels</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the individuals content of each detected node.
List of character vectors. Each of the vectors contains the names
of the individuals at each node.
</p>

<hr>
<h2 id='lp_norm_k_powers_surv'>Filtering function</h2><span id='topic+lp_norm_k_powers_surv'></span>

<h3>Description</h3>

<p>A filtering function for mapper that projects $$R$^n$ into $R$.
It calculates for each column of the matrix (each patient), its value
of the filtering function. Specifically, it computes
the vector magnitude in the [L_p] norm (as well
as k powers of this magnitude) of the vector resulting of
weighting each element of the column vector by the Z score obtained
by fitting a cox proportional hazard model to the level of each gene.
For further information see &quot;Progression Analysis of Disease with Survival
(PAD-S) by SurvMap identifies different prognostic subgroups of breast
cancer in a large combined set of transcriptomics and methylation studies&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lp_norm_k_powers_surv(genes_disease_component, p, k, cox_all_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lp_norm_k_powers_surv_+3A_genes_disease_component">genes_disease_component</code></td>
<td>
<p>Disease component matrix (output of the function of
<code>generate_disease_component</code>), after having selected the rows
corresponding to the selected genes.</p>
</td></tr>
<tr><td><code id="lp_norm_k_powers_surv_+3A_p">p</code></td>
<td>
<p>integer. It indicates the p norm to be calculated.
If k = 1 and p = 2, the function computes the standard
(Euclidean) vector magnitude of each column. For larger values of p the
weight of genes with larger levels is greater.</p>
</td></tr>
<tr><td><code id="lp_norm_k_powers_surv_+3A_k">k</code></td>
<td>
<p>integer. Powers of the vector magnitude. If k = 1 and p = 2,
the function computes the standard (Euclidean) vector magnitude
of each column.</p>
</td></tr>
<tr><td><code id="lp_norm_k_powers_surv_+3A_cox_all_matrix">cox_all_matrix</code></td>
<td>
<p>A matrix with the output of the
<code>cox_all_genes</code> function that stores the information of all cox
proportional hazard model tests for each gene in the dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector including the values produced by the function
for each sample in the dataset.
</p>

<hr>
<h2 id='map_to_color'>Map to color</h2><span id='topic+map_to_color'></span>

<h3>Description</h3>

<p>Auxiliary function that maps a numeric vector, the average node
filtering function values, to a color vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_to_color(x, limits = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_to_color_+3A_x">x</code></td>
<td>
<p>A vector of numeric values storing the average filtering
function values found in the samples placed into a specific node.</p>
</td></tr>
<tr><td><code id="map_to_color_+3A_limits">limits</code></td>
<td>
<p>A two element numeric vector including the range of values.
This is optional.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length of x with colors ranging from blue to
red.
</p>

<hr>
<h2 id='mapper'>Mapper object</h2><span id='topic+mapper'></span>

<h3>Description</h3>

<p>TDA are persistent homology and mapper. Persistent homology
borrows ideas from abstract algebra to identify particular aspects
related to the shape of the data such as the number of connected
components and the presence of higher-dimensional holes, whereas
mapper condenses the information of high-dimensional datasets into
a combinatory graph or simplicial complex that is referred to as
the skeleton of the dataset. This implementation is the mapper of one
dimension, i.e. using only one filter function value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapper(
  full_data,
  filter_values,
  num_intervals = 5,
  percent_overlap = 40,
  distance_type = "cor",
  clustering_type = "hierarchical",
  num_bins_when_clustering = 10,
  linkage_type = "single",
  optimal_clustering_mode = "",
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapper_+3A_full_data">full_data</code></td>
<td>
<p>Input matrix whose columns correspond to the individuals
and rows to the features.</p>
</td></tr>
<tr><td><code id="mapper_+3A_filter_values">filter_values</code></td>
<td>
<p>Vector obtained after applying the filtering function
to the input matrix, i.e, a vector with the filtering function
values for each included sample.</p>
</td></tr>
<tr><td><code id="mapper_+3A_num_intervals">num_intervals</code></td>
<td>
<p>Number of intervals used to create the first sample
partition based on filtering values. 5 default option.</p>
</td></tr>
<tr><td><code id="mapper_+3A_percent_overlap">percent_overlap</code></td>
<td>
<p>Percentage of overlap between intervals. Expressed
as a percentage. 40 default option.</p>
</td></tr>
<tr><td><code id="mapper_+3A_distance_type">distance_type</code></td>
<td>
<p>Type of distance to be used for clustering.
Choose between correlation (&quot;cor&quot;) and euclidean (&quot;euclidean&quot;). &quot;cor&quot;
default option.</p>
</td></tr>
<tr><td><code id="mapper_+3A_clustering_type">clustering_type</code></td>
<td>
<p>Type of clustering method. Choose between
&quot;hierarchical&quot; and &quot;PAM&quot; (“partition around medoids”) options.
&quot;hierarchical&quot; default option.</p>
</td></tr>
<tr><td><code id="mapper_+3A_num_bins_when_clustering">num_bins_when_clustering</code></td>
<td>
<p>Number of bins to generate the
histogram employed by the standard optimal number of cluster finder
method. Parameter not necessary if the &quot;optimal_clust_mode&quot; option
is &quot;silhouette&quot; or the &quot;clust_type&quot; is &quot;PAM&quot;. 10 default option.</p>
</td></tr>
<tr><td><code id="mapper_+3A_linkage_type">linkage_type</code></td>
<td>
<p>Linkage criteria used in hierarchical clustering.
Choose between &quot;single&quot; for single-linkage clustering, &quot;complete&quot; for
complete-linkage clustering or &quot;average&quot; for average linkage clustering
(or UPGMA). Only necessary for hierarchical clustering.
&quot;single&quot; default option.</p>
</td></tr>
<tr><td><code id="mapper_+3A_optimal_clustering_mode">optimal_clustering_mode</code></td>
<td>
<p>Method for selection optimal number of
clusters. It is only necessary if the chosen type of algorithm is
hierarchical. In this case, choose between &quot;standard&quot; (the method used
in the original mapper article) or &quot;silhouette&quot;. In the case of the PAM
algorithm, the method will always be &quot;silhouette&quot;.</p>
</td></tr>
<tr><td><code id="mapper_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.
If <code>FALSE</code>, an error occurs in case of <code>NA</code> rows. TRUE default
option.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mapper_obj</code> object. It contains the values of the intervals
(interval_data), the samples included in each interval (sample_in_level),
information about the cluster to which the individuals in each interval
belong (clustering_all_levels), a list including the individuals contained
in each detected node (node_samples), their size (node_sizes), the
average of the filter function values of the individuals of each node
(node_average_filt) and the adjacency matrix linking the nodes (adj_matrix).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
control_tag_cases &lt;- which(case_tag == "NT")
geneSelection_object &lt;- gene_selection(full_data, survival_time, survival_event, control_tag_cases,
gen_select_type ="top_bot", num_gen_select = 10)

mapper_object &lt;- mapper(full_data = geneSelection_object[["genes_disease_component"]],
filter_values = geneSelection_object[["filter_values"]],
num_intervals = 5,
percent_overlap = 40, distance_type = "cor",
clustering_type = "hierarchical",
linkage_type = "single")
</code></pre>

<hr>
<h2 id='one_D_Mapper'>one_D_Mapper</h2><span id='topic+one_D_Mapper'></span>

<h3>Description</h3>

<p>Wrapping function to carry out the complete process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one_D_Mapper(mapper_object_ini)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="one_D_Mapper_+3A_mapper_object_ini">mapper_object_ini</code></td>
<td>
<p>Mapper TDA initializated object generated
by <code>mapper</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mapper_obj</code> object. It contains the values of the intervals
(interval_data), the samples included in each interval (sample_in_level),
information about the cluster to which the individuals in each interval
belong (clustering_all_levels), a list including the individuals contained
in each detected node (node_samples), their size (node_sizes), the
average of the filter function values of the individuals of each node
(node_average_filt) and the adjacency matrix linking the nodes (adj_matrix).
Moreover, information is provided on the number of nodes, the average node
size, the standard deviation of the node size, the number of connections
between nodes, the proportion of connections to all possible connections
and the number of ramifications.
</p>

<hr>
<h2 id='plot_DGSA'>plot DGSA</h2><span id='topic+plot_DGSA'></span>

<h3>Description</h3>

<p>It draws the heatmap of the DGSA result by selecting the 100 genes with
the highest variability between samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_DGSA(selected_matrix_disease_component, case_tag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_DGSA_+3A_selected_matrix_disease_component">selected_matrix_disease_component</code></td>
<td>
<p>Disease component matrix of
the selected genes that contains the disease component of all patients.
Output of the function <code>generate_disease_component</code>.</p>
</td></tr>
<tr><td><code id="plot_DGSA_+3A_case_tag">case_tag</code></td>
<td>
<p>Character vector of the same length as the number of
columns of full_data. Patients must be in the same order as in full_data.
It must be indicated for each patient whether he/she is healthy or not.
One value should be used to indicate whether the patient is healthy and
another value should be used to indicate whether the patient's sample is
tumourous. The user will then be asked which one indicates whether
the patient is healthy. Only two values are valid in the vector in total.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The heatmap of the DGSA result.
</p>

<hr>
<h2 id='plot_mapper'>Plot mapper</h2><span id='topic+plot_mapper'></span>

<h3>Description</h3>

<p>This function produces an interactive network plot using
the <code>visNetork</code> function from the mapper results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mapper(mapper_object, trans_node_size = TRUE, exp_to_res = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_mapper_+3A_mapper_object">mapper_object</code></td>
<td>
<p>A list produced as an output of the <code>one_D_Mapper</code>
function.</p>
</td></tr>
<tr><td><code id="plot_mapper_+3A_trans_node_size">trans_node_size</code></td>
<td>
<p>Logical, it indicates whether you want to resize
the size of the nodes. <code>TRUE</code> default option.</p>
</td></tr>
<tr><td><code id="plot_mapper_+3A_exp_to_res">exp_to_res</code></td>
<td>
<p>Only necessary if trans_node_size is <code>TRUE</code>. An
exponent of the form 1/n to which the node sizes must be raised in order
to resize them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots an interactive network using the <code>visNetwork</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create data object
data_object &lt;- list("full_data" = full_data, "survival_time" = survival_time,
                   "survival_event" = survival_event, "case_tag" = case_tag)
class(data_object) &lt;- "data_object"

#Select gene from data object
geneSelection_object &lt;- geneSelection(data_object, gen_select_type="top_bot",
 percent_gen_select=10)

mapper_object &lt;- mapper(full_data = geneSelection_object[["genes_disease_component"]],
filter_values = geneSelection_object[["filter_values"]],
num_intervals = 5,
percent_overlap = 40, distance_type = "cor",
clustering_type = "hierarchical",
linkage_type = "single")
plot_mapper(mapper_object)
</code></pre>

<hr>
<h2 id='results_DGSA'>results DGSA</h2><span id='topic+results_DGSA'></span>

<h3>Description</h3>

<p>It calculates the 100 genes with the highest variability in the matrix
disease component between samples and use them to draw the heat map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>results_DGSA(matrix_disease_component, case_tag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="results_DGSA_+3A_matrix_disease_component">matrix_disease_component</code></td>
<td>
<p>Disease component matrix that contains
the disease component of all patients. Output of the function
<code>generate_disease_component</code>.</p>
</td></tr>
<tr><td><code id="results_DGSA_+3A_case_tag">case_tag</code></td>
<td>
<p>Character vector of the same length as the number of
columns of full_data. Patients must be in the same order as in full_data.
It must be indicated for each patient whether he/she is healthy or not.
One value should be used to indicate whether the patient is healthy and
another value should be used to indicate whether the patient's sample is
tumourous. The user will then be asked which one indicates whether
the patient is healthy. Only two values are valid in the vector in total.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A heatmap of the 100 genes with the highest variability in the matrix
disease component.
</p>

<hr>
<h2 id='samples_in_levels'>Samples in levels</h2><span id='topic+samples_in_levels'></span>

<h3>Description</h3>

<p>This function returns a list of vectors containing the
individuals included at each level, i.e. the vectors of individuals with
a value of the filter function within each of the intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samples_in_levels(interval_data, filter_values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samples_in_levels_+3A_interval_data">interval_data</code></td>
<td>
<p>Filter function intervals. List with the set of
intervals for the filtering function values produced by the
<code>get_intervals_One_D</code> function.</p>
</td></tr>
<tr><td><code id="samples_in_levels_+3A_filter_values">filter_values</code></td>
<td>
<p>Vector obtained after applying the filtering
function to the input matrix, i.e, a vector with the filtering function
values for each included sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors with the samples included
in each of the levels (i.e. each of the intervals of the values of the
filter functions).
</p>

<hr>
<h2 id='survival_event'>Survival event vector</h2><span id='topic+survival_event'></span>

<h3>Description</h3>

<p>Character vector of length 121 containing whether or not the patient
is deceased.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(survival_event, package = "GSSTDA")
</code></pre>


<h3>Format</h3>

<p>Character vector of length 121.
</p>
<p>A value of &quot;0&quot; indicates that the patient did not pass away
during follow-up, a value of &quot;1&quot; indicates that the patient did. Samples
from healthy tissue contain a value of <code>NA</code>.

</p>


<h3>Source</h3>

<p>The data are from the study GSE42568. Information extracted from
the file GSE42568_family.soft.gz available at
<a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE42568">https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE42568</a>.
</p>

<hr>
<h2 id='survival_time'>Survival time vector</h2><span id='topic+survival_time'></span>

<h3>Description</h3>

<p>Numeric vector of length 121 containing the time in months until
the death of the patient or until the end of the follow-up in case the
patient has not passed away.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(survival_time, package = "GSSTDA")
</code></pre>


<h3>Format</h3>

<p>Numeric vector of length 121.
</p>
<p>Time in months. Samples from healthy tissue contain a
value of <code>NA</code>.

</p>


<h3>Source</h3>

<p>The data are from the study GSE42568. Information extracted from
the file GSE42568_family.soft.gz available at
<a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE42568">https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE42568</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
