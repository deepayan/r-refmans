<!DOCTYPE html><html><head><title>Help for package bvarsv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bvarsv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bvarsv-package'>
<p>Bayesian Analysis of a Vector Autoregressive Model with Stochastic Volatility and Time-Varying Parameters</p></a></li>
<li><a href='#bvar.sv.tvp'>
<p>Bayesian Analysis of a Vector Autoregressive Model with Stochastic Volatility and Time-Varying Parameters</p></a></li>
<li><a href='#Example data sets'>
<p>US Macroeconomic Time Series</p></a></li>
<li><a href='#helpers'>
<p>Helper Functions to Access BVAR Forecast Distributions and Parameter Draws</p></a></li>
<li><a href='#impulse.responses'>
<p>Compute Impulse Response Function from a Fitted Model</p></a></li>
<li><a href='#sim.var1.sv.tvp'>
<p>Simulate from a VAR(1) with Stochastic Volatility and Time-Varying Parameters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Analysis of a Vector Autoregressive Model with
Stochastic Volatility and Time-Varying Parameters</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2015-10-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Fabian Krueger</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fabian Krueger &lt;Fabian.Krueger83@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>R/C++ implementation of the model proposed by Primiceri ("Time Varying Structural Vector Autoregressions and Monetary Policy", Review of Economic Studies, 2005), with functionality for computing posterior predictive distributions and impulse responses.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sites.google.com/site/fk83research/code">https://sites.google.com/site/fk83research/code</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-11-25 13:14:28 UTC; kruegefn</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-11-25 14:40:22</td>
</tr>
</table>
<hr>
<h2 id='bvarsv-package'>
Bayesian Analysis of a Vector Autoregressive Model with Stochastic Volatility and Time-Varying Parameters
</h2><span id='topic+bvarsv-package'></span><span id='topic+bvarsv'></span>

<h3>Description</h3>

<p>R/C++ implementation of the Primiceri (2005) model, which allows for both stochastic volatility and time-varying regression parameters. The package contains functions for computing posterior predictive distributions and impulse responses from the model, based on an input data set. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> bvarsv</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2014-08-14</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://sites.google.com/site/fk83research/code</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Fabian Krueger &lt;Fabian.Krueger83@gmail.com&gt;, based on Matlab code by Dimitris Korobilis (see Koop and Korobilis, 2010).
</p>


<h3>References</h3>

<p><em>The code incorporates the recent corrigendum by Del Negro and Primiceri (2015), which points to an error in the original MCMC algorithm of Primiceri (2005).</em>
</p>
<p>Del Negro, M. and Primicerio, G.E. (2015). &lsquo;Time Varying Structural Vector Autoregressions and Monetary Policy: A Corrigendum&rsquo;, Review of Economic Studies 82, 1342-1345.
</p>
<p>Koop, G. and D. Korobilis (2010): &lsquo;Bayesian Multivariate Time Series Methods for Empirical Macroeconomics&rsquo;, Foundations and Trends in Econometrics 3, 267-358. Accompanying Matlab code available at <a href="https://sites.google.com/site/dimitriskorobilis/matlab">https://sites.google.com/site/dimitriskorobilis/matlab</a>.
</p>
<p>Primiceri, G.E. (2005): &lsquo;Time Varying Structural Vector Autoregressions and Monetary Policy&rsquo;, Review of Economic Studies 72, 821-852.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Load US macro data
data(usmacro)

# Estimate trivariate model using Primiceri's prior choices (default settings)
set.seed(5813)
bv &lt;- bvar.sv.tvp(usmacro)


## End(Not run)
</code></pre>

<hr>
<h2 id='bvar.sv.tvp'>
Bayesian Analysis of a Vector Autoregressive Model with Stochastic Volatility and Time-Varying Parameters
</h2><span id='topic+bvar.sv.tvp'></span>

<h3>Description</h3>

<p>Bayesian estimation of the flexible VAR model by Primiceri (2005) which allows for both stochastic volatility and time drift in the model parameters. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bvar.sv.tvp(Y, p = 1, tau = 40, nf = 10, pdrift = TRUE, nrep = 50000, 
nburn = 5000, thinfac = 10, itprint = 10000, save.parameters = TRUE, 
k_B = 4, k_A = 4, k_sig = 1, k_Q = 0.01, k_S = 0.1, k_W = 0.01, 
pQ = NULL, pW = NULL, pS = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bvar.sv.tvp_+3A_y">Y</code></td>
<td>
<p>Matrix of data, where rows represent time and columns are different variables. <code>Y</code> must have at least two columns.</p>
</td></tr>
<tr><td><code id="bvar.sv.tvp_+3A_p">p</code></td>
<td>
<p>Lag length, greater or equal than 1 (the default)</p>
</td></tr>
<tr><td><code id="bvar.sv.tvp_+3A_tau">tau</code></td>
<td>
<p>Length of the training sample used for determining prior parameters via least squares (LS). That is, data in <code>Y[1:tau, ]</code> are used for estimating prior parameters via LS; formal Bayesian analysis is then performed for data in <code>Y[(tau+1):nrow(Y), ]</code>.</p>
</td></tr>
<tr><td><code id="bvar.sv.tvp_+3A_nf">nf</code></td>
<td>
<p>Number of future time periods for which forecasts are computed (integer, 1 or greater, defaults to 10).</p>
</td></tr>
<tr><td><code id="bvar.sv.tvp_+3A_pdrift">pdrift</code></td>
<td>
<p>Dummy, indicates whether or not to account for parameter drift when simulating forecasts (defaults to TRUE).</p>
</td></tr>
<tr><td><code id="bvar.sv.tvp_+3A_nrep">nrep</code></td>
<td>
<p>Number of MCMC draws excluding burn-in (defaults to 50000)</p>
</td></tr>
<tr><td><code id="bvar.sv.tvp_+3A_nburn">nburn</code></td>
<td>
<p>Number of MCMC draws used to initialize the sampler (defaults to 5000). These draws do not enter the computation of posterior moments, forecasts etc.</p>
</td></tr>
<tr><td><code id="bvar.sv.tvp_+3A_thinfac">thinfac</code></td>
<td>
<p>Thinning factor for MCMC output. Defaults to 10, which means that the forecast sequences (<code>fc.mdraws</code>, <code>fc.vdraws</code>, <code>fc.ydraws</code>, see below) contain only every tenth draw of the original sequence. Set <code>thinfac</code> to one to obtain the full MCMC sequence.</p>
</td></tr>
<tr><td><code id="bvar.sv.tvp_+3A_itprint">itprint</code></td>
<td>
<p>Print every <code>itprint</code>-th iteration. Defaults to 10000. Set to very large value to omit printing altogether.</p>
</td></tr>
<tr><td><code id="bvar.sv.tvp_+3A_save.parameters">save.parameters</code></td>
<td>
<p>If set to <code>TRUE</code>, parameter draws are saved in lists (these can be very large). Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bvar.sv.tvp_+3A_k_b">k_B</code>, <code id="bvar.sv.tvp_+3A_k_a">k_A</code>, <code id="bvar.sv.tvp_+3A_k_sig">k_sig</code>, <code id="bvar.sv.tvp_+3A_k_q">k_Q</code>, <code id="bvar.sv.tvp_+3A_k_w">k_W</code>, <code id="bvar.sv.tvp_+3A_k_s">k_S</code>, <code id="bvar.sv.tvp_+3A_pq">pQ</code>, <code id="bvar.sv.tvp_+3A_pw">pW</code>, <code id="bvar.sv.tvp_+3A_ps">pS</code></td>
<td>
<p>Quantities which enter the prior distributions, see the links below for details. Defaults to the exact values used in the original article by Primiceri.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Beta.postmean</code></td>
<td>
<p>Posterior means of coefficients. This is an array of dimension <code class="reqn">[M, Mp+1, T]</code>, where <code class="reqn">T</code> denotes the number of time periods (= number of rows of <code>Y</code>), and <code class="reqn">M</code> denotes the number of system variables (= number of columns of <code>Y</code>). The submatrix <code class="reqn">[, , t]</code> represents the coefficient matrix at time <code class="reqn">t</code>. The intercept vector is stacked in the first column; the <code>p</code> coefficient matrices of dimension <code class="reqn">[M,M]</code> are placed next to it.</p>
</td></tr>
<tr><td><code>H.postmean</code></td>
<td>
<p>Posterior means of error term covariance matrices. This is an array of dimension <code class="reqn">[M, M, T]</code>. The submatrix <code class="reqn">[, , t]</code> represents the covariance matrix at time <code class="reqn">t</code>.</p>
</td></tr>
<tr><td><code>Q.postmean</code>, <code>S.postmean</code>, <code>W.postmean</code></td>
<td>
<p>Posterior means of various covariance matrices.</p>
</td></tr>
<tr><td><code>fc.mdraws</code></td>
<td>
<p>Draws for the forecast mean vector at various horizons (three-dimensional array, where the first dimension corresponds to system variables, the second to forecast horizons, and the third to MCMC draws). <em>Note:</em> The third dimension will be equal to <code>nrep/thinfac</code>, apart from possible rounding issues.</p>
</td></tr>
<tr><td><code>fc.vdraws</code></td>
<td>
<p>Draws for the forecast covariance matrix. Design similar to <code>fc.mdraws</code>, except that the first array dimension contains the lower-diagonal elements of the forecast covariance matrix.</p>
</td></tr>
<tr><td><code>fc.ydraws</code></td>
<td>
<p>Simulated future observations. Design analogous to <code>fc.mdraws</code>.</p>
</td></tr>
<tr><td><code>Beta.draws</code>, <code>H.draws</code></td>
<td>
<p>Matrices of parameter draws, can be used for computing impulse responses later on (see <a href="#topic+impulse.responses">impulse.responses</a>), and accessed via the helper function <code><a href="#topic+parameter.draws">parameter.draws</a></code>.
These outputs are generated only if <code>save.parameters</code> has been set to <code>TRUE</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fabian Krueger, based on Matlab code by Dimitris Korobilis (see Koop and Korobilis, 2010). <em>Incorporates the corrigendum by Del Negro and Primiceri (2015), which points to an error in the original MCMC algorithm of Primiceri (2005).</em>
</p>


<h3>References</h3>

<p>Del Negro, M. and Primicerio, G.E. (2015). &lsquo;Time Varying Structural Vector Autoregressions and Monetary Policy: A Corrigendum&rsquo;, Review of Economic Studies 82, 1342-1345. 
</p>
<p>Koop, G. and D. Korobilis (2010): &lsquo;Bayesian Multivariate Time Series Methods for Empirical Macroeconomics&rsquo;, Foundations and Trends in Econometrics 3, 267-358. Accompanying Matlab code available at <a href="https://sites.google.com/site/dimitriskorobilis/matlab">https://sites.google.com/site/dimitriskorobilis/matlab</a>.
</p>
<p>Primiceri, G.E. (2005): &lsquo;Time Varying Structural Vector Autoregressions and Monetary Policy&rsquo;, Review of Economic Studies 72, 821-852.
</p>


<h3>See Also</h3>

<p>The helper functions <code><a href="#topic+predictive.density">predictive.density</a></code> and <code><a href="#topic+predictive.draws">predictive.draws</a></code> provide simple access to the forecast distribution produced by <code><a href="#topic+bvar.sv.tvp">bvar.sv.tvp</a></code>. 
Impulse responses can be computed using <a href="#topic+impulse.responses">impulse.responses</a>. For detailed examples and explanations, see the accompanying pdf file hosted at <a href="https://sites.google.com/site/fk83research/code">https://sites.google.com/site/fk83research/code</a>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Load US macro data
data(usmacro)

# Estimate trivariate BVAR using default settings
set.seed(5813)
bv &lt;- bvar.sv.tvp(usmacro)


## End(Not run)
</code></pre>

<hr>
<h2 id='Example+20data+20sets'>
US Macroeconomic Time Series
</h2><span id='topic+usmacro'></span><span id='topic+usmacro.update'></span>

<h3>Description</h3>

<p>Inflation rate, unemployment rate and treasury bill interest rate for the US, as used by Primiceri (2005). Whereas <code>usmacro</code> covers the time period studied by
Primiceri (1953:Q1 to 2001:Q3), <code>usmacro.update</code> updates the data until 2015:Q2.
</p>


<h3>Format</h3>

<p>Multiple time series (<code>mts</code>) object, series names: &lsquo;inf&rsquo;, &lsquo;une&rsquo;, and &lsquo;tbi&rsquo;.
</p>


<h3>Source</h3>

<p>Inflation data provided by Federal Reserve Bank of Philadelphia (2015): &lsquo;Real-Time Data Research Center&rsquo;, 
<a href="https://www.phil.frb.org/research-and-data/real-time-center/real-time-data/data-files/p">https://www.phil.frb.org/research-and-data/real-time-center/real-time-data/data-files/p</a>
Accessed: 2015-10-29.
The inflation rate is the year-over-year log growth rate of the GDP price index. We use the 2001:Q4 vintage of the price index for <code>usmacro</code>, and the 2015:Q3 vintage for <code>usmacro.update</code>. 
</p>
<p>Unemployment and Treasury Bill: 
Federal Reserve Bank of St. Louis (2015): &lsquo;Federal Reserve Economic Data&rsquo;,
<a href="http://research.stlouisfed.org/fred2/">http://research.stlouisfed.org/fred2/</a>.
Accessed: 2015-10-29.
The two series have the identifiers &lsquo;UNRATE&rsquo; and &lsquo;TB3MS&rsquo;. For each quarter, we compute simple averages over three monthly observations. 
</p>
<p>Disclaimer: Please note that the providers of the original data cannot take responsibility for the data posted here, nor can they answer any questions about them. Users should consult their respective websites for the official and most recent version of the data.
</p>


<h3>References</h3>

<p>Primiceri, G.E. (2005): &lsquo;Time Varying Structural Vector Autoregressions and Monetary Policy&rsquo;, Review of Economic Studies 72, 821-852.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Load and plot data
data(usmacro)
plot(usmacro)


## End(Not run)
</code></pre>

<hr>
<h2 id='helpers'>
Helper Functions to Access BVAR Forecast Distributions and Parameter Draws
</h2><span id='topic+predictive.density'></span><span id='topic+predictive.draws'></span><span id='topic+parameter.draws'></span>

<h3>Description</h3>

<p>Functions to extract a univariate posterior predictive distribution from a model fit generated by <code><a href="#topic+bvar.sv.tvp">bvar.sv.tvp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictive.density(fit, v = 1, h = 1, cdf = FALSE)
predictive.draws(fit, v = 1, h = 1)
parameter.draws(fit, type = "lag1", row = 1, col = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="helpers_+3A_fit">fit</code></td>
<td>
<p>List, model fit generated by <code><a href="#topic+bvar.sv.tvp">bvar.sv.tvp</a></code></p>
</td></tr>
<tr><td><code id="helpers_+3A_v">v</code></td>
<td>
<p>Index for variable of interest. <em>Must be in line with the specification of <code>fit</code></em>.</p>
</td></tr>
<tr><td><code id="helpers_+3A_h">h</code></td>
<td>
<p>Index for forecast horizon of interest. <em>Must be in line with the specification of <code>fit</code></em>.</p>
</td></tr>
<tr><td><code id="helpers_+3A_cdf">cdf</code></td>
<td>
<p>Set to TRUE to return cumulative distribution function, set to FALSE to return probability density function</p>
</td></tr>
<tr><td><code id="helpers_+3A_type">type</code></td>
<td>
<p>Character string, used to specify output for function <code><a href="#topic+parameter.draws">parameter.draws</a></code>. Setting to <code>"intercept"</code> returns parameter draws for the intercept vector. Setting to one of <code>"lag1"</code>, ..., <code>"lagX"</code>, (where X is the lag order used in <code>fit</code>)
returns parameter draws from the autoregressive coefficient matrices. Setting to <code>"vcv"</code> returns draws for the elements of the residual variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="helpers_+3A_row">row</code>, <code id="helpers_+3A_col">col</code></td>
<td>
<p>Row and column index for the parameter for which <code><a href="#topic+parameter.draws">parameter.draws</a></code> should return posterior draws. That is, the function returns the row, col element of the matrix specified by <code>type</code>. Note that 
<code>col</code> is irrelevant if <code>type = "intercept"</code> has been chosen.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p><code><a href="#topic+predictive.density">predictive.density</a></code> returns a function <code>f(z)</code>, which yields the value(s) of the predictive density at point(s) <code>z</code>. This function exploits conditional normality of the model, given the posterior draws of the parameters.
</p>
<p><code><a href="#topic+predictive.draws">predictive.draws</a></code> returns a list containing vectors of MCMC draws, more specifically:
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>Draws from the predictand itself</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Mean of the normal distribution for the predictand in each draw</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>Variance of the normal distribution for the predictand in each draw</p>
</td></tr>
</table>
<p>Both outputs should be closely in line with each other (apart from a small amount of sampling noise), see the link below for details.
</p>
<p><code><a href="#topic+parameter.draws">parameter.draws</a></code> returns posterior draws for a single (scalar) parameter of the model fitted by <code><a href="#topic+bvar.sv.tvp">bvar.sv.tvp</a></code>. The output is a matrix, with rows representing MCMC draws, and columns representing time.
</p>


<h3>Author(s)</h3>

<p>Fabian Krueger
</p>


<h3>See Also</h3>

<p>For examples and background, see the accompanying pdf file hosted at <a href="https://sites.google.com/site/fk83research/code">https://sites.google.com/site/fk83research/code</a>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Load US macro data
data(usmacro)

# Estimate trivariate BVAR using default settings
set.seed(5813)
bv &lt;- bvar.sv.tvp(usmacro)

# Construct predictive density function for the second variable (inflation), one period ahead
f &lt;- predictive.density(bv, v = 2, h = 1)

# Plot the density for a grid of values
grid &lt;- seq(-2, 5, by = 0.05)
plot(x = grid, y = f(grid), type = "l")

# Cross-check: Extract MCMC sample for the same variable and horizon
smp &lt;- predictive.draws(bv, v = 2, h = 1)

# Add density estimate to plot
lines(density(smp), col = "green")


## End(Not run)
</code></pre>

<hr>
<h2 id='impulse.responses'>
Compute Impulse Response Function from a Fitted Model 
</h2><span id='topic+impulse.responses'></span>

<h3>Description</h3>

<p>Computes impulse response functions (IRFs) from a model fit produced by <a href="#topic+bvar.sv.tvp">bvar.sv.tvp</a>. The
IRF describes how a variable responds to a shock in another variable, in the periods following the shock. To enable simple handling, this 
function computes IRFs for only one pair of variables that must be specified in advance (see <code>impulse.variable</code>
and <code>response.variable</code> below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impulse.responses(fit, impulse.variable = 1, response.variable = 2, 
                  t = NULL, nhor = 20, scenario = 2, draw.plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impulse.responses_+3A_fit">fit</code></td>
<td>
<p>Model fit produced by <a href="#topic+bvar.sv.tvp">bvar.sv.tvp</a>, with the option <code>save.parameters</code> set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="impulse.responses_+3A_impulse.variable">impulse.variable</code></td>
<td>
<p>Variable which experiences the shock.</p>
</td></tr>
<tr><td><code id="impulse.responses_+3A_response.variable">response.variable</code></td>
<td>
<p>Variable which (possibly) responds to the shock.</p>
</td></tr>
<tr><td><code id="impulse.responses_+3A_t">t</code></td>
<td>
<p>Time point from which parameter matrices are to be taken. Defaults to most recent time point.</p>
</td></tr>
<tr><td><code id="impulse.responses_+3A_nhor">nhor</code></td>
<td>
<p>Maximal time between impulse and response (defaults to 20).</p>
</td></tr>
<tr><td><code id="impulse.responses_+3A_scenario">scenario</code></td>
<td>
<p>If <code>1</code>, there is no orthogonalizaton, and the shock size corresponds to one unit of the impulse variable. If <code>scenario</code> is either <code>2</code> (the default) or <code>3</code>, 
the error term variance-covariance matrix is orthogonalized via Cholesky decomposition. For <code>scenario = 2</code>, the Cholesky decomposition of the error term VCV matrix at time point <code>t</code> is used. 
<code>scenario = 3</code> is the variant used in Del Negro and Primiceri (2015). Here, the diagonal elements are set to their averages over time, whereas the off-diagonal elements are specific to time <code>t</code>. See the 
notes below for further information.</p>
</td></tr>
<tr><td><code id="impulse.responses_+3A_draw.plot">draw.plot</code></td>
<td>
<p>If <code>TRUE</code> (the default): Produces a plot showing the 5, 25, 50, 75 and 95 percent quantiles of the simulated impulse responses.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of two elements:
</p>
<table>
<tr><td><code>contemporaneous</code></td>
<td>
<p>Contemporaneous impulse responses (vector of simulation draws).</p>
</td></tr>
<tr><td><code>irf</code></td>
<td>
<p>Matrix of simulated impulse responses, where rows represent simulation draws, and columns represent the number of 
time periods after the shock (1 in first column, <code>nhor</code> in last column).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If <code>scenario</code> is set to either <code>2</code> or <code>3</code>, the Cholesky transform (transpose of <a href="base.html#topic+chol">chol</a>) is used to produce the orthogonal impulse responses. See Hamilton (1994), Section 11.4, and particularly Equation [11.4.22]. As discussed by Hamilton, the ordering of the system variables matters, and should be considered carefully. The magnitude of the shock (impulse) corresponds to one standard deviation of the error term.
</p>
<p>If <code>scenario = 1</code>, the function simply outputs the matrices of the model's moving average representation, see Equation [11.4.1] in 
Hamilton (1994). The scenario considered here may be unrealistic, in that an isolated shock may be unlikely. The magnitude of the shock (impulse)
corresponds to one unit of the error term.
</p>
<p>Further supporting information is available at <a href="https://sites.google.com/site/FK83research/code">https://sites.google.com/site/FK83research/code</a>.
</p>


<h3>Author(s)</h3>

<p>Fabian Krueger
</p>


<h3>References</h3>

<p>Hamilton, J.D. (1994): Time Series Analysis, Princeton University Press.
</p>
<p>Del Negro, M. and Primicerio, G.E. (2015). &lsquo;Time Varying Structural Vector Autoregressions and Monetary Policy: A Corrigendum&rsquo;, Review of Economic Studies 82, 1342-1345. Supplementary material available at 
<a href="http://restud.oxfordjournals.org/content/82/4/1342/suppl/DC1">http://restud.oxfordjournals.org/content/82/4/1342/suppl/DC1</a> (accessed: 2015-11-17).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

data(usmacro)
set.seed(5813)
# Run BVAR; save parameters
fit &lt;- bvar.sv.tvp(usmacro, save.parameters = TRUE)
# Impulse responses
impulse.responses(fit)


## End(Not run)
</code></pre>

<hr>
<h2 id='sim.var1.sv.tvp'>
Simulate from a VAR(1) with Stochastic Volatility and Time-Varying Parameters
</h2><span id='topic+sim.var1.sv.tvp'></span>

<h3>Description</h3>

<p>Simulate from a VAR(1) with Stochastic Volatility and Time-Varying Parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.var1.sv.tvp(B0 = NULL, A0 = NULL, Sig0 = NULL, Q = NULL, 
S = NULL, W = NULL, t = 500, init = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.var1.sv.tvp_+3A_b0">B0</code></td>
<td>
<p>Initial values of mean parameters: Matrix of dimension <code class="reqn">[M, M+1]</code>, where the first column holds the intercept vector and the other columns hold the matrix of first-order autoregressive coefficients. By default (NULL), <code>B0</code> corresponds to <code class="reqn">M = 2</code> uncorrelated zero-mean processes with moderate persistence (first-order autocorrelation of <code class="reqn">0.6</code>).</p>
</td></tr>
<tr><td><code id="sim.var1.sv.tvp_+3A_a0">A0</code></td>
<td>
<p>Initial values for (transformed) error correlation parameters: Vector of length <code class="reqn">0.5*M*(M-1)</code>. Defaults to a vector of zeros.</p>
</td></tr>
<tr><td><code id="sim.var1.sv.tvp_+3A_sig0">Sig0</code></td>
<td>
<p>Initial values for log error term volatility parameters: Vector of length <code class="reqn">M</code>. Defaults to a vector of zeros.</p>
</td></tr>
<tr><td><code id="sim.var1.sv.tvp_+3A_q">Q</code>, <code id="sim.var1.sv.tvp_+3A_s">S</code>, <code id="sim.var1.sv.tvp_+3A_w">W</code></td>
<td>
<p>Covariance matrices for the innovation terms in the time-varying parameters (<code class="reqn">B, A, Sig</code>). The matrices are symmetric, with dimensions equal to the number of elements in <code class="reqn">B, A</code> and <code class="reqn">Sig</code>, respectively. Default to diagonal matrices with very small terms (<code>1e-10</code>) on the main diagonal. This corresponds to essentially no time variation in the parameters and error term matrix elements.</p>
</td></tr>
<tr><td><code id="sim.var1.sv.tvp_+3A_t">t</code></td>
<td>
<p>Number of time periods to simulate.</p>
</td></tr>
<tr><td><code id="sim.var1.sv.tvp_+3A_init">init</code></td>
<td>
<p>Number of draws to initialize simulation (to decrease the impact of starting values).</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>data</code></td>
<td>
<p>Simulated data, with rows corresponding to time and columns corresponding to the <code class="reqn">M</code> system variables.</p>
</td></tr>
<tr><td><code>Beta</code></td>
<td>
<p>Array of dimension <code class="reqn">[M, M+1, t]</code>. Submatrix <code class="reqn">[,,l]</code> holds the parameter matrix for time period <code class="reqn">l</code>.</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Array of dimension <code class="reqn">[M, M, t]</code>. Submatrix <code class="reqn">[,,l]</code> holds the error term covariance matrix for period <code class="reqn">l</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The choice of &lsquo;reasonable&rsquo; values for the elements of <code>Q</code>, <code>S</code> and <code>W</code> requires some care. If the elements of these matrices are too large, parameter variation can easily become excessive. Too large elements of <code>Q</code> can lead the parameter matrix <code class="reqn">B</code> into regions which correspond to explosive processes. Too large elements in <code>S</code> and (especially) <code>W</code> may lead to excessive error term variances.</p>


<h3>Author(s)</h3>

<p>Fabian Krueger
</p>


<h3>References</h3>

<p>Primiceri, G.E. (2005): &lsquo;Time Varying Structural Vector Autoregressions and Monetary Policy&rsquo;, Review of Economic Studies 72, 821-852.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bvar.sv.tvp">bvar.sv.tvp</a></code> can be used to fit a model on data generated by <code><a href="#topic+sim.var1.sv.tvp">sim.var1.sv.tvp</a></code>. This can be a useful way to analyze the performance of the estimation methods.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Generate data from a model with moderate time variation in the parameters 
# and error term variances
set.seed(5813)
sim &lt;- sim.var1.sv.tvp(Q = 1e-5*diag(6), S = 1e-5*diag(1), W = 1e-5*diag(2))
# Plot both series
matplot(sim$data, type = "l")
# Plot AR(1) parameters of both equations
matplot(cbind(sim$Beta[1,2,], sim$Beta[2,3,]), type = "l")


## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
