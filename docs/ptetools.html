<!DOCTYPE html><html lang="en"><head><title>Help for package ptetools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ptetools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pte'><p>Panel Treatment Effects</p></a></li>
<li><a href='#aggte_obj'><p>Aggregated Treatment Effects Class</p></a></li>
<li><a href='#attgt_if'><p>Class for (g,t)-Specific Results with Influence Function</p></a></li>
<li><a href='#attgt_noif'><p>Class for (g,t)-Specific Results without Influence Function</p></a></li>
<li><a href='#attgt_pte_aggregations'><p>Aggregate Group-Time Average Treatment Effects</p></a></li>
<li><a href='#compute.pte'><p>Heavy-Lifting for pte Function</p></a></li>
<li><a href='#crit_val_checks'><p>Sanity Checks on Critical Values</p></a></li>
<li><a href='#did_attgt'><p>Difference-in-differences for ATT(g,t)</p></a></li>
<li><a href='#dose_obj'><p>Class for Continuous Treatments</p></a></li>
<li><a href='#get_agg_inf_func'><p>Recover Aggregated Influence Function</p></a></li>
<li><a href='#getSE'><p>Influence Functions to Standard Errors</p></a></li>
<li><a href='#ggpte'><p>ptetools Generic Plotting Function</p></a></li>
<li><a href='#ggpte_cont'><p>Generic Plots with a Continuous Treatment</p></a></li>
<li><a href='#group_time_att'><p>Class for Estimates across Groups and Time</p></a></li>
<li><a href='#gt_data_frame'><p>Convert Data to Usable Format</p></a></li>
<li><a href='#keep_all_pretreatment_subset'><p>Keep All Pre-Treatment Subset</p></a></li>
<li><a href='#keep_all_untreated_subset'><p>Keep All Untreated Subset</p></a></li>
<li><a href='#mboot2'><p>Multiplier Bootstrap</p></a></li>
<li><a href='#overall_weights'><p>Weights for Overall Aggregation</p></a></li>
<li><a href='#panel_empirical_bootstrap'><p>Panel Empirical Bootstrap</p></a></li>
<li><a href='#print.group_time_att'><p>print.group_time_att</p></a></li>
<li><a href='#print.pte_results'><p>print.pte_results</p></a></li>
<li><a href='#print.summary.dose_obj'><p>print.summary.dose_obj</p></a></li>
<li><a href='#print.summary.pte_results'><p>print.summary.pte_results</p></a></li>
<li><a href='#process_att_gt'><p>Process ATT(g,t) Results</p></a></li>
<li><a href='#process_dose_gt'><p>Process Results with a Continuous Treatment</p></a></li>
<li><a href='#pte_aggte'><p>Aggregates (g,t)-Specific Results</p></a></li>
<li><a href='#pte_attgt'><p>General ATT(g,t)</p></a></li>
<li><a href='#pte_default'><p>Default, General Function for Computing Treatment Effects with Panel Data</p></a></li>
<li><a href='#pte_dose_results'><p>Class for Continuous Treatment Results</p></a></li>
<li><a href='#pte_emp_boot'><p>Class for Empirical Bootstrap Results</p></a></li>
<li><a href='#pte_params'><p>PTE Parameters Class</p></a></li>
<li><a href='#pte_results'><p>Class for PTE Results</p></a></li>
<li><a href='#qott_pte_aggregations'><p>Aggregate Group-Time Quantile of the Treatment Effect</p></a></li>
<li><a href='#qtt_pte_aggregations'><p>Aggregate Group-Time Quantile Treatment Effects</p></a></li>
<li><a href='#setup_pte'><p>Generic Setup Function</p></a></li>
<li><a href='#setup_pte_basic'><p>Basic Setup Function</p></a></li>
<li><a href='#summary.aggte_obj'><p>Summary Aggregate Treatment Effect Parameter Objects</p></a></li>
<li><a href='#summary.dose_obj'><p>summary.dose_obj</p></a></li>
<li><a href='#summary.group_time_att'><p>summary.group_time_att</p></a></li>
<li><a href='#summary.pte_emp_boot'><p>summary.pte_emp_boot</p></a></li>
<li><a href='#summary.pte_results'><p>summary.pte_results</p></a></li>
<li><a href='#two_by_two_subset'><p>Two Period Two Group Subset</p></a></li>
<li><a href='#wif'><p>Compute Extra Terms in Influence Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Panel Treatment Effects Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bcallaway11/ptetools">https://github.com/bcallaway11/ptetools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bcallaway11/ptetools/issues">https://github.com/bcallaway11/ptetools/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Generic code for estimating treatment effects with panel data.  The idea is to break into separate steps organizing the data, looping over groups and time periods, computing group-time average treatment effects, and aggregating group-time average treatment effects.  Often, one is able to implement a new identification/estimation procedure by simply replacing the step on estimating group-time average treatment effects.  See several different examples of this approach in the package documentation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>BMisc (&ge; 1.4.7), Matrix, ggplot2, DRDID, tidyr, dplyr,
pbapply, splines2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), did</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-11 21:19:36 UTC; bmc43193</td>
</tr>
<tr>
<td>Author:</td>
<td>Brantly Callaway [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brantly Callaway &lt;brantly.callaway@uga.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-13 10:00:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='pte'>Panel Treatment Effects</h2><span id='topic+ptetools'></span><span id='topic+ptetools-package'></span><span id='topic+pte'></span>

<h3>Description</h3>

<p>Tools for estimating treatment effects with panel data.
</p>
<p>Main function for computing panel treatment effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pte(
  yname,
  gname,
  tname,
  idname,
  data,
  setup_pte_fun,
  subset_fun,
  attgt_fun,
  cband = TRUE,
  alp = 0.05,
  boot_type = "multiplier",
  weightsname = NULL,
  gt_type = "att",
  ret_quantile = NULL,
  global_fun = FALSE,
  time_period_fun = FALSE,
  group_fun = FALSE,
  process_dtt_gt_fun = process_dtt_gt,
  process_dose_gt_fun = process_dose_gt,
  biters = 100,
  cl = 1,
  call = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pte_+3A_yname">yname</code></td>
<td>
<p>Name of outcome in <code>data</code></p>
</td></tr>
<tr><td><code id="pte_+3A_gname">gname</code></td>
<td>
<p>Name of group in <code>data</code></p>
</td></tr>
<tr><td><code id="pte_+3A_tname">tname</code></td>
<td>
<p>Name of time period in <code>data</code></p>
</td></tr>
<tr><td><code id="pte_+3A_idname">idname</code></td>
<td>
<p>Name of id in <code>data</code></p>
</td></tr>
<tr><td><code id="pte_+3A_data">data</code></td>
<td>
<p>balanced panel data</p>
</td></tr>
<tr><td><code id="pte_+3A_setup_pte_fun">setup_pte_fun</code></td>
<td>
<p>This is a function that should take in <code>data</code>,
<code>yname</code> (the name of the outcome variable in <code>data</code>),
<code>gname</code> (the name of the group variable),
<code>idname</code> (the name of the id variable),
and possibly other arguments such as the significance level <code>alp</code>,
the number of bootstrap iterations <code>biters</code>, and how many clusters
for parallel computing in the bootstrap <code>cl</code>.  The key thing that
needs to be figured out in this function is which groups and time periods
ATT(g,t) should be computed in.  The function should
return a <code>pte_params</code> object which contains all of the parameters
passed into the function as well as <code>glist</code> and <code>tlist</code> which
should be ordered lists of groups and time periods for ATT(g,t) to be computed.
</p>
<p>This function provides also provides a good place for error handling related
to the types of data that can be handled.
</p>
<p>The <code>pte</code> package contains the function <code>setup_pte</code> that is
a lightweight function that basically just takes the data, omits
the never-treated group from <code>glist</code> but includes all other groups
and drops the first time period.  This works in cases where ATT would
be identified in the 2x2 case (i.e., where there are two time periods,
no units are treated in the first period and the identification strategy
&quot;works&quot; with access to a treated and untreated group and untreated
potential outcomes for both groups in the first period) &mdash; for example,
this approach works if DID is the identification strategy.</p>
</td></tr>
<tr><td><code id="pte_+3A_subset_fun">subset_fun</code></td>
<td>
<p>This is a function that should take in <code>data</code>,
<code>g</code> (for group), <code>tp</code> (for time period), and <code>...</code>
and be able to return the appropriate <code>data.frame</code> that can be used
by <code>attgt_fun</code> to produce ATT(g=g,t=tp).  The data frame should
be constructed using <code>gt_data_frame</code> in order to guarantee that
it has the appropriate columns that identify which group an observation
belongs to, etc.</p>
</td></tr>
<tr><td><code id="pte_+3A_attgt_fun">attgt_fun</code></td>
<td>
<p>This is a function that should work in the case where
there is a single group and the &quot;right&quot; number of time periods to
recover an estimate of the ATT.  For example, in the contest of
difference in differences, it would need to work for a single group,
find the appropriate comparison group (untreated units), find the right
time periods (pre- and post-treatment), and then recover an estimate
of ATT for that group.  It will be called over and over separately
by groups and by time periods to compute ATT(g,t)'s.
</p>
<p>The function needs to work in a very specific way.  It should take in the
arguments: <code>data</code>, <code>...</code>.  <code>data</code> should be constructed
using the function <code>gt_data_frame</code> which checks to make sure
that <code>data</code> has the correct columns defined.
<code>...</code> are additional arguments (such as
formulas for covariates) that <code>attgt_fun</code> needs.  From these arguments
<code>attgt_fun</code> must return a list with element <code>ATT</code> containing the
group-time average treatment effect for that group and that time period.
</p>
<p>If <code>attgt_fun</code> returns an influence function (which should be provided
in a list element named <code>inf_func</code>), then the code will use the
multiplier bootstrap to compute standard errors for group-time average
treatment effects, an overall treatment effect parameter, and a dynamic
treatment effect parameter (i.e., event study parameter).  If
<code>attgt_fun</code> does not return an influence function, then the same
objects will be computed using the empirical bootstrap.  This is usually
(perhaps substantially) easier to code, but also will usually be (perhaps
substantially) computationally slower.</p>
</td></tr>
<tr><td><code id="pte_+3A_cband">cband</code></td>
<td>
<p>whether or not to report a uniform (instead of pointwise)
confidence band (default is TRUE)</p>
</td></tr>
<tr><td><code id="pte_+3A_alp">alp</code></td>
<td>
<p>significance level; default is 0.05</p>
</td></tr>
<tr><td><code id="pte_+3A_boot_type">boot_type</code></td>
<td>
<p>should be one of &quot;multiplier&quot; (the default) or &quot;empirical&quot;.
The multiplier bootstrap is generally much faster, but <code>attgt_fun</code> needs
to provide an expression for the influence function (which could be challenging
to figure out).  If no influence function is provided, then the <code>pte</code>
package will use the empirical bootstrap no matter what the value of this
parameter.</p>
</td></tr>
<tr><td><code id="pte_+3A_weightsname">weightsname</code></td>
<td>
<p>The name of the column that contains sampling weights.
The default is NULL, in which case no sampling weights are used.</p>
</td></tr>
<tr><td><code id="pte_+3A_gt_type">gt_type</code></td>
<td>
<p>which type of group-time effects are computed.
The default is &quot;att&quot;.  Different estimation strategies can implement
their own choices for <code>gt_type</code></p>
</td></tr>
<tr><td><code id="pte_+3A_ret_quantile">ret_quantile</code></td>
<td>
<p>For functions that compute quantile treatment effects,
this is a specific quantile at which to report results, e.g.,
<code>ret_quantile = 0.5</code> will return that the qte at the median.</p>
</td></tr>
<tr><td><code id="pte_+3A_global_fun">global_fun</code></td>
<td>
<p>Logical indicating whether or not untreated potential
outcomes can be estimated in one shot, i.e., for all groups and time periods.
Main use case would be for one-shot imputation estimators.  Not supported yet.</p>
</td></tr>
<tr><td><code id="pte_+3A_time_period_fun">time_period_fun</code></td>
<td>
<p>Logical indicating whether or not untreated potential
outcomes can be estimated for all groups in the same time period.  Not supported yet.</p>
</td></tr>
<tr><td><code id="pte_+3A_group_fun">group_fun</code></td>
<td>
<p>Logical indicating whether or not untreated potential outcomes
can be estimated for all time periods for a single group.  Not supported yet.
These functions aim at reducing or eliminating running the same code multiple times.</p>
</td></tr>
<tr><td><code id="pte_+3A_process_dtt_gt_fun">process_dtt_gt_fun</code></td>
<td>
<p>An optional function to customize results when
the gt-specific function returns the distribution of treated and untreated
potential outcomes.  The default is <code>process_dtt_gt</code>, which is a function
provided by the package.  See that function for an example of what this function
should return.  This is unused is unused except in cases where
the results involve distributions.</p>
</td></tr>
<tr><td><code id="pte_+3A_process_dose_gt_fun">process_dose_gt_fun</code></td>
<td>
<p>An optional function to customize results when the gt-specific
function returns treatment effects that depend on dose (i.e., amount of the
treatment).  The default is <code>process_dose_gt</code>, which is a function provided
by the package.  See that function for an example of what this function should
return.  This is unused except in cases where the results involve doses.</p>
</td></tr>
<tr><td><code id="pte_+3A_biters">biters</code></td>
<td>
<p>number of bootstrap iterations; default is 100</p>
</td></tr>
<tr><td><code id="pte_+3A_cl">cl</code></td>
<td>
<p>number of clusters to be used when bootstrapping; default is 1</p>
</td></tr>
<tr><td><code id="pte_+3A_call">call</code></td>
<td>
<p>keeps track of through the <code>call</code> from external functions/packages</p>
</td></tr>
<tr><td><code id="pte_+3A_...">...</code></td>
<td>
<p>extra arguments that can be passed to create the correct subsets
of the data (depending on <code>subset_fun</code>), to estimate group time
average treatment effects (depending on <code>attgt_fun</code>), or to
aggregating treatment effects (particularly useful are <code>min_e</code>,
<code>max_e</code>, and <code>balance_e</code> arguments to event study aggregations)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pte_results</code> object
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Brantly Callaway <a href="mailto:brantly.callaway@uga.edu">brantly.callaway@uga.edu</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/bcallaway11/ptetools">https://github.com/bcallaway11/ptetools</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/bcallaway11/ptetools/issues">https://github.com/bcallaway11/ptetools/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># example using minimum wage data
# and difference-in-differences identification strategy
library(did)
data(mpdta)
did_res &lt;- pte(
  yname = "lemp",
  gname = "first.treat",
  tname = "year",
  idname = "countyreal",
  data = mpdta,
  setup_pte_fun = setup_pte,
  subset_fun = two_by_two_subset,
  attgt_fun = did_attgt,
  xformla = ~lpop
)

summary(did_res)
ggpte(did_res)

</code></pre>

<hr>
<h2 id='aggte_obj'>Aggregated Treatment Effects Class</h2><span id='topic+aggte_obj'></span>

<h3>Description</h3>

<p>Objects of this class hold results on aggregated
group-time average treatment effects.  This is derived from the AGGTEobj
class in the <code>did</code> package.
</p>
<p>An object for holding aggregated treatment effect parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggte_obj(
  overall.att = NULL,
  overall.se = NULL,
  type = "simple",
  egt = NULL,
  att.egt = NULL,
  se.egt = NULL,
  crit.val.egt = NULL,
  inf.function = NULL,
  min_e = NULL,
  max_e = NULL,
  balance_e = NULL,
  DIDparams = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggte_obj_+3A_overall.att">overall.att</code></td>
<td>
<p>The estimated overall ATT</p>
</td></tr>
<tr><td><code id="aggte_obj_+3A_overall.se">overall.se</code></td>
<td>
<p>Standard error for overall ATT</p>
</td></tr>
<tr><td><code id="aggte_obj_+3A_type">type</code></td>
<td>
<p>The type of aggregation to be done.  Default is &quot;overall&quot;.</p>
</td></tr>
<tr><td><code id="aggte_obj_+3A_egt">egt</code></td>
<td>
<p>Holds the length of exposure (for dynamic effects), the
group (for selective treatment timing), or the time period (for calendar
time effects)</p>
</td></tr>
<tr><td><code id="aggte_obj_+3A_att.egt">att.egt</code></td>
<td>
<p>The ATT specific to egt</p>
</td></tr>
<tr><td><code id="aggte_obj_+3A_se.egt">se.egt</code></td>
<td>
<p>The standard error specific to egt</p>
</td></tr>
<tr><td><code id="aggte_obj_+3A_crit.val.egt">crit.val.egt</code></td>
<td>
<p>A critical value for computing uniform confidence
bands for dynamic effects, selective treatment timing, or time period
effects.</p>
</td></tr>
<tr><td><code id="aggte_obj_+3A_inf.function">inf.function</code></td>
<td>
<p>The influence function of the chosen aggregated parameters</p>
</td></tr>
<tr><td><code id="aggte_obj_+3A_min_e">min_e</code></td>
<td>
<p>The minimum event time computed in the event study results.
This is useful when there are a huge number of pre-treatment periods.</p>
</td></tr>
<tr><td><code id="aggte_obj_+3A_max_e">max_e</code></td>
<td>
<p>The maximum event time computed in the event study results.
This is useful when there are a huge number of post-treatment periods.</p>
</td></tr>
<tr><td><code id="aggte_obj_+3A_balance_e">balance_e</code></td>
<td>
<p>Drops groups that do not have at least <code>balance_e</code> periods
of post-treatment data.  This keeps the composition of groups constant
across different event times in an event study.
Default is NULL, in which case this is ignored.</p>
</td></tr>
<tr><td><code id="aggte_obj_+3A_didparams">DIDparams</code></td>
<td>
<p>A DIDparams object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an aggte_obj
</p>

<hr>
<h2 id='attgt_if'>Class for (g,t)-Specific Results with Influence Function</h2><span id='topic+attgt_if'></span>

<h3>Description</h3>

<p>Class for holding group-time average treatment effects
along with their influence function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attgt_if(attgt, inf_func, extra_gt_returns = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attgt_if_+3A_attgt">attgt</code></td>
<td>
<p>group-time average treatment effect</p>
</td></tr>
<tr><td><code id="attgt_if_+3A_inf_func">inf_func</code></td>
<td>
<p>influence function</p>
</td></tr>
<tr><td><code id="attgt_if_+3A_extra_gt_returns">extra_gt_returns</code></td>
<td>
<p>A place to return anything extra from particular
group-time average treatment effect calculations.  For DID, this might
be something like propensity score estimates, regressions of untreated
potential outcomes on covariates.  For ife, this could be something
like the first step regression 2sls estimates.  This argument is also
potentially useful for debugging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>attgt_if</code> object
</p>

<hr>
<h2 id='attgt_noif'>Class for (g,t)-Specific Results without Influence Function</h2><span id='topic+attgt_noif'></span>

<h3>Description</h3>

<p>Class for holding returns from group-time specific estimates
in settings when an influence function is not returned
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attgt_noif(attgt, extra_gt_returns = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attgt_noif_+3A_attgt">attgt</code></td>
<td>
<p>group-time average treatment effect</p>
</td></tr>
<tr><td><code id="attgt_noif_+3A_extra_gt_returns">extra_gt_returns</code></td>
<td>
<p>A place to return anything extra from particular
group-time average treatment effect calculations.  For DID, this might
be something like propensity score estimates, regressions of untreated
potential outcomes on covariates.  For ife, this could be something
like the first step regression 2sls estimates.  This argument is also
potentially useful for debugging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>attgt_noif</code> object
</p>

<hr>
<h2 id='attgt_pte_aggregations'>Aggregate Group-Time Average Treatment Effects</h2><span id='topic+attgt_pte_aggregations'></span>

<h3>Description</h3>

<p>Aggregate group-time average treatment effects into
overall, group, and dynamic effects.  This function is only used
for (i) computing standard errors using the empirical bootstrap,
and (ii) combining distributions at the (g,t) level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attgt_pte_aggregations(attgt.list, ptep)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attgt_pte_aggregations_+3A_attgt.list">attgt.list</code></td>
<td>
<p>list of attgt results from <code>compute.pte</code></p>
</td></tr>
<tr><td><code id="attgt_pte_aggregations_+3A_ptep">ptep</code></td>
<td>
<p><code>pte_params</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pte_emp_boot</code> object
</p>

<hr>
<h2 id='compute.pte'>Heavy-Lifting for pte Function</h2><span id='topic+compute.pte'></span>

<h3>Description</h3>

<p>Function that actually computes panel treatment effects.
The difference relative to <code>compute.pte</code> is that this function
loops over time periods first (instead of groups) and tries to
estimate model for untreated potential outcomes jointly for all groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.pte(ptep, subset_fun, attgt_fun, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute.pte_+3A_ptep">ptep</code></td>
<td>
<p><code>pte_params</code> object</p>
</td></tr>
<tr><td><code id="compute.pte_+3A_subset_fun">subset_fun</code></td>
<td>
<p>This is a function that should take in <code>data</code>,
<code>g</code> (for group), <code>tp</code> (for time period), and <code>...</code>
and be able to return the appropriate <code>data.frame</code> that can be used
by <code>attgt_fun</code> to produce ATT(g=g,t=tp).  The data frame should
be constructed using <code>gt_data_frame</code> in order to guarantee that
it has the appropriate columns that identify which group an observation
belongs to, etc.</p>
</td></tr>
<tr><td><code id="compute.pte_+3A_attgt_fun">attgt_fun</code></td>
<td>
<p>This is a function that should work in the case where
there is a single group and the &quot;right&quot; number of time periods to
recover an estimate of the ATT.  For example, in the contest of
difference in differences, it would need to work for a single group,
find the appropriate comparison group (untreated units), find the right
time periods (pre- and post-treatment), and then recover an estimate
of ATT for that group.  It will be called over and over separately
by groups and by time periods to compute ATT(g,t)'s.
</p>
<p>The function needs to work in a very specific way.  It should take in the
arguments: <code>data</code>, <code>...</code>.  <code>data</code> should be constructed
using the function <code>gt_data_frame</code> which checks to make sure
that <code>data</code> has the correct columns defined.
<code>...</code> are additional arguments (such as
formulas for covariates) that <code>attgt_fun</code> needs.  From these arguments
<code>attgt_fun</code> must return a list with element <code>ATT</code> containing the
group-time average treatment effect for that group and that time period.
</p>
<p>If <code>attgt_fun</code> returns an influence function (which should be provided
in a list element named <code>inf_func</code>), then the code will use the
multiplier bootstrap to compute standard errors for group-time average
treatment effects, an overall treatment effect parameter, and a dynamic
treatment effect parameter (i.e., event study parameter).  If
<code>attgt_fun</code> does not return an influence function, then the same
objects will be computed using the empirical bootstrap.  This is usually
(perhaps substantially) easier to code, but also will usually be (perhaps
substantially) computationally slower.</p>
</td></tr>
<tr><td><code id="compute.pte_+3A_...">...</code></td>
<td>
<p>extra arguments that can be passed to create the correct subsets
of the data (depending on <code>subset_fun</code>), to estimate group time
average treatment effects (depending on <code>attgt_fun</code>), or to
aggregating treatment effects (particularly useful are <code>min_e</code>,
<code>max_e</code>, and <code>balance_e</code> arguments to event study aggregations)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following elements:
</p>

<ul>
<li> <p><code>attgt.list</code>: list of ATT(g,t) estimates
</p>
</li>
<li> <p><code>inffunc</code>: influence function matrix
</p>
</li>
<li> <p><code>extra_gt_returns</code>: list of extra returns from gt-specific calculationsons
</p>
</li></ul>


<hr>
<h2 id='crit_val_checks'>Sanity Checks on Critical Values</h2><span id='topic+crit_val_checks'></span>

<h3>Description</h3>

<p>A function to perform sanity checks and possibly adjust a
a critical value to form a uniform confidence band
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crit_val_checks(crit_val, alp = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crit_val_checks_+3A_crit_val">crit_val</code></td>
<td>
<p>the critical value</p>
</td></tr>
<tr><td><code id="crit_val_checks_+3A_alp">alp</code></td>
<td>
<p>the significance level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a (possibly adjusted) critical value
</p>

<hr>
<h2 id='did_attgt'>Difference-in-differences for ATT(g,t)</h2><span id='topic+did_attgt'></span>

<h3>Description</h3>

<p>Takes a data.frame and computes for a particular group g
and time period t and computes
an estimate of a group time average treatment effect
and a corresponding influence function using a difference in differences
approach.
</p>
<p>The code relies on <code>gt_data</code> having certain variables defined.
In particular, there should be an <code>id</code> column (individual identifier),
<code>D</code> (treated group identifier), <code>period</code> (time period), <code>name</code>
(equal to &quot;pre&quot; for pre-treatment periods and equal to &quot;post&quot; for post
treatment periods), <code>Y</code> (outcome).
</p>
<p>In our case, we call <code>two_by_two_subset</code> which sets up the
data to have this format before the call to <code>did_attgt</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>did_attgt(gt_data, xformula = ~1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="did_attgt_+3A_gt_data">gt_data</code></td>
<td>
<p>data that is &quot;local&quot; to a particular group-time average
treatment effect</p>
</td></tr>
<tr><td><code id="did_attgt_+3A_xformula">xformula</code></td>
<td>
<p>one-sided formula for covariates used in the propensity score
and outcome regression models</p>
</td></tr>
<tr><td><code id="did_attgt_+3A_...">...</code></td>
<td>
<p>extra function arguments; not used here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>attgt_if
</p>

<hr>
<h2 id='dose_obj'>Class for Continuous Treatments</h2><span id='topic+dose_obj'></span>

<h3>Description</h3>

<p>Holds results from computing dose-specific treatment effects
with a continuous treatment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dose_obj(
  dose,
  overall_att = NULL,
  overall_att_se = NULL,
  overall_att_inffunc = NULL,
  overall_acrt = NULL,
  overall_acrt_se = NULL,
  overall_acrt_inffunc = NULL,
  att.d = NULL,
  att.d_se = NULL,
  att.d_crit.val = NULL,
  att.d_inffunc = NULL,
  acrt.d = NULL,
  acrt.d_se = NULL,
  acrt.d_crit.val = NULL,
  acrt.d_inffunc = NULL,
  pte_params = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dose_obj_+3A_dose">dose</code></td>
<td>
<p>vector containing the values of the dose used in estimation</p>
</td></tr>
<tr><td><code id="dose_obj_+3A_overall_att">overall_att</code></td>
<td>
<p>estimate of the overall ATT, the mean of ATT(D) given D &gt; 0</p>
</td></tr>
<tr><td><code id="dose_obj_+3A_overall_att_se">overall_att_se</code></td>
<td>
<p>the standard error of the estimate of overall_att</p>
</td></tr>
<tr><td><code id="dose_obj_+3A_overall_att_inffunc">overall_att_inffunc</code></td>
<td>
<p>the influence function for estimating overall_att</p>
</td></tr>
<tr><td><code id="dose_obj_+3A_overall_acrt">overall_acrt</code></td>
<td>
<p>estimate of the overall ACRT, the mean of ACRT(D|D) given D &gt; 0</p>
</td></tr>
<tr><td><code id="dose_obj_+3A_overall_acrt_se">overall_acrt_se</code></td>
<td>
<p>the standard error for the estimate of overall_acrt</p>
</td></tr>
<tr><td><code id="dose_obj_+3A_overall_acrt_inffunc">overall_acrt_inffunc</code></td>
<td>
<p>the influence function for estimating overall_acrt</p>
</td></tr>
<tr><td><code id="dose_obj_+3A_att.d">att.d</code></td>
<td>
<p>estimates of ATT(d) for each value of <code>dose</code></p>
</td></tr>
<tr><td><code id="dose_obj_+3A_att.d_se">att.d_se</code></td>
<td>
<p>standard error of ATT(d) for each value of <code>dose</code></p>
</td></tr>
<tr><td><code id="dose_obj_+3A_att.d_crit.val">att.d_crit.val</code></td>
<td>
<p>critical value to produce pointwise or uniform confidence
interval for ATT(d)</p>
</td></tr>
<tr><td><code id="dose_obj_+3A_att.d_inffunc">att.d_inffunc</code></td>
<td>
<p>matrix containing the influence function from estimating
ATT(d)</p>
</td></tr>
<tr><td><code id="dose_obj_+3A_acrt.d">acrt.d</code></td>
<td>
<p>estimates of ACRT(d) for each value of <code>dose</code></p>
</td></tr>
<tr><td><code id="dose_obj_+3A_acrt.d_se">acrt.d_se</code></td>
<td>
<p>standard error of ACRT(d) for each value of <code>dose</code></p>
</td></tr>
<tr><td><code id="dose_obj_+3A_acrt.d_crit.val">acrt.d_crit.val</code></td>
<td>
<p>critical value to produce pointwise or uniform confidence
interval for ACRT(d)</p>
</td></tr>
<tr><td><code id="dose_obj_+3A_acrt.d_inffunc">acrt.d_inffunc</code></td>
<td>
<p>matrix containing the influence function from estimating
ACRT(d)</p>
</td></tr>
<tr><td><code id="dose_obj_+3A_pte_params">pte_params</code></td>
<td>
<p>a pte_params object containing other parameters passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>dose_obj</code> object
</p>

<hr>
<h2 id='get_agg_inf_func'>Recover Aggregated Influence Function</h2><span id='topic+get_agg_inf_func'></span>

<h3>Description</h3>

<p>Recover Aggregated Influence Function
</p>
<p>This is a generic internal function for combining influence
functions across ATT(g,t)'s to return an influence function for
various aggregated treatment effect parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_agg_inf_func(att, inffunc1, whichones, weights.agg, wif = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_agg_inf_func_+3A_att">att</code></td>
<td>
<p>vector of group-time average treatment effects</p>
</td></tr>
<tr><td><code id="get_agg_inf_func_+3A_inffunc1">inffunc1</code></td>
<td>
<p>influence function for all group-time average treatment effects
(matrix)</p>
</td></tr>
<tr><td><code id="get_agg_inf_func_+3A_whichones">whichones</code></td>
<td>
<p>which elements of att will be used to compute the aggregated
treatment effect parameter</p>
</td></tr>
<tr><td><code id="get_agg_inf_func_+3A_weights.agg">weights.agg</code></td>
<td>
<p>the weights to apply to each element of att(whichones);
should have the same dimension as att(whichones)</p>
</td></tr>
<tr><td><code id="get_agg_inf_func_+3A_wif">wif</code></td>
<td>
<p>extra influence function term coming from estimating the weights;
should be n x k matrix where k is dimension of whichones</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nx1 influence function
</p>

<hr>
<h2 id='getSE'>Influence Functions to Standard Errors</h2><span id='topic+getSE'></span>

<h3>Description</h3>

<p>Function to take an nx1 influence function and return
a standard error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSE(thisinffunc, bstrap = TRUE, biters = 100, alp = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSE_+3A_thisinffunc">thisinffunc</code></td>
<td>
<p>An influence function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar standard error
</p>

<hr>
<h2 id='ggpte'>ptetools Generic Plotting Function</h2><span id='topic+ggpte'></span>

<h3>Description</h3>

<p>The main plotting function in the <code>ptetools</code> package.  It plots
event studies.  This
function is generic enough that most packages that otherwise use
the <code>ptetools</code> package can call it directly to plot an event study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggpte(pte_results)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggpte_+3A_pte_results">pte_results</code></td>
<td>
<p>A <code>pte_results</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>

<hr>
<h2 id='ggpte_cont'>Generic Plots with a Continuous Treatment</h2><span id='topic+ggpte_cont'></span>

<h3>Description</h3>

<p>Plots dose-specific results in applications with a continuous treatment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggpte_cont(dose_obj, type = "att")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggpte_cont_+3A_dose_obj">dose_obj</code></td>
<td>
<p>a <code>dose_obj</code> that holds results with a continuous treatment</p>
</td></tr>
<tr><td><code id="ggpte_cont_+3A_type">type</code></td>
<td>
<p>whether to plot ATT(d) or ACRT(d), defaults to <code>att</code> for
plotting ATT(d).  For ACRT(d), use &quot;acrt&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>

<hr>
<h2 id='group_time_att'>Class for Estimates across Groups and Time</h2><span id='topic+group_time_att'></span>

<h3>Description</h3>

<p>Class that holds causal effect parameter estimates across
timing groups and time periods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_time_att(
  group,
  time.period,
  att,
  V_analytical,
  se,
  crit_val,
  inf_func,
  n,
  W,
  Wpval,
  cband,
  alp,
  ptep,
  extra_gt_returns
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_time_att_+3A_group">group</code></td>
<td>
<p>numeric vector of groups for ATT(g,t)</p>
</td></tr>
<tr><td><code id="group_time_att_+3A_time.period">time.period</code></td>
<td>
<p>numeric vector of time periods for ATT(g,t)</p>
</td></tr>
<tr><td><code id="group_time_att_+3A_att">att</code></td>
<td>
<p>numeric vector containing the value of ATT(g,t) for
corresponding group and time period</p>
</td></tr>
<tr><td><code id="group_time_att_+3A_v_analytical">V_analytical</code></td>
<td>
<p>analytical asymptotic variance matrix for ATT(g,t)'s</p>
</td></tr>
<tr><td><code id="group_time_att_+3A_se">se</code></td>
<td>
<p>numeric vector of standard errors</p>
</td></tr>
<tr><td><code id="group_time_att_+3A_crit_val">crit_val</code></td>
<td>
<p>critical value (usually a critical value for conducting
uniform inference)</p>
</td></tr>
<tr><td><code id="group_time_att_+3A_inf_func">inf_func</code></td>
<td>
<p>matrix of influence function</p>
</td></tr>
<tr><td><code id="group_time_att_+3A_n">n</code></td>
<td>
<p>number of unique individuals</p>
</td></tr>
<tr><td><code id="group_time_att_+3A_w">W</code></td>
<td>
<p>Wald statistic for ATT(g,t) version of pre-test of parallel trends
assumption</p>
</td></tr>
<tr><td><code id="group_time_att_+3A_wpval">Wpval</code></td>
<td>
<p>p-value for Wald pre-test of ATT(g,t) version of parallel
trends assumption</p>
</td></tr>
<tr><td><code id="group_time_att_+3A_cband">cband</code></td>
<td>
<p>logical indicating whether or not to report a confidence band</p>
</td></tr>
<tr><td><code id="group_time_att_+3A_alp">alp</code></td>
<td>
<p>significance level</p>
</td></tr>
<tr><td><code id="group_time_att_+3A_ptep">ptep</code></td>
<td>
<p><code>pte_params</code> object</p>
</td></tr>
<tr><td><code id="group_time_att_+3A_extra_gt_returns">extra_gt_returns</code></td>
<td>
<p>list containing extra returns at the group-time level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>group_time_att</code>
</p>

<hr>
<h2 id='gt_data_frame'>Convert Data to Usable Format</h2><span id='topic+gt_data_frame'></span>

<h3>Description</h3>

<p>Checks and converts data to satisfy criteria to be used in internal
<code>ptetools</code> functions.  In particular,
the function takes in a data.frame, checks if it has the right
columns to be used to calculate a group-time average treatment effect,
and sets the class of the data.frame to include <code>gt_data_frame</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gt_data_frame(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gt_data_frame_+3A_data">data</code></td>
<td>
<p>data that will be checked to see if has right format for
computing group-time average treatment effects</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gt_data_frame</code> object
</p>

<hr>
<h2 id='keep_all_pretreatment_subset'>Keep All Pre-Treatment Subset</h2><span id='topic+keep_all_pretreatment_subset'></span>

<h3>Description</h3>

<p>A function that takes an original data set and keeps all
data for all groups that are not-yet-treated by period <code>tp</code> as well
as for group <code>g</code>.
</p>
<p>In particular, this keeps more data than functions like <code>two_by_two</code>
subset that use a fixed base period.
</p>
<p>A main use case for this function is the interactive fixed effects approach
proposed in Callaway and Tsyawo (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keep_all_pretreatment_subset(data, g, tp, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keep_all_pretreatment_subset_+3A_data">data</code></td>
<td>
<p>the full dataset</p>
</td></tr>
<tr><td><code id="keep_all_pretreatment_subset_+3A_g">g</code></td>
<td>
<p>the current group</p>
</td></tr>
<tr><td><code id="keep_all_pretreatment_subset_+3A_tp">tp</code></td>
<td>
<p>the current time period</p>
</td></tr>
<tr><td><code id="keep_all_pretreatment_subset_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list that contains the following elements:
</p>

<ul>
<li> <p><code>gt_data</code>: a <code>gt_data_frame</code> object that contains the
correct subset of data
</p>
</li>
<li> <p><code>n1</code>: the number of observations in this subset
</p>
</li>
<li> <p><code>disidx</code>: a vector of the correct ids for this subset
</p>
</li></ul>


<hr>
<h2 id='keep_all_untreated_subset'>Keep All Untreated Subset</h2><span id='topic+keep_all_untreated_subset'></span>

<h3>Description</h3>

<p>A function that takes an original data set and keeps all
pre-treatment data for all groups.  For group g, it also includes data
for the current period.
</p>
<p>Also, note that if <code>tp</code> is still a pre-treatment period for group g,
then periods after <code>tp</code> will also be dropped for group g.  This is a
design choice and is useful especially for estimating placebo
group-time average treatment effects in pre-treatment periods.
</p>
<p>A main use case for this function is to compute ATT(g,t)'s using a global
estimation strategy such as imputation in Gardner (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keep_all_untreated_subset(data, g, tp, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keep_all_untreated_subset_+3A_data">data</code></td>
<td>
<p>the full dataset</p>
</td></tr>
<tr><td><code id="keep_all_untreated_subset_+3A_g">g</code></td>
<td>
<p>the current group</p>
</td></tr>
<tr><td><code id="keep_all_untreated_subset_+3A_tp">tp</code></td>
<td>
<p>the current time period</p>
</td></tr>
<tr><td><code id="keep_all_untreated_subset_+3A_...">...</code></td>
<td>
<p>extra arguments to get the subset correct</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list that contains the following elements:
</p>

<ul>
<li> <p><code>gt_data</code>: a <code>gt_data_frame</code> object that contains the
correct subset of data
</p>
</li>
<li> <p><code>n1</code>: the number of observations in this subset
</p>
</li>
<li> <p><code>disidx</code>: a vector of the correct ids for this subset
</p>
</li></ul>


<hr>
<h2 id='mboot2'>Multiplier Bootstrap</h2><span id='topic+mboot2'></span>

<h3>Description</h3>

<p>Function for using multiplier bootstrap to conduct
inference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mboot2(inffunc, biters = 1000, alp = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mboot2_+3A_inffunc">inffunc</code></td>
<td>
<p>influence function matrix</p>
</td></tr>
<tr><td><code id="mboot2_+3A_biters">biters</code></td>
<td>
<p>number of bootstrap iterations; default is 100</p>
</td></tr>
<tr><td><code id="mboot2_+3A_alp">alp</code></td>
<td>
<p>significance level; default is 0.05</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements:
</p>

<ul>
<li> <p><code>boot_se</code>: bootstrap standard errors
</p>
</li>
<li> <p><code>crit_val</code>: critical value for uniform confidence bands
</p>
</li></ul>


<hr>
<h2 id='overall_weights'>Weights for Overall Aggregation</h2><span id='topic+overall_weights'></span>

<h3>Description</h3>

<p>A function that returns weights on (g,t)'s to deliver overall
(averaged across groups and time periods) treatment effect parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overall_weights(attgt, balance_e = NULL, min_e = -Inf, max_e = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="overall_weights_+3A_attgt">attgt</code></td>
<td>
<p>A group_time_att object to be aggregated</p>
</td></tr>
<tr><td><code id="overall_weights_+3A_balance_e">balance_e</code></td>
<td>
<p>Drops groups that do not have at least <code>balance_e</code> periods
of post-treatment data.  This keeps the composition of groups constant
across different event times in an event study.
Default is NULL, in which case this is ignored.</p>
</td></tr>
<tr><td><code id="overall_weights_+3A_min_e">min_e</code></td>
<td>
<p>The minimum event time computed in the event study results.
This is useful when there are a huge number of pre-treatment periods.</p>
</td></tr>
<tr><td><code id="overall_weights_+3A_max_e">max_e</code></td>
<td>
<p>The maximum event time computed in the event study results.
This is useful when there are a huge number of post-treatment periods.</p>
</td></tr>
<tr><td><code id="overall_weights_+3A_...">...</code></td>
<td>
<p>extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame containing columns:
</p>

<ul>
<li><p> group: the group
</p>
</li>
<li><p> time.period: the time period
</p>
</li>
<li><p> overall_weight: the weight
</p>
</li></ul>


<hr>
<h2 id='panel_empirical_bootstrap'>Panel Empirical Bootstrap</h2><span id='topic+panel_empirical_bootstrap'></span>

<h3>Description</h3>

<p>Computes empirical bootstrap pointwise standard errors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel_empirical_bootstrap(
  attgt.list,
  ptep,
  setup_pte_fun,
  subset_fun,
  attgt_fun,
  extra_gt_returns,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel_empirical_bootstrap_+3A_attgt.list">attgt.list</code></td>
<td>
<p>list of attgt results from <code>compute.pte</code></p>
</td></tr>
<tr><td><code id="panel_empirical_bootstrap_+3A_ptep">ptep</code></td>
<td>
<p><code>pte_params</code> object</p>
</td></tr>
<tr><td><code id="panel_empirical_bootstrap_+3A_setup_pte_fun">setup_pte_fun</code></td>
<td>
<p>This is a function that should take in <code>data</code>,
<code>yname</code> (the name of the outcome variable in <code>data</code>),
<code>gname</code> (the name of the group variable),
<code>idname</code> (the name of the id variable),
and possibly other arguments such as the significance level <code>alp</code>,
the number of bootstrap iterations <code>biters</code>, and how many clusters
for parallel computing in the bootstrap <code>cl</code>.  The key thing that
needs to be figured out in this function is which groups and time periods
ATT(g,t) should be computed in.  The function should
return a <code>pte_params</code> object which contains all of the parameters
passed into the function as well as <code>glist</code> and <code>tlist</code> which
should be ordered lists of groups and time periods for ATT(g,t) to be computed.
</p>
<p>This function provides also provides a good place for error handling related
to the types of data that can be handled.
</p>
<p>The <code>pte</code> package contains the function <code>setup_pte</code> that is
a lightweight function that basically just takes the data, omits
the never-treated group from <code>glist</code> but includes all other groups
and drops the first time period.  This works in cases where ATT would
be identified in the 2x2 case (i.e., where there are two time periods,
no units are treated in the first period and the identification strategy
&quot;works&quot; with access to a treated and untreated group and untreated
potential outcomes for both groups in the first period) &mdash; for example,
this approach works if DID is the identification strategy.</p>
</td></tr>
<tr><td><code id="panel_empirical_bootstrap_+3A_subset_fun">subset_fun</code></td>
<td>
<p>This is a function that should take in <code>data</code>,
<code>g</code> (for group), <code>tp</code> (for time period), and <code>...</code>
and be able to return the appropriate <code>data.frame</code> that can be used
by <code>attgt_fun</code> to produce ATT(g=g,t=tp).  The data frame should
be constructed using <code>gt_data_frame</code> in order to guarantee that
it has the appropriate columns that identify which group an observation
belongs to, etc.</p>
</td></tr>
<tr><td><code id="panel_empirical_bootstrap_+3A_attgt_fun">attgt_fun</code></td>
<td>
<p>This is a function that should work in the case where
there is a single group and the &quot;right&quot; number of time periods to
recover an estimate of the ATT.  For example, in the contest of
difference in differences, it would need to work for a single group,
find the appropriate comparison group (untreated units), find the right
time periods (pre- and post-treatment), and then recover an estimate
of ATT for that group.  It will be called over and over separately
by groups and by time periods to compute ATT(g,t)'s.
</p>
<p>The function needs to work in a very specific way.  It should take in the
arguments: <code>data</code>, <code>...</code>.  <code>data</code> should be constructed
using the function <code>gt_data_frame</code> which checks to make sure
that <code>data</code> has the correct columns defined.
<code>...</code> are additional arguments (such as
formulas for covariates) that <code>attgt_fun</code> needs.  From these arguments
<code>attgt_fun</code> must return a list with element <code>ATT</code> containing the
group-time average treatment effect for that group and that time period.
</p>
<p>If <code>attgt_fun</code> returns an influence function (which should be provided
in a list element named <code>inf_func</code>), then the code will use the
multiplier bootstrap to compute standard errors for group-time average
treatment effects, an overall treatment effect parameter, and a dynamic
treatment effect parameter (i.e., event study parameter).  If
<code>attgt_fun</code> does not return an influence function, then the same
objects will be computed using the empirical bootstrap.  This is usually
(perhaps substantially) easier to code, but also will usually be (perhaps
substantially) computationally slower.</p>
</td></tr>
<tr><td><code id="panel_empirical_bootstrap_+3A_extra_gt_returns">extra_gt_returns</code></td>
<td>
<p>A place to return anything extra from particular
group-time average treatment effect calculations.  For DID, this might
be something like propensity score estimates, regressions of untreated
potential outcomes on covariates.  For ife, this could be something
like the first step regression 2sls estimates.  This argument is also
potentially useful for debugging.</p>
</td></tr>
<tr><td><code id="panel_empirical_bootstrap_+3A_...">...</code></td>
<td>
<p>extra arguments that can be passed to create the correct subsets
of the data (depending on <code>subset_fun</code>), to estimate group time
average treatment effects (depending on <code>attgt_fun</code>), or to
aggregating treatment effects (particularly useful are <code>min_e</code>,
<code>max_e</code>, and <code>balance_e</code> arguments to event study aggregations)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pte_emp_boot</code> object
</p>

<hr>
<h2 id='print.group_time_att'>print.group_time_att</h2><span id='topic+print.group_time_att'></span>

<h3>Description</h3>

<p>prints value of a <code>group_time_att</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'group_time_att'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.group_time_att_+3A_x">x</code></td>
<td>
<p>a <code>group_time_att</code> object</p>
</td></tr>
<tr><td><code id="print.group_time_att_+3A_...">...</code></td>
<td>
<p>extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Prints a summary of the <code>group_time_att</code> object
</p>

<hr>
<h2 id='print.pte_results'>print.pte_results</h2><span id='topic+print.pte_results'></span>

<h3>Description</h3>

<p>prints value of a <code>pte_results</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pte_results'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.pte_results_+3A_x">x</code></td>
<td>
<p>a <code>pte_results</code> object</p>
</td></tr>
<tr><td><code id="print.pte_results_+3A_...">...</code></td>
<td>
<p>extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Prints a summary of the <code>pte_results</code> object
</p>

<hr>
<h2 id='print.summary.dose_obj'>print.summary.dose_obj</h2><span id='topic+print.summary.dose_obj'></span>

<h3>Description</h3>

<p>prints a summary of a <code>dose_obj</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.dose_obj'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.dose_obj_+3A_x">x</code></td>
<td>
<p>a list containing the summary of a <code>dose_obj</code> object</p>
</td></tr>
<tr><td><code id="print.summary.dose_obj_+3A_...">...</code></td>
<td>
<p>extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Prints a summary of a <code>dose_obj</code> object.
</p>

<hr>
<h2 id='print.summary.pte_results'>print.summary.pte_results</h2><span id='topic+print.summary.pte_results'></span>

<h3>Description</h3>

<p>prints value of a <code>summary.pte_results</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.pte_results'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.pte_results_+3A_x">x</code></td>
<td>
<p>a <code>summary.pte_results</code> object</p>
</td></tr>
<tr><td><code id="print.summary.pte_results_+3A_...">...</code></td>
<td>
<p>extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Prints a summary of the <code>summary.pte_results</code> object
</p>

<hr>
<h2 id='process_att_gt'>Process ATT(g,t) Results</h2><span id='topic+process_att_gt'></span>

<h3>Description</h3>

<p>Process ATT(g,t) results when influence function is available
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_att_gt(att_gt_results, ptep)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_att_gt_+3A_att_gt_results">att_gt_results</code></td>
<td>
<p>ATT(g,t)'s</p>
</td></tr>
<tr><td><code id="process_att_gt_+3A_ptep">ptep</code></td>
<td>
<p><code>pte_params</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>group_time_att</code> object
</p>

<hr>
<h2 id='process_dose_gt'>Process Results with a Continuous Treatment</h2><span id='topic+process_dose_gt'></span>

<h3>Description</h3>

<p>After computing results for each group and time period,
<code>process_dose_gt</code> combines/averages them into overall effects and/or
dose specific effects.  This is generic code that can be used
from different ways of estimating causal effects across different
timing groups and periods in a previous step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_dose_gt(gt_results, ptep, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_dose_gt_+3A_gt_results">gt_results</code></td>
<td>
<p>list of group-time specific results</p>
</td></tr>
<tr><td><code id="process_dose_gt_+3A_ptep">ptep</code></td>
<td>
<p><code>pte_params</code> object</p>
</td></tr>
<tr><td><code id="process_dose_gt_+3A_...">...</code></td>
<td>
<p>extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>dose_obj</code> object
</p>

<hr>
<h2 id='pte_aggte'>Aggregates (g,t)-Specific Results</h2><span id='topic+pte_aggte'></span>

<h3>Description</h3>

<p>This is a slight edit of the aggte function from the <code>did</code> package.
Currently, it only provides aggregations for &quot;overall&quot; treatment effects
and event studies.  It also will provide the weights directly which is
currently used for constructing aggregations based on distributions.
The other difference is that, <code>pte_aggte</code> provides inference results
where the only randomness is coming from the outcomes (not from the group
assignment nor from the covariates).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pte_aggte(
  attgt,
  type = "overall",
  balance_e = NULL,
  min_e = -Inf,
  max_e = Inf,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pte_aggte_+3A_attgt">attgt</code></td>
<td>
<p>A group_time_att object to be aggregated</p>
</td></tr>
<tr><td><code id="pte_aggte_+3A_type">type</code></td>
<td>
<p>The type of aggregation to be done.  Default is &quot;overall&quot;.</p>
</td></tr>
<tr><td><code id="pte_aggte_+3A_balance_e">balance_e</code></td>
<td>
<p>Drops groups that do not have at least <code>balance_e</code> periods
of post-treatment data.  This keeps the composition of groups constant
across different event times in an event study.
Default is NULL, in which case this is ignored.</p>
</td></tr>
<tr><td><code id="pte_aggte_+3A_min_e">min_e</code></td>
<td>
<p>The minimum event time computed in the event study results.
This is useful when there are a huge number of pre-treatment periods.</p>
</td></tr>
<tr><td><code id="pte_aggte_+3A_max_e">max_e</code></td>
<td>
<p>The maximum event time computed in the event study results.
This is useful when there are a huge number of post-treatment periods.</p>
</td></tr>
<tr><td><code id="pte_aggte_+3A_...">...</code></td>
<td>
<p>extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>aggte_obj</code>
</p>

<hr>
<h2 id='pte_attgt'>General ATT(g,t)</h2><span id='topic+pte_attgt'></span>

<h3>Description</h3>

<p><code>pte_attgt</code> takes a &quot;local&quot; data.frame and computes
an estimate of a group time average treatment effect
and a corresponding influence function.  This function generalizes
a number of existing methods and underlies the <code>pte_default</code> function.
</p>
<p>The code relies on <code>gt_data</code> having certain variables defined.
In particular, there should be an <code>id</code> column (individual identifier),
<code>G</code> (group identifier), <code>period</code> (time period), <code>name</code>
(equal to &quot;pre&quot; for pre-treatment periods and equal to &quot;post&quot; for post
treatment periods), <code>Y</code> (outcome).
</p>
<p>In our case, we call <code>two_by_two_subset</code> which sets up the
data to have this format before the call to <code>pte_attgt</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pte_attgt(
  gt_data,
  xformula,
  d_outcome = FALSE,
  d_covs_formula = ~-1,
  lagged_outcome_cov = FALSE,
  est_method = "dr",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pte_attgt_+3A_gt_data">gt_data</code></td>
<td>
<p>data that is &quot;local&quot; to a particular group-time average
treatment effect</p>
</td></tr>
<tr><td><code id="pte_attgt_+3A_xformula">xformula</code></td>
<td>
<p>one-sided formula for covariates used in the propensity score
and outcome regression models</p>
</td></tr>
<tr><td><code id="pte_attgt_+3A_d_outcome">d_outcome</code></td>
<td>
<p>Whether or not to take the first difference of the outcome.
The default is FALSE.  To use difference-in-differences, set this to be TRUE.</p>
</td></tr>
<tr><td><code id="pte_attgt_+3A_d_covs_formula">d_covs_formula</code></td>
<td>
<p>A formula for time varying covariates to enter the
first estimation step models.  The default is not to include any, and, hence,
to only include pre-treatment covariates.</p>
</td></tr>
<tr><td><code id="pte_attgt_+3A_lagged_outcome_cov">lagged_outcome_cov</code></td>
<td>
<p>Whether to include the lagged outcome as a covariate.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="pte_attgt_+3A_est_method">est_method</code></td>
<td>
<p>Which type of estimation method to use. Default is &quot;dr&quot; for
doubly robust.  The other option is &quot;reg&quot; for regression adjustment.</p>
</td></tr>
<tr><td><code id="pte_attgt_+3A_...">...</code></td>
<td>
<p>extra function arguments; not used here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>attgt_if
</p>

<hr>
<h2 id='pte_default'>Default, General Function for Computing Treatment Effects with Panel Data</h2><span id='topic+pte_default'></span>

<h3>Description</h3>

<p>This is a generic/example wrapper for a call to the <code>pte</code> function.
</p>
<p>This function provides access to difference-in-differences and unconfoundedness
based identification/estimation strategies given (i) panel data and (ii)
staggered treatment adoption
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pte_default(
  yname,
  gname,
  tname,
  idname,
  data,
  xformula = ~1,
  d_outcome = FALSE,
  d_covs_formula = ~-1,
  lagged_outcome_cov = FALSE,
  est_method = "dr",
  anticipation = 0,
  base_period = "varying",
  control_group = "notyettreated",
  weightsname = NULL,
  cband = TRUE,
  alp = 0.05,
  boot_type = "multiplier",
  biters = 100,
  cl = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pte_default_+3A_yname">yname</code></td>
<td>
<p>Name of outcome in <code>data</code></p>
</td></tr>
<tr><td><code id="pte_default_+3A_gname">gname</code></td>
<td>
<p>Name of group in <code>data</code></p>
</td></tr>
<tr><td><code id="pte_default_+3A_tname">tname</code></td>
<td>
<p>Name of time period in <code>data</code></p>
</td></tr>
<tr><td><code id="pte_default_+3A_idname">idname</code></td>
<td>
<p>Name of id in <code>data</code></p>
</td></tr>
<tr><td><code id="pte_default_+3A_data">data</code></td>
<td>
<p>balanced panel data</p>
</td></tr>
<tr><td><code id="pte_default_+3A_xformula">xformula</code></td>
<td>
<p>one-sided formula for covariates used in the propensity score
and outcome regression models</p>
</td></tr>
<tr><td><code id="pte_default_+3A_d_outcome">d_outcome</code></td>
<td>
<p>Whether or not to take the first difference of the outcome.
The default is FALSE.  To use difference-in-differences, set this to be TRUE.</p>
</td></tr>
<tr><td><code id="pte_default_+3A_d_covs_formula">d_covs_formula</code></td>
<td>
<p>A formula for time varying covariates to enter the
first estimation step models.  The default is not to include any, and, hence,
to only include pre-treatment covariates.</p>
</td></tr>
<tr><td><code id="pte_default_+3A_lagged_outcome_cov">lagged_outcome_cov</code></td>
<td>
<p>Whether to include the lagged outcome as a covariate.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="pte_default_+3A_est_method">est_method</code></td>
<td>
<p>Which type of estimation method to use. Default is &quot;dr&quot; for
doubly robust.  The other option is &quot;reg&quot; for regression adjustment.</p>
</td></tr>
<tr><td><code id="pte_default_+3A_anticipation">anticipation</code></td>
<td>
<p>how many periods before the treatment actually takes
place that it can have an effect on outcomes</p>
</td></tr>
<tr><td><code id="pte_default_+3A_base_period">base_period</code></td>
<td>
<p>The type of base period to use.  This only affects
the numeric value of results in pre-treatment periods.  Results in
post-treatment periods are not affected by this choice.  The default
is &quot;varying&quot;, where the base period will &quot;back up&quot; to the immediately
preceding period in pre-treatment periods.  The other option is &quot;universal&quot;
where the base period is fixed in pre-treatment periods to be the period
right before the treatment starts.  &quot;Universal&quot; is commonly used in
difference-in-differences applications, but can be unnatural for other
identification strategies.</p>
</td></tr>
<tr><td><code id="pte_default_+3A_control_group">control_group</code></td>
<td>
<p>Which group is used as the comparison group.
The default choice is &quot;notyettreated&quot;, but
different estimation strategies can implement their own choices
for the control group</p>
</td></tr>
<tr><td><code id="pte_default_+3A_weightsname">weightsname</code></td>
<td>
<p>The name of the column that contains sampling weights.
The default is NULL, in which case no sampling weights are used.</p>
</td></tr>
<tr><td><code id="pte_default_+3A_cband">cband</code></td>
<td>
<p>whether or not to report a uniform (instead of pointwise)
confidence band (default is TRUE)</p>
</td></tr>
<tr><td><code id="pte_default_+3A_alp">alp</code></td>
<td>
<p>significance level; default is 0.05</p>
</td></tr>
<tr><td><code id="pte_default_+3A_boot_type">boot_type</code></td>
<td>
<p>should be one of &quot;multiplier&quot; (the default) or &quot;empirical&quot;.
The multiplier bootstrap is generally much faster, but <code>attgt_fun</code> needs
to provide an expression for the influence function (which could be challenging
to figure out).  If no influence function is provided, then the <code>pte</code>
package will use the empirical bootstrap no matter what the value of this
parameter.</p>
</td></tr>
<tr><td><code id="pte_default_+3A_biters">biters</code></td>
<td>
<p>number of bootstrap iterations; default is 100</p>
</td></tr>
<tr><td><code id="pte_default_+3A_cl">cl</code></td>
<td>
<p>number of clusters to be used when bootstrapping; default is 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pte_results</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example using minimum wage data
# and a lagged outcome unconfoundedness strategy
library(did)
data(mpdta)
lou_res &lt;- pte_default(
  yname = "lemp",
  gname = "first.treat",
  tname = "year",
  idname = "countyreal",
  data = mpdta,
  xformula = ~lpop,
  d_outcome = FALSE,
  d_covs_formula = ~lpop,
  lagged_outcome_cov = TRUE
)

summary(lou_res)
ggpte(lou_res)

</code></pre>

<hr>
<h2 id='pte_dose_results'>Class for Continuous Treatment Results</h2><span id='topic+pte_dose_results'></span>

<h3>Description</h3>

<p>Class for holding results with a continuous treatment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pte_dose_results(att_gt, dose, att_d = NULL, acrt_d = NULL, ptep)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pte_dose_results_+3A_att_gt">att_gt</code></td>
<td>
<p>attgt results</p>
</td></tr>
<tr><td><code id="pte_dose_results_+3A_dose">dose</code></td>
<td>
<p>vector of doses</p>
</td></tr>
<tr><td><code id="pte_dose_results_+3A_att_d">att_d</code></td>
<td>
<p>ATT(d) for each value of <code>dose</code></p>
</td></tr>
<tr><td><code id="pte_dose_results_+3A_acrt_d">acrt_d</code></td>
<td>
<p>ACRT(d) for each value of <code>dose</code></p>
</td></tr>
<tr><td><code id="pte_dose_results_+3A_ptep">ptep</code></td>
<td>
<p>a <code>pte_params</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>pte_dose_results</code> object
</p>

<hr>
<h2 id='pte_emp_boot'>Class for Empirical Bootstrap Results</h2><span id='topic+pte_emp_boot'></span>

<h3>Description</h3>

<p>Class for holding <code>ptetools</code> empirical bootstrap results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pte_emp_boot(
  attgt_results,
  overall_results,
  group_results,
  dyn_results,
  overall_weights = NULL,
  dyn_weights = NULL,
  group_weights = NULL,
  extra_gt_returns = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pte_emp_boot_+3A_attgt_results">attgt_results</code></td>
<td>
<p><code>data.frame</code> holding attgt results</p>
</td></tr>
<tr><td><code id="pte_emp_boot_+3A_overall_results">overall_results</code></td>
<td>
<p><code>data.frame</code> holding overall results</p>
</td></tr>
<tr><td><code id="pte_emp_boot_+3A_group_results">group_results</code></td>
<td>
<p><code>data.frame</code> holding group results</p>
</td></tr>
<tr><td><code id="pte_emp_boot_+3A_dyn_results">dyn_results</code></td>
<td>
<p><code>data.frame</code> holding dynamic results</p>
</td></tr>
<tr><td><code id="pte_emp_boot_+3A_overall_weights">overall_weights</code></td>
<td>
<p>vector containing weights on underlying ATT(g,t)
for overall treatment effect parameter</p>
</td></tr>
<tr><td><code id="pte_emp_boot_+3A_dyn_weights">dyn_weights</code></td>
<td>
<p>list containing weights on underlying ATT(g,t)
for each value of <code>e</code> corresponding to the dynamic treatment
effect parameters.</p>
</td></tr>
<tr><td><code id="pte_emp_boot_+3A_group_weights">group_weights</code></td>
<td>
<p>list containing weights on underlying ATT(g,t)
corresponding to deliver averaged group-specific treatment effects</p>
</td></tr>
<tr><td><code id="pte_emp_boot_+3A_extra_gt_returns">extra_gt_returns</code></td>
<td>
<p>A place to return anything extra from particular
group-time average treatment effect calculations.  For DID, this might
be something like propensity score estimates, regressions of untreated
potential outcomes on covariates.  For ife, this could be something
like the first step regression 2sls estimates.  This argument is also
potentially useful for debugging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>pte_emp_boot</code> object
</p>

<hr>
<h2 id='pte_params'>PTE Parameters Class</h2><span id='topic+pte_params'></span>

<h3>Description</h3>

<p>Class that contains pte parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pte_params(
  yname,
  gname,
  tname,
  idname,
  data,
  glist,
  tlist,
  cband,
  alp,
  boot_type,
  anticipation = NULL,
  base_period = NULL,
  weightsname = NULL,
  control_group = "notyettreated",
  gt_type = "att",
  ret_quantile = 0.5,
  global_fun = FALSE,
  time_period_fun = FALSE,
  group_fun = FALSE,
  biters,
  cl,
  call = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pte_params_+3A_yname">yname</code></td>
<td>
<p>Name of outcome in <code>data</code></p>
</td></tr>
<tr><td><code id="pte_params_+3A_gname">gname</code></td>
<td>
<p>Name of group in <code>data</code></p>
</td></tr>
<tr><td><code id="pte_params_+3A_tname">tname</code></td>
<td>
<p>Name of time period in <code>data</code></p>
</td></tr>
<tr><td><code id="pte_params_+3A_idname">idname</code></td>
<td>
<p>Name of id in <code>data</code></p>
</td></tr>
<tr><td><code id="pte_params_+3A_data">data</code></td>
<td>
<p>balanced panel data</p>
</td></tr>
<tr><td><code id="pte_params_+3A_glist">glist</code></td>
<td>
<p>list of groups to create group-time average treatment effects
for</p>
</td></tr>
<tr><td><code id="pte_params_+3A_tlist">tlist</code></td>
<td>
<p>list of time periods to create group-time average treatment
effects for</p>
</td></tr>
<tr><td><code id="pte_params_+3A_cband">cband</code></td>
<td>
<p>whether or not to report a uniform (instead of pointwise)
confidence band (default is TRUE)</p>
</td></tr>
<tr><td><code id="pte_params_+3A_alp">alp</code></td>
<td>
<p>significance level; default is 0.05</p>
</td></tr>
<tr><td><code id="pte_params_+3A_boot_type">boot_type</code></td>
<td>
<p>which type of bootstrap to use</p>
</td></tr>
<tr><td><code id="pte_params_+3A_anticipation">anticipation</code></td>
<td>
<p>how many periods before the treatment actually takes
place that it can have an effect on outcomes</p>
</td></tr>
<tr><td><code id="pte_params_+3A_base_period">base_period</code></td>
<td>
<p>The type of base period to use.  This only affects
the numeric value of results in pre-treatment periods.  Results in
post-treatment periods are not affected by this choice.  The default
is &quot;varying&quot;, where the base period will &quot;back up&quot; to the immediately
preceding period in pre-treatment periods.  The other option is &quot;universal&quot;
where the base period is fixed in pre-treatment periods to be the period
right before the treatment starts.  &quot;Universal&quot; is commonly used in
difference-in-differences applications, but can be unnatural for other
identification strategies.</p>
</td></tr>
<tr><td><code id="pte_params_+3A_weightsname">weightsname</code></td>
<td>
<p>The name of the column that contains sampling weights.
The default is NULL, in which case no sampling weights are used.</p>
</td></tr>
<tr><td><code id="pte_params_+3A_control_group">control_group</code></td>
<td>
<p>Which group is used as the comparison group.
The default choice is &quot;notyettreated&quot;, but
different estimation strategies can implement their own choices
for the control group</p>
</td></tr>
<tr><td><code id="pte_params_+3A_gt_type">gt_type</code></td>
<td>
<p>which type of group-time effects are computed.
The default is &quot;att&quot;.  Different estimation strategies can implement
their own choices for <code>gt_type</code></p>
</td></tr>
<tr><td><code id="pte_params_+3A_ret_quantile">ret_quantile</code></td>
<td>
<p>For functions that compute quantile treatment effects,
this is a specific quantile at which to report results, e.g.,
<code>ret_quantile = 0.5</code> will return that the qte at the median.</p>
</td></tr>
<tr><td><code id="pte_params_+3A_global_fun">global_fun</code></td>
<td>
<p>Logical indicating whether or not untreated potential
outcomes can be estimated in one shot, i.e., for all groups and time periods.
Main use case would be for one-shot imputation estimators.  Not supported yet.</p>
</td></tr>
<tr><td><code id="pte_params_+3A_time_period_fun">time_period_fun</code></td>
<td>
<p>Logical indicating whether or not untreated potential
outcomes can be estimated for all groups in the same time period.  Not supported yet.</p>
</td></tr>
<tr><td><code id="pte_params_+3A_group_fun">group_fun</code></td>
<td>
<p>Logical indicating whether or not untreated potential outcomes
can be estimated for all time periods for a single group.  Not supported yet.
These functions aim at reducing or eliminating running the same code multiple times.</p>
</td></tr>
<tr><td><code id="pte_params_+3A_biters">biters</code></td>
<td>
<p>number of bootstrap iterations; default is 100</p>
</td></tr>
<tr><td><code id="pte_params_+3A_cl">cl</code></td>
<td>
<p>number of clusters to be used when bootstrapping; default is 1</p>
</td></tr>
<tr><td><code id="pte_params_+3A_call">call</code></td>
<td>
<p>keeps track of through the <code>call</code> from external functions/packages</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pte_params</code> object
</p>

<hr>
<h2 id='pte_results'>Class for PTE Results</h2><span id='topic+pte_results'></span>

<h3>Description</h3>

<p>Class for holding overall results with a staggered treatment,
including an overall ATT and an event study
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pte_results(att_gt, overall_att, event_study, ptep)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pte_results_+3A_att_gt">att_gt</code></td>
<td>
<p>attgt results</p>
</td></tr>
<tr><td><code id="pte_results_+3A_overall_att">overall_att</code></td>
<td>
<p>overall_att results</p>
</td></tr>
<tr><td><code id="pte_results_+3A_event_study">event_study</code></td>
<td>
<p>event_study results</p>
</td></tr>
<tr><td><code id="pte_results_+3A_ptep">ptep</code></td>
<td>
<p><code>pte_params</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>pte_results</code> object
</p>

<hr>
<h2 id='qott_pte_aggregations'>Aggregate Group-Time Quantile of the Treatment Effect</h2><span id='topic+qott_pte_aggregations'></span>

<h3>Description</h3>

<p>Aggregate group-time distribution of the treatment effect into
overall, group, and dynamic effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qott_pte_aggregations(attgt.list, ptep, extra_gt_returns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qott_pte_aggregations_+3A_attgt.list">attgt.list</code></td>
<td>
<p>list of attgt results from <code>compute.pte</code></p>
</td></tr>
<tr><td><code id="qott_pte_aggregations_+3A_ptep">ptep</code></td>
<td>
<p><code>pte_params</code> object</p>
</td></tr>
<tr><td><code id="qott_pte_aggregations_+3A_extra_gt_returns">extra_gt_returns</code></td>
<td>
<p>A place to return anything extra from particular
group-time average treatment effect calculations.  For DID, this might
be something like propensity score estimates, regressions of untreated
potential outcomes on covariates.  For ife, this could be something
like the first step regression 2sls estimates.  This argument is also
potentially useful for debugging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pte_emp_boot</code> object
</p>

<hr>
<h2 id='qtt_pte_aggregations'>Aggregate Group-Time Quantile Treatment Effects</h2><span id='topic+qtt_pte_aggregations'></span>

<h3>Description</h3>

<p>Aggregate group-time distributions into qtt versions of
overall, group, and dynamic effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtt_pte_aggregations(attgt.list, ptep, extra_gt_returns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qtt_pte_aggregations_+3A_attgt.list">attgt.list</code></td>
<td>
<p>list of attgt results from <code>compute.pte</code></p>
</td></tr>
<tr><td><code id="qtt_pte_aggregations_+3A_ptep">ptep</code></td>
<td>
<p><code>pte_params</code> object</p>
</td></tr>
<tr><td><code id="qtt_pte_aggregations_+3A_extra_gt_returns">extra_gt_returns</code></td>
<td>
<p>A place to return anything extra from particular
group-time average treatment effect calculations.  For DID, this might
be something like propensity score estimates, regressions of untreated
potential outcomes on covariates.  For ife, this could be something
like the first step regression 2sls estimates.  This argument is also
potentially useful for debugging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pte_emp_boot</code> object
</p>

<hr>
<h2 id='setup_pte'>Generic Setup Function</h2><span id='topic+setup_pte'></span>

<h3>Description</h3>

<p>This is a function for how to setup
the data to be used in the <code>ptetools</code> package.
</p>
<p>The <code>setup_pte</code> function builds on <code>setup_pte_basic</code> and
attempts to provide a general purpose function (with error handling)
to arrange the data in a way that can be processed by <code>subset_fun</code>
and <code>attgt_fun</code> in the next steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_pte(
  yname,
  gname,
  tname,
  idname,
  data,
  required_pre_periods = 1,
  anticipation = 0,
  base_period = "varying",
  cband = TRUE,
  alp = 0.05,
  boot_type = "multiplier",
  weightsname = NULL,
  gt_type = "att",
  ret_quantile = 0.5,
  biters = 100,
  cl = 1,
  call = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setup_pte_+3A_yname">yname</code></td>
<td>
<p>Name of outcome in <code>data</code></p>
</td></tr>
<tr><td><code id="setup_pte_+3A_gname">gname</code></td>
<td>
<p>Name of group in <code>data</code></p>
</td></tr>
<tr><td><code id="setup_pte_+3A_tname">tname</code></td>
<td>
<p>Name of time period in <code>data</code></p>
</td></tr>
<tr><td><code id="setup_pte_+3A_idname">idname</code></td>
<td>
<p>Name of id in <code>data</code></p>
</td></tr>
<tr><td><code id="setup_pte_+3A_data">data</code></td>
<td>
<p>balanced panel data</p>
</td></tr>
<tr><td><code id="setup_pte_+3A_required_pre_periods">required_pre_periods</code></td>
<td>
<p>The number of required pre-treatment periods to implement
the estimation strategy.  Default is 1.</p>
</td></tr>
<tr><td><code id="setup_pte_+3A_anticipation">anticipation</code></td>
<td>
<p>how many periods before the treatment actually takes
place that it can have an effect on outcomes</p>
</td></tr>
<tr><td><code id="setup_pte_+3A_base_period">base_period</code></td>
<td>
<p>The type of base period to use.  This only affects
the numeric value of results in pre-treatment periods.  Results in
post-treatment periods are not affected by this choice.  The default
is &quot;varying&quot;, where the base period will &quot;back up&quot; to the immediately
preceding period in pre-treatment periods.  The other option is &quot;universal&quot;
where the base period is fixed in pre-treatment periods to be the period
right before the treatment starts.  &quot;Universal&quot; is commonly used in
difference-in-differences applications, but can be unnatural for other
identification strategies.</p>
</td></tr>
<tr><td><code id="setup_pte_+3A_cband">cband</code></td>
<td>
<p>whether or not to report a uniform (instead of pointwise)
confidence band (default is TRUE)</p>
</td></tr>
<tr><td><code id="setup_pte_+3A_alp">alp</code></td>
<td>
<p>significance level; default is 0.05</p>
</td></tr>
<tr><td><code id="setup_pte_+3A_boot_type">boot_type</code></td>
<td>
<p>which type of bootstrap to use</p>
</td></tr>
<tr><td><code id="setup_pte_+3A_weightsname">weightsname</code></td>
<td>
<p>The name of the column that contains sampling weights.
The default is NULL, in which case no sampling weights are used.</p>
</td></tr>
<tr><td><code id="setup_pte_+3A_gt_type">gt_type</code></td>
<td>
<p>which type of group-time effects are computed.
The default is &quot;att&quot;.  Different estimation strategies can implement
their own choices for <code>gt_type</code></p>
</td></tr>
<tr><td><code id="setup_pte_+3A_ret_quantile">ret_quantile</code></td>
<td>
<p>For functions that compute quantile treatment effects,
this is a specific quantile at which to report results, e.g.,
<code>ret_quantile = 0.5</code> will return that the qte at the median.</p>
</td></tr>
<tr><td><code id="setup_pte_+3A_biters">biters</code></td>
<td>
<p>number of bootstrap iterations; default is 100</p>
</td></tr>
<tr><td><code id="setup_pte_+3A_cl">cl</code></td>
<td>
<p>number of clusters to be used when bootstrapping; default is 1</p>
</td></tr>
<tr><td><code id="setup_pte_+3A_call">call</code></td>
<td>
<p>keeps track of through the <code>call</code> from external functions/packages</p>
</td></tr>
<tr><td><code id="setup_pte_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pte_params</code> object
</p>

<hr>
<h2 id='setup_pte_basic'>Basic Setup Function</h2><span id='topic+setup_pte_basic'></span>

<h3>Description</h3>

<p>This is a lightweight (example) function for how to setup
the data to be used in the <code>ptetools</code> package.
</p>
<p><code>setup_pte_basic</code> takes in information about the structure of <code>data</code>
and returns a <code>pte_params</code> object.  The key piece of information
that is computed by this function is the list of groups and list of
time periods where ATT(g,t) should be computed.  In particular, this function
omits the never-treated group but includes all other groups and drops the first
time period.  This setup is basically geared towards the 2x2 case &mdash;
i.e., where ATT could be identified with two periods, a treated and
untreated group, and the first period being pre-treatment for both groups.
This is the relevant case for DID, but is also relevant for other cases as well.
However, for example, if more pre-treatment periods were needed, then this
function should be replaced by something else.
</p>
<p>For code that is written with the idea of being easy-to-use by other
researchers, this is a good place to do some error handling / checking
that the data is in the correct format, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_pte_basic(
  yname,
  gname,
  tname,
  idname,
  data,
  cband = TRUE,
  alp = 0.05,
  boot_type = "multiplier",
  gt_type = "att",
  ret_quantile = 0.5,
  biters = 100,
  cl = 1,
  call = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setup_pte_basic_+3A_yname">yname</code></td>
<td>
<p>Name of outcome in <code>data</code></p>
</td></tr>
<tr><td><code id="setup_pte_basic_+3A_gname">gname</code></td>
<td>
<p>Name of group in <code>data</code></p>
</td></tr>
<tr><td><code id="setup_pte_basic_+3A_tname">tname</code></td>
<td>
<p>Name of time period in <code>data</code></p>
</td></tr>
<tr><td><code id="setup_pte_basic_+3A_idname">idname</code></td>
<td>
<p>Name of id in <code>data</code></p>
</td></tr>
<tr><td><code id="setup_pte_basic_+3A_data">data</code></td>
<td>
<p>balanced panel data</p>
</td></tr>
<tr><td><code id="setup_pte_basic_+3A_cband">cband</code></td>
<td>
<p>whether or not to report a uniform (instead of pointwise)
confidence band (default is TRUE)</p>
</td></tr>
<tr><td><code id="setup_pte_basic_+3A_alp">alp</code></td>
<td>
<p>significance level; default is 0.05</p>
</td></tr>
<tr><td><code id="setup_pte_basic_+3A_boot_type">boot_type</code></td>
<td>
<p>which type of bootstrap to use</p>
</td></tr>
<tr><td><code id="setup_pte_basic_+3A_gt_type">gt_type</code></td>
<td>
<p>which type of group-time effects are computed.
The default is &quot;att&quot;.  Different estimation strategies can implement
their own choices for <code>gt_type</code></p>
</td></tr>
<tr><td><code id="setup_pte_basic_+3A_ret_quantile">ret_quantile</code></td>
<td>
<p>For functions that compute quantile treatment effects,
this is a specific quantile at which to report results, e.g.,
<code>ret_quantile = 0.5</code> will return that the qte at the median.</p>
</td></tr>
<tr><td><code id="setup_pte_basic_+3A_biters">biters</code></td>
<td>
<p>number of bootstrap iterations; default is 100</p>
</td></tr>
<tr><td><code id="setup_pte_basic_+3A_cl">cl</code></td>
<td>
<p>number of clusters to be used when bootstrapping; default is 1</p>
</td></tr>
<tr><td><code id="setup_pte_basic_+3A_call">call</code></td>
<td>
<p>keeps track of through the <code>call</code> from external functions/packages</p>
</td></tr>
<tr><td><code id="setup_pte_basic_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pte_params</code> object
</p>

<hr>
<h2 id='summary.aggte_obj'>Summary Aggregate Treatment Effect Parameter Objects</h2><span id='topic+summary.aggte_obj'></span>

<h3>Description</h3>

<p>A function to summarize aggregated treatment effect parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aggte_obj'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.aggte_obj_+3A_object">object</code></td>
<td>
<p>an <code>aggte_obj</code> object</p>
</td></tr>
<tr><td><code id="summary.aggte_obj_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.  This function prints a summary of an
aggregated treatment effect parameter object.
</p>

<hr>
<h2 id='summary.dose_obj'>summary.dose_obj</h2><span id='topic+summary.dose_obj'></span>

<h3>Description</h3>

<p>summarizes a <code>dose_obj</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dose_obj'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.dose_obj_+3A_object">object</code></td>
<td>
<p>an <code>dose_obj</code> object</p>
</td></tr>
<tr><td><code id="summary.dose_obj_+3A_...">...</code></td>
<td>
<p>extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the summary of a <code>dose_obj</code> object:
</p>

<ul>
<li> <p><code>dose</code>: vector of dose values
</p>
</li>
<li> <p><code>overall_att</code>: overall ATT estimate
</p>
</li>
<li> <p><code>overall_att_se</code>: standard error of overall ATT estimate
</p>
</li>
<li> <p><code>overall_acrt</code>: overall ACRT estimate
</p>
</li>
<li> <p><code>overall_acrt_se</code>: standard error of overall ACRT estimate
</p>
</li>
<li> <p><code>att.d</code>: vector of ATT(d) estimates
</p>
</li>
<li> <p><code>att.d_se</code>: vector of standard errors for ATT(d) estimates
</p>
</li>
<li> <p><code>att.d_crit.val</code>: critical value for pointwise or uniform confidence interval for ATT(d)
</p>
</li>
<li> <p><code>acrt.d</code>: vector of ACRT(d) estimates
</p>
</li>
<li> <p><code>acrt.d_se</code>: vector of standard errors for ACRT(d) estimates
</p>
</li>
<li> <p><code>acrt.d_crit.val</code>: critical value for pointwise or uniform confidence interval for ACRT(d)
</p>
</li>
<li> <p><code>alp</code>: significance level
</p>
</li>
<li> <p><code>cband</code>: logical indicating whether to use simultaneous or pointwise confidence intervals
</p>
</li>
<li> <p><code>bstrap</code>: logical indicating whether to use bootstrap for critical value
</p>
</li></ul>


<hr>
<h2 id='summary.group_time_att'>summary.group_time_att</h2><span id='topic+summary.group_time_att'></span>

<h3>Description</h3>

<p>prints a summary of a <code>group_time_att</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'group_time_att'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.group_time_att_+3A_object">object</code></td>
<td>
<p>an <code>group_time_att</code> object</p>
</td></tr>
<tr><td><code id="summary.group_time_att_+3A_...">...</code></td>
<td>
<p>extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Prints a summary of the <code>group_time_att</code> object
</p>

<hr>
<h2 id='summary.pte_emp_boot'>summary.pte_emp_boot</h2><span id='topic+summary.pte_emp_boot'></span>

<h3>Description</h3>

<p>Summary for <code>pte_emp_boot</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pte_emp_boot'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.pte_emp_boot_+3A_object">object</code></td>
<td>
<p>a <code>pte_emp_boot</code> object</p>
</td></tr>
<tr><td><code id="summary.pte_emp_boot_+3A_...">...</code></td>
<td>
<p>additional function arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.pte_results</code> object
</p>

<hr>
<h2 id='summary.pte_results'>summary.pte_results</h2><span id='topic+summary.pte_results'></span>

<h3>Description</h3>

<p>A function to summarize <code>ptetools</code> results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pte_results'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.pte_results_+3A_object">object</code></td>
<td>
<p>an <code>pte_results</code> object</p>
</td></tr>
<tr><td><code id="summary.pte_results_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>summary.pte_results</code> object
</p>

<hr>
<h2 id='two_by_two_subset'>Two Period Two Group Subset</h2><span id='topic+two_by_two_subset'></span>

<h3>Description</h3>

<p>A function for computing a 2x2 subset of original data.
This is the subset with post treatment periods separately for the
treated group and comparison group and pre-treatment periods in the period
immediately before the treated group became treated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>two_by_two_subset(
  data,
  g,
  tp,
  control_group = "notyettreated",
  anticipation = 0,
  base_period = "varying",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="two_by_two_subset_+3A_data">data</code></td>
<td>
<p>the full dataset</p>
</td></tr>
<tr><td><code id="two_by_two_subset_+3A_g">g</code></td>
<td>
<p>the current group</p>
</td></tr>
<tr><td><code id="two_by_two_subset_+3A_tp">tp</code></td>
<td>
<p>the current time period</p>
</td></tr>
<tr><td><code id="two_by_two_subset_+3A_control_group">control_group</code></td>
<td>
<p>whether to use &quot;notyettreated&quot; (default) or
&quot;nevertreated&quot;</p>
</td></tr>
<tr><td><code id="two_by_two_subset_+3A_anticipation">anticipation</code></td>
<td>
<p>the number of periods of anticipation (i.e., number
of periods before the treatment happens where the treatment can &quot;already&quot;
affect the outcome)</p>
</td></tr>
<tr><td><code id="two_by_two_subset_+3A_base_period">base_period</code></td>
<td>
<p>The type of base period to use.  This only affects
the numeric value of results in pre-treatment periods.  Results in
post-treatment periods are not affected by this choice.  The default
is &quot;varying&quot;, where the base period will &quot;back up&quot; to the immediately
preceding period in pre-treatment periods.  The other option is &quot;universal&quot;
where the base period is fixed in pre-treatment periods to be the period
right before the treatment starts.  &quot;Universal&quot; is commonly used in
difference-in-differences applications, but can be unnatural for other
identification strategies.</p>
</td></tr>
<tr><td><code id="two_by_two_subset_+3A_...">...</code></td>
<td>
<p>extra arguments to get the subset correct</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list that contains the following elements:
</p>

<ul>
<li> <p><code>gt_data</code>: a <code>gt_data_frame</code> object that contains the
correct subset of data
</p>
</li>
<li> <p><code>n1</code>: the number of observations in this subset
</p>
</li>
<li> <p><code>disidx</code>: a vector of the correct ids for this subset
</p>
</li></ul>


<hr>
<h2 id='wif'>Compute Extra Terms in Influence Functions</h2><span id='topic+wif'></span>

<h3>Description</h3>

<p>A function to compute the extra term that shows up in the
influence function for aggregated treatment effect parameters
due to estimating the weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wif(keepers, pg, weights.ind, G, group)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wif_+3A_keepers">keepers</code></td>
<td>
<p>a vector of indices for which group-time average
treatment effects are used to compute a particular aggregated parameter</p>
</td></tr>
<tr><td><code id="wif_+3A_pg">pg</code></td>
<td>
<p>a vector with same length as total number of group-time average
treatment effects that contains the probability of being in particular group</p>
</td></tr>
<tr><td><code id="wif_+3A_weights.ind">weights.ind</code></td>
<td>
<p>additional sampling weights (nx1)</p>
</td></tr>
<tr><td><code id="wif_+3A_g">G</code></td>
<td>
<p>vector containing which group a unit belongs to (nx1)</p>
</td></tr>
<tr><td><code id="wif_+3A_group">group</code></td>
<td>
<p>vector of groups</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nxk influence function matrix
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
