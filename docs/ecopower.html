<!DOCTYPE html><html><head><title>Help for package ecopower</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ecopower}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#crayweed'><p>Crayweed dataset</p></a></li>
<li><a href='#effect_alt.manyglm'><p>Specify multivariate effect sizes</p></a></li>
<li><a href='#effect_null.manyglm'><p>Specify null effects for multivariate abundance data</p></a></li>
<li><a href='#equivtest.cord'><p>Multivariate equivalence testing</p></a></li>
<li><a href='#extend.cord'><p>Simulate or extend multivariate abundance data</p></a></li>
<li><a href='#fish'><p>Fish dataset</p></a></li>
<li><a href='#powersim.cord'><p>Provide power estimates for multivariate abundance models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Power Estimates and Equivalence Testing for Multivariate Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates power by simulation for multivariate
    abundance data to be used for sample size estimates. Multivariate
    equivalence testing by simulation from a Gaussian copula model.
    The package also provides functions for parameterising multivariate effect
    sizes and simulating multivariate abundance data jointly. The discrete
    Gaussian copula approach is described in
    Popovic et al. (2018) &lt;<a href="https://doi.org/10.1016%2Fj.jmva.2017.12.002">doi:10.1016/j.jmva.2017.12.002</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, mvabund, ecoCopula, stats</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL (&ge; 2.1)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, ggplot2, RColorBrewer</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-24 14:41:55 UTC; USER</td>
</tr>
<tr>
<td>Author:</td>
<td>Ben Maslen [aut],
  Michelle Lim [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michelle Lim &lt;michelle.lim@unsw.edu.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-24 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='crayweed'>Crayweed dataset</h2><span id='topic+crayweed'></span>

<h3>Description</h3>

<p>Dataset of fish abundances recorded at crayweed reference and restored sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(crayweed)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"list"</code> containing:
</p>

<dl>
<dt>abund</dt><dd><p>A matrix with 27 observations of abundance of 34 fish species.</p>
</dd>
<dt>X</dt><dd><p>A data frame with treatment and time variables.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The matrix <code>abund</code> has the following species abundances:
</p>

<ul>
<li><p> Abudefduf.sp.
</p>
</li>
<li><p> Acanthopagrus.australis
</p>
</li>
<li><p> Acanthurus.nigrofuscus
</p>
</li>
<li><p> Achoerodus.viridis
</p>
</li>
<li><p> Aplodactylus.lophodon
</p>
</li>
<li><p> Atypichthys.strigatus
</p>
</li>
<li><p> Cheilodactylus.fuscus
</p>
</li>
<li><p> Chromis.hypsilepis
</p>
</li>
<li><p> Crinodus.lophodon
</p>
</li>
<li><p> Girella.elevata
</p>
</li>
<li><p> Girella.tricuspidata
</p>
</li>
<li><p> Hypoplectrodes.maccullochi
</p>
</li>
<li><p> Needle.fish.unidentified
</p>
</li>
<li><p> Notolabrus.gymnogenis
</p>
</li>
<li><p> Odax.cyanomelas
</p>
</li>
<li><p> Olisthops.cyanomelas
</p>
</li>
<li><p> Ophthalmolepis.lineolatus
</p>
</li>
<li><p> Parma.microlepis
</p>
</li>
<li><p> Parma.unifasciata
</p>
</li>
<li><p> Pempheris.compressa
</p>
</li>
<li><p> Pempheris.multiradiata
</p>
</li>
<li><p> Pictilabrus.laticlavius
</p>
</li>
<li><p> Prionurus.microlepidotus
</p>
</li>
<li><p> Pseudocaranx.dentex
</p>
</li>
<li><p> Pseudojuloides.elongatus
</p>
</li>
<li><p> Pseudolabrus.gymnogenis
</p>
</li>
<li><p> Sardinops.neopilchardus
</p>
</li>
<li><p> Scorpis.lineolatus
</p>
</li>
<li><p> Seriola.lalandi
</p>
</li>
<li><p> Sphyraena.obtusata
</p>
</li>
<li><p> Tetractenos.hamiltoni
</p>
</li>
<li><p> Trachinops.taeniatus
</p>
</li>
<li><p> Trachurus.novaezelandiae
</p>
</li>
<li><p> Upeneichthyes.lineatus
</p>
</li></ul>

<p>The data frame <code>X</code> has the following variables:
</p>

<ul>
<li><p> treatment - reference / restored
</p>
</li>
<li><p> time - sample period with seven time points 
</p>
</li></ul>



<h3>References</h3>

<p>Data attributed to the crayweed restoration project (<a href="http://www.operationcrayweed.com/">http://www.operationcrayweed.com/</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(crayweed)
head(crayweed$abund)
head(crayweed$X)

</code></pre>

<hr>
<h2 id='effect_alt.manyglm'>Specify multivariate effect sizes</h2><span id='topic+effect_alt.manyglm'></span><span id='topic+effect_alt'></span>

<h3>Description</h3>

<p><code>effect_alt</code> returns a coefficient matrix to be parsed to <code><a href="#topic+extend">extend</a></code>, <code><a href="#topic+powersim">powersim</a></code>
and <code><a href="#topic+equivtest">equivtest</a></code> to specify an effect size of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'manyglm'
effect_alt(object, effect_size, increasers, decreasers, term, K = NULL)

effect_alt(object, effect_size, increasers, decreasers, term, K = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effect_alt.manyglm_+3A_object">object</code></td>
<td>
<p>objects of class <code>manyglm</code>, typically the result of a call to <code><a href="mvabund.html#topic+manyglm">manyglm</a></code>.</p>
</td></tr>
<tr><td><code id="effect_alt.manyglm_+3A_effect_size">effect_size</code></td>
<td>
<p>An effect size of interest, see details for interpretation.</p>
</td></tr>
<tr><td><code id="effect_alt.manyglm_+3A_increasers">increasers</code></td>
<td>
<p>A vector list of responses which increase relative to the control group/intercept.</p>
</td></tr>
<tr><td><code id="effect_alt.manyglm_+3A_decreasers">decreasers</code></td>
<td>
<p>A vector list of responses which decrease relative to the control group/intercept.</p>
</td></tr>
<tr><td><code id="effect_alt.manyglm_+3A_term">term</code></td>
<td>
<p>Name of predictor of interest in quotes.</p>
</td></tr>
<tr><td><code id="effect_alt.manyglm_+3A_k">K</code></td>
<td>
<p>A vector of length <code>nlevels - 1</code>. If <code>NULL</code>, the effect size will increase by its exponent according to
the order of factor variables. Alternatively, specify a vector <code>K</code> that corresponds to the exponent of the
<code>effect_size</code> for each level of a factor variable. Defaults to <code>NULL</code>, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>effect_alt</code> helps users to create interpretable multivariate effect sizes to be parsed into <code><a href="#topic+extend">extend</a></code>,
<code><a href="#topic+powersim">powersim</a></code> and <code><a href="#topic+equivtest">equivtest</a></code>, so that researchers can investigate the relationship between effect size, power and
sample size in a complicated multivariate abundance setting.
</p>
<p><code>effect_alt</code> creates an effect of size <code>log(effect_size)</code> for a predictor of interest (<code>term</code>), for responses
who have been specified to increase (<code>increasers</code>) and <code>-log(effect_size)</code> for responses who have been specified
to decrease (<code>decreasers</code>). Responses that have not been specified in the <code>increasers</code> or <code>decreasers</code> vectors
are specified to have no effect with a coefficient of 0. The effect has been logged to make the effect size
interpretable within the coefficient matrix.
</p>
<p>For poisson regression <code>family=poisson()</code> and negative binomial regression <code>family="negative.binomial"</code> the effect
size is interpreted for a categorical variable as the multiplicative change in mean abundance in the treatment
group relative to the control group, whilst for a continuous variable it is interpreted as the multiplicative
change in abundance for a 1 unit increase in the predictor of interest.
</p>
<p>For logit regression <code>family=binomial("logit")</code> the effect size is interpreted as an odds ratio. For a categorical
variable this is the change in odds of obtaining outcome <code>1</code> when being in the treatment group relative to the
control group. Whilst for continuous variables, this is interpreted as the change in odds of obtaining outcome <code>1</code>
with a 1 unit increase in the predictor of interest.
</p>
<p>For cloglog regression <code>family=binomial("cloglog")</code> the effect size is interpreted similarly to poisson and
negative binomial regression. For a categorical variable it is interpreted as the multiplicative change in
the mean of the underlying count in the treatment group relative to the control. Whilst for a continuous
variable it is interpreted as the multiplicative change in the mean of the underlying count for a 1 unit
increase in the predictor of interest.
</p>
<p>For categorical variables, the intercept is also changed to be the group mean intercept by taking the
intercept of a model without the categorical predictor of interest. This is done to avoid messy comparisons
of null control groups.
</p>
<p>For categorical variables with more than two levels, effect size is changed to <code>effect_size^K[i]</code> where K defaults
to be <code>c(1,2,...,nlevels - 1)</code>, where <code>nlevels</code> are the number of levels of the categorical variable and is
specified along the order of the levels. To change this, specify a vector <code>K</code> with length of <code>nlevels - 1</code>. 
To change the control group, this must be done prior to specifying the <code><a href="mvabund.html#topic+manyglm">manyglm</a></code> object
using <code>relevel</code> (which can also change the order of the levels).
</p>
<p>Note that if the predictor of interest is a categorical variable it must be classed either as a factor or
character otherwise results may be misleading.
</p>


<h3>Value</h3>

<p>A coefficient matrix with the specified effect size.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>effect_alt()</code>: Specify multivariate effect sizes
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+extend">extend</a></code>, <code><a href="#topic+equivtest">equivtest</a></code>, <code><a href="#topic+powersim">powersim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mvabund)
data(spider)
spiddat = mvabund(spider$abund)
X = data.frame(spider$x)

# Specify increasers and decreasers
increasers = c("Alopacce", "Arctlute", "Arctperi", "Pardnigr", "Pardpull")
decreasers = c("Alopcune", "Alopfabr", "Zoraspin")

# Obtain an effect matrix of effect_size=3
spid.glm = manyglm(spiddat~soil.dry, family="negative.binomial", data=X)
effect_mat = effect_alt(spid.glm, effect_size=3,
         increasers, decreasers, term="soil.dry")

# Obtain an effect matrix of effect_size=1.5
X$Treatment = rep(c("A","B","C","D"),each=7)
spid.glm = manyglm(spiddat~Treatment, family="negative.binomial", data=X)
effect_mat = effect_alt(spid.glm, effect_size=1.5,
         increasers, decreasers, term="Treatment")

# Change effect size parameterisation
effect_mat = effect_alt(spid.glm, effect_size=1.5,
                         increasers, decreasers, term="Treatment",
                         K=c(3,1,2))
</code></pre>

<hr>
<h2 id='effect_null.manyglm'>Specify null effects for multivariate abundance data</h2><span id='topic+effect_null.manyglm'></span><span id='topic+effect_null'></span>

<h3>Description</h3>

<p><code>effect_null</code> returns a coefficient matrix to be parsed to <code><a href="#topic+powersim">powersim</a></code> by default
to specify a null effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'manyglm'
effect_null(object, term)

effect_null(object, term)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effect_null.manyglm_+3A_object">object</code></td>
<td>
<p>objects of class <code>manyglm</code>, typically the result of a call to <code><a href="mvabund.html#topic+manyglm">manyglm</a></code>.</p>
</td></tr>
<tr><td><code id="effect_null.manyglm_+3A_term">term</code></td>
<td>
<p>Name of predictor of interest in quotes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>effect_null</code> produces a coefficient matrix with a null effect that is specified by setting the parameter
estimates of a predictor of interest <code>term</code> to 0. This function is used by default in <code><a href="#topic+powersim">powersim</a></code>.
Note that intercept values are parameterised as in <code><a href="#topic+effect_alt">effect_alt</a></code>.
</p>


<h3>Value</h3>

<p>A coefficient matrix with the null effect.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>effect_null()</code>: Specify null effects for multivariate abundance data
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+effect_alt">effect_alt</a></code>, <code><a href="#topic+powersim">powersim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mvabund)
data(spider)
spiddat = mvabund(spider$abund)
X = data.frame(spider$x)

# Find null effect size for continuous predictor
spid.glm = manyglm(spiddat~soil.dry, family="negative.binomial", data=X)
coeffs0 = effect_null(spid.glm, term="soil.dry")
</code></pre>

<hr>
<h2 id='equivtest.cord'>Multivariate equivalence testing</h2><span id='topic+equivtest.cord'></span><span id='topic+equivtest'></span>

<h3>Description</h3>

<p><code>equivtest</code> takes in a copula model fitted to data and a matrix of effect sizes to execute a
a multivariate equivalence test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cord'
equivtest(
  object,
  coeffs,
  term = NULL,
  object0 = NULL,
  stats = NULL,
  test = "LR",
  nsim = 999,
  ncores = detectCores() - 1,
  show.time = TRUE
)

equivtest(
  object,
  coeffs,
  term = NULL,
  object0 = NULL,
  stats = NULL,
  test = "LR",
  nsim = 999,
  ncores = detectCores() - 1,
  show.time = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equivtest.cord_+3A_object">object</code></td>
<td>
<p>objects of class <code>cord</code>, typically the result of a call to <code><a href="ecoCopula.html#topic+cord">cord</a></code>.</p>
</td></tr>
<tr><td><code id="equivtest.cord_+3A_coeffs">coeffs</code></td>
<td>
<p>Coefficient matrix for a <code><a href="mvabund.html#topic+manyglm">manyglm</a></code> object that characterises the size of effects to be simulated.
See <code><a href="#topic+effect_alt">effect_alt</a></code> for help in producing this matrix.</p>
</td></tr>
<tr><td><code id="equivtest.cord_+3A_term">term</code></td>
<td>
<p>Name of predictor of interest in quotes. Defaults to <code>NULL</code>, see details.</p>
</td></tr>
<tr><td><code id="equivtest.cord_+3A_object0">object0</code></td>
<td>
<p>object of class <code>cord</code> that specifies the null hypothesis. Defaults to <code>NULL</code>, see details.</p>
</td></tr>
<tr><td><code id="equivtest.cord_+3A_stats">stats</code></td>
<td>
<p>Statistics simulated under the null hypothesis. Optional, defaults to <code>NULL</code>. If not <code>NULL</code>, <code>equivtest</code> will not
simulate test statistics and use the <code>stats</code> specified.</p>
</td></tr>
<tr><td><code id="equivtest.cord_+3A_test">test</code></td>
<td>
<p>Test statistic for computing p-value. Defaults to <code>"LR"</code>.</p>
</td></tr>
<tr><td><code id="equivtest.cord_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations for p-value estimate to be based upon. Defaults to <code>999</code>.</p>
</td></tr>
<tr><td><code id="equivtest.cord_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for parallel computing. Defaults to the total number of cores available on the
machine minus 1.</p>
</td></tr>
<tr><td><code id="equivtest.cord_+3A_show.time">show.time</code></td>
<td>
<p>Logical. Displays time elapsed. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>equivtest</code> takes a <code><a href="ecoCopula.html#topic+cord">cord</a></code> object and a coefficient matrix <code>coeffs</code> which specifies an effect size of
interest to perform an equivalence test.
</p>
<p>First, marginal parameters of the data are obtained from a <code><a href="mvabund.html#topic+manyglm">manyglm</a></code> object. Next, a copula model is fitted
using <code><a href="ecoCopula.html#topic+cord">cord</a></code> to estimate the factor analytic covariance structure of the data. The <code><a href="ecoCopula.html#topic+cord">cord</a></code> function uses two
factors by default. The p-value is then obtained by parsing the <code><a href="ecoCopula.html#topic+cord">cord</a></code> object into <code><a href="#topic+extend">extend</a></code>,
<code>nsim</code> times with an effect size specified by <code>coeffs</code>.
</p>
<p>The test statistics are simulated under the hypothesis that the effect size equals a certain threshold.
The p-value is computed as the proportion of times the simulated test statistics are less than the observed
statistic. Equivalence is declared if the estimated effect is less than the threshold.
</p>
<p><code>equivtest</code> can handle any user-defined null hypothesis, so only the fitted null model (<code>object0</code>) or the predictor of
interest (<code>term</code>) needs to be specified. If both <code>object0</code> and <code>term</code> are <code>NULL</code>, <code>equivtest</code> will
automatically set the predictor of interest as the last term in the fitted <code>object</code> model or drop the only term in the model
to obtain the intercept model.
</p>
<p>Simulations are computed in parallel using the &quot;socket&quot; approach, which uses all available cores minus 1 for clustering
to improve computation efficiency. Using 1 less than the number of available cores for your
machine (<code>detectCores()-1</code>) is recommended to leave one core available for other computer processes.
</p>


<h3>Value</h3>

<p>Equivalence test results, and;
</p>
<table>
<tr><td><code>p</code></td>
<td>
<p>p-value;</p>
</td></tr>
<tr><td><code>stat_obs</code></td>
<td>
<p>observed statistic;</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>simulated statistics.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>equivtest()</code>: Multivariate equivalence testing
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+effect_alt">effect_alt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ecoCopula)
library(mvabund)
data(spider)
spiddat = mvabund(spider$abund)
X = data.frame(spider$x)

# Specify increasers and decreasers
increasers = c("Alopacce", "Arctlute", "Arctperi", "Pardnigr", "Pardpull")
decreasers = c("Alopcune", "Alopfabr", "Zoraspin")

# Equivalence test for continuous predictor at effect_size=1.5
fit.glm = manyglm(spiddat~bare.sand, family="negative.binomial", data=X)
threshold = effect_alt(fit.glm, effect_size=1.5,
       increasers, decreasers, term="bare.sand")
fit.cord = cord(fit.glm)
equivtest(fit.cord, coeffs=threshold, term="bare.sand", nsim=99, ncores=2)

# Equivalence test for categorical predictor with 4 levels at effect_size=1.5
X$Treatment = rep(c("A","B","C","D"),each=7)
fit_factors.glm = manyglm(spiddat~Treatment, family="negative.binomial", data=X)
threshold = effect_alt(fit_factors.glm, effect_size=1.5,
       increasers, decreasers, term="Treatment")
fit_factors.cord = cord(fit_factors.glm)
equivtest(fit_factors.cord, coeffs=threshold, term="Treatment", nsim=99, ncores=2)

# Specify object0
object0.glm = manyglm(spiddat~1, family="negative.binomial")
object0.cord = cord(object0.glm)
equivtest(fit_factors.cord, coeffs=threshold, object0=object0.cord, nsim=99, ncores=2)

</code></pre>

<hr>
<h2 id='extend.cord'>Simulate or extend multivariate abundance data</h2><span id='topic+extend.cord'></span><span id='topic+extend'></span>

<h3>Description</h3>

<p><code>extend</code> returns a simulated response matrix or a <code><a href="mvabund.html#topic+manyglm">manyglm</a></code> object with <code>N</code> observations
and simulated response matrix that utilises the existing correlation structure of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cord'
extend(
  object,
  N = nrow(object$obj$data),
  coeffs = coef(object$obj),
  newdata = NULL,
  n_replicate = NULL,
  do.fit = FALSE,
  seed = NULL
)

extend(
  object,
  N = nrow(object$obj$data),
  coeffs = coef(object$obj),
  newdata = NULL,
  n_replicate = NULL,
  do.fit = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extend.cord_+3A_object">object</code></td>
<td>
<p>objects of class <code>cord</code>, typically the result of a call to <code><a href="ecoCopula.html#topic+cord">cord</a></code>.</p>
</td></tr>
<tr><td><code id="extend.cord_+3A_n">N</code></td>
<td>
<p>Number of samples to be extended. Defaults to the number of observations in the original sample.</p>
</td></tr>
<tr><td><code id="extend.cord_+3A_coeffs">coeffs</code></td>
<td>
<p>Coefficient matrix for a <code><a href="mvabund.html#topic+manyglm">manyglm</a></code> object that characterises the size of effects to be simulated.
See <code><a href="#topic+effect_alt">effect_alt</a></code> for help in producing this matrix. Defaults to the coefficient matrix from the <code><a href="ecoCopula.html#topic+cord">cord</a></code>
object, <code>coef(object$obj)</code>.</p>
</td></tr>
<tr><td><code id="extend.cord_+3A_newdata">newdata</code></td>
<td>
<p>Data frame of same size as the original X covariates from the fitted <code>object</code>, that specifies
a different design of interest. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="extend.cord_+3A_n_replicate">n_replicate</code></td>
<td>
<p>Number of unique replicates of the original data frame. Defaults to <code>NULL</code>, overwrites <code>N</code> if specified.</p>
</td></tr>
<tr><td><code id="extend.cord_+3A_do.fit">do.fit</code></td>
<td>
<p>Logical. If <code>TRUE</code>, fits a <code><a href="mvabund.html#topic+manyglm">manyglm</a></code> object from the simulated data. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="extend.cord_+3A_seed">seed</code></td>
<td>
<p>Random number seed, defaults to a random seed number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>extend</code> takes a <code><a href="ecoCopula.html#topic+cord">cord</a></code> object and returns a new simulated response matrix or an &quot;extended&quot; <code><a href="mvabund.html#topic+manyglm">manyglm</a></code> object
with <code>N</code> observations and the new simulated response matrix. Response abundances are simulated through a Gaussian
copula model that utilises a coefficient matrix <code>coeffs</code>, the specified <code>cord</code> model and the joint
correlation structure exhibited between the response variables. To help with the specification of
<code>coeffs</code>, see <code><a href="#topic+effect_alt">effect_alt</a></code> which simplifies this process.
</p>
<p>Response variables are simulated through a copula model by first extracting Gaussian copular scores
as Dunn-Smyth residuals (Dunn &amp; Smyth 1996), which are obtained from abundances <code class="reqn">y_{ij}</code> with marginal distributions
<code class="reqn">F_j</code> which have been specified via the original <code>manyglm</code> model (<code>fit.glm</code>; see examples);
</p>
<p style="text-align: center;"><code class="reqn">z_{ij} = \Phi^{-1}{F_{j}(y_{ij}^-) + u_{ij} f_{j}(y_{ij})}</code>
</p>

<p>These scores then follow a multivariate Gaussian distribution with zero mean and covariance structure <code class="reqn">\Sigma</code>,
</p>
<p style="text-align: center;"><code class="reqn">z_{ij} \sim N_p(0,\Sigma)</code>
</p>

<p>To avoid estimating a large number <code class="reqn">p(p-1)/2</code> pairwise correlations within <code class="reqn">\Sigma</code>, factor analysis is utilised
with two latent factor variables, which can be interpreted as an unobserved environmental covariate.
</p>
<p>Thus, in order to simulate new multivariate abundances we simulate new copula scores and back transform them to
abundances as <code class="reqn">y_{ij}= {F^*}_j^{-1}(\Phi(z_{ij}))</code>, where the coefficient matrix <code>coeffs</code> specifies the
effect size within the new marginal distributions <code class="reqn">{F^*}_j</code>.
</p>
<p>The data frame is also extended in a manner that preserves the original design structure. This is done by first
repeating the design matrix until the number of samples exceeds <code>N</code>, then randomly removing rows from the last
repeated data frame until the number of samples equals <code>N</code>. Alternatively, a balanced design structure can be
obtained by specifying the number of replicates.
</p>
<p><code>newdata</code> can be utilised if a different data frame is wanted for simulation.
</p>
<p>If users are interested in obtaining a <code>manyglm</code> model, <code>do.fit=TRUE</code> can be used to obtain a <code><a href="mvabund.html#topic+manyglm">manyglm</a></code>
object from the simulated responses.
</p>


<h3>Value</h3>

<p>Simulated data or <code>manyglm</code> object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>extend()</code>: Simulate or extend multivariate abundance data
</p>
</li></ul>


<h3>References</h3>

<p>Dunn, P.K., &amp; Smyth, G.K. (1996). Randomized quantile residuals. Journal of Computational and Graphical Statistics 5, 236-244.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+effect_alt">effect_alt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ecoCopula)
library(mvabund)
data(spider)
spiddat = mvabund(spider$abund)
X = data.frame(spider$x)

# Specify increasers and decreasers
increasers = c("Alopacce", "Arctlute", "Arctperi", "Pardnigr", "Pardpull")
decreasers = c("Alopcune", "Alopfabr", "Zoraspin")

# Simulate data
fit.glm = manyglm(spiddat~1, family="negative.binomial")
fit.cord = cord(fit.glm)
simData = extend(fit.cord)

# Simulate data with N=20
fit.glm = manyglm(spiddat~soil.dry, family="negative.binomial", data=X)
fit.cord = cord(fit.glm)
simData = extend(fit.cord, N=20)

# Obtain a manyglm fit from simulated data with N=10 and effect_size=1.5
X$Treatment = rep(c("A","B","C","D"),each=7)
fit_factors.glm = manyglm(spiddat~Treatment, family="negative.binomial", data=X)
effect_mat = effect_alt(fit_factors.glm, effect_size=1.5,
     increasers, decreasers, term="Treatment")
fit_factors.cord = cord(fit_factors.glm)
newFit.glm = extend(fit_factors.cord, N=10,
     coeffs=effect_mat, do.fit=TRUE)

# Change sampling design
X_new = X
X_new$Treatment[6:7] = c("B","B")
simData = extend(fit_factors.cord, N=NULL,
   coeffs=effect_mat, newdata=X_new, n_replicate=5)
</code></pre>

<hr>
<h2 id='fish'>Fish dataset</h2><span id='topic+fish'></span>

<h3>Description</h3>

<p>Dataset of fish abundances and associated environmental variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fish)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code> containing:
</p>

<dl>
<dt>fish</dt><dd><p>A data frame with nine observations of abundance of 34 fish species, and five site-related variables.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The matrix <code>abund</code> has the following species abundances:
</p>

<ul>
<li><p> Abudefduf.sp
</p>
</li>
<li><p> Acanthurus.nigrofuscus
</p>
</li>
<li><p> Achoerodus.viridis
</p>
</li>
<li><p> Aplodactylus.lophodon
</p>
</li>
<li><p> Atypichthys.strigatus
</p>
</li>
<li><p> Baitfish
</p>
</li>
<li><p> Brachaluteres.jacksonianus
</p>
</li>
<li><p> Chaeotodon.auriga
</p>
</li>
<li><p> Cheilodactylus.fuscus
</p>
</li>
<li><p> Chromis.hypsilepis
</p>
</li>
<li><p> Girella.elevata
</p>
</li>
<li><p> Girella.tricuspidata
</p>
</li>
<li><p> Heterodontus.portusjacksoni
</p>
</li>
<li><p> Kyphosus.sydneyanus
</p>
</li>
<li><p> Latropiscis.purpurissatus
</p>
</li>
<li><p> Meuschenia.spp
</p>
</li>
<li><p> Microcanthus.strigatus
</p>
</li>
<li><p> Naso.unicornis
</p>
</li>
<li><p> Notolabrus.gymnogenis
</p>
</li>
<li><p> Olisthops.cyanomelas
</p>
</li>
<li><p> Ophthalmolepis.lineolatus
</p>
</li>
<li><p> Pagrus.auratus
</p>
</li>
<li><p> Parma.microlepis
</p>
</li>
<li><p> Parma.unifasciata
</p>
</li>
<li><p> Parupeneus.signatus
</p>
</li>
<li><p> Pempheris.compressa
</p>
</li>
<li><p> Pictilabrus.laticlavius
</p>
</li>
<li><p> Prionurus.maculatus
</p>
</li>
<li><p> Prionurus.microlepidotus
</p>
</li>
<li><p> Scorpis.lineolatus
</p>
</li>
<li><p> Seriola.lalandi
</p>
</li>
<li><p> Seriola.sp
</p>
</li>
<li><p> Trachinops.taeniatus
</p>
</li>
<li><p> Unidentified.wrasse
</p>
</li>
<li><p> Site.Type - control / reference / restored
</p>
</li>
<li><p> Site.Name - location of site
</p>
</li>
<li><p> Viz - visibility in metres
</p>
</li>
<li><p> Temp - temperature in degrees Celsius
</p>
</li>
<li><p> Depth - depth in metres
</p>
</li></ul>



<h3>References</h3>

<p>Data attributed to the crayweed restoration project (<a href="http://www.operationcrayweed.com/">http://www.operationcrayweed.com/</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fish)
head(fish)

</code></pre>

<hr>
<h2 id='powersim.cord'>Provide power estimates for multivariate abundance models</h2><span id='topic+powersim.cord'></span><span id='topic+powersim'></span>

<h3>Description</h3>

<p><code>powersim</code> returns a power estimate for a <code><a href="ecoCopula.html#topic+cord">cord</a></code> object for a given sample size <code>N</code>
and effect size of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cord'
powersim(
  object,
  coeffs,
  term,
  N = nrow(object$obj$data),
  coeffs0 = effect_null(object$obj, term),
  nsim = 1000,
  ncrit = 999,
  test = "score",
  alpha = 0.05,
  newdata = NULL,
  ncores = detectCores() - 1,
  show.time = TRUE,
  long_power = FALSE,
  n.samp = 10,
  nlv = 2
)

powersim(
  object,
  coeffs,
  term,
  N = nrow(object$obj$data),
  coeffs0 = effect_null(object$obj, term),
  nsim = 999,
  ncrit = nsim,
  test = "score",
  alpha = 0.05,
  newdata = NULL,
  ncores = detectCores() - 1,
  show.time = TRUE,
  long_power = FALSE,
  n.samp = 10,
  nlv = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powersim.cord_+3A_object">object</code></td>
<td>
<p>objects of class <code>cord</code>, typically the result of a call to <code><a href="ecoCopula.html#topic+cord">cord</a></code>.</p>
</td></tr>
<tr><td><code id="powersim.cord_+3A_coeffs">coeffs</code></td>
<td>
<p>Coefficient matrix for a <code><a href="mvabund.html#topic+manyglm">manyglm</a></code> object that characterises the size of effects to be simulated.
See <code><a href="#topic+effect_alt">effect_alt</a></code> for help in producing this matrix.</p>
</td></tr>
<tr><td><code id="powersim.cord_+3A_term">term</code></td>
<td>
<p>Name of predictor of interest in quotes.</p>
</td></tr>
<tr><td><code id="powersim.cord_+3A_n">N</code></td>
<td>
<p>Number of samples for power estimate. Defaults to the number of observations in the original sample.</p>
</td></tr>
<tr><td><code id="powersim.cord_+3A_coeffs0">coeffs0</code></td>
<td>
<p>Coefficient matrix under the null hypothesis. Defaults to being specified by <code><a href="#topic+effect_null">effect_null</a></code>.</p>
</td></tr>
<tr><td><code id="powersim.cord_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated test statistics under the specified effect size (<code>coeffs</code>) to estimate power. Defaults to <code>999</code>.</p>
</td></tr>
<tr><td><code id="powersim.cord_+3A_ncrit">ncrit</code></td>
<td>
<p>Number of simulated test statistics under the null effect to estimate the critical value. Defaults to <code>999</code>.</p>
</td></tr>
<tr><td><code id="powersim.cord_+3A_test">test</code></td>
<td>
<p>Test statistic for power estimate to based upon. Defaults to <code>"score"</code>, however <code>"wald"</code> is also allowed.</p>
</td></tr>
<tr><td><code id="powersim.cord_+3A_alpha">alpha</code></td>
<td>
<p>Type I error rate for power estimate, defaults to <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="powersim.cord_+3A_newdata">newdata</code></td>
<td>
<p>Data frame of the same size as the original data frame from the <code><a href="ecoCopula.html#topic+cord">cord</a></code> object
(<code>object$obj$data</code>), that specifies a different design of interest.</p>
</td></tr>
<tr><td><code id="powersim.cord_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for parallel computing. Defaults to the total number of cores available on the
machine minus 1.</p>
</td></tr>
<tr><td><code id="powersim.cord_+3A_show.time">show.time</code></td>
<td>
<p>Logical. Displays time elapsed. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="powersim.cord_+3A_long_power">long_power</code></td>
<td>
<p>Logical. Whether to estimate power using separate critical test statistics for each <code>nsim</code> test statistics
simulated under the alternative hypothesis. Note that although this will give a more accurate estimate of power, it will
take a considerably large amount of time. First try increasing <code>ncrit</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="powersim.cord_+3A_n.samp">n.samp</code></td>
<td>
<p>integer, number of sets of residuals for importance sampling for the copula model with cord. Defaults to <code>10</code>, recommend setting this
higher for smaller sample sizes <code>N</code>.</p>
</td></tr>
<tr><td><code id="powersim.cord_+3A_nlv">nlv</code></td>
<td>
<p>number of latent variables (default = 2) for the copula model with cord, recommend setting this lower for smaller sample sizes <code>N</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>powersim</code> takes a <code><a href="ecoCopula.html#topic+cord">cord</a></code> object, sample size <code>N</code> and coefficient matrix <code>coeffs</code> which
specifies an effect size of interest and returns a power estimate.
</p>
<p>The power estimate is obtained by first parsing the <code><a href="ecoCopula.html#topic+cord">cord</a></code> object into <code><a href="#topic+extend">extend</a></code>,
<code>nsim</code> times with an effect size specified by <code>coeffs</code>. Next, the <code><a href="ecoCopula.html#topic+cord">cord</a></code> object is parsed into
<code><a href="#topic+extend">extend</a></code> an additional <code>ncrit</code> times with a null effect, which is defined by default by
<code><a href="#topic+effect_null">effect_null</a></code>. This effectively simulates <code>nsim</code> + <code>ncrit</code> <code>manyglm</code> models under both the null
and alternative hypothesis.
</p>
<p>For each simulated <code><a href="mvabund.html#topic+manyglm">manyglm</a></code> object, a test statistic <code>test</code> is obtained. A critical test statistic
is then obtained as the upper 1 - <code>alpha</code> quantile of simulated test statistics under the null
hypothesis. Power is then estimated as the proportion of times the test statistics simulated under
the alternative hypothesis exceed the critical test statistic under the null.
</p>
<p>To improve computation time, simulations are computed in parallel using the &quot;socket&quot; approach, which
by default uses all available cores minus 1 for clustering. Using 1 less than the number of available cores for your
machine (<code>detectCores()-1</code>) is recommended to better avoid errors relating to clustering or nodes.
</p>


<h3>Value</h3>

<p>Power estimate result, and;
</p>
<table>
<tr><td><code>power</code></td>
<td>
<p>power.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>powersim()</code>: Provide power estimates for multivariate abundance models
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Ben Maslen &lt;b.maslen@unsw.edu.au&gt;.
</p>


<h3>References</h3>

<p>Maslen, B., Popovic, G., Lim, M., Marzinelli, E., &amp; Warton, D. (2023). How many sites? Methods to assist design decisions when collecting multivariate data in ecology. Methods in Ecology and Evolution, 14(6), 1564-1573.
Popovic, G. C., Hui, F. K., &amp; Warton, D. I. (2018). A general algorithm for covariance modeling of discrete data. Journal of Multivariate Analysis, 165, 86-100.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+effect_alt">effect_alt</a></code>, <code><a href="#topic+effect_null">effect_null</a></code>, <code><a href="#topic+extend">extend</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ecoCopula)
library(mvabund)
data(spider)
spiddat = mvabund(spider$abund)
X = data.frame(spider$x)

# Specify increasers and decreasers
increasers = c("Alopacce", "Arctlute", "Arctperi", "Pardnigr", "Pardpull")
decreasers = c("Alopcune", "Alopfabr", "Zoraspin")

# Find power for continuous predictor at effect_size=1.5
fit.glm = manyglm(spiddat~bare.sand, family="negative.binomial", data=X)
effect_mat = effect_alt(fit.glm, effect_size=1.5,
       increasers, decreasers, term="bare.sand")
fit.cord = cord(fit.glm)
powersim(fit.cord, coeffs=effect_mat, term="bare.sand", nsim=99, ncrit=99, ncores=2)

# Find power for categorical predictor with 4 levels at effect_size=1.5
X$Treatment = rep(c("A","B","C","D"),each=7)
fit_factors.glm = manyglm(spiddat~Treatment, family="negative.binomial", data=X)
effect_mat = effect_alt(fit_factors.glm, effect_size=1.5,
       increasers, decreasers, term="Treatment")
fit_factors.cord = cord(fit_factors.glm)
powersim(fit_factors.cord, coeffs=effect_mat, term="Treatment", nsim=99, ncrit=99, ncores=2)

# Change effect size parameterisation
effect_mat = effect_alt(fit_factors.glm, effect_size=1.5,
                         increasers, decreasers, term="Treatment",
                         K=c(3,1,2))
powersim(fit_factors.cord, coeffs=effect_mat, term="Treatment", nsim=99, ncrit=99, ncores=2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
