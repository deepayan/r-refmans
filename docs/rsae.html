<!DOCTYPE html><html><head><title>Help for package rsae</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rsae}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rsae-package'><p>Robust Small Area Estimation</p></a></li>
<li><a href='#fitsaemodel'><p>Fitting SAE Models</p></a></li>
<li><a href='#fitsaemodel.control'><p>Tuning Parameters of <code>fitsaemodel</code></p></a></li>
<li><a href='#landsat'><p>LANDSAT Data: Prediction of County Crop Areas Using Survey and</p>
Satellite Data</a></li>
<li><a href='#landsat_means'><p>Means of the LANDSAT Data for Corn and Soybeans</p></a></li>
<li><a href='#makedata'><p>Synthetic Data Generation for the Basic Unit-Level SAE Model</p></a></li>
<li><a href='#robpredict'><p>Robust Prediction of Random Effects, Fixed Effects, and</p>
Area-Specific Means</a></li>
<li><a href='#saemodel'><p>Setting Up a SAE Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Robust Small Area Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Empirical best linear unbiased prediction (EBLUP) and
    robust prediction of the area-level means under the basic unit-level
    model. The model can be fitted by maximum likelihood or a (robust)
    M-estimator. Mean square prediction error is computed by a parametric
    bootstrap.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tobiasschoch/rsae">https://github.com/tobiasschoch/rsae</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tobiasschoch/rsae/issues">https://github.com/tobiasschoch/rsae/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, robustbase</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-06 18:46:57 UTC; tobias</td>
</tr>
<tr>
<td>Author:</td>
<td>Tobias Schoch <a href="https://orcid.org/0000-0002-1640-3395"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Burkardt John [cph] (Fortran 90 subroutine zero_rc)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tobias Schoch &lt;tobias.schoch@fhnw.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-06 19:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rsae-package'>Robust Small Area Estimation</h2><span id='topic+rsae-package'></span><span id='topic+rsae'></span>

<h3>Description</h3>

<p>The package implements methods to fit the basic unit-level model (also
known as model type &quot;B&quot; in Rao, 2003, or nested-error regression model in
Battese et al., 1988), to predict area-specific means by the empirical
best linear unbiased predictor (EBLUP) or a robust prediction method
(Copt and Victoria-Feser, 2009; Heritier et al., 2011), and to compute
the mean square prediction error of the predicted area-level means
by a parametric bootstrap (Sinha and Rao, 2009; see also Hall and Maiti,
2006; Lahiri, 2003).
</p>
<p>The methods are discussed in Schoch (2012).
</p>


<h3>Details</h3>



<h4>Implemented methods</h4>


<ul>
<li><p> maximum likelihood estimator
</p>
</li>
<li><p> Huber-type M-estimator (RML II of Richardson and Welsh,
1995, not the method proposed in Sinha and Rao, 2009); see
Schoch (2012) for details
</p>
</li></ul>




<h4>How to</h4>

<p>Data analysis involves the following steps:
</p>

<ol>
<li><p> prepare the data/ specify the model for estimation;
see <code><a href="#topic+saemodel">saemodel()</a></code>
</p>
</li>
<li><p> fit the model by various (robust) methods; see
<code><a href="#topic+fitsaemodel">fitsaemodel()</a></code>
</p>
</li>
<li><p> (robustly) predict the random effects and the area
means; see <code><a href="#topic+robpredict">robpredict()</a></code>
</p>
</li></ol>




<h3>References</h3>

<p>Battese, G. E., Harter, R. M., and W.A. Fuller (1988).
An error component model for prediction of county crop areas using.
<em>Journal of the American Statistical Association</em> <b>83</b>, 28&ndash;36.
<a href="https://doi.org/10.2307/2288915">doi:10.2307/2288915</a>
</p>
<p>Copt, S. and M.-P. Victoria-Feser (2009).
<em>Robust Predictions in Mixed Linear Models</em>,
Research Report, University of Geneva.
</p>
<p>Lahiri, P. (2003).
On the impact of bootstrap in survey sampling and small area estimation.
<em>Statistical Science</em> <b>18</b>, 199&ndash;210.
<a href="https://doi.org/10.1214/ss/1063994975">doi:10.1214/ss/1063994975</a>
</p>
<p>Hall, P. and T. Maiti (2006).
On parametric bootstrap methods for small area prediction.
<em>Journal of the Royal Statistical Society. Series B</em> <b>68</b>,
221&ndash;238. <a href="https://doi.org/10.1111/j.1467-9868.2006.00541.x">doi:10.1111/j.1467-9868.2006.00541.x</a>
</p>
<p>Heritier, S., Cantoni, E., Copt, S., and M.-P. Victoria-Feser (2009).
<em>Robust methods in Biostatistics</em>, New York: John Wiley and Sons.
</p>
<p>Rao, J.N.K. (2003).
<em>Small Area Estimation</em>, New York: John Wiley and Sons.
</p>
<p>Richardson, A.M. and A.H. Welsh (1995).
Robust restricted maximum likelihood in mixed linear model.
<em>Biometrics</em> <b>51</b>, 1429&ndash;1439.
<a href="https://doi.org/10.2307/2533273">doi:10.2307/2533273</a>
</p>
<p>Schoch, T. (2012). Robust Unit-Level Small Area Estimation: A Fast Algorithm
for Large Datasets. <em>Austrian Journal of Statistics</em> <b>41</b>,
243&ndash;265. <a href="https://doi.org/10.17713/ajs.v41i4.1548">doi:10.17713/ajs.v41i4.1548</a>
</p>
<p>Sinha, S.K. and J.N.K. Rao (2009).
Robust small area estimation.
<em>Canadian Journal of Statistics</em> <b>37</b>, 381&ndash;399.
<a href="https://doi.org/10.1002/cjs.10029">doi:10.1002/cjs.10029</a>
</p>

<hr>
<h2 id='fitsaemodel'>Fitting SAE Models</h2><span id='topic+fitsaemodel'></span><span id='topic+print.fit_model_b'></span><span id='topic+print.summary_fit_model_b'></span><span id='topic+summary.fit_model_b'></span><span id='topic+coef.fit_model_b'></span><span id='topic+convergence'></span>

<h3>Description</h3>

<p><code>fitsaemodel</code> fits SAE models that have been specified by
<code><a href="#topic+saemodel">saemodel()</a></code> (or synthetic data generated by
<code><a href="#topic+makedata">makedata()</a></code>) for various (robust) estimation
methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitsaemodel(method, model, ...)
convergence(object)

## S3 method for class 'fit_model_b'
print(x, digits = max(3L, getOption("digits") - 3L),
    ...)
## S3 method for class 'summary_fit_model_b'
print(x, digits = max(3L, getOption("digits")
    - 3L), ...)
## S3 method for class 'fit_model_b'
summary(object, ...)
## S3 method for class 'fit_model_b'
coef(object, type = "both", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitsaemodel_+3A_method">method</code></td>
<td>
<p><code>[character]</code> estimation method; <code>method = "ml"</code>
for (non-robust) maximum likelihood or <code>method = "huberm"</code>
for Huber-type M-estimation.</p>
</td></tr>
<tr><td><code id="fitsaemodel_+3A_model">model</code></td>
<td>
<p>an object of class <code>"saemodel"</code>, i.e., a SAE model;
see <code><a href="#topic+saemodel">saemodel()</a></code>.</p>
</td></tr>
<tr><td><code id="fitsaemodel_+3A_digits">digits</code></td>
<td>
<p><code>[integer]</code> number of digits printed by the
<code>print()</code> and <code>summary()</code> methods.</p>
</td></tr>
<tr><td><code id="fitsaemodel_+3A_object">object</code></td>
<td>
<p>an object of class <code>"fit_model_b"</code>.</p>
</td></tr>
<tr><td><code id="fitsaemodel_+3A_x">x</code></td>
<td>
<p>an object of class <code>"fit_model_b"</code>.</p>
</td></tr>
<tr><td><code id="fitsaemodel_+3A_type">type</code></td>
<td>
<p><code>[character]</code> name of the effects to be extracted
by the <code>coef</code> method; it can take one of the
following possibilities: <code>"both"</code> (extracts fixed and random
effects; default), <code>"ranef"</code> (only random effects), or
<code>"fixef"</code> (only fixed effects).</p>
</td></tr>
<tr><td><code id="fitsaemodel_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to
<code><a href="#topic+fitsaemodel.control">fitsaemodel.control()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>fitsaemodel()</code> computes the following estimators:
</p>

<ul>
<li><p> maximum likelihood (ML): <code>method = "ml"</code>,
</p>
</li>
<li><p> Huber-type M-estimation: <code>method = "huberm"</code>; this
method is called RML II by Richardson and Welsh (1995); see
Schoch (2012)
</p>
</li></ul>



<h4>Maximum likelihood</h4>

<p>The ML is <b>not</b> robust against outliers.
</p>



<h4>Huber-type M-estimation</h4>

<p>The call for the Huber-type M-estimator (with Huber psi-function) is:
<code>fitsaemodel(method = "huberm", model, k)</code>, where <code>k</code> is
the robustness tuning constant of the Huber psi-function,
<code class="reqn">k \in (0, \infty]</code>.
</p>
<p>By default, the computation of the M-estimator is initialized by a
robust estimate that derives from a fixed-effects model (centered by
the median instead of the mean); see Schoch (2012) for the details.
</p>
<p>If the data are supposed to be heavily contaminated (<b>or</b> if the
<b>default algorithm did not converge</b>), one may try to initialize
the algorithm underlying <code>fitsaemodel()</code> by a high breakdown-point
estimate. The package offers two initialization methods:
<b>NOTE:</b> the <span class="pkg">robustbase</span> package (Maechler et al., 2022)
must be installed to use this functionality.
</p>

<ul>
<li> <p><code>init = "lts"</code>: least trimmed squares (LTS)
regression from <span class="pkg">robustbase</span>; see
<a href="robustbase.html#topic+ltsReg">ltsReg()</a> and Rousseeuw and Van
Driessen (2006),
</p>
</li>
<li> <p><code>init = "s"</code>: regression S-estimator from
<span class="pkg">robustbase</span>; see <a href="robustbase.html#topic+lmrob">lmrob()</a> and
Maronna et al. (2019).
</p>
</li></ul>

<p>For small and medium size datasets, both methods are equivalent in
terms of computation time. For large data, the S-estimator is
considerably faster.
</p>



<h4>Implementation</h4>

<p>The methods are computed by (nested) iteratively re-weighted least
squares and a derivative of Richard Brent's <code>zeroin</code> algorithm;
see Brent (2013, Chapter 4). The functions depend on the subroutines in
BLAS (Blackford et al., 2002) and LAPACK (Anderson et al., 2000); see
Schoch (2012).
</p>



<h3>Value</h3>

<p>An instance of the class <code>"fitmodel"</code>
</p>


<h3>References</h3>

<p>Anderson, E., Bai, Z., Bischof, C., Blackford, L. S., Demmel, J., Dongarra,
J., et al. (2000). <em>LAPACK users' guide</em> (3rd ed.). Philadelphia:
Society for Industrial and Applied Mathematics (SIAM).
</p>
<p>Blackford, L.S., Petitet, A., Pozo, R., Remington, K., Whaley, R.C.,
Demmel, J., et al. (2002).
An updated set of basic linear algebra subprograms (BLAS).
<em>ACM Transactions on Mathematical Software</em> <b>28</b>, 135&ndash;151.
<a href="https://doi.org/10.1145/567806.567807">doi:10.1145/567806.567807</a>
</p>
<p>Brent, R.P. (2013). <em>Algorithms for minimization without derivatives</em>.
Mineola (NY): Dover Publications Inc. (This publication is an unabridged
republication of the work originally published by Prentice-Hall Inc.,
Englewood Cliffs, NJ, in 1973).
</p>
<p>Maechler, M., Rousseeuw, P., Croux, C., Todorov, V., Ruckstuhl, A.,
Salibian-Barrera, M., Verbeke, T., Koller, M., Conceicao, E.L.T. and
M. Anna di Palma (2022). robustbase: Basic Robust Statistics R package
version 0.95-0. <a href="https://CRAN.R-project.org/package=robustbase">https://CRAN.R-project.org/package=robustbase</a>
</p>
<p>Maronna, R.A., Martin, D., V.J. Yohai and M. Salibian-Barrera (2019):
<em>Robust statistics: Theory and methods</em>. Chichester: John Wiley
and Sons, 2nd ed.
</p>
<p>Richardson, A.M. and A.H. Welsh (1995).
Robust restricted maximum likelihood in mixed linear model.
<em>Biometrics</em> <b>51</b>, 1429&ndash;1439.
<a href="https://doi.org/10.2307/2533273">doi:10.2307/2533273</a>
</p>
<p>Rousseeuw, P. J. and K. Van Driessen (2006).
Computing LTS regression for large data sets.
<em>Data Mining and Knowledge Discovery</em> <b>12</b>, 29&ndash;45.
<a href="https://doi.org/10.1007/s10618-005-0024-4">doi:10.1007/s10618-005-0024-4</a>
</p>
<p>Schoch, T. (2012). Robust Unit-Level Small Area Estimation: A Fast Algorithm
for Large Datasets. <em>Austrian Journal of Statistics</em> <b>41</b>,
243&ndash;265. <a href="https://doi.org/10.17713/ajs.v41i4.1548">doi:10.17713/ajs.v41i4.1548</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitsaemodel.control">fitsaemodel.control()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use the landsat data
head(landsat)

# define the saemodel using the landsat data
model &lt;- saemodel(formula = HACorn ~ PixelsCorn + PixelsSoybeans,
    area = ~CountyName,
    data = subset(landsat, subset = (outlier == FALSE)))

# summary of the model
summary(model)

# maximum likelihood estimates
fitsaemodel("ml", model)

# Huber M-estimate with robustness tuning constant k = 2
m &lt;- fitsaemodel("huberm", model, k = 2)
m

# summary of the fitted model/ estimates
summary(m)

# obtain more information about convergence
convergence(m)

# extract the fixed effects
coef(m, "fixef")

# extract the random effects
coef(m, "ranef")

# extract both
coef(m)
</code></pre>

<hr>
<h2 id='fitsaemodel.control'>Tuning Parameters of <code>fitsaemodel</code></h2><span id='topic+fitsaemodel.control'></span>

<h3>Description</h3>

<p>This function is used to define global settings and parameters that
are used by <code><a href="#topic+fitsaemodel">fitsaemodel()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitsaemodel.control(niter = 40, iter = c(200, 200), acc = 1e-05,
    dec = 0, decorr = 0, init = "default", k_Inf = 20000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitsaemodel.control_+3A_niter">niter</code></td>
<td>
<p><code>[integer]</code> the maximum number of outer-loop
iterations (default: <code>niter = 40</code>).</p>
</td></tr>
<tr><td><code id="fitsaemodel.control_+3A_iter">iter</code></td>
<td>
<p><code>[integer]</code> the maximum number of inner-loop
iterations. It can be a vector of size 2. The first element of the
vector refers to the estimation of the regression
coefficients <code class="reqn">\beta</code>; the second element refers to the
estimation of the variance of the unit-level errors, <code class="reqn">v</code>; the
maximum number of iterations used to compute the ratio of variances,
<code class="reqn">d</code>, cannot be modified (default: <code>iter = c(200, 200)</code>).</p>
</td></tr>
<tr><td><code id="fitsaemodel.control_+3A_acc">acc</code></td>
<td>
<p><code>[numeric]</code> numeric tolerance used in the
termination rule of the iterative updating algorithms.
It can be a vector of size 4. The positions <code>1:4</code> of the
vector <code>acc</code> refer to <code>1</code>: (overall) outer-loop,
<code>2</code>: regression coefficients, <code class="reqn">\beta</code>, <code>3</code>:
variance component, <code class="reqn">v</code>, <code>4</code>: ratio of variances
<code class="reqn">d</code>; default: <code>acc = 1e-05</code>.</p>
</td></tr>
<tr><td><code id="fitsaemodel.control_+3A_dec">dec</code></td>
<td>
<p><code>[integer]</code> type of matrix square root (decomposition);
<code>dec = 0</code> for eigenvalue decomposition (default)
or <code>dec = 1</code> for Cholesky decomposition.</p>
</td></tr>
<tr><td><code id="fitsaemodel.control_+3A_decorr">decorr</code></td>
<td>
<p><code>[integer]</code> type of decorrelation of the
residuals; <code>decorr = 0</code>: no robust decorrelation (default);
<code>decorr = 1</code>: means are replaced by medians.</p>
</td></tr>
<tr><td><code id="fitsaemodel.control_+3A_init">init</code></td>
<td>
<p><code>[character]</code> method by which the main
algorithm is initialized. By default, <code>init = "default"</code>
the algorithm is initialized by a robust fixed-effects estimator;
alternatively, (and provided that the <span class="pkg">robustbase</span> package is
installed) one may choose one of the high-breakdown-point initial
estimators: &quot;lts&quot; (fast least-trimmed squares, LTS, regression) or
&quot;s&quot; (regression S-estimator). For more details
on the initialization methods, see documentation of
<code><a href="#topic+fitsaemodel">fitsaemodel()</a></code>.</p>
</td></tr>
<tr><td><code id="fitsaemodel.control_+3A_k_inf">k_Inf</code></td>
<td>
<p><code>[numeric]</code> tuning constant of the robust estimator
that represents infinity (default: <code>k_Inf = 20000</code>).</p>
</td></tr>
<tr><td><code id="fitsaemodel.control_+3A_...">...</code></td>
<td>
<p>additional arguments (not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Changing the default values of the parameters may result in failure of
convergence or loss of convergence speed.
</p>


<h3>Value</h3>

<p>A list with entries
</p>

<ul>
<li> <p><code>niter</code>
</p>
</li>
<li> <p><code>iter</code>
</p>
</li>
<li> <p><code>acc</code>
</p>
</li>
<li> <p><code>k_Inf</code>
</p>
</li>
<li> <p><code>init</code>
</p>
</li>
<li> <p><code>dec</code>
</p>
</li>
<li> <p><code>decorr</code>
</p>
</li>
<li> <p><code>add</code>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitsaemodel">fitsaemodel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use the landsat data
head(landsat)

# define the saemodel using the landsat data
model &lt;- saemodel(formula = HACorn ~ PixelsCorn + PixelsSoybeans,
    area = ~CountyName,
    data = subset(landsat, subset = (outlier == FALSE)))

# summary of the model
summary(model)

# obtain the maximum likelihood estimates with, for instance, 'niter = 50'
# number of outer-loop iterations (by default: niter = 40). Here, we use
# 'niter = 50' for the sake of demonstration, not because it is needed.
fitsaemodel("ml", model, niter = 50)
</code></pre>

<hr>
<h2 id='landsat'>LANDSAT Data: Prediction of County Crop Areas Using Survey and
Satellite Data</h2><span id='topic+landsat'></span>

<h3>Description</h3>

<p>The <code>landsat</code> data is a compilation of survey and satellite
data from Battese et al. (1988). It consists of data on segments
(primary sampling unit; 1 segement approx. 250 hectares) under
corn and soybeans for 12 counties in north-central Iowa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(landsat)</code></pre>


<h3>Format</h3>

<p>A data frame with 37 observations on the following 10 variables.
</p>

<dl>
<dt><code>SegmentsInCounty</code></dt><dd><p>number of segments per county.</p>
</dd>
<dt><code>SegementID</code></dt><dd><p>sample segment identifier (per county).</p>
</dd>
<dt><code>HACorn</code></dt><dd><p>hectares of corn for each sample segment
(as reported in the June 1978 Enumerative Survey).</p>
</dd>
<dt><code>HASoybeans</code></dt><dd><p>hectares of soybeans for each sample
segment (as reported in the June 1978 Enumerative Survey).</p>
</dd>
<dt><code>PixelsCorn</code></dt><dd><p>number of pixels classified
as corn for each sample segment (LANDSAT readings).</p>
</dd>
<dt><code>PixelsSoybeans</code></dt><dd><p>number of pixels classified as
soybeans for each sample segment (LANDSAT readings).</p>
</dd>
<dt><code>MeanPixelsCorn</code></dt><dd><p>county-specific mean number of
pixels classified as corn.</p>
</dd>
<dt><code>MeanPixelsSoybeans</code></dt><dd><p>county-specific mean number
of pixels classified as soybeans.</p>
</dd>
<dt><code>outlier</code></dt><dd><p>outlier indicator; observation number 33
is flagged as outlier.</p>
</dd>
<dt><code>CountyName</code></dt><dd><p>county names (factor variable):
Cerro Gordo, Hamilton, Worth, Humboldt, Franklin, Pocahontas,
Winnebago, Wright, Webster, Hancock, Kossuth, Hardin.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The <code>landsat</code> data in Battese et al. (1988) is a compilation
of the LANDSAT satellite data from the U.S. Department of Agriculture
(USDA) and the 1978 June Enumerative Survey.
</p>


<h4>Survey data</h4>

<p>The survey data on the areas under corn and soybeans (reported in
hectares) in the 37 segments of the 12 counties (north-central Iowa)
have been determined by USDA Statistical Reporting Service staff,
who interviewed farm operators. A segment is about 250 hectares.
</p>



<h4>Satellite data</h4>

<p>For the LANDSAT satellite data, information is recorded as &quot;pixels&quot;.
A pixel is about 0.45 hectares. The USDA has been engaged in
research toward transforming satellite information into good
estimates of crop areas at the individual pixel and segments
level. The satellite (LANDSAT) readings were obtained during
August and September 1978.
</p>

<p>Data for more than one sample segment are available for several counties
(i.e., unbalanced data).
</p>
<p>Observations No. 33 has been flaged as outlier; see Battese et al.
(1988, p. 28).
</p>


<h3>Source</h3>

<p>The <code>landsat</code> data is from Table 1 of Battese et al. (1988, p. 29).
</p>


<h3>References</h3>

<p>Battese, G. E., Harter, R. M., and W.A. Fuller (1988).
An error component model for prediction of county crop areas using.
<em>Journal of the American Statistical Association</em> <b>83</b>, 28&ndash;36.
<a href="https://doi.org/10.2307/2288915">doi:10.2307/2288915</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+landsat_means">landsat_means</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(landsat)
</code></pre>

<hr>
<h2 id='landsat_means'>Means of the LANDSAT Data for Corn and Soybeans</h2><span id='topic+landsat_means'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+landsat">landsat</a></code> data is a compilation of survey and satellite
data from Battese et al. (1988). The county-specific population means of
pixels of the segments under corn and soybeans, respectively, are available
in the data.frame <code>landsat_means</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(landsat_means)</code></pre>


<h3>Format</h3>

<p>A data frame with 12 observations (counties) on the following 3 variables.
</p>

<dl>
<dt><code>(intercept)</code></dt><dd><p>all ones.</p>
</dd>
<dt><code>MeanPixelsCorn</code></dt><dd><p>county-specific mean of number of pixels
classified as corn (LANDSAT readings).</p>
</dd>
<dt><code>MeanPixelsSoybeans</code></dt><dd><p>county-specific number of pixels
classified as soybeans (LANDSAT readings).</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data.frame <code>landsat_means</code> is an aggregation of the data.frame
<code><a href="#topic+landsat">landsat</a></code>.
</p>


<h3>References</h3>

<p>Battese, G. E., Harter, R. M., and W.A. Fuller (1988).
An error component model for prediction of county crop areas using.
<em>Journal of the American Statistical Association</em> <b>83</b>, 28&ndash;36.
<a href="https://doi.org/10.2307/2288915">doi:10.2307/2288915</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(landsat_means)
</code></pre>

<hr>
<h2 id='makedata'>Synthetic Data Generation for the Basic Unit-Level SAE Model</h2><span id='topic+makedata'></span>

<h3>Description</h3>

<p>This function generates synthetic data (possibly contaminated by outliers)
for the basic unit-level SAE model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makedata(seed = 1024, intercept = 1, beta = 1, n = 4, g = 20, areaID = NULL,
         ve = 1, ve.contam = 41, ve.epsilon = 0, vu = 1, vu.contam = 41,
         vu.epsilon = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makedata_+3A_seed">seed</code></td>
<td>
<p><code>[integer]</code> seed value used in <code>set.seed</code> (default
<code>seed = 1024</code>).</p>
</td></tr>
<tr><td><code id="makedata_+3A_intercept">intercept</code></td>
<td>
<p><code>[numeric]</code> or <code>[NULL]</code> value of the intercept
of the fixed-effects model or <code>NULL</code> for a model without
intercept (default: <code>intercept = 1</code>).</p>
</td></tr>
<tr><td><code id="makedata_+3A_beta">beta</code></td>
<td>
<p><code>[numeric vector]</code> value of the fixed-effect coefficients
(without intercept; default: <code>beta = 1</code>). For each given
coefficient, a vector of realizations is drawn from the standard
normal distribution.</p>
</td></tr>
<tr><td><code id="makedata_+3A_n">n</code></td>
<td>
<p><code>[integer]</code> number of units per area in balanced-data
setups (default: <code>n = 4</code>).</p>
</td></tr>
<tr><td><code id="makedata_+3A_g">g</code></td>
<td>
<p><code>[integer]</code> number of areas (default: <code>g = 20</code>).</p>
</td></tr>
<tr><td><code id="makedata_+3A_areaid">areaID</code></td>
<td>
<p><code>[integer vector]</code> or <code>[NULL]</code>. If one attempts
to generate synthetic unbalanced data, one calls <code>makedata</code> with
a vector, the elements of which area identifiers. This vector
should contain a series of (integer valued) area IDs. The number
of areas is set equal to the number unique IDs.</p>
</td></tr>
<tr><td><code id="makedata_+3A_ve">ve</code></td>
<td>
<p><code>[numeric]</code> nonnegative value of model/ residual variance.</p>
</td></tr>
<tr><td><code id="makedata_+3A_ve.contam">ve.contam</code></td>
<td>
<p><code>[numeric]</code> nonnegative value of model variance of
the outlier part in a mixture distribution (Tukey-Huber-type
contamination model) <code class="reqn">e = (1-h)N(0, ve) + hN(0, ve.contam)
            </code>.</p>
</td></tr>
<tr><td><code id="makedata_+3A_ve.epsilon">ve.epsilon</code></td>
<td>
<p><code>[numeric]</code> value in <code class="reqn">[0,1]</code> that
defines the relative number of outliers (i.e., epsilon or h in
the contamination mixture distribution). Typically, it takes
values between 0 and 0.5 (but it is not restricted to this interval).</p>
</td></tr>
<tr><td><code id="makedata_+3A_vu">vu</code></td>
<td>
<p><code>[numeric]</code> value of the (area-level) random-effect
variance.</p>
</td></tr>
<tr><td><code id="makedata_+3A_vu.contam">vu.contam</code></td>
<td>
<p><code>[numeric]</code> nonnegative value of the (area-level)
random-effect variance of the outlier part in the contamination
mixture distribution.</p>
</td></tr>
<tr><td><code id="makedata_+3A_vu.epsilon">vu.epsilon</code></td>
<td>
<p><code>[numeric]</code> value in <code class="reqn">[0,1]</code> that
defines the relative number of outliers in the contamination
mixture distribution of the (area-level) random effects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">y_i</code> denote an area-specific <code class="reqn">n_i</code>-vector of
the response variable for the areas <code class="reqn">i = 1,..., g</code>. Define a
<code class="reqn">(n_i \times p)</code>-matrix <code class="reqn">X_i</code> of realizations
from the std. normal distribution, <code class="reqn">N(0,1)</code>, and let
<code class="reqn">\beta</code> denote a <code class="reqn">p</code>-vector of regression coefficients. Now, the
<code class="reqn">y_i</code> are drawn using the law
<code class="reqn">y_i \sim N(X_i\beta, v_e I_i + v_u J_i)</code> with <code class="reqn">v_e</code> and
<code class="reqn">v_u</code> the variances of the model error and random-effect
variance, respectively, and <code class="reqn">I_i</code> and <code class="reqn">J_i</code> denoting
the identity matrix and matrix of ones, respectively.
</p>
<p>In addition, we allow the distribution of the model/residual and
area-level random effect to be contaminated (cf. Stahel and Welsh, 1997).
Notably, the laws of <code class="reqn">e_{i,j}</code> and <code class="reqn">u_i</code> are replaced
by the Tukey-Huber contamination mixture:
</p>

<ul>
<li> <p><code class="reqn">e_{i,j} \sim (1-\epsilon^{ve})N(0,v_e) +
            \epsilon^{ve}N(0, v_e^{\epsilon})</code>
</p>
</li>
<li> <p><code class="reqn">u_{i} \sim (1-\epsilon^{vu})N(0,v_u) +
            \epsilon^{vu}N(0, v_u^{\epsilon})</code>
</p>
</li></ul>

<p>where <code class="reqn">\epsilon^{ve}</code> and
<code class="reqn">\epsilon^{vu}</code> regulate the degree of contamination;
<code class="reqn">v_e^{\epsilon}</code> and <code class="reqn">v_u^{\epsilon}</code>
define the variance of the contamination part of the mixture distribution.
</p>
<p>Four different contamination setups are possible:
</p>

<ul>
<li><p> no contamination (i.e., <code>ve.epsilon = vu.epsilon = 0</code>),
</p>
</li>
<li><p> contaminated model error (i.e., <code>ve.epsilon != 0</code> and
<code>vu.epsilon = 0</code>),
</p>
</li>
<li><p> contaminated random effect (i.e., <code>ve.epsilon = 0</code> and
<code>vu.epsilon != 0</code>),
</p>
</li>
<li><p> both are conaminated (i.e., <code>ve.epsilon != 0</code> and
<code>vu.epsilon != 0</code>).
</p>
</li></ul>



<h3>Value</h3>

<p>An instance of the class <code>saemodel</code>.
</p>


<h3>References</h3>

<p>Schoch, T. (2012). Robust Unit-Level Small Area Estimation: A Fast Algorithm
for Large Datasets. <em>Austrian Journal of Statistics</em> <b>41</b>,
243&ndash;265. <a href="https://doi.org/10.17713/ajs.v41i4.1548">doi:10.17713/ajs.v41i4.1548</a>
</p>
<p>Stahel, W. A. and A. Welsh (1997).
Approaches to robust estimation in the simplest variance components model.
<em>Journal of Statistical Planning and Inference</em> <b>57</b>, 295&ndash;319.
<a href="https://doi.org/10.1016/S0378-3758%2896%2900050-X">doi:10.1016/S0378-3758(96)00050-X</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+saemodel">saemodel()</a></code>,
<code><a href="#topic+fitsaemodel">fitsaemodel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a model with synthetic data
model &lt;- makedata()
model

# summary of the model
summary(model)
</code></pre>

<hr>
<h2 id='robpredict'>Robust Prediction of Random Effects, Fixed Effects, and
Area-Specific Means</h2><span id='topic+robpredict'></span><span id='topic+print.pred_model_b'></span><span id='topic+plot.pred_model_b'></span><span id='topic+residuals.pred_model_b'></span><span id='topic+as.matrix.pred_model_b'></span><span id='topic+head.pred_model_b'></span><span id='topic+tail.pred_model_b'></span>

<h3>Description</h3>

<p>Function <code>robpredict()</code> predicts the area-level means by (1) the
empirical best linear unbiased predictor (EBLUP) or (2) a robust
prediction method which is due to Copt and Victoria-Feser (2009).
In addition, the function computes the mean square prediction
error (MSPE) of the predicted area-level means by a parametric
bootstrap method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robpredict(fit, areameans = NULL, k = NULL, reps = NULL, seed = 1024,
    progress_bar = TRUE)

## S3 method for class 'pred_model_b'
print(x, digits = max(3L, getOption("digits") - 3L),
    ...)
## S3 method for class 'pred_model_b'
plot(x, type = "e", sort = NULL, ...)
## S3 method for class 'pred_model_b'
residuals(object, ...)
## S3 method for class 'pred_model_b'
as.matrix(x, ...)
## S3 method for class 'pred_model_b'
head(x, n = 6L, ...)
## S3 method for class 'pred_model_b'
tail(x, n = 6L, keepnums = TRUE, addrownums, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robpredict_+3A_fit">fit</code></td>
<td>
<p>an object of class <code>fit_model_b</code>; a fitted SAE model.</p>
</td></tr>
<tr><td><code id="robpredict_+3A_areameans">areameans</code></td>
<td>
<p><code>[matrix</code>]  or <code>[NULL]</code> area-level means of
dimension <code>(g, p)</code>, where <code>g</code> and <code>p</code> denote,
respectively, the number of areas and number of fixed-effects terms
in the regression model (incl. intercept). By default,
<code>areadata = NULL</code> which implies that the predictions are
base on the data used in fitting the model (not new data).</p>
</td></tr>
<tr><td><code id="robpredict_+3A_k">k</code></td>
<td>
<p><code>[numeric]</code> or <code>[NULL]</code> robustness tuning constant
(of the Huber psi-function) for robust prediction. Note that
<code>k</code> does not necessarily have to be the same as the <code>k</code>
that has been used in <code><a href="#topic+fitsaemodel">fitsaemodel()</a></code>.
By default, <code>k = NULL</code> which implies that the tuning constant
specified in <code>fitsaemodel()</code> is used.</p>
</td></tr>
<tr><td><code id="robpredict_+3A_reps">reps</code></td>
<td>
<p><code>[integer</code>] or <code>[NULL]</code> number of bootstrap
replicates for the computation of the mean squared prediction
error (MSPE).  If <code>reps = NULL</code> the MSPE is not computed.</p>
</td></tr>
<tr><td><code id="robpredict_+3A_seed">seed</code></td>
<td>
<p><code>[integer]</code> a positive integer used as argument
<code>seed</code> in <code><a href="base.html#topic+set.seed">set.seed()</a></code> to specify
the random seed.</p>
</td></tr>
<tr><td><code id="robpredict_+3A_progress_bar">progress_bar</code></td>
<td>
<p><code>[logical]</code> whether a progress bar is displayed
for the parametric bootstrap; see <b>NOTE</b> below.</p>
</td></tr>
<tr><td><code id="robpredict_+3A_x">x</code></td>
<td>
<p>an object of class <code>"pred_model_b"</code>.</p>
</td></tr>
<tr><td><code id="robpredict_+3A_digits">digits</code></td>
<td>
<p><code>[integer]</code> number of digits to be printed by.</p>
</td></tr>
<tr><td><code id="robpredict_+3A_type">type</code></td>
<td>
<p><code>[character]</code> type of <code>plot</code> method: <code>"e"</code>
(error bars; default) or <code>"l"</code> (lines).</p>
</td></tr>
<tr><td><code id="robpredict_+3A_sort">sort</code></td>
<td>
<p><code>[character]</code> or <code>[NULL]</code> if <code>sort = "means"</code>,
the predicted means are plotted in ascending order (default:
<code>sort = NULL</code>); similarly, with <code>sort = "fixef"</code> and
<code>sort = "ranef"</code> the predicted means are sorted along the
fixed effects or the random effects, respectively.</p>
</td></tr>
<tr><td><code id="robpredict_+3A_object">object</code></td>
<td>
<p>an object of class <code>fit_model_b</code>.</p>
</td></tr>
<tr><td><code id="robpredict_+3A_n">n</code></td>
<td>
<p><code>[integer]</code> vector of length up to <code>dim(x)</code>, i.e.,
number of areas.</p>
</td></tr>
<tr><td><code id="robpredict_+3A_keepnums">keepnums</code></td>
<td>
<p>in each dimension, if no names in that dimension are
present, create them using the indices included in that dimension.
Ignored if <code>dim(x)</code> is <code>NULL</code> or its length 1.</p>
</td></tr>
<tr><td><code id="robpredict_+3A_addrownums">addrownums</code></td>
<td>
<p>deprecated - <code>keepnums</code> should be used instead.</p>
</td></tr>
<tr><td><code id="robpredict_+3A_...">...</code></td>
<td>
<p>additional arguments (not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>robpredict()</code> computes predictions of the area-level means
and&mdash;if required&mdash;an estimate of the area-specific mean square
prediction error (MSPE).
</p>

<dl>
<dt>Prediction of area-level means</dt><dd>

<ul>
<li><p> Case 1: If <code>areameans</code> is a <code>matrix</code> with
area-level means of the explanatory variables, then
the computation of the fixed effects effects are
based on <code>areameans</code>.
</p>
</li>
<li><p> Case 2: If <code>areameans = NULL</code>, then the predictions
are based on the sample data that have been used to
fit the model.
</p>
</li></ul>

</dd>
<dt>Mean square prediction error</dt><dd>

<ul>
<li><p> If <code>reps = NULL</code>, the number of bootstrap
replicates is not specified; hence, MSPE is not computed.
</p>
</li>
<li><p> If <code>reps</code> is a positive integer and
<code>areameans</code> is not <code>NULL</code> (see Case 1 above), then
a (robust) parametric bootstrap estimate of MSPE is computed
as proposed by Sinha and Rao (2009); see also Lahiri (2003)
and Hall.
</p>
</li></ul>

</dd>
<dt>Robustness</dt><dd>

<ul>
<li><p> The EBLUP obtains if <code>k = NULL</code>, i.e., if the
robustness tuning constant <code>k</code> is unspecified.
</p>
</li>
<li><p> Robust predictions of the area-level means are
computed if <code>k</code> is a nonnegative real number.
Small values of <code>k</code> imply that outliers are
heavily downweighted; formally, the EBLUP corresponds
to choosing the tuning constant <code>k</code> equal to
infinity. The value of the tuning constant <code>k</code>
specified in <code>robpredict()</code> can be different
from the tuning constant <code>k</code> used in fitting
the model. The robust prediction method is due to Copt
and Victoria-Feser (2009); see also Heritier et al.
(2009, 113-114) and differs from the method in Sinha
and Rao (2009).
</p>
</li></ul>

</dd>
</dl>



<h3>Value</h3>

<p>An instance of the S3 class <code>pred_model_b</code>
</p>


<h3>NOTE</h3>

<p>Users of <code>Rgui.exe</code> on Windows are recommended to call
<code>robpredict()</code> with argument <code>progress_bar = FALSE</code>
because <code>Rgui.exe</code> does not handle calls to
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar()</a></code> well (the
execution time of the same job increases and it tends to stall the
execution of R). Users of <code>R-Studio</code> and <code>Rterm.exe</code>
are <b>not</b> affected.
</p>


<h3>References</h3>

<p>Copt, S. and M.-P. Victoria-Feser (2009).
<em>Robust Predictions in Mixed Linear Models</em>,
Research Report, University of Geneva.
</p>
<p>Lahiri, P. (2003).
On the impact of bootstrap in survey sampling and small area estimation.
<em>Statistical Science</em> <b>18</b>, 199&ndash;210.
<a href="https://doi.org/10.1214/ss/1063994975">doi:10.1214/ss/1063994975</a>
</p>
<p>Hall, P. and T. Maiti (2006).
On parametric bootstrap methods for small area prediction.
<em>Journal of the Royal Statistical Society. Series B</em> <b>68</b>,
221&ndash;238. <a href="https://doi.org/10.1111/j.1467-9868.2006.00541.x">doi:10.1111/j.1467-9868.2006.00541.x</a>
</p>
<p>Heritier, S., Cantoni, E., Copt, S., and M.-P. Victoria-Feser (2009).
<em>Robust methods in biostatistics</em>. New York: John Wiley and Sons.
</p>
<p>Schoch, T. (2012). Robust Unit-Level Small Area Estimation: A Fast Algorithm
for Large Datasets. <em>Austrian Journal of Statistics</em> <b>41</b>,
243&ndash;265. <a href="https://doi.org/10.17713/ajs.v41i4.1548">doi:10.17713/ajs.v41i4.1548</a>
</p>
<p>Sinha, S.K. and J.N.K. Rao (2009).
Robust small area estimation.
<em>Canadian Journal of Statistics</em> <b>37</b>, 381&ndash;399.
<a href="https://doi.org/10.1002/cjs.10029">doi:10.1002/cjs.10029</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+saemodel">saemodel()</a></code>, <code><a href="#topic+makedata">makedata()</a></code>,
<code><a href="#topic+fitsaemodel">fitsaemodel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use the landsat data
head(landsat)

# set up the model
model &lt;- saemodel(formula = HACorn ~ PixelsCorn + PixelsSoybeans,
    area = ~CountyName,
    data = subset(landsat, subset = (outlier == FALSE)))

# summary of the model
summary(model)

# Huber M-estimate with robustness tuning constant k = 2
m &lt;- fitsaemodel("huberm", model, k = 2)
m

# summary of the fitted model/ estimates
summary(m)

# robust prediction of the random effects and the area-level means (robust
# EBLUP) using the counts-specific means (landsat_means)
head(landsat_means)

# for robust prediction, we use the robustness tuning constant 'k = 1.8'
m_predicted &lt;- robpredict(m, landsat_means, k = 1.8)
head(m_predicted)

# extract prediction as matrix
as.matrix(m_predicted)

# extract residuals from the predictions
head(residuals(m_predicted))

# prediction incl. MSPE; parametric bootstrap with only 'reps = 10'
# replications (for demonstration purposes; in practice, 'reps' should be
# considerably larger)
m_predicted_mspe &lt;- robpredict(m, landsat_means, k = 1.8, reps = 10,
                               progress_bar = FALSE)
head(m_predicted_mspe)
</code></pre>

<hr>
<h2 id='saemodel'>Setting Up a SAE Model</h2><span id='topic+saemodel'></span><span id='topic+print.saemodel'></span><span id='topic+summary.saemodel'></span><span id='topic+as.matrix.saemodel'></span>

<h3>Description</h3>

<p>Function <code>saemodel()</code> is used to specify a model. Once a model
has been specified, it can be fitted using
<code><a href="#topic+fitsaemodel">fitsaemodel()</a></code> by different estimation methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saemodel(formula, area, data, type = "b", na.omit = FALSE)

## S3 method for class 'saemodel'
print(x, ...)
## S3 method for class 'saemodel'
summary(object, ...)
## S3 method for class 'saemodel'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saemodel_+3A_formula">formula</code></td>
<td>
<p>a <code>formula</code> object of describing the fixed-effects
part of the model, with the response on the RHS of the <code>~</code>
operator and the terms or regressors, separated by <code>+</code>
operators, on the LHS of the formula.</p>
</td></tr>
<tr><td><code id="saemodel_+3A_area">area</code></td>
<td>
<p>a one-sided <code>formula</code> object. A <code>~</code> operator
followed by only one single term defining the area-specific
random-effect part.</p>
</td></tr>
<tr><td><code id="saemodel_+3A_data">data</code></td>
<td>
<p>data.frame.</p>
</td></tr>
<tr><td><code id="saemodel_+3A_type">type</code></td>
<td>
<p><code>[character]</code> <code>"a"</code> or <code>"b"</code> refering to
J.N.K. Rao's definition of model type A (area-level model) or B
(unit-level model); default is <code>"b"</code>.</p>
</td></tr>
<tr><td><code id="saemodel_+3A_na.omit">na.omit</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values
should be removed before the computation proceeds. Note that none
of the algorithms can cope with missing values.</p>
</td></tr>
<tr><td><code id="saemodel_+3A_x">x</code></td>
<td>
<p>an object of class <code>"saemodel"</code>.</p>
</td></tr>
<tr><td><code id="saemodel_+3A_object">object</code></td>
<td>
<p>an object of the class <code>"saemodel"</code>.</p>
</td></tr>
<tr><td><code id="saemodel_+3A_...">...</code></td>
<td>
<p>additional arguments (not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>saemodel()</code> is used to specify a model.
</p>

<ul>
<li> <p><code>model</code> is a symbolic description (<code>formula</code> of the
fixed-effects model to be fitted.
</p>
<p>A typical model has the form <code>response ~ terms</code> where
<code>response</code> is the (numeric) response vector and
<code>terms</code> is a series of terms which specifies a linear
predictor for response (explanatory variables); see
<code><a href="stats.html#topic+formula">formula</a></code>.
</p>
<p>A <code>formula</code> has an implied intercept term. To remove
this use either <code>y ~ x - 1</code> or <code>y ~ 0 + x</code>;
see <code><a href="stats.html#topic+formula">formula</a></code> for more details of allowed formulae.
</p>
</li>
<li> <p><code>area</code> is a symbolic description (<code>formula</code>) of
the random effects (nested error structure). It must be
right-hand side only formula consisting of one term,
e.g., <code>~ areaDefinition</code>.
</p>
</li></ul>

<p>The data must no contain missing values.
</p>
<p>The design matrix (i.e., matrix of the explanatory variables
defined the right-hand side of <code>model</code>) must have full column
rank; otherwise execution is terminated by an error.
</p>
<p>Once a model has been specified, it can be fitted by
<code><a href="#topic+fitsaemodel">fitsaemodel()</a></code>.
</p>


<h3>Value</h3>

<p>An instance of the S3 class <code>"saemodel"</code>
</p>


<h3>References</h3>

<p>Rao, J.N.K. (2003). <em>Small Area Estimation</em>, New York: John Wiley and Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makedata">makedata()</a></code>,
<code><a href="#topic+fitsaemodel">fitsaemodel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use the landsat data
head(landsat)

# set up the model
model &lt;- saemodel(formula = HACorn ~ PixelsCorn + PixelsSoybeans,
    area = ~CountyName,
    data = subset(landsat, subset = (outlier == FALSE)))

# summar of the model
summary(model)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
