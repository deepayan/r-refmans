<!DOCTYPE html><html lang="en"><head><title>Help for package heatwaveR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {heatwaveR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#heatwaveR-package'><p>heatwaveR: Detect Heatwaves and Cold-Spells</p></a></li>
<li><a href='#Algiers'><p>Daily maximum (tX) and minimum (tN) air temperatures for Algiers, Algeria.</p></a></li>
<li><a href='#block_average'><p>Calculate yearly means for event metrics.</p></a></li>
<li><a href='#category'><p>Calculate the categories of events.</p></a></li>
<li><a href='#clim_calc'><p>Calculate seasonal and threshold climatologies as well as the variance.</p></a></li>
<li><a href='#clim_spread'><p>Spead a time series wide to allow for a climatology to be calculated.</p></a></li>
<li><a href='#detect_event'><p>Detect heatwaves and cold-spells.</p></a></li>
<li><a href='#event_line'><p>Create a line plot of heatwaves or cold-spells.</p></a></li>
<li><a href='#exceedance'><p>Detect consecutive days in exceedance of a given threshold.</p></a></li>
<li><a href='#geom_flame'><p>Create 'flame' polygons.</p></a></li>
<li><a href='#geom_lolli'><p>Visualise a timeline of several event metrics as 'lollipops'.</p></a></li>
<li><a href='#lolli_plot'><p>Create a timeline of selected event metrics as 'lollipops'.</p></a></li>
<li><a href='#make_whole'><p>Constructs a continuous, uninterrupted time series of temperatures.</p></a></li>
<li><a href='#make_whole_fast'><p>Constructs a continuous, uninterrupted time series of temperatures (faster).</p></a></li>
<li><a href='#na_interp'><p>Pad NA gaps of user-defined width with interpolated values.</p></a></li>
<li><a href='#proto_event'><p>Detect proto-events based on a chosen criterion (column).</p></a></li>
<li><a href='#smooth_percentile'><p>Detect the climatology for a time series.</p></a></li>
<li><a href='#sst_Med'><p>NOAA Optimally Interpolated (OI) v2.1 daily 1/4 degree SST for the Mediterranean region.</p></a></li>
<li><a href='#sst_NW_Atl'><p>NOAA Optimally Interpolated (OI) v2.1 daily 1/4 degree SST for the NW Atlantic region.</p></a></li>
<li><a href='#sst_WA'><p>NOAA Optimally Interpolated (OI) v2.1 daily 1/4 degree SST for the Western Australian region.</p></a></li>
<li><a href='#ts2clm'><p>Make a climatology from a daily time series.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.4.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-10-26</td>
</tr>
<tr>
<td>Title:</td>
<td>Detect Heatwaves and Cold-Spells</td>
</tr>
<tr>
<td>Description:</td>
<td>The different methods for defining, detecting, and categorising the extreme events 
    known as heatwaves or cold-spells, as first proposed in Hobday et al. (2016) &lt;<a href="https://doi.org/10.1016%2Fj.pocean.2015.12.014">doi:10.1016/j.pocean.2015.12.014</a>&gt; 
    and Hobday et al. (2018) <a href="https://www.jstor.org/stable/26542662">https://www.jstor.org/stable/26542662</a>. The functions in this package work on both air 
    and water temperature data. These detection algorithms may be used on non-temperature data as well.</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robert W. Schlegel &lt;robwschlegel@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>doParallel, covr, ggpubr, knitr, ncdf4, rerddap, rmarkdown,
testthat, tidync, tidyr</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, dplyr, ggplot2, grid, lubridate, plyr, Rcpp,
RcppRoll, stats, tibble, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.12.16), RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://robwschlegel.github.io/heatwaveR/index.html">https://robwschlegel.github.io/heatwaveR/index.html</a>,
<a href="https://github.com/robwschlegel/heatwaveR">https://github.com/robwschlegel/heatwaveR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/robwschlegel/heatwaveR/issues">https://github.com/robwschlegel/heatwaveR/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-26 08:38:20 UTC; robert</td>
</tr>
<tr>
<td>Author:</td>
<td>Robert W. Schlegel
    <a href="https://orcid.org/0000-0002-0705-1287"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    ctb],
  Albertus J. Smit <a href="https://orcid.org/0000-0002-3799-6126"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-27 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='heatwaveR-package'>heatwaveR: Detect Heatwaves and Cold-Spells</h2><span id='topic+heatwaveR'></span><span id='topic+heatwaveR-package'></span>

<h3>Description</h3>

<p>The different methods for defining, detecting, and categorising the extreme events known as heatwaves or cold-spells, as first proposed in Hobday et al. (2016) &lt;doi: 10.1016/j.pocean.2015.12.014&gt; and Hobday et al. (2018) &lt;https://www.jstor.org/stable/26542662&gt;. The functions in this package work on both air and water temperature data. These detection algorithms may be used on non-temperature data as well.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Robert W. Schlegel <a href="mailto:robwschlegel@gmail.com">robwschlegel@gmail.com</a> (<a href="https://orcid.org/0000-0002-0705-1287">ORCID</a>) [contributor]
</p>
<p>Authors:
</p>

<ul>
<li><p> Albertus J. Smit (<a href="https://orcid.org/0000-0002-3799-6126">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://robwschlegel.github.io/heatwaveR/index.html">https://robwschlegel.github.io/heatwaveR/index.html</a>
</p>
</li>
<li> <p><a href="https://github.com/robwschlegel/heatwaveR">https://github.com/robwschlegel/heatwaveR</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/robwschlegel/heatwaveR/issues">https://github.com/robwschlegel/heatwaveR/issues</a>
</p>
</li></ul>


<hr>
<h2 id='Algiers'>Daily maximum (tX) and minimum (tN) air temperatures for Algiers, Algeria.</h2><span id='topic+Algiers'></span>

<h3>Description</h3>

<p>A dataset containing the daily maximum and minimum air temperatures
(in degrees Celsius) and date for Algiers, Algeria
for the period 1961-01-01 to 2005-12-31.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Algiers
</code></pre>


<h3>Format</h3>

<p>A data frame with 16436 rows and 3 variables:
</p>

<dl>
<dt>t</dt><dd><p>date, as.Date() format</p>
</dd>
<dt>tMax</dt><dd><p>daily max. temperature, in degrees Celsius</p>
</dd>
<dt>tMin</dt><dd><p>daily min. temperature, in degrees Celsius</p>
</dd>
</dl>
<p>...

</p>


<h3>Details</h3>

<p>lon/lat:
</p>


<h3>Source</h3>

<p>Mr. Haouari Mahmoud, IHFR, Algeria
</p>

<hr>
<h2 id='block_average'>Calculate yearly means for event metrics.</h2><span id='topic+block_average'></span>

<h3>Description</h3>

<p>Calculate yearly means for event metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_average(data, x = t, y = temp, report = "full")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="block_average_+3A_data">data</code></td>
<td>
<p>Accepts the data returned by the <code><a href="#topic+detect_event">detect_event</a></code> function.</p>
</td></tr>
<tr><td><code id="block_average_+3A_x">x</code></td>
<td>
<p>This column is expected to contain a vector of dates as per the
specification of <code>ts2clm</code>. If a column headed <code>t</code> is present in
the dataframe, this argument may be ommitted; otherwise, specify the name of
the column with dates here.</p>
</td></tr>
<tr><td><code id="block_average_+3A_y">y</code></td>
<td>
<p>This is a column containing the measurement variable. If the column
name differs from the default (i.e. <code>temp</code>), specify the name here.</p>
</td></tr>
<tr><td><code id="block_average_+3A_report">report</code></td>
<td>
<p>Specify either <code>full</code> or <code>partial</code>. Selecting <code>full</code> causes
the report to contain NAs for any years in which no events were detected
(except for <code>count</code>, which will be zero in those years), while <code>partial</code>
reports only the years wherein events were detected. The default is <code>full</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function needs to be provided with the full output from the <code>detect_event</code>
or <code>exceedance</code> functions. Note that the yearly averages are calculted only for
complete years (i.e. years that start/end part-way through the year at the beginning
or end of the original time series are removed from the calculations).
</p>
<p>This function differs from the python implementation of the function of the
same name (i.e., <code>blockAverage</code>, see <a href="https://github.com/ecjoliver/marineHeatWaves">https://github.com/ecjoliver/marineHeatWaves</a>)
in that we only provide the ability to calculate the average (or aggregate)
event metrics in 'blocks' of one year, while the python version allows
arbitrary (integer) block sizes.
</p>
<p>Note that if this function is used on the output of <code>exceedance</code>, all of the metrics
(see below) with <code>relThresh</code> in the name will be returned as <code>NA</code> values.
</p>


<h3>Value</h3>

<p>The function will return a data frame of the averaged (or aggregate)
metrics. It includes the following:
</p>
<table role = "presentation">
<tr><td><code>year</code></td>
<td>
<p>The year over which the metrics were averaged.</p>
</td></tr>
<tr><td><code>count</code></td>
<td>
<p>The number of events per year.</p>
</td></tr>
<tr><td><code>duration</code></td>
<td>
<p>The average duration of events per year [days].</p>
</td></tr>
<tr><td><code>duration_max</code></td>
<td>
<p>The maximum duration of an event in each year [days].</p>
</td></tr>
<tr><td><code>intensity_mean</code></td>
<td>
<p>The average event &quot;mean intensity&quot; in each year [deg. C].</p>
</td></tr>
<tr><td><code>intensity_max</code></td>
<td>
<p>The average event &quot;maximum (peak) intensity&quot; in each year
[deg. C].</p>
</td></tr>
<tr><td><code>intensity_max_max</code></td>
<td>
<p>The maximum event &quot;maximum (peak) intensity&quot; in
each year [deg. C].</p>
</td></tr>
<tr><td><code>intensity_var</code></td>
<td>
<p>The average event &quot;intensity variability&quot; in each year
[deg. C].</p>
</td></tr>
<tr><td><code>intensity_cumulative</code></td>
<td>
<p>The average event &quot;cumulative intensity&quot; in each year
[deg. C x days].</p>
</td></tr>
<tr><td><code>rate_onset</code></td>
<td>
<p>Average event onset rate in each year [deg. C / days].</p>
</td></tr>
<tr><td><code>rate_decline</code></td>
<td>
<p>Average event decline rate in each year [deg. C / days].</p>
</td></tr>
<tr><td><code>total_days</code></td>
<td>
<p>Total number of events days in each year [days].</p>
</td></tr>
<tr><td><code>total_icum</code></td>
<td>
<p>Total cumulative intensity over all events in each year [deg. C x days].</p>
</td></tr>
</table>
<p><code>intensity_max_relThresh</code>, <code>intensity_mean_relThresh</code>,
<code>intensity_var_relThresh</code>, and <code>intensity_cumulative_relThresh</code>
are as above except relative to the threshold (e.g., 90th percentile) rather
than the seasonal climatology.
</p>
<p><code>intensity_max_abs</code>, <code>intensity_mean_abs</code>, <code>intensity_var_abs</code>, and
<code>intensity_cumulative_abs</code> are as above except as absolute magnitudes
rather than relative to the seasonal climatology or threshold.
</p>


<h3>Author(s)</h3>

<p>Albertus J. Smit, Eric C. J. Oliver, Robert W. Schlegel
</p>


<h3>References</h3>

<p>Hobday, A.J. et al. (2016), A hierarchical approach to defining
marine heatwaves, Progress in Oceanography, 141, pp. 227-238,
doi: 10.1016/j.pocean.2015.12.014
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ts &lt;- ts2clm(sst_WA, climatologyPeriod = c("1983-01-01", "2012-12-31"))
res &lt;- detect_event(ts)
out &lt;- block_average(res)
summary(glm(count ~ year, out, family = "poisson"))

library(ggplot2)

ggplot(data = out, aes(x = year, y = count)) +
  geom_point(colour = "salmon") +
  geom_line() +
  labs(x = NULL, y = "Number of events")

</code></pre>

<hr>
<h2 id='category'>Calculate the categories of events.</h2><span id='topic+category'></span>

<h3>Description</h3>

<p>Calculates the categories of MHWs or MCSs produced by <code><a href="#topic+detect_event">detect_event</a></code> in
accordance with the naming scheme proposed in Hobday et al. (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>category(
  data,
  y = temp,
  S = TRUE,
  name = "Event",
  climatology = FALSE,
  MCScorrect = F,
  season = "range",
  roundVal = 4
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="category_+3A_data">data</code></td>
<td>
<p>The function receives the full (list) output from the
<code><a href="#topic+detect_event">detect_event</a></code> function.</p>
</td></tr>
<tr><td><code id="category_+3A_y">y</code></td>
<td>
<p>The column containing the measurement variable. If the column
name differs from the default (i.e. <code>temp</code>), specify the name here.</p>
</td></tr>
<tr><td><code id="category_+3A_s">S</code></td>
<td>
<p>This argument informs the function if the data were collected in the
southern hemisphere (TRUE, default) or the northern hemisphere (FALSE) so that it may correctly
output the <code>season</code> column (see below).</p>
</td></tr>
<tr><td><code id="category_+3A_name">name</code></td>
<td>
<p>If a character string (e.g. &quot;Bohai Sea&quot;) is provided here it will be used
to name the events in the <code>event_name</code> column (see below) of the output.
If no value is provided the default output is &quot;Event&quot;.</p>
</td></tr>
<tr><td><code id="category_+3A_climatology">climatology</code></td>
<td>
<p>The default setting of <code>FALSE</code> will tell this function to output only
the summary (wide) results for the individual events as seen in Hobday et al. (2018). If set
to <code>TRUE</code>, this function will return a list of two dataframes, same
as <code><a href="#topic+detect_event">detect_event</a></code>. The first dataframe <code>climatology</code>, contains the same
information as found in <code><a href="#topic+detect_event">detect_event</a></code>, but with the addition of the daily
intensity (anomaly above seasonal doy threshold) and category values. The second dataframe,
<code>event</code>, is the summary results that this function produces by default.</p>
</td></tr>
<tr><td><code id="category_+3A_mcscorrect">MCScorrect</code></td>
<td>
<p>When calculating marine cold-spells (MCSs) it may occur in some areas
that the bottom thresholds for the more intense categories will be below -1.8C,
this is physically impossible on Earth, so if one wants to correct the bottom thresholds
to not be able to exceed -1.8C, set this argument to TRUE (default is FALSE).</p>
</td></tr>
<tr><td><code id="category_+3A_season">season</code></td>
<td>
<p>This argument allows the user to decide how the season(s) of occurrence for
the MHWs are labelled. The default setting of <code>"range"</code> will return the range of seasons
over which the MHW occurred, as seen in Hobday et al. (2018). One may chose to rather have
this function return only the season during the &quot;start&quot;, &quot;peak&quot;, or &quot;end&quot; of the MHW by giving
the corresponding character vector.</p>
</td></tr>
<tr><td><code id="category_+3A_roundval">roundVal</code></td>
<td>
<p>This argument allows the user to choose how many decimal places
the outputs will be rounded to. Default is 4. To
prevent rounding set <code>roundClm = FALSE</code>. This argument may only be given
numeric values or FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An explanation for the categories is as follows:
</p>

<ol>
<li><p>I Moderate-Events that have been detected, but with a maximum intensity that does not
double the distance between the seasonal climatology and the threshold value.
</p>
</li>
<li><p>II Strong-Events with a maximum intensity that doubles the distance from the seasonal
climatology and the threshold, but do not triple it.
</p>
</li>
<li><p>III Severe-Events that triple the aforementioned distance, but do not quadruple it.
</p>
</li>
<li><p>IV Extreme-Events with a maximum intensity that is four times or greater than the
aforementioned distance. Scary stuff...
</p>
</li></ol>



<h3>Value</h3>

<p>The function will return a tibble with results similar to those seen in
Table 2 of Hobday et al. (2018). This provides the information necessary to
appraise the extent of the events in the output of <code><a href="#topic+detect_event">detect_event</a></code> based on the
category ranking scale. The category thresholds are calculated based on the difference
between the given seasonal climatology and threshold climatology. The four category levels
are then the difference multiplied by the category level.
</p>
<p>The definitions for the default output columns are as follows:
</p>
<table role = "presentation">
<tr><td><code>event_no</code></td>
<td>
<p>The number of the event as determined by <code><a href="#topic+detect_event">detect_event</a></code>
to allow for joining between the outputs.</p>
</td></tr>
<tr><td><code>event_name</code></td>
<td>
<p>The name of the event. Generated from the <code><a href="base.html#topic+name">name</a></code>
value provided and the year of the <code>peak_date</code> (see following) of
the event. If no <code><a href="base.html#topic+name">name</a></code> value is provided the default &quot;Event&quot; is used.
As proposed in Hobday et al. (2018), <code>Moderate</code> events are not given a name
so as to prevent multiple repeat names within the same year. If two or more events
ranked greater than Moderate are reported within the same year, they will be
differentiated with the addition of a trailing letter
(e.g. Event 2001a, Event 2001b).</p>
</td></tr>
<tr><td><code>peak_date</code></td>
<td>
<p>The date (day) on which the maximum intensity of the event
was recorded.</p>
</td></tr>
<tr><td><code>category</code></td>
<td>
<p>The maximum category threshold reached/exceeded by the event.</p>
</td></tr>
<tr><td><code>i_max</code></td>
<td>
<p>The maximum intensity of the event above the threshold value.</p>
</td></tr>
<tr><td><code>duration</code></td>
<td>
<p>The total duration (days) of the event. Note that this includes
any possible days when the measurement value <code>y</code>) may have dropped below the
threshold value. Therefore, the proportion of the event duration (days) spent above
certain thresholds may not add up to 100% (see following four items).</p>
</td></tr>
<tr><td><code>p_moderate</code></td>
<td>
<p>The proportion of the total duration (days) spent at or above
the first threshold, but below any further thresholds.</p>
</td></tr>
<tr><td><code>p_strong</code></td>
<td>
<p>The proportion of the total duration (days) spent at or above
the second threshold, but below any further thresholds.</p>
</td></tr>
<tr><td><code>p_severe</code></td>
<td>
<p>The proportion of the total duration (days) spent at or above
the third threshold, but below the fourth threshold.</p>
</td></tr>
<tr><td><code>p_extreme</code></td>
<td>
<p>The proportion of the total duration (days) spent at or above
the fourth and final threshold.</p>
</td></tr>
<tr><td><code>season</code></td>
<td>
<p>The season(s) during which the event occurred. If the event
occurred across two seasons this will be displayed as e.g. &quot;Winter/Spring&quot;.
Across three seasons as e.g. &quot;Winter-Summer&quot;. Events lasting across four or more
seasons are listed as &quot;Year-round&quot;. December (June) is used here as the start of
Austral (Boreal) summer. If &quot;start&quot;, &quot;peak&quot;, or &quot;end&quot; was given to the <code>season</code>
argument then only the one season during that chosen period will be given.</p>
</td></tr>
</table>
<p>If <code>climatology = TRUE</code>, this function will output a list of two dataframes.
The first dataframe, <code>climatology</code>, will contain the following columns:
</p>
<table role = "presentation">
<tr><td><code>t</code></td>
<td>
<p>The column containing the daily date values.</p>
</td></tr>
<tr><td><code>event_no</code></td>
<td>
<p>The numeric event number label.</p>
</td></tr>
<tr><td><code>intensity</code></td>
<td>
<p>The daily exceedance (default is degrees C) above the
seasonal climatology.</p>
</td></tr>
<tr><td><code>category</code></td>
<td>
<p>The category classification per day.</p>
</td></tr>
</table>
<p>The second dataframe, <code>event</code>, contains the default output of this function,
as detailed above.
</p>


<h3>Author(s)</h3>

<p>Robert W. Schlegel
</p>


<h3>References</h3>

<p>Hobday et al. (2018). Categorizing and Naming
Marine Heatwaves. Oceanography 31(2).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res_WA &lt;- detect_event(ts2clm(sst_WA,
                       climatologyPeriod = c("1983-01-01", "2012-12-31")))
# Note that the name argument expects a character vector
cat_WA &lt;- category(res_WA, name = "WA")
tail(cat_WA)

# If the data were collected in the northern hemisphere
# we must let the function know this, as seen below
res_Med &lt;- detect_event(ts2clm(sst_Med,
                        climatologyPeriod = c("1983-01-01", "2012-12-31")))
cat_Med &lt;- category(res_Med, S = FALSE, name = "Med")
tail(cat_Med)

# One may also choose to have this function output the daily
# category classifications as well by setting: climatology = TRUE
cat_WA_daily &lt;- category(res_WA, name = "WA", climatology = TRUE)
head(cat_WA_daily$climatology)

# Note that this will not return the complete time series, only the
# days during which events were detected.
# This was done to reduce the size of the output for those working
# with gridded data.
# Should one want a complete time series, the daily category results
# may simply be left_join() with the detect_event() results
cat_WA_ts &lt;- dplyr::left_join(res_WA$climatology,
                              cat_WA_daily$climatology)
head(cat_WA_ts)

</code></pre>

<hr>
<h2 id='clim_calc'>Calculate seasonal and threshold climatologies as well as the variance.</h2><span id='topic+clim_calc'></span>

<h3>Description</h3>

<p>An internal function that helps to create the climatologies that are
then output with <code><a href="#topic+ts2clm">ts2clm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clim_calc(data, windowHalfWidth, pctile)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clim_calc_+3A_data">data</code></td>
<td>
<p>The data given to this function during the calculations
performed by <code><a href="#topic+ts2clm">ts2clm</a></code>.</p>
</td></tr>
<tr><td><code id="clim_calc_+3A_windowhalfwidth">windowHalfWidth</code></td>
<td>
<p>The width of the smoothing window to be applied.
This width is doubled and centred around the point that the smoothing
occurs. Default = 5, which makes an overall window size of 11.</p>
</td></tr>
<tr><td><code id="clim_calc_+3A_pctile">pctile</code></td>
<td>
<p>Threshold percentile (%) for detection of events (MHWs).
Default is <code>90</code>th percentile.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the calculated climatologies.
</p>


<h3>Author(s)</h3>

<p>Smit, A. J.
</p>

<hr>
<h2 id='clim_spread'>Spead a time series wide to allow for a climatology to be calculated.</h2><span id='topic+clim_spread'></span>

<h3>Description</h3>

<p>An internal function that helps to create a wide time series that will
then be used by <code><a href="#topic+clim_calc">clim_calc</a></code> within <code><a href="#topic+ts2clm">ts2clm</a></code>
to produce a climatology as desired by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clim_spread(data, clim_start, clim_end, windowHalfWidth)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clim_spread_+3A_data">data</code></td>
<td>
<p>The data given to this function during the calculations
performed by <code><a href="#topic+ts2clm">ts2clm</a></code>.</p>
</td></tr>
<tr><td><code id="clim_spread_+3A_clim_start">clim_start</code></td>
<td>
<p>The first day of the time series to use when spreading.</p>
</td></tr>
<tr><td><code id="clim_spread_+3A_clim_end">clim_end</code></td>
<td>
<p>The last day of the time series to use when spreading.</p>
</td></tr>
<tr><td><code id="clim_spread_+3A_windowhalfwidth">windowHalfWidth</code></td>
<td>
<p>The width of the smoothing window to be applied.
This width is doubled and centred around the point that the smoothing
occurs. Default = 5, which makes an overall window size of 11.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the data (a matrix) in a wide format.
</p>


<h3>Author(s)</h3>

<p>Smit, A. J.
</p>

<hr>
<h2 id='detect_event'>Detect heatwaves and cold-spells.</h2><span id='topic+detect_event'></span>

<h3>Description</h3>

<p>Applies the Hobday et al. (2016) marine heat wave definition to an input time
series of a given value (usually, but not necessarily limited to, temperature)
along with a daily date vector and pre-calculated seasonal and threshold
climatologies, which may either be created with <code><a href="#topic+ts2clm">ts2clm</a></code> or some
other means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_event(
  data,
  x = t,
  y = temp,
  seasClim = seas,
  threshClim = thresh,
  threshClim2 = NA,
  minDuration = 5,
  minDuration2 = minDuration,
  joinAcrossGaps = TRUE,
  maxGap = 2,
  maxGap2 = maxGap,
  coldSpells = FALSE,
  protoEvents = FALSE,
  categories = FALSE,
  roundRes = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detect_event_+3A_data">data</code></td>
<td>
<p>A data frame with at least four columns. In the default setting
(i.e. omitting the arguments <code>x</code>, <code>y</code>, <code>seas</code>, and <code>thresh</code>;
see immediately below), the data set is expected to have the headers <code>t</code>,
<code>temp</code>, <code>seas</code>, and <code>thresh</code>. The <code>t</code>
column is a vector of dates of class <code>Date</code>, <code>temp</code> is the measured
variable (by default it is assumed to be temperature), <code>seas</code> is the seasonal
cycle daily climatology (366 days), and <code>thresh</code> is the seasonal cycle
daily threshold above which events may be detected. Data of the appropriate
format are created by the function <code><a href="#topic+ts2clm">ts2clm</a></code>, but your own data
can be supplied if they meet the criteria specified by <code><a href="#topic+ts2clm">ts2clm</a></code>.
If the column names of <code>data</code> match those outlined here, the following
four arguments may be ignored.</p>
</td></tr>
<tr><td><code id="detect_event_+3A_x">x</code></td>
<td>
<p>This column is expected to contain a vector of dates as per the
specification of <code><a href="#topic+ts2clm">ts2clm</a></code>. If a column headed <code>t</code> is present in
the dataframe, this argument may be omitted; otherwise, specify the name of
the column with dates here.</p>
</td></tr>
<tr><td><code id="detect_event_+3A_y">y</code></td>
<td>
<p>This is a column containing the measurement variable. If the column
name differs from the default (i.e. <code>temp</code>), specify the name here.</p>
</td></tr>
<tr><td><code id="detect_event_+3A_seasclim">seasClim</code></td>
<td>
<p>The dafault for this argument assumes that the seasonal
climatology column is called <code>seas</code> as this matches the output of
<code><a href="#topic+ts2clm">ts2clm</a></code>. If the column name for the seasonal climatology is
different, provide that here.</p>
</td></tr>
<tr><td><code id="detect_event_+3A_threshclim">threshClim</code></td>
<td>
<p>The threshold climatology column should be called
<code>thresh</code>. If it is not, provide the name of the threshold column here.</p>
</td></tr>
<tr><td><code id="detect_event_+3A_threshclim2">threshClim2</code></td>
<td>
<p>If one wishes to provide a second climatology threshold
filter for the more rigorous detection of events, a vector or column containing
logical values (i.e. TRUE FALSE) should be provided here. By default this
argument is ignored. It's primary purpose is to allow for the inclusion of
tMin and tMax thresholds.</p>
</td></tr>
<tr><td><code id="detect_event_+3A_minduration">minDuration</code></td>
<td>
<p>The minimum duration for acceptance of detected events.
The default is <code>5</code> days.</p>
</td></tr>
<tr><td><code id="detect_event_+3A_minduration2">minDuration2</code></td>
<td>
<p>The minimum duration for acceptance of events after
filtering by <code>threshClim</code> and <code>threshClim</code>. By default
<code>minDuration2 = minDuration</code> and is ignored if <code>threshClim2</code> has not
been specified.</p>
</td></tr>
<tr><td><code id="detect_event_+3A_joinacrossgaps">joinAcrossGaps</code></td>
<td>
<p>Boolean switch indicating whether to join events which
occur before/after a short gap as specified by <code>maxGap</code>. The default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="detect_event_+3A_maxgap">maxGap</code></td>
<td>
<p>The maximum length of gap allowed for the joining of MHWs. The
default is <code>2</code> days.</p>
</td></tr>
<tr><td><code id="detect_event_+3A_maxgap2">maxGap2</code></td>
<td>
<p>The maximum gap length after applying both thresholds.
By default <code>maxGap2 = maxGap</code> and is ignored if <code>threshClim2</code> has not
been specified.</p>
</td></tr>
<tr><td><code id="detect_event_+3A_coldspells">coldSpells</code></td>
<td>
<p>Boolean specifying if the code should detect cold events
instead of warm events. The default is <code>FALSE</code>. Please note that the
climatological thresholds for cold-spells are considered to be the inverse
of those for MHWs. For example, the default setting for the detection of
MHWs is <code>pctile = 90</code>, as seen in <code><a href="#topic+ts2clm">ts2clm</a></code>. Should one want
to use <code>detect_event</code> for MCSs, this threshold would best be generated
in <code><a href="#topic+ts2clm">ts2clm</a></code> by setting <code>pctile = 10</code> (see example below).
Any value may be used, but this is the setting used for the calculation of
MCSs in Schlegel et al. (2017a).</p>
</td></tr>
<tr><td><code id="detect_event_+3A_protoevents">protoEvents</code></td>
<td>
<p>Boolean specifying whether the full time series must be
returned as a long table, together with columns indicating whether or not the
threshold criterion (<code>threshCriterion</code>) and duration criterion (<code>durationCriterion</code>)
have been exceeded, a column showing if a heatwave is present (i.e. both
<code>threshCriterion</code> and <code>durationCriterion</code> <code>TRUE</code>), and a
sequential number uniquely identifying the detected event. In this case,
the heatwave metrics will not be reported. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="detect_event_+3A_categories">categories</code></td>
<td>
<p>Rather than using <code><a href="#topic+category">category</a></code> as a separate step to determine
the categories of the detected MHWs, one may choose to set this argument to <code>TRUE</code>.
One may pass the same arguments used in the <code><a href="#topic+category">category</a></code> function to this function
to affect the output. Note that the default behaviour of <code><a href="#topic+category">category</a></code> is to
return the event data only. To return the same list structure that <code><a href="#topic+detect_event">detect_event</a></code>
outputs by default, use <code>climatology = TRUE</code>.</p>
</td></tr>
<tr><td><code id="detect_event_+3A_roundres">roundRes</code></td>
<td>
<p>This argument allows the user to choose how many decimal places
the MHW metric outputs will be rounded to. Default is 4. To
prevent rounding set <code>roundRes = FALSE</code>. This argument may only be given
numeric values or FALSE.</p>
</td></tr>
<tr><td><code id="detect_event_+3A_...">...</code></td>
<td>
<p>Other arguments that will be passed internally to <code><a href="#topic+category">category</a></code>
when <code>categories = TRUE</code>. See the documentation for <code><a href="#topic+category">category</a></code> for the
list of possible arguments.</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> This function assumes that the input time series consists of continuous
daily values with few missing values. Time ranges which start and end
part-way through the calendar year are supported. The accompanying function
<code><a href="#topic+ts2clm">ts2clm</a></code> aids in the preparation of a time series that is
suitable for use with <code>detect_event</code>, although this may also be accomplished
'by hand' as long as the criteria are met as discussed in the documentation
to <code><a href="#topic+ts2clm">ts2clm</a></code>.
</p>
</li>
<li><p> The calculation of onset and decline rates assumes that the events
started a half-day before the start day and ended a half-day after the
end-day. This is consistent with the duration definition as implemented,
which assumes duration = end day - start day + 1. An event that is already
present at the beginning of a time series, or an event that is still present
at the end of a time series, will report the rate of onset or the rate of
decline as <code>NA</code>, as it is impossible to know what the temperature half a
day before or after the start or end of the event is.
</p>
</li>
<li><p> For the purposes of event detection, any missing temperature values not
interpolated over (through optional <code>maxPadLength</code> in <code><a href="#topic+ts2clm">ts2clm</a></code>)
will be set equal to the seasonal climatology. This means they will trigger
the end/start of any adjacent temperature values which satisfy the event
definition criteria.
</p>
</li>
<li><p> If the code is used to detect cold events (<code>coldSpells = TRUE</code>),
then it works just as for heat waves except that events are detected as
deviations below the (100 - pctile)th percentile (e.g., the 10th instead of
90th) for at least 5 days. Intensities are reported as negative values and
represent the temperature anomaly below climatology.
</p>
</li></ol>

<p>The original Python algorithm was written by Eric Oliver, Institute for
Marine and Antarctic Studies, University of Tasmania, Feb 2015, and is
documented by Hobday et al. (2016). The marine cold spell option was
implemented in version 0.13 (21 Nov 2015) of the Python module as a result
of our preparation of Schlegel et al. (2017), wherein the cold events
receive a brief overview.
</p>


<h3>Value</h3>

<p>The function will return a list of two tibbles (see the <code>tidyverse</code>),
<code>climatology</code> and <code>event</code>, which are, surprisingly, the climatology
and event results, respectively. The climatology contains the full time series of
daily temperatures, as well as the the seasonal climatology, the threshold
and various aspects of the events that were detected. The software was
designed for detecting extreme thermal events, and the units specified below
reflect that intended purpose. However, various other kinds of extreme
events may be detected according to the specifications, and if that is the
case, the appropriate units need to be determined by the user.
</p>
<p>The <code>climatology</code> results will contain the same column produced by
<code><a href="#topic+ts2clm">ts2clm</a></code> as well as the following:
</p>
<table role = "presentation">
<tr><td><code>threshCriterion</code></td>
<td>
<p>Boolean indicating if <code>temp</code> exceeds
<code>thresh</code>.</p>
</td></tr>
<tr><td><code>durationCriterion</code></td>
<td>
<p>Boolean indicating whether periods of consecutive
<code>threshCriterion</code> are &gt;= <code>min_duration</code>.</p>
</td></tr>
<tr><td><code>event</code></td>
<td>
<p>Boolean indicating if all criteria that define an extreme event
are met.</p>
</td></tr>
<tr><td><code>event_no</code></td>
<td>
<p>A sequential number indicating the ID and order of
occurrence of the events.</p>
</td></tr>
<tr><td><code>intensity</code></td>
<td>
<p>The difference between <code>temp</code> (or whichever column is provided
for <code>y</code>) and <code>seas</code>. Only added if <code>categories = TRUE</code>
and <code>climatology = TRUE</code>.</p>
</td></tr>
<tr><td><code>category</code></td>
<td>
<p>The category classification per day. Only added
if <code>categories = TRUE</code> and <code>climatology = TRUE</code>.</p>
</td></tr>
</table>
<p>The <code>event</code> results are summarised using a range of event metrics:
</p>
<table role = "presentation">
<tr><td><code>event_no</code></td>
<td>
<p>A sequential number indicating the ID and order of
the events.</p>
</td></tr>
<tr><td><code>index_start</code></td>
<td>
<p>Start index of event.</p>
</td></tr>
<tr><td><code>index_end</code></td>
<td>
<p>End index of event.</p>
</td></tr>
<tr><td><code>duration</code></td>
<td>
<p>Duration of event [days].</p>
</td></tr>
<tr><td><code>date_start</code></td>
<td>
<p>Start date of event [date].</p>
</td></tr>
<tr><td><code>date_end</code></td>
<td>
<p>End date of event [date].</p>
</td></tr>
<tr><td><code>date_peak</code></td>
<td>
<p>Date of event peak [date].</p>
</td></tr>
<tr><td><code>intensity_mean</code></td>
<td>
<p>Mean intensity [deg. C].</p>
</td></tr>
<tr><td><code>intensity_max</code></td>
<td>
<p>Maximum (peak) intensity [deg. C].</p>
</td></tr>
<tr><td><code>intensity_var</code></td>
<td>
<p>Intensity variability (standard deviation) [deg. C].</p>
</td></tr>
<tr><td><code>intensity_cumulative</code></td>
<td>
<p>Cumulative intensity [deg. C x days].</p>
</td></tr>
<tr><td><code>rate_onset</code></td>
<td>
<p>Onset rate of event [deg. C / day].</p>
</td></tr>
<tr><td><code>rate_decline</code></td>
<td>
<p>Decline rate of event [deg. C / day].</p>
</td></tr>
<tr><td><code>event_name</code></td>
<td>
<p>The name of the event. Generated from the <code><a href="base.html#topic+name">name</a></code>
value provided and the year of the <code>date_peak</code> of
the event. If no <code><a href="base.html#topic+name">name</a></code> value is provided the default &quot;Event&quot; is used.
As proposed in Hobday et al. (2018), <code>Moderate</code> events are not given a name
so as to prevent multiple repeat names within the same year. If two or more events
ranked greater than Moderate are reported within the same year, they will be
differentiated with the addition of a trailing letter
(e.g. Event 2001a, Event 2001b). Only added if <code>categories = TRUE</code>.</p>
</td></tr>
<tr><td><code>category</code></td>
<td>
<p>The maximum category threshold reached/exceeded by the event.
Only added if <code>categories = TRUE</code>.</p>
</td></tr>
<tr><td><code>p_moderate</code></td>
<td>
<p>The proportion of the total duration (days) spent at or above
the first threshold, but below any further thresholds. Only added if <code>categories = TRUE</code>.</p>
</td></tr>
<tr><td><code>p_strong</code></td>
<td>
<p>The proportion of the total duration (days) spent at or above
the second threshold, but below any further thresholds. Only added if <code>categories = TRUE</code>.</p>
</td></tr>
<tr><td><code>p_severe</code></td>
<td>
<p>The proportion of the total duration (days) spent at or above
the third threshold, but below the fourth threshold. Only added if <code>categories = TRUE</code>.</p>
</td></tr>
<tr><td><code>p_extreme</code></td>
<td>
<p>The proportion of the total duration (days) spent at or above
the fourth and final threshold. Only added if <code>categories = TRUE</code>.</p>
</td></tr>
<tr><td><code>season</code></td>
<td>
<p>The season(s) during which the event occurred. If the event
occurred across two seasons this will be displayed as e.g. &quot;Winter/Spring&quot;.
Across three seasons as e.g. &quot;Winter-Summer&quot;. Events lasting across four or more
seasons are listed as &quot;Year-round&quot;. December (June) is used here as the start of
Austral (Boreal) summer. If &quot;start&quot;, &quot;peak&quot;, or &quot;end&quot; was given to the <code>season</code>
argument then only the one season during that chosen period will be given.
Only added if <code>categories = TRUE</code>.</p>
</td></tr>
</table>
<p><code>intensity_max_relThresh</code>, <code>intensity_mean_relThresh</code>,
<code>intensity_var_relThresh</code>, and <code>intensity_cumulative_relThresh</code>
are as above except relative to the threshold (e.g., 90th percentile) rather
than the seasonal climatology.
</p>
<p><code>intensity_max_abs</code>, <code>intensity_mean_abs</code>, <code>intensity_var_abs</code>, and
<code>intensity_cumulative_abs</code> are as above except as absolute magnitudes
rather than relative to the seasonal climatology or threshold.
</p>
<p>Note that <code>rate_onset</code> and <code>rate_decline</code> will return <code>NA</code>
when the event begins/ends on the first/last day of the time series. This
may be particularly evident when the function is applied to large gridded
data sets. Although the other metrics do not contain any errors and
provide sensible values, please take this into account in its
interpretation.
</p>


<h3>Author(s)</h3>

<p>Albertus J. Smit, Robert W. Schlegel, Eric C. J. Oliver
</p>


<h3>References</h3>

<p>Hobday, A.J. et al. (2016). A hierarchical approach to defining
marine heatwaves, Progress in Oceanography, 141, pp. 227-238,
doi:10.1016/j.pocean.2015.12.014
</p>
<p>Schlegel, R. W., Oliver, C. J., Wernberg, T. W., Smit, A. J. (2017).
Nearshore and offshore co-occurrences of marine heatwaves and cold-spells.
Progress in Oceanography, 151, pp. 189-205, doi:10.1016/j.pocean.2017.01.004
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res_clim &lt;- ts2clm(sst_WA, climatologyPeriod = c("1983-01-01", "2012-12-31"))
out &lt;- detect_event(res_clim)
# show a portion of the climatology:
out$climatology[1:10, ]
# show some of the heat waves:
out$event[1:5, 1:10]

# Or if one wants to calculate MCSs
res_clim &lt;- ts2clm(sst_WA, climatologyPeriod = c("1983-01-01", "2012-12-31"),
                   pctile = 10)
out &lt;- detect_event(res_clim, coldSpells = TRUE)
# show a portion of the climatology:
out$climatology[1:10, ]
# show some of the cold-spells:
out$event[1:5, 1:10]

# It is also possible to calculate the categories of events directly
# See the \code{\link{category}} documentation for more functionality
res_clim &lt;- ts2clm(sst_WA, climatologyPeriod = c("1983-01-01", "2012-12-31"))
out_event &lt;- detect_event(res_clim, categories = TRUE)
out_list &lt;- detect_event(res_clim, categories = TRUE, climatology = TRUE)

# It is also possible to give two separate sets of threshold criteria

# To use a second static threshold we first use the exceedance function
thresh_19 &lt;- exceedance(sst_Med, threshold = 19, minDuration = 10, maxGap = 0)$threshold
# Then we use that output when detecting our events
events_19 &lt;- detect_event(ts2clm(sst_Med, climatologyPeriod = c("1982-01-01", "2011-12-31")),
                         threshClim2 = thresh_19$exceedance, minDuration2 = 10, maxGap2 = 0)

# If we want to use two different percentile thresholds we use detect_event
thresh_95 &lt;- detect_event(ts2clm(sst_Med, pctile = 95,
                                 climatologyPeriod = c("1982-01-01", "2011-12-31")),
                          minDuration = 2, maxGap = 0)$climatology
# Then we use that output when detecting our events
events_95 &lt;- detect_event(ts2clm(sst_Med, climatologyPeriod = c("1982-01-01", "2011-12-31")),
                          threshClim2 = thresh_95$event, minDuration2 = 2, maxGap2 = 0)

</code></pre>

<hr>
<h2 id='event_line'>Create a line plot of heatwaves or cold-spells.</h2><span id='topic+event_line'></span>

<h3>Description</h3>

<p>Creates a graph of warm or cold events as per the second row of Figure 3 in
Hobday et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event_line(
  data,
  x = t,
  y = temp,
  min_duration = 5,
  spread = 150,
  metric = "intensity_cumulative",
  start_date = NULL,
  end_date = NULL,
  category = FALSE,
  x_axis_title = NULL,
  x_axis_text_angle = NULL,
  y_axis_title = NULL,
  y_axis_range = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="event_line_+3A_data">data</code></td>
<td>
<p>The function receives the full (list) output from the
<code><a href="#topic+detect_event">detect_event</a></code> function.</p>
</td></tr>
<tr><td><code id="event_line_+3A_x">x</code></td>
<td>
<p>This column is expected to contain a vector of dates as per the
specification of <code>make_whole</code>. If a column headed <code>t</code> is present in
the dataframe, this argument may be ommitted; otherwise, specify the name of
the column with dates here.</p>
</td></tr>
<tr><td><code id="event_line_+3A_y">y</code></td>
<td>
<p>This is a column containing the measurement variable. If the column
name differs from the default (i.e. <code>temp</code>), specify the name here.</p>
</td></tr>
<tr><td><code id="event_line_+3A_min_duration">min_duration</code></td>
<td>
<p>The minimum duration (days) the event must be for it to
qualify as a heatwave or cold-spell.</p>
</td></tr>
<tr><td><code id="event_line_+3A_spread">spread</code></td>
<td>
<p>The number of days leading and trailing the largest event
(as per <code>metric</code>) detected within the time period specified by
<code>start_date</code> and <code>end_date</code>. The default is 150 days.</p>
</td></tr>
<tr><td><code id="event_line_+3A_metric">metric</code></td>
<td>
<p>This tells the function how to choose the event that should be
highlighted as the 'greatest' of the events in the chosen period. One may
choose from the following options: <code>intensity_mean</code>, <code>intensity_max</code>,
<code>intensity_var</code>,<code>intensity_cumulative</code>, <code>intensity_mean_relThresh</code>,
<code>intensity_max_relThresh</code>, <code>intensity_var_relThresh</code>,
<code>intensity_cumulative_relThresh</code>, <code>intensity_mean_abs</code>,
<code>intensity_max_abs</code>, <code>intensity_var_abs</code>, <code>intensity_cumulative_abs</code>,
<code>rate_onset</code>, <code>rate_decline</code>. Partial name matching is currently not
supported so please specify the metric name precisely. The default is
<code>intensity_cumulative</code>.</p>
</td></tr>
<tr><td><code id="event_line_+3A_start_date">start_date</code></td>
<td>
<p>The start date of a period of time within which the largest
event (as per <code>metric</code>) is retrieved and plotted. This may not necessarily
correspond to the biggest event of the specified metric within the entire
time series. To plot the largest event within the whole time series, make sure
<code>start_date</code> and <code>end_date</code> straddle this event, or simply leave them both
as NULL (default) and <code>event_line</code> will use the entire time series date range.</p>
</td></tr>
<tr><td><code id="event_line_+3A_end_date">end_date</code></td>
<td>
<p>The end date of a period of time within which the largest
event (as per <code>metric</code>) is retrieved and plotted. See <code>start_date</code>
for additional information.</p>
</td></tr>
<tr><td><code id="event_line_+3A_category">category</code></td>
<td>
<p>A boolean choice of TRUE or FALSE. If set to FALSE (default) event_line() will
produce a figure as per the second row of Figure 3 in Hobday et al. (2016). If set to TRUE a
figure showing the different categories of the MHWs in the chosen period, highlighted as
seen in Figure 3 of Hobday et al. (in review), will be produced. If <code>category</code> = TRUE,
<code>metric</code> will be ignored as a different colouring scheme is used.</p>
</td></tr>
<tr><td><code id="event_line_+3A_x_axis_title">x_axis_title</code></td>
<td>
<p>If one would like to add a title for the x-axis it may be provided here.</p>
</td></tr>
<tr><td><code id="event_line_+3A_x_axis_text_angle">x_axis_text_angle</code></td>
<td>
<p>If one would like to change the angle of the x-axis text, provide
the angle here as a single numeric value.</p>
</td></tr>
<tr><td><code id="event_line_+3A_y_axis_title">y_axis_title</code></td>
<td>
<p>Provide text here if one would like a title for the y-axis other
than &quot;Temperature °C&quot; (default)</p>
</td></tr>
<tr><td><code id="event_line_+3A_y_axis_range">y_axis_range</code></td>
<td>
<p>If one would like to control the y-axis range, provide the desired limits
here as two numeric values (e.g. c(20, 30)).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function will return a line plot indicating the climatology,
threshold and temperature, with the hot or cold events that meet the
specifications of Hobday et al. (2016) shaded in as appropriate. The plotting
of hot or cold events depends on which option is specified in <code><a href="#topic+detect_event">detect_event</a></code>.
The top event detect during the selected time period will be visible in a
brighter colour. This function differs in use from <code><a href="#topic+geom_flame">geom_flame</a></code>
in that it creates a stand alone figure. The benefit of this being
that one must not have any prior knowledge of ggplot2 to create the figure.
</p>


<h3>Author(s)</h3>

<p>Robert W. Schlegel
</p>


<h3>References</h3>

<p>Hobday, A.J. et al. (2016), A hierarchical approach to defining
marine heatwaves, Progress in Oceanography, 141, pp. 227-238,
doi: 10.1016/j.pocean.2015.12.014
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ts &lt;- ts2clm(sst_WA, climatologyPeriod = c("1983-01-01", "2012-12-31"))
res &lt;- detect_event(ts)

event_line(res, spread = 100, metric = "intensity_cumulative",
start_date = "2010-12-01", end_date = "2011-06-30")

event_line(res, spread = 100, start_date = "2010-12-01",
end_date = "2011-06-30", category = TRUE)

</code></pre>

<hr>
<h2 id='exceedance'>Detect consecutive days in exceedance of a given threshold.</h2><span id='topic+exceedance'></span>

<h3>Description</h3>

<p>Detect consecutive days in exceedance of a given threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exceedance(
  data,
  x = t,
  y = temp,
  threshold,
  below = FALSE,
  minDuration = 5,
  joinAcrossGaps = TRUE,
  maxGap = 2,
  maxPadLength = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exceedance_+3A_data">data</code></td>
<td>
<p>A data frame with at least the two following columns:
a <code>t</code> column which is a vector of dates of class <code>Date</code>,
and a <code>temp</code> column, which is the temperature on those given
dates. If columns are named differently, their names can be supplied as <code>x</code>
and <code>y</code> (see below). The function will not accurately detect consecutive
days of temperatures in exceedance of the <code>threshold</code> if missing days of
data are not filled in with <code>NA</code>. Data of the appropriate format are created
by the function <code><a href="#topic+make_whole">make_whole</a></code>, but your own data may be used
directly if they meet the given criteria.</p>
</td></tr>
<tr><td><code id="exceedance_+3A_x">x</code></td>
<td>
<p>This column is expected to contain a vector of dates as per the
specification of <code>make_whole</code>. If a column headed <code>t</code> is present in
the dataframe, this argument may be omitted; otherwise, specify the name of
the column with dates here.</p>
</td></tr>
<tr><td><code id="exceedance_+3A_y">y</code></td>
<td>
<p>This is a column containing the measurement variable. If the column
name differs from the default (i.e. <code>temp</code>), specify the name here.</p>
</td></tr>
<tr><td><code id="exceedance_+3A_threshold">threshold</code></td>
<td>
<p>The static threshold used to determine how many consecutive
days are in exceedance of the temperature of interest.</p>
</td></tr>
<tr><td><code id="exceedance_+3A_below">below</code></td>
<td>
<p>Default is <code>FALSE</code>. When set to TRUE, consecutive days of temperature
below the <code>threshold</code> variable are calculated. When set to FALSE,
consecutive days above the <code>threshold</code> variable are calculated.</p>
</td></tr>
<tr><td><code id="exceedance_+3A_minduration">minDuration</code></td>
<td>
<p>Minimum duration that temperatures must be in exceedance
of the <code>threshold</code> variable. The default is <code>5</code> days.</p>
</td></tr>
<tr><td><code id="exceedance_+3A_joinacrossgaps">joinAcrossGaps</code></td>
<td>
<p>A TRUE/FALSE statement that indicates whether
or not to join consecutive days of temperatures in exceedance of the
<code>threshold</code> across a small gap between groups before/after a short
gap as specified by <code>maxGap</code>. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="exceedance_+3A_maxgap">maxGap</code></td>
<td>
<p>The maximum length of the gap across which to connect
consecutive days in exceedance of the <code>threshold</code> when
<code>joinAcrossGaps = TRUE</code>.</p>
</td></tr>
<tr><td><code id="exceedance_+3A_maxpadlength">maxPadLength</code></td>
<td>
<p>Specifies the maximum length of days over which to
interpolate (pad) missing data (specified as <code>NA</code>) in the input
temperature time series; i.e., any consecutive blocks of NAs with length
greater than <code>maxPadLength</code> will be left as <code>NA</code>. Set as an
integer. The default is <code>3</code> days.</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> This function assumes that the input time series consists of continuous
daily temperatures, with few missing values. The accompanying function
<code><a href="#topic+make_whole">make_whole</a></code> aids in the preparation of a time series that is
suitable for use with <code>exceedance</code>, although this may also be accomplished
'by hand' as long as the criteria are met as discussed in the documentation
to <code><a href="#topic+make_whole">make_whole</a></code>.
</p>
</li>
<li><p> Future versions seek to accommodate monthly and annual time series, too.
</p>
</li>
<li><p> The calculation of onset and decline rates assumes that exceedance of the
<code>threshold</code> started a half-day before the start day and ended a half-day
after the end-day. This is consistent with the duration definition as implemented,
which assumes duration = end day - start day + 1.
</p>
</li>
<li><p> For the purposes of exceedance detection, any missing temperature values not
interpolated over (through optional <code>maxPadLength</code>) will remain as
<code>NA</code>. This means they will trigger the end of an exceedance if the adjacent
temperature values are in exceedance of the <code>threshold</code>.
</p>
</li>
<li><p> If the function is used to detect consecutive days of temperature under
the given <code>theshold</code>, these temperatures are then taken as being in
exceedance below the <code>threshold</code> as there is no antonym in the English
language for 'exceedance'.
</p>
</li></ol>

<p>This function is based largely on the <code>detect_event</code> function found in this
package, which was ported from the Python algorithm that was written by Eric
Oliver, Institute for Marine and Antarctic Studies, University of Tasmania,
Feb 2015, and is documented by Hobday et al. (2016).
</p>


<h3>Value</h3>

<p>The function will return a list of two tibbles (see the <code>tidyverse</code>).
The first being <code>threshold</code>, which shows the daily temperatures and on which
specific days the given <code>threshold</code> was exceeded. The second component of the
list is <code>exceedance</code>, which shows a medley of statistics for each discrete
group of days in exceedance of the given <code>threshold</code>. Note that any additional
columns left in the data frame given to this function will be output in the
<code>threshold</code> component of the output. For example, if one uses
<code><a href="#topic+ts2clm">ts2clm</a></code> to prepare a time series for analysis and leaves
in the <code>doy</code> column, this column will appear in the output.
</p>
<p>The information shown in the <code>threshold</code> component is:
</p>
<table role = "presentation">
<tr><td><code>t</code></td>
<td>
<p>The date of the temperature measurement. This variable may named
differently if an alternative name is supplied to the function's <code>x</code>
argument.</p>
</td></tr>
<tr><td><code>temp</code></td>
<td>
<p>Temperature on the specified date [deg. C]. This variable may
named differently if an alternative name is supplied to the function's <code>y</code>
argument.</p>
</td></tr>
<tr><td><code>thresh</code></td>
<td>
<p>The static <code>threshold</code> chosen by the user [deg. C].</p>
</td></tr>
<tr><td><code>thresh_criterion</code></td>
<td>
<p>Boolean indicating if <code>temp</code> exceeds
<code>threshold</code>.</p>
</td></tr>
<tr><td><code>duration_criterion</code></td>
<td>
<p>Boolean indicating whether periods of consecutive
<code>thresh_criterion</code> are &gt;= <code>minDuration</code>.</p>
</td></tr>
<tr><td><code>exceedance</code></td>
<td>
<p>Boolean indicting if all criteria that define a discrete
group in exceedance of the <code>threshold</code> are met.</p>
</td></tr>
<tr><td><code>exceedance_no</code></td>
<td>
<p>A sequential number indicating the ID and order of
occurrence of exceedances.</p>
</td></tr>
</table>
<p>The individual exceedances are summarised using the following metrics:
</p>
<table role = "presentation">
<tr><td><code>exceedance_no</code></td>
<td>
<p>The same sequential number indicating the ID and
order of the exceedance as found in the <code>threshold</code> component of the
output list.</p>
</td></tr>
<tr><td><code>index_start</code></td>
<td>
<p>Row number on which exceedance starts.</p>
</td></tr>
<tr><td><code>index_peak</code></td>
<td>
<p>Row number on which exceedance peaks.</p>
</td></tr>
<tr><td><code>index_end</code></td>
<td>
<p>Row number on which exceedance ends.</p>
</td></tr>
<tr><td><code>duration</code></td>
<td>
<p>Duration of exceedance [days].</p>
</td></tr>
<tr><td><code>date_start</code></td>
<td>
<p>Start date of exceedance [date].</p>
</td></tr>
<tr><td><code>date_peak</code></td>
<td>
<p>Date of exceedance peak [date].</p>
</td></tr>
<tr><td><code>date_end</code></td>
<td>
<p>End date of exceedance [date].</p>
</td></tr>
<tr><td><code>intensity_mean</code></td>
<td>
<p>Mean intensity [deg. C].</p>
</td></tr>
<tr><td><code>intensity_max</code></td>
<td>
<p>Maximum (peak) intensity [deg. C].</p>
</td></tr>
<tr><td><code>intensity_var</code></td>
<td>
<p>Intensity standard deviation [deg. C].</p>
</td></tr>
<tr><td><code>intensity_cumulative</code></td>
<td>
<p>Cumulative intensity [deg. C x days].</p>
</td></tr>
<tr><td><code>rate_onset</code></td>
<td>
<p>Onset rate of exceedance [deg. C / day].</p>
</td></tr>
<tr><td><code>rate_decline</code></td>
<td>
<p>Decline rate of exceedance [deg. C / day].</p>
</td></tr>
</table>
<p><code>intensity_max_abs</code>, <code>intensity_mean_abs</code>, <code>intensity_var_abs</code>,
and <code>intensity_cum_abs</code> are as above except as absolute magnitudes rather
than relative to the threshold.
</p>


<h3>Author(s)</h3>

<p>Robert W. Schlegel, Albertus J. Smit
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- exceedance(sst_WA, threshold = 25)
# show first ten days of daily data:
res$threshold[1:10, ]
# show first five exceedances:
res$exceedance[1:5, ]

</code></pre>

<hr>
<h2 id='geom_flame'>Create 'flame' polygons.</h2><span id='topic+geom_flame'></span>

<h3>Description</h3>

<p>This function will create polygons between two lines. If given a
temperature and theshold time series, like that produced by
<code><a href="#topic+detect_event">detect_event</a></code>, the output will meet the specifications
of Hobday et al. (2016) shown as 'flame polygons.' If one wishes to
plot polygons below a given threshold, and not above, switch the values
being fed to the <code>y</code> and <code>y2</code> aesthetics. This function differs
in use from <code><a href="#topic+event_line">event_line</a></code> in that it must be created as a
<code>ggplot</code> 'geom' object. The benefit of this being that one may add
additional information to the figure as geom layers to ggplot2 graphs
as may be necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_flame(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  n = 0,
  n_gap = 0,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_flame_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code>aes()</code> or <code>aes_()</code>.
If specified and inherit.aes = TRUE (the default), it is combined with the
default mapping at the top level of the plot. You must supply mapping if
there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_flame_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three options:
</p>
<p>If NULL, the default, the data is inherited from the plot data as specified
in the call to <code>ggplot()</code>.
</p>
<p>A data.frame, or other object, will override the plot data. All objects will
be fortified to produce a data frame. See <code>fortify()</code> for which variables will
be created.
</p>
<p>A function will be called with a single argument, the plot data. The return
value must be a <code>data.frame</code>, and will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_flame_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer,
as a string.</p>
</td></tr>
<tr><td><code id="geom_flame_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call
to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_flame_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>layer</code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_flame_+3A_n">n</code></td>
<td>
<p>The number of steps along the x-axis (i.e. in a daily time series this
would be days) required before the area between <code>y</code> and <code>y2</code> will be
filled in. The default of 0 will fill in _all_ of the area between the lines.
The standard to match Hobday et al. (2016) is <code>n = 5</code>.</p>
</td></tr>
<tr><td><code id="geom_flame_+3A_n_gap">n_gap</code></td>
<td>
<p>The number of steps along the x-axis (i.e. in a daily time series this
would be days) within which to allow <code>geom_flame()</code> to connect polygons.
This is useful when one wants to not screen out parts of a polygon that dip
only briefly below <code>y</code> before coming back up above it. The defauly of 0
will not connect any of the polygons. The standard to match
Hobday et al. (2016) is <code>n_gap = 2</code>.</p>
</td></tr>
<tr><td><code id="geom_flame_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning. If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_flame_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical. Should this layer be included in the legends? <code>NA</code>,
the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and
<code>TRUE</code> always includes. It can also be a named logical vector to finely select
the aesthetics to display.</p>
</td></tr>
<tr><td><code id="geom_flame_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that define
both data and aesthetics and shouldn't inherit behaviour from the default plot
specification, e.g. <code>borders()</code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_flame</code> understands the following aesthetics (required aesthetics
are in bold):
</p>

<ul>
<li> <p><strong><code>x</code></strong>
</p>
</li>
<li> <p><strong><code>y</code></strong>
</p>
</li>
<li> <p><strong><code>y2</code></strong>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>fill</code>
</p>
</li>
<li> <p><code>size</code>
</p>
</li>
<li> <p><code>alpha</code>
</p>
</li>
<li> <p><code>linetype</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Robert W. Schlegel
</p>


<h3>References</h3>

<p>Hobday, A.J. et al. (2016), A hierarchical approach to defining
marine heatwaves, Progress in Oceanography, 141, pp. 227-238,
doi: 10.1016/j.pocean.2015.12.014
</p>


<h3>See Also</h3>

<p><code><a href="#topic+event_line">event_line</a></code> for a non-ggplot2 based flame function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ts &lt;- ts2clm(sst_WA, climatologyPeriod = c("1983-01-01", "2012-12-31"))
res &lt;- detect_event(ts)
mhw &lt;- res$clim
mhw &lt;- mhw[10580:10690,]

library(ggplot2)

ggplot(mhw, aes(x = t, y = temp)) +
  geom_flame(aes(y2 = thresh)) +
  geom_text(aes(x = as.Date("2011-02-01"), y = 28,
            label = "That's not a heatwave.\nThis, is a heatwave.")) +
  xlab("Date") + ylab(expression(paste("Temperature [", degree, "C]")))

</code></pre>

<hr>
<h2 id='geom_lolli'>Visualise a timeline of several event metrics as 'lollipops'.</h2><span id='topic+geom_lolli'></span>

<h3>Description</h3>

<p>The function will return a graph of the intensity of the selected
metric along the *y*-axis versus a time variable along the *x*-axis.
The number of top events (<code>n</code>) from the chosen metric may be highlighted
in a brighter colour with the aesthetic value <code>colour_n</code>.
This function differs in use from <code><a href="#topic+lolli_plot">lolli_plot</a></code>
in that it must be created as a ggplot2 'geom' object. The benefit of this being
that one may add additional information layer by layer to the figure as
geoms as necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_lolli(
  mapping = NULL,
  data = NULL,
  ...,
  n = 0,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_lolli_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code>aes()</code> or <code>aes_()</code>. If
specified and inherit.aes = TRUE (the default), it is combined with the
default mapping at the top level of the plot. You must supply mapping if
there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_lolli_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three options:
</p>

<ol>
<li><p> If NULL, the default, the data is inherited from the plot data as specified
in the call to <code>ggplot()</code>.
</p>
</li>
<li><p> A data.frame, or other object, will override the plot data. All objects will
be fortified to produce a data frame. See <code>fortify()</code> for which variables will
be created.
</p>
</li>
<li><p> A function will be called with a single argument, the plot data. The return
value must be a <code>data.frame</code>, and will be used as the layer data.
</p>
</li></ol>
</td></tr>
<tr><td><code id="geom_lolli_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>layer</code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_lolli_+3A_n">n</code></td>
<td>
<p>The number of top events to highlight as based on the value provided
to <code>aes(y)</code>. Default is 0.</p>
</td></tr>
<tr><td><code id="geom_lolli_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning. If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_lolli_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical. Should this layer be included in the legends? <code>NA</code>,
the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and
<code>TRUE</code> always includes. It can also be a named logical vector to finely select
the aesthetics to display.</p>
</td></tr>
<tr><td><code id="geom_lolli_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that define
both data and aesthetics and shouldn't inherit behaviour from the default plot
specification, e.g. <code>borders()</code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_lolli</code> understands the following aesthetics (required aesthetics
are in bold):
</p>

<ul>
<li> <p><strong><code>x</code></strong>
</p>
</li>
<li> <p><strong><code>y</code></strong>
</p>
</li>
<li> <p><code>alpha</code>
</p>
</li>
<li> <p><code>color</code>
</p>
</li>
<li> <p><code>linetype</code>
</p>
</li>
<li> <p><code>size</code>
</p>
</li>
<li> <p><code>shape</code>
</p>
</li>
<li> <p><code>stroke</code>
</p>
</li>
<li> <p><code>fill</code>
</p>
</li>
<li> <p><code>colour_n</code> While this value may be used as an aesthetic, it works
better as a parameter for this function because it is set to use discrete values.
One may provide continuous values to <code>colour_n</code> but remember that one may
not provide multiple continuous or discrete scales to a single ggplot2 object.
Therefore, if one provides a continuous value to <code>aes(colour)</code>, the values
supplied to <code>colour_n</code> must be discrete. <code>ggplot2</code> will attempt to
do this automatically.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Robert W. Schlegel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lolli_plot">lolli_plot</a></code> for a non-geom based lolliplot function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ts &lt;- ts2clm(sst_WA, climatologyPeriod = c("1983-01-01", "2012-12-31"))
res &lt;- detect_event(ts)
mhw &lt;- res$event

library(ggplot2)

# Height of lollis represent event durations and their colours
# are mapped to the events' cumulative intensity:
ggplot(mhw, aes(x = date_peak, y = duration)) +
  geom_lolli(aes(colour = intensity_cumulative)) +
  scale_color_distiller(palette = "Spectral", name = "Cumulative \nintensity") +
  xlab("Date") + ylab("Event duration [days]")

# Height of lollis represent event durations and the top three (longest)
# lollis are highlighted in red:
ggplot(mhw, aes(x = date_peak, y = duration)) +
  geom_lolli(n = 3, colour_n = "red") +
  scale_color_distiller(palette = "Spectral") +
  xlab("Peak date") + ylab("Event duration [days]")

# Because this is a proper geom, any number of ill-advised things
# may be done with it:
ggplot(mhw, aes(x = event_no, y = intensity_max)) +
  geom_lolli(shape = 5, aes(colour = rate_onset), linetype = "dotted") +
  scale_color_distiller(palette = "RdYlGn", name = "Rate \nonset") +
  xlab("Event number") + ylab("Max intensity [degree C]")

</code></pre>

<hr>
<h2 id='lolli_plot'>Create a timeline of selected event metrics as 'lollipops'.</h2><span id='topic+lolli_plot'></span>

<h3>Description</h3>

<p>Visualise a timeline of several possible event metrics as 'lollipop' graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lolli_plot(
  data,
  xaxis = "date_peak",
  metric = "intensity_max",
  event_count = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lolli_plot_+3A_data">data</code></td>
<td>
<p>Output from the <code><a href="#topic+detect_event">detect_event</a></code> function.</p>
</td></tr>
<tr><td><code id="lolli_plot_+3A_xaxis">xaxis</code></td>
<td>
<p>One of <code>event_no</code>, <code>date_start</code> or <code>date_peak</code>.
Default is <code>date_start</code>.</p>
</td></tr>
<tr><td><code id="lolli_plot_+3A_metric">metric</code></td>
<td>
<p>One of <code>intensity_mean</code>, <code>intensity_max</code>,
<code>intensity_cumulative</code> and <code>duration</code>.
Default is <code>intensity_max</code>.</p>
</td></tr>
<tr><td><code id="lolli_plot_+3A_event_count">event_count</code></td>
<td>
<p>The number of top events to highlight, as determined by the
value given to <code>metric</code>. Default is 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function will return a graph of the intensity of the selected
<code>metric</code> along the y-axis and the chosen <code>xaxis</code> value.
The number of top events as per <code>event_count</code> will be highlighted
in a brighter colour. This function differs in use from <code><a href="#topic+geom_lolli">geom_lolli</a></code>
in that it creates a stand-alone figure. The benefit of this being
that one must not have any prior knowledge of <code>ggplot2</code> to create the figure.
</p>


<h3>Author(s)</h3>

<p>Albertus J. Smit and Robert W. Schlegel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ts &lt;- ts2clm(sst_WA, climatologyPeriod = c("1983-01-01", "2012-12-31"))
res &lt;- detect_event(ts)

library(ggplot2)

# The default output
lolli_plot(res)

</code></pre>

<hr>
<h2 id='make_whole'>Constructs a continuous, uninterrupted time series of temperatures.</h2><span id='topic+make_whole'></span>

<h3>Description</h3>

<p>Takes a series of dates and temperatures, and if irregular (but ordered), inserts
missing dates and fills corresponding temperatures with NAs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_whole(data, x = t, y = temp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_whole_+3A_data">data</code></td>
<td>
<p>A data frame with columns for date and temperature data.
Ordered daily data are expected, and although missing values (NA) can be
accommodated, the function is only recommended when NAs occur infrequently,
preferably at no more than 3 consecutive days.</p>
</td></tr>
<tr><td><code id="make_whole_+3A_x">x</code></td>
<td>
<p>A column with the daily time vector (see details). For backwards
compatibility, the column is named <code>t</code> by default.</p>
</td></tr>
<tr><td><code id="make_whole_+3A_y">y</code></td>
<td>
<p>A column with the response vector. RmarineHeatWaves version &lt;= 0.15.9
assumed that this would be daily seawater temperatures, but as of version 0.16.0
it may be any arbitrary measurement taken at a daily frequency. The default
remains temperature, and the default column name is therefore <code>temp</code>, again
hopefully ensuring backwards compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> Upon import, the package uses 'zoo' and 'lubridate' to process the input
date and temperature data. It reads in daily data with the time vector
specified as either <code>POSIXct</code> or <code>Date</code> (e.g. &quot;1982-01-01 02:00:00&quot; or
&quot;1982-01-01&quot;). The data may be an irregular time series, but date must be
ordered. The function constructs a complete time series from the start date
to the end date, and fills in the regions in the time series where temperature
data are missing with NAs in the temperature vector. There must only be one
temperature value per day otherwise the function takes the mean of multiple
values. It is up to the user to calculate daily data from sub-daily
measurements. Leap years are automatically accommodated by this function.
</p>
</li>
<li><p> This function can handle some of missing days, but this is not a
licence to actually use these data for the detection of anomalous thermal
events. Hobday et al. (2016) recommend gaps of no more than 3 days, which
may be adjusted by setting the <code>maxPadLength</code> argument of the
<code><a href="#topic+ts2clm">ts2clm</a></code> function. The longer and more frequent the gaps become
the lower the fidelity of the annual climatology and threshold that can be
calculated, which will not only have repercussions for the accuracy at which
the event metrics can be determined, but also for the number of events that
can be detected.
</p>
</li>
<li><p> It is recommended that a climatology period of at least 30 years is
specified in order to capture any decadal thermal periodicities.
</p>
</li>
<li><p> A faster version of this function called <code>make_whole_fast</code>
is enabled by default in <code>ts2clm</code>, and we assume (hopefully correctly)
that the user is certain that her data do not have missing rows (dates) or
duplicated values. This slower but more robust function (i.e. <code>make_whole</code>)
may be selected as an argument to <code>ts2clm</code> in case the data may have some
issues.
</p>
</li></ol>



<h3>Value</h3>

<p>The function will return a data frame with three columns. The column
headed <code>doy</code> (day-of-year) is the Julian day running from 1 to 366, but
modified so that the day-of-year series for non-leap-years runs 1...59 and
then 61...366. For leap years the 60th day is February 29. See the example,
below. The other two columns take the names of <code>x</code> and <code>y</code>, if supplied,
or it will be <code>t</code> and <code>temp</code> in case the default values were used.
The <code>x</code> (or <code>t</code>) column is a series of dates of class <code>Date</code>,
while <code>y</code> (or <code>temp</code>) is the measured variable. This time series will
be uninterrupted and continuous daily values between the first and last dates
of the input data.
</p>


<h3>Author(s)</h3>

<p>Smit, A. J.
</p>

<hr>
<h2 id='make_whole_fast'>Constructs a continuous, uninterrupted time series of temperatures (faster).</h2><span id='topic+make_whole_fast'></span>

<h3>Description</h3>

<p>Takes a series of dates and temperatures, and if irregular (but ordered), inserts
missing dates and fills correpsonding temperatures with NAs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_whole_fast(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_whole_fast_+3A_data">data</code></td>
<td>
<p>A data frame with columns for date (<code>ts_x</code>) and
temperature (<code>ts_y</code>) data. Ordered daily data are expected, and
although missing values (NA) can be accommodated, the function is only
recommended when NAs occur infrequently, preferably at no more than three
consecutive days.</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> This function reads in daily data with the time vector specified as
<code>Date</code> (e.g. &quot;1982-01-01&quot;).
</p>
</li>
<li><p> It is up to the user to calculate daily data from sub-daily measurements.
Leap years are automatically accommodated by this function.
</p>
</li>
<li><p> This function can handle some missing days, but this is not a
licence to actually use these data for the detection of anomalous thermal
events. Hobday et al. (2016) recommend gaps of no more than 3 days, which
may be adjusted by setting the <code>maxPadLength</code> argument of the
<code><a href="#topic+ts2clm">ts2clm</a></code> function. The longer and more frequent the gaps become
the lower the fidelity of the annual climatology and threshold that can be
calculated, which will not only have repercussions for the accuracy at which
the event metrics can be determined, but also for the number of events that
can be detected.
</p>
</li>
<li><p> The original <code>make_whole</code> tests to see if some rows are
duplicated, or if replicate temperature measurements are present per day. In
<code>make_whole_fast</code> (this function) this has been disabled; also,
the latter function lacks the facility to check if the time series is complete
and regular (i.e. no missing values in the date vector). Effectively,
we now only set up the day-of-year (doy) vector in <code>make_whole_fast</code>.
Should the user be concerned about the potential for repeated measurements
or worry that the time series is irregular, we suggest that the necessary
checks and fixes are implemented prior to feeding the time series to <code>ts2clim</code>
via <code>make_whole_fast</code>, or to use <code>make_whole</code> instead. For very large
gridded temperature records it probably makes a measurable difference if the
'fast' version is used, but it might prevent <code><a href="#topic+detect_event">detect_event</a></code>
from failing should some gridded cells contain missing rows or some duplicated
values. When using the fast algorithm, we assume that the user has done all
the necessary work to ensure that the time vector is regular and without
repeated measurements beforehand.
</p>
</li></ol>



<h3>Value</h3>

<p>The function will return a data frame with three columns. The column
headed <code>doy</code> (day-of-year) is the Julian day running from 1 to 366, but
modified so that the day-of-year series for non-leap-years runs 1...59 and
then 61...366. For leap years the 60th day is February 29. The <code>ts_x</code>
column is a series of dates of class <code>Date</code>, while <code>y</code> is the
measured variable. This time series will be uninterrupted and continuous daily
values between the first and last dates of the input data.
</p>


<h3>Author(s)</h3>

<p>Smit, A. J., Schlegel, R. W.
</p>

<hr>
<h2 id='na_interp'>Pad NA gaps of user-defined width with interpolated values.</h2><span id='topic+na_interp'></span>

<h3>Description</h3>

<p>An internal function that helps to create a time series that will
then be used by <code><a href="#topic+clim_calc">clim_calc</a></code> within <code><a href="#topic+ts2clm">ts2clm</a></code>
to produce a climatology as desired by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na_interp(doy = doy, x = ts_x, y = ts_y, maxPadLength)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="na_interp_+3A_doy">doy</code></td>
<td>
<p>Date-of-year as per <code>make_whole</code> or <code>make_whole_fast</code>.</p>
</td></tr>
<tr><td><code id="na_interp_+3A_x">x</code></td>
<td>
<p>Date as per <code>make_whole</code> or <code>make_whole_fast</code>.</p>
</td></tr>
<tr><td><code id="na_interp_+3A_y">y</code></td>
<td>
<p>Measurement variable as per <code>make_whole</code> or <code>make_whole_fast</code>.</p>
</td></tr>
<tr><td><code id="na_interp_+3A_maxpadlength">maxPadLength</code></td>
<td>
<p>Specifies the maximum length of days over which to
interpolate (pad) missing data (specified as <code>NA</code>) in the input
temperature time series; i.e., any consecutive blocks of NAs with length
greater than <code>maxPadLength</code> will be left as <code>NA</code>. Set as an
integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the data (a data.table) in a long format.
</p>


<h3>Author(s)</h3>

<p>Smit, A. J.
</p>

<hr>
<h2 id='proto_event'>Detect proto-events based on a chosen criterion (column).</h2><span id='topic+proto_event'></span>

<h3>Description</h3>

<p>An internal function that detects the events according to the heatwave
definition, and joins across the gaps if desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proto_event(t_series, criterion_column, minDuration, joinAcrossGaps, maxGap)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="proto_event_+3A_t_series">t_series</code></td>
<td>
<p>A dataframe of the correct dimensions inherited
from <code><a href="#topic+detect_event">detect_event</a></code> within which this runs.</p>
</td></tr>
<tr><td><code id="proto_event_+3A_criterion_column">criterion_column</code></td>
<td>
<p>The column to use for the detection of events.</p>
</td></tr>
<tr><td><code id="proto_event_+3A_minduration">minDuration</code></td>
<td>
<p>Minimum duration for acceptance of detected events.</p>
</td></tr>
<tr><td><code id="proto_event_+3A_joinacrossgaps">joinAcrossGaps</code></td>
<td>
<p>This logic gate tells this internal function if
it should connect events across the <code>maxGap</code> (see below). The
default it inherits is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="proto_event_+3A_maxgap">maxGap</code></td>
<td>
<p>This is the number of rows (days) across which distinct
events will be combined into one event if <code>joinAcrossGaps = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe that will be used within <code><a href="#topic+detect_event">detect_event</a></code>,
or which can be returned by <code><a href="#topic+detect_event">detect_event</a></code> if the switch
'protoEvent' is specified as TRUE.
</p>


<h3>Author(s)</h3>

<p>Albertus J. Smit, Robert W. Schlegel
</p>

<hr>
<h2 id='smooth_percentile'>Detect the climatology for a time series.</h2><span id='topic+smooth_percentile'></span>

<h3>Description</h3>

<p>An internal function that helps to create climatologies in
accordance with the Hobday et al. (2016) standard.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_percentile(data, smoothPercentileWidth, var_calc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth_percentile_+3A_data">data</code></td>
<td>
<p>The data given to this function during the calculations
performed by <code><a href="#topic+ts2clm">ts2clm</a></code>.</p>
</td></tr>
<tr><td><code id="smooth_percentile_+3A_smoothpercentilewidth">smoothPercentileWidth</code></td>
<td>
<p>The width of the smoothing window
to be applied. The default is <code>31</code> days.</p>
</td></tr>
<tr><td><code id="smooth_percentile_+3A_var_calc">var_calc</code></td>
<td>
<p>This is passed from the ts2clm argument <code>var</code>
and tells the function if a var column exists that needs to be smoothed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the data in the same format it was
input as, with the climatology values smoothed as desired.
</p>


<h3>Author(s)</h3>

<p>Smit, A. J.
</p>

<hr>
<h2 id='sst_Med'>NOAA Optimally Interpolated (OI) v2.1 daily 1/4 degree SST for the Mediterranean region.</h2><span id='topic+sst_Med'></span>

<h3>Description</h3>

<p>A dataset containing the sea surface temperature (in degrees Celsius)
and date for the Mediterranean region from 1982-01-01 to 2020-12-31.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sst_Med
</code></pre>


<h3>Format</h3>

<p>A dataframe with 14245 rows and 2 variables:
</p>

<dl>
<dt>t</dt><dd><p>date, as.Date() format</p>
</dd>
<dt>temp</dt><dd><p>SST, in degrees Celsius</p>
</dd>
</dl>
<p>...

</p>


<h3>Details</h3>

<p>lon/lat: 9.125/43.625
</p>


<h3>Source</h3>

<p><a href="https://www.ncei.noaa.gov/products/optimum-interpolation-sst">https://www.ncei.noaa.gov/products/optimum-interpolation-sst</a>
</p>

<hr>
<h2 id='sst_NW_Atl'>NOAA Optimally Interpolated (OI) v2.1 daily 1/4 degree SST for the NW Atlantic region.</h2><span id='topic+sst_NW_Atl'></span>

<h3>Description</h3>

<p>A dataset containing the sea surface temperature (in degrees Celsius)
and date for the Northwest Atlantic region from 1982-01-01 to 2020-12-31.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sst_NW_Atl
</code></pre>


<h3>Format</h3>

<p>A dataframe with 14245 rows and 2 variables:
</p>

<dl>
<dt>t</dt><dd><p>date, as.Date() format</p>
</dd>
<dt>temp</dt><dd><p>SST, in degrees Celsius</p>
</dd>
</dl>
<p>...

</p>


<h3>Details</h3>

<p>lon/lat: -66.875/43.125
</p>


<h3>Source</h3>

<p><a href="https://www.ncei.noaa.gov/products/optimum-interpolation-sst">https://www.ncei.noaa.gov/products/optimum-interpolation-sst</a>
</p>

<hr>
<h2 id='sst_WA'>NOAA Optimally Interpolated (OI) v2.1 daily 1/4 degree SST for the Western Australian region.</h2><span id='topic+sst_WA'></span>

<h3>Description</h3>

<p>A dataset containing the sea surface temperature (in degrees Celsius)
and date for the Western Australian region from 1982-01-01 to 2020-12-31.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sst_WA
</code></pre>


<h3>Format</h3>

<p>A dataframe with 14245 rows and 2 variables:
</p>

<dl>
<dt>t</dt><dd><p>date, as.Date() format</p>
</dd>
<dt>temp</dt><dd><p>SST, in degrees Celsius</p>
</dd>
</dl>
<p>...

</p>


<h3>Details</h3>

<p>lon/lat: 112.625/-29.375
</p>


<h3>Source</h3>

<p><a href="https://www.ncei.noaa.gov/products/optimum-interpolation-sst">https://www.ncei.noaa.gov/products/optimum-interpolation-sst</a>
</p>

<hr>
<h2 id='ts2clm'>Make a climatology from a daily time series.</h2><span id='topic+ts2clm'></span>

<h3>Description</h3>

<p>Creates a daily climatology from a time series of daily temperatures using a
user-specified sliding window for the mean and threshold calculation, followed
by an optional moving average smoother as used by Hobday et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts2clm(
  data,
  x = t,
  y = temp,
  climatologyPeriod,
  robust = FALSE,
  maxPadLength = FALSE,
  windowHalfWidth = 5,
  pctile = 90,
  smoothPercentile = TRUE,
  smoothPercentileWidth = 31,
  clmOnly = FALSE,
  var = FALSE,
  roundClm = 4
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ts2clm_+3A_data">data</code></td>
<td>
<p>A data frame with two columns. In the default setting (i.e. omitting
the arguments <code>x</code> and <code>y</code>; see immediately below), the data set is
expected to have the headers <code>t</code> and <code>temp</code>. The <code>t</code> column is a
vector of dates of class <code>Date</code>, while <code>temp</code> is the measured variable
(by default it is assumed to be temperature).</p>
</td></tr>
<tr><td><code id="ts2clm_+3A_x">x</code></td>
<td>
<p>This column is expected to contain a vector of dates. If a column
headed <code>t</code> is present in the dataframe, this argument may be omitted;
otherwise, specify the name of the column with dates here.</p>
</td></tr>
<tr><td><code id="ts2clm_+3A_y">y</code></td>
<td>
<p>This is a column containing the measurement variable. If the column
name differs from the default (i.e. <code>temp</code>), specify the name here.</p>
</td></tr>
<tr><td><code id="ts2clm_+3A_climatologyperiod">climatologyPeriod</code></td>
<td>
<p>Required. To this argument should be passed two values
(see example below). The first value should be the chosen date for the start of
the climatology period, and the second value the end date of said period. This
chosen period (preferably 30 years in length) is then used to calculate the
seasonal cycle and the extreme value threshold.</p>
</td></tr>
<tr><td><code id="ts2clm_+3A_robust">robust</code></td>
<td>
<p>This argument has been deprecated and no longer has affects how
the function operates.</p>
</td></tr>
<tr><td><code id="ts2clm_+3A_maxpadlength">maxPadLength</code></td>
<td>
<p>Specifies the maximum length of days over which to
interpolate (pad) missing data (specified as <code>NA</code>) in the input
temperature time series; i.e., any consecutive blocks of NAs with length
greater than <code>maxPadLength</code> will be left as <code>NA</code>. The default is
<code>FALSE</code>. Set as an integer to interpolate. Setting <code>maxPadLength</code>
to <code>TRUE</code> will return an error.</p>
</td></tr>
<tr><td><code id="ts2clm_+3A_windowhalfwidth">windowHalfWidth</code></td>
<td>
<p>Width of sliding window about day-of-year (to one
side of the center day-of-year) used for the pooling of values and
calculation of climatology and threshold percentile. Default is <code>5</code>
days, which gives a window width of 11 days centred on the 6th day of the
series of 11 days.</p>
</td></tr>
<tr><td><code id="ts2clm_+3A_pctile">pctile</code></td>
<td>
<p>Threshold percentile (%) for detection of events (MHWs).
Default is <code>90</code>th percentile. Should the intent be to use these
threshold data for MCSs, set <code>pctile = 10</code>. Or some other low value.</p>
</td></tr>
<tr><td><code id="ts2clm_+3A_smoothpercentile">smoothPercentile</code></td>
<td>
<p>Boolean switch selecting whether to smooth the
climatology and threshold percentile time series with a moving average of
<code>smoothPercentileWidth</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ts2clm_+3A_smoothpercentilewidth">smoothPercentileWidth</code></td>
<td>
<p>Full width of moving average window for smoothing
climatology and threshold. The default is <code>31</code> days.</p>
</td></tr>
<tr><td><code id="ts2clm_+3A_clmonly">clmOnly</code></td>
<td>
<p>Choose to calculate and return only the climatologies.
The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ts2clm_+3A_var">var</code></td>
<td>
<p>This argument has been introduced to allow the user to choose if
the variance of the seasonal signal per doy should be calculated. The default of
<code>FALSE</code> will prevent the calculation, potentially increasing speed of calculations
on gridded data and reducing the size of the output. The variance was initially
introduced as part of the standard output from Hobday et al. (2016), but few
researchers use it and so it is generally regarded now as unnecessary.</p>
</td></tr>
<tr><td><code id="ts2clm_+3A_roundclm">roundClm</code></td>
<td>
<p>This argument allows the user to choose how many decimal places
the <code>seas</code> and <code>thresh</code> outputs will be rounded to. Default is 4. To
prevent rounding set <code>roundClm = FALSE</code>. This argument may only be given
numeric values or FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> This function assumes that the input time series consists of continuous
daily values with few missing values. Time ranges which start and end
part-way through the calendar year are supported.
</p>
</li>
<li><p> It is recommended that a period of at least 30 years is specified in
order to produce a climatology that smooths out any decadal thermal
periodicities that may be present. It is further advised that full the start
and end dates for the climatology period result in full years, e.g.
&quot;1982-01-01&quot; to &quot;2011-12-31&quot; or &quot;1982-07-01&quot; to &quot;2012-06-30&quot;; if not, this
may result in an unequal weighting of data belonging with certain months
within a time series. A daily climatology will be created; that is, the
climatology will be comprised of one mean temperature for each day of the
year (365 or 366 days, depending on how leap years are dealt with), and the
mean will be based on a sample size that is a function of the length of time
determined by the start and end values given to <code>climatologyPeriod</code> and
the width of the sliding window specified in <code>windowHalfWidth</code>.
</p>
</li>
<li><p> This function supports leap years. This is done by ignoring Feb 29s
for the initial calculation of the climatology and threshold. The values for
Feb 29 are then linearly interpolated from the values for Feb 28 and Mar 1.
</p>
</li>
<li><p> Previous versions of <code>ts2clm()</code> tested to see if some rows
are duplicated, or if replicate temperature readings are present per day, but
this has now been disabled. Should the user be concerned about such repeated
measurements, we suggest that the necessary checks and fixes are implemented
prior to feeding the time series to <code>ts2clm()</code>.
</p>
</li></ol>

<p>The original Python algorithm was written by Eric Oliver, Institute for
Marine and Antarctic Studies, University of Tasmania, Feb 2015, and is
documented by Hobday et al. (2016).
</p>


<h3>Value</h3>

<p>The function will return a tibble (see the <code>tidyverse</code>) with the
input time series and the newly calculated climatology. The climatology contains
the seasonal climatology and the threshold for calculating MHWs. The software was
designed for creating climatologies of daily temperatures, and the units
specified below reflect that intended purpose. However, various other kinds
of climatologies may be created, and if that is the case, the appropriate
units need to be determined by the user.
</p>
<table role = "presentation">
<tr><td><code>doy</code></td>
<td>
<p>Julian day (day-of-year). For non-leap years it runs 1...59 and
61...366, while leap years run 1...366.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>The date vector in the original time series supplied in <code>data</code>. If
an alternate column was provided to the <code>x</code> argument, that name will rather
be used for this column.</p>
</td></tr>
<tr><td><code>temp</code></td>
<td>
<p>The measurement vector as per the the original <code>data</code> supplied
to the function. If a different column was given to the <code>y</code> argument that
will be shown here.</p>
</td></tr>
<tr><td><code>seas</code></td>
<td>
<p>Climatological seasonal cycle [deg. C].</p>
</td></tr>
<tr><td><code>thresh</code></td>
<td>
<p>Seasonally varying threshold (e.g., 90th
percentile) [deg. C]. This is used in <code><a href="#topic+detect_event">detect_event</a></code> for the
detection/calculation of events (MHWs).</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>Seasonally varying variance (standard deviation) [deg. C]. This
column is not returned if <code>var = FALSE</code> (default).</p>
</td></tr>
</table>
<p>Should <code>clmOnly</code> be enabled, only the 365 or 366 day climatology will be
returned.
</p>


<h3>Author(s)</h3>

<p>Albertus J. Smit, Robert W. Schlegel, Eric C. J. Oliver
</p>


<h3>References</h3>

<p>Hobday, A.J. et al. (2016). A hierarchical approach to defining
marine heatwaves, Progress in Oceanography, 141, pp. 227-238,
doi:10.1016/j.pocean.2015.12.014
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- ts2clm(sst_WA, climatologyPeriod = c("1983-01-01", "2012-12-31"))
res[1:10, ]

# Or if one only wants the 366 day climatology
res_clim &lt;- ts2clm(sst_WA, climatologyPeriod = c("1983-01-01", "2012-12-31"),
                   clmOnly = TRUE)
res_clim[1:10, ]

# Or if one wants the variance column included in the results
res_var &lt;- ts2clm(sst_WA, climatologyPeriod = c("1983-01-01", "2012-12-31"),
                  var = TRUE)
res_var[1:10, ]

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
