<!DOCTYPE html><html><head><title>Help for package distr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {distr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#distr-package'>
<p>distr &ndash; Object Oriented Implementation of Distributions</p></a></li>
<li><a href='#AbscontDistribution'><p>Generating function &quot;AbscontDistribution&quot;</p></a></li>
<li><a href='#AbscontDistribution-class'><p>Class &quot;AbscontDistribution&quot;</p></a></li>
<li><a href='#Arcsine-class'><p>Class &quot;Arcsine&quot;</p></a></li>
<li><a href='#Beta-class'><p>Class &quot;Beta&quot;</p></a></li>
<li><a href='#BetaParameter-class'><p>Class &quot;BetaParameter&quot;</p></a></li>
<li><a href='#Binom-class'><p>Class &quot;Binom&quot;</p></a></li>
<li><a href='#BinomParameter-class'><p>Class &quot;BinomParameter&quot;</p></a></li>
<li><a href='#Cauchy-class'><p>Class &quot;Cauchy&quot;</p></a></li>
<li><a href='#CauchyParameter-class'><p>Class &quot;CauchyParameter&quot;</p></a></li>
<li><a href='#Chisq-class'><p>Class &quot;Chisq&quot;</p></a></li>
<li><a href='#ChisqParameter-class'><p>Class &quot;ChisqParameter&quot;</p></a></li>
<li><a href='#CompoundDistribution'><p>Generating function for Class &quot;CompoundDistribution&quot;</p></a></li>
<li><a href='#CompoundDistribution-class'><p>Class &quot;CompoundDistribution&quot;</p></a></li>
<li><a href='#convpow-methods'><p>Distribution of the sum of univariate i.i.d r.v's</p></a></li>
<li><a href='#d-methods'><p> Methods for Function d in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#decomposePM-methods'><p> Methods for function decomposePM in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#DExp-class'><p>Class &quot;DExp&quot;</p></a></li>
<li><a href='#df-methods'><p> Methods for Function df in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#df1-methods'><p> Methods for Function df1 in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#df2-methods'><p> Methods for Function df2 in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#dim-methods'><p> Methods for Function dim in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#dimension-methods'><p> Methods for Function dimension in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#Dirac-class'><p>Class &quot;Dirac&quot;</p></a></li>
<li><a href='#DiracParameter-class'><p>Class &quot;DiracParameter&quot;</p></a></li>
<li><a href='#DiscreteDistribution'><p>Generating function &quot;DiscreteDistribution&quot;</p></a></li>
<li><a href='#DiscreteDistribution-class'><p>Class &quot;DiscreteDistribution&quot;</p></a></li>
<li><a href='#distr-defunct'><p>Class &quot;GeomParameter&quot;</p></a></li>
<li><a href='#distrARITH'><p>Arithmetics on Distributions</p></a></li>
<li><a href='#Distribution-class'><p>Class &quot;Distribution&quot;</p></a></li>
<li><a href='#DistributionSymmetry-class'><p>Class of Symmetries for Distributions</p></a></li>
<li><a href='#DistrList'><p>Generating function for DistrList-class</p></a></li>
<li><a href='#DistrList-class'><p>List of distributions</p></a></li>
<li><a href='#distrMASK'><p>Masking of/by other functions in package &quot;distr&quot;</p></a></li>
<li><a href='#distroptions'>
<p>functions to change the global variables of the package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#DistrSymmList'><p>Generating function for DistrSymmList-class</p></a></li>
<li><a href='#DistrSymmList-class'><p>List of Symmetries for a List of Distributions</p></a></li>
<li><a href='#EllipticalSymmetry'><p>Generating function for EllipticalSymmetry-class</p></a></li>
<li><a href='#EllipticalSymmetry-class'><p>Class for Elliptically Symmetric Distributions</p></a></li>
<li><a href='#EmpiricalDistribution'><p>Generating function &quot;EmpiricalDistribution&quot;</p></a></li>
<li><a href='#EuclideanSpace-class'><p>Class &quot;EuclideanSpace&quot;</p></a></li>
<li><a href='#Exp-class'><p>Class &quot;Exp&quot;</p></a></li>
<li><a href='#ExpOrGammaOrChisq-class'><p>Class &quot;ExpOrGammaOrChisq&quot;</p></a></li>
<li><a href='#ExpParameter-class'><p>Class &quot;ExpParameter&quot;</p></a></li>
<li><a href='#Fd-class'><p>Class &quot;Fd&quot;</p></a></li>
<li><a href='#flat.LCD'><p>Flattening a list of Lebesgue decomposed distributions</p></a></li>
<li><a href='#flat.mix'><p>Default procedure to fill slots d,p,q given r for Lebesgue decomposed distributions</p></a></li>
<li><a href='#FParameter-class'><p>Class &quot;FParameter&quot;</p></a></li>
<li><a href='#Gammad-class'><p>Class &quot;Gammad&quot;</p></a></li>
<li><a href='#GammaParameter-class'><p>Class &quot;GammaParameter&quot;</p></a></li>
<li><a href='#gaps-methods'><p> Methods for Functions gaps and setgaps in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#Geom-class'><p>Class &quot;Geom&quot;</p></a></li>
<li><a href='#getLabel'><p>Labels for distribution objects</p></a></li>
<li><a href='#getLow,getUp'><p>getLow, getUp functions of package distr</p></a></li>
<li><a href='#Huberize-methods'><p> Methods for function Huberize in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#Hyper-class'><p>Class &quot;Hyper&quot;</p></a></li>
<li><a href='#HyperParameter-class'><p>Class &quot;HyperParameter&quot;</p></a></li>
<li><a href='#igamma'><p>Inverse of the digamma function</p></a></li>
<li><a href='#img-methods'><p> Methods for Function img in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#Integer-class'><p>Internal Class &quot;Integer&quot;</p></a></li>
<li><a href='#InternalClassUnions'><p>Class unions in 'distr'</p></a></li>
<li><a href='#internalGenerics'><p>Internal: Common Generics 'distribution' and 'samplesize', 'samplesize&lt;-'</p></a></li>
<li><a href='#internals_for_distr'><p>Internal functions of package distr</p></a></li>
<li><a href='#internals_for_qqplot'><p>Internal functions for qqplot of package distr</p></a></li>
<li><a href='#k-methods'><p> Methods for Function k in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#lambda-methods'><p> Methods for Function lambda  in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#Lattice-class'><p>Class &quot;Lattice&quot;</p></a></li>
<li><a href='#LatticeDistribution'><p>Class &quot;LatticeDistribution&quot;</p></a></li>
<li><a href='#LatticeDistribution-class'><p>Class &quot;LatticeDistribution&quot;</p></a></li>
<li><a href='#Length-methods'><p> Methods for Function Length in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#liesIn-methods'><p> Methods for Function liesIn in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#liesInSupport'><p>Generic Function for Testing the Support of a Distribution</p></a></li>
<li><a href='#Lnorm-class'><p>Class &quot;Lnorm&quot;</p></a></li>
<li><a href='#LnormParameter-class'><p>Class &quot;LnormParameter&quot;</p></a></li>
<li><a href='#location-methods'><p> Methods for Function location in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#Logis-class'><p>Class &quot;Logis&quot;</p></a></li>
<li><a href='#LogisParameter-class'><p>Class &quot;LogisParameter&quot;</p></a></li>
<li><a href='#m-methods'><p> Methods for Function m in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#makeAbscontDistribution'><p>&quot;makeAbscontDistribution&quot;</p></a></li>
<li><a href='#Math-methods'><p> Methods for Functions from group &lsquo;Math&rsquo; in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#Max-methods'><p> Methods for Function Max in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#mean-methods'><p> Methods for Function mean in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#meanlog-methods'><p> Methods for Function meanlog in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#Min-methods'><p> Methods for Function Min in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#Minimum-methods'><p> Methods for functions Minimum and Maximum in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#n-methods'><p> Methods for Function n in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#name-methods'><p> Methods for Function name in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#Naturals-class'><p>Class &quot;Naturals&quot;</p></a></li>
<li><a href='#Nbinom-class'><p>Class &quot;Nbinom&quot;</p></a></li>
<li><a href='#NbinomParameter-class'><p>Class &quot;NbinomParameter&quot;</p></a></li>
<li><a href='#ncp-methods'><p> Methods for Function ncp in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#Norm-class'><p>Class &quot;Norm&quot;</p></a></li>
<li><a href='#NormParameter-class'><p>Class &quot;NormParameter&quot;</p></a></li>
<li><a href='#NoSymmetry'><p>Generating function for NoSymmetry-class</p></a></li>
<li><a href='#NoSymmetry-class'><p>Class for Non-symmetric Distributions</p></a></li>
<li><a href='#operators-methods'><p>Methods for operators +,-,*,/,... in Package distr</p></a></li>
<li><a href='#OptionalParameter-class'><p>Classes &quot;OptionalParameter&quot;, &quot;OptionalMatrix&quot;</p></a></li>
<li><a href='#options'>
<p>additional options in package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#p-methods'><p> Methods for Function p in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#p.l-methods'><p>Methods for Function p.l in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#param-methods'><p> Methods for Function param in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#Parameter-class'><p>Class &quot;Parameter&quot;</p></a></li>
<li><a href='#pivot-methods'><p> Methods for Function pivot in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#plot-methods'><p> Methods for Function plot in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#Pois-class'><p>Class &quot;Pois&quot;</p></a></li>
<li><a href='#PoisParameter-class'><p>Class &quot;PoisParameter&quot;</p></a></li>
<li><a href='#PosDefSymmMatrix'><p>Generating functions for PosSemDefSymmMatrix-class resp. PosDefSymmMatrix-class</p></a></li>
<li><a href='#PosDefSymmMatrix-class'><p>Positive-[Semi-]definite, symmetric matrices</p></a></li>
<li><a href='#print-methods'><p> Methods for Functions print/show in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#prob-methods'><p> Methods for Function prob in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#q-methods'><p>Methods for Function q in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#q.r-methods'><p>Methods for Function q.r in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#qqbounds'><p>Computation of confidence intervals for qqplot</p></a></li>
<li><a href='#qqplot'><p>Methods for Function qqplot in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#r-methods'><p> Methods for Function r in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#rate-methods'><p> Methods for Function rate in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#Reals-class'><p>Class &quot;Reals&quot;</p></a></li>
<li><a href='#rSpace-class'><p>Class &quot;rSpace&quot;</p></a></li>
<li><a href='#RtoDPQ'><p>Default procedure to fill slots d,p,q given r for a.c. distributions</p></a></li>
<li><a href='#RtoDPQ.d'><p>Default procedure to fill slots d,p,q given r for discrete distributions</p></a></li>
<li><a href='#RtoDPQ.LC'><p>Default procedure to fill slots d,p,q given r for Lebesgue decomposed distributions</p></a></li>
<li><a href='#scale-methods'><p> Methods for Function scale in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#sd-methods'><p> Methods for Function sd in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#sdlog-methods'><p> Methods for Function sdlog in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#shape-methods'><p> Methods for Function shape in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#shape1-methods'><p> Methods for Function shape1 in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#shape2-methods'><p> Methods for Function shape2 in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#showobj-methods'><p>Helping Methods for Functions print/show in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#simplifyD-methods'><p>Methods for function simplifyD in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#simplifyr-methods'><p> Methods for Function simplifyr in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#size-methods'><p> Methods for Function size in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#solve-methods'><p> Methods for Function solve in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#SphericalSymmetry'><p>Generating function for SphericalSymmetry-class</p></a></li>
<li><a href='#SphericalSymmetry-class'><p>Class for Spherical Symmetric Distributions</p></a></li>
<li><a href='#sqrt-methods'><p> Methods for Function sqrt in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#standardMethods'><p>Utility to automatically generate accessor and replacement functions</p></a></li>
<li><a href='#support-methods'><p>Methods for Function support in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#Symmetry-class'><p>Class of Symmetries</p></a></li>
<li><a href='#Td-class'><p>Class &quot;Td&quot;</p></a></li>
<li><a href='#TParameter-class'><p>Class &quot;TParameter&quot;</p></a></li>
<li><a href='#Truncate-methods'><p> Methods for function Truncate in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#Unif-class'><p>Class &quot;Unif&quot;</p></a></li>
<li><a href='#UnifParameter-class'><p>Class &quot;UnifParameter&quot;</p></a></li>
<li><a href='#UniNormParameter-class'><p>Class &quot;UniNormParameter&quot;</p></a></li>
<li><a href='#UnivarDistrList'><p>Generating function for UnivarDistrList-class</p></a></li>
<li><a href='#UnivarDistrList-class'><p>List of univariate distributions</p></a></li>
<li><a href='#UnivariateDistribution-class'><p>Class &quot;UnivariateDistribution&quot;</p></a></li>
<li><a href='#UnivarLebDecDistribution'><p>Generating function for Class &quot;UnivarLebDecDistribution&quot;</p></a></li>
<li><a href='#UnivarLebDecDistribution-class'><p>Class &quot;UnivarLebDecDistribution&quot;</p></a></li>
<li><a href='#UnivarMixingDistribution'><p>Generating function for Class &quot;UnivarMixingDistribution&quot;</p></a></li>
<li><a href='#UnivarMixingDistribution-class'><p>Class &quot;UnivarMixingDistribution&quot;</p></a></li>
<li><a href='#Version Management'><p> Methods for Version Management in Package &lsquo;distr&rsquo;</p></a></li>
<li><a href='#Weibull-class'><p>Class &quot;Weibull&quot;</p></a></li>
<li><a href='#WeibullParameter-class'><p>Class &quot;WeibullParameter&quot;</p></a></li>
<li><a href='#width-methods'><p> Methods for Function width in Package &lsquo;distr&rsquo;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.9.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-27</td>
</tr>
<tr>
<td>Title:</td>
<td>Object Oriented Implementation of Distributions</td>
</tr>
<tr>
<td>Description:</td>
<td>S4-classes and methods for distributions.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.4), methods, graphics, startupmsg, sfsmisc</td>
</tr>
<tr>
<td>Suggests:</td>
<td>distrEx, svUnit (&ge; 0.7-11), knitr, distrMod, ROptEst</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, grDevices, utils, MASS</td>
</tr>
<tr>
<td>Enhances:</td>
<td>RobAStBase</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://distr.r-forge.r-project.org/">http://distr.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>LastChangedDate:</td>
<td>{$LastChangedDate: 2023-05-07 23:08:38 +0200 (So, 07.
Mai 2023) $}</td>
</tr>
<tr>
<td>LastChangedRevision:</td>
<td>{$LastChangedRevision: 1407 $}</td>
</tr>
<tr>
<td>VCS/SVNRevision:</td>
<td>1422</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-28 16:19:47 UTC; ruckdesc</td>
</tr>
<tr>
<td>Author:</td>
<td>Florian Camphausen [ctb] (contributed as student in the initial phase
    --2005),
  Matthias Kohl [aut, cph],
  Peter Ruckdeschel [cre, cph],
  Thomas Stabla [ctb] (contributed as student in the initial phase
    --2005),
  R Core Team [ctb, cph] (for source file ks.c/ routines 'pKS2' and
    'pKolmogorov2x')</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Ruckdeschel &lt;peter.ruckdeschel@uni-oldenburg.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-29 23:40:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='distr-package'>
distr &ndash; Object Oriented Implementation of Distributions
</h2><span id='topic+distr-package'></span><span id='topic+distr'></span>

<h3>Description</h3>

<p><span class="pkg">distr</span> provides a conceptual treatment of distributions by means of S4
classes. A mother class <code>Distribution</code> is introduced with slots for a
parameter and &mdash;most important&mdash; for the four constitutive methods <code>r</code>,
<code>d</code>, <code>p</code>, and <code>q</code> for simulation respectively for evaluation of
density / c.d.f.\ and quantile function of the corresponding distribution.
Most distributions of  package <span class="pkg">stats</span> (like normal, Poisson, etc.)
are implemented as subclasses of either <code>AbscontDistribution</code> or
<code>DiscreteDistribution</code>, which themselves are again subclasses of
<code>Distribution</code>.
Up to arguments referring to a parameter of the distribution (like
<code>mean</code> for the normal distribution), these function slots have the
same arguments as those of package <span class="pkg">stats</span>, i.e.; for a distribution object
<code>X</code> we may call these functions as
</p>

<ul>
<li> <p><code>r(X)(n)</code>
</p>
</li>
<li> <p><code>d(X)(x, log = FALSE)</code>
</p>
</li>
<li> <p><code>p(X)(q, lower.tail = TRUE, log.p = FALSE)</code>
</p>
</li>
<li> <p><code>q(X)(p, lower.tail = TRUE, log.p = FALSE)</code>
</p>
</li></ul>

<p>For the arguments of these function slots see e.g. <code><a href="stats.html#topic+rnorm">rnorm</a></code>.
Note that, as usual, slots <code>d</code>, <code>p</code>, and <code>q</code> are vectorized
in their first argument, but are not on the subsequent ones.
In the environments of RStudio, see <a href="https://posit.co">https://posit.co</a> and
Jupyter IRKernel, see <a href="https://github.com/IRkernel/IRkernel">https://github.com/IRkernel/IRkernel</a>,
calls to <code>q</code> are caught away from standard R evaluation and are treated
in a non-standard way. This non-standard evaluation in particular throws
errors at calls to our accessor methods <code>q</code> to slot <code>q</code> of the
respective distribution object. To amend this, we provide function <code>q.l</code>
as alias to our accessors <code>q</code>, so that our packages also become available
in these environments.
Arithmetics and unary mathematical transformations for distributions are
available: For <code>Distribution</code> objects <code>X</code> and <code>Y</code> expressions
like <code>3*X+sin(exp(-Y/4+3))</code> have their natural interpretation as
corresponding image distributions.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> distr </td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.9.3 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-01-27 </td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R(&gt;= 3.4), methods, graphics, startupmsg, sfsmisc </td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> distrEx, svUnit (&gt;= 0.7-11), knitr, distrMod, ROptEst </td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> stats, grDevices, utils, MASS </td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> LGPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://distr.r-forge.r-project.org/</td>
</tr>
<tr>
 <td style="text-align: left;">
VCS/SVNRevision: </td><td style="text-align: left;"> 1422 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<h3>Classes</h3>

<p>Distribution classes have a slot <code>param</code> the class of which
is is specialized for the particualar distributions. The parameter
classes for the particular distributions have slots with names
according to the corresponding <var>[rdpq]&lt;name&gt;</var> functions of
package <span class="pkg">base</span>.
From version 1.9 on, <code>AbscontDistribution</code> and descendants have
a slot <code><a href="#topic+gaps">gaps</a></code> for gaps in the support.
<code>DiscreteDistribution</code> and descendants have
an additional slot <code><a href="#topic+support">support</a></code>, which is again specialized
to be a lattice for class <code>LatticeDistribution</code>. <br />
For saved objects from earlier versions, we provide the methods
<code><a href="#topic+isOldVersion">isOldVersion</a></code>, and  <code><a href="#topic+conv2NewVersion">conv2NewVersion</a></code>
to check whether the object was generated by an older version of
this package and to convert such an object to the new format,
respectively. This applies to objects of subclasses of
<code>AbscontDistribution</code> lacking a <code>gap</code>-slot as well as to
to objects of subclasses of <code>LatticeDistribution</code> lacking a
<code>lattice</code>-slot.<br />
To enhance accuracy, from version 1.9 on, we also provide
subclasses <code>AffLinAbscontDistribution</code>, <code>AffLinDiscreteDistribution</code>,
and <code>AffLinLatticeDistribution</code>, as well as the class union
<code>AffLinDistribution</code>, so that in particular functionals like <code>E</code>
from package <span class="pkg">distrEx</span> can recur to exact formula more frequently:
These classes have additional slots <code>a</code>, <code>b</code>, and <code>X0</code> to
reflect the fact, that a distribution object of theses classes has the
same distribution as <code>a*X0+b</code>.<br />
For all particular distributions, as well as for classes
<code>AbscontDistribution</code>, <code>DiscreteDistribution</code>,
<code>LatticeDistribution</code>, <code>UnivarDistrList</code> and <code>DistrList</code>
generating functions are provided, e.g. <code>X &lt;- Norm(mean = 3, sd = 2)</code>.
The same goes for the space classes.
All slots should be inspected / modified by means of corresponding
accessor- /replacement functions; e.g. <code>mean(X) &lt;- 3</code>
Again to enhance accuracy, from version 2.0 on, we also provide
subclasses <code>UnivarMixingDistribution</code> to support mixing distributions,
<code>UnivarLebDecDistribution</code>, to support Lebesgue decomposed distributions
(with a discrete and an a.c. part) as well as <code>AffLinUnivarLebDecDistribution</code>,
for corresponding affine linear transformations.
Class <code>UnivarLebDecDistribution</code> is closed under arithmetical operations
+  <code>/</code>, <code>*</code>, <code>^</code> for pairs of independent variables
+  <code>+</code>, <code>-</code> for pairs of independent variables
+  affine linear transformations
+  truncation, huberization, min/max
which are all now available analytically.<br />
(see Parameter classes).
</p>
<pre>
[*]: there is a generating function with the same name
##########################
Distribution classes
##########################
slots: [&lt;name&gt;(&lt;class&gt;)]
img(rSpace), param(OptionalParameter),
r(function), d(OptionalFunction), p(OptionalFunction), q(OptionalFunction),
.withSim(logical), .withArith(logical), .logExact(logical), .lowerExact(logical),
Symmetry(DistributionSymmetry)
"Distribution"
|&gt;"UnivariateDistribution"
|&gt;|&gt;"UnivarMixingDistribution"            [*]
|&gt;|&gt;|&gt;"UnivarLebDecDistribution"          [*]
|&gt;|&gt;|&gt;|&gt;"AffLinUnivarLebDecDistribution"
|&gt;|&gt;|&gt;"CompoundDistribution"              [*]
|&gt;|&gt;"AbscontDistribution"                 [*]
|&gt;|&gt;|&gt;"AffLinAbscontDistribution"
|&gt;|&gt;|&gt;"Arcsine"                           [*]
|&gt;|&gt;|&gt;"Beta"                              [*]
|&gt;|&gt;|&gt;"Cauchy"                            [*]
|&gt;|&gt;|&gt;"ExpOrGammaOrChisq" (VIRTUAL)
|&gt;|&gt;|&gt;|&gt;"Exp"                             [*]
|&gt;|&gt;|&gt;|&gt;"Gammad"                          [*]
|&gt;|&gt;|&gt;|&gt;"Chisq"                           [*]
|&gt;|&gt;|&gt;"Fd"                                [*]
|&gt;|&gt;|&gt;"Lnorm"                             [*]
|&gt;|&gt;|&gt;"Logis"                             [*]
|&gt;|&gt;|&gt;"Norm"                              [*]
|&gt;|&gt;|&gt;"Td"                                [*]
|&gt;|&gt;|&gt;"Unif"                              [*]
|&gt;|&gt;|&gt;"Weibull"                           [*]
|&gt;|&gt;|"DiscreteDistribution"               [*]
|&gt;|&gt;|&gt;"AffLinDiscreteDistribution"
|&gt;|&gt;|&gt;"LatticeDistribution"               [*]
|&gt;|&gt;|&gt;|&gt;"AffLinLatticeDistribution"
|&gt;|&gt;|&gt;|&gt;"Binom"                           [*]
|&gt;|&gt;|&gt;|&gt;"Dirac"                           [*]
|&gt;|&gt;|&gt;|&gt;"Hyper"                           [*]
|&gt;|&gt;|&gt;|&gt;"NBinom"                          [*]
|&gt;|&gt;|&gt;|&gt;|&gt;"Geom"                          [*]
|&gt;|&gt;|&gt;|&gt;"Pois"                            [*]
"AffLinDistribution" = union ( "AffLinAbscontDistribution",
                               "AffLinDiscreteDistribution",
                               "AffLinUnivarLebDecDistribution" )
"DistrList"
|&gt;"UnivarDistrList"                       [*]
"AcDcLc" = union ( "AbscontDistribution",
                   "DiscreteDistribution",
                   "UnivarLebDecDistribution" )
##########################
Parameter classes
##########################
"OptionalParameter"
|&gt;"Parameter"
|&gt;|&gt;"BetaParameter"
|&gt;|&gt;"BinomParameter"
|&gt;|&gt;"CauchyParameter"
|&gt;|&gt;"ChisqParameter"
|&gt;|&gt;"DiracParameter"
|&gt;|&gt;"ExpParameter"
|&gt;|&gt;"FParameter"
|&gt;|&gt;"GammaParameter"
|&gt;|&gt;"GeomParameter"
|&gt;|&gt;"HyperParameter"
|&gt;|&gt;"LnormParameter"
|&gt;|&gt;"LogisParameter"
|&gt;|&gt;"NbinomParameter"
|&gt;|&gt;"NormParameter"
|&gt;|&gt;"UniNormParameter"
|&gt;|&gt;|&gt;"PoisParameter"
|&gt;|&gt;"TParameter"
|&gt;|&gt;"UnifParameter"
|&gt;|&gt;"WeibullParameter"
##########################
Space classes
##########################
"rSpace"
|&gt;"EuclideanSpace"
|&gt;|&gt;"Reals"
|&gt;"Lattice"
|&gt;"Naturals"
##########################
Symmetry classes
##########################
slots:
type(character), SymmCenter(ANY)
"Symmetry"
|&gt;"NoSymmetry"          [*]
|&gt;"EllipticalSymmetry"  [*]
|&gt;|&gt;"SphericalSymmetry" [*]
|&gt;"DistributionSymmetry"
|&gt;"FunctionSymmetry"
|&gt;|&gt;"NonSymmetric"      [*]
|&gt;|&gt;"EvenSymmetric"     [*]
|&gt;|&gt;"OddSymmetric"      [*]
list thereof
"DistrSymmList"         [*]
"FunSymmList"           [*]
##########################
Matrix classes
##########################
slots:
none
"PosSemDefSymmMatrix" [*] is subclass of class "matrix" of package "base".
|&gt;"PosDefSymmMatrix"  [*]
##########################
Class unions
##########################
"OptionalNumeric" = union("numeric", "NULL")
"OptionalMatrix" = union("matrix","NULL")
</pre>


<h3>Methods</h3>

<p>The group <code>Math</code> of unary (see <a href="methods.html#topic+S4groupGeneric">Math</a>) as well as
convolution are made available for distributions, see <a href="#topic+operators-methods">operators-methods</a>
;in particular for convolution powers, we have method <a href="#topic+convpow">convpow</a>.
Besides, there are <code>plot</code> and <code>print</code>-methods for distributions.
For the space classes, we have <code>liesIn</code>, for the
<code>DicreteDistribution</code> class, we have <code>liesInSupport</code>, as well
as a generating function.
The &quot;history&quot; of distributions
obtained by chaining operations may be shortened using <code>simplifyr</code>.
</p>


<h3>Functions</h3>

<pre>
RtoDPQ                  Default procedure to fill slots d,p,q given r
                        for a.c. distributions
RtoDPQ.d                Default procedure to fill slots d,p,q given r
                        for discrete distributions
RtoDPQ.LC               Default procedure to fill slots d,p,q given r
                        for Lebesgue decomposed distributions
decomposePM             decomposes a distribution into positive and negative
                        part and, if discrete, into part '0'
simplifyD               tries to reduce/simplify mixing distribution using
                        that certain weights are 0
flat.LCD                makes a single UnivarLebDecDistribution out of
                        a list of UnivarLebDecDistribution with corresp. weights
flat.mix                makes a single UnivarLebDecDistribution out of
                        a list of a UnivarMixingDistribution
distroptions            Functions to change the global variables of the
                        package 'distr'
standardMethods         Utility to automatically generate accessor and
                        replacement functions
</pre>

<h3>Extension Packages in distrXXX family</h3>

<p>Please note that there are extension packages of this packages
available on CRAN,
</p>

<dl>
<dt><span class="pkg">distrDoc</span></dt><dd><p>a documentation package providing joint documentation
for all packages of the distrXXX family of packages in the form of vignette
'distr'; try <code>require(distrDoc); vignette("distr")</code>.</p>
</dd>
<dt><span class="pkg">distrEx</span></dt><dd><p>provides functionals (like <code>E</code>, <code>sd</code>, <code>mad</code>)
operating on distributions, as well as distances between distributions and basic
support for multivariate and conditional distributions.</p>
</dd>
<dt><span class="pkg">distrSim</span></dt><dd><p>for the standardized treatment of simulations,
also under contaminations.</p>
</dd>
<dt><span class="pkg">distrTEst</span></dt><dd><p>with classes and methods for evaluations of statistical procedures
on simulations generated by <span class="pkg">distrSim</span>.</p>
</dd>
<dt><span class="pkg">distrTeach</span></dt><dd><p>embodies illustrations for basic stats courses using
our distribution classes.</p>
</dd>
<dt><span class="pkg">distrMod</span></dt><dd><p>provides classes for parametric models and hence covers,
in an object orientated way, estimation in statistical models.</p>
</dd>
<dt><span class="pkg">distrEllipse</span></dt><dd><p>provides classes for elliptically symmetric
distributions.</p>
</dd>
</dl>



<h3>Package versions</h3>

<p>Note: The first two numbers of package versions do not necessarily reflect
package-individual development, but rather are chosen for the
distrXXX family as a whole in order to ease updating &quot;depends&quot;
information.
</p>


<h3>Acknowledgement</h3>

<p>We thank Martin Maechler, Josef Leydold, John Chambers,
Duncan Murdoch, Gregory Warnes, Paul Gilbert, Kurt Hornik,
Uwe Ligges, Torsten Hothorn, and Seth Falcon for their help
in preparing this package.</p>


<h3>Start-up-Banner</h3>

<p>You may suppress the start-up banner/message completely by setting
<code>options("StartupBanner"="off")</code> somewhere before loading this
package by <code>library</code> or <code>require</code> in your R-code / R-session.
If option <code>"StartupBanner"</code> is not defined (default) or setting
<code>options("StartupBanner"=NULL)</code> or
<code>options("StartupBanner"="complete")</code> the complete start-up banner is
displayed.
For any other value of option <code>"StartupBanner"</code>
(i.e., not in <code>c(NULL,"off","complete")</code>)
only the version information is displayed.
The same can be achieved by wrapping the <code>library</code> or <code>require</code>
call into either <code>suppressStartupMessages()</code> or
<code>onlytypeStartupMessages(.,atypes="version")</code>.
As for general <code>packageStartupMessage</code>'s, you may also suppress all
the start-up banner by wrapping the <code>library</code> or <code>require</code>
call into <code>suppressPackageStartupMessages()</code> from
<span class="pkg">startupmsg</span>-version 0.5 on.
</p>


<h3>Demos</h3>

<p>Demos are available &mdash; see <code>demo(package="distr")</code></p>


<h3>Note</h3>

<p>Arithmetics on distribution objects are understood as operations on
corresponding  (independent) r.v.'s and <strong>not</strong> on distribution functions
or densities.<br />
See also <code>distrARITH()</code>.<br />
Some functions of package <span class="pkg">stats</span> have intentionally been masked,
but completely retain their functionality &mdash; see <code>distrMASK()</code>.<br />
Accuracy of these arithmetics is controlled by global options which may
be inspected / set by <code>distroptions()</code> and <code>getdistrOption()</code>,
confer <a href="#topic+distroptions">distroptions</a> .
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br />
Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br />
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a><br />
<em>Maintainer:</em> Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>References</h3>

<p>P. Ruckdeschel, M. Kohl, T. Stabla, F. Camphausen (2006):
S4 Classes for Distributions, <em>R News</em>, <em>6</em>(2), 2-6.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-2.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-2.pdf</a>
P. Ruckdeschel and M. Kohl (2014):
General purpose convolution algorithm for distributions
in S4-Classes by means of FFT. <em>J. Statist. Softw.</em>
<b>59</b>(4): 1-25.
a vignette for packages <span class="pkg">distr</span>, <span class="pkg">distrSim</span>, <span class="pkg">distrTEst</span>, and
<span class="pkg">distrEx</span> is included into the mere documentation package <span class="pkg">distrDoc</span>
and may be called by
<code>require("distrDoc");vignette("distr")</code>
a homepage to this package is available under<br />
<a href="https://distr.r-forge.r-project.org/">https://distr.r-forge.r-project.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- Unif(2,3)
Y &lt;- Pois(lambda = 3)
Z &lt;- X+Y  # generates Law of corresponding independent variables
p(Z)(0.2)
r(Z)(1000)
plot(Z+sin(Norm()))
</code></pre>

<hr>
<h2 id='AbscontDistribution'>Generating function &quot;AbscontDistribution&quot;</h2><span id='topic+AbscontDistribution'></span>

<h3>Description</h3>

<p>Generates an object of class  <code>"AbscontDistribution"</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>AbscontDistribution(r = NULL, d = NULL, p = NULL, q = NULL,
                   gaps = NULL, param = NULL, img = new("Reals"),
                   .withSim = FALSE, .withArith = FALSE,
                    .lowerExact = FALSE, .logExact = FALSE,
                   withgaps = getdistrOption("withgaps"),
                   low1 = NULL, up1 = NULL, low = -Inf, up =Inf,
                   withStand = FALSE,
                   ngrid = getdistrOption("DefaultNrGridPoints"),
                   ep = getdistrOption("TruncQuantile"),
                   e = getdistrOption("RtoDPQ.e"),
                   Symmetry = NoSymmetry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AbscontDistribution_+3A_r">r</code></td>
<td>
<p>slot <code>r</code> to be filled</p>
</td></tr> 
<tr><td><code id="AbscontDistribution_+3A_d">d</code></td>
<td>
<p>slot <code>d</code> to be filled</p>
</td></tr> 
<tr><td><code id="AbscontDistribution_+3A_p">p</code></td>
<td>
<p>slot <code>p</code> to be filled</p>
</td></tr> 
<tr><td><code id="AbscontDistribution_+3A_q">q</code></td>
<td>
<p>slot <code>q</code> to be filled</p>
</td></tr> 
<tr><td><code id="AbscontDistribution_+3A_gaps">gaps</code></td>
<td>
<p>slot gaps (of class <code>"matrix"</code> with two columns) to be filled 
(i.e. <code>t(gaps)</code> must be ordered if read as vector)</p>
</td></tr> 
<tr><td><code id="AbscontDistribution_+3A_param">param</code></td>
<td>
<p>parameter (of class <code>"OptionalParameter"</code>)</p>
</td></tr> 
<tr><td><code id="AbscontDistribution_+3A_img">img</code></td>
<td>
<p>image range of the distribution (of class <code>"rSpace"</code>)</p>
</td></tr> 
<tr><td><code id="AbscontDistribution_+3A_low1">low1</code></td>
<td>
<p>lower bound (to be the lower TruncQuantile-quantile of the distribution)</p>
</td></tr> 
<tr><td><code id="AbscontDistribution_+3A_up1">up1</code></td>
<td>
<p>upper bound (to be the upper TruncQuantile-quantile of the distribution)</p>
</td></tr> 
<tr><td><code id="AbscontDistribution_+3A_low">low</code></td>
<td>
<p>lower bound (to be the 100-percent-quantile of the distribution)</p>
</td></tr>   
<tr><td><code id="AbscontDistribution_+3A_up">up</code></td>
<td>
<p>upper bound (to be the 100-percent-quantile of the distribution)</p>
</td></tr>  
<tr><td><code id="AbscontDistribution_+3A_withstand">withStand</code></td>
<td>
<p>logical: shall we standardize argument function <code>d</code>
to integrate to 1 &mdash; default is no resp. <code>FALSE</code></p>
</td></tr>  
<tr><td><code id="AbscontDistribution_+3A_ngrid">ngrid</code></td>
<td>
<p>number of gridpoints</p>
</td></tr>
<tr><td><code id="AbscontDistribution_+3A_ep">ep</code></td>
<td>
<p>tolerance epsilon</p>
</td></tr>
<tr><td><code id="AbscontDistribution_+3A_e">e</code></td>
<td>
<p>exponent to base 10 to be used for simulations</p>
</td></tr>
<tr><td><code id="AbscontDistribution_+3A_withgaps">withgaps</code></td>
<td>
<p>logical; shall gaps be reconstructed empirically?</p>
</td></tr>
<tr><td><code id="AbscontDistribution_+3A_.witharith">.withArith</code></td>
<td>
<p>normally not set by the user, but if determining the entries <code>supp</code>, <code>prob</code>
distributional arithmetics was involved, you may set this to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="AbscontDistribution_+3A_.withsim">.withSim</code></td>
<td>
<p>normally not set by the user, but if determining the entries <code>supp</code>, <code>prob</code>
simulations were involved, you may set this to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="AbscontDistribution_+3A_.lowerexact">.lowerExact</code></td>
<td>
<p>normally not set by the user: whether the <code>lower.tail=FALSE</code>
part is calculated exactly, avoing a &ldquo;<code>1-.</code>&rdquo;.</p>
</td></tr>
<tr><td><code id="AbscontDistribution_+3A_.logexact">.logExact</code></td>
<td>
<p>normally not set by the user: whether in determining slots <code>d,p,q</code>,
we make particular use of a logarithmic representation to enhance accuracy.</p>
</td></tr>
<tr><td><code id="AbscontDistribution_+3A_symmetry">Symmetry</code></td>
<td>
<p>you may help <span class="rlang"><b>R</b></span> in calculations if you tell it whether
the distribution is non-symmetric (default) or symmetric with respect
to a center; in this case use <code>Symmetry=SphericalSymmetry(center)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typical usages are
</p>
<pre>
  AbscontDistribution(r)
  AbscontDistribution(r = NULL, d)
  AbscontDistribution(r = NULL, d = NULL, p)
  AbscontDistribution(r = NULL, d = NULL, p = NULL, d)
  AbscontDistribution(r, d, p, q)
  </pre>
<p>Minimally, only one of the slots <code>r</code>, <code>d</code>, <code>p</code> or <code>q</code> needs to be given as argument.
The other non-given slots are then reconstructed according to the following scheme:
</p>

<table>
<tr>
 <td style="text-align: center;">
r</td><td style="text-align: center;"> d</td><td style="text-align: center;"> p</td><td style="text-align: center;"> q</td><td style="text-align: left;"> proceding</td>
</tr>
<tr>
 <td style="text-align: center;">
-</td><td style="text-align: center;"> -</td><td style="text-align: center;"> -</td><td style="text-align: center;"> -</td><td style="text-align: left;"> excluded</td>
</tr>
<tr>
 <td style="text-align: center;">
-</td><td style="text-align: center;"> +</td><td style="text-align: center;"> -</td><td style="text-align: center;"> -</td><td style="text-align: left;"> p by <code>.D2P</code>, q by <code>.P2Q</code>, r by <code>q(runif(n))</code></td>
</tr>
<tr>
 <td style="text-align: center;">
-</td><td style="text-align: center;"> -</td><td style="text-align: center;"> +</td><td style="text-align: center;"> -</td><td style="text-align: left;"> d by <code>.P2D</code>, q by <code>.P2Q</code>, r by <code>q(runif(n))</code></td>
</tr>
<tr>
 <td style="text-align: center;">
-</td><td style="text-align: center;"> +</td><td style="text-align: center;"> +</td><td style="text-align: center;"> -</td><td style="text-align: left;"> q by <code>.P2Q</code>, r by <code>q(runif(n))</code></td>
</tr>
<tr>
 <td style="text-align: center;">
-</td><td style="text-align: center;"> -</td><td style="text-align: center;"> -</td><td style="text-align: center;"> +</td><td style="text-align: left;"> p by <code>.Q2P</code>, d by <code>.P2D</code>, r by <code>q(runif(n))</code></td>
</tr>
<tr>
 <td style="text-align: center;">
-</td><td style="text-align: center;"> +</td><td style="text-align: center;"> -</td><td style="text-align: center;"> +</td><td style="text-align: left;"> p by <code>.Q2P</code>, r by <code>q(runif(n))</code></td>
</tr>
<tr>
 <td style="text-align: center;">
-</td><td style="text-align: center;"> -</td><td style="text-align: center;"> +</td><td style="text-align: center;"> +</td><td style="text-align: left;"> d by <code>.P2D</code>, r by <code>q(runif(n))</code></td>
</tr>
<tr>
 <td style="text-align: center;">
-</td><td style="text-align: center;"> +</td><td style="text-align: center;"> +</td><td style="text-align: center;"> +</td><td style="text-align: left;"> r by <code>q(runif(n))</code></td>
</tr>
<tr>
 <td style="text-align: center;">
+</td><td style="text-align: center;"> -</td><td style="text-align: center;"> -</td><td style="text-align: center;"> -</td><td style="text-align: left;"> call to <code><a href="#topic+RtoDPQ">RtoDPQ</a></code></td>
</tr>
<tr>
 <td style="text-align: center;">
+</td><td style="text-align: center;"> +</td><td style="text-align: center;"> -</td><td style="text-align: center;"> -</td><td style="text-align: left;"> p by <code>.D2P</code>, q by <code>.P2Q</code></td>
</tr>
<tr>
 <td style="text-align: center;">
+</td><td style="text-align: center;"> -</td><td style="text-align: center;"> +</td><td style="text-align: center;"> -</td><td style="text-align: left;"> d by <code>.P2D</code>, q by <code>.P2Q</code></td>
</tr>
<tr>
 <td style="text-align: center;">
+</td><td style="text-align: center;"> +</td><td style="text-align: center;"> +</td><td style="text-align: center;"> -</td><td style="text-align: left;"> q by <code>.P2Q</code></td>
</tr>
<tr>
 <td style="text-align: center;">
+</td><td style="text-align: center;"> -</td><td style="text-align: center;"> -</td><td style="text-align: center;"> +</td><td style="text-align: left;"> p by <code>.Q2P</code>, d by <code>.P2D</code></td>
</tr>
<tr>
 <td style="text-align: center;">
+</td><td style="text-align: center;"> +</td><td style="text-align: center;"> -</td><td style="text-align: center;"> +</td><td style="text-align: left;"> p by <code>.Q2P</code></td>
</tr>
<tr>
 <td style="text-align: center;">
+</td><td style="text-align: center;"> -</td><td style="text-align: center;"> +</td><td style="text-align: center;"> +</td><td style="text-align: left;"> d by <code>.P2D</code></td>
</tr>
<tr>
 <td style="text-align: center;">
+</td><td style="text-align: center;"> +</td><td style="text-align: center;"> +</td><td style="text-align: center;"> +</td><td style="text-align: left;"> nothing</td>
</tr>

</table>

<p>For this purpose, one may alternatively give arguments <code>low1</code> and <code>up1</code> (<code>NULL</code> each by default,
and determined through slot <code>q</code>, resp. <code>p</code>, resp. <code>d</code>, resp. <code>r</code> in this order
according to availability),
for the (finite) range of values in the support of this distribution, 
as well as the possibly infinite theoretical range given by
arguments <code>low</code> and <code>up</code> with default values <code>-Inf</code>, <code>Inf</code>, respectively.
Of course all other slots may be specified as arguments.</p>


<h3>Value</h3>

<p>Object of class <code>"AbscontDistribution"</code></p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>,
<code><a href="#topic+DiscreteDistribution-class">DiscreteDistribution-class</a></code>, 
<code><a href="#topic+RtoDPQ">RtoDPQ</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(Norm())
plot(AbscontDistribution(r = rnorm))
plot(AbscontDistribution(d = dnorm))
plot(AbscontDistribution(p = pnorm))
plot(AbscontDistribution(q = qnorm))
plot(Ac &lt;- AbscontDistribution(d = function(x, log = FALSE){
                                   d &lt;- exp(-abs(x^3))
                                   ## unstandardized!!
                                   if(log) d &lt;- log(d)
                                   return(d)}, 
                         withStand = TRUE))
</code></pre>

<hr>
<h2 id='AbscontDistribution-class'>Class &quot;AbscontDistribution&quot;</h2><span id='topic+AbscontDistribution-class'></span><span id='topic+AffLinDistribution-class'></span><span id='topic+AffLinAbscontDistribution-class'></span><span id='topic+sqrt+2CAbscontDistribution-method'></span><span id='topic+initialize+2CAbscontDistribution-method'></span><span id='topic+initialize+2CAffLinAbscontDistribution-method'></span><span id='topic+sqrt+2CAbscontDistribution-method'></span>

<h3>Description</h3>

<p>The <code>AbscontDistribution</code>-class is the mother-class of the classes <code>Beta</code>, <code>Cauchy</code>, 
<code>Chisq</code>, <code>Exp</code>, <code>F</code>, <code>Gammad</code>, <code>Lnorm</code>, <code>Logis</code>, <code>Norm</code>, <code>T</code>, <code>Unif</code> and 
<code>Weibull</code>. Further absolutely continuous distributions can be defined either by declaration of
own random number generator, density, cumulative distribution and quantile functions, or as result of a 
convolution of two absolutely continuous distributions or by application of a mathematical operator to an absolutely
continuous distribution.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("AbscontDistribution", r, d, p, q)</code>.
More comfortably, you may use the generating function <code><a href="#topic+AbscontDistribution">AbscontDistribution</a></code>.
The result of these calls is an absolutely continuous distribution. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>: the space of the image of this distribution which has dimension 1
and the name &quot;Real Space&quot; </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"Parameter"</code>: the parameter of this distribution, having only 
the slot name &quot;Parameter of an absolutely continuous distribution&quot; </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: generates random numbers</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>: density function</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>: cumulative distribution function</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>: quantile function</p>
</dd>
<dt><code>gaps</code></dt><dd><p>[from version 1.9 on] Object of class <code>"OptionalMatrix"</code>, 
i.e.; an object which may either be <code>NULL</code> ora <code>matrix</code>. 
This slot, if non-<code>NULL</code>, contains left and right 
endpoints of intervals where the density of the object is 0. This slot 
may be inspected by the accessor <code><a href="#topic+gaps">gaps</a>()</code> and modified by a corresponding
replacement method. It may also be filled automatically by 
<code><a href="#topic+setgaps">setgaps</a>()</code>. For saved objects from earlier versions, we provide functions
<code><a href="#topic+isOldVersion">isOldVersion</a></code> and <code><a href="#topic+conv2NewVersion">conv2NewVersion</a></code>.</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>


<h3>Extends</h3>

<p>Class <code>"UnivariateDistribution"</code>, directly. <br />
Class <code>"Distribution"</code>, by class <code>"UnivariateDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "AbscontDistribution")</code>: initialize method </p>
</dd>
<dt>Math</dt><dd><p><code>signature(x = "AbscontDistribution")</code>: application of a mathematical function, e.g. <code>sin</code> or
<code>exp</code> (does not work with <code>log</code>, <code>sign</code>!), to this absolutely continouos distribution
</p>

<ul>
<li> <p><code>abs</code>: <code>signature(x = "AbscontDistribution")</code>: exact image distribution of <code>abs(x)</code>.
</p>
</li>
<li> <p><code>exp</code>: <code>signature(x = "AbscontDistribution")</code>:  exact image distribution of <code>exp(x)</code>.
</p>
</li>
<li> <p><code>sign</code>: <code>signature(x = "AbscontDistribution")</code>:  exact image distribution of <code>sign(x)</code>.
</p>
</li>
<li> <p><code>sqrt</code>: <code>signature(x = "AbscontDistribution")</code>:  exact image distribution of <code>sqrt(x)</code>.
</p>
</li>
<li> <p><code>log</code>: <code>signature(x = "AbscontDistribution")</code>:  (with optional further argument <code>base</code>, defaulting to <code>exp(1)</code>) exact image distribution of <code>log(x)</code>.
</p>
</li>
<li> <p><code>log10</code>: <code>signature(x = "AbscontDistribution")</code>:  exact image distribution of <code>log10(x)</code>.
</p>
</li>
<li> <p><code>gamma</code>: <code>signature(x = "AbscontDistribution")</code>:  exact image distribution of <code>gamma(x)</code>.
</p>
</li>
<li> <p><code>lgamma</code>: <code>signature(x = "AbscontDistribution")</code>:  exact image distribution of <code>lgamma(x)</code>.
</p>
</li>
<li> <p><code>digamma</code>: <code>signature(x = "AbscontDistribution")</code>:  exact image distribution of <code>digamma(x)</code>.
</p>
</li>
<li> <p><code>sqrt</code>: <code>signature(x = "AbscontDistribution")</code>:  exact image distribution of <code>sqrt(x)</code>.
</p>
</li></ul>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "AbscontDistribution")</code>: application of &lsquo;-&rsquo; to this absolutely continuous distribution.</p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "AbscontDistribution", e2 = "numeric")</code>: multiplication of this absolutely continuous distribution by an object of class <code>"numeric"</code></p>
</dd>
<dt>/</dt><dd><p><code>signature(e1 = "AbscontDistribution", e2 = "numeric")</code>: division of this absolutely continuous distribution by an object of class <code>"numeric"</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "AbscontDistribution", e2 = "numeric")</code>: addition of this absolutely continuous distribution to an object of class <code>"numeric"</code>.</p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "AbscontDistribution", e2 = "numeric")</code>: subtraction of an object of class <code>"numeric"</code> from this absolutely continuous distribution.</p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "numeric", e2 = "AbscontDistribution")</code>: multiplication of this absolutely continuous distribution by an object of class <code>"numeric"</code>.</p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "numeric", e2 = "AbscontDistribution")</code>: addition of this absolutely continuous distribution to an object of class <code>"numeric"</code>.</p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "numeric", e2 = "AbscontDistribution")</code>: subtraction of this absolutely continuous distribution from an object of class <code>"numeric"</code>.</p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "AbscontDistribution", e2 = "AbscontDistribution")</code>: Convolution of two absolutely continuous distributions. The slots p, d and q are approximated by grids.</p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "AbscontDistribution", e2 = "AbscontDistribution")</code>: Convolution of two absolutely continuous distributions. The slots p, d and q are approximated by grids.</p>
</dd>
<dt>plot</dt><dd><p><code>signature(object = "AbscontDistribution")</code>: plots density, cumulative distribution and quantile function.</p>
</dd>
</dl>



<h3>Internal subclass &quot;AffLinAbscontDistribution&quot;</h3>

<p>To enhance accuracy of several functionals on distributions,
mainly from package <span class="pkg">distrEx</span>, from version 1.9 of this package on, 
there is an internally used (but exported) subclass 
<code>"AffLinAbscontDistribution"</code> which has extra slots 
<code>a</code>, <code>b</code> (both of class <code>"numeric"</code>),  and <code>X0</code> 
(of class <code>"AbscontDistribution"</code>), to capture the fact 
that the object has the same distribution as <code>a * X0 + b</code>. This is 
the class of the return value of methods 
</p>

<dl>
<dt>-</dt><dd><p><code>signature(e1 = "AbscontDistribution")</code></p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "AbscontDistribution", e2 = "numeric")</code></p>
</dd>
<dt>/</dt><dd><p><code>signature(e1 = "AbscontDistribution", e2 = "numeric")</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "AbscontDistribution", e2 = "numeric")</code></p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "AbscontDistribution", e2 = "numeric")</code></p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "numeric", e2 = "AbscontDistribution")</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "numeric", e2 = "AbscontDistribution")</code></p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "numeric", e2 = "AbscontDistribution")</code></p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "AffLinAbscontDistribution")</code></p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "AffLinAbscontDistribution", e2 = "numeric")</code></p>
</dd>
<dt>/</dt><dd><p><code>signature(e1 = "AffLinAbscontDistribution", e2 = "numeric")</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "AffLinAbscontDistribution", e2 = "numeric")</code></p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "AffLinAbscontDistribution", e2 = "numeric")</code></p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "numeric", e2 = "AffLinAbscontDistribution")</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "numeric", e2 = "AffLinAbscontDistribution")</code></p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "numeric", e2 = "AffLinAbscontDistribution")</code></p>
</dd>
</dl>

<p>There also is a class union of <code>"AffLinAbscontDistribution"</code>,
<code>"AffLinDiscreteDistribution"</code>, <code>"AffLinUnivarLebDecDistribution"</code>
and called <code>"AffLinDistribution"</code>
which is used for functionals.
</p>


<h3>Internal virtual superclass &quot;AcDcLcDistribution&quot;</h3>

<p>As many operations should be valid no matter whether the operands
are of class <code>"AbscontDistribution"</code>,
<code>"DiscreteDistribution"</code>, or <code>"UnivarLebDecDistribution"</code>,
there is a class union of these classes called <code>"AcDcLcDistribution"</code>;
in partiucalar methods for <code>"*"</code>, <code>"/"</code>, 
<code>"^"</code> (see <a href="#topic+operators-methods">operators-methods</a>) and methods
<code><a href="#topic+Minimum">Minimum</a></code>, <code>Maximum</code>, <code><a href="#topic+Truncate">Truncate</a></code>, and
<code><a href="#topic+Huberize">Huberize</a></code>, and <code><a href="#topic+convpow">convpow</a></code> are defined for this 
class union.   
</p>


<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AbscontDistribution">AbscontDistribution</a></code>
<code><a href="#topic+Parameter-class">Parameter-class</a></code>
<code><a href="#topic+UnivariateDistribution-class">UnivariateDistribution-class</a></code>
<code><a href="#topic+Beta-class">Beta-class</a></code>
<code><a href="#topic+Cauchy-class">Cauchy-class</a></code>
<code><a href="#topic+Chisq-class">Chisq-class</a></code>
<code><a href="#topic+Exp-class">Exp-class</a></code>
<code><a href="#topic+Fd-class">Fd-class</a></code>
<code><a href="#topic+Gammad-class">Gammad-class</a></code>
<code><a href="#topic+Lnorm-class">Lnorm-class</a></code>
<code><a href="#topic+Logis-class">Logis-class</a></code>
<code><a href="#topic+Norm-class">Norm-class</a></code>
<code><a href="#topic+Td-class">Td-class</a></code>
<code><a href="#topic+Unif-class">Unif-class</a></code>
<code><a href="#topic+Weibull-class">Weibull-class</a></code>
<code><a href="#topic+DiscreteDistribution-class">DiscreteDistribution-class</a></code>
<code><a href="#topic+Reals-class">Reals-class</a></code>
<code><a href="#topic+RtoDPQ">RtoDPQ</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;-  Norm() # N is a normal distribution with mean=0 and sd=1.
E &lt;-  Exp() # E is an exponential distribution with rate=1.
A1 &lt;-  E+1 # a new absolutely continuous distributions with exact slots d, p, q
A2 &lt;-  A1*3 # a new absolutely continuous distributions with exact slots d, p, q
A3 &lt;- N*0.9 + E*0.1 # a new absolutely continuous distribution with approximated slots d, p, q
r(A3)(1) # one random number generated from this distribution, e.g. -0.7150937
d(A3)(0) # The (approximated) density for x=0 is 0.43799.
p(A3)(0) # The (approximated) probability that x &lt;= 0 is 0.45620.
q(A3)(.1) # The (approximated) 10 percent quantile is -1.06015.
## in RStudio or Jupytier IRKernel, use q.l(.)(.) instead of q(.)(.)
</code></pre>

<hr>
<h2 id='Arcsine-class'>Class &quot;Arcsine&quot;</h2><span id='topic+Arcsine-class'></span><span id='topic+Arcsine'></span><span id='topic+initialize+2CArcsine-method'></span>

<h3>Description</h3>

<p>The Arcsine distribution has density
</p>
<p style="text-align: center;"><code class="reqn">f(x)=\frac{1}{\pi \sqrt{1-x^2}%
  }</code>
</p>

<p>for <code class="reqn">-1 &lt; x &lt; 1</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Arcsine()</code>.
This object is an Arcsine distribution.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>:
The space of the image of this distribution has got dimension 1 and the name &quot;Real Space&quot;. </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>:
generates random numbers (calls function rArcsine)</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>:
density function (calls function dArcsine)</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>:
cumulative function (calls function pArcsine)</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>:
inverse of the cumulative function (calls function qArcsine)</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"AbscontDistribution"</code>, directly. <br />
Class <code>"UnivariateDistribution"</code>, by class <code>"AbscontDistribution"</code>. <br />
Class <code>"Distribution"</code>, by class <code>"AbscontDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "Arcsine")</code>:
initialize method</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>
<code><a href="#topic+Reals-class">Reals-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- Arcsine()
# A is a Arcsine distribution with shape1 = 1 and shape2 = 1.
r(A)(3) # three random number generated from this distribution, e.g. 0.6979795
d(A)(c(-2,-1,-0.2,0,0.2,1,2)) # Density at x=c(-1,-0.2,0,0.2,1).
p(A)(c(-2,-1,-0.2,0,0.2,1,2)) # cdf at q=c(-1,-0.2,0,0.2,1).
q(A)(c(0,0.2,1,2)) # quantile function at at x=c(0,0.2,1).
## in RStudio or Jupyter IRKernel, use q.l(A)(c(0,0.2,1,2)) instead
</code></pre>

<hr>
<h2 id='Beta-class'>Class &quot;Beta&quot;</h2><span id='topic+Beta-class'></span><span id='topic+Beta'></span><span id='topic+initialize+2CBeta-method'></span>

<h3>Description</h3>

<p>The Beta distribution with parameters <code>shape1</code> <code class="reqn">= a</code> and
<code>shape2</code> <code class="reqn">= b</code> has density
</p>
<p style="text-align: center;"><code class="reqn">f(x)=\frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)}{x}^{a-1} {(1-x)}^{b-1}%
  </code>
</p>

<p>for <code class="reqn">a &gt; 0</code>, <code class="reqn">b &gt; 0</code> and <code class="reqn">0 \le x \le 1</code>
where the boundary values at <code class="reqn">x=0</code> or <code class="reqn">x=1</code> are defined as
by continuity (as limits).
</p>


<h3>Ad hoc methods</h3>

<p>For R Version <code>&lt;2.3.0</code> ad hoc methods are provided for slots <code>q</code>, <code>r</code> if <code>ncp!=0</code>;
for R Version <code>&gt;=2.3.0</code> the methods from package <span class="pkg">stats</span> are used.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Beta(shape1, shape2)</code>.
This object is a beta distribution.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>:
The space of the image of this distribution has got dimension 1 and the name &quot;Real Space&quot;. </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"BetaParameter"</code>:
the parameter of this distribution (shape1 and shape2), declared at its instantiation </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>:
generates random numbers (calls function rbeta)</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>:
density function (calls function dbeta)</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>:
cumulative function (calls function pbeta)</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>:
inverse of the cumulative function (calls function qbeta)</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"AbscontDistribution"</code>, directly. <br />
Class <code>"UnivariateDistribution"</code>, by class <code>"AbscontDistribution"</code>. <br />
Class <code>"Distribution"</code>, by class <code>"AbscontDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "Beta")</code>:
initialize method</p>
</dd>
<dt>shape1</dt><dd><p><code>signature(object = "Beta")</code>:
returns the slot shape1 of the parameter of the distribution</p>
</dd>
<dt>shape1&lt;-</dt><dd><p><code>signature(object = "Beta")</code>:
modifies the slot shape1 of the parameter of the distribution</p>
</dd>
<dt>shape2</dt><dd><p><code>signature(object = "Beta")</code>:
returns the slot shape2 of the parameter of the distribution</p>
</dd>
<dt>shape2&lt;-</dt><dd><p><code>signature(object = "Beta")</code>:
modifies the slot shape2 of the parameter of the distribution</p>
</dd>
<dt><code>-</code></dt><dd><p><code>signature(e1 = "numeric", e2 = "Beta")</code> if <code>ncp(e2)==0</code> and <code>e1 == 1</code>,
an exact (central) <code>Beta(shape1 = shape2(e2), shape2 = shape1(e2))</code> is returned, else
the default method is used; exact</p>
</dd>
</dl>



<h3>Note</h3>

 
<p>The non-central Beta distribution is defined (Johnson et al, 1995,
pp. 502) as the distribution of <code class="reqn">X/(X+Y)</code> where
<code class="reqn">X \sim \chi^2_{2a}(\lambda)</code> and
<code class="reqn">Y \sim \chi^2_{2b}</code>.
C.f. <code><a href="stats.html#topic+Beta">rbeta</a></code> </p>


<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br />
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BetaParameter-class">BetaParameter-class</a></code>
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>
<code><a href="#topic+Reals-class">Reals-class</a></code>
<code><a href="stats.html#topic+Beta">rbeta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B &lt;- Beta(shape1 = 1, shape2 = 1)
# B is a beta distribution with shape1 = 1 and shape2 = 1.
r(B)(1) # one random number generated from this distribution, e.g. 0.6979795
d(B)(1) # Density of this distribution is 1 for x=1.
p(B)(1) # Probability that x &lt; 1 is 1.
q(B)(.1) # Probability that x &lt; 0.1 is 0.1.
shape1(B) # shape1 of this distribution is 1.
shape1(B) &lt;- 2 # shape1 of this distribution is now 2.
Bn &lt;- Beta(shape1 = 1, shape2 = 3, ncp = 5) 
# Bn is a beta distribution with shape1 = 1 and shape2 = 3 and ncp = 5.
B0 &lt;- Bn; ncp(B0) &lt;- 0; 
# B0 is just the same beta distribution as Bn but with ncp = 0
q(B0)(0.1) ## 
q(Bn)(0.1) ## =&gt; from R 2.3.0 on ncp no longer ignored...
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
</code></pre>

<hr>
<h2 id='BetaParameter-class'>Class &quot;BetaParameter&quot;</h2><span id='topic+BetaParameter-class'></span><span id='topic+initialize+2CBetaParameter-method'></span>

<h3>Description</h3>

<p>The parameter of a beta distribution, used by <code>Beta-class</code>
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("BetaParameter", shape1, shape2, ncp)</code>.
Usually an object of this class is not needed on its own, it is
generated   automatically when an object of the class Beta
is instantiated. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>shape1</code></dt><dd><p>Object of class <code>"numeric"</code>: the shape1 of a beta distribution </p>
</dd>
<dt><code>shape2</code></dt><dd><p>Object of class <code>"numeric"</code>: the shape2 of a beta distribution </p>
</dd>
<dt><code>ncp</code></dt><dd><p>Object of class <code>"numeric"</code>: the noncentrality parameter of a beta distribution </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: a name / comment for the parameters </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "BetaParameter")</code>:
initialize method</p>
</dd>
<dt>shape1</dt><dd><p><code>signature(object = "BetaParameter")</code>:
returns the slot shape1 of the parameter of the distribution</p>
</dd>
<dt>shape1&lt;-</dt><dd><p><code>signature(object = "BetaParameter")</code>:
modifies the slot shape1 of the parameter of the distribution</p>
</dd>
<dt>shape2</dt><dd><p><code>signature(object = "BetaParameter")</code>:
returns the slot shape2 of the parameter of the distribution</p>
</dd>
<dt>shape2&lt;-</dt><dd><p><code>signature(object = "BetaParameter")</code>:
modifies the slot shape2 of the parameter of the distribution</p>
</dd>
<dt>ncp</dt><dd><p><code>signature(object = "BetaParameter")</code>: returns the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
<dt>ncp&lt;-</dt><dd><p><code>signature(object = "BetaParameter")</code>: modifies the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br />
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Beta-class">Beta-class</a></code>
<code><a href="#topic+Parameter-class">Parameter-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- new("BetaParameter", shape1 = 1, shape2 = 1, ncp = 0)
shape2(W) # shape2 of this distribution is 1.
shape2(W) &lt;- 2 # shape2 of this distribution is now 2.
</code></pre>

<hr>
<h2 id='Binom-class'>Class &quot;Binom&quot; </h2><span id='topic+Binom-class'></span><span id='topic+Binom'></span><span id='topic+initialize+2CBinom-method'></span>

<h3>Description</h3>

<p>The binomial distribution with <code>size</code> <code class="reqn">= n</code>, by default 
<code class="reqn">=1</code>, and
<code>prob</code> <code class="reqn">= p</code>, by default <code class="reqn">=0.5</code>, has density
</p>
<p style="text-align: center;"><code class="reqn">p(x) = {n \choose x} {p}^{x} {(1-p)}^{n-x}</code>
</p>

<p>for <code class="reqn">x = 0, \ldots, n</code>.
</p>
<p>C.f.<code><a href="stats.html#topic+Binomial">rbinom</a></code>
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Binom(prob, size)</code>.
This object is a binomial distribution. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Naturals"</code>: The space of the 
image of this distribution has got dimension 1 and the 
name &quot;Natural Space&quot;. </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"BinomParameter"</code>: the parameter 
of this distribution (<code>prob</code>, <code>size</code>), declared at its 
instantiation </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: generates random 
numbers (calls function <code>rbinom</code>) </p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>: density function (calls 
function <code>dbinom</code>) </p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>: cumulative function 
(calls function <code>pbinom</code>) </p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>: inverse of the 
cumulative function (calls function <code>qbinom</code>).
The quantile is defined as the smallest value x such that F(x) &gt;= p, where 
F is the cumulative function. </p>
</dd>
<dt><code>support</code></dt><dd><p>Object of class <code>"numeric"</code>: a (sorted) 
vector containing the support of the discrete density function</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"DiscreteDistribution"</code>, directly.<br />
Class <code>"UnivariateDistribution"</code>, by class <code>"DiscreteDistribution"</code>.<br />
Class <code>"Distribution"</code>, by class <code>"DiscreteDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>+</dt><dd><p><code>signature(e1 = "Binom", e2 = "Binom")</code>: For two binomial 
distributions with equal probabilities the exact convolution 
formula is implemented thereby improving the general numerical 
accuracy.</p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "Binom")</code>: initialize method </p>
</dd>
<dt>prob</dt><dd><p><code>signature(object = "Binom")</code>: returns the slot <code>prob</code> 
of the parameter of the distribution </p>
</dd>
<dt>prob&lt;-</dt><dd><p><code>signature(object = "Binom")</code>: modifies the slot 
<code>prob</code> of the parameter of the distribution </p>
</dd>
<dt>size</dt><dd><p><code>signature(object = "Binom")</code>: returns the slot <code>size</code> 
of the parameter of the distribution </p>
</dd>
<dt>size&lt;-</dt><dd><p><code>signature(object = "Binom")</code>: modifies the slot 
<code>size</code> of the parameter of the distribution </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BinomParameter-class">BinomParameter-class</a></code>
<code><a href="#topic+DiscreteDistribution-class">DiscreteDistribution-class</a></code>
<code><a href="#topic+Naturals-class">Naturals-class</a></code>
<code><a href="stats.html#topic+Binomial">rbinom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B &lt;- Binom(prob=0.5,size=1) # B is a binomial distribution with prob=0.5 and size=1.
r(B)(1) # # one random number generated from this distribution, e.g. 1
d(B)(1) # Density of this distribution is  0.5 for x=1.
p(B)(0.4) # Probability that x&lt;0.4 is 0.5.
q(B)(.1) # x=0 is the smallest value x such that p(B)(x)&gt;=0.1.
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
size(B) # size of this distribution is 1.
size(B) &lt;- 2 # size of this distribution is now 2.
C &lt;- Binom(prob = 0.5, size = 1) # C is a binomial distribution with prob=0.5 and size=1.
D &lt;- Binom(prob = 0.6, size = 1) # D is a binomial distribution with prob=0.6 and size=1.
E &lt;- B + C # E is a binomial distribution with prob=0.5 and size=3.
F &lt;- B + D # F is an object of class LatticeDistribution.
G &lt;- B + as(D,"DiscreteDistribution") ## DiscreteDistribution
</code></pre>

<hr>
<h2 id='BinomParameter-class'>Class &quot;BinomParameter&quot;</h2><span id='topic+BinomParameter-class'></span><span id='topic+initialize+2CBinomParameter-method'></span>

<h3>Description</h3>

<p> The parameter of a binomial distribution, used by Binom-class</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form 
<code>new("BinomParameter", prob, size)</code>.
Usually an object of this class is not needed on its own, it is generated 
automatically when an object of the class Binom
is instantiated. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>prob</code></dt><dd><p>Object of class <code>"numeric"</code>: 
the probability of a binomial distribution </p>
</dd>
<dt><code>size</code></dt><dd><p>Object of class <code>"numeric"</code>: 
the size of a binomial distribution </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: 
a name / comment for the parameters </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "BinomParameter")</code>: 
initialize method </p>
</dd>
<dt>prob</dt><dd><p><code>signature(object = "BinomParameter")</code>: returns the slot 
<code>prob</code> of the parameter of the distribution </p>
</dd>
<dt>prob&lt;-</dt><dd><p><code>signature(object = "BinomParameter")</code>: modifies the slot 
<code>prob</code> of the parameter of the distribution </p>
</dd>
<dt>size</dt><dd><p><code>signature(object = "BinomParameter")</code>: returns the slot 
<code>size</code> of the parameter of the distribution </p>
</dd>
<dt>size&lt;-</dt><dd><p><code>signature(object = "BinomParameter")</code>: modifies the slot 
<code>size</code> of the parameter of the distribution</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Binom-class">Binom-class</a></code>
<code><a href="#topic+Parameter-class">Parameter-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- new("BinomParameter",prob=0.5,size=1)
size(W) # size of this distribution is 1.
size(W) &lt;- 2 # size of this distribution is now 2.
</code></pre>

<hr>
<h2 id='Cauchy-class'>Class &quot;Cauchy&quot;</h2><span id='topic+Cauchy-class'></span><span id='topic+Cauchy'></span><span id='topic+initialize+2CCauchy-method'></span>

<h3>Description</h3>

<p>  The Cauchy distribution with location <code class="reqn">l</code>, by default <code class="reqn">=0</code>, and scale <code class="reqn">s</code> , by default <code class="reqn">=1</code>,has
density
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{1}{\pi s}
    \left( 1 + \left(\frac{x - l}{s}\right)^2 \right)^{-1}%
  </code>
</p>

<p>for all <code class="reqn">x</code>.
C.f. <code><a href="stats.html#topic+Cauchy">rcauchy</a></code>
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Cauchy(location, scale)</code>.
This object is a Cauchy distribution.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>: The domain of this distribution has got dimension 1
and the name &quot;Real Space&quot;. </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"CauchyParameter"</code>: the parameter of this distribution (location and scale),
declared at its instantiation </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: generates random numbers (calls function <code>rcauchy</code>)</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>: density function (calls function <code>dcauchy</code>)</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>: cumulative function (calls function <code>pcauchy</code>)</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>: inverse of the cumulative function (calls function <code>qcauchy</code>)</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"AbscontDistribution"</code>, directly.<br />
Class <code>"UnivariateDistribution"</code>, by class <code>"AbscontDistribution"</code>.<br />
Class <code>"Distribution"</code>, by class <code>"AbscontDistribution"</code>.
</p>


<h3>Is-Relations</h3>

<p>By means of <code>setIs</code>, R &ldquo;knows&rdquo; that a distribution object <code>obj</code> of class <code>"Cauchy"</code> with location 0 and scale 1 also is
a T distribution with parameters <code>df = 1, ncp = 0</code>. 
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "Cauchy")</code>: initialize method </p>
</dd>
<dt>location</dt><dd><p><code>signature(object = "Cauchy")</code>: returns the slot <code>location</code> of the parameter of the distribution </p>
</dd>
<dt>location&lt;-</dt><dd><p><code>signature(object = "Cauchy")</code>: modifies the slot <code>location</code> of the parameter of the distribution </p>
</dd>
<dt>scale</dt><dd><p><code>signature(object = "Cauchy")</code>: returns the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>scale&lt;-</dt><dd><p><code>signature(object = "Cauchy")</code>: modifies the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "Cauchy", e2 = "Cauchy")</code>: For the Cauchy distribution the exact convolution formula is
implemented thereby improving the general numerical approximation.</p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "Cauchy", e2 = "numeric")</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "Cauchy", e2 = "numeric")</code>: 
For the Cauchy location scale family we use its closedness under affine linear transformations.</p>
</dd>
</dl>

<p>further arithmetic methods see <a href="#topic+operators-methods">operators-methods</a>
</p>


<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+CauchyParameter-class">CauchyParameter-class</a></code>
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>
<code><a href="#topic+Reals-class">Reals-class</a></code>
<code><a href="stats.html#topic+Cauchy">rcauchy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C &lt;- Cauchy(location = 1, scale = 1) # C is a Cauchy distribution with location=1 and scale=1.
r(C)(1) # one random number generated from this distribution, e.g. 4.104603
d(C)(1) # Density of this distribution is 0.3183099 for x=1.
p(C)(1) # Probability that x&lt;1 is 0.5.
q(C)(.1) # Probability that x&lt;-2.077684 is 0.1.
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
location(C) # location of this distribution is 1.
location(C) &lt;- 2 # location of this distribution is now 2.
is(C,"Td") # no
C0 &lt;- Cauchy() # standard, i.e. location = 0, scale = 1
is(C0,"Td") # yes
as(C0,"Td") 
</code></pre>

<hr>
<h2 id='CauchyParameter-class'>Class &quot;CauchyParameter&quot;</h2><span id='topic+CauchyParameter-class'></span><span id='topic+initialize+2CCauchyParameter-method'></span>

<h3>Description</h3>

<p> The parameter of a Cauchy distribution, used by Cauchy-class</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("CauchyParameter", location, scale)</code>.
Usually an object of this class is not needed on its own, it is generated automatically when an object of the class Cauchy is instantiated. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>location</code>:</dt><dd><p>Object of class <code>"numeric"</code>: the location of a Cauchy distribution </p>
</dd>
<dt><code>scale</code></dt><dd><p>Object of class <code>"numeric"</code>: the scale of a Cauchy distribution </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: a name / comment for the parameters </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "CauchyParameter")</code>: initialize method </p>
</dd>
<dt>scale</dt><dd><p><code>signature(object = "CauchyParameter")</code>: returns the slot <code>scale</code> of the parameter of the distribution</p>
</dd>
<dt>scale&lt;-</dt><dd><p><code>signature(object = "CauchyParameter")</code>: modifies the slot <code>scale</code> of the parameter of the
distribution </p>
</dd>
<dt>location</dt><dd><p><code>signature(object = "CauchyParameter")</code>: returns the slot <code>location</code> of the parameter of the
distribution </p>
</dd>
<dt>location&lt;-</dt><dd><p><code>signature(object = "CauchyParameter")</code>: modifies the slot <code>location</code> of the parameter of the
distribution </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Cauchy-class">Cauchy-class</a></code>
<code><a href="#topic+Parameter-class">Parameter-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- new("CauchyParameter",location=1,scale=1)
location(W) # location of this distribution is 1.
location(W) &lt;- 2 # location of this distribution is now 2.
</code></pre>

<hr>
<h2 id='Chisq-class'>Class &quot;Chisq&quot;</h2><span id='topic+Chisq-class'></span><span id='topic+Chisq'></span><span id='topic+initialize+2CChisq-method'></span>

<h3>Description</h3>

<p>The chi-squared distribution with <code>df</code><code class="reqn">= n</code> degrees of
freedom has density
</p>
<p style="text-align: center;"><code class="reqn">f_n(x) = \frac{1}{{2}^{n/2} \Gamma (n/2)} {x}^{n/2-1} {e}^{-x/2}</code>
</p>

<p>for <code class="reqn">x &gt; 0</code>.  The mean and variance are <code class="reqn">n</code> and <code class="reqn">2n</code>.
</p>
<p>The non-central chi-squared distribution with <code>df</code><code class="reqn">= n</code>
degrees of freedom and non-centrality parameter <code>ncp</code>
<code class="reqn">= \lambda</code> has density
</p>
<p style="text-align: center;"><code class="reqn">
    f(x) = e^{-\lambda / 2}
      \sum_{r=0}^\infty \frac{(\lambda/2)^r}{r!}\, f_{n + 2r}(x)</code>
</p>

<p>for <code class="reqn">x \ge 0</code>.  For integer <code class="reqn">n</code>, this is the distribution of
the sum of squares of <code class="reqn">n</code> normals each with variance one,
<code class="reqn">\lambda</code> being the sum of squares of the normal means.
</p>
<p>C.f. <code><a href="stats.html#topic+Chisquare">rchisq</a></code>
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Chisq(df, ncp)</code>.
This object is a chi-squared distribution.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>:
The space of the image of this distribution has got dimension 1 and the name &quot;Real Space&quot;.</p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"ChisqParameter"</code>:
the parameter of this distribution (df and ncp), declared at its instantiation</p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>:
generates random numbers (calls function rchisq)</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>:
density function (calls function dchisq)</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>:
cumulative function (calls function pchisq)</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>:
inverse of the cumulative function (calls function qchisq)</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"ExpOrGammaOrChisq"</code>, directly.<br />
Class <code>"AbscontDistribution"</code>, by class <code>"ExpOrGammaOrChisq"</code>.<br />
Class <code>"UnivariateDistribution"</code>, by class <code>"AbscontDistribution"</code>.<br />
Class <code>"Distribution"</code>, by class <code>"UnivariateDistribution"</code>.
</p>


<h3>Is-Relations</h3>

<p>By means of <code>setIs</code>, R &ldquo;knows&rdquo; that a distribution object <code>obj</code> of class <code>"Chisq"</code> with non-centrality 0 also is
a Gamma distribution with parameters <code>shape = df(obj)/2, scale = 2</code>. 
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "Chisq")</code>: initialize method </p>
</dd>
<dt>df</dt><dd><p><code>signature(object = "Chisq")</code>:
returns the slot df of the parameter of the distribution </p>
</dd>
<dt>df&lt;-</dt><dd><p><code>signature(object = "Chisq")</code>:
modifies the slot df of the parameter of the distribution </p>
</dd>
<dt>ncp</dt><dd><p><code>signature(object = "Chisq")</code>:
returns the slot ncp of the parameter of the distribution </p>
</dd>
<dt>ncp&lt;-</dt><dd><p><code>signature(object = "Chisq")</code>:
modifies the slot ncp of the parameter of the distribution </p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "Chisq", e2 = "Chisq")</code>: 
For the chi-squared distribution we use its closedness under convolutions.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Warning: The code for pchisq and qchisq is unreliable for values of ncp above approximately 290. 
</p>


<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br />
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ChisqParameter-class">ChisqParameter-class</a></code>
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>
<code><a href="#topic+Reals-class">Reals-class</a></code>
<code><a href="stats.html#topic+Chisquare">rchisq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C &lt;- Chisq(df = 1, ncp = 1) # C is a chi-squared distribution with df=1 and ncp=1.
r(C)(1) # one random number generated from this distribution, e.g. 0.2557184
d(C)(1) # Density of this distribution is 0.2264666 for x = 1.
p(C)(1) # Probability that x &lt; 1 is 0.4772499.
q(C)(.1) # Probability that x &lt; 0.04270125 is 0.1.
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
df(C) # df of this distribution is 1.
df(C) &lt;- 2 # df of this distribution is now 2.
is(C, "Gammad") # no
C0 &lt;- Chisq() # default: Chisq(df=1,ncp=0)
is(C0, "Gammad") # yes
as(C0,"Gammad")
</code></pre>

<hr>
<h2 id='ChisqParameter-class'>Class &quot;ChisqParameter&quot;</h2><span id='topic+ChisqParameter-class'></span><span id='topic+initialize+2CChisqParameter-method'></span>

<h3>Description</h3>

<p> The parameter of a chi-squared distribution, used by Chisq-class</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("ChisqParameter", ncp, df)</code>.
Usually an object of this class is not needed on its own, it is generated automatically when an object of the class Chisq
is instantiated. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>ncp</code></dt><dd><p>Object of class <code>"numeric"</code>: the ncp of a chi-squared distribution </p>
</dd>
<dt><code>df</code></dt><dd><p>Object of class <code>"numeric"</code>: the df of a chi-squared distribution </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: a name / comment for the parameters </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "ChisqParameter")</code>: initialize method </p>
</dd>
<dt>df</dt><dd><p><code>signature(object = "ChisqParameter")</code>: returns the slot <code>df</code> of the parameter of the distribution </p>
</dd>
<dt>df&lt;-</dt><dd><p><code>signature(object = "ChisqParameter")</code>: modifies the slot <code>df</code> of the parameter of the distribution </p>
</dd>
<dt>ncp</dt><dd><p><code>signature(object = "ChisqParameter")</code>: returns the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
<dt>ncp&lt;-</dt><dd><p><code>signature(object = "ChisqParameter")</code>: modifies the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Chisq-class">Chisq-class</a></code>
<code><a href="#topic+Parameter-class">Parameter-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- new("ChisqParameter",df=1,ncp=1)
ncp(W) # ncp of this distribution is 1.
ncp(W) &lt;- 2 # ncp of this distribution is now 2.
</code></pre>

<hr>
<h2 id='CompoundDistribution'>Generating function for Class &quot;CompoundDistribution&quot;</h2><span id='topic+CompoundDistribution'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"CompoundDistribution"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompoundDistribution(NumbOfSummandsDistr, SummandsDistr, .withSim = FALSE,
                                 withSimplify = FALSE)
                                </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompoundDistribution_+3A_numbofsummandsdistr">NumbOfSummandsDistr</code></td>
<td>
<p>Object of class <code>"DiscreteDistribution"</code>,
the frequency distribution; it is checked that support is contained in
0,1,2,...</p>
</td></tr>
<tr><td><code id="CompoundDistribution_+3A_summandsdistr">SummandsDistr</code></td>
<td>
<p>Object of class <code>"UnivDistrListOrDistribution"</code>,
that is, either of class <code>"UnivarDistrList"</code> (non i.i.d. case) or
of class <code>"UnivariateDistribution"</code> (i.i.d. case); 
the summand distribution(s).</p>
</td></tr>
<tr><td><code id="CompoundDistribution_+3A_.withsim">.withSim</code></td>
<td>
<p>logical; value of the corresponding slot.</p>
</td></tr> 
<tr><td><code id="CompoundDistribution_+3A_withsimplify">withSimplify</code></td>
<td>
<p><code>"logical"</code>: shall the return value be piped through a 
call to <code>simplifyD</code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"CompoundDistribution"</code>, or if 
argument <code>withSimplify</code> is <code>TRUE</code> the result of
<code><a href="#topic+simplifyD">simplifyD</a></code> applied to the compound distribution,
i.e. an object of class <code>"UnivarLebDecDistribution"</code>, or if degenerate,
of class <code>"AbscontDistribution"</code> or <code>"DiscreteDistribution"</code>.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+CompoundDistribution-class">CompoundDistribution-class</a></code>,
<code><a href="#topic+simplifyD">simplifyD</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>CP0 &lt;- CompoundDistribution(Pois(), Norm())
CP0
CP1 &lt;- CompoundDistribution(DiscreteDistribution(supp = c(1,5,9,11),
                            prob = dbinom(0:3, size = 3,prob = 0.3)),Norm())
CP1
UL &lt;- UnivarDistrList(Norm(), Binom(10,0.3), Chisq(df=4), Norm(),
                      Binom(10,0.3), Chisq(df=4), Norm(), Binom(10,0.3),
                      Chisq(df=4), Td(5), Td(10))
CP2 &lt;- CompoundDistribution(DiscreteDistribution(supp = c(1,5,9,11),
                      prob = dbinom(0:3, size = 3, prob = 0.3)),UL)
plot(CP2)
</code></pre>

<hr>
<h2 id='CompoundDistribution-class'>Class &quot;CompoundDistribution&quot;</h2><span id='topic+CompoundDistribution-class'></span><span id='topic+NumbOfSummandsDistr'></span><span id='topic+SummandsDistr'></span><span id='topic+NumbOfSummandsDistr-methods'></span><span id='topic+SummandsDistr-methods'></span><span id='topic+NumbOfSummandsDistr+2CCompoundDistribution-method'></span><span id='topic+SummandsDistr+2CCompoundDistribution-method'></span><span id='topic+coerce+2CCompoundDistribution+2CUnivarLebDecDistribution-method'></span><span id='topic+UnivDistrListOrDistribution-class'></span>

<h3>Description</h3>

<p><code>CompoundDistribution</code>-class is a class to formalize 
compound distributions; it is a subclass to
class <code>UnivarMixingDistribution</code>.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form 
<code>new("CompoundDistribution", ...)</code>.
More frequently they are created via the generating function 
<code><a href="#topic+CompoundDistribution">CompoundDistribution</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>NumbOfSummandsDistr</code></dt><dd><p>Object of class <code>"DiscreteDistribution"</code>,
the frequency distribution.</p>
</dd>
<dt><code>SummandsDistr</code></dt><dd><p>Object of class <code>"UnivDistrListOrDistribution"</code>,
that is, either of class <code>"UnivarDistrList"</code> (non i.i.d. case) or
of class <code>"UnivariateDistribution"</code> (i.i.d. case); the summand distribution(s).</p>
</dd>
<dt><code>mixCoeff</code></dt><dd><p>Object of class <code>"numeric"</code>: a vector of 
probabilities for the mixing components.</p>
</dd>
<dt><code>mixDistr</code></dt><dd><p>Object of class <code>"UnivarDistrList"</code>: a list of
univariate distributions containing the mixing components; must be of same
length as <code>mixCoeff</code>.</p>
</dd>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>: the space of the image of this distribution which has dimension 1
and the name &quot;Real Space&quot; </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"Parameter"</code>: the parameter of this distribution, having only the
slot name &quot;Parameter of a discrete distribution&quot; </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: generates random numbers</p>
</dd>
<dt><code>d</code></dt><dd><p>fixed to <code>NULL</code></p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>: cumulative distribution function</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>: quantile function</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"UnivarMixingDistribution"</code>
class <code>"UnivarDistribution"</code> by class <code>"UnivarMixingDistribution"</code>,
class <code>"Distribution"</code> by class <code>"UnivariateDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "CompoundDistribution")</code> prints the object</p>
</dd>
<dt>SummandsDistr</dt><dd><p><code>signature(object = "CompoundDistribution")</code> returns the corresponding slot</p>
</dd>
<dt>NumbOfSummandsDistr</dt><dd><p><code>signature(object = "CompoundDistribution")</code> returns the corresponding slot</p>
</dd>
</dl>



<h3>setAs relations</h3>

<p>There is a coerce method to coerce objects of class <code>"CompoundDistribution"</code> to
class <code>UnivarLebDecDistribution</code>; this is done by a simple call to <code>simplifyD</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Parameter-class">Parameter-class</a></code>, 
<code><a href="#topic+UnivariateDistribution-class">UnivariateDistribution-class</a></code>, 
<code><a href="#topic+LatticeDistribution-class">LatticeDistribution-class</a></code>, 
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>, 
<code><a href="#topic+simplifyD">simplifyD</a></code>, 
<code><a href="#topic+flat.mix">flat.mix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CP &lt;- CompoundDistribution(Pois(),Norm())
CP
p(CP)(0.3)          
plot(CP)
</code></pre>

<hr>
<h2 id='convpow-methods'>Distribution of the sum of univariate i.i.d r.v's</h2><span id='topic+convpow'></span><span id='topic+convpow-methods'></span><span id='topic+convpow+2CAcDcLcDistribution-method'></span><span id='topic+convpow+2CAbscontDistribution-method'></span><span id='topic+convpow+2CLatticeDistribution-method'></span><span id='topic+convpow+2CDiscreteDistribution-method'></span><span id='topic+convpow+2CAcDcLcDistribution-method'></span><span id='topic+convpow+2CNorm-method'></span><span id='topic+convpow+2CBinom-method'></span><span id='topic+convpow+2CNbinom-method'></span><span id='topic+convpow+2CExpOrGammaOrChisq-method'></span><span id='topic+convpow+2CCauchy-method'></span><span id='topic+convpow+2CPois-method'></span><span id='topic+convpow+2CDirac-method'></span>

<h3>Description</h3>

<p>Method <code>convpow</code> determines the distribution of the sum of N univariate
i.i.d r.v's by means of DFT</p>


<h3>Usage</h3>

<pre><code class='language-R'>  convpow(D1,...)
  ## S4 method for signature 'AbscontDistribution'
convpow(D1,N)
  ## S4 method for signature 'LatticeDistribution'
convpow(D1,N, 
                     ep = getdistrOption("TruncQuantile"))
  ## S4 method for signature 'DiscreteDistribution'
convpow(D1,N)
  ## S4 method for signature 'AcDcLcDistribution'
convpow(D1,N, 
                     ep = getdistrOption("TruncQuantile"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convpow-methods_+3A_d1">D1</code></td>
<td>
<p>an object of (a sub)class (of) <code>"AbscontDistribution"</code> or  
<code>"LatticeDistribution"</code> or of <code>"UnivarLebDecDistribution"</code></p>
</td></tr>
<tr><td><code id="convpow-methods_+3A_...">...</code></td>
<td>
<p>not yet used; meanwhile takes up N </p>
</td></tr>
<tr><td><code id="convpow-methods_+3A_n">N</code></td>
<td>
<p> an integer or 0 (for 0 returns Dirac(0), for 1 D1)</p>
</td></tr>
<tr><td><code id="convpow-methods_+3A_ep">ep</code></td>
<td>
<p> numeric of length 1 in (0,1) &mdash;
for <code>"LatticeDistribution"</code>: support points will be 
cancelled if their probability is less than <code>ep</code>;
for <code>"UnivarLebDecDistribution"</code>: if <code>(acWeight(object)&lt;ep)</code> 
we work with the discrete parts only, and, similarly, if
<code>(discreteWeight(object)&lt;ep)</code> we with the absolutely continuous 
parts only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>in the methods implemented a second argument <code>N</code> is obligatory;
the general methods use a general purpose convolution algorithm for 
distributions by means of D/FFT. In case of an argument of class 
<code>"UnivarLebDecDistribution"</code>, the result will in generally be
again of class <code>"UnivarLebDecDistribution"</code>. However, if <code>acWeight(D1)</code>
is positive, <code>discreteWeight(convpow(D1,N))</code> will decay exponentially
in <code>N</code>, hence from some (small) <code class="reqn">N_0</code> on, the result will be of
class <code>"AbscontDistribution"</code>. This is used algorithmically, too, as 
then only the a.c. part needs to be convolved.
In case of an argument <code>D1</code> of class <code>"DiscreteDistribution"</code>,
for <code>N</code> equal to 0,1 we return the obvious solutions, and for <code>N==2</code> 
the return value is <code>D1+D1</code>. For <code>N&gt;2</code>, we split up <code>N</code> into
<code>N=N1+N2</code>, <code>N1=floor(N/2)</code> and recursively return
<code>convpow(D1,N1)+convpow(D1,N2)</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"AbscontDistribution"</code>, <code>"DiscreteDistribution"</code>,
<code>"LatticeDistribution"</code> resp. <code>"AcDcLcDistribution"</code></p>


<h3>further S4-Methods</h3>

<p>There are particular methods for the following classes, using explicit 
convolution formulae:
</p>

<dl>
<dt><code>signature(D1="Norm")</code></dt><dd><p>returns class <code>"Norm"</code></p>
</dd>
<dt><code>signature(D1="Nbinom")</code></dt><dd><p>returns class <code>"Nbinom"</code></p>
</dd>
<dt><code>signature(D1="Binom")</code></dt><dd><p>returns class <code>"Binom"</code></p>
</dd>
<dt><code>signature(D1="Cauchy")</code></dt><dd><p>returns class <code>"Cauchy"</code></p>
</dd>
<dt><code>signature(D1="ExpOrGammaOrChisq")</code></dt><dd><p>returns class 
<code>"Gammad"</code> &mdash;if <code>D1</code> may be coerced to <code>Gammad</code></p>
</dd>
<dt><code>signature(D1="Pois")</code></dt><dd><p>returns class <code>"Pois"</code></p>
</dd>
<dt><code>signature(D1="Dirac")</code></dt><dd><p>returns class <code>"Dirac"</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a><br />
Matthias Kohl <a href="mailto:matthias.kohl@stamats.de">matthias.kohl@stamats.de</a>
Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>
</p>


<h3>References</h3>

<p>Kohl, M., Ruckdeschel, P., (2014):
General purpose convolution algorithm for distributions 
in S4-Classes by means of FFT. <em>J. Statist. Softw.</em>
<b>59</b>(4): 1-25.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+operators">operators</a></code>, <code>distrARITH()</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>convpow(Exp()+Pois(),4)
</code></pre>

<hr>
<h2 id='d-methods'> Methods for Function d in Package &lsquo;distr&rsquo; </h2><span id='topic+d-methods'></span><span id='topic+d'></span><span id='topic+d+2CDistribution-method'></span>

<h3>Description</h3>

<p>d-methods</p>


<h3>Methods</h3>


<dl>
<dt>d</dt><dd><p><code>signature(object = "Distribution")</code>: returns the density function </p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+Distribution-class">Distribution-class</a></code>
</p>

<hr>
<h2 id='decomposePM-methods'> Methods for function decomposePM in Package &lsquo;distr&rsquo; </h2><span id='topic+decomposePM-methods'></span><span id='topic+decomposePM'></span><span id='topic+decomposePM+2CAbscontDistribution-method'></span><span id='topic+decomposePM+2CDiscreteDistribution-method'></span><span id='topic+decomposePM+2CUnivarLebDecDistribution-method'></span>

<h3>Description</h3>

<p>decomposePM-methods</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomposePM(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decomposePM-methods_+3A_object">object</code></td>
<td>
<p>Abscont-/Discrete-/UnivarLebDec-Distribution object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are particular return types for the following classes
</p>

<dl>
<dt>&quot;AbscontDistribution&quot;</dt><dd><p>a list with components <code>"neg"</code> and 
<code>"pos"</code> for the respective negative and positive part; each of these
parts in its turn is a list with components <code>D</code> for the distribution
(in this case of class <code>"AbscontDistribution"</code> again) and <code>w</code> 
for the weight of the respective part; if the weight of
the negative part is 0, the corresponding distribution is set to 
<code>-abs(Norm())</code>, and respectively, if the weight of the positive part 
is 0, the corresponding distribution is set to 
<code>abs(Norm())</code>.</p>
</dd>
<dt>&quot;DiscreteDistribution&quot;</dt><dd><p>a list with components <code>"neg"</code>, 
<code>"pos"</code> and <code>"0"</code> for the respective negative, positive and zero 
part; each of these parts in its turn is a list with components <code>D</code> for 
the distribution (in this case of class <code>"DiscreteDistribution"</code> again)
and <code>w</code> for the weight of the respective part; while the distribution of
the zero part is always <code>Dirac(0)</code>, if the weight of
the negative part is 0, the corresponding distribution is set to 
<code>Dirac(-1)</code>, and respectively, if the weight of the positive part 
is 0, the corresponding distribution is set to 
<code>Dirac(1)</code>.</p>
</dd>
<dt>&quot;UnivarLebDecDistribution&quot;</dt><dd><p>a list with components <code>"neg"</code>, 
<code>"pos"</code> and <code>"0"</code> for the respective negative, positive and zero 
part; each of these parts in its turn is a list with components <code>D</code> for 
the distribution (in case of components <code>"neg"</code>, 
<code>"pos"</code> of class <code>"UnivarLebDecDistribution"</code> again, while 
the distribution of the zero part is always <code>Dirac(0)</code>)
and <code>w</code> for the weight of the respective part; it is build up by calling
<code>decomposePM</code> for <code>acPart(object)</code> and <code>discretePart(object)</code>
separately, hence if weights of some parts are zero the corresponding
procedure mentionned for these methods applies.</p>
</dd>
</dl>

<p>Method <code>decomposePM</code> is used by our multiplication, division and exponentiation
(<code>"*"</code>, <code>"/"</code> <code>"^"</code>) - methods.
</p>


<h3>Value</h3>

<p>the positive and negative part of the distribution together with
corresponding weights as a list.</p>


<h3>See Also</h3>

<p><code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>, 
<code><a href="#topic+DiscreteDistribution-class">DiscreteDistribution-class</a></code>,
<code><a href="#topic+UnivarLebDecDistribution-class">UnivarLebDecDistribution-class</a></code>,
<code><a href="#topic+operators-methods">operators-methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>decomposePM(Norm())
decomposePM(Binom(2,0.3)-Binom(5,.4))
decomposePM(UnivarLebDecDistribution(Norm(),Binom(2,0.3)-Binom(5,.4), 
            acWeight = 0.3))
</code></pre>

<hr>
<h2 id='DExp-class'>Class &quot;DExp&quot;</h2><span id='topic+DExp-class'></span><span id='topic+DExp'></span><span id='topic+Laplace'></span><span id='topic+DoubleExponential'></span><span id='topic+initialize+2CDExp-method'></span>

<h3>Description</h3>

<p>The double exponential or Laplace distribution with rate <code class="reqn">\lambda</code> has density
</p>
<p style="text-align: center;"><code class="reqn">
    f(x) = \frac{1}{2}\lambda {e}^{- \lambda |x|}</code>
</p>

<p>C.f. <code><a href="#topic+Exp-class">Exp-class</a></code>, <code><a href="stats.html#topic+Exponential">rexp</a></code>
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>DExp(rate)</code>.
This object is a double exponential (or Laplace) distribution. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>:
The space of the image of this distribution has got dimension 1
and the name &quot;Real Space&quot;.</p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"ExpParameter"</code>:
the parameter of this distribution (rate), declared at its instantiation </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>:
generates random numbers (calls function rexp)</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>:
density function (calls function dexp)</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>:
cumulative function (calls function pexp)</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>:
inverse of the cumulative function (calls function qexp)</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"AbscontDistribution"</code>, directly.<br />
Class <code>"UnivariateDistribution"</code>, by class <code>"AbscontDistribution"</code>.
Class <code>"Distribution"</code>, by class <code>"AbscontDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "DExp")</code>:
initialize method</p>
</dd>
<dt>rate</dt><dd><p><code>signature(object = "DExp")</code>:
returns the slot rate of the parameter of the distribution</p>
</dd>
<dt>rate&lt;-</dt><dd><p><code>signature(object = "DExp")</code>:
modifies the slot rate of the parameter of the distribution</p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "DExp", e2 = "numeric")</code>: 
For the Laplace distribution we use its closedness under scaling transformations.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Exp-class">Exp-class</a></code>
<code><a href="#topic+ExpParameter-class">ExpParameter-class</a></code>
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>
<code><a href="#topic+Reals-class">Reals-class</a></code>
<code><a href="stats.html#topic+Exponential">rexp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D &lt;- DExp(rate = 1) # D is a Laplace distribution with rate = 1.
r(D)(1) # one random number generated from this distribution, e.g. 0.4190765
d(D)(1) # Density of this distribution is 0.1839397 for x = 1.
p(D)(1) # Probability that x &lt; 1 is 0.8160603.
q(D)(.1) # Probability that x &lt; -1.609438 is 0.1.
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
rate(D) # rate of this distribution is 1.
rate(D) &lt;- 2 # rate of this distribution is now 2.
3*D ###  still a DExp -distribution
</code></pre>

<hr>
<h2 id='df-methods'> Methods for Function df in Package &lsquo;distr&rsquo; </h2><span id='topic+df-methods'></span><span id='topic+df+3C--methods'></span><span id='topic+df'></span><span id='topic+df+3C-'></span><span id='topic+df+2CTParameter-method'></span><span id='topic+df+2CTd-method'></span><span id='topic+df+2CChisqParameter-method'></span><span id='topic+df+2CChisq-method'></span><span id='topic+df+3C-+2CTParameter-method'></span><span id='topic+df+3C-+2CTd-method'></span><span id='topic+df+3C-+2CChisqParameter-method'></span><span id='topic+df+3C-+2CChisq-method'></span>

<h3>Description</h3>

<p>df-methods</p>


<h3>Methods</h3>


<dl>
<dt>df</dt><dd><p><code>signature(object = "TParameter")</code>: returns the slot <code>df</code> of the parameter of the distribution </p>
</dd>
<dt>df&lt;-</dt><dd><p><code>signature(object = "TParameter")</code>: modifies the slot <code>df</code> of the parameter of the distribution </p>
</dd>
<dt>df</dt><dd><p><code>signature(object = "Td")</code>: returns the slot <code>df</code> of the parameter of the distribution </p>
</dd>
<dt>df&lt;-</dt><dd><p><code>signature(object = "Td")</code>: modifies the slot <code>df</code> of the parameter of the distribution </p>
</dd>
<dt>df</dt><dd><p><code>signature(object = "ChisqParameter")</code>: returns the slot <code>df</code> of the parameter of the distribution </p>
</dd>
<dt>df&lt;-</dt><dd><p><code>signature(object = "ChisqParameter")</code>: modifies the slot <code>df</code> of the parameter of the distribution </p>
</dd>
<dt>df</dt><dd><p><code>signature(object = "Chisq")</code>: returns the slot <code>df</code> of the parameter of the distribution </p>
</dd>
<dt>df&lt;-</dt><dd><p><code>signature(object = "Chisq")</code>: modifies the slot <code>df</code> of the parameter of the distribution </p>
</dd>
</dl>

<hr>
<h2 id='df1-methods'> Methods for Function df1 in Package &lsquo;distr&rsquo; </h2><span id='topic+df1-methods'></span><span id='topic+df1+3C--methods'></span><span id='topic+df1'></span><span id='topic+df1+3C-'></span><span id='topic+df1+2CFParameter-method'></span><span id='topic+df1+2CFd-method'></span><span id='topic+df1+3C-+2CFParameter-method'></span><span id='topic+df1+3C-+2CFd-method'></span>

<h3>Description</h3>

<p>df-methods</p>


<h3>Methods</h3>


<dl>
<dt>df1</dt><dd><p><code>signature(object = "FParameter")</code>: returns the slot <code>df1</code> of the parameter of an F-distribution </p>
</dd>
<dt>df1&lt;-</dt><dd><p><code>signature(object = "FParameter")</code>: modifies the slot <code>df1</code> of the parameter of an F-distribution </p>
</dd>
<dt>df1</dt><dd><p><code>signature(object  = "Fd")</code>: returns the slot <code>df1</code> of the slot <code>param</code> of the distribution</p>
</dd>
<dt>df1&lt;-</dt><dd><p><code>signature(object = "Fd")</code>: modifies the slot <code>df1</code> of the slot <code>param</code> of the distribution </p>
</dd>
</dl>

<hr>
<h2 id='df2-methods'> Methods for Function df2 in Package &lsquo;distr&rsquo; </h2><span id='topic+df2-methods'></span><span id='topic+df2+3C--methods'></span><span id='topic+df2'></span><span id='topic+df2+3C-'></span><span id='topic+df2+2CFParameter-method'></span><span id='topic+df2+2CFd-method'></span><span id='topic+df2+3C-+2CFParameter-method'></span><span id='topic+df2+3C-+2CFd-method'></span>

<h3>Description</h3>

<p>df-methods</p>


<h3>Methods</h3>


<dl>
<dt>df2</dt><dd><p><code>signature(object = "FParameter")</code>: returns the slot <code>df2</code> of the parameter of an F-distribution </p>
</dd>
<dt>df2&lt;-</dt><dd><p><code>signature(object = "FParameter")</code>: modifies the slot <code>df2</code> of the parameter of an F-distribution </p>
</dd>
<dt>df2</dt><dd><p><code>signature(object  = "Fd")</code>: returns the slot <code>df2</code> of the slot <code>param</code> of the distribution</p>
</dd>
<dt>df2&lt;-</dt><dd><p><code>signature(object = "Fd")</code>: modifies the slot <code>df2</code> of the slot <code>param</code> of the distribution </p>
</dd>
</dl>

<hr>
<h2 id='dim-methods'> Methods for Function dim in Package &lsquo;distr&rsquo; </h2><span id='topic+dim-methods'></span><span id='topic+dim'></span><span id='topic+dim+2CUnivariateDistribution-method'></span>

<h3>Description</h3>

<p>dim-methods</p>


<h3>Methods</h3>


<dl>
<dt>dim</dt><dd><p><code>signature(object = "UnivariateDistribution")</code>: returns the dimension of the distribution </p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+UnivariateDistribution-class">UnivariateDistribution-class</a></code>
</p>

<hr>
<h2 id='dimension-methods'> Methods for Function dimension in Package &lsquo;distr&rsquo; </h2><span id='topic+dimension-methods'></span><span id='topic+dimension+3C--methods'></span><span id='topic+dimension'></span><span id='topic+dimension+3C-'></span><span id='topic+dimension+2CEuclideanSpace-method'></span><span id='topic+dimension+3C-+2CEuclideanSpace-method'></span>

<h3>Description</h3>

<p>dimension-methods</p>


<h3>Methods</h3>


<dl>
<dt>dimension</dt><dd><p><code>signature(object = "EuclideanSpace")</code>: returns the dimension of the space </p>
</dd>
<dt>dimension&lt;-</dt><dd><p><code>signature(object = "EuclideanSpace")</code>: modifies the dimension of the space </p>
</dd>
</dl>

<hr>
<h2 id='Dirac-class'>Class &quot;Dirac&quot;  </h2><span id='topic+Dirac-class'></span><span id='topic+Dirac'></span><span id='topic+initialize+2CDirac-method'></span><span id='topic+log+2CDirac-method'></span><span id='topic+Math+2CDirac-method'></span>

<h3>Description</h3>

<p> The Dirac distribution with location <code class="reqn">l</code>, by default <code class="reqn">=0</code>, has density
<code class="reqn">d(x) = 1</code> for <code class="reqn">x = l</code>, <code class="reqn">0</code> else.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Dirac(location)</code>.
This object is a <code>Dirac</code> distribution. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Naturals"</code>: The space of the image of this
distribution has got dimension 1 and the name &quot;Real Space&quot;. </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"DiracParameter"</code>: the parameter of this distribution (location), declared at its instantiation </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: generates random numbers </p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>: density function </p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>: cumulative function </p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>: inverse of the cumulative function </p>
</dd>
<dt><code>support</code></dt><dd><p>Object of class <code>"numeric"</code>: a (sorted) vector containing the support of the discrete density function</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"DiscreteDistribution"</code>, directly.<br />
Class <code>"UnivariateDistribution"</code>, by class <code>"DiscreteDistribution"</code>.<br />
Class <code>"Distribution"</code>, by class <code>"DiscreteDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>-</dt><dd><p><code>signature(e1 = "Dirac", e2 = "Dirac")</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "Dirac", e2 = "Dirac")</code></p>
</dd> 
<dt>*</dt><dd><p><code>signature(e1 = "Dirac", e2 = "Dirac")</code></p>
</dd>
<dt>/</dt><dd><p><code>signature(e1 = "Dirac", e2 = "Dirac")</code>: 
For the Dirac distribution these operations are trivial.</p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "Dirac")</code>: initialize method </p>
</dd>
<dt>location</dt><dd><p><code>signature(object = "Dirac")</code>: returns the slot <code>location</code> of the parameter of the distribution </p>
</dd>
<dt>location&lt;-</dt><dd><p><code>signature(object = "Dirac")</code>: modifies the slot <code>location</code> of the parameter of the distribution </p>
</dd>
<dt>log</dt><dd><p><code>signature(object = "Dirac")</code>: returns an object of class <code>"Dirac"</code> distribution with log-transformed
<code>location</code> parameter. </p>
</dd>
<dt>Math</dt><dd><p><code>signature(object = "Dirac")</code>: given a <code>"Math"</code> group generic <code>fun</code> an object of class 
<code>"Dirac"</code> distribution with <code>fun</code>-transformed <code>location</code> parameter is returned. </p>
</dd>
</dl>

<p>further arithmetic methods see <a href="#topic+operators-methods">operators-methods</a>
</p>


<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+DiracParameter-class">DiracParameter-class</a></code>
<code><a href="#topic+DiscreteDistribution-class">DiscreteDistribution-class</a></code>
<code><a href="#topic+Naturals-class">Naturals-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D &lt;- Dirac(location = 0) # D is a Dirac distribution with location=0.
r(D)(1)
# r(D)(1) generates a pseudo-random-number according to a Dirac
# distribution with location = 0,
# which of course will take 0 as value almost surely.
d(D)(0) # Density of this distribution is 1 for x = 0.
p(D)(1) # Probability that x &lt; 1 is 1.
q(D)(.1) # q(D)(x) is always 0 (= location).
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
location(D) # location of this distribution is 0.
location(D) &lt;- 2 # location of this distribution is now 2.
</code></pre>

<hr>
<h2 id='DiracParameter-class'>Class &quot;DiracParameter&quot;</h2><span id='topic+DiracParameter-class'></span><span id='topic+initialize+2CDiracParameter-method'></span>

<h3>Description</h3>

<p> The parameter of a Dirac distribution, used by <code>Dirac</code>-class</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("DiracParameter", location)</code>.
Usually an object of this class is not needed on its own, it is generated automatically when an object of the class <code>Dirac</code>
is instantiated. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>location</code></dt><dd><p>Object of class <code>"numeric"</code>: the location of a Dirac distribution </p>
</dd></dl>
<p><br />
</p>
<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: a name / comment for the parameters </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "DiracParameter")</code>: initialize method </p>
</dd>
<dt>location</dt><dd><p><code>signature(object = "DiracParameter")</code>: returns the slot location of the parameter of the
distribution </p>
</dd>
<dt>location&lt;-</dt><dd><p><code>signature(object = "DiracParameter")</code>: modifies the slot location of the parameter of the
distribution </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Dirac-class">Dirac-class</a></code>
<code><a href="#topic+Parameter-class">Parameter-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- new("DiracParameter",location=1)
location(W) # location of this distribution is 1.
location(W) &lt;- 2 # location of this distribution is now 2.
</code></pre>

<hr>
<h2 id='DiscreteDistribution'>Generating function &quot;DiscreteDistribution&quot;</h2><span id='topic+DiscreteDistribution'></span>

<h3>Description</h3>

<p>Generates an object of class  <code>"DiscreteDistribution"</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>  DiscreteDistribution(supp, prob, .withArith=FALSE, .withSim=FALSE, 
                       .lowerExact = TRUE, .logExact = FALSE,
             .DistrCollapse = getdistrOption("DistrCollapse"),
             .DistrCollapse.Unique.Warn = 
                  getdistrOption("DistrCollapse.Unique.Warn"),
             .DistrResolution = getdistrOption("DistrResolution"),
             Symmetry = NoSymmetry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiscreteDistribution_+3A_supp">supp</code></td>
<td>
<p>numeric vector which forms the support
of the discrete distribution. </p>
</td></tr>
<tr><td><code id="DiscreteDistribution_+3A_prob">prob</code></td>
<td>
<p>vector of probability weights for the
elements of <code>supp</code>.</p>
</td></tr>
<tr><td><code id="DiscreteDistribution_+3A_.witharith">.withArith</code></td>
<td>
<p>normally not set by the user, but if determining the entries <code>supp</code>, <code>prob</code>
distributional arithmetics was involved, you may set this to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="DiscreteDistribution_+3A_.withsim">.withSim</code></td>
<td>
<p>normally not set by the user, but if determining the entries <code>supp</code>, <code>prob</code>
simulations were involved, you may set this to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="DiscreteDistribution_+3A_.lowerexact">.lowerExact</code></td>
<td>
<p>normally not set by the user: whether the <code>lower.tail=FALSE</code>
part is calculated exactly, avoing a &ldquo;<code>1-.</code>&rdquo;.</p>
</td></tr>
<tr><td><code id="DiscreteDistribution_+3A_.logexact">.logExact</code></td>
<td>
<p>normally not set by the user: whether in determining slots <code>d,p,q</code>,
we make particular use of a logarithmic representation to enhance accuracy.</p>
</td></tr>
<tr><td><code id="DiscreteDistribution_+3A_.distrcollapse">.DistrCollapse</code></td>
<td>
<p>controls whether in generating a new discrete 
distribution, support points closer together than <code>.DistrResolution</code> are
collapsed.</p>
</td></tr>
<tr><td><code id="DiscreteDistribution_+3A_.distrcollapse.unique.warn">.DistrCollapse.Unique.Warn</code></td>
<td>
<p>controls whether there is a warning
whenever collapsing occurs or when two points are collapsed by a call to
<code>unique()</code> (default behaviour if <code>.DistrCollapse</code> is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="DiscreteDistribution_+3A_.distrresolution">.DistrResolution</code></td>
<td>
<p>minimal spacing between two mass points in a discrete 
distribution</p>
</td></tr>
<tr><td><code id="DiscreteDistribution_+3A_symmetry">Symmetry</code></td>
<td>
<p>you may help <span class="rlang"><b>R</b></span> in calculations if you tell it whether
the distribution is non-symmetric (default) or symmetric with respect
to a center; in this case use <code>Symmetry=SphericalSymmetry(center)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>prob</code> is missing, all elements in <code>supp</code>
are equally weighted.<br />
</p>
<p>Typical usages are
</p>
<pre>
    DiscreteDistribution(supp, prob)
    DiscreteDistribution(supp)
  </pre>


<h3>Value</h3>

<p>Object of class <code>"DiscreteDistribution"</code></p>


<h3>Note</h3>

<p> Working with a computer, we use a finite interval as support which 
carries at least mass <code>1-getdistrOption("TruncQuantile")</code>. <br />
</p>
<p>Also, we require that support points have distance at least       
<code>.DistrResoltion</code>, if this condition fails,
upon a suggestion by Jacob van Etten, <a href="mailto:jacobvanetten@yahoo.com">jacobvanetten@yahoo.com</a>,
we use the global option <code>.DistrCollapse</code> to
decide whether we use collapsing or not. If we do so, we collapse support 
points if they are too close to each other, taking
the (left most) median among them as new support point which accumulates
all the mass of the collapsed points. 
With <code>.DistrCollapse==FALSE</code>, we at least collapse
points according to the result of <code>unique()</code>, and if after this
collapsing, the minimal distance is less than <code>.DistrResoltion</code>,
we throw an error. By <code>.DistrCollapse.Unique.Warn</code>,
we control, whether we throw a warning upon collapsing or not.       
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br />
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DiscreteDistribution-class">DiscreteDistribution-class</a></code>
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>
<code><a href="#topic+RtoDPQ.d">RtoDPQ.d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Dirac-measure at 0
D1 &lt;- DiscreteDistribution(supp = 0)
D1
# simple discrete distribution
D2 &lt;- DiscreteDistribution(supp = c(1:5), prob = c(0.1, 0.2, 0.3, 0.2, 0.2))
D2

plot(D2)
</code></pre>

<hr>
<h2 id='DiscreteDistribution-class'>Class &quot;DiscreteDistribution&quot;</h2><span id='topic+DiscreteDistribution-class'></span><span id='topic+AffLinDiscreteDistribution-class'></span><span id='topic+initialize+2CDiscreteDistribution-method'></span><span id='topic+initialize+2CAffLinDiscreteDistribution-method'></span><span id='topic+sqrt+2CDiscreteDistribution-method'></span><span id='topic+coerce+2CDiscreteDistribution+2CLatticeDistribution-method'></span><span id='topic+coerce+2CAffLinDiscreteDistribution+2CLatticeDistribution-method'></span>

<h3>Description</h3>

<p>The <code>DiscreteDistribution</code>-class is the mother-class of the class <code>LatticeDistribution</code>.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to <code>new("DiscreteDistribution", ...)</code>, but more
easily is the use of the generating function <code>"DiscreteDistribution"</code>.
This generating function, from version 1.9 on, has been moved to this package from package <span class="pkg">distrEx</span>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>: the space of the image of this distribution which has dimension 1
and the name &quot;Real Space&quot; </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"Parameter"</code>: the parameter of this distribution, having only the
slot name &quot;Parameter of a discrete distribution&quot; </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: generates random numbers</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>: density/probability function</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>: cumulative distribution function</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>: quantile function</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>.finSupport</code></dt><dd><p>logical: used internally to check whether the
true support is finite; in case <code>img</code> is one-dimensional, it is
of length 2 (left and right end).</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"UnivariateDistribution"</code>, directly.<br />
Class <code>"Distribution"</code>, by class <code>"UnivariateDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "DiscreteDistribution")</code>: initialize method </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "DiscreteDistribution", 
                   to = "LatticeDistribution")</code>: coerce method to class <code>"LatticeDistribution"</code>
(checks if support is a lattice)</p>
</dd>
<dt>Math</dt><dd><p><code>signature(x = "DiscreteDistribution")</code>: application of a mathematical function, e.g. <code>sin</code> or <code>tan</code> to this discrete distribution
</p>

<ul>
<li> <p><code>abs</code>: <code>signature(x = "DiscreteDistribution")</code>:  exact image distribution of <code>abs(x)</code>.
</p>
</li>
<li> <p><code>exp</code>: <code>signature(x = "DiscreteDistribution")</code>:  exact image distribution of <code>exp(x)</code>.
</p>
</li>
<li> <p><code>sign</code>: <code>signature(x = "DiscreteDistribution")</code>:  exact image distribution of <code>sign(x)</code>.
</p>
</li>
<li> <p><code>sqrt</code>: <code>signature(x = "DiscreteDistribution")</code>:  exact image distribution of <code>sqrt(x)</code>.
</p>
</li>
<li> <p><code>log</code>: <code>signature(x = "DiscreteDistribution")</code>:  (with optional further argument <code>base</code>, defaulting to <code>exp(1)</code>) exact image distribution of <code>log(x)</code>.
</p>
</li>
<li> <p><code>log10</code>: <code>signature(x = "DiscreteDistribution")</code>:  exact image distribution of <code>log10(x)</code>.
</p>
</li>
<li> <p><code>gamma</code>: <code>signature(x = "DiscreteDistribution")</code>:  exact image distribution of <code>gamma(x)</code>.
</p>
</li>
<li> <p><code>lgamma</code>: <code>signature(x = "DiscreteDistribution")</code>:  exact image distribution of <code>lgamma(x)</code>.
</p>
</li>
<li> <p><code>digamma</code>: <code>signature(x = "DiscreteDistribution")</code>:  exact image distribution of <code>digamma(x)</code>.
</p>
</li></ul>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "DiscreteDistribution")</code>: application of &lsquo;-&rsquo; to this discrete distribution</p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "DiscreteDistribution", e2 = "numeric")</code>: multiplication of this discrete distribution
by an object of class &lsquo;numeric&rsquo;</p>
</dd>
<dt>/</dt><dd><p><code>signature(e1 = "DiscreteDistribution", e2 = "numeric")</code>: division of this discrete distribution
by an object of class &lsquo;numeric&rsquo;</p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "DiscreteDistribution", e2 = "numeric")</code>: addition of this discrete distribution
to an object of class &lsquo;numeric&rsquo;</p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "DiscreteDistribution", e2 = "numeric")</code>: subtraction of an object of class &lsquo;numeric&rsquo;
from this discrete distribution </p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "numeric", e2 = "DiscreteDistribution")</code>: multiplication of this discrete distribution
by an object of class &lsquo;numeric&rsquo;</p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "numeric", e2 = "DiscreteDistribution")</code>: addition of this discrete distribution
to an object of class &lsquo;numeric&rsquo;</p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "numeric", e2 = "DiscreteDistribution")</code>: subtraction of this discrete distribution
from an object of class &lsquo;numeric&rsquo;</p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "DiscreteDistribution", e2 = "DiscreteDistribution")</code>: Convolution of two discrete
distributions. The slots p, d and q are approximated on a common grid.</p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "DiscreteDistribution", e2 = "DiscreteDistribution")</code>: Convolution of two discrete
distributions. The slots p, d and q are approximated on a common grid.</p>
</dd>
<dt>support</dt><dd><p><code>signature(object = "DiscreteDistribution")</code>: returns the support</p>
</dd>
<dt>p.l</dt><dd><p><code>signature(object = "DiscreteDistribution")</code>: returns the 
left continuous cumulative distribution function, i.e.; 
<code class="reqn">p.l(t) = P(object &lt; t)</code> </p>
</dd>
<dt>q.r</dt><dd><p><code>signature(object = "DiscreteDistribution")</code>: returns the 
right-continuous quantile function, i.e.; 
<code class="reqn">{\rm q.r}(s)=\sup\{t \,\big|\, P({\tt object}\ge t)\leq s\}</code></p>
</dd>
<dt>plot</dt><dd><p><code>signature(object = "DiscreteDistribution")</code>: plots density, cumulative distribution and quantile
function </p>
</dd>
</dl>



<h3>Internal subclass &quot;AffLinDiscreteDistribution&quot;</h3>

<p>To enhance accuracy of several functionals on distributions,
mainly from package <span class="pkg">distrEx</span>, from version 1.9 of this package on, 
there is an internally used (but exported) subclass 
<code>"AffLinDiscreteDistribution"</code> which has extra slots 
<code>a</code>, <code>b</code> (both of class <code>"numeric"</code>),  and <code>X0</code> 
(of class <code>"DiscreteDistribution"</code>), to capture the fact 
that the object has the same distribution as <code>a * X0 + b</code>. This is 
the class of the return value of methods 
</p>

<dl>
<dt>-</dt><dd><p><code>signature(e1 = "DiscreteDistribution")</code></p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "DiscreteDistribution", e2 = "numeric")</code></p>
</dd>
<dt>/</dt><dd><p><code>signature(e1 = "DiscreteDistribution", e2 = "numeric")</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "DiscreteDistribution", e2 = "numeric")</code></p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "DiscreteDistribution", e2 = "numeric")</code></p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "numeric", e2 = "DiscreteDistribution")</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "numeric", e2 = "DiscreteDistribution")</code></p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "numeric", e2 = "DiscreteDistribution")</code></p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "AffLinDiscreteDistribution")</code></p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "AffLinDiscreteDistribution", e2 = "numeric")</code></p>
</dd>
<dt>/</dt><dd><p><code>signature(e1 = "AffLinDiscreteDistribution", e2 = "numeric")</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "AffLinDiscreteDistribution", e2 = "numeric")</code></p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "AffLinDiscreteDistribution", e2 = "numeric")</code></p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "numeric", e2 = "AffLinDiscreteDistribution")</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "numeric", e2 = "AffLinDiscreteDistribution")</code></p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "numeric", e2 = "AffLinDiscreteDistribution")</code></p>
</dd>
</dl>

<p>There also is a class union of <code>"AffLinAbscontDistribution"</code>,
<code>"AffLinDiscreteDistribution"</code>, <code>"AffLinUnivarLebDecDistribution"</code>
and called <code>"AffLinDistribution"</code>
which is used for functionals.
</p>


<h3>Internal virtual superclass &quot;AcDcLcDistribution&quot;</h3>

<p>As many operations should be valid no matter whether the operands
are of class <code>"AbscontDistribution"</code>,
<code>"DiscreteDistribution"</code>, or <code>"UnivarLebDecDistribution"</code>,
there is a class union of these classes called <code>"AcDcLcDistribution"</code>;
in partiucalar methods for <code>"*"</code>, <code>"/"</code>, 
<code>"^"</code> (see <a href="#topic+operators-methods">operators-methods</a>) and methods
<code><a href="#topic+Minimum">Minimum</a></code>, <code>Maximum</code>, <code><a href="#topic+Truncate">Truncate</a></code>, and
<code><a href="#topic+Huberize">Huberize</a></code>, and <code><a href="#topic+convpow">convpow</a></code> are defined for this 
class union.   
</p>


<h3>Note</h3>

<p> Working with a computer, we use a finite interval as support which 
carries at least mass <code>1-getdistrOption("TruncQuantile")</code>. <br />
</p>
<p>Also, we require that support points have distance at least       
<code>getdistrOption("DistrResoltion")</code>, if this condition fails,
upon a suggestion by Jacob van Etten, <a href="mailto:jacobvanetten@yahoo.com">jacobvanetten@yahoo.com</a>,
we use the global option <code>getdistrOption("DistrCollapse")</code> to
decide whether we use collapsing or not. If we do so, we collapse support 
points if they are too close to each other, taking
the (left most) median among them as new support point which accumulates
all the mass of the collapsed points. 
With <code>getdistrOption("DistrCollapse")==FALSE</code>, we at least collapse
points according to the result of <code>unique()</code>, and if after this
collapsing, the minimal distance is less than <code>getdistrOption("DistrResoltion")</code>,
we throw an error. By <code>getdistrOption("DistrCollapse.Unique.Warn")</code>,
we control, whether we throw a warning upon collapsing or not.       
</p>


<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Parameter-class">Parameter-class</a></code>
<code><a href="#topic+UnivariateDistribution-class">UnivariateDistribution-class</a></code>
<code><a href="#topic+LatticeDistribution-class">LatticeDistribution-class</a></code>
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>
<code><a href="#topic+Reals-class">Reals-class</a></code>
<code><a href="#topic+RtoDPQ.d">RtoDPQ.d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Dirac-measure at 0
D1 &lt;- DiscreteDistribution(supp = 0)
support(D1)

# simple discrete distribution
D2 &lt;- DiscreteDistribution(supp = c(1:5), prob = c(0.1, 0.2, 0.3, 0.2, 0.2))
plot(D2)
(pp &lt;- p(D2)(support(D2)))
p(D2)(support(D2)-1e-5)
p(D2)(support(D2)+1e-5)
p.l(D2)(support(D2))
p.l(D2)(support(D2)-1e-5)
p.l(D2)(support(D2)+1e-5)
q(D2)(pp)
q(D2)(pp-1e-5)
q(D2)(pp+1e-5)
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
q.r(D2)(pp)
q.r(D2)(pp-1e-5)
q.r(D2)(pp+1e-5)
</code></pre>

<hr>
<h2 id='distr-defunct'>Class &quot;GeomParameter&quot;</h2><span id='topic+distr-defunct'></span><span id='topic+GeomParameter-class'></span><span id='topic+initialize+2CGeomParameter-method'></span>

<h3>Description</h3>

<p> The parameter of a geometric distribution, used by Geom-class</p>


<h3>Objects from the Class</h3>

<p>Objects were created by calls of the form <code>new("GeomParameter", prob)</code>.
Usually an object of this class was not needed on its own, it was generated
automatically when an object of the class Geom
is instantiated.
</p>


<h3>Slots</h3>


<dl>
<dt><code>prob</code></dt><dd><p>Object of class <code>"numeric"</code>: the probability of a
geometric distribution </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>:
a name / comment for the parameters </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "GeomParameter")</code>:
initialize method </p>
</dd>
<dt>prob</dt><dd><p><code>signature(object = "GeomParameter")</code>:
returns the slot <code>prob</code> of the parameter of the
distribution </p>
</dd>
<dt>prob&lt;-</dt><dd><p><code>signature(object = "GeomParameter")</code>:
modifies the slot <code>prob</code> of the parameter of the
distribution </p>
</dd>
</dl>



<h3>Defunct</h3>

<p>The use of class <code>GeomParameter</code> is defunct as of version 2.8.0;
it is to be replaced by a corresponding use
of class <code>NbinomParameter</code> with slot <code>size = 1</code> which may be
generated, e.g. by
<code>new("NbinomParameter", prob, size = 1,
           name = "Parameter of a Geometric distribution")</code>
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Defunct">Defunct</a></code>
</p>

<hr>
<h2 id='distrARITH'>Arithmetics on Distributions</h2><span id='topic+distrARITH'></span><span id='topic+ARITHMETICS'></span>

<h3>Description</h3>

<p>Provides information on the interpretation of
arithmetics operating on Distributions in package <span class="pkg">distr</span></p>


<h3>Usage</h3>

<pre><code class='language-R'>distrARITH(library = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distrARITH_+3A_library">library</code></td>
<td>
<p>a character vector with path names of R libraries, or <code>NULL</code>.
The default value of <code>NULL</code> corresponds to all libraries
currently known.  If the default is used, the loaded packages
are searched before the libraries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no value is returned
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>distrARITH()
</code></pre>

<hr>
<h2 id='Distribution-class'>Class &quot;Distribution&quot;</h2><span id='topic+Distribution-class'></span><span id='topic+.logExact'></span><span id='topic+.logExact-methods'></span><span id='topic+.logExact+2CDistribution-method'></span><span id='topic+.lowerExact'></span><span id='topic+.lowerExact-methods'></span><span id='topic+.lowerExact+2CDistribution-method'></span><span id='topic+Symmetry'></span><span id='topic+Symmetry-methods'></span><span id='topic+Symmetry+2CDistribution-method'></span>

<h3>Description</h3>

<p> The <code>Distribution-class</code> is the mother-class of 
class <code>UnivariateDistribution</code>.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("Distribution")</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"rSpace"</code>: the space of the image </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"OptionalParameter"</code>: the parameter </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: generates random numbers</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"OptionalFunction"</code>: density function</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"OptionalFunction"</code>: cumulative 
distribution function</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"OptionalFunction"</code>: quantile function</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>img</dt><dd><p><code>signature(object = "Distribution")</code>: returns the space of 
the image</p>
</dd>
<dt>param</dt><dd><p><code>signature(object = "Distribution")</code>: returns the 
parameter</p>
</dd>
<dt>r</dt><dd><p><code>signature(object = "Distribution")</code>: returns the random 
number generator </p>
</dd>
<dt>d</dt><dd><p><code>signature(object = "Distribution")</code>: returns the density 
function </p>
</dd>
<dt>p</dt><dd><p><code>signature(object = "Distribution")</code>: returns the cumulative 
distribution function </p>
</dd>
<dt>q</dt><dd><p><code>signature(object = "Distribution")</code>: returns the quantile 
function</p>
</dd>
<dt>.logExact</dt><dd><p><code>signature(object = "Distribution")</code>: returns slot 
<code>.logExact</code> if existing; else tries to convert the object to a newer 
version of its class by <code><a href="#topic+conv2NewVersion">conv2NewVersion</a></code> and
returns the corresponding slot of the converted object.</p>
</dd>
<dt>.lowerExact</dt><dd><p><code>signature(object = "Distribution")</code>: returns slot 
<code>.lowerExact</code> if existing; else tries to convert the object to a 
newer version of its class by <code><a href="#topic+conv2NewVersion">conv2NewVersion</a></code> and
returns the corresponding slot of the converted object.</p>
</dd>
<dt>Symmetry:</dt><dd><p>returns slot <code>Symmetry</code> if existing; else
tries to convert the object to a 
newer version of its class by <code><a href="#topic+conv2NewVersion">conv2NewVersion</a></code> and
returns the corresponding slot of the converted object.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+UnivariateDistribution-class">UnivariateDistribution-class</a></code>
<code><a href="#topic+Parameter-class">Parameter-class</a></code>
</p>

<hr>
<h2 id='DistributionSymmetry-class'>Class of Symmetries for Distributions</h2><span id='topic+DistributionSymmetry-class'></span>

<h3>Description</h3>

<p>Class of symmetries for distributions.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
discribes type of symmetry. </p>
</dd>
<dt><code>SymmCenter</code></dt><dd><p>Object of class <code>"OptionalNumeric"</code>:
center of symmetry. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Symmetry"</code>, directly.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Symmetry-class">Symmetry-class</a></code>, <code><a href="#topic+Distribution-class">Distribution-class</a></code>, 
<code><a href="#topic+OptionalNumeric-class">OptionalNumeric-class</a></code></p>

<hr>
<h2 id='DistrList'>Generating function for DistrList-class</h2><span id='topic+DistrList'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"DistrList"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>DistrList(..., Dlist)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DistrList_+3A_...">...</code></td>
<td>
<p>Objects of class <code>"Distribution"</code> (or subclasses)</p>
</td></tr>
<tr><td><code id="DistrList_+3A_dlist">Dlist</code></td>
<td>
<p>an optional list or object of class <code>"DistrList"</code>;
if not missing it is appended to argument <code>...</code>; this way
<code>DistrList</code> may also be called with a list (or
<code>"DistrList"</code>-object) as argument as suggested in an e-mail
by Krunoslav Sever (thank you!)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"DistrList"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+DistrList-class">DistrList-class</a></code>, <code><a href="#topic+UnivarDistrList-class">UnivarDistrList-class</a></code>,
<code><a href="#topic+UnivarDistrList">UnivarDistrList</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(DL &lt;- DistrList(Norm(), Exp(), Pois()))
plot(DL)
as(Norm(), "DistrList")

## The function is currently defined as
function(...){ 
    new("DistrList", list(...)) 
}
</code></pre>

<hr>
<h2 id='DistrList-class'>List of distributions</h2><span id='topic+DistrList-class'></span><span id='topic+coerce+2CDistribution+2CDistrList-method'></span><span id='topic+show+2CDistrList-method'></span>

<h3>Description</h3>

<p>Create a list of distributions</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("DistrList", ...)</code>.
More frequently they are created via the generating function 
<code>DistrList</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p>Object of class <code>"list"</code>. 
A list of distributions.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"list"</code>, from data part.<br />
Class <code>"vector"</code>, by class <code>"list"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "DistrList")</code></p>
</dd>
<dt>plot</dt><dd><p><code>signature(object = "DistrList")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "Distribution", to = "DistrList")</code>:
create a <code>"DistrList"</code> object from a <code>"Distribution"</code> object</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+DistrList">DistrList</a></code>, <code><a href="#topic+Distribution-class">Distribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(DL &lt;- new("DistrList", list(Norm(), Exp())))
plot(DL)
as(Norm(), "DistrList")
</code></pre>

<hr>
<h2 id='distrMASK'>Masking of/by other functions in package &quot;distr&quot;</h2><span id='topic+distrMASK'></span><span id='topic+MASKING'></span>

<h3>Description</h3>

<p>Provides information on the (intended) masking of
and (non-intended) masking by other other functions in package <span class="pkg">distr</span></p>


<h3>Usage</h3>

<pre><code class='language-R'>distrMASK(library = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distrMASK_+3A_library">library</code></td>
<td>
<p>a character vector with path names of R libraries, or <code>NULL</code>.
The default value of <code>NULL</code> corresponds to all libraries
currently known.  If the default is used, the loaded packages
are searched before the libraries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no value is returned
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>distrMASK()
</code></pre>

<hr>
<h2 id='distroptions'>
functions to change the global variables of the package &lsquo;distr&rsquo;
</h2><span id='topic+distroptions'></span><span id='topic+getdistrOption'></span><span id='topic+DefaultNrGridPoints'></span><span id='topic+DistrResolution'></span><span id='topic+DistrCollapse'></span><span id='topic+TruncQuantile'></span><span id='topic+WarningSim'></span><span id='topic+WarningArith'></span><span id='topic+DefaultNrFFTGridPointsExponent'></span><span id='topic+RtoDPQ.e'></span><span id='topic+WarningArith'></span><span id='topic+WarningSim'></span><span id='topic+withSweave'></span><span id='topic+warn.makeDNew'></span><span id='topic+withgaps'></span><span id='topic+use.generalized.inverse.by.default'></span><span id='topic+DistributionAggregate.Unique.Warn'></span>

<h3>Description</h3>

<p>With <code>distroptions</code> and <code>getdistrOption</code> you may inspect and change the global
variables used by package <span class="pkg">distr</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distroptions(...)
getdistrOption(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distroptions_+3A_...">...</code></td>
<td>
<p> any options can be defined, using name = value or by passing a list of such tagged values. </p>
</td></tr>
<tr><td><code id="distroptions_+3A_x">x</code></td>
<td>
<p> a character string holding an option name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Invoking <code>distroptions()</code> with no arguments returns a list with the current values of the options.  
To access the value of a single option, one should use <code>getdistrOption("WarningSim")</code>, e.g., rather than
<code>distroptions("WarningSim")</code> which is a <em>list</em> of length one.</p>


<h3>Value</h3>

<p><code>distroptions()</code> returns a list of the global options of <span class="pkg">distr</span>. <br />
<code>distroptions("RtoDPQ.e")</code> returns  the global option <code>RtoDPQ.e</code> as a list of length 1. <br />
<code>distroptions("RtoDPQ.e" = 3)</code> sets the value of the global option  <code>RtoDPQ.e</code> to 3. 
<code>getdistrOption("RtoDPQ.e")</code> the current value set for option <code>RtoDPQ.e</code>. 
</p>


<h3>Currently available options</h3>


<dl>
<dt><code>DefaultNrGridPoints</code></dt><dd><p>default number of grid points in integration, default value: <code>2^12</code></p>
</dd>
<dt><code>DistrResolution</code></dt><dd><p>minimal spacing between two mass points in a discrete distribution, default value: <code>1e-6</code></p>
</dd>
<dt><code>DistrCollapse</code></dt><dd><p>logical; in discrete distributions, shall support points
with distance smaller than <code>DistrResolution</code> be collapsed; default value:  <code>TRUE</code></p>
</dd>
<dt><code>TruncQuantile</code></dt><dd><p>argument for <code>q</code>-slot at which to truncate; also, for discrete distributions, 
support is restricted to [<code>q(TruncQuantile)</code>,<code>q(1-TruncQuantile)</code>], default value: <code>1e-5</code></p>
</dd>
<dt><code>DefaultNrFFTGridPointsExponent</code></dt><dd><p>by default, for e = <code>DefaultNrFFTGridPointsExponent</code>, 
FFT uses <code class="reqn">2^e</code> gridpoints; default value: <code>12</code></p>
</dd>
<dt><code>RtoDPQ.e</code></dt><dd><p>by default, for reconstructing the <code>d</code>-,<code>p</code>-,<code>q</code>-slots out of simulations by slot <code>r</code>,
<code>RtoDPQ</code> resp. <code>RtoDPQ.d</code> use <code class="reqn">10^e</code> simulations, where e = <code>RtoDPQ.e</code>, default value: <code>5</code></p>
</dd>
<dt><code>WarningSim</code></dt><dd><p>if <code>WarningSim==TRUE</code>, <code>print</code>/<code>show</code> issue a warning as to the precision of 
<code>d</code>-,<code>p</code>-,<code>q</code>-slots when these are obtained by <code>RtoDPQ</code> resp. <code>RtoDPQ.d</code>, default value: <code>TRUE</code></p>
</dd>
<dt><code>WarningArith</code></dt><dd><p>if <code>WarningArith==TRUE</code>, <code>print</code>/<code>show</code> issue a warning as to the interpretation of
arithmetics operating on distributions, when the corresponding distribution to be plotted/shown is obtained by such an operation;
keep in mind that arithmetics in fact operate on random variables distributed according to the given distributions and <b>not</b>
on corresponding cdf's or densities; default value: <code>TRUE</code></p>
</dd>
<dt><code>withSweave</code></dt><dd><p>is code run in Sweave (then no new graphic devices are opened), 
default value: <code>FALSE</code></p>
</dd>
<dt><code>withgaps</code></dt><dd><p>controls whether in the return value of arithmetic
operations the slot <code>gaps</code> of an the <code>AbscontDistribution</code> part
is filled automatically based on empirical evaluations via  <code>setgaps</code>
&mdash;default <code>TRUE</code></p>
</dd>
<dt><code>simplifyD</code></dt><dd><p> controls whether in the return value of arithmetic
operations there is a call to <code>simplifyD</code> or not &mdash;default <code>TRUE</code></p>
</dd>
<dt>use.generalized.inverse.by.default</dt><dd><p>logical; decides whether by default
(i.e., if argument <code>generalized</code> of <code><a href="#topic+solve">solve</a></code> is not explicitely
set), <code><a href="#topic+solve">solve</a></code> is to use generalized inverses if the original 
<code>solve</code>-method from package <span class="pkg">base</span> fails; if the option is <code>FALSE</code>, 
in case of failure, and unless argument <code>generalized</code> is not explicitely 
set to <code>TRUE</code>, <code>solve</code> will throw an error as is 
the <span class="pkg">base</span>-method behavior. The default value is <code>TRUE</code>.  
</p>
</dd>
<dt><code>DistrCollapse.Unique.Warn</code></dt><dd><p>controls whether there is a warning
whenever collapsing occurs or when two points are collapsed by a call to
<code>unique()</code> (default behaviour if <code>DistrCollapse</code> is <code>FALSE</code>);
&mdash;default <code>FALSE</code></p>
</dd>
<dt><code>warn.makeDNew</code></dt><dd><p>controls whether a warning is issued once in
internal utility <code>.makeDNew</code> standard integration with
<code>integrate</code> throws an error&mdash;default <code>TRUE</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+options">options</a></code>, <code><a href="base.html#topic+options">getOption</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>distroptions("RtoDPQ.e") # returns the value of RtoDPQ.e, by default = 5
currentDistrOptions &lt;- distroptions()
distroptions(RtoDPQ.e = 6)
distroptions("RtoDPQ.e") 
getdistrOption("RtoDPQ.e") 
distroptions(c("WarningSim","WarningArith"))   
getdistrOption("WarningSim")   
distroptions("WarningSim" = FALSE)   
         # switches off warnings as to (In)accuracy due to simulations
distroptions("WarningArith" = FALSE) 
         # switches off warnings as to arithmetics
distroptions(currentDistrOptions)
</code></pre>

<hr>
<h2 id='DistrSymmList'>Generating function for DistrSymmList-class</h2><span id='topic+DistrSymmList'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"DistrSymmList"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DistrSymmList(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DistrSymmList_+3A_...">...</code></td>
<td>
<p> Objects of class <code>"DistributionSymmetry"</code> which
shall form the list of symmetry types. </p>
</td></tr>
</table>


<h3>Value</h3>

<p> Object of class <code>"DistrSymmList"</code> </p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+DistrSymmList-class">DistrSymmList-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>DistrSymmList(NoSymmetry(), SphericalSymmetry(SymmCenter = 1), 
              EllipticalSymmetry(SymmCenter = 2))

## The function is currently defined as
function (...){
    new("DistrSymmList", list(...))
}
</code></pre>

<hr>
<h2 id='DistrSymmList-class'>List of Symmetries for a List of Distributions</h2><span id='topic+DistrSymmList-class'></span>

<h3>Description</h3>

<p>Create a list of symmetries for a list of distributions</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("DistrSymmList", ...)</code>.
More frequently they are created via the generating function 
<code>DistrSymmList</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p> Object of class <code>"list"</code>. A list 
of objects of class <code>"DistributionSymmetry"</code>. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"list"</code>, from data part.<br />
Class <code>"vector"</code>, by class <code>"list"</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+DistributionSymmetry-class">DistributionSymmetry-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("DistrSymmList", list(NoSymmetry(), SphericalSymmetry(SymmCenter = 1), 
                          EllipticalSymmetry(SymmCenter = 2)))
</code></pre>

<hr>
<h2 id='EllipticalSymmetry'>Generating function for EllipticalSymmetry-class</h2><span id='topic+EllipticalSymmetry'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"EllipticalSymmetry"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>EllipticalSymmetry(SymmCenter = 0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EllipticalSymmetry_+3A_symmcenter">SymmCenter</code></td>
<td>
<p> numeric: center of symmetry </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"EllipticalSymmetry"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+EllipticalSymmetry-class">EllipticalSymmetry-class</a></code>, <code><a href="#topic+DistributionSymmetry-class">DistributionSymmetry-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>EllipticalSymmetry()

## The function is currently defined as
function(SymmCenter = 0){ 
    new("EllipticalSymmetry", SymmCenter = SymmCenter) 
}
</code></pre>

<hr>
<h2 id='EllipticalSymmetry-class'>Class for Elliptically Symmetric Distributions</h2><span id='topic+EllipticalSymmetry-class'></span>

<h3>Description</h3>

<p>Class for elliptically symmetric distributions.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("EllipticalSymmetry")</code>.
More frequently they are created via the generating function 
<code>EllipticalSymmetry</code>. Elliptical symmetry for instance leads to 
a simplification for the computation of optimally robust influence curves.
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
contains &ldquo;elliptical symmetric distribution&rdquo; </p>
</dd>
<dt><code>SymmCenter</code></dt><dd><p>Object of class <code>"numeric"</code>:
center of symmetry </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"DistributionSymmetry"</code>, directly.<br />
Class <code>"Symmetry"</code>, by class <code>"DistributionSymmetry"</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+EllipticalSymmetry">EllipticalSymmetry</a></code>, <code><a href="#topic+DistributionSymmetry-class">DistributionSymmetry-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("EllipticalSymmetry")
</code></pre>

<hr>
<h2 id='EmpiricalDistribution'>Generating function &quot;EmpiricalDistribution&quot;</h2><span id='topic+EmpiricalDistribution'></span>

<h3>Description</h3>

<p>Generates an object of class  <code>"DiscreteDistribution"</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>  EmpiricalDistribution(data, .withArith=FALSE, .withSim=FALSE, 
                        .lowerExact = TRUE, .logExact = FALSE,
                        .DistrCollapse = getdistrOption("DistrCollapse"),
                        .DistrCollapse.Unique.Warn = 
                             getdistrOption("DistrCollapse.Unique.Warn"),
                        .DistrResolution = getdistrOption("DistrResolution"),
                        Symmetry = NoSymmetry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EmpiricalDistribution_+3A_data">data</code></td>
<td>
<p>numeric vector with data. </p>
</td></tr>
<tr><td><code id="EmpiricalDistribution_+3A_.witharith">.withArith</code></td>
<td>
<p>normally not set by the user, but if determining the entries <code>supp</code>, <code>prob</code>
distributional arithmetics was involved, you may set this to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="EmpiricalDistribution_+3A_.withsim">.withSim</code></td>
<td>
<p>normally not set by the user, but if determining the entries <code>supp</code>, <code>prob</code>
simulations were involved, you may set this to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="EmpiricalDistribution_+3A_.lowerexact">.lowerExact</code></td>
<td>
<p>normally not set by the user: whether the <code>lower.tail=FALSE</code>
part is calculated exactly, avoing a &ldquo;<code>1-.</code>&rdquo;.</p>
</td></tr>
<tr><td><code id="EmpiricalDistribution_+3A_.logexact">.logExact</code></td>
<td>
<p>normally not set by the user: whether in determining slots <code>d,p,q</code>,
we make particular use of a logarithmic representation to enhance accuracy.</p>
</td></tr>
<tr><td><code id="EmpiricalDistribution_+3A_.distrcollapse">.DistrCollapse</code></td>
<td>
<p>controls whether in generating a new discrete 
distribution, support points closer together than <code>.DistrResolution</code> are
collapsed.</p>
</td></tr>
<tr><td><code id="EmpiricalDistribution_+3A_.distrcollapse.unique.warn">.DistrCollapse.Unique.Warn</code></td>
<td>
<p>controls whether there is a warning
whenever collapsing occurs or when two points are collapsed by a call to
<code>unique()</code> (default behaviour if <code>.DistrCollapse</code> is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="EmpiricalDistribution_+3A_.distrresolution">.DistrResolution</code></td>
<td>
<p>minimal spacing between two mass points in a discrete 
distribution</p>
</td></tr>
<tr><td><code id="EmpiricalDistribution_+3A_symmetry">Symmetry</code></td>
<td>
<p>you may help <span class="rlang"><b>R</b></span> in calculations if you tell it whether
the distribution is non-symmetric (default) or symmetric with respect
to a center; in this case use <code>Symmetry=SphericalSymmetry(center)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a simple utility function providing a wrapper to the 
generating function <code><a href="#topic+DiscreteDistribution">DiscreteDistribution</a></code>.
</p>
<p>Typical usage is
</p>
<pre>
    EmpiricalDistribution(data)
  </pre>


<h3>Value</h3>

<p>Object of class <code>"DiscreteDistribution"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DiscreteDistribution">DiscreteDistribution</a></code>
<code><a href="#topic+DiscreteDistribution-class">DiscreteDistribution-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(20)
D1 &lt;- EmpiricalDistribution(data = x)
D1

plot(D1)
</code></pre>

<hr>
<h2 id='EuclideanSpace-class'>Class &quot;EuclideanSpace&quot; </h2><span id='topic+EuclideanSpace'></span><span id='topic+EuclideanSpace-class'></span><span id='topic+initialize+2CEuclideanSpace-method'></span>

<h3>Description</h3>

<p> The distribution-classes contain a slot where the sample space is stored. One typical sample space is the
Euclidean Space in dimension k. </p>


<h3>Usage</h3>

<pre><code class='language-R'>EuclideanSpace(dimension = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EuclideanSpace-class_+3A_dimension">dimension</code></td>
<td>
<p> positive integer: dimension of 
the Euclidean space (default <code>=1</code>)</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Objects could theoretically be created by calls of the form <code>new("EuclideanSpace", dimension, name)</code>.
Usually an object of this class is not needed on its own. <code>EuclideanSpace</code> is the mother-class of the class 
<code>Reals</code>, which is generated automatically when a univariate absolutly continuous distribution is instantiated. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>dimension</code></dt><dd><p>Object of class <code>"numeric"</code>: the dimension of the space, by default = 1 </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: the name of the space, by default = &quot;Euclidean Space&quot;</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"rSpace"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "EuclideanSpace")</code>: initialize method </p>
</dd>
<dt>liesIn</dt><dd><p><code>signature(object = "EuclideanSpace", x = "numeric")</code>: Does a particular vector lie in this space or
not?
</p>
</dd>
<dt>dimension</dt><dd><p><code>signature(object = "EuclideanSpace")</code>: returns the dimension of the space </p>
</dd>
<dt>dimension&lt;-</dt><dd><p><code>signature(object = "EuclideanSpace")</code>: modifies the dimension of the space </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rSpace-class">rSpace-class</a></code>
<code><a href="#topic+Reals-class">Reals-class</a></code>
<code><a href="#topic+Distribution-class">Distribution-class</a></code>
<code><a href="#topic+liesIn-methods">liesIn-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E &lt;- EuclideanSpace(dimension = 2) 
dimension(E) # The dimension of this space is 2.
dimension(E) &lt;- 3 # The dimension of this space is now 3.
liesIn(E,c(0,0,0)) # TRUE
liesIn(E,c(0,0)) # FALSE
</code></pre>

<hr>
<h2 id='Exp-class'>Class &quot;Exp&quot;</h2><span id='topic+Exp-class'></span><span id='topic+Exp'></span><span id='topic+initialize+2CExp-method'></span>

<h3>Description</h3>

<p>The exponential distribution with rate <code class="reqn">\lambda</code> has density
</p>
<p style="text-align: center;"><code class="reqn">
    f(x) = \lambda {e}^{- \lambda x}</code>
</p>

<p>for <code class="reqn">x \ge 0</code>.
</p>
<p>C.f. <code><a href="stats.html#topic+Exponential">rexp</a></code>
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Exp(rate)</code>.
This object is an exponential distribution. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>:
The space of the image of this distribution has got dimension 1
and the name &quot;Real Space&quot;.</p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"ExpParameter"</code>:
the parameter of this distribution (rate), declared at its instantiation </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>:
generates random numbers (calls function rexp)</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>:
density function (calls function dexp)</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>:
cumulative function (calls function pexp)</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>:
inverse of the cumulative function (calls function qexp)</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"ExpOrGammaOrChisq"</code>, directly.<br />
Class <code>"AbscontDistribution"</code>, by class <code>"ExpOrGammaOrChisq"</code>.<br />
Class <code>"UnivariateDistribution"</code>, by class <code>"AbscontDistribution"</code>.
Class <code>"Distribution"</code>, by class <code>"AbscontDistribution"</code>.
</p>


<h3>Is-Relations</h3>

<p>By means of <code>setIs</code>, R &ldquo;knows&rdquo; that a distribution object <code>obj</code> of class <code>"Exp"</code> also is
a Gamma distribution with parameters <code>shape = 1, scale = 1/rate(obj)</code> and a Weibull  distribution with 
parameters <code>shape = 1, scale = 1/rate(obj)</code>
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "Exp")</code>:
initialize method</p>
</dd>
<dt>rate</dt><dd><p><code>signature(object = "Exp")</code>:
returns the slot rate of the parameter of the distribution</p>
</dd>
<dt>rate&lt;-</dt><dd><p><code>signature(object = "Exp")</code>:
modifies the slot rate of the parameter of the distribution</p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "Exp", e2 = "numeric")</code>: 
For the exponential distribution we use its closedness under positive scaling transformations.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br />
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ExpParameter-class">ExpParameter-class</a></code>
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>
<code><a href="#topic+Reals-class">Reals-class</a></code>
<code><a href="stats.html#topic+Exponential">rexp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E &lt;- Exp(rate = 1) # E is a exp distribution with rate = 1.
r(E)(1) # one random number generated from this distribution, e.g. 0.4190765
d(E)(1) # Density of this distribution is 0.3678794 for x = 1.
p(E)(1) # Probability that x &lt; 1 is 0.6321206.
q(E)(.1) # Probability that x &lt; 0.1053605 is 0.1.
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
rate(E) # rate of this distribution is 1.
rate(E) &lt;- 2 # rate of this distribution is now 2.
is(E, "Gammad") # yes
as(E,"Gammad")
is(E, "Weibull") 
E+E+E ###  a Gammad -distribution
2*E+Gammad(scale=1)
</code></pre>

<hr>
<h2 id='ExpOrGammaOrChisq-class'>Class &quot;ExpOrGammaOrChisq&quot;</h2><span id='topic+ExpOrGammaOrChisq-class'></span>

<h3>Description</h3>

<p>To have common methods, a class <code>"ExpOrGammaOrChisq"</code> is introduced
as subclass of class <code>"AbscontDistribution"</code>  and as superclass of
classes <code>"Chisq"</code>, <code>"Exp"</code>, <code>"Gammad"</code>. It is only used 
internally.
</p>


<h3>Objects from the Class</h3>

<p>This class is virtual, hence cannot be instantiated.
</p>


<h3>Extends</h3>

<p>Class <code>"AbscontDistribution"</code>, directly.<br />
Class <code>"UnivariateDistribution"</code>, by class <code>"AbscontDistribution"</code>.<br />
Class <code>"Distribution"</code>, by class <code>"UnivariateDistribution"</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Chisq-class">Chisq-class</a></code>
<code><a href="#topic+Gammad-class">Gammad-class</a></code>
<code><a href="#topic+Exp-class">Exp-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## class only used internally
</code></pre>

<hr>
<h2 id='ExpParameter-class'>Class &quot;ExpParameter&quot;</h2><span id='topic+ExpParameter-class'></span><span id='topic+initialize+2CExpParameter-method'></span>

<h3>Description</h3>

<p> The parameter of an exponential distribution, used by Exp-class and DExp-class</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("ExpParameter", rate)</code>.
Usually an object of this class is not needed on its own, it is generated automatically when an object of the class Exp
is instantiated. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>rate</code></dt><dd><p>Object of class <code>"numeric"</code>: the rate of an exponential distribution </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: a name / comment for the parameters </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "ExpParameter")</code>: initialize method </p>
</dd>
<dt>rate</dt><dd><p><code>signature(object = "ExpParameter")</code>: returns the slot <code>rate</code> of the parameter of the distribution </p>
</dd>
<dt>rate&lt;-</dt><dd><p><code>signature(object = "ExpParameter")</code>: modifies the slot <code>rate</code> of the parameter of the distribution </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Exp-class">Exp-class</a></code>
<code><a href="#topic+DExp-class">DExp-class</a></code>
<code><a href="#topic+Parameter-class">Parameter-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- new("ExpParameter", rate = 1)
rate(W) # rate of this distribution is 1.
rate(W) &lt;- 2 # rate of this distribution is now 2.
</code></pre>

<hr>
<h2 id='Fd-class'>Class &quot;Fd&quot;</h2><span id='topic+Fd-class'></span><span id='topic+Fd'></span><span id='topic+initialize+2CFd-method'></span>

<h3>Description</h3>

<p>   The F distribution with <code>df1 =</code> <code class="reqn">n_1</code>, by default <code>= 1</code>, 
and <code>df2 =</code> <code class="reqn">n_2</code>, by default <code>= 1</code>, degrees of freedom has density
</p>
<p style="text-align: center;"><code class="reqn">
    d(x) = \frac{\Gamma(n_1/2 + n_2/2)}{\Gamma(n_1/2)\Gamma(n_2/2)}
    \left(\frac{n_1}{n_2}\right)^{n_1/2} x^{n_1/2 -1}
    \left(1 + \frac{n_1 x}{n_2}\right)^{-(n_1 + n_2) / 2}%
  </code>
</p>

<p>for <code class="reqn">x &gt; 0</code>.
</p>
<p>C.f. <code><a href="stats.html#topic+Fdist">rf</a></code>
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Fd(df1, df2)</code>.
This object is a F distribution.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>: The space of the image of this distribution has got dimension 1 and the name &quot;Real Space&quot;. </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"FParameter"</code>: the parameter of this distribution (df1 and df2), declared at its instantiation </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: generates random numbers (calls function rf)</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>: density function (calls function df)</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>: cumulative function (calls function pf)</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>: inverse of the cumulative function (calls function qf)</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"AbscontDistribution"</code>, directly. <br />
Class <code>"UnivariateDistribution"</code>, by class <code>"AbscontDistribution"</code>. <br />
Class <code>"Distribution"</code>, by class <code>"AbscontDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "Fd")</code>: initialize method </p>
</dd>
<dt>df1</dt><dd><p><code>signature(object = "Fd")</code>: returns the slot <code>df1</code> of the parameter of the distribution </p>
</dd>
<dt>df1&lt;-</dt><dd><p><code>signature(object = "Fd")</code>: modifies the slot <code>df1</code> of the parameter of the distribution </p>
</dd>
<dt>df2</dt><dd><p><code>signature(object = "Fd")</code>: returns the slot <code>df2</code> of the parameter of the distribution </p>
</dd>
<dt>df2&lt;-</dt><dd><p><code>signature(object = "Fd")</code>: modifies the slot <code>df2</code> of the parameter of the distribution </p>
</dd>
</dl>



<h3>Ad hoc methods</h3>


<ul>
<li><p> An ad hoc method is provided for slot <code>d</code> if <code>ncp!=0</code>.
</p>
</li>
<li><p> For R Version <code>&lt;2.3.0</code> ad hoc methods are provided for slots <code>q</code>, <code>r</code> if <code>ncp!=0</code>;
for R Version <code>&gt;=2.3.0</code> the methods from package <span class="pkg">stats</span> are used.
</p>
</li></ul>


<h3>Note</h3>

<p>It is the distribution of the ratio of the mean squares of n1 and n2 independent standard normals, and hence of the
ratio of two independent chi-squared variates each divided by its degrees of freedom. Since the ratio of a normal and the
root mean-square of m independent normals has a Student's <code class="reqn">t_m</code> distribution, the square of a <code class="reqn">t_m</code> variate has a F
distribution on 1 and m degrees of freedom. 
</p>
<p>The non-central F distribution is again the ratio of mean squares of independent normals of unit variance, but those in the
numerator are allowed to have non-zero means and ncp is the sum of squares of the means. 
</p>


<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+FParameter-class">FParameter-class</a></code>
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>
<code><a href="#topic+Reals-class">Reals-class</a></code>
<code><a href="stats.html#topic+Fdist">rf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>F &lt;- Fd(df1 = 1, df2 = 1) # F is a F distribution with df=1 and df2=1.
r(F)(1) # one random number generated from this distribution, e.g. 29.37863
d(F)(1) # Density of this distribution is 0.1591549 for x=1 .
p(F)(1) # Probability that x&lt;1 is 0.5.
q(F)(.1) # Probability that x&lt;0.02508563 is 0.1.
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
df1(F) # df1 of this distribution is 1.
df1(F) &lt;- 2 # df1 of this distribution is now 2.
Fn &lt;- Fd(df1 = 1, df2 = 1, ncp = 0.5) 
  # Fn is a F distribution with df=1, df2=1 and ncp =0.5.
d(Fn)(1) ## from R 2.3.0 on ncp no longer ignored...
</code></pre>

<hr>
<h2 id='flat.LCD'>Flattening a list of Lebesgue decomposed distributions</h2><span id='topic+flat.LCD'></span>

<h3>Description</h3>

<p>flattens a list of Lebesgue decomposed distributions endowed with weights to 
give one Lebesgue decomposed distribution</p>


<h3>Usage</h3>

<pre><code class='language-R'>flat.LCD(..., mixCoeff = NULL, withgaps = getdistrOption("withgaps"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flat.LCD_+3A_...">...</code></td>
<td>
<p>list of Lebesgue decomposed distributions</p>
</td></tr>
<tr><td><code id="flat.LCD_+3A_mixcoeff">mixCoeff</code></td>
<td>
<p>Object of class <code>"numeric"</code> of the same length
as ...: a vector of probabilities for the mixing components.</p>
</td></tr>
<tr><td><code id="flat.LCD_+3A_withgaps">withgaps</code></td>
<td>
<p>logical; shall <code>gaps</code> be detected empirically?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>flat.LCD</code> flattens a list of Lebesgue decomposed distributions given through <code>...</code>,
i.e., it takes all list elements and mixing coefficients and builds up the mixed
distribution (forgetting about the components); the result will be one distribution of 
class <code>UnivarLebDecDistribution</code>. If <code>mixCoeff</code> is missing, all list elements 
are equally weighted. It is used internally in our methods for <code>"*"</code>, <code>"/"</code>,
<code>"^"</code> (see <a href="#topic+operators-methods">operators-methods</a>), 
<code><a href="#topic+Minimum">Minimum</a></code>, and <code><a href="#topic+convpow">convpow</a></code>, as well in method <code><a href="#topic+flat.mix">flat.mix</a></code>.</p>


<h3>Value</h3>

 <p><code>flat.LCD</code> returns an object of class <code>UnivarLebDecDistribution</code>.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

 
<p><code><a href="#topic+UnivarLebDecDistribution-class">UnivarLebDecDistribution-class</a></code>, 
<code><a href="#topic+operators-methods">operators-methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>D1 &lt;- as(Norm(),"UnivarLebDecDistribution")
D2 &lt;- as(Pois(1),"UnivarLebDecDistribution")
D3 &lt;- as(Binom(1,.4),"UnivarLebDecDistribution")
flat.LCD(D1,D2,D3, mixCoeff = c(0.4,0.5,0.1))
</code></pre>

<hr>
<h2 id='flat.mix'>Default procedure to fill slots d,p,q given r for Lebesgue decomposed distributions</h2><span id='topic+flat.mix'></span>

<h3>Description</h3>

<p>function to do get empirical density, cumulative distribution and quantile function from random numbers</p>


<h3>Usage</h3>

<pre><code class='language-R'>flat.mix(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flat.mix_+3A_object">object</code></td>
<td>
<p>object of class <code>UnivariateMixingDistribution</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>flat.mix generates <code class="reqn">10^e</code> random numbers, by default </p>
<p style="text-align: center;"><code class="reqn">e = RtoDPQ.e</code>
</p>
<p>. 
Replicates are assumed to be part of the discrete part, unique values to be
part of the a.c. part of the distribution. For the replicated ones,
we generate a discrete distribution by a call to <code><a href="#topic+DiscreteDistribution">DiscreteDistribution</a></code>.
The a.c. density is formed on the basis of <code class="reqn">n</code>
points using approxfun and density (applied to the unique values), by default </p>
<p style="text-align: center;"><code class="reqn">n = DefaultNrGridPoints</code>
</p>
<p>.
The cumulative distribution function is based on all random variables, 
and, as well as the quantile function, is also created on the basis of <code class="reqn">n</code> points using 
<code>approxfun</code> and <code>ecdf</code>.  Of course, the results are usually not exact as they rely on random numbers.</p>


<h3>Value</h3>

 <p><code>flat.mix</code> returns an object of class <code>UnivarLebDecDistribution</code>.
</p>


<h3>Note</h3>

<p> Use <code>RtoDPQ</code> for absolutely continuous and <code>RtoDPQ.d</code> for discrete distributions. </p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

 
<p><code><a href="#topic+UnivariateDistribution-class">UnivariateDistribution-class</a></code>, 
<code><a href="stats.html#topic+density">density</a></code>, 
<code><a href="stats.html#topic+approxfun">approxfun</a></code>, 
<code><a href="stats.html#topic+ecdf">ecdf</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>D1 &lt;- Norm()
D2 &lt;- Pois(1)
D3 &lt;- Binom(1,.4)
D4 &lt;- UnivarMixingDistribution(D1,D2,D3, mixCoeff = c(0.4,0.5,0.1), 
      withSimplify = FALSE)
D &lt;- UnivarMixingDistribution(D1,D4,D1,D2, mixCoeff = c(0.4,0.3,0.1,0.2), 
      withSimplify = FALSE)
D
D0&lt;-flat.mix(D)
D0
plot(D0)
</code></pre>

<hr>
<h2 id='FParameter-class'>Class &quot;FParameter&quot;</h2><span id='topic+FParameter-class'></span><span id='topic+initialize+2CFParameter-method'></span>

<h3>Description</h3>

<p> The parameter of a F distribution, used by Fd-class</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("FParameter", df1, df2, ncp)</code>.
Usually an object of this class is not needed on its own, it is
generated automatically when an object of the class Fd is instantiated. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>df1</code></dt><dd><p>Object of class <code>"numeric"</code>: the degrees of freedom of the nominator of an F distribution</p>
</dd>
<dt><code>df2</code></dt><dd><p>Object of class <code>"numeric"</code>: the degrees of freedom of the denominator of an F distribution</p>
</dd>
<dt><code>ncp</code></dt><dd><p>Object of class <code>"numeric"</code>: the noncentrality parameter of an F distribution </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: a name / comment for the parameters</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "FParameter")</code>: initialize method </p>
</dd>
<dt>df1</dt><dd><p><code>signature(object = "FParameter")</code>:
returns the slot df1 of the parameter of the distribution</p>
</dd>
<dt>df1&lt;-</dt><dd><p><code>signature(object = "FParameter")</code>:
modifies the slot df1 of the parameter of the distribution</p>
</dd>
<dt>df2</dt><dd><p><code>signature(object = "FParameter")</code>:
returns the slot df2 of the parameter of the distribution</p>
</dd>
<dt>df2&lt;-</dt><dd><p><code>signature(object = "FParameter")</code>:
modifies the slot df2 of the parameter of the distribution</p>
</dd>
<dt>ncp</dt><dd><p><code>signature(object = "FParameter")</code>: 
returns the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
<dt>ncp&lt;-</dt><dd><p><code>signature(object = "FParameter")</code>: 
modifies the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br />
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fd-class">Fd-class</a></code>
<code><a href="#topic+Parameter-class">Parameter-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- new("FParameter", df1 = 1, df2 = 1, ncp = 0)
df2(W) # df2 of this distribution is 1.
df2(W) &lt;- 2 # df2 of this distribution is now 2.
</code></pre>

<hr>
<h2 id='Gammad-class'>Class &quot;Gammad&quot;</h2><span id='topic+Gammad-class'></span><span id='topic+Gammad'></span><span id='topic+initialize+2CGammad-method'></span>

<h3>Description</h3>

<p>   The Gammad distribution with parameters <code>shape</code> <code class="reqn">=\alpha</code>,
by default <code>= 1</code>, and <code>scale</code> <code class="reqn">=\sigma</code>, by default <code>= 1</code>, has 
density
</p>
<p style="text-align: center;"><code class="reqn">
    d(x)= \frac{1}{{\sigma}^{\alpha}\Gamma(\alpha)} {x}^{\alpha-1} e^{-x/\sigma}%
  </code>
</p>

<p>for <code class="reqn">x &gt; 0</code>, <code class="reqn">\alpha &gt; 0</code> and <code class="reqn">\sigma &gt; 0</code>.
The mean and variance are
<code class="reqn">E(X) = \alpha\sigma</code> and
<code class="reqn">Var(X) = \alpha\sigma^2</code>. C.f. <code><a href="stats.html#topic+GammaDist">rgamma</a></code> 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Gammad(scale, shape)</code>.
This object is a gamma distribution.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>: The space of the image of this distribution has got dimension 1
and the name &quot;Real Space&quot;. </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"GammaParameter"</code>: the parameter of this distribution (scale and shape), declared at its instantiation </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: generates random numbers (calls function rgamma)</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>: density function (calls function dgamma)</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>: cumulative function (calls function pgamma)</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>: inverse of the cumulative function (calls function qgamma)</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"ExpOrGammaOrChisq"</code>, directly.<br />
Class <code>"AbscontDistribution"</code>, by class <code>"ExpOrGammaOrChisq"</code>.<br />
Class <code>"UnivariateDistribution"</code>, by class <code>"AbscontDistribution"</code>.<br />
Class <code>"Distribution"</code>, by class <code>"UnivariateDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "Gammad")</code>: initialize method </p>
</dd>
<dt>scale</dt><dd><p><code>signature(object = "Gammad")</code>: returns the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>scale&lt;-</dt><dd><p><code>signature(object = "Gammad")</code>: modifies the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>shape</dt><dd><p><code>signature(object = "Gammad")</code>: returns the slot <code>shape</code> of the parameter of the distribution </p>
</dd>
<dt>shape&lt;-</dt><dd><p><code>signature(object = "Gammad")</code>: modifies the slot <code>shape</code> of the parameter of the distribution </p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "Gammad", e2 = "Gammad")</code>: 
For the Gamma distribution we use its closedness under convolutions.</p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "Gammad", e2 = "numeric")</code>: 
For the Gamma distribution we use its closedness under positive scaling transformations.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+GammaParameter-class">GammaParameter-class</a></code>
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>
<code><a href="#topic+Reals-class">Reals-class</a></code>
<code><a href="stats.html#topic+GammaDist">rgamma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>G &lt;- Gammad(scale=1,shape=1) # G is a gamma distribution with scale=1 and shape=1.
r(G)(1) # one random number generated from this distribution, e.g. 0.1304441
d(G)(1) # Density of this distribution is 0.3678794 for x=1.
p(G)(1) # Probability that x&lt;1 is 0.6321206.
q(G)(.1) # Probability that x&lt;0.1053605 is 0.1.
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
scale(G) # scale of this distribution is 1.
scale(G) &lt;- 2 # scale of this distribution is now 2.
</code></pre>

<hr>
<h2 id='GammaParameter-class'>Class &quot;GammaParameter&quot;</h2><span id='topic+GammaParameter-class'></span><span id='topic+initialize+2CGammaParameter-method'></span>

<h3>Description</h3>

<p> The parameter of a gamma distribution, used by <code>Gammad</code>-class</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("GammaParameter", shape, scale)</code>.
Usually an object of this class is not needed on its own, it is generated automatically when an object of the class <code>Gammad</code>
is instantiated. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>shape</code></dt><dd><p>Object of class <code>"numeric"</code>: the shape of a Gamma distribution </p>
</dd>
<dt><code>scale</code></dt><dd><p>Object of class <code>"numeric"</code>: the scale of a Gamma distribution </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: a name / comment for the parameters </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "GammaParameter")</code>: initialize method </p>
</dd>
<dt>scale</dt><dd><p><code>signature(object = "GammaParameter")</code>: returns the slot <code>scale</code> of a parameter of a Gamma distribution </p>
</dd>
<dt>scale&lt;-</dt><dd><p><code>signature(object = "GammaParameter")</code>: modifies the slot <code>scale</code> of a parameter of a Gamma
distribution </p>
</dd>
<dt>shape</dt><dd><p><code>signature(object = "GammaParameter")</code>: returns the slot <code>shape</code> of a parameter of a Gamma distribution </p>
</dd>
<dt>shape&lt;-</dt><dd><p><code>signature(object = "GammaParameter")</code>: modifies the slot <code>shape</code> of a parameter of a Gamma
distribution </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Gammad-class">Gammad-class</a></code>
<code><a href="#topic+Parameter-class">Parameter-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- new("GammaParameter",scale=1,shape=1)
shape(W) # shape of this distribution is 1.
shape(W) &lt;- 2 # shape of this distribution is now 2.
</code></pre>

<hr>
<h2 id='gaps-methods'> Methods for Functions gaps and setgaps in Package &lsquo;distr&rsquo; </h2><span id='topic+gaps-methods'></span><span id='topic+setgaps-methods'></span><span id='topic+gaps+3C--methods'></span><span id='topic+gaps'></span><span id='topic+setgaps'></span><span id='topic+gaps+3C-'></span><span id='topic+gaps+2CAbscontDistribution-method'></span><span id='topic+gaps+3C-+2CAbscontDistribution-method'></span><span id='topic+setgaps+2CAbscontDistribution-method'></span><span id='topic+setgaps+2CUnivarMixingDistribution-method'></span>

<h3>Description</h3>

<p>[set]gaps-methods</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaps(object)
gaps(object)
gaps(object) &lt;- value
setgaps(object, ...)
## S4 method for signature 'AbscontDistribution'
gaps(object)
## S4 method for signature 'AbscontDistribution'
setgaps(object, exactq = 6, 
           ngrid = 50000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaps-methods_+3A_object">object</code></td>
<td>
<p>object of class  <code>"AbscontDistribution"</code> (or subclasses)</p>
</td></tr>
<tr><td><code id="gaps-methods_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>setgaps</code>; not yet used.</p>
</td></tr>
<tr><td><code id="gaps-methods_+3A_value">value</code></td>
<td>
<p><code class="reqn">n \times 2</code> matrix <code>m</code> of numerics where 
<code>c(t(m))</code> is an ordered vector; value to be assigned to slot 
<code>gaps</code></p>
</td></tr>
<tr><td><code id="gaps-methods_+3A_exactq">exactq</code></td>
<td>
<p>density values smaller than 
<code class="reqn">10^{\scriptsize -{\rm exactq}}</code>
are considered as <code class="reqn">0</code>.</p>
</td></tr> 
<tr><td><code id="gaps-methods_+3A_ngrid">ngrid</code></td>
<td>
<p>number of gridpoints at which the density is evaluated.</p>
</td></tr> 
</table>


<h3>Methods</h3>


<dl>
<dt>gaps</dt><dd><p><code>signature(object = "AbscontDistribution")</code>: returns  slot 
<code>gaps</code> of an absolutely continuous distribution</p>
</dd>
<dt>setgaps</dt><dd><p><code>signature(object = "AbscontDistribution")</code>: tries to find 
out the gaps (where <code>d(object)</code> is approximately
0) and fills slot <code>gaps</code> of <code>object</code> correspondingly</p>
</dd>
<dt>setgaps</dt><dd><p><code>signature(object = "UnivarMixingDistribution")</code>: 
for each mixing component, if it has a slot <code>gaps</code>, tries to find out the gaps 
and fills slot <code>gaps</code> of the component correspondingly, and,
subsequently merges all found gap-slots of the components to a gap-slot
for the object, using internal function <code><a href="#topic+.mergegaps2">.mergegaps2</a></code>.</p>
</dd>
<dt>gaps&lt;-</dt><dd><p><code>signature(object = "AbscontDistribution")</code>: modifies  slot 
<code>gaps</code> of an absolutely continuous distribution</p>
</dd>
</dl>

<hr>
<h2 id='Geom-class'>Class &quot;Geom&quot; </h2><span id='topic+Geom-class'></span><span id='topic+Geom'></span><span id='topic+initialize+2CGeom-method'></span>

<h3>Description</h3>

<p>The geometric distribution with <code>prob</code> <code class="reqn">= p</code> has density
</p>
<p style="text-align: center;"><code class="reqn">p(x) = p {(1-p)}^{x}</code>
</p>

<p>for <code class="reqn">x = 0, 1, 2, \ldots</code>
</p>
<p>C.f. <code><a href="stats.html#topic+Geometric">rgeom</a></code>
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Geom(prob)</code>.
This object is a geometric distribution. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Naturals"</code>:
The space of the image of this distribution has got dimension 1
and the name &quot;Natural Space&quot;.</p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"NbinomParameter"</code>:
the parameter of this distribution (prob),  
declared at its instantiation (size=1)</p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>:
generates random numbers (calls function rgeom)</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>:
density function (calls function dgeom)</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>:
cumulative function (calls function pgeom)</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>:
inverse of the cumulative function (calls function qgeom).
The quantile is defined as the smallest value <code class="reqn">x</code> such that
<code class="reqn">F(x) \ge p</code>, where <code class="reqn">F</code> is the distribution function.</p>
</dd>      
<dt><code>support</code></dt><dd><p>Object of class <code>"numeric"</code>:
a (sorted) vector containing the support of the discrete density
function</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"DiscreteDistribution"</code>, directly.<br /> 
Class <code>"Nbinom"</code>, directly.<br />
Class <code>"UnivariateDistribution"</code>, by class <code>"DiscreteDistribution"</code>.<br />
Class <code>"Distribution"</code>, by class <code>"DiscreteDistribution"</code>.
</p>


<h3>Contains-Relations</h3>

<p>By means of a <code>contains</code> argument in the class declaration, R &ldquo;knows&rdquo; 
that a distribution object <code>obj</code> of class <code>"Geom"</code> also is a 
negative Binomial distribution with parameters <code>size = 1, prob = prob(obj)</code>
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "Geom")</code>: initialize method</p>
</dd>
<dt>prob</dt><dd><p><code>signature(object = "Geom")</code>:
returns the slot prob of the parameter of the distribution</p>
</dd>
<dt>prob&lt;-</dt><dd><p><code>signature(object = "Geom")</code>:
modifies the slot prob of the parameter of the distribution</p>
</dd>
</dl>



<h3>Note</h3>

<p>Working with a computer, we use a finite interval as support which carries 
at least mass <code>1-getdistrOption("TruncQuantile")</code>. </p>


<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br />
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Nbinom-class">Nbinom-class</a></code>
<code><a href="#topic+GeomParameter-class">GeomParameter-class</a></code>
<code><a href="#topic+DiscreteDistribution-class">DiscreteDistribution-class</a></code>
<code><a href="#topic+Naturals-class">Naturals-class</a></code>
<code><a href="stats.html#topic+Geometric">rgeom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>G &lt;- Geom(prob = 0.5) # G is a geometric distribution with prob = 0.5.
r(G)(1) # one random number generated from this distribution, e.g. 0
d(G)(1) # Density of this distribution is 0.25 for x = 1.
p(G)(1) # Probability that x&lt;1 is 0.75.
q(G)(.1) # x = 0 is the smallest value x such that p(G)(x) &gt;= 0.1.
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
prob(G) # prob of this distribution is 0.5.
prob(G) &lt;- 0.6 # prob of this distribution is now 0.6.
as(G,"Nbinom")
G+G+G
</code></pre>

<hr>
<h2 id='getLabel'>Labels for distribution objects</h2><span id='topic+getLabel'></span>

<h3>Description</h3>

<p>a help function to get reasonable labels for distribution objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLabel(x, withnames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLabel_+3A_x">x</code></td>
<td>
<p> a distribution object</p>
</td></tr>
<tr><td><code id="getLabel_+3A_withnames">withnames</code></td>
<td>
<p> logical: are the parameters (if any) of <code>x</code> to be 
displayed with names? </p>
</td></tr>
</table>


<h3>Remark</h3>

<p>The need for this helper function (external to our 
<code>plot</code> methods) was brought to our attention in a mail 
by Kouros Owzar <a href="mailto:owzar001@mc.duke.edu">owzar001@mc.duke.edu</a>.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+plot-methods">plot-methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## example due to Kouros Owzar:
foo&lt;- function(law,n, withnames = TRUE)
  {
    data.frame(muhat=mean(r(law)(n)),n=n,law= getLabel(law,withnames))
  } 
### a function that groups certain informations on 
##  created with distribution objects
do.call("rbind",lapply(list(Exp(1),Norm(0,1),Weibull(1,1)),foo,n=100))
do.call("rbind",lapply(list(Exp(1),Norm(0,1),Weibull(1,1)),foo,n=100,FALSE))
</code></pre>

<hr>
<h2 id='getLow+2CgetUp'>getLow, getUp functions of package distr</h2><span id='topic+getUp'></span><span id='topic+getUp-methods'></span><span id='topic+getUp+2CAbscontDistribution-method'></span><span id='topic+getUp+2CDiscreteDistribution-method'></span><span id='topic+getUp+2CLatticeDistribution-method'></span><span id='topic+getUp+2CUnivarLebDecDistribution-method'></span><span id='topic+getUp+2CUnivarMixingDistribution-method'></span><span id='topic+getLow'></span><span id='topic+getLow-methods'></span><span id='topic+getLow+2CAbscontDistribution-method'></span><span id='topic+getLow+2CDiscreteDistribution-method'></span><span id='topic+getLow+2CLatticeDistribution-method'></span><span id='topic+getLow+2CUnivarLebDecDistribution-method'></span><span id='topic+getLow+2CUnivarMixingDistribution-method'></span>

<h3>Description</h3>

<p>getLow, getUp return lower and upper endpoint of a distribution &mdash;
truncated to lower/upper <code>TruncQuantile</code> if infinite; in case of an object 
of class <code>"LatticeDistribution"</code> with infinite lattice length, we search
for the smallest/largest point in the lattice which is returned by succesive
halving of <code>x=0.5</code> in <code>q(object)(x, lower.tail)</code> for <code>lower.tail</code> 
<code>TRUE</code> resp. <code>false</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AbscontDistribution'
getUp(object,
                                      eps = getdistrOption("TruncQuantile"))
## S4 method for signature 'DiscreteDistribution'
getUp(object, ...)
## S4 method for signature 'LatticeDistribution'
getUp(object, ...)
## S4 method for signature 'UnivarLebDecDistribution'
getUp(object,
                                      eps = getdistrOption("TruncQuantile"))
## S4 method for signature 'UnivarMixingDistribution'
getUp(object,
                                      eps = getdistrOption("TruncQuantile"))
## S4 method for signature 'AbscontDistribution'
getLow(object,
                                       eps = getdistrOption("TruncQuantile"))
## S4 method for signature 'DiscreteDistribution'
getLow(object, ...)
## S4 method for signature 'LatticeDistribution'
getLow(object, ...)
## S4 method for signature 'UnivarLebDecDistribution'
getLow(object,
                                      eps = getdistrOption("TruncQuantile"))
## S4 method for signature 'UnivarMixingDistribution'
getLow(object,
                                      eps = getdistrOption("TruncQuantile"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLow+2B2CgetUp_+3A_object">object</code></td>
<td>
<p>a distribution object</p>
</td></tr>
<tr><td><code id="getLow+2B2CgetUp_+3A_eps">eps</code></td>
<td>
<p>truncation point (numeric)</p>
</td></tr>
<tr><td><code id="getLow+2B2CgetUp_+3A_...">...</code></td>
<td>
<p>for convenience only; makes it possible to call <code>getLow</code>, 
<code>getUp</code> with argument <code>eps</code> no matter of the class of <code>object</code>;
is ignored in these functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>getLow</code>, <code>getUp</code></td>
<td>
<p>a <code>numeric</code> of length 1</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>

<hr>
<h2 id='Huberize-methods'> Methods for function Huberize in Package &lsquo;distr&rsquo; </h2><span id='topic+Huberize-methods'></span><span id='topic+Huberize'></span><span id='topic+Huberize+2CAcDcLcDistribution-method'></span>

<h3>Description</h3>

<p>Huberize-methods</p>


<h3>Usage</h3>

<pre><code class='language-R'>Huberize(object, ...)
## S4 method for signature 'AcDcLcDistribution'
Huberize(object,lower,upper,
                    withSimplify = getdistrOption("simplifyD"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Huberize-methods_+3A_object">object</code></td>
<td>
<p>distribution object</p>
</td></tr>
<tr><td><code id="Huberize-methods_+3A_...">...</code></td>
<td>
<p>further arguments for <code>Huberize</code>; takes up <code>lower</code>, 
<code>upper</code>, <code>withSimplify</code>.</p>
</td></tr>
<tr><td><code id="Huberize-methods_+3A_lower">lower</code></td>
<td>
<p>numeric; lower truncation point</p>
</td></tr>
<tr><td><code id="Huberize-methods_+3A_upper">upper</code></td>
<td>
<p>numeric; upper truncation point</p>
</td></tr>
<tr><td><code id="Huberize-methods_+3A_withsimplify">withSimplify</code></td>
<td>
<p>logical; is result to be piped through a call to
<code><a href="#topic+simplifyD">simplifyD</a></code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the corresponding distribution of the truncated random variable</p>


<h3>Methods</h3>


<dl>
<dt>Huberize</dt><dd><p><code>signature(object = "AcDcLcDistribution")</code>:
returns the unconditioned
distribution of <code>min(upper,max(X,lower))</code>, if <code>X</code> is
distributed according to <code>object</code>;
the result is of class <code>"UnivarLebDecDistribution"</code> in general.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+Truncate">Truncate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Hub &lt;- Huberize(Norm(),lower=-1,upper=2)
Hub 
plot(Hub)
</code></pre>

<hr>
<h2 id='Hyper-class'>Class &quot;Hyper&quot; </h2><span id='topic+Hyper-class'></span><span id='topic+Hyper'></span><span id='topic+initialize+2CHyper-method'></span>

<h3>Description</h3>

<p> The hypergeometric distribution is used for sampling <em>without</em> 
replacement. The density of this distribution with parameters
<code>m</code>, <code>n</code> and <code>k</code> (named <code class="reqn">Np</code>, <code class="reqn">N-Np</code>, and
<code class="reqn">n</code>, respectively in the reference below) is given by
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \left. {m \choose x}{n \choose k-x} \right/ {m+n \choose k}%
  </code>
</p>

<p>for <code class="reqn">x = 0, \ldots, k</code>.
C.f. <code><a href="stats.html#topic+Hypergeometric">rhyper</a></code> 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Hyper(m, n, k)</code>.
This object is a hypergeometric distribution. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Naturals"</code>: The space of the image of this
distribution has got dimension 1 and the name &quot;Natural Space&quot;. </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"HyperParameter"</code>: the parameter of this distribution (<code>m</code>, <code>n</code>, <code>k</code>),
declared at its instantiation </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: generates random numbers (calls function <code>rhyper</code>) </p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>: density function (calls function <code>dhyper</code>) </p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>: cumulative function (calls function <code>phyper</code>) </p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>: inverse of the cumulative function (calls function <code>qhyper</code>).
The <code class="reqn">\alpha</code>-quantile is defined as the smallest value <code class="reqn">x</code> such that 
<code class="reqn">p(x) \ge \alpha]</code>, where <code class="reqn">p</code> is the cumulative function. </p>
</dd>
<dt><code>support</code>:</dt><dd><p>Object of class <code>"numeric"</code>: a (sorted) vector containing the support of the discrete
density function</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"DiscreteDistribution"</code>, directly.<br />
Class <code>"UnivariateDistribution"</code>, by class <code>"DiscreteDistribution"</code>.<br />
Class <code>"Distribution"</code>, by class <code>"DiscreteDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "Hyper")</code>: initialize method </p>
</dd>
<dt>m</dt><dd><p><code>signature(object = "Hyper")</code>: returns the slot <code>m</code> of the parameter of the distribution </p>
</dd>
<dt>m&lt;-</dt><dd><p><code>signature(object = "Hyper")</code>: modifies the slot <code>m</code> of the parameter of the distribution </p>
</dd>
<dt>n</dt><dd><p><code>signature(object = "Hyper")</code>: returns the slot <code>n</code> of the parameter of the distribution </p>
</dd>
<dt>n&lt;-</dt><dd><p><code>signature(object = "Hyper")</code>: modifies the slot <code>n</code> of the parameter of the distribution </p>
</dd>
<dt>k</dt><dd><p><code>signature(object = "Hyper")</code>: returns the slot <code>k</code> of the parameter of the distribution </p>
</dd>
<dt>k&lt;-</dt><dd><p><code>signature(object = "Hyper")</code>: modifies the slot <code>k</code> of the parameter of the distribution </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HyperParameter-class">HyperParameter-class</a></code>
<code><a href="#topic+DiscreteDistribution-class">DiscreteDistribution-class</a></code>
<code><a href="#topic+Naturals-class">Naturals-class</a></code>
<code><a href="stats.html#topic+Hypergeometric">rhyper</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>H &lt;- Hyper(m=3,n=3,k=3) # H is a hypergeometric distribution with m=3,n=3,k=3.
r(H)(1) # one random number generated from this distribution, e.g. 2
d(H)(1) # Density of this distribution is  0.45 for x=1.
p(H)(1) # Probability that x&lt;1 is 0.5.
q(H)(.1) # x=1 is the smallest value x such that p(H)(x)&gt;=0.1.
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
m(H) # m of this distribution is 3.
m(H) &lt;- 2 # m of this distribution is now 2.
</code></pre>

<hr>
<h2 id='HyperParameter-class'>Class &quot;HyperParameter&quot;</h2><span id='topic+HyperParameter-class'></span><span id='topic+initialize+2CHyperParameter-method'></span>

<h3>Description</h3>

<p> The parameter of a hypergeometric distribution, used by <code>Hyper</code>-class</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("HyperParameter", k, m, n)</code>.
Usually an object of this class is not needed on its own, it is generated automatically when an object of the class <code>Hyper</code>
is instantiated. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>k</code></dt><dd><p>Object of class <code>"numeric"</code>: k of a hypergeometric distribution </p>
</dd>
<dt><code>m</code></dt><dd><p>Object of class <code>"numeric"</code>: m of a hypergeometric distribution </p>
</dd>
<dt><code>n</code></dt><dd><p>Object of class <code>"numeric"</code>: n of a hypergeometric distribution </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: a name / comment for the parameters </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "HyperParameter")</code>: initialize method </p>
</dd>
<dt>k</dt><dd><p><code>signature(object = "HyperParameter")</code>: returns the slot <code>k</code> of the parameter of the distribution </p>
</dd>
<dt>k&lt;-</dt><dd><p><code>signature(object = "HyperParameter")</code>: modifies the slot <code>k</code> of the parameter of the distribution </p>
</dd>
<dt>m</dt><dd><p><code>signature(object = "HyperParameter")</code>: returns the slot <code>m</code> of the parameter of the distribution </p>
</dd>
<dt>m&lt;-</dt><dd><p><code>signature(object = "HyperParameter")</code>: modifies the slot <code>m</code> of the parameter of the distribution </p>
</dd>
<dt>n</dt><dd><p><code>signature(object = "HyperParameter")</code>: returns the slot <code>n</code> of the parameter of the distribution </p>
</dd>
<dt>n&lt;-</dt><dd><p><code>signature(object = "HyperParameter")</code>: modifies the slot <code>n</code> of the parameter of the distribution </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hyper-class">Hyper-class</a></code>
<code><a href="#topic+Parameter-class">Parameter-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- new("HyperParameter",k=3, m=3, n=3)
m(W) # m of this distribution is 3.
m(W) &lt;- 2 # m of this distribution is now 2.
</code></pre>

<hr>
<h2 id='igamma'>Inverse of the digamma function</h2><span id='topic+igamma'></span>

<h3>Description</h3>

<p>Function <code>igamma</code> is a numerical inverse of <code>digamma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igamma(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igamma_+3A_v">v</code></td>
<td>
<p> a numeric in the range [-100000,18] </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>igamma</code> is vectorized;  it is won
by spline inversion of a grid; it works well for range 
[digamma(1e-5);digamma(1e8)] or [-100000,18].
</p>


<h3>Value</h3>

<p><code>igamma(x)</code> is a value <code>u</code> such that <code>digamma(u</code> is approximately <code>x</code>.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code>digamma</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>igamma(digamma(c(1e-4,1,20,1e8)))
</code></pre>

<hr>
<h2 id='img-methods'> Methods for Function img in Package &lsquo;distr&rsquo;</h2><span id='topic+img-methods'></span><span id='topic+img'></span><span id='topic+img+2CDistribution-method'></span>

<h3>Description</h3>

<p>img-methods</p>


<h3>Methods</h3>


<dl>
<dt>img</dt><dd><p><code>signature(object  = "Distribution")</code>: returns the image space / domain of the distribution </p>
</dd>
</dl>

<hr>
<h2 id='Integer-class'>Internal Class &quot;Integer&quot;</h2><span id='topic+Integer-class'></span><span id='topic+coerce+2Cnumeric+2CInteger-method'></span>

<h3>Description</h3>

<p>For the ease of method dispatch, there is an internal
S4 class <code>Integer</code>, which is a subclass of <code>numeric</code> and has a 
straightforward validity method.</p>


<h3>Objects from the Class</h3>

<p>new(&quot;Integer&quot;,
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p>Object of class <code>"numeric"</code></p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="methods.html#topic+numeric-class">numeric</a>"</code>, from data part.
Class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class &quot;numeric&quot;, distance 2.
</p>


<h3>Methods</h3>

   <dl>
<dt>coerce</dt><dd><p><code>signature(from = "numeric", to = "Integer")</code>:
create a <code>"Integer"</code> object from a <code>"numeric"</code> vector.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+numeric">numeric</a></code>, <code><a href="base.html#topic+vector">vector</a></code>
</p>

<hr>
<h2 id='InternalClassUnions'>Class unions in 'distr'</h2><span id='topic+InternalClassUnions'></span><span id='topic+OptionalNumeric-class'></span>

<h3>Description</h3>

<p>Class unions in package <span class="pkg">distr</span> defined for internal 
purposes; these are <code>OptionalNumeric</code>,</p>


<h3>Details</h3>

<p>These classes are used internally to make available methods or to allow
slots of classes to be filled with varying types. In particular
</p>

<ul>
<li> <p><code>"OptionalNumeric"</code>: may contain objects of class  <code>"numeric"</code>
or <code>"NULL"</code>; it is used e.g. for slot <code>nuisance</code> of class
<code>"ParamFamParameter"</code>, as it may or may not be present but if so
it has to be numeric.
</p>
</li></ul>



<h3>Objects from the Class</h3>

<p>All of these classes are virtual: 
No objects may be created from them.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="methods.html#topic+BasicClasses">numeric-class</a></code>,
</p>

<hr>
<h2 id='internalGenerics'>Internal: Common Generics 'distribution' and 'samplesize', 'samplesize&lt;-'</h2><span id='topic+internalGenerics'></span><span id='topic+distribution'></span><span id='topic+samplesize'></span><span id='topic+samplesize+3C-'></span>

<h3>Description</h3>

<p>In order to be able to use packages <span class="pkg">distrSim</span> and <span class="pkg">distrMod</span>
resp. <span class="pkg">RobAStBase</span> independently,
it is necessary to import the respective generic from a prior package, i.e.,
<span class="pkg">distr</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distribution(object)
samplesize(object, ...)
samplesize(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internalGenerics_+3A_object">object</code></td>
<td>
<p> the first argument to dispatch on in the actual methods. </p>
</td></tr>
<tr><td><code id="internalGenerics_+3A_value">value</code></td>
<td>
<p> the value to be assigned. </p>
</td></tr>
<tr><td><code id="internalGenerics_+3A_...">...</code></td>
<td>
<p> additional arguments for function <code>samplesize</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>

<hr>
<h2 id='internals_for_distr'>Internal functions of package distr</h2><span id='topic+internals_for_distr'></span><span id='topic+.is.vector.lattice'></span><span id='topic+.is.consistent'></span><span id='topic+.isInteger'></span><span id='topic+.isNatural'></span><span id='topic+.isNatural0'></span><span id='topic+.mergegaps'></span><span id='topic+.mergegaps2'></span><span id='topic+.pmixfun'></span><span id='topic+.dmixfun'></span><span id='topic+.qmixfun'></span><span id='topic+.rmixfun'></span><span id='topic+.del0dmixfun'></span><span id='topic+.ULC.cast'></span><span id='topic+.loupmixfun'></span><span id='topic+.make.lattice.es.vector'></span><span id='topic+.presubs'></span><span id='topic+.inArgs'></span><span id='topic+.EuclidAlgo'></span><span id='topic+.getCommonWidth'></span><span id='topic+.isEqual'></span><span id='topic+.isIn'></span><span id='topic+.setEqual'></span><span id='topic+.isEqual01'></span><span id='topic+.makeD'></span><span id='topic+.makeP'></span><span id='topic+.makeQ'></span><span id='topic+.makeDNew'></span><span id='topic+.makePNew'></span><span id='topic+.makeQNew'></span><span id='topic+.makeDd'></span><span id='topic+.makePd'></span><span id='topic+.makeQd'></span><span id='topic+.makeQc'></span><span id='topic+.fM2'></span><span id='topic+.fM'></span><span id='topic+.fm'></span><span id='topic+.notwithLArg'></span><span id='topic+.multm'></span><span id='topic+.plusm'></span><span id='topic+.getObjName'></span><span id='topic+.discretizeP'></span><span id='topic+.expm.d'></span><span id='topic+.expm.c'></span><span id='topic+.logm.d'></span><span id='topic+.logm.c'></span><span id='topic+.P2D'></span><span id='topic+.P2Q'></span><span id='topic+.D2P'></span><span id='topic+.Q2P'></span><span id='topic+.csimpsum'></span><span id='topic+.primefun'></span><span id='topic+.IssueWarn'></span><span id='topic+.fillList'></span><span id='topic+.trunc.up'></span><span id='topic+.trunc.low'></span><span id='topic+.modifyqgaps'></span><span id='topic+.DistrCollapse'></span><span id='topic+.convDiscrDiscr'></span><span id='topic+.inWithTol'></span><span id='topic+.panel.mingle'></span><span id='topic+.consolidategaps'></span><span id='topic+.List'></span><span id='topic+devNew'></span>

<h3>Description</h3>

<p>These functions are used internally by package distr.</p>


<h3>Usage</h3>

<pre><code class='language-R'>.is.vector.lattice(x)
.is.consistent(lattice, support, eq.space = TRUE)
.make.lattice.es.vector(x)
.inArgs(arg, fct)
.isEqual(p0, p1, tol = min( getdistrOption("TruncQuantile")/2,
                                          .Machine$double.eps^.7))
.isEqual01(x)
.isIn(p0, pmat, tol = min( getdistrOption("TruncQuantile")/2,
                                          .Machine$double.eps^.7
                                          ))
.isInteger(x, tol = .Machine$double.eps)
.isNatural(x, tol = .Machine$double.eps)
.isNatural0(x, tol = .Machine$double.eps)
.setEqual(x, y, tol = 1e-7)
.presubs(inp, frompat, topat)
.makeD(object, argList,  stand = NULL, fac = NULL)
.makeP(object, argList,  sign = TRUE, correct = NULL, fac =
                 NULL, fac2 = NULL)
.makeQ(object, lastCall, sign = TRUE, Cont = TRUE)
.plusm(e1, e2, Dclass = "DiscreteDistribution")
.multm(e1, e2, Dclass = "DiscreteDistribution")
.notwithLArg(D)
.getObjName(i = 1)
.discretizeP(D, lower, upper, h)
.fm(x,f)
.fM(x,f)
.fM2(x,f)
.makeDd(x,y, yleft, yright)
.makePd(x,y, yleft, yright)
.makeQd(x,y, yleft, yright)
.makeQc(x,y, yleft, yright)
.makeDNew(x, dx, h = NULL, Cont = TRUE, standM = "sum")
.makePNew(x, dx, h = NULL, notwithLLarg = FALSE,
                      Cont = TRUE, myPf = NULL, pxl = NULL, pxu = NULL)
.makeQNew(x, px.l, px.u, notwithLLarg = FALSE, yL , yR, Cont = TRUE)
.mergegaps(gaps, support)
.mergegaps2(gaps1, gaps2)
.consolidategaps(gaps)
.pmixfun(mixDistr, mixCoeff, leftright = "right")
.dmixfun(mixDistr, mixCoeff, withStand = FALSE, supp = NULL)
.rmixfun(mixDistr, mixCoeff)
.qmixfun(mixDistr, mixCoeff, Cont = TRUE, pnew, gaps = NULL, leftright = "left")
.del0dmixfun(mixDistr)
.loupmixfun(mixDistr)
.ULC.cast(x)
.expm.d(e1)
.expm.c(e1)
.logm.d(e1)
.logm.c(e1)
.P2D (p, xx, ql, qu, ngrid = getdistrOption("DefaultNrGridPoints"))
.P2Q (p, xx, ql,qu, ngrid = getdistrOption("DefaultNrGridPoints"), 
                qL = -Inf, qU = Inf)
.D2P (d, xx, ql, qu,  ngrid = getdistrOption("DefaultNrGridPoints"))
.Q2P (q, ngrid = getdistrOption("DefaultNrGridPoints"))
.csimpsum(fx)
.primefun(f,x, nm = NULL)
.IssueWarn(Arith,Sim)
.List(list0)
.fillList(list0, len=length(list0))
.trunc.up(object, upper)
.trunc.low(object, lower)
.modifyqgaps(pfun, qfun, gaps, leftright = "left")
.DistrCollapse(support, prob, eps = getdistrOption("DistrResolution"))
.EuclidAlgo(n1,n2)
.getCommonWidth(x1,x2, tol=.Machine$double.eps)
.convDiscrDiscr(e1,e2)
.inWithTol(x,y,tol=.Machine$double.eps)
.panel.mingle(dots,element)
devNew(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internals_for_distr_+3A_x">x</code></td>
<td>
<p>a (numeric) vector, or (in case of <code>.ULC.cast</code>) an object of class <code>"AcDcLcDistribution"</code></p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_y">y</code></td>
<td>
<p>a (numeric) vector</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_f">f</code></td>
<td>
<p>in function <code>.primefun</code>: a function in one (numeric) argument; 
in functions <code>.fm</code>, <code>.fM</code>, <code>.fM2</code> a vector of function evaluations</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_lattice">lattice</code></td>
<td>
<p>a lattice (of class <code>Lattice</code>)</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_support">support</code></td>
<td>
<p>a support vector / support vector of a univariate discrete distribution</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_eq.space">eq.space</code></td>
<td>
<p>logical: shall we check for the support to be equally spaced?</p>
</td></tr> 
<tr><td><code id="internals_for_distr_+3A_arg">arg</code></td>
<td>
<p>a formal argument as character</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_fct">fct</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_p0">p0</code>, <code id="internals_for_distr_+3A_p1">p1</code></td>
<td>
<p>(numeric) vectors</p>
</td></tr> 
<tr><td><code id="internals_for_distr_+3A_pmat">pmat</code></td>
<td>
<p>(matrix) a matrix with two columns where row-wise the left column
is smaller than the right one</p>
</td></tr> 
<tr><td><code id="internals_for_distr_+3A_tol">tol</code></td>
<td>
<p>an error tolerance (numeric)</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_e1">e1</code></td>
<td>
<p>a distribution object</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_e2">e2</code></td>
<td>
<p>a numeric</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_object">object</code></td>
<td>
<p>a distribution object</p>
</td></tr>  
<tr><td><code id="internals_for_distr_+3A_arglist">argList</code></td>
<td>
<p>an (unevaluated) list of arguments passed to <code>m(object)</code>  
where  <code>m</code> is in <code>d,p,q</code></p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_stand">stand</code></td>
<td>
<p>factor for a (Lebesgue) density to integrate to 1</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_sign">sign</code></td>
<td>
<p>the sign of the second operand &mdash; for multiplication at 
the moment</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_correct">correct</code></td>
<td>
<p>unevaluated R-code to correct for right-continuity 
(for multiplication with negative numerics at the moment)</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_fac">fac</code></td>
<td>
<p>factor to be multiplied with the return value</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_fac2">fac2</code></td>
<td>
<p>factor to be added to the return value</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_lastcall">lastCall</code></td>
<td>
<p>unevaluated R-Code &mdash;gives how the result of a call to 
<code>q(e1)</code> is further transformed</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_cont">Cont</code></td>
<td>
<p>logical: <code>TRUE</code> if <code>object</code> is continuous</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_dclass">Dclass</code></td>
<td>
<p>character: name of distribution class</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_d">D</code></td>
<td>
<p>a distribution object</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_i">i</code></td>
<td>
<p>an integer</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_yleft">yleft</code>, <code id="internals_for_distr_+3A_yright">yright</code></td>
<td>
<p>extrapolation value beyond left/right endpoint of grid</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_h">h</code></td>
<td>
<p>numeric: grid width</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_standm">standM</code></td>
<td>
<p>standardization method &mdash; summation or integration</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_notwithllarg">notwithLLarg</code></td>
<td>
<p>logical &mdash; can we use <code>log.p</code>, <code>lower.tail</code> 
arguments for <code>p,q</code>-methods of first operand?</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_dx">dx</code></td>
<td>
<p>numeric: vector of cell-probabilities for the (discretized) 
distribution</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_mypf">myPf</code></td>
<td>
<p>function with args <code>x,y, yleft, yright</code> 
(as <code>approxfun</code>): 
if given: replaces <code>approxfun</code> as interpolation method for 
continuos distributions</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_pxl">pxl</code>, <code id="internals_for_distr_+3A_pxu">pxu</code></td>
<td>
<p>numeric: if given vector of (lower/upper) cumulative 
probabilities</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_yl">yL</code>, <code id="internals_for_distr_+3A_yr">yR</code></td>
<td>
<p>argmin / argmax of p()-method</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_inp">inp</code></td>
<td>
<p>either a language object or a character vector</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_frompat">frompat</code></td>
<td>
<p>vector of character strings containing regular expressions (or
character string for <code>fixed = TRUE</code>) to be matched in the
given character vector.  Coerced by <code>as.character</code> to a
character string if possible; (as argument <code>pattern</code> in 
<code><a href="base.html#topic+gsub">gsub</a></code> &mdash; but possibly of length &gt;1).</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_topat">topat</code></td>
<td>
<p> a (vector of) replacement(s) for matched pattern in 
<code>.presubs</code>. 
Coerced to character if possible.  For <code>fixed = FALSE</code> this
can include backreferences <code>"\1"</code> to <code>"\9"</code> to 
parenthesized subexpressions of <code>pattern</code>.  For 
<code>perl = TRUE</code> only, it can
also contain <code>"\U"</code> or <code>"\L"</code> to convert the rest of the
replacement to upper or lower case; (as argument <code>replacement</code> 
in <code><a href="base.html#topic+gsub">gsub</a></code>&mdash; but possibly of length &gt;1).</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_gaps">gaps</code>, <code id="internals_for_distr_+3A_gaps1">gaps1</code>, <code id="internals_for_distr_+3A_gaps2">gaps2</code></td>
<td>
<p>matrices <code>m</code> with two columns, 
such that <code>t(m)</code>, interpreted as vector, is ordered</p>
</td></tr>         
<tr><td><code id="internals_for_distr_+3A_prob">prob</code></td>
<td>
<p>probability vector for a univariate discrete distribution</p>
</td></tr>         
<tr><td><code id="internals_for_distr_+3A_mixdistr">mixDistr</code></td>
<td>
<p>an object of class <code>UnivarDistrList</code></p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_mixcoeff">mixCoeff</code></td>
<td>
<p>an object of class <code>numeric</code>; a probability vector</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_pnew">pnew</code></td>
<td>
<p>a function <code>function(q, lower.tail = TRUE, log.p = FALSE</code>
realizing slot <code>p</code> in a distribution object.</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_withstand">withStand</code></td>
<td>
<p>logical; if <code>TRUE</code> a standardization is made such
that the sum of the values of the result evaluated at argument <code>supp</code> is 1</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_supp">supp</code></td>
<td>
<p>NULL or <code>numeric</code>; if <code>withStand</code> is <code>TRUE</code> used
to standardize such that the result is a probability density.</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_p">p</code>, <code id="internals_for_distr_+3A_pfun">pfun</code></td>
<td>
<p>slot <code>p</code> of an object of class <code>"AbscontDistribution"</code></p>
</td></tr> 
<tr><td><code id="internals_for_distr_+3A_d">d</code></td>
<td>
<p>slot <code>d</code> of an object of class <code>"AbscontDistribution"</code></p>
</td></tr> 
<tr><td><code id="internals_for_distr_+3A_q">q</code>, <code id="internals_for_distr_+3A_qfun">qfun</code></td>
<td>
<p>slot <code>q</code> of an object of class <code>"AbscontDistribution"</code></p>
</td></tr> 
<tr><td><code id="internals_for_distr_+3A_xx">xx</code></td>
<td>
<p>a given grid of x-values for functions <code>p</code>, <code>d</code> to be
evaluated at</p>
</td></tr>  
<tr><td><code id="internals_for_distr_+3A_ql">ql</code>, <code id="internals_for_distr_+3A_qu">qu</code></td>
<td>
<p>lower and upper <code>getdistrOption("TruncQuantile")</code>-quantile of
the distribution; also, if argument <code>xx</code> is missing, left and right endpoint
of a regular grid of <code>ngrid</code> gridpoints to be used in place of <code>xx</code>.</p>
</td></tr>  
<tr><td><code id="internals_for_distr_+3A_ql">qL</code>, <code id="internals_for_distr_+3A_qu">qU</code></td>
<td>
<p>argmin / argmax of p()-method</p>
</td></tr>  
<tr><td><code id="internals_for_distr_+3A_ngrid">ngrid</code></td>
<td>
<p>number of gridpoints</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_fx">fx</code></td>
<td>
<p>a vector of function evaluations multiplied by the gridwidth</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_nm">nm</code></td>
<td>
<p>an optional right asymptotic value</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_arith">Arith</code></td>
<td>
<p>logical; slot <code>.withArith</code> of a distribution object,
or logically-&ldquo;any&rdquo; of these slots in a collection of such objects</p>
</td></tr> 
<tr><td><code id="internals_for_distr_+3A_sim">Sim</code></td>
<td>
<p>logical; slot <code>.withSim</code> of a distribution object,
or logically-&ldquo;any&rdquo; of these slots in a collection of such objects</p>
</td></tr> 
<tr><td><code id="internals_for_distr_+3A_list0">list0</code></td>
<td>
<p>list, the elements of which are to be copied to a new list using
recycling if necessary</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_len">len</code></td>
<td>
<p>length of the list to be filled</p>
</td></tr>              
<tr><td><code id="internals_for_distr_+3A_lower">lower</code></td>
<td>
<p>lower truncation point</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_upper">upper</code></td>
<td>
<p>upper truncation point</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_leftright">leftright</code></td>
<td>
<p>character; for slot <code>q</code>: if partially matched to <code>"right"</code> 
function will return the right continuous version, else
the left continuous version; for slot <code>p</code>: if partially 
matched to <code>"left"</code> the left continuous version, else
the right continuous version;</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_n1">n1</code></td>
<td>
<p>integer argument for <code>.EuclidAlgo</code></p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_n2">n2</code></td>
<td>
<p>integer argument for <code>.EuclidAlgo</code></p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_x1">x1</code></td>
<td>
<p>width argument for <code>.getCommonWidth</code></p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_x2">x2</code></td>
<td>
<p>width argument for <code>.getCommonWidth</code></p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_dots">dots</code></td>
<td>
<p>the unevaluated <code>...</code> argument</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_element">element</code></td>
<td>
<p>the name of the item in the unevaluated <code>...</code> argument</p>
</td></tr>
<tr><td><code id="internals_for_distr_+3A_...">...</code></td>
<td>
<p>arguments passed through to other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.is.vector.lattice</code> checks whether a given vector <code>x</code> is equally 
spaced.
<code>.is.consistent</code> checks whether a given support vector <code>support</code> is 
consistent to a given lattice <code>lattice</code> &mdash; with or without checking
if <code>support</code> is equally spaced.  <code>.make.lattice.es.vector</code> 
makes an object of class <code>Lattice</code> out of a given (equally spaced) vector 
<code>x</code>.
</p>
<p><code>.inArgs</code> checks whether an argument <code>arg</code> is a formal argument of 
<code>fct</code> &mdash; not vectorized.
</p>
<p><code>.isEqual</code> checks whether <code>p0</code> and <code>p1</code> are equal to given
tolerance.
<code>.isIn</code> checks whether <code>p0</code> lies in any of the intervals given by
matrix <code>pmat</code> to given tolerance.
<code>.isEqual01</code>(x) checks whether <code>x</code> is 0 or 1 to given tolerance. 
<code>.setEqual</code> sets all elements of x which are equal to some element of y 
up to tolerance tol, to exactly the respective element of y. 
</p>
<p><code>.notwithLArg</code> checks whether object <code>D</code> was generated by simulations 
or if its slots <code>p,q</code> do not have <code>lower.tail</code> arguments.
</p>
<p><code>.getObjName</code> returns the name of the object in the <code>i</code>th operand.
<code>.discretizeP</code> discretizes <code>D</code> to a grid of probabilities from 
<code>lower</code> to <code>upper</code> with width <code>h</code>.   
</p>
<p><code>.fm</code>, <code>.fM</code> return the smallest / biggest value in (0,1) such that
<code>f</code>(x) is finite; <code>.fM2</code> is a variant of <code>.fM</code> using a 
<code>lower.tail = FALSE</code> argument.
</p>
<p><code>.makeD</code>, <code>.makeP</code>, <code>.makeQ</code> generate slots <code>p,d,q</code> for
binary operations <code>e1 /op/ e2</code> for a distribution object <code>e1</code> 
and a numeric <code>e2</code> &mdash;for the moment only <code>/op/</code>'s 
<code>+,-,*,/</code> are implemented.
</p>
<p><code>.plusm</code>, <code>.multm</code> more specifically use <code>.makeD</code>, <code>.makeP</code>, 
<code>.makeQ</code> to generate slots <code>p,d,q</code> for <code>+</code>, <code>*</code>, 
respectively. 
</p>
<p><code>.makeDd</code>, <code>.makePd</code>, <code>.makeQd</code> provide discrete analogues to 
<code>approxfun</code> for interpolation at non grid-values 
</p>
<p><code>.makeQc</code> is an analogue to <code>makeQd</code> for absolutely continuous 
distributions using <code>approxfun</code>. 
</p>
<p><code>.makeDNew</code> generates slot <code>d</code> for a new distribution object.
In case of a discrete distribution it produces a step function with 
<code>stepfun</code> (using <code>.makeDd</code>) and standardizes to 1 by summation.
In case of a continuous distribution it produces a density function with 
<code>approxfun</code> and standardizes to 1 by integration if the latter fails,
it uses a trapezoid rule / summation for this purpose.
</p>
<p><code>.makePNew</code> generates slot <code>p</code> for a new distribution object.
In case of a discrete distribution it produces a step function from 
<code>cumsum</code> applied to <code>dx</code> &mdash;or from <code>pxl</code> if this is given, with 
<code>stepfun</code> (using <code>.makePd</code>). 
In case of a continuous distribution it produces a cdf with 
<code>approxfun</code>. In case of <code>RtoDPQ</code>, <code>approxfun</code> is replaced by
<code>myPf</code> which calls <code>ecdf</code> directly.
</p>
<p><code>.makeQNew</code> generates slot <code>q</code> for a new distribution object.
In case of a discrete distribution it produces a step function 
(using <code>.makeQd</code>). Special care is taken for left continuity...
In case of a continuous distribution it produces a quantile function with 
<code>approxfun</code>. 
</p>
<p><code>.isInteger</code>, <code>.isNatural</code>, and <code>.isNatural0</code> test for each 
coordinate of argument <code>x</code> whether it
is integer [natural / natural or 0] or not.
</p>
<p><code>.mergegaps</code> modifies the gaps matrix of an a.c. distribution according to
the support slot of a discrete distribution; if necessary, a gap interval
[a,b] is split into [a,c],[c,b] if <code>a&lt;c&lt;b</code>.
<code>.mergegaps2</code> merges two gap matrices of two a.c. distributions <code>X1</code> 
and <code>X2</code> such that in the intervals of the resulting gap matrix, 
neither <code>X1</code> nor <code>X2</code> carries mass.
<code>.consolidategaps</code> consolidates a gap matrix, i.e. joins adjacent 
gap intervals.  
</p>
<p><code>.pmixfun</code>, <code>.dmixfun</code>, <code>.rmixfun</code>, and <code>.qmixfun</code>
fill the slots <code>p</code>, <code>d</code>, <code>r</code>, and <code>q</code>
of a corresponding mixing distribution according to the arguments
in <code>mixDistr</code>, <code>mixCoeff</code>.
</p>
<p><code>.loupmixfun</code> finds commun lower and upper bounds for the support of
the mixing distribution.
</p>
<p><code>.del0dmixfun</code> sets (if slot <code>d.ac</code> is not <code>NULL</code>) the return
value of slot function <code>d.ac</code> of <code>mixDistr</code> 
for argument <code>0</code> to <code>0</code>.
</p>
<p><code>.ULC.cast</code> coerces an object of class <code>"AcDcLcDistribution"</code> to
class <code>"UnivarLebDecDistribution"</code>, using <code>simplifyD</code>.
</p>
<p><code>.expm.d,.expm.c</code> for discrete, resp. a.c. argument <code>e1</code> fill the 
slots <code>p</code>, <code>d</code>, <code>r</code>, and <code>q</code>
of the transformation <code>exp(e1)</code> exactly.
<code>.logm.d,.logm.c</code> for discrete, resp. a.c. argument <code>e1</code> fill the 
slots <code>p</code>, <code>d</code>, <code>r</code>, and <code>q</code>
of the transformation <code>log(e1)</code> exactly.
</p>
<p>For objects of class <code><a href="#topic+AbscontDistribution">AbscontDistribution</a></code>,
<code>.P2D</code> and <code>.P2Q</code> reconstruct function slots <code>d</code> resp. 
<code>q</code> from function slot <code>p</code>
by means of function <code>D1ss</code> from package <span class="pkg">sfsmisc</span>;
and of function <code>.makeQNew</code>,  respectively. The other way round, 
<code>.D2P</code> and <code>.Q2P</code> reconstruct function slot <code>p</code> from 
from function slots  <code>d</code> resp. <code>q</code> 
by means of function <code>.makePNew</code> and explicite numeric inversion,  
respectively.
</p>
<p><code>.csimpsum</code> is used internally in <code>.makePNew</code> to produce
a primitive function out of function evaluations by means of vectorized
Simpson quadrature method, returning already the function values
of the prime function on a grid; it is to mimick the behaviour
of <code>cumsum</code>. <code>.primefun</code> is similar but more flexible and
produces the prime function as a function.
</p>
<p><code>.List</code> checks if argument already is a list, and if so leaves it as
it is, otherwise casts it to a list by a call to <code>list</code>.
</p>
<p><code>.fillList</code> fills a new list with the elements of a given list <code>list0</code>
until length <code>len</code> is reached using recycling if necessary.
Argument <code>list0</code> is cast to <code>list</code> by a call
to <code>.List</code> if necessary.
</p>
<p><code>.trunc.up</code>, <code>.trunc.low</code>  provide common routines for
classes <code>DiscreteDistribution</code> and <code>AbscontDistribution</code> for 
one-sided truncation, using (for slot <code>r</code>) Peter Dalgaard's clever 
log-tricks as indicated in 
<a href="https://stat.ethz.ch/pipermail/r-help/2008-September/174321.html">https://stat.ethz.ch/pipermail/r-help/2008-September/174321.html</a>.
</p>
<p><code>.modifyqgaps</code> modifies slot <code>q</code> for objects of class 
<code>AbscontDistribution</code> in the presence of gaps, i.e.; if slot
<code>gaps</code> is not <code>NULL</code>. If argument <code>leftright</code> does not
partially match <code>"right"</code> (default) returns the left continuous
version of the quantile function, else the right continuous one.
</p>
<p><code>.EuclidAlgo</code> computes the greatest common divisor of two integers by 
means of the Euclidean algorithm.
<code>.getCommonWidth</code> for two lattices with widths <code>x1</code> and <code>x2</code>
computes the smallest common lattice width for convolution.
<code>.convDiscrDiscr</code> computes the convolution of two discrete distributions by
brute force.
<code>.inWithTol</code> works like <code>%in%</code> but with a given tolerance.
</p>
<p><code>.panel.mingle</code> is used for mingling arguments <code>panel.first</code>,
<code>panel.last</code> in a plot; it returns the evaluated argument <code>element</code>
within dots, if it is a symbol; else if it can be interpreted as a call, and if
the top call is <code>list</code>, it returns a list of the items of the call to <code>list</code>,
unevaluated, and otherwise the unchanged argument.
</p>
<p><code>devNew</code> opens a new device. This function is for back compatibility
with R versions &lt; 2.8.0. To control the number of opened devices, when
<code>length(dev.list())&gt;20</code>, in interactive mode we ask the user to shut
some windows until <code>length(dev.list())&lt;=20</code>; in non-interactive mode
we shut the first 15 open devices (except for the first one) before opening
a new one.
</p>


<h3>Value</h3>

<table>
<tr><td><code>.is.vector.lattice</code></td>
<td>
<p><code>logical</code> (length 1).</p>
</td></tr>
<tr><td><code>.is.consistent</code></td>
<td>
<p><code>logical</code> (length 1).</p>
</td></tr>
<tr><td><code>.notwithLArg</code></td>
<td>
<p><code>logical</code> (length 1).</p>
</td></tr>
<tr><td><code>.make.lattice.es.vector</code></td>
<td>
<p>an object of class <code>Lattice</code>.</p>
</td></tr>
<tr><td><code>.inArgs</code></td>
<td>
<p><code>logical</code> (length 1).</p>
</td></tr>
<tr><td><code>.isIn</code>, <code>.isEqual</code>, <code>.isEqual01</code></td>
<td>
<p>vector of <code>logical</code>.</p>
</td></tr>
<tr><td><code>.fm</code>, <code>.fM</code>, <code>.fM2</code></td>
<td>
<p>a <code>numeric</code> of length 1.</p>
</td></tr>
<tr><td><code>.plusm</code>, <code>.multm</code></td>
<td>
<p>an object of class <code>DiscreteDistribution</code> or 
<code>AbscontDistribution</code> according to argument <code>DClass</code>.</p>
</td></tr>
<tr><td><code>.getObjName</code></td>
<td>
<p><code>character</code>.</p>
</td></tr>
<tr><td><code>.discretizeP</code></td>
<td>
<p><code>numeric</code> &mdash; the probabilities for the grid-values.</p>
</td></tr>
<tr><td><code>.makeDd</code>, <code>.makePd</code>, <code>.makeQd</code></td>
<td>
<p>a function with args 
<code>x, y, yleft, yright</code>.</p>
</td></tr>
<tr><td><code>.makeD</code>, <code>.makeDNew</code></td>
<td>
<p>a function with args <code>x, log = FALSE</code>.</p>
</td></tr>
<tr><td><code>.makeP</code>, <code>.makePNew</code></td>
<td>
<p>a function with args <code>q, lower.tail = TRUE, 
       log.p = FALSE</code>.</p>
</td></tr>
<tr><td><code>.makeQ</code>, <code>.makeQNew</code></td>
<td>
<p>a function with args <code>p, lower.tail = TRUE, 
       log.p = FALSE</code>.</p>
</td></tr>
<tr><td><code>.isInteger</code>, <code>.isNatural</code>, <code>.isNatural0</code></td>
<td>
<p><code>logical</code> (same length as argument <code>x</code>).</p>
</td></tr>
<tr><td><code>.mergegaps</code>, <code>.mergegaps2</code></td>
<td>
<p>a <code>gaps</code>-matrix, i.e.; a matrix <code>m</code> with two columns, 
such that <code>t(m)</code>, interpreted as vector, is ordered.</p>
</td></tr>
<tr><td><code>.pmixfun</code></td>
<td>
<p>slot <code>p</code> for a mixing distribution, i.e. a function 
<code>function(q, lower.tail = TRUE, log.p = FALSE)</code>, which
is  the cdf of the distribution.</p>
</td></tr>
<tr><td><code>.dmixfun</code></td>
<td>
<p>slot <code>d</code> for a mixing distribution, i.e. a function 
<code>function(x, log = FALSE)</code>, which
is  the density of the distribution.</p>
</td></tr>
<tr><td><code>.qmixfun</code></td>
<td>
<p>slot <code>q</code> for a mixing distribution, i.e. a function 
<code>function(p, lower.tail = TRUE, log.p = FALSE)</code>, which
is  the quantile function of the distribution.</p>
</td></tr>
<tr><td><code>.rmixfun</code></td>
<td>
<p>slot <code>r</code> for a mixing distribution, i.e. a function 
<code>function(n)</code> generating r.v.'s according to the distribution.</p>
</td></tr>
<tr><td><code>.deldmixfun</code></td>
<td>
<p>a possibly modified argument <code>mixDistr</code>.</p>
</td></tr>
<tr><td><code>.loupmixfun</code></td>
<td>
<p>a list of four components: <code>qL</code>, the minimal value of 
<code>q(x)(0)</code>, <code>ql</code>, the minimal value of 
<code>q(x)(getdistrOption("TruncQuantile"))</code>, <code>qU</code>, the maximal value of 
<code>q(x)(1)</code>, <code>qu</code>, the maximal value of 
<code>q(x)(getdistrOption("TruncQuantile"), lower.tail = FALSE)</code>,
<code>x</code> running through the members of <code>mixDistr</code> in each case.</p>
</td></tr>
<tr><td><code>.ULC.cast</code></td>
<td>
<p>an object of class <code>"UnivarLebDecDistribution"</code>.</p>
</td></tr>
<tr><td><code>.expm.d</code>, <code>.logm.d</code></td>
<td>
<p>an object of class <code>"DiscreteDistribution"</code>.</p>
</td></tr> 
<tr><td><code>.expm.c</code>, <code>.logm.c</code></td>
<td>
<p>an object of class <code>"AbscontDistribution"</code>.</p>
</td></tr> 
<tr><td><code>.P2D</code></td>
<td>
<p>a density <code>d</code> as function <code>function(x,  log = FALSE)</code>.</p>
</td></tr>
<tr><td><code>.P2Q</code></td>
<td>
<p>a quantile function <code>q</code> as function <code>function(p, 
            lower.tail = TRUE, log.p = FALSE)</code></p>
</td></tr> 
<tr><td><code>.D2P</code>, <code>.Q2P</code></td>
<td>
<p>a cdf <code>p</code> as function <code>function(q, 
            lower.tail = TRUE, log.p = FALSE)</code>.</p>
</td></tr>
<tr><td><code>.csimpsum</code></td>
<td>
<p>a vector of evaluations of the prime function at the grid points.</p>
</td></tr>
<tr><td><code>.primefun</code></td>
<td>
<p>the prime function as a function.</p>
</td></tr>
<tr><td><code>.IssueWarn</code></td>
<td>
<p>a list with two warnings to be issued each of which may be empty.</p>
</td></tr>
<tr><td><code>.List</code></td>
<td>
<p>a list.</p>
</td></tr>
<tr><td><code>.fillList</code></td>
<td>
<p>a list.</p>
</td></tr>
<tr><td><code>.trunc.up</code>, <code>.trunc.low</code></td>
<td>
<p>a list with elements <code>r,p,d,q</code> (in this order).</p>
</td></tr>
<tr><td><code>.DistrCollapse</code></td>
<td>
<p>upon a suggestion by Jacob van Etten, 
<a href="mailto:jacobvanetten@yahoo.com">jacobvanetten@yahoo.com</a>: help function to collapse the support 
points of a discrete distributions if they are too close to each other;
here argument <code>support</code> is the (original; already sorted) support
and <code>prob</code> a corresponding probability vector of same length.
Criterium for collapsing: a distance smaller than argument
<code>eps</code>.
</p>
</td></tr>
<tr><td><code>.EuclidAlgo</code></td>
<td>
<p>returns the greatest common divisor (an integer).</p>
</td></tr>
<tr><td><code>.getCommonWidth</code></td>
<td>
<p>returns the  smallest common lattice width (a numeric).</p>
</td></tr>
<tr><td><code>.convDiscrDiscr</code></td>
<td>
<p>returns the convolution of two discrete distributions.</p>
</td></tr>
<tr><td><code>.inWithTol</code></td>
<td>
<p>returns a logical vector of same lenght as <code>x</code> for the
matches (up to tolerance) with vector <code>y</code>.</p>
</td></tr>
<tr><td><code>.panel.mingle</code></td>
<td>
<p>used for mingling arguments <code>panel.first</code>,
<code>panel.last</code>; returns the evaluated argument <code>element</code> within dots,
if it is a symbol; else if it can be interpreted as a call, and if the top
call is <code>list</code>, it returns a list of the items of the call to <code>list</code>,
unevaluated, and otherwise the unchanged argument.</p>
</td></tr>
<tr><td><code>devNew</code></td>
<td>
<p>returns the return value of the device opened,
usually invisible <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AbscontDistribution">AbscontDistribution</a></code>,
<code><a href="#topic+DiscreteDistribution">DiscreteDistribution</a></code>,
<code><a href="#topic+LatticeDistribution">LatticeDistribution</a></code>,
<code><a href="#topic+RtoDPQ">RtoDPQ</a></code>,
<code><a href="#topic+RtoDPQ.d">RtoDPQ.d</a></code>,
<code><a href="#topic+convpow">convpow</a></code>,
<code><a href="#topic+operators">operators</a></code>,
<code><a href="#topic+plot-methods">plot-methods</a></code>
<code><a href="grDevices.html#topic+dev">dev.new</a></code>
</p>

<hr>
<h2 id='internals_for_qqplot'>Internal functions for qqplot of package distr</h2><span id='topic+internals_for_qqplot'></span><span id='topic+.inGaps'></span><span id='topic+.isReplicated'></span><span id='topic+.NotInSupport'></span><span id='topic+.SingleDiscrete'></span><span id='topic+.makeLenAndOrder'></span><span id='topic+.q2kolmogorov'></span><span id='topic+.BinomCI.in'></span><span id='topic+.BinomCI'></span><span id='topic+.BinomCI.nosym'></span><span id='topic+.q2pw'></span><span id='topic+.confqq'></span><span id='topic+.deleteItemsMCL'></span><span id='topic+.distrExInstalled'></span>

<h3>Description</h3>

<p>These functions are used internally by qqplot of package distr.</p>


<h3>Usage</h3>

<pre><code class='language-R'>.inGaps(x,gapm)
.isReplicated(x, tol = .Machine$double.eps)
.NotInSupport(x,D)
.SingleDiscrete(x,D)
.makeLenAndOrder(x,ord)

.BinomCI.in(t,p.bi,x.i, del.i=0,D.i,n.i,alpha.i)
.BinomCI(x,p.b,D,n,alpha, silent0 = TRUE)
.BinomCI.nosym(x,p.b,D,n,alpha, silent0 = TRUE)

.q2kolmogorov(alpha,n,exact=(n&lt;100), silent0 = TRUE)
.q2pw(x,p.b,D,n,alpha,exact=(n&lt;100),nosym=FALSE, silent0 = TRUE)

.confqq(x,D, datax=FALSE, withConf.pw  = TRUE,  withConf.sim = TRUE, alpha,
                    col.pCI, lty.pCI, lwd.pCI, pch.pCI, cex.pCI,
                    col.sCI, lty.sCI, lwd.sCI, pch.sCI, cex.sCI,
                    n,exact.sCI=(n&lt;100),exact.pCI=(n&lt;100),
                    nosym.pCI = FALSE, with.legend = TRUE,
                    legend.bg = "white", legend.pos = "topleft",
                    legend.cex = 0.8, legend.pref = "", legend.postf = "",
                    legend.alpha = alpha, qqb0 = NULL, transf0=NULL, debug = FALSE)

.deleteItemsMCL(mcl)
.distrExInstalled
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internals_for_qqplot_+3A_x">x</code></td>
<td>
<p>a (numeric) vector</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_gapm">gapm</code></td>
<td>
<p>matrix; the gap matrix as in slot <code>gaps</code> of
an <code>"AbscontDistribution"</code> or <code>"UnivarLebDecDistribution"</code>
object.
</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_tol">tol</code></td>
<td>
<p>numeric; tolerance for separating points.</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_d">D</code></td>
<td>
<p>object of class <code>"UnivariateDistribution"</code></p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_datax">datax</code></td>
<td>
<p>logical; (to be used in <span class="pkg">distrMod</span>) shall data be plotted on x-axis?</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_ord">ord</code></td>
<td>
<p>integer; the result of a call to <code>order</code></p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_alpha">alpha</code></td>
<td>
<p>numeric in [0,1]; confidence level</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_n">n</code></td>
<td>
<p>integer; sample size</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_exact">exact</code></td>
<td>
<p>logical; shall finite sample version be used?</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_t">t</code></td>
<td>
<p>current  (half of the) width of the confidence interval.</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_p.bi">p.bi</code></td>
<td>
<p>(local) (binomial) c.d.f. value at <code>x.i</code>.</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_x.i">x.i</code></td>
<td>
<p>a (numeric) vector</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_del.i">del.i</code></td>
<td>
<p>numeric; a (local) asymmetry parameter to pass on to
<code>optim</code> and <code>uniroot</code> &mdash; the endpoints of the searched interval
are <code>x.i+t/sqrt(n)+del.i/sqrt(n)</code> and <code>x.i-t/sqrt(n)+del.i/sqrt(n)</code>.</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_d.i">D.i</code></td>
<td>
<p>object of class <code>"UnivariateDistribution"</code></p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_n.i">n.i</code></td>
<td>
<p>integer; (local) sample size</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_alpha.i">alpha.i</code></td>
<td>
<p>numeric in [0,1]; (local) confidence level</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_p.b">p.b</code></td>
<td>
<p>(binomial) c.d.f. value at <code>x</code>.</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_nosym">nosym</code></td>
<td>
<p>logical; shall we compute shortest (asymmetric) confidence intervals;</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_withconf.pw">withConf.pw</code></td>
<td>
<p>logical; shall pointwise confidence lines be plotted?</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_withconf.sim">withConf.sim</code></td>
<td>
<p>logical; shall simultaneous confidence lines be plotted?</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_exact.pci">exact.pCI</code></td>
<td>
<p>logical; shall pointwise CIs be determined with exact Binomial distribution?</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_exact.sci">exact.sCI</code></td>
<td>
<p>logical; shall simultaneous CIs be determined with exact kolmogorov distribution?</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_nosym.pci">nosym.pCI</code></td>
<td>
<p>logical; shall we use (shortest) asymmetric CIs?</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_col.pci">col.pCI</code></td>
<td>
<p>color for the pointwise CI</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_lty.pci">lty.pCI</code></td>
<td>
<p>line type for the pointwise CI</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_lwd.pci">lwd.pCI</code></td>
<td>
<p>line width for the pointwise CI</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_pch.pci">pch.pCI</code></td>
<td>
<p>symbol for points (for discrete mass points) in pointwise CI</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_cex.pci">cex.pCI</code></td>
<td>
<p>magnification factor for points (for discrete mass points) in pointwise CI</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_col.sci">col.sCI</code></td>
<td>
<p>color for the simultaneous CI</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_lty.sci">lty.sCI</code></td>
<td>
<p>line type for the simultaneous CI</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_lwd.sci">lwd.sCI</code></td>
<td>
<p>line width for the simultaneous CI</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_pch.sci">pch.sCI</code></td>
<td>
<p>symbol for points (for discrete mass points) in simultaneous CI</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_cex.sci">cex.sCI</code></td>
<td>
<p>magnification factor for points (for discrete mass points) in simultaneous CI</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_with.legend">with.legend</code></td>
<td>
<p>logical; shall a legend be plotted?</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_legend.bg">legend.bg</code></td>
<td>
<p>background color for the legend</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_legend.pos">legend.pos</code></td>
<td>
<p>position for the legend</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_legend.cex">legend.cex</code></td>
<td>
<p>magnification factor for the legend</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_legend.pref">legend.pref</code></td>
<td>
<p>character to be prepended to legend text</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_legend.postf">legend.postf</code></td>
<td>
<p>character to be appended to legend text</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_legend.alpha">legend.alpha</code></td>
<td>
<p>nominal coverage probability</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_mcl">mcl</code></td>
<td>
<p>arguments in call as a list</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_qqb0">qqb0</code></td>
<td>
<p>precomputed return value of <code>qqbounds</code></p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_transf0">transf0</code></td>
<td>
<p>optional transformation of x-values (by default <code>NULL</code> and then ignored)</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_debug">debug</code></td>
<td>
<p>logical; if <code>TRUE</code> additional output to debug confidence bounds. </p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_silent0">silent0</code></td>
<td>
<p>logical; it is used as argument <code>silent</code> in <code>try</code>-catches
within this function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.inGaps</code> produces a logical vector of same length as <code>x</code> with
entries <code>TRUE</code> if the corresponding component of <code>x</code> lies within a
gap as given by gap matrix <code>gapm</code> and <code>FALSE</code> otherwise.
</p>
<p><code>.isReplicated</code> produces a logical vector of same length as <code>x</code> with
entries <code>TRUE</code> if the corresponding component of <code>x</code> appears at least
twice within <code>x</code> and <code>FALSE</code> otherwise.
</p>
<p><code>.NotInSupport</code> produces a logical vector of same length as <code>x</code> with
entries <code>TRUE</code> if the corresponding component of <code>x</code> does not
lie within the support of <code>D</code> and <code>FALSE</code> otherwise.
</p>
<p><code>.SingleDiscrete</code> produces a numerical vector of same length as <code>x</code> with
values <code>0</code>  if the corresponding component of <code>x</code> is discrete mass point
of <code>D</code>, <code>1</code>  if the corresponding component of <code>x</code> lies within
the continuous support of <code>D</code>, <code>2</code> and <code>3</code>
if the corresponding component of <code>x</code>
is a left resp. right end point of a gap of <code>D</code>, and <code>4</code> if
the corresponding component of <code>x</code> does not lie within the support of <code>D</code>
at all.
</p>
<p><code>.makeLenAndOrder</code> by standard recycling roules respectively by truncation
at the end, forces <code>x</code> to length <code>length{ord}</code> and then orders the
result according to <code>ord</code>.
</p>
<p><code>.q2kolmogorov</code>, in the finite sample version (<code>exact==TRUE</code>),
returns the corresponding <code>alpha</code>-quantile
of the exact Kolmogorov distribution multiplied by <code class="reqn">\sqrt{n}</code>, and
in the asymptotic version (<code>exact==FALSE</code>),
the the corresponding (upper) <code>alpha</code>-quantile
of the asymptotic Kolmogorov distribution. Doing so we make use of
C-function <code>"pkolmogorov2x"</code> (from <code><a href="stats.html#topic+ks.test">ks.test</a></code> in package <span class="pkg">stats</span>)
and R-function <code>pkstwo</code> (again from <code><a href="stats.html#topic+ks.test">ks.test</a></code> in package <span class="pkg">stats</span>).
</p>
<p><code>.BinomCI.in</code> in a non-vectorized form, computes,
for given <code>t</code>, <code>x</code>, <code class="reqn">\alpha</code>, <code class="reqn">\delta</code>,
and for <code class="reqn">X\sim D</code>, the discrepancy
</p>
<p style="text-align: center;"><code class="reqn">P(\sqrt{n} |X-x-\delta| \leq t) - \alpha</code>
</p>

<p><code>.BinomCI</code>, in a vectorized form, computes,
for given <code>x</code>, <code class="reqn">\alpha</code>, <code class="reqn">\delta</code>,
values <code>t</code> such that,
pointwise in <code>x</code> and for <code class="reqn">X\sim D</code>,
</p>
<p style="text-align: center;"><code class="reqn">P(\sqrt{n} |X-x-\delta| \leq t) = \alpha</code>
</p>

<p><code>.BinomCI.nosym</code>, in an outer loop, by varying <code>del</code> in the former
formula, tries to minimize the length of
a corresponding level alpha confidence interval containing the estimate.
</p>
<p><code>.q2pw</code> computes  pointwise finite sample or asymptotic confidence widths
by means of binomial probabilities / quantiles, in the former case either
symmetric (default) or shortest asymmetric; in the asymptotic case, for
distributions without a Lebesgue density, for the corresponding
density value at the quantile appearing in the expression for the
asymptotic variance, we make an approximation of <code>(D-E(D))/sd(D)</code> by
the standard normal, using the density of the latter one; this latter approximation
is only  available if <code>.distrExInstalled == TRUE</code>; otherwise the corresponding
columns will be filled with <code>NA</code>.
</p>
<p><code>.confqq</code> calls <code>qqbound</code> to compute the confidence intervals
and plots them; returns the return value of qqbound.
</p>
<p><code>.deleteItemsMCL</code> deletes arguments from a call list which
functions like <code>plot</code>, <code>lines</code>, <code>points</code> cannot digest;
this is necessary in the manipulation of an original call
to a specific <code>qqplot</code> method to pass on the <code>...</code> argument
correctly to calls the mentioned functions.
</p>
<p><code>.distrExInstalled</code> is a constant logical &mdash; <code>TRUE</code> if package
<span class="pkg">distrEx</span> is installed.
</p>


<h3>Value</h3>

<table>
<tr><td><code>.inGaps</code></td>
<td>
<p>a logical vector of same length as <code>x</code>.</p>
</td></tr>
<tr><td><code>.isReplicated</code></td>
<td>
<p>a logical vector of same length as <code>x</code>.</p>
</td></tr>
<tr><td><code>.NotInSupport</code></td>
<td>
<p>a logical vector of same length as <code>x</code>.</p>
</td></tr>
<tr><td><code>.SingleDiscrete</code></td>
<td>
<p>a vector of same length as <code>x</code> with entries in the
set <code class="reqn">\{0,1,2,3,4\}</code>.</p>
</td></tr>
<tr><td><code>.makeLenAndOrder</code></td>
<td>
<p>a numeric of length <code>length(ord</code>.</p>
</td></tr>
<tr><td><code>.BinomCI.in</code></td>
<td>
<p>a numeric of length 1: the discrepancy
</p>
<p style="text-align: center;"><code class="reqn">P(\sqrt{n} |X-x-\delta| \leq t) - \alpha</code>
</p>

</td></tr>
<tr><td><code>.BinomCI</code></td>
<td>
<p>a numeric matrix with two columns <code>"left"</code> and <code>"right"</code>
with the corresponding pointwise confidence widths.</p>
</td></tr>
<tr><td><code>.BinomCI.nosym</code></td>
<td>
<p>a numeric matrix with two columns <code>"left"</code> and <code>"right"</code>
with the corresponding pointwise confidence widths.</p>
</td></tr>
<tr><td><code>.q2kolmogorov</code></td>
<td>
<p>a numeric of length 1; a corresponding quantile of the
(exact/asymptotic) Kolmogorov distribution</p>
</td></tr>
<tr><td><code>.q2pw</code></td>
<td>
<p>a numeric matrix with two columns <code>"left"</code> and <code>"right"</code>
with the corresponding pointwise confidence widths.</p>
</td></tr>
<tr><td><code>.confqq</code></td>
<td>
<p><code>invisible(NULL)</code></p>
</td></tr>
<tr><td><code>.deleteItemsMCL</code></td>
<td>
<p>the manipulated list of arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ks.test">ks.test</a></code>, <code><a href="#topic+qqplot">qqplot</a></code>
, <code><a href="distrMod.html#topic+qqplot">qqplot</a></code>, <code><a href="RobAStBase.html#topic+qqplot">qqplot</a></code>
</p>

<hr>
<h2 id='k-methods'> Methods for Function k in Package &lsquo;distr&rsquo; </h2><span id='topic+k-methods'></span><span id='topic+k+3C--methods'></span><span id='topic+k'></span><span id='topic+k+3C-'></span><span id='topic+k+2CHyperParameter-method'></span><span id='topic+k+2CHyper-method'></span><span id='topic+k+3C-+2CHyperParameter-method'></span><span id='topic+k+3C-+2CHyper-method'></span>

<h3>Description</h3>

<p>k-methods</p>


<h3>Methods</h3>


<dl>
<dt>k</dt><dd><p><code>signature(object = "HyperParameter")</code>: returns the slot <code>k</code> of the parameter of the distribution </p>
</dd>
<dt>k&lt;-</dt><dd><p><code>signature(object = "HyperParameter")</code>: modifies the slot <code>k</code> of the parameter of the distribution </p>
</dd>
<dt>k</dt><dd><p><code>signature(object = "Hyper")</code>: returns the slot <code>k</code> of the parameter of the distribution </p>
</dd>
<dt>k&lt;-</dt><dd><p><code>signature(object = "Hyper")</code>: modifies the slot <code>k</code> of the parameter of the distribution </p>
</dd>
</dl>

<hr>
<h2 id='lambda-methods'> Methods for Function lambda  in Package &lsquo;distr&rsquo;</h2><span id='topic+lambda-methods'></span><span id='topic+lambda+3C--methods'></span><span id='topic+lambda'></span><span id='topic+lambda+3C-'></span><span id='topic+lambda+2CPoisParameter-method'></span><span id='topic+lambda+2CPois-method'></span><span id='topic+lambda+3C-+2CPoisParameter-method'></span><span id='topic+lambda+3C-+2CPois-method'></span>

<h3>Description</h3>

<p>lambda-methods</p>


<h3>Methods</h3>


<dl>
<dt>lambda</dt><dd><p><code>signature(object = "PoisParameter")</code>: returns the slot <code>lambda</code> of the parameter of the distribution </p>
</dd>
<dt>lambda&lt;-</dt><dd><p><code>signature(object = "PoisParameter")</code>: modifies the slot <code>lambda</code> of the parameter of the distribution </p>
</dd>
<dt>lambda</dt><dd><p><code>signature(object  = "Pois")</code>: returns the slot <code>lambda</code> of the parameter of the distribution </p>
</dd>
<dt>lambda&lt;-</dt><dd><p><code>signature(object = "Pois")</code>: modifies the slot <code>lambda</code> of the parameter of the distribution </p>
</dd>
</dl>

<hr>
<h2 id='Lattice-class'>Class &quot;Lattice&quot; </h2><span id='topic+Lattice-class'></span><span id='topic+Lattice'></span>

<h3>Description</h3>

<p>Class <code>Lattice</code> formalizes an affine linearly generated grid
of (support) points  <code>pivot + (0:(Length-1)) * width</code>;
this is used for subclass <code>LatticeDistribution</code> of class
<code>DiscreteDistribution</code> which in addition to the latter contains a slot 
<code>lattice</code> of class <code>Lattice</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Lattice(pivot = 0, width = 1, Length = 2, name = "a lattice")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lattice-class_+3A_pivot">pivot</code></td>
<td>
<p>the (finite) utmost left or right value of the lattice</p>
</td></tr>
<tr><td><code id="Lattice-class_+3A_width">width</code></td>
<td>
<p>the (finite) grid-width; if negative the lattice is expanded to 
the left, else to the right</p>
</td></tr>
<tr><td><code id="Lattice-class_+3A_length">Length</code></td>
<td>
<p>the (possibly infinite) length of the lattice</p>
</td></tr>
<tr><td><code id="Lattice-class_+3A_name">name</code></td>
<td>
<p>the (possibly empty) name of the lattice 
(inherited from class <code>rSpace</code>)</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Objects may be generated by calling the generating function <code>Lattice</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>pivot</code></dt><dd><p>Object of class <code>"numeric"</code>: 
&mdash; the pivot of the lattice; must be of length 1</p>
</dd>
<dt><code>width</code></dt><dd><p>Object of class <code>"numeric"</code>: 
&mdash; the width of the lattice; must be of length 1 and 
must not be 0</p>
</dd>
<dt><code>Length</code></dt><dd><p>Object of class <code>"numeric"</code>: 
&mdash; the width of the lattice; must be an integer &gt; 0 
of length 1</p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: 
the name of the space, by default = &quot;a lattice&quot;</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"rSpace"</code>, directly.<br />
</p>


<h3>Methods</h3>


<dl>
<dt>pivot</dt><dd><p><code>signature(.Object = "Lattice")</code>: 
returns the <code>'pivot'</code> slot</p>
</dd>
<dt>pivot&lt;-</dt><dd><p><code>signature(.Object = "Lattice")</code>:
modifies the <code>'pivot'</code> slot</p>
</dd>
<dt>width</dt><dd><p><code>signature(.Object = "Lattice")</code>: 
returns the <code>'width'</code> slot </p>
</dd>
<dt>width&lt;-</dt><dd><p><code>signature(.Object = "Lattice")</code>: 
modifies the <code>'width'</code> slot</p>
</dd>
<dt>Length</dt><dd><p><code>signature(.Object = "Lattice")</code>: 
returns the <code>'Length'</code> slot </p>
</dd>
<dt>Length&lt;-</dt><dd><p><code>signature(.Object = "Lattice")</code>: 
modifies the <code>'Length'</code> slot </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+rSpace-class">rSpace-class</a></code>
<code><a href="#topic+LatticeDistribution-class">LatticeDistribution-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L &lt;- Lattice(pivot = 0, width = 1, Length = Inf, name = "the Naturals")
name(L)
pivot(L) &lt;- 1 ### now starting from 1
</code></pre>

<hr>
<h2 id='LatticeDistribution'>Class &quot;LatticeDistribution&quot;</h2><span id='topic+LatticeDistribution'></span>

<h3>Description</h3>

<p>The <code>LatticeDistribution</code>-class is the mother-class of the
classes <code>Binom</code>, <code>Dirac</code>, <code>Geom</code>, <code>Hyper</code>, <code>Nbinom</code> and
<code>Poisson</code>. It formalizes a distribution on a regular affine
linear lattice.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  LatticeDistribution(lattice = NULL, supp = NULL, prob = NULL,
                       .withArith = FALSE, .withSim = FALSE,
                       DiscreteDistribution = NULL, check = TRUE,
                       Symmetry = NoSymmetry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LatticeDistribution_+3A_discretedistribution">DiscreteDistribution</code></td>
<td>
<p>an object of class <code>DiscreteDistribution</code>
or <code>AffLinDiscreteDistribution</code> to be
coerced to <code>LatticeDistribution</code> or <code>AffLinLatticeDistribution</code>,
respectively</p>
</td></tr>
<tr><td><code id="LatticeDistribution_+3A_lattice">lattice</code></td>
<td>
<p>lattice (of class <code>Lattice</code>) which determines the support
of the discrete distribution. </p>
</td></tr>
<tr><td><code id="LatticeDistribution_+3A_supp">supp</code></td>
<td>
<p> numeric vector which forms the support
of the discrete distribution. </p>
</td></tr>
<tr><td><code id="LatticeDistribution_+3A_prob">prob</code></td>
<td>
<p> vector of probability weights for the
elements of <code>supp</code>.</p>
</td></tr>
<tr><td><code id="LatticeDistribution_+3A_.witharith">.withArith</code></td>
<td>
<p>normally not set by the user, but if determining the entries
<code>supp</code>, <code>prob</code> distributional arithmetics was
involved, you may set this to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="LatticeDistribution_+3A_.withsim">.withSim</code></td>
<td>
<p>normally not set by the user, but if determining the entries
<code>supp</code>, <code>prob</code> simulations were involved, you may
set this to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="LatticeDistribution_+3A_check">check</code></td>
<td>
<p> logical: if <code>TRUE</code>, <code>LatticeDistribution()</code> throws an
error if argument <code>lattice</code> and other arguments are
inconsistent or if there is no way to automatically generate
a <code>lattice</code> argument. If <code>check == FALSE</code>,
<code>LatticeDistribution()</code>
returns an object of <code>DiscreteDistribution</code>, ignoring
argument <code>lattice</code></p>
</td></tr>
<tr><td><code id="LatticeDistribution_+3A_symmetry">Symmetry</code></td>
<td>
<p>you may help <span class="rlang"><b>R</b></span> in calculations if you tell it whether
the distribution is non-symmetric (default) or symmetric with respect
to a center; in this case use <code>Symmetry=SphericalSymmetry(center)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typical usages are
</p>
<pre>
  LatticeDistribution(DiscreteDistribution)
  LatticeDistribution(lattice, DiscreteDistribution)
  LatticeDistribution(lattice, supp, prob, .withArith, .withSim, check = FALSE)
  LatticeDistribution(lattice, supp, prob)
  LatticeDistribution(supp)
  </pre>
<p>For the generating function <code>LatticeDistribution()</code>, the arguments
are processed in the following order:<br />
Arguments <code>.withSim</code> and <code>.withArith</code> are used in any case.<br />
If there is an argument <code>DiscreteDistribution</code> (of the respective class),
all its slots (except for <code>.withSim</code> and <code>.withArith</code>)
will be used for filling the slots of the object of class
<code>LatticeDistribution()</code>/<code>AffLinLatticeDistribution()</code>.
If in addition, there is an argument <code>lattice</code> of class <code>Lattice</code>,
it will be checked for consistency
with argument <code>DiscreteDistribution</code> and if oK will be used for slot
lattice of the object of class
<code>LatticeDistribution()</code>/<code>AffLinLatticeDistribution()</code>. In case
there is no <code>lattice</code> argument, slot <code>lattice</code> will be constructed
from slot <code>support</code> from argument <code>DiscreteDistribution</code>.<br />
If there is no argument <code>DiscreteDistribution</code>, but there are arguments
<code>supp</code> and <code>lattice</code> (the latter of class <code>Lattice</code>) then
these are checked for consistency and if oK, generating function
<code>DiscreteDistribution()</code> is called with arguments <code>supp</code>,
<code>prob</code>, <code>.withArith</code>, and <code>.withSim</code> to produce an object
of class <code>DiscreteDistribution</code> the slots of which will be used for the
filling the slots of the object of class
<code>LatticeDistribution()</code>/<code>AffLinLatticeDistribution()</code>.
If in this case, argument <code>prob</code> is not given explicitely, all elements
in <code>supp</code> are equally weighted.
<br />
If there is no argument <code>DiscreteDistribution</code>, but there is an argument
<code>lattice</code> of class <code>Lattice</code> (but no argument <code>slot</code>) then
if <code>Length(lattice)</code> is finite, a corresponding support vector <code>supp</code>
is generated from argument <code>lattice</code> and generating function
<code>DiscreteDistribution()</code> is called with arguments <code>supp</code>,
<code>prob</code>, <code>.withArith</code>, and <code>.withSim</code> to produce an object
of class <code>DiscreteDistribution</code> the slots of which will be used for the
filling the slots of the object of class <code>LatticeDistribution()</code>.
If in the same situation <code>Length(lattice)</code> is not finite, a finite length
for the support vector is extracted from argument <code>prob</code> and after
generating <code>supp</code> one procedes as in the finite <code>Length(lattice)</code>
case. <br />
If there is no argument <code>DiscreteDistribution</code> and no argument
<code>lattice</code> of class <code>Lattice</code> but an argument <code>supp</code> then
it will be checked if <code>supp</code> makes for a lattice, and if so,
<code>DiscreteDistribution()</code> is called with arguments <code>supp</code>,
<code>prob</code>, <code>.withArith</code>, and <code>.withSim</code> to produce an object
of class <code>DiscreteDistribution</code> the slots of which will be used for the
filling the slots of the object of class <code>LatticeDistribution()</code>. The
corresponding <code>lattice</code>-slot will be filled with information from
argument <code>supp</code>.  <br />

The price for this flexibility of arguments, <code>LatticeDistribution()</code> may
be called with, is that you should call <code>LatticeDistribution()</code> with
<em>named arguments</em> only.<br />
Note that internally we suppress lattice points from the support where
the probability is 0.
</p>


<h3>Objects from the Class</h3>

<p>The usual way to generate objects of class <code>LatticeDistribution</code> is to call
the generating function <code>LatticeDistribution()</code>  (see details). <br />
Somewhat more flexible, but also proner to inconsistencies is a call to
<code>new("LatticeDistribution")</code>, where you may explicitly specify random
number generator, (counting) density, cumulative distribution and quantile
functions. For conveniance, in this call to <code>new("LatticeDistribution")</code>,
an additional possibility is to only specify the random number generator. The
function <code>RtoDPQ.d</code> then approximates the three remaining slots <code>d</code>,
<code>p</code> and <code>q</code> by random sampling.
</p>


<h3>Note</h3>

<p> Working with a computer, we use a finite interval as support which
carries at least mass <code>1-getdistrOption("TruncQuantile")</code>. </p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Parameter-class">Parameter-class</a></code>
<code><a href="#topic+Lattice-class">Lattice-class</a></code>
<code><a href="#topic+LatticeDistribution-class">LatticeDistribution-class</a></code>
<code><a href="#topic+Reals-class">Reals-class</a></code>
<code><a href="#topic+RtoDPQ.d">RtoDPQ.d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  LatticeDistribution(DiscreteDistribution = DiscreteDistribution(supp =
                       c(4,3,2), prob=c(0.3,0.1,0.6)))
  LatticeDistribution(supp = c(4,3,2))
</code></pre>

<hr>
<h2 id='LatticeDistribution-class'>Class &quot;LatticeDistribution&quot;</h2><span id='topic+AffLinLatticeDistribution-class'></span><span id='topic+LatticeDistribution-class'></span><span id='topic+lattice'></span><span id='topic+lattice-method'></span><span id='topic+lattice+2CLatticeDistribution-method'></span><span id='topic+initialize+2CLatticeDistribution-method'></span><span id='topic+initialize+2CAffLinLatticeDistribution-method'></span><span id='topic+sqrt+2CLatticeDistribution-method'></span><span id='topic+coerce+2CLatticeDistribution+2CDiscreteDistribution-method'></span><span id='topic+coerce+2CAffLinLatticeDistribution+2CAffLinDiscreteDistribution-method'></span>

<h3>Description</h3>

<p>The <code>LatticeDistribution</code>-class is the mother-class of the 
classes <code>Binom</code>, <code>Dirac</code>, <code>Geom</code>, <code>Hyper</code>, <code>Nbinom</code> and 
<code>Poisson</code>. It formalizes a distribution on a regular affine
linear lattice.</p>


<h3>Objects from the Class</h3>

<p>The usual way to generate objects of class <code>LatticeDistribution</code> is to call 
the generating function <code><a href="#topic+LatticeDistribution">LatticeDistribution</a></code>. <br />
Somewhat more flexible, but also proner to inconsistencies is a call to 
<code>new("LatticeDistribution")</code>, where you may explicitly specify random 
number generator, (counting) density, cumulative distribution and quantile 
functions. For conveniance, in this call to <code>new("LatticeDistribution")</code>, 
an additional possibility is to only specify the random number generator. The 
function <code>RtoDPQ.d</code> then approximates the three remaining slots <code>d</code>, 
<code>p</code> and <code>q</code> by random sampling. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>: the space of the image 
of this distribution which has dimension 1 and the name &quot;Real Space&quot; </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"Parameter"</code>: the parameter of 
this distribution, having only the slot name 
&quot;Parameter of a discrete distribution&quot; </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: 
generates random numbers</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>: 
(counting) density/probability function</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>: 
cumulative distribution function</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>: 
quantile function</p>
</dd>
<dt><code>support</code></dt><dd><p>Object of class <code>"numeric"</code>: a (sorted) vector 
containing the support of the discrete
density function</p>
</dd>
<dt><code>lattice</code></dt><dd><p>Object of class <code>"Lattice"</code>: the lattice 
generating the support.</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"UnivariateDistribution"</code>, directly.<br />
Class <code>"Distribution"</code>, by class <code>"UnivariateDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>initialize</code></dt><dd><p><code>signature(.Object = "LatticeDistribution")</code>: 
initialize method </p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "LatticeDistribution")</code>: 
application of &lsquo;-&rsquo; to this lattice distribution</p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "LatticeDistribution", e2 = "numeric")</code>: 
multiplication of this lattice distribution
by an object of class &lsquo;numeric&rsquo;</p>
</dd>
<dt>/</dt><dd><p><code>signature(e1 = "LatticeDistribution", e2 = "numeric")</code>: 
division of this lattice distribution by an object of class &lsquo;numeric&rsquo;</p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "LatticeDistribution", e2 = "numeric")</code>: 
addition of this lattice distribution to an object of class &lsquo;numeric&rsquo;</p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "LatticeDistribution", e2 = "numeric")</code>: 
subtraction of an object of class &lsquo;numeric&rsquo; from this lattice 
distribution </p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "numeric", e2 = "LatticeDistribution")</code>: 
multiplication of this lattice distribution by an object of class &lsquo;numeric&rsquo;</p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "numeric", e2 = "LatticeDistribution")</code>: 
addition of this lattice distribution to an object of class &lsquo;numeric&rsquo;</p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "numeric", e2 = "LatticeDistribution")</code>: 
subtraction of this lattice distribution from an object of class &lsquo;numeric&rsquo;</p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "LatticeDistribution", 
    e2 = "LatticeDistribution")</code>: Convolution of two lattice distributions. 
Slots p, d and q are approximated by grids.</p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "LatticeDistribution", 
    e2 = "LatticeDistribution")</code>: Convolution of two lattice
distributions. The slots p, d and q are approximated by grids.</p>
</dd>
<dt><code>sqrt</code></dt><dd><p><code>signature(x = "LatticeDistribution")</code>:  exact 
image distribution of <code>sqrt(x)</code>.</p>
</dd>
<dt><code>lattice</code></dt><dd><p>accessor method to the corresponding slot.</p>
</dd>
<dt><code>coerce</code></dt><dd><p><code>signature(from = "LatticeDistribution",
    to = "DiscreteDistribution")</code>: coerces an object from 
<code>"LatticeDistribution"</code> to <code>"DiscreteDistribution"</code>
thereby cancelling out support points with probability 0.</p>
</dd>
</dl>



<h3>Internal subclass &quot;AffLinLatticeDistribution&quot;</h3>

<p>To enhance accuracy of several functionals on distributions,
mainly from package <span class="pkg">distrEx</span>, there is an internally used 
(but exported) subclass <code>"AffLinLatticeDistribution"</code> which has extra slots 
<code>a</code>, <code>b</code> (both of class <code>"numeric"</code>),  and <code>X0</code> 
(of class <code>"LatticeDistribution"</code>), to capture the fact 
that the object has the same distribution as <code>a * X0 + b</code>. This is 
the class of the return value of methods 
</p>

<dl>
<dt>-</dt><dd><p><code>signature(e1 = "LatticeDistribution")</code></p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "LatticeDistribution", e2 = "numeric")</code></p>
</dd>
<dt>/</dt><dd><p><code>signature(e1 = "LatticeDistribution", e2 = "numeric")</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "LatticeDistribution", e2 = "numeric")</code></p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "LatticeDistribution", e2 = "numeric")</code></p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "numeric", e2 = "LatticeDistribution")</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "numeric", e2 = "LatticeDistribution")</code></p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "numeric", e2 = "LatticeDistribution")</code></p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "AffLinLatticeDistribution")</code></p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "AffLinLatticeDistribution", e2 = "numeric")</code></p>
</dd>
<dt>/</dt><dd><p><code>signature(e1 = "AffLinLatticeDistribution", e2 = "numeric")</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "AffLinLatticeDistribution", e2 = "numeric")</code></p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "AffLinLatticeDistribution", e2 = "numeric")</code></p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "numeric", e2 = "AffLinLatticeDistribution")</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "numeric", e2 = "AffLinLatticeDistribution")</code></p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "numeric", e2 = "AffLinLatticeDistribution")</code></p>
</dd>
</dl>

<p>There is also an explicit <code>coerce</code>-method from class
<code>"AffLinLatticeDistribution"</code> to class <code>"AffLinDiscreteDistribution"</code>
which cancels out support points with probability 0.
</p>


<h3>Note</h3>

<p> Working with a computer, we use a finite interval as support which 
carries at least mass <code>1-getdistrOption("TruncQuantile")</code>. </p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+LatticeDistribution">LatticeDistribution</a></code>
<code><a href="#topic+Parameter-class">Parameter-class</a></code>
<code><a href="#topic+Lattice-class">Lattice-class</a></code>
<code><a href="#topic+UnivariateDistribution-class">UnivariateDistribution-class</a></code>
<code><a href="#topic+DiscreteDistribution-class">DiscreteDistribution-class</a></code>
<code><a href="#topic+Binom-class">Binom-class</a></code>
<code><a href="#topic+Dirac-class">Dirac-class</a></code>
<code><a href="#topic+Geom-class">Geom-class</a></code>
<code><a href="#topic+Hyper-class">Hyper-class</a></code>
<code><a href="#topic+Nbinom-class">Nbinom-class</a></code>
<code><a href="#topic+Pois-class">Pois-class</a></code>
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>
<code><a href="#topic+Reals-class">Reals-class</a></code>
<code><a href="#topic+RtoDPQ.d">RtoDPQ.d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B &lt;- Binom(prob = 0.1,size = 10) # B is a Binomial distribution w/ prob=0.1 and size=10.
P &lt;- Pois(lambda = 1) # P is a Poisson distribution with lambda = 1.
D1 &lt;- B+1 # a new Lattice distributions with exact slots d, p, q
D2 &lt;- D1*3 # a new Lattice distributions with exact slots d, p, q
D3 &lt;- B+P # a new Lattice distributions with approximated slots d, p, q
D4 &lt;- D1+P # a new Lattice distributions with approximated slots d, p, q
support(D4) # the (approximated) support of this distribution is 1, 2, ..., 21
r(D4)(1) # one random number generated from this distribution, e.g. 4
d(D4)(1) # The (approximated) density for x=1 is 0.1282716.
p(D4)(1) # The (approximated) probability that x&lt;=1 is 0.1282716.
q(D4)(.5) # The (approximated) 50 percent quantile is 3.
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
</code></pre>

<hr>
<h2 id='Length-methods'> Methods for Function Length in Package &lsquo;distr&rsquo; </h2><span id='topic+Length-methods'></span><span id='topic+Length+3C--methods'></span><span id='topic+Length'></span><span id='topic+Length+3C-'></span><span id='topic+Length+2CLattice-method'></span><span id='topic+Length+3C-+2CLattice-method'></span><span id='topic+Length+2CLatticeDistribution-method'></span><span id='topic+Length+3C-+2CLatticeDistribution-method'></span>

<h3>Description</h3>

<p>Length-methods</p>


<h3>Methods</h3>


<dl>
<dt>Length</dt><dd><p><code>signature(object = "Lattice")</code>: returns the slot Length of the lattice </p>
</dd>
<dt>Length&lt;-</dt><dd><p><code>signature(object = "Lattice")</code>: modifies the slot Length of the lattice </p>
</dd>
<dt>Length</dt><dd><p><code>signature(object = "LatticeDistribution")</code>: returns the slot Length of the lattice slot of the distribution</p>
</dd>
<dt>Length&lt;-</dt><dd><p><code>signature(object = "LatticeDistribution")</code>: modifies the slot Length of the lattice slot of the distribution</p>
</dd>
</dl>

<hr>
<h2 id='liesIn-methods'> Methods for Function liesIn in Package &lsquo;distr&rsquo; </h2><span id='topic+liesIn-methods'></span><span id='topic+liesIn'></span><span id='topic+liesIn+2CEuclideanSpace+2Cnumeric-method'></span><span id='topic+liesIn+2CNaturals+2Cnumeric-method'></span>

<h3>Description</h3>

<p>liesIn-methods</p>


<h3>Methods</h3>


<dl>
<dt>liesIn</dt><dd><p><code>signature(object = "EuclideanSpace", x =
	"numeric")</code></p>
</dd></dl>
<p>:
</p>
<p>Does a particular vector lie in this space or not?
</p>
<dl>
<dt>liesIn</dt><dd><p><code>signature(object = "Naturals", x =
	"numeric")</code></p>
</dd></dl>
<p>:
</p>
<p>Does a particular vector only contain naturals?
</p>

<hr>
<h2 id='liesInSupport'>Generic Function for Testing the Support of a Distribution </h2><span id='topic+liesInSupport'></span><span id='topic+liesInSupport-methods'></span><span id='topic+liesInSupport+2CUnivarLebDecDistribution+2Cnumeric-method'></span><span id='topic+liesInSupport+2CUnivarMixingDistribution+2Cnumeric-method'></span><span id='topic+liesInSupport+2CLatticeDistribution+2Cnumeric-method'></span><span id='topic+liesInSupport+2CDiscreteDistribution+2Cnumeric-method'></span><span id='topic+liesInSupport+2CDistribution+2Cmatrix-method'></span><span id='topic+liesInSupport+2CAbscontDistribution+2Cnumeric-method'></span><span id='topic+liesInSupport+2CExpOrGammaOrChisq+2Cnumeric-method'></span><span id='topic+liesInSupport+2CLnorm+2Cnumeric-method'></span><span id='topic+liesInSupport+2CFd+2Cnumeric-method'></span><span id='topic+liesInSupport+2CNorm+2Cnumeric-method'></span><span id='topic+liesInSupport+2CDExp+2Cnumeric-method'></span><span id='topic+liesInSupport+2CCauchy+2Cnumeric-method'></span><span id='topic+liesInSupport+2CTd+2Cnumeric-method'></span><span id='topic+liesInSupport+2CLogis+2Cnumeric-method'></span><span id='topic+liesInSupport+2CWeibull+2Cnumeric-method'></span><span id='topic+liesInSupport+2CUnif+2Cnumeric-method'></span><span id='topic+liesInSupport+2CBeta+2Cnumeric-method'></span>

<h3>Description</h3>

<p>The function tests if <code>x</code> lies in the support of the
distribution <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>liesInSupport(object, x, ...)
## S4 method for signature 'UnivarLebDecDistribution,numeric'
liesInSupport(object,x, checkFin = FALSE)
## S4 method for signature 'UnivarMixingDistribution,numeric'
liesInSupport(object,x, checkFin = FALSE)
## S4 method for signature 'LatticeDistribution,numeric'
liesInSupport(object,x, checkFin = FALSE)
## S4 method for signature 'DiscreteDistribution,numeric'
liesInSupport(object,x, checkFin = FALSE)
## S4 method for signature 'AbscontDistribution,numeric'
liesInSupport(object,x, checkFin = FALSE)
## S4 method for signature 'Distribution,matrix'
liesInSupport(object,x, checkFin = FALSE)
## S4 method for signature 'ExpOrGammaOrChisq,numeric'
liesInSupport(object,x, checkFin = TRUE)
## S4 method for signature 'Lnorm,numeric'
liesInSupport(object,x, checkFin = TRUE)
## S4 method for signature 'Fd,numeric'
liesInSupport(object,x, checkFin = TRUE)
## S4 method for signature 'Norm,numeric'
liesInSupport(object,x, checkFin = TRUE)
## S4 method for signature 'DExp,numeric'
liesInSupport(object,x, checkFin = TRUE)
## S4 method for signature 'Cauchy,numeric'
liesInSupport(object,x, checkFin = TRUE)
## S4 method for signature 'Td,numeric'
liesInSupport(object,x, checkFin = TRUE)
## S4 method for signature 'Logis,numeric'
liesInSupport(object,x, checkFin = TRUE)
## S4 method for signature 'Weibull,numeric'
liesInSupport(object,x, checkFin = TRUE)
## S4 method for signature 'Unif,numeric'
liesInSupport(object,x, checkFin = TRUE)
## S4 method for signature 'Beta,numeric'
liesInSupport(object,x, checkFin = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="liesInSupport_+3A_object">object</code></td>
<td>
<p> object of class <code>"Distribution"</code> </p>
</td></tr>
<tr><td><code id="liesInSupport_+3A_x">x</code></td>
<td>
<p> numeric vector or matrix </p>
</td></tr>
<tr><td><code id="liesInSupport_+3A_checkfin">checkFin</code></td>
<td>
<p> logical: in case <code>FALSE</code>, we simply check whether
<code>x</code> lies in the <em>numerical</em> (i.e., possibly cut
to relevant quantile range) support; in case <code>TRUE</code> we try to
check this by more exact techniques (e.g. in case of lattice distributions)
and by using slot <code>.finSupport</code> / the return values of <code>q.l(object)</code>
in <code>0</code> and <code>1</code>. This is only used on discrete (parts of)
distributions).</p>
</td></tr>
<tr><td><code id="liesInSupport_+3A_...">...</code></td>
<td>
<p> used for specific arguments to particular methods. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;DiscreteDistribution&quot;, x = &quot;numeric&quot;:</dt><dd> 
<p>We return a logical vector of the same length as <code>x</code> with <code>TRUE</code>
when <code>x</code> lies in the support of <code>object</code>.
As support we use the value of <code>support(object)</code>, so this
is possibly cut to relevant quantile ranges.
In case <code>checkFin</code> is <code>TRUE</code>, in addition, we flag those coordinates
to <code>TRUE</code> where <code>x &lt; min(support(object))</code> if
<code>is.na(object@.finSupport[1])</code> or <code>object@.finSupport[1]==FALSE</code>
or <code>q.l(object)(0)==-Inf</code>, and similarly, where
<code>x &gt; max(support(object))</code> if <code>is.na(object@.finSupport[2])</code>
or <code>object@.finSupport[2]==FALSE</code> or <code>q.l(object)(1)==Inf</code>.
In addition we flag those coordinates to <code>TRUE</code> where
<code>q.l(object)(0)&lt;=x&lt;min(support(object))</code> if
<code>object@.finSupport[1]==TRUE</code> and, similarly, where
<code>q.l(object)(1)&gt;=x&gt;max(support(object))</code> if
<code>object@.finSupport[2]==TRUE</code>.
</p>
</dd>
<dt>object = &quot;Distribution&quot;, x = &quot;matrix&quot;:</dt><dd>
<p>Argument <code>x</code> is cast to vector and then the respective
<code>liesInSupport</code> method for vectors is called. The method throws an
arror when the dispatch mechanism does not find a suitable, applicable
respective vector-method.
</p>
</dd>
<dt>object = &quot;AbscontDistribution&quot;, x = &quot;numeric&quot;:</dt><dd>
<p>We return a logical vector of the same length as <code>x</code> with <code>TRUE</code>
where <code>q.l(object)(0)&lt;=x&lt;=q.l(object)(1)</code> (and replace the boundary
values by <code>q.l(object)(10*.Machine$double.eps)</code> resp.
<code>q.l(object)(1-10*.Machine$double.eps)</code> once the return values
for <code>0</code> or <code>1</code> return are <code>NaN</code>.
</p>
</dd>
<dt>object = &quot;LatticeDistribution&quot;, x = &quot;numeric&quot;:</dt><dd>
<p>We return a logical vector of the same length as <code>x</code> with <code>TRUE</code>
when <code>x</code> lies in the support of <code>object</code>.
As support we use the value of <code>support(object)</code>, so this
is possibly cut to relevant quantile ranges.
In case <code>checkFin</code> is <code>TRUE</code>, we instead use the lattice
information: We check whether all values
<code>(x-pivot(lattice(object))/width(lattice(object))</code> are non-negative
integers and are non larger than <code>Length(lattice(object))-1</code>.
In addition, we flag those coordinates to <code>TRUE</code> where
<code>x &lt; min(support(object))</code> if
<code>is.na(object@.finSupport[1])</code> or <code>object@.finSupport[1]==FALSE</code>,
and similarly, where <code>x &gt; max(support(object))</code> if
<code>is.na(object@.finSupport[2])</code>
or <code>object@.finSupport[2]==FALSE</code>.
</p>
</dd>
<dt>object = &quot;UnivarLebDecDistribution&quot;, x = &quot;numeric&quot;:</dt><dd>
<p>We split up <code>object</code> into discrete and absolutely continuous
part and for each of them apply <code>liesInSupport</code> separately;
the two return values are combined by a coponentwise logical <code>|</code>.
</p>
</dd>
<dt>object = &quot;UnivarMixingDistribution&quot;, x = &quot;numeric&quot;:</dt><dd>
<p>We first cast <code>object</code> to <code>UnivarLebDecDistribution</code>
by <code>flat.mix</code> and then apply the respective method.
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a> and
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Distribution-class">Distribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>liesInSupport(Exp(1), rnorm(10))

# note
x &lt;- rpois(10, lambda = 10)
liesInSupport(Pois(1), x)
# better
liesInSupport(Pois(1), x, checkFin = TRUE)
liesInSupport(Pois(1), 1000*x, checkFin = TRUE)
liesInSupport(-10*Pois(1), -10*x+1, checkFin = TRUE)

xs = c(1000*x,runif(10))
D &lt;- UnivarMixingDistribution(Pois(1),Unif())
liesInSupport(D, xs)

</code></pre>

<hr>
<h2 id='Lnorm-class'>Class &quot;Lnorm&quot;</h2><span id='topic+Lnorm-class'></span><span id='topic+Lnorm'></span><span id='topic+initialize+2CLnorm-method'></span>

<h3>Description</h3>

 
<p>The log normal distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
    d(x) = \frac{1}{\sqrt{2\pi}\sigma x} e^{-(\log(x) - \mu)^2/2 \sigma^2}%
  </code>
</p>

<p>where <code class="reqn">\mu</code>, by default <code class="reqn">=0</code>, and <code class="reqn">\sigma</code>, by default <code class="reqn">=1</code>, are the mean and standard
deviation of the logarithm.
C.f. <code><a href="stats.html#topic+Lognormal">rlnorm</a></code> </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Lnorm(meanlog, sdlog)</code>.
This object is a log normal distribution.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>: The space of the image of this distribution has got dimension 1
and the name &quot;Real Space&quot;. </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"LnormParameter"</code>: the parameter of this distribution (meanlog and sdlog),
declared at its instantiation </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: generates random numbers (calls function <code>rlnorm</code>)</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>: density function (calls function <code>dlnorm</code>)</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>: cumulative function (calls function <code>plnorm</code>)</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>: inverse of the cumulative function (calls function <code>qlnorm</code>)</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"AbscontDistribution"</code>, directly.<br />
Class <code>"UnivariateDistribution"</code>, by class <code>"AbscontDistribution"</code>.<br />
Class <code>"Distribution"</code>, by class <code>"AbscontDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "Lnorm")</code>: initialize method </p>
</dd>
<dt>meanlog</dt><dd><p><code>signature(object = "Lnorm")</code>: returns the slot <code>meanlog</code> of the parameter of the distribution </p>
</dd>
<dt>meanlog&lt;-</dt><dd><p><code>signature(object = "Lnorm")</code>: modifies the slot <code>meanlog</code> of the parameter of the distribution </p>
</dd>
<dt>sdlog</dt><dd><p><code>signature(object = "Lnorm")</code>: returns the slot <code>sdlog</code> of the parameter of the distribution </p>
</dd>
<dt>sdlog&lt;-</dt><dd><p><code>signature(object = "Lnorm")</code>: modifies the slot <code>sdlog</code> of the parameter of the distribution </p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "Lnorm", e2 = "numeric")</code>:
For the Lognormal distribution we use its closedness under positive scaling transformations.</p>
</dd>
</dl>



<h3>Note</h3>

<p>  The mean is <code class="reqn">E(X) = exp(\mu + 1/2 \sigma^2)</code>, and the variance
<code class="reqn">Var(X) = exp(2\mu + \sigma^2)(exp(\sigma^2) - 1)</code> and
hence the coefficient of variation is
<code class="reqn">\sqrt{exp(\sigma^2) - 1}</code> which is
approximately <code class="reqn">\sigma</code> when that is small (e.g., <code class="reqn">\sigma &lt; 1/2</code>).
</p>


<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LnormParameter-class">LnormParameter-class</a></code>
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>
<code><a href="#topic+Reals-class">Reals-class</a></code>
<code><a href="stats.html#topic+Lognormal">rlnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L &lt;- Lnorm(meanlog=1,sdlog=1) # L is a lnorm distribution with mean=1 and sd=1.
r(L)(1) # one random number generated from this distribution, e.g. 3.608011
d(L)(1) # Density of this distribution is 0.2419707 for x=1.
p(L)(1) # Probability that x&lt;1 is 0.1586553.
q(L)(.1) # Probability that x&lt;0.754612 is 0.1.
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
meanlog(L) # meanlog of this distribution is 1.
meanlog(L) &lt;- 2 # meanlog of this distribution is now 2.
</code></pre>

<hr>
<h2 id='LnormParameter-class'>Class &quot;LnormParameter&quot;</h2><span id='topic+LnormParameter-class'></span><span id='topic+initialize+2CLnormParameter-method'></span>

<h3>Description</h3>

<p> The parameter of a log normal distribution, used by Lnorm-class</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("LnormParameter", meanlog, sdlog)</code>.
Usually an object of this class is not needed on its own, it is generated automatically when an object of the class Lnorm
is instantiated. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>meanlog</code></dt><dd><p>Object of class <code>"numeric"</code>: the mean of a log normal distribution </p>
</dd>
<dt><code>sdlog</code></dt><dd><p>Object of class <code>"numeric"</code>: the sd of a log normal distribution </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: a name / comment for the parameters </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "LnormParameter")</code>: initialize method </p>
</dd>
<dt>sdlog</dt><dd><p><code>signature(object = "LnormParameter")</code>: returns the slot sdlog of the parameter of the distribution </p>
</dd>
<dt>sdlog&lt;-</dt><dd><p><code>signature(object = "LnormParameter")</code>: modifies the slot sdlog of the parameter of the
distribution </p>
</dd>
<dt>meanlog</dt><dd><p><code>signature(object = "LnormParameter")</code>: returns the slot meanlog of the parameter of the
distribution</p>
</dd>
<dt>meanlog&lt;-</dt><dd><p><code>signature(object = "LnormParameter")</code>: modifies the slot meanlog of the parameter of the
distribution </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lnorm-class">Lnorm-class</a></code>
<code><a href="#topic+Parameter-class">Parameter-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- new("LnormParameter",sdlog=1,meanlog=0)
meanlog(W) # meanlog of this distribution is 0.
meanlog(W) &lt;- 2 # meanlog of this distribution is now 2.
</code></pre>

<hr>
<h2 id='location-methods'> Methods for Function location in Package &lsquo;distr&rsquo; </h2><span id='topic+location-methods'></span><span id='topic+location+3C--methods'></span><span id='topic+location'></span><span id='topic+location+3C-'></span><span id='topic+location+2CLogisParameter-method'></span><span id='topic+location+2CLogis-method'></span><span id='topic+location+2CCauchyParameter-method'></span><span id='topic+location+2CCauchy-method'></span><span id='topic+location+2CDiracParameter-method'></span><span id='topic+location+2CDirac-method'></span><span id='topic+location+3C-+2CLogisParameter-method'></span><span id='topic+location+3C-+2CLogis-method'></span><span id='topic+location+3C-+2CCauchyParameter-method'></span><span id='topic+location+3C-+2CCauchy-method'></span><span id='topic+location+3C-+2CDiracParameter-method'></span><span id='topic+location+3C-+2CDirac-method'></span>

<h3>Description</h3>

<p>location-methods</p>


<h3>Methods</h3>


<dl>
<dt>location</dt><dd><p><code>signature(object = "LogisParameter")</code>: returns the slot <code>location</code> of the parameter of the distribution </p>
</dd>
<dt>location&lt;-</dt><dd><p><code>signature(object = "LogisParameter")</code>: modifies the slot <code>location</code> of the parameter of the
distribution </p>
</dd>
<dt>location</dt><dd><p><code>signature(object = "Logis")</code>: returns the slot <code>location</code> of the parameter of the distribution </p>
</dd>
<dt>location&lt;-</dt><dd><p><code>signature(object = "Logis")</code>: modifies the slot <code>location</code> of the parameter of the distribution </p>
</dd>
<dt>location</dt><dd><p><code>signature(object = "CauchyParameter")</code>: returns the slot <code>location</code> of the parameter of the distribution </p>
</dd>
<dt>location&lt;-</dt><dd><p><code>signature(object = "CauchyParameter")</code>: modifies the slot <code>location</code> of the parameter of the
distribution </p>
</dd>
<dt>location</dt><dd><p><code>signature(object = "Cauchy")</code>: returns the slot <code>location</code> of the parameter of the distribution </p>
</dd>
<dt>location&lt;-</dt><dd><p><code>signature(object = "Cauchy")</code>: modifies the slot <code>location</code> of the parameter of the distribution </p>
</dd>
<dt>location</dt><dd><p><code>signature(object = "DiracParameter")</code>: returns the slot <code>location</code> of the parameter of the distribution </p>
</dd>
<dt>location&lt;-</dt><dd><p><code>signature(object = "DiracParameter")</code>: modifies the slot <code>location</code> of the parameter of the
distribution</p>
</dd>
<dt>location</dt><dd><p><code>signature(object = "Dirac")</code>: returns the slot <code>location</code> of the parameter of the distribution </p>
</dd>
<dt>location&lt;-</dt><dd><p><code>signature(object = "Dirac")</code>: modifies the slot <code>location</code> of the parameter of the distribution </p>
</dd>
</dl>

<hr>
<h2 id='Logis-class'>Class &quot;Logis&quot;</h2><span id='topic+Logis-class'></span><span id='topic+Logis'></span><span id='topic+initialize+2CLogis-method'></span>

<h3>Description</h3>

<p> The Logistic distribution with <code>location</code> <code class="reqn">= \mu</code>, 
by default <code>= 0</code>, and <code>scale</code> <code class="reqn">= \sigma</code>, by default <code>= 1</code>, 
has distribution function
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \frac{1}{1 + e^{-(x-\mu)/\sigma}}%
  </code>
</p>
<p>  and density
</p>
<p style="text-align: center;"><code class="reqn">
    d(x)= \frac{1}{\sigma}\frac{e^{(x-\mu)/\sigma}}{(1 + e^{(x-\mu)/\sigma})^2}%
  </code>
</p>

<p>It is a long-tailed distribution with mean <code class="reqn">\mu</code> and variance
<code class="reqn">\pi^2/3 \sigma^2</code>. C.f. <code><a href="stats.html#topic+Logistic">rlogis</a></code> 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Logis(location, scale)</code>.
This object is a logistic distribution.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>: The space of the image of this distribution has got dimension 1
and the name &quot;Real Space&quot;. </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"LogisParameter"</code>: the parameter of this distribution (location and scale),
declared at its instantiation </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: generates random numbers (calls function rlogis)</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>: density function (calls function dlogis)</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>: cumulative function (calls function plogis)</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>: inverse of the cumulative function (calls function qlogis)</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"AbscontDistribution"</code>, directly.<br />
Class <code>"UnivariateDistribution"</code>, by class <code>"AbscontDistribution"</code>.<br />
Class <code>"Distribution"</code>, by class <code>"AbscontDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "Logis")</code>: initialize method </p>
</dd>
<dt>location</dt><dd><p><code>signature(object = "Logis")</code>: returns the slot <code>location</code> of the parameter of the distribution </p>
</dd>
<dt>location&lt;-</dt><dd><p><code>signature(object = "Logis")</code>: modifies the slot <code>location</code> of the parameter of the distribution </p>
</dd>
<dt>scale</dt><dd><p><code>signature(object = "Logis")</code>: returns the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>scale&lt;-</dt><dd><p><code>signature(object = "Logis")</code>: modifies the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "Logis", e2 = "numeric")</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "Logis", e2 = "numeric")</code>: 
For the logistic location scale family we use its closedness under affine linear transformations.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LogisParameter-class">LogisParameter-class</a></code>
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>
<code><a href="#topic+Reals-class">Reals-class</a></code>
<code><a href="stats.html#topic+Logistic">rlogis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L &lt;- Logis(location = 1,scale = 1)
# L is a logistic distribution with  location = 1 and scale = 1.
r(L)(1) # one random number generated from this distribution, e.g. 5.87557
d(L)(1) # Density of this distribution is 0.25 for x = 1.
p(L)(1) # Probability that x &lt; 1 is 0.5.
q(L)(.1) # Probability that x &lt; -1.197225 is 0.1.
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
location(L) # location of this distribution is 1.
location(L) &lt;- 2 # location of this distribution is now 2.
</code></pre>

<hr>
<h2 id='LogisParameter-class'>Class &quot;LogisParameter&quot;</h2><span id='topic+LogisParameter-class'></span><span id='topic+initialize+2CLogisParameter-method'></span>

<h3>Description</h3>

<p> The parameter of a logistic distribution, used by <code>Logis</code>-class</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("LogisParameter", scale, location)</code>.
Usually an object of this class is not needed on its own, it is generated automatically when an object of the class 
<code>Logis</code> is instantiated. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>scale</code></dt><dd><p>Object of class <code>"numeric"</code>: the scale of a logistic distribution </p>
</dd>
<dt><code>location</code></dt><dd><p>Object of class <code>"numeric"</code>: the location of a logistic distribution </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: a name / comment for the parameters </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "LogisParameter")</code>: initialize method </p>
</dd>
<dt>location</dt><dd><p><code>signature(object = "LogisParameter")</code>: returns the slot <code>location</code> of the parameter of the
distribution </p>
</dd>
<dt>location&lt;-</dt><dd><p><code>signature(object = "LogisParameter")</code>: modifies the slot <code>location</code> of the parameter of the
distribution </p>
</dd>
<dt>scale</dt><dd><p><code>signature(object = "LogisParameter")</code>: returns the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>scale&lt;-</dt><dd><p><code>signature(object = "LogisParameter")</code>: modifies the slot <code>scale</code> of the parameter of the
distribution </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Logis-class">Logis-class</a></code>
<code><a href="#topic+Parameter-class">Parameter-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- new("LogisParameter",location=0,scale=1)
scale(W) # scale of this distribution is 1.
scale(W) &lt;- 2 # scale of this distribution is now 2.
</code></pre>

<hr>
<h2 id='m-methods'> Methods for Function m in Package &lsquo;distr&rsquo; </h2><span id='topic+m-methods'></span><span id='topic+m+3C--methods'></span><span id='topic+m'></span><span id='topic+m+3C-'></span><span id='topic+m+2CHyperParameter-method'></span><span id='topic+m+2CHyper-method'></span><span id='topic+m+3C-+2CHyperParameter-method'></span><span id='topic+m+3C-+2CHyper-method'></span>

<h3>Description</h3>

<p>m-methods</p>


<h3>Methods</h3>


<dl>
<dt>m</dt><dd><p><code>signature(object = "HyperParameter")</code>: returns the slot m of the parameter of the distribution </p>
</dd>
<dt>m&lt;-</dt><dd><p><code>signature(object = "HyperParameter")</code>: modifies the slot m of the parameter of the distribution </p>
</dd>
<dt>m</dt><dd><p><code>signature(object = "Hyper")</code>: returns the slot m of the parameter of the distribution </p>
</dd>
<dt>m&lt;-</dt><dd><p><code>signature(object = "Hyper")</code>: modifies the slot m of the parameter of the distribution </p>
</dd>
</dl>

<hr>
<h2 id='makeAbscontDistribution'>&quot;makeAbscontDistribution&quot;</h2><span id='topic+makeAbscontDistribution'></span>

<h3>Description</h3>

<p>Transforms an object of <code>"UnivariateDistribution"</code> to 
an object of class <code>"makeAbscontDistribution"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeAbscontDistribution(object, gaps = NULL,
                       param = NULL, img = NULL,
                   withgaps = getdistrOption("withgaps"),
                   ngrid = getdistrOption("DefaultNrGridPoints"),
                   ep = getdistrOption("TruncQuantile"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeAbscontDistribution_+3A_object">object</code></td>
<td>
<p>Objects of class <code>"UnivariateDistribution"</code> (or subclasses)</p>
</td></tr>
<tr><td><code id="makeAbscontDistribution_+3A_gaps">gaps</code></td>
<td>
<p>slot gaps (of class <code>"matrix"</code> with two columns) to be filled 
(i.e. <code>t(gaps)</code> must be ordered if read as vector)</p>
</td></tr> 
<tr><td><code id="makeAbscontDistribution_+3A_param">param</code></td>
<td>
<p>parameter (of class <code>"OptionalParameter"</code>)</p>
</td></tr> 
<tr><td><code id="makeAbscontDistribution_+3A_img">img</code></td>
<td>
<p>image range of the distribution (of class <code>"rSpace"</code>)</p>
</td></tr> 
<tr><td><code id="makeAbscontDistribution_+3A_withgaps">withgaps</code></td>
<td>
<p>logical; shall gaps be reconstructed empirically?</p>
</td></tr>
<tr><td><code id="makeAbscontDistribution_+3A_ngrid">ngrid</code></td>
<td>
<p>number of gridpoints</p>
</td></tr>
<tr><td><code id="makeAbscontDistribution_+3A_ep">ep</code></td>
<td>
<p>tolerance epsilon</p>
</td></tr>
</table>


<h3>Details</h3>

<p>takes slot <code>p</code> of <code>object</code> and then generates an
<code>"AbscontDistribution"</code> object using generating function
<code><a href="#topic+AbscontDistribution">AbscontDistribution</a></code>.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>  Hu &lt;- Huberize(Norm(), -2,1)
  Hu
  plot(Hu)
  Hu0 &lt;- makeAbscontDistribution(Hu)
  Hu0
  plot(Hu0)
</code></pre>

<hr>
<h2 id='Math-methods'> Methods for Functions from group &lsquo;Math&rsquo; in Package &lsquo;distr&rsquo; </h2><span id='topic+Math-methods'></span><span id='topic+log-methods'></span><span id='topic+log10-methods'></span><span id='topic+lgamma-methods'></span><span id='topic+gamma-methods'></span><span id='topic+sign-methods'></span><span id='topic+Math+2CAcDcLcDistribution-method'></span><span id='topic+Math+2CAbscontDistribution-method'></span><span id='topic+Math+2CDiscreteDistribution-method'></span><span id='topic+abs+2CAbscontDistribution-method'></span><span id='topic+abs+2CDiscreteDistribution-method'></span><span id='topic+exp+2CAbscontDistribution-method'></span><span id='topic+exp+2CDiscreteDistribution-method'></span><span id='topic+log+2CAbscontDistribution-method'></span><span id='topic+log+2CDiscreteDistribution-method'></span><span id='topic+sign+2CAbscontDistribution-method'></span><span id='topic+sign+2CDiscreteDistribution-method'></span><span id='topic+log10+2CAbscontDistribution-method'></span><span id='topic+log10+2CDiscreteDistribution-method'></span><span id='topic+digamma+2CAbscontDistribution-method'></span><span id='topic+digamma+2CDiscreteDistribution-method'></span><span id='topic+lgamma+2CAbscontDistribution-method'></span><span id='topic+lgamma+2CDiscreteDistribution-method'></span><span id='topic+gamma+2CAbscontDistribution-method'></span><span id='topic+gamma+2CDiscreteDistribution-method'></span>

<h3>Description</h3>

<p>Math-methods provide automatical generation of image distributions
for random variables transformed by functions from group
<code><a href="methods.html#topic+S4groupGeneric">Math</a></code></p>


<h3>Methods</h3>


<dl>
<dt>Math</dt><dd><p><code>signature(x = "AbscontDistribution")</code>: application of a
mathematical function from group <code><a href="methods.html#topic+S4groupGeneric">Math</a></code>, e.g.
<code>sin</code> or <code>exp</code>  (including
<code>log, log10, gamma, lgamma, digamma</code>), to this
absolutely continouos distribution</p>
</dd>
<dt>Math</dt><dd><p><code>signature(x = "DiscreteDistribution")</code>: application of a
mathematical function, e.g. sin or exp  (including
<code>log, log10, gamma, lgamma, digamma</code>), to this
discrete distribution</p>
</dd>
<dt>Math</dt><dd><p><code>signature(x = "UnivarLebDecDistribution")</code>: application of a
mathematical function from group <code><a href="methods.html#topic+S4groupGeneric">Math</a></code>, e.g.
<code>sin</code> or <code>exp</code>  (including
<code>log, log10, gamma, lgamma</code>), to this
Lebesgue decomposed distribution</p>
</dd>
<dt>Math</dt><dd><p><code>signature(x = "UnivarLebDecDistribution")</code>: application of a
mathematical function from group <code><a href="methods.html#topic+S4groupGeneric">Math</a></code>, e.g.
<code>sin</code> or <code>exp</code>  (including
<code>log, log10, gamma, lgamma</code>), to this
distribution of class <code>"AcDcLcDistribution"</code></p>
</dd>
<dt>abs</dt><dd><p><code>signature(x = "AbscontDistribution")</code>: application of 
function <code>abs</code> to this absolutely continouos distribution; 
(exactly)</p>
</dd>
<dt>abs</dt><dd><p><code>signature(x = "DiscreteDistribution")</code>: application of 
function <code>abs</code> to this discrete distribution; 
(exactly)</p>
</dd>
<dt>sign</dt><dd><p><code>signature(x = "AbscontDistribution")</code>: application of 
function <code>abs</code> to this absolutely continouos distribution; 
(exactly)</p>
</dd>
<dt>sign</dt><dd><p><code>signature(x = "DiscreteDistribution")</code>: application of 
function <code>abs</code> to this discrete continouos distribution; 
(exactly)</p>
</dd>
<dt>exp</dt><dd><p><code>signature(x = "AbscontDistribution")</code>: application of
function <code>exp</code> to this absolutely continouos distribution;
(exactly)</p>
</dd>
<dt>exp</dt><dd><p><code>signature(x = "DiscreteDistribution")</code>: application of
function <code>exp</code> to this discrete distribution;
(exactly)</p>
</dd>
<dt>log</dt><dd><p><code>signature(x = "AbscontDistribution")</code>: application of
function <code>log</code> to this absolutely continouos distribution;
(exactly for R-version <code>&gt;2.5.1</code>)</p>
</dd>
<dt>log</dt><dd><p><code>signature(x = "DiscreteDistribution")</code>: application of
function <code>log</code> to this discrete distribution;
(exactly for R-version <code>&gt;2.5.1</code>)</p>
</dd>
</dl>

<hr>
<h2 id='Max-methods'> Methods for Function Max in Package &lsquo;distr&rsquo; </h2><span id='topic+Max-methods'></span><span id='topic+Max+3C--methods'></span><span id='topic+Max'></span><span id='topic+Max+3C-'></span><span id='topic+Max+2CUnifParameter-method'></span><span id='topic+Max+2CUnif-method'></span><span id='topic+Max+3C-+2CUnifParameter-method'></span><span id='topic+Max+3C-+2CUnif-method'></span>

<h3>Description</h3>

<p>Max-methods</p>


<h3>Methods</h3>


<dl>
<dt>Max</dt><dd><p><code>signature(object = "UnifParameter")</code>: returns the slot <code>Max</code> of the parameter of the distribution </p>
</dd>
<dt>Max&lt;-</dt><dd><p><code>signature(object = "UnifParameter")</code>: modifies the slot <code>Max</code> of the parameter of the distribution </p>
</dd>
<dt>Max</dt><dd><p><code>signature(object = "Unif")</code>: returns the slot <code>Max</code> of the parameter of the distribution </p>
</dd>
<dt>Max&lt;-</dt><dd><p><code>signature(object = "Unif")</code>: modifies the slot <code>Max</code> of the parameter of the distribution </p>
</dd>
</dl>

<hr>
<h2 id='mean-methods'> Methods for Function mean in Package &lsquo;distr&rsquo; </h2><span id='topic+mean-methods'></span><span id='topic+mean+3C--methods'></span><span id='topic+mean'></span><span id='topic+mean+3C-'></span><span id='topic+mean+2CNormParameter-method'></span><span id='topic+mean+2CNorm-method'></span><span id='topic+mean+3C-+2CNormParameter-method'></span><span id='topic+mean+3C-+2CNorm-method'></span>

<h3>Description</h3>

<p>mean-methods</p>


<h3>Methods</h3>


<dl>
<dt>mean</dt><dd><p><code>signature(object = "NormParameter")</code>: returns the slot mean of the parameter of the distribution </p>
</dd>    
<dt>mean&lt;-</dt><dd><p><code>signature(object = "NormParameter")</code>: modifies the slot mean of the parameter of the distribution </p>
</dd>
<dt>mean</dt><dd><p><code>signature(object = "Norm")</code>: returns the slot mean of the parameter of the distribution </p>
</dd>
<dt>mean&lt;-</dt><dd><p><code>signature(object = "Norm")</code>: modifies the slot mean of the parameter of the distribution </p>
</dd>
</dl>

<hr>
<h2 id='meanlog-methods'> Methods for Function meanlog in Package &lsquo;distr&rsquo; </h2><span id='topic+meanlog-methods'></span><span id='topic+meanlog+3C--methods'></span><span id='topic+meanlog'></span><span id='topic+meanlog+3C-'></span><span id='topic+meanlog+2CLnormParameter-method'></span><span id='topic+meanlog+2CLnorm-method'></span><span id='topic+meanlog+3C-+2CLnormParameter-method'></span><span id='topic+meanlog+3C-+2CLnorm-method'></span>

<h3>Description</h3>

<p>meanlog-methods</p>


<h3>Methods</h3>


<dl>
<dt>meanlog</dt><dd><p><code>signature(object = "LnormParameter")</code>: returns the slot meanlog of the parameter of the distribution </p>
</dd>
<dt>meanlog&lt;-</dt><dd><p><code>signature(object = "LnormParameter")</code>: modifies the slot meanlog of the parameter of the distribution </p>
</dd>
<dt>meanlog</dt><dd><p><code>signature(object = "Lnorm")</code>: returns the slot meanlog of the parameter of the distribution </p>
</dd>
<dt>meanlog&lt;-</dt><dd><p><code>signature(object = "Lnorm")</code>: modifies the slot meanlog of the parameter of the distribution </p>
</dd>
</dl>

<hr>
<h2 id='Min-methods'> Methods for Function Min in Package &lsquo;distr&rsquo; </h2><span id='topic+Min-methods'></span><span id='topic+Min+3C--methods'></span><span id='topic+Min'></span><span id='topic+Min+3C-'></span><span id='topic+Min+2CUnifParameter-method'></span><span id='topic+Min+2CUnif-method'></span><span id='topic+Min+3C-+2CUnifParameter-method'></span><span id='topic+Min+3C-+2CUnif-method'></span>

<h3>Description</h3>

<p>Min-methods</p>


<h3>Methods</h3>


<dl>
<dt>Min</dt><dd><p><code>signature(object = "UnifParameter")</code>: returns the slot <code>Min</code> of the parameter of the distribution </p>
</dd>
<dt>Min&lt;-</dt><dd><p><code>signature(object = "UnifParameter")</code>: modifies the slot <code>Min</code> of the parameter of the distribution </p>
</dd>
<dt>Min</dt><dd><p><code>signature(object = "Unif")</code>: returns the slot <code>Min</code> of the parameter of the distribution </p>
</dd>
<dt>Min&lt;-</dt><dd><p><code>signature(object = "Unif")</code>: modifies the slot <code>Min</code> of the parameter of the distribution </p>
</dd>
</dl>

<hr>
<h2 id='Minimum-methods'> Methods for functions Minimum and Maximum in Package &lsquo;distr&rsquo; </h2><span id='topic+Minimum-methods'></span><span id='topic+Minimum'></span><span id='topic+Maximum-methods'></span><span id='topic+Maximum'></span><span id='topic+Minimum+2CAbscontDistribution+2CAbscontDistribution-method'></span><span id='topic+Minimum+2CDiscreteDistribution+2CDiscreteDistribution-method'></span><span id='topic+Minimum+2CAbscontDistribution+2CDirac-method'></span><span id='topic+Minimum+2CAcDcLcDistribution+2CAcDcLcDistribution-method'></span><span id='topic+Minimum+2CAbscontDistribution+2Cnumeric-method'></span><span id='topic+Minimum+2CDiscreteDistribution+2Cnumeric-method'></span><span id='topic+Minimum+2CAcDcLcDistribution+2Cnumeric-method'></span><span id='topic+Maximum+2CAcDcLcDistribution+2CAcDcLcDistribution-method'></span><span id='topic+Maximum+2CAcDcLcDistribution+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Minimum and Maximum-methods</p>


<h3>Usage</h3>

<pre><code class='language-R'>Minimum(e1, e2, ...)
Maximum(e1, e2, ...) 
## S4 method for signature 'AbscontDistribution,AbscontDistribution'
Minimum(e1,e2, ...)
## S4 method for signature 'DiscreteDistribution,DiscreteDistribution'
Minimum(e1,e2, ...)
## S4 method for signature 'AbscontDistribution,Dirac'
Minimum(e1,e2, 
                   withSimplify = getdistrOption("simplifyD"))
## S4 method for signature 'AcDcLcDistribution,AcDcLcDistribution'
Minimum(e1,e2, 
                   withSimplify = getdistrOption("simplifyD"))
## S4 method for signature 'AcDcLcDistribution,AcDcLcDistribution'
Maximum(e1,e2, 
                   withSimplify = getdistrOption("simplifyD"))
## S4 method for signature 'AbscontDistribution,numeric'
Minimum(e1,e2, ...)
## S4 method for signature 'DiscreteDistribution,numeric'
Minimum(e1,e2, ...)
## S4 method for signature 'AcDcLcDistribution,numeric'
Minimum(e1,e2,
                   withSimplify = getdistrOption("simplifyD"))
## S4 method for signature 'AcDcLcDistribution,numeric'
Maximum(e1,e2, 
                   withSimplify = getdistrOption("simplifyD"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Minimum-methods_+3A_e1">e1</code></td>
<td>
<p>distribution object</p>
</td></tr>
<tr><td><code id="Minimum-methods_+3A_e2">e2</code></td>
<td>
<p>distribution object or numeric</p>
</td></tr>
<tr><td><code id="Minimum-methods_+3A_...">...</code></td>
<td>
<p>further arguments (to be able to call various methods  with the same
arguments</p>
</td></tr>
<tr><td><code id="Minimum-methods_+3A_withsimplify">withSimplify</code></td>
<td>
<p>logical; is result to be piped through a call to 
<code><a href="#topic+simplifyD">simplifyD</a></code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the corresponding distribution of the minimum / maximum</p>


<h3>Methods</h3>


<dl>
<dt>Minimum</dt><dd><p><code>signature(e1 = "AbscontDistribution", e2 = "AbscontDistribution")</code>: 
returns the distribution of <code>min(X1,X2)</code>, if <code>X1</code>,<code>X2</code> are independent
and distributed according to <code>e1</code> and <code>e2</code> respectively;
the result is again of class <code>"AbscontDistribution"</code></p>
</dd>
<dt>Minimum</dt><dd><p><code>signature(e1 = "DiscreteDistribution", e2 = "DiscreteDistribution")</code>: 
returns the distribution of <code>min(X1,X2)</code>, if <code>X1</code>,<code>X2</code> are independent
and distributed according to <code>e1</code> and <code>e2</code> respectively;
the result is again of class <code>"DiscreteDistribution"</code></p>
</dd>
<dt>Minimum</dt><dd><p><code>signature(e1 = "AbscontDistribution", e2 = "Dirac")</code>: 
returns the distribution of <code>min(X1,X2)</code>, if <code>X1</code>,<code>X2</code> are  
distributed according to <code>e1</code> and <code>e2</code> respectively;
the result is of class <code>"UnivarLebDecDistribution"</code></p>
</dd>
<dt>Minimum</dt><dd><p><code>signature(e1 = "AcDcLcDistribution", e2 = "AcDcLcDistribution")</code>: 
returns the distribution of <code>min(X1,X2)</code>, if <code>X1</code>,<code>X2</code> are  
distributed according to <code>e1</code> and <code>e2</code> respectively;
the result is of class <code>"UnivarLebDecDistribution"</code></p>
</dd>
<dt>Minimum</dt><dd><p><code>signature(e1 = "AcDcLcDistribution", e2 = "numeric")</code>: 
if <code>e2</code> = <code class="reqn">n</code>, returns the distribution of <code>min(X1,X2,...,Xn)</code>, if <code>X1</code>,<code>X2</code>, 
..., <code>Xn</code> are i.i.d. according to <code>e1</code>;
the result is of class <code>"UnivarLebDecDistribution"</code></p>
</dd>
<dt>Maximum</dt><dd><p><code>signature(e1 = "AcDcLcDistribution", e2 = "AcDcLcDistribution")</code>: 
returns the distribution of <code>max(X1,X2)</code>, if <code>X1</code>,<code>X2</code> are  
distributed according to <code>e1</code> and <code>e2</code> respectively;
translates into <code>-Minimum(-e1,-e2)</code>;
the result is of class <code>"UnivarLebDecDistribution"</code></p>
</dd>
<dt>Maximum</dt><dd><p><code>signature(e1 = "AcDcLcDistribution", e2 = "numeric")</code>: 
if <code>e2</code> = <code class="reqn">n</code>, returns the distribution of <code>max(X1,X2,...,Xn)</code>, if <code>X1</code>,<code>X2</code>, 
..., <code>Xn</code> are i.i.d. according to <code>e1</code>; translates into 
<code>-Minimum(-e1,e2)</code>; the result is of class <code>"UnivarLebDecDistribution"</code></p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+Huberize">Huberize</a></code>, <code><a href="#topic+Truncate">Truncate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## IGNORE_RDIFF_BEGIN
plot(Maximum(Unif(0,1), Minimum(Unif(0,1), Unif(0,1))))
plot(Minimum(Exp(4),4))
## IGNORE_RDIFF_END


## a sometimes lengthy example...
plot(Minimum(Norm(),Pois()))
</code></pre>

<hr>
<h2 id='n-methods'> Methods for Function n in Package &lsquo;distr&rsquo; </h2><span id='topic+n-methods'></span><span id='topic+n+3C--methods'></span><span id='topic+n'></span><span id='topic+n+3C-'></span><span id='topic+n+2CHyperParameter-method'></span><span id='topic+n+2CHyper-method'></span><span id='topic+n+3C-+2CHyperParameter-method'></span><span id='topic+n+3C-+2CHyper-method'></span>

<h3>Description</h3>

<p>n-methods</p>


<h3>Methods</h3>


<dl>
<dt>n</dt><dd><p><code>signature(object = "HyperParameter")</code>: returns the slot <code>n</code> of the parameter of the distribution </p>
</dd>
<dt>n&lt;-</dt><dd><p><code>signature(object = "HyperParameter")</code>: modifies the slot <code>n</code> of the parameter of the distribution </p>
</dd>
<dt>n</dt><dd><p><code>signature(object = "Hyper")</code>: returns the slot <code>n</code> of the parameter of the distribution </p>
</dd>
<dt>n&lt;-</dt><dd><p><code>signature(object = "Hyper")</code>: modifies the slot <code>n</code> of the parameter of the distribution </p>
</dd>
</dl>

<hr>
<h2 id='name-methods'> Methods for Function name in Package &lsquo;distr&rsquo; </h2><span id='topic+name-methods'></span><span id='topic+name+3C--methods'></span><span id='topic+name'></span><span id='topic+name+3C-'></span><span id='topic+name+2CParameter-method'></span><span id='topic+name+3C-+2CParameter-method'></span><span id='topic+name+2CrSpace-method'></span><span id='topic+name+3C-+2CrSpace-method'></span>

<h3>Description</h3>

<p>name-methods</p>


<h3>Methods</h3>


<dl>
<dt>name</dt><dd><p><code>signature(object = "Parameter")</code>: returns the slot name of the parameter </p>
</dd>
<dt>name&lt;-</dt><dd><p><code>signature(object = "Parameter")</code>: modifies the slot name of the parameter </p>
</dd>
<dt>name</dt><dd><p><code>signature(object = "rSpace")</code>: returns the slot name of the space </p>
</dd>
<dt>name&lt;-</dt><dd><p><code>signature(object = "rSpace")</code>: modifies the slot name of the space </p>
</dd>
</dl>

<hr>
<h2 id='Naturals-class'>Class &quot;Naturals&quot; </h2><span id='topic+Naturals'></span><span id='topic+Naturals-class'></span><span id='topic+initialize+2CNaturals-method'></span>

<h3>Description</h3>

<p> The distribution-classes contain a slot where the sample space is stored. Typically, discrete random
variables take naturals as values. </p>


<h3>Usage</h3>

<pre><code class='language-R'>Naturals()</code></pre>


<h3>Objects from the Class</h3>

<p>Objects could theoretically be created by calls of the form <code>new("Naturals", dimension, name)</code>.
Usually an object of this class is not needed on its own. It is generated automatically when a univariate discrete
distribution is instantiated. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>dimension</code></dt><dd><p>Object of class <code>"character"</code>: the dimension of the space, by default = 1 </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: the name of the space, by default = &quot;Natural Space&quot;</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Reals"</code>, directly.<br />
Class <code>"EuclideanSpace"</code>, by class <code>"Reals"</code>.<br />
Class <code>"rSpace"</code>, by class <code>"Reals"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "Naturals")</code>: initialize method </p>
</dd>
<dt>liesIn</dt><dd><p><code>signature(object = "Naturals", x = "numeric")</code>: Does a particular vector only contain naturals? </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Reals-class">Reals-class</a></code>
<code><a href="#topic+DiscreteDistribution-class">DiscreteDistribution-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- Naturals()
liesIn(N,1) # TRUE
liesIn(N,c(0,1)) # FALSE
liesIn(N,0.1) # FALSE
</code></pre>

<hr>
<h2 id='Nbinom-class'>Class &quot;Nbinom&quot; </h2><span id='topic+Nbinom-class'></span><span id='topic+Nbinom'></span><span id='topic+initialize+2CNbinom-method'></span>

<h3>Description</h3>

<p>The negative binomial distribution with <code>size</code> <code class="reqn">= n</code>, by default <code class="reqn">=1</code>, and
<code>prob</code> <code class="reqn">= p</code>, by default <code class="reqn">=0.5</code>, has density
</p>
<p style="text-align: center;"><code class="reqn">
    d(x) = \frac{\Gamma(x+n)}{\Gamma(n) x!} p^n (1-p)^x</code>
</p>

<p>for <code class="reqn">x = 0, 1, 2, \ldots</code>
</p>
<p>This represents the number of failures
which occur in a sequence of Bernoulli trials before a target number
of successes is reached.
C.f. <code><a href="stats.html#topic+NegBinomial">rnbinom</a></code> 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Nbinom(prob, size)</code>.
This object is a negative binomial distribution. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Naturals"</code>: The space of the image of this
distribution has got dimension 1 and the name &quot;Natural Space&quot;. </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"NbinomParameter"</code>: the parameter of this distribution (prob, size),
declared at its instantiation </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: generates random numbers (calls function <code>rnbinom</code>) </p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>: density function (calls function <code>dnbinom</code>) </p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>: cumulative function (calls function <code>pnbinom</code>) </p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>: inverse of the cumulative function (calls function <code>qnbinom</code>).
The quantile is defined as the smallest value <code class="reqn">x</code> such that
<code class="reqn">F(x) \ge p</code>, where <code class="reqn">F</code> is the distribution function.</p>
</dd>
<dt><code>support</code></dt><dd><p>Object of class <code>"numeric"</code>: a (sorted) vector containing the support of the discrete
density function</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"DiscreteDistribution"</code>, directly.<br />
Class <code>"UnivariateDistribution"</code>, by class <code>"DiscreteDistribution"</code>.<br />
Class <code>"Distribution"</code>, by class <code>"DiscreteDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "Nbinom")</code>: initialize method </p>
</dd>
<dt>prob</dt><dd><p><code>signature(object = "Nbinom")</code>: returns the slot <code>prob</code> of the parameter of the distribution </p>
</dd>
<dt>prob&lt;-</dt><dd><p><code>signature(object = "Nbinom")</code>: modifies the slot <code>prob</code> of the parameter of the distribution </p>
</dd>
<dt>size</dt><dd><p><code>signature(object = "Nbinom")</code>: returns the slot <code>size</code> of the parameter of the distribution </p>
</dd>
<dt>size&lt;-</dt><dd><p><code>signature(object = "Nbinom")</code>: modifies the slot <code>size</code> of the parameter of the distribution </p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "Nbinom", e2 = "Nbinom")</code>: 
For the negative binomial distribution we use its closedness under convolutions.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Working with a computer, we use a finite interval as support which carries at least mass <code>1-getdistrOption("TruncQuantile")</code>. </p>


<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+NbinomParameter-class">NbinomParameter-class</a></code>
<code><a href="#topic+Geom-class">Geom-class</a></code>
<code><a href="#topic+DiscreteDistribution-class">DiscreteDistribution-class</a></code>
<code><a href="#topic+Naturals-class">Naturals-class</a></code>
<code><a href="stats.html#topic+NegBinomial">rnbinom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- Nbinom(prob = 0.5, size = 1) # N is a binomial distribution with prob=0.5 and size=1.
r(N)(1) # one random number generated from this distribution, e.g. 3
d(N)(1) # Density of this distribution is  0.25 for x=1.
p(N)(0.4) # Probability that x&lt;0.4 is 0.5.
q(N)(.1) # x=0 is the smallest value x such that p(B)(x)&gt;=0.1.
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
size(N) # size of this distribution is 1.
size(N) &lt;- 2 # size of this distribution is now 2.
</code></pre>

<hr>
<h2 id='NbinomParameter-class'>Class &quot;NbinomParameter&quot;</h2><span id='topic+NbinomParameter-class'></span><span id='topic+initialize+2CNbinomParameter-method'></span>

<h3>Description</h3>

<p> The parameter of a negative binomial distribution, used by Nbinom-class</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("NbinomParameter", prob, size)</code>.
Usually an object of this class is not needed on its own, it is generated automatically when an object of the class Nbinom
is prepared. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>prob</code></dt><dd><p>Object of class <code>"numeric"</code>: the probability of a negative binomial distribution </p>
</dd>
<dt><code>size</code></dt><dd><p>Object of class <code>"numeric"</code>: the size of a negative binomial distribution </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: a name / comment for the parameters </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "NbinomParameter")</code>: initialize method </p>
</dd>
<dt>prob</dt><dd><p><code>signature(object = "NbinomParameter")</code>: returns the slot <code>prob</code> of the parameter of the
distribution </p>
</dd>
<dt>prob&lt;-</dt><dd><p><code>signature(object = "NbinomParameter")</code>: modifies the slot <code>prob</code> of the parameter of the
distribution </p>
</dd>
<dt>size</dt><dd><p><code>signature(object = "NbinomParameter")</code>: returns the slot <code>size</code> of the parameter of the distribution </p>
</dd>
<dt>size&lt;-</dt><dd><p><code>signature(object = "NbinomParameter")</code>: modifies the slot <code>size</code> of the parameter of the
distribution </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Nbinom-class">Nbinom-class</a></code>
<code><a href="#topic+Parameter-class">Parameter-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- new("NbinomParameter",prob=0.5,size=1)
size(W) # size of this distribution is 1.
size(W) &lt;- 2 # size of this distribution is now 2.
</code></pre>

<hr>
<h2 id='ncp-methods'> Methods for Function ncp in Package &lsquo;distr&rsquo; </h2><span id='topic+ncp-methods'></span><span id='topic+ncp+3C--methods'></span><span id='topic+ncp'></span><span id='topic+ncp+3C-'></span><span id='topic+ncp+2CChisqParameter-method'></span><span id='topic+ncp+2CChisq-method'></span><span id='topic+ncp+3C-+2CChisqParameter-method'></span><span id='topic+ncp+3C-+2CChisq-method'></span><span id='topic+ncp+2CFParameter-method'></span><span id='topic+ncp+2CFd-method'></span><span id='topic+ncp+3C-+2CFParameter-method'></span><span id='topic+ncp+3C-+2CFd-method'></span><span id='topic+ncp+2CBetaParameter-method'></span><span id='topic+ncp+2CBeta-method'></span><span id='topic+ncp+3C-+2CBetaParameter-method'></span><span id='topic+ncp+3C-+2CBeta-method'></span><span id='topic+ncp+2CTParameter-method'></span><span id='topic+ncp+2CTd-method'></span><span id='topic+ncp+3C-+2CTParameter-method'></span><span id='topic+ncp+3C-+2CTd-method'></span>

<h3>Description</h3>

<p>ncp-methods</p>


<h3>Methods</h3>


<dl>
<dt>ncp</dt><dd><p><code>signature(object = "BetaParameter")</code>: returns the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
<dt>ncp&lt;-</dt><dd><p><code>signature(object = "BetaParameter")</code>: modifies the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
<dt>ncp</dt><dd><p><code>signature(object = "Beta")</code>: returns the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
<dt>ncp&lt;-</dt><dd><p><code>signature(object = "Beta")</code>: modifies the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
<dt>ncp</dt><dd><p><code>signature(object = "ChisqParameter")</code>: returns the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
<dt>ncp&lt;-</dt><dd><p><code>signature(object = "ChisqParameter")</code>: modifies the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
<dt>ncp</dt><dd><p><code>signature(object = "Chisq")</code>: returns the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
<dt>ncp&lt;-</dt><dd><p><code>signature(object = "Chisq")</code>: modifies the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
<dt>ncp</dt><dd><p><code>signature(object = "FParameter")</code>: returns the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
<dt>ncp&lt;-</dt><dd><p><code>signature(object = "FParameter")</code>: modifies the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
<dt>ncp</dt><dd><p><code>signature(object = "Fd")</code>: returns the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
<dt>ncp&lt;-</dt><dd><p><code>signature(object = "Fd")</code>: modifies the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
<dt>ncp</dt><dd><p><code>signature(object = "TParameter")</code>: returns the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
<dt>ncp&lt;-</dt><dd><p><code>signature(object = "TParameter")</code>: modifies the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
<dt>ncp</dt><dd><p><code>signature(object = "Td")</code>: returns the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
<dt>ncp&lt;-</dt><dd><p><code>signature(object = "Td")</code>: modifies the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
</dl>

<hr>
<h2 id='Norm-class'>Class &quot;Norm&quot;</h2><span id='topic+Norm-class'></span><span id='topic+Norm'></span><span id='topic+initialize+2CNorm-method'></span>

<h3>Description</h3>

<p>  The normal distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
    f(x) =
    \frac{1}{\sqrt{2\pi}\sigma} e^{-(x-\mu)^2/2\sigma^2}</code>
</p>

<p>where <code class="reqn">\mu</code> is the mean of the distribution and
<code class="reqn">\sigma</code> the standard deviation.
C.f. <code><a href="stats.html#topic+Normal">rnorm</a></code>
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Norm(mean, sd)</code>.
This object is a normal distribution.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>: The domain of this distribution has got dimension 1
and the name &quot;Real Space&quot;. </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"UniNormParameter"</code>: the parameter of this distribution (mean and sd),
declared at its instantiation </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: generates random numbers (calls function <code>rnorm</code>)</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>: density function (calls function <code>dnorm</code>)</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>: cumulative function (calls function <code>pnorm</code>)</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>: inverse of the cumulative function (calls function <code>qnorm</code>)</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"AbscontDistribution"</code>, directly.<br />
Class <code>"UnivariateDistribution"</code>, by class <code>"AbscontDistribution"</code>.<br />
Class <code>"Distribution"</code>, by class <code>"AbscontDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>-</dt><dd><p><code>signature(e1 = "Norm", e2 = "Norm")</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "Norm", e2 = "Norm")</code>: 
For the normal distribution the exact convolution formulas are implemented thereby improving the general numerical
approximation.</p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "Norm", e2 = "numeric")</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "Norm", e2 = "numeric")</code>: 
For the normal distribution we use its closedness under affine linear transformations.</p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "Norm")</code>: initialize method </p>
</dd>
<dt>mean</dt><dd><p><code>signature(object = "Norm")</code>: returns the slot <code>mean</code> of the parameter of the distribution </p>
</dd>
<dt>mean&lt;-</dt><dd><p><code>signature(object = "Norm")</code>: modifies the slot <code>mean</code> of the parameter of the distribution </p>
</dd>
<dt>sd</dt><dd><p><code>signature(object = "Norm")</code>: returns the slot <code>sd</code> of the parameter of the distribution  </p>
</dd>
<dt>sd&lt;-</dt><dd><p><code>signature(object = "Norm")</code>: modifies the slot <code>sd</code> of the parameter of the distribution </p>
</dd>
</dl>

<p>further arithmetic methods see <a href="#topic+operators-methods">operators-methods</a>
</p>


<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+UniNormParameter-class">UniNormParameter-class</a></code>
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>
<code><a href="#topic+Reals-class">Reals-class</a></code>
<code><a href="stats.html#topic+Normal">rnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- Norm(mean=1,sd=1) # N is a normal distribution with mean=1 and sd=1.
r(N)(1) # one random number generated from this distribution, e.g. 2.257783
d(N)(1) # Density of this distribution is  0.3989423 for x=1.
p(N)(1) # Probability that x&lt;1 is 0.5.
q(N)(.1) # Probability that x&lt;-0.2815516 is 0.1.
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
mean(N) # mean of this distribution is 1.
sd(N) &lt;- 2 # sd of this distribution is now 2.
M &lt;- Norm() # M is a normal distribution with mean=0 and sd=1.
O &lt;- M+N # O is a normal distribution with mean=1 (=1+0) and sd=sqrt(5) (=sqrt(2^2+1^2)).
</code></pre>

<hr>
<h2 id='NormParameter-class'>Class &quot;NormParameter&quot;</h2><span id='topic+NormParameter-class'></span><span id='topic+initialize+2CNormParameter-method'></span>

<h3>Description</h3>

<p> The parameter of a normal distribution, used by Norm-class</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("NormParameter", sd, mean)</code>.
Usually an object of this class is not needed on its own. It is the
mother-class of the class UniNormParameter, which is generated
automatically when such a distribution is instantiated.  
</p>


<h3>Slots</h3>


<dl>
<dt><code>sd</code></dt><dd><p>Object of class <code>"numeric"</code>: the sd of a normal distribution </p>
</dd>
<dt><code>mean</code></dt><dd><p>Object of class <code>"numeric"</code>: the mean of a normal distribution </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: a name / comment for the parameters </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "NormParameter")</code>:
initialize method</p>
</dd>
<dt>mean</dt><dd><p><code>signature(object = "NormParameter")</code>:
returns the slot mean of the parameter of the distribution</p>
</dd> 
<dt>mean&lt;-</dt><dd><p><code>signature(object = "NormParameter")</code>:
modifies the slot mean of the parameter of the distribution</p>
</dd> 
<dt>sd</dt><dd><p><code>signature(object = "NormParameter")</code>:
returns the slot sd of the parameter of the distribution</p>
</dd>
<dt>sd&lt;-</dt><dd><p><code>signature(object = "NormParameter")</code>:
modifies the slot sd of the parameter of the distribution</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Norm-class">Norm-class</a></code>
<code><a href="#topic+Parameter-class">Parameter-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- new("NormParameter", mean = 0, sd = 1)
sd(W) # sd of this distribution is 1.
sd(W) &lt;- 2 # sd of this distribution is now 2.
</code></pre>

<hr>
<h2 id='NoSymmetry'>Generating function for NoSymmetry-class</h2><span id='topic+NoSymmetry'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"NoSymmetry"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>NoSymmetry()</code></pre>


<h3>Value</h3>

<p>Object of class <code>"NoSymmetry"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+NoSymmetry-class">NoSymmetry-class</a></code>, <code><a href="#topic+DistributionSymmetry-class">DistributionSymmetry-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>NoSymmetry()

## The function is currently defined as
function(){ new("NoSymmetry") }
</code></pre>

<hr>
<h2 id='NoSymmetry-class'>Class for Non-symmetric Distributions</h2><span id='topic+NoSymmetry-class'></span>

<h3>Description</h3>

<p>Class for non-symmetric distributions.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("NoSymmetry")</code>.
More frequently they are created via the generating function 
<code>NoSymmetry</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
contains &ldquo;non-symmetric distribution&rdquo; </p>
</dd>
<dt><code>SymmCenter</code></dt><dd><p>Object of class <code>"NULL"</code> </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"DistributionSymmetry"</code>, directly.<br />
Class <code>"Symmetry"</code>, by class <code>"DistributionSymmetry"</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+NoSymmetry">NoSymmetry</a></code>, <code><a href="#topic+Distribution-class">Distribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("NoSymmetry")
</code></pre>

<hr>
<h2 id='operators-methods'>Methods for operators +,-,*,/,... in Package distr</h2><span id='topic+operators-methods'></span><span id='topic+operators'></span><span id='topic+-+2CUnivariateDistribution+2Cmissing-method'></span><span id='topic+-+2CLatticeDistribution+2Cmissing-method'></span><span id='topic+-+2CNorm+2Cmissing-method'></span><span id='topic++2B+2CUnivariateDistribution+2Cnumeric-method'></span><span id='topic++2B+2CAbscontDistribution+2Cnumeric-method'></span><span id='topic++2B+2CDiscreteDistribution+2Cnumeric-method'></span><span id='topic++2B+2CLatticeDistribution+2Cnumeric-method'></span><span id='topic++2B+2CUnivarLebDecDistribution+2Cnumeric-method'></span><span id='topic++2B+2CAffLinAbscontDistribution+2Cnumeric-method'></span><span id='topic++2B+2CAffLinDiscreteDistribution+2Cnumeric-method'></span><span id='topic++2B+2CAffLinLatticeDistribution+2Cnumeric-method'></span><span id='topic++2B+2CAffLinUnivarLebDecDistribution+2Cnumeric-method'></span><span id='topic++2B+2CCompoundDistribution+2Cnumeric-method'></span><span id='topic++2B+2CCauchy+2Cnumeric-method'></span><span id='topic++2B+2CDirac+2Cnumeric-method'></span><span id='topic++2B+2CNorm+2Cnumeric-method'></span><span id='topic++2B+2CUnif+2Cnumeric-method'></span><span id='topic++2B+2Cnumeric+2CUnivariateDistribution-method'></span><span id='topic++2B+2Cnumeric+2CLatticeDistribution-method'></span><span id='topic+-+2CUnivariateDistribution+2Cnumeric-method'></span><span id='topic+-+2CUnivariateDistribution+2CUnivariateDistribution-method'></span><span id='topic+-+2CLatticeDistribution+2Cnumeric-method'></span><span id='topic+-+2CLatticeDistribution+2CLatticeDistribution-method'></span><span id='topic+-+2CLatticeDistribution+2CUnivariateDistribution-method'></span><span id='topic+-+2CUnivariateDistribution+2CLatticeDistribution-method'></span><span id='topic+-+2CAcDcLcDistribution+2CAcDcLcDistribution-method'></span><span id='topic+-+2Cnumeric+2CUnivariateDistribution-method'></span><span id='topic+-+2Cnumeric+2CLatticeDistribution-method'></span><span id='topic++2A+2CUnivariateDistribution+2Cnumeric-method'></span><span id='topic++2A+2CAbscontDistribution+2Cnumeric-method'></span><span id='topic++2A+2CDiscreteDistribution+2Cnumeric-method'></span><span id='topic++2A+2CLatticeDistribution+2Cnumeric-method'></span><span id='topic++2A+2CUnivarLebDecDistribution+2Cnumeric-method'></span><span id='topic++2A+2CCompoundDistribution+2Cnumeric-method'></span><span id='topic++2A+2CAffLinAbscontDistribution+2Cnumeric-method'></span><span id='topic++2A+2CAffLinDiscreteDistribution+2Cnumeric-method'></span><span id='topic++2A+2CAffLinLatticeDistribution+2Cnumeric-method'></span><span id='topic++2A+2CAffLinUnivarLebDecDistribution+2Cnumeric-method'></span><span id='topic++2A+2CDExp+2Cnumeric-method'></span><span id='topic++2A+2CExp+2Cnumeric-method'></span><span id='topic++2A+2CExpOrGammaOrChisq+2Cnumeric-method'></span><span id='topic++2A+2CWeibull+2Cnumeric-method'></span><span id='topic++2A+2CCauchy+2Cnumeric-method'></span><span id='topic++2A+2CDirac+2Cnumeric-method'></span><span id='topic++2A+2CNorm+2Cnumeric-method'></span><span id='topic++2A+2CLogis+2Cnumeric-method'></span><span id='topic++2A+2CLnorm+2Cnumeric-method'></span><span id='topic++2A+2CUnif+2Cnumeric-method'></span><span id='topic++2A+2Cnumeric+2CUnivariateDistribution-method'></span><span id='topic++2A+2Cnumeric+2CLatticeDistribution-method'></span><span id='topic++2F+2CUnivariateDistribution+2Cnumeric-method'></span><span id='topic++2F+2CLatticeDistribution+2Cnumeric-method'></span><span id='topic++2B+2CUnivariateDistribution+2CUnivariateDistribution-method'></span><span id='topic++2B+2CAbscontDistribution+2CAbscontDistribution-method'></span><span id='topic++2B+2CAbscontDistribution+2CDiscreteDistribution-method'></span><span id='topic++2B+2CDiscreteDistribution+2CAbscontDistribution-method'></span><span id='topic++2B+2CDiscreteDistribution+2CDiscreteDistribution-method'></span><span id='topic++2B+2CLatticeDistribution+2CDiscreteDistribution-method'></span><span id='topic++2B+2CLatticeDistribution+2CLatticeDistribution-method'></span><span id='topic++2B+2CUnivarLebDecDistribution+2CUnivarLebDecDistribution-method'></span><span id='topic++2B+2CAcDcLcDistribution+2CAcDcLcDistribution-method'></span><span id='topic++2B+2CBinom+2CBinom-method'></span><span id='topic++2B+2CCauchy+2CCauchy-method'></span><span id='topic++2B+2CChisq+2CChisq-method'></span><span id='topic++2B+2CDirac+2CDirac-method'></span><span id='topic++2B+2CExpOrGammaOrChisq+2CExpOrGammaOrChisq-method'></span><span id='topic++2B+2CPois+2CPois-method'></span><span id='topic++2B+2CNbinom+2CNbinom-method'></span><span id='topic++2B+2CNorm+2CNorm-method'></span><span id='topic++2B+2CLogis+2Cnumeric-method'></span><span id='topic++2B+2CDirac+2CUnivariateDistribution-method'></span><span id='topic++2B+2CDirac+2CDiscreteDistribution-method'></span><span id='topic++2B+2CUnivariateDistribution+2CDirac-method'></span><span id='topic+-+2Cnumeric+2CBeta-method'></span><span id='topic+-+2CDirac+2CDirac-method'></span><span id='topic++2A+2CDirac+2CDirac-method'></span><span id='topic++2A+2CDirac+2CUnivariateDistribution-method'></span><span id='topic++2A+2CUnivariateDistribution+2CDirac-method'></span><span id='topic++2A+2CAcDcLcDistribution+2CAcDcLcDistribution-method'></span><span id='topic++2F+2CDirac+2CDirac-method'></span><span id='topic++2F+2Cnumeric+2CDirac-method'></span><span id='topic++2F+2Cnumeric+2CAcDcLcDistribution-method'></span><span id='topic++2F+2CAcDcLcDistribution+2CAcDcLcDistribution-method'></span><span id='topic++5E+2CAcDcLcDistribution+2Cnumeric-method'></span><span id='topic++5E+2CAcDcLcDistribution+2CInteger-method'></span><span id='topic++5E+2CAcDcLcDistribution+2CAcDcLcDistribution-method'></span><span id='topic++5E+2Cnumeric+2CAcDcLcDistribution-method'></span>

<h3>Description</h3>

<p>Arithmetics and unary mathematical transformations for distributions</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="operators-methods_+3A_e1">e1</code>, <code id="operators-methods_+3A_e2">e2</code></td>
<td>
<p> objects of class <code>"UnivariateDistribution"</code> (or subclasses) or <code>"numeric"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arithmetics as well as all functions from group <code>Math</code>, see <code><a href="methods.html#topic+S4groupGeneric">Math</a></code>
are provided for distributions; wherever possible exact expressions are used; else 
random variables are generated according to this transformation and subsequently the remaining
slots filled by <code><a href="#topic+RtoDPQ">RtoDPQ</a></code>, <code><a href="#topic+RtoDPQ.d">RtoDPQ.d</a></code></p>


<h3>Methods</h3>


<dl>
<dt><code>-</code></dt><dd><p><code>signature(e1 = "UnivariateDistribution", e2 = "missing")</code> unary operator; result again of class <code>"UnivariateDistribution"</code>; exact</p>
</dd>
<dt><code>-</code></dt><dd><p><code>signature(e1 = "Norm", e2 = "missing")</code> unary operator; result again of <code>"Norm"</code>; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "UnivariateDistribution", e2 = "numeric")</code> result again of class <code>"UnivariateDistribution"</code>; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "AbscontDistribution", e2 = "numeric")</code> result of 
class <code>"AffLinAbscontDistribution"</code>; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "DiscreteDistribution", e2 = "numeric")</code> result of 
class <code>"AffLinDiscreteDistribution"</code>; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "LatticeDistribution", e2 = "numeric")</code> result  of 
class <code>"AffLinLatticeDistribution"</code>; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "numeric")</code> result of 
class <code>"AffLinUnivarLebDecDistribution"</code>; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "CompoundDistribution", e2 = "numeric")</code> result of 
class <code>"AffLinUnivarLebDecDistribution"</code>; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "AffLinAbscontDistribution", e2 = "numeric")</code> result again of 
class <code>"AffLinAbscontDistribution"</code>; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "AffLinDiscreteDistribution", e2 = "numeric")</code> result again of 
class <code>"AffLinDiscreteDistribution"</code>; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "AffLinLatticeDistribution", e2 = "numeric")</code> result again of 
class <code>"AffLinLatticeDistribution"</code>; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "AffLinUnivarLebDecDistribution", e2 = "numeric")</code> result of 
class <code>"AffLinUnivarLebDecDistribution"</code>; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "Cauchy", e2 = "numeric")</code> result again of class <code>"Cauchy"</code>; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "Dirac", e2 = "numeric")</code> result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "Norm", e2 = "numeric")</code> result again of class <code>"Norm"</code>; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "Unif", e2 = "numeric")</code> result again of class <code>"Unif"</code>; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "Logis", e2 = "numeric")</code>  result again of class <code>"Logis"</code>; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "numeric", e2 = "UnivariateDistribution")</code> is translated to  
<code>signature(e1 = "UnivariateDistribution", e2 = "numeric")</code>; exact</p>
</dd>
<dt><code>-</code></dt><dd><p><code>signature(e1 = "UnivariateDistribution", e2= "ANY")</code>;exact</p>
</dd>
<dt><code>-</code></dt><dd><p><code>signature(e1 = "UnivariateDistribution", e2 = "numeric")</code> is translated to 
<code>e1 + (-e2)</code>; exact</p>
</dd>
<dt><code>-</code></dt><dd><p><code>signature(e1 = "numeric", e2 = "UnivariateDistribution")</code> is translated to <code>(-e1) + e2</code>; exact</p>
</dd>
<dt><code>-</code></dt><dd><p><code>signature(e1 = "numeric", e2 = "Beta")</code> if <code>ncp(e2)==0</code> and <code>e1 == 1</code>,
an exact (central) <code>Beta(shape1 = shape2(e2), shape2 = shape1(e2))</code> is returned, else
the default method is used; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "UnivariateDistribution", e2 = "numeric")</code> result again of class <code>"UnivariateDistribution"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "AbscontDistribution", e2 = "numeric")</code> result of 
class <code>"AffLinAbscontDistribution"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "DiscreteDistribution", e2 = "numeric")</code> result of 
class <code>"AffLinDiscreteDistribution"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "LatticeDistribution", e2 = "numeric")</code> result  of 
class <code>"AffLinLatticeDistribution"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "numeric")</code> result of 
class <code>"AffLinUnivarLebDecDistribution"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "CompoundDistribution", e2 = "numeric")</code> result of 
class <code>"AffLinUnivarLebDecDistribution"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "AffLinAbscontDistribution", e2 = "numeric")</code> result again of 
class <code>"AffLinAbscontDistribution"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "AffLinDiscreteDistribution", e2 = "numeric")</code> result again of 
class <code>"AffLinDiscreteDistribution"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "AffLinLatticeDistribution", e2 = "numeric")</code> result again of 
class <code>"AffLinLatticeDistribution"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "AffLinUnivarLebDecDistribution", e2 = "numeric")</code> result of 
class <code>"AffLinUnivarLebDecDistribution"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "DExp", e2 = "numeric")</code> if <code>abs(e2)&gt;0</code> result again of class <code>"DExp"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "Exp", e2 = "numeric")</code> if <code>e2&gt;0</code> result again of class <code>"Exp"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "ExpOrGammaOrChisq", e2 = "numeric")</code> if <code>e1</code> is a Gamma distribution and <code>e2&gt;0</code> 
result of class <code>"Gammad"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "Weibull", e2 = "numeric")</code> if <code>e2&gt;0</code> 
result of class <code>"Weibull"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "Cauchy", e2 = "numeric")</code>  if <code>abs(e2)&gt;0</code> result again of class <code>"Cauchy"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "Dirac", e2 = "numeric")</code>  result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "Norm", e2 = "numeric")</code>  if <code>abs(e2)&gt;0</code> result again of class <code>"Norm"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "Unif", e2 = "numeric")</code>  if <code>abs(e2)&gt;0</code> result again of class <code>"Unif"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "Logis", e2 = "numeric")</code>  if <code>e2&gt;0</code> result again of class <code>"Logis"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "Lnorm", e2 = "numeric")</code>  if <code>e2&gt;0</code> result again of class <code>"Lnorm"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "numeric", e2 = "UnivariateDistribution")</code> is translated to 
<code>signature(e1 = "UnivariateDistribution", e2 = "numeric")</code>; exact</p>
</dd>
<dt><code>/</code></dt><dd><p><code>signature(e1 = "UnivariateDistribution", e2 = "numeric")</code> is translated to <code>e1 * (1/e2)</code>; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "UnivariateDistribution", e2 = "UnivariateDistribution")</code>  result again of class 
<code>"UnivariateDistribution"</code>; is generated by simulations</p>
</dd>
<dt><code>-</code></dt><dd><p><code>signature(e1 = "UnivariateDistribution", e2 = "UnivariateDistribution")</code> is translated to <code>(-e1) + (-e2)</code>; 
result again of class   <code>"UnivariateDistribution"</code>; is generated by simulations</p>
</dd>
<dt><code>-</code></dt><dd><p><code>signature(e1 = "AcDcLcDistribution", e2 = "AcDcLcDistribution")</code>: both operands are coerced
to class <code>"UnivarLebDecDistribution"</code> and the corresponding method is used.
</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "AbscontDistribution", e2 = "AbscontDistribution")</code> assumes <code>e1</code>, <code>e2</code> independent; result again of class 
<code>"AbscontDistribution"</code>; is generated by FFT</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "AbscontDistribution", e2 = "DiscreteDistribution")</code> assumes <code>e1</code>, <code>e2</code> independent; result again of class 
<code>"AbscontDistribution"</code>; is generated by FFT</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "DiscreteDistribution", e2 = "AbscontDistribution")</code> assumes <code>e1</code>, <code>e2</code> independent; result again of class 
<code>"AbscontDistribution"</code>; is generated by FFT</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "LatticeDistribution", e2 = "LatticeDistribution")</code> assumes <code>e1</code>, <code>e2</code> independent; 
if the larger lattice-width is an integer multiple of the smaller(in abs. value) one: result again of class 
<code>"LatticeDistribution"</code>; is generated by D/FFT</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "DiscreteDistribution", e2 = "DiscreteDistribution")</code> assumes <code>e1</code>, <code>e2</code> independent; result again of class 
<code>"DiscreteDistribution"</code>; is generated by explicite convolution</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "LatticeDistribution", e2 = "DiscreteDistribution")</code> assumes <code>e1</code>, <code>e2</code> independent; result again of class 
<code>"DiscreteDistribution"</code>; is generated by explicite convolution</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "UnivarLebDecDistribution")</code> assumes <code>e1</code>, <code>e2</code> independent; result again of class 
<code>"UnivarLebDecDistribution"</code>; is generated by separate explicite convolution of a.c. and discrete parts of <code>e1</code> and <code>e2</code>
and subsequent flattening with <code><a href="#topic+flat.LCD">flat.LCD</a></code>; if <code>getdistrOption("withSimplify")</code> is  <code>TRUE</code>, result is piped
through a call to <code><a href="#topic+simplifyD">simplifyD</a></code></p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "AcDcLcDistribution", e2 = "AcDcLcDistribution")</code>: both operands are coerced
to class <code>"UnivarLebDecDistribution"</code> and the corresponding method is used.
</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "Binom", e2 = "Binom")</code> assumes <code>e1</code>, <code>e2</code> independent; 
if <code>prob(e1)==prob(e2)</code>, result again of class 
<code>"Binom"</code>; uses the convolution formula for binomial distributions; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "Cauchy", e2 = "Cauchy")</code>  assumes <code>e1</code>, <code>e2</code> independent; result again of class 
<code>"Cauchy"</code>; uses the convolution formula for Cauchy distributions; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "Chisq", e2 = "Chisq")</code>  assumes <code>e1</code>, <code>e2</code> independent; result again of class 
<code>"Chisq"</code>; uses the convolution formula for Chisq distributions; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "Dirac", e2 = "Dirac")</code> result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "ExpOrGammaOrChisq", e2 = "ExpOrGammaOrChisq")</code>  assumes <code>e1</code>, <code>e2</code> independent; if 
<code>e1</code>, <code>e2</code> are Gamma distributions, result is of class 
<code>"Gammad"</code>; uses the convolution formula for Gamma distributions; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "Pois", e2 = "Pois")</code>  assumes <code>e1</code>, <code>e2</code> independent; result again of class 
<code>"Pois"</code>; uses the convolution formula for Poisson distributions; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "Nbinom", e2 = "Nbinom")</code>  assumes <code>e1</code>, <code>e2</code> independent; if 
<code>prob(e1)==prob(e2)</code>, result again of class 
<code>"Nbinom"</code>; uses the convolution formula for negative binomial distributions; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "Norm", e2 = "Norm")</code>  assumes <code>e1</code>, <code>e2</code> independent; result again of class 
<code>"Norm"</code>; uses the convolution formula for normal distributions; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "UnivariateDistribution", e2 = "Dirac")</code>  translated to <code>e1 + location(e2)</code>; 
result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "Dirac", e2 = "UnivariateDistribution")</code>  translated to <code>e2 + location(e1)</code>; 
result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "Dirac", e2 = "DiscreteDistribution")</code>  translated to <code>e2 + location(e1)</code>; 
result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>-</code></dt><dd><p><code>signature(e1 = "Dirac", e2 = "Dirac")</code>  result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "Dirac", e2 = "Dirac")</code>  result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "UnivariateDistribution", e2 = "Dirac")</code>  translated to <code>e1 * location(e2)</code>; 
result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "Dirac", e2 = "UnivariateDistribution")</code>  translated to <code>e2 * location(e1)</code>; 
result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "AcDcLcDistribution", e2 = "AcDcLcDistribution")</code>: by means of <code><a href="#topic+decomposePM">decomposePM</a></code>
<code>e1</code> and <code>e2</code> are decomposed into positive and negative parts; of these, convolutions of the
corresponding logarithms are computed separately and finally <code>exp</code> is applied to them, again separately;
the resulting mixing components are then &ldquo;flattened&rdquo; to one object of class 
<code>UnivarLebDecDistribution</code> by <code><a href="#topic+flat.LCD">flat.LCD</a></code> which according to <code>getdistrOption(withSimplify)</code> 
gets piped through a call to <code><a href="#topic+simplifyD">simplifyD</a></code>.
</p>
</dd>
<dt><code>/</code></dt><dd><p><code>signature(e1 = "Dirac", e2 = "Dirac")</code>  result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>/</code></dt><dd><p><code>signature(e1 = "numeric", e2 = "Dirac")</code>  result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>/</code></dt><dd><p><code>signature(e1 = "numeric", e2 = "AcDcLcDistribution")</code>: if <code>d.discrete(e2)(0)*discreteWeight(e2)&gt;0</code>
throws an error (would give division by 0 with positive probability); else by means of <code><a href="#topic+decomposePM">decomposePM</a></code>
<code>e2</code> is decomposed into positive and negative parts; then, similarly the result obtains as for 
<code>"*"(signature(e1 = "AcDcLcDistribution", e2 = "AcDcLcDistribution"))</code> by the exp-log trick
and is &ldquo;flattened&rdquo; to one object of class 
<code>UnivarLebDecDistribution</code> by <code><a href="#topic+flat.LCD">flat.LCD</a></code> and 
according to <code>getdistrOption(withSimplify)</code> is piped through
a call to <code><a href="#topic+simplifyD">simplifyD</a></code>; exact..
</p>
</dd>
<dt><code>/</code></dt><dd><p><code>signature(e1 = "AcDcLcDistribution", e2 = "AcDcLcDistribution")</code>: translated to <code>e1 * (1/e2)</code>.
</p>
</dd>
<dt><code>^</code></dt><dd><p><code>signature(e1 = "AcDcLcDistribution", e2 = "Integer")</code>: if <code>e2=0</code> returns <code>Dirac(1)</code>;
if <code>e2=1</code> returns <code>e1</code>; if <code>e2&lt;0</code> translated to <code>(1/e1)^(-e2)</code>; exact. 
</p>
</dd>
<dt><code>^</code></dt><dd><p><code>signature(e1 = "AcDcLcDistribution", e2 = "numeric")</code>: if <code>e2</code> is integer uses preceding
item; else if <code>e1&lt; 0</code> with positive probability, throughs an error; else
the result obtains similarly to 
<code>"*"(signature(e1 = "AcDcLcDistribution", e2 = "AcDcLcDistribution"))</code> by the exp-log trick
and is &ldquo;flattened&rdquo; to one object of class 
<code>UnivarLebDecDistribution</code> by <code><a href="#topic+flat.LCD">flat.LCD</a></code> and 
according to <code>getdistrOption(withSimplify)</code> is piped through
a call to <code><a href="#topic+simplifyD">simplifyD</a></code>; exact.
</p>
</dd>
<dt><code>^</code></dt><dd><p><code>signature(e1 = "AcDcLcDistribution", e2 = "AcDcLcDistribution")</code>: 
if <code>e1</code> is negative with positive probability, 
throws an error if <code>e2</code> is non-integer
with positive probability; if <code>e1</code> is 0 with positive probability
throws an error if <code>e2</code> is non-integer with positive probability. 
if  <code>e2</code> is integer with probability 1 uses 
<code>DiscreteDistribution(supp=e1^(Dirac(x))</code> for each <code>x</code> in <code>support(e2)</code>,
builds up a corresponding mixing distribution; the latter is &ldquo;flattened&rdquo; to one object of class 
<code>UnivarLebDecDistribution</code> by <code><a href="#topic+flat.LCD">flat.LCD</a></code> and 
according to <code>getdistrOption(withSimplify)</code> is piped through
a call to <code><a href="#topic+simplifyD">simplifyD</a></code>.
Else the result obtains similarly to <code>"*"(signature(e1 = "AcDcLcDistribution", 
                e2 = "AcDcLcDistribution"))</code> by the exp-log trick
and is &ldquo;flattened&rdquo; to one object of class 
<code>UnivarLebDecDistribution</code> by <code><a href="#topic+flat.LCD">flat.LCD</a></code> and 
according to <code>getdistrOption(withSimplify)</code> is piped through
a call to <code><a href="#topic+simplifyD">simplifyD</a></code>; exact.
</p>
</dd>
<dt><code>^</code></dt><dd><p><code>signature(e1 = "numeric", e2 = "AcDcLcDistribution")</code>: 
if <code>e1</code> is negative, throws an error if <code>e2</code> is non-integer
with positive probability; if <code>e1</code> is 0 throws an error if
<code>e2</code> is non-integer with positive probability. 
if  <code>e2</code> is integer with probability 1 uses 
<code>DiscreteDistribution(supp=e1^support(e2), prob=discrete.d(supp))</code>
else the result obtains similarly to <code>"*"(signature(e1 = "AcDcLcDistribution", 
                e2 = "AcDcLcDistribution"))</code> by the exp-log trick
and is &ldquo;flattened&rdquo; to one object of class 
<code>UnivarLebDecDistribution</code> by <code><a href="#topic+flat.LCD">flat.LCD</a></code> and 
according to <code>getdistrOption(withSimplify)</code> is piped through
a call to <code><a href="#topic+simplifyD">simplifyD</a></code>; exact.
</p>
</dd>
</dl>


<h3>References</h3>

<p>Ruckdeschel, P., Kohl, M.(2014):
General purpose convolution algorithm for distributions 
in S4-Classes by means of FFT. <em>J. Statist. Softw.</em>
<b>59</b>(4): 1-25.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UnivariateDistribution-class">UnivariateDistribution-class</a></code>
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code> <br />
<code><a href="#topic+DiscreteDistribution-class">DiscreteDistribution-class</a></code>
<code><a href="#topic+LatticeDistribution-class">LatticeDistribution-class</a></code><br />
<code><a href="#topic+Norm-class">Norm-class</a></code>
<code><a href="#topic+Binom-class">Binom-class</a></code>
<code><a href="#topic+Pois-class">Pois-class</a></code>
<code><a href="#topic+Dirac-class">Dirac-class</a></code><br />
<code><a href="#topic+Cauchy-class">Cauchy-class</a></code>
<code><a href="#topic+Gammad-class">Gammad-class</a></code>
<code><a href="#topic+Logis-class">Logis-class</a></code>
<code><a href="#topic+Lnorm-class">Lnorm-class</a></code><br />
<code><a href="#topic+Exp-class">Exp-class</a></code>
<code><a href="#topic+Weibull-class">Weibull-class</a></code>
<code><a href="#topic+Nbinom-class">Nbinom-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- Norm(0,3)
P &lt;- Pois(4)
a &lt;- 3
N + a
N + P
N - a
a * N
a * P
N / a + sin( a * P - N)
N * P
N / N

## takes a little time
N ^ P

1.2 ^ N
abs(N) ^ 1.3
</code></pre>

<hr>
<h2 id='OptionalParameter-class'>Classes &quot;OptionalParameter&quot;, &quot;OptionalMatrix&quot; </h2><span id='topic+OptionalParameter-class'></span><span id='topic+OptionalMatrix-class'></span>

<h3>Description</h3>

<p> auxiliary classes; may contain either a Parameter or NULL, resp.
a matrix or NULL cf. J. Chambers, &quot;green book&quot;.</p>


<h3>Objects from the Class</h3>

<p>&quot;OptionalParameter&quot; is a virtual Class: No objects may be created from it;
&quot;OptionalMatrix&quot; is a class generated by <code>setClassUnion()</code> so may contain NULL or any matrix</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;OptionalParameter&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br />
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Parameter-class">Parameter-class</a></code>, <code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code></p>

<hr>
<h2 id='options'>
additional options in package &lsquo;distr&rsquo;
</h2><span id='topic+options'></span><span id='topic+newDevice'></span>

<h3>Description</h3>

<p>In package <span class="pkg">distr</span>, we add an extra option <code>"newDevice"</code>;
it is inspected and manipulated as usual.
</p>


<h3>Details</h3>

<p>We do not change the behaviour of <code>options</code> or <code>getOption</code>;
for the general documentation to these two functions, 
confer <code><a href="base.html#topic+options">options</a></code>, <code><a href="base.html#topic+options">getOption</a></code>. Here
we only document added options.</p>


<h3>Additionally available options in package 'distr'</h3>


<dl>
<dt><code>"newDevice"</code></dt><dd><p>logical; controls behaviour when generating several plots within
one function; if <code>TRUE</code>, before each call to  call to <code><a href="graphics.html#topic+frame">plot.new</a></code>,
a call to <code><a href="#topic+devNew">devNew</a></code> is inserted; if <code>FALSE</code>, we reproduce the usual behaviour
in <span class="pkg">graphics</span>, i.e.; we do not call <code><a href="#topic+devNew">devNew</a></code>. Defaults to <code>FALSE</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+options">options</a></code>, <code><a href="base.html#topic+options">getOption</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>getOption("newDevice") 
options("newDevice"=TRUE) 
</code></pre>

<hr>
<h2 id='p-methods'> Methods for Function p in Package &lsquo;distr&rsquo; </h2><span id='topic+p.r-methods'></span><span id='topic+p.r'></span><span id='topic+p.r+2CDistribution-method'></span><span id='topic+p-methods'></span><span id='topic+p'></span><span id='topic+p+2CDistribution-method'></span>

<h3>Description</h3>

<p>p-methods</p>


<h3>Methods</h3>


<dl>
<dt>p</dt><dd><p><code>signature(object = "Distribution")</code>: returns the cumulative distribution function (c.d.f.),
i.e.; <code class="reqn">p(t) = P(object \le t)</code>  </p>
</dd>
<dt>p.r</dt><dd><p><code>signature(object  = "Distribution")</code>: 
from distr-2.6 onwards, we provide this as a synonym for 
method <code>p</code>; this synonym more explicitely states that we are dealing with
the right-continuous variant of a c.d.f.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+Distribution-class">Distribution-class</a></code>, <code>p.l</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(distr)
N &lt;- Norm()
p(N)(0.3)
p.r(N)(0.3)
</code></pre>

<hr>
<h2 id='p.l-methods'>Methods for Function p.l in Package &lsquo;distr&rsquo; </h2><span id='topic+p.l-methods'></span><span id='topic+p.l'></span><span id='topic+p.l+2CAbscontDistribution-method'></span><span id='topic+p.l+2CDiscreteDistribution-method'></span><span id='topic+p.l+2CUnivarLebDecDistribution-method'></span><span id='topic+p.l+2CUnivarMixingDistribution-method'></span>

<h3>Description</h3>

<p>p-methods</p>


<h3>Methods</h3>

<p>return the left continuous cumulative distribution function,
i.e.; <code class="reqn">p.l(t) = P(object &lt; t)</code> 
</p>

<dl>
<dt>p.l</dt><dd><p><code>signature(object = "AbscontDistribution")</code></p>
</dd> 
<dt>p.l</dt><dd><p><code>signature(object = "DiscreteDistribution")</code></p>
</dd> 
<dt>p.l</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>p.l</dt><dd><p><code>signature(object = "UnivarMixingDistribution")</code></p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+DiscreteDistribution-class">DiscreteDistribution-class</a></code>
<code><a href="#topic+UnivarLebDecDistribution-class">UnivarLebDecDistribution-class</a></code>
</p>

<hr>
<h2 id='param-methods'> Methods for Function param in Package &lsquo;distr&rsquo; </h2><span id='topic+param-methods'></span><span id='topic+param'></span><span id='topic+param+2CDistribution-method'></span>

<h3>Description</h3>

<p>param-methods</p>


<h3>Methods</h3>


<dl>
<dt>param</dt><dd><p><code>signature(object = "Distribution")</code>: returns the parameter </p>
</dd>
</dl>

<hr>
<h2 id='Parameter-class'>Class &quot;Parameter&quot;</h2><span id='topic+Parameter-class'></span>

<h3>Description</h3>

<p>Parameter is the mother-class of all Parameter classes.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("Parameter")</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>:
a name / comment for the parameters</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>name</dt><dd><p><code>signature(object = "Parameter")</code>:
returns the name of the parameter</p>
</dd>
<dt>name&lt;-</dt><dd><p><code>signature(object = "Parameter")</code>:
modifies the name of the parameter</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Distribution-class">Distribution-class</a></code>
</p>

<hr>
<h2 id='pivot-methods'> Methods for Function pivot in Package &lsquo;distr&rsquo; </h2><span id='topic+pivot-methods'></span><span id='topic+pivot+3C--methods'></span><span id='topic+pivot'></span><span id='topic+pivot+3C-'></span><span id='topic+pivot+2CLattice-method'></span><span id='topic+pivot+3C-+2CLattice-method'></span><span id='topic+pivot+2CLatticeDistribution-method'></span><span id='topic+pivot+3C-+2CLatticeDistribution-method'></span>

<h3>Description</h3>

<p>pivot-methods</p>


<h3>Methods</h3>


<dl>
<dt>pivot</dt><dd><p><code>signature(object = "Lattice")</code>: returns the slot pivot of the lattice </p>
</dd>
<dt>pivot&lt;-</dt><dd><p><code>signature(object = "Lattice")</code>: modifies the slot pivot of the lattice </p>
</dd>
<dt>pivot</dt><dd><p><code>signature(object = "LatticeDistribution")</code>: returns the slot pivot of the lattice slot of the distribution</p>
</dd>
<dt>pivot&lt;-</dt><dd><p><code>signature(object = "LatticeDistribution")</code>: modifies the slot pivot of the lattice slot of the distribution</p>
</dd>
</dl>

<hr>
<h2 id='plot-methods'> Methods for Function plot in Package &lsquo;distr&rsquo; </h2><span id='topic+plot'></span><span id='topic+plot-methods'></span><span id='topic+plot+2CAffLinUnivarLebDecDistribution+2Cmissing-method'></span><span id='topic+plot+2CUnivarLebDecDistribution+2Cmissing-method'></span><span id='topic+plot+2CAbscontDistribution+2Cmissing-method'></span><span id='topic+plot+2CDiscreteDistribution+2Cmissing-method'></span><span id='topic+plot+2CCompoundDistribution+2Cmissing-method'></span><span id='topic+plot+2CDistrList+2Cmissing-method'></span>

<h3>Description</h3>

<p>plot-methods</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot(x, y, ...)
## S4 method for signature 'AbscontDistribution,missing'
plot(x, width = 10, height = 5.5,
     withSweave = getdistrOption("withSweave"), xlim = NULL, ylim = NULL,
     ngrid = 1000, verticals = TRUE, do.points = TRUE, main = FALSE,
     inner = TRUE, sub = FALSE, bmar = par("mar")[1], tmar = par("mar")[3], ...,
     cex.main = par("cex.main"), cex.inner = 1.2, cex.sub = par("cex.sub"), 
     col.points = par("col"), col.vert = par("col"), col.main = par("col.main"),  
     col.inner = par("col.main"), col.sub = par("col.sub"), cex.points = 2.0, 
     pch.u = 21, pch.a = 16, mfColRow = TRUE,
     to.draw.arg = NULL, withSubst = TRUE)
## S4 method for signature 'DiscreteDistribution,missing'
plot(x, width = 10, height = 5.5,
     withSweave = getdistrOption("withSweave"), xlim = NULL, ylim = NULL,
     verticals = TRUE, do.points = TRUE, main = FALSE, inner = TRUE, sub = FALSE,
     bmar = par("mar")[1], tmar = par("mar")[3], ..., 
     cex.main = par("cex.main"), cex.inner = 1.2, cex.sub = par("cex.sub"), 
     col.points = par("col"), col.hor = par("col"), col.vert = par("col"), 
     col.main = par("col.main"), col.inner = par("col.main"), 
     col.sub = par("col.sub"),  cex.points = 2.0, pch.u = 21, pch.a = 16,
     mfColRow = TRUE, to.draw.arg = NULL, withSubst = TRUE)
## S4 method for signature 'AffLinUnivarLebDecDistribution,missing'
plot(x, width = 10, 
     height = 5.5, withSweave = getdistrOption("withSweave"), xlim = NULL,
     ylim = NULL, ngrid = 1000, verticals = TRUE, do.points = TRUE, main = FALSE,
     inner = TRUE, sub = FALSE, bmar = par("mar")[1], tmar = par("mar")[3], ...,
     cex.main = par("cex.main"), cex.inner = 1.2, cex.sub = par("cex.sub"),
     col.points = par("col"), col.hor = par("col"), col.vert = par("col"),
     col.main = par("col.main"), col.inner = par("col.main"),
     col.sub = par("col.sub"),  cex.points = 2.0, pch.u = 21, pch.a = 16,
     mfColRow = TRUE, to.draw.arg = NULL, withSubst = TRUE)
## S4 method for signature 'UnivarLebDecDistribution,missing'
plot(x, width = 10, 
     height = 14.5, withSweave = getdistrOption("withSweave"), xlim = NULL,
     ylim = NULL, ngrid = 1000, verticals = TRUE, do.points = TRUE, main = FALSE,
     inner = TRUE, sub = FALSE, bmar = par("mar")[1], tmar = par("mar")[3], ...,
     cex.main = par("cex.main"), cex.inner = 0.9, cex.sub = par("cex.sub"),
     col.points = par("col"), col.hor = par("col"), col.vert = par("col"),
     col.main = par("col.main"), col.inner = par("col.main"),
     col.sub = par("col.sub"),  cex.points = 2.0, pch.u = 21, pch.a = 16,
     mfColRow = TRUE, to.draw.arg = NULL, withSubst = TRUE)
## S4 method for signature 'DistrList,missing'
plot(x, y, ...)
## S4 method for signature 'CompoundDistribution,missing'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-methods_+3A_x">x</code></td>
<td>
<p>object of class 
<code>"AffLinUnivarLebDecDistribution"</code> or class
<code>"UnivarLebDecDistribution"</code> or class
<code>"AbscontDistribution"</code> or class
<code>"DiscreteDistribution"</code> or class
<code>"DistrList"</code>: (list of) distribution(s) to be plotted </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_y">y</code></td>
<td>
<p> missing </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_xlim">xlim</code></td>
<td>
<p>the x limits (x1, x2) of the plot.  Note that <code>x1 &gt; x2</code> is
allowed and leads to a &quot;reversed axis&quot;. As in <code>plot.default</code>.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot. Either as in <code>plot.default</code>
(i.e. a vector of length 2) or a vector of length 4, where the first two
elements are the values for <code>ylim</code> in panel &quot;d&quot;, and the last
two elements are the values for <code>ylim</code> resp. <code>xlim</code> in panels &quot;p&quot;,
and &quot;q&quot;.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_width">width</code></td>
<td>
<p>width (in inches) of the graphics device opened</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_height">height</code></td>
<td>
<p>height (in inches) of the graphics device opened</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_withsweave">withSweave</code></td>
<td>
<p>logical: if <code>TRUE</code> (for working with <code>Sweave</code>) 
no extra device is opened and height/width are not set</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_ngrid">ngrid</code></td>
<td>
<p>integer: number of grid points used for plots of absolutely continuous 
distributions</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_main">main</code></td>
<td>
<p>logical: is a main title to be used? or <br />
just as argument <code>main</code> in <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_inner">inner</code></td>
<td>
<p>logical: do panels for density/probability function -
cdf - quantile function have their own titles? or <br />
list which is filled to length 3  (resp. 8 for class 
<code>UnivarLebDecDistribution</code>) if necessary
(possibly using recycling rules):  titles for 
density/probability function -
cdf - quantile function (each of the same form as argument 
<code>main</code> in <code><a href="graphics.html#topic+plot.default">plot.default</a></code>)</p>
</td></tr> 
<tr><td><code id="plot-methods_+3A_sub">sub</code></td>
<td>
<p>logical: is a sub-title to be used? or <br />
just as argument <code>sub</code> in <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_tmar">tmar</code></td>
<td>
<p>top margin &ndash; useful for non-standard main title sizes</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_bmar">bmar</code></td>
<td>
<p>bottom margin &ndash; useful for non-standard sub title sizes</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_verticals">verticals</code></td>
<td>
<p>logical: if <code>TRUE</code>, draw vertical lines at steps;
as in <code><a href="stats.html#topic+plot.stepfun">plot.stepfun</a></code></p>
</td></tr> 
<tr><td><code id="plot-methods_+3A_do.points">do.points</code></td>
<td>
<p>logical: if <code>TRUE</code>, draw  also draw points at the 
(<code>xlim</code> restricted) knot locations; as 
in <code><a href="stats.html#topic+plot.stepfun">plot.stepfun</a></code></p>
</td></tr> 
<tr><td><code id="plot-methods_+3A_cex.points">cex.points</code></td>
<td>
<p>numeric; character expansion factor; as in 
<code><a href="stats.html#topic+plot.stepfun">plot.stepfun</a></code></p>
</td></tr>              
<tr><td><code id="plot-methods_+3A_col.points">col.points</code></td>
<td>
<p>character or integer code; color of points; as in 
<code><a href="stats.html#topic+plot.stepfun">plot.stepfun</a></code></p>
</td></tr>              
<tr><td><code id="plot-methods_+3A_col.hor">col.hor</code></td>
<td>
<p>character or integer code; color of horizontal lines; as in 
<code><a href="stats.html#topic+plot.stepfun">plot.stepfun</a></code></p>
</td></tr>              
<tr><td><code id="plot-methods_+3A_col.vert">col.vert</code></td>
<td>
<p>character or integer code; color of vertical lines; as in 
<code><a href="stats.html#topic+plot.stepfun">plot.stepfun</a></code></p>
</td></tr>              
<tr><td><code id="plot-methods_+3A_cex.main">cex.main</code></td>
<td>
<p>magnification to be used for main titles relative
to the current setting of <code>cex</code>; as in 
<code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot-methods_+3A_cex.inner">cex.inner</code></td>
<td>
<p>magnification to be used for inner titles relative
to the current setting of <code>cex</code>; as in 
<code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot-methods_+3A_cex.sub">cex.sub</code></td>
<td>
<p>magnification to be used for sub titles relative
to the current setting of <code>cex</code>; as in 
<code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot-methods_+3A_col.main">col.main</code></td>
<td>
<p>character or integer code; color for the main title</p>
</td></tr>              
<tr><td><code id="plot-methods_+3A_col.inner">col.inner</code></td>
<td>
<p>character or integer code; color for the inner title</p>
</td></tr>              
<tr><td><code id="plot-methods_+3A_col.sub">col.sub</code></td>
<td>
<p>character or integer code; color for the sub title</p>
</td></tr>              
<tr><td><code id="plot-methods_+3A_pch.u">pch.u</code></td>
<td>
<p>character or integer code; plotting characters or symbols for
unattained value; see <code><a href="graphics.html#topic+points">points</a></code></p>
</td></tr>              
<tr><td><code id="plot-methods_+3A_pch.a">pch.a</code></td>
<td>
<p>character or integer code; plotting characters or symbols for
attained value; see <code><a href="graphics.html#topic+points">points</a></code></p>
</td></tr>              
<tr><td><code id="plot-methods_+3A_mfcolrow">mfColRow</code></td>
<td>
<p>shall default partition in panels be used &mdash; defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot-methods_+3A_to.draw.arg">to.draw.arg</code></td>
<td>
<p>Either <code>NULL</code> (default; everything
is plotted) or a vector of either integers 
(the indices of the subplots to be drawn) or characters &mdash; the names of
the subplots to be drawn: in case of an object <code>x</code> of class 
<code>"DiscreteDistribution"</code> or <code>"AbscontDistribution"</code> <code>c("d","p","q")</code>
for density, c.d.f. and quantile function; in case of <code>x</code> a proper
<code>"UnivarLebDecDistribution"</code> (with pos. weights for both discrete and
abs. continuous part) names are 
<code>c("p","q","d.c","p.c","q.c","d.d","p.d","q.d")</code>) 
for c.d.f. and quantile function of the composed distribution and the respective
three panels for the absolutely continuous and the discrete part, respectively; 
</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_withsubst">withSubst</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) pattern substitution for
titles and lables is used; otherwise no substitution is used. </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_...">...</code></td>
<td>
<p>addtional arguments for <code>plot</code> &mdash; see 
<code><a href="graphics.html#topic+plot">plot</a></code>, 
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>, 
<code><a href="stats.html#topic+plot.stepfun">plot.stepfun</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "AffLinUnivarLebDecDistribution", y = "missing")</code>: plots  
cumulative distribution function and the quantile function </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "UnivarLebDecDistribution", y = "missing")</code>: plots a set of
eight plots: in the first row, it plots the 
cumulative distribution function and the quantile function; in the second
row the absolutely continuous part (with density, cdf and quantile fct.),
and in the last row the discrete part (with prob.fct., cdf and quantile fct.). </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "CompoundDistribution", y = "missing")</code>: 
coerces <code>x</code> to <code>"UnivarLebDecDistribution"</code> and uses the corresponding
method. </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "AbscontDistribution", y = "missing")</code>: plots density, 
cumulative distribution function and the quantile function </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "DiscreteDistribution", y = "missing")</code>: plots probability 
function, cumulative distribution function and the quantile function</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "DistrList", y = "missing")</code>: plots a list of distributions</p>
</dd>
</dl>

<p>Any parameters of <code>plot.default</code> may be passed on to this particular
<code>plot</code> method. 
</p>
<p>For main-, inner, and subtitles given as arguments <code>main</code>, 
<code>inner</code>, and <code>sub</code>, top and bottom margins are enlarged to 5 resp. 
6 by default but may also be specified by <code>tmar</code> / <code>bmar</code> arguments. 
If <code>main</code> / <code>inner</code> / <code>sub</code> are 
logical then if the respective argument is <code>FALSE</code> nothing is done/plotted, 
but if it is <code>TRUE</code>, we use a default main title taking up the calling 
argument <code>x</code> in case of <code>main</code>, default inner titles taking up the
class and (named) parameter slots of argument <code>x</code> in case of <code>inner</code>,
and a &quot;generated on &lt;data&gt;&quot;-tag in case of <code>sub</code>.
Of course, if <code>main</code> / <code>inner</code> / <code>sub</code> are <code>character</code>, this
is used for the title; in case of <code>inner</code> it is then checked whether it
has length 3. In all title and axis label arguments, if <code>withSubst</code> is <code>TRUE</code>,
the following patterns are substituted:
</p>

<dl>
<dt><code>"%C"</code></dt><dd><p>class of argument <code>x</code></p>
</dd>
<dt><code>"%P"</code></dt><dd><p>parameters of <code>x</code> in form of a comma-separated list of 
&lt;value&gt;'s coerced to character</p>
</dd>
<dt><code>"%Q"</code></dt><dd><p>parameters of <code>x</code> in form of a comma-separated list of 
&lt;value&gt;'s coerced to character and in parenthesis &mdash; unless 
empty; then &quot;&quot;</p>
</dd>
<dt><code>"%N"</code></dt><dd><p>parameters of <code>x</code> in form of a comma-separated list 
&lt;name&gt; = &lt;value&gt; coerced to character</p>
</dd>
<dt><code>"%A"</code></dt><dd><p>deparsed argument <code>x</code></p>
</dd>
<dt><code>"%D"</code></dt><dd><p>time/date-string when the plot was generated</p>
</dd>
</dl>

<p>If not explicitly set, <code>col.points</code>, <code>col.vert</code>,
<code>col.hor</code>, <code>col.main</code>, <code>col.inner</code>, <code>col.sub</code> are set 
to <code>col</code> if this arg is given and else to
<code>par("col")</code> resp. for the titles <code>par("col.main")</code>,
<code>par("col.main")</code>, <code>par("col.sub")</code>.  
</p>
<p>If not explicitly set, <code>pch.a</code>, <code>pch.u</code> are set 
to <code>pch</code> if this arg is given and else to 16, 21, respectively.
</p>
<p>If not explicitly set, <code>cex</code> is set to 1. If not explicitly set, 
<code>cex.points</code> is set to $2.0 <code>cex</code>$ (if <code>cex</code> is given)
and to 2.0 else.
</p>
<p>If general <code>plot</code> arguments <code>xlab</code>, <code>ylab</code> are not specified,
they are set to <code>"x"</code>, <code>"q"</code>, <code>"p"</code> for <code>xlab</code> and
to <code>"d(x)"</code>, <code>"p(q)"</code>, <code>"q(p)"</code> for <code>ylab</code> for
density, cdf and quantile function respectively.
Otherwise, according to the respective content of <code>to.draw.arg</code>,
it is supposed to be a list with one entry for each selected panel, i.e.,
in case <code>x</code> is an object of class <code>DiscreteDistribution</code> or
<code>AbscontDistribution</code> a list of maximal length maximally 3, respectively,
in case <code>x</code> is an object of class <code>UnivarLebDecDistribution</code>
In these label arguments, the same pattern substitutions are made as
for titles. If no character substitutions and mathematical expressions
are needed, character vectors of respective length instead of lists are
also allowed for arguments <code>xlab</code>, <code>ylab</code>.
</p>
<p>In addition, argument <code>...</code> may contain arguments <code>panel.first</code>,
<code>panel.last</code>, i.e., hook expressions to be evaluated at the very beginning
and at the very end of each panel (within the then valid coordinates).
To be able to use these hooks for each panel individually, they may also be
lists of expressions (of the same length as the number of panels and
run through in the same order as the panels).
</p>


<h3>Value</h3>

<p>An S3 object of class <code>c("plotInfo","DiagnInfo")</code>, i.e., a list
containing the information needed to produce the
respective plot, which at a later stage could be used by different
graphic engines (like, e.g. <code>ggplot</code>) to produce the plot
in a different framework. A more detailed description will follow in
a subsequent version.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot">plot</a></code>,<code><a href="graphics.html#topic+plot.default">plot.default</a></code>, 
<code><a href="stats.html#topic+plot.stepfun">plot.stepfun</a></code>,  <code><a href="graphics.html#topic+par">par</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(Binom(size = 4, prob = 0.3))
plot(Binom(size = 4, prob = 0.3), do.points = FALSE)
plot(Binom(size = 4, prob = 0.3), verticals = FALSE)
plot(Binom(size = 4, prob = 0.3), main = TRUE)
plot(Binom(size = 4, prob = 0.3), main = FALSE)
plot(Binom(size = 4, prob = 0.3), cex.points = 1.2, pch = 20)
plot(Binom(size = 4, prob = 0.3), xlab = list("a1","a2", "a3"),
           ylab=list("p"="U","q"="V","d"="W"))
B &lt;- Binom(size = 4, prob = 0.3)
plot(B, col = "red", col.points = "green", main = TRUE, col.main = "blue", 
     col.sub = "orange", sub = TRUE, cex.sub = 0.6, col.inner = "brown")
plot(Nbinom(size = 4,prob = 0.3), cex.points = 1.2, col = "red", 
     col.points = "green")
plot(Nbinom(size = 4,prob = 0.3), cex.points = 1.2, pch.u = 20, pch.a = 10)
plot(Norm(), main = TRUE, cex.main = 3, tmar = 6)
plot(Norm(), inner = FALSE, main = TRUE, cex.main = 3, tmar = 6)
plot(Norm(), lwd = 3, col = "red", ngrid = 200, lty = 3, las = 2)
plot(Norm(), main = "my Distribution: %A", 
     inner = list(expression(paste(lambda,"-density of %C(%P)")), "CDF",
                  "Pseudo-inverse with param's %N"), 
     sub = "this plot was correctly generated on %D", 
     cex.inner = 0.9, cex.sub = 0.8)

plot(Norm(),panel.first=grid(4,4))
## does not (yet) work as desired:
plot(Norm(),panel.first=list(grid(5,5),grid(3,3),grid(4,4)))
li &lt;- list(substitute(grid(5,5)),substitute(grid(3,3)),substitute(grid(4,4)))
plot(Norm(),panel.first=li)

plot(Cauchy())
plot(Cauchy(), xlim = c(-4,4))
plot(Chisq())
### the next ylab argument is just for illustration purposes
plot(Chisq(),mfColRow = FALSE,to.draw.arg="d",
     xlab="x",ylab=list(expression(paste(lambda,"-density of %C(%P)"))))
## substitution can be switched off
plot(Chisq(),mfColRow = FALSE,to.draw.arg="d",
     xlab="x",ylab=list(expression(paste(lambda,"-density of %C(%P)"))), withSubst=FALSE)
plot(Chisq(), log = "xy", ngrid = 100)
Ch &lt;- Chisq(); setgaps(Ch); plot(Ch, do.points = FALSE)
setgaps(Ch, exactq = 3); plot(Ch, verticals = FALSE)
plot(Ch, cex = 1.2, pch.u = 20, pch.a = 10, col.points = "green", 
     col.vert = "red")

## Not run:  # to save time 
## some distribution with gaps
wg &lt;- flat.mix(UnivarMixingDistribution(Unif(0,1),Unif(4,5), 
               withSimplify=FALSE))
# some Lebesgue decomposed distribution 
mymix &lt;- UnivarLebDecDistribution(acPart = wg, discretePart = Binom(4,.4),
         acWeight = 0.4)
plot(mymix)         
#
## selection of subpanels for plotting
N &lt;- Norm()
par(mfrow=c(1,2))
plot(N, mfColRow = FALSE, to.draw.arg=c("d","q"))
plot(N, mfColRow = FALSE, to.draw.arg=c(2,3))
par(mfrow=c(1,1))

wg &lt;- flat.mix(UnivarMixingDistribution(Unif(0,1),Unif(4,5),
               withSimplify=FALSE))
myLC &lt;- UnivarLebDecDistribution(discretePart=Binom(3,.3), acPart = wg,
          discreteWeight=.2)
layout(matrix(c(rep(1,6),2,2,3,3,4,4,5,5,5,6,6,6), 
              nrow=3, byrow=TRUE))
plot(myLC,mfColRow = FALSE,
     to.draw.arg=c("p","d.c","p.c","q.c", "p.d","q.d"))

P &lt;- Pois(2)
plot(as(P,"UnivarLebDecDistribution"),mfColRow = FALSE,to.draw.arg=c("d.d"))
### the next ylab argument is just for illustration purposes
plot(as(P,"UnivarLebDecDistribution"),mfColRow = FALSE,to.draw.arg=c("d.d"),
     xlab="x",ylab=list(expression(paste(lambda,"-density of %C(%P)"))))

## End(Not run)
</code></pre>

<hr>
<h2 id='Pois-class'>Class &quot;Pois&quot; </h2><span id='topic+Pois-class'></span><span id='topic+Pois'></span><span id='topic+initialize+2CPois-method'></span>

<h3>Description</h3>

<p>The Poisson distribution has density
</p>
<p style="text-align: center;"><code class="reqn">p(x) = \frac{\lambda^x e^{-\lambda}}{x!}</code>
</p>

<p>for <code class="reqn">x = 0, 1, 2, \ldots</code>.  The mean and variance are
<code class="reqn">E(X) = Var(X) = \lambda</code>.
</p>
<p>C.f. <code><a href="stats.html#topic+Poisson">rpois</a></code>
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Pois(lambda)</code>.
This object is a Poisson distribution. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Naturals"</code>:
The space of the image of this distribution has got dimension 1
and the name &quot;Natural Space&quot;.</p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"PoisParameter"</code>:
the parameter of this distribution (lambda), declared at its
instantiation</p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>:
generates random numbers (calls function rpois)</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>:
density function (calls function dpois)</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>:
cumulative function (calls function ppois)</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>:
inverse of the cumulative function (calls function qpois).
The quantile is defined as the smallest value <code class="reqn">x</code> such that
<code class="reqn">F(x) \ge p</code>, where <code class="reqn">F</code> is the distribution function.</p>
</dd>
<dt><code>support</code></dt><dd><p>Object of class <code>"numeric"</code>: a (sorted)
vector containing the support of the discrete density function</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"DiscreteDistribution"</code>, directly.
Class <code>"UnivariateDistribution"</code>, by class <code>"DiscreteDistribution"</code>.
Class <code>"Distribution"</code>, by class <code>"DiscreteDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>+</dt><dd><p><code>signature(e1 = "Pois", e2 = "Pois")</code>:
For the Poisson distribution the exact convolution formula is
implemented thereby improving the general numerical approximation.</p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "Pois")</code>:
initialize method</p>
</dd>
<dt>lambda</dt><dd><p><code>signature(object = "Pois")</code>:
returns the slot lambda of the parameter of the distribution</p>
</dd>
<dt>lambda&lt;-</dt><dd><p><code>signature(object = "Pois")</code>:
modifies the slot lambda of the parameter of the distribution</p>
</dd>
</dl>



<h3>Note</h3>

<p>Working with a computer, we use a finite interval as support which carries at least mass <code>1-getdistrOption("TruncQuantile")</code>. </p>


<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br />
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PoisParameter-class">PoisParameter-class</a></code>
<code><a href="#topic+DiscreteDistribution-class">DiscreteDistribution-class</a></code>
<code><a href="#topic+Naturals-class">Naturals-class</a></code>
<code><a href="stats.html#topic+Poisson">rpois</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- Pois(lambda = 1) # P is a Poisson distribution with lambda = 1.
r(P)(1) # one random number generated from this distribution, e.g. 1
d(P)(1) # Density of this distribution is 0.3678794 for x = 1.
p(P)(0.4) # Probability that x &lt; 0.4 is 0.3678794.
q(P)(.1) # x = 0 is the smallest value x such that p(B)(x) &gt;= 0.1.
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
lambda(P) # lambda of this distribution is 1.
lambda(P) &lt;- 2 # lambda of this distribution is now 2.
R &lt;- Pois(lambda = 3) # R is a Poisson distribution with lambda = 2.
S &lt;- P + R # R is a Poisson distribution with lambda = 5(=2+3).
</code></pre>

<hr>
<h2 id='PoisParameter-class'>Class &quot;PoisParameter&quot;</h2><span id='topic+PoisParameter-class'></span><span id='topic+initialize+2CPoisParameter-method'></span>

<h3>Description</h3>

<p> The parameter of a Poisson distribution, used by Pois-class</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PoisParameter", lambda)</code>.
Usually an object of this class is not needed on its own, it is
generated automatically when an object of the class Pois is prepared. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>lambda</code></dt><dd><p>Object of class <code>"numeric"</code>:
the lambda of a Poisson distribution</p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>:
a name / comment for the parameters</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "PoisParameter")</code>:
initialize method </p>
</dd>
<dt>lambda</dt><dd><p><code>signature(object = "PoisParameter")</code>:
returns the slot lambda of the parameter of the distribution</p>
</dd>
<dt>lambda&lt;-</dt><dd><p><code>signature(object = "PoisParameter")</code>:
modifies the slot lambda of the parameter of the distribution</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pois-class">Pois-class</a></code>
<code><a href="#topic+Parameter-class">Parameter-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- new("PoisParameter",lambda = 1)
lambda(W) # lambda of this distribution is 1.
lambda(W) &lt;- 2 # lambda of this distribution is now 2.
</code></pre>

<hr>
<h2 id='PosDefSymmMatrix'>Generating functions for PosSemDefSymmMatrix-class resp. PosDefSymmMatrix-class</h2><span id='topic+PosDefSymmMatrix'></span><span id='topic+PosSemDefSymmMatrix'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"PosSemDefSymmMatrix"</code> resp. of class <code>"PosDefSymmMatrix"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>PosSemDefSymmMatrix(mat)
       PosDefSymmMatrix(mat)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PosDefSymmMatrix_+3A_mat">mat</code></td>
<td>
<p>A numeric positive-[semi-]definite, symmetric 
matrix with finite entries.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>mat</code> is no matrix, <code>as.matrix</code> is applied.
</p>


<h3>Value</h3>

<p>Object of class <code>"PosSemDefSymmMatrix"</code> resp. of class <code>"PosDefSymmMatrix"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+PosDefSymmMatrix-class">PosDefSymmMatrix-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>PosSemDefSymmMatrix(1)
PosSemDefSymmMatrix(diag(2))
PosDefSymmMatrix(1)
PosDefSymmMatrix(diag(2))
</code></pre>

<hr>
<h2 id='PosDefSymmMatrix-class'>Positive-[Semi-]definite, symmetric matrices</h2><span id='topic+PosDefSymmMatrix-class'></span><span id='topic+PosSemDefSymmMatrix-class'></span>

<h3>Description</h3>

<p>The class of positive-[semi-]definite, symmetric matrices.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PosSemDefSymmMatrix", ...)</code>
resp. <code>new("PosDefSymmMatrix", ...)</code>.
More frequently they are created via the generating functions
<code>PosSemDefSymmMatrix</code> resp. <code>PosDefSymmMatrix</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p>Object of class <code>"matrix"</code>. 
A numeric matrix with finite entries.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>[Class <code>"PosSemDefSymmMatrix"</code>, directly]
Class <code>"matrix"</code>, from data part.<br />
Class <code>"structure"</code>, by class <code>"matrix"</code>.<br />
Class <code>"array"</code>, by class <code>"matrix"</code>.<br />
Class <code>"vector"</code>, by class &quot;matrix&quot;, with explicit coerce.<br />
Class <code>"vector"</code>, by class &quot;matrix&quot;, with explicit coerce.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+PosDefSymmMatrix">PosDefSymmMatrix</a></code>, <code><a href="methods.html#topic+StructureClasses">matrix-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("PosDefSymmMatrix", diag(2))
</code></pre>

<hr>
<h2 id='print-methods'> Methods for Functions print/show in Package &lsquo;distr&rsquo; </h2><span id='topic+print-methods'></span><span id='topic+show-methods'></span><span id='topic+print+2CUnivariateDistribution-method'></span><span id='topic+show+2CUnivariateDistribution-method'></span><span id='topic+show+2CLatticeDistribution-method'></span><span id='topic+show+2CUnivarMixingDistribution-method'></span><span id='topic+show+2CUnivarLebDecDistribution-method'></span>

<h3>Description</h3>

<p>print/show-methods</p>


<h3>Methods</h3>


<dl>
<dt>print</dt><dd><p><code>signature(x = "UnivariateDistribution")</code>: returns the class of the object and its parameters </p>
</dd>
<dt>show</dt><dd><p><code>signature(x = "UnivariateDistribution")</code>: returns the class of the object and its parameters </p>
</dd>
</dl>

<hr>
<h2 id='prob-methods'> Methods for Function prob in Package &lsquo;distr&rsquo; </h2><span id='topic+prob-methods'></span><span id='topic+prob+3C--methods'></span><span id='topic+prob'></span><span id='topic+prob+3C-'></span><span id='topic+prob+2CBinomParameter-method'></span><span id='topic+prob+2CBinom-method'></span><span id='topic+prob+2CNbinomParameter-method'></span><span id='topic+prob+2CNbinom-method'></span><span id='topic+prob+2CGeomParameter-method'></span><span id='topic+prob+2CGeom-method'></span><span id='topic+prob+2CDiscreteDistribution-method'></span><span id='topic+prob+2CUnivarLebDecDistribution-method'></span><span id='topic+prob+3C-+2CBinomParameter-method'></span><span id='topic+prob+3C-+2CBinom-method'></span><span id='topic+prob+3C-+2CNbinomParameter-method'></span><span id='topic+prob+3C-+2CNbinom-method'></span><span id='topic+prob+3C-+2CGeomParameter-method'></span><span id='topic+prob+3C-+2CGeom-method'></span><span id='topic+prob+3C-+2CDiscreteDistribution-method'></span>

<h3>Description</h3>

<p>prob-methods</p>


<h3>Methods</h3>


<dl>
<dt>prob</dt><dd><p><code>signature(object = "BinomParameter")</code>: returns the slot <code>prop</code> of the parameter of the distribution </p>
</dd>
<dt>prob&lt;-</dt><dd><p><code>signature(object = "BinomParameter")</code>: modifies the slot <code>prob</code> of the parameter of the distribution </p>
</dd>
<dt>prob</dt><dd><p><code>signature(object = "Binom")</code>: returns the slot <code>prop</code> of the parameter of the distribution </p>
</dd>
<dt>prob&lt;-</dt><dd><p><code>signature(object = "Binom")</code>: modifies the slot <code>prob</code> of the parameter of the distribution </p>
</dd>
<dt>prob</dt><dd><p><code>signature(object = "NbinomParameter")</code>: returns the slot <code>prop</code> of the parameter of the distribution </p>
</dd>
<dt>prob&lt;-</dt><dd><p><code>signature(object = "NbinomParameter")</code>: modifies the slot <code>prob</code> of the parameter of the distribution </p>
</dd>
<dt>prob</dt><dd><p><code>signature(object = "Nbinom")</code>: returns the slot <code>prop</code> of the parameter of the distribution </p>
</dd>
<dt>prob&lt;-</dt><dd><p><code>signature(object = "Nbinom")</code>: modifies the slot <code>prob</code> of the parameter of the distribution </p>
</dd>
<dt>prob</dt><dd><p><code>signature(object = "GeomParameter")</code>: returns the slot <code>prop</code> of the parameter of the distribution (deprecated from 1.9 on)</p>
</dd>
<dt>prob&lt;-</dt><dd><p><code>signature(object = "GeomParameter")</code>: modifies the slot <code>prob</code> of the parameter of the distribution (deprecated from 1.9 on)</p>
</dd>
<dt>prob</dt><dd><p><code>signature(object = "Geom")</code>: returns the slot <code>prop</code> of the parameter of the distribution </p>
</dd>
<dt>prob&lt;-</dt><dd><p><code>signature(object = "Geom")</code>: modifies the slot <code>prob</code> of the parameter of the distribution </p>
</dd>
<dt>prob</dt><dd><p><code>signature(object = "DiscreteDistribution")</code>: returns the 
(named) vector of probabilities for the support points of the distribution. </p>
</dd>
<dt>prob&lt;-</dt><dd><p><code>signature(object = "DiscreteDistribution")</code>: 
generates a new object of class <code>"DiscreteDistribution"</code> with
the same support as <code>object</code> as well as the same 
<code>.withSim</code>, <code>.withArith</code>, <code>.lowerExact</code>, 
<code>.logExact</code> slots. </p>
</dd>
<dt>prob</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code>: returns a
<code class="reqn">2 \times n</code> matrix where n is the length of the support of
the discrete part of the distribution; the first row named <code>"cond"</code> 
gives the vector of  probabilities for the support points of the discrete part
of the distribution (i.e.; conditional on being in the discrete part), the second
row named <code>"abs"</code> is like the first one but multiplied with <code>discreteWeight</code>
of the distribution, hence gives the absolute probabilities of the support points;
the columns are named by the support values. </p>
</dd>
</dl>

<hr>
<h2 id='q-methods'>Methods for Function q in Package &lsquo;distr&rsquo;</h2><span id='topic+q-methods'></span><span id='topic+q'></span><span id='topic+q+2CDistribution-method'></span><span id='topic+q.l-methods'></span><span id='topic+q.l'></span><span id='topic+q.l+2CDistribution-method'></span>

<h3>Description</h3>

<p>q-methods</p>


<h3>Methods</h3>


<dl>
<dt>q</dt><dd><p><code>signature(save  = "Distribution")</code>: returns the
(left-continuous) quantile function, i.e.;
<code class="reqn">{\rm q}(s)=\inf\{t \,\big|\, P({\tt object}\leq t)\geq s\}</code></p>
</dd>
<dt>q.l</dt><dd><p><code>signature(object  = "Distribution")</code>: 
from distr-2.6 onwards, we provide this as a synonym for 
method <code>q</code>; this synonym more explicitely states that we are dealing with
the left-continuous variant of a quantile function. It is useful in particular 
when used from the console in RStudio, as RStudio catches calls to 
<code>q()</code> and treats them separately from usual R evaluation.  
The developers of RStudio have been asked to fix this and comply with standard 
R evaluation which explicitely allows overloading <code>q()</code> as we do it in this 
package, but so far have refused to do so, as they claim overloading 
<code>q()</code> was insane.
</p>
</dd></dl>


<h3>See Also</h3>

<p><code><a href="#topic+Distribution-class">Distribution-class</a></code>, <code>q.r</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(distr)
N &lt;- Norm()
q(N)(0.3)
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
q.l(N)(0.3)
</code></pre>

<hr>
<h2 id='q.r-methods'>Methods for Function q.r in Package &lsquo;distr&rsquo;</h2><span id='topic+q.r-methods'></span><span id='topic+q.r'></span><span id='topic+q.r+2CAbscontDistribution-method'></span><span id='topic+q.r+2CDiscreteDistribution-method'></span><span id='topic+q.r+2CUnivarLebDecDistribution-method'></span><span id='topic+q.r+2CUnivarMixingDistribution-method'></span>

<h3>Description</h3>

<p>q.r-methods</p>


<h3>Methods</h3>

<p>return the right-continuous quantile function, i.e.; 
<code class="reqn">{\rm q.r}(s)=\sup\{t \,\big|\, P({\tt object}\leq t)\leq s\}</code>
</p>

<dl>
<dt>q.r</dt><dd><p><code>signature(object  = "DiscreteDistribution")</code></p>
</dd> 
<dt>q.r</dt><dd><p><code>signature(object  = "AbscontDistribution")</code></p>
</dd> 
<dt>q.r</dt><dd><p><code>signature(object  = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>q.r</dt><dd><p><code>signature(object  = "UnivarMixingDistribution")</code></p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+DiscreteDistribution-class">DiscreteDistribution-class</a></code>
<code><a href="#topic+UnivarLebDecDistribution-class">UnivarLebDecDistribution-class</a></code>
</p>

<hr>
<h2 id='qqbounds'>Computation of confidence intervals for qqplot</h2><span id='topic+qqbounds'></span>

<h3>Description</h3>

<p>We compute confidence intervals for QQ plots.
These can be simultaneous (to check whether the whole data set is compatible)
or pointwise (to check whether each (single) data point is compatible);</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqbounds(x,D,alpha,n,withConf.pw, withConf.sim,
         exact.sCI=(n&lt;100),exact.pCI=(n&lt;100),
         nosym.pCI = FALSE, debug = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqbounds_+3A_x">x</code></td>
<td>
<p>data to be checked for compatibility with distribution <code>D</code>.</p>
</td></tr>
<tr><td><code id="qqbounds_+3A_d">D</code></td>
<td>
<p>object of class <code>"UnivariateDistribution"</code>, the assumed data
distribution.</p>
</td></tr>
<tr><td><code id="qqbounds_+3A_alpha">alpha</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="qqbounds_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="qqbounds_+3A_withconf.pw">withConf.pw</code></td>
<td>
<p>logical; shall pointwise confidence lines be computed?</p>
</td></tr>
<tr><td><code id="qqbounds_+3A_withconf.sim">withConf.sim</code></td>
<td>
<p>logical; shall simultaneous confidence lines be computed?</p>
</td></tr>
<tr><td><code id="qqbounds_+3A_exact.pci">exact.pCI</code></td>
<td>
<p>logical; shall pointwise CIs be determined with exact Binomial distribution?</p>
</td></tr>
<tr><td><code id="qqbounds_+3A_exact.sci">exact.sCI</code></td>
<td>
<p>logical; shall simultaneous CIs be determined with exact kolmogorov distribution?</p>
</td></tr>
<tr><td><code id="qqbounds_+3A_nosym.pci">nosym.pCI</code></td>
<td>
<p>logical; shall we use (shortest) asymmetric CIs?</p>
</td></tr>
<tr><td><code id="qqbounds_+3A_debug">debug</code></td>
<td>
<p>logical; if <code>TRUE</code> additional output to debug confidence bounds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both simultaneous  and pointwise confidence intervals come in a
finite-sample and an asymptotic version;
the finite sample versions will get quite slow
for large data sets <code>x</code>, so in these cases the asymptotic version
will be preferrable.<br />
For simultaneous intervals,
the finite sample version is based on C function <code>"pkolmogorov2x"</code>
from package <span class="pkg">stats</span>, while the asymptotic one uses
R function <code>pkstwo</code> again from package <span class="pkg">stats</span>, both taken
from the code to <code><a href="stats.html#topic+ks.test">ks.test</a></code>.
</p>
<p>Both finite sample and asymptotic versions use the fact,
that the distribution of the supremal distance between the
empirical distribution <code class="reqn">\hat F_n</code> and the corresponding theoretical one
<code class="reqn">F</code> (assuming data from <code class="reqn">F</code>)
does not depend on <code class="reqn">F</code> for continuous distribution <code class="reqn">F</code>
and leads to the Kolmogorov distribution (compare, e.g. Durbin(1973)).
In case of <code class="reqn">F</code> with jumps, the corresponding Kolmogorov distribution
is used to produce conservative intervals.
<br />
For pointwise intervals,
the finite sample version is based on corresponding binomial distributions,
(compare e.g., Fisz(1963)), while the asymptotic one uses a CLT approximation
for this binomial distribution. In fact, this approximation is only valid
for distributions with strictly positive density at the evaluation quantiles.
</p>
<p>In the finite sample version, the binomial distributions will in general not
be symmetric, so that, by setting <code>nosym.pCI</code> to <code>TRUE</code> we may
produce shortest asymmetric confidence intervals (albeit with a considerable
computational effort).
</p>
<p>The symmetric intervals returned by default will
be conservative (which also applies to distributions with jumps in this case).
</p>
<p>For distributions with jumps or with density (nearly) equal to 0 at the
corresponding quantile, we use the approximation of <code>(D-E(D))/sd(D)</code>
by the standard normal at these points; this latter approximation is only
available if package <span class="pkg">distrEx</span> is installed; otherwise the corresponding
columns will be filled with <code>NA</code>.
</p>


<h3>Value</h3>

<p>A list with components <code>crit</code> &mdash; a matrix with the lower and upper confidence
bounds, and <code>err</code> a logical vector of length 2.
</p>
<p>Component <code>crit</code> is a matrix with <code>length(x)</code> rows
and four columns <code>c("sim.left","sim.right","pw.left","pw.right")</code>.
Entries will be set to <code>NA</code> if the corresponding <code>x</code> component
is not in <code>support(D)</code> or if the computation method returned an error
or if the corresponding parts have not been required (if <code>withConf.pw</code>
or <code>withConf.sim</code> is <code>FALSE</code>).
</p>
<p><code>err</code> has components <code>pw</code>
&mdash;do we have a non-error return value for the computation of pointwise CI's
(<code>FALSE</code> if <code>withConf.pw</code> is <code>FALSE</code>)&mdash;  and <code>sim</code>
&mdash;do we have a   non-error return value for the computation of simultaneous CI's
(<code>FALSE</code> if <code>withConf.sim</code> is <code>FALSE</code>).
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>References</h3>

<p>Durbin, J. (1973)
<em>Distribution theory for tests based on the sample distribution
function</em>.  SIAM.
</p>
<p>Fisz, M. (1963). <em>Probability Theory and Mathematical Statistics</em>.
3rd ed. Wiley, New York.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+qqnorm">qqplot</a></code> from package <span class="pkg">stats</span> &ndash; the standard QQ plot
function, <code><a href="stats.html#topic+ks.test">ks.test</a></code> again from package <span class="pkg">stats</span>
for the implementation of the Kolmogorov distributions;
<code><a href="#topic+qqplot">qqplot</a></code> from package <span class="pkg">distr</span> for
comparisons of distributions, and
<code>qqplot</code> from package <span class="pkg">distrMod</span> for comparisons
of data with models, as well as  <code>RobAStBase::qqplot</code> from package <span class="pkg">RobAStBase</span> for
checking of corresponding robust esimators.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qqplot(Norm(15,sqrt(30)), Chisq(df=15))
## uses:
old.digits &lt;- getOption("digits")
on.exit(options(digits = old.digits))
options(digits = 6)
set.seed(20230508)
## IGNORE_RDIFF_BEGIN
qqbounds(x = rnorm(30), Norm(), alpha = 0.95, n = 30,
        withConf.pw = TRUE, withConf.sim  = TRUE,
        exact.sCI = TRUE, exact.pCI = TRUE,
        nosym.pCI = FALSE)
## other calls:
qqbounds(x = rchisq(30,df=4), Chisq(df=4), alpha = 0.95, n = 30,
        withConf.pw = TRUE, withConf.sim  = TRUE,
        exact.sCI = FALSE, exact.pCI = FALSE,
        nosym.pCI = FALSE)
qqbounds(x = rchisq(30,df=4), Chisq(df=4), alpha = 0.95, n = 30,
        withConf.pw = TRUE, withConf.sim  = TRUE,
        exact.sCI = TRUE, exact.pCI= TRUE,
        nosym.pCI = TRUE)
## IGNORE_RDIFF_END
options(digits = old.digits)
</code></pre>

<hr>
<h2 id='qqplot'>Methods for Function qqplot in Package &lsquo;distr&rsquo;</h2><span id='topic+qqplot'></span><span id='topic+qqplot-methods'></span><span id='topic+qqplot+2CANY+2CANY-method'></span><span id='topic+qqplot+2CUnivariateDistribution+2CUnivariateDistribution-method'></span>

<h3>Description</h3>

<p>We generalize function <code><a href="stats.html#topic+qqnorm">qqplot</a></code> from package <span class="pkg">stats</span> to
be applicable to distribution objects.  In this context,
<code>qqplot</code> produces a QQ plot of two distributions, i.e.; argument <code>x</code>
is the distribution to be checked for compatibility, and <code>y</code> is the
model (<code class="reqn">H_0</code>-)distribution.
Graphical parameters may be given as arguments to <code>qqplot</code>.
The <span class="pkg">stats</span> function
is just the method for signature <code>x=ANY,y=ANY</code>.
In all title and axis label arguments, if <code>withSubst</code> is <code>TRUE</code>,
the following patterns are substituted:
</p>

<dl>
<dt><code>"%C"</code></dt><dd><p>class of argument <code>x</code></p>
</dd>
<dt><code>"%A"</code></dt><dd><p>deparsed argument <code>x</code></p>
</dd>
<dt><code>"%D"</code></dt><dd><p>time/date-string when the plot was generated</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>qqplot(x, y, ...)
## S4 method for signature 'UnivariateDistribution,UnivariateDistribution'
qqplot(x, y,
    n = 30, withIdLine = TRUE, withConf = TRUE,
    withConf.pw  = withConf,  withConf.sim = withConf,
    plot.it = TRUE, xlab = deparse(substitute(x)),
    ylab = deparse(substitute(y)), ...,
    width = 10, height = 5.5, withSweave = getdistrOption("withSweave"),
    mfColRow = TRUE, n.CI = n, col.IdL = "red", lty.IdL = 2, lwd.IdL = 2,
    alpha.CI = .95, exact.pCI = (n&lt;100), exact.sCI = (n&lt;100), nosym.pCI = FALSE,
    col.pCI = "orange", lty.pCI = 3, lwd.pCI = 2, pch.pCI = par("pch"),
    cex.pCI = par("cex"),
    col.sCI = "tomato2", lty.sCI = 4, lwd.sCI = 2, pch.sCI = par("pch"),
    cex.sCI = par("cex"),
    cex.pch = par("cex"), col.pch = par("col"),
    jit.fac = 0, check.NotInSupport = TRUE,
    col.NotInSupport = "red", with.legend = TRUE, legend.bg = "white",
    legend.pos = "topleft", legend.cex = 0.8, legend.pref = "", 
    legend.postf = "", legend.alpha = alpha.CI, debug = FALSE, withSubst = TRUE)
## S4 method for signature 'ANY,ANY'
qqplot(x, y,
    plot.it = TRUE, xlab = deparse(substitute(x)),
    ylab = deparse(substitute(y)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqplot_+3A_x">x</code></td>
<td>
<p>object of class <code>"ANY"</code> (<span class="pkg">stats</span>-method) or
of code <code>"UnivariateDistribution"</code>; to be compared to <code>y</code>.</p>
</td></tr>
<tr><td><code id="qqplot_+3A_y">y</code></td>
<td>
<p>object of class <code>"ANY"</code> (<span class="pkg">stats</span>-method) or
of class <code>"UnivariateDistribution"</code>.</p>
</td></tr>
<tr><td><code id="qqplot_+3A_n">n</code></td>
<td>
<p>numeric; number of quantiles at which to do the comparison.</p>
</td></tr>
<tr><td><code id="qqplot_+3A_withidline">withIdLine</code></td>
<td>
<p>logical; shall line <code>y = x</code> be plotted in?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_withconf">withConf</code></td>
<td>
<p>logical; shall confidence lines be plotted?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_withconf.pw">withConf.pw</code></td>
<td>
<p>logical; shall pointwise confidence lines be plotted?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_withconf.sim">withConf.sim</code></td>
<td>
<p>logical; shall simultaneous confidence lines be plotted?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_plot.it">plot.it</code></td>
<td>
<p>logical; shall be plotted at all (inherited from <code><a href="stats.html#topic+qqnorm">qqplot</a></code>)?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_xlab">xlab</code></td>
<td>
<p>x-label</p>
</td></tr>
<tr><td><code id="qqplot_+3A_ylab">ylab</code></td>
<td>
<p>y-label</p>
</td></tr>
<tr><td><code id="qqplot_+3A_...">...</code></td>
<td>
<p>further parameters for function <code>plot</code></p>
</td></tr>
<tr><td><code id="qqplot_+3A_width">width</code></td>
<td>
<p>width (in inches) of the graphics device opened</p>
</td></tr>
<tr><td><code id="qqplot_+3A_height">height</code></td>
<td>
<p>height (in inches) of the graphics device opened</p>
</td></tr>
<tr><td><code id="qqplot_+3A_withsweave">withSweave</code></td>
<td>
<p>logical: if <code>TRUE</code> (for working with <code>Sweave</code>)
no extra device is opened and height/width are not set</p>
</td></tr>
<tr><td><code id="qqplot_+3A_mfcolrow">mfColRow</code></td>
<td>
<p>shall default partition in panels be used &mdash; defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="qqplot_+3A_n.ci">n.CI</code></td>
<td>
<p>numeric; number of points to be used for confidence interval</p>
</td></tr>
<tr><td><code id="qqplot_+3A_col.idl">col.IdL</code></td>
<td>
<p>color for the identity line</p>
</td></tr>
<tr><td><code id="qqplot_+3A_lty.idl">lty.IdL</code></td>
<td>
<p>line type for the identity line</p>
</td></tr>
<tr><td><code id="qqplot_+3A_lwd.idl">lwd.IdL</code></td>
<td>
<p>line width for the identity line</p>
</td></tr>
<tr><td><code id="qqplot_+3A_alpha.ci">alpha.CI</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="qqplot_+3A_exact.pci">exact.pCI</code></td>
<td>
<p>logical; shall pointwise CIs be determined with exact Binomial distribution?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_exact.sci">exact.sCI</code></td>
<td>
<p>logical; shall simultaneous CIs be determined with exact kolmogorov distribution?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_nosym.pci">nosym.pCI</code></td>
<td>
<p>logical; shall we use (shortest) asymmetric CIs?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_col.pci">col.pCI</code></td>
<td>
<p>color for the pointwise CI</p>
</td></tr>
<tr><td><code id="qqplot_+3A_lty.pci">lty.pCI</code></td>
<td>
<p>line type for the pointwise CI</p>
</td></tr>
<tr><td><code id="qqplot_+3A_lwd.pci">lwd.pCI</code></td>
<td>
<p>line width for the pointwise CI</p>
</td></tr>
<tr><td><code id="qqplot_+3A_pch.pci">pch.pCI</code></td>
<td>
<p>symbol for points (for discrete mass points) in pointwise CI</p>
</td></tr>
<tr><td><code id="qqplot_+3A_cex.pci">cex.pCI</code></td>
<td>
<p>magnification factor for points (for discrete mass points) in pointwise CI</p>
</td></tr>
<tr><td><code id="qqplot_+3A_col.sci">col.sCI</code></td>
<td>
<p>color for the simultaneous CI</p>
</td></tr>
<tr><td><code id="qqplot_+3A_lty.sci">lty.sCI</code></td>
<td>
<p>line type for the simultaneous CI</p>
</td></tr>
<tr><td><code id="qqplot_+3A_lwd.sci">lwd.sCI</code></td>
<td>
<p>line width for the simultaneous CI</p>
</td></tr>
<tr><td><code id="qqplot_+3A_pch.sci">pch.sCI</code></td>
<td>
<p>symbol for points (for discrete mass points) in simultaneous CI</p>
</td></tr>
<tr><td><code id="qqplot_+3A_cex.sci">cex.sCI</code></td>
<td>
<p>magnification factor for points (for discrete mass points) in simultaneous CI</p>
</td></tr>
<tr><td><code id="qqplot_+3A_cex.pch">cex.pch</code></td>
<td>
<p>magnification factor for the plotted symbols</p>
</td></tr>
<tr><td><code id="qqplot_+3A_col.pch">col.pch</code></td>
<td>
<p>color for the plotted symbols</p>
</td></tr>
<tr><td><code id="qqplot_+3A_jit.fac">jit.fac</code></td>
<td>
<p>jittering factor used for discrete distributions</p>
</td></tr>
<tr><td><code id="qqplot_+3A_check.notinsupport">check.NotInSupport</code></td>
<td>
<p>logical; shall we check if all <code>x</code>-quantiles lie in <code>support(y)</code>?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_col.notinsupport">col.NotInSupport</code></td>
<td>
<p>logical; if preceding check <code>TRUE</code> color of <code>x</code>-quantiles if not in <code>support(y)</code></p>
</td></tr>
<tr><td><code id="qqplot_+3A_with.legend">with.legend</code></td>
<td>
<p>logical; shall a legend be plotted?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_legend.bg">legend.bg</code></td>
<td>
<p>background color for the legend</p>
</td></tr>
<tr><td><code id="qqplot_+3A_legend.pos">legend.pos</code></td>
<td>
<p>position for the legend</p>
</td></tr>
<tr><td><code id="qqplot_+3A_legend.cex">legend.cex</code></td>
<td>
<p>magnification factor for the legend</p>
</td></tr>
<tr><td><code id="qqplot_+3A_legend.pref">legend.pref</code></td>
<td>
<p>character to be prepended to legend text</p>
</td></tr>
<tr><td><code id="qqplot_+3A_legend.postf">legend.postf</code></td>
<td>
<p>character to be appended to legend text</p>
</td></tr>
<tr><td><code id="qqplot_+3A_legend.alpha">legend.alpha</code></td>
<td>
<p>nominal coverage probability</p>
</td></tr>
<tr><td><code id="qqplot_+3A_debug">debug</code></td>
<td>
<p>logical; if <code>TRUE</code> additional output to debug confidence bounds.</p>
</td></tr>
<tr><td><code id="qqplot_+3A_withsubst">withSubst</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) pattern substitution for
titles and lables is used; otherwise no substitution is used. </p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>qqplot</dt><dd><p><code>signature(x = "ANY", y = "ANY")</code>: function <code>qqplot</code> from
package <span class="pkg">stats</span>.</p>
</dd>
<dt>qqplot</dt><dd><p><code>signature(x = "UnivariateDistribution", y = "UnivariateDistribution")</code>:
produces a QQ plot for two univariate distributions.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list of elements containing the information needed to compute the 
respective QQ plot, in particular it extends the elements of the 
return value of function <code><a href="stats.html#topic+qqnorm">qqplot</a></code> 
from package <span class="pkg">stats</span>, i.e., a
list with components <code>x</code> and <code>y</code> for x and y coordinates
of the plotted points; more specifically it contains
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>The x coordinates of the points that were/would be plotted</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The corresponding quantiles of the second distribution,
<em>including <code><a href="base.html#topic+NA">NA</a></code>s</em>.</p>
</td></tr>
<tr><td><code>crit</code></td>
<td>
<p>A matrix with the lower and upper confidence bounds
(computed by <code>qqbounds</code>).</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>logical vector of length 2.</p>
</td></tr>
</table>
<p>(elements <code>crit</code> and <code>err</code> are taken from the return
value(s) of <code>qqbounds</code>).
The return value allows to recover all information used to produce the plot
for later use in enhanced graphics (e.g. with ggplot).   
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>References</h3>

<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
<em>The New S Language</em>.
Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+qqnorm">qqplot</a></code> from package <span class="pkg">stats</span> &ndash; the standard QQ plot
function and
<code><a href="#topic+qqbounds">qqbounds</a></code>, used by <code>qqplot</code> to produce confidence
intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## IGNORE_RDIFF_BEGIN
qqplot(Norm(15,sqrt(30)), Chisq(df=15))
## some discrete Distributions:
P &lt;- Pois(5)
B &lt;- Binom(size=2000,prob=5/2000)
qqplot(B,P)
## IGNORE_RDIFF_END

## takes too much time for R CMD check --as-cran
qqplot(B,P, nosym.pCI=TRUE)

## some Lebesgue-Decomposed distributions:
mylist &lt;- UnivarLebDecDistribution(discretePart=Binom(3,.3), acPart=Norm(2,2),
               acWeight=11/20)
mylist2 &lt;- mylist+0.1

## IGNORE_RDIFF_BEGIN
qqplot(mylist,mylist2)
qqplot(mylist,mylist2,exact.pCI=FALSE,exact.sCI=FALSE)
## IGNORE_RDIFF_END


## takes too much time for R CMD check --as-cran
qqplot(mylist,mylist2,nosym.pCI=TRUE)
## some ac. distribution with a gap
mylist3 &lt;- UnivarMixingDistribution(Unif(0,0.3),Unif(0.6,1),mixCoeff=c(0.8,0.2))
gaps(mylist3)
mylist4 &lt;- UnivarMixingDistribution(Unif(0,0.3),Unif(0.6,1),mixCoeff=c(0.6,0.4))
qqplot(mylist3,mylist4)
qqplot(mylist3,mylist4,nosym.pCI=TRUE)

</code></pre>

<hr>
<h2 id='r-methods'> Methods for Function r in Package &lsquo;distr&rsquo; </h2><span id='topic+r-methods'></span><span id='topic+r'></span><span id='topic+r+2CDistribution-method'></span>

<h3>Description</h3>

<p>r-methods</p>


<h3>Methods</h3>


<dl>
<dt>r</dt><dd><p><code>signature(object = "Distribution")</code>: generates random deviates
according to the distribution</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+Distribution-class">Distribution-class</a></code>
</p>

<hr>
<h2 id='rate-methods'> Methods for Function rate in Package &lsquo;distr&rsquo; </h2><span id='topic+rate-methods'></span><span id='topic+rate+3C--methods'></span><span id='topic+rate'></span><span id='topic+rate+3C-'></span><span id='topic+rate+2CExpParameter-method'></span><span id='topic+rate+2CExp-method'></span><span id='topic+rate+2CDExp-method'></span><span id='topic+rate+3C-+2CExpParameter-method'></span><span id='topic+rate+3C-+2CExp-method'></span><span id='topic+rate+3C-+2CDExp-method'></span>

<h3>Description</h3>

<p>rate-methods</p>


<h3>Methods</h3>


<dl>
<dt>rate</dt><dd><p><code>signature(object = "ExpParameter")</code>: returns the slot <code>rate</code> of the parameter of the distribution </p>
</dd>
<dt>rate&lt;-</dt><dd><p><code>signature(object = "ExpParameter")</code>: modifies the slot <code>rate</code> of the parameter of the distribution </p>
</dd>
<dt>rate</dt><dd><p><code>signature(object = "Exp")</code>: returns the slot <code>rate</code> of the parameter of the distribution </p>
</dd>
<dt>rate&lt;-</dt><dd><p><code>signature(object = "Exp")</code>: modifies the slot <code>rate</code> of the parameter of the distribution </p>
</dd>
<dt>rate</dt><dd><p><code>signature(object = "DExp")</code>: returns the slot <code>rate</code> of the parameter of the distribution </p>
</dd>
<dt>rate&lt;-</dt><dd><p><code>signature(object = "DExp")</code>: modifies the slot <code>rate</code> of the parameter of the distribution </p>
</dd>
</dl>

<hr>
<h2 id='Reals-class'>Class &quot;Reals&quot; </h2><span id='topic+Reals'></span><span id='topic+Reals-class'></span><span id='topic+initialize+2CReals-method'></span>

<h3>Description</h3>

<p> Particular case of a one-dimensional Euclidean Space </p>


<h3>Usage</h3>

<pre><code class='language-R'>Reals()</code></pre>


<h3>Objects from the Class</h3>

<p>Objects could theoretically be created by calls of the form <code>new("Reals", dimension, name)</code>.
Usually an object of this class is not needed on its own. It is generated automatically when a univariate absolutly
continuous distribution is instantiated. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>dimension</code></dt><dd><p>Object of class <code>"character"</code>: the dimension of the space, by default = 1 </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: the name of the space, by default = &quot;Real Space&quot;</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"EuclideanSpace"</code>, directly.<br />
Class <code>"rSpace"</code>, by class <code>"EuclideanSpace"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "Reals")</code>: initialize method </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EuclideanSpace-class">EuclideanSpace-class</a></code>
<code><a href="#topic+Naturals-class">Naturals-class</a></code>
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R &lt;- Reals()
liesIn(R,c(0,0)) # FALSE
</code></pre>

<hr>
<h2 id='rSpace-class'>Class &quot;rSpace&quot; </h2><span id='topic+rSpace-class'></span>

<h3>Description</h3>

<p> The distribution-classes contain a slot where the sample space is stored. Typically, discrete random variables
take naturals as values. rSpace is the mother-class of the class EuclideanSpace. </p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: the name of the space </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>name</dt><dd><p><code>signature(object = "rSpace")</code>: returns the name of the space </p>
</dd>
<dt>name&lt;-</dt><dd><p><code>signature(object = "rSpace")</code>: changes the name of the space </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Lattice-class">Lattice-class</a></code>
<code><a href="#topic+Naturals-class">Naturals-class</a></code>
<code><a href="#topic+EuclideanSpace-class">EuclideanSpace-class</a></code>
<code><a href="#topic+Distribution-class">Distribution-class</a></code>
</p>

<hr>
<h2 id='RtoDPQ'>Default procedure to fill slots d,p,q given r for a.c. distributions</h2><span id='topic+RtoDPQ'></span>

<h3>Description</h3>

<p>function to do get empirical density, cumulative distribution and quantile function from random numbers</p>


<h3>Usage</h3>

<pre><code class='language-R'>RtoDPQ(r, e = getdistrOption("RtoDPQ.e"), 
       n = getdistrOption("DefaultNrGridPoints"), y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RtoDPQ_+3A_r">r</code></td>
<td>
<p> the random number generator </p>
</td></tr>
<tr><td><code id="RtoDPQ_+3A_e">e</code></td>
<td>
 <p><code class="reqn">10^e</code> numbers are generated, a higher number leads to a better result. </p>
</td></tr>
<tr><td><code id="RtoDPQ_+3A_n">n</code></td>
<td>
<p> The number of grid points used to create the approximated functions, a higher number leads to a better result.</p>
</td></tr>
<tr><td><code id="RtoDPQ_+3A_y">y</code></td>
<td>
<p>a (numeric) vector or <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>RtoDPQ generates <code class="reqn">10^e</code> random numbers, by default </p>
<p style="text-align: center;"><code class="reqn">e = RtoDPQ.e</code>
</p>
<p>. 
Instead of using simulated grid points, we have an optional parameter <code>y</code>
for using N. Horbenko's quantile trick: i.e.; on an equally spaced grid <code>x.grid</code> on [0,1], apply
<code>f(q(x)(x.grid))</code> and write the result to <code>y</code> and produce density and cdf from this
value <code>y</code> given to <code>RtoDPQ</code> as argument (instead of simulating grid points).
</p>
<p>The density is formed on the basis of <code class="reqn">n</code>
points using approxfun and density, by default </p>
<p style="text-align: center;"><code class="reqn">n = DefaultNrGridPoints</code>
</p>
<p>.
The cumulative distribution function and the quantile function are also created on the basis of <code class="reqn">n</code> points using 
<code>approxfun</code> and <code>ecdf</code>.  Of course, the results are usually not exact as they rely on random numbers.</p>


<h3>Value</h3>

 <p><code>RtoDPQ</code> returns a list of functions.
</p>
<table>
<tr><td><code>dfun</code></td>
<td>
<p> density </p>
</td></tr>
<tr><td><code>pfun</code></td>
<td>
<p> cumulative distribution function </p>
</td></tr>
<tr><td><code>qfun</code></td>
<td>
<p> quantile function </p>
</td></tr>
</table>


<h3>Note</h3>

<p> Use <code>RtoDPQ</code> for absolutely continuous and <code>RtoDPQ.d</code> for discrete distributions. </p>


<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

 
<p><code><a href="#topic+UnivariateDistribution-class">UnivariateDistribution-class</a></code>, 
<code><a href="stats.html#topic+density">density</a></code>, 
<code><a href="stats.html#topic+approxfun">approxfun</a></code>, 
<code><a href="stats.html#topic+ecdf">ecdf</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20230508)
rn2 &lt;- function(n){rnorm(n)^2}
x &lt;- RtoDPQ(r = rn2, e = 4, n = 512)
# returns density, cumulative distribution and quantile function of
# squared standard normal distribution
## IGNORE_RDIFF_BEGIN
x$dfun(4)
RtoDPQ(r = rn2, e = 5, n = 1024) # for a better result
## IGNORE_RDIFF_END
rp2 &lt;- function(n){rpois(n, lambda = 1)^2}
x &lt;- RtoDPQ.d(r = rp2, e = 5)
# returns density, cumulative distribution and quantile function of
# squared Poisson distribution with parameter lambda=1
</code></pre>

<hr>
<h2 id='RtoDPQ.d'>Default procedure to fill slots d,p,q given r for discrete distributions</h2><span id='topic+RtoDPQ.d'></span>

<h3>Description</h3>

<p>function to do get empirical density, cumulative distribution and quantile function from random numbers</p>


<h3>Usage</h3>

<pre><code class='language-R'>RtoDPQ.d(r, e = getdistrOption("RtoDPQ.e"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RtoDPQ.d_+3A_r">r</code></td>
<td>
<p> the random number generator </p>
</td></tr>
<tr><td><code id="RtoDPQ.d_+3A_e">e</code></td>
<td>
 <p><code class="reqn">10^e</code> numbers are generated, a higher number leads to a better result. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>RtoDPQ.d</code> generates <code class="reqn">10^e</code> random numbers, by default <code class="reqn">e =</code>
<code>RtoDPQ.e</code> which are used to produce a density, cdf and
quantile function.
Of course, the results are usually not exact as they rely on random numbers.</p>


<h3>Value</h3>

<p> RtoDPQ returns a list of functions.
</p>
<table>
<tr><td><code>dfun</code></td>
<td>
<p> density </p>
</td></tr>
<tr><td><code>pfun</code></td>
<td>
<p> cumulative distribution function </p>
</td></tr>
<tr><td><code>qfun</code></td>
<td>
<p> quantile function </p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use RtoDPQ for absolutely continuous and RtoDPQ.d for discrete
distributions.
</p>


<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br />
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+UnivariateDistribution-class">UnivariateDistribution-class</a></code>, 
<code><a href="stats.html#topic+density">density</a></code>, 
<code><a href="stats.html#topic+approxfun">approxfun</a></code>, 
<code><a href="stats.html#topic+ecdf">ecdf</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20230508)
rn2 &lt;- function(n){rnorm(n)^2}
x &lt;- RtoDPQ(r = rn2, e = 4, n = 512)
# returns density, cumulative distribution and quantile function of
# squared standard  normal distribution
## IGNORE_RDIFF_BEGIN
x$dfun(4)
RtoDPQ(r = rn2, e = 5, n = 1024) # for a better result
## IGNORE_RDIFF_END
rp2 &lt;- function(n){rpois(n, lambda = 1)^2}
x &lt;- RtoDPQ.d(r = rp2, e = 5)
# returns density, cumulative distribution and quantile function of
# squared Poisson distribution with parameter lambda=1
</code></pre>

<hr>
<h2 id='RtoDPQ.LC'>Default procedure to fill slots d,p,q given r for Lebesgue decomposed distributions</h2><span id='topic+RtoDPQ.LC'></span>

<h3>Description</h3>

<p>function to do get empirical density, cumulative distribution and quantile function from random numbers</p>


<h3>Usage</h3>

<pre><code class='language-R'>RtoDPQ.LC(r, e = getdistrOption("RtoDPQ.e"), 
          n = getdistrOption("DefaultNrGridPoints"), y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RtoDPQ.LC_+3A_r">r</code></td>
<td>
<p> the random number generator </p>
</td></tr>
<tr><td><code id="RtoDPQ.LC_+3A_e">e</code></td>
<td>
 <p><code class="reqn">10^e</code> numbers are generated, a higher number leads to a better result. </p>
</td></tr>
<tr><td><code id="RtoDPQ.LC_+3A_n">n</code></td>
<td>
<p> The number of grid points used to create the approximated functions, a higher number leads to a better result.</p>
</td></tr>
<tr><td><code id="RtoDPQ.LC_+3A_y">y</code></td>
<td>
<p>a (numeric) vector or <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>RtoDPQ.LC generates <code class="reqn">10^e</code> random numbers, by default </p>
<p style="text-align: center;"><code class="reqn">e = RtoDPQ.e</code>
</p>
<p>. 
Replicates are assumed to be part of the discrete part, unique values to be
part of the a.c. part of the distribution. For the replicated ones,
we generate a discrete distribution by a call to <code><a href="#topic+DiscreteDistribution">DiscreteDistribution</a></code>.
</p>
<p>For the a.c. part, similarly to <code><a href="#topic+RtoDPQ">RtoDPQ</a></code> we have an optional parameter <code>y</code>
for using N. Horbenko's quantile trick: i.e.; on an equally spaced grid <code>x.grid</code> on [0,1], apply
<code>f(q(x)(x.grid))</code>, write the result to <code>y</code> and use these
values instead of simulated ones.
</p>
<p>The a.c. density is formed on the basis of <code class="reqn">n</code>
points using approxfun and density (applied to the unique values), by default </p>
<p style="text-align: center;"><code class="reqn">n = DefaultNrGridPoints</code>
</p>
<p>.
The cumulative distribution function is based on all random variables, 
and, as well as the quantile function, is also created on the basis of <code class="reqn">n</code> points using 
<code>approxfun</code> and <code>ecdf</code>.  Of course, the results are usually not exact as they rely on random numbers.</p>


<h3>Value</h3>

 <p><code>RtoDPQ.LC</code> returns an object of class <code>UnivarLebDecDistribution</code>.
</p>


<h3>Note</h3>

<p> Use <code>RtoDPQ</code> for absolutely continuous and <code>RtoDPQ.d</code> for discrete distributions. </p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

 
<p><code><a href="#topic+UnivariateDistribution-class">UnivariateDistribution-class</a></code>, 
<code><a href="stats.html#topic+density">density</a></code>, 
<code><a href="stats.html#topic+approxfun">approxfun</a></code>, 
<code><a href="stats.html#topic+ecdf">ecdf</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20230508)
rn2 &lt;- function(n)ifelse(rbinom(n,1,0.3),rnorm(n)^2,rbinom(n,4,.3))
x &lt;- RtoDPQ.LC(r = rn2, e = 4, n = 512)
plot(x)
# returns density, cumulative distribution and quantile function of
# squared standard normal distribution
## IGNORE_RDIFF_BEGIN
d.discrete(x)(4)
## IGNORE_RDIFF_END
x2 &lt;- RtoDPQ.LC(r = rn2, e = 5, n = 1024) # for a better result
plot(x2)
</code></pre>

<hr>
<h2 id='scale-methods'> Methods for Function scale in Package &lsquo;distr&rsquo; </h2><span id='topic+scale-methods'></span><span id='topic+scale+3C--methods'></span><span id='topic+scale'></span><span id='topic+scale+3C-'></span><span id='topic+scale+2CGammaParameter-method'></span><span id='topic+scale+2CGammad-method'></span><span id='topic+scale+2CChisq-method'></span><span id='topic+scale+2CLogisParameter-method'></span><span id='topic+scale+2CLogis-method'></span><span id='topic+scale+2CWeibullParameter-method'></span><span id='topic+scale+2CWeibull-method'></span><span id='topic+scale+2CCauchyParameter-method'></span><span id='topic+scale+2CCauchy-method'></span><span id='topic+scale+3C-+2CGammaParameter-method'></span><span id='topic+scale+3C-+2CGammad-method'></span><span id='topic+scale+3C-+2CLogisParameter-method'></span><span id='topic+scale+3C-+2CLogis-method'></span><span id='topic+scale+3C-+2CWeibullParameter-method'></span><span id='topic+scale+3C-+2CWeibull-method'></span><span id='topic+scale+3C-+2CCauchyParameter-method'></span><span id='topic+scale+3C-+2CCauchy-method'></span>

<h3>Description</h3>

<p>scale-methods</p>


<h3>Methods</h3>


<dl>
<dt>scale</dt><dd><p><code>signature(object = "GammaParameter")</code>: returns the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>scale&lt;-</dt><dd><p><code>signature(object = "GammaParameter")</code>: modifies the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>scale</dt><dd><p><code>signature(object = "Gammad")</code>: returns the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>scale&lt;-</dt><dd><p><code>signature(object = "Gammad")</code>: modifies the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>scale</dt><dd><p><code>signature(object = "LogisParameter")</code>: returns the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>scale&lt;-</dt><dd><p><code>signature(object = "LogisParameter")</code>: modifies the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>scale</dt><dd><p><code>signature(object = "Logis")</code>: returns the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>scale&lt;-</dt><dd><p><code>signature(object = "Logis")</code>: modifies the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>scale</dt><dd><p><code>signature(object = "WeibullParameter")</code>: returns the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>scale&lt;-</dt><dd><p><code>signature(object = "WeibullParameter")</code>: modifies the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>scale</dt><dd><p><code>signature(object = "Weibull")</code>: returns the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>scale&lt;-</dt><dd><p><code>signature(object = "Weibull")</code>: modifies the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>scale</dt><dd><p><code>signature(object = "CauchyParameter")</code>: returns the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>scale&lt;-</dt><dd><p><code>signature(object = "CauchyParameter")</code>: modifies the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>scale</dt><dd><p><code>signature(object = "Cauchy")</code>: returns the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>scale&lt;-</dt><dd><p><code>signature(object = "Cauchy")</code>: modifies the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>scale</dt><dd><p><code>signature(object = "Chisq")</code>:  if <code>ncp(object)</code> is 0, a Chi-squared distribution is also a Gamma distribution;
in this case, <code>scale</code> returns 2 else an error;</p>
</dd>
</dl>

<hr>
<h2 id='sd-methods'> Methods for Function sd in Package &lsquo;distr&rsquo; </h2><span id='topic+sd-methods'></span><span id='topic+sd+3C--methods'></span><span id='topic+sd'></span><span id='topic+sd+3C-'></span><span id='topic+sd+2CNormParameter-method'></span><span id='topic+sd+2CNorm-method'></span><span id='topic+sd+3C-+2CNormParameter-method'></span><span id='topic+sd+3C-+2CNorm-method'></span>

<h3>Description</h3>

<p>sd-methods</p>


<h3>Methods</h3>


<dl>
<dt>sd</dt><dd><p><code>signature(x = "Any")</code>: see <a href="stats.html#topic+sd">sd</a></p>
</dd>    
<dt>sd</dt><dd><p><code>signature(x = "NormParameter")</code>: returns the slot sd of the parameter of the distribution </p>
</dd>    
<dt>sd&lt;-</dt><dd><p><code>signature(object = "NormParameter")</code>: modifies the slot sd of the parameter of the distribution </p>
</dd>
<dt>sd</dt><dd><p><code>signature(x = "Norm")</code>: returns the slot sd of the parameter of the distribution </p>
</dd>
<dt>sd&lt;-</dt><dd><p><code>signature(object = "Norm")</code>: modifies the slot sd of the parameter of the distribution </p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="stats.html#topic+sd">sd</a></p>

<hr>
<h2 id='sdlog-methods'> Methods for Function sdlog in Package &lsquo;distr&rsquo; </h2><span id='topic+sdlog-methods'></span><span id='topic+sdlog+3C--methods'></span><span id='topic+sdlog'></span><span id='topic+sdlog+3C-'></span><span id='topic+sdlog+2CLnormParameter-method'></span><span id='topic+sdlog+2CLnorm-method'></span><span id='topic+sdlog+3C-+2CLnormParameter-method'></span><span id='topic+sdlog+3C-+2CLnorm-method'></span>

<h3>Description</h3>

<p>sdlog-methods</p>


<h3>Methods</h3>


<dl>
<dt>sdlog</dt><dd><p><code>signature(object = "LnormParameter")</code>: returns the slot <code>sdlog</code> of the parameter of the distribution </p>
</dd>
<dt>sdlog&lt;-</dt><dd><p><code>signature(object = "LnormParameter")</code>: modifies the slot <code>sdlog</code> of the parameter of the distribution </p>
</dd>
<dt>sdlog</dt><dd><p><code>signature(object = "Lnorm")</code>: returns the slot <code>sdlog</code> of the parameter of the distribution </p>
</dd>
<dt>sdlog&lt;-</dt><dd><p><code>signature(object = "Lnorm")</code>: modifies the slot <code>sdlog</code> of the parameter of the distribution </p>
</dd>
</dl>

<hr>
<h2 id='shape-methods'> Methods for Function shape in Package &lsquo;distr&rsquo; </h2><span id='topic+shape-methods'></span><span id='topic+shape+3C--methods'></span><span id='topic+shape'></span><span id='topic+shape+3C-'></span><span id='topic+shape+2CGammaParameter-method'></span><span id='topic+shape+2CGammad-method'></span><span id='topic+shape+2CChisq-method'></span><span id='topic+shape+2CExp-method'></span><span id='topic+shape+2CWeibullParameter-method'></span><span id='topic+shape+2CWeibull-method'></span><span id='topic+shape+3C-+2CGammaParameter-method'></span><span id='topic+shape+3C-+2CGammad-method'></span><span id='topic+shape+3C-+2CWeibullParameter-method'></span><span id='topic+shape+3C-+2CWeibull-method'></span>

<h3>Description</h3>

<p>shape-methods</p>


<h3>Methods</h3>


<dl>
<dt>shape</dt><dd><p><code>signature(object  = "GammaParameter")</code>: returns the slot <code>shape</code> of a parameter of a Gamma distribution </p>
</dd>
<dt>shape&lt;-</dt><dd><p><code>signature(object = "GammaParameter")</code>: modifies the slot <code>shape</code> of a parameter of a Gamma distribution </p>
</dd>
<dt>shape</dt><dd><p><code>signature(object = "Gammad")</code>: returns the slot <code>shape</code> of the parameter slot of a Gamma distribution </p>
</dd>
<dt>shape&lt;-</dt><dd><p><code>signature(object = "Gammad")</code>: modifies the slot shape of the parameter slot of a Gamma distribution </p>
</dd>
<dt>shape</dt><dd><p><code>signature(object  = "WeibullParameter")</code>: returns the slot <code>shape</code> of a parameter of a Weibull distribution </p>
</dd>
<dt>shape&lt;-</dt><dd><p><code>signature(object = "WeibullParameter")</code>: modifies the slot <code>shape</code> of a parameter of a Weibull distribution </p>
</dd>
<dt>shape</dt><dd><p><code>signature(object  = "Weibull")</code>: returns the slot <code>shape</code> of the parameter slot of the distribution </p>
</dd>
<dt>shape&lt;-</dt><dd><p><code>signature(object = "Weibull")</code>: modifies the slot <code>shape</code> of the parameter slot of the distribution </p>
</dd>
<dt>shape</dt><dd><p><code>signature(object = "Chisq")</code>: if <code>ncp(object)</code> is 0, a Chi-squared distribution is also a Gamma distribution;
in this case, <code>shape</code> returns <code>df(object)/2</code> else an error;</p>
</dd>
<dt>shape</dt><dd><p><code>signature(object  = "Exp")</code>: returns the slot <code>shape</code> of the parameter slot of the Exp distribution  (=1)</p>
</dd>
</dl>

<hr>
<h2 id='shape1-methods'> Methods for Function shape1 in Package &lsquo;distr&rsquo; </h2><span id='topic+shape1-methods'></span><span id='topic+shape1+3C--methods'></span><span id='topic+shape1'></span><span id='topic+shape1+3C-'></span><span id='topic+shape1+2CBetaParameter-method'></span><span id='topic+shape1+2CBeta-method'></span><span id='topic+shape1+3C-+2CBetaParameter-method'></span><span id='topic+shape1+3C-+2CBeta-method'></span>

<h3>Description</h3>

<p>shape-methods</p>


<h3>Methods</h3>


<dl>
<dt>shape1</dt><dd><p><code>signature(object = "BetaParameter")</code>: returns the slot <code>shape1</code> of the parameter of the distribution </p>
</dd>
<dt>shape1&lt;-</dt><dd><p><code>signature(object = "BetaParameter")</code>: modifies the slot <code>shape1</code> of the parameter of the distribution </p>
</dd>
<dt>shape1</dt><dd><p><code>signature(object = "Beta")</code>: returns the slot <code>shape1</code> of the parameter of the distribution </p>
</dd>
<dt>shape1&lt;-</dt><dd><p><code>signature(object = "Beta")</code>: modifies the slot <code>shape1</code> of the parameter of the distribution </p>
</dd>
</dl>

<hr>
<h2 id='shape2-methods'> Methods for Function shape2 in Package &lsquo;distr&rsquo; </h2><span id='topic+shape2-methods'></span><span id='topic+shape2+3C--methods'></span><span id='topic+shape2'></span><span id='topic+shape2+3C-'></span><span id='topic+shape2+2CBetaParameter-method'></span><span id='topic+shape2+2CBeta-method'></span><span id='topic+shape2+3C-+2CBetaParameter-method'></span><span id='topic+shape2+3C-+2CBeta-method'></span>

<h3>Description</h3>

<p>shape-methods</p>


<h3>Methods</h3>


<dl>
<dt>shape2</dt><dd><p><code>signature(object = "BetaParameter")</code>: returns the slot shape2 of the parameter of the distribution </p>
</dd>
<dt>shape2&lt;-</dt><dd><p><code>signature(object = "BetaParameter")</code>: modifies the slot shape2 of the parameter of the distribution </p>
</dd>
<dt>shape2</dt><dd><p><code>signature(object = "Beta")</code>: returns the slot shape2 of the parameter of the distribution </p>
</dd>
<dt>shape2&lt;-</dt><dd><p><code>signature(object = "Beta")</code>: modifies the slot shape2 of the parameter of the distribution </p>
</dd>
</dl>

<hr>
<h2 id='showobj-methods'>Helping Methods for Functions print/show in Package &lsquo;distr&rsquo; </h2><span id='topic+showobj'></span><span id='topic+showobj-methods'></span><span id='topic+showobj+2CUnivariateDistribution-method'></span><span id='topic+showobj+2CDistrList-method'></span><span id='topic+showobj+2CUnivarMixingDistribution-method'></span><span id='topic+showobj+2CUnivarLebDecDistribution-method'></span><span id='topic+showobj+2CCompoundDistribution-method'></span>

<h3>Description</h3>

<p>showobj-methods</p>


<h3>Usage</h3>

<pre><code class='language-R'>showobj(object, ...)
## S4 method for signature 'UnivariateDistribution'
showobj(object, className = class(object)[1])
## S4 method for signature 'CompoundDistribution'
showobj(object, className = class(object)[1])
## S4 method for signature 'DistrList'
showobj(object, className = class(object)[1])
## S4 method for signature 'UnivarMixingDistribution'
showobj(object, className = class(object)[1])
## S4 method for signature 'UnivarLebDecDistribution'
showobj(object, className = class(object)[1],
objs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showobj-methods_+3A_...">...</code></td>
<td>
<p>further parameters for <code>showobj</code>; not yet used.</p>
</td></tr>
<tr><td><code id="showobj-methods_+3A_object">object</code></td>
<td>
<p>distribution [list] object</p>
</td></tr>
<tr><td><code id="showobj-methods_+3A_classname">className</code></td>
<td>
<p>name of the class of the object</p>
</td></tr>
<tr><td><code id="showobj-methods_+3A_objs">objs</code></td>
<td>
<p>a character capturing the input from <code>show</code>, <code>print</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector, which is then shown by method <code>show</code>,
but can also be indented if necessary &mdash; like in the possibly nested 
list classes</p>


<h3>See Also</h3>

<p><code><a href="#topic+print-methods">print-methods</a></code></p>

<hr>
<h2 id='simplifyD-methods'>Methods for function simplifyD in Package &lsquo;distr&rsquo; </h2><span id='topic+simplifyD-methods'></span><span id='topic+simplifyD'></span><span id='topic+simplifyD+2CAbscontDistribution-method'></span><span id='topic+simplifyD+2CDiscreteDistribution-method'></span><span id='topic+simplifyD+2CUnivarLebDecDistribution-method'></span><span id='topic+simplifyD+2CUnivarMixingDistribution-method'></span>

<h3>Description</h3>

<p>simplifyD-methods</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplifyD(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplifyD-methods_+3A_object">object</code></td>
<td>
<p>distribution object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>generating functions <code><a href="#topic+UnivarMixingDistribution">UnivarMixingDistribution</a></code>
<code><a href="#topic+Minimum">Minimum</a></code>, <code>Maximum</code>, <code><a href="#topic+Truncate">Truncate</a></code>, and
<code><a href="#topic+Huberize">Huberize</a></code> have an argument  <code>withSimplify</code> which
decides whether the respective result is filtered by/piped through a 
call to <code>simplifyD</code>.
By default this argument is set to the distr-option 
<code>getdistrOption("simplifyD"</code> (for the inspection and modification of such
global options see <code><a href="#topic+distroptions">distroptions</a></code>). Depending on whether or not this 
option is <code>TRUE</code>, also arithmetic operations <code>"+"</code>, <code>"*"</code>, <code>"/"</code>,
<code>"^"</code> and group <code>Math</code> give results filtered by/piped through a call 
to <code>simplifyD</code>.</p>


<h3>Value</h3>

<p>the corresponding, possibly simplified distribution</p>


<h3>Methods</h3>


<dl>
<dt>simplifyD</dt><dd><p><code>signature(object = "AbscontDistribution")</code>: 
returns <code>object</code> unchanged</p>
</dd>
<dt>simplifyD</dt><dd><p><code>signature(object = "DiscreteDistribution")</code>: 
returns <code>object</code> unchanged</p>
</dd>
<dt>simplifyD</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code>: 
checks whether <code>acWeight</code> or <code>discreteWeight</code> is approximately
(i.e.; up to <code>getdistrOption("TruncQuantile")</code>) zero and if so,
accordingly returns <code>discretePart(object)</code> or <code>acPart(object)</code>,
respectively.</p>
</dd>
<dt>simplifyD</dt><dd><p><code>signature(object = "UnivarMixingDistribution")</code>: 
returns the flattened version of <code>object</code> (using <code><a href="#topic+flat.mix">flat.mix</a></code>).
before doing so, it checks whether any component carries weight  approximately
(i.e.; up to <code>getdistrOption("TruncQuantile")</code>) one (in slot <code>mixCoeff</code>) 
and if so, returns this component; else, if not all weights are below
<code>getdistrOption("TruncQuantile")</code>), it filters out those components
with weight less than <code>getdistrOption("TruncQuantile")</code>).
</p>
</dd></dl>


<h3>See Also</h3>

<p><code><a href="#topic+Huberize">Huberize</a></code>, <code><a href="#topic+Minimum">Minimum</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
Mix1 &lt;- UnivarMixingDistribution(Norm(),Binom(2,.3),
  UnivarLebDecDistribution(acPart = Chisq(df = 2), discretePart = Nbinom(3,.09),
                           acWeight = 0.3),
  Norm()-Chisq(df=3), mixCoeff=c(0,0,0.2,0.8), withSimplify = FALSE)
Mix2 &lt;- UnivarMixingDistribution(Norm(),Mix1, DExp(2),
        mixCoeff = c(0,0.2,0.8), withSimplify = FALSE)
Mix2        
simplifyD(Mix2)
</code></pre>

<hr>
<h2 id='simplifyr-methods'> Methods for Function simplifyr in Package &lsquo;distr&rsquo;</h2><span id='topic+simplifyr-methods'></span><span id='topic+simplifyr'></span><span id='topic+simplifyr+2CUnivariateDistribution-method'></span>

<h3>Description</h3>

<p>simplifyr-methods</p>


<h3>Methods</h3>


<dl>
<dt>simplifyr</dt><dd><p><code>signature(.Object = "UnivariateDistribution")</code>: After several transformations of a given distribution it may take quite 
a long time  to generate random numbers from the resulting distribution. simplifyr generates a certain number, 
by default <code class="reqn">10^5</code>, of random numbers once. This pool of random numbers forms the basis for further uses of the 
r-method. That is, random numbers are generated by sampling with replacement out of this pool. </p>
</dd>
</dl>


<h3>Note</h3>

<p> If you want to generate many random numbers, you should use simplifyr with a big size to be sure,
that your numbers are really random. </p>


<h3>See Also</h3>

<p><code><a href="#topic+Distribution-class">Distribution-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>F &lt;- ( Norm() + Binom() + Pois() + Exp() ) * 2 - 10
## IGNORE_RDIFF_BEGIN
system.time(r(F)(10^6))
## IGNORE_RDIFF_END
simplifyr(F, size = 10^6)
## IGNORE_RDIFF_BEGIN
system.time(r(F)(10^6))
## IGNORE_RDIFF_END
</code></pre>

<hr>
<h2 id='size-methods'> Methods for Function size in Package &lsquo;distr&rsquo; </h2><span id='topic+size-methods'></span><span id='topic+size+3C--methods'></span><span id='topic+size'></span><span id='topic+size+3C-'></span><span id='topic+size+2CBinomParameter-method'></span><span id='topic+size+2CBinom-method'></span><span id='topic+size+2CNbinomParameter-method'></span><span id='topic+size+2CNbinom-method'></span><span id='topic+size+2CGeom-method'></span><span id='topic+size+3C-+2CBinomParameter-method'></span><span id='topic+size+3C-+2CBinom-method'></span><span id='topic+size+3C-+2CNbinomParameter-method'></span><span id='topic+size+3C-+2CNbinom-method'></span><span id='topic+size+3C-+2CGeom-method'></span>

<h3>Description</h3>

<p>size-methods</p>


<h3>Methods</h3>


<dl>
<dt>size</dt><dd><p><code>signature(object  = "BinomParameter")</code>: returns the slot <code>size</code> of the parameter of the distribution </p>
</dd>
<dt>size&lt;-</dt><dd><p><code>signature(object = "BinomParameter")</code>: modifies the slot <code>size</code> of the parameter of the distribution </p>
</dd>
<dt>size</dt><dd><p><code>signature(object = "Binom")</code>: returns the slot <code>size</code> of the parameter of the distribution </p>
</dd>
<dt>size&lt;-</dt><dd><p><code>signature(object = "Binom")</code>: modifies the slot <code>size</code> of the parameter of the distribution </p>
</dd>
<dt>size</dt><dd><p><code>signature(object = "NbinomParameter")</code>: returns the slot <code>size</code> of the parameter of the distribution </p>
</dd>
<dt>size&lt;-</dt><dd><p><code>signature(object = "NbinomParameter")</code>: modifies the slot <code>size</code> of the parameter of the distribution </p>
</dd>
<dt>size</dt><dd><p><code>signature(object = "Nbinom")</code>: returns the slot <code>size</code> of the parameter of the distribution </p>
</dd>
<dt>size&lt;-</dt><dd><p><code>signature(object = "Nbinom")</code>: modifies the slot <code>size</code> of the parameter of the distribution </p>
</dd>
<dt>size</dt><dd><p><code>signature(object = "Geom")</code>: returns the slot <code>size</code> of the parameter of the distribution </p>
</dd>
</dl>

<hr>
<h2 id='solve-methods'> Methods for Function solve in Package &lsquo;distr&rsquo; </h2><span id='topic+solve-methods'></span><span id='topic+solve'></span><span id='topic+solve+2CANY+2CANY-method'></span><span id='topic+solve+2CPosSemDefSymmMatrix+2CANY-method'></span><span id='topic+solve+2CPosDefSymmMatrix+2CANY-method'></span><span id='topic+solve+2CANY-method'></span><span id='topic+solve+2CPosSemDefSymmMatrix-method'></span><span id='topic+solve+2CPosDefSymmMatrix-method'></span>

<h3>Description</h3>

<p>solve-methods using generalized inverses for various types of matrices</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve(a,b, ...)
## S4 method for signature 'ANY,ANY'
solve(a, b, generalized = 
getdistrOption("use.generalized.inverse.by.default"), tol = 1e-10)
## S4 method for signature 'PosSemDefSymmMatrix,ANY'
solve(a, b, generalized =
getdistrOption("use.generalized.inverse.by.default"), tol = 1e-10)
## S4 method for signature 'PosDefSymmMatrix,ANY'
solve(a, b, tol = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve-methods_+3A_a">a</code></td>
<td>
<p>matrix to be inverted / to be solved for RHS.</p>
</td></tr>
<tr><td><code id="solve-methods_+3A_b">b</code></td>
<td>
<p>a numeric or complex vector or matrix giving the right-hand
side(s) of the linear system.  If missing, <code>b</code> is taken to be
an identity matrix and <code>solve</code> will return the inverse of
<code>a</code>.</p>
</td></tr>
<tr><td><code id="solve-methods_+3A_...">...</code></td>
<td>
<p> further arguments to be passed to specific methods (see <code><a href="base.html#topic+solve">solve</a></code>).</p>
</td></tr>
<tr><td><code id="solve-methods_+3A_generalized">generalized</code></td>
<td>
<p> logical: should generalized / Moore-Penrose inverses be used? By default uses
the corresponding global option to be set by <code><a href="#topic+distroptions">distroptions</a></code>.</p>
</td></tr>
<tr><td><code id="solve-methods_+3A_tol">tol</code></td>
<td>
<p> the tolerance for detecting linear dependencies in the
columns of <code>a</code>.  Default is <code>.Machine$double.eps</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method for the Moore-Penrose inverse for 
<code>signature(a = "PosSemDefSymmMatrix", b = "ANY")</code> uses <code>eigen</code> to find the eigenvalue 
decomposition of <code>a</code> and then simply &quot;pseudo-inverts&quot; the corresponding diagonal matrix built from
<code>eigen(a)$values</code>, while for <code>signature(a = "ANY", b = "ANY")</code>  it uses the svd 
decomposition of <code>a</code> and then simply &quot;pseudo-inverts&quot; the corresponding diagonal matrix built from
<code>svd(a)$d</code>.</p>


<h3>Methods</h3>


<dl>
<dt>solve</dt><dd><p><code>signature(a = "ANY", b = "ANY")</code>: tries to evaluate <code>solve.default</code> method from <span class="pkg">base</span> in classical way;
if this gives an error, this one is returned if <code>generalized</code> is <code>TRUE</code>, else it will then
return <code class="reqn">a^-b</code> where <code class="reqn">a^-</code> is the pseudo or Moore-Penrose inverse of <code class="reqn">a</code>.</p>
</dd>
<dt>solve</dt><dd><p><code>signature(a = "PosSemDefSymmMatrix", b = "ANY")</code>: evaluates <code class="reqn">a^-b</code> where <code class="reqn">a^-</code> is the pseudo or Moore-Penrose
inverse of <code class="reqn">a</code>.</p>
</dd>
<dt>solve</dt><dd><p><code>signature(a = "PosDefSymmMatrix", b = "ANY")</code>: evaluates solve method from <span class="pkg">base</span> in classical way.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+solve">solve</a></code> for the default method, <code><a href="base.html#topic+eigen">eigen</a></code> and <code><a href="base.html#topic+svd">svd</a></code> 
for the pseudo inversion</p>

<hr>
<h2 id='SphericalSymmetry'>Generating function for SphericalSymmetry-class</h2><span id='topic+SphericalSymmetry'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"SphericalSymmetry"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>SphericalSymmetry(SymmCenter = 0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SphericalSymmetry_+3A_symmcenter">SymmCenter</code></td>
<td>
<p> numeric: center of symmetry </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"SphericalSymmetry"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+SphericalSymmetry-class">SphericalSymmetry-class</a></code>, <code><a href="#topic+DistributionSymmetry-class">DistributionSymmetry-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>SphericalSymmetry()

## The function is currently defined as
function(SymmCenter = 0){ 
    new("SphericalSymmetry", SymmCenter = SymmCenter) 
}
</code></pre>

<hr>
<h2 id='SphericalSymmetry-class'>Class for Spherical Symmetric Distributions</h2><span id='topic+SphericalSymmetry-class'></span>

<h3>Description</h3>

<p>Class for spherical symmetric distributions.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("SphericalSymmetry")</code>.
More frequently they are created via the generating function 
<code>SphericalSymmetry</code>. Spherical symmetry for instance leads to 
a simplification for the computation of optimally robust influence curves.
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
contains &ldquo;spherical symmetric distribution&rdquo; </p>
</dd>
<dt><code>SymmCenter</code></dt><dd><p>Object of class <code>"numeric"</code>:
center of symmetry </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"EllipticalSymmetry"</code>, directly.<br />
Class <code>"DistributionSymmetry"</code>, by class <code>"EllipticalSymmetry"</code>.<br />
Class <code>"Symmetry"</code>, by class <code>"EllipticalSymmetry"</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+SphericalSymmetry">SphericalSymmetry</a></code>, <code><a href="#topic+DistributionSymmetry-class">DistributionSymmetry-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("SphericalSymmetry")
</code></pre>

<hr>
<h2 id='sqrt-methods'> Methods for Function sqrt in Package &lsquo;distr&rsquo; </h2><span id='topic+sqrt-methods'></span><span id='topic+sqrt'></span><span id='topic+sqrt+2CPosSemDefSymmMatrix-method'></span>

<h3>Description</h3>

<p>sqrt-methods using generalized inverses for p.s.d. matrices</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PosSemDefSymmMatrix'
sqrt(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqrt-methods_+3A_x">x</code></td>
<td>
<p>a p.s.d. matrix (of class <code>PosSemDefSymmMatrix</code></p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>sqrt</dt><dd><p><code>signature(x = "PosSemDefSymmMatrix")</code>: produces a symmetric,
p.s.d. matrix <code class="reqn">y</code> such that  <code class="reqn">x = y^2</code>.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+solve">solve</a></code></p>

<hr>
<h2 id='standardMethods'>Utility to automatically generate accessor and replacement functions</h2><span id='topic+standardMethods'></span>

<h3>Description</h3>

<p>Creates definitions for accessor and replacement functions of an given class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardMethods(class, writetofile = FALSE, directory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardMethods_+3A_class">class</code></td>
<td>
<p>the class for which accessor and replacement functions
are to be produced, given as a string</p>
</td></tr>
<tr><td><code id="standardMethods_+3A_writetofile">writetofile</code></td>
<td>
<p>logical value, indicating wheter output is to be written to a file</p>
</td></tr>
<tr><td><code id="standardMethods_+3A_directory">directory</code></td>
<td>
<p>if writetofile = TRUE, the output is
written to a file in the given directory, the name of the file
starting with &quot;classname&quot; and ending with &quot;StandardMethods.txt&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no value is returned
</p>


<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho@web.de">statho@web.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>setClass("testclass", representation(a = "numeric", b = "character"))
standardMethods("testclass")
</code></pre>

<hr>
<h2 id='support-methods'>Methods for Function support in Package &lsquo;distr&rsquo;</h2><span id='topic+support-methods'></span><span id='topic+support'></span><span id='topic+support+2CDiscreteDistribution-method'></span>

<h3>Description</h3>

<p>support-methods</p>


<h3>Methods</h3>


<dl>
<dt>support</dt><dd><p><code>signature(object =
    "DiscreteDistribution")</code>: returns the support</p>
</dd>
</dl>

<hr>
<h2 id='Symmetry-class'>Class of Symmetries</h2><span id='topic+Symmetry-class'></span><span id='topic+show+2CSymmetry-method'></span><span id='topic+type'></span><span id='topic+type+2CSymmetry-method'></span><span id='topic+SymmCenter'></span><span id='topic+SymmCenter+2CSymmetry-method'></span>

<h3>Description</h3>

<p>Class of symmetries of various objects.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
discribes type of symmetry. </p>
</dd>
<dt><code>SymmCenter</code></dt><dd><p>Object of class <code>"ANY"</code>:
center of symmetry. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>type</dt><dd><p><code>signature(object = "Symmetry")</code>: 
accessor function for slot <code>type</code></p>
</dd>
<dt>SymmCenter</dt><dd><p><code>signature(object = "Symmetry")</code>: 
accessor function for slot <code>SymmCenter</code></p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Symmetry")</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+DistributionSymmetry-class">DistributionSymmetry-class</a></code>, <code><a href="#topic+OptionalNumeric-class">OptionalNumeric-class</a></code></p>

<hr>
<h2 id='Td-class'>Class &quot;Td&quot;</h2><span id='topic+Td-class'></span><span id='topic+Td'></span><span id='topic+initialize+2CTd-method'></span>

<h3>Description</h3>

<p>  The <code class="reqn">t</code> distribution with <code>df</code> <code class="reqn">= \nu</code> degrees of
freedom has density
</p>
<p style="text-align: center;"><code class="reqn">
    f(x) = \frac{\Gamma ((\nu+1)/2)}{\sqrt{\pi \nu} \Gamma (\nu/2)}
    (1 + x^2/\nu)^{-(\nu+1)/2}%
  </code>
</p>

<p>for all real <code class="reqn">x</code>.
It has mean <code class="reqn">0</code> (for <code class="reqn">\nu &gt; 1</code>) and
variance <code class="reqn">\frac{\nu}{\nu-2}</code> (for <code class="reqn">\nu &gt; 2</code>).
C.f. <code><a href="stats.html#topic+TDist">rt</a></code>   
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Td(df)</code>.
This object is a <code class="reqn">t</code> distribution.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>: The domain of this distribution has got dimension 1
and the name &quot;Real Space&quot;. </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"TParameter"</code>: the parameter of this distribution (df),
declared at its instantiation </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: generates random numbers (calls function <code>rt</code>)</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>: density function (calls function <code>dt</code>)</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>: cumulative function (calls function <code>pt</code>)</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>: inverse of the cumulative function (calls function <code>qt</code>)</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"AbscontDistribution"</code>, directly.<br />
Class <code>"UnivariateDistribution"</code>, by class <code>"AbscontDistribution"</code>.<br />
Class <code>"Distribution"</code>, by class <code>"AbscontDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "Td")</code>: initialize method </p>
</dd>
<dt>df</dt><dd><p><code>signature(object = "Td")</code>: returns the slot df of the parameter of the distribution </p>
</dd>
<dt>df&lt;-</dt><dd><p><code>signature(object = "Td")</code>: modifies the slot df of the parameter of the distribution </p>
</dd>
<dt>ncp</dt><dd><p><code>signature(object = "Td")</code>: returns the slot ncp of the parameter of the distribution </p>
</dd>
<dt>ncp&lt;-</dt><dd><p><code>signature(object = "Td")</code>: modifies the slot ncp of the parameter of the distribution </p>
</dd>
</dl>



<h3>Ad hoc methods</h3>

<p>For R Version <code>&lt;2.3.0</code> ad hoc methods are provided for slots <code>q</code>, <code>r</code> if <code>ncp!=0</code>;
for R Version <code>&gt;=2.3.0</code> the methods from package <span class="pkg">stats</span> are used.
</p>


<h3>Note</h3>

<p>  The general <em>non-central</em> <code class="reqn">t</code>
with parameters <code class="reqn">(\nu,\delta)</code> <code>= (df, ncp)</code>
is defined as a the distribution of
<code class="reqn">T_{\nu}(\delta) := \frac{U + \delta}{\chi_{\nu}/\sqrt{\nu}}</code>
where <code class="reqn">U</code> and <code class="reqn">\chi_{\nu}</code>  are independent random
variables, <code class="reqn">U \sim {\cal N}(0,1)</code>, and
<code class="reqn">\chi^2_\nu</code>
is chi-squared, see <code><a href="stats.html#topic+Chisquare">rchisq</a></code>.
</p>
<p>The most used applications are power calculations for <code class="reqn">t</code>-tests:<br />
Let <code class="reqn">T= \frac{\bar{X} - \mu_0}{S/\sqrt{n}}</code>
where
<code class="reqn">\bar{X}</code> is the <code><a href="#topic+mean">mean</a></code> and <code class="reqn">S</code> the sample standard
deviation (<code><a href="#topic+sd">sd</a></code>) of <code class="reqn">X_1,X_2,\dots,X_n</code> which are i.i.d.
<code class="reqn">       N(\mu,\sigma^2)</code>.
Then <code class="reqn">T</code> is distributed as non-centrally <code class="reqn">t</code> with
<code>df</code><code class="reqn">= n-1</code>
degrees of freedom and <b>n</b>on-<b>c</b>entrality <b>p</b>arameter
<code>ncp</code><code class="reqn">= (\mu - \mu_0) \sqrt{n}/\sigma</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+TParameter-class">TParameter-class</a></code>, 
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>, 
<code><a href="#topic+Reals-class">Reals-class</a></code>, 
<code><a href="stats.html#topic+TDist">rt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- Td(df = 1) # T is a t distribution with df = 1.
r(T)(1) # one random number generated from this distribution, e.g. -0.09697573
d(T)(1) # Density of this distribution is 0.1591549 for x = 1.
p(T)(1) # Probability that x &lt; 1 is 0.75.
q(T)(.1) # Probability that x &lt; -3.077684 is 0.1.
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
df(T) # df of this distribution is 1.
df(T) &lt;- 2 # df of this distribution is now 2.
Tn &lt;- Td(df = 1, ncp = 5) 
  # T is a noncentral t distribution with df = 1 and ncp = 5.
d(Tn)(1) ## from R 2.3.0 on ncp no longer ignored...
</code></pre>

<hr>
<h2 id='TParameter-class'>Class &quot;TParameter&quot;</h2><span id='topic+TParameter-class'></span><span id='topic+initialize+2CTParameter-method'></span>

<h3>Description</h3>

<p> The parameter of a t distribution, used by Td-class</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("TParameter", df, ncp)</code>.
Usually an object of this class is not needed on its own, it is generated automatically when an object of the class
<code>Td</code> is instantiated. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>df</code></dt><dd><p>Object of class <code>"numeric"</code>: the degrees of freedom of a T distribution </p>
</dd>
<dt><code>ncp</code></dt><dd><p>Object of class <code>"numeric"</code>: the noncentrality parameter of a T distribution </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: a name / comment for the parameters </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "TParameter")</code>: initialize method </p>
</dd>
<dt>df</dt><dd><p><code>signature(object = "TParameter")</code>: returns the slot <code>df</code> of the parameter of the distribution </p>
</dd>
<dt>df&lt;-</dt><dd><p><code>signature(object = "TParameter")</code>: modifies the slot <code>df</code> of the parameter of the distribution </p>
</dd>
<dt>ncp</dt><dd><p><code>signature(object = "TParameter")</code>: returns the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
<dt>ncp&lt;-</dt><dd><p><code>signature(object = "TParameter")</code>: modifies the slot <code>ncp</code> of the parameter of the distribution </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Td-class">Td-class</a></code>
<code><a href="#topic+Parameter-class">Parameter-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- new("TParameter",df=1, ncp = 0)
df(W) # df of this distribution is 1.
df(W) &lt;- 2 # df of this distribution is now 2.
</code></pre>

<hr>
<h2 id='Truncate-methods'> Methods for function Truncate in Package &lsquo;distr&rsquo; </h2><span id='topic+Truncate-methods'></span><span id='topic+Truncate'></span><span id='topic+Truncate+2CAbscontDistribution-method'></span><span id='topic+Truncate+2CDiscreteDistribution-method'></span><span id='topic+Truncate+2CLatticeDistribution-method'></span><span id='topic+Truncate+2CUnivarLebDecDistribution-method'></span>

<h3>Description</h3>

<p>Truncate-methods</p>


<h3>Usage</h3>

<pre><code class='language-R'>Truncate(object, ...)
## S4 method for signature 'AbscontDistribution'
Truncate(object, lower = -Inf, upper = Inf)
## S4 method for signature 'DiscreteDistribution'
Truncate(object, lower= -Inf, upper = Inf)
## S4 method for signature 'LatticeDistribution'
Truncate(object, lower= -Inf, upper = Inf)
## S4 method for signature 'UnivarLebDecDistribution'
Truncate(object, lower = -Inf, upper = Inf, 
                    withSimplify = getdistrOption("simplifyD"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Truncate-methods_+3A_object">object</code></td>
<td>
<p>distribution object</p>
</td></tr>
<tr><td><code id="Truncate-methods_+3A_...">...</code></td>
<td>
<p>not yet used; takes up <code>lower</code>, 
<code>upper</code>, <code>withSimplify</code>.</p>
</td></tr>
<tr><td><code id="Truncate-methods_+3A_lower">lower</code></td>
<td>
<p>numeric; lower truncation point</p>
</td></tr>
<tr><td><code id="Truncate-methods_+3A_upper">upper</code></td>
<td>
<p>numeric; upper truncation point</p>
</td></tr>
<tr><td><code id="Truncate-methods_+3A_withsimplify">withSimplify</code></td>
<td>
<p>logical; is result to be piped through a call to 
<code><a href="#topic+simplifyD">simplifyD</a></code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the corresponding distribution of the truncated random variable</p>


<h3>Methods</h3>


<dl>
<dt>Truncate</dt><dd><p><code>signature(object = "AbscontDistribution")</code>: 
returns the distribution of <code>min(upper,max(X,lower))</code>
conditioned to <code>lower&lt;=X&lt;=upper</code>, if <code>X</code> is 
distributed according to <code>object</code>;
if slot <code>.logExact</code> of argument <code>object</code> is <code>TRUE</code> 
and if either there is only one-sided truncation or both truncation
points lie on the same side of the median, we use this representation
to enhance the range of applicability, in particular, for slot <code>r</code>,
we profit from Peter Dalgaard's clever log-tricks as indicated in 
<a href="https://stat.ethz.ch/pipermail/r-help/2008-September/174321.html">https://stat.ethz.ch/pipermail/r-help/2008-September/174321.html</a>. To this
end we use the internal functions
(i.e.; non exported to namespace) <code><a href="#topic+.trunc.up">.trunc.up</a></code> and
<code><a href="#topic+.trunc.low">.trunc.low</a></code> which provide functional slots <code>r,d,p,q</code> for 
one-sided truncation. In case of two sided truncation, we simply use one-sided
truncation successively &mdash; first left and then right in case we are right of
the median, and the other way round else;
the result is again of class <code>"AbscontDistribution"</code>;
</p>
</dd>
<dt>Truncate</dt><dd><p><code>signature(object = "DiscreteDistribution")</code>: 
returns the distribution of <code>min(upper,max(X,lower))</code>
conditioned to <code>lower&lt;=X&lt;=upper</code>, if <code>X</code> is 
distributed according to <code>object</code>;
the result is again of class <code>"DiscreteDistribution"</code></p>
</dd>
<dt>Truncate</dt><dd><p><code>signature(object = "LatticeDistribution")</code>: 
if length of the corresp. <code>lattice</code> is infinite  and 
slot <code>.logExact</code> of argument <code>object</code> is <code>TRUE</code>, 
we proceed similarly as in case of <code>AbscontDistribution</code>, also 
using internal functions <code><a href="#topic+.trunc.up">.trunc.up</a></code> and <code><a href="#topic+.trunc.low">.trunc.low</a></code>; 
else we use the corresponding <code>"DiscreteDistribution"</code> method;
the result is again of class <code>"LatticeDistribution"</code></p>
</dd>
<dt>Truncate</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code>: 
returns the distribution of <code>min(upper,max(X,lower))</code>
conditioned to <code>lower&lt;=X&lt;=upper</code>, if <code>X</code> is 
distributed according to <code>object</code>;
the result is again of class <code>"UnivarLebDecDistribution"</code></p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+Huberize">Huberize</a></code>, <code><a href="#topic+Minimum">Minimum</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(Truncate(Norm(),lower=-1,upper=2))
TN &lt;- Truncate(Norm(),lower=15,upper=15.7) ### remarkably right!
plot(TN)
r(TN)(30)
TNG &lt;- Truncate(Geom(prob=0.05),lower=325,upper=329) ### remarkably right!
plot(TNG)
</code></pre>

<hr>
<h2 id='Unif-class'>Class &quot;Unif&quot;</h2><span id='topic+Unif-class'></span><span id='topic+Unif'></span><span id='topic+initialize+2CUnif-method'></span>

<h3>Description</h3>

 
<p>The uniform distribution has density
</p>
<p style="text-align: center;"><code class="reqn">d(x) = \frac{1}{max-min}</code>
</p>

<p>for <code class="reqn">min</code>, by default <code class="reqn">=0</code>, <code class="reqn">\le x \le max</code>, by default <code class="reqn">=1</code>.
C.f. <code><a href="stats.html#topic+Uniform">runif</a></code> 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Unif(Min, Max)</code>.
This object is a uniform distribution.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>: The space of the image of this distribution has got dimension 1
and the name &quot;Real Space&quot;. </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"UnifParameter"</code>: the parameter of this distribution (Min and Max),
declared at its instantiation </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: generates random numbers (calls function <code>runif</code>)</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>: density function (calls function <code>dunif</code>)</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>: cumulative function (calls function <code>punif</code>)</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>: inverse of the cumulative function (calls function <code>qunif</code>)</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"AbscontDistribution"</code>, directly.<br />
Class <code>"UnivariateDistribution"</code>, by class <code>"AbscontDistribution"</code>.<br />
Class <code>"Distribution"</code>, by class <code>"AbscontDistribution"</code>.
</p>


<h3>Is-Relations</h3>

<p>By means of <code>setIs</code>, R &ldquo;knows&rdquo; that a distribution object <code>obj</code> of class <code>"Unif"</code> with Min 0 and Max 1 also is
a Beta distribution with parameters <code>shape1 = 1, shape2 = 1, ncp = 0</code>. 
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "Unif")</code>: initialize method </p>
</dd>
<dt>Min</dt><dd><p><code>signature(object = "Unif")</code>: returns the slot <code>Min</code> of the parameter of the distribution </p>
</dd>
<dt>Min&lt;-</dt><dd><p><code>signature(object = "Unif")</code>: modifies the slot <code>Min</code> of the parameter of the distribution </p>
</dd>
<dt>Max</dt><dd><p><code>signature(object = "Unif")</code>: returns the slot <code>Max</code> of the parameter of the distribution </p>
</dd>
<dt>Max&lt;-</dt><dd><p><code>signature(object = "Unif")</code>: modifies the slot <code>Max</code> of the parameter of the distribution </p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "Unif", e2 = "numeric")</code>: multiplication of this uniform distribution
by an object of class &lsquo;numeric&rsquo;</p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "Unif", e2 = "numeric")</code>: addition of this uniform distribution
to an object of class &lsquo;numeric&rsquo;</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+UnifParameter-class">UnifParameter-class</a></code>
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>
<code><a href="#topic+Reals-class">Reals-class</a></code>
<code><a href="stats.html#topic+Uniform">runif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>U &lt;- Unif(Min=0,Max=2) # U is a uniform distribution with Min=0 and Max=2.
r(U)(1) # one random number generated from this distribution, e.g. 1.984357
d(U)(1) # Density of this distribution is 0.5 for x=1.
p(U)(1) # Probability that x&lt;1 is 0.5.
q(U)(.1) # Probability that x&lt;0.2 is 0.1.
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
Min(U) # Min of this distribution is 0.
Min(U) &lt;- 1 # Min of this distribution is now 1.
Min(U) # Min of this distribution is 1.
Min(U) &lt;- 0
is(U/2,"Beta") # yes
V &lt;- U/2; as(V,"Beta")
</code></pre>

<hr>
<h2 id='UnifParameter-class'>Class &quot;UnifParameter&quot;</h2><span id='topic+UnifParameter-class'></span><span id='topic+initialize+2CUnifParameter-method'></span>

<h3>Description</h3>

<p> The parameter of a uniform distribution, used by Unif-class</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("UnifParameter", Max, Min)</code>.
Usually an object of this class is not needed on its own, it is generated automatically when an object of the class 
<code>Unif</code> is instantiated. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>Max</code></dt><dd><p>Object of class <code>"numeric"</code>: the Max of a uniform distribution </p>
</dd>
<dt><code>Min</code></dt><dd><p>Object of class <code>"numeric"</code>: the Min of a uniform distribution </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: a name / comment for the parameters </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "UnifParameter")</code>: initialize method </p>
</dd>
<dt>Min</dt><dd><p><code>signature(object = "UnifParameter")</code>: returns the slot <code>Min</code> of the parameter of the distribution </p>
</dd>
<dt>Min&lt;-</dt><dd><p><code>signature(object = "UnifParameter")</code>: modifies the slot <code>Min</code> of the parameter of the distribution </p>
</dd>
<dt>Max</dt><dd><p><code>signature(object = "UnifParameter")</code>: returns the slot <code>Max</code> of the parameter of the distribution </p>
</dd>
<dt>Max&lt;-</dt><dd><p><code>signature(object = "UnifParameter")</code>: modifies the slot <code>Max</code> of the parameter of the distribution </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Unif-class">Unif-class</a></code>
<code><a href="#topic+Parameter-class">Parameter-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- new("UnifParameter",Min=0,Max=1)
Max(W) # Max of this distribution is 1.
Max(W) &lt;- 2 # Max of this distribution is now 2.
</code></pre>

<hr>
<h2 id='UniNormParameter-class'>Class &quot;UniNormParameter&quot;</h2><span id='topic+UniNormParameter-class'></span><span id='topic+initialize+2CUniNormParameter-method'></span>

<h3>Description</h3>

<p> The parameter of a univariate normal distribution, used by Norm-class</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("NormParameter", sd, mean)</code>.
Usually an object of this class is not needed on its own, it is
generated automatically when an object of the class Norm is
instantiated. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>sd</code></dt><dd><p>Object of class <code>"numeric"</code>:
the sd of a univariate normal distribution</p>
</dd>
<dt><code>mean</code></dt><dd><p>Object of class <code>"numeric"</code>:
the mean of a univariate normal distribution</p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>:
a name / comment for the parameters</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"NormParameter"</code>, directly.
Class <code>"Parameter"</code>, by class <code>"NormParameter"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "UniNormParameter")</code>:
initialize method</p>
</dd>
<dt>mean</dt><dd><p><code>signature(object = "UniNormParameter")</code>:
returns the slot mean of the parameter of the distribution</p>
</dd>
<dt>mean&lt;-</dt><dd><p><code>signature(object = "UniNormParameter")</code>:
modifies the slot mean of the parameter of the distribution</p>
</dd>
<dt>sd</dt><dd><p><code>signature(object = "UniNormParameter")</code>:
returns the slot sd of the parameter of the distribution</p>
</dd>
<dt>sd&lt;-</dt><dd><p><code>signature(object = "UniNormParameter")</code>:
modifies the slot sd of the parameter of the distribution</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br />
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Norm-class">Norm-class</a></code>
<code><a href="#topic+NormParameter-class">NormParameter-class</a></code>
<code><a href="#topic+Parameter-class">Parameter-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- new("UniNormParameter", mean = 0, sd = 1)
sd(W) # sd of this distribution is 1
sd(W) &lt;- 2 # sd of this distribution is now 2
</code></pre>

<hr>
<h2 id='UnivarDistrList'>Generating function for UnivarDistrList-class</h2><span id='topic+UnivarDistrList'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"UnivarDistrList"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>UnivarDistrList(..., Dlist)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnivarDistrList_+3A_...">...</code></td>
<td>
<p>Objects of class <code>"UnivariateDistribution"</code> (or subclasses)</p>
</td></tr>
<tr><td><code id="UnivarDistrList_+3A_dlist">Dlist</code></td>
<td>
<p>an optional list or object of class <code>"UnivarDistrList"</code>;
if not missing it is appended to argument <code>...</code>; this way
<code>UnivarMixingDistribution</code> may also be called with a list (or
<code>"UnivarDistrList"</code>-object) as argument as suggested in an e-mail
by Krunoslav Sever (thank you!)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"UnivarDistrList"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+DistrList-class">DistrList-class</a></code>, <code><a href="#topic+UnivarDistrList-class">UnivarDistrList-class</a></code>,
<code><a href="#topic+UnivarDistrList">UnivarDistrList</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(DL &lt;- UnivarDistrList(Norm(), Exp(), Pois()))
plot(DL)
as(Norm(), "UnivarDistrList")

## The function is currently defined as
function(...){ 
    new("UnivarDistrList", list(...)) 
}
</code></pre>

<hr>
<h2 id='UnivarDistrList-class'>List of univariate distributions</h2><span id='topic+UnivarDistrList-class'></span><span id='topic+coerce+2CUnivariateDistribution+2CUnivarDistrList-method'></span>

<h3>Description</h3>

<p>Create a list of univariate distributions</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("UnivarDistrList", ...)</code>.
More frequently they are created via the generating function 
<code><a href="#topic+DistrList">DistrList</a></code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p>Object of class <code>"list"</code>. 
A list of univariate distributions.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"DistrList"</code>, directly.<br />
Class <code>"list"</code>, by class <code>"DistrList"</code>.<br />
Class <code>"vector"</code>, by class <code>"DistrList"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "UnivariateDistribution", to = "UnivarDistrList")</code>:
create a <code>UnivarDistrList</code> object from a univariate distribution</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+UnivarDistrList">UnivarDistrList</a></code>, <code><a href="#topic+DistrList-class">DistrList-class</a></code>,
<code><a href="#topic+UnivariateDistribution-class">UnivariateDistribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(DL &lt;- new("UnivarDistrList", list(Norm(), Exp())))
plot(DL)
as(Norm(), "UnivarDistrList")
</code></pre>

<hr>
<h2 id='UnivariateDistribution-class'>Class &quot;UnivariateDistribution&quot;</h2><span id='topic+UnivariateDistribution-class'></span><span id='topic+initialize+2CUnivariateDistribution-method'></span>

<h3>Description</h3>

<p>The UnivariateDistribution-class is the mother-class of the classes
AbscontDistribution and DiscreteDistribution.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("UnivariateDistribution")</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>:
the space of the image of this distribution which has dimension 1
and the name &quot;Real Space&quot;</p>
</dd> 
<dt><code>param</code></dt><dd><p>Object of class <code>"Parameter"</code>:
the parameter of this distribution</p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>:
generates random numbers</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>:
density function</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>:
cumulative distribution function</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>:
quantile function</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Distribution"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "UnivariateDistribution")</code>:
</p>
<p>initialize method </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "UnivariateDistribution")</code>:
</p>
<p>returns the dimension of the support of the distribution</p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "UnivariateDistribution")</code>:
</p>
<p>application of &lsquo;-&rsquo; to this univariate distribution</p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "UnivariateDistribution", e2 = "numeric")</code>:
</p>
<p>multiplication of this univariate distribution by an object of
class &lsquo;numeric&rsquo;</p>
</dd> 
<dt>/</dt><dd><p><code>signature(e1 = "UnivariateDistribution", e2 = "numeric")</code>:
</p>
<p>division of this univariate distribution by an object of class &lsquo;numeric&rsquo;</p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "UnivariateDistribution", e2 = "numeric")</code>:
</p>
<p>addition of this univariate distribution to an object of class
&lsquo;numeric&rsquo;</p>
</dd> 
<dt>-</dt><dd><p><code>signature(e1 = "UnivariateDistribution", e2 = "numeric")</code>:
</p>
<p>subtraction of an object of class &lsquo;numeric&rsquo; from this univariate
distribution</p>
</dd> 
<dt>*</dt><dd><p><code>signature(e1 = "numeric", e2 = "UnivariateDistribution")</code>:
</p>
<p>multiplication of this univariate distribution by an object of
class &lsquo;numeric&rsquo;</p>
</dd> 
<dt>+</dt><dd><p><code>signature(e1 = "numeric", e2 = "UnivariateDistribution")</code>:
</p>
<p>addition of this univariate distribution to an object of class
&lsquo;numeric&rsquo;</p>
</dd> 
<dt>-</dt><dd><p><code>signature(e1 = "numeric", e2 = "UnivariateDistribution")</code>:
</p>
<p>subtraction of this univariate distribution from an object of
class &lsquo;numeric&rsquo;</p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "UnivariateDistribution", e2 = "UnivariateDistribution")</code>:
</p>
<p>Convolution of two univariate distributions. The slots p, d and q
are approximated by grids.</p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "UnivariateDistribution", e2 = "UnivariateDistribution")</code>:
</p>
<p>Convolution of two univariate distributions. The slots p, d and q
are approximated by grids.</p>
</dd>
<dt>simplifyr</dt><dd><p><code>signature(object = "UnivariateDistribution")</code>:
</p>
<p>simplifies the r-method of a distribution, see there for further information</p>
</dd>
<dt>print</dt><dd><p><code>signature(object = "UnivariateDistribution")</code>:
</p>
<p>returns the class of the object and its parameters</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "UnivariateDistribution")</code>:
as print</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br />
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Parameter-class">Parameter-class</a></code>
<code><a href="#topic+Distribution-class">Distribution-class</a></code>
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code> <br />
<code><a href="#topic+DiscreteDistribution-class">DiscreteDistribution-class</a></code> 
<code><a href="#topic+Reals-class">Reals-class</a></code> 
<code><a href="#topic+RtoDPQ">RtoDPQ</a></code>
<code><a href="#topic+simplifyr-methods">simplifyr-methods</a></code>
</p>

<hr>
<h2 id='UnivarLebDecDistribution'>Generating function for Class &quot;UnivarLebDecDistribution&quot;</h2><span id='topic+UnivarLebDecDistribution'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"UnivarLebDecDistribution"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>UnivarLebDecDistribution(acPart, discretePart, acWeight, discreteWeight,
                                     r = NULL, e = NULL, n = NULL, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnivarLebDecDistribution_+3A_acpart">acPart</code></td>
<td>
<p>Object of class <code>"AbscontDistribution"</code> (or subclasses); 
a.c. part of the distribution</p>
</td></tr>
<tr><td><code id="UnivarLebDecDistribution_+3A_discretepart">discretePart</code></td>
<td>
<p>Object of class <code>"AbscontDistribution"</code> (or subclasses);
discrete part of the distribution</p>
</td></tr>
<tr><td><code id="UnivarLebDecDistribution_+3A_acweight">acWeight</code></td>
<td>
<p>Object of class <code>"numeric"</code>; weight of the a.c. part of 
the distribution</p>
</td></tr>
<tr><td><code id="UnivarLebDecDistribution_+3A_discreteweight">discreteWeight</code></td>
<td>
<p>Object of class <code>"numeric"</code>; weight of the discrete 
part of the distribution</p>
</td></tr>
<tr><td><code id="UnivarLebDecDistribution_+3A_r">r</code></td>
<td>
<p>optional argument; if given, this is a random number generator as function
<code>r &lt;- function(n){....}</code> to produce r.v.'s distributed 
according to the distribution; used in a call to <code><a href="#topic+RtoDPQ.LC">RtoDPQ.LC</a></code>
if  <code>acPart</code> and <code>discretePart</code> are missing.</p>
</td></tr>
<tr><td><code id="UnivarLebDecDistribution_+3A_e">e</code></td>
<td>
<p>optional argument; if argument <code>r</code> is given, this is the number
of r.v.'s drawn to fill the empty slots of this object; if missing filled
with <code>getdistrOption("RtoDPQ.e")</code>.</p>
</td></tr>
<tr><td><code id="UnivarLebDecDistribution_+3A_n">n</code></td>
<td>
<p>optional argument; if argument <code>r</code> is given, this is the number
gridpoints used in filling the empty p,d,q slots of this object; if missing filled
with <code>getdistrOption("DefaultNrGridPoints")</code>.</p>
</td></tr>
<tr><td><code id="UnivarLebDecDistribution_+3A_y">y</code></td>
<td>
<p>a (numeric) vector or <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>At least one of arguments <code>discretePart</code>, <code>acPart</code>, or <code>r</code>
must be given; if the first two are missing, slots are filled by a call
to <code>RtoDPQ.LC</code>. For this purpose argument <code>r</code> is used together
with arguments <code>e</code> and <code>n</code>. If the latter are missing they are
filled with <code>getdistrOption("RtoDPQ.e")</code> and 
<code>getdistrOption("DefaultNrGridPoints")</code>, respectively.
For the a.c. part, similarly to <code><a href="#topic+RtoDPQ">RtoDPQ</a></code> we have an optional 
parameter <code>y</code> for using N. Horbenko's quantile trick: i.e.; on an 
equally spaced grid <code>x.grid</code> on [0,1], apply 
<code>f(q(x)(x.grid))</code>, write the result to <code>y</code> and use these
values instead of simulated ones.
</p>
<p>If argument <code>discretePart</code> is missing but  <code>acPart</code> is not,
<code>discreteWeight</code> is set to 0 and <code>discretePart</code> is set to <code>Dirac(0)</code>.
If argument   <code>acPart</code>  is missing but <code>discretePart</code> is not,
<code>acWeight</code> is set to 0 and <code>discretePart</code> is set to <code>Norm()</code>.
If both arguments   <code>acPart</code> and <code>discretePart</code> are given,
at least one of arguments <code>discreteWeight</code> and <code>acWeight</code> must
be given and lie in [0,1], else an error is thrown.
If only one argument <code>acWeight</code> or <code>discreteWeight</code> is given
the other one is gotten as 1-[ac/discrete]Weight.
Else if both are given, they must sum up to 1.
If a weight is smaller than <code>getdistrOption("TruncQuantile")</code>, it 
is set to 0.
</p>


<h3>Value</h3>

<p>Object of class <code>"UnivarLebDecDistribution"</code>.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+UnivarLebDecDistribution-class">UnivarLebDecDistribution-class</a></code>,
<code><a href="#topic+simplifyD">simplifyD</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>mylist &lt;- UnivarLebDecDistribution(discretePart=Binom(3,.3), acPart=Norm(2,2),
          acWeight=11/20)
mylist          
</code></pre>

<hr>
<h2 id='UnivarLebDecDistribution-class'>Class &quot;UnivarLebDecDistribution&quot;</h2><span id='topic+UnivarLebDecDistribution-class'></span><span id='topic+AffLinUnivarLebDecDistribution-class'></span><span id='topic+AcDcLcDistribution-class'></span><span id='topic+acPart'></span><span id='topic+discretePart'></span><span id='topic+acPart+3C-'></span><span id='topic+discretePart+3C-'></span><span id='topic+acPart-methods'></span><span id='topic+discretePart-methods'></span><span id='topic+acPart+3C--methods'></span><span id='topic+discretePart+3C--methods'></span><span id='topic+acPart+2CUnivarLebDecDistribution-method'></span><span id='topic+discretePart+2CUnivarLebDecDistribution-method'></span><span id='topic+acPart+3C-+2CUnivarLebDecDistribution-method'></span><span id='topic+discretePart+3C-+2CUnivarLebDecDistribution-method'></span><span id='topic+acWeight'></span><span id='topic+discreteWeight'></span><span id='topic+acWeight+3C-'></span><span id='topic+discreteWeight+3C-'></span><span id='topic+acWeight-methods'></span><span id='topic+discreteWeight-methods'></span><span id='topic+acWeight+3C--methods'></span><span id='topic+discreteWeight+3C--methods'></span><span id='topic+acWeight+2CUnivarLebDecDistribution-method'></span><span id='topic+discreteWeight+2CUnivarLebDecDistribution-method'></span><span id='topic+acWeight+3C-+2CUnivarLebDecDistribution-method'></span><span id='topic+discreteWeight+3C-+2CUnivarLebDecDistribution-method'></span><span id='topic+p.discrete+2CUnivarLebDecDistribution-method'></span><span id='topic+d.discrete+2CUnivarLebDecDistribution-method'></span><span id='topic+q.discrete+2CUnivarLebDecDistribution-method'></span><span id='topic+r.discrete+2CUnivarLebDecDistribution-method'></span><span id='topic+p.ac+2CUnivarLebDecDistribution-method'></span><span id='topic+d.ac+2CUnivarLebDecDistribution-method'></span><span id='topic+q.ac+2CUnivarLebDecDistribution-method'></span><span id='topic+r.ac+2CUnivarLebDecDistribution-method'></span><span id='topic+p.discrete-methods'></span><span id='topic+d.discrete-methods'></span><span id='topic+q.discrete-methods'></span><span id='topic+r.discrete-methods'></span><span id='topic+p.ac-methods'></span><span id='topic+d.ac-methods'></span><span id='topic+q.ac-methods'></span><span id='topic+r.ac-methods'></span><span id='topic+p.discrete'></span><span id='topic+d.discrete'></span><span id='topic+q.discrete'></span><span id='topic+r.discrete'></span><span id='topic+p.ac'></span><span id='topic+d.ac'></span><span id='topic+q.ac'></span><span id='topic+r.ac'></span><span id='topic+coerce+2CAbscontDistribution+2CUnivarLebDecDistribution-method'></span><span id='topic+coerce+2CDiscreteDistribution+2CUnivarLebDecDistribution-method'></span><span id='topic+coerce+2CAffLinUnivarLebDecDistribution+2CUnivarLebDecDistribution-method'></span><span id='topic+abs+2CUnivarLebDecDistribution-method'></span><span id='topic+log+2CUnivarLebDecDistribution-method'></span><span id='topic+log10+2CUnivarLebDecDistribution-method'></span><span id='topic+Math+2CUnivarLebDecDistribution-method'></span><span id='topic++5E+2CAcDcLcDistribution+2CDirac-method'></span><span id='topic+exp+2CUnivarLebDecDistribution-method'></span><span id='topic+sign+2CUnivarLebDecDistribution-method'></span><span id='topic+sign+2CAcDcLcDistribution-method'></span><span id='topic+sqrt+2CUnivarLebDecDistribution-method'></span><span id='topic+sqrt+2CAcDcLcDistribution-method'></span>

<h3>Description</h3>

<p><code>UnivarLebDecDistribution</code>-class is a class to formalize
a Lebesgue decomposed distribution with a discrete and an
absolutely continuous part; it is a subclass to
class <code>UnivarMixingDistribution</code>.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("UnivarLebDecDistribution", ...)</code>.
More frequently they are created via the generating function
<code><a href="#topic+UnivarLebDecDistribution">UnivarLebDecDistribution</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mixCoeff</code></dt><dd><p>Object of class <code>"numeric"</code>: a vector of length
2 of probabilities for the respective a.c. and discrete part of
the object</p>
</dd>
<dt><code>mixDistr</code></dt><dd><p>Object of class <code>"UnivarDistrList"</code>: a list of
univariate distributions containing the a.c. and discrete components; must be of
length 2; the first component must be of class <code>"AbscontDistribution"</code>,
the second of class <code>"DiscreteDistribution"</code>.</p>
</dd>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>: the space of the image of this distribution which has dimension 1
and the name &quot;Real Space&quot; </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"Parameter"</code>: the parameter of this distribution, having only the
slot name &quot;Parameter of a discrete distribution&quot; </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: generates random numbers</p>
</dd>
<dt><code>d</code></dt><dd><p>fixed to <code>NULL</code></p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>: cumulative distribution function</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>: quantile function</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
<dt><code>support</code></dt><dd><p>numeric vector &mdash; the support slot of the discrete part</p>
</dd>
<dt><code>gaps</code></dt><dd><p>(numeric) matrix or <code>NULL</code>; &mdash; the gaps slot of 
the absolutely continuous part</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"UnivarMixingDistribution"</code>, directly;
class <code>"UnivariateDistribution"</code> by class <code>"UnivarMixingDistribution"</code>
class <code>"Distribution"</code> by class <code>"UnivariateDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>plot</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>acPart</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>acPart&lt;-</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>discretePart</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>discretePart&lt;-</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>acWeight</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>acWeight&lt;-</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>discreteWeight</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>discreteWeight&lt;-</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>p.ac</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code> accessor to 
slot <code>p</code> of <code>acPart(object)</code>, possibly weighted 
by <code>acWeight(object)</code>; 
it has an extra argument <code>CondOrAbs</code> with default value 
<code>"cond"</code> which if it does not partially match 
(by <code><a href="base.html#topic+pmatch">pmatch</a></code>) <code>"abs"</code>, returns exactly
slot <code>p</code> of <code>acPart(object)</code> else weighted by 
<code>acWeight(object)</code>.</p>
</dd>
<dt>d.ac</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code>accessor to 
slot <code>d</code> of the absolutely continuous part of
the distribution, possibly weighted by <code>acWeight(object)</code>; 
it has an extra argument <code>CondOrAbs</code> which acts as the one
in <code>p.ac</code>.</p>
</dd>
<dt>q.ac</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code> accessor to 
slot <code>q</code> of <code>acPart(object)</code>.</p>
</dd>
<dt>r.ac</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code> accessor to 
slot <code>q</code> of <code>acPart(object)</code>.</p>
</dd>
<dt>p.discrete</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code> 
accessor to slot <code>p</code> of <code>discretePart(object)</code>, 
possibly weighted by <code>discreteWeight(object)</code>; 
it has an extra argument <code>CondOrAbs</code> which acts 
as the one in <code>p.ac</code>.</p>
</dd>
<dt>d.discrete</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code> 
accessor to slot <code>d</code> of <code>discretePart(object)</code>, 
possibly weighted by <code>discreteWeight(object)</code>; 
it has an extra argument <code>CondOrAbs</code> which acts as 
the one in <code>p.ac</code>.</p>
</dd>
<dt>q.discrete</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code> 
accessor to slot <code>q</code> of <code>discretePart(object)</code>.</p>
</dd>
<dt>r.discrete</dt><dd><p><code>signature(object = "UnivarLebDecDistribution")</code> 
accessor to slot <code>r</code> of <code>discretePart(object)</code>.</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "AffLinUnivarLebDecDistribution", to = "UnivarLebDecDistribution")</code>:
create a <code>"UnivarLebDecDistribution"</code> object from a <code>"AffLinUnivarLebDecDistribution"</code> object</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "AbscontDistribution", to = "UnivarLebDecDistribution")</code>:
create a <code>"UnivarLebDecDistribution"</code> object from a <code>"AbscontDistribution"</code> object</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "DiscreteDistribution", to = "UnivarLebDecDistribution")</code>:
create a <code>"UnivarLebDecDistribution"</code> object from a <code>"DiscreteDistribution"</code> object</p>
</dd>
<dt>Math</dt><dd><p><code>signature(x = "UnivarLebDecDistribution")</code>: application of a mathematical function, e.g. <code>sin</code> or <code>tan</code> to this discrete distribution
</p>

<ul>
<li> <p><code>abs</code>: <code>signature(x = "UnivarLebDecDistribution")</code>:  exact image distribution of <code>abs(x)</code>.
</p>
</li>
<li> <p><code>exp</code>: <code>signature(x = "UnivarLebDecDistribution")</code>:  exact image distribution of <code>exp(x)</code>.
</p>
</li>
<li> <p><code>sign</code>: <code>signature(x = "UnivarLebDecDistribution")</code>:  exact image distribution of <code>sign(x)</code>.
</p>
</li>
<li> <p><code>sign</code>: <code>signature(x = "AcDcLcDistribution")</code>:  exact image distribution of <code>sign(x)</code>.
</p>
</li>
<li> <p><code>sqrt</code>: <code>signature(x = "AcDcLcDistribution")</code>:  exact image distribution of <code>sqrt(x)</code>.
</p>
</li>
<li> <p><code>log</code>: <code>signature(x = "UnivarLebDecDistribution")</code>:  (with optional further argument <code>base</code>, defaulting to <code>exp(1)</code>) exact image distribution of <code>log(x)</code>.
</p>
</li>
<li> <p><code>log10</code>: <code>signature(x = "UnivarLebDecDistribution")</code>:  exact image distribution of <code>log10(x)</code>.
</p>
</li>
<li> <p><code>sqrt</code>: <code>signature(x = "UnivarLebDecDistribution")</code>:  exact 
image distribution of <code>sqrt(x)</code>.
</p>
</li>
<li> <p><code>sqrt</code>: <code>signature(x = "AcDcLcDistribution")</code>:  exact image distribution of <code>sqrt(x)</code>.
</p>
</li></ul>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "UnivarLebDecDistribution")</code>: application of &lsquo;-&rsquo; to this distribution</p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "numeric")</code>: multiplication of this distribution
by an object of class &lsquo;numeric&rsquo;</p>
</dd>
<dt>/</dt><dd><p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "numeric")</code>: division of this distribution
by an object of class &lsquo;numeric&rsquo;</p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "numeric")</code>: addition of this distribution
to an object of class &lsquo;numeric&rsquo;</p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "numeric")</code>: subtraction of an object of class &lsquo;numeric&rsquo;
from this distribution </p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "numeric", e2 = "UnivarLebDecDistribution")</code>: multiplication of this distribution
by an object of class &lsquo;numeric&rsquo;</p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "numeric", e2 = "UnivarLebDecDistribution")</code>: addition of this distribution
to an object of class &lsquo;numeric&rsquo;</p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "numeric", e2 = "UnivarLebDecDistribution")</code>: subtraction of this distribution
from an object of class &lsquo;numeric&rsquo;</p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "UnivarLebDecDistribution")</code>: Convolution of two Lebesgue
decomposed distributions. Result is again of class <code>"UnivarLebDecDistribution"</code>, but if option
<code>getdistrOption("withSimplify")</code> is <code>TRUE</code> it is piped through a call to <code><a href="#topic+simplifyD">simplifyD</a></code>,
hence may also be of class <code>AbscontDistribution</code> or <code>DiscreteDistribution</code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt>-</dt><dd><p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "UnivarLebDecDistribution")</code>: Convolution of two Lebesgue
decomposed distributions. The same applies as for the preceding item.</p>
</dd>
</dl>



<h3>Internal subclass &quot;AffLinUnivarLebDecDistribution&quot;</h3>

<p>To enhance accuracy of several functionals on distributions,
mainly from package <span class="pkg">distrEx</span>,  
there is an internally used (but exported) subclass 
<code>"AffLinUnivarLebDecDistribution"</code> which has extra slots 
<code>a</code>, <code>b</code> (both of class <code>"numeric"</code>),  and <code>X0</code> 
(of class <code>"UnivarLebDecDistribution"</code>), to capture the fact 
that the object has the same distribution as <code>a * X0 + b</code>. This is 
the class of the return value of methods 
</p>

<dl>
<dt>-</dt><dd><p><code>signature(e1 = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "numeric")</code></p>
</dd>
<dt>/</dt><dd><p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "numeric")</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "numeric")</code></p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "numeric")</code></p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "numeric", e2 = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "numeric", e2 = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "numeric", e2 = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "AffLinUnivarLebDecDistribution")</code></p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "AffLinUnivarLebDecDistribution", e2 = "numeric")</code></p>
</dd>
<dt>/</dt><dd><p><code>signature(e1 = "AffLinUnivarLebDecDistribution", e2 = "numeric")</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "AffLinUnivarLebDecDistribution", e2 = "numeric")</code></p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "AffLinUnivarLebDecDistribution", e2 = "numeric")</code></p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "numeric", e2 = "AffLinUnivarLebDecDistribution")</code></p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "numeric", e2 = "AffLinUnivarLebDecDistribution")</code></p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "numeric", e2 = "AffLinUnivarLebDecDistribution")</code></p>
</dd>
</dl>

<p>There also is a class union of <code>"AffLinAbscontDistribution"</code>,
<code>"AffLinDiscreteDistribution"</code>, <code>"AffLinUnivarLebDecDistribution"</code>
and called <code>"AffLinDistribution"</code>
which is used for functionals.
</p>


<h3>Internal virtual superclass &quot;AcDcLcDistribution&quot;</h3>

<p>As many operations should be valid no matter whether the operands
are of class <code>"AbscontDistribution"</code>,
<code>"DiscreteDistribution"</code>, or <code>"UnivarLebDecDistribution"</code>,
there is a class union of these classes called <code>"AcDcLcDistribution"</code>;
in particular methods for <code>"*"</code>, <code>"/"</code>, 
<code>"^"</code> (see <a href="#topic+operators-methods">operators-methods</a>) and methods
<code><a href="#topic+Minimum">Minimum</a></code>, <code>Maximum</code>, <code><a href="#topic+Truncate">Truncate</a></code>, and
<code><a href="#topic+Huberize">Huberize</a></code>, and <code><a href="#topic+convpow">convpow</a></code> are defined for this 
class union.   
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Parameter-class">Parameter-class</a></code>
<code><a href="#topic+UnivarMixingDistribution-class">UnivarMixingDistribution-class</a></code>
<code><a href="#topic+DiscreteDistribution-class">DiscreteDistribution-class</a></code>
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>
<code><a href="#topic+simplifyD">simplifyD</a></code>
<code><a href="#topic+flat.LCD">flat.LCD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wg &lt;- flat.mix(UnivarMixingDistribution(Unif(0,1),Unif(4,5),
               withSimplify=FALSE))
myLC &lt;- UnivarLebDecDistribution(discretePart=Binom(3,.3), acPart = wg,
          discreteWeight=.2)
myLC
p(myLC)(0.3)
r(myLC)(30)
q(myLC)(0.9)
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
acPart(myLC)
plot(myLC)
d.discrete(myLC)(2)
p.ac(myLC)(0)
acWeight(myLC)
plot(acPart(myLC))
plot(discretePart(myLC))
gaps(myLC)
support(myLC)
plot(as(Norm(),"UnivarLebDecDistribution"))
</code></pre>

<hr>
<h2 id='UnivarMixingDistribution'>Generating function for Class &quot;UnivarMixingDistribution&quot;</h2><span id='topic+UnivarMixingDistribution'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"UnivarMixingDistribution"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>UnivarMixingDistribution(..., Dlist, mixCoeff, 
                                withSimplify = getdistrOption("simplifyD"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnivarMixingDistribution_+3A_...">...</code></td>
<td>
<p>Objects of class <code>"UnivariateDistribution"</code> (or subclasses)</p>
</td></tr>
<tr><td><code id="UnivarMixingDistribution_+3A_dlist">Dlist</code></td>
<td>
<p>an optional list or object of class <code>"UnivarDistrList"</code>;
if not missing it is appended to argument <code>...</code>; this way 
<code>UnivarMixingDistribution</code> may also be called with a list (or 
<code>"UnivarDistrList"</code>-object) as argument as suggested in an e-mail
by Krunoslav Sever (thank you!)</p>
</td></tr>
<tr><td><code id="UnivarMixingDistribution_+3A_mixcoeff">mixCoeff</code></td>
<td>
<p>Objects of class <code>"numeric"</code> : a vector of 
probabilities for the mixing components (must be of same length as
arguments in ...).</p>
</td></tr>
<tr><td><code id="UnivarMixingDistribution_+3A_withsimplify">withSimplify</code></td>
<td>
<p><code>"logical"</code>: shall the return value be piped through a 
call to <code>simplifyD</code>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>mixCoeff</code> is missing, all elements in <code>...</code>
are equally weighted.</p>


<h3>Value</h3>

<p>Object of class <code>"UnivarMixingDistribution"</code>, or if 
argument <code>withSimplify</code> is <code>TRUE</code> and the resulting 
object would have one mixing component with probability (almost) 1,
<code>UnivarMixingDistribution</code> will return this component.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+UnivarMixingDistribution-class">UnivarMixingDistribution-class</a></code>,
<code><a href="#topic+simplifyD">simplifyD</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>mylist &lt;- UnivarMixingDistribution(Binom(3,.3), Dirac(2), Norm(), 
          mixCoeff=c(1/4,1/5,11/20))
</code></pre>

<hr>
<h2 id='UnivarMixingDistribution-class'>Class &quot;UnivarMixingDistribution&quot;</h2><span id='topic+UnivarMixingDistribution-class'></span><span id='topic+mixCoeff'></span><span id='topic+mixDistr'></span><span id='topic+mixCoeff+3C-'></span><span id='topic+mixDistr+3C-'></span><span id='topic+mixCoeff+3C--methods'></span><span id='topic+mixDistr+3C--methods'></span><span id='topic+mixCoeff+3C-+2CUnivarMixingDistribution-method'></span><span id='topic+mixDistr+3C-+2CUnivarMixingDistribution-method'></span><span id='topic+mixCoeff-methods'></span><span id='topic+mixDistr-methods'></span><span id='topic+mixCoeff+2CUnivarMixingDistribution-method'></span><span id='topic+mixDistr+2CUnivarMixingDistribution-method'></span><span id='topic+support+2CUnivarMixingDistribution-method'></span><span id='topic+gaps+2CUnivarMixingDistribution-method'></span><span id='topic+.logExact+2CUnivarMixingDistribution-method'></span><span id='topic+.lowerExact+2CUnivarMixingDistribution-method'></span><span id='topic+Symmetry+2CUnivarMixingDistribution-method'></span>

<h3>Description</h3>

<p><code>UnivarMixingDistribution</code>-class is a class to formalize 
univariate mixing distributions; it is a subclass to
class <code>UnivariateDistribution</code>.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form 
<code>new("UnivarMixingDistribution", ...)</code>.
More frequently they are created via the generating function 
<code><a href="#topic+UnivarMixingDistribution">UnivarMixingDistribution</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mixCoeff</code></dt><dd><p>Object of class <code>"numeric"</code>: a vector of 
probabilities for the mixing components.</p>
</dd>
<dt><code>mixDistr</code></dt><dd><p>Object of class <code>"UnivarDistrList"</code>: a list of
univariate distributions containing the mixing components; must be of same
length as <code>mixCoeff</code>.</p>
</dd>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>: the space of the image of this distribution which has dimension 1
and the name &quot;Real Space&quot; </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"Parameter"</code>: the parameter of this distribution, having only the
slot name &quot;Parameter of a discrete distribution&quot; </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: generates random numbers</p>
</dd>
<dt><code>d</code></dt><dd><p>fixed to <code>NULL</code></p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>: cumulative distribution function</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>: quantile function</p>
</dd>
<dt><code>support</code></dt><dd><p>numeric vector &mdash; the union of all support slots of components, if existing</p>
</dd>
<dt><code>gaps</code></dt><dd><p>(numeric) matrix or <code>NULL</code>; the merged <code>gaps</code> slots of all components, 
if existing (else NULL)</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where there are explicit formulae for the
log version of density, cdf, and quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where there are explicit formulae for the
lower tail version of cdf and quantile function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"UnivariateDistribution"</code>
class <code>"Distribution"</code> by class <code>"UnivariateDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "UnivarMixingDistribution")</code> prints the object</p>
</dd>
<dt>mixCoeff&lt;-</dt><dd><p><code>signature(object = "UnivarMixingDistribution")</code> replaces the corresponding slot</p>
</dd>
<dt>mixCoeff</dt><dd><p><code>signature(object = "UnivarMixingDistribution")</code> returns the corresponding slot</p>
</dd>
<dt>mixDistr&lt;-</dt><dd><p><code>signature(object = "UnivarMixingDistribution")</code> replaces the corresponding slot</p>
</dd>
<dt>mixDistr</dt><dd><p><code>signature(object = "UnivarMixingDistribution")</code> returns the corresponding slot</p>
</dd>
<dt>support</dt><dd><p><code>signature(object = "UnivarMixingDistribution")</code> returns the corresponding slot</p>
</dd>
<dt>gaps</dt><dd><p><code>signature(object = "UnivarMixingDistribution")</code> returns the corresponding slot</p>
</dd>
<dt>.logExact</dt><dd><p><code>signature(object = "Distribution")</code>: returns slot 
<code>.logExact</code> if existing; else tries to convert the object to a newer 
version of its class by <code><a href="#topic+conv2NewVersion">conv2NewVersion</a></code> and
returns the corresponding slot of the converted object.</p>
</dd>
<dt>.lowerExact</dt><dd><p><code>signature(object = "Distribution")</code>: returns slot 
<code>.lowerExact</code> if existing; else tries to convert the object to a 
newer version of its class by <code><a href="#topic+conv2NewVersion">conv2NewVersion</a></code> and
returns the corresponding slot of the converted object.</p>
</dd>
<dt>Symmetry</dt><dd><p>returns slot <code>Symmetry</code> if existing; else
tries to convert the object to a 
newer version of its class by <code><a href="#topic+conv2NewVersion">conv2NewVersion</a></code> and
returns the corresponding slot of the converted object.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Parameter-class">Parameter-class</a></code>, 
<code><a href="#topic+UnivariateDistribution-class">UnivariateDistribution-class</a></code>, 
<code><a href="#topic+LatticeDistribution-class">LatticeDistribution-class</a></code>, 
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>, 
<code><a href="#topic+simplifyD">simplifyD</a></code>, 
<code><a href="#topic+flat.mix">flat.mix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mylist &lt;- UnivarMixingDistribution(Binom(3,.3), Dirac(2), Norm(), 
          mixCoeff=c(1/4,1/5,11/20))
mylist2 &lt;- UnivarMixingDistribution(Binom(3,.3), mylist, 
          mixCoeff=c(.3,.7))
mylist2
p(mylist)(0.3)          
mixDistr(mylist2)
</code></pre>

<hr>
<h2 id='Version+20Management'> Methods for Version Management in Package &lsquo;distr&rsquo; </h2><span id='topic+isOldVersion'></span><span id='topic+isOldVersion-methods'></span><span id='topic+isOldVersion+2CANY-method'></span><span id='topic+conv2NewVersion'></span><span id='topic+conv2NewVersion-methods'></span><span id='topic+conv2NewVersion+2CANY-method'></span><span id='topic+conv2NewVersion+2CLatticeDistribution-method'></span>

<h3>Description</h3>

<p>Version-Management-methods</p>


<h3>Usage</h3>

<pre><code class='language-R'>isOldVersion(object)
conv2NewVersion(object)
## S4 method for signature 'ANY'
isOldVersion(object)
## S4 method for signature 'ANY'
conv2NewVersion(object)
## S4 method for signature 'LatticeDistribution'
conv2NewVersion(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Version+2B20Management_+3A_object">object</code></td>
<td>
<p>object of class  <code>"ANY"</code> (or subclasses)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From version 1.9 of this package on, class <code>"AbscontDistribution"</code> has an extra slot
<code>gaps</code>. As the addition of new slots will probably happen again in the future development
of our packages, we provide the following two help functions
<code>isOldVersion</code> and <code>conv2NewVersion</code> to check whether the object was generated by an 
older version of this package and to convert such an object to the new format, respectively. 
Also, the intermediate class <code>"LatticeDistribution"</code> is introduced at version 1.9
so that all subclasses of <code>"DiscreteDistribution"</code> like <code>"Binom"</code>, <code>"Nbinom"</code> etc,
now have an extra slot <code>lattice</code>. <code>conv2NewVersion</code> takes this up and provides
a particular method for signature <code>"LatticeDistribution"</code> which fills slot
<code>lattice</code> accordingly.
</p>

<dl>
<dt>isOldVersion</dt><dd><p><code>signature(object = "ANY")</code>: 
throws an error if <code>isClass(class(object))</code> is <code>FALSE</code>, i.e.; if
the class of <code>object</code> is no formal (S4) class. Else it checks whether
all slots of the actual class definition may be accessed and if so
returns <code>FALSE</code> and else <code>TRUE</code> and issues a warning.
</p>
</dd>
<dt>conv2NewVersion</dt><dd><p><code>signature(object = "ANY")</code>: 
Generates a valid copy of <code>object</code> (according to the actual class definition), 
using the slots of <code>object</code> where possible and for the slots which are not yet
present in <code>object</code> (because it was generated by an older version of 
the class definition), it generates a prototype object of the class 
of <code>object</code> with <code>new(class(object))</code> and uses
the slot values of this prototype to fill the missing slots.
</p>
</dd>
<dt>conv2NewVersion</dt><dd><p><code>signature(object = "LatticeDistribution")</code>: 
Generates a valid copy of <code>object</code> (according to the actual class definition,
i.e.; with a corresponding <code>lattice</code>-slot), by generating a new instance of
this object by <code>new(class(object), &lt;list-of-parameters&gt;</code>.
</p>
</dd>
</dl>


<hr>
<h2 id='Weibull-class'>Class &quot;Weibull&quot;</h2><span id='topic+Weibull-class'></span><span id='topic+Weibull'></span><span id='topic+initialize+2CWeibull-method'></span>

<h3>Description</h3>

<p>  The Weibull distribution with <code>shape</code> parameter <code class="reqn">a</code>, by default <code class="reqn">=1</code>, and
<code>scale</code> parameter <code class="reqn">\sigma</code> has density given by, by default <code class="reqn">=1</code>,
</p>
<p style="text-align: center;"><code class="reqn">d(x) = (a/\sigma) {(x/\sigma)}^{a-1} \exp (-{(x/\sigma)}^{a})</code>
</p>

<p>for <code class="reqn">x &gt; 0</code>.
</p>
<p>C.f. <code><a href="stats.html#topic+Weibull">rweibull</a></code>
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Weibull(shape, scale)</code>.
This object is a Weibull distribution.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>: The space of the image of this distribution has got dimension 1
and the name &quot;Real Space&quot;. </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"WeibullParameter"</code>: the parameter of this distribution (shape and scale),
declared at its instantiation </p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: generates random numbers (calls function <code>rweibull</code>)</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"function"</code>: density function (calls function <code>dweibull</code>)</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"function"</code>: cumulative function (calls function <code>pweibull</code>)</p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"function"</code>: inverse of the cumulative function (calls function <code>qweibull</code>)</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"AbscontDistribution"</code>, directly.<br />
Class <code>"UnivariateDistribution"</code>, by class <code>"AbscontDistribution"</code>.<br />
Class <code>"Distribution"</code>, by class <code>"AbscontDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "Weibull")</code>: initialize method </p>
</dd>
<dt>scale</dt><dd><p><code>signature(object = "Weibull")</code>: returns the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>scale&lt;-</dt><dd><p><code>signature(object = "Weibull")</code>: modifies the slot <code>scale</code> of the parameter of the distribution </p>
</dd>
<dt>shape</dt><dd><p><code>signature(object = "Weibull")</code>: returns the slot <code>shape</code> of the parameter of the distribution </p>
</dd>
<dt>shape&lt;-</dt><dd><p><code>signature(object = "Weibull")</code>: modifies the slot <code>shape</code> of the parameter of the distribution </p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "Weibull", e2 = "numeric")</code>:
For the Weibull distribution we use its closedness under positive scaling transformations.</p>
</dd>
</dl>



<h3>Note</h3>

<p> The density is <code class="reqn">d(x)=0</code> for <code class="reqn">x &lt; 0</code>.<br />
The cumulative is
<code class="reqn">p(x) = 1 - \exp(-{(x/\sigma)}^a)</code>,<br />
the mean is <code class="reqn">E(X) = \sigma \Gamma(1 + 1/a)</code>,<br />
and the <code class="reqn">Var(X) = \sigma^2(\Gamma(1 + 2/a)-(\Gamma(1 + 1/a))^2)</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+WeibullParameter-class">WeibullParameter-class</a></code>
<code><a href="#topic+AbscontDistribution-class">AbscontDistribution-class</a></code>
<code><a href="#topic+Reals-class">Reals-class</a></code>
<code><a href="stats.html#topic+Weibull">rweibull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- Weibull(shape=1,scale=1) # W is a Weibull distribution with shape=1 and scale=1.
r(W)(1) # one random number generated from this distribution, e.g. 0.5204105
d(W)(1) # Density of this distribution is 0.3678794 for x=1.
p(W)(1) # Probability that x&lt;1 is 0.6321206.
q(W)(.1) # Probability that x&lt;0.1053605 is 0.1.
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
shape(W) # shape of this distribution is 1.
shape(W) &lt;- 2 # shape of this distribution is now 2.
</code></pre>

<hr>
<h2 id='WeibullParameter-class'>Class &quot;WeibullParameter&quot;</h2><span id='topic+WeibullParameter-class'></span><span id='topic+initialize+2CWeibullParameter-method'></span>

<h3>Description</h3>

<p> The parameter of a Weibull distribution, used by <code>Weibull</code>-class</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("WeibullParameter", shape, scale)</code>.
Usually an object of this class is not needed on its own, it is generated automatically when an object of the class <code>Weibull</code>
is instantiated. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>shape</code></dt><dd><p>Object of class <code>"numeric"</code>: the shape of a Weibull distribution </p>
</dd>
<dt><code>scale</code></dt><dd><p>Object of class <code>"numeric"</code>: the scale of a Weibull distribution </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: a name / comment for the parameters </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "WeibullParameter")</code>: initialize method </p>
</dd>
<dt>scale</dt><dd><p><code>signature(object = "WeibullParameter")</code>: returns the slot <code>scale</code> of a parameter of a Weibull
distribution </p>
</dd>
<dt>scale&lt;-</dt><dd><p><code>signature(object = "WeibullParameter")</code>: modifies the slot <code>scale</code> of a parameter of a Weibull
distribution </p>
</dd>
<dt>shape</dt><dd><p><code>signature(object = "WeibullParameter")</code>: returns the slot <code>shape</code> of a parameter of a Weibull
distribution </p>
</dd>
<dt>shape&lt;-</dt><dd><p><code>signature(object = "WeibullParameter")</code>: modifies the slot <code>shape</code> of a parameter of a Weibull
distribution </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br /> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Weibull-class">Weibull-class</a></code>
<code><a href="#topic+Parameter-class">Parameter-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- new("WeibullParameter",shape=1,scale=1)
shape(W) # shape of this distribution is 1.
shape(W) &lt;- 2 # shape of this distribution is now 2.
</code></pre>

<hr>
<h2 id='width-methods'> Methods for Function width in Package &lsquo;distr&rsquo; </h2><span id='topic+width-methods'></span><span id='topic+width+3C--methods'></span><span id='topic+width'></span><span id='topic+width+3C-'></span><span id='topic+width+2CLattice-method'></span><span id='topic+width+3C-+2CLattice-method'></span><span id='topic+width+2CLatticeDistribution-method'></span><span id='topic+width+3C-+2CLatticeDistribution-method'></span>

<h3>Description</h3>

<p>width-methods</p>


<h3>Methods</h3>


<dl>
<dt>width</dt><dd><p><code>signature(object = "Lattice")</code>: returns the slot width of the lattice </p>
</dd>
<dt>width&lt;-</dt><dd><p><code>signature(object = "Lattice")</code>: modifies the slot width of the lattice </p>
</dd>
<dt>width</dt><dd><p><code>signature(object = "LatticeDistribution")</code>: returns the slot width of the lattice slot of the distribution</p>
</dd>
<dt>width&lt;-</dt><dd><p><code>signature(object = "LatticeDistribution")</code>: modifies the slot width of the lattice slot of the distribution</p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
