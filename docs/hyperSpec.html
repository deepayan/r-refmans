<!DOCTYPE html><html lang="en"><head><title>Help for package hyperSpec</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hyperSpec}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hyperSpec-package'><p>Package hyperSpec</p></a></li>
<li><a href='#.cluster.wavelengths'><p>Find clusters of approximately equal wavelengths</p></a></li>
<li><a href='#.collapse.equal'><p>Try finding groups of hyperSpec objects with (approximately) equal wavelength axes</p></a></li>
<li><a href='#.DollarNames.hyperSpec'><p>command line completion for $</p></a></li>
<li><a href='#.fileio.optional'><p>Helper function to harmonize treatment of file import results</p></a></li>
<li><a href='#.fix_spc_colnames'><p>Ensure that the spectra matrix has the wavelengths in column names</p></a></li>
<li><a href='#.read.spe.xml'><p>Read XML footer from SPE file format version 3.0</p></a></li>
<li><a href='#.read.spe.xml_string'><p>.read.spe.xml_string</p></a></li>
<li><a href='#+5B+2ChyperSpec-method'><p>Extract and Replace parts of hyperSpec objects</p></a></li>
<li><a href='#aggregate'><p>aggregate hyperSpec objects</p></a></li>
<li><a href='#apply'><p>apply</p>
Computes summary statistics for the spectra of a <code>hyperSpec</code> object.</a></li>
<li><a href='#Arith'><p>Arithmetical Operators for hyperSpec objects</p></a></li>
<li><a href='#as.character+2ChyperSpec-method'><p>Convert a hyperSpec object to character strings for Display</p>
<code>print</code>, <code>show</code>, and <code>summary</code> show the result of
<code>as.character</code>.</a></li>
<li><a href='#as.data.frame'><p>Conversion of a hyperSpec object into a data.frame or matrix</p>
<code>as.data.frame</code> returns <code>x@data</code> (as data.frame) <code>as.matrix</code>
returns the spectra matrix <code>x@data$spc</code> as matrix</a></li>
<li><a href='#as.hyperSpec'><p>as.hyperSpec: convenience conversion functions</p></a></li>
<li><a href='#barbiturates'><p>Barbiturates Spectra from .spc example files</p>
A time series of mass spectra in a list of hyperSpec objects.</a></li>
<li><a href='#bind'><p>Binding hyperSpec Objects</p></a></li>
<li><a href='#chk.hy'><p>Validation of hyperSpec objects</p></a></li>
<li><a href='#chondro'><p>Raman spectra of 2 Chondrocytes in Cartilage</p>
A Raman-map (laterally resolved Raman spectra) of chondrocytes in
cartilage.</a></li>
<li><a href='#collapse'><p>Collapse hyperSpec objects</p></a></li>
<li><a href='#colSums'><p>colSums, colMeans, rowSums and rowMeans functions for hyperSpec objects</p></a></li>
<li><a href='#Comparison'><p>Comparison of hyperSpec objects</p></a></li>
<li><a href='#count_lines'><p>count lines (of an ASCII file)</p></a></li>
<li><a href='#cov+2ChyperSpec+2Cmissing-method'><p>Covariance matrices for hyperSpec objects</p></a></li>
<li><a href='#decomposition'><p>Convert Principal Component Decomposition or the like into a hyperSpec</p>
Object</a></li>
<li><a href='#dimnames+2ChyperSpec-method'><p>dimnames for hyperSpec objects</p></a></li>
<li><a href='#droplevels+2ChyperSpec-method'><p>droplevels for hyperSpec object</p></a></li>
<li><a href='#empty'><p>Empty hyperSpec object</p></a></li>
<li><a href='#flu'><p>Quinine Fluorescence Spectra</p>
Fluorescence spectra of different dilutions of quinine forming a
calibration set.</a></li>
<li><a href='#Future-functions'><p>Future functions</p></a></li>
<li><a href='#guess.wavelength'><p>guess wavelengths from character vector</p></a></li>
<li><a href='#hy.getOptions'><p>Options for package hyperSpec</p>
Functions to access and set hyperSpec's options.</a></li>
<li><a href='#hy.unittest'><p>hyperSpec unit tests</p></a></li>
<li><a href='#hyperSpec-class'><p>Class &quot;hyperSpec&quot;</p>
This class handles hyperspectral data sets, i.e. spatially or time-resolved
spectra, or spectra with any other kind of information associated with the
spectra.</a></li>
<li><a href='#initialize'><p>Creating a hyperSpec Object</p></a></li>
<li><a href='#labels+26lt+3B-'><p>Get and Set Labels of a hyperSpec Object</p>
<code>value</code> may be a list or vector of labels giving the new label for
each of the entries specified by <code>which</code>.</a></li>
<li><a href='#laser'><p>Laser Emission</p>
A time series of an unstable laser emission.</a></li>
<li><a href='#legendright'><p>Plot multivariate data into colour channels</p></a></li>
<li><a href='#makeraster'><p>makeraster</p></a></li>
<li><a href='#map.sel.poly'><p>Interactively select a polygon (grid graphics) and highlight points</p></a></li>
<li><a href='#mark.dendrogram'><p>Mark groups in <code>hclust</code> dendrograms</p></a></li>
<li><a href='#markpeak'><p>Mark peak</p>
</p>
<p>Marks location of the <em>first</em> spectrum at the data point closest to the</p>
specified position on the current plot.</a></li>
<li><a href='#Math2+2ChyperSpec-method'><p>Math Functions for hyperSpec Objects</p></a></li>
<li><a href='#matlab.palette'><p>Matlab-like Palettes</p>
Two palettes going from blue over green to red, approximately as the
standard palette of Matlab does. The second one has darker green values and
is better suited for plotting lines on white background.</a></li>
<li><a href='#mean_sd+2Cnumeric-method'><p>Mean and Standard Deviation</p>
Calculate mean and standard deviation, and mean, mean <code class="reqn">\pm</code> one
standard deviation, respectively.</a></li>
<li><a href='#merge+2ChyperSpec+2ChyperSpec-method'><p>Merge hyperSpec objects</p></a></li>
<li><a href='#ncol+2ChyperSpec-method'><p>The Number of Rows (Spectra), Columns, and Data Points per Spectrum of an</p>
hyperSpec Object)</a></li>
<li><a href='#normalize01'><p>normalization for mixed colors</p></a></li>
<li><a href='#orderwl'><p>Sorting the Wavelengths of a hyperSpec Object</p>
Rearranges the <code>hyperSpec</code> object so that the wavelength vector is in increasing (or
decreasing) order.</a></li>
<li><a href='#paracetamol'><p>Paracetamol Spectrum</p>
A Raman spectrum of a paracetamol tablet.</a></li>
<li><a href='#pearson.dist'><p>Distance based on Pearson's <code class="reqn">R^2</code></p></a></li>
<li><a href='#plot-methods'><p>Plotting hyperSpec Objects</p></a></li>
<li><a href='#plotc'><p>Calibration- and Timeseries Plots, Depth-Profiles and the like</p>
<code>plotc</code> plots intensities of a <code>hyperSpec</code> object over another
dimension such as concentration, time, or a spatial coordinate.</a></li>
<li><a href='#plotmap'><p>Plot a Map and Identify/Select Spectra in the Map</p>
<code>levelplot</code> functions for hyperSpec objects.  An image or map of a summary
value of each spectrum is plotted. Spectra may be identified by mouse click.</a></li>
<li><a href='#plotmat'><p>Plot spectra matrix</p></a></li>
<li><a href='#plotspc'><p>Plotting Spectra</p>
Plot the spectra of a <code>hyperSpec</code> object, i.e. intensity over
wavelength. Instead of the intensity values of the spectra matrix summary
values calculated from these may be used.</a></li>
<li><a href='#qplotc'><p>Spectra plotting with ggplot2</p></a></li>
<li><a href='#qplotmap'><p>Spectra plotting with ggplot2</p></a></li>
<li><a href='#qplotmixmap'><p>qplotmap with colour mixing for multivariate overlay</p></a></li>
<li><a href='#qplotspc'><p>Spectra plotting with ggplot2</p></a></li>
<li><a href='#quickdf'><p>Quick data frame.</p>
Experimental version of <code>as.data.frame</code> that converts a
list to a data frame, but doesn't do any checks to make sure it's a
valid format. Much faster.</a></li>
<li><a href='#rbind.fill.matrix'><p>Bind matrices by row, and fill missing columns with NA</p></a></li>
<li><a href='#read.asc.PerkinElmer'><p>File import filter PerkinElmer ASCII spectra</p></a></li>
<li><a href='#read.cytomat'><p>Import for Cytospec mat files</p></a></li>
<li><a href='#read.ENVI'><p>Import of ENVI data as hyperSpec object</p></a></li>
<li><a href='#read.ini'><p>Read INI files</p></a></li>
<li><a href='#read.jdx'><p>JCAMP-DX Import for Shimadzu Library Spectra</p></a></li>
<li><a href='#read.spc'><p>Import for Thermo Galactic's spc file format</p>
These functions allow to import Thermo Galactic/Grams .spc files.</a></li>
<li><a href='#read.spc.Kaiser'><p>read Kaiser .spc files</p></a></li>
<li><a href='#read.spe'><p>Import WinSpec SPE file</p></a></li>
<li><a href='#read.txt.Horiba'><p>Import Horiba Labspec exported ASCII files</p></a></li>
<li><a href='#read.txt.Shimadzu'><p>Reads Shimadzu GCxGC-qMS - Spectra Files (.txt) as exported by Shimadzu Chrome Solution (v. 2.72)</p>
Mass Spectrometer: Shimadzu GCMS-QP 2010 Ultra (www.shimadzu.com)</a></li>
<li><a href='#read.txt.wide'><p>Import/export of hyperSpec objects to/from ASCII files</p>
A detailed discussion of hyperSpec's file import and export capabilities is given in vignette &ldquo;fileio&rdquo;.</a></li>
<li><a href='#rmmvnorm'><p>Multivariate normal random numbers</p></a></li>
<li><a href='#sample+2ChyperSpec-method'><p>Random Samples and Permutations</p>
Take a sample of the specified size from the elements of x with or without
replacement.</a></li>
<li><a href='#scale+2ChyperSpec-method'><p>Center and scale hyperSpec object</p></a></li>
<li><a href='#scan.asc.Andor'><p>File Import Andor Solis</p></a></li>
<li><a href='#scan.txt.Renishaw'><p>import Raman measurements from Renishaw ASCII-files</p></a></li>
<li><a href='#scan.txt.Witec'><p>File Import Witec Raman</p></a></li>
<li><a href='#seq.hyperSpec'><p>Sequence generation along spectra or wavelengths</p>
This function generates sequences along the spectra (rows) or wavelengths of hyperSpec objects.</a></li>
<li><a href='#spc.bin'><p>Wavelength Binning</p>
In order to reduce the spectral resolution and thus gain signal to noise
ratio or to reduce the dimensionality of the spectral data set, the
spectral resolution can be reduced.</a></li>
<li><a href='#spc.fit.poly'><p>Polynomial Baseline Fitting</p>
These functions fit polynomal baselines.</a></li>
<li><a href='#spc.identify'><p>Identifying Spectra and Spectral Data Points</p>
This function allows to identify the spectrum and the wavelength of a point
in a plot produced by <code>plotspc</code>.</a></li>
<li><a href='#spc.loess'><p>loess smoothing interpolation for spectra</p>
Spectra can be smoothed and interpolated on a new wavelength axis using
<code>loess</code>.</a></li>
<li><a href='#spc.NA.approx'><p>Impute missing data points</p></a></li>
<li><a href='#spc.rubberband'><p>Rubberband baseline correction</p></a></li>
<li><a href='#spc.smooth.spline'><p>Spectral smoothing by splines</p></a></li>
<li><a href='#split'><p>Split a hyperSpec object according to groups</p>
<code>split</code> divides the <code>hyperSpec</code> object into a list of
<code>hyperSpec</code> objects according to the groups given by <code>f</code>.</a></li>
<li><a href='#subset'><p>subset</p></a></li>
<li><a href='#Summary'><p>The functions</p></a></li>
<li><a href='#sweep'><p>Sweep Summary Statistic out of an hyperSpec Object</p>
<code>sweep</code> for <code>hyperSpec</code> objects.</a></li>
<li><a href='#trellis.factor.key'><p>Color coding legend for factors</p>
Modifies a list of lattice arguments (as for <code>levelplot</code>, etc.) according to
the factor levels. The colorkey will shows all levels (including unused), and the drawing colors
will be set accordingly.</a></li>
<li><a href='#vanderMonde'><p>Function evaluation on hyperSpec objects</p></a></li>
<li><a href='#wc'><p>line/word/character count of ASCII files</p></a></li>
<li><a href='#wl'><p>Getting and Setting the Wavelength Axis</p>
<code>wl</code> returns the wavelength axis, <code>wl&lt;-</code> sets it.</a></li>
<li><a href='#wl.eval'><p>Evaluate function on wavelengths of hyperSpec object</p></a></li>
<li><a href='#wl2i'><p>Conversion between Wavelength and Spectra Matrix Column</p>
Index <code>wl2i</code> returns the column indices for the spectra matrix for the given wavelengths.
<code>i2wl</code> converts column indices into wavelengths.</a></li>
<li><a href='#wlconv'><p>Convert different wavelength units</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Work with Hyperspectral Data, i.e. Spectra + Meta Information
(Spatial, Time, Concentration, ...)</td>
</tr>
<tr>
<td>Version:</td>
<td>0.100.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-01</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Claudia Beleites &lt;Claudia.Beleites@chemometrix.gmbh&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Comfortable ways to work with hyperspectral data sets.
    I.e. spatially or time-resolved spectra, or spectra with any other kind
    of information associated with each of the spectra. The spectra can be data
    as obtained in XRF, UV/VIS, Fluorescence, AES, NIR, IR, Raman, NMR, MS,
    etc. More generally, any data that is recorded over a discretized variable,
    e.g. absorbance = f(wavelength), stored as a vector of absorbance values
    for discrete wavelengths is suitable.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), lattice, grid, ggplot2 (&ge; 2.2.0), xml2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.matlab, deldir, rgl, plotrix, sp, baseline, compiler,
inline, Rcpp, MASS, fastcluster, pls, mvtnorm, digest, reshape,
devtools, R.rsp, tibble, knitr, rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>testthat, methods, utils, latticeExtra, lazyeval, dplyr, rlang</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-hyperspec.github.io/hyperSpec/">https://r-hyperspec.github.io/hyperSpec/</a> (documentation),
<a href="https://github.com/r-hyperspec/hyperSpec">https://github.com/r-hyperspec/hyperSpec</a> (code)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-hyperspec/hyperSpec/issues">https://github.com/r-hyperspec/hyperSpec/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'validate.R' 'hyperspec-class.R' 'unittest.R' 'paste.row.R'
'Arith.R' 'Compare.R' 'DollarNames.R' 'Math.R' 'chk.hy.R'
'read.txt.wide.R' 'read.txt.long.R' 'options.R' 'wl.R'
'fileio.optional.R' 'NEW-functions.R' 'Summary.R' 'aggregate.R'
'all.equal.R' 'apply.R' 'as.data.frame.R' 'barbiturates.R'
'bind.R' 'call.list.R' 'chondro.R' 'colMeans.R' 'collapse.R'
'count_lines.R' 'cov.R' 'decomposition.R' 'deprecated.R'
'dim.R' 'dimnames.R' 'droplevels.R' 'empty.R' 'wl2i.R'
'extract.R' 'factor2num.R' 'fix_spc_colnames.R' 'flu.R'
'getbynames.R' 'regexps.R' 'guesswavelength.R' 'paracetamol.R'
'laser.R' 'hyperspec-package.R' 'initialize.R' 'labels.R'
'plotmap.R' 'levelplot.R' 'makeraster.R' 'map.identify.R'
'map.sel.poly.R' 'mark.dendrogram.R' 'mark.peak.R'
'matlab.palette.R' 'mean_sd.R' 'merge.R' 'mvtnorm.R'
'normalize01.R' 'orderwl.R' 'pearson.dist.R' 'plot.R' 'plotc.R'
'plotmat.R' 'plotspc.R' 'plotvoronoi.R' 'qplot.R'
'qplotmixmap.R' 'quantile.R' 'rbind.fill.R' 'read.ENVI.R'
'read.ENVI.HySpex.R' 'read.ENVI.Nicolet.R' 'read.txt.Witec.R'
'read.asc.Andor.R' 'read.asc.PerkinElmer.R' 'read.ini.R'
'read.jdx.R' 'read.mat.Cytospec.R' 'read.mat.Witec.R'
'read.spc.Kaiser.R' 'read.spc.R' 'read.spc.Shimadzu.R'
'read.spe.R' 'read.txt.Horiba.R' 'read.txt.Renishaw.R'
'read.txt.Shimadzu.R' 'replace.R' 'sample.R' 'scale.R' 'seq.R'
'show.R' 'spc.NA.approx.R' 'spc.bin.R' 'spc.fit.poly.R'
'spc.identify.R' 'spc.loess.R' 'spc.rubberband.R'
'spc.spline.R' 'split.R' 'split.string.R' 'splitdots.R'
'subset.R' 'sweep.R' 'trellis.factor.key.R' 'units.R'
'vandermonde.R' 'wc.R' 'wleval.R' 'write.txt.long.R'
'write.txt.wide.R' 'y-pastenames.R' 'zzz.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-01 13:53:43 UTC; cb</td>
</tr>
<tr>
<td>Author:</td>
<td>Claudia Beleites <a href="https://orcid.org/0000-0003-1626-154X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, dtc],
  Valter Sergo [aut],
  Alois Bonifacio [ctb, dtc],
  Marcel Dahms [ctb],
  Björn Egert [ctb],
  Simon Fuller [ctb],
  Vilmantas Gegzna [aut],
  Rustam Guliev [ctb],
  Bryan A. Hanson [ctb],
  Michael Hermes [ctb],
  Martin Kammer [dtc],
  Roman Kiselev [ctb],
  Sebastian Mellor [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-01 16:02:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='hyperSpec-package'>Package hyperSpec</h2><span id='topic+hyperSpec-package'></span>

<h3>Description</h3>

<p>Interface for hyperspectral data sets
This package gives an interface to handle hyperspectral data sets in R.
Hyperspectral data are spatially or time-resolved spectra, or spectra with
any other kind of information associated with the spectra. E.g. spectral
maps or images, time series, calibration series, etc.
</p>


<h3>Details</h3>

<p>The spectra can be data as obtained in XRF, UV/VIS, Fluorescence, AES, NIR,
IR, Raman, NMR, MS, etc.
</p>
<p>More generally, any data that is recorded over a discretized variable, e.g.
absorbance = f (wavelength), stored as a vector of absorbance values for
discrete wavelengths is suitable.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>
<p>Maintainer: Claudia Beleites &lt;claudia.beleites@chemometrix.eu&gt;
</p>


<h3>See Also</h3>

<p><code>citation ("hyperSpec")</code> produces the correct citation.
</p>
<p><code>package?hyperSpec</code> for information about the package
</p>
<p><code>class?hyperSpec</code> for details on the S4 class provided by this
package.
</p>

<hr>
<h2 id='.cluster.wavelengths'>Find clusters of approximately equal wavelengths</h2><span id='topic+.cluster.wavelengths'></span>

<h3>Description</h3>

<p>Find clusters of approximately equal wavelengths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cluster.wavelengths(dots, wl.tolerance)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".cluster.wavelengths_+3A_dots">dots</code></td>
<td>
<p>list of hyperSpec objects to collapse</p>
</td></tr>
<tr><td><code id=".cluster.wavelengths_+3A_wl.tolerance">wl.tolerance</code></td>
<td>
<p>wavelength difference tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with information about suitable wavelength bins
</p>

<hr>
<h2 id='.collapse.equal'>Try finding groups of hyperSpec objects with (approximately) equal wavelength axes</h2><span id='topic+.collapse.equal'></span>

<h3>Description</h3>

<p>... and directly rbind.fill them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.collapse.equal(dots, wl.tolerance)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".collapse.equal_+3A_dots">dots</code></td>
<td>
<p>list with hyperSpec object to collapse</p>
</td></tr>
<tr><td><code id=".collapse.equal_+3A_wl.tolerance">wl.tolerance</code></td>
<td>
<p>wavelength difference tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>possible shorter list of dots
</p>

<hr>
<h2 id='.DollarNames.hyperSpec'>command line completion for $</h2><span id='topic+.DollarNames.hyperSpec'></span><span id='topic+.DollarNames'></span><span id='topic+.DollarNames+2ChyperSpec-method'></span>

<h3>Description</h3>

<p>command line completion for $
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hyperSpec'
.DollarNames(x, pattern = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".DollarNames.hyperSpec_+3A_x">x</code></td>
<td>
<p>the hyperSpecobject</p>
</td></tr>
<tr><td><code id=".DollarNames.hyperSpec_+3A_pattern">pattern</code></td>
<td>
<p>pattern to look for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the name of the extra data slot
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+.DollarNames">.DollarNames</a></code>
</p>

<hr>
<h2 id='.fileio.optional'>Helper function to harmonize treatment of file import results</h2><span id='topic+.fileio.optional'></span>

<h3>Description</h3>

<p>This function provides two ways of post-processing imported spectra:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.fileio.optional(
  spc,
  filename,
  ...,
  file.remove.emptyspc = hy.getOption("file.remove.emptyspc"),
  file.keep.name = hy.getOption("file.keep.name"),
  tolerance = hy.getOption("tolerance")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".fileio.optional_+3A_spc">spc</code></td>
<td>
<p>hyperSpec object for file import post-processing</p>
</td></tr>
<tr><td><code id=".fileio.optional_+3A_filename">filename</code></td>
<td>
<p>filename(s) to become extra data column of 'spc'</p>
</td></tr>
<tr><td><code id=".fileio.optional_+3A_...">...</code></td>
<td>
<p>(ignored)</p>
</td></tr>
<tr><td><code id=".fileio.optional_+3A_file.remove.emptyspc">file.remove.emptyspc</code></td>
<td>
<p>should empty (all 'NA' or all '0') spectra be
removed?</p>
</td></tr>
<tr><td><code id=".fileio.optional_+3A_file.keep.name">file.keep.name</code></td>
<td>
<p>should file names be kept and put into 'spc$filename'?</p>
</td></tr>
<tr><td><code id=".fileio.optional_+3A_tolerance">tolerance</code></td>
<td>
<p>intensities in +/- 'tolerance' are considered '0' for
'file.remove.emptyspc = TRUE'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>- optionally remove empty spectra (some spectrograph software will produce
empty spectra when measurements are cancelled)
- optionally keep the filenames in column 'spc$filename'
</p>
<p>The desired overall behavior can be set by options via [hy.setOptions()]. All
file import filters should call '.fileio.optional()' to ensure the same
behavior.
</p>


<h3>Value</h3>

<p>hyperSpec object
</p>

<hr>
<h2 id='.fix_spc_colnames'>Ensure that the spectra matrix has the wavelengths in column names</h2><span id='topic+.fix_spc_colnames'></span>

<h3>Description</h3>

<p>Ensure that the spectra matrix has the wavelengths in column names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.fix_spc_colnames(spc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".fix_spc_colnames_+3A_spc">spc</code></td>
<td>
<p>hyperSpec object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hyperSpec object with wavelengths in column names of <code style="white-space: pre;">&#8288;$spc&#8288;</code>
</p>

<hr>
<h2 id='.read.spe.xml'>Read XML footer from SPE file format version 3.0</h2><span id='topic+.read.spe.xml'></span>

<h3>Description</h3>

<p>The new SPE file format, introduced in 2012, was designed to be backwards compatible with the
previous format 2.5. The most prominent change is the new plain text XML footer holding vast
experimental metadata that gets attached at the end of the file. Thus, the file contains 3
blocks: a 4100-bytes long binary header, a chunk with spectral data, and the XML footer.
This function retrieves the XML footer converted to R list, and throws error if it is not available.
The file format specification is available at Princeton Instruments FTP server under name
'SPE 3.0 File Format Specification'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.read.spe.xml(filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".read.spe.xml_+3A_filename">filename</code></td>
<td>
<p>- SPE filename</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function relies on R package xml2 to work correctly
</p>


<h3>Value</h3>

<p>xml data from the file converted to R list
</p>

<hr>
<h2 id='.read.spe.xml_string'>.read.spe.xml_string</h2><span id='topic+.read.spe.xml_string'></span>

<h3>Description</h3>

<p>Read XML footer from SPE file format version 3.0 and return it as a long string
for subsequent parsing. Basically the purpose of this function is to check
that the file format version is 3.0 or above, and to find and read the
correct part of this file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.read.spe.xml_string(filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".read.spe.xml_string_+3A_filename">filename</code></td>
<td>
<p>- SPE filename</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string containing XML footer
</p>

<hr>
<h2 id='+5B+2ChyperSpec-method'>Extract and Replace parts of hyperSpec objects</h2><span id='topic++5B+2ChyperSpec-method'></span><span id='topic++5B'></span><span id='topic++5B+5B+2ChyperSpec-method'></span><span id='topic++5B+5B'></span><span id='topic++24+2ChyperSpec-method'></span><span id='topic++24'></span><span id='topic++5B+3C-'></span><span id='topic++5B+3C-+2ChyperSpec-method'></span><span id='topic++5B+5B+3C-'></span><span id='topic++5B+5B+3C-+2ChyperSpec-method'></span><span id='topic++24+3C-'></span><span id='topic++24+3C-+2ChyperSpec-method'></span>

<h3>Description</h3>

<p>These Methods allow to extract and replace parts of the <code>hyperSpec</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hyperSpec'
x[i, j, l, ..., wl.index = FALSE, drop = FALSE]

## S4 method for signature 'hyperSpec'
x[[i, j, l, ..., wl.index = FALSE, drop = FALSE]]

## S4 method for signature 'hyperSpec'
x$name

## S4 replacement method for signature 'hyperSpec'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'hyperSpec'
x[[i, j, l, wl.index = FALSE, ...]] &lt;- value

## S4 replacement method for signature 'hyperSpec'
x$name &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B5B+2B2ChyperSpec-method_+3A_x">x</code></td>
<td>
<p>a <code>hyperSpec</code> Object</p>
</td></tr>
<tr><td><code id="+2B5B+2B2ChyperSpec-method_+3A_i">i</code></td>
<td>
<p>row index: selects spectra
</p>
<p><code>[[</code> and <code>[[&lt;-</code> accept indexing with logical matrix or a n by 2
integer index matrix. In this case the indexing is done inside the
spectra matrix. See the examples below.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2ChyperSpec-method_+3A_j">j</code></td>
<td>
<p>selecting columns of <code>x@data</code></p>
</td></tr>
<tr><td><code id="+2B5B+2B2ChyperSpec-method_+3A_l">l</code></td>
<td>
<p>selecting columns of the spectra matrix. If <code>l</code> is numeric,
the default behaviour is treating <code>l</code> as wavelengths, <em>not</em> as
indices.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2ChyperSpec-method_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="+2B5B+2B2ChyperSpec-method_+3A_wl.index">wl.index</code></td>
<td>
<p>If <code>TRUE</code> (default), the value(s) in <code>l</code> are
treated as column indices for the spectral matrix. Otherwise, the numbers
in <code>l</code> are treated as wavelengths and the corresponding column
indices are looked up first via <code><a href="#topic+wl2i">wl2i</a></code>.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2ChyperSpec-method_+3A_drop">drop</code></td>
<td>
<p>For <code>[[</code>: drop unnecessary dimensions, see
<code><a href="base.html#topic+drop">drop</a></code> and <code><a href="base.html#topic+Extract">Extract</a></code>. Ignored for
<code>[</code>, as otherwise invalid <code>hyperSpec</code> objects might result.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2ChyperSpec-method_+3A_name">name</code></td>
<td>
<p>name of the data column to extract. <code>$spc</code> yields the spectra matrix.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2ChyperSpec-method_+3A_value">value</code></td>
<td>
<p>the replacement value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>They work with respect to the spectra (rows of <code>x</code>), the columns of the data matrix, and the
wavelengths (columns of the spectra matrix).
</p>
<p>Thus, they can be used for selecting/deleting spectra, cutting the spectral range, and extracting
or setting the data belonging to the spectra.
</p>
<p>Convenient shortcuts for access of the spectra matrix and the <code>data.frame</code> in slot
<code>data</code> are provided.
</p>
<p><em>Extracting: <code>[</code>, <code>[[</code>, and <code>$</code></em>.
</p>
<p>The version with single square brackets (<code>[</code>) returns the resulting <code>hyperSpec</code> object.
</p>
<p><code>[[</code> yields <code>data.frame</code> of slot <code>@data</code> of that corresponding <code>hyperSpec</code>
object returned with the same arguments by <code>[</code> if columns were selected (i.e. <code>j</code> is
given), otherwise the spectra <code>matrix</code> <code>x@data$spc</code>.
</p>
<p><code>$</code> returns the selected column of the <code>data.frame</code> in slot <code>@data</code>.
</p>
<p><em>Shortcuts.</em> Three shortcuts to conveniently extract much needed parts of the object are
defined:
</p>
<p><code>x[[]]</code> returns the spectra matrix.
</p>
<p><code>x$.</code> returns the complete slot <code>@data</code>, including the spectra matrix in column
<code>$spc</code>, as a <code>data.frame</code>.
</p>
<p><code>x$..</code> returns a <code>data.frame</code> like <code>x$.</code> but without the spectra matrix.
</p>
<p><em>Replacing: <code>[&lt;-</code>, <code>[[&lt;-</code>, and <code>$&lt;-</code></em>.
</p>
<pre>
## S4 method for signature 'hyperSpec':
x [i, j, l, \dots] &lt;- value

## S4 method for signature 'hyperSpec':
x [[i, j, l, wl.index = FALSE, \dots]] &lt;- value

## S4 method for signature 'hyperSpec':
x$name &lt;- value
</pre>
<p><code>value</code> gives the values to be assigned.<br />
</p>
<p>For <code>$</code>, this can also be a list of the form <code>list (value =
value, label = label)</code>, with <code>label</code> containing the label for data
column <code>name</code>.
</p>
<p><code>[[&lt;-</code> replaces parts of the spectra matrix.
</p>
<p><code>[&lt;-</code> replaces parts of the <code>data.frame</code> in slot <code>x@data</code>.
</p>
<p><code>$&lt;-</code> replaces a column of the <code>data.frame</code> in slot
<code>x@data</code>.  The <code>value</code> may be a list with two elements,
<code>value</code> and <code>label</code>.  In this case the label of the data column
is changed accordingly.
</p>
<p><code>$..&lt;-</code> is again an abbreviation for the data.frame without the
spectra matrix.
</p>


<h3>Value</h3>

<p>For <code>[</code>, <code>[&lt;-</code>, <code>[[&lt;-</code>, and <code>$&lt;-</code> a <code>hyperSpec</code> object,
</p>
<p>for <code>[[</code> a matrix or <code>data.frame</code>, and
</p>
<p>for <code>$</code> the column of the <code>data.frame</code> <code>@data</code>.
</p>
<p><code>x[[]]</code> returns the complete spectra matrix.
</p>
<p><code>x$.</code> returns the complete slot <code>@data</code>,
</p>
<p><code>x$..</code> returns the <code>data.frame</code> in <code>@data</code> but without the column
<code>@data$spc</code> containing the spectra matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wl2i">wl2i</a></code> on conversion of wavelength ranges to indices.
</p>
<p><code><a href="base.html#topic+drop">drop</a></code> and <code><a href="base.html#topic+Extract">Extract</a></code> on <code>drop</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## index into the rows (spectra) -------------------------------------
## make some "spectra"

## numeric index
plot (flu, "spc", lines.args = list (lty = 2))
plot (flu[1:3], "spc", add = TRUE, col = "red")     # select spectra
plot (flu[-(1:3)], "spc", add = TRUE, col = "blue") # delete spectra

## logic index
plot (flu, "spc", lines.args = list (lty = 2))
index &lt;- rnorm (6) &gt; 0
index
plot (flu[index], "spc", add = TRUE, col = "red")   # select spectra
plot (flu[!index], "spc", add = TRUE, col = "blue") # select spectra

## index into the data columns ---------------------------------------
range (chondro[[,"x"]])
colnames (chondro[[,1]])
dim (chondro[[,c(TRUE, FALSE, FALSE)]])
chondro$x


## the shortcut functions --------------------------------------------

## extract the spectra matrix
flu[[]]

## indexing via logical matrix
summary (flu [[flu &lt; 125]])

## indexing the spectra matrix with index matrix n by 2
ind &lt;- matrix (c (1, 2, 4, 406, 405.5, 409), ncol = 2)
ind
flu [[ind]]

ind &lt;- matrix (c (1, 2, 4, 4:6), ncol = 2)
ind
flu [[ind, wl.index = TRUE]]

pca &lt;- prcomp (flu[[]])

## result is data.frame, if j is given:
result &lt;- flu [[, 1:2, 405 ~ 410]]
result
class (result)
colnames (result)

## extract the data.frame including the spectra matrix
flu$.
dim(flu$.)
colnames (flu$.)
flu$.$spc

calibration &lt;- lm (spc ~ c, data = flu[,,450]$.)
calibration

flu$..
colnames (flu$..)

## replacement functions
spc &lt;- flu
spc$.
spc[, "c"] &lt;- 16 : 11
## be careful:
plot (spc)
spc [] &lt;- 6 : 1
spc$..
plot (spc)

spc &lt;- flu [,, 405 ~ 410]
spc [[]]
spc [[3]] &lt;- -spc[[3]]
spc [[]]
spc [[,,405 : 410]] &lt;- -spc[[,,405 : 410]]
spc [[]]
spc [[,,405 ~ 410]] &lt;- -spc[[,,405 ~ 410]]

## indexing with logical matrix
spc &lt;- flu [,, min ~ 410]
spc &lt; 125
spc [[spc &lt; 125]] &lt;- NA
spc [[]]

## indexing with n by 2 matrix
ind &lt;- matrix (c (1, 2, 4, 406, 405.5, 409), ncol = 2)
ind
spc [[ind]] &lt;- 3
spc [[]]

ind &lt;- matrix (c (1, 2, 4, 4:6), ncol = 2)
ind
spc [[ind, wl.index = TRUE]] &lt;- 9999
spc [[]]

spc$.
spc$z &lt;- 1 : 6
spc
spc$z &lt;- list (1 : 6, "z / a.u.")

</code></pre>

<hr>
<h2 id='aggregate'>aggregate hyperSpec objects</h2><span id='topic+aggregate'></span><span id='topic+aggregate+2ChyperSpec-method'></span><span id='topic+ave+2ChyperSpec-method'></span>

<h3>Description</h3>

<p>Compute summary statistics for subsets of a <code>hyperSpec</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hyperSpec'
aggregate(
  x,
  by = stop("by is needed"),
  FUN = stop("FUN is needed."),
  ...,
  out.rows = NULL,
  append.rows = NULL,
  by.isindex = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggregate_+3A_x">x</code></td>
<td>
<p>a <code>hyperSpec</code> object</p>
</td></tr>
<tr><td><code id="aggregate_+3A_by">by</code></td>
<td>
<p>grouping for the rows of <code>x@data</code>.
</p>
<p>Either a list containing an index vector for each of the subgroups or a
vector that can be <code>split</code> in such a list.</p>
</td></tr>
<tr><td><code id="aggregate_+3A_fun">FUN</code></td>
<td>
<p>function to compute the summary statistics</p>
</td></tr>
<tr><td><code id="aggregate_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>FUN</code></p>
</td></tr>
<tr><td><code id="aggregate_+3A_out.rows">out.rows</code></td>
<td>
<p>number of rows in the resulting <code>hyperSpec</code> object,
for memory preallocation.</p>
</td></tr>
<tr><td><code id="aggregate_+3A_append.rows">append.rows</code></td>
<td>
<p>If more rows are needed, how many should be appended?
</p>
<p>Defaults to 100 or an estimate based on the percentage of groups that are
still to be done, whatever is larger.</p>
</td></tr>
<tr><td><code id="aggregate_+3A_by.isindex">by.isindex</code></td>
<td>
<p>If a list is given in <code>by</code>: does the list already
contain the row indices of the groups? If <code>FALSE</code>, the list in
<code>by</code> is computed first (as in <code><a href="stats.html#topic+aggregate">aggregate</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>aggregate</code> applies <code>FUN</code> to each of the subgroups given by
<code>by</code>. It combines the functionality of <code><a href="stats.html#topic+aggregate">aggregate</a></code>,
<code><a href="base.html#topic+tapply">tapply</a></code>, and <code><a href="stats.html#topic+ave">ave</a></code> for hyperSpec
objects.
</p>
<p><code>aggregate</code> avoids splitting <code>x@data</code>.
</p>
<p><code>FUN</code> does not need to return exactly one value.  The number of
returned values needs to be the same for all wavelengths (otherwise the
result could not be a matrix), see the examples.
</p>
<p>If the initially preallocated <code>data.frame</code> turns out to be too small,
more rows are appended and a warning is issued.
</p>


<h3>Value</h3>

<p>A <code>hyperSpec</code> object with an additional column
<code>@data$.aggregate</code> tracing which group the rows belong to.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+tapply">tapply</a></code>, <code><a href="stats.html#topic+aggregate">aggregate</a></code>,
<code><a href="stats.html#topic+ave">ave</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cluster.means &lt;- aggregate (chondro, chondro$clusters, mean_pm_sd)
plot(cluster.means, stacked = ".aggregate", fill = ".aggregate",
     col = matlab.dark.palette (3))

## make some "spectra"
spc &lt;- new ("hyperSpec", spc = sweep (matrix (rnorm (10*20), ncol = 20), 1, (1:10)*5, "+"))

## 3 groups
color &lt;- c("red", "blue", "black")
by &lt;- as.factor (c (1, 1, 1, 1, 1, 1, 5, 1, 2, 2))
by
plot (spc, "spc", col = color[by])

## Example 1: plot the mean of the groups
plot (aggregate (spc, by, mean), "spc", col = color, add = TRUE,
      lines.args = list(lwd = 3, lty = 2))

## Example 2: FUN may return more than one value (here: 3)
plot (aggregate (spc, by, mean_pm_sd), "spc",
      col = rep(color, each = 3), lines.args = list(lwd = 3, lty = 2))

## Example 3: aggregate even takes FUN that return different numbers of
##            values for different groups
plot (spc, "spc", col = color[by])

weird.function &lt;- function (x){
   if (length (x) == 1)
      x + 1 : 10
   else if (length (x) == 2)
      NULL
   else
      x [1]
}

agg &lt;- aggregate (spc, by, weird.function)
agg$.aggregate
plot (agg, "spc",  add = TRUE, col = color[agg$.aggregate],
      lines.args = list (lwd = 3, lty = 2))

</code></pre>

<hr>
<h2 id='apply'>apply
Computes summary statistics for the spectra of a <code>hyperSpec</code> object.</h2><span id='topic+apply'></span><span id='topic+apply+2ChyperSpec-method'></span>

<h3>Description</h3>

<p><code>apply</code> gives the functionality of <code><a href="base.html#topic+apply">apply</a></code> for
<code>hyperSpec</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hyperSpec'
apply(
  X,
  MARGIN,
  FUN,
  ...,
  label.wl = NULL,
  label.spc = NULL,
  new.wavelength = NULL,
  simplify
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_+3A_x">X</code>, <code id="apply_+3A_spc">spc</code></td>
<td>
<p>a <code>hyperSpec</code> object</p>
</td></tr>
<tr><td><code id="apply_+3A_margin">MARGIN</code></td>
<td>
<p>The subscript which the function will be applied over.
</p>
<p><code>1</code> indicates rows (<code>FUN</code> is applied to each spectrum),
</p>
<p><code>2</code> indicates columns (<code>FUN</code> is applied to each wavelength),
</p>
<p><code>1 : 2</code> indicates that <code>FUN</code> should be applied to each single
element of the spectra matrix. Note that many basic mathematical
functions are already defined for hyperSpec objects (see
<code><a href="#topic+Math">Math</a></code>).
</p>
<p>If <code>MARGIN</code> is missing, the whole spectra matrix is handed to
<code>FUN</code>, see also the examples.</p>
</td></tr>
<tr><td><code id="apply_+3A_fun">FUN</code></td>
<td>
<p>function to compute the summary statistics</p>
</td></tr>
<tr><td><code id="apply_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>FUN</code></p>
</td></tr>
<tr><td><code id="apply_+3A_label.wl">label.wl</code>, <code id="apply_+3A_label.spc">label.spc</code></td>
<td>
<p>new labels for wavelength and spectral intensity
axes</p>
</td></tr>
<tr><td><code id="apply_+3A_new.wavelength">new.wavelength</code></td>
<td>
<p>for <code>MARGIN = 2</code>: numeric vector or name of the
argument in ... that is to be used (character) as wavelength axis of
the resulting object.</p>
</td></tr>
<tr><td><code id="apply_+3A_simplify">simplify</code></td>
<td>
<p>ignored: apply for hyperSpec results are always simplified</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic functions of group <code><a href="methods.html#topic+Math">Math</a></code> are not definded
for <code>hyperSpec</code> objects. Instead, <code>apply</code> can be used. For
functions like <code>log</code> that work on scalars, <code>MARGIN = 1 : 2</code> gives
the appropriate behaviour.
</p>
<p><code>spcapply</code> does the same as <code>apply</code> with <code>MARGIN = 1</code>, but
additionally allows to set a new wavelength axis and adjust the labels.
</p>
<p><code>wlapply</code> does the same as <code>apply</code> with <code>MARGIN = 2</code>, but
additionally allows to set a new wavelength axis and adjust the labels.
</p>


<h3>Value</h3>

<p>A <code>hyperSpec</code> object
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+apply">apply</a></code>, for applying <code>FUN</code> to subgroups of
the <code>hyperSpec</code> object: <code><a href="#topic+aggregate">aggregate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

plotspc (apply (chondro, 2, range))

avgflu &lt;- apply (flu, 1, mean,
                 label.spc = expression (bar (I)),
                 new.wavelength = mean (wl (flu)))
avgflu

flu[[,,405:407]]
apply (flu, 1:2, "*", -1)[[,,405:407]]

## without MARGIN the whole matrix is handed to FUN
apply (flu [,,405:407], , print) [[]]

## whereas MARGIN = 1 : 2 leads to FUN being called for each element separately
apply (flu [,,405:407], 1 : 2, print) [[]]

</code></pre>

<hr>
<h2 id='Arith'>Arithmetical Operators for hyperSpec objects</h2><span id='topic+Arith'></span><span id='topic+Arith+2ChyperSpec-method'></span><span id='topic+Arith+2ChyperSpec+2ChyperSpec-method'></span><span id='topic++2B+2ChyperSpec+2ChyperSpec-method'></span><span id='topic+-+2ChyperSpec+2ChyperSpec-method'></span><span id='topic++2A+2ChyperSpec+2ChyperSpec-method'></span><span id='topic++5E+2ChyperSpec+2ChyperSpec-method'></span><span id='topic++25+25+2ChyperSpec+2ChyperSpec-method'></span><span id='topic++25+2F+25+2ChyperSpec+2ChyperSpec-method'></span><span id='topic++2F+2ChyperSpec+2ChyperSpec-method'></span><span id='topic+Arith+2ChyperSpec+2Cmatrix-method'></span><span id='topic+Arith+2ChyperSpec+2Cnumeric-method'></span><span id='topic+Arith+2ChyperSpec+2Cmissing-method'></span><span id='topic+Arith+2Cmatrix+2ChyperSpec-method'></span><span id='topic+Arith+2Cnumeric+2ChyperSpec-method'></span><span id='topic++25+2A+25'></span><span id='topic++25+2A+25+2ChyperSpec+2ChyperSpec-method'></span><span id='topic++25+2A+25+2Cmatrix+2ChyperSpec-method'></span><span id='topic++25+2A+25+2ChyperSpec+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Arithmetical Operators: +, -, *, /, ^, %%, %/%, %*% for hyperSpec objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hyperSpec,hyperSpec'
Arith(e1, e2)

## S4 method for signature 'hyperSpec,numeric'
Arith(e1, e2)

## S4 method for signature 'hyperSpec,matrix'
Arith(e1, e2)

## S4 method for signature 'hyperSpec,missing'
Arith(e1, e2)

## S4 method for signature 'numeric,hyperSpec'
Arith(e1, e2)

## S4 method for signature 'matrix,hyperSpec'
Arith(e1, e2)

## S4 method for signature 'hyperSpec,hyperSpec'
x %*% y

## S4 method for signature 'hyperSpec,matrix'
x %*% y

## S4 method for signature 'matrix,hyperSpec'
x %*% y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Arith_+3A_e1">e1</code>, <code id="Arith_+3A_e2">e2</code></td>
<td>
<p>or</p>
</td></tr>
<tr><td><code id="Arith_+3A_x">x</code>, <code id="Arith_+3A_y">y</code></td>
<td>
<p>either two <code>hyperSpec</code> objects or
</p>
<p>one <code>hyperSpec</code> object and  matrix of same size as <code>hyperSpec[[]]</code> or
</p>
<p>a vector which length equalling either the number of rows or the number of wavelengths
of the hyperSpec object, or
</p>
<p>a scalar (numeric of length 1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arithmetical operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>\^</code>, <code>%%</code>,
<code>%/%</code>,  and <code>%*%</code> for <code>hyperSpec</code> objects.
</p>
<p>You can use these operators in different ways:
</p>
<pre>
e1 + e2
`+` (e1, e2)

x %*% y
`%*%`(x, y)

-x </pre>
<p>The arithmetical operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>, <code>%%</code>,
<code>%/%</code>, and <code>%*%</code> work on the  spectra matrix of the <code>hyperSpec</code> object. They
have their usual meaning (see <code><a href="base.html#topic+Arithmetic">Arithmetic</a></code>).  The operators work also with one
<code>hyperSpec</code> object and a numeric object or a matrices of the same size as the spectra matrix
of the <code>hyperSpec</code> object.
</p>
<p>With numeric vectors <code><a href="#topic+sweep">sweep</a></code> is most probably more appropriate.
</p>
<p>If you want to calculate on the extra data as well, use the data.frame <code>hyperSpec@data</code>
directly or <code><a href="#topic+as.data.frame">as.data.frame</a> (x)</code>.
</p>


<h3>Value</h3>

<p><code>hyperSpec</code> object with the new spectra matrix.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sweep-methods">sweep-methods</a></code> for calculations involving a vector and
the spectral matrix.
</p>
<p><code><a href="methods.html#topic+S4groupGeneric">S4groupGeneric</a></code> for group generic methods.
</p>
<p><code><a href="base.html#topic+Arithmetic">Arithmetic</a></code> for the base arithmetic functions.
</p>
<p><code><a href="#topic+Comparison">Comparison</a></code> for comparison operators,
<code><a href="#topic+Math">Math</a></code> for mathematical group generic
functions (Math and Math2 groups) working on <code>hyperSpec</code> objects.
</p>
<p><code><a href="base.html#topic+matmult">matmult</a></code> for matrix multiplications with <code>%*%</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>flu + flu
1 / flu
all((flu + flu - 2 * flu)[[]] == 0)
-flu
flu / flu$c
</code></pre>

<hr>
<h2 id='as.character+2ChyperSpec-method'>Convert a hyperSpec object to character strings for Display
<code>print</code>, <code>show</code>, and <code>summary</code> show the result of
<code>as.character</code>.</h2><span id='topic+as.character+2ChyperSpec-method'></span><span id='topic+as.character'></span><span id='topic+show'></span><span id='topic+show+2ChyperSpec-method'></span><span id='topic+print+2ChyperSpec-method'></span><span id='topic+print'></span><span id='topic+summary+2ChyperSpec-method'></span><span id='topic+summary'></span>

<h3>Description</h3>

<p><code>print</code>, <code>show</code>, and <code>summary</code> differ only in the defaults.
<code>show</code> displays the range of values instead,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hyperSpec'
as.character(
  x,
  digits = getOption("digits"),
  range = TRUE,
  max.print = 5,
  shorten.to = c(2, 1)
)

## S4 method for signature 'hyperSpec'
show(object)

## S4 method for signature 'hyperSpec'
print(x, range = FALSE, ...)

## S4 method for signature 'hyperSpec'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.character+2B2ChyperSpec-method_+3A_x">x</code></td>
<td>
<p>a <code>hyperSpec</code> object</p>
</td></tr>
<tr><td><code id="as.character+2B2ChyperSpec-method_+3A_digits">digits</code></td>
<td>
<p>number of digits handed over to <code>format</code></p>
</td></tr>
<tr><td><code id="as.character+2B2ChyperSpec-method_+3A_range">range</code></td>
<td>
<p>should the values be indicated as range rather then first and
last elements?</p>
</td></tr>
<tr><td><code id="as.character+2B2ChyperSpec-method_+3A_max.print">max.print</code></td>
<td>
<p>maximum number of elements to be printed (of a variable)</p>
</td></tr>
<tr><td><code id="as.character+2B2ChyperSpec-method_+3A_shorten.to">shorten.to</code></td>
<td>
<p>if a vector is longer than <code>max.print</code>, only the
first <code>shorten.to[1]</code> and the last <code>shorten.to[2]</code> elements are
printed</p>
</td></tr>
<tr><td><code id="as.character+2B2ChyperSpec-method_+3A_object">object</code></td>
<td>
<p>a <code>hyperSpec</code> object</p>
</td></tr>
<tr><td><code id="as.character+2B2ChyperSpec-method_+3A_...">...</code></td>
<td>
<p><code>print</code> and <code>summary</code>  hand further arguments to <code>as.character</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.character</code> returns a character vector fit to be printed by
<code>cat</code> with <code>sep = "\n"</code>.
</p>
<p><code>print</code> invisibly returns <code>x</code> after printing, <code>show</code> returns
an invisible <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.character">as.character</a></code>
</p>
<p><code><a href="methods.html#topic+show">show</a></code>
</p>
<p><code><a href="base.html#topic+print">print</a></code>
</p>
<p><code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
chondro

show (chondro)

summary (chondro)

print (chondro, range = TRUE)

</code></pre>

<hr>
<h2 id='as.data.frame'>Conversion of a hyperSpec object into a data.frame or matrix
<code>as.data.frame</code> returns <code>x@data</code> (as data.frame) <code>as.matrix</code>
returns the spectra matrix <code>x@data$spc</code> as matrix</h2><span id='topic+as.data.frame'></span><span id='topic+as.data.frame.hyperSpec'></span><span id='topic+as.data.frame+2ChyperSpec-method'></span><span id='topic+as.matrix.hyperSpec'></span><span id='topic+as.matrix'></span><span id='topic+as.matrix+2ChyperSpec-method'></span><span id='topic+as.wide.df'></span><span id='topic+as.long.df'></span><span id='topic+as.t.df'></span>

<h3>Description</h3>

<p>The data.frame returned by <code>as.long.df</code> is guaranteed to have columns
<code>spc</code> and <code>.wavelength</code>. If <code>nwl (x) == 0</code> these columns
will be <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hyperSpec'
as.data.frame(x, row.names = TRUE, optional = NULL, ...)

## S3 method for class 'hyperSpec'
as.matrix(x, ...)

as.wide.df(x, wl.prefix = "")

as.long.df(x, rownames = FALSE, wl.factor = FALSE, na.rm = TRUE)

as.t.df(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame_+3A_x">x</code></td>
<td>
<p>a <code>hyperSpec</code> object</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_row.names">row.names</code></td>
<td>
<p>if <code>TRUE</code>, a column <code>.row</code> is created containing row names or row
indices if no rownames are set. If character vector, the rownames are set accordingly.</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_optional">optional</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_wl.prefix">wl.prefix</code></td>
<td>
<p>prefix to prepend wavelength column names</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_rownames">rownames</code></td>
<td>
<p>should the rownames be in column <code>.rownames</code> of the
long-format data.frame?</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_wl.factor">wl.factor</code></td>
<td>
<p>should the wavelengths be returned as a factor (instead of
numeric)?</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_na.rm">na.rm</code></td>
<td>
<p>if <code>TRUE</code>, rows where spc is not <code>NA</code> are deleted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x@data</code> and <code>x@data$spc</code> (== <code>x$spc</code> == <code>x [[]]</code>), respectively.
</p>
<p><code>as.wide.df</code> returns a data.frame that consists of the extra data and
the spectra matrix converted to a data.frame. The spectra matrix is
expanded <em>in place</em>.
</p>
<p><code>as.long.df</code> returns the stacked or molten version of <code>x@data</code>. The
wavelengths are in column <code>.wavelength</code>.
</p>
<p><code>as.t.df</code> returns a data.frame similar to <code>as.long.df</code>, but each
spectrum in its own column. This is useful for exporting summary spectra,
see the example.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>
</p>
<p>and <code><a href="base.html#topic+matrix">base::as.matrix()</a></code>
</p>
<p>[<code>[[</code>()] (<code style="white-space: pre;">&#8288;[[]]&#8288;</code>) for a shortcut to <code>as.matrix</code>
</p>
<p><code><a href="utils.html#topic+stack">stack</a></code> and <code><a href="reshape.html#topic+melt">melt</a></code> or <code>reshape2::melt()</code> for
other functions producing long-format data.frames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
as.data.frame (chondro [1:3,, 600 ~ 620])
as.matrix (chondro [1:3,, 600 ~ 620])
lm (c ~ spc, data = flu [,,450])

as.wide.df (chondro [1:5,, 600 ~ 610])
summary (as.wide.df (chondro [1:5,, 600 ~ 610]))

as.long.df (flu [,, 405 ~ 410])
summary (as.long.df (flu [,, 405 ~ 410]))
summary (as.long.df (flu [,, 405 ~ 410], rownames = TRUE))
summary (as.long.df (flu [,, 405 ~ 410], wl.factor = TRUE))

df &lt;- as.t.df (apply (chondro, 2, mean_pm_sd))
head (df)

if (require (ggplot2)){
  ggplot (df, aes (x = .wavelength)) +
    geom_ribbon (aes (ymin = mean.minus.sd, ymax = mean.plus.sd),
      fill = "#00000040") +
    geom_line (aes (y = mean))
}
</code></pre>

<hr>
<h2 id='as.hyperSpec'>as.hyperSpec: convenience conversion functions</h2><span id='topic+as.hyperSpec'></span><span id='topic+as.hyperSpec+2Cmatrix-method'></span><span id='topic+as.hyperSpec+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>These functions are shortcuts to convert other objects into hypeSpec objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.hyperSpec(X, ...)

## S4 method for signature 'matrix'
as.hyperSpec(X, wl = guess.wavelength(colnames(X)), ...)

## S4 method for signature 'data.frame'
as.hyperSpec(
  X,
  spc = NULL,
  wl = guess.wavelength(spc),
  labels = attr(X, "labels"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.hyperSpec_+3A_x">X</code></td>
<td>
<p>the object to convert.
A matrix is assumed to contain the spectra matrix,
a data.frame is assumed to contain extra data.</p>
</td></tr>
<tr><td><code id="as.hyperSpec_+3A_...">...</code></td>
<td>
<p>additional parameters that should be handed over to <code>new ("hyperSpec")</code> (initialize)</p>
</td></tr>
<tr><td><code id="as.hyperSpec_+3A_wl">wl</code></td>
<td>
<p>wavelength vector. Defaults to guessing from the column names in <code>X</code></p>
</td></tr>
<tr><td><code id="as.hyperSpec_+3A_spc">spc</code></td>
<td>
<p>spectra matrix</p>
</td></tr>
<tr><td><code id="as.hyperSpec_+3A_labels">labels</code></td>
<td>
<p>list with labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hyperSpec object
</p>


<h3>Note</h3>

<p><em>Note that the behaviour of <code>as.hyperSpec (X)</code> was changed: it now assumes <code>X</code> to be extra data,
and returns a hyperSpec object with 0 wavelengths. To get the old behaviour</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+initialize">initialize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- data.frame(flu [[,, 400 ~ 410]])
(wl &lt;- colnames (tmp))
guess.wavelength (wl)
</code></pre>

<hr>
<h2 id='barbiturates'>Barbiturates Spectra from .spc example files
A time series of mass spectra in a list of hyperSpec objects.</h2><span id='topic+barbiturates'></span>

<h3>Description</h3>

<p>Barbiturates Spectra from .spc example files
A time series of mass spectra in a list of hyperSpec objects.
</p>


<h3>Format</h3>

<p>The data sets consists of 286 spectra. They are the result of importing the
BARBITUATES.SPC example data from Thermo Galactic's spc file format specification.
</p>


<h3>Author(s)</h3>

<p>C. Beleites and Thermo Galactic
</p>


<h3>References</h3>

<p>The raw data is available at <a href="http://hyperspec.r-forge.r-project.org/blob/fileio.zip">http://hyperspec.r-forge.r-project.org/blob/fileio.zip</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
barbiturates [1:3]
length (barbiturates)

barb &lt;- collapse (barbiturates, collapse.equal = FALSE)
barb &lt;- orderwl (barb)

plot (barb [1:3], lines.args = list (type = "h"),
      col = matlab.dark.palette (3), stacked = TRUE,
      stacked.args = list (add.factor = .2))

if (require (latticeExtra)){
levelplot (spc ~ .wavelength * z, log (barb), panel = panel.levelplot.points,
   cex = 0.3, col = "#00000000", col.regions = matlab.palette (20))
}

plotc (apply (barb [,, 42.9~43.2], 1, sum, na.rm = TRUE), spc ~ z,
       panel = panel.lines, ylab = expression (I[m/z == 43] / "a.u."))

</code></pre>

<hr>
<h2 id='bind'>Binding hyperSpec Objects</h2><span id='topic+bind'></span><span id='topic+cbind.hyperSpec'></span><span id='topic+rbind.hyperSpec'></span><span id='topic+cbind2+2ChyperSpec+2ChyperSpec-method'></span><span id='topic+rbind2+2ChyperSpec+2ChyperSpec-method'></span><span id='topic+cbind2+2ChyperSpec+2Cmissing-method'></span><span id='topic+rbind2+2ChyperSpec+2Cmissing-method'></span>

<h3>Description</h3>

<p>The former difficulties with binding S4 objects
are resolved since R version 3.2.0 and <code>cbind</code> and <code>rbind</code> now work as intended and
expected for hyperSpec objects.
</p>
<p><code>cbind2</code> binds the spectral matrices of two <code>hyperSpec</code> objects by column. All columns
besides <code>spc</code> with the same name in <code>x@data</code> and <code>y@data</code> must have the same
elements.  Rows are ordered before checking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind(
  direction = stop("direction ('c' or 'r') required"),
  ...,
  wl.tolerance = hy.getOption("wl.tolerance")
)

## S3 method for class 'hyperSpec'
cbind(...)

## S3 method for class 'hyperSpec'
rbind(...)

## S4 method for signature 'hyperSpec,hyperSpec'
cbind2(x, y)

## S4 method for signature 'hyperSpec,missing'
cbind2(x, y)

## S4 method for signature 'hyperSpec,hyperSpec'
rbind2(x, y, wl.tolerance = hy.getOption("wl.tolerance"))

## S4 method for signature 'hyperSpec,missing'
rbind2(x, y, wl.tolerance)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bind_+3A_direction">direction</code></td>
<td>
<p>&quot;r&quot; or &quot;c&quot; to bind rows or columns</p>
</td></tr>
<tr><td><code id="bind_+3A_...">...</code></td>
<td>
<p>The <code>hyperSpec</code> objects to be combined.
</p>
<p>Alternatively, <em>one</em> list of <code>hyperSpec</code> objects can be given to
<code>bind</code>.</p>
</td></tr>
<tr><td><code id="bind_+3A_wl.tolerance">wl.tolerance</code></td>
<td>
<p><code>rbind</code> and <code>rbind2</code> check for equal wavelengths
with this tolerance.</p>
</td></tr>
<tr><td><code id="bind_+3A_x">x</code>, <code id="bind_+3A_y">y</code></td>
<td>
<p><code>hyperSpec</code> objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, calling <code>rbind.hyperSpec</code> and
<code>cbind.hyperSpec</code> is now depecated: <code>cbind</code> and <code>rbind</code> should now be called
directly.
</p>
<p>However, in consequence it is no longer possible to call <code>cbind</code> or <code>rbind</code> with a
list of hyperSpec objects. In that case, use <code>bind</code> or <code><a href="base.html#topic+do.call">do.call</a></code> (see example).
</p>
<p><code>bind</code> does the common work for both column- and row-wise binding.
</p>


<h3>Value</h3>

<p>a <code>hyperSpec</code> object, possibly with different row order (for
<code>bind ("c", ...{})</code> and <code>cbind2</code>).
</p>


<h3>Note</h3>

<p>You might have to make sure that the objects either all have or all
do not have rownames and/or colnames.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="methods.html#topic+rbind2">rbind2</a></code>, <code><a href="methods.html#topic+cbind2">cbind2</a></code>
<code><a href="base.html#topic+rbind">rbind</a></code>, <code><a href="base.html#topic+cbind">cbind</a></code>
</p>
<p><code><a href="#topic+merge">merge</a></code> and <code><a href="#topic+collapse">collapse</a></code> for combining objects that do not share spectra
or wavelengths, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
chondro
bind ("r", chondro, chondro)
rbind (chondro, chondro)
cbind (chondro, chondro)
bind ("r", list (chondro, chondro, chondro))

x &lt;- chondro[,, 600 : 605]
x$a &lt;- 1
x@data &lt;- x@data[, sample (ncol (x), ncol (x))] # reorder columns

y &lt;- chondro [nrow (chondro) : 1,, 1730 : 1750] # reorder rows
y$b &lt;- 2

cbind2 (x, y) # works

y$y[3] &lt;- 5
try (cbind2 (x, y)) # error

# list of hyperSpec objects

lhy &lt;- list (flu, flu)
do.call ("rbind", lhy)
bind ("r", lhy)
</code></pre>

<hr>
<h2 id='chk.hy'>Validation of hyperSpec objects</h2><span id='topic+chk.hy'></span><span id='topic+validObject'></span><span id='topic+validObject+2ChyperSpec-method'></span>

<h3>Description</h3>

<p>Check whether an object is a hyperSpec object and validate the object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chk.hy(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chk.hy_+3A_object">object</code></td>
<td>
<p>the object to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the check passes, otherwise stop with an
error.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="methods.html#topic+validObject">validObject</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chk.hy (chondro)
validObject (chondro)
</code></pre>

<hr>
<h2 id='chondro'>Raman spectra of 2 Chondrocytes in Cartilage
A Raman-map (laterally resolved Raman spectra) of chondrocytes in
cartilage.</h2><span id='topic+chondro'></span>

<h3>Description</h3>

<p>See the vignette <code>vignette ("chondro", package = "hyperSpec")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chondro
</code></pre>


<h3>Format</h3>

<p>The data set has 875 Raman spectra measured on a 25 <code class="reqn">\times</code>
35 grid with 1 micron step size. Spatial information is in
<code>chondro$x</code> and <code>chondro$y</code>. Each spectrum has 300 data points
in the range of ca. 600 - 1800 cm<code class="reqn">^{-1}</code>.
</p>


<h3>Author(s)</h3>

<p>A. Bonifacio and C. Beleites
</p>


<h3>References</h3>

<p>The raw data is available at <a href="http://hyperspec.r-forge.r-project.org/blob/chondro.zip">http://hyperspec.r-forge.r-project.org/blob/chondro.zip</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

chondro

## do baseline correction
baselines &lt;- spc.fit.poly.below (chondro)
chondro &lt;- chondro - baselines

## area normalization
chondro &lt;- chondro / colMeans (chondro)

## substact common composition
chondro &lt;- chondro - quantile (chondro, 0.05)

cols &lt;- c ("dark blue", "orange", "#C02020")
plotmap (chondro, clusters ~ x * y, col.regions = cols)

cluster.means &lt;- aggregate (chondro, chondro$clusters, mean_pm_sd)
plot (cluster.means, stacked = ".aggregate", fill = ".aggregate", col = cols)

## plot nucleic acid bands
plotmap (chondro[, , c( 728, 782, 1098, 1240, 1482, 1577)],
       col.regions = colorRampPalette (c ("white", "gold", "dark green"), space = "Lab") (20))

</code></pre>

<hr>
<h2 id='collapse'>Collapse hyperSpec objects</h2><span id='topic+collapse'></span><span id='topic+collapse.hyperSpec'></span>

<h3>Description</h3>

<p>collapse/bind several hyperSpec objects into one object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse(
  ...,
  wl.tolerance = hy.getOption("wl.tolerance"),
  collapse.equal = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collapse_+3A_...">...</code></td>
<td>
<p>hyperSpec objects to be collapsed into one object. Instead of giving several
arguments, a list with all objects to be collapsed may be given.</p>
</td></tr>
<tr><td><code id="collapse_+3A_wl.tolerance">wl.tolerance</code></td>
<td>
<p>tolerance to decide which wavelengths are considered equal.</p>
</td></tr>
<tr><td><code id="collapse_+3A_collapse.equal">collapse.equal</code></td>
<td>
<p>logical indicating whether to try first finding groups of spectra
with (approximately) equal wavelength axes. If the data is known to contain few or no
such groups, <code>collapse()</code> will be faster with this first pass being turned off.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spectra from all objects will be put into one object.
The resulting object has all wavelengths that occur in any of the input objects,
<code>wl.tolerance</code> is used to determine which difference in the wavelengths is
tolerated as equal: clusters of approximately equal wavelengths will span at most <code>2 * wl.tolerance</code>.
Differences up to +/- <code>wl.tolerance</code> are considered equal.
</p>
<p>The returned object has wavelengths that are the weighted average
(by number of spectra) of the wavelengths within any such cluster of approximately
equal wavelengths.
</p>
<p>Labels will be taken from the first object where they are encountered. However,
the order of processing objects is not necessarily the same as the order of objects
in the input: <code>collapse</code> first processes groups of input objects that share all
wavelengths (within <code>wl.tolerance</code>).
</p>
<p>Data points corresponding to wavelengths not in the original spectrum will be set to NA.
Extra data is combined in the same manner.
</p>
<p>If the objects are named, the names will be preserved in extra data column <code style="white-space: pre;">&#8288;$.name&#8288;</code>.
If the wavelengths are names, names are preserved and taken from the first object where they were encountered,
the same applies to possible column names of the spectra matrix.
</p>


<h3>Value</h3>

<p>a hyperSpec object
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="#topic+merge">merge()</a></code>,  <code><a href="base.html#topic+rbind">rbind()</a></code>, and <code>plyr::rbind.fill()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>barbiturates [1:3]
collapse (barbiturates [1:3])

a &lt;- barbiturates [[1]]
b &lt;- barbiturates [[2]]
c &lt;- barbiturates [[3]]

a
b
c
collapse (a, b, c)

collapse (barbiturates [1:3], collapse.equal = FALSE)

</code></pre>

<hr>
<h2 id='colSums'>colSums, colMeans, rowSums and rowMeans functions for hyperSpec objects</h2><span id='topic+colSums'></span><span id='topic+colMeans+2ChyperSpec-method'></span><span id='topic+colSums+2ChyperSpec-method'></span><span id='topic+rowMeans+2ChyperSpec-method'></span><span id='topic+rowSums+2ChyperSpec-method'></span>

<h3>Description</h3>

<p>hyperSpec objects can use the base functions <code><a href="base.html#topic+colMeans">colMeans</a></code>,
<code><a href="base.html#topic+colSums">colSums</a></code>, <code><a href="base.html#topic+rowMeans">rowMeans</a></code> and <code><a href="base.html#topic+rowSums">rowSums</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hyperSpec'
colMeans(x, na.rm = TRUE, ..., label.spc)

## S4 method for signature 'hyperSpec'
colSums(x, na.rm = TRUE, ..., label.spc)

## S4 method for signature 'hyperSpec'
rowMeans(x, na.rm = TRUE, ..., label.wavelength)

## S4 method for signature 'hyperSpec'
rowSums(x, na.rm = TRUE, ..., label.wavelength)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colSums_+3A_x">x</code></td>
<td>
<p>hyperSpec object</p>
</td></tr>
<tr><td><code id="colSums_+3A_na.rm">na.rm</code>, <code id="colSums_+3A_...">...</code></td>
<td>
<p>further parameters to the base functions
</p>
<p><code>na.rm</code> defaults to <code>TRUE</code> for hyperSpec objects.</p>
</td></tr>
<tr><td><code id="colSums_+3A_label.spc">label.spc</code></td>
<td>
<p>labels for the intensity axis for loadings-like (col) statistics</p>
</td></tr>
<tr><td><code id="colSums_+3A_label.wavelength">label.wavelength</code></td>
<td>
<p>labels for the wavelength axis for scores-like (row) statistics</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="base.html#topic+colSums">colSums</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colMeans (flu)
colSums (flu)
colSums (flu)
rowSums (flu)
</code></pre>

<hr>
<h2 id='Comparison'>Comparison of hyperSpec objects</h2><span id='topic+Comparison'></span><span id='topic+Operators'></span><span id='topic+Compare+2ChyperSpec-method'></span><span id='topic+Compare+2ChyperSpec+2ChyperSpec-method'></span><span id='topic++3C+2ChyperSpec+2ChyperSpec-method'></span><span id='topic++3E+2ChyperSpec+2ChyperSpec-method'></span><span id='topic++3C+3D+2ChyperSpec+2ChyperSpec-method'></span><span id='topic++3E+3D+2ChyperSpec+2ChyperSpec-method'></span><span id='topic++3D+3D+2ChyperSpec+2ChyperSpec-method'></span><span id='topic++21+3D+2ChyperSpec+2ChyperSpec-method'></span><span id='topic+Compare+2ChyperSpec+2Cmatrix-method'></span><span id='topic+Compare+2ChyperSpec+2Cnumeric-method'></span><span id='topic+Compare+2Cmatrix+2ChyperSpec-method'></span><span id='topic+Compare+2Cnumeric+2ChyperSpec-method'></span><span id='topic+all.equal+2ChyperSpec+2ChyperSpec-method'></span><span id='topic+all.equal'></span>

<h3>Description</h3>

<p>The comparison operators <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>,
<code>==</code>, and <code>!=</code> for <code>hyperSpec</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hyperSpec,hyperSpec'
Compare(e1, e2)

## S4 method for signature 'hyperSpec,numeric'
Compare(e1, e2)

## S4 method for signature 'hyperSpec,matrix'
Compare(e1, e2)

## S4 method for signature 'numeric,hyperSpec'
Compare(e1, e2)

## S4 method for signature 'matrix,hyperSpec'
Compare(e1, e2)

## S4 method for signature 'hyperSpec,hyperSpec'
all.equal(
  target,
  current,
  ...,
  check.attributes = FALSE,
  check.names = FALSE,
  check.column.order = FALSE,
  check.label = FALSE,
  tolerance = hy.getOption("tolerance"),
  wl.tolerance = hy.getOption("wl.tolerance")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Comparison_+3A_e1">e1</code>, <code id="Comparison_+3A_e2">e2</code></td>
<td>
<p>Either two <code>hyperSpec</code> objects or one <code>hyperSpec</code>
object and matrix of same size as <code>hyperSpec[[]]</code> or a scalar
(numeric of length 1).
</p>
<p>As <code>hyperSpec</code> objects must have numeric spectra matrices, the
resulting matrix of the comparison is returned directly.</p>
</td></tr>
<tr><td><code id="Comparison_+3A_target">target</code>, <code id="Comparison_+3A_current">current</code></td>
<td>
<p>two <code>hyperSpec</code> objects that are tested for
equality</p>
</td></tr>
<tr><td><code id="Comparison_+3A_...">...</code></td>
<td>
<p>handed to <code><a href="base.html#topic+all.equal">all.equal</a></code> when testing the slots of the
<code>hyperSpec</code> objects</p>
</td></tr>
<tr><td><code id="Comparison_+3A_check.attributes">check.attributes</code>, <code id="Comparison_+3A_check.names">check.names</code></td>
<td>
<p>see <code><a href="base.html#topic+all.equal">all.equal</a></code></p>
</td></tr>
<tr><td><code id="Comparison_+3A_check.column.order">check.column.order</code></td>
<td>
<p>If two objects have the same data, but the order
of the columns (determined by the names) differs, should they be regarded
as different?</p>
</td></tr>
<tr><td><code id="Comparison_+3A_check.label">check.label</code></td>
<td>
<p>Should the slot <code>label</code> be checked? <br /> If the
labels differ only in the order of their entries, they are conidered
equal.</p>
</td></tr>
<tr><td><code id="Comparison_+3A_tolerance">tolerance</code>, <code id="Comparison_+3A_wl.tolerance">wl.tolerance</code></td>
<td>
<p>tolerances for checking wavelengths and data, respectively</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>all.equal</code> checks the equality of two hyperSpec objects.
</p>
<p>The comparison operators <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>,
<code>==</code>, and <code>!=</code> work on the spectra matrix of the <code>hyperSpec</code>
object. They have their usual meaning (see <code><a href="base.html#topic+Comparison">Comparison</a></code>).
The operators work also with one <code>hyperSpec</code> object and a numeric
(scalar) object or a matrices of the same size as the spectra matrix of the
<code>hyperSpec</code> object.
</p>
<p>With numeric vectors <code><a href="#topic+sweep">sweep</a></code> might be more
appropriate.
</p>
<p>If you want to calculate on the <code>data.frame</code> <code>hyperSpec@data</code>,
you have to do this directly on <code>hyperSpec@data</code>.
</p>


<h3>Value</h3>

<p>a logical matrix for the comparison operators.
</p>
<p><code>all.equal</code> returns either <code>TRUE</code>, or a character vector describing the
differences. In conditions, the result must therefore be tested with
<code><a href="base.html#topic+isTRUE">isTRUE</a></code>.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sweep-methods">sweep-methods</a></code> for calculations involving
a vector and the spectral matrix.
</p>
<p><code><a href="methods.html#topic+S4groupGeneric">S4groupGeneric</a></code> for group generic methods.
</p>
<p><code><a href="base.html#topic+Comparison">Comparison</a></code> for the base comparison functions.
</p>
<p><code><a href="#topic+Arith">Arith</a></code> for arithmetic operators,
<code><a href="#topic+Math">Math</a></code> for mathematical group generic functions
(groups Math and Math2) working on <code>hyperSpec</code> objects.
</p>
<p><code><a href="base.html#topic+all.equal">all.equal</a></code> and <code><a href="base.html#topic+isTRUE">isTRUE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
flu [,,445 ~ 450] &gt; 300

all (flu == flu[[]])

</code></pre>

<hr>
<h2 id='count_lines'>count lines (of an ASCII file)</h2><span id='topic+count_lines'></span>

<h3>Description</h3>

<p>count lines (of an ASCII file)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_lines(file, chunksize = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_lines_+3A_file">file</code></td>
<td>
<p>the file name or connection</p>
</td></tr>
<tr><td><code id="count_lines_+3A_chunksize">chunksize</code></td>
<td>
<p><code>file</code> is read in chunks of <code>chunksize</code> lines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of lines in file
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>

<hr>
<h2 id='cov+2ChyperSpec+2Cmissing-method'>Covariance matrices for hyperSpec objects</h2><span id='topic+cov+2ChyperSpec+2Cmissing-method'></span><span id='topic+pooled.cov'></span>

<h3>Description</h3>

<p>Covariance matrices for hyperSpec objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hyperSpec,missing'
cov(
  x,
  y = NULL,
  use = "everything",
  method = c("pearson", "kendall", "spearman")
)

pooled.cov(x, groups, ..., regularize = 1e-05 * max(abs(COV)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov+2B2ChyperSpec+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>hyperSpec object</p>
</td></tr>
<tr><td><code id="cov+2B2ChyperSpec+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>not supported</p>
</td></tr>
<tr><td><code id="cov+2B2ChyperSpec+2B2Cmissing-method_+3A_use">use</code>, <code id="cov+2B2ChyperSpec+2B2Cmissing-method_+3A_method">method</code></td>
<td>
<p>handed to  <code><a href="stats.html#topic+cov">cov</a></code></p>
</td></tr>
<tr><td><code id="cov+2B2ChyperSpec+2B2Cmissing-method_+3A_groups">groups</code></td>
<td>
<p>factor indicating the groups</p>
</td></tr>
<tr><td><code id="cov+2B2ChyperSpec+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="cov+2B2ChyperSpec+2B2Cmissing-method_+3A_regularize">regularize</code></td>
<td>
<p>regularization of the covariance matrix. Set <code>0</code> to switch off
</p>
<p><code>pooled.cov</code> calculates pooled covariance like e.g. in LDA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>covariance matrix of size <code>nwl (x)</code> x  <code>nwl (x)</code>
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cov">cov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image (cov (chondro))
pcov &lt;-  pooled.cov (chondro, chondro$clusters)
plot (pcov$means)
image (pcov$COV)

</code></pre>

<hr>
<h2 id='decomposition'>Convert Principal Component Decomposition or the like into a hyperSpec
Object</h2><span id='topic+decomposition'></span>

<h3>Description</h3>

<p>Decomposition of the spectra matrix is a common procedure in chemometric
data analysis. <code>scores</code> and <code>loadings</code> convert the result matrices
into new <code>hyperSpec</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomposition(
  object,
  x,
  wavelength = seq_len(ncol(x)),
  label.wavelength,
  label.spc,
  scores = TRUE,
  retain.columns = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decomposition_+3A_object">object</code></td>
<td>
<p>A <code>hyperSpec</code> object.</p>
</td></tr>
<tr><td><code id="decomposition_+3A_x">x</code></td>
<td>
<p>matrix with the new content for <code>object@data$spc</code>.
</p>
<p>Its size must correspond to rows (for <code>scores</code>) and to either columns
or rows (for <code>loadings</code>) of <code>object</code>.</p>
</td></tr>
<tr><td><code id="decomposition_+3A_wavelength">wavelength</code></td>
<td>
<p>for a scores-like <code>x</code>: the new
<code>object@wavelength</code>.</p>
</td></tr>
<tr><td><code id="decomposition_+3A_label.wavelength">label.wavelength</code></td>
<td>
<p>The new label for the wavelength axis (if <code>x</code>
is scores-like). If not given, the label of <code>object</code> is kept.</p>
</td></tr>
<tr><td><code id="decomposition_+3A_label.spc">label.spc</code></td>
<td>
<p>The new label for the spectra matrix. If not given, the
label of <code>object</code> is kept.</p>
</td></tr>
<tr><td><code id="decomposition_+3A_scores">scores</code></td>
<td>
<p>is <code>x</code> a scores-like matrix?</p>
</td></tr>
<tr><td><code id="decomposition_+3A_retain.columns">retain.columns</code></td>
<td>
<p>for loading-like decompostition (i.e. <code>x</code> holds
loadings, pure component spectra or the like), the data columns need
special attention.
</p>
<p>Columns with different values across the rows will be set to <code>NA</code> if
<code>retain.columns</code> is <code>TRUE</code>, otherwise they will be deleted.</p>
</td></tr>
<tr><td><code id="decomposition_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multivariate data are frequently decomposed by methods like principal
component analysis, partial least squares, linear discriminant analysis, and
the like.  These methods yield latent spectra (or latent variables,
loadings, components, ...) that are linear combination coefficients
along the wavelength axis and scores for each spectrum and loading.
</p>
<p>The loadings matrix gives a coordinate transformation, and the scores are
values in that new coordinate system.
</p>
<p>The obtained latent variables are spectra-like objects: a latent variable
has a coefficient for each wavelength. If such a matrix (with the same
number of columns as <code>object</code> has wavelengths) is given to
<code>decomposition</code> (also setting <code>scores = FALSE</code>), the spectra
matrix is replaced by <code>x</code>. Moreover, all columns of <code>object@data</code>
that did not contain the same value for all spectra are set to <code>NA</code>.
Thus, for the resulting <code>hyperSpec</code> object, <code><a href="#topic+plotspc">plotspc</a></code> and
related functions are meaningful. <code><a href="#topic+plotmap">plotmap</a></code> cannot be
applied as the loadings are not laterally resolved.
</p>
<p>The scores matrix needs to have the same number of rows as <code>object</code> has
spectra. If such a matrix is given, <code>decomposition</code> will replace the
spectra matrix is replaced by <code>x</code> and <code>object@wavelength</code> by
<code>wavelength</code>. The information related to each of the spectra is
retained. For such a <code>hyperSpec</code> object, <code><a href="#topic+plotmap">plotmap</a></code> and
<code><a href="#topic+plotc">plotc</a></code> and the like can be applied. It is also possible to use
the spectra plotting, but the interpretation is not that of the spectrum any
longer.
</p>


<h3>Value</h3>

<p>A <code>hyperSpec</code> object, updated according to <code>x</code>
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic++25+2A+25">%*%</a></code> for matrix multiplication of
<code>hyperSpec</code> objects.
</p>
<p>See e.g. <code><a href="stats.html#topic+prcomp">prcomp</a></code> and <code><a href="stats.html#topic+princomp">princomp</a></code> for
principal component analysis, and package <code>pls</code> for Partial Least
Squares Regression.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pca &lt;- prcomp (flu)

pca.loadings &lt;- decomposition (flu, t (pca$rotation), scores = FALSE)
pca.center &lt;- decomposition (flu, pca$center, scores = FALSE)
pca.scores &lt;- decomposition (flu, pca$x)

plot (pca.center)
plot (pca.loadings, col = c ("red", "gray50"))
plotc (pca.scores, groups = .wavelength)
</code></pre>

<hr>
<h2 id='dimnames+2ChyperSpec-method'>dimnames for hyperSpec objects</h2><span id='topic+dimnames+2ChyperSpec-method'></span><span id='topic+dimnames'></span><span id='topic+rownames+2ChyperSpec-method'></span><span id='topic+rownames'></span><span id='topic+rownames+3C-'></span><span id='topic+rownames+3C-+2ChyperSpec-method'></span><span id='topic+colnames+2ChyperSpec-method'></span><span id='topic+colnames'></span><span id='topic+colnames+3C-'></span><span id='topic+colnames+3C-+2ChyperSpec-method'></span>

<h3>Description</h3>

<p>hyperSpec objects can have row- and column names like data.frames. The &quot;names&quot; of the wavelengths
are treated separately: see <code><a href="#topic+wl">wl</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hyperSpec'
dimnames(x)

## S4 method for signature 'hyperSpec'
rownames(x, do.NULL = TRUE, prefix = "row")

## S4 replacement method for signature 'hyperSpec'
 rownames(x) &lt;- value

## S4 method for signature 'hyperSpec'
colnames(x, do.NULL = TRUE, prefix = "col")

## S4 replacement method for signature 'hyperSpec'
 colnames(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dimnames+2B2ChyperSpec-method_+3A_x">x</code></td>
<td>
<p>the hyperSpec object</p>
</td></tr>
<tr><td><code id="dimnames+2B2ChyperSpec-method_+3A_do.null">do.NULL</code></td>
<td>
<p>handed to <code><a href="base.html#topic+rownames">rownames</a></code> or <code><a href="base.html#topic+colnames">colnames</a></code>: logical.
Should this create names if they are <code>NULL</code>?</p>
</td></tr>
<tr><td><code id="dimnames+2B2ChyperSpec-method_+3A_prefix">prefix</code></td>
<td>
<p>handed to <code><a href="base.html#topic+rownames">rownames</a></code> or <code><a href="base.html#topic+colnames">colnames</a></code></p>
</td></tr>
<tr><td><code id="dimnames+2B2ChyperSpec-method_+3A_value">value</code></td>
<td>
<p>the new names</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wl">wl</a></code> for the wavelength dimension
</p>
<p><code><a href="base.html#topic+dimnames">dimnames</a></code>
</p>
<p><code><a href="base.html#topic+rownames">rownames</a></code>
</p>
<p><code><a href="base.html#topic+colnames">colnames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dimnames (flu)
rownames (flu)
colnames (chondro)
</code></pre>

<hr>
<h2 id='droplevels+2ChyperSpec-method'>droplevels for hyperSpec object</h2><span id='topic+droplevels+2ChyperSpec-method'></span>

<h3>Description</h3>

<p>calls <code><a href="base.html#topic+droplevels">base::droplevels()</a></code> on the data.frame in <code>spc@data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hyperSpec'
droplevels(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="droplevels+2B2ChyperSpec-method_+3A_x">x</code></td>
<td>
<p>hyperSpec object</p>
</td></tr>
<tr><td><code id="droplevels+2B2ChyperSpec-method_+3A_...">...</code></td>
<td>
<p>handed to <code><a href="base.html#topic+droplevels">base::droplevels.data.frame()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>hyperSpec object with unused levels of all factors in <code style="white-space: pre;">&#8288;@data&#8288;</code> dropped.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+droplevels">base::droplevels()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
chondro[1:3]$clusters
droplevels (chondro [1:3])$clusters
</code></pre>

<hr>
<h2 id='empty'>Empty hyperSpec object</h2><span id='topic+empty'></span>

<h3>Description</h3>

<p>Empty produces an hyperSpec object with the same columns and wavelengths as <code>x</code>.  The new
object will either contain no rows at all (default), or the given number of rows with all data
initialized to <code>spc</code> and <code>extra</code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empty(x, nrow = 0, spc = NA, extra = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="empty_+3A_x">x</code></td>
<td>
<p>hyperSpec object</p>
</td></tr>
<tr><td><code id="empty_+3A_nrow">nrow</code></td>
<td>
<p>number of rows the new object should have</p>
</td></tr>
<tr><td><code id="empty_+3A_spc">spc</code></td>
<td>
<p>value to initialize the new spectra matrix with</p>
</td></tr>
<tr><td><code id="empty_+3A_extra">extra</code></td>
<td>
<p>value to initialize the new extra data with</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>Examples</h3>

<pre><code class='language-R'>empty (chondro, nrow = 2, spc = 0)
</code></pre>

<hr>
<h2 id='flu'>Quinine Fluorescence Spectra
Fluorescence spectra of different dilutions of quinine forming a
calibration set.</h2><span id='topic+flu'></span>

<h3>Description</h3>

<p>See the vignette: <code>vignette ("flu", package = "hyperSpec")</code>
</p>


<h3>Format</h3>

<p>The data set has 6 fluorescence emission spectra measured on
quinine concentrations between 0.05 mg/l and 0.30 mg/l.  Each spectrum
consists of 181 data points in the range of 405 nm to 495 nm.
</p>


<h3>Author(s)</h3>

<p>M. Kammer and C. Beleites
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
flu

plot (flu)

plotc (flu)

</code></pre>

<hr>
<h2 id='Future-functions'>Future functions</h2><span id='topic+Future-functions'></span><span id='topic+.spc_io_postprocess_optional'></span><span id='topic+wl_convert_units'></span><span id='topic+hy_set_options'></span><span id='topic+hy_get_option'></span><span id='topic+read_txt_long'></span><span id='topic+read_txt_wide'></span><span id='topic+.wl_fix_unit_name'></span><span id='topic+assert_hyperSpec'></span>

<h3>Description</h3>

<p>These functions will be introduced in <span class="pkg">hyperSpec</span> v1.0 and will replace
some current functions. Now they appear here just for compatibility with
other packages, which should be released on CRAN. They are not intended to
be used by <span class="pkg">hyperSpec</span> v0.100 users directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.spc_io_postprocess_optional(...)

wl_convert_units(x, from, to, ref_wl = NULL)

hy_set_options(...)

hy_get_option(...)

hy_set_options(...)

read_txt_long(...)

read_txt_wide(...)

.wl_fix_unit_name(...)

assert_hyperSpec(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Future-functions_+3A_...">...</code></td>
<td>
<p>Arguments to functions.</p>
</td></tr>
<tr><td><code id="Future-functions_+3A_x">x</code>, <code id="Future-functions_+3A_from">from</code>, <code id="Future-functions_+3A_to">to</code>, <code id="Future-functions_+3A_ref_wl">ref_wl</code></td>
<td>
<p>Arguments to functions.</p>
</td></tr>
</table>

<hr>
<h2 id='guess.wavelength'>guess wavelengths from character vector</h2><span id='topic+guess.wavelength'></span>

<h3>Description</h3>

<p>character vectors used for names (e.g. colnames for matrices or data.frames) 
are often treated by <code><a href="base.html#topic+make.names">make.names</a></code> or similar functions that
produce suitable names (e.g. by prepending &quot;X&quot; to numbers.). Such names 
cannot be directly converted to numeric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess.wavelength(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="guess.wavelength_+3A_x">X</code></td>
<td>
<p>character with numbers hidden inside</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>guess.wavlength</code> tries to extract numbers from X which may be
surrounded by such &quot;protecting&quot; characters.
</p>


<h3>Value</h3>

<p>numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- data.frame(flu [[,, 400 ~ 410]])
(wl &lt;- colnames (tmp))
guess.wavelength (wl)
</code></pre>

<hr>
<h2 id='hy.getOptions'>Options for package hyperSpec
Functions to access and set hyperSpec's options.</h2><span id='topic+hy.getOptions'></span><span id='topic+hy.getOption'></span><span id='topic+hy.setOptions'></span>

<h3>Description</h3>

<p>Currently, the following options are defined:
</p>

<table>
<tr>
 <td style="text-align: left;">
<b>Name</b>          </td><td style="text-align: left;"> <b>Default Value (range)</b>      </td><td style="text-align: left;"> <b>Description</b>                               </td><td style="text-align: left;"> <b>Used by</b></td>
</tr>
<tr>
 <td style="text-align: left;">
debuglevel           </td><td style="text-align: left;"> 0 (1L 2L 3L)                      </td><td style="text-align: left;"> amount of debugging information produced         </td><td style="text-align: left;"> <code><a href="#topic+spc.identify">spc.identify</a></code> <code><a href="#topic+map.identify">map.identify</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
                     </td><td style="text-align: left;">                                   </td><td style="text-align: left;">                                                  </td><td style="text-align: left;"> various file import functions</td>
</tr>
<tr>
 <td style="text-align: left;">
                     </td><td style="text-align: left;">                                   </td><td style="text-align: left;">                                                  </td><td style="text-align: left;"> <code><a href="#topic+spc.fit.poly.below">spc.fit.poly.below</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
gc                   </td><td style="text-align: left;"> FALSE                             </td><td style="text-align: left;"> triggers frequent calling of gc ()               </td><td style="text-align: left;"> <code><a href="#topic+read.ENVI">read.ENVI</a></code>, <code>new ("hyperSpec")</code></td>
</tr>
<tr>
 <td style="text-align: left;">
file.remove.emptyspc </td><td style="text-align: left;"> TRUE                              </td><td style="text-align: left;"> remove empty spectra directly on file import     </td><td style="text-align: left;"> various file import functions</td>
</tr>
<tr>
 <td style="text-align: left;">
file.keep.name       </td><td style="text-align: left;"> TRUE                              </td><td style="text-align: left;"> always create filename column                    </td><td style="text-align: left;"> various file import functions</td>
</tr>
<tr>
 <td style="text-align: left;">
tolerance            </td><td style="text-align: left;"> <code>sqrt (.Machine$double.eps)</code> </td><td style="text-align: left;"> tolerance for numerical comparisons              </td><td style="text-align: left;"> <code><a href="#topic+normalize01">normalize01</a></code>, file import: <code>file.remove.emptyspc</code></td>
</tr>
<tr>
 <td style="text-align: left;">
wl.tolerance         </td><td style="text-align: left;"> <code>sqrt (.Machine$double.eps)</code> </td><td style="text-align: left;"> tolerance for comparisons of the wavelength axis </td><td style="text-align: left;"> <code><a href="#topic+all.equal">all.equal</a></code>, <code><a href="#topic+collapse">collapse</a></code>, <code><a href="base.html#topic+rbind">rbind</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
plot.spc.nmax        </td><td style="text-align: left;"> 25                                </td><td style="text-align: left;"> number of spectra to be plotted by default       </td><td style="text-align: left;"> <code><a href="#topic+plotspc">plotspc</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
ggplot.spc.nmax      </td><td style="text-align: left;"> 10                                </td><td style="text-align: left;">                                                  </td><td style="text-align: left;"> <code><a href="#topic+qplotspc">qplotspc</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>hy.getOptions(...)

hy.getOption(name)

hy.setOptions(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hy.getOptions_+3A_...">...</code></td>
<td>
<p><code>hy.setOptions</code>: pairs of argument names and values.
</p>
<p><code>hy.getOptions</code>: indices (or names) of the options.</p>
</td></tr>
<tr><td><code id="hy.getOptions_+3A_name">name</code></td>
<td>
<p>the name of the option</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hy.setOptions</code> will discard any values that were given without a
name.
</p>


<h3>Value</h3>


<table>
<tr>
 <td style="text-align: left;">
<code>hy.getOptions</code> </td><td style="text-align: left;"> returns a list of all options</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>hy.setOptions</code> </td><td style="text-align: left;"> invisibly returns a list with the options </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>hy.getOption</code>  </td><td style="text-align: left;"> returns the value of the requested option </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hy.getOptions ()

</code></pre>

<hr>
<h2 id='hy.unittest'>hyperSpec unit tests</h2><span id='topic+hy.unittest'></span>

<h3>Description</h3>

<p>If <code><a href="testthat.html#topic+testthat">testthat</a></code> is available, run the unit tests and
display the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hy.unittest(standalone = TRUE, reporter = "progress")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hy.unittest_+3A_standalone">standalone</code></td>
<td>
<p>run the unit test on their own, e.g. from the console
('TRUE') or within testthat tests ('FALSE'), e.g. via 'devtools::test()'</p>
</td></tr>
<tr><td><code id="hy.unittest_+3A_reporter">reporter</code></td>
<td>
<p>the reporter to use, defaults to [testthat::ProgressReporter]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a data frame with the test results
</p>


<h3>Author(s)</h3>

<p>Claudia Beleites
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hy.unittest ()

</code></pre>

<hr>
<h2 id='hyperSpec-class'>Class &quot;hyperSpec&quot;
This class handles hyperspectral data sets, i.e. spatially or time-resolved
spectra, or spectra with any other kind of information associated with the
spectra.</h2><span id='topic+hyperSpec-class'></span>

<h3>Description</h3>

<p>The spectra can be data as obtained in XRF, UV/VIS, Fluorescence, AES, NIR,
IR, Raman, NMR, MS, etc.
</p>


<h3>Details</h3>

<p>More generally, any data that is recorded over a discretized variable, e.g.
absorbance = f (wavelength), stored as a vector of absorbance values for
discrete wavelengths is suitable.
</p>


<h3>Slots</h3>


<dl>
<dt><code>wavelength</code></dt><dd><p>wavelengths (wavenumbers, frequencies, etc.) for each of the columns of the
spectra matrix</p>
</dd>
<dt><code>data</code></dt><dd><p>the data (extra data and spectra matrix)</p>
</dd>
<dt><code>label</code></dt><dd><p>expressions for column labels (incl. units). The label of the wavelength axis is in
the special element <code>.wavelength</code>.</p>
</dd>
<dt><code>log</code></dt><dd><p>deprecated.</p>
</dd>
</dl>


<h3>Note</h3>

<p>Please note that the logbook is now removed.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p>See the vignette &quot;hyperspec&quot; for an introduction to hyperSpec
from a spectroscopic point of view.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("hyperSpec")
## Not run: vignette ("hyperspec")
</code></pre>

<hr>
<h2 id='initialize'>Creating a hyperSpec Object</h2><span id='topic+initialize'></span><span id='topic+initialize+2ChyperSpec-method'></span><span id='topic+create'></span><span id='topic+create+2ChyperSpec-method'></span><span id='topic+new+2ChyperSpec-method'></span><span id='topic+new'></span>

<h3>Description</h3>

<p>Like other S4 objects, a hyperSpec object can be created by <code>new</code>. The
hyperSpec object is then <code>initialize</code>d using the given parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hyperSpec'
initialize(.Object, spc = NULL, data = NULL, wavelength = NULL, labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initialize_+3A_.object">.Object</code></td>
<td>
<p>the new <code>hyperSpec</code> object.</p>
</td></tr>
<tr><td><code id="initialize_+3A_spc">spc</code></td>
<td>
<p>the spectra matrix.
</p>
<p><code>spc</code> does not need to be a matrix, it is converted explicitly by
<code>I (as.matrix (spc))</code>.</p>
</td></tr>
<tr><td><code id="initialize_+3A_data">data</code></td>
<td>
<p><code>data.frame</code>, possibly with the spectra in
<code>data$spc</code>, and further variates in more columns.  A matrix can be
entered as <em>one</em> column of a data frame by: <code>data.frame (spc =
  I (as.matrix (spc)))</code>.
</p>
<p>However, it will usually be more convenient if the spectra are given in
<code>spc</code></p>
</td></tr>
<tr><td><code id="initialize_+3A_wavelength">wavelength</code></td>
<td>
<p>The wavelengths corresponding to the columns of
<code>data</code>. If no wavelengths are given, an appropriate vector is
derived from the column names of <code>data$spc</code>. If this is not
possible, <code>1 : ncol (data$spc)</code> is used instead.</p>
</td></tr>
<tr><td><code id="initialize_+3A_labels">labels</code></td>
<td>
<p>A <code>list</code> containing the labels for the columns of the
<code>data</code> slot of the <code>hyperSpec</code> object and for the wavelength
(in <code>label$.wavelength</code>). The labels should be given in a form ready
for the text-drawing functions (see <code><a href="grDevices.html#topic+plotmath">plotmath</a></code>).
</p>
<p>If <code>label</code> is not given, a list containing <code>NULL</code> for each of the
columns of<code>data</code> and <code>wavelength</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If option <code>gc</code> is <code>TRUE</code>, the initialization will have frequent
calls to <code>gc ()</code> which can help to avoid swapping or running out of
memory.
</p>


<h3>Author(s)</h3>

<p>C.Beleites
</p>


<h3>See Also</h3>

<p><code><a href="methods.html#topic+new">new</a></code> for more information on creating and
initializing S4 objects.
</p>
<p><code><a href="grDevices.html#topic+plotmath">plotmath</a></code> on expressions for math annotations as
for slot <code>label</code>.
</p>
<p><code><a href="#topic+hy.setOptions">hy.setOptions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
new ("hyperSpec")

spc &lt;- matrix (rnorm (12), ncol = 4)
new ("hyperSpec", spc = spc)
new ("hyperSpec", data = data.frame (x = letters[1:3]),
     spc = spc)

colnames (spc) &lt;- 600:603
new ("hyperSpec", spc = spc)  # wavelength taken from colnames (spc)

# given wavelengths precede over colnames of spc
new ("hyperSpec", spc = spc, wavelength = 700:703)

# specifying labels
h &lt;- new ("hyperSpec", spc = spc, data = data.frame (pos = 1 : 3),
          label = list (spc = "I / a.u.",
                        .wavelength = expression (tilde (nu) / cm^-1),
                        pos = expression ("/" (x, mu*m)))
)

plot (h)
plotc (h, spc ~ pos)

</code></pre>

<hr>
<h2 id='labels+26lt+3B-'>Get and Set Labels of a hyperSpec Object
<code>value</code> may be a list or vector of labels giving the new label for
each of the entries specified by <code>which</code>.</h2><span id='topic+labels+3C-'></span><span id='topic+labels+3C-+2ChyperSpec-method'></span><span id='topic+labels+2ChyperSpec-method'></span>

<h3>Description</h3>

<p>The names of the labels are the same as the colnames of the
<code>data.frame</code>.  The label for the wavelength axis has the name
<code>.wavelength</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labels (object, which = NULL, ...) &lt;- value

## S4 method for signature 'hyperSpec'
labels(object, which = bquote(), drop = TRUE, ..., use.colnames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="labels+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>a hyperSpec object</p>
</td></tr>
<tr><td><code id="labels+2B26lt+2B3B-_+3A_which">which</code></td>
<td>
<p>numeric or character to specify the label(s)</p>
</td></tr>
<tr><td><code id="labels+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="labels+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>the new label(s)</p>
</td></tr>
<tr><td><code id="labels+2B26lt+2B3B-_+3A_drop">drop</code></td>
<td>
<p>if the result would be a list with only one element, should the
element be returned instead?</p>
</td></tr>
<tr><td><code id="labels+2B26lt+2B3B-_+3A_use.colnames">use.colnames</code></td>
<td>
<p>should missing labels be replaced by column names of
the extra data?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The labels should be given in a form ready for the text-drawing functions
(see <code><a href="grDevices.html#topic+plotmath">plotmath</a></code>), e.g. as <code>expression</code> or a
<code>character</code>.
</p>


<h3>Value</h3>

<p><code>labels&lt;-</code> returns a <code>hyperSpec</code> object.
</p>
<p><code>labels</code> returns a list of labels.  If <code>drop</code> is
<code>TRUE</code> and the list contains only one element, the element is
returned instead.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+labels">labels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
labels (flu, "c") &lt;- expression ("/" ("c", "mg / l"))


labels (chondro)

</code></pre>

<hr>
<h2 id='laser'>Laser Emission
A time series of an unstable laser emission.</h2><span id='topic+laser'></span>

<h3>Description</h3>

<p>see the Vignette
</p>


<h3>Format</h3>

<p>The data set consists of 84 laser emission spectra measured during
95 min.  Each spectrum has 36 data points in the range of 404.5 nm to
405.8 nm.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
laser

cols &lt;- c ("black", "blue", "darkgreen", "red")
wl &lt;- c (405.0, 405.1, 405.3, 405.4)
plotspc (laser, axis.args=list (x = list (at = seq (404.5, 405.8, .1))))
for (i in seq_along (wl))
   abline (v = wl[i], col = cols[i], lwd = 2, lty = 2)

plotc (laser [,, wl], spc ~ t, groups = .wavelength, type = "b",
       col = cols)

## Not run: vignette ("laser", package="hyperSpec")

</code></pre>

<hr>
<h2 id='legendright'>Plot multivariate data into colour channels</h2><span id='topic+legendright'></span><span id='topic+qmixtile'></span><span id='topic+normalize.colrange'></span><span id='topic+normalize.range'></span><span id='topic+normalize.null'></span><span id='topic+normalize.minmax'></span><span id='topic+qmixlegend'></span><span id='topic+colmix.rgb'></span>

<h3>Description</h3>

<p>plot graph with legend right of it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legendright(p, l, legend.width = 8, legend.unit = "lines")

qmixtile(
  object,
  purecol = stop("pure component colors needed."),
  mapping = aes_string(x = "x", y = "y", fill = "spc"),
  ...,
  map.tileonly = FALSE
)

normalize.colrange(x, na.rm = TRUE, legend = FALSE, n = 100, ...)

normalize.range(x, na.rm = TRUE, legend = FALSE, n = 100, ...)

normalize.null(x, na.rm = TRUE, legend = FALSE, n = 100, ...)

normalize.minmax(x, min = 0, max = 1, legend = FALSE, n = 100, ...)

qmixlegend(
  x,
  purecol,
  dx = 0.33,
  ny = 100,
  labels = names(purecol),
  normalize = normalize.colrange,
  ...
)

colmix.rgb(
  x,
  purecol,
  against = 1,
  sub = TRUE,
  normalize = normalize.colrange,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="legendright_+3A_p">p</code></td>
<td>
<p>plot object</p>
</td></tr>
<tr><td><code id="legendright_+3A_l">l</code></td>
<td>
<p>legend object</p>
</td></tr>
<tr><td><code id="legendright_+3A_legend.width">legend.width</code>, <code id="legendright_+3A_legend.unit">legend.unit</code></td>
<td>
<p>size of legend part</p>
</td></tr>
<tr><td><code id="legendright_+3A_object">object</code></td>
<td>
<p>matrix to be plotted with mixed colour channels</p>
</td></tr>
<tr><td><code id="legendright_+3A_purecol">purecol</code></td>
<td>
<p>pure component colours, names determine legend labels</p>
</td></tr>
<tr><td><code id="legendright_+3A_mapping">mapping</code></td>
<td>
<p>see <code><a href="ggplot2.html#topic+geom_tile">geom_tile</a></code></p>
</td></tr>
<tr><td><code id="legendright_+3A_...">...</code></td>
<td>
<p><code>qmixtile</code>: handed to <a href="#topic+colmix.rgb">colmix.rgb</a>
</p>
<p><code>qmixlegend</code> and <code>colmix.rgb</code> hand further arguments to the <code>normalize</code> function</p>
</td></tr>
<tr><td><code id="legendright_+3A_map.tileonly">map.tileonly</code></td>
<td>
<p>if <code>TRUE</code>, <code>mapping</code> will be handed to
<code><a href="ggplot2.html#topic+geom_tile">geom_tile</a></code> instead of <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.</p>
</td></tr>
<tr><td><code id="legendright_+3A_x">x</code></td>
<td>
<p>matrix with component intensities in columns</p>
</td></tr>
<tr><td><code id="legendright_+3A_na.rm">na.rm</code></td>
<td>
<p>see <code>link[base]{min}</code></p>
</td></tr>
<tr><td><code id="legendright_+3A_legend">legend</code></td>
<td>
<p>should a legend be produced instead of normalized values?</p>
</td></tr>
<tr><td><code id="legendright_+3A_n">n</code></td>
<td>
<p>of colours to produce in legend</p>
</td></tr>
<tr><td><code id="legendright_+3A_min">min</code></td>
<td>
<p>numeric with value corresponding to &quot;lowest&quot; colour for each column</p>
</td></tr>
<tr><td><code id="legendright_+3A_max">max</code></td>
<td>
<p>numeric with value corresponding to &quot;hightest&quot; colour for each column</p>
</td></tr>
<tr><td><code id="legendright_+3A_dx">dx</code></td>
<td>
<p>width of label bar</p>
</td></tr>
<tr><td><code id="legendright_+3A_ny">ny</code></td>
<td>
<p>number of colours in legend</p>
</td></tr>
<tr><td><code id="legendright_+3A_labels">labels</code></td>
<td>
<p>component names</p>
</td></tr>
<tr><td><code id="legendright_+3A_normalize">normalize</code></td>
<td>
<p>function to normalize the values.</p>
</td></tr>
<tr><td><code id="legendright_+3A_against">against</code></td>
<td>
<p>value to mix against (for <code>sub = TRUE</code> only, 1 = white, 0 = black)</p>
</td></tr>
<tr><td><code id="legendright_+3A_sub">sub</code></td>
<td>
<p>subtractive color mixing?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible <code>NULL</code>
</p>
<p>list with components ymin, max and fill to specify value and fill colour value (still
numeric!) for the legend, otherwise the normalized values
</p>
<p>ggplot object with legend
</p>
<p>character with colours
</p>


<h3>Author(s)</h3>

<p>Claudia Beleites
</p>
<p>Claudia Beleites
</p>
<p>Claudia Beleites
</p>

<hr>
<h2 id='makeraster'>makeraster</h2><span id='topic+makeraster'></span><span id='topic+fitraster'></span>

<h3>Description</h3>

<p>find an evenly spaced grid for x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeraster(x, startx, d, newlevels, tol = 0.1)

fitraster(x, tol = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeraster_+3A_x">x</code></td>
<td>
<p>numeric to be fitted with a raster</p>
</td></tr>
<tr><td><code id="makeraster_+3A_startx">startx</code></td>
<td>
<p>starting point (&quot;origin&quot;) for calculation of the raster</p>
</td></tr>
<tr><td><code id="makeraster_+3A_d">d</code></td>
<td>
<p>step size of the raster</p>
</td></tr>
<tr><td><code id="makeraster_+3A_newlevels">newlevels</code></td>
<td>
<p>levels of the raster</p>
</td></tr>
<tr><td><code id="makeraster_+3A_tol">tol</code></td>
<td>
<p>tolerance for rounding to new levels: elements of x within <code>tol</code> of the distance between the levels of the new grid are rounded to the new grid point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>makeraster</code> fits the data to the specified raster.
</p>
<p><code>fitraster</code> tries different raster parameter and returns the raster that covers most of the
<code>x</code> values: The differences between the values of <code>x</code> are calculated (possible step
sizes). For each of those step sizes, different points are tried (until all points have been
covered by a raster) and the parameter combination leading to the best coverage (i.e. most points
on the grid) ist used.
</p>
<p>Note that only differences between the sorted values of x are considered as step size.
</p>


<h3>Value</h3>

<p>list with elements
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>the values of <code>x</code>, possibly rounded to the raster values</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>the values of the raster</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudia Beleites
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c (sample (1:20, 10), (0 : 5) + 0.5)
raster &lt;- makeraster (x, x [1], 2)
raster
plot (x)
abline (h = raster$levels, col = "#00000040")

## unoccupied levels
missing &lt;- setdiff (raster$levels, raster$x)
abline (h = missing, col = "red")

## points acutally on the raster
onraster &lt;- raster$x %in% raster$levels
points (which (onraster), raster$x [onraster], col = "blue", pch = 20)


raster &lt;- fitraster (x)
raster
plot (x)
abline (h = raster$levels, col = "#00000040")

## unoccupied levels
missing &lt;- setdiff (raster$levels, raster$x)
abline (h = missing, col = "red")

## points acutally on the raster
onraster &lt;- raster$x %in% raster$levels
points (which (onraster), raster$x [onraster], col = "blue", pch = 20)

x &lt;- c (sample (1:20, 10), (0 : 5) + 0.45)
raster &lt;- fitraster (x)
raster
plot (x)
abline (h = raster$levels, col = "#00000040")

## unoccupied levels
missing &lt;- setdiff (raster$levels, raster$x)
abline (h = missing, col = "red")

## points acutally on the raster
onraster &lt;- raster$x %in% raster$levels
points (which (onraster), raster$x [onraster], col = "blue", pch = 20)

</code></pre>

<hr>
<h2 id='map.sel.poly'>Interactively select a polygon (grid graphics) and highlight points</h2><span id='topic+map.sel.poly'></span><span id='topic+sel.poly'></span>

<h3>Description</h3>

<p>Click the points that should be connected as polygon. Input ends with right click (see
<code><a href="grid.html#topic+grid.locator">grid.locator</a></code>). Polygon will be drawn closed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.sel.poly(data, pch = 19, size = 0.3, ...)

sel.poly(pch = 19, size = 0.3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map.sel.poly_+3A_data">data</code></td>
<td>
<p>hyperSpec object for plotting map or list returned by <code><a href="#topic+plotmap">plotmap</a></code></p>
</td></tr>
<tr><td><code id="map.sel.poly_+3A_pch">pch</code></td>
<td>
<p>symbol to display the points of the polygon for <code><a href="#topic+sel.poly">sel.poly</a></code></p>
</td></tr>
<tr><td><code id="map.sel.poly_+3A_size">size</code></td>
<td>
<p>size for polygon point symbol for <code><a href="#topic+sel.poly">sel.poly</a></code></p>
</td></tr>
<tr><td><code id="map.sel.poly_+3A_...">...</code></td>
<td>
<p>further arguments for <code><a href="grid.html#topic+grid.points">grid.points</a></code> and
<code><a href="grid.html#topic+grid.lines">grid.lines</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>map.sel.poly</code> is a convenience wrapper for <code><a href="#topic+plotmap">plotmap</a></code>, <code>sel.poly</code>, 
and <code><a href="sp.html#topic+point.in.polygon">point.in.polygon</a></code>. For custiomized plotting, the plot can be produced by 
<code><a href="#topic+plotmap">plotmap</a></code>, <code><a href="#topic+plotvoronoi">plotvoronoi</a></code> or <code><a href="lattice.html#topic+levelplot">levelplot</a></code>, and the result of 
that plot command handed over to <code>map.sel.poly</code>, see the example below.
</p>
<p>If even more customized plotting is required,<code>sel.poly</code> should be used (see example).
</p>


<h3>Value</h3>

<p><code>map.sel.poly</code>: array of indices for points within the selected polygon
</p>
<p><code>sel.poly</code>: n x 2 matrix with the corner points of the polygon
</p>


<h3>Author(s)</h3>

<p>Claudia Beleites, Sebastian Mellor
</p>
<p>Claudia Beleites
</p>


<h3>See Also</h3>

<p><code><a href="grid.html#topic+grid.locator">grid.locator</a></code>, <code><a href="#topic+map.identify">map.identify</a></code>
</p>
<p><code><a href="grid.html#topic+grid.locator">grid.locator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive ()){
## convenience wrapper
map.sel.poly (chondro)

## customized version
data &lt;- sample (chondro [,, 1004 - 2i ~ 1004 + 2i], 300)

plotdata &lt;- plotvoronoi (data, clusters ~ y * x, col.regions = alois.palette ())
print (plotdata)
map.sel.poly (plotdata)

## even more customization:
plotvoronoi (data)

## interactively retrieve polygon
polygon &lt;- sel.poly ()

## find data points within polygon
require ("sp")     
i.sel &lt;- which (point.in.polygon (data$x, data$y, polygon [, 1], polygon [, 2]) &gt; 0)

## work with selected points
grid.points (unit (data$x [i.sel], "native"), unit (data$y [i.sel], "native"))
}
</code></pre>

<hr>
<h2 id='mark.dendrogram'>Mark groups in <code><a href="stats.html#topic+hclust">hclust</a></code> dendrograms</h2><span id='topic+mark.dendrogram'></span>

<h3>Description</h3>

<p>Groups are marked by colored rectangles as well as by their levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mark.dendrogram(
  dendrogram,
  groups,
  col = seq_along(unique(groups)),
  pos.marker = 0,
  height = 0.025 * max(dendrogram$height),
  pos.text = -2.5 * height,
  border = NA,
  text.col = "black",
  label,
  label.right = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mark.dendrogram_+3A_dendrogram">dendrogram</code></td>
<td>
<p>the dendrogram</p>
</td></tr>
<tr><td><code id="mark.dendrogram_+3A_groups">groups</code></td>
<td>
<p>factor giving the the groups to mark</p>
</td></tr>
<tr><td><code id="mark.dendrogram_+3A_col">col</code></td>
<td>
<p>vector with colors for each group</p>
</td></tr>
<tr><td><code id="mark.dendrogram_+3A_pos.marker">pos.marker</code></td>
<td>
<p>top of the marker rectangle</p>
</td></tr>
<tr><td><code id="mark.dendrogram_+3A_height">height</code></td>
<td>
<p>height of the marker rectangle</p>
</td></tr>
<tr><td><code id="mark.dendrogram_+3A_pos.text">pos.text</code></td>
<td>
<p>position of the text label</p>
</td></tr>
<tr><td><code id="mark.dendrogram_+3A_border">border</code></td>
<td>
<p>see <code><a href="graphics.html#topic+text">text</a></code></p>
</td></tr>
<tr><td><code id="mark.dendrogram_+3A_text.col">text.col</code></td>
<td>
<p>color (vector) giving the color for the text markers</p>
</td></tr>
<tr><td><code id="mark.dendrogram_+3A_label">label</code></td>
<td>
<p>side label see example</p>
</td></tr>
<tr><td><code id="mark.dendrogram_+3A_label.right">label.right</code></td>
<td>
<p>should the side labels be at the right side?</p>
</td></tr>
<tr><td><code id="mark.dendrogram_+3A_...">...</code></td>
<td>
<p>handed to <code><a href="graphics.html#topic+rect">rect</a></code> and <code><a href="graphics.html#topic+text">text</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dendrogram should be plotted separately, see the example.
</p>


<h3>Author(s)</h3>

<p>Claudia Beleites
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dend &lt;- hclust (pearson.dist (laser[[]]))
par (xpd = TRUE, mar = c (5.1, 4, 4, 3)) # allows plotting into the margin
plot (dend, hang = -1, labels = FALSE)

## mark clusters
clusters &lt;- as.factor (cutree (dend, k = 4))
levels (clusters) &lt;- LETTERS [1 : 4]
mark.dendrogram (dend, clusters, label = "cluster")

## mark independent factor
mark.dendrogram (dend, as.factor (laser [,,405.36] &gt; 11000),
pos.marker = -0.02, pos.text = - 0.03)

## mark continuous variable: convert it to a factor and omit labels
mark.dendrogram (dend, cut (laser [[,, 405.36]], 100), alois.palette (100),
                 pos.marker = -.015, text.col = NA,
                 label = expression (I [lambda == 405.36~nm]), label.right = FALSE)
 
</code></pre>

<hr>
<h2 id='markpeak'>Mark peak
Marks location of the <em>first</em> spectrum at the data point closest to the
specified position on the current plot.</h2><span id='topic+markpeak'></span>

<h3>Description</h3>

<p>Mark peak
</p>
<p>Marks location of the <em>first</em> spectrum at the data point closest to the
specified position on the current plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markpeak(spc, xpos, col = "red")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="markpeak_+3A_spc">spc</code></td>
<td>
<p>the <code>hyperSpec</code> object</p>
</td></tr>
<tr><td><code id="markpeak_+3A_xpos">xpos</code></td>
<td>
<p>position of the peak(s) in current x-axis units</p>
</td></tr>
<tr><td><code id="markpeak_+3A_col">col</code></td>
<td>
<p>color of the markers and text</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>R. Kiselev
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot (chondro [7])
markpeak (chondro [7], 1662)
</code></pre>

<hr>
<h2 id='Math2+2ChyperSpec-method'>Math Functions for hyperSpec Objects</h2><span id='topic+Math2+2ChyperSpec-method'></span><span id='topic+Math'></span><span id='topic+Math2'></span><span id='topic+Math+2ChyperSpec-method'></span><span id='topic+abs+2ChyperSpec-method'></span><span id='topic+sign+2ChyperSpec-method'></span><span id='topic+sqrt+2ChyperSpec-method'></span><span id='topic+floor+2ChyperSpec-method'></span><span id='topic+ceiling+2ChyperSpec-method'></span><span id='topic+trunc+2ChyperSpec-method'></span><span id='topic+round+2ChyperSpec-method'></span><span id='topic+signif+2ChyperSpec-method'></span><span id='topic+exp+2ChyperSpec-method'></span><span id='topic+log+2ChyperSpec-method'></span><span id='topic+expm1+2ChyperSpec-method'></span><span id='topic+log1p+2ChyperSpec-method'></span><span id='topic+cos+2ChyperSpec-method'></span><span id='topic+sin+2ChyperSpec-method'></span><span id='topic+tan+2ChyperSpec-method'></span><span id='topic+acos+2ChyperSpec-method'></span><span id='topic+asin+2ChyperSpec-method'></span><span id='topic+atan+2ChyperSpec-method'></span><span id='topic+cosh+2ChyperSpec-method'></span><span id='topic+sinh+2ChyperSpec-method'></span><span id='topic+tanh+2ChyperSpec-method'></span><span id='topic+acosh+2ChyperSpec-method'></span><span id='topic+asinh+2ChyperSpec-method'></span><span id='topic+atanh+2ChyperSpec-method'></span><span id='topic+lgamma+2ChyperSpec-method'></span><span id='topic+gamma+2ChyperSpec-method'></span><span id='topic+digamma+2ChyperSpec-method'></span><span id='topic+trigamma+2ChyperSpec-method'></span><span id='topic+cumsum+2ChyperSpec-method'></span><span id='topic+cumprod+2ChyperSpec-method'></span><span id='topic+cummax+2ChyperSpec-method'></span><span id='topic+cummin+2ChyperSpec-method'></span><span id='topic+log'></span>

<h3>Description</h3>

<p>Mathematical functions for hyperSpec Objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hyperSpec'
Math2(x, digits)

## S4 method for signature 'hyperSpec'
log(x, base = exp(1), ...)

## S4 method for signature 'hyperSpec'
Math(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Math2+2B2ChyperSpec-method_+3A_x">x</code></td>
<td>
<p>the <code>hyperSpec</code> object</p>
</td></tr>
<tr><td><code id="Math2+2B2ChyperSpec-method_+3A_digits">digits</code></td>
<td>
<p>integer stating the rounding precision</p>
</td></tr>
<tr><td><code id="Math2+2B2ChyperSpec-method_+3A_base">base</code></td>
<td>
<p>base of logarithm</p>
</td></tr>
<tr><td><code id="Math2+2B2ChyperSpec-method_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>abs</code>, <code>sign</code>, <code>sqrt</code>, <code>floor</code>,
<code>ceiling</code>, <code>trunc</code>, <code>round</code>, <code>signif</code>, <code>exp</code>,
<code>log</code>, <code>expm1</code>, <code>log1p</code>, <code>cos</code>, <code>sin</code>, <code>tan</code>,
<code>acos</code>, <code>asin</code>, <code>atan</code>, <code>cosh</code>, <code>sinh</code>,
<code>tanh</code>, <code>acosh</code>, <code>asinh</code>, <code>atanh</code>, <code>lgamma</code>,
<code>gamma</code>, <code>digamma</code>, <code>trigamma</code>, <code>cumsum</code>,
<code>cumprod</code>, <code>cummax</code>, <code>cummin</code> for <code>hyperSpec</code> objects.
</p>


<h3>Value</h3>

<p>a <code>hyperSpec</code> object
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="methods.html#topic+S4groupGeneric">S4groupGeneric</a></code> for group generic methods.
</p>
<p><code><a href="base.html#topic+Math">Math</a></code> for the base math functions.
</p>
<p><code><a href="#topic+Arith">Arith</a></code> for arithmetic operators,
<code><a href="#topic+Comparison">Comparison</a></code> for comparison operators, and
<code><a href="#topic+Summary">Summary</a></code> for group generic functions working on
<code>hyperSpec</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	log (flu)

</code></pre>

<hr>
<h2 id='matlab.palette'>Matlab-like Palettes
Two palettes going from blue over green to red, approximately as the
standard palette of Matlab does. The second one has darker green values and
is better suited for plotting lines on white background.</h2><span id='topic+matlab.palette'></span><span id='topic+matlab.dark.palette'></span><span id='topic+alois.palette'></span>

<h3>Description</h3>

<p>Matlab-like Palettes
Two palettes going from blue over green to red, approximately as the
standard palette of Matlab does. The second one has darker green values and
is better suited for plotting lines on white background.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matlab.palette(n = 100, ...)

matlab.dark.palette(n = 100, ...)

alois.palette(n = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matlab.palette_+3A_n">n</code></td>
<td>
<p>the number of colors to be in the palette.</p>
</td></tr>
<tr><td><code id="matlab.palette_+3A_...">...</code></td>
<td>
<p>further arguments are handed to <code><a href="grDevices.html#topic+rainbow">rainbow</a></code>
(<code>alois.palette</code>: <code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the color values in the form &quot;#rrbbggaa&quot;.
</p>


<h3>Author(s)</h3>

<p>C. Beleites and A. Bonifacio
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+rainbow">rainbow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plotmap (chondro [,, 778], col.regions = matlab.palette ())


plot (flu, col = matlab.dark.palette (nrow (flu)))

plotmap (chondro, col = alois.palette)
</code></pre>

<hr>
<h2 id='mean_sd+2Cnumeric-method'>Mean and Standard Deviation
Calculate mean and standard deviation, and mean, mean <code class="reqn">\pm</code> one
standard deviation, respectively.</h2><span id='topic+mean_sd+2Cnumeric-method'></span><span id='topic+mean_sd'></span><span id='topic+mean_sd+2Cmatrix-method'></span><span id='topic+mean_sd+2ChyperSpec-method'></span><span id='topic+mean_pm_sd+2Cnumeric-method'></span><span id='topic+mean_pm_sd'></span><span id='topic+mean_pm_sd+2Cmatrix-method'></span><span id='topic+mean_pm_sd+2ChyperSpec-method'></span><span id='topic+mean+2ChyperSpec-method'></span><span id='topic+quantile+2ChyperSpec-method'></span>

<h3>Description</h3>

<p>These functions are provided for convenience.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric'
mean_sd(x, na.rm = TRUE, ...)

## S4 method for signature 'matrix'
mean_sd(x, na.rm = TRUE, ...)

## S4 method for signature 'hyperSpec'
mean_sd(x, na.rm = TRUE, ...)

## S4 method for signature 'numeric'
mean_pm_sd(x, na.rm = TRUE, ...)

## S4 method for signature 'matrix'
mean_pm_sd(x, na.rm = TRUE, ...)

## S4 method for signature 'hyperSpec'
mean_pm_sd(x, na.rm = TRUE, ...)

## S4 method for signature 'hyperSpec'
mean(x, na.rm = TRUE, ...)

## S4 method for signature 'hyperSpec'
quantile(x, probs = seq(0, 1, 0.5), na.rm = TRUE, names = "num", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean_sd+2B2Cnumeric-method_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="mean_sd+2B2Cnumeric-method_+3A_na.rm">na.rm</code></td>
<td>
<p>handed to <code><a href="base.html#topic+mean">mean</a></code> and <code><a href="stats.html#topic+sd">sd</a></code></p>
</td></tr>
<tr><td><code id="mean_sd+2B2Cnumeric-method_+3A_...">...</code></td>
<td>
<p>ignored (needed to make function generic)</p>
</td></tr>
<tr><td><code id="mean_sd+2B2Cnumeric-method_+3A_probs">probs</code></td>
<td>
<p>the quantiles, see <code><a href="stats.html#topic+quantile">quantile</a></code></p>
</td></tr>
<tr><td><code id="mean_sd+2B2Cnumeric-method_+3A_names">names</code></td>
<td>
<p><code>"pretty"</code> results in percentages (like <code><a href="stats.html#topic+quantile">quantile</a></code>'s
<code>names = TRUE</code>), <code>"num"</code> results in the row names being <code>as.character (probs)</code>
(good for ggplot2 getting the order of the quantiles right). Otherwise, no names are assigned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mean_sd</code> returns a vector with two values (mean and standard
deviation) of <code>x</code>.
</p>
<p><code>mean_sd (matrix)</code> returns a matrix with the mean spectrum in the first row and the standard deviation in the 2nd.
</p>
<p><code>mean_sd</code> returns a hyperSpec object with the mean spectrum in the first row and the standard deviation in the 2nd.
</p>
<p><code>mean_pm_sd</code> returns a vector with 3 values: mean - 1 sd, mean, mean + 1 sd
</p>
<p><code>mean_pm_sd (matrix)</code> returns a matrix containing mean - sd, mean, and mean + sd
rows.
</p>
<p>For hyperSpec objects, <code>mean_pm_sd</code> returns a hyperSpec object containing mean - sd,
mean, and mean + sd spectra.
</p>
<p>For hyperSpec object, <code>mean</code> returns a hyperSpec object containing the mean
spectrum.
</p>
<p>For hyperSpec object, <code>quantile</code> returns a hyperSpec object containing the
respective quantile spectra.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+mean">mean</a></code>, <code><a href="stats.html#topic+sd">sd</a></code>
</p>
<p><code><a href="base.html#topic+mean">mean</a></code>, <code><a href="stats.html#topic+sd">sd</a></code>
</p>
<p><code><a href="stats.html#topic+quantile">quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mean_sd (flu [,, 405 ~ 410])

mean_sd (flu$spc)

mean_sd (flu)

  mean_pm_sd (flu$c)

mean_pm_sd (flu$spc)

mean_pm_sd (flu)

plot (mean (chondro))

plot (quantile (chondro))
</code></pre>

<hr>
<h2 id='merge+2ChyperSpec+2ChyperSpec-method'>Merge hyperSpec objects</h2><span id='topic+merge+2ChyperSpec+2ChyperSpec-method'></span><span id='topic+merge'></span><span id='topic+merge+2ChyperSpec+2Cdata.frame-method'></span><span id='topic+merge+2Cdata.frame+2ChyperSpec-method'></span>

<h3>Description</h3>

<p>Merges two hyperSpec objects and <code><a href="base.html#topic+cbind">cbind</a></code>s their spectra
matrices, or merges additional extra data into a hyperSpec object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hyperSpec,hyperSpec'
merge(x, y, ...)

## S4 method for signature 'hyperSpec,data.frame'
merge(x, y, ...)

## S4 method for signature 'data.frame,hyperSpec'
merge(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge+2B2ChyperSpec+2B2ChyperSpec-method_+3A_x">x</code></td>
<td>
<p>a hyperSpec object or data.frame</p>
</td></tr>
<tr><td><code id="merge+2B2ChyperSpec+2B2ChyperSpec-method_+3A_y">y</code></td>
<td>
<p>a hyperSpec object or data.frame (including derived classes like tibble)</p>
</td></tr>
<tr><td><code id="merge+2B2ChyperSpec+2B2ChyperSpec-method_+3A_...">...</code></td>
<td>
<p>handed to <code><a href="base.html#topic+merge.data.frame">merge.data.frame</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>After merging, the spectra matrix can contain duplicates, and is not
ordered according to the wavelength.
</p>
<p>If the wavelength axis should be ordered, use <code><a href="#topic+orderwl">orderwl</a></code>.
</p>
<p>If a <code>hyperSpec</code> object and  a <code>data.frame</code> are merged, the result is of the class of the first (<code>x</code>) object.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+merge">merge</a></code>.
</p>
<p><code><a href="#topic+collapse">collapse</a></code> combines hyperSpec objects that do not share the wavelength axis.
<code><a href="base.html#topic+rbind">rbind</a></code>, and <code><a href="base.html#topic+cbind">cbind</a></code> for combining hyperSpec objects that.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
merge (chondro [1:10,, 600], chondro [5:15,, 600], by = c("x", "y"))$.
tmp &lt;- merge (chondro [1:10,, 610], chondro [5:15,, 610],
              by = c("x", "y"), all = TRUE)
tmp$.
wl (tmp)

## remove duplicated wavelengths:
approxfun &lt;- function (y, wl, new.wl){
  approx (wl, y, new.wl, method = "constant",
          ties = function (x) mean (x, na.rm = TRUE)
          )$y
}

merged &lt;- merge (chondro [1:7,, 610 ~ 620], chondro [5:10,, 615 ~ 625], all = TRUE)
merged$.
merged &lt;- apply (merged, 1, approxfun,
                 wl = wl (merged), new.wl = unique (wl (merged)),
                 new.wavelength = "new.wl")
merged$.

## merging data.frame into hyperSpec object =&gt; hyperSpec object
y &lt;- data.frame (filename = sample (flu$filename, 4, replace = TRUE), cpred = 1:4)
y
tmp &lt;- merge (flu, y)
tmp$..

## merging hyperSpec object into data.frame =&gt; data.frame
merge (y, flu)
</code></pre>

<hr>
<h2 id='ncol+2ChyperSpec-method'>The Number of Rows (Spectra), Columns, and Data Points per Spectrum of an
hyperSpec Object)</h2><span id='topic+ncol+2ChyperSpec-method'></span><span id='topic+nrow+2ChyperSpec-method'></span><span id='topic+nwl'></span><span id='topic+dim+2ChyperSpec-method'></span><span id='topic+length+2ChyperSpec-method'></span>

<h3>Description</h3>

<p><code>ncol</code> returns the number of columns in <code>x@data</code>. I.e. the number
of columns with additional information to each spectrum (e.g. &quot;x&quot;, &quot;y&quot;,
...) + 1 (for column <code>spc</code> containing the spectra).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hyperSpec'
ncol(x)

## S4 method for signature 'hyperSpec'
nrow(x)

nwl(x)

## S4 method for signature 'hyperSpec'
dim(x)

## S4 method for signature 'hyperSpec'
length(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ncol+2B2ChyperSpec-method_+3A_x">x</code></td>
<td>
<p>a <code>hyperSpec</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nrow</code>, <code>ncol</code>, <code>nwl</code>, and <code>length</code>, return an
<code>integer</code>.
</p>
<p><code>dim</code> returns a vector of length 3.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+ncol">ncol</a></code>
</p>
<p><code><a href="base.html#topic+nrow">nrow</a></code>
</p>
<p><code><a href="base.html#topic+dim">dim</a></code>
</p>
<p><code><a href="base.html#topic+length">length</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ncol (chondro)
nrow (chondro)

nwl  (chondro)
dim (chondro)
length (chondro)
</code></pre>

<hr>
<h2 id='normalize01'>normalization for mixed colors</h2><span id='topic+normalize01'></span><span id='topic+normalize01+2Cmatrix-method'></span><span id='topic+normalize01+2Cnumeric-method'></span><span id='topic+normalize01+2ChyperSpec-method'></span>

<h3>Description</h3>

<p>Normalize numbers -&gt; [0, 1]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize01(x, ...)

## S4 method for signature 'matrix'
normalize01(x, tolerance = hy.getOption("tolerance"))

## S4 method for signature 'numeric'
normalize01(x, tolerance = hy.getOption("tolerance"))

## S4 method for signature 'hyperSpec'
normalize01(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize01_+3A_x">x</code></td>
<td>
<p>vector with values to transform</p>
</td></tr>
<tr><td><code id="normalize01_+3A_...">...</code></td>
<td>
<p>additional parameters such as <code>tolerance</code> handed down.</p>
</td></tr>
<tr><td><code id="normalize01_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance level for determining what is 0 and 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>x</code> is mapped to [0, 1] by subtracting the minimum and subsequently dividing by
the maximum. If all elements of <code>x</code> are equal, 1 is returned.
</p>


<h3>Value</h3>

<p>vector with <code>x</code> values mapped to the interval [0, 1]
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wl.eval">wl.eval</a></code>, <code><a href="#topic+vanderMonde">vanderMonde</a></code>
</p>

<hr>
<h2 id='orderwl'>Sorting the Wavelengths of a hyperSpec Object
Rearranges the <code>hyperSpec</code> object so that the wavelength vector is in increasing (or
decreasing) order.</h2><span id='topic+orderwl'></span>

<h3>Description</h3>

<p>The wavelength vector is sorted and the columns of the spectra matrix are rearranged accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderwl(x, na.last = TRUE, decreasing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderwl_+3A_x">x</code></td>
<td>
<p>The <code>hyperSpec</code> object.</p>
</td></tr>
<tr><td><code id="orderwl_+3A_na.last">na.last</code>, <code id="orderwl_+3A_decreasing">decreasing</code></td>
<td>
<p>Handed to <code><a href="base.html#topic+order">order</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>hyperSpec</code> object.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+order">order</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1: different drawing order in plotspc
spc &lt;- new ("hyperSpec", spc = matrix (rnorm (5) + 1:5, ncol = 5))
spc &lt;- cbind (spc, spc+.5)

plot (spc, "spc")
text (wl (spc), spc [[]], as.character (1:10))
spc &lt;- orderwl (spc)
plot (spc, "spc")
text (wl (spc), spc [[]], as.character (1:10))

## Example 2
spc &lt;- new ("hyperSpec", spc = matrix (rnorm (5)*2 + 1:5, ncol = 5))
spc &lt;- cbind (spc, spc)

plot (seq_len(nwl(spc)), spc[[]], type = "b")
spc[[]]

spc &lt;- orderwl (spc)
lines (seq_len(nwl(spc)), spc[[]], type = "l", col = "red")
spc[[]]

</code></pre>

<hr>
<h2 id='paracetamol'>Paracetamol Spectrum
A Raman spectrum of a paracetamol tablet.</h2><span id='topic+paracetamol'></span>

<h3>Description</h3>

<p>Paracetamol Spectrum
A Raman spectrum of a paracetamol tablet.
</p>


<h3>Format</h3>

<p>The spectrum was acquired with a Renishaw InVia spectrometer from
100 to 3200 cm^-1 in step scan mode. Thus the spectrum has several
overlapping wavelength regions.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
paracetamol

plot (paracetamol)
plotspc (paracetamol, c (min ~ 1750, 2800 ~ max), xoffset = 800,
wl.reverse = TRUE)

</code></pre>

<hr>
<h2 id='pearson.dist'>Distance based on Pearson's <code class="reqn">R^2</code></h2><span id='topic+pearson.dist'></span>

<h3>Description</h3>

<p>The calculated distance is
<code class="reqn">D^2 = \frac{1 - COR (\code{x}')}{2}</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pearson.dist(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pearson.dist_+3A_x">x</code></td>
<td>
<p>a matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distance between the rows of <code>x</code> is calculated.  The possible
values range from 0 (prefectly correlated) over 0.5 (uncorrelated) to 1
(perfectly anti-correlated).
</p>


<h3>Value</h3>

<p>distance matrix (distance object)
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>References</h3>

<p>S. Theodoridis and K. Koutroumbas: Pattern Recognition, 3rd ed., p. 495
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+as.dist">as.dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pearson.dist (flu [[]])
pearson.dist (flu)
</code></pre>

<hr>
<h2 id='plot-methods'>Plotting hyperSpec Objects</h2><span id='topic+plot-methods'></span><span id='topic+plot'></span><span id='topic+plot+2CANY+2CANY-method'></span><span id='topic+plot+2ChyperSpec+2Ccharacter-method'></span><span id='topic+plot+2ChyperSpec+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plotting <code>hyperSpec</code> objects. The <code>plot</code> method for
<code>hyperSpec</code> objects is a switchyard to <code><a href="#topic+plotspc">plotspc</a></code>,
<code><a href="#topic+plotmap">plotmap</a></code>, and <code><a href="#topic+plotc">plotc</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hyperSpec,missing'
plot(x, y, ...)

## S4 method for signature 'hyperSpec,character'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot-methods_+3A_x">x</code></td>
<td>
<p>the <code>hyperSpec</code> object</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_y">y</code></td>
<td>
<p>selects what plot should be produced</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_...">...</code></td>
<td>
<p>arguments passed to the respective plot function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It also supplies some convenient abbrevations for much used plots.
</p>
<p>If <code>y</code> is missing, <code>plot</code> behaves like <code>plot (x, y =
"spc")</code>.
</p>
<p>Supported values for <code>y</code> are:
</p>
 <dl>
<dt>&quot;spc&quot;</dt><dd><p>calls <code><a href="#topic+plotspc">plotspc</a></code> to produce a spectra
plot.</p>
</dd>
<dt>&quot;spcmeansd&quot;</dt><dd><p>plots mean spectrum +/- one standard deviation</p>
</dd>
<dt>&quot;spcprctile&quot;</dt><dd><p>plots 16th, 50th, and 84th percentile spectre. If the
distributions of the intensities at all wavelengths were normal, this would
correspond to <code>"spcmeansd"</code>. However, this is frequently not the case.
Then <code>"spcprctile"</code> gives a better impression of the spectral data
set.</p>
</dd>
<dt>&quot;spcprctl5&quot;</dt><dd><p>like <code>"spcprctile"</code>, but additionally the 5th and
95th percentile spectra are plotted.</p>
</dd>
<dt>&quot;map&quot;</dt><dd><p>calls <code><a href="#topic+plotmap">plotmap</a></code> to produce a map plot.</p>
</dd>
<dt>&quot;voronoi&quot;</dt><dd><p>calls <code><a href="#topic+plotvoronoi">plotvoronoi</a></code> to produce a Voronoi plot
(tesselated plot, like &quot;map&quot; for hyperSpec objects with uneven/non-rectangular
grid).</p>
</dd>
<dt>&quot;mat&quot;</dt><dd><p>calls <code><a href="#topic+plotmat">plotmat</a></code> to produce a plot of the spectra
matrix (not to be confused with <code><a href="graphics.html#topic+matplot">matplot</a></code>).</p>
</dd>
<dt>&quot;c&quot;</dt><dd><p>calls <code><a href="#topic+plotc">plotc</a></code> to produce a calibration (or time
series, depth-profile, or the like)</p>
</dd>
<dt>&quot;ts&quot;</dt><dd><p>plots a time series: abbrevation for <code><a href="#topic+plotc">plotc</a> (x,
use.c = "t")</code></p>
</dd>
<dt>&quot;depth&quot;</dt><dd><p>plots a depth profile: abbrevation for <code><a href="#topic+plotc">plotc</a>
(x, use.c = "z")</code></p>
</dd> </dl>



<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotspc">plotspc</a></code> for spectra plots (intensity over
wavelength),
</p>
<p><code><a href="#topic+plotmap">plotmap</a></code> for plotting maps, i.e. color coded summary value on
two (usually spatial) dimensions.
</p>
<p><code><a href="#topic+plotc">plotc</a></code>
</p>
<p><code><a href="graphics.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot (flu)

plot (flu, "c")

plot (laser, "ts")

spc &lt;- apply (chondro, 2, quantile, probs = 0.05)
spc &lt;- sweep (chondro, 2, spc, "-")
plot (spc, "spcprctl5")
plot (spc, "spcprctile")
plot (spc, "spcmeansd")

</code></pre>

<hr>
<h2 id='plotc'>Calibration- and Timeseries Plots, Depth-Profiles and the like
<code>plotc</code> plots intensities of a <code>hyperSpec</code> object over another
dimension such as concentration, time, or a spatial coordinate.</h2><span id='topic+plotc'></span>

<h3>Description</h3>

<p>If <code>func</code> is not <code>NULL</code>, the summary characteristic is calculated
first by applying <code>func</code> with the respective arguments (in
<code>func.args</code>) to each of the spectra. If <code>func</code> returns more than
one value (for each spectrum), the different values end up as different
wavelengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotc(
  object,
  model = spc ~ c,
  groups = NULL,
  func = NULL,
  func.args = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotc_+3A_object">object</code></td>
<td>
<p>the <code>hyperSpec</code> object</p>
</td></tr>
<tr><td><code id="plotc_+3A_model">model</code></td>
<td>
<p>the lattice model specifying the plot</p>
</td></tr>
<tr><td><code id="plotc_+3A_groups">groups</code></td>
<td>
<p>grouping variable, e.g. <code>.wavelength</code> if intensities of
more than one wavelength should be plotted</p>
</td></tr>
<tr><td><code id="plotc_+3A_func">func</code></td>
<td>
<p>function to compute a summary value from the spectra to be
plotted instead of single intensities</p>
</td></tr>
<tr><td><code id="plotc_+3A_func.args">func.args</code></td>
<td>
<p>further arguments to <code>func</code></p>
</td></tr>
<tr><td><code id="plotc_+3A_...">...</code></td>
<td>
<p>further arguments to <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the wavelength is not used in the model specification nor in
<code>groups</code>, nor for specifying <code>subsets</code>, and neither is
<code>func</code> given, then only the first wavelength's intensities are plotted
and a warning is issued.
</p>
<p>The special column names <code>.rownames</code> and <code>.wavelength</code> may be
used.
</p>
<p>The actual plotting is done by <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+xyplot">xyplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## example 1: calibration of fluorescence 
plotc (flu) ## gives a warning

plotc (flu, func = mean)
plotc (flu, func = range, groups = .wavelength)

plotc (flu[,,450], ylab = expression (I ["450 nm"] / a.u.))


calibration &lt;- lm (spc ~ c, data = flu[,,450]$.)
summary (calibration)
plotc (flu [,, 450], type = c("p", "r"))

conc &lt;- list (c = seq (from = 0.04, to = 0.31, by = 0.01))
ci &lt;- predict (calibration, newdata = conc, interval = "confidence", level = 0.999) 

panel.ci &lt;-  function (x, y, ...,
                       conc, ci.lwr, ci.upr, ci.col = "#606060") {
   panel.xyplot (x, y, ...)
   panel.lmline (x, y,...)
   panel.lines (conc, ci.lwr, col = ci.col)
   panel.lines (conc, ci.upr, col = ci.col)
}

plotc (flu [,, 450], panel = panel.ci,
       conc = conc$c, ci.lwr = ci [, 2], ci.upr = ci [, 3])

## example 2: time-trace of laser emission modes
cols &lt;- c ("black", "blue", "#008000", "red")
wl &lt;- i2wl (laser, c(13, 17, 21, 23))

plotspc (laser, axis.args=list (x = list (at = seq (404.5, 405.8, .1))))
for (i in seq_along (wl))
   abline (v = wl[i], col = cols[i], lwd = 2)

plotc (laser [,, wl], spc ~ t, groups = .wavelength, type = "b",
       col = cols)

</code></pre>

<hr>
<h2 id='plotmap'>Plot a Map and Identify/Select Spectra in the Map
<code><a href="lattice.html#topic+levelplot">levelplot</a></code> functions for hyperSpec objects.  An image or map of a summary
value of each spectrum is plotted. Spectra may be identified by mouse click.</h2><span id='topic+plotmap'></span><span id='topic+plotvoronoi'></span><span id='topic+levelplot+2Cformula+2ChyperSpec-method'></span><span id='topic+levelplot+2ChyperSpec+2Cmissing-method'></span><span id='topic+map.identify'></span>

<h3>Description</h3>

<p>The <code>model</code> can contain the special column name <code>.wavelength</code> to specify the wavelength
axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotmap(object, model = spc ~ x * y, func = mean, func.args = list(), ...)

## S4 method for signature 'hyperSpec,missing'
levelplot(x, data, ...)

## S4 method for signature 'formula,hyperSpec'
levelplot(
  x,
  data,
  transform.factor = TRUE,
  ...,
  contour = FALSE,
  useRaster = !contour
)

map.identify(
  object,
  model = spc ~ x * y,
  voronoi = FALSE,
  ...,
  tol = 0.02,
  warn = TRUE
)

plotvoronoi(object, model = spc ~ x * y, use.tripack = FALSE, mix = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotmap_+3A_object">object</code>, <code id="plotmap_+3A_data">data</code></td>
<td>
<p>the <code>hyperSpec</code> object</p>
</td></tr>
<tr><td><code id="plotmap_+3A_model">model</code>, <code id="plotmap_+3A_x">x</code></td>
<td>
<p>formula specifying the columns of object that are to be
displayed by <code><a href="lattice.html#topic+levelplot">levelplot</a></code></p>
</td></tr>
<tr><td><code id="plotmap_+3A_func">func</code>, <code id="plotmap_+3A_func.args">func.args</code></td>
<td>
<p>Before plotting, <code>plotmap</code> applies function
<code>func</code> with the arguments given in the list <code>func.args</code> to each
of the spectra. Thus a single summary value is displayed for each of the
spectra.
</p>
<p>This can be suppressed manually by setting <code>func</code> to NULL. It is automatically suppressed if
<code>.wavelength</code> appears in the formula.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_...">...</code></td>
<td>
<p>further arguments are passed down the call chain, and finally
to <code><a href="lattice.html#topic+levelplot">levelplot</a></code></p>
</td></tr>
<tr><td><code id="plotmap_+3A_transform.factor">transform.factor</code></td>
<td>
<p>If the color-coded variable is a factor, should
<code><a href="#topic+trellis.factor.key">trellis.factor.key</a></code> be used to compute the color coding and
legend?</p>
</td></tr>
<tr><td><code id="plotmap_+3A_contour">contour</code>, <code id="plotmap_+3A_useraster">useRaster</code></td>
<td>
<p>see  <code><a href="lattice.html#topic+levelplot">levelplot</a></code></p>
</td></tr>
<tr><td><code id="plotmap_+3A_voronoi">voronoi</code></td>
<td>
<p>Should the plot for identifying spectra by mouse click be
produced by <code>plotmap</code> (default) or <code>plotvoronoi</code>?</p>
</td></tr>
<tr><td><code id="plotmap_+3A_tol">tol</code></td>
<td>
<p>tolerance for <code>map.identify</code> as fraction of the viewport
(i.e. in &quot;npc&quot; <a href="grid.html#topic+unit">unit</a>s)</p>
</td></tr>
<tr><td><code id="plotmap_+3A_warn">warn</code></td>
<td>
<p>should a warning be issued if no point is within the specified
tolerance? See also details.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_use.tripack">use.tripack</code></td>
<td>
<p>Whether package tripack should be used for calculating
the voronoi polygons. If <code>FALSE</code>, package deldir is used instead.
See details.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_mix">mix</code></td>
<td>
<p>For Voronoi plots using package tripack, I experienced errors if
the data was spatially ordered. Randomly rearrangig the rows of the
hyperSpec object circumvents this problem.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plotmap</code>, <code>map.identify</code>, and the <code>levelplot</code> methods internally use the same
gateway function to <code><a href="lattice.html#topic+levelplot">levelplot</a></code>. Thus <code>transform.factor</code> can be used
with all of them and the panel function defaults to <code><a href="lattice.html#topic+panel.levelplot.raster">panel.levelplot.raster</a></code>
for all three. Two special column names, <code>.rownames</code> and <code>.wavelength</code> may be used.
</p>
<p><code>levelplot</code> plots the spectra matrix.
</p>
<p><code>plotvoronoi</code> calls <code>plotmap</code> with different default settings, namely the panel
function defaults to <code><a href="latticeExtra.html#topic+panel.voronoi">panel.voronoi</a></code>.
<code><a href="latticeExtra.html#topic+panel.voronoi">panel.voronoi</a></code> depends on either of the packages 'tripack' or 'deldir'
being installed. For further information, please consult the help page of
<code><a href="latticeExtra.html#topic+panel.voronoi">panel.voronoi</a></code>.  On the <code><a href="#topic+chondro">chondro</a></code> data set, <code>plotmap</code>
is roughly 5 times faster than <code>plotvoronoi</code> using tripack, and ca. 15 times faster than
<code>plotvoronoi</code> using deldir. Package tripack, however, is free only for non-commercial
use. Also, it seems that tripack version hang (R running at full CPU power, but not responding
nor finishing the calculation) for certain data sets. In this case, <code>mix = TRUE</code> may help.
</p>
<p><code>map.identify</code> calls <code>plotmap</code> and <code>plotvoronoi</code>, respectively and waits for
(left) mouse clicks on points. Other mouse clicks end the input.
</p>
<p>Unlike <code><a href="lattice.html#topic+panel.identify">panel.identify</a></code>, the indices returned by <code>map.identify</code> are in
the same order as the points were clicked. Also, multiple clicks on the same point are returned
as multiple entries with the same index.
</p>
<p><code>map.identify</code> uses option <code>debuglevel</code> similar to <code><a href="#topic+spc.identify">spc.identify</a></code>:
<code>debuglevel == 1</code> will plot the tolerance window if no data point was inside (and
additionally labels the point) while <code>debuglevel == 2</code> will always plot the tolerance
window.
</p>
<p>The <code>map.sel.*</code> functions offer further interactive selection, see
<code><a href="#topic+map.sel.poly">map.sel.poly</a></code>.
</p>


<h3>Value</h3>

<p><code>map.identify</code> returns a vector of row indices into
<code>object</code> of the clicked points.
</p>
<p>The other functions return a lattice object.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code>vignette (plotting)</code>, <code>vignette (hyperspec)</code>
</p>
<p><code><a href="#topic+plot">plot</a></code>
</p>
<p><code><a href="lattice.html#topic+levelplot">levelplot</a></code>
</p>
<p><code><a href="#topic+trellis.factor.key">trellis.factor.key</a></code> for improved color coding of factors
</p>
<p><code><a href="#topic+options">hyperSpec options</a></code> <code><a href="#topic+spc.identify">spc.identify</a></code>
<code><a href="#topic+map.sel.poly">map.sel.poly</a></code>
</p>
<p><code><a href="latticeExtra.html#topic+panel.voronoi">panel.voronoi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
vignette (plotting)
vignette (hyperspec)

## End(Not run)

levelplot (spc ~ y * x, chondro [,,1003]) # properly rotated
plotmap (chondro [,,1003])

# plot spectra matrix
levelplot (spc ~ .wavelength * t, laser, contour = TRUE, col = "#00000080")
# see also plotmat

plotmap (chondro, clusters ~ x * y)

# Voronoi plots
smpl &lt;- sample (chondro, 300)
plotmap (smpl, clusters ~ x * y)
if (require (deldir))
    plotvoronoi (smpl, clusters ~ x * y,
                 use.tripack = FALSE)

</code></pre>

<hr>
<h2 id='plotmat'>Plot spectra matrix</h2><span id='topic+plotmat'></span>

<h3>Description</h3>

<p>plots the spectra matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotmat(
  object,
  y = ".row",
  ylab,
  col = alois.palette(20),
  ...,
  contour = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotmat_+3A_object">object</code></td>
<td>
<p>hyperSpec object</p>
</td></tr>
<tr><td><code id="plotmat_+3A_y">y</code></td>
<td>
<p>character giving the name of the extra data column to label the y axis.</p>
</td></tr>
<tr><td><code id="plotmat_+3A_ylab">ylab</code></td>
<td>
<p>y axis label, defaults to <code>"row"</code> and the label of the extra data column used
for the y axis, respectively.</p>
</td></tr>
<tr><td><code id="plotmat_+3A_col">col</code></td>
<td>
<p>see  <code><a href="graphics.html#topic+image">image</a></code></p>
</td></tr>
<tr><td><code id="plotmat_+3A_...">...</code></td>
<td>
<p>further parameters for <code><a href="graphics.html#topic+image">image</a></code></p>
</td></tr>
<tr><td><code id="plotmat_+3A_contour">contour</code></td>
<td>
<p>should <code><a href="graphics.html#topic+contour">contour</a></code> be called instead of
<code><a href="graphics.html#topic+image">image</a></code>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If package plotrix is available, a color legend is plotted to the right. The right margin is set
to at least 5 lines.
</p>


<h3>Author(s)</h3>

<p>Claudia Beleites
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+image">image</a></code>, <code><a href="graphics.html#topic+contour">contour</a></code>, <code><a href="#topic+levelplot">levelplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotmat (laser, col = alois.palette (100))

plot (laser, "mat")

plotmat (laser)
plotmat (laser, contour = TRUE, add = TRUE)

## use different y axis labels

plotmat (laser, "t")

plotmat (laser, laser$t / 3600, ylab = "t / h")
</code></pre>

<hr>
<h2 id='plotspc'>Plotting Spectra
Plot the spectra of a <code>hyperSpec</code> object, i.e. intensity over
wavelength. Instead of the intensity values of the spectra matrix summary
values calculated from these may be used.</h2><span id='topic+plotspc'></span><span id='topic+stacked.offsets'></span>

<h3>Description</h3>

<p>This is <code>hyperSpec</code>'s main plotting function for spectra plots.
</p>
<p>Usually, the <code>stacked</code> argument of <code><a href="#topic+plotspc">plotspc</a></code> will do fine, but if you
need fine control over the stacking, you may calculate the y offsets yourself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotspc(
  object,
  wl.range = TRUE,
  wl.index = FALSE,
  wl.reverse = FALSE,
  spc.nmax = hy.getOption("plot.spc.nmax"),
  func = NULL,
  func.args = list(),
  stacked = NULL,
  stacked.args = list(),
  add = FALSE,
  bty = "l",
  plot.args = list(),
  col = "black",
  lines.args = list(),
  xoffset = 0,
  yoffset = 0,
  nxticks = 10,
  axis.args = list(),
  break.args = list(),
  title.args = list(),
  fill = NULL,
  fill.col = NULL,
  border = NA,
  polygon.args = list(),
  zeroline = list(lty = 2, col = col),
  debuglevel = hy.getOption("debuglevel")
)

stacked.offsets(
  x,
  stacked = TRUE,
  min.zero = FALSE,
  add.factor = 0.05,
  add.sum = 0,
  .spc = NULL,
  debuglevel = hy.getOption("debuglevel")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotspc_+3A_object">object</code></td>
<td>
<p>the <code>hyperSpec</code> object</p>
</td></tr>
<tr><td><code id="plotspc_+3A_wl.range">wl.range</code></td>
<td>
<p>the wavelength range to be plotted.
</p>
<p>Either a numeric vector or a list of vectors with different wavelength
ranges to be plotted separately.
</p>
<p>The values can be either wavelengths or wavelength indices (according to
<code>wl.index</code>).</p>
</td></tr>
<tr><td><code id="plotspc_+3A_wl.index">wl.index</code></td>
<td>
<p>if <code>TRUE</code>, <code>wl.range</code> is considered to give
column indices into the spectra matrix. Defaults to specifying wavelength
values rather than indices.</p>
</td></tr>
<tr><td><code id="plotspc_+3A_wl.reverse">wl.reverse</code></td>
<td>
<p>if <code>TRUE</code>, the wavelength axis is plotted backwards.</p>
</td></tr>
<tr><td><code id="plotspc_+3A_spc.nmax">spc.nmax</code></td>
<td>
<p>maximal number of spectra to be plotted (to avoid
accidentally plotting of large numbers of spectra).</p>
</td></tr>
<tr><td><code id="plotspc_+3A_func">func</code></td>
<td>
<p>a function to apply to each wavelength in order to calculate
summary spectra such as mean, min, max, etc.</p>
</td></tr>
<tr><td><code id="plotspc_+3A_func.args">func.args</code></td>
<td>
<p><code>list</code> with furter arguments for <code>func</code></p>
</td></tr>
<tr><td><code id="plotspc_+3A_stacked">stacked</code></td>
<td>
<p>if not <code>NULL</code>, a &quot;stacked&quot; plot is produced, see the
example. <code>stacked</code> may be <code>TRUE</code> to stack single spectra.  A
numeric or factor is interpreted as giving the grouping, character is
interpreted as the name of the extra data column that holds the groups.</p>
</td></tr>
<tr><td><code id="plotspc_+3A_stacked.args">stacked.args</code></td>
<td>
<p>a list with further arguments to
<code><a href="#topic+stacked.offsets">stacked.offsets</a></code>.</p>
</td></tr>
<tr><td><code id="plotspc_+3A_add">add</code></td>
<td>
<p>if <code>TRUE</code>, the output is added to the existing plot</p>
</td></tr>
<tr><td><code id="plotspc_+3A_bty">bty</code></td>
<td>
<p>see <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plotspc_+3A_plot.args">plot.args</code></td>
<td>
<p><code>list</code> with further arguments to
<code><a href="graphics.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plotspc_+3A_col">col</code></td>
<td>
<p>see <code><a href="graphics.html#topic+par">par</a></code>. <code>col</code> might be a vector
giving individual colors for the spectra.</p>
</td></tr>
<tr><td><code id="plotspc_+3A_lines.args">lines.args</code></td>
<td>
<p>list with further arguments to
<code><a href="graphics.html#topic+lines">lines</a></code>.
</p>
<p><code>lines.args$type</code> defaults to &quot;l&quot;.</p>
</td></tr>
<tr><td><code id="plotspc_+3A_xoffset">xoffset</code></td>
<td>
<p>vector with abscissa offsets for each of the
<code>wl.range</code>s. If it has one element less than there are
<code>wl.range</code>s, 0 is padded at the beginning.
</p>
<p>The values are interpreted as the distance along the wavelength axis that
the following parts of the spectra are shifted towards the origin. E.g.
if <code>wl.range = list (600 ~ 1800, 2800 ~ 3200)</code>, <code>xoffset = 750</code>
would result in a reasonable plot. See also the examples.</p>
</td></tr>
<tr><td><code id="plotspc_+3A_yoffset">yoffset</code></td>
<td>
<p>ordinate offset values for the spectra. May be offsets to
stack the spectra (<code><a href="#topic+stacked.offsets">stacked.offsets</a></code>). Either one for all
spectra, one per spectrum or one per group in <code>stacked</code>.</p>
</td></tr>
<tr><td><code id="plotspc_+3A_nxticks">nxticks</code></td>
<td>
<p>hint how many tick marks the abscissa should have.</p>
</td></tr>
<tr><td><code id="plotspc_+3A_axis.args">axis.args</code></td>
<td>
<p><code>list</code> with further arguments for
<code><a href="graphics.html#topic+axis">axis</a></code>. <code>axis.args$x</code> should contain arguments
for plotting the abscissa, <code>axis.args$y</code> those for the ordinate
(again as <code>lists</code>).</p>
</td></tr>
<tr><td><code id="plotspc_+3A_break.args">break.args</code></td>
<td>
<p>list with arguments for
<code><a href="plotrix.html#topic+axis.break">axis.break</a></code>.</p>
</td></tr>
<tr><td><code id="plotspc_+3A_title.args">title.args</code></td>
<td>
<p>list with further arguments to
<code><a href="graphics.html#topic+title">title</a></code>.
</p>
<p><code>title.args</code> may contain two lists, <code>$x</code>, and <code>$y</code> to set
parameters individually for each axis.</p>
</td></tr>
<tr><td><code id="plotspc_+3A_fill">fill</code></td>
<td>
<p>if not <code>NULL</code>, the area between the specified spectra is
filled with color <code>col</code>. The grouping can be given as factor or
numeric, or as a character with the name of the extra data column to use.
If a group contains more than 2 spectra, the first and the last are used.
</p>
<p>If <code>TRUE</code> spectra n and nrow (spc) - n build a group.</p>
</td></tr>
<tr><td><code id="plotspc_+3A_fill.col">fill.col</code></td>
<td>
<p>character vector with fill color. Defaults to brightened
colors from <code>col</code>.</p>
</td></tr>
<tr><td><code id="plotspc_+3A_border">border</code></td>
<td>
<p>character vector with border color. You will need to set the
line color <code>col</code> to <code>NA</code> in order see the effect.</p>
</td></tr>
<tr><td><code id="plotspc_+3A_polygon.args">polygon.args</code></td>
<td>
<p>list with further arguments to
<code><a href="graphics.html#topic+polygon">polygon</a></code> which draws the filled areas.</p>
</td></tr>
<tr><td><code id="plotspc_+3A_zeroline">zeroline</code></td>
<td>
<p><code>NA</code> or a list with arguments
<code><a href="graphics.html#topic+abline">abline</a></code>, used to plot line (s) marking I = 0.
</p>
<p><code>NA</code> suppresses plotting of the line.  The line is by default turned
off if <code>yoffset</code> is not 0.</p>
</td></tr>
<tr><td><code id="plotspc_+3A_debuglevel">debuglevel</code></td>
<td>
<p>if &gt; 0, additional debug output is produced,
see <code><a href="#topic+options">options</a></code> for details</p>
</td></tr>
<tr><td><code id="plotspc_+3A_x">x</code></td>
<td>
<p>a <code>hyperSpec</code> object</p>
</td></tr>
<tr><td><code id="plotspc_+3A_min.zero">min.zero</code></td>
<td>
<p>if <code>TRUE</code>, the lesser of zero and the minimum intensity of the spectrum is
used as minimum.</p>
</td></tr>
<tr><td><code id="plotspc_+3A_add.factor">add.factor</code>, <code id="plotspc_+3A_add.sum">add.sum</code></td>
<td>
<p>proportion and absolute amount of space that should be added.</p>
</td></tr>
<tr><td><code id="plotspc_+3A_.spc">.spc</code></td>
<td>
<p>for internal use. If given, the ranges are evaluated on <code>.spc</code>. However, this
may change in future.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>New plots are created by <code><a href="graphics.html#topic+plot">plot</a></code>, but the abscissa and
ordinate are drawn separately by <code><a href="graphics.html#topic+axis">axis</a></code>. Also,
<code><a href="graphics.html#topic+title">title</a></code> is called explicitly to set up titles and
axis labels. This allows fine-grained customization of the plots.
</p>
<p>If package plotrix is available, its function
<code><a href="plotrix.html#topic+axis.break">axis.break</a></code> is used to produce break marks for cut
wavelength axes.
</p>
<p>Empty levels of the stacking factor are dropped (as no stacking offset can be calculated in that
case.)
</p>


<h3>Value</h3>

<p><code>plotspc</code> invisibly returns a list with
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>the abscissa coordinates of the plotted spectral data points</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a matrix the ordinate coordinates of the plotted spectral data
points</p>
</td></tr>
<tr><td><code>wavelengths</code></td>
<td>
<p>the wavelengths of the plotted spectral data points</p>
</td></tr>
</table>
<p>This can be used together with <code><a href="#topic+spc.identify">spc.identify</a></code>.
</p>
<p>a list containing </p>
<table role = "presentation">
<tr><td><code>offsets</code></td>
<td>
<p>numeric with the yoffset for each group in
<code>stacked</code></p>
</td></tr> <tr><td><code>groups</code></td>
<td>
<p>numeric with the group number for each spectrum</p>
</td></tr> <tr><td><code>levels</code></td>
<td>
<p>if
<code>stacked</code> is a factor, the levels of the groups</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>C. Beleites
</p>
<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+axis">axis</a></code>,
<code><a href="graphics.html#topic+title">title</a></code>, <code><a href="graphics.html#topic+lines">lines</a></code>,
<code><a href="graphics.html#topic+polygon">polygon</a></code>, <code><a href="graphics.html#topic+par">par</a></code> for the
description of the respective arguments.
</p>
<p><code><a href="plotrix.html#topic+axis.break">axis.break</a></code> for cut marks
</p>
<p>See <code><a href="#topic+plot">plot</a></code> for some predefined spectra plots such as mean
spectrum +/- one standard deviation and the like.
</p>
<p><code><a href="graphics.html#topic+identify">identify</a></code> and <code><a href="graphics.html#topic+locator">locator</a></code> about
interaction with plots.
</p>
<p><code><a href="#topic+plotspc">plotspc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plotspc (flu)

## artificial example to show wavelength axis cutting
plotspc (chondro [sample (nrow (chondro), 50)],
         wl.range = list (600 ~ 650, 1000 ~ 1100, 1600 ~ 1700),
         xoffset = c (0, 300, 450))

plotspc (chondro [sample (nrow (chondro), 50)],
         wl.range = list (600 ~ 650, 1000 ~ 1100, 1600 ~ 1700),
         xoffset = c (300, 450))

## some journals publish Raman spectra backwards
plotspc (chondro [sample (nrow (chondro), 50)], wl.reverse = TRUE)

plotspc (laser[(0:4)*20+1,,], stacked = TRUE)

plotspc (laser, func = mean_pm_sd,
         col = c(NA, "red", "black"), lines.args = list (lwd = 2),
         fill = c (1, NA, 1),
         fill.col = "yellow", border = "blue",
         polygon.args = list (lty = 2, lwd = 4),
         title.args = list (xlab = expression (lambda[emission] / nm),
                            y = list(line = 3.4),
                            col.lab = "darkgreen"),
         axis.args = list (x = list (col = "magenta"), y = list (las = 1))
        )

mean.pm.sd &lt;- aggregate (chondro, chondro$clusters, mean_pm_sd)
plot (mean.pm.sd, col = matlab.palette (3), fill = ".aggregate", stacked = ".aggregate")


mean.pm.sd &lt;- aggregate (chondro, chondro$clusters, mean_pm_sd)

offset &lt;- stacked.offsets (mean.pm.sd, ".aggregate")
plot (mean.pm.sd, fill.col = matlab.palette (3), fill = ".aggregate",
      stacked = ".aggregate")

plot (aggregate (chondro, chondro$clusters, mean), yoffset = offset$offsets,
      lines.args = list (lty = 2, lwd = 2), add = TRUE)

barb &lt;- do.call (collapse, barbiturates [1:3])
plot (barb, lines.args = list (type = "h"), stacked = TRUE,
      stacked.args = list (add.factor = .2))


</code></pre>

<hr>
<h2 id='qplotc'>Spectra plotting with ggplot2</h2><span id='topic+qplotc'></span>

<h3>Description</h3>

<p>Spectra plotting with ggplot2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qplotc(
  object,
  mapping = aes_string(x = "c", y = "spc"),
  ...,
  func = NULL,
  func.args = list(),
  map.pointonly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qplotc_+3A_object">object</code></td>
<td>
<p>hyperSpec object</p>
</td></tr>
<tr><td><code id="qplotc_+3A_mapping">mapping</code></td>
<td>
<p>see  <code><a href="ggplot2.html#topic+geom_point">geom_point</a></code></p>
</td></tr>
<tr><td><code id="qplotc_+3A_...">...</code></td>
<td>
<p>handed to <code><a href="ggplot2.html#topic+geom_point">geom_point</a></code></p>
</td></tr>
<tr><td><code id="qplotc_+3A_func">func</code></td>
<td>
<p>function to summarize the wavelengths, if <code>NULL</code>, only the first wavelength is used</p>
</td></tr>
<tr><td><code id="qplotc_+3A_func.args">func.args</code></td>
<td>
<p>arguments to <code>func</code></p>
</td></tr>
<tr><td><code id="qplotc_+3A_map.pointonly">map.pointonly</code></td>
<td>
<p>if <code>TRUE</code>, <code>mapping</code> will be handed to
<code><a href="ggplot2.html#topic+geom_point">geom_point</a></code> instead of <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are still experimental and may change substantially in future.
</p>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object
</p>


<h3>Author(s)</h3>

<p>Claudia Beleites
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotc">plotc</a></code>
</p>
<p><code><a href="ggplot2.html#topic+ggplot">ggplot</a></code><code><a href="ggplot2.html#topic+geom_point">geom_point</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qplotc (flu)
qplotc (flu) + geom_smooth (method = "lm")
</code></pre>

<hr>
<h2 id='qplotmap'>Spectra plotting with ggplot2</h2><span id='topic+qplotmap'></span>

<h3>Description</h3>

<p>Spectra plotting with ggplot2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qplotmap(
  object,
  mapping = aes_string(x = "x", y = "y", fill = "spc"),
  ...,
  func = mean,
  func.args = list(),
  map.tileonly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qplotmap_+3A_object">object</code></td>
<td>
<p>hyperSpec object</p>
</td></tr>
<tr><td><code id="qplotmap_+3A_mapping">mapping</code></td>
<td>
<p>see  <code><a href="ggplot2.html#topic+geom_tile">geom_tile</a></code></p>
</td></tr>
<tr><td><code id="qplotmap_+3A_...">...</code></td>
<td>
<p>handed to <code><a href="ggplot2.html#topic+geom_tile">geom_tile</a></code></p>
</td></tr>
<tr><td><code id="qplotmap_+3A_func">func</code></td>
<td>
<p>function to summarize the wavelengths</p>
</td></tr>
<tr><td><code id="qplotmap_+3A_func.args">func.args</code></td>
<td>
<p>arguments to <code>func</code></p>
</td></tr>
<tr><td><code id="qplotmap_+3A_map.tileonly">map.tileonly</code></td>
<td>
<p>if <code>TRUE</code>, <code>mapping</code> will be handed to
<code><a href="ggplot2.html#topic+geom_tile">geom_tile</a></code> instead of <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are still experimental and may change substantially in future.
</p>
<p>Note that <code>qplotmap</code> will currently produce the wrong scales if x or y are discrete.
</p>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object
</p>


<h3>Author(s)</h3>

<p>Claudia Beleites
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotmap">plotmap</a></code>
</p>
<p><code><a href="ggplot2.html#topic+ggplot">ggplot</a></code><code><a href="ggplot2.html#topic+geom_tile">geom_tile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qplotmap (chondro)
qplotmap (chondro) + scale_fill_gradientn (colours = alois.palette ())
</code></pre>

<hr>
<h2 id='qplotmixmap'>qplotmap with colour mixing for multivariate overlay</h2><span id='topic+qplotmixmap'></span>

<h3>Description</h3>

<p>map plot with colour overlay.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qplotmixmap(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qplotmixmap_+3A_object">object</code></td>
<td>
<p>hyperSpec object</p>
</td></tr>
<tr><td><code id="qplotmixmap_+3A_...">...</code></td>
<td>
<p>handed over to <code><a href="#topic+qmixlegend">qmixlegend</a></code> and <code><a href="#topic+qmixtile">qmixtile</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible list with ggplot2 objects map and legend
</p>


<h3>Author(s)</h3>

<p>Claudia Beleites
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qmixtile">qmixtile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chondro &lt;- chondro - spc.fit.poly.below (chondro)
chondro &lt;- sweep (chondro, 1, apply (chondro, 1, mean), "/")
chondro &lt;- sweep (chondro, 2, apply (chondro, 2, quantile, 0.05), "-")

qplotmixmap (chondro [,,c (940, 1002, 1440)],
             purecol = c (colg = "red", Phe = "green", Lipid = "blue"))

</code></pre>

<hr>
<h2 id='qplotspc'>Spectra plotting with ggplot2</h2><span id='topic+qplotspc'></span>

<h3>Description</h3>

<p>Spectra plotting with ggplot2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qplotspc(
  x,
  wl.range = TRUE,
  ...,
  mapping = aes_string(x = ".wavelength", y = "spc", group = ".rownames"),
  spc.nmax = hy.getOption("ggplot.spc.nmax"),
  map.lineonly = FALSE,
  debuglevel = hy.getOption("debuglevel")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qplotspc_+3A_x">x</code></td>
<td>
<p>hyperSpec object</p>
</td></tr>
<tr><td><code id="qplotspc_+3A_wl.range">wl.range</code></td>
<td>
<p>wavelength ranges to plot</p>
</td></tr>
<tr><td><code id="qplotspc_+3A_...">...</code></td>
<td>
<p>handed to <code><a href="ggplot2.html#topic+geom_line">geom_line</a></code></p>
</td></tr>
<tr><td><code id="qplotspc_+3A_mapping">mapping</code></td>
<td>
<p>see  <code><a href="ggplot2.html#topic+geom_line">geom_line</a></code></p>
</td></tr>
<tr><td><code id="qplotspc_+3A_spc.nmax">spc.nmax</code></td>
<td>
<p>maximum number of spectra to plot</p>
</td></tr>
<tr><td><code id="qplotspc_+3A_map.lineonly">map.lineonly</code></td>
<td>
<p>if <code>TRUE</code>, <code>mapping</code> will be handed to
<code><a href="ggplot2.html#topic+geom_line">geom_line</a></code> instead of <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.</p>
</td></tr>
<tr><td><code id="qplotspc_+3A_debuglevel">debuglevel</code></td>
<td>
<p>if &gt; 0, additional debug output is produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are still experimental and may change substantially in future.
</p>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object
</p>


<h3>Author(s)</h3>

<p>Claudia Beleites
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotspc">plotspc</a></code>
</p>
<p><code><a href="ggplot2.html#topic+ggplot">ggplot</a></code><code><a href="ggplot2.html#topic+geom_line">geom_line</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  qplotspc (chondro)

  qplotspc (paracetamol, c (2800 ~ max, min ~ 1800)) + scale_x_reverse (breaks = seq (0, 3200, 400))

  qplotspc (aggregate (chondro, chondro$clusters, mean),
            mapping = aes (x = .wavelength, y = spc, colour = clusters)) +
    facet_grid (clusters ~ .)

  qplotspc (aggregate (chondro, chondro$clusters, mean_pm_sd),
            mapping = aes (x = .wavelength, y = spc, colour = clusters, group = .rownames)) +
    facet_grid (clusters ~ .)
</code></pre>

<hr>
<h2 id='quickdf'>Quick data frame.
Experimental version of <code><a href="#topic+as.data.frame">as.data.frame</a></code> that converts a
list to a data frame, but doesn't do any checks to make sure it's a
valid format. Much faster.</h2><span id='topic+quickdf'></span>

<h3>Description</h3>

<p>Quick data frame.
Experimental version of <code><a href="#topic+as.data.frame">as.data.frame</a></code> that converts a
list to a data frame, but doesn't do any checks to make sure it's a
valid format. Much faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quickdf(list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quickdf_+3A_list">list</code></td>
<td>
<p>list to convert to data frame</p>
</td></tr>
</table>

<hr>
<h2 id='rbind.fill.matrix'>Bind matrices by row, and fill missing columns with NA</h2><span id='topic+rbind.fill.matrix'></span><span id='topic+rbind.fill'></span>

<h3>Description</h3>

<p>The matrices are bound together using their column names or the column indices (in that order of
precedence.) Numeric columns may be converted to character beforehand, e.g. using format.  If a
matrix doesn't have colnames, the column number is used (via <code><a href="base.html#topic+make.names">make.names</a>(unique
= TRUE)</code>).
</p>
<p>This is an enhancement to <code><a href="base.html#topic+rbind">rbind</a></code> which adds in columns
that are not present in all inputs, accepts a list of data frames, and
operates substantially faster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
rbind.fill(...)

## S3 method for class 'fill'
rbind(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rbind.fill.matrix_+3A_...">...</code></td>
<td>
<p>data frames/matrices to row bind together</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this means that a column with name <code>"X1"</code> is merged with the first column of a
matrix without name and so on.
</p>
<p>Vectors are converted to 1-column matrices prior to rbind.
</p>
<p>Matrices of factors are not supported. (They are anyways quite inconvenient.) You may convert
them first to either numeric or character matrices. If a character matrix is merged with a
numeric, the result will be character.
</p>
<p>Row names are ignored.
</p>
<p>The return matrix will always have column names.
</p>


<h3>Value</h3>

<p>a matrix
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rbind">rbind</a></code>, <code><a href="base.html#topic+cbind">cbind</a></code>, <code>plyr::rbind.fill()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> A &lt;- matrix (1:4, 2)
 B &lt;- matrix (6:11, 2)
 A
 B
 hyperSpec:::rbind.fill.matrix (A, B)

 colnames (A) &lt;- c (3, 1)
 A
 hyperSpec:::rbind.fill.matrix (A, B)

 hyperSpec:::rbind.fill.matrix (A, 99)

#' rbind.fill(mtcars[c("mpg", "wt")], mtcars[c("wt", "cyl")])
</code></pre>

<hr>
<h2 id='read.asc.PerkinElmer'>File import filter PerkinElmer ASCII spectra</h2><span id='topic+read.asc.PerkinElmer'></span>

<h3>Description</h3>

<p>Imports a single spectrum in PerkinElmer's ASCII format. This function is experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.asc.PerkinElmer(file = stop("filename or connection needed"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.asc.PerkinElmer_+3A_file">file</code></td>
<td>
<p>filename (or connection)</p>
</td></tr>
<tr><td><code id="read.asc.PerkinElmer_+3A_...">...</code></td>
<td>
<p>further parameters are handed to <code><a href="#topic+read.txt.long">read.txt.long</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>hyperSpec object
</p>

<hr>
<h2 id='read.cytomat'>Import for Cytospec mat files</h2><span id='topic+read.cytomat'></span><span id='topic+read.mat.Cytospec'></span>

<h3>Description</h3>

<p>These functions allow to import .mat (Matlab V5) files written by Cytospec.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.cytomat(...)

read.mat.Cytospec(file, keys2data = FALSE, blocks = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.cytomat_+3A_...">...</code></td>
<td>
<p><code>read.cytomat</code> for now hands all arguments to
<code>read.mat.Cytospec</code> for backwards compatibility.</p>
</td></tr>
<tr><td><code id="read.cytomat_+3A_file">file</code></td>
<td>
<p>The complete file name (or a connection to) the .mat file.</p>
</td></tr>
<tr><td><code id="read.cytomat_+3A_keys2data">keys2data</code></td>
<td>
<p>specifies which elements of the <code>Info</code> should be
transferred into the extra data</p>
</td></tr>
<tr><td><code id="read.cytomat_+3A_blocks">blocks</code></td>
<td>
<p>which blocks should be read? <code>TRUE</code> reads all blocks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>read.cytomat</code> has been renamed to <code>read.mat.Cytospec</code> and is now
deprecated. Use <code>read.mat.Cytospec</code> instead.
</p>


<h3>Value</h3>

<p>hyperSpec object if the file contains a single spectra block,
otherwise a list with one hyperSpec object for each block.
</p>


<h3>Note</h3>

<p>This function is an ad-hoc implementation and subject to changes.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code>R.matlab::readMat</code>
</p>

<hr>
<h2 id='read.ENVI'>Import of ENVI data as hyperSpec object</h2><span id='topic+read.ENVI'></span><span id='topic+read.ENVI.Nicolet'></span><span id='topic+read.ENVI.HySpex'></span>

<h3>Description</h3>

<p>This function allows ENVI data import as <code>hyperSpec</code> object.
</p>
<p><code>read.ENVI.Nicolet</code> should be a good starting point for writing custom
wrappers for <code>read.ENVI</code> that take into account your manufacturer's
special entries in the header file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.ENVI(
  file = stop("read.ENVI: file name needed"),
  headerfile = NULL,
  header = list(),
  keys.hdr2data = FALSE,
  x = 0:1,
  y = x,
  wavelength = NULL,
  label = list(),
  block.lines.skip = 0,
  block.lines.size = NULL,
  ...,
  pull.header.lines = TRUE
)

read.ENVI.HySpex(
  file = stop("read.ENVI.HySpex: file name needed"),
  headerfile = NULL,
  header = list(),
  keys.hdr2data = NULL,
  ...
)

read.ENVI.Nicolet(
  file = stop("read.ENVI: file name needed"),
  headerfile = NULL,
  header = list(),
  ...,
  x = NA,
  y = NA,
  nicolet.correction = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.ENVI_+3A_file">file</code></td>
<td>
<p>complete name of the binary file</p>
</td></tr>
<tr><td><code id="read.ENVI_+3A_headerfile">headerfile</code></td>
<td>
<p>name of the ASCII header file. If <code>NULL</code>, the name
of the header file is guessed by looking for a second file with the same
basename as <code>file</code> but <code>hdr</code> or <code>HDR</code> suffix.</p>
</td></tr>
<tr><td><code id="read.ENVI_+3A_header">header</code></td>
<td>
<p>list with header information, see details. Overwrites information extracted from the header file.</p>
</td></tr>
<tr><td><code id="read.ENVI_+3A_keys.hdr2data">keys.hdr2data</code></td>
<td>
<p>determines which fields of the header file should be
put into the extra data. Defaults to none.
</p>
<p>To specify certain entries, give character vectors containing the lowercase
names of the header file entries.</p>
</td></tr>
<tr><td><code id="read.ENVI_+3A_x">x</code>, <code id="read.ENVI_+3A_y">y</code></td>
<td>
<p>vectors of form c(offset, step size) for the position vectors,
see details.</p>
</td></tr>
<tr><td><code id="read.ENVI_+3A_wavelength">wavelength</code>, <code id="read.ENVI_+3A_label">label</code></td>
<td>
<p>lists that overwrite the respective information
from the ENVI header file. These data is then handed to
<code><a href="#topic+initialize">initialize</a></code></p>
</td></tr>
<tr><td><code id="read.ENVI_+3A_block.lines.skip">block.lines.skip</code>, <code id="read.ENVI_+3A_block.lines.size">block.lines.size</code></td>
<td>
<p>BIL and BIP ENVI files may be read in blocks of lines:
skip the first <code>block.lines.skip</code> lines, then read a block of <code>block.lines.size</code>
lines. If <code>block.lines.NULL</code>, the whole file is read.
Blocks are silently truncated at the end of the file (more precisely: to <code>header$lines</code>).</p>
</td></tr>
<tr><td><code id="read.ENVI_+3A_...">...</code></td>
<td>
<p>currently unused by <code>read.ENVI</code>,
<code>read.ENVI.Nicolet</code> hands those arguements over to <code>read.ENVI</code></p>
</td></tr>
<tr><td><code id="read.ENVI_+3A_pull.header.lines">pull.header.lines</code></td>
<td>
<p>(internal) flag whether multi-line header entries grouped by curly
braces should be pulled into one line each.</p>
</td></tr>
<tr><td><code id="read.ENVI_+3A_nicolet.correction">nicolet.correction</code></td>
<td>
<p>see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ENVI data usually consists of two files, an ASCII header and a binary data
file. The header contains all information necessary for correctly reading
the binary file.
</p>
<p>I experienced missing header files (or rather: header files without any
contents) produced by Bruker Opus' ENVI export.
</p>
<p>In this case the necessary information can be given as a list in parameter
<code>header</code> instead:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>header$</code>          </td><td style="text-align: left;"> values        </td><td style="text-align: left;"> meaning</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>samples</code>          </td><td style="text-align: left;"> integer       </td><td style="text-align: left;"> no of columns / spectra in x direction</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>lines</code>            </td><td style="text-align: left;"> integer       </td><td style="text-align: left;"> no of lines / spectra in y direction</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>bands</code>            </td><td style="text-align: left;"> integer       </td><td style="text-align: left;"> no of wavelengths / data points per spectrum</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>`data type`</code>      </td><td style="text-align: left;">               </td><td style="text-align: left;"> format of the binary file</td>
</tr>
<tr>
 <td style="text-align: left;">
                        </td><td style="text-align: left;"> 1             </td><td style="text-align: left;"> 1 byte unsigned integer </td>
</tr>
<tr>
 <td style="text-align: left;">
                        </td><td style="text-align: left;"> 2             </td><td style="text-align: left;"> 2 byte signed integer </td>
</tr>
<tr>
 <td style="text-align: left;">
                        </td><td style="text-align: left;"> 3             </td><td style="text-align: left;"> 4 byte signed integer </td>
</tr>
<tr>
 <td style="text-align: left;">
                        </td><td style="text-align: left;"> 4             </td><td style="text-align: left;"> 4 byte float </td>
</tr>
<tr>
 <td style="text-align: left;">
                        </td><td style="text-align: left;"> 5             </td><td style="text-align: left;"> 8 byte double </td>
</tr>
<tr>
 <td style="text-align: left;">
                        </td><td style="text-align: left;"> 9             </td><td style="text-align: left;"> 16 (2 x 8) byte complex double </td>
</tr>
<tr>
 <td style="text-align: left;">
                        </td><td style="text-align: left;"> 12            </td><td style="text-align: left;"> 2 byte unsigned integer </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>`header offset`</code> </td><td style="text-align: left;"> integer       </td><td style="text-align: left;"> number of bytes to skip before binary data starts</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>interleave</code>      </td><td style="text-align: left;">               </td><td style="text-align: left;"> directions of the data cube </td>
</tr>
<tr>
 <td style="text-align: left;">
                        </td><td style="text-align: left;"> "BSQ"         </td><td style="text-align: left;"> band sequential (indexing: [sample, line, band])</td>
</tr>
<tr>
 <td style="text-align: left;">
                        </td><td style="text-align: left;"> "BIL"         </td><td style="text-align: left;"> band interleave by line (indexing: [sample, line, band])</td>
</tr>
<tr>
 <td style="text-align: left;">
                        </td><td style="text-align: left;"> "BIP"         </td><td style="text-align: left;"> band interleave by pixel (indexing: [band, line, sample])</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>`byte order`</code>    </td><td style="text-align: left;"> 0 or "little" </td><td style="text-align: left;"> little endian </td>
</tr>
<tr>
 <td style="text-align: left;">
                        </td><td style="text-align: left;"> 1 or "big"    </td><td style="text-align: left;"> big endian </td>
</tr>
<tr>
 <td style="text-align: left;">
                        </td><td style="text-align: left;"> "swap"        </td><td style="text-align: left;"> swap byte order
</td>
</tr>

</table>

<p>Some more information that is not provided by the ENVI files may be given:
</p>
<p>Wavelength axis and axis labels in the respective parameters. For more
information, see <code><a href="#topic+initialize">initialize</a></code>.
</p>
<p>The spatial information is by default a sequence from 0 to
<code>header$samples - 1</code> and <code>header$lines - 1</code>, respectively.
<code>x</code> and <code>y</code> give offset of the first spectrum and step size.
</p>
<p>Thus, the object's <code>$x</code> colum is: <code>(0 : header$samples - 1) * x
[2] + x [1]</code>.  The <code>$y</code> colum is calculated analogously.
</p>
<p>Nicolet uses some more keywords in their header file.
They are interpreted as follows:
</p>

<table>
<tr>
 <td style="text-align: left;">
description   </td><td style="text-align: left;"> giving the position of the first spectrum </td>
</tr>
<tr>
 <td style="text-align: left;">
z plot titles </td><td style="text-align: left;"> wavelength and intensity axis units, comma separated </td>
</tr>
<tr>
 <td style="text-align: left;">
pixel size    </td><td style="text-align: left;"> interpreted as x and y step size
                   (specify <code>x = NA</code> and <code>y = NA</code>)
</td>
</tr>

</table>

<p>These parameters can be overwritten by giving a list with the respective
elements in parameter <code>header</code>.
</p>
<p>The values in header line description seem to be microns while the pixel
size seems to be in microns. If <code>nicolet.correction</code> is true, the
pixel size values (i.e. the step sizes) are multiplied by 1000.
</p>


<h3>Value</h3>

<p>a <code>hyperSpec</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>read.ENVI.HySpex</code>: 
</p>
</li>
<li> <p><code>read.ENVI.Nicolet</code>: 
</p>
</li></ul>


<h3>Author(s)</h3>

<p>C. Beleites, testing for the Nicolet files C. Dicko
</p>


<h3>References</h3>

<p>This function was adapted from
<code>caTools::read.ENVI()</code>:
</p>
<p>Jarek Tuszynski (2008). caTools: Tools: moving window statistics, GIF,
Base64, ROC AUC, etc.. R package version 1.9.
</p>


<h3>See Also</h3>

<p><code>caTools::read.ENVI()</code>
</p>
<p><code><a href="#topic+textio">textio</a></code>
</p>

<hr>
<h2 id='read.ini'>Read INI files</h2><span id='topic+read.ini'></span>

<h3>Description</h3>

<p><code>read.ini</code> reads ini files of the form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.ini(
  con = stop("Connection con needed."),
  skip = NULL,
  encoding = "unknown"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.ini_+3A_con">con</code></td>
<td>
<p>connection or file name</p>
</td></tr>
<tr><td><code id="read.ini_+3A_skip">skip</code></td>
<td>
<p>number of lines to skip before first <code>[section]</code> starts</p>
</td></tr>
<tr><td><code id="read.ini_+3A_encoding">encoding</code></td>
<td>
<p>see <code><a href="base.html#topic+readLines">readLines</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>[section]
key = value
</p>
<p>into a list.
</p>
<p><code>read.ini</code> sanitizes the element names and tries to convert scalars and comma separated
numeric vectors to numeric.
</p>


<h3>Value</h3>

<p>a list with one element per section in the .ini file, each containing a list with elements
for the key-value-pairs.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>

<hr>
<h2 id='read.jdx'>JCAMP-DX Import for Shimadzu Library Spectra</h2><span id='topic+read.jdx'></span>

<h3>Description</h3>

<p>this is a first rough import function for JCAMP-DX spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.jdx(
  filename = stop("filename is needed"),
  encoding = "",
  header = list(),
  keys.hdr2data = FALSE,
  ...,
  NA.symbols = c("NA", "N/A", "N.A."),
  collapse.multi = TRUE,
  wl.tolerance = hy.getOption("wl.tolerance"),
  collapse.equal = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.jdx_+3A_filename">filename</code></td>
<td>
<p>file name and path of the .jdx file</p>
</td></tr>
<tr><td><code id="read.jdx_+3A_encoding">encoding</code></td>
<td>
<p>encoding of the JCAMP-DX file (used by <code><a href="base.html#topic+readLines">base::readLines()</a></code>)</p>
</td></tr>
<tr><td><code id="read.jdx_+3A_header">header</code></td>
<td>
<p>list with manually set header values</p>
</td></tr>
<tr><td><code id="read.jdx_+3A_keys.hdr2data">keys.hdr2data</code></td>
<td>
<p>index vector indicating which header entries should be tranfered into the
extra data. Usually a character vector of labels (lowercase, without and dashes, blanks,
underscores). If <code>TRUE</code>, all header entries are read.</p>
</td></tr>
<tr><td><code id="read.jdx_+3A_...">...</code></td>
<td>
<p>further parameters handed to the data import function, e.g.</p>

<table>
<tr>
 <td style="text-align: left;">
   parameter </td><td style="text-align: left;"> meaning </td><td style="text-align: left;"> default </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>xtol</code> </td><td style="text-align: left;"> tolerance for checking calculated x values against checkpoints at beginning of line </td><td style="text-align: left;"> XFACTOR </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>ytol</code> </td><td style="text-align: left;"> tolerance for checking Y values against MINY and MAXY </td><td style="text-align: left;"> YFACTOR </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="read.jdx_+3A_na.symbols">NA.symbols</code></td>
<td>
<p>character vector of text values that should be converted to <code>NA</code></p>
</td></tr>
<tr><td><code id="read.jdx_+3A_collapse.multi">collapse.multi</code></td>
<td>
<p>should hyperSpec objects from multispectra files be collapsed into one
hyperSpec object (if <code>FALSE</code>, a list of hyperSpec objects is returned).</p>
</td></tr>
<tr><td><code id="read.jdx_+3A_wl.tolerance">wl.tolerance</code>, <code id="read.jdx_+3A_collapse.equal">collapse.equal</code></td>
<td>
<p>see <a href="#topic+collapse">collapse</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>So far, AFFN and PAC formats are supported for simple XYDATA, DATA TABLEs and PEAK TABLEs.
</p>
<p>NTUPLES / PAGES are not (yet) supported.
</p>
<p>DIF, DUF, DIFDUP and SQZ data formats are not (yet) supported.
</p>


<h3>Value</h3>

<p>hyperSpec object
</p>


<h3>Note</h3>

<p>JCAMP-DX support is incomplete and the functions may change without notice. See
<code>vignette ("fileio")</code>  and the details section.
</p>


<h3>Author(s)</h3>

<p>C. Beleites with contributions by Bryan Hanson
</p>

<hr>
<h2 id='read.spc'>Import for Thermo Galactic's spc file format
These functions allow to import Thermo Galactic/Grams .spc files.</h2><span id='topic+read.spc'></span>

<h3>Description</h3>

<p>Import for Thermo Galactic's spc file format
These functions allow to import Thermo Galactic/Grams .spc files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.spc(
  filename,
  keys.hdr2data = FALSE,
  keys.log2data = FALSE,
  log.txt = TRUE,
  log.bin = FALSE,
  log.disk = FALSE,
  hdr = list(),
  no.object = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.spc_+3A_filename">filename</code></td>
<td>
<p>The complete file name of the .spc file.</p>
</td></tr>
<tr><td><code id="read.spc_+3A_keys.hdr2data">keys.hdr2data</code>, <code id="read.spc_+3A_keys.log2data">keys.log2data</code></td>
<td>
<p>character vectors with the names of parameters in the .spc
file's log block (log2xxx) or header (hdr2xxx) that should go into the extra data (yyy2data) of
the returned hyperSpec object.
</p>
<p>All header fields specified in the .spc file format specification (see
below) are imported and can be referred to by their de-capitalized names.</p>
</td></tr>
<tr><td><code id="read.spc_+3A_log.txt">log.txt</code></td>
<td>
<p>Should the text part of the .spc file's log block be read?</p>
</td></tr>
<tr><td><code id="read.spc_+3A_log.bin">log.bin</code>, <code id="read.spc_+3A_log.disk">log.disk</code></td>
<td>
<p>Should the normal and on-disk binary parts of the
.spc file's log block be read?  If so, they will be put as raw vectors
into the hyperSpec object's log.</p>
</td></tr>
<tr><td><code id="read.spc_+3A_hdr">hdr</code></td>
<td>
<p>A list with fileheader fields that overwrite the settings of
actual file's header.
</p>
<p>Use with care, and look into the source code for detailed insight on the
elements of this list.</p>
</td></tr>
<tr><td><code id="read.spc_+3A_no.object">no.object</code></td>
<td>
<p>If <code>TRUE</code>, a list with wavelengths, spectra, labels,
log and data are returned instead of a hyperSpec object.
</p>
<p>This parameter will likely be subject to change in future - use with care.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the file contains multiple spectra with individual wavelength
axes, <code>read.spc</code> returns a list of hyperSpec objects.  Otherwise the
result is a hyperSpec object.
</p>
<p><code>read.spc.KaiserMap</code> returns a hyperSpec object with data columns x,
y, and z containing the stage position as recorded in the .spc files'
log.
</p>


<h3>Note</h3>

<p>Only a restricted set of test files was available for development.
Particularly, the w-planes feature could not be tested.
</p>
<p>If you have .spc files that cannot be read with these function, don't
hesitate to contact the package maintainer with your code patch or asking
advice.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>References</h3>

<p>Source development kit and file format specification of .spc
files.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+textio">textio</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## get the sample .spc files from ftirsearch.com (see above)
## Not run: 
# single spectrum
spc &lt;- read.spc ("BENZENE.SPC")
plot (spc)

# multi-spectra .spc file with common wavelength axis
spc &lt;- read.spc ('IG_MULTI.SPC')
spc

# multi-spectra .spc file with individual wavelength axes
spc &lt;- read.spc ("BARBITUATES.SPC")
plot (spc [[1]], lines.args = list (type = "h"))

## End(Not run)

</code></pre>

<hr>
<h2 id='read.spc.Kaiser'>read Kaiser .spc files</h2><span id='topic+read.spc.Kaiser'></span><span id='topic+read.spc.KaiserMap'></span><span id='topic+read.spc.KaiserLowHigh'></span>

<h3>Description</h3>

<p>Import functions for Kaiser Optical Systems .spc files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.spc.Kaiser(files, ..., glob = TRUE)

read.spc.KaiserMap(files, keys.log2data = NULL, ...)

read.spc.KaiserLowHigh(
  files = stop("file names needed"),
  type = c("single", "map"),
  ...,
  glob = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.spc.Kaiser_+3A_files">files</code></td>
<td>
<p>If <code>glob = TRUE</code>, <code>filename</code> can contain wildcards.
Thus all files matching the name pattern in <code>filename</code> can be
specified.</p>
</td></tr>
<tr><td><code id="read.spc.Kaiser_+3A_glob">glob</code></td>
<td>
<p>If <code>TRUE</code> the filename is interpreted as a wildcard
containing file name pattern and expanded to all matching file names.</p>
</td></tr>
<tr><td><code id="read.spc.Kaiser_+3A_keys.log2data">keys.log2data</code>, <code id="read.spc.Kaiser_+3A_...">...</code></td>
<td>
<p>All further arguments are handed over directly to <code><a href="#topic+read.spc">read.spc</a></code>.</p>
</td></tr>
<tr><td><code id="read.spc.Kaiser_+3A_type">type</code></td>
<td>
<p>what kind of measurement was done? If <code>"map"</code>, <code>read.spc.KaiserMap</code> is used
instead of <code>read.spc.Kaiser</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>read.spc.Kaiser</code> imports sets of .spc files written by Kaiser Optical Systems' Hologram
software.  It may also serve as an example how to write wrapper functions for <code>read.spc</code> to
conveniently import specialized sets of .spc files.
</p>


<h3>Value</h3>

<p>hyperSpec
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## for examples, please see `vignette ("fileio", package = "hyperSpec")`.
</code></pre>

<hr>
<h2 id='read.spe'>Import WinSpec SPE file</h2><span id='topic+read.spe'></span><span id='topic+.read.spe.header'></span><span id='topic+spe.showcalpoints'></span>

<h3>Description</h3>

<p>Import function for WinSpec SPE files (file version up to 3.0). The calibration
data (polynome and calibration data pairs) for x-axis are automatically
read and applied to the spectra. Note that the y-calibration data structure
is not extracted from the file since it is not saved there by WinSpec and is
always empty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.spe(
  filename,
  xaxis = "file",
  acc2avg = F,
  cts_sec = F,
  keys.hdr2data = c("exposure_sec", "LaserWavelen", "accumulCount", "numFrames",
    "darkSubtracted")
)

.read.spe.header(filename)

spe.showcalpoints(filename, xaxis = "file", acc2avg = F, cts_sec = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.spe_+3A_filename">filename</code></td>
<td>
<p>Name of the SPE file to read data from</p>
</td></tr>
<tr><td><code id="read.spe_+3A_xaxis">xaxis</code></td>
<td>
<p>Units of x-axis, e.g. <em>&quot;file&quot;</em>, <em>&quot;px&quot;</em>,
<em>&quot;nm&quot;</em>, <em>&quot;energy&quot;</em>, <em>&quot;raman&quot;</em>, <em>...</em>
<code>read.spe</code> function automatically checks if the x-calibration data are
available and uses them (if possible) to reconstruct the xaxis
in the selected units.</p>
</td></tr>
<tr><td><code id="read.spe_+3A_acc2avg">acc2avg</code></td>
<td>
<p>whether to divide the actual data set by the number of
accumulations, thus transforming <em>accumulated</em> spectra to
<em>averaged</em> spectra. WinSpec does not do this automatically, so the
spectral intensity is always proportional to the number of accumulations.
The flag <code>@data$averaged</code> is automatically set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="read.spe_+3A_cts_sec">cts_sec</code></td>
<td>
<p>whether to divide the actual data set by the exposure time,
thus going to count per second unit.</p>
</td></tr>
<tr><td><code id="read.spe_+3A_keys.hdr2data">keys.hdr2data</code></td>
<td>
<p>Which metadata from the file header should be saved to
the <code>Data</code> slot of a newly created hyperSpec object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hyperSpec object
</p>
<p>hdr list with <code>key=value</code> pairs
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>.read.spe.header</code>: Read only header of a WinSpec SPE file (version 2.5)
</p>
</li>
<li> <p><code>spe.showcalpoints</code>: Plot the WinSpec SPE file (version 2.5) and show the
calibration points stored inside of it (x-axis calibration)
</p>
</li></ul>


<h3>Author(s)</h3>

<p>R. Kiselev, C. Beleites
</p>

<hr>
<h2 id='read.txt.Horiba'>Import Horiba Labspec exported ASCII files</h2><span id='topic+read.txt.Horiba'></span><span id='topic+read.txt.Horiba.xy'></span><span id='topic+read.txt.Horiba.t'></span>

<h3>Description</h3>

<p>Read ASCII (.txt) files exported by Horiba's Labspec software (LabRAM spectrometers)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.txt.Horiba(
  file,
  cols = c(spc = "I / a.u.", .wavelength = expression(Delta * tilde(nu)/cm^-1)),
  header = TRUE,
  sep = "\t",
  row.names = NULL,
  check.names = FALSE,
  ...
)

read.txt.Horiba.xy(file, ...)

read.txt.Horiba.t(
  file,
  header = TRUE,
  sep = "\t",
  row.names = NULL,
  check.names = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.txt.Horiba_+3A_file">file</code></td>
<td>
<p>connection (file name and path) to the .txt file</p>
</td></tr>
<tr><td><code id="read.txt.Horiba_+3A_cols">cols</code>, <code id="read.txt.Horiba_+3A_header">header</code>, <code id="read.txt.Horiba_+3A_sep">sep</code>, <code id="read.txt.Horiba_+3A_row.names">row.names</code>, <code id="read.txt.Horiba_+3A_check.names">check.names</code>, <code id="read.txt.Horiba_+3A_...">...</code></td>
<td>
<p>further parameters are handed over to <code><a href="#topic+read.txt.wide">read.txt.wide</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>read.txt.Horiba.xy</code> reads maps, i.e. .txt files where the first two columns give x and y coordinates.
</p>


<h3>Value</h3>

<p>hyperSpec object
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>

<hr>
<h2 id='read.txt.Shimadzu'>Reads Shimadzu GCxGC-qMS - Spectra Files (.txt) as exported by Shimadzu Chrome Solution (v. 2.72) 
Mass Spectrometer: Shimadzu GCMS-QP 2010 Ultra (www.shimadzu.com)</h2><span id='topic+read.txt.Shimadzu'></span>

<h3>Description</h3>

<p>Reads Shimadzu GCxGC-qMS - Spectra Files (.txt) as exported by Shimadzu Chrome Solution (v. 2.72) 
Mass Spectrometer: Shimadzu GCMS-QP 2010 Ultra (www.shimadzu.com)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.txt.Shimadzu(filename, encoding = "", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.txt.Shimadzu_+3A_filename">filename</code></td>
<td>
<p>file name and path of the .txt file</p>
</td></tr>
<tr><td><code id="read.txt.Shimadzu_+3A_encoding">encoding</code></td>
<td>
<p>encoding of the txt file (used by <code><a href="base.html#topic+readLines">readLines</a></code>)</p>
</td></tr>
<tr><td><code id="read.txt.Shimadzu_+3A_quiet">quiet</code></td>
<td>
<p>suppress printing of progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of spectra tables
</p>


<h3>Note</h3>

<p>This is a first rough import function and the functions may change without notice.
</p>


<h3>Author(s)</h3>

<p>Bjoern Egert
</p>

<hr>
<h2 id='read.txt.wide'>Import/export of hyperSpec objects to/from ASCII files
A detailed discussion of hyperSpec's file import and export capabilities is given in vignette &ldquo;fileio&rdquo;.</h2><span id='topic+read.txt.wide'></span><span id='topic+read.txt.long'></span><span id='topic+import'></span><span id='topic+export'></span><span id='topic+write.txt.long'></span><span id='topic+write.txt.wide'></span>

<h3>Description</h3>

<p>Besides <code><a href="base.html#topic+save">save</a></code> and <code><a href="base.html#topic+load">load</a></code>, two general ways to import and
export data into <code>hyperSpec</code> objects exist.
</p>
<p>Firstly, hyperSpec objects can be imported and exported as ASCII files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.txt.wide(
  file = stop("file is required"),
  cols = list(spc = "I / a.u.", .wavelength = expression(lambda/nm)),
  sep = "\t",
  row.names = NULL,
  check.names = FALSE,
  ...
)

read.txt.long(
  file = stop("file is required"),
  cols = list(.wavelength = expression(lambda/nm), spc = "I / a.u."),
  header = TRUE,
  ...
)

write.txt.long(
  object,
  file = "",
  order = c(".rownames", ".wavelength"),
  na.last = TRUE,
  decreasing = FALSE,
  quote = FALSE,
  sep = "\t",
  row.names = FALSE,
  cols = NULL,
  col.names = TRUE,
  col.labels = FALSE,
  append = FALSE,
  ...
)

write.txt.wide(
  object,
  file = "",
  cols = NULL,
  quote = FALSE,
  sep = "\t",
  row.names = FALSE,
  col.names = TRUE,
  header.lines = 1,
  col.labels = if (header.lines == 1) FALSE else TRUE,
  append = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.txt.wide_+3A_file">file</code></td>
<td>
<p>filename or connection</p>
</td></tr>
<tr><td><code id="read.txt.wide_+3A_cols">cols</code></td>
<td>
<p>the column names specifying the column order.
</p>
<p>For data import, a list with elements <code>colname = label</code>; for export a
character vector with the colnames.  Use <code>wavelength</code> to specify the
wavelengths.</p>
</td></tr>
<tr><td><code id="read.txt.wide_+3A_check.names">check.names</code></td>
<td>
<p>handed to <code><a href="utils.html#topic+read.table">read.table</a></code>. Make sure this is <code>FALSE</code>, if
the column names of the spectra are the wavelength values.</p>
</td></tr>
<tr><td><code id="read.txt.wide_+3A_...">...</code></td>
<td>
<p>arguments handed to <code><a href="utils.html#topic+read.table">read.table</a></code> and
<code><a href="utils.html#topic+write.table">write.table</a></code>, respectively.</p>
</td></tr>
<tr><td><code id="read.txt.wide_+3A_header">header</code></td>
<td>
<p>the file has (shall have) a header line</p>
</td></tr>
<tr><td><code id="read.txt.wide_+3A_object">object</code></td>
<td>
<p>the <code>hyperSpec</code> object</p>
</td></tr>
<tr><td><code id="read.txt.wide_+3A_order">order</code></td>
<td>
<p>which columns should be <code><a href="base.html#topic+order">order</a></code>ed?
<code>order</code> is used as index vector into a <code>data.frame</code> with
columns given by <code>cols</code>.</p>
</td></tr>
<tr><td><code id="read.txt.wide_+3A_na.last">na.last</code></td>
<td>
<p>handed to <code><a href="base.html#topic+order">order</a></code> by
<code>write.txt.long</code>.</p>
</td></tr>
<tr><td><code id="read.txt.wide_+3A_decreasing">decreasing</code></td>
<td>
<p>logical vector giving the sort order</p>
</td></tr>
<tr><td><code id="read.txt.wide_+3A_quote">quote</code>, <code id="read.txt.wide_+3A_sep">sep</code>, <code id="read.txt.wide_+3A_col.names">col.names</code>, <code id="read.txt.wide_+3A_row.names">row.names</code></td>
<td>
<p>have their usual meaning (see
<code><a href="utils.html#topic+read.table">read.table</a></code> and <code><a href="utils.html#topic+write.table">write.table</a></code>),
but different default values.
</p>
<p>For file import, <code>row.names</code> should usually be <code>NULL</code> so that the
first column becomes a extra data column (as opposed to row names of the extra data).</p>
</td></tr>
<tr><td><code id="read.txt.wide_+3A_col.labels">col.labels</code></td>
<td>
<p>Should the column labels be used rather than the
colnames?</p>
</td></tr>
<tr><td><code id="read.txt.wide_+3A_append">append</code></td>
<td>
<p>Should the output be appended to an existing file?</p>
</td></tr>
<tr><td><code id="read.txt.wide_+3A_header.lines">header.lines</code></td>
<td>
<p>Toggle one or two line header (wavelengths in the
second header line) for <code>write.txt.wide</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Firstly, hyperSpec objects can be imported  and exported as ASCII files.
</p>
<p>A second option is using the package <code><a href="R.matlab.html#topic+R.matlab">R.matlab</a></code>
which provides the functions <code><a href="R.matlab.html#topic+readMat">readMat</a></code> and
<code><a href="R.matlab.html#topic+writeMat">writeMat</a></code>.
</p>
<p>hyperSpec comes with a number of pre-defined functions to import
manufacturer specific file formats. For details, see <code>vignette
  ("fileio")</code>.
</p>
<p><code><a href="#topic+read.spc">read.spc</a></code> imports Thermo Galactic's .spc file
format, and ENVI files may be read using
<code><a href="#topic+read.ENVI">read.ENVI</a></code>.
</p>
<p>These functions are very flexible and provide lots of arguments.
</p>
<p>If you use them to read or write manufacturer specific ASCII formats,
please consider writing a wrapper function and contributing this
function to <span class="pkg">hyperSpec</span>.  An example is in the &ldquo;flu&rdquo; vignette
(see <code>vignette ("flu", package = "hyperSpec"</code>).
</p>
<p>Note that R accepts many packed formats for ASCII files, see
<code><a href="base.html#topic+connections">connections</a></code>. For .zip files, see <code><a href="utils.html#topic+unzip">unzip</a></code>.
</p>
<p>For further information, see the examples below, <code>vignette ("fileio")</code> and the documentation
of <code><a href="R.matlab.html#topic+R.matlab">R.matlab</a></code>.
</p>
<p>A second option is using the package <code><a href="R.matlab.html#topic+R.matlab">R.matlab</a></code> which
provides the functions <code><a href="R.matlab.html#topic+readMat">readMat</a></code> and
<code><a href="R.matlab.html#topic+writeMat">writeMat</a></code>.
</p>
<p>hyperSpec comes with a number of pre-defined functions to import
manufacturer specific file formats. For details, see <code>vignette
("file-io")</code>.
</p>
<p><code><a href="#topic+read.spc">read.spc</a></code> imports Thermo Galactic's .spc file
format, and ENVI files may be read using
<code><a href="#topic+read.ENVI">read.ENVI</a></code>.
</p>
<p>These functions are very flexible and provide lots of arguments.
</p>
<p>If you use them to read or write manufacturer specific ASCII formats,
please consider writing a wrapper function and contributing this function
to <span class="pkg">hyperSpec</span>.  An example is in the &ldquo;flu&rdquo; vignette (see
<code>vignette ("flu", package = "hyperSpec"</code>).
</p>
<p>Note that R accepts many packed formats for ASCII files, see
<code><a href="base.html#topic+connections">connections</a></code>. For .zip files, see
<code><a href="utils.html#topic+unzip">unzip</a></code>.
</p>
<p>For further information, see the examples below and the documentation of
<code><a href="R.matlab.html#topic+R.matlab">R.matlab</a></code>.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code>vignette ("fileio")</code> and <a href="http://hyperspec.r-forge.r-project.org/blob/fileio.pdf">http://hyperspec.r-forge.r-project.org/blob/fileio.pdf</a>,
respectively
</p>
<p><code><a href="utils.html#topic+read.table">read.table</a></code> and
<code><a href="utils.html#topic+write.table">write.table</a></code>
</p>
<p><code><a href="R.matlab.html#topic+R.matlab">R.matlab</a></code> for .mat files
</p>
<p><code><a href="#topic+read.ENVI">read.ENVI</a></code> for ENVI data
</p>
<p><code><a href="#topic+read.spc">read.spc</a></code> for .spc files
</p>
<p>Manufacturer specific file formats: <code><a href="#topic+read.txt.Renishaw">read.txt.Renishaw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: vignette  ("file-io")

## export &amp; import matlab files
if (require (R.matlab)) {
   # export to matlab file
   writeMat (paste0 (tempdir(), "/test.mat"),
             x = flu[[]], wavelength = flu@wavelength,
             label = lapply (flu@label, as.character))

   # reading a matlab file
   data &lt;- readMat (paste0 (tempdir(), "/test.mat"))
   print (data)
   mat &lt;- new ("hyperSpec", spc = data$x,
               wavelength = as.numeric(data$wavelength),
               label = data$label[,,1])
}

## ascii export &amp; import


write.txt.long (flu,
    file = paste0 (tempdir(), "/flu.txt"),
    cols = c(".wavelength", "spc", "c"),
		order = c("c", ".wavelength"),
		decreasing = c(FALSE, TRUE))

read.txt.long (file = paste0 (tempdir(), "/flu.txt"),
      cols = list (.wavelength = expression (lambda / nm),
      spc = "I / a.u", c = expression ("/" (c, (mg/l)))))

write.txt.wide (flu,  file = paste0 (tempdir(), "/flu.txt"),
    cols = c("c", "spc"),
		col.labels = TRUE, header.lines = 2, row.names = TRUE)

write.txt.wide (flu,  file = paste0 (tempdir(), "/flu.txt"),
                col.labels = FALSE, row.names = FALSE)

read.txt.wide (file = paste0 (tempdir(), "/flu.txt"),
    # give columns in same order as they are in the file
    cols = list (spc = "I / a.u",
                 c = expression ("/"("c", "mg/l")),
                 filename = "filename",
                 # plus wavelength label last
                 .wavelength = "lambda / nm"),
		header = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='rmmvnorm'>Multivariate normal random numbers</h2><span id='topic+rmmvnorm'></span><span id='topic+rmmvnorm+2Cnumeric+2ChyperSpec+2Cmatrix-method'></span><span id='topic+rmmvnorm+2ChyperSpec-method'></span><span id='topic+rmmvnorm+2Cnumeric+2ChyperSpec+2Carray-method'></span><span id='topic+rmmvnorm+2Cnumeric+2Cmatrix+2Cmatrix-method'></span><span id='topic+rmmvnorm+2Cnumeric+2Cmatrix+2Carray-method'></span>

<h3>Description</h3>

<p>Interface functions to use <code><a href="mvtnorm.html#topic+rmvnorm">rmvnorm</a></code> for
<code><a href="#topic+hyperSpec-class">hyperSpec-class</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmmvnorm(n, mean, sigma)

## S4 method for signature 'numeric,hyperSpec,matrix'
rmmvnorm(n, mean, sigma)

## S4 method for signature 'numeric,hyperSpec,array'
rmmvnorm(n, mean, sigma)

## S4 method for signature 'numeric,matrix,matrix'
rmmvnorm(n, mean, sigma)

## S4 method for signature 'numeric,matrix,array'
rmmvnorm(n, mean, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmmvnorm_+3A_n">n</code></td>
<td>
<p>vector giving the numer of cases to generate for each group</p>
</td></tr>
<tr><td><code id="rmmvnorm_+3A_mean">mean</code></td>
<td>
<p>matrix with mean cases in rows</p>
</td></tr>
<tr><td><code id="rmmvnorm_+3A_sigma">sigma</code></td>
<td>
<p>common covariance matrix or array (<code>ncol (mean)</code> x <code>ncol (mean)</code> x <code>nrow (mean)</code>) with individual covariance matrices for the groups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>mvtnorm</code> method for hyperSpec objects supports producing multivariate normal data for
groups with different mean but common covariance matrix, see the examples.
</p>


<h3>See Also</h3>

<p><code><a href="mvtnorm.html#topic+rmvnorm">rmvnorm</a></code>
</p>
<p><code><a href="#topic+cov">cov</a></code> and <code><a href="#topic+pooled.cov">pooled.cov</a></code> about calculating  covariance of hyperSpec objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## multiple groups, common covariance matrix

if (require ("mvtnorm")){
   pcov &lt;- pooled.cov (chondro, chondro$clusters)
   rnd &lt;- rmmvnorm (rep (10, 3), mean = pcov$mean, sigma = pcov$COV)
   plot (rnd, col = rnd$.group)
}
</code></pre>

<hr>
<h2 id='sample+2ChyperSpec-method'>Random Samples and Permutations
Take a sample of the specified size from the elements of x with or without
replacement.</h2><span id='topic+sample+2ChyperSpec-method'></span><span id='topic+isample'></span><span id='topic+sample+2Cdata.frame-method'></span><span id='topic+sample+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Random Samples and Permutations
Take a sample of the specified size from the elements of x with or without
replacement.
</p>
<p><code>isample</code> returns an vector of indices, <code>sample</code> returns the
corresponding hyperSpec object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hyperSpec'
sample(x, size, replace = FALSE, prob = NULL)

isample(x, size = nrow(x), replace = FALSE, prob = NULL)

## S4 method for signature 'data.frame'
sample(x, size, replace = FALSE, prob = NULL, drop = FALSE)

## S4 method for signature 'matrix'
sample(x, size, replace = FALSE, prob = NULL, drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample+2B2ChyperSpec-method_+3A_x">x</code></td>
<td>
<p>The hyperSpec object, data.frame or matrix to sample fromto sample from</p>
</td></tr>
<tr><td><code id="sample+2B2ChyperSpec-method_+3A_size">size</code></td>
<td>
<p>positive integer giving the number of spectra (rows) to choose.</p>
</td></tr>
<tr><td><code id="sample+2B2ChyperSpec-method_+3A_replace">replace</code></td>
<td>
<p>Should sampling be with replacement?</p>
</td></tr>
<tr><td><code id="sample+2B2ChyperSpec-method_+3A_prob">prob</code></td>
<td>
<p>A vector of probability weights for obtaining the elements of
the vector being sampled.</p>
</td></tr>
<tr><td><code id="sample+2B2ChyperSpec-method_+3A_drop">drop</code></td>
<td>
<p>see <code><a href="base.html#topic+drop">drop</a></code>: by default, do not drop dimensions of the result</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a hyperSpec object, data.frame or matrix with <code>size</code> rows for <code>sample</code>, and an
integer vector for <code>isample</code> that is suitable for indexing (into the spectra) of x.
</p>
<p>vector with indices suitable for row-indexing x
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sample">sample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sample (flu, 3)

plot (flu, col = "darkgray")
plot (sample (flu, 3), col = "red", add = TRUE)

plot (flu, col = "darkgray")
plot (sample (flu, 3, replace = TRUE), col = "#0000FF80", add = TRUE,
      lines.args = list (lwd = 2));

isample (flu, 3)
isample (flu, 3, replace = TRUE)
isample (flu, 8, replace = TRUE)
sample (cars, 2)
sample (matrix (1:24, 6), 2)
</code></pre>

<hr>
<h2 id='scale+2ChyperSpec-method'>Center and scale hyperSpec object</h2><span id='topic+scale+2ChyperSpec-method'></span><span id='topic+scale'></span><span id='topic+scale-methods'></span>

<h3>Description</h3>

<p><code>link[base]{scale}</code>s the spectra matrix. <code>scale (x, scale = FALSE)</code> centers the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hyperSpec'
scale(x, center = TRUE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale+2B2ChyperSpec-method_+3A_x">x</code></td>
<td>
<p>the <code>hyperSpec</code> object</p>
</td></tr>
<tr><td><code id="scale+2B2ChyperSpec-method_+3A_center">center</code></td>
<td>
<p>if <code>TRUE</code>, the data is centered to <code>colMeans (x)</code>, <code>FALSE</code>
suppresses centering. Alternatively, an object that can be converted to numeric of length
<code>nwl (x)</code> by <code><a href="base.html#topic+as.matrix">as.matrix</a></code> (e.g. hyperSpec object containing 1 spectrum) can
specify the center spectrum.</p>
</td></tr>
<tr><td><code id="scale+2B2ChyperSpec-method_+3A_scale">scale</code></td>
<td>
<p>if <code>TRUE</code>, the data is scaled to have unit variance at each wavelength,
<code>FALSE</code> suppresses scaling. Alternatively, an object that can be converted to numeric of
length <code>nwl (x)</code> by <code><a href="base.html#topic+as.matrix">as.matrix</a></code> (e.g. hyperSpec object containing 1 spectrum)
can specify the center spectrum.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <code>scale</code> provides a fast alternative for <code>base::<a href="base.html#topic+scale">scale</a></code>
</p>


<h3>Value</h3>

<p>the centered &amp; scaled <code>hyperSpec</code> object
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scale">scale</a></code>
</p>
<p>package scale.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## mean center &amp; variance scale
tmp &lt;- scale (chondro)
plot (tmp, "spcmeansd")
plot (sample (tmp, 5), add = TRUE, col = 2)

## mean center only
tmp &lt;- scale (chondro, scale = FALSE)
plot (tmp, "spcmeansd")
plot (sample (tmp, 5), add = TRUE, col = 2)

## custom center
tmp &lt;- sweep (chondro, 1, mean, `/`)
plot (tmp, "spcmeansd")
tmp &lt;- scale (tmp, center = quantile (tmp, .05), scale = FALSE)

</code></pre>

<hr>
<h2 id='scan.asc.Andor'>File Import Andor Solis</h2><span id='topic+scan.asc.Andor'></span><span id='topic+read.asc.Andor'></span>

<h3>Description</h3>

<p>Import Raman Spectra/Maps from Andor Cameras/Solis ASCII files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan.asc.Andor(...)

read.asc.Andor(
  file = stop("filename or connection needed"),
  ...,
  quiet = TRUE,
  dec = ".",
  sep = ","
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scan.asc.Andor_+3A_...">...</code>, <code id="scan.asc.Andor_+3A_quiet">quiet</code>, <code id="scan.asc.Andor_+3A_dec">dec</code>, <code id="scan.asc.Andor_+3A_sep">sep</code></td>
<td>
<p>handed to <code><a href="base.html#topic+scan">scan</a></code></p>
</td></tr>
<tr><td><code id="scan.asc.Andor_+3A_file">file</code></td>
<td>
<p>filename or connection to ASCII file</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>read.asc.Andor</code> reads Andor Solis ASCII (<code>.asc</code>) files where the first column gives the wavelength
axes and the other columns the spectra.
</p>


<h3>Value</h3>

<p>a hyperSpec object
</p>


<h3>Author(s)</h3>

<p>Claudia Beleites
</p>


<h3>See Also</h3>

<p><code>vignette ("fileio")</code> for more information on file import and
</p>
<p><code><a href="base.html#topic+options">options</a></code> for details on options.
</p>

<hr>
<h2 id='scan.txt.Renishaw'>import Raman measurements from Renishaw ASCII-files</h2><span id='topic+scan.txt.Renishaw'></span><span id='topic+scan.zip.Renishaw'></span><span id='topic+read.txt.Renishaw'></span><span id='topic+read.zip.Renishaw'></span>

<h3>Description</h3>

<p>import Raman measurements from Renishaw (possibly compressed) .txt file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan.txt.Renishaw(...)

scan.zip.Renishaw(...)

read.txt.Renishaw(
  file = stop("file is required"),
  data = "xyspc",
  nlines = 0,
  nspc = NULL
)

read.zip.Renishaw(
  file = stop("filename is required"),
  txt.file = sub("[.]zip", ".txt", basename(file)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scan.txt.Renishaw_+3A_...">...</code></td>
<td>
<p>Arguments for <code>read.txt.Renishaw</code></p>
</td></tr>
<tr><td><code id="scan.txt.Renishaw_+3A_file">file</code></td>
<td>
<p>file name or connection</p>
</td></tr>
<tr><td><code id="scan.txt.Renishaw_+3A_data">data</code></td>
<td>
<p>type of file, one of &quot;spc&quot;, &quot;xyspc&quot;, &quot;zspc&quot;, &quot;depth&quot;, &quot;ts&quot;, see
details.</p>
</td></tr>
<tr><td><code id="scan.txt.Renishaw_+3A_nlines">nlines</code></td>
<td>
<p>number of lines to read in each chunk, if 0 or less read
whole file at once.
</p>
<p><code>nlines</code> must cover at least one complete spectrum,i.e. <code>nlines</code>
must be at least the number of data points per spectrum. Reasonable
values start at <code>1e6</code>.</p>
</td></tr>
<tr><td><code id="scan.txt.Renishaw_+3A_nspc">nspc</code></td>
<td>
<p>number of spectra in the file</p>
</td></tr>
<tr><td><code id="scan.txt.Renishaw_+3A_txt.file">txt.file</code></td>
<td>
<p>name of the .txt file in the .zip archive. Defaults to zip
file's name with suffix .txt instead of .zip</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The file may be of any file type that can be read by
<code><a href="base.html#topic+gzfile">gzfile</a></code> (i.e. text, or zipped by gzip, bzip2, xz or
lzma). .zip zipped files need to be read using <code>read.zip.Renishaw</code>.
</p>
<p>Renishaw .wxd files are converted to .txt ASCII files by their batch
converter. They come in a &quot;long&quot; format with columns (y x | time | z)?
wavelength intensity.  The first columns depend on the data type.
</p>
<p>The corresponding possibilities for the <code>data</code> argument are:
</p>

<table>
<tr>
 <td style="text-align: left;"> <code>data</code> </td><td style="text-align: left;"> columns </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>"spc"</code> </td><td style="text-align: left;"> wl int
</td><td style="text-align: left;"> single spectrum </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>"zspc"</code>, <code>"depth"</code> </td><td style="text-align: left;"> z wl int </td><td style="text-align: left;">
depth profile</td>
</tr>
<tr>
 <td style="text-align: left;"> <code>"ts"</code> </td><td style="text-align: left;"> t wl int </td><td style="text-align: left;"> time series</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"xyspc"</code> </td><td style="text-align: left;"> y x wl int </td><td style="text-align: left;"> 2d map</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>This function allows reading very large ASCII files, but it does not work
on files with missing values (<code>NA</code>s are allowed).
</p>
<p>If the file is so large that it sould be read in chunks and <code>nspc</code> is
not given, <code>read.txt.Renishaw</code> tries to guess it by using <code>wc</code>
(if installed).
</p>


<h3>Value</h3>

<p>the <code>hyperSpec</code> object
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.txt.long">read.txt.long</a></code>, <code><a href="#topic+read.txt.wide">read.txt.wide</a></code>,
<code><a href="base.html#topic+scan">scan</a></code>
</p>

<hr>
<h2 id='scan.txt.Witec'>File Import Witec Raman</h2><span id='topic+scan.txt.Witec'></span><span id='topic+scan.dat.Witec'></span><span id='topic+scan.txt.Witec.Graph'></span><span id='topic+read.txt.Witec'></span><span id='topic+read.dat.Witec'></span><span id='topic+read.txt.Witec.Graph'></span>

<h3>Description</h3>

<p>Import Raman Spectra/Maps from Witec Instrument via ASCII files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan.txt.Witec(...)

scan.dat.Witec(...)

scan.txt.Witec.Graph(...)

read.txt.Witec(
  file = stop("filename or connection needed"),
  points.per.line = NULL,
  lines.per.image = NULL,
  type = c("single", "map"),
  hdr.label = FALSE,
  hdr.units = FALSE,
  encoding = "unknown",
  ...,
  quiet = TRUE
)

read.dat.Witec(
  filex = stop("filename or connection needed"),
  filey = sub("-x", "-y", filex),
  points.per.line = NULL,
  lines.per.image = NULL,
  type = c("single", "map"),
  encoding = "unknown",
  ...,
  quiet = hy.getOption("debuglevel") &lt; 1L
)

read.txt.Witec.Graph(
  headerfile = stop("filename or connection needed"),
  filex = gsub("Header", "X-Axis", headerfile),
  filey = gsub("Header", "Y-Axis", headerfile),
  type = c("single", "map"),
  encoding = "unknown",
  ...,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scan.txt.Witec_+3A_...">...</code>, <code id="scan.txt.Witec_+3A_quiet">quiet</code></td>
<td>
<p>handed to <code><a href="base.html#topic+scan">scan</a></code></p>
</td></tr>
<tr><td><code id="scan.txt.Witec_+3A_file">file</code></td>
<td>
<p>filename or connection to ASCII file</p>
</td></tr>
<tr><td><code id="scan.txt.Witec_+3A_points.per.line">points.per.line</code></td>
<td>
<p>number of spectra in x direction of the map</p>
</td></tr>
<tr><td><code id="scan.txt.Witec_+3A_lines.per.image">lines.per.image</code></td>
<td>
<p>number of spectra in y direction</p>
</td></tr>
<tr><td><code id="scan.txt.Witec_+3A_type">type</code></td>
<td>
<p>type of spectra: <code>single</code> for single spectra (including time series), <code>map</code> for imaging data.</p>
</td></tr>
<tr><td><code id="scan.txt.Witec_+3A_hdr.label">hdr.label</code></td>
<td>
<p>WITec Project exports the spectra names (contain information of map position or number of spectra) within the <code>file</code>.</p>
</td></tr>
<tr><td><code id="scan.txt.Witec_+3A_hdr.units">hdr.units</code></td>
<td>
<p>WITec Project exports the spectra units within the <code>file</code>.</p>
</td></tr>
<tr><td><code id="scan.txt.Witec_+3A_encoding">encoding</code></td>
<td>
<p>character encoding, see <code><a href="base.html#topic+readLines">readLines</a></code></p>
</td></tr>
<tr><td><code id="scan.txt.Witec_+3A_filex">filex</code></td>
<td>
<p>filename wavelength axis file</p>
</td></tr>
<tr><td><code id="scan.txt.Witec_+3A_filey">filey</code></td>
<td>
<p>filename intensity file</p>
</td></tr>
<tr><td><code id="scan.txt.Witec_+3A_headerfile">headerfile</code></td>
<td>
<p>filename or connection to ASCII file with header information</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>read.txt.Witec</code> reads Witec ASCII files where the first column gives the wavelength
axes and the other columns the spectra. <code>read.dat.Witec</code> reads Witec's ASCII exported data
which comes in separate files with x and y data.
</p>
<p>Parameters <code>nwl</code> (automatically calculated now) and <code>remove.zerospc</code>
(use  <code><a href="#topic+hy.setOptions">hy.setOptions</a> (file.remove.emptyspc = TRUE)</code> instead) have
been deprecated and removed.
</p>


<h3>Value</h3>

<p>a hyperSpec object
</p>


<h3>Author(s)</h3>

<p>Claudia Beleites and Marcel Dahms
</p>


<h3>See Also</h3>

<p><code>vignette ("fileio")</code> for more information on file import and
</p>
<p><code><a href="base.html#topic+options">options</a></code> for details on options.
</p>

<hr>
<h2 id='seq.hyperSpec'>Sequence generation along spectra or wavelengths
This function generates sequences along the spectra (rows) or wavelengths of hyperSpec objects.</h2><span id='topic+seq.hyperSpec'></span><span id='topic+seq'></span><span id='topic+seq+2ChyperSpec-method'></span>

<h3>Description</h3>

<p>Note that <code><a href="#topic+wl2i">wl2i</a></code> generates sequences of indices along the wavelength axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hyperSpec'
seq(x, from = 1, to = nrow(x), ..., index = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seq.hyperSpec_+3A_x">x</code></td>
<td>
<p>the hyperSpec object</p>
</td></tr>
<tr><td><code id="seq.hyperSpec_+3A_from">from</code>, <code id="seq.hyperSpec_+3A_to">to</code></td>
<td>
<p>arguments handed to <code><a href="base.html#topic+seq.int">seq.int</a></code></p>
</td></tr>
<tr><td><code id="seq.hyperSpec_+3A_...">...</code></td>
<td>
<p>arguments for <code><a href="base.html#topic+seq">seq</a></code>, namely <code>by</code>, <code>length.out</code></p>
</td></tr>
<tr><td><code id="seq.hyperSpec_+3A_index">index</code></td>
<td>
<p>should a vector with indices be returned rather than a hyperSpec object?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>seq</code> had to be implemented as S3 method as the generic has only ... arguments (on which
no dispatch with differing types is possible).
</p>
<p><code><a href="base.html#topic+seq_along">seq_along</a></code> is not generic, but returns a sequence of the <code>length</code> of the
object. As hyperSpec provides a Method <code><a href="base.html#topic+length">length</a></code>, it can be used. The result is a
sequence of indices for the spectra.
</p>


<h3>Value</h3>

<p>a numeric or hyperSpec object, depending on <code>index</code>.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wl2i">wl2i</a></code> to construct sequences of wavelength indices.
</p>
<p><code><a href="base.html#topic+seq">seq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
seq (flu, index = TRUE)
seq_along (flu)
seq (flu, length.out = 3, index = TRUE) # return value is numeric, not integer! 
seq (flu, by = 2, index = TRUE) 		    # return value is numeric, not integer! 

plot (flu, col = "darkgray") 
plot (seq (flu, by = 2), add = TRUE, col= "red")
plot (seq (flu, length.out = 2), add = TRUE, col= "blue")

</code></pre>

<hr>
<h2 id='spc.bin'>Wavelength Binning
In order to reduce the spectral resolution and thus gain signal to noise
ratio or to reduce the dimensionality of the spectral data set, the
spectral resolution can be reduced.</h2><span id='topic+spc.bin'></span>

<h3>Description</h3>

<p>The mean of every <code>by</code> data points in the spectra is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spc.bin(spc, by = stop("reduction factor needed"), na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spc.bin_+3A_spc">spc</code></td>
<td>
<p>the <code>hyperSpec</code> object</p>
</td></tr>
<tr><td><code id="spc.bin_+3A_by">by</code></td>
<td>
<p>reduction factor</p>
</td></tr>
<tr><td><code id="spc.bin_+3A_na.rm">na.rm</code></td>
<td>
<p>decides about the treatment of <code>NA</code>s:
</p>
<p>if <code>FALSE</code> or <code>0</code>, the binning is done using <code>na.rm = FALSE</code>
</p>
<p>if <code>TRUE</code> or <code>1</code>, the binning is done using <code>na.rm = TRUE</code>
</p>
<p>if <code>2</code>, the binning is done using <code>na.rm = FALSE</code>, and resulting <code>NA</code>s are
corrected with <code>mean(...{}, na.rm = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="spc.bin_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using <code>na.rm = TRUE</code> always takes about twice as long as <code>na.rm = FALSE</code>.
</p>
<p>If the spectra matrix does not contain too many <code>NA</code>s, <code>na.rm = 2</code> is faster than
<code>na.rm = TRUE</code>.
</p>


<h3>Value</h3>

<p>A <code>hyperSpec</code> object with <code>ceiling (nwl (spc) / by)</code> data points per spectrum.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 spc &lt;- spc.bin (flu, 5)

 plot (flu[1,,425:475])
 plot (spc[1,,425:475], add = TRUE, col = "blue")

 nwl (flu)
 nwl (spc)

</code></pre>

<hr>
<h2 id='spc.fit.poly'>Polynomial Baseline Fitting
These functions fit polynomal baselines.</h2><span id='topic+spc.fit.poly'></span><span id='topic+spc.fit.poly.below'></span>

<h3>Description</h3>

<p>Both functions fit polynomials to be used as baselines. If <code>apply.to</code>
is <code>NULL</code>, a <code>hyperSpec</code> object with the polynomial coefficients
is returned, otherwise the polynomials are evaluated on the spectral range
of <code>apply.to</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spc.fit.poly(
  fit.to,
  apply.to = NULL,
  poly.order = 1,
  offset.wl = !(is.null(apply.to))
)

spc.fit.poly.below(
  fit.to,
  apply.to = fit.to,
  poly.order = 1,
  npts.min = max(round(nwl(fit.to) * 0.05), 3 * (poly.order + 1)),
  noise = 0,
  offset.wl = FALSE,
  max.iter = nwl(fit.to),
  stop.on.increase = FALSE,
  debuglevel = hy.getOption("debuglevel")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spc.fit.poly_+3A_fit.to">fit.to</code></td>
<td>
<p><code>hyperSpec</code> object on which the baselines are fitted</p>
</td></tr>
<tr><td><code id="spc.fit.poly_+3A_apply.to">apply.to</code></td>
<td>
<p><code>hyperSpec</code> object on which the baselines are evaluted
If <code>NULL</code>, a <code>hyperSpec</code> object containing the polynomial
coefficients rather than evaluted baselines is returned.</p>
</td></tr>
<tr><td><code id="spc.fit.poly_+3A_poly.order">poly.order</code></td>
<td>
<p>order of the polynomial to be used</p>
</td></tr>
<tr><td><code id="spc.fit.poly_+3A_offset.wl">offset.wl</code></td>
<td>
<p>should the wavelength range be mapped to -&gt; [0, delta wl]?
This enhances numerical stability.</p>
</td></tr>
<tr><td><code id="spc.fit.poly_+3A_npts.min">npts.min</code></td>
<td>
<p>minimal number of points used for fitting the polynomial</p>
</td></tr>
<tr><td><code id="spc.fit.poly_+3A_noise">noise</code></td>
<td>
<p>noise level to be considered during the fit. It may be given
as one value for all the spectra, or for each spectrum separately.</p>
</td></tr>
<tr><td><code id="spc.fit.poly_+3A_max.iter">max.iter</code></td>
<td>
<p>stop at the latest after so many iterations.</p>
</td></tr>
<tr><td><code id="spc.fit.poly_+3A_stop.on.increase">stop.on.increase</code></td>
<td>
<p>additional stopping rule: stop if the number of support points would increase, 
regardless whether npts.min was reached or not.</p>
</td></tr>
<tr><td><code id="spc.fit.poly_+3A_debuglevel">debuglevel</code></td>
<td>
<p>additional output:
<code>1</code> shows <code>npts.min</code>, 
<code>2</code> plots support points for the final baseline of 1st spectrum, 
<code>3</code> plots support points for 1st spectrum,
<code>4</code> plots support points for all spectra.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>spc.fit.poly</code> calculates the least squares fit of order
<code>poly.order</code> to the <em>complete</em> spectra given in <code>fit.to</code>.
Thus <code>fit.to</code> needs to be cut appropriately.
</p>


<h3>Value</h3>

<p><code>hyperspec</code> object containing the baselines in the spectra
matrix, either as polynomial coefficients or as polynomials evaluted on
the spectral range of <code>apply.to</code>
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code>vignette ("baseline", package = "hyperSpec")</code>
</p>
<p>see <code><a href="#topic+options">options</a></code> for more on <code>debuglevel</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: vignette ("baseline", package = "hyperSpec")

spc &lt;- chondro [1 : 10]
baselines &lt;- spc.fit.poly(spc [,, c (625 ~ 640, 1785 ~ 1800)], spc)
plot(spc - baselines)


baselines &lt;- spc.fit.poly.below (spc)
plot (spc - baselines)

spc.fit.poly.below(chondro [1:3], debuglevel = 1)
spc.fit.poly.below(chondro [1:3], debuglevel = 2)
spc.fit.poly.below(chondro [1:3], debuglevel = 3, noise = sqrt (rowMeans (chondro [[1:3]])))

</code></pre>

<hr>
<h2 id='spc.identify'>Identifying Spectra and Spectral Data Points
This function allows to identify the spectrum and the wavelength of a point
in a plot produced by <code><a href="#topic+plotspc">plotspc</a></code>.</h2><span id='topic+spc.identify'></span><span id='topic+spc.label.default'></span><span id='topic+spc.label.wlonly'></span><span id='topic+spc.point.default'></span><span id='topic+spc.point.max'></span><span id='topic+spc.point.min'></span><span id='topic+spc.point.sqr'></span>

<h3>Description</h3>

<p>This function first finds the spectrum with a point closest to the clicked
position (see <code><a href="graphics.html#topic+locator">locator</a></code>). The distance to the clicked
point is evaluated relative to the size of the tolerance window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spc.identify(
  x,
  y = NULL,
  wavelengths = NULL,
  ispc = NULL,
  tol.wl = diff(range(x))/200,
  tol.spc = diff(range(y))/50,
  point.fn = spc.point.max,
  formatter = spc.label.default,
  ...,
  cex = 0.7,
  adj = c(0, 0.5),
  srt = 90,
  warn = TRUE
)

spc.point.max(wl, spc, wlclick)

spc.point.default(wl, spc, wlclick)

spc.point.min(wl, spc, wlclick)

spc.point.sqr(wl, spc, wlclick, delta = 1L)

spc.label.default(ispc, wl, spc, digits = 3)

spc.label.wlonly(ispc, wl, spc, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spc.identify_+3A_x">x</code></td>
<td>
<p>either the abscissa coordinates or the list returned by
<code><a href="#topic+plotspc">plotspc</a></code></p>
</td></tr>
<tr><td><code id="spc.identify_+3A_y">y</code></td>
<td>
<p>the ordinate values. Giving <code>y</code> will override any values from
<code>x$y</code>.</p>
</td></tr>
<tr><td><code id="spc.identify_+3A_wavelengths">wavelengths</code></td>
<td>
<p>the wavelengths for the data points. Giving
<code>wavelengths</code> will override any values from <code>x$wavelengths</code>.</p>
</td></tr>
<tr><td><code id="spc.identify_+3A_ispc">ispc</code></td>
<td>
<p>if a selection of spectra was plotted, their indices can be
given in <code>ispc</code>. In this case <code>ispc [i]</code> is returned rather
than <code>i</code>.</p>
</td></tr>
<tr><td><code id="spc.identify_+3A_tol.wl">tol.wl</code>, <code id="spc.identify_+3A_tol.spc">tol.spc</code></td>
<td>
<p>tolerance in wavelength and spectral intensity to
search around the clicked point. See details.</p>
</td></tr>
<tr><td><code id="spc.identify_+3A_point.fn">point.fn</code></td>
<td>
<p><code>function (wl, spc, wlclick)</code> to determine the actual
point to label, see details.</p>
</td></tr>
<tr><td><code id="spc.identify_+3A_formatter">formatter</code></td>
<td>
<p><code>function (i, wl, spc)</code> that produces the labels. If
<code>NULL</code>, no labels are displayed.</p>
</td></tr>
<tr><td><code id="spc.identify_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="graphics.html#topic+text">text</a></code> in order to produce the
labels</p>
</td></tr>
<tr><td><code id="spc.identify_+3A_cex">cex</code>, <code id="spc.identify_+3A_adj">adj</code>, <code id="spc.identify_+3A_srt">srt</code></td>
<td>
<p>see <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="spc.identify_+3A_warn">warn</code></td>
<td>
<p>Should the user be warned if no point is in the considered
window? In addition, see the discussion of option <code>debuglevel</code> in
the details.
</p>
<p>If <code>FALSE</code>, the resulting data.frame will have a row of <code>NA</code>s
instead.</p>
</td></tr>
<tr><td><code id="spc.identify_+3A_wl">wl</code></td>
<td>
<p>the wavelength to label</p>
</td></tr>
<tr><td><code id="spc.identify_+3A_spc">spc</code></td>
<td>
<p>the intensity to label</p>
</td></tr>
<tr><td><code id="spc.identify_+3A_wlclick">wlclick</code></td>
<td>
<p>the clicked wavelength</p>
</td></tr>
<tr><td><code id="spc.identify_+3A_delta">delta</code></td>
<td>
<p><code>spc.point.sqr</code> fits the parabola in the window wlclick
<code class="reqn">\pm</code> delta points.</p>
</td></tr>
<tr><td><code id="spc.identify_+3A_digits">digits</code></td>
<td>
<p>how many digits of the wavelength should be displayed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a second step, <code>max.fn</code> searches for the actual point to label
within the specified wavelength window of that spectrum. This allows to
label maxima (or minima) without demanding too precise clicks. Currently,
the following functions to determine the precise point: </p>

<table>
<tr>
 <td style="text-align: left;">
spc.point.default </td><td style="text-align: left;"> uses the clicked wavelength together with its
spectral intensity</td>
</tr>
<tr>
 <td style="text-align: left;"> spc.point.max </td><td style="text-align: left;"> the point with the highest
intensity in the wavelength window </td>
</tr>
<tr>
 <td style="text-align: left;"> spc.point.min </td><td style="text-align: left;"> the point with
the lowest intensity in the wavelength window </td>
</tr>
<tr>
 <td style="text-align: left;"> spc.point.sqr </td><td style="text-align: left;">
maximum of a parabola fit throug the point with highest intensity and the
two surrounding points </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>
 <p><code>point.fn</code> is called with the arguments
<code>wl</code> containing the considered wavelength window, <code>spc</code> the
respective intensities of the closest spectrum, and <code>wlclick</code> the
wavelength that was clicked. They return a vector of two elements
(wavelength and intensity).
</p>
<p>As a last step, a label for the point produced by <code>formatter</code> and
plotted using <code><a href="graphics.html#topic+text">text</a></code>. Currently, the following
<code>formatter</code>s are available: </p>

<table>
<tr>
 <td style="text-align: left;"> spc.label.default </td><td style="text-align: left;">
spectrum number, wavelength </td>
</tr>
<tr>
 <td style="text-align: left;"> spc.label.wlonly </td><td style="text-align: left;"> wavelength</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p><code>formatter</code> functions receive the number of the spectrum <code>ispc</code>,
the wavelength <code>wl</code>, and the spectral intensity <code>spc</code> and produce
a character variable suitable for labelling. The predefined formatters
surround the label text by spaces in order to easily have an appropriate
offset from the point of the spectrum.
</p>
<p>The warning issued if no spectral point is inside the tolerance window may
be switched of by <code>warn = FALSE</code>. In that case, the click will produce
a row of <code>NA</code>s in the resulting data.frame.
</p>
<p><code>spc.identify</code> uses option <code>debuglevel</code> to determine whether debugging output should be
produced. <code>debuglevel == 2</code> will plot the tolerance window for every clicked point,
<code>debuglevel == 1</code> will plot the tolerance window only if no data point was inside.  See
<code><a href="#topic+options">hyperSpec options</a></code> for details about retrieving and setting
options.
</p>
<p>You may want to adjust the plot's <code>ylim</code> to ensure that the labels are
not clipped. As a dirty shortcut, <code>xpd = NA</code> may help.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> with columns </p>
<table role = "presentation">
<tr><td><code>ispc</code></td>
<td>
<p>spectra indices of the
identified points, i.e. the rows of the <code>hyperSpec</code> object that was
plotted.
</p>
<p>If <code>ispc</code> is given, <code>ispc [i]</code> is returned rather than <code>i</code>.
</p>
</td></tr> <tr><td><code>wavelengths</code></td>
<td>
<p>the wavelengths of the identified points</p>
</td></tr>
<tr><td><code>spc</code></td>
<td>
<p>the intensities of the identified points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+locator">locator</a></code>, <code><a href="#topic+plotspc">plotspc</a></code>,
<code><a href="#topic+options">hyperSpec options</a></code>
</p>
<p><code><a href="#topic+map.identify">map.identify</a></code> <code><a href="#topic+map.sel.poly">map.sel.poly</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive ()){
ispc &lt;- sample (nrow (laser), 10)
ispc

identified &lt;- spc.identify (plotspc (laser[ispc]))

## convert to the "real" spectra indices
ispc [identified$ispc]
identified$wl
identified$spc

## allow the labels to be plotted into the plot margin
spc.identify (plotspc (laser[ispc]), ispc = ispc, xpd = NA) 

spc.identify (plotspc (paracetamol, xoffset = 1100,
              wl.range = c (600 ~ 1700, 2900 ~ 3150)),
              formatter = spc.label.wlonly)

## looking for minima
spc.identify (plot (-paracetamol, wl.reverse = TRUE),
              point.fn = spc.point.min, adj = c (1, 0.5))

}

</code></pre>

<hr>
<h2 id='spc.loess'>loess smoothing interpolation for spectra
Spectra can be smoothed and interpolated on a new wavelength axis using
<code><a href="stats.html#topic+loess">loess</a></code>.</h2><span id='topic+spc.loess'></span>

<h3>Description</h3>

<p>Applying <code><a href="stats.html#topic+loess">loess</a></code> to each of the spectra, an interpolation onto a new
wavelength axis is performed.  At the same time, the specta are smoothed in order to increase the
signal : noise ratio. See <code><a href="stats.html#topic+loess">loess</a></code> and <code><a href="stats.html#topic+loess.control">loess.control</a></code> on
the parameters that control the amount of smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spc.loess(spc, newx, enp.target = nwl(spc)/4, surface = "direct", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spc.loess_+3A_spc">spc</code></td>
<td>
<p>the <code>hyperSpec</code> object</p>
</td></tr>
<tr><td><code id="spc.loess_+3A_newx">newx</code></td>
<td>
<p>wavelengh axis to interpolate on</p>
</td></tr>
<tr><td><code id="spc.loess_+3A_enp.target">enp.target</code>, <code id="spc.loess_+3A_surface">surface</code>, <code id="spc.loess_+3A_...">...</code></td>
<td>
<p>parameters for <code><a href="stats.html#topic+loess">loess</a></code> and
<code><a href="stats.html#topic+loess.control">loess.control</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new <code>hyperspec</code> object.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+loess">loess</a></code>, <code><a href="stats.html#topic+loess.control">loess.control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot (flu, col = "darkgray")
plot (spc.loess(flu, seq (420, 470, 5)), add = TRUE, col = "red")

flu [[3, ]] &lt;- NA_real_
smooth &lt;- spc.loess(flu, seq (420, 470, 5))
smooth [[, ]]
plot (smooth, add = TRUE, col = "blue")

</code></pre>

<hr>
<h2 id='spc.NA.approx'>Impute missing data points</h2><span id='topic+spc.NA.approx'></span><span id='topic+spc.NA.linapprox'></span>

<h3>Description</h3>

<p>Replace <code>NA</code>s in the spectra matrix by interpolation. With
less than 4 points available linear interpolation of the 2 neighbour points is used. For larger numbers of
neighbour points, smoothing interpolation is performed by
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spc.NA.approx(
  spc,
  neighbours = 1,
  w = rep(1, 2 * neighbours),
  df = 1 + .Machine$double.eps,
  spar = NULL,
  debuglevel = hy.getOption("debuglevel")
)

spc.NA.linapprox(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spc.NA.approx_+3A_spc">spc</code></td>
<td>
<p>hyperSpec object with spectra matrix containing <code>NA</code>s</p>
</td></tr>
<tr><td><code id="spc.NA.approx_+3A_neighbours">neighbours</code></td>
<td>
<p>how many neighbour data points should be used to fit the
line</p>
</td></tr>
<tr><td><code id="spc.NA.approx_+3A_w">w</code>, <code id="spc.NA.approx_+3A_df">df</code>, <code id="spc.NA.approx_+3A_spar">spar</code></td>
<td>
<p>see <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code></p>
</td></tr>
<tr><td><code id="spc.NA.approx_+3A_debuglevel">debuglevel</code></td>
<td>
<p>see <code><a href="#topic+options">options</a></code></p>
</td></tr>
<tr><td><code id="spc.NA.approx_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hyperSpec object
</p>


<h3>Note</h3>

<p>The function has been renamed from <code>spc.NA.linapprox</code> to  <code>spc.NA.approx</code>
</p>


<h3>Author(s)</h3>

<p>Claudia Beleites
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fluNA &lt;- hyperSpec:::fluNA
spc.NA.approx (fluNA [,, min ~ 410], debuglevel = 1)
spc.NA.approx (fluNA [1,, min ~ 410], debuglevel = 2)
spc.NA.approx (fluNA [4,, min ~ 410], neighbours = 3, df = 4, debuglevel = 2)
</code></pre>

<hr>
<h2 id='spc.rubberband'>Rubberband baseline correction</h2><span id='topic+spc.rubberband'></span>

<h3>Description</h3>

<p>Rubberband baseline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spc.rubberband(spc, ..., upper = FALSE, noise = 0, spline = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spc.rubberband_+3A_spc">spc</code></td>
<td>
<p>hyperSpec object</p>
</td></tr>
<tr><td><code id="spc.rubberband_+3A_...">...</code></td>
<td>
<p>further parameters handed to <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code></p>
</td></tr>
<tr><td><code id="spc.rubberband_+3A_upper">upper</code></td>
<td>
<p>logical indicating whether the lower or upper part of the hull should be used</p>
</td></tr>
<tr><td><code id="spc.rubberband_+3A_noise">noise</code></td>
<td>
<p>noise level to be taken into account</p>
</td></tr>
<tr><td><code id="spc.rubberband_+3A_spline">spline</code></td>
<td>
<p>logical indicating whether the baseline should be an interpolating spline through
the support points or piecewise linear.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Baseline with support points determined from a convex hull of the spectrum.
</p>
<p>Use <code>debuglevel &gt;= 1</code> to obtain debug plots, either directly via function argument or by setting hyperSpec's <code>debuglevel</code> option.
</p>


<h3>Value</h3>

<p>hyperSpec object containing the baselines
</p>


<h3>Note</h3>

<p>This function is still experimental
</p>


<h3>Author(s)</h3>

<p>Claudia Beleites
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spc.fit.poly">spc.fit.poly</a></code>, <code><a href="#topic+spc.fit.poly.below">spc.fit.poly.below</a></code>
</p>
<p><code>vignette ("baseline")</code>
</p>
<p><code><a href="#topic+hy.setOptions">hy.setOptions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot (paracetamol [,, 175 ~ 1800])
bl &lt;- spc.rubberband (paracetamol [,, 175 ~ 1800], noise = 300, df = 20)
plot (bl, add = TRUE, col = 2)

plot (paracetamol [,, 175 ~ 1800] - bl)
</code></pre>

<hr>
<h2 id='spc.smooth.spline'>Spectral smoothing by splines</h2><span id='topic+spc.smooth.spline'></span>

<h3>Description</h3>

<p>Smoothing splines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spc.smooth.spline(spc, newx = wl(spc), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spc.smooth.spline_+3A_spc">spc</code></td>
<td>
<p>hyperSpec object</p>
</td></tr>
<tr><td><code id="spc.smooth.spline_+3A_newx">newx</code></td>
<td>
<p>wavelengh axis to interpolate on</p>
</td></tr>
<tr><td><code id="spc.smooth.spline_+3A_...">...</code></td>
<td>
<p>further parameters handed to <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spectral smoothing by splines
</p>


<h3>Value</h3>

<p>hyperSpec object containing smoothed spectra
</p>


<h3>Note</h3>

<p>This function is still experimental
</p>


<h3>Author(s)</h3>

<p>Claudia Beleites
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spc.loess">spc.loess</a></code>
</p>
<p><code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- paracetamol [,,2200 ~ max]
plot (p, col = "gray")
smooth &lt;- spc.smooth.spline (p [,, c (2200 ~ 2400, 2500 ~ 2825, 3150 ~ max)],
                             wl (paracetamol [,, 2200 ~ max]),
                             df = 4, spar = 1)
plot (smooth, col = "red", add = TRUE)

plot (p - smooth)

</code></pre>

<hr>
<h2 id='split'>Split a hyperSpec object according to groups
<code>split</code> divides the <code>hyperSpec</code> object into a list of
<code>hyperSpec</code> objects according to the groups given by <code>f</code>.</h2><span id='topic+split'></span><span id='topic+split-methods'></span><span id='topic+split+2CANY-method'></span><span id='topic+split+2ChyperSpec-method'></span>

<h3>Description</h3>

<p>The <code>hyperSpec</code> objects in the list may be bound together again by
<code><a href="#topic+bind">bind</a> ("r", list_of_hyperSpec_objects)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hyperSpec'
split(x, f, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_+3A_x">x</code></td>
<td>
<p>the <code>hyperSpec</code> object</p>
</td></tr>
<tr><td><code id="split_+3A_f">f</code></td>
<td>
<p>a factor giving the grouping (or a variable that can be converted
into a factor by <code>as.factor</code>)</p>
</td></tr>
<tr><td><code id="split_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code>, levels of<code>f</code> that do not occur are
dropped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>hyperSpec</code> objects.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+split">split</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dist &lt;- pearson.dist (chondro[[]])
dend &lt;- hclust (dist, method = "ward")
z &lt;- cutree (dend, h = 0.15)

clusters &lt;- split (chondro, z)
length (clusters)

# difference in cluster mean spectra
plot (apply (clusters[[2]], 2, mean) - apply (clusters[[1]], 2, mean))


</code></pre>

<hr>
<h2 id='subset'>subset</h2><span id='topic+subset'></span><span id='topic+subset+2ChyperSpec-method'></span>

<h3>Description</h3>

<p>subset for hyperSpec object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hyperSpec'
subset(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset_+3A_x">x</code></td>
<td>
<p>hyperSpec object</p>
</td></tr>
<tr><td><code id="subset_+3A_...">...</code></td>
<td>
<p>handed to <code><a href="base.html#topic+subset">subset</a></code> (data.frame method)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hyperSpec object containing the respective subset of spectra.
</p>


<h3>Author(s)</h3>

<p>Claudia Beleites
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+subset">subset</a></code>
</p>

<hr>
<h2 id='Summary'>The functions</h2><span id='topic+Summary'></span><span id='topic+Summary+2ChyperSpec-method'></span><span id='topic+all+2ChyperSpec-method'></span><span id='topic+any+2ChyperSpec-method'></span><span id='topic+sum+2ChyperSpec-method'></span><span id='topic+prod+2ChyperSpec-method'></span><span id='topic+min+2ChyperSpec-method'></span><span id='topic+max+2ChyperSpec-method'></span><span id='topic+range+2ChyperSpec-method'></span><span id='topic+is.na+2ChyperSpec-method'></span><span id='topic+all_wl'></span><span id='topic+any_wl'></span>

<h3>Description</h3>

<p><code>all</code>, <code>any</code>,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hyperSpec'
Summary(x, ..., na.rm = FALSE)

## S4 method for signature 'hyperSpec'
is.na(x)

all_wl(expression, na.rm = FALSE)

any_wl(expression, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Summary_+3A_x">x</code></td>
<td>
<p>hyperSpec object</p>
</td></tr>
<tr><td><code id="Summary_+3A_...">...</code></td>
<td>
<p>further objects</p>
</td></tr>
<tr><td><code id="Summary_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether missing values should be removed</p>
</td></tr>
<tr><td><code id="Summary_+3A_expression">expression</code></td>
<td>
<p>expression that evaluates to a logical matrix of the same size as the spectra matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sum</code>, <code>prod</code>,
</p>
<p><code>min</code>, <code>max</code>, 
</p>
<p><code>range</code>, and
</p>
<p><code>is.na</code>
</p>
<p>for <code>hyperSpec</code> objects.
</p>
<p>All these functions work on the spectra matrix.
</p>


<h3>Value</h3>

<p><code>sum</code>, <code>prod</code>, <code>min</code>, <code>max</code>, and <code>range</code> return  a numeric,
<code>all</code>, <code>any</code>, and <code>is.na</code> a logical.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Summary">Summary</a></code> for the base summary functions.
</p>
<p><code><a href="base.html#topic+all.equal">all.equal</a></code> and <code><a href="base.html#topic+isTRUE">isTRUE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	range (flu) 


is.na (flu [,, 405 ~ 410]);

all_wl (flu &gt; 100)

any_wl (flu &gt; 300)
! any_wl (is.na (flu))
</code></pre>

<hr>
<h2 id='sweep'>Sweep Summary Statistic out of an hyperSpec Object
<code><a href="base.html#topic+sweep">sweep</a></code> for <code>hyperSpec</code> objects.</h2><span id='topic+sweep'></span><span id='topic+sweep-methods'></span><span id='topic+sweep+2ChyperSpec-method'></span>

<h3>Description</h3>

<p>Calls <code><a href="base.html#topic+sweep">sweep</a></code> for the spectra matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hyperSpec'
sweep(x, MARGIN, STATS, FUN = "-", check.margin = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sweep_+3A_x">x</code></td>
<td>
<p>a <code>hyperSpec object.</code></p>
</td></tr>
<tr><td><code id="sweep_+3A_margin">MARGIN</code></td>
<td>
<p>direction of the spectra matrix that <code>STATS</code> goees
along.</p>
</td></tr>
<tr><td><code id="sweep_+3A_stats">STATS</code></td>
<td>
<p>the summary statistic to sweep out. Either a vector or a
<code>hyperSpec</code> object.
</p>
<p>hyperSpec offers a non-standard convenience function: if <code>STATS</code> is a
function, this function is applied first (with the same <code>MARGIN</code>) to
compute the statistic. However, no further arguments to the apply
function can be given.  See the examples.</p>
</td></tr>
<tr><td><code id="sweep_+3A_fun">FUN</code></td>
<td>
<p>the function to do the sweeping, e.g. '-' or '/'.</p>
</td></tr>
<tr><td><code id="sweep_+3A_check.margin">check.margin</code></td>
<td>
<p>If <code>TRUE</code> (the default), warn if the length or
dimensions of <code>STATS</code> do not match the specified dimensions of
<code>x</code>.  Set to <code>FALSE</code> for a small speed gain when you
<em>know</em> that dimensions match.</p>
</td></tr>
<tr><td><code id="sweep_+3A_...">...</code></td>
<td>
<p>further arguments for <code>FUN</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sweep</code> is useful for some spectra preprocessing, like offset
correction, substraction of background spectra, and normalization of the
spectra.
</p>


<h3>Value</h3>

<p>A <code>hyperSpec</code> object.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sweep">sweep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Substract the background / slide / blank spectrum
# the example data does not have spectra of the empty slide,
# so instead the overall composition of the sample is substracted
background &lt;- apply (chondro, 2, quantile, probs = 0.05)
corrected &lt;- sweep (chondro, 2, background, "-")
plot (corrected, "spcprctl5")

## Offset correction
offsets &lt;- apply (chondro, 1, min)
corrected &lt;- sweep (chondro, 1, offsets, "-")
plot (corrected, "spcprctl5")

## Min-max normalization (on max amide I)
# the minimum is set to zero by the offset correction.
factor &lt;- apply (corrected, 1, max)
mm.corrected &lt;- sweep (corrected, 1, factor, "/")
plot (mm.corrected, "spcprctl5")

## convenience: give function to compute STATS:
mm.corrected2 &lt;- sweep (corrected, 1, max, "/")
plot (mm.corrected2)

## checking
stopifnot (all (mm.corrected2 == mm.corrected))

</code></pre>

<hr>
<h2 id='trellis.factor.key'>Color coding legend for factors
Modifies a list of lattice arguments (as for <code><a href="lattice.html#topic+levelplot">levelplot</a></code>, etc.) according to
the factor levels. The colorkey will shows all levels (including unused), and the drawing colors
will be set accordingly.</h2><span id='topic+trellis.factor.key'></span>

<h3>Description</h3>

<p><code>trellis.factor.key</code> is used during <code>levelplot</code>-based plotting of factors (for
hyperSpec objects) unless <code>transform.factor = FALSE</code> is specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trellis.factor.key(f, levelplot.args = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trellis.factor.key_+3A_f">f</code></td>
<td>
<p>the factor that will be color-coded</p>
</td></tr>
<tr><td><code id="trellis.factor.key_+3A_levelplot.args">levelplot.args</code></td>
<td>
<p>a list with levelplot arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the modified list with levelplot arguments.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+levelplot">levelplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
chondro$z &lt;- factor (rep (c("a", "a", "d", "c"),
                          length.out = nrow (chondro)),
                     levels = letters [1 : 4])

str (trellis.factor.key (chondro$z))

plotmap (chondro, z ~ x * y)

## switch off using trellis.factor.key:
## note that the factor levels are collapsed to c(1, 2, 3) rather than
## c (1, 3, 4)
plotmap (chondro, z ~ x * y, transform.factor = FALSE)

plotmap (chondro, z ~ x * y,
         col.regions = c ("gray", "red", "blue", "dark green"))

</code></pre>

<hr>
<h2 id='vanderMonde'>Function evaluation on hyperSpec objects</h2><span id='topic+vanderMonde'></span><span id='topic+vanderMonde+2ChyperSpec-method'></span>

<h3>Description</h3>

<p>vandermonde generates van der Monde matrices, the hyperSpec method generates a hyperSpec object
containing the van der Monde matrix of the wavelengths of a hyperSpec object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vanderMonde(x, order, ...)

## S4 method for signature 'hyperSpec'
vanderMonde(x, order, ..., normalize.wl = normalize01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vanderMonde_+3A_x">x</code></td>
<td>
<p>object to evaluate the polynomial on</p>
</td></tr>
<tr><td><code id="vanderMonde_+3A_order">order</code></td>
<td>
<p>of the polynomial</p>
</td></tr>
<tr><td><code id="vanderMonde_+3A_...">...</code></td>
<td>
<p>hyperSpec method: further arguments to <code><a href="#topic+decomposition">decomposition</a></code></p>
</td></tr>
<tr><td><code id="vanderMonde_+3A_normalize.wl">normalize.wl</code></td>
<td>
<p>function to transorm the wavelengths before evaluating the polynomial (or
other function). <code><a href="#topic+normalize01">normalize01</a></code> maps the wavelength range to the interval
[0, 1]. Use <code><a href="base.html#topic+I">I</a></code> to turn off.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is often numerically preferrable to map <code>wl (x)</code> to [0, 1], see the example.
</p>


<h3>Value</h3>

<p>van der Monde matrix
</p>
<p>hyperSpec method: hyperSpec object containing van der Monde matrix as spectra and an additional column &quot;.vdm.order&quot; giving the order of each spectrum (term).
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wl.eval">wl.eval</a></code> for calculating arbitrary functions of the wavelength,
</p>
<p><code><a href="#topic+normalize01">normalize01</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot (vanderMonde (flu, 2))
plot (vanderMonde (flu, 2, normalize.wl = I))


</code></pre>

<hr>
<h2 id='wc'>line/word/character count of ASCII files</h2><span id='topic+wc'></span>

<h3>Description</h3>

<p>'wc()' is defunct and will be removed from hyperSpec in future. Consider using [count_lines()] instead for line counting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wc()
</code></pre>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p>[count_lines()]
</p>

<hr>
<h2 id='wl'>Getting and Setting the Wavelength Axis
<code>wl</code> returns the wavelength axis, <code>wl&lt;-</code> sets it.</h2><span id='topic+wl'></span><span id='topic+wl+3C-'></span>

<h3>Description</h3>

<p>The wavelength axis of a <code>hyperSpec</code> object can be retrieved and
replaced with <code>wl</code> and <code>wl&lt;-</code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wl(x)

wl (x, label=NULL, digits=6) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wl_+3A_x">x</code></td>
<td>
<p>a <code>hyperSpec</code> object</p>
</td></tr>
<tr><td><code id="wl_+3A_label">label</code></td>
<td>
<p>The label for the new wavelength axis. See <a href="#topic+initialize">initialize</a>
for details.</p>
</td></tr>
<tr><td><code id="wl_+3A_digits">digits</code></td>
<td>
<p>handed to <code><a href="base.html#topic+signif">signif</a></code>. See details.</p>
</td></tr>
<tr><td><code id="wl_+3A_value">value</code></td>
<td>
<p>either a numeric containing the new wavelength vector, or a
list with <code>value$wl</code> containing the new wavelength vector and
<code>value$label</code> holding the corresponding <code>label</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the wavelength axis is replaced, the colnames of <code>x@data$spc</code> are
replaced by the rounded new wavelengths.  <code>digits</code> specifies the how
many significant digits should be used.
</p>
<p>There are two ways to set the label of the new wavelength axis, see the
examples.  If no label is given, a warning will be issued.
</p>


<h3>Value</h3>

<p>a numeric vector
</p>
<p><code>hyperSpec</code> object
</p>


<h3>Note</h3>

<p><code>wl&lt;-</code> always sets the complete wavelength axis, without
changing the columns of the spectra matrix. If you rather want to cut the
spectral range, use <code><a href="#topic+extractreplace">[</a></code>, for
interpolation along the spectral axis see
<code><a href="#topic+spc.loess">spc.loess</a></code> and for spectral binning
<code><a href="#topic+spc.bin">spc.bin</a></code>.
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+signif">signif</a></code>
</p>
<p>cutting the spectral range: <code><a href="#topic+extractreplace">[</a></code>
</p>
<p>interpolation along the spectral axis: <code><a href="#topic+spc.loess">spc.loess</a></code>
</p>
<p>spectral binning: <code><a href="#topic+spc.bin">spc.bin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	wl (laser)

	# convert from wavelength to frequency
	plot (laser)
	wl (laser, "f / Hz") &lt;- 2.998e8 * wl (laser) * 1e9
	plot (laser)

	# convert from Raman shift to wavelength
	# excitation was at 785 nm
	plot (chondro [1])
	wl (chondro) &lt;- list (wl = 1e7 / (1e7/785 - wl (chondro)), label = expression (lambda / nm))
	plot (chondro [1])

</code></pre>

<hr>
<h2 id='wl.eval'>Evaluate function on wavelengths of hyperSpec object</h2><span id='topic+wl.eval'></span>

<h3>Description</h3>

<p>This is useful for generating certain types of baseline &quot;reference spectra&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wl.eval(x, ..., normalize.wl = I)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wl.eval_+3A_x">x</code></td>
<td>
<p>hyperSpec object</p>
</td></tr>
<tr><td><code id="wl.eval_+3A_...">...</code></td>
<td>
<p>hyperSpec method: expressions to be evaluated</p>
</td></tr>
<tr><td><code id="wl.eval_+3A_normalize.wl">normalize.wl</code></td>
<td>
<p>function to transorm the wavelengths before evaluating the polynomial (or
other function). Use <code><a href="#topic+normalize01">normalize01</a></code> to map the wavelength range to the interval [0, 1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hyperSpec object containing one spectrum for each expression
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vanderMonde">vanderMonde</a></code> for  polynomials,
</p>
<p><code><a href="#topic+normalize01">normalize01</a></code> to normalize the wavenumbers before evaluating the function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot (wl.eval (laser, exp = function (x) exp (-x)))
</code></pre>

<hr>
<h2 id='wl2i'>Conversion between Wavelength and Spectra Matrix Column
Index <code>wl2i</code> returns the column indices for the spectra matrix for the given wavelengths.
<code>i2wl</code> converts column indices into wavelengths.</h2><span id='topic+wl2i'></span><span id='topic+i2wl'></span>

<h3>Description</h3>

<p>If <code>wavelength</code> is numeric, each of its elements is converted to the respective index.
Values outside the range of <code>x@wavelength</code> become <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wl2i(x, wavelength = stop("wavelengths are required."), unlist = TRUE)

i2wl(x, i)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wl2i_+3A_x">x</code></td>
<td>
<p>a <code>hyperSpec</code> object</p>
</td></tr>
<tr><td><code id="wl2i_+3A_wavelength">wavelength</code></td>
<td>
<p>the wavelengths to be converted into column indices,
either numeric or a formula, see details.</p>
</td></tr>
<tr><td><code id="wl2i_+3A_unlist">unlist</code></td>
<td>
<p>if multiple wavelength ranges are given, should the indices be unlisted or kept in a list?</p>
</td></tr>
<tr><td><code id="wl2i_+3A_i">i</code></td>
<td>
<p>the column indices into the spectra matrix for which the
wavelength is to be computed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the range is given as a formula (i.e. <code>start ~ end</code>, a sequence
</p>
<p>index corresponding to start : index corresponding to end
</p>
<p>is returned. If the wavelengths are not ordered, that may lead to chaos. In this case, call
<code><a href="#topic+orderwl">orderwl</a></code> first.
</p>
<p>Two special variables can be used: <code>min</code> and <code>max</code>, corresponding to the lowest and
highest wavelength of <code>x</code>, respectively.
</p>
<p>start and end may be complex numbers. The resulting index for a complex x is then
</p>
<p>index (Re (x)) + Im (x)
</p>


<h3>Value</h3>

<p>A numeric containing the resulting indices for <code>wl2i</code>
</p>
<p><code>i2wl</code> returns a numeric with the wavelengths
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
flu
wl2i (flu, 405 : 407)
wl2i (flu, 405 ~ 407)
  
## beginning of the spectrum to 407 nm 
wl2i (flu, min ~ 407)

## 2 data points from the beginning of the spectrum to 407 nm 
wl2i (flu, min + 2i ~ 407)

## the first 3 data points   
wl2i (flu, min ~ min + 2i)

## from 490 nm to end of the spectrum 
wl2i (flu, 490 ~ max)
  
## the last 8 data points 
wl2i (flu, max - 7i ~ max)
  
## get 450 nm +- 3 data points
wl2i (flu, 450 - 3i ~ 450 + 3i) 
  
wl2i (flu, 300 : 400) ## all NA: 
wl2i (flu, 600 ~ 700) ## NULL: completely outside flu's wavelength range

  
i2wl (chondro, 17:20)

</code></pre>

<hr>
<h2 id='wlconv'>Convert different wavelength units</h2><span id='topic+wlconv'></span><span id='topic+nm2raman'></span><span id='topic+nm2invcm'></span><span id='topic+nm2ev'></span><span id='topic+nm2freq'></span><span id='topic+invcm2raman'></span><span id='topic+invcm2nm'></span><span id='topic+invcm2ev'></span><span id='topic+invcm2freq'></span><span id='topic+raman2invcm'></span><span id='topic+raman2nm'></span><span id='topic+raman2ev'></span><span id='topic+raman2freq'></span><span id='topic+ev2raman'></span><span id='topic+ev2invcm'></span><span id='topic+ev2nm'></span><span id='topic+ev2freq'></span><span id='topic+freq2nm'></span><span id='topic+freq2invcm'></span><span id='topic+freq2ev'></span><span id='topic+freq2raman'></span>

<h3>Description</h3>

<p>The following units can be converted into each other: 
<em>nm</em>, <em><code class="reqn">cm^{-1}</code></em>, <em>eV</em>, <em>THz</em> and 
<em>Raman shift</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wlconv(points, src, dst, laser = NULL)

nm2raman(x, laser)

nm2invcm(x, ...)

nm2ev(x, ...)

nm2freq(x, ...)

invcm2raman(x, laser)

invcm2nm(x, ...)

invcm2ev(x, ...)

invcm2freq(x, ...)

raman2invcm(x, laser)

raman2nm(x, laser)

raman2ev(x, laser)

raman2freq(x, laser)

ev2raman(x, laser)

ev2invcm(x, ...)

ev2nm(x, ...)

ev2freq(x, ...)

freq2nm(x, ...)

freq2invcm(x, ...)

freq2ev(x, ...)

freq2raman(x, laser)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wlconv_+3A_points">points</code></td>
<td>
<p>data for conversion</p>
</td></tr>
<tr><td><code id="wlconv_+3A_src">src</code></td>
<td>
<p>source unit</p>
</td></tr>
<tr><td><code id="wlconv_+3A_dst">dst</code></td>
<td>
<p>destination unit</p>
</td></tr>
<tr><td><code id="wlconv_+3A_laser">laser</code></td>
<td>
<p>laser wavelength (required for work with Raman shift)</p>
</td></tr>
<tr><td><code id="wlconv_+3A_x">x</code></td>
<td>
<p>wavelength points for conversion</p>
</td></tr>
<tr><td><code id="wlconv_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>nm2raman</code>: conversion <strong>nanometers</strong> -&gt; <strong>Raman shift (relative wavenumber)</strong>
</p>
</li>
<li> <p><code>nm2invcm</code>: conversion <strong>nanometers</strong> -&gt; <strong>inverse cm (absolute wavenumber)</strong>
</p>
</li>
<li> <p><code>nm2ev</code>: conversion <strong>nanometers</strong> -&gt; <strong>electronvolt</strong>
</p>
</li>
<li> <p><code>nm2freq</code>: conversion <strong>nm</strong> -&gt; <strong>frequency in THz</strong>
</p>
</li>
<li> <p><code>invcm2raman</code>: conversion <strong>inverse cm (absolute wavenumber)</strong> -&gt; <strong>Raman shift (relative wavenumber)</strong>
</p>
</li>
<li> <p><code>invcm2nm</code>: conversion <strong>inverse cm (absolute wavenumber)</strong> -&gt; <strong>nanometers</strong>
</p>
</li>
<li> <p><code>invcm2ev</code>: conversion <strong>inverse cm (absolute wavenumber)</strong> -&gt; <strong>electronvolt</strong>
</p>
</li>
<li> <p><code>invcm2freq</code>: conversion <strong>inverse cm (absolute wavenumber)</strong> -&gt; <strong>frequency in THz</strong>
</p>
</li>
<li> <p><code>raman2invcm</code>: conversion <strong>Raman shift (relative wavenumber)</strong> -&gt; <strong>inverse cm (absolute wavenumber)</strong>
</p>
</li>
<li> <p><code>raman2nm</code>: conversion <strong>Raman shift (relative wavenumber)</strong> -&gt; <strong>nanometers</strong>
</p>
</li>
<li> <p><code>raman2ev</code>: conversion <strong>Raman shift (relative wavenumber)</strong> -&gt; <strong>electronvolt</strong>
</p>
</li>
<li> <p><code>raman2freq</code>: conversion <strong>Raman shift (relative wavenumber)</strong> -&gt; <strong>frequency in THz</strong>
</p>
</li>
<li> <p><code>ev2raman</code>: conversion <strong>electronvolt</strong> -&gt; <strong>Raman shift (relative wavenumber)</strong>
</p>
</li>
<li> <p><code>ev2invcm</code>: conversion <strong>electronvolt</strong> -&gt; <strong>inverse cm (absolute wavenumber)</strong>
</p>
</li>
<li> <p><code>ev2nm</code>: conversion <strong>electronvolt</strong> -&gt; <strong>nanometers</strong>
</p>
</li>
<li> <p><code>ev2freq</code>: conversion <strong>electronvolt</strong> -&gt; <strong>frequency in THz</strong>
</p>
</li>
<li> <p><code>freq2nm</code>: conversion <strong>frequency in THz</strong> -&gt; <strong>nanometers</strong>
</p>
</li>
<li> <p><code>freq2invcm</code>: conversion <strong>frequency in THz</strong> -&gt; <strong>inverse cm (absolute wavenumber)</strong>
</p>
</li>
<li> <p><code>freq2ev</code>: conversion <strong>frequency in THz</strong> -&gt; <strong>electronvolt</strong>
</p>
</li>
<li> <p><code>freq2raman</code>: conversion <strong>frequency in THz</strong> -&gt; <strong>Raman shift (relative wavenumber)</strong>
</p>
</li></ul>


<h3>Author(s)</h3>

<p>R. Kiselev
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wlconv (3200, "Raman shift", "nm", laser = 785.04)
wlconv( 785, "nm", "invcm")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
