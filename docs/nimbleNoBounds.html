<!DOCTYPE html><html><head><title>Help for package nimbleNoBounds</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nimbleNoBounds}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dLogChisq'><p>Log transformed chi-squared distribution.</p></a></li>
<li><a href='#dLogExp'><p>Log transformed exponential distribution.</p></a></li>
<li><a href='#dLogGamma'><p>Log transformed gamma distribution.</p></a></li>
<li><a href='#dLogHalfflat'><p>Log transformed half-flat distribution .</p></a></li>
<li><a href='#dLogInvgamma'><p>Log transformed inverse-gamma distribution.</p></a></li>
<li><a href='#dLogitBeta'><p>Logit transformed beta distribution.</p></a></li>
<li><a href='#dLogitUnif'><p>Logit transformed beta distribution.</p></a></li>
<li><a href='#dLogLnorm'><p>Log transformed log-normal distribution.</p></a></li>
<li><a href='#dLogWeib'><p>Log transformed Weibull distribution.</p></a></li>
<li><a href='#efficiencyGain'><p>Efficiency gain estimates from vignette example</p></a></li>
<li><a href='#nimbleNoBounds'><p>nimbleNoBounds</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Transformed Distributions for Improved MCMC Efficiency</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-08</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Pleydell &lt;david.pleydell@inrae.fr&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>David Pleydell [aut, cre, cph] (Package developer, &lt;https://orcid.org/0000-0002-6450-1475&gt;)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DRJP/nimbleNoBounds">https://github.com/DRJP/nimbleNoBounds</a></td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of common univariate bounded probability distributions transformed to the unbounded real line, for the purpose of increased MCMC efficiency.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Copyright:</td>
<td>See COPYRIGHTS file.</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2), nimble</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, coda</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-09 09:13:33 UTC; pleydell</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-09 10:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dLogChisq'>Log transformed chi-squared distribution.</h2><span id='topic+dLogChisq'></span><span id='topic+rLogChisq'></span>

<h3>Description</h3>

<p><code>dLogChisq</code> and <code>rLogChisq</code> provide a log-transformed chi-squared distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dLogChisq(x, df = 1, log = 0)

rLogChisq(n = 1, df = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dLogChisq_+3A_x">x</code></td>
<td>
<p>A continuous random variable on the real line, where y=exp(x) and y ~ dchisq(df).</p>
</td></tr>
<tr><td><code id="dLogChisq_+3A_df">df</code></td>
<td>
<p>df parameter of y ~ dchisq(df).</p>
</td></tr>
<tr><td><code id="dLogChisq_+3A_log">log</code></td>
<td>
<p>Logical flag to toggle returning the log density.</p>
</td></tr>
<tr><td><code id="dLogChisq_+3A_n">n</code></td>
<td>
<p>Number of random variables. Currently limited to 1, as is common in nimble. See ?replicate for an alternative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The density or log density of x, such that x = log(y) and y ~ dchisq(df).
</p>


<h3>Author(s)</h3>

<p>David R.J. Pleydell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create a Chi-squared random variable, and transform it to the log scale
n  = 100000
df = 3
y  = rchisq(n=n, df=df)
x  = log(y)

## Plot histograms of the two random variables
oldpar &lt;- par()
par(mfrow=n2mfrow(2))
## Plot 1
hist(x, n=100, freq=FALSE, main="", xlab= "x = log(y)")
curve(dLogChisq(x, df=df), -7, 4, n=1001, col="red", add=TRUE, lwd=3)
## Plot 2: back-transformed
xNew = replicate(n=n, rLogChisq(n=1, df=df))
yNew = exp(xNew)
hist(yNew, n=100, freq=FALSE, xlab="y = exp(x)", main="")
curve(dchisq(x, df=df), 0, 30, n=1001, col="red", lwd=3, add=TRUE)
par(oldpar)

## Create a NIMBLE model that uses this transformed distribution
code = nimbleCode({
  x ~ dLogChisq(df = 0.5)
  y &lt;- exp(x)
})


## Build &amp; compile the model
modelR = nimbleModel(code=code)
modelC = compileNimble(modelR)

## Configure, build and compile an MCMC
conf   = configureMCMC(modelC, monitors=c("x","y"))
mcmc   = buildMCMC(conf=conf)
cMcmc  = compileNimble(mcmc)

## Run the MCMC
samps = runMCMC(mcmc=cMcmc, niter=50000)
x     = samps[,"x"]
y     = samps[,"y"]

## Plot MCMC output
oldpar &lt;- par()
par(mfrow=n2mfrow(3))
## Plot 1: MCMC trajectory
plot(x, typ="l")
## Plot 2: taget density on unbounded sampling scale
hist(x, n=100, freq=FALSE, main="Histogram of MCMC samples", xlab="x = log(y)")
curve(dLogChisq(x, df=0.5), -55, 5, n=1001, col="red", lwd=3, add=TRUE)
## Plot 3: taget density on bounded scale
hist(y, n=100, freq=FALSE, xlab="y = exp(x)", main="Back-transformed MCMC samples")
curve(dchisq(x, df=0.5), 0, 20, n=1001, col="red", lwd=3, add=TRUE)
par(oldpar)

</code></pre>

<hr>
<h2 id='dLogExp'>Log transformed exponential distribution.</h2><span id='topic+dLogExp'></span><span id='topic+rLogExp'></span>

<h3>Description</h3>

<p><code>dLogExp</code> and <code>rLogExp</code> provide a log-transformed exponential distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dLogExp(x, rate = 1, log = 0)

rLogExp(n = 1, rate = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dLogExp_+3A_x">x</code></td>
<td>
<p>A continuous random variable on the real line. Let y=exp(x). Then y ~ dexp(rate).</p>
</td></tr>
<tr><td><code id="dLogExp_+3A_rate">rate</code></td>
<td>
<p>Rate parameter of y ~ dexp(rate).</p>
</td></tr>
<tr><td><code id="dLogExp_+3A_log">log</code></td>
<td>
<p>Logical flag to toggle returning the log density.</p>
</td></tr>
<tr><td><code id="dLogExp_+3A_n">n</code></td>
<td>
<p>Number of random variables. Currently limited to 1, as is common in nimble. See ?replicate for an alternative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The density or log density of x, such that x = log(y) and y ~ dexp(rate).
</p>


<h3>Author(s)</h3>

<p>David R.J. Pleydell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create a exponential random variable, and transform it to the log scale
n      = 100000
lambda = 3
y      = rexp(n=n, rate=lambda)
x      = log(y)

## Plot histograms of the two random variables
oldpar &lt;- par()
par(mfrow=n2mfrow(2))
## Plot 1
hist(x, n=100, freq=FALSE)
curve(dLogExp(x, rate=lambda), -15, 4, n=1001, col="red", add=TRUE, lwd=3)
## Plot 2: back-transformed
xNew = replicate(n=n, rLogExp(n=1, rate=lambda))
yNew   = exp(xNew)
hist(yNew, n=100, freq=FALSE, xlab="exp(x)")
curve(dexp(x, rate=lambda), 0, 4, n=1001, col="red", lwd=3, add=TRUE)
par(oldpar)

## Create a NIMBLE model that uses this distribution
code = nimbleCode({
  x ~ dLogExp(rate = 0.5)
  y &lt;- exp(x)
})


## Build &amp; compile the model
modelR = nimbleModel(code=code)
modelC = compileNimble(modelR)

## Configure, build and compile an MCMC
conf  = configureMCMC(modelC, monitors=c("x","y"))
mcmc  = buildMCMC(conf=conf)
cMcmc = compileNimble(mcmc)

## Run the MCMC
samps = runMCMC(mcmc=cMcmc, niter=50000)
x     = samps[,"x"]
y     = samps[,"y"]

## Plot MCMC output
oldpar &lt;- par()
par(mfrow=n2mfrow(3))
## Plot 1: MCMC trajectory
plot(x, typ="l")
## Plot 2: taget density on unbounded sampling scale
hist(x, n=100, freq=FALSE)
curve(dLogExp(x, rate=0.5), -15, 5, n=1001, col="red", lwd=3, add=TRUE)
## Plot 3: taget density on bounded scale
hist(y, n=100, freq=FALSE)
curve(dexp(x, rate=0.5), 0, 25, n=1001, col="red", lwd=3, add=TRUE)
par(oldpar)

</code></pre>

<hr>
<h2 id='dLogGamma'>Log transformed gamma distribution.</h2><span id='topic+dLogGamma'></span><span id='topic+rLogGamma'></span>

<h3>Description</h3>

<p><code>dLogGamma</code> and <code>rLogGamma</code> provide a log-transformed gamma distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dLogGamma(x, shape = 1, scale = 1, log = 0)

rLogGamma(n = 1, shape = 1, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dLogGamma_+3A_x">x</code></td>
<td>
<p>A continuous random variable on the real line. Let y=exp(x). Then y ~ dgamma(shape,scale).</p>
</td></tr>
<tr><td><code id="dLogGamma_+3A_shape">shape</code></td>
<td>
<p>Shape parameter of y ~ dgamma(shape,scale).</p>
</td></tr>
<tr><td><code id="dLogGamma_+3A_scale">scale</code></td>
<td>
<p>Scale parameter of y ~ dgamma(shape,scale).</p>
</td></tr>
<tr><td><code id="dLogGamma_+3A_log">log</code></td>
<td>
<p>Logical flag to toggle returning the log density.</p>
</td></tr>
<tr><td><code id="dLogGamma_+3A_n">n</code></td>
<td>
<p>Number of random variables. Currently limited to 1, as is common in nimble. See ?replicate for an alternative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The density or log density of x, such that x = log(y) and y ~ dgamma(shape,scale).
</p>


<h3>Author(s)</h3>

<p>David R.J. Pleydell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create a gamma random variable, and transform it to the log scale
n      = 100000
shape = 2
scale = 2
y      = rgamma(n=n, shape=shape, scale=scale)
x      = log(y)

## Plot histograms of the two random variables
oldpar &lt;- par()
par(mfrow=n2mfrow(2))
## Plot 1
hist(x, n=100, freq=FALSE)
curve(dLogGamma(x, shape=shape, scale=scale), -4, 5, n=1001, col="red", add=TRUE, lwd=3)
## Plot 2: back-transformed
xNew = replicate(n=n, rLogGamma(n=1, shape=shape, scale=scale))
yNew   = exp(xNew)
hist(yNew, n=100, freq=FALSE, xlab="exp(x)")
curve(dgamma(x, shape=shape, scale=scale), 0, 100, n=1001, col="red", lwd=3, add=TRUE)
par(oldpar)

## Create a NIMBLE model that uses this distribution
code = nimbleCode({
  log(y)  ~ dLogGamma(shape=shape, scale=scale)
  log(y2) ~ dLogGamma(shape=shape, rate=1/scale)
  log(y3) ~ dLogGamma(mean=shape*scale, sd=scale * sqrt(shape))
})


## Build &amp; compile the model
const = list (shape=shape, scale=scale)
modelR = nimbleModel(code=code, const=const)
simulate(modelR)
modelC = compileNimble(modelR)

## Configure, build and compile an MCMC
conf  = configureMCMC(modelC, monitors2=c("y", "y2", "y3"))
mcmc  = buildMCMC(conf=conf)
cMcmc = compileNimble(mcmc)

## Run the MCMC &amp; extract samples
samps = runMCMC(mcmc=cMcmc, niter=50000)
x  = as.vector(samps[[1]][,"log_y"])
x2 = as.vector(samps[[1]][,"log_y2"])
x3 = as.vector(samps[[1]][,"log_y3"])
y  = as.vector(samps[[2]][,"y"])
y2 = as.vector(samps[[2]][,"y2"])
y3 = as.vector(samps[[2]][,"y3"])

## Plot MCMC output
oldpar &lt;- par()
par(mfrow=n2mfrow(4))
## Plot 1: MCMC trajectory
plot(x, typ="l")
## Plot 2: taget density on unbounded sampling scale
hist(x, n=100, freq=FALSE)
curve(dLogGamma(x, shape=shape, scale=scale), -4, 3, n=1001, col="red", lwd=3, add=TRUE)
## Plot 3: taget density on bounded scale
hist(y, n=100, freq=FALSE)
curve(dgamma(x, shape=shape, scale=scale), 0, 25, n=1001, col="red", lwd=3, add=TRUE)
## Plot 4: different parameterisations
nBreaks=51
xLims = range(pretty(range(samps[[1]])))
hist(x, breaks=seq(xLims[1], xLims[2], l=nBreaks), col=rgb(1, 0, 0, 0.1))
hist(x2, breaks=seq(xLims[1], xLims[2], l=nBreaks), col=rgb(0, 1, 0, 0.1), add=TRUE)
hist(x3, breaks=seq(xLims[1], xLims[2], l=nBreaks), col=rgb(0, 0, 1, 0.1), add=TRUE)
par(oldpar)


</code></pre>

<hr>
<h2 id='dLogHalfflat'>Log transformed half-flat distribution .</h2><span id='topic+dLogHalfflat'></span><span id='topic+rLogHalfflat'></span>

<h3>Description</h3>

<p><code>dLogHalfflat</code> and <code>rLogHalfflat</code> provide a log-transformed half-flat distribution.
Note, both dhalfflat and dLogHalfflat are improper. Thus, rLogHalfflat returns NAN, just as rhalfflat does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dLogHalfflat(x, log = 0)

rLogHalfflat(n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dLogHalfflat_+3A_x">x</code></td>
<td>
<p>A continuous random variable on the real line, where y=exp(x) and y ~ dhalfflat().</p>
</td></tr>
<tr><td><code id="dLogHalfflat_+3A_log">log</code></td>
<td>
<p>Logical flag to toggle returning the log density.</p>
</td></tr>
<tr><td><code id="dLogHalfflat_+3A_n">n</code></td>
<td>
<p>Number of random variables. Currently limited to 1, as is common in nimble. See ?replicate for an alternative. Note, NAN will be returned because distribution is improper.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value proportional to the density, or the log of that value, of x, such that x = log(y) and y ~ dhalfflat().
</p>


<h3>Author(s)</h3>

<p>David R.J. Pleydell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
oldpar &lt;- par()
par(mfrow=n2mfrow(2))
## Plot 1
curve(dhalfflat(x), -11, 11, n=1001, col="red", lwd=3, xlab="y = exp(x)", ylab="dhalfflat(y)")
## Plot 2: back-transformed
curve(dLogHalfflat(x), -5, 1.5, n=1001, col="red", lwd=3, , xlab="x = log(y)")
abline(v=0:1, h=c(0,1,exp(1)), col="grey")
par(oldpar)

</code></pre>

<hr>
<h2 id='dLogInvgamma'>Log transformed inverse-gamma distribution.</h2><span id='topic+dLogInvgamma'></span><span id='topic+rLogInvgamma'></span>

<h3>Description</h3>

<p><code>dLogInvgamma</code> and <code>rLogInvgamma</code> provide a log-transformed inverse gamma distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dLogInvgamma(x, shape, scale = 1, log = 0)

rLogInvgamma(n = 1, shape, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dLogInvgamma_+3A_x">x</code></td>
<td>
<p>A continuous random variable on the real line. Let y=exp(x). Then y ~ dinvgamma(shape,scale).</p>
</td></tr>
<tr><td><code id="dLogInvgamma_+3A_shape">shape</code></td>
<td>
<p>Shape parameter of y ~ dinvgamma(shape,scale).</p>
</td></tr>
<tr><td><code id="dLogInvgamma_+3A_scale">scale</code></td>
<td>
<p>Scale parameter of y ~ dinvgamma(shape,scale).</p>
</td></tr>
<tr><td><code id="dLogInvgamma_+3A_log">log</code></td>
<td>
<p>Logical flag to toggle returning the log density.</p>
</td></tr>
<tr><td><code id="dLogInvgamma_+3A_n">n</code></td>
<td>
<p>Number of random variables. Currently limited to 1, as is common in nimble. See ?replicate for an alternative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The density or log density of x, such that x = log(y) and y ~ dinvgamma(shape,scale).
</p>


<h3>Author(s)</h3>

<p>David R.J. Pleydell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create an inverse gamma random variable, and transform it to the log scale
n      = 100000
shape = 2.5
scale = 0.01
y      = rinvgamma(n=n, shape=shape, scale=scale)
x      = log(y)

## Plot histograms of the two random variables
oldpar &lt;- par()
par(mfrow=n2mfrow(4))
## Plot 1
hist(y, n=100, freq=FALSE, xlab="y")
curve(dinvgamma(x, shape=shape, scale=scale), 0, 1.0, n=5001, col="red", add=TRUE, lwd=2)
## Plot 2
hist(x, n=100, freq=FALSE)
curve(dLogInvgamma(x, shape=shape, scale=scale), -8, 1, n=1001, col="red", add=TRUE, lwd=3)
## Plot 3: back-transformed
z = rgamma(n=n, shape=shape, scale=1/scale)
hist(1/z, n=100, freq=FALSE, xlab="y")
curve(dinvgamma(x, shape=shape, scale=scale), 0, 1, n=5001, col="red", lwd=3, add=TRUE)
## Plot 4: back-transformed
xNew = replicate(n=n, rLogInvgamma(n=1, shape=shape, scale=scale))
yNew = exp(xNew)
hist(yNew, n=100, freq=FALSE, xlab="exp(x)")
curve(dinvgamma(x, shape=shape, scale=scale), 0, 1, n=5001, col="red", lwd=3, add=TRUE)
par(oldpar)

## Create a NIMBLE model that uses this transformed distribution
code = nimbleCode({
  log(y) ~ dLogInvgamma(shape=shape, scale=scale)
})


## Build &amp; compile the model
const  = list(shape=shape, scale=scale)
modelR = nimbleModel(code=code, const=const)
simulate(modelR)
modelC = compileNimble(modelR)

## Configure, build and compile an MCMC
conf  = configureMCMC(modelC, monitors=c("log_y", "y"))
mcmc  = buildMCMC(conf=conf)
cMcmc = compileNimble(mcmc)

## Run the MCMC
samps = runMCMC(mcmc=cMcmc, niter=50000)
x = samps[,"log_y"]
y = samps[,"y"]


## Plot MCMC output
oldpar &lt;- par()
par(mfrow=n2mfrow(3))
## Plot 1: MCMC trajectory
plot(x, typ="l")
## Plot 2: taget density on unbounded sampling scale
hist(x, n=100, freq=FALSE)
curve(dLogInvgamma(x, shape=shape, scale=scale), -10, 1, n=1001, col="red", lwd=3, add=TRUE)
## Plot 3: taget density on bounded scale
curve(dinvgamma(x, shape=shape, scale=scale), xlab="y = exp(x)", 0, 0.5, n=1001, col="red", lwd=3)
hist(y, n=100, freq=FALSE, add=TRUE)
curve(dinvgamma(x, shape=shape, scale=scale), 0, 0.5, n=1001, col="red", add=TRUE, lwd=3)
par(oldpar)

</code></pre>

<hr>
<h2 id='dLogitBeta'>Logit transformed beta distribution.</h2><span id='topic+dLogitBeta'></span><span id='topic+rLogitBeta'></span>

<h3>Description</h3>

<p>Logit transformation of beta random variable to the real line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dLogitBeta(x, shape1 = 1, shape2 = 1, log = 0)

rLogitBeta(n = 1, shape1 = 1, shape2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dLogitBeta_+3A_x">x</code></td>
<td>
<p>A continuous random variable on the real line, where y=ilogit(x) and y ~ dbeta(shape1, shape2).</p>
</td></tr>
<tr><td><code id="dLogitBeta_+3A_shape1">shape1</code></td>
<td>
<p>non-negative parameter of the Beta distribution.</p>
</td></tr>
<tr><td><code id="dLogitBeta_+3A_shape2">shape2</code></td>
<td>
<p>non-negative parameter of the Beta distribution.</p>
</td></tr>
<tr><td><code id="dLogitBeta_+3A_log">log</code></td>
<td>
<p>logical flag. Returns log-density if TRUE.</p>
</td></tr>
<tr><td><code id="dLogitBeta_+3A_n">n</code></td>
<td>
<p>Number of random variables. Currently limited to 1, as is common in nimble. See ?replicate for an alternative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>density or log-density of beta distributions transformed to real line via logit function.
</p>


<h3>Author(s)</h3>

<p>David R.J. Pleydell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create a beta random variable, and transform it to the logit scale
n      = 100000
sh1    = 1
sh2    = 11
y      = rbeta(n=n, sh1, sh2)
x      = logit(y)

## Plot histograms of the two random variables
oldpar &lt;- par()
par(mfrow=n2mfrow(2))
## Plot 1
hist(x, n=100, freq=FALSE)
curve(dLogitBeta(x, sh1, sh2), -15, 4, n=1001, col="red", add=TRUE, lwd=3)
## Plot 2: back-transformed
xNew = replicate(n=n, rLogitBeta(n=1, sh1, sh2))
yNew   = ilogit(xNew)
hist(yNew, n=100, freq=FALSE, xlab="exp(x)")
curve(dbeta(x, sh1, sh2), 0, 1, n=1001, col="red", lwd=3, add=TRUE)
par(oldpar)

## Create a NIMBLE model that uses this transformed distribution
code = nimbleCode({
  x ~ dLogitBeta(sh1, sh2)
})


## Build &amp; compile the model
const = list(sh1=sh1, sh2=sh2)
modelR = nimbleModel(code=code, const=const)
modelC = compileNimble(modelR)

## Configure, build and compile an MCMC
conf  = configureMCMC(modelC)
mcmc  = buildMCMC(conf=conf)
cMcmc = compileNimble(mcmc)

## Run the MCMC
x = as.vector(runMCMC(mcmc=cMcmc, niter=50000))

## Plot MCMC output
oldpar &lt;- par()
par(mfrow=n2mfrow(3))
## Plot 1: MCMC trajectory
plot(x, typ="l")
## Plot 2: taget density on unbounded sampling scale
hist(x, n=100, freq=FALSE, xlab="x = logit(y)")
curve(dLogitBeta(x, sh1, sh2), -15, 5, n=1001, col="red", lwd=3, add=TRUE)
## Plot 3: taget density on bounded scale
hist(ilogit(x), n=100, freq=FALSE, xlab="y")
curve(dbeta(x, sh1, sh2), 0, 1, n=1001, col="red", lwd=3, add=TRUE)
par(oldpar)

</code></pre>

<hr>
<h2 id='dLogitUnif'>Logit transformed beta distribution.</h2><span id='topic+dLogitUnif'></span><span id='topic+rLogitUnif'></span>

<h3>Description</h3>

<p>Transformation of uniform distribution, via scaled-logit transform, to the real line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dLogitUnif(x, min = 0, max = 1, log = 0)

rLogitUnif(n = 1, min = 0, max = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dLogitUnif_+3A_x">x</code></td>
<td>
<p>A continuous random variable on the real line, where y=ilogit(x)*(max-min)+min and y ~ dunif(min, max).</p>
</td></tr>
<tr><td><code id="dLogitUnif_+3A_min">min</code></td>
<td>
<p>lower limit of the distribution.  Must be finite.</p>
</td></tr>
<tr><td><code id="dLogitUnif_+3A_max">max</code></td>
<td>
<p>upper limit of the distribution.  Must be finite.</p>
</td></tr>
<tr><td><code id="dLogitUnif_+3A_log">log</code></td>
<td>
<p>logical flag. Returns log-density if TRUE.</p>
</td></tr>
<tr><td><code id="dLogitUnif_+3A_n">n</code></td>
<td>
<p>Number of random variables. Currently limited to 1, as is common in nimble. See ?replicate for an alternative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>density, or log-density, of uniform distribution transformed to real line via scaling and logit function.
</p>


<h3>Author(s)</h3>

<p>David R.J. Pleydell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create a uniform random variable, and transform it to the log scale
n      = 100000
lower  = -5
upper  = 11
y      = runif(n=n, lower, upper)
x      = logit((y-lower)/(upper-lower))

## Plot histograms of the two random variables
oldpar &lt;- par()
par(mfrow=n2mfrow(2))
## Plot 1
hist(x, n=100, freq=FALSE)
curve(dLogitUnif(x, lower, upper), -15, 15, n=1001, col="red", add=TRUE, lwd=3)
## Plot 2: back-transformed
xNew = replicate(n=n, rLogitUnif(n=1, lower, upper))
yNew   = ilogit(xNew) * (upper-lower) + lower
hist(yNew, n=100, freq=FALSE, xlab="exp(x)")
curve(dunif(x, lower, upper), -15, 15, n=1001, col="red", lwd=3, add=TRUE)
par(oldpar)

## Create a NIMBLE model that uses this transformed distribution
code = nimbleCode({
  x ~ dLogitUnif(lower, upper)
})


## Build &amp; compile the model
const = list(lower=lower, upper=upper)
modelR = nimbleModel(code=code, const=const)
modelC = compileNimble(modelR)

## Configure, build and compile an MCMC
conf  = configureMCMC(modelC)
mcmc  = buildMCMC(conf=conf)
cMcmc = compileNimble(mcmc)

## Run the MCMC
x = as.vector(runMCMC(mcmc=cMcmc, niter=50000))

## Plot MCMC output
oldpar &lt;- par()
par(mfrow=n2mfrow(3))
## Plot 1: MCMC trajectory
plot(x, typ="l")
## Plot 2: taget density on unbounded sampling scale
hist(x, n=100, freq=FALSE, xlab="x = logit(y)")
curve(dLogitUnif(x, lower, upper), -15, 15, n=1001, col="red", lwd=3, add=TRUE)
## Plot 3: taget density on bounded scale
hist(ilogit(x)*(upper-lower)+lower, n=100, freq=FALSE, xlab="y")
curve(dunif(x, lower, upper), -15, 15, n=1001, col="red", lwd=3, add=TRUE)
par(oldpar)

</code></pre>

<hr>
<h2 id='dLogLnorm'>Log transformed log-normal distribution.</h2><span id='topic+dLogLnorm'></span><span id='topic+rLogLnorm'></span>

<h3>Description</h3>

<p><code>dLogLnorm</code> and <code>rLogLnorm</code> provide a log-transformed log-normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dLogLnorm(x, meanlog = 0, sdlog = 1, log = 0)

rLogLnorm(n = 1, meanlog = 0, sdlog = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dLogLnorm_+3A_x">x</code></td>
<td>
<p>A continuous random variable on the real line. Let y=exp(x). Then y ~ dlnorm(meanlog, sdlog).</p>
</td></tr>
<tr><td><code id="dLogLnorm_+3A_meanlog">meanlog</code></td>
<td>
<p>mean of the distribution on the log scale with default values of ‘0’.</p>
</td></tr>
<tr><td><code id="dLogLnorm_+3A_sdlog">sdlog</code></td>
<td>
<p>standard deviation of the distribution on the log scale with default values of ‘1’.</p>
</td></tr>
<tr><td><code id="dLogLnorm_+3A_log">log</code></td>
<td>
<p>Logical flag to toggle returning the log density.</p>
</td></tr>
<tr><td><code id="dLogLnorm_+3A_n">n</code></td>
<td>
<p>Number of random variables. Currently limited to 1, as is common in nimble. See ?replicate for an alternative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The density or log density of x, such that x = log(y) and y ~ dlnorm(meanlog,sdlog).
</p>


<h3>Author(s)</h3>

<p>David R.J. Pleydell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create a log-normal random variable, and transform it to the log scale
n       = 100000
meanlog = -3
sdlog   = 0.1
y       = rlnorm(n=n, meanlog=meanlog, sdlog=sdlog)
x       = log(y)

## Plot histograms of the two random variables
oldpar &lt;- par()
par(mfrow=n2mfrow(2))
## Plot 1
hist(x, n=100, freq=FALSE)
curve(dLogLnorm(x, meanlog=meanlog, sdlog=sdlog), -4, -2, n=1001, col="red", add=TRUE, lwd=3)
## Plot 2: back-transformed
xNew = replicate(n=n, rLogLnorm(n=1, meanlog=meanlog, sdlog=sdlog))
yNew   = exp(xNew)
hist(yNew, n=100, freq=FALSE, xlab="exp(x)")
curve(dlnorm(x, meanlog=meanlog, sdlog=sdlog), 0, 0.1, n=1001, col="red", lwd=3, add=TRUE)
par(oldpar)

## Create a NIMBLE model that uses this transformed distribution
code = nimbleCode({
  log(y) ~ dLogLnorm(meanlog=meanlog, sdlog=sdlog)
})


## Build &amp; compile the model
const = list (meanlog=meanlog, sdlog=sdlog)
modelR = nimbleModel(code=code, const=const)
simulate(modelR)
modelC = compileNimble(modelR)

## Configure, build and compile an MCMC
conf  = configureMCMC(modelC)
mcmc  = buildMCMC(conf=conf)
cMcmc = compileNimble(mcmc)

## Run the MCMC
x = as.vector(runMCMC(mcmc=cMcmc, niter=50000))
y = exp(x)

## Plot MCMC output
oldpar &lt;- par()
par(mfrow=n2mfrow(3))
## Plot 1: MCMC trajectory
plot(x, typ="l")
## Plot 2: taget density on unbounded sampling scale
hist(x, n=100, freq=FALSE)
curve(dLogLnorm(x, meanlog=meanlog, sdlog=sdlog), -4, -2, n=1001, col="red", lwd=3, add=TRUE)
## Plot 3: taget density on bounded scale
hist(y, n=100, freq=FALSE)
curve(dlnorm(x, meanlog=meanlog, sdlog=sdlog), 0, 0.1, n=1001, col="red", lwd=3, add=TRUE)
par(oldpar)

</code></pre>

<hr>
<h2 id='dLogWeib'>Log transformed Weibull distribution.</h2><span id='topic+dLogWeib'></span><span id='topic+rLogWeib'></span>

<h3>Description</h3>

<p><code>dLogWeib</code> and <code>rLogWeib</code> provide a log-transformed Weibull distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dLogWeib(x, shape = 1, scale = 1, log = 0)

rLogWeib(n = 1, shape = 1, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dLogWeib_+3A_x">x</code></td>
<td>
<p>A continuous random variable on the real line, where y=exp(x) and y ~ dweib(shape,scale).</p>
</td></tr>
<tr><td><code id="dLogWeib_+3A_shape">shape</code></td>
<td>
<p>Shape parameter of y ~ dweib(shape,scale).</p>
</td></tr>
<tr><td><code id="dLogWeib_+3A_scale">scale</code></td>
<td>
<p>Scale parameter of y ~ dweib(shape,scale).</p>
</td></tr>
<tr><td><code id="dLogWeib_+3A_log">log</code></td>
<td>
<p>Logical flag to toggle returning the log density.</p>
</td></tr>
<tr><td><code id="dLogWeib_+3A_n">n</code></td>
<td>
<p>Number of random variables. Currently limited to 1, as is common in nimble. See ?replicate for an alternative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The density or log density of x, such that x = log(y) and y ~ dweib(shape,scale).
</p>


<h3>Author(s)</h3>

<p>David R.J. Pleydell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create a Weibull random variable, and transform it to the log scale
n      = 100000
shape = 2
scale = 2
y      = rweibull(n=n, shape=shape, scale=scale)
x      = log(y)

## Plot histograms of the two random variables
oldpar &lt;- par()
par(mfrow=n2mfrow(2))
## Plot 1
hist(x, n=100, freq=FALSE, xlab="x = log(y)",
     main="Histogram of log-transformed random numbers from rweibull.")
curve(dLogWeib(x, shape=shape, scale=scale), -6, 3, n=1001, col="red", add=TRUE, lwd=3)
## Plot 2: back-transformed
xNew = replicate(n=n, rLogWeib(n=1, shape=shape, scale=scale))
yNew = exp(xNew)
hist(yNew, n=100, freq=FALSE, xlab="y = exp(x)", main="Histogram of random numbers from rLogWeib.")
curve(dweibull(x, shape=shape, scale=scale), 0, 100, n=1001, col="red", lwd=3, add=TRUE)
par(oldpar)

## Create a NIMBLE model that uses this transformed distribution
code = nimbleCode({
  log(y) ~ dLogWeib(shape=shape, scale=scale)
})


## Build &amp; compile the model
const = list (shape=shape, scale=scale)
modelR = nimbleModel(code=code, const=const)
simulate(modelR)
modelC = compileNimble(modelR)

## Configure, build and compile an MCMC
conf  = configureMCMC(modelC)
mcmc  = buildMCMC(conf=conf)
cMcmc = compileNimble(mcmc)

## Run the MCMC
x = as.vector(runMCMC(mcmc=cMcmc, niter=50000))
y = exp(x)

## Plot MCMC output
oldpar &lt;- par()
par(mfrow=n2mfrow(3))
## Plot 1: MCMC trajectory
plot(x, typ="l")
## Plot 2: taget density on unbounded sampling scale
hist(x, n=100, freq=FALSE, main="Histogram of MCMC samples", xlab="x = log(y)")
curve(dLogWeib(x, shape=shape, scale=scale), -5, 3, n=1001, col="red", lwd=3, add=TRUE)
## Plot 3: taget density on bounded scale
hist(y, n=100, freq=FALSE, xlab="y = exp(x)",
     main="Histogram of back-transformed MCMC samples")
curve(dweibull(x, shape=shape, scale=scale), 0, 8, n=1001, col="red", lwd=3, add=TRUE)
par(oldpar)

</code></pre>

<hr>
<h2 id='efficiencyGain'>Efficiency gain estimates from vignette example</h2><span id='topic+efficiencyGain'></span>

<h3>Description</h3>

<p>The toy example in the vignette provides a simple Monte Carlo experiment that tests the gain in sampling efficiency when switching to sampling on unbounded scales (i.e. the real line).
Since that Monte Carlo experiment takes 10 minutes to run, 'efficiencyGain' is provided as an example set of output data - providing an alternative to re-running the Monte Carlo code.
</p>


<h3>Format</h3>

<p>A data frame with 111 rows (number of Monte Carlo replicates) and 8 variables
</p>

<dl>
<dt>beta</dt><dd><p>Efficiency gain when sampling a beta distribution on the real line.</p>
</dd>
<dt>chisq</dt><dd><p>Efficiency gain when sampling a chi-squared distribution on the real line.</p>
</dd>
<dt>exp</dt><dd><p>Efficiency gain when sampling a exponential distribution on the real line.</p>
</dd>
<dt>gamma</dt><dd><p>Efficiency gain when sampling a gamma distribution on the real line.</p>
</dd>
<dt>invgamma</dt><dd><p>Efficiency gain when sampling a inverse-gamma distribution on the real line.</p>
</dd>
<dt>lnorm</dt><dd><p>Efficiency gain when sampling a log-normal distribution on the real line.</p>
</dd>
<dt>unif</dt><dd><p>Efficiency gain when sampling a uniform distribution on the real line.</p>
</dd>
<dt>weib</dt><dd><p>Efficiency gain when sampling a Weibull distribution on the real line.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>David Pleydell
</p>


<h3>Source</h3>

<p>See 'vignette(&quot;nimbleNoBounds&quot;)'
</p>

<hr>
<h2 id='nimbleNoBounds'>nimbleNoBounds</h2><span id='topic+nimbleNoBounds'></span>

<h3>Description</h3>

<p>A collection of NIMBLE functions for sampling common probability distributions on unbounded scales.
</p>


<h3>Transformed probability distributions for unbounded sampling in NIMBLE.</h3>

<p>NA
</p>


<h3>See Also</h3>

<p><a href="https://r-nimble.org/">https://r-nimble.org/</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
