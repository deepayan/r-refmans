<!DOCTYPE html><html><head><title>Help for package sdmTMB</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sdmTMB}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_barrier_mesh'><p>Transform a mesh object into a mesh with correlation barriers</p></a></li>
<li><a href='#add_utm_columns'><p>Add UTM coordinates to a data frame</p></a></li>
<li><a href='#dharma_residuals'><p>DHARMa residuals</p></a></li>
<li><a href='#Effect.sdmTMB'><p>Calculate effects</p></a></li>
<li><a href='#emmeans.sdmTMB'><p>Estimated marginal means with the <span class="pkg">emmeans</span> package with <span class="pkg">sdmTMB</span></p></a></li>
<li><a href='#extract_mcmc'><p>Extract MCMC samples from a model fit with <span class="pkg">tmbstan</span>.</p></a></li>
<li><a href='#Families'><p>Additional families</p></a></li>
<li><a href='#get_index'><p>Extract a relative biomass/abundance index or a center of gravity</p></a></li>
<li><a href='#get_index_sims'><p>Calculate a population index via simulation from the joint precision matrix</p></a></li>
<li><a href='#get_pars'><p>Get TMB parameter list</p></a></li>
<li><a href='#ggplot2_installed'><p>Check if ggplot2 installed</p></a></li>
<li><a href='#make_mesh'><p>Construct an SPDE mesh for sdmTMB</p></a></li>
<li><a href='#pcod'><p>Example fish survey data</p></a></li>
<li><a href='#plot_anisotropy'><p>Plot anisotropy from an sdmTMB model</p></a></li>
<li><a href='#plot_pc_matern'><p>Plot PC Matérn priors</p></a></li>
<li><a href='#plot_smooth'><p>Plot a smooth term from an sdmTMB model</p></a></li>
<li><a href='#predict.sdmTMB'><p>Predict from an sdmTMB model</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#replicate_df'><p>Replicate a prediction data frame over time</p></a></li>
<li><a href='#residuals.sdmTMB'><p>Residuals method for sdmTMB models</p></a></li>
<li><a href='#run_extra_optimization'><p>Run extra optimization on an already fitted object</p></a></li>
<li><a href='#sanity'><p>Sanity check of an sdmTMB model</p></a></li>
<li><a href='#sdmTMB'><p>Fit a spatial or spatiotemporal GLMM with TMB</p></a></li>
<li><a href='#sdmTMB_cv'><p>Cross validation with sdmTMB models</p></a></li>
<li><a href='#sdmTMB_simulate'><p>Simulate from a spatial/spatiotemporal model</p></a></li>
<li><a href='#sdmTMB_stacking'><p>Perform stacking with log scores on <code>sdmTMB_cv()</code> output</p></a></li>
<li><a href='#sdmTMBcontrol'><p>Optimization control options</p></a></li>
<li><a href='#sdmTMBpriors'><p>Prior distributions</p></a></li>
<li><a href='#set_delta_model'><p>Set delta model for <code>ggeffects::ggpredict()</code></p></a></li>
<li><a href='#simulate.sdmTMB'><p>Simulate from a fitted sdmTMB model</p></a></li>
<li><a href='#spread_sims'><p>Extract parameter simulations from the joint precision matrix</p></a></li>
<li><a href='#tidy.sdmTMB'><p>Turn sdmTMB model output into a tidy data frame</p></a></li>
<li><a href='#visreg_delta'><p>Plot sdmTMB models with the <span class="pkg">visreg</span> package</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial and Spatiotemporal SPDE-Based GLMMs with 'TMB'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements spatial and spatiotemporal GLMMs (Generalized Linear
    Mixed Effect Models) using 'TMB', 'fmesher', and the SPDE (Stochastic Partial
    Differential Equation) Gaussian Markov random field approximation to
    Gaussian random fields. One common application is for spatially explicit
    species distribution models (SDMs).
    See Anderson et al. (2022) &lt;<a href="https://doi.org/10.1101%2F2022.03.24.485545">doi:10.1101/2022.03.24.485545</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>inst/COPYRIGHTS</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pbs-assess.github.io/sdmTMB/">https://pbs-assess.github.io/sdmTMB/</a>,
<a href="https://github.com/pbs-assess/sdmTMB">https://github.com/pbs-assess/sdmTMB</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pbs-assess/sdmTMB/issues">https://github.com/pbs-assess/sdmTMB/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, clisymbols, cli, fmesher, fishMod, generics,
graphics, lifecycle, lme4, Matrix, methods, mgcv, mvtnorm,
nlme, rlang, stats, TMB (&ge; 1.8.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DHARMa, dplyr, effects (&ge; 4.0-1), estimability, emmeans (&ge;
1.4), future, future.apply, ggeffects, ggforce, glmmTMB,
ggplot2, knitr, rmarkdown, sf, splancs, testthat, tibble,
visreg</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppEigen, TMB</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-03 19:50:01 UTC; seananderson</td>
</tr>
<tr>
<td>Author:</td>
<td>Sean C. Anderson <a href="https://orcid.org/0000-0001-9563-1937"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Eric J. Ward <a href="https://orcid.org/0000-0002-4359-0296"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Philina A. English
    <a href="https://orcid.org/0000-0003-2992-6782"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Lewis A. K. Barnett
    <a href="https://orcid.org/0000-0002-9381-8375"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  James T. Thorson <a href="https://orcid.org/0000-0001-7415-1010"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph] (VAST author),
  Joe Watson [ctb] (Censored Poisson),
  Julia Indivero [ctb] (Vignette writing),
  Jillian C. Dunic <a href="https://orcid.org/0000-0002-0729-3083"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Cole C. Monnahan <a href="https://orcid.org/0000-0003-0871-6700"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb, cph] (VAST contributor),
  Mollie Brooks <a href="https://orcid.org/0000-0001-6963-8326"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb, cph] (glmmTMB author),
  Ben Bolker <a href="https://orcid.org/0000-0002-2127-0443"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb,
    cph] (glmmTMB author),
  Kasper Kristensen [ctb, cph] (TMB/glmmTMB author),
  Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb, cph] (glmmTMB author),
  Arni Magnusson <a href="https://orcid.org/0000-0003-2769-6741"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb, cph] (glmmTMB author),
  Hans J. Skaug [ctb, cph] (glmmTMB author, SPDE barrier),
  Anders Nielsen <a href="https://orcid.org/0000-0001-9683-9262"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb, cph] (glmmTMB author),
  Casper Berg <a href="https://orcid.org/0000-0002-3812-5269"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb,
    cph] (glmmTMB author),
  Koen van Bentham [ctb, cph] (glmmTMB author),
  Olav Nikolai Breivik [ctb, cph] (SPDE barrier),
  Simon Wood [ctb, cph] (mgcv: smoother prediction),
  Paul-Christian Bürkner [ctb, cph] (brms: smoother matrix parsing),
  His Majesty the King in Right of Canada, as represented by the Minister
    of the Department of Fisheries and Oceans [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sean C. Anderson &lt;sean@seananderson.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-03 20:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_barrier_mesh'>Transform a mesh object into a mesh with correlation barriers</h2><span id='topic+add_barrier_mesh'></span>

<h3>Description</h3>

<p>Moved to the <a href="https://github.com/pbs-assess/sdmTMBextra">sdmTMBextra</a>
package. Make sure to load <span class="pkg">sdmTMBextra</span> <em>after</em> <span class="pkg">sdmTMB</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_barrier_mesh(
  spde_obj = deprecated(),
  barrier_sf = deprecated(),
  range_fraction = 0.2,
  proj_scaling = 1,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_barrier_mesh_+3A_spde_obj">spde_obj</code></td>
<td>
<p>Output from <code><a href="#topic+make_mesh">make_mesh()</a></code>.</p>
</td></tr>
<tr><td><code id="add_barrier_mesh_+3A_barrier_sf">barrier_sf</code></td>
<td>
<p>An sf object with polygons defining the barriers. For
example, a coastline dataset for ocean data. <strong>Note that this object must
have the same projection as the data used to generate the x and y columns
in <code>spde_obj</code>.</strong></p>
</td></tr>
<tr><td><code id="add_barrier_mesh_+3A_range_fraction">range_fraction</code></td>
<td>
<p>The fraction of the spatial range that barrier
triangles have.</p>
</td></tr>
<tr><td><code id="add_barrier_mesh_+3A_proj_scaling">proj_scaling</code></td>
<td>
<p>If <code>spde_obj</code> was created with scaling of the coordinates
after the projection (e.g., dividing UTMs by 1000 so the spatial range is
on a reasonable scale) the x and y values in <code>spde_obj</code> are multiplied by
this scaling factor before applying the projection from <code>barrier_sf</code>.</p>
</td></tr>
<tr><td><code id="add_barrier_mesh_+3A_plot">plot</code></td>
<td>
<p>Logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Deprecated. See the
<a href="https://github.com/pbs-assess/sdmTMBextra">sdmTMBextra</a> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
add_barrier_mesh()

## End(Not run)
</code></pre>

<hr>
<h2 id='add_utm_columns'>Add UTM coordinates to a data frame</h2><span id='topic+add_utm_columns'></span><span id='topic+get_crs'></span>

<h3>Description</h3>

<p>Add UTM (Universal Transverse Mercator) coordinates to a data frame. This is
useful since geostatistical modeling should generally be performed in an
equal-distance projection. You can do this yourself separately with the
<code><a href="sf.html#topic+st_as_sf">sf::st_as_sf()</a></code>, <code><a href="sf.html#topic+st_transform">sf::st_transform()</a></code>, and <code><a href="sf.html#topic+st_coordinates">sf::st_coordinates()</a></code> functions
in the <span class="pkg">sf</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_utm_columns(
  dat,
  ll_names = c("longitude", "latitude"),
  ll_crs = 4326,
  utm_names = c("X", "Y"),
  utm_crs = get_crs(dat, ll_names),
  units = c("km", "m")
)

get_crs(dat, ll_names = c("longitude", "latitude"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_utm_columns_+3A_dat">dat</code></td>
<td>
<p>Data frame that contains longitude and latitude columns.</p>
</td></tr>
<tr><td><code id="add_utm_columns_+3A_ll_names">ll_names</code></td>
<td>
<p>Longitude and latitude column names. <strong>Note the order.</strong></p>
</td></tr>
<tr><td><code id="add_utm_columns_+3A_ll_crs">ll_crs</code></td>
<td>
<p>Input CRS value for <code>ll_names</code>.</p>
</td></tr>
<tr><td><code id="add_utm_columns_+3A_utm_names">utm_names</code></td>
<td>
<p>Output column names for the UTM columns.</p>
</td></tr>
<tr><td><code id="add_utm_columns_+3A_utm_crs">utm_crs</code></td>
<td>
<p>Output CRS value for the UTM zone; tries to detect with
<code><a href="#topic+get_crs">get_crs()</a></code> but can be specified manually.</p>
</td></tr>
<tr><td><code id="add_utm_columns_+3A_units">units</code></td>
<td>
<p>UTM units.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Note that longitudes west of the prime meridian should be encoded
as running from -180 to 0 degrees.</strong>
</p>
<p>You may wish to work in km's rather than the standard UTM meters so that the
range parameter estimate is not too small, which can cause computational
issues. This depends on the the scale of your data.
</p>


<h3>Value</h3>

<p>A copy of the input data frame with new columns for UTM coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- data.frame(lat = c(52.1, 53.4), lon = c(-130.0, -131.4))
get_crs(d, c("lon", "lat"))
add_utm_columns(d, c("lon", "lat"))

</code></pre>

<hr>
<h2 id='dharma_residuals'>DHARMa residuals</h2><span id='topic+dharma_residuals'></span>

<h3>Description</h3>

<p>Plot (and possibly return) DHARMa residuals. This is a wrapper function
around <code><a href="DHARMa.html#topic+createDHARMa">DHARMa::createDHARMa()</a></code> to facilitate its use with <code><a href="#topic+sdmTMB">sdmTMB()</a></code> models.
<strong>Note:</strong> It is recommended to set <code>type = "mle-mvn"</code> in
<code><a href="#topic+simulate.sdmTMB">simulate.sdmTMB()</a></code> for the resulting residuals to have the
expected distribution. This is <em>not</em> the default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dharma_residuals(
  simulated_response,
  object,
  plot = TRUE,
  return_DHARMa = FALSE,
  expected_distribution = c("uniform", "normal"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dharma_residuals_+3A_simulated_response">simulated_response</code></td>
<td>
<p>Output from <code><a href="#topic+simulate.sdmTMB">simulate.sdmTMB()</a></code>. It is recommended
to set <code>type = "mle-mvn"</code> in the call to <code><a href="#topic+simulate.sdmTMB">simulate.sdmTMB()</a></code> for the
residuals to have the expected distribution.</p>
</td></tr>
<tr><td><code id="dharma_residuals_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+sdmTMB">sdmTMB()</a></code>.</p>
</td></tr>
<tr><td><code id="dharma_residuals_+3A_plot">plot</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="dharma_residuals_+3A_return_dharma">return_DHARMa</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="dharma_residuals_+3A_expected_distribution">expected_distribution</code></td>
<td>
<p>Experimental: expected distribution for
comparison: uniform(0, 1) or normal(0, 1). Traditional <span class="pkg">DHARMa</span>
residuals are uniform. If <code>"normal"</code>, a <code>pnorm()</code> transformation is applied.
First, any simulated quantiles of 0 (no simulations were smaller than the
observation) are set to an arbitrary value of <code>1/(n*10)</code> where <code>n</code> is the
number of simulated replicated. Any simulated quantiles of 1 (no
simulations were larger than the observation) are set to an arbitrary value
of <code>1 - 1/(n*10)</code>. These points are shown with crosses overlaid.</p>
</td></tr>
<tr><td><code id="dharma_residuals_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="DHARMa.html#topic+createDHARMa">DHARMa::createDHARMa()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Advantages to these residuals over the ones from the <code><a href="#topic+residuals.sdmTMB">residuals.sdmTMB()</a></code>
method are (1) they work with delta/hurdle models for the combined
predictions, not the just the two parts separately, (2) they should work for
all families, not the just the families where we have worked out the
analytical quantile function, and (3) they can be used with the various
diagnostic tools and plots from the <span class="pkg">DHARMa</span> package.
</p>
<p>Disadvantages are (1) they are slower to calculate since one must first
simulate from the model, (2) the stability of the distribution of the
residuals depends on having a sufficient number of simulation draws, (3)
uniformly distributed residuals put less emphasis on the tails visually
(which or may not be desired).
</p>
<p>Note that <span class="pkg">DHARMa</span> returns residuals that are uniform(0, 1) if the data
are consistent with the model whereas any randomized quantile residuals from
<code><a href="#topic+residuals.sdmTMB">residuals.sdmTMB()</a></code> are expected to be normal(0, 1). An experimental option
<code>expected_distribution</code> is included to transform the distributions to
a normal(0, 1) expectation.
</p>


<h3>Value</h3>

<p>A data frame of observed and expected values is invisibly returned,
so you can set <code>plot = FALSE</code> and assign the output to an object if you wish
to plot the residuals yourself. See the examples.
</p>
<p>If <code>return_DHARMa = TRUE</code>, the object from <code>DHARMa::createDHARMa()</code>
is returned and any subsequent <span class="pkg">DHARMa</span> functions can be applied.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.sdmTMB">simulate.sdmTMB()</a></code>, <code><a href="#topic+residuals.sdmTMB">residuals.sdmTMB()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Try Tweedie family:
fit &lt;- sdmTMB(density ~ as.factor(year) + s(depth, k = 3),
  data = pcod_2011, mesh = pcod_mesh_2011,
  family = tweedie(link = "log"), spatial = "on")

# The `simulated_response` argument is first so the output from
# simulate() can be piped to dharma_residuals().

# We will work with 100 simulations for fast examples, but you'll
# likely want to work with more than this (enough that the results
# are stable from run to run).

# not great:
set.seed(123)
simulate(fit, nsim = 100, type = "mle-mvn") |&gt;
  dharma_residuals(fit)


# delta-lognormal looks better:
set.seed(123)
fit_dl &lt;- update(fit, family = delta_lognormal())
simulate(fit_dl, nsim = 100, type = "mle-mvn") |&gt;
  dharma_residuals(fit)

# or skip the pipe:
set.seed(123)
s &lt;- simulate(fit_dl, nsim = 100, type = "mle-mvn")
# and manually plot it:
r &lt;- dharma_residuals(s, fit_dl, plot = FALSE)
head(r)
plot(r$expected, r$observed)
abline(0, 1)

# return the DHARMa object and work with the DHARMa methods
ret &lt;- simulate(fit_dl, nsim = 100, type = "mle-mvn") |&gt;
  dharma_residuals(fit, return_DHARMa = TRUE)
plot(ret)

# try normal(0, 1) residuals:
s &lt;- simulate(fit_dl, nsim = 100, type = "mle-mvn")
dharma_residuals(s, fit, expected_distribution = "normal")
# note the points in the top right corner that had Inf quantiles
# because of pnorm(1)

# work with the residuals themselves:
r &lt;- dharma_residuals(s, fit, return_DHARMa = TRUE)
plot(fitted(fit), r$scaledResiduals)


</code></pre>

<hr>
<h2 id='Effect.sdmTMB'>Calculate effects</h2><span id='topic+Effect.sdmTMB'></span>

<h3>Description</h3>

<p>Used by effects package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Effect.sdmTMB(focal.predictors, mod, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Effect.sdmTMB_+3A_focal.predictors">focal.predictors</code></td>
<td>
<p>a character vector of one or more predictors in the model in any order.</p>
</td></tr>
<tr><td><code id="Effect.sdmTMB_+3A_mod">mod</code></td>
<td>
<p>a regression model object.  If no specific method exists for the class of <code>mod</code>, <code>Effect.default</code> will be called.</p>
</td></tr>
<tr><td><code id="Effect.sdmTMB_+3A_...">...</code></td>
<td>
<p>arguments to be passed down.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output from <code><a href="effects.html#topic+effect">effects::effect()</a></code>. Can then be plotted with with associated
<code>plot()</code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fit &lt;- sdmTMB(present ~ depth_scaled, data = pcod_2011, family = binomial(),
  spatial = "off")
effects::effect("depth_scaled", fit)
plot(effects::effect("depth_scaled", fit))

</code></pre>

<hr>
<h2 id='emmeans.sdmTMB'>Estimated marginal means with the <span class="pkg">emmeans</span> package with <span class="pkg">sdmTMB</span></h2><span id='topic+emmeans.sdmTMB'></span>

<h3>Description</h3>

<p>Methods for using the <span class="pkg">emmeans</span> package with <span class="pkg">sdmTMB</span>. The
<span class="pkg">emmeans</span> package computes estimated marginal means for the fixed
effects.
</p>


<h3>References</h3>

<p><a href="https://aosmith.rbind.io/2019/03/25/getting-started-with-emmeans/">https://aosmith.rbind.io/2019/03/25/getting-started-with-emmeans/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mesh &lt;- make_mesh(pcod_2011, c("X", "Y"), cutoff = 20)
fit &lt;- sdmTMB(
  present ~ as.factor(year),
  data = pcod_2011, mesh = mesh,
  family = binomial()
)
fit
emmeans::emmeans(fit, ~ year)
emmeans::emmeans(fit, pairwise ~ year)
emmeans::emmeans(fit, pairwise ~ year, type = "response")
emmeans::emmeans(fit, pairwise ~ year, adjust = "none")

e &lt;- emmeans::emmeans(fit, ~ year)
plot(e)

e &lt;- emmeans::emmeans(fit, pairwise ~ year)
confint(e)
summary(e, infer = TRUE)
as.data.frame(e)

# interaction of factor with continuous predictor:
fit2 &lt;- sdmTMB(
  present ~ depth_scaled * as.factor(year),
  data = pcod_2011, mesh = mesh,
  family = binomial()
)
fit2
# slopes for each level:
emmeans::emtrends(fit2, ~ year, var = "depth_scaled")
# test difference in slopes:
emmeans::emtrends(fit2, pairwise ~ year, var = "depth_scaled")
emmeans::emmip(fit2, year ~ depth_scaled,
  at = list(depth_scaled = seq(-2.5, 2.5, length.out = 50)), CIs = TRUE)

</code></pre>

<hr>
<h2 id='extract_mcmc'>Extract MCMC samples from a model fit with <span class="pkg">tmbstan</span>.</h2><span id='topic+extract_mcmc'></span>

<h3>Description</h3>

<p>Moved to the <a href="https://github.com/pbs-assess/sdmTMBextra">sdmTMBextra</a>
package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_mcmc(object = deprecated())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_mcmc_+3A_object">object</code></td>
<td>
<p><strong>Deprecated</strong> See the <a href="https://github.com/pbs-assess/sdmTMBextra">sdmTMBextra</a> package. Make sure to load <span class="pkg">sdmTMBextra</span> <em>after</em> <span class="pkg">sdmTMB</span>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Deprecated. See the
<a href="https://github.com/pbs-assess/sdmTMBextra">sdmTMBextra</a> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
extract_mcmc()

## End(Not run)
</code></pre>

<hr>
<h2 id='Families'>Additional families</h2><span id='topic+Families'></span><span id='topic+Beta'></span><span id='topic+lognormal'></span><span id='topic+gengamma'></span><span id='topic+gamma_mix'></span><span id='topic+lognormal_mix'></span><span id='topic+nbinom2_mix'></span><span id='topic+nbinom2'></span><span id='topic+nbinom1'></span><span id='topic+truncated_nbinom2'></span><span id='topic+truncated_nbinom1'></span><span id='topic+student'></span><span id='topic+tweedie'></span><span id='topic+censored_poisson'></span><span id='topic+delta_gamma'></span><span id='topic+delta_gamma_mix'></span><span id='topic+delta_gengamma'></span><span id='topic+delta_lognormal'></span><span id='topic+delta_lognormal_mix'></span><span id='topic+delta_truncated_nbinom2'></span><span id='topic+delta_truncated_nbinom1'></span><span id='topic+delta_poisson_link_gamma'></span><span id='topic+delta_poisson_link_lognormal'></span><span id='topic+delta_beta'></span>

<h3>Description</h3>

<p>Additional families compatible with <code><a href="#topic+sdmTMB">sdmTMB()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Beta(link = "logit")

lognormal(link = "log")

gengamma(link = "log")

gamma_mix(link = "log")

lognormal_mix(link = "log")

nbinom2_mix(link = "log")

nbinom2(link = "log")

nbinom1(link = "log")

truncated_nbinom2(link = "log")

truncated_nbinom1(link = "log")

student(link = "identity", df = 3)

tweedie(link = "log")

censored_poisson(link = "log")

delta_gamma(link1, link2 = "log", type = c("standard", "poisson-link"))

delta_gamma_mix(link1 = "logit", link2 = "log")

delta_gengamma(link1, link2 = "log", type = c("standard", "poisson-link"))

delta_lognormal(link1, link2 = "log", type = c("standard", "poisson-link"))

delta_lognormal_mix(link1 = "logit", link2 = "log")

delta_truncated_nbinom2(link1 = "logit", link2 = "log")

delta_truncated_nbinom1(link1 = "logit", link2 = "log")

delta_poisson_link_gamma(link1 = "log", link2 = "log")

delta_poisson_link_lognormal(link1 = "log", link2 = "log")

delta_beta(link1 = "logit", link2 = "logit")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Families_+3A_link">link</code></td>
<td>
<p>Link.</p>
</td></tr>
<tr><td><code id="Families_+3A_df">df</code></td>
<td>
<p>Student-t degrees of freedom fixed value parameter.</p>
</td></tr>
<tr><td><code id="Families_+3A_link1">link1</code></td>
<td>
<p>Link for first part of delta/hurdle model. Defaults to <code>"logit"</code>
for <code>type = "standard"</code> and <code>"log"</code> for <code>type = "poisson-link"</code>.</p>
</td></tr>
<tr><td><code id="Families_+3A_link2">link2</code></td>
<td>
<p>Link for second part of delta/hurdle model.</p>
</td></tr>
<tr><td><code id="Families_+3A_type">type</code></td>
<td>
<p>Delta/hurdle family type. <code>"standard"</code> for a classic hurdle
model. <code>"poisson-link"</code> for a Poisson-link delta model (Thorson 2018).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>delta_poisson_link_gamma()</code> and <code>delta_poisson_link_lognormal()</code> have been
deprecated in favour of <code>delta_gamma(type = "poisson-link")</code> and
<code>delta_lognormal(type = "poisson-link")</code>.
</p>
<p>The <code>gengamma()</code> family was implemented by J.T. Thorson and uses the Prentice
(1974) parameterization such that the lognormal occurs as the internal
parameter <code>gengamma_Q</code> (reported in <code>print()</code> as &quot;Generalized gamma lambda&quot;)
approaches 0.
</p>
<p>The families ending in <code style="white-space: pre;">&#8288;_mix()&#8288;</code> are 2-component mixtures where each
distribution has its own mean but a shared scale parameter.
(Thorson et al. 2011). See the model-description vignette for details.
The parameter <code>plogis(log_p_mix)</code> is the probability of the extreme (larger)
mean and <code>exp(log_ratio_mix) + 1</code> is the ratio of the larger extreme
mean to the &quot;regular&quot; mean. You can see these parameters in
<code>model$sd_report</code>.
</p>
<p>The <code>nbinom2</code> negative binomial parameterization is the NB2 where the
variance grows quadratically with the mean (Hilbe 2011).
</p>
<p>The <code>nbinom1</code> negative binomial parameterization lets the variance grow
linearly with the mean (Hilbe 2011).
</p>
<p>For <code>student()</code>, the degrees of freedom parameter is currently not estimated and is fixed at <code>df</code>.
</p>


<h3>Value</h3>

<p>A list with elements common to standard R family objects including <code>family</code>,
<code>link</code>, <code>linkfun</code>, and <code>linkinv</code>. Delta/hurdle model families also have
elements <code>delta</code> (logical) and <code>type</code> (standard vs. Poisson-link).
</p>


<h3>References</h3>

<p><em>Generalized gamma family</em>:
</p>
<p>Prentice, R.L. 1974. A log gamma model and its maximum likelihood estimation.
Biometrika 61(3): 539–544. <a href="https://doi.org/10.1093/biomet/61.3.539">doi:10.1093/biomet/61.3.539</a>
</p>
<p>Stacy, E.W. 1962. A Generalization of the Gamma Distribution. The Annals of
Mathematical Statistics 33(3): 1187–1192. Institute of Mathematical
Statistics.
</p>
<p><em>Families ending in <code style="white-space: pre;">&#8288;_mix()&#8288;</code></em>:
</p>
<p>Thorson, J.T., Stewart, I.J., and Punt, A.E. 2011. Accounting for fish shoals
in single- and multi-species survey data using mixture distribution models.
Can. J. Fish. Aquat. Sci. 68(9): 1681–1693. <a href="https://doi.org/10.1139/f2011-086">doi:10.1139/f2011-086</a>.
</p>
<p><em>Negative binomial families</em>:
</p>
<p>Hilbe, J. M. 2011. Negative binomial regression. Cambridge University Press.
</p>
<p><em>Poisson-link delta families</em>:
</p>
<p>Thorson, J.T. 2018. Three problems with the conventional delta-model for
biomass sampling data, and a computationally efficient alternative. Canadian
Journal of Fisheries and Aquatic Sciences, 75(9), 1369-1382.
<a href="https://doi.org/10.1139/cjfas-2017-0266">doi:10.1139/cjfas-2017-0266</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Beta(link = "logit")
lognormal(link = "log")
gengamma(link = "log")
gamma_mix(link = "log")
lognormal_mix(link = "log")
nbinom2_mix(link = "log")
nbinom2(link = "log")
nbinom1(link = "log")
truncated_nbinom2(link = "log")
truncated_nbinom1(link = "log")
student(link = "identity")
tweedie(link = "log")
censored_poisson(link = "log")
delta_gamma()
delta_gamma_mix()
delta_gengamma()
delta_lognormal()
delta_lognormal_mix()
delta_truncated_nbinom2()
delta_truncated_nbinom1()
delta_beta()
</code></pre>

<hr>
<h2 id='get_index'>Extract a relative biomass/abundance index or a center of gravity</h2><span id='topic+get_index'></span><span id='topic+get_cog'></span>

<h3>Description</h3>

<p>Extract a relative biomass/abundance index or a center of gravity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_index(
  obj,
  bias_correct = FALSE,
  level = 0.95,
  area = 1,
  silent = TRUE,
  ...
)

get_cog(
  obj,
  bias_correct = FALSE,
  level = 0.95,
  format = c("long", "wide"),
  area = 1,
  silent = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_index_+3A_obj">obj</code></td>
<td>
<p>Output from <code><a href="#topic+predict.sdmTMB">predict.sdmTMB()</a></code> with <code>return_tmb_object = TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_index_+3A_bias_correct">bias_correct</code></td>
<td>
<p>Should bias correction be implemented <code><a href="TMB.html#topic+sdreport">TMB::sdreport()</a></code>?</p>
</td></tr>
<tr><td><code id="get_index_+3A_level">level</code></td>
<td>
<p>The confidence level.</p>
</td></tr>
<tr><td><code id="get_index_+3A_area">area</code></td>
<td>
<p>Grid cell area. A vector of length <code>newdata</code> from
<code><a href="#topic+predict.sdmTMB">predict.sdmTMB()</a></code> or a value of length 1, which will be repeated
internally to match.</p>
</td></tr>
<tr><td><code id="get_index_+3A_silent">silent</code></td>
<td>
<p>Silent?</p>
</td></tr>
<tr><td><code id="get_index_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="TMB.html#topic+sdreport">TMB::sdreport()</a></code>.</p>
</td></tr>
<tr><td><code id="get_index_+3A_format">format</code></td>
<td>
<p>Long or wide.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>get_index()</code>:
A data frame with a columns for time, estimate, lower and upper
confidence intervals, log estimate, and standard error of the log estimate.
</p>
<p>For <code>get_cog()</code>:
A data frame with a columns for time, estimate (center of gravity in x and y
coordinates), lower and upper confidence intervals, and standard error of
center of gravity coordinates.
</p>


<h3>References</h3>

<p>Geostatistical random-field model-based indices of abundance
(along with many newer papers):
</p>
<p>Shelton, A.O., Thorson, J.T., Ward, E.J., and Feist, B.E. 2014. Spatial
semiparametric models improve estimates of species abundance and
distribution. Canadian Journal of Fisheries and Aquatic Sciences 71(11):
1655&ndash;1666. <a href="https://doi.org/10.1139/cjfas-2013-0508">doi:10.1139/cjfas-2013-0508</a>
</p>
<p>Thorson, J.T., Shelton, A.O., Ward, E.J., and Skaug, H.J. 2015.
Geostatistical delta-generalized linear mixed models improve precision for
estimated abundance indices for West Coast groundfishes. ICES J. Mar. Sci.
72(5): 1297–1310. <a href="https://doi.org/10.1093/icesjms/fsu243">doi:10.1093/icesjms/fsu243</a>
</p>
<p>Geostatistical model-based centre of gravity:
</p>
<p>Thorson, J.T., Pinsky, M.L., and Ward, E.J. 2016. Model-based inference for
estimating shifts in species distribution, area occupied and centre of
gravity. Methods Ecol Evol 7(8): 990–1002. <a href="https://doi.org/10.1111/2041-210X.12567">doi:10.1111/2041-210X.12567</a>
</p>
<p>Bias correction:
</p>
<p>Thorson, J.T., and Kristensen, K. 2016. Implementing a generic method for
bias correction in statistical models using random effects, with spatial and
population dynamics examples. Fisheries Research 175: 66–74.
<a href="https://doi.org/10.1016/j.fishres.2015.11.016">doi:10.1016/j.fishres.2015.11.016</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_index_sims">get_index_sims()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Use a small number of knots for this example to make it fast:
pcod_spde &lt;- make_mesh(pcod, c("X", "Y"), n_knots = 60, type = "kmeans")
m &lt;- sdmTMB(
 data = pcod,
 formula = density ~ 0 + as.factor(year),
 time = "year", mesh = pcod_spde, family = tweedie(link = "log")
)

# make prediction grid:
nd &lt;- replicate_df(qcs_grid, "year", unique(pcod$year))

# Note `return_tmb_object = TRUE` and the prediction grid:
predictions &lt;- predict(m, newdata = nd, return_tmb_object = TRUE)
ind &lt;- get_index(predictions)

if (require("ggplot2", quietly = TRUE)) {
ggplot(ind, aes(year, est)) + geom_line() +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.4)
}

cog &lt;- get_cog(predictions)
cog


</code></pre>

<hr>
<h2 id='get_index_sims'>Calculate a population index via simulation from the joint precision matrix</h2><span id='topic+get_index_sims'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Calculate a population index via simulation from the joint precision matrix.
Compared to <code><a href="#topic+get_index">get_index()</a></code>, this version can be faster if bias correction was
turned on in <code><a href="#topic+get_index">get_index()</a></code> while being approximately equivalent. <strong>This is an
experimental function.</strong> This function usually works reasonably well, but we
make no guarantees. It is recommended to use <code><a href="#topic+get_index">get_index()</a></code> with <code>bias_correct = TRUE</code> for final inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_index_sims(
  obj,
  level = 0.95,
  return_sims = FALSE,
  area = rep(1, nrow(obj)),
  est_function = stats::median,
  area_function = function(x, area) x + log(area),
  agg_function = function(x) sum(exp(x))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_index_sims_+3A_obj">obj</code></td>
<td>
<p><code><a href="#topic+predict.sdmTMB">predict.sdmTMB()</a></code> output with <code>nsim &gt; 0</code>.</p>
</td></tr>
<tr><td><code id="get_index_sims_+3A_level">level</code></td>
<td>
<p>The confidence level.</p>
</td></tr>
<tr><td><code id="get_index_sims_+3A_return_sims">return_sims</code></td>
<td>
<p>Logical. Return simulation draws? The default (<code>FALSE</code>) is
a quantile summary of those simulation draws.</p>
</td></tr>
<tr><td><code id="get_index_sims_+3A_area">area</code></td>
<td>
<p>A vector of grid cell/polyon areas for each year-grid cell (row
of data) in <code>obj</code>. Adjust this if cells are not of unit area or not all
the same area (e.g., some cells are partially over land/water). Note that
the area vector is added as <code>log(area)</code> to the raw values in <code>obj</code>. In
other words, the function assumes a log link, which typically makes sense.</p>
</td></tr>
<tr><td><code id="get_index_sims_+3A_est_function">est_function</code></td>
<td>
<p>Function to summarize the estimate (the expected value).
<code>mean()</code> would be an alternative to <code>median()</code>.</p>
</td></tr>
<tr><td><code id="get_index_sims_+3A_area_function">area_function</code></td>
<td>
<p>Function to apply area weighting.
Assuming a log link, the <code>function(x, area) x + log(area)</code> default makes sense.
If in natural space, <code>function(x, area) x * area</code> makes sense.</p>
</td></tr>
<tr><td><code id="get_index_sims_+3A_agg_function">agg_function</code></td>
<td>
<p>Function to aggregate samples within each time slice.
Assuming a log link, the <code>function(x) sum(exp(x))</code> default makes sense.
If in natural space, <code>function(x) sum(x)</code> makes sense.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can also be used to produce an index from a model fit with
<span class="pkg">tmbstan</span>.
</p>
<p>This function does nothing more than summarize and reshape the
matrix of simulation draws into a data frame.
</p>


<h3>Value</h3>

<p>A data frame. If <code>return_sims = FALSE</code>:
</p>

<ul>
<li><p> name of column (e.g. <code>year</code>) that was supplied to <code><a href="#topic+sdmTMB">sdmTMB()</a></code> time argument
</p>
</li>
<li> <p><code>est</code>: estimate
</p>
</li>
<li> <p><code>lwr</code>: lower confidence interval value
</p>
</li>
<li> <p><code>upr</code>: upper confidence interval value
</p>
</li>
<li> <p><code>log_est</code>: log estimate
</p>
</li>
<li> <p><code>se</code>: standard error on the log estimate
</p>
</li></ul>

<p>If <code>return_sims = TRUE</code>, samples from the index values in a long-format data frame:
</p>

<ul>
<li><p> name of column (e.g. <code>year</code>) that was supplied to <code><a href="#topic+sdmTMB">sdmTMB()</a></code> time argument
</p>
</li>
<li> <p><code>.value</code>: sample value
</p>
</li>
<li> <p><code>.iteration</code>: sample number
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+get_index">get_index()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- sdmTMB(density ~ 0 + as.factor(year),
  data = pcod_2011, mesh = pcod_mesh_2011, family = tweedie(link = "log"),
  time = "year"
)
qcs_grid_2011 &lt;- replicate_df(qcs_grid, "year", unique(pcod_2011$year))
p &lt;- predict(m, newdata = qcs_grid_2011, nsim = 100)
x &lt;- get_index_sims(p)
x_sims &lt;- get_index_sims(p, return_sims = TRUE)

if (require("ggplot2", quietly = TRUE)) {
  ggplot(x, aes(year, est, ymin = lwr, ymax = upr)) +
    geom_line() +
    geom_ribbon(alpha = 0.4)
  ggplot(x_sims, aes(as.factor(year), .value)) +
    geom_violin()
}

# Demo custom functions if working in natural space:
ind &lt;- get_index_sims(
  exp(p),
  agg_function = function(x) sum(x),
  area_function = function(x, area) x * area
)

</code></pre>

<hr>
<h2 id='get_pars'>Get TMB parameter list</h2><span id='topic+get_pars'></span>

<h3>Description</h3>

<p>Get TMB parameter list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pars(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pars_+3A_object">object</code></td>
<td>
<p>Fit from <code><a href="#topic+sdmTMB">sdmTMB()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of parameter values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- sdmTMB(present ~ 1, data = pcod_2011, family = binomial(), spatial = "off")
pars &lt;- get_pars(fit)
names(pars)
</code></pre>

<hr>
<h2 id='ggplot2_installed'>Check if ggplot2 installed</h2><span id='topic+ggplot2_installed'></span>

<h3>Description</h3>

<p>Check if ggplot2 installed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplot2_installed()
</code></pre>


<h3>Value</h3>

<p>Returns <code>TRUE</code> or <code>FALSE</code>.
</p>

<hr>
<h2 id='make_mesh'>Construct an SPDE mesh for sdmTMB</h2><span id='topic+make_mesh'></span><span id='topic+plot.sdmTMBmesh'></span>

<h3>Description</h3>

<p>Construct an SPDE mesh for use with sdmTMB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_mesh(
  data,
  xy_cols,
  type = c("kmeans", "cutoff", "cutoff_search"),
  cutoff,
  n_knots,
  seed = 42,
  mesh = NULL,
  fmesher_func = fmesher::fm_rcdt_2d_inla,
  convex = NULL,
  concave = convex,
  ...
)

## S3 method for class 'sdmTMBmesh'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_mesh_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="make_mesh_+3A_xy_cols">xy_cols</code></td>
<td>
<p>A character vector of x and y column names contained in
<code>data</code>. These should likely be in an equal distance projection. For
a helper function to convert to UTMs, see <code><a href="#topic+add_utm_columns">add_utm_columns()</a></code>.</p>
</td></tr>
<tr><td><code id="make_mesh_+3A_type">type</code></td>
<td>
<p>Method to create the mesh. Also see <code>mesh</code> argument to supply
your own mesh.</p>
</td></tr>
<tr><td><code id="make_mesh_+3A_cutoff">cutoff</code></td>
<td>
<p>An optional cutoff if type is <code>"cutoff"</code>. The minimum allowed
triangle edge length.</p>
</td></tr>
<tr><td><code id="make_mesh_+3A_n_knots">n_knots</code></td>
<td>
<p>The number of desired knots if <code>type</code> is not <code>"cutoff"</code>.</p>
</td></tr>
<tr><td><code id="make_mesh_+3A_seed">seed</code></td>
<td>
<p>Random seed. Affects <code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code> determination of knot
locations if <code>type = "kmeans"</code>.</p>
</td></tr>
<tr><td><code id="make_mesh_+3A_mesh">mesh</code></td>
<td>
<p>An optional mesh created via <span class="pkg">fmesher</span> instead of using the above
convenience options.</p>
</td></tr>
<tr><td><code id="make_mesh_+3A_fmesher_func">fmesher_func</code></td>
<td>
<p>Which <span class="pkg">fmesher</span> function to use. Options include
<code><a href="fmesher.html#topic+fm_rcdt_2d">fmesher::fm_rcdt_2d_inla()</a></code> and <code><a href="fmesher.html#topic+fm_mesh_2d">fmesher::fm_mesh_2d_inla()</a></code> along with
version without the <code style="white-space: pre;">&#8288;_inla&#8288;</code> on the end.</p>
</td></tr>
<tr><td><code id="make_mesh_+3A_convex">convex</code></td>
<td>
<p>If specified, passed to <code><a href="fmesher.html#topic+fm_nonconvex_hull">fmesher::fm_nonconvex_hull()</a></code>.
Distance to extend non-convex hull from data.</p>
</td></tr>
<tr><td><code id="make_mesh_+3A_concave">concave</code></td>
<td>
<p>If specified, passed to <code><a href="fmesher.html#topic+fm_nonconvex_hull">fmesher::fm_nonconvex_hull()</a></code>.
&quot;Minimum allowed reentrant curvature&quot;. Defaults to <code>convex</code>.</p>
</td></tr>
<tr><td><code id="make_mesh_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code>.</p>
</td></tr>
<tr><td><code id="make_mesh_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+make_mesh">make_mesh()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>make_mesh()</code>: A list of class <code>sdmTMBmesh</code>. The element <code>mesh</code> is the output
from <code>fmesher_func</code> (default is <code><a href="fmesher.html#topic+fm_mesh_2d">fmesher::fm_mesh_2d_inla()</a></code>). See
<code>mesh$mesh$n</code> for the number of vertices.
</p>
<p><code>plot.sdmTMBmesh()</code>: A plot of the mesh and data points. If
<span class="pkg">ggplot2</span> is installed, a <span class="pkg">ggplot2</span> object is
returned, otherwise a base graphics R plot is returned. To make your own,
pass <code>your_mesh$mesh</code> to <code>inlabru::gg()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Extremely simple cutoff:
mesh &lt;- make_mesh(pcod, c("X", "Y"), cutoff = 5, type = "cutoff")
plot(mesh)

# Using a k-means algorithm to assign vertices:
mesh &lt;- make_mesh(pcod, c("X", "Y"), n_knots = 50, type = "kmeans")
plot(mesh)


# But, it's better to develop more tailored meshes:

# Pass arguments via '...' to fmesher::fm_mesh_2d_inla():
mesh &lt;- make_mesh(
  pcod, c("X", "Y"),
  fmesher_func = fmesher::fm_mesh_2d_inla,
  cutoff = 8, # minimum triangle edge length
  max.edge = c(20, 40), # inner and outer max triangle lengths
  offset = c(5, 40) # inner and outer border widths
)
plot(mesh)

# Or define a mesh directly with fmesher (formerly in INLA):
inla_mesh &lt;- fmesher::fm_mesh_2d_inla(
  loc = cbind(pcod$X, pcod$Y), # coordinates
  max.edge = c(25, 50), # max triangle edge length; inner and outer meshes
  offset = c(5, 25),  # inner and outer border widths
  cutoff = 5 # minimum triangle edge length
)
mesh &lt;- make_mesh(pcod, c("X", "Y"), mesh = inla_mesh)
plot(mesh)

</code></pre>

<hr>
<h2 id='pcod'>Example fish survey data</h2><span id='topic+pcod'></span><span id='topic+pcod_2011'></span><span id='topic+pcod_mesh_2011'></span><span id='topic+qcs_grid'></span><span id='topic+dogfish'></span><span id='topic+yelloweye'></span><span id='topic+hbll_s_grid'></span><span id='topic+wcvi_grid'></span>

<h3>Description</h3>

<p>Various fish survey datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcod

pcod_2011

pcod_mesh_2011

qcs_grid

dogfish

yelloweye

hbll_s_grid

wcvi_grid
</code></pre>


<h3>Format</h3>

<p><code>pcod</code>: Trawl survey data for Pacific Cod in Queen Charlotte Sound. A
data frame.
</p>
<p><code>pcod_2011</code>: A version of <code>pcod</code> for years 2011 and after (smaller
for speed). A data frame.
</p>
<p><code>pcod_mesh_2011</code>: A mesh pre-built for <code>pcod_2011</code> for examples. A
list of class <code>sdmTMBmesh</code>.
</p>
<p><code>qcs_grid</code> A 2x2km prediction grid for Queen Charlotte Sound. A data
frame.
</p>
<p><code>dogfish</code>: Trawl survey data for Pacific Spiny Dogfish on West Coast
Vancouver Island. A data frame.
</p>
<p><code>yelloweye</code>: Survey data for Yelloweye Rockfish from the Hard Bottom
Longline Survey (South) off West Coast Vancouver Island.
</p>
<p><code>hbll_s_grid</code>: A survey domain grid to go with <code>yelloweye</code>. A data frame.
</p>
<p><code>wcvi_grid</code>: A survey domain grid to go with <code>dogfish</code>. A data frame.
</p>

<hr>
<h2 id='plot_anisotropy'>Plot anisotropy from an sdmTMB model</h2><span id='topic+plot_anisotropy'></span><span id='topic+plot_anisotropy2'></span>

<h3>Description</h3>

<p>Anisotropy is when spatial correlation is directionally dependent. In
<code><a href="#topic+sdmTMB">sdmTMB()</a></code>, the default spatial correlation is isotropic, but anisotropy can
be enabled with <code>anisotropy = TRUE</code>. These plotting functions help visualize
that estimated anisotropy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_anisotropy(object, return_data = FALSE)

plot_anisotropy2(object, model = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_anisotropy_+3A_object">object</code></td>
<td>
<p>An object from <code><a href="#topic+sdmTMB">sdmTMB()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_anisotropy_+3A_return_data">return_data</code></td>
<td>
<p>Logical. Return a data frame? <code>plot_anisotropy()</code> only.</p>
</td></tr>
<tr><td><code id="plot_anisotropy_+3A_model">model</code></td>
<td>
<p>Which model if a delta model (only for <code>plot_anisotropy2()</code>;
<code>plot_anisotropy()</code> always plots both).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plot_anisotropy()</code>: One or more ellipses illustrating the estimated
anisotropy. The ellipses are centered at coordinates of zero in the space of
the X-Y coordinates being modeled. The ellipses show the spatial and/or
spatiotemporal range (distance at which correlation is effectively
independent) in any direction from zero. Uses <span class="pkg">ggplot2</span>. If anisotropy
was turned off when fitting the model, <code>NULL</code> is returned instead of a
<span class="pkg">ggplot2</span> object.
</p>
<p><code>plot_anisotropy2()</code>: A plot of eigenvectors illustrating the estimated
anisotropy. A list of the plotted data is invisibly returned. Uses base
graphics. If anisotropy was turned off when fitting the model, <code>NULL</code> is
returned instead of a plot object.
</p>


<h3>References</h3>

<p>Code adapted from VAST R package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mesh &lt;- make_mesh(pcod_2011, c("X", "Y"), n_knots = 80, type = "kmeans")
fit &lt;- sdmTMB(
  data = pcod_2011,
  formula = density ~ 1,
  mesh = mesh,
  family = tweedie(),
  share_range = FALSE,
  time = "year",
  anisotropy = TRUE #&lt;
)
plot_anisotropy(fit)
plot_anisotropy2(fit)

</code></pre>

<hr>
<h2 id='plot_pc_matern'>Plot PC Matérn priors</h2><span id='topic+plot_pc_matern'></span>

<h3>Description</h3>

<p>Plot PC Matérn priors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pc_matern(
  range_gt,
  sigma_lt,
  range_prob = 0.05,
  sigma_prob = 0.05,
  range_lims = c(range_gt * 0.1, range_gt * 10),
  sigma_lims = c(0, sigma_lt * 2),
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_pc_matern_+3A_range_gt">range_gt</code></td>
<td>
<p>A value one expects the spatial or spatiotemporal range is
<strong>g</strong>reater <strong>t</strong>han with <code>1 - range_prob</code> probability.</p>
</td></tr>
<tr><td><code id="plot_pc_matern_+3A_sigma_lt">sigma_lt</code></td>
<td>
<p>A value one expects the spatial or spatiotemporal marginal
standard deviation (<code>sigma_O</code> or <code>sigma_E</code> internally) is <strong>l</strong>ess <strong>t</strong>han
with <code>1 - sigma_prob</code> probability.</p>
</td></tr>
<tr><td><code id="plot_pc_matern_+3A_range_prob">range_prob</code></td>
<td>
<p>Probability. See description for <code>range_gt</code>.</p>
</td></tr>
<tr><td><code id="plot_pc_matern_+3A_sigma_prob">sigma_prob</code></td>
<td>
<p>Probability. See description for <code>sigma_lt</code>.</p>
</td></tr>
<tr><td><code id="plot_pc_matern_+3A_range_lims">range_lims</code></td>
<td>
<p>Plot range variable limits.</p>
</td></tr>
<tr><td><code id="plot_pc_matern_+3A_sigma_lims">sigma_lims</code></td>
<td>
<p>Plot sigma variable limits.</p>
</td></tr>
<tr><td><code id="plot_pc_matern_+3A_plot">plot</code></td>
<td>
<p>Logical controlling whether plot is drawn (defaults to <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot from <code><a href="Matrix.html#topic+image">image()</a></code>.
Invisibly returns the underlying matrix data. The rows are the sigmas. The
columns are the ranges. Column and row names are provided.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pc_matern">pc_matern()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot_pc_matern(range_gt = 5, sigma_lt = 1)
plot_pc_matern(range_gt = 5, sigma_lt = 10)
plot_pc_matern(range_gt = 5, sigma_lt = 1, sigma_prob = 0.2)
plot_pc_matern(range_gt = 5, sigma_lt = 1, range_prob = 0.2)
</code></pre>

<hr>
<h2 id='plot_smooth'>Plot a smooth term from an sdmTMB model</h2><span id='topic+plot_smooth'></span>

<h3>Description</h3>

<p><strong>Deprecated: use <code>visreg::visreg()</code>. See <code><a href="#topic+visreg_delta">visreg_delta()</a></code> for examples.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_smooth(
  object,
  select = 1,
  n = 100,
  level = 0.95,
  ggplot = FALSE,
  rug = TRUE,
  return_data = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_smooth_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+sdmTMB">sdmTMB()</a></code> model.</p>
</td></tr>
<tr><td><code id="plot_smooth_+3A_select">select</code></td>
<td>
<p>The smoother term to plot.</p>
</td></tr>
<tr><td><code id="plot_smooth_+3A_n">n</code></td>
<td>
<p>The number of equally spaced points to evaluate the smoother along.</p>
</td></tr>
<tr><td><code id="plot_smooth_+3A_level">level</code></td>
<td>
<p>The confidence level.</p>
</td></tr>
<tr><td><code id="plot_smooth_+3A_ggplot">ggplot</code></td>
<td>
<p>Logical: use the <span class="pkg">ggplot2</span> package?</p>
</td></tr>
<tr><td><code id="plot_smooth_+3A_rug">rug</code></td>
<td>
<p>Logical: add rug lines along the lower axis?</p>
</td></tr>
<tr><td><code id="plot_smooth_+3A_return_data">return_data</code></td>
<td>
<p>Logical: return the predicted data instead of making a plot?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note:
</p>

<ul>
<li><p> Any numeric predictor is set to its mean
</p>
</li>
<li><p> Any factor predictor is set to its first-level value
</p>
</li>
<li><p> The time element (if present) is set to its minimum value
</p>
</li>
<li><p> The x and y coordinates are set to their mean values
</p>
</li></ul>



<h3>Value</h3>

<p>A plot of a smoother term.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d &lt;- subset(pcod, year &gt;= 2000 &amp; density &gt; 0)
  pcod_spde &lt;- make_mesh(d, c("X", "Y"), cutoff = 30)
  m &lt;- sdmTMB(
    data = d,
    formula = log(density) ~ s(depth_scaled) + s(year, k = 5),
    mesh = pcod_spde
  )
  plot_smooth(m)
</code></pre>

<hr>
<h2 id='predict.sdmTMB'>Predict from an sdmTMB model</h2><span id='topic+predict.sdmTMB'></span>

<h3>Description</h3>

<p>Make predictions from an <span class="pkg">sdmTMB</span> model; can predict on the original or
new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sdmTMB'
predict(
  object,
  newdata = NULL,
  type = c("link", "response"),
  se_fit = FALSE,
  re_form = NULL,
  re_form_iid = NULL,
  nsim = 0,
  sims_var = "est",
  model = c(NA, 1, 2),
  offset = NULL,
  mcmc_samples = NULL,
  return_tmb_object = FALSE,
  return_tmb_report = FALSE,
  return_tmb_data = FALSE,
  tmbstan_model = deprecated(),
  sims = deprecated(),
  area = deprecated(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.sdmTMB_+3A_object">object</code></td>
<td>
<p>A model fitted with <code><a href="#topic+sdmTMB">sdmTMB()</a></code>.</p>
</td></tr>
<tr><td><code id="predict.sdmTMB_+3A_newdata">newdata</code></td>
<td>
<p>A data frame to make predictions on. This should be a data
frame with the same predictor columns as in the fitted data and a time
column (if this is a spatiotemporal model) with the same name as in the
fitted data.</p>
</td></tr>
<tr><td><code id="predict.sdmTMB_+3A_type">type</code></td>
<td>
<p>Should the <code>est</code> column be in link (default) or response space?</p>
</td></tr>
<tr><td><code id="predict.sdmTMB_+3A_se_fit">se_fit</code></td>
<td>
<p>Should standard errors on predictions at the new locations
given by <code>newdata</code> be calculated? Warning: the current implementation can
be slow for large data sets or high-resolution projections unless
<code>re_form = NA</code> (omitting random fields). A faster option to approximate
point-wise uncertainty is to use the <code>nsim</code> argument.</p>
</td></tr>
<tr><td><code id="predict.sdmTMB_+3A_re_form">re_form</code></td>
<td>
<p><code>NULL</code> to specify including all spatial/spatiotemporal random
effects in predictions. <code>~0</code> or <code>NA</code> for population-level predictions.
Likely to be used in conjunction with <code>se_fit = TRUE</code>. This does not affect
<code><a href="#topic+get_index">get_index()</a></code> calculations.</p>
</td></tr>
<tr><td><code id="predict.sdmTMB_+3A_re_form_iid">re_form_iid</code></td>
<td>
<p><code>NULL</code> to specify including all random intercepts in the
predictions. <code>~0</code> or <code>NA</code> for population-level predictions. No other
options (e.g., some but not all random intercepts) are implemented yet.
Only affects predictions with <code>newdata</code>. This <em>does</em> affects <code><a href="#topic+get_index">get_index()</a></code>.</p>
</td></tr>
<tr><td><code id="predict.sdmTMB_+3A_nsim">nsim</code></td>
<td>
<p>If <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code>, simulate from the joint precision
matrix with <code>nsim</code> draws. Returns a matrix of <code>nrow(data)</code> by <code>nsim</code>
representing the estimates of the linear predictor (i.e., in link space).
Can be useful for deriving uncertainty on predictions
(e.g., <code>apply(x, 1, sd)</code>) or propagating uncertainty. This is currently
the fastest way to characterize uncertainty on predictions in space with
sdmTMB.</p>
</td></tr>
<tr><td><code id="predict.sdmTMB_+3A_sims_var">sims_var</code></td>
<td>
<p>Experimental: Which TMB reported variable from the model
should be extracted from the joint precision matrix simulation draws?
Defaults to link-space predictions. Options include: <code>"omega_s"</code>,
<code>"zeta_s"</code>, <code>"epsilon_st"</code>, and <code>"est_rf"</code> (as described below).
Other options will be passed verbatim.</p>
</td></tr>
<tr><td><code id="predict.sdmTMB_+3A_model">model</code></td>
<td>
<p>Type of prediction if a delta/hurdle model <em>and</em> <code>nsim &gt; 0</code> or
<code>mcmc_samples</code> is supplied: <code>NA</code> returns the combined prediction from both
components on the link scale for the positive component; <code>1</code> or <code>2</code> return
the first or second model component only on the link or response scale
depending on the argument <code>type</code>. For regular prediction from delta models,
both sets of predictions are returned.</p>
</td></tr>
<tr><td><code id="predict.sdmTMB_+3A_offset">offset</code></td>
<td>
<p>A numeric vector of optional offset values. If left at default
<code>NULL</code>, the offset is implicitly left at 0.</p>
</td></tr>
<tr><td><code id="predict.sdmTMB_+3A_mcmc_samples">mcmc_samples</code></td>
<td>
<p>See <code>extract_mcmc()</code> in the
<a href="https://github.com/pbs-assess/sdmTMBextra">sdmTMBextra</a> package for
more details and the
<a href="https://pbs-assess.github.io/sdmTMB/articles/web_only/bayesian.html">Bayesian vignette</a>.
If specified, the predict function will return a matrix of a similar form
as if <code>nsim &gt; 0</code> but representing Bayesian posterior samples from the Stan
model.</p>
</td></tr>
<tr><td><code id="predict.sdmTMB_+3A_return_tmb_object">return_tmb_object</code></td>
<td>
<p>Logical. If <code>TRUE</code>, will include the TMB object in a
list format output. Necessary for the <code><a href="#topic+get_index">get_index()</a></code> or <code><a href="#topic+get_cog">get_cog()</a></code>
functions.</p>
</td></tr>
<tr><td><code id="predict.sdmTMB_+3A_return_tmb_report">return_tmb_report</code></td>
<td>
<p>Logical: return the output from the TMB
report? For regular prediction, this is all the reported variables
at the MLE parameter values. For <code>nsim &gt; 0</code> or when <code>mcmc_samples</code>
is supplied, this is a list where each element is a sample and the
contents of each element is the output of the report for that sample.</p>
</td></tr>
<tr><td><code id="predict.sdmTMB_+3A_return_tmb_data">return_tmb_data</code></td>
<td>
<p>Logical: return formatted data for TMB? Used
internally.</p>
</td></tr>
<tr><td><code id="predict.sdmTMB_+3A_tmbstan_model">tmbstan_model</code></td>
<td>
<p>Deprecated. See <code>mcmc_samples</code>.</p>
</td></tr>
<tr><td><code id="predict.sdmTMB_+3A_sims">sims</code></td>
<td>
<p><strong>Deprecated</strong>. Please use <code>nsim</code> instead.</p>
</td></tr>
<tr><td><code id="predict.sdmTMB_+3A_area">area</code></td>
<td>
<p><strong>Deprecated</strong>. Please use <code>area</code> in <code><a href="#topic+get_index">get_index()</a></code>.</p>
</td></tr>
<tr><td><code id="predict.sdmTMB_+3A_...">...</code></td>
<td>
<p>Not implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return_tmb_object = FALSE</code> (and <code>nsim = 0</code> and <code>mcmc_samples = NULL</code>):
</p>
<p>A data frame:
</p>

<ul>
<li> <p><code>est</code>: Estimate in link space (everything is in link space)
</p>
</li>
<li> <p><code>est_non_rf</code>: Estimate from everything that isn't a random field
</p>
</li>
<li> <p><code>est_rf</code>: Estimate from all random fields combined
</p>
</li>
<li> <p><code>omega_s</code>: Spatial (intercept) random field that is constant through time
</p>
</li>
<li> <p><code>zeta_s</code>: Spatial slope random field
</p>
</li>
<li> <p><code>epsilon_st</code>: Spatiotemporal (intercept) random fields, could be
off (zero), IID, AR1, or random walk
</p>
</li></ul>

<p>If <code>return_tmb_object = TRUE</code> (and <code>nsim = 0</code> and <code>mcmc_samples = NULL</code>):
</p>
<p>A list:
</p>

<ul>
<li> <p><code>data</code>: The data frame described above
</p>
</li>
<li> <p><code>report</code>: The TMB report on parameter values
</p>
</li>
<li> <p><code>obj</code>: The TMB object returned from the prediction run
</p>
</li>
<li> <p><code>fit_obj</code>: The original TMB model object
</p>
</li></ul>

<p>In this case, you likely only need the <code>data</code> element as an end user.
The other elements are included for other functions.
</p>
<p>If <code>nsim &gt; 0</code> or <code>mcmc_samples</code> is not <code>NULL</code>:
</p>
<p>A matrix:
</p>

<ul>
<li><p> Columns represent samples
</p>
</li>
<li><p> Rows represent predictions with one row per row of <code>newdata</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

d &lt;- pcod_2011
mesh &lt;- make_mesh(d, c("X", "Y"), cutoff = 30) # a coarse mesh for example speed
m &lt;- sdmTMB(
 data = d, formula = density ~ 0 + as.factor(year) + depth_scaled + depth_scaled2,
 time = "year", mesh = mesh, family = tweedie(link = "log")
)

# Predictions at original data locations -------------------------------

predictions &lt;- predict(m)
head(predictions)

predictions$resids &lt;- residuals(m) # randomized quantile residuals

library(ggplot2)
ggplot(predictions, aes(X, Y, col = resids)) + scale_colour_gradient2() +
  geom_point() + facet_wrap(~year)
hist(predictions$resids)
qqnorm(predictions$resids);abline(a = 0, b = 1)

# Predictions onto new data --------------------------------------------

qcs_grid_2011 &lt;- replicate_df(qcs_grid, "year", unique(pcod_2011$year))
predictions &lt;- predict(m, newdata = qcs_grid_2011)


# A short function for plotting our predictions:
plot_map &lt;- function(dat, column = est) {
  ggplot(dat, aes(X, Y, fill = {{ column }})) +
    geom_raster() +
    facet_wrap(~year) +
    coord_fixed()
}

plot_map(predictions, exp(est)) +
  scale_fill_viridis_c(trans = "sqrt") +
  ggtitle("Prediction (fixed effects + all random effects)")

plot_map(predictions, exp(est_non_rf)) +
  ggtitle("Prediction (fixed effects and any time-varying effects)") +
  scale_fill_viridis_c(trans = "sqrt")

plot_map(predictions, est_rf) +
  ggtitle("All random field estimates") +
  scale_fill_gradient2()

plot_map(predictions, omega_s) +
  ggtitle("Spatial random effects only") +
  scale_fill_gradient2()

plot_map(predictions, epsilon_st) +
  ggtitle("Spatiotemporal random effects only") +
  scale_fill_gradient2()

# Visualizing a marginal effect ----------------------------------------

# See the visreg package or the ggeffects::ggeffect() or
# ggeffects::ggpredict() functions
# To do this manually:

nd &lt;- data.frame(depth_scaled =
  seq(min(d$depth_scaled), max(d$depth_scaled), length.out = 100))
nd$depth_scaled2 &lt;- nd$depth_scaled^2

# Because this is a spatiotemporal model, you'll need at least one time
# element. If time isn't also a fixed effect then it doesn't matter what you pick:
nd$year &lt;- 2011L # L: integer to match original data
p &lt;- predict(m, newdata = nd, se_fit = TRUE, re_form = NA)
ggplot(p, aes(depth_scaled, exp(est),
  ymin = exp(est - 1.96 * est_se), ymax = exp(est + 1.96 * est_se))) +
  geom_line() + geom_ribbon(alpha = 0.4)

# Plotting marginal effect of a spline ---------------------------------

m_gam &lt;- sdmTMB(
 data = d, formula = density ~ 0 + as.factor(year) + s(depth_scaled, k = 5),
 time = "year", mesh = mesh, family = tweedie(link = "log")
)
if (require("visreg", quietly = TRUE)) {
  visreg::visreg(m_gam, "depth_scaled")
}

# or manually:
nd &lt;- data.frame(depth_scaled =
  seq(min(d$depth_scaled), max(d$depth_scaled), length.out = 100))
nd$year &lt;- 2011L
p &lt;- predict(m_gam, newdata = nd, se_fit = TRUE, re_form = NA)
ggplot(p, aes(depth_scaled, exp(est),
  ymin = exp(est - 1.96 * est_se), ymax = exp(est + 1.96 * est_se))) +
  geom_line() + geom_ribbon(alpha = 0.4)

# Forecasting ----------------------------------------------------------
mesh &lt;- make_mesh(d, c("X", "Y"), cutoff = 15)

unique(d$year)
m &lt;- sdmTMB(
  data = d, formula = density ~ 1,
  spatiotemporal = "AR1", # using an AR1 to have something to forecast with
  extra_time = 2019L, # `L` for integer to match our data
  spatial = "off",
  time = "year", mesh = mesh, family = tweedie(link = "log")
)

# Add a year to our grid:
grid2019 &lt;- qcs_grid_2011[qcs_grid_2011$year == max(qcs_grid_2011$year), ]
grid2019$year &lt;- 2019L # `L` because `year` is an integer in the data
qcsgrid_forecast &lt;- rbind(qcs_grid_2011, grid2019)

predictions &lt;- predict(m, newdata = qcsgrid_forecast)
plot_map(predictions, exp(est)) +
  scale_fill_viridis_c(trans = "log10")
plot_map(predictions, epsilon_st) +
  scale_fill_gradient2()

# Estimating local trends ----------------------------------------------

d &lt;- pcod
d$year_scaled &lt;- as.numeric(scale(d$year))
mesh &lt;- make_mesh(pcod, c("X", "Y"), cutoff = 25)
m &lt;- sdmTMB(data = d, formula = density ~ depth_scaled + depth_scaled2,
  mesh = mesh, family = tweedie(link = "log"),
  spatial_varying = ~ 0 + year_scaled, time = "year", spatiotemporal = "off")
nd &lt;- replicate_df(qcs_grid, "year", unique(pcod$year))
nd$year_scaled &lt;- (nd$year - mean(d$year)) / sd(d$year)
p &lt;- predict(m, newdata = nd)

plot_map(subset(p, year == 2003), zeta_s_year_scaled) + # pick any year
  ggtitle("Spatial slopes") +
  scale_fill_gradient2()

plot_map(p, est_rf) +
  ggtitle("Random field estimates") +
  scale_fill_gradient2()

plot_map(p, exp(est_non_rf)) +
  ggtitle("Prediction (fixed effects only)") +
  scale_fill_viridis_c(trans = "sqrt")

plot_map(p, exp(est)) +
  ggtitle("Prediction (fixed effects + all random effects)") +
  scale_fill_viridis_c(trans = "sqrt")


</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+tidy'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
</dl>

<hr>
<h2 id='replicate_df'>Replicate a prediction data frame over time</h2><span id='topic+replicate_df'></span>

<h3>Description</h3>

<p>Useful for replicating prediction grids across time slices used in model
fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replicate_df(dat, time_name, time_values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replicate_df_+3A_dat">dat</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="replicate_df_+3A_time_name">time_name</code></td>
<td>
<p>Name of time column in output.</p>
</td></tr>
<tr><td><code id="replicate_df_+3A_time_values">time_values</code></td>
<td>
<p>Time values to replicate <code>dat</code> over.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame replicated over <code>time_values</code> with a new column based on
<code>time_name</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(variable = c("a", "b"))
replicate_df(df, time_name = "year", time_values = 1:3)

head(qcs_grid)
nd &lt;- replicate_df(qcs_grid, "year", unique(pcod$year))
head(nd)
table(nd$year)
</code></pre>

<hr>
<h2 id='residuals.sdmTMB'>Residuals method for sdmTMB models</h2><span id='topic+residuals.sdmTMB'></span>

<h3>Description</h3>

<p>See the residual-checking vignette: <code>browseVignettes("sdmTMB")</code> or <a href="https://pbs-assess.github.io/sdmTMB/articles/residual-checking.html">on the documentation site</a>.
See notes about types of residuals in 'Details' section below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sdmTMB'
residuals(
  object,
  type = c("mle-mvn", "mle-eb", "mle-mcmc", "response", "pearson"),
  model = c(1, 2),
  mcmc_samples = NULL,
  qres_func = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.sdmTMB_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+sdmTMB">sdmTMB()</a></code> model.</p>
</td></tr>
<tr><td><code id="residuals.sdmTMB_+3A_type">type</code></td>
<td>
<p>Residual type. See details.</p>
</td></tr>
<tr><td><code id="residuals.sdmTMB_+3A_model">model</code></td>
<td>
<p>Which delta/hurdle model component?</p>
</td></tr>
<tr><td><code id="residuals.sdmTMB_+3A_mcmc_samples">mcmc_samples</code></td>
<td>
<p>A vector of MCMC samples of the linear predictor in link
space. See the <code>predict_mle_mcmc()</code> function in the
<a href="https://github.com/pbs-assess/sdmTMBextra">sdmTMBextra</a> package.</p>
</td></tr>
<tr><td><code id="residuals.sdmTMB_+3A_qres_func">qres_func</code></td>
<td>
<p>A custom quantile residuals function. Function should take
the arguments <code style="white-space: pre;">&#8288;object, y, mu, ...&#8288;</code> and return a vector of length
<code>length(y)</code>.</p>
</td></tr>
<tr><td><code id="residuals.sdmTMB_+3A_...">...</code></td>
<td>
<p>Passed to custom <code>qres_func</code> function. Unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Randomized quantile residuals:</strong>
</p>
<p><code>mle-mvn</code>, <code>mle-eb</code>, and <code>mle-mcmc</code> are all implementations of
randomized quantile residuals (Dunn &amp; Smyth 1996), which are also known as
probability integral transform (PIT) residuals (Smith 1985). If the data are
consistent with model assumptions, these residuals should be distributed as
normal(0, 1). Randomization is added to account for integer or binary
response observations. For example, for a Poisson observation likelihood with
observations <code>y</code> and mean predictions <code>mu</code>, we would create randomized
quantile residuals as:
</p>
<div class="sourceCode"><pre>a &lt;- ppois(y - 1, mu)
b &lt;- ppois(y, mu)
u &lt;- runif(n = length(y), min = a, max = b)
qnorm(u)
</pre></div>
<p><strong>Types of residuals:</strong>
</p>
<p>Acronyms:
</p>

<ul>
<li><p> EB: Empirical Bayes
</p>
</li>
<li><p> MCMC: Markov chain Monte Carlo
</p>
</li>
<li><p> MLE: Maximum Likelihood Estimate
</p>
</li>
<li><p> MVN: Multivariate normal
</p>
</li></ul>

<p><strong><code>mle-mvn</code></strong>: Fixed effects are held at their MLEs and random effects are
taken from a single approximate posterior sample. The &quot;approximate&quot; part
refers to the sample being taken from the random effects' assumed MVN
distribution. In practice, the sample is obtained based on the mode and
Hessian of the random effects taking advantage of sparsity in the Hessian for
computational efficiency. This sample is taken with <code>obj$MC()</code>, where <code>obj</code>
is the <span class="pkg">TMB</span> object created with <code>TMB::MakeADFun()</code>. See Waagepetersen
(2006) and the description in the source code for the internal <span class="pkg">TMB</span>
function <code>TMB:::oneSamplePosterior()</code>. Residuals are converted to randomized
quantile residuals as described above.
</p>
<p><strong><code>mle-eb</code></strong>: Fixed effects are held at their MLEs and random effects are
taken as their EB estimates. These used to be the default residuals in
<span class="pkg">sdmTMB</span> (and were called <code>mle-laplace</code>). They are available for
backwards compatibility and for research purposes but they are <em>not</em>
recommended for checking goodness of fit. Residuals are converted to
randomized quantile residuals as described above.
</p>
<p><strong><code>mle-mcmc</code></strong>: Fixed effects are held at their MLEs and random effects are
taken from a single posterior sample obtained with MCMC. These are an
excellent option since they make no assumption about the distribution of the
random effects (compared to the <code>mle-mvn</code> option) but can be slow to obtain.
See Waagepetersen (2006) and Thygesen et al. (2017). Residuals are converted
to randomized quantile residuals as described above.
</p>
<p>See the <a href="https://github.com/pbs-assess/sdmTMBextra"><span class="pkg">sdmTMBextra</span></a>
package for the function <code>predict_mle_mcmc()</code>, which can generate the MCMC
samples to pass to the <code>mcmc_samples</code> argument. Ideally MCMC is run until
convergence and then the last iteration can be used for residuals.
The defaults may not be sufficient for many models.
</p>
<p><strong><code>response</code></strong>: These are simple observed minus predicted residuals.
</p>
<p><strong><code>pearson</code></strong>: These are Pearson residuals: response residuals scaled by the
standard deviation. If weights are present, the residuals are then
multiplied by sqrt(weights).
</p>


<h3>Value</h3>

<p>A vector of residuals. Note that randomization from any single
random effect posterior sample and from any randomized quantile routines
will result in different residuals with each call. It is suggested to <strong>set
a randomization seed</strong> and to not go &quot;fishing&quot; for the perfect residuals or
to present all inspected residuals.
</p>


<h3>References</h3>

<p>Dunn, P.K. &amp; Smyth, G.K. (1996). Randomized Quantile Residuals. Journal of
Computational and Graphical Statistics, 5, 236–244.
</p>
<p>Smith, J.Q. (1985). Diagnostic checks of non-standard time series models.
Journal of Forecasting, 4, 283–291.
</p>
<p>Waagepetersen, R. (2006). A simulation-based goodness-of-fit test for random
effects in generalized linear mixed models. Scandinavian Journal of
Statistics, 33(4), 721-731.
</p>
<p>Thygesen, U.H., Albertsen, C.M., Berg, C.W., Kristensen, K., and Nielsen, A.
2017. Validation of ecological state space models using the Laplace
approximation. Environ Ecol Stat 24(2): 317–339.
<a href="https://doi.org/10.1007/s10651-017-0372-4">doi:10.1007/s10651-017-0372-4</a>
</p>
<p>Rufener, M.-C., Kristensen, K., Nielsen, J.R., and Bastardie, F. 2021.
Bridging the gap between commercial fisheries and survey data to model the
spatiotemporal dynamics of marine species. Ecological Applications. e02453.
<a href="https://doi.org/10.1002/eap.2453">doi:10.1002/eap.2453</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.sdmTMB">simulate.sdmTMB()</a></code>, <code><a href="#topic+dharma_residuals">dharma_residuals()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mesh &lt;- make_mesh(pcod_2011, c("X", "Y"), cutoff = 10)
fit &lt;- sdmTMB(
  present ~ as.factor(year) + poly(depth, 2),
  data = pcod_2011, mesh = mesh,
  family = binomial()
)

# the default "mle-mvn" residuals use fixed effects at their MLE and a
# single sample from the approximate random effect posterior:
set.seed(9283)
r &lt;- residuals(fit, type = "mle-mvn")
qqnorm(r)
abline(0, 1)

# response residuals will be not be normally distributed unless
# the family is Gaussian:
r &lt;- residuals(fit, type = "response")
qqnorm(r)
abline(0, 1)

# "mle-eb" are quick but are not expected to be N(0, 1); not recommended:
set.seed(2321)
r &lt;- residuals(fit, type = "mle-eb")
qqnorm(r)
abline(0, 1)

# see also "mle-mcmc" residuals with the help of the sdmTMBextra package
# we can fake them here by taking a single sample from the joint precision
# matrix and pretending they are MCMC samples:
set.seed(82728)
p &lt;- predict(fit, nsim = 1) # pretend these are from sdmTMBextra::predict_mle_mcmc()
r &lt;- residuals(fit, mcmc_samples = p)
qqnorm(r)
abline(0, 1)
</code></pre>

<hr>
<h2 id='run_extra_optimization'>Run extra optimization on an already fitted object</h2><span id='topic+run_extra_optimization'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_extra_optimization(object, nlminb_loops = 0, newton_loops = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_extra_optimization_+3A_object">object</code></td>
<td>
<p>An object from <code><a href="#topic+sdmTMB">sdmTMB()</a></code>.</p>
</td></tr>
<tr><td><code id="run_extra_optimization_+3A_nlminb_loops">nlminb_loops</code></td>
<td>
<p>How many extra times to run <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>
optimization. Sometimes restarting the optimizer at the previous best
values aids convergence.</p>
</td></tr>
<tr><td><code id="run_extra_optimization_+3A_newton_loops">newton_loops</code></td>
<td>
<p>How many extra Newton optimization loops to try with
<code><a href="stats.html#topic+optim">stats::optimHess()</a></code>. Sometimes aids convergence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated model fit of class <code>sdmTMB</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Run extra optimization steps to help convergence:
# (Not typically needed)
fit &lt;- sdmTMB(density ~ 0 + poly(depth, 2) + as.factor(year),
  data = pcod_2011, mesh = pcod_mesh_2011, family = tweedie())
fit_1 &lt;- run_extra_optimization(fit, newton_loops = 1)
max(fit$gradients)
max(fit_1$gradients)
</code></pre>

<hr>
<h2 id='sanity'>Sanity check of an sdmTMB model</h2><span id='topic+sanity'></span>

<h3>Description</h3>

<p>Sanity check of an sdmTMB model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sanity(object, big_sd_log10 = 2, gradient_thresh = 0.001, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sanity_+3A_object">object</code></td>
<td>
<p>Fitted model from <code><a href="#topic+sdmTMB">sdmTMB()</a></code>.</p>
</td></tr>
<tr><td><code id="sanity_+3A_big_sd_log10">big_sd_log10</code></td>
<td>
<p>Value to check size of standard errors against. A value
of 2 would indicate that standard errors greater than <code>10^2</code> (i.e., 100)
should be flagged.</p>
</td></tr>
<tr><td><code id="sanity_+3A_gradient_thresh">gradient_thresh</code></td>
<td>
<p>Gradient threshold to issue warning.</p>
</td></tr>
<tr><td><code id="sanity_+3A_silent">silent</code></td>
<td>
<p>Logical: suppress messages? Useful to set to <code>TRUE</code> if running
large numbers of models and just interested in returning sanity list
objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>object</code> is <code>NA</code>, <code>NULL</code>, or of class <code>"try-error"</code>, <code>sanity()</code> will
return <code>FALSE</code>. This is to facilitate using <code>sanity()</code> on models with <code><a href="base.html#topic+try">try()</a></code>
or <code><a href="base.html#topic+tryCatch">tryCatch()</a></code>. See the examples section.
</p>


<h3>Value</h3>

<p>An invisible named list of checks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- sdmTMB(
  present ~ s(depth),
  data = pcod_2011, mesh = pcod_mesh_2011,
  family = binomial()
)
sanity(fit)

s &lt;- sanity(fit)
s

# If fitting many models in a loop, you may want to wrap
# sdmTMB() in try() to handle errors. sanity() will take an object
# of class "try-error" and return FALSE.
# Here, we will use stop() to simulate a failed sdmTMB() fit:
failed_fit &lt;- try(stop())
s2 &lt;- sanity(failed_fit)
all(unlist(s))
all(unlist(s2))
</code></pre>

<hr>
<h2 id='sdmTMB'>Fit a spatial or spatiotemporal GLMM with TMB</h2><span id='topic+sdmTMB'></span>

<h3>Description</h3>

<p>Fit a spatial or spatiotemporal generalized linear mixed effects model (GLMM)
with the TMB (Template Model Builder) R package and the SPDE (stochastic
partial differential equation) approximation to Gaussian random fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdmTMB(
  formula,
  data,
  mesh,
  time = NULL,
  family = gaussian(link = "identity"),
  spatial = c("on", "off"),
  spatiotemporal = c("iid", "ar1", "rw", "off"),
  share_range = TRUE,
  time_varying = NULL,
  time_varying_type = c("rw", "rw0", "ar1"),
  spatial_varying = NULL,
  weights = NULL,
  offset = NULL,
  extra_time = NULL,
  reml = FALSE,
  silent = TRUE,
  anisotropy = FALSE,
  control = sdmTMBcontrol(),
  priors = sdmTMBpriors(),
  knots = NULL,
  bayesian = FALSE,
  previous_fit = NULL,
  do_fit = TRUE,
  do_index = FALSE,
  predict_args = NULL,
  index_args = NULL,
  experimental = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdmTMB_+3A_formula">formula</code></td>
<td>
<p>Model formula. IID random intercepts are possible using
<span class="pkg">lme4</span> syntax, e.g., <code>+ (1 | g)</code> where <code>g</code> is a column of class
character or factor representing groups. Penalized splines are possible via
<span class="pkg">mgcv</span> with <code>s()</code>. Optionally a list for delta (hurdle) models.  See
examples and details below.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_mesh">mesh</code></td>
<td>
<p>An object from <code><a href="#topic+make_mesh">make_mesh()</a></code>.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_time">time</code></td>
<td>
<p>An optional time column name (as character). Can be left as
<code>NULL</code> for a model with only spatial random fields; however, if the data
are actually spatiotemporal and you wish to use <code><a href="#topic+get_index">get_index()</a></code> or <code><a href="#topic+get_cog">get_cog()</a></code>
downstream, supply the time argument.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_family">family</code></td>
<td>
<p>The family and link. Supports <code><a href="stats.html#topic+gaussian">gaussian()</a></code>, <code><a href="stats.html#topic+Gamma">Gamma()</a></code>,
<code><a href="stats.html#topic+binomial">binomial()</a></code>, <code><a href="stats.html#topic+poisson">poisson()</a></code>, <code><a href="#topic+families">Beta()</a></code>,
<code><a href="#topic+families">nbinom2()</a></code>,
<code><a href="#topic+families">truncated_nbinom2()</a></code>,
<code><a href="#topic+families">nbinom1()</a></code>,
<code><a href="#topic+families">truncated_nbinom1()</a></code>,
<code><a href="#topic+families">censored_poisson()</a></code>,
<code><a href="#topic+families">gamma_mix()</a></code>,
<code><a href="#topic+families">lognormal_mix()</a></code>,
<code><a href="#topic+families">student()</a></code>,
<code><a href="#topic+families">tweedie()</a></code>, and
<code><a href="#topic+families">gengamma()</a></code>.
Supports the delta/hurdle models:
<code><a href="#topic+families">delta_beta()</a></code>,
<code><a href="#topic+families">delta_gamma()</a></code>,
<code><a href="#topic+families">delta_gamma_mix()</a></code>,
<code><a href="#topic+families">delta_lognormal_mix()</a></code>,
<code><a href="#topic+families">delta_lognormal()</a></code>, and
<code><a href="#topic+families">delta_truncated_nbinom2()</a></code>,
For binomial family options, see 'Binomial families' in the Details
section below.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_spatial">spatial</code></td>
<td>
<p>Estimate spatial random fields? Options are <code>'on'</code> / <code>'off'</code>
or <code>TRUE</code> / <code>FALSE</code>. Optionally, a list for delta models, e.g. <code>list('on', 'off')</code>.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_spatiotemporal">spatiotemporal</code></td>
<td>
<p>Estimate the spatiotemporal random fields as <code>'iid'</code>
(independent and identically distributed; default), stationary <code>'ar1'</code>
(first-order autoregressive), a random walk (<code>'rw'</code>), or fixed at 0
<code>'off'</code>. Will be set to <code>'off'</code> if <code>time = NULL</code>. If a delta model, can be
a list. E.g., <code>list('off', 'ar1')</code>. Note that the spatiotemporal standard
deviation represents the marginal steady-state standard deviation of the
process in the case of the AR1. I.e., it is scaled according to the
correlation. See the <a href="https://kaskr.github.io/adcomp/classdensity_1_1AR1__t.html">TMB documentation</a>.
If the AR1 correlation coefficient (rho) is estimated close to 1,
say &gt; 0.99, then you may wish to switch to the random walk <code>'rw'</code>.
Capitalization is ignored. <code>TRUE</code> gets converted to <code>'iid'</code> and <code>FALSE</code>
gets converted to <code>'off'</code>.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_share_range">share_range</code></td>
<td>
<p>Logical: estimate a shared spatial and spatiotemporal
range parameter (<code>TRUE</code>, default) or independent range parameters
(<code>FALSE</code>). If a delta model, can be a list. E.g., <code>list(TRUE, FALSE)</code>.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_time_varying">time_varying</code></td>
<td>
<p>An optional one-sided formula describing covariates
that should be modelled as a time-varying process. Set the type of
process with <code>time_varying_type</code>. See the help for <code>time_varying_type</code>
for warnings about modelling the first time step. Structure shared in
delta models.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_time_varying_type">time_varying_type</code></td>
<td>
<p>Type of time-varying process to apply to
<code>time_varying</code> formula. <code>'rw'</code> indicates a random walk with the first
time step estimated independently (included for legacy reasons), <code>'rw0'</code>
indicates a random walk with the first time step estimated with
a mean-zero normal prior, <code>'ar1'</code> indicates a <a href="https://kaskr.github.io/adcomp/classdensity_1_1AR1__t.html">stationary first-order autoregressive process</a>
with the first time step estimated with a mean-zero prior. In the case of
<code>'rw'</code>, be careful not to include covariates (including the intercept) in
both the main and time-varying formula since the first time step is
estimated independently. I.e., in this case, at least one should have <code>~ 0</code> or <code>~ -1</code>. Structure shared in delta models.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_spatial_varying">spatial_varying</code></td>
<td>
<p>An optional one-sided formula of coefficients that
should vary in space as random fields. Note that you likely want to include
a fixed effect for the same variable to improve interpretability since the
random field is assumed to have a mean of 0. If a (scaled) time column is
used, it will represent a local-time-trend model. See
<a href="https://doi.org/10.1111/ecog.05176">doi:10.1111/ecog.05176</a> and the <a href="https://pbs-assess.github.io/sdmTMB/articles/spatial-trend-models.html">spatial trends vignette</a>.
Note this predictor should usually be centered to have mean zero and have a
standard deviation of approximately 1.
<strong>The spatial intercept is controlled by the <code>spatial</code> argument</strong>; therefore,
include or exclude the spatial intercept by setting <code>spatial = 'on'</code> or
<code>'off'</code>. The only time when it matters whether <code>spatial_varying</code> excludes
an intercept is in the case of factor predictors. In this case, if
<code>spatial_varying</code> excludes the intercept (<code>~ 0</code> or <code>~ -1</code>), you should set
<code>spatial = 'off'</code> to match.  Structure must be shared in delta models.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_weights">weights</code></td>
<td>
<p>A numeric vector representing optional likelihood weights for
the conditional model. Implemented as in <span class="pkg">glmmTMB</span>: weights do not have
to sum to one and are not internally modified. Can also be used for trials
with the binomial family; the <code>weights</code> argument needs to be a vector and not
a name of the variable in the data frame. See the Details section below.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_offset">offset</code></td>
<td>
<p>A numeric vector representing the model offset <em>or</em> a character
value representing the column name of the offset. In delta/hurdle models,
this applies only to the positive component. Usually a log transformed
variable.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_extra_time">extra_time</code></td>
<td>
<p>Optional extra time slices (e.g., years) to include for
interpolation or forecasting with the predict function. See the Details
section below.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_reml">reml</code></td>
<td>
<p>Logical: use REML (restricted maximum likelihood) estimation
rather than maximum likelihood? Internally, this adds the fixed effects to
the list of random effects to integrate over.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_silent">silent</code></td>
<td>
<p>Silent or include optimization details? Helpful to set to
<code>FALSE</code> for models that take a while to fit.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_anisotropy">anisotropy</code></td>
<td>
<p>Logical: allow for anisotropy (spatial correlation that is
directionally dependent)? See <code><a href="#topic+plot_anisotropy">plot_anisotropy()</a></code>.
Must be shared across delta models.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_control">control</code></td>
<td>
<p>Optimization control options via <code><a href="#topic+sdmTMBcontrol">sdmTMBcontrol()</a></code>.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_priors">priors</code></td>
<td>
<p>Optional penalties/priors via <code><a href="#topic+sdmTMBpriors">sdmTMBpriors()</a></code>. Must currently
be shared across delta models.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_knots">knots</code></td>
<td>
<p>Optional named list containing knot values to be used for basis
construction of smoothing terms. See <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code> and <code><a href="mgcv.html#topic+gamm">mgcv::gamm()</a></code>.
E.g., <code style="white-space: pre;">&#8288;s(x, bs = 'cc', k = 4), knots = list(x = c(1, 2, 3, 4))&#8288;</code></p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_bayesian">bayesian</code></td>
<td>
<p>Logical indicating if the model will be passed to
<span class="pkg">tmbstan</span>. If <code>TRUE</code>, Jacobian adjustments are applied to account for
parameter transformations when priors are applied.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_previous_fit">previous_fit</code></td>
<td>
<p>A previously fitted sdmTMB model to initialize the
optimization with. Can greatly speed up fitting. Note that the model must
be set up <em>exactly</em> the same way. However, the data and <code>weights</code> arguments
can change, which can be useful for cross-validation.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_do_fit">do_fit</code></td>
<td>
<p>Fit the model (<code>TRUE</code>) or return the processed data without
fitting (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_do_index">do_index</code></td>
<td>
<p>Do index standardization calculations while fitting? Saves
memory and time when working with large datasets or projection grids since
the TMB object doesn't have to be rebuilt with <code><a href="#topic+predict.sdmTMB">predict.sdmTMB()</a></code> and
<code><a href="#topic+get_index">get_index()</a></code>. If <code>TRUE</code>, then <code>predict_args</code> must have a <code>newdata</code> element
supplied and <code>area</code> can be supplied to <code>index_args</code>.
Most users can ignore this option. The fitted object can be passed directly
to <code><a href="#topic+get_index">get_index()</a></code>.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_predict_args">predict_args</code></td>
<td>
<p>A list of arguments to pass to <code><a href="#topic+predict.sdmTMB">predict.sdmTMB()</a></code> <strong>if</strong>
<code>do_index = TRUE</code>. Most users can ignore this option.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_index_args">index_args</code></td>
<td>
<p>A list of arguments to pass to <code><a href="#topic+get_index">get_index()</a></code> <strong>if</strong>
<code>do_index = TRUE</code>. Currently, only <code>area</code> is supported. Bias correction
can be done when calling <code><a href="#topic+get_index">get_index()</a></code> on the resulting fitted object.
Most users can ignore this option.</p>
</td></tr>
<tr><td><code id="sdmTMB_+3A_experimental">experimental</code></td>
<td>
<p>A named list for esoteric or in-development options. Here
be dragons.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Model description</strong>
</p>
<p>See the <a href="https://pbs-assess.github.io/sdmTMB/articles/model-description.html">model description</a>
vignette or the relevant appendix of the preprint on sdmTMB:
<a href="https://doi.org/10.1101/2022.03.24.485545">doi:10.1101/2022.03.24.485545</a>
</p>
<p><strong>Binomial families</strong>
</p>
<p>Following the structure of <code><a href="stats.html#topic+glm">stats::glm()</a></code> and <span class="pkg">glmmTMB</span>, a binomial
family can be specified in one of 4 ways: (1) the response may be a factor
(and the model classifies the first level versus all others), (2) the
response may be binomial (0/1), (3) the response can be a matrix of form
<code>cbind(success, failure)</code>, and (4) the response may be the observed
proportions, and the 'weights' argument is used to specify the Binomial size
(N) parameter (<code style="white-space: pre;">&#8288;prob ~ ..., weights = N&#8288;</code>).
</p>
<p><strong>Smooth terms</strong>
</p>
<p>Smooth terms can be included following GAMs (generalized additive models)
using <code>+ s(x)</code>, which implements a smooth from <code><a href="mgcv.html#topic+s">mgcv::s()</a></code>. <span class="pkg">sdmTMB</span> uses
penalized smooths, constructed via <code><a href="mgcv.html#topic+smooth2random">mgcv::smooth2random()</a></code>. This is a similar
approach implemented in <span class="pkg">gamm4</span> and <span class="pkg">brms</span>, among other packages.
Within these smooths, the same syntax commonly used in <code><a href="mgcv.html#topic+s">mgcv::s()</a></code> or
<code><a href="mgcv.html#topic+t2">mgcv::t2()</a></code> can be applied, e.g. 2-dimensional smooths may be constructed
with <code>+ s(x, y)</code> or <code>+ t2(x, y)</code>; smooths can be specific to various factor
levels, <code>+ s(x, by = group)</code>; the basis function dimensions may be specified,
e.g. <code>+ s(x, k = 4)</code>; and various types of splines may be constructed such as
cyclic splines to model seasonality (perhaps with the <code>knots</code> argument also
be supplied).
</p>
<p><strong>Threshold models</strong>
</p>
<p>A linear break-point relationship for a covariate can be included via
<code>+ breakpt(variable)</code> in the formula, where <code>variable</code> is a single covariate
corresponding to a column in <code>data</code>. In this case, the relationship is linear
up to a point and then constant (hockey-stick shaped).
</p>
<p>Similarly, a logistic-function threshold model can be included via
<code>+ logistic(variable)</code>. This option models the relationship as a logistic
function of the 50% and 95% values. This is similar to length- or size-based
selectivity in fisheries, and is parameterized by the points at which f(x) =
0.5 or 0.95. See the
<a href="https://pbs-assess.github.io/sdmTMB/articles/threshold-models.html">threshold vignette</a>.
</p>
<p>Note that only a single threshold covariate can be included and the same covariate
is included in both components for the delta families.
</p>
<p><strong>Extra time: forecasting or interpolating</strong>
</p>
<p>Extra time slices (e.g., years) can be included for interpolation or
forecasting with the predict function via the <code>extra_time</code> argument. The
predict function requires all time slices to be defined when fitting the
model to ensure the various time indices are set up correctly. Be careful if
including extra time slices that the model remains identifiable. For example,
including <code>+ as.factor(year)</code> in <code>formula</code> will render a model with no data
to inform the expected value in a missing year. <code><a href="#topic+sdmTMB">sdmTMB()</a></code> makes no attempt
to determine if the model makes sense for forecasting or interpolation. The
options <code>time_varying</code>, <code>spatiotemporal = "rw"</code>, <code>spatiotemporal = "ar1"</code>,
or a smoother on the time column provide mechanisms to predict over missing
time slices with process error.
</p>
<p><code>extra_time</code> can also be used to fill in missing time steps for the purposes
of a random walk or AR(1) process if the gaps between time steps are uneven.
</p>
<p><strong>Regularization and priors</strong>
</p>
<p>You can achieve regularization via penalties (priors) on the fixed effect
parameters. See <code><a href="#topic+sdmTMBpriors">sdmTMBpriors()</a></code>. You can fit the model once without
penalties and look at the output of <code>print(your_model)</code> or <code>tidy(your_model)</code>
or fit the model with <code>do_fit = FALSE</code> and inspect
<code>head(your_model$tmb_data$X_ij[[1]])</code> if you want to see how the formula is
translated to the fixed effect model matrix. Also see the
<a href="https://pbs-assess.github.io/sdmTMB/articles/bayesian.html">Bayesian vignette</a>.
</p>
<p><strong>Delta/hurdle models</strong>
</p>
<p>Delta models (also known as hurdle models) can be fit as two separate models
or at the same time by using an appropriate delta family. E.g.:
<code><a href="#topic+families">delta_gamma()</a></code>,
<code><a href="#topic+families">delta_beta()</a></code>,
<code><a href="#topic+families">delta_lognormal()</a></code>, and
<code><a href="#topic+families">delta_truncated_nbinom2()</a></code>.
If fit with a delta family, by default the formula, spatial, and spatiotemporal
components are shared. Some elements can be specified independently for the two models
using a list format. These include <code>formula</code>, <code>spatial</code>, <code>spatiotemporal</code>,
and <code>share_range</code>. The first element of the list is for the binomial component
and the second element is for the positive component (e.g., Gamma).
Other elements must be shared for now (e.g., spatially varying coefficients,
time-varying coefficients). Furthermore, there are currently limitations if
specifying two formulas as a list: the two formulas cannot have smoothers,
threshold effects, or random intercepts. For now, these must be specified
through a single formula that is shared across the two models.
</p>
<p>The main advantage of specifying such models using a delta family (compared
to fitting two separate models) is (1) coding simplicity and (2) calculation
of uncertainty on derived quantities such as an index of abundance with
<code><a href="#topic+get_index">get_index()</a></code> using the generalized delta method within TMB. Also, selected
parameters can be shared across the models.
</p>
<p>See the <a href="https://pbs-assess.github.io/sdmTMB/articles/delta-models.html">delta-model vignette</a>.
</p>
<p><strong>Index standardization</strong>
</p>
<p>For index standardization, you may wish to include <code>0 + as.factor(year)</code>
(or whatever the time column is called) in the formula. See a basic
example of index standardization in the relevant
<a href="https://pbs-assess.github.io/sdmTMB/articles/index-standardization.html">package vignette</a>.
You will need to specify the <code>time</code> argument. See <code><a href="#topic+get_index">get_index()</a></code>.
</p>


<h3>Value</h3>

<p>An object (list) of class <code>sdmTMB</code>. Useful elements include:
</p>

<ul>
<li> <p><code>sd_report</code>: output from <code><a href="TMB.html#topic+sdreport">TMB::sdreport()</a></code>
</p>
</li>
<li> <p><code>gradients</code>: marginal log likelihood gradients with respect to each fixed effect
</p>
</li>
<li> <p><code>model</code>: output from <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>
</p>
</li>
<li> <p><code>data</code>: the fitted data
</p>
</li>
<li> <p><code>mesh</code>: the object that was supplied to the <code>mesh</code> argument
</p>
</li>
<li> <p><code>family</code>: the family object, which includes the inverse link function as <code>family$linkinv()</code>
</p>
</li>
<li> <p><code>tmb_params</code>: The parameters list passed to <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>
</p>
</li>
<li> <p><code>tmb_map</code>: The 'map' list passed to <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>
</p>
</li>
<li> <p><code>tmb_data</code>: The data list passed to <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>
</p>
</li>
<li> <p><code>tmb_obj</code>: The TMB object created by <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>
</p>
</li></ul>



<h3>References</h3>

<p><strong>Main reference introducing the package to cite when using sdmTMB:</strong>
</p>
<p>Anderson, S.C., E.J. Ward, P.A. English, L.A.K. Barnett. 2022. sdmTMB: an R
package for fast, flexible, and user-friendly generalized linear mixed effects
models with spatial and spatiotemporal random fields.
bioRxiv 2022.03.24.485545; <a href="https://doi.org/10.1101/2022.03.24.485545">doi:10.1101/2022.03.24.485545</a>.
</p>
<p><em>Reference for local trends:</em>
</p>
<p>Barnett, L.A.K., E.J. Ward, S.C. Anderson. 2021. Improving estimates of species
distribution change by incorporating local trends. Ecography. 44(3):427-439.
<a href="https://doi.org/10.1111/ecog.05176">doi:10.1111/ecog.05176</a>.
</p>
<p><em>Further explanation of the model and application to calculating climate
velocities:</em>
</p>
<p>English, P., E.J. Ward, C.N. Rooper, R.E. Forrest, L.A. Rogers, K.L. Hunter,
A.M. Edwards, B.M. Connors, S.C. Anderson. 2021. Contrasting climate velocity
impacts in warm and cool locations show that effects of marine warming are
worse in already warmer temperate waters. Fish and Fisheries. 23(1) 239-255.
<a href="https://doi.org/10.1111/faf.12613">doi:10.1111/faf.12613</a>.
</p>
<p><em>Discussion of and illustration of some decision points when fitting these
models:</em>
</p>
<p>Commander, C.J.C., L.A.K. Barnett, E.J. Ward, S.C. Anderson, T.E.
Essington. 2022. The shadow model: how and why small choices in
spatially explicit species distribution models affect predictions. PeerJ 10:
e12783. <a href="https://doi.org/10.7717/peerj.12783">doi:10.7717/peerj.12783</a>.
</p>
<p><em>Application and description of threshold/break-point models:</em>
</p>
<p>Essington, T.E., S.C. Anderson, L.A.K. Barnett, H.M. Berger, S.A. Siedlecki,
E.J. Ward. 2022. Advancing statistical models to reveal the effect of
dissolved oxygen on the spatial distribution of marine taxa using thresholds
and a physiologically based index. Ecography. 2022: e06249
<a href="https://doi.org/10.1111/ecog.06249">doi:10.1111/ecog.06249</a>.
</p>
<p><em>Application to fish body condition:</em>
</p>
<p>Lindmark, M., S.C. Anderson, M. Gogina, M. Casini. Evaluating drivers of
spatiotemporal individual condition of a bottom-associated marine fish.
bioRxiv 2022.04.19.488709. <a href="https://doi.org/10.1101/2022.04.19.488709">doi:10.1101/2022.04.19.488709</a>.
</p>
<p><em>Several sections of the original TMB model code were adapted from the
VAST R package:</em>
</p>
<p>Thorson, J.T. 2019. Guidance for decisions using the Vector Autoregressive
Spatio-Temporal (VAST) package in stock, ecosystem, habitat and climate
assessments. Fish. Res. 210:143–161.
<a href="https://doi.org/10.1016/j.fishres.2018.10.013">doi:10.1016/j.fishres.2018.10.013</a>.
</p>
<p><em>Code for the <code>family</code> R-to-TMB implementation, selected parameterizations of
the observation likelihoods, general package structure inspiration, and the
idea behind the TMB prediction approach were adapted from the glmmTMB R
package:</em>
</p>
<p>Brooks, M.E., K. Kristensen, K.J. van Benthem, A. Magnusson,
C.W. Berg, A. Nielsen, H.J. Skaug, M. Maechler, B.M. Bolker.
2017. glmmTMB Balances Speed and Flexibility Among Packages for
Zero-inflated Generalized Linear Mixed Modeling. The R Journal, 9(2):378-400.
<a href="https://doi.org/10.32614/rj-2017-066">doi:10.32614/rj-2017-066</a>.
</p>
<p><em>Implementation of geometric anisotropy with the SPDE and use of random
field GLMMs for index standardization</em>:
</p>
<p>Thorson, J.T., A.O. Shelton, E.J. Ward, H.J. Skaug. 2015.
Geostatistical delta-generalized linear mixed models improve precision for
estimated abundance indices for West Coast groundfishes. ICES J. Mar. Sci.
72(5): 1297–1310. <a href="https://doi.org/10.1093/icesjms/fsu243">doi:10.1093/icesjms/fsu243</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(sdmTMB)

# Build a mesh to implement the SPDE approach:
mesh &lt;- make_mesh(pcod_2011, c("X", "Y"), cutoff = 20)

# - this example uses a fairly coarse mesh so these examples run quickly
# - 'cutoff' is the minimum distance between mesh vertices in units of the
#   x and y coordinates
# - 'cutoff = 10' might make more sense in applied situations for this dataset
# - or build any mesh in 'fmesher' and pass it to the 'mesh' argument in make_mesh()`
# - the mesh is not needed if you will be turning off all
#   spatial/spatiotemporal random fields

# Quick mesh plot:
plot(mesh)

# Fit a Tweedie spatial random field GLMM with a smoother for depth:
fit &lt;- sdmTMB(
  density ~ s(depth),
  data = pcod_2011, mesh = mesh,
  family = tweedie(link = "log")
)
fit

# Extract coefficients:
tidy(fit, conf.int = TRUE)
tidy(fit, effects = "ran_par", conf.int = TRUE)

# Perform several 'sanity' checks:
sanity(fit)

# Predict on the fitted data; see ?predict.sdmTMB
p &lt;- predict(fit)

# Predict on new data:
p &lt;- predict(fit, newdata = qcs_grid)
head(p)


# Visualize the depth effect with ggeffects:
ggeffects::ggpredict(fit,  "depth [all]") |&gt; plot()

# Visualize depth effect with visreg: (see ?visreg_delta)
visreg::visreg(fit, xvar = "depth") # link space; randomized quantile residuals
visreg::visreg(fit, xvar = "depth", scale = "response")
visreg::visreg(fit, xvar = "depth", scale = "response", gg = TRUE, rug = FALSE)

# Add spatiotemporal random fields:
fit &lt;- sdmTMB(
  density ~ 0 + as.factor(year),
  time = "year", #&lt;
  data = pcod_2011, mesh = mesh,
  family = tweedie(link = "log")
)
fit

# Make the fields AR1:
fit &lt;- sdmTMB(
  density ~ s(depth),
  time = "year",
  spatial = "off",
  spatiotemporal = "ar1", #&lt;
  data = pcod_2011, mesh = mesh,
  family = tweedie(link = "log")
)
fit

# Make the fields a random walk:
fit &lt;- sdmTMB(
  density ~ s(depth),
  time = "year",
  spatial = "off",
  spatiotemporal = "rw", #&lt;
  data = pcod_2011, mesh = mesh,
  family = tweedie(link = "log")
)
fit

# Depth smoothers by year:
fit &lt;- sdmTMB(
  density ~ s(depth, by = as.factor(year)), #&lt;
  time = "year",
  spatial = "off",
  spatiotemporal = "rw",
  data = pcod_2011, mesh = mesh,
  family = tweedie(link = "log")
)
fit

# 2D depth-year smoother:
fit &lt;- sdmTMB(
  density ~ s(depth, year), #&lt;
  spatial = "off",
  data = pcod_2011, mesh = mesh,
  family = tweedie(link = "log")
)
fit

# Turn off spatial random fields:
fit &lt;- sdmTMB(
  present ~ poly(log(depth)),
  spatial = "off", #&lt;
  data = pcod_2011, mesh = mesh,
  family = binomial()
)
fit

# Which, matches glm():
fit_glm &lt;- glm(
  present ~ poly(log(depth)),
  data = pcod_2011,
  family = binomial()
)
summary(fit_glm)
AIC(fit, fit_glm)

# Delta/hurdle binomial-Gamma model:
fit_dg &lt;- sdmTMB(
  density ~ poly(log(depth), 2),
  data = pcod_2011, mesh = mesh,
  spatial = "off",
  family = delta_gamma() #&lt;
)
fit_dg

# Delta model with different formulas and spatial structure:
fit_dg &lt;- sdmTMB(
  list(density ~ depth_scaled, density ~ poly(depth_scaled, 2)), #&lt;
  data = pcod_2011, mesh = mesh,
  spatial = list("off", "on"), #&lt;
  family = delta_gamma()
)
fit_dg

# Delta/hurdle truncated NB2:
pcod_2011$count &lt;- round(pcod_2011$density)
fit_nb2 &lt;- sdmTMB(
  count ~ s(depth),
  data = pcod_2011, mesh = mesh,
  spatial = "off",
  family = delta_truncated_nbinom2() #&lt;
)
fit_nb2

# Regular NB2:
fit_nb2 &lt;- sdmTMB(
  count ~ s(depth),
  data = pcod_2011, mesh = mesh,
  spatial = "off",
  family = nbinom2() #&lt;
)
fit_nb2

# IID random intercepts by year:
pcod_2011$fyear &lt;- as.factor(pcod_2011$year)
fit &lt;- sdmTMB(
  density ~ s(depth) + (1 | fyear), #&lt;
  data = pcod_2011, mesh = mesh,
  family = tweedie(link = "log")
)
fit

# Spatially varying coefficient of year:
pcod_2011$year_scaled &lt;- as.numeric(scale(pcod_2011$year))
fit &lt;- sdmTMB(
  density ~ year_scaled,
  spatial_varying = ~ 0 + year_scaled, #&lt;
  data = pcod_2011, mesh = mesh, family = tweedie(), time = "year"
)
fit

# Time-varying effects of depth and depth squared:
fit &lt;- sdmTMB(
  density ~ 0 + as.factor(year),
  time_varying = ~ 0 + depth_scaled + depth_scaled2, #&lt;
  data = pcod_2011, time = "year", mesh = mesh,
  family = tweedie()
)
print(fit)
# Extract values:
est &lt;- as.list(fit$sd_report, "Estimate")
se &lt;- as.list(fit$sd_report, "Std. Error")
est$b_rw_t[, , 1]
se$b_rw_t[, , 1]

# Linear break-point effect of depth:
fit &lt;- sdmTMB(
  density ~ breakpt(depth_scaled), #&lt;
  data = pcod_2011,
  mesh = mesh,
  family = tweedie()
)
fit


</code></pre>

<hr>
<h2 id='sdmTMB_cv'>Cross validation with sdmTMB models</h2><span id='topic+sdmTMB_cv'></span>

<h3>Description</h3>

<p>Facilitates cross validation with sdmTMB models. Returns the log likelihood
of left-out data, which is similar in spirit to the ELPD (expected log
pointwise predictive density). The function has an option for
leave-future-out cross validation. By default, the function creates folds
randomly but folds can be manually assigned via the <code>fold_ids</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdmTMB_cv(
  formula,
  data,
  mesh_args,
  mesh = NULL,
  time = NULL,
  k_folds = 8,
  fold_ids = NULL,
  lfo = FALSE,
  lfo_forecast = 1,
  lfo_validations = 5,
  parallel = TRUE,
  use_initial_fit = FALSE,
  future_globals = NULL,
  spde = deprecated(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdmTMB_cv_+3A_formula">formula</code></td>
<td>
<p>Model formula.</p>
</td></tr>
<tr><td><code id="sdmTMB_cv_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="sdmTMB_cv_+3A_mesh_args">mesh_args</code></td>
<td>
<p>Arguments for <code><a href="#topic+make_mesh">make_mesh()</a></code>. If supplied, the mesh will be
reconstructed for each fold.</p>
</td></tr>
<tr><td><code id="sdmTMB_cv_+3A_mesh">mesh</code></td>
<td>
<p>Output from <code><a href="#topic+make_mesh">make_mesh()</a></code>. If supplied, the mesh will be constant
across folds.</p>
</td></tr>
<tr><td><code id="sdmTMB_cv_+3A_time">time</code></td>
<td>
<p>The name of the time column. Leave as <code>NULL</code> if this is only
spatial data.</p>
</td></tr>
<tr><td><code id="sdmTMB_cv_+3A_k_folds">k_folds</code></td>
<td>
<p>Number of folds.</p>
</td></tr>
<tr><td><code id="sdmTMB_cv_+3A_fold_ids">fold_ids</code></td>
<td>
<p>Optional vector containing user fold IDs. Can also be a
single string, e.g. <code>"fold_id"</code> representing the name of the variable in
<code>data</code>. Ignored if <code>lfo</code> is TRUE</p>
</td></tr>
<tr><td><code id="sdmTMB_cv_+3A_lfo">lfo</code></td>
<td>
<p>Whether to implement leave-future-out (LFO) cross validation where
data are used to predict future folds. <code>time</code> argument in <code><a href="#topic+sdmTMB">sdmTMB()</a></code> must
be specified. See Details section below.</p>
</td></tr>
<tr><td><code id="sdmTMB_cv_+3A_lfo_forecast">lfo_forecast</code></td>
<td>
<p>If <code>lfo = TRUE</code>, number of time steps to forecast. Time
steps 1, ..., T are used to predict T + <code>lfo_forecast</code> and the last
forecasted time step is used for validation. See Details section below.</p>
</td></tr>
<tr><td><code id="sdmTMB_cv_+3A_lfo_validations">lfo_validations</code></td>
<td>
<p>If <code>lfo = TRUE</code>, number of times to step through the
LFOCV process. Defaults to 5. See Details section below.</p>
</td></tr>
<tr><td><code id="sdmTMB_cv_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code> and a <code><a href="future.html#topic+plan">future::plan()</a></code> is supplied, will be run in
parallel.</p>
</td></tr>
<tr><td><code id="sdmTMB_cv_+3A_use_initial_fit">use_initial_fit</code></td>
<td>
<p>Fit the first fold and use those parameter values
as starting values for subsequent folds? Can be faster with many folds.</p>
</td></tr>
<tr><td><code id="sdmTMB_cv_+3A_future_globals">future_globals</code></td>
<td>
<p>A character vector of global variables used within
arguments if an error is returned that <span class="pkg">future.apply</span> can't find an
object. This vector is appended to <code>TRUE</code> and passed to the argument
<code>future.globals</code> in <code><a href="future.apply.html#topic+future_lapply">future.apply::future_lapply()</a></code>. Useful if global
objects are used to specify arguments like priors, families, etc.</p>
</td></tr>
<tr><td><code id="sdmTMB_cv_+3A_spde">spde</code></td>
<td>
<p><strong>Depreciated.</strong> Use <code>mesh</code> instead.</p>
</td></tr>
<tr><td><code id="sdmTMB_cv_+3A_...">...</code></td>
<td>
<p>All other arguments required to run <code><a href="#topic+sdmTMB">sdmTMB()</a></code> model with the
exception of <code>weights</code>, which are used to define the folds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Parallel processing</strong>
</p>
<p>Parallel processing can be used by setting a <code>future::plan()</code>.
</p>
<p>For example:
</p>
<div class="sourceCode"><pre>library(future)
plan(multisession)
# now use sdmTMB_cv() ...
</pre></div>
<p><strong>Leave-future-out cross validation (LFOCV)</strong>
</p>
<p>An example of LFOCV with 9 time steps, <code>lfo_forecast = 1</code>, and
<code>lfo_validations = 2</code>:
</p>

<ul>
<li><p> Fit data to time steps 1 to 7, predict and validate step 8.
</p>
</li>
<li><p> Fit data to time steps 1 to 8, predict and validate step 9.
</p>
</li></ul>

<p>An example of LFOCV with 9 time steps, <code>lfo_forecast = 2</code>, and
<code>lfo_validations = 3</code>:
</p>

<ul>
<li><p> Fit data to time steps 1 to 5, predict and validate step 7.
</p>
</li>
<li><p> Fit data to time steps 1 to 6, predict and validate step 8.
</p>
</li>
<li><p> Fit data to time steps 1 to 7, predict and validate step 9.
</p>
</li></ul>

<p>See example below.
</p>


<h3>Value</h3>

<p>A list:
</p>

<ul>
<li> <p><code>data</code>: Original data plus columns for fold ID, CV predicted value,
and CV log likelihood.
</p>
</li>
<li> <p><code>models</code>: A list of models; one per fold.
</p>
</li>
<li> <p><code>fold_loglik</code>: Sum of left-out log likelihoods per fold. More positive
values are better.
</p>
</li>
<li> <p><code>sum_loglik</code>: Sum of <code>fold_loglik</code> across all left-out data. More positive
values are better.
</p>
</li>
<li> <p><code>pdHess</code>: Logical vector: Hessian was invertible each fold?
</p>
</li>
<li> <p><code>converged</code>: Logical: all <code>pdHess</code> <code>TRUE</code>?
</p>
</li>
<li> <p><code>max_gradients</code>: Max gradient per fold.
</p>
</li></ul>

<p>Prior to <span class="pkg">sdmTMB</span> version '0.3.0.9002', <code>elpd</code> was incorrectly returned as
the log average likelihood, which is another metric you could compare models
with, but not ELPD. For maximum likelihood, <a href="https://github.com/pbs-assess/sdmTMB/issues/235">ELPD is equivalent in spirit to the sum of the log likelihoods</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mesh &lt;- make_mesh(pcod, c("X", "Y"), cutoff = 25)

# Set parallel processing first if desired with the future package.
# See the Details section above.

m_cv &lt;- sdmTMB_cv(
  density ~ 0 + depth_scaled + depth_scaled2,
  data = pcod, mesh = mesh,
  family = tweedie(link = "log"), k_folds = 2
)

m_cv$fold_loglik
m_cv$sum_loglik

head(m_cv$data)
m_cv$models[[1]]
m_cv$max_gradients


# Create mesh each fold:
m_cv2 &lt;- sdmTMB_cv(
  density ~ 0 + depth_scaled + depth_scaled2,
  data = pcod, mesh_args = list(xy_cols = c("X", "Y"), cutoff = 20),
  family = tweedie(link = "log"), k_folds = 2
)

# Use fold_ids:
m_cv3 &lt;- sdmTMB_cv(
  density ~ 0 + depth_scaled + depth_scaled2,
  data = pcod, mesh = mesh,
  family = tweedie(link = "log"),
  fold_ids = rep(seq(1, 3), nrow(pcod))[seq(1, nrow(pcod))]
)

</code></pre>

<hr>
<h2 id='sdmTMB_simulate'>Simulate from a spatial/spatiotemporal model</h2><span id='topic+sdmTMB_simulate'></span>

<h3>Description</h3>

<p><code>sdmTMB_simulate()</code> uses TMB to simulate <em>new</em> data given specified parameter
values. <code><a href="#topic+simulate.sdmTMB">simulate.sdmTMB()</a></code>, on the other hand, takes an <em>existing</em> model fit
and simulates new observations and optionally new random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdmTMB_simulate(
  formula,
  data,
  mesh,
  family = gaussian(link = "identity"),
  time = NULL,
  B = NULL,
  range = NULL,
  rho = NULL,
  sigma_O = NULL,
  sigma_E = NULL,
  sigma_Z = NULL,
  phi = NULL,
  tweedie_p = NULL,
  df = NULL,
  threshold_coefs = NULL,
  fixed_re = list(omega_s = NULL, epsilon_st = NULL, zeta_s = NULL),
  previous_fit = NULL,
  seed = sample.int(1e+06, 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdmTMB_simulate_+3A_formula">formula</code></td>
<td>
<p>A <em>one-sided</em> formula describing the fixed-effect structure.
Random intercepts are not (yet) supported. Fixed effects should match
the corresponding <code>B</code> argument vector of coefficient values.</p>
</td></tr>
<tr><td><code id="sdmTMB_simulate_+3A_data">data</code></td>
<td>
<p>A data frame containing the predictors described in <code>formula</code> and
the time column if <code>time</code> is specified.</p>
</td></tr>
<tr><td><code id="sdmTMB_simulate_+3A_mesh">mesh</code></td>
<td>
<p>Output from <code><a href="#topic+make_mesh">make_mesh()</a></code>.</p>
</td></tr>
<tr><td><code id="sdmTMB_simulate_+3A_family">family</code></td>
<td>
<p>Family as in <code><a href="#topic+sdmTMB">sdmTMB()</a></code>. Delta families are not supported.
Instead, simulate the two component models separately and combine.</p>
</td></tr>
<tr><td><code id="sdmTMB_simulate_+3A_time">time</code></td>
<td>
<p>The time column name.</p>
</td></tr>
<tr><td><code id="sdmTMB_simulate_+3A_b">B</code></td>
<td>
<p>A vector of beta values (fixed-effect coefficient values).</p>
</td></tr>
<tr><td><code id="sdmTMB_simulate_+3A_range">range</code></td>
<td>
<p>Parameter that controls the decay of spatial correlation. If a
vector of length 2, <code>share_range</code> will be set to <code>FALSE</code> and the spatial
and spatiotemporal ranges will be unique.</p>
</td></tr>
<tr><td><code id="sdmTMB_simulate_+3A_rho">rho</code></td>
<td>
<p>Spatiotemporal correlation between years; should be between -1 and
1.</p>
</td></tr>
<tr><td><code id="sdmTMB_simulate_+3A_sigma_o">sigma_O</code></td>
<td>
<p>SD of spatial process (Omega).</p>
</td></tr>
<tr><td><code id="sdmTMB_simulate_+3A_sigma_e">sigma_E</code></td>
<td>
<p>SD of spatiotemporal process (Epsilon).</p>
</td></tr>
<tr><td><code id="sdmTMB_simulate_+3A_sigma_z">sigma_Z</code></td>
<td>
<p>SD of spatially varying coefficient field (Zeta).</p>
</td></tr>
<tr><td><code id="sdmTMB_simulate_+3A_phi">phi</code></td>
<td>
<p>Observation error scale parameter (e.g., SD in Gaussian).</p>
</td></tr>
<tr><td><code id="sdmTMB_simulate_+3A_tweedie_p">tweedie_p</code></td>
<td>
<p>Tweedie p (power) parameter; between 1 and 2.</p>
</td></tr>
<tr><td><code id="sdmTMB_simulate_+3A_df">df</code></td>
<td>
<p>Student-t degrees of freedom.</p>
</td></tr>
<tr><td><code id="sdmTMB_simulate_+3A_threshold_coefs">threshold_coefs</code></td>
<td>
<p>An optional vector of threshold coefficient values
if the <code>formula</code> includes <code>breakpt()</code> or <code>logistic()</code>. If <code>breakpt()</code>,
these are slope and cut values. If <code>logistic()</code>, these are the threshold at
which the function is 50% of the maximum, the threshold at which the
function is 95% of the maximum, and the maximum. See the model description
vignette for details.</p>
</td></tr>
<tr><td><code id="sdmTMB_simulate_+3A_fixed_re">fixed_re</code></td>
<td>
<p>A list of optional random effects to fix at specified
(e.g., previously estimated) values. Values of <code>NULL</code> will result
in the random effects being simulated.</p>
</td></tr>
<tr><td><code id="sdmTMB_simulate_+3A_previous_fit">previous_fit</code></td>
<td>
<p>(<strong>Deprecated</strong>; please use <code><a href="#topic+simulate.sdmTMB">simulate.sdmTMB()</a></code>).
An optional previous <code><a href="#topic+sdmTMB">sdmTMB()</a></code> fit to pull parameter values.
Will be over-ruled by any non-NULL specified parameter arguments.</p>
</td></tr>
<tr><td><code id="sdmTMB_simulate_+3A_seed">seed</code></td>
<td>
<p>Seed number.</p>
</td></tr>
<tr><td><code id="sdmTMB_simulate_+3A_...">...</code></td>
<td>
<p>Any other arguments to pass to <code><a href="#topic+sdmTMB">sdmTMB()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame where:
</p>

<ul>
<li><p> The 1st column is the time variable (if present).
</p>
</li>
<li><p> The 2nd and 3rd columns are the spatial coordinates.
</p>
</li>
<li> <p><code>omega_s</code> represents the simulated spatial random effects (only if present).
</p>
</li>
<li> <p><code>zeta_s</code> represents the simulated spatial varying covariate field (only if present).
</p>
</li>
<li> <p><code>epsilon_st</code> represents the simulated spatiotemporal random effects (only if present).
</p>
</li>
<li> <p><code>eta</code> is the true value in link space
</p>
</li>
<li> <p><code>mu</code> is the true value in inverse link space.
</p>
</li>
<li> <p><code>observed</code> represents the simulated process with observation error.
</p>
</li>
<li><p> The remaining columns are the fixed-effect model matrix.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+simulate.sdmTMB">simulate.sdmTMB()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(123)

  # make fake predictor(s) (a1) and sampling locations:
  predictor_dat &lt;- data.frame(
    X = runif(300), Y = runif(300),
    a1 = rnorm(300), year = rep(1:6, each = 50)
  )
  mesh &lt;- make_mesh(predictor_dat, xy_cols = c("X", "Y"), cutoff = 0.1)

  sim_dat &lt;- sdmTMB_simulate(
    formula = ~ 1 + a1,
    data = predictor_dat,
    time = "year",
    mesh = mesh,
    family = gaussian(),
    range = 0.5,
    sigma_E = 0.1,
    phi = 0.1,
    sigma_O = 0.2,
    seed = 42,
    B = c(0.2, -0.4) # B0 = intercept, B1 = a1 slope
  )
  head(sim_dat)

  if (require("ggplot2", quietly = TRUE)) {
    ggplot(sim_dat, aes(X, Y, colour = observed)) +
      geom_point() +
      facet_wrap(~year) +
      scale_color_gradient2()
  }

  # fit to the simulated data:
  fit &lt;- sdmTMB(observed ~ a1, data = sim_dat, mesh = mesh, time = "year")
  fit
</code></pre>

<hr>
<h2 id='sdmTMB_stacking'>Perform stacking with log scores on <code>sdmTMB_cv()</code> output</h2><span id='topic+sdmTMB_stacking'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>This approach is described in Yao et al. (2018) <a href="https://doi.org/10.1214/17-BA1091">doi:10.1214/17-BA1091</a>. The
general method minimizes (or maximizes) some quantity across models. For
simple models with normal error, this may be the root mean squared error
(RMSE), but other approaches include the log score. We adopt the latter here,
where log scores are used to generate the stacking of predictive
distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdmTMB_stacking(model_list, include_folds = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdmTMB_stacking_+3A_model_list">model_list</code></td>
<td>
<p>A list of models fit with <code><a href="#topic+sdmTMB_cv">sdmTMB_cv()</a></code> to generate
estimates of predictive densities. You will want to set the seed
to the same value before fitting each model or manually construct
the fold IDs so that they are the same across models.</p>
</td></tr>
<tr><td><code id="sdmTMB_stacking_+3A_include_folds">include_folds</code></td>
<td>
<p>An optional numeric vector specifying which folds to
include in the calculations. For example, if 5 folds are used for k-fold
cross validation, and the first 4 are needed to generate these weights,
<code>include_folds = 1:4</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of model weights.
</p>


<h3>References</h3>

<p>Yao, Y., Vehtari, A., Simpson, D., and Gelman, A. 2018. Using Stacking to
Average Bayesian Predictive Distributions (with Discussion). Bayesian Analysis
13(3): 917–1007. International Society for Bayesian Analysis.
<a href="https://doi.org/10.1214/17-BA1091">doi:10.1214/17-BA1091</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set parallel processing if desired. See 'Details' in ?sdmTMB_cv

# Depth as quadratic:
set.seed(1)
m_cv_1 &lt;- sdmTMB_cv(
  density ~ 0 + depth_scaled + depth_scaled2,
  data = pcod_2011, mesh = pcod_mesh_2011,
  family = tweedie(link = "log"), k_folds = 2
)
# Depth as linear:
set.seed(1)
m_cv_2 &lt;- sdmTMB_cv(
  density ~ 0 + depth_scaled,
  data = pcod_2011, mesh = pcod_mesh_2011,
  family = tweedie(link = "log"), k_folds = 2
)

# Only an intercept:
set.seed(1)
m_cv_3 &lt;- sdmTMB_cv(
  density ~ 1,
  data = pcod_2011, mesh = pcod_mesh_2011,
  family = tweedie(link = "log"), k_folds = 2
)

models &lt;- list(m_cv_1, m_cv_2, m_cv_3)
weights &lt;- sdmTMB_stacking(models)
weights

</code></pre>

<hr>
<h2 id='sdmTMBcontrol'>Optimization control options</h2><span id='topic+sdmTMBcontrol'></span>

<h3>Description</h3>

<p><code><a href="#topic+sdmTMB">sdmTMB()</a></code> and <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code> control options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdmTMBcontrol(
  eval.max = 2000L,
  iter.max = 1000L,
  normalize = FALSE,
  nlminb_loops = 1L,
  newton_loops = 1L,
  mgcv = deprecated(),
  quadratic_roots = FALSE,
  start = NULL,
  map_rf = deprecated(),
  map = NULL,
  lower = NULL,
  upper = NULL,
  censored_upper = NULL,
  multiphase = TRUE,
  profile = FALSE,
  get_joint_precision = TRUE,
  parallel = getOption("sdmTMB.cores", 1L),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdmTMBcontrol_+3A_eval.max">eval.max</code></td>
<td>
<p>Maximum number of evaluations of the objective function
allowed.</p>
</td></tr>
<tr><td><code id="sdmTMBcontrol_+3A_iter.max">iter.max</code></td>
<td>
<p>Maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="sdmTMBcontrol_+3A_normalize">normalize</code></td>
<td>
<p>Logical: use <code><a href="TMB.html#topic+normalize">TMB::normalize()</a></code> to normalize the process
likelihood using the Laplace approximation? Can result in a substantial
speed boost in some cases. This used to default to <code>FALSE</code> prior to
May 2021. Currently not working for models fit with REML or random intercepts.</p>
</td></tr>
<tr><td><code id="sdmTMBcontrol_+3A_nlminb_loops">nlminb_loops</code></td>
<td>
<p>How many times to run <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code> optimization.
Sometimes restarting the optimizer at the previous best values aids
convergence. If the maximum gradient is still too large,
try increasing this to <code>2</code>.</p>
</td></tr>
<tr><td><code id="sdmTMBcontrol_+3A_newton_loops">newton_loops</code></td>
<td>
<p>How many Newton optimization steps to try after running
<code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>. This sometimes aids convergence by further reducing the
log-likelihood gradient with respect to the fixed effects. This calculates
the Hessian at the current MLE with <code><a href="stats.html#topic+optim">stats::optimHess()</a></code> using a
finite-difference approach and uses this to update the fixed effect
estimates.</p>
</td></tr>
<tr><td><code id="sdmTMBcontrol_+3A_mgcv">mgcv</code></td>
<td>
<p><strong>Deprecated</strong> Parse the formula with <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>?</p>
</td></tr>
<tr><td><code id="sdmTMBcontrol_+3A_quadratic_roots">quadratic_roots</code></td>
<td>
<p>Experimental feature for internal use right now; may
be moved to a branch. Logical: should quadratic roots be calculated? Note:
on the sdmTMB side, the first two coefficients are used to generate the
quadratic parameters. This means that if you want to generate a quadratic
profile for depth, and depth and depth^2 are part of your formula, you need
to make sure these are listed first and that an intercept isn't included.
For example, <code>formula = cpue ~ 0 + depth + depth2 + as.factor(year)</code>.</p>
</td></tr>
<tr><td><code id="sdmTMBcontrol_+3A_start">start</code></td>
<td>
<p>A named list specifying the starting values for parameters. You
can see the necessary structure by fitting the model once and inspecting
<code>your_model$tmb_obj$env$parList()</code>. Elements of <code>start</code> that are specified
will replace the default starting values.</p>
</td></tr>
<tr><td><code id="sdmTMBcontrol_+3A_map_rf">map_rf</code></td>
<td>
<p><strong>Deprecated</strong> use <code style="white-space: pre;">&#8288;spatial = 'off', spatiotemporal = 'off'&#8288;</code> in
<code><a href="#topic+sdmTMB">sdmTMB()</a></code>.</p>
</td></tr>
<tr><td><code id="sdmTMBcontrol_+3A_map">map</code></td>
<td>
<p>A named list with factor <code>NA</code>s specifying parameter values that
should be fixed at a constant value. See the documentation in
<code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>. This should usually be used with <code>start</code> to specify the
fixed value.</p>
</td></tr>
<tr><td><code id="sdmTMBcontrol_+3A_lower">lower</code></td>
<td>
<p>An optional named list of lower bounds within the optimization.
Parameter vectors with the same name (e.g., <code>b_j</code> or <code>ln_kappa</code> in some
cases) can be specified as a numeric vector. E.g.
<code>lower = list(b_j = c(-5, -5))</code>.</p>
</td></tr>
<tr><td><code id="sdmTMBcontrol_+3A_upper">upper</code></td>
<td>
<p>An optional named list of upper bounds within the optimization.</p>
</td></tr>
<tr><td><code id="sdmTMBcontrol_+3A_censored_upper">censored_upper</code></td>
<td>
<p>An optional vector of upper bounds for
<code><a href="#topic+sdmTMBcontrol">sdmTMBcontrol()</a></code>. Values of <code>NA</code> indicate an unbounded right-censored to
distribution, values greater that the observation indicate and upper bound,
and values equal to the observation indicate no censoring.</p>
</td></tr>
<tr><td><code id="sdmTMBcontrol_+3A_multiphase">multiphase</code></td>
<td>
<p>Logical: estimate the fixed and random effects in phases?
Phases are usually faster and more stable.</p>
</td></tr>
<tr><td><code id="sdmTMBcontrol_+3A_profile">profile</code></td>
<td>
<p>Logical: should population-level/fixed effects be profiled
out of the likelihood? These are then appended to the random effects
vector without the Laplace approximation. See <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>. <em>This
can dramatically speed up model fit if there are many fixed effects but is
experimental at this stage.</em></p>
</td></tr>
<tr><td><code id="sdmTMBcontrol_+3A_get_joint_precision">get_joint_precision</code></td>
<td>
<p>Logical. Passed to <code>getJointPrecision</code> in
<code><a href="TMB.html#topic+sdreport">TMB::sdreport()</a></code>. Must be <code>TRUE</code> to use simulation-based methods in
<code><a href="#topic+predict.sdmTMB">predict.sdmTMB()</a></code> or <code style="white-space: pre;">&#8288;[get_index_sims()]&#8288;</code>. If not needed, setting this
<code>FALSE</code> will reduce object size.</p>
</td></tr>
<tr><td><code id="sdmTMBcontrol_+3A_parallel">parallel</code></td>
<td>
<p>Argument currently ignored. For parallel processing with 3
cores, as an example, use <code>TMB::openmp(n = 3, DLL = "sdmTMB")</code>. But be
careful, because it's not always faster with more cores and there is
definitely an upper limit.</p>
</td></tr>
<tr><td><code id="sdmTMBcontrol_+3A_...">...</code></td>
<td>
<p>Anything else. See the 'Control parameters' section of
<code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually used within <code><a href="#topic+sdmTMB">sdmTMB()</a></code>. For example:
</p>
<div class="sourceCode"><pre>sdmTMB(..., control = sdmTMBcontrol(newton_loops = 2))
</pre></div>


<h3>Value</h3>

<p>A list of control arguments
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sdmTMBcontrol()
</code></pre>

<hr>
<h2 id='sdmTMBpriors'>Prior distributions</h2><span id='topic+sdmTMBpriors'></span><span id='topic+normal'></span><span id='topic+halfnormal'></span><span id='topic+mvnormal'></span><span id='topic+pc_matern'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Optional priors/penalties on model parameters. This results in penalized
likelihood within TMB or can be used as priors if the model is passed to
<span class="pkg">tmbstan</span> (see the Bayesian vignette).
</p>
<p><strong>Note that Jacobian adjustments are only made if <code>bayesian = TRUE</code></strong> when the
<code><a href="#topic+sdmTMB">sdmTMB()</a></code> model is fit. I.e., the final model will be fit with <span class="pkg">tmbstan</span>
and priors are specified then <code>bayesian</code> should be set to <code>TRUE</code>. Otherwise,
leave <code>bayesian = FALSE</code>.
</p>
<p><code>pc_matern()</code> is the Penalized Complexity prior for the Matern
covariance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdmTMBpriors(
  matern_s = pc_matern(range_gt = NA, sigma_lt = NA),
  matern_st = pc_matern(range_gt = NA, sigma_lt = NA),
  phi = halfnormal(NA, NA),
  ar1_rho = normal(NA, NA),
  tweedie_p = normal(NA, NA),
  b = normal(NA, NA),
  sigma_G = halfnormal(NA, NA)
)

normal(location = 0, scale = 1)

halfnormal(location = 0, scale = 1)

mvnormal(location = 0, scale = diag(length(location)))

pc_matern(range_gt, sigma_lt, range_prob = 0.05, sigma_prob = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdmTMBpriors_+3A_matern_s">matern_s</code></td>
<td>
<p>A PC (Penalized Complexity) prior (<code>pc_matern()</code>) on the
spatial random field Matérn parameters.</p>
</td></tr>
<tr><td><code id="sdmTMBpriors_+3A_matern_st">matern_st</code></td>
<td>
<p>Same as <code>matern_s</code> but for the spatiotemporal random field.
Note that you will likely want to set <code>share_fields = FALSE</code> if you choose
to set both a spatial and spatiotemporal Matérn PC prior since they both
include a prior on the spatial range parameter.</p>
</td></tr>
<tr><td><code id="sdmTMBpriors_+3A_phi">phi</code></td>
<td>
<p>A <code>halfnormal()</code> prior for the dispersion parameter in the
observation distribution.</p>
</td></tr>
<tr><td><code id="sdmTMBpriors_+3A_ar1_rho">ar1_rho</code></td>
<td>
<p>A <code>normal()</code> prior for the AR1 random field parameter. Note
the parameter has support <code style="white-space: pre;">&#8288;-1 &lt; ar1_rho &lt; 1&#8288;</code>.</p>
</td></tr>
<tr><td><code id="sdmTMBpriors_+3A_tweedie_p">tweedie_p</code></td>
<td>
<p>A <code>normal()</code> prior for the Tweedie power parameter. Note the
parameter has support <code style="white-space: pre;">&#8288;1 &lt; tweedie_p &lt; 2&#8288;</code> so choose a mean appropriately.</p>
</td></tr>
<tr><td><code id="sdmTMBpriors_+3A_b">b</code></td>
<td>
<p><code>normal()</code> priors for the main population-level 'beta' effects.</p>
</td></tr>
<tr><td><code id="sdmTMBpriors_+3A_sigma_g">sigma_G</code></td>
<td>
<p><code>halfnormal()</code> priors for the random intercept SDs.</p>
</td></tr>
<tr><td><code id="sdmTMBpriors_+3A_location">location</code></td>
<td>
<p>Location parameter(s).</p>
</td></tr>
<tr><td><code id="sdmTMBpriors_+3A_scale">scale</code></td>
<td>
<p>Scale parameter. For <code>normal()</code>/<code>halfnormal()</code>: standard
deviation(s). For <code>mvnormal()</code>: variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="sdmTMBpriors_+3A_range_gt">range_gt</code></td>
<td>
<p>A value one expects the spatial or spatiotemporal range is
<strong>g</strong>reater <strong>t</strong>han with <code>1 - range_prob</code> probability.</p>
</td></tr>
<tr><td><code id="sdmTMBpriors_+3A_sigma_lt">sigma_lt</code></td>
<td>
<p>A value one expects the spatial or spatiotemporal marginal
standard deviation (<code>sigma_O</code> or <code>sigma_E</code> internally) is <strong>l</strong>ess <strong>t</strong>han
with <code>1 - sigma_prob</code> probability.</p>
</td></tr>
<tr><td><code id="sdmTMBpriors_+3A_range_prob">range_prob</code></td>
<td>
<p>Probability. See description for <code>range_gt</code>.</p>
</td></tr>
<tr><td><code id="sdmTMBpriors_+3A_sigma_prob">sigma_prob</code></td>
<td>
<p>Probability. See description for <code>sigma_lt</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Meant to be passed to the <code>priors</code> argument in <code><a href="#topic+sdmTMB">sdmTMB()</a></code>.
</p>
<p><code>normal()</code> and <code>halfnormal()</code> define normal and half-normal priors that, at
this point, must have a location (mean) parameter of 0. <code>halfnormal()</code> is the
same as <code>normal()</code> but can be used to make the syntax clearer. It is intended
to be used for parameters that have support <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code>.
</p>
<p>See <a href="https://arxiv.org/abs/1503.00256">https://arxiv.org/abs/1503.00256</a> for a description of the
PC prior for Gaussian random fields. Quoting the discussion (and substituting
the argument names in <code>pc_matern()</code>):
&quot;In the simulation study we observe good coverage of the equal-tailed 95%
credible intervals when the prior satisfies <code>P(sigma &gt; sigma_lt) = 0.05</code> and
<code>P(range &lt; range_gt) = 0.05</code>, where <code>sigma_lt</code> is between 2.5 to 40 times
the true marginal standard deviation and <code>range_gt</code> is between 1/10 and 1/2.5
of the true range.&quot;
</p>
<p>Keep in mind that the range is dependent on the units and scale of the
coordinate system. In practice, you may choose to try fitting the model
without a PC prior and then constraining the model from there. A better
option would be to simulate from a model with a given range and sigma to
choose reasonable values for the system or base the prior on knowledge from a
model fit to a similar system but with more spatial information in the data.
</p>


<h3>Value</h3>

<p>A named list with values for the specified priors.
</p>


<h3>References</h3>

<p>Fuglstad, G.-A., Simpson, D., Lindgren, F., and Rue, H. (2016) Constructing
Priors that Penalize the Complexity of Gaussian Random Fields.
arXiv:1503.00256
</p>
<p>Simpson, D., Rue, H., Martins, T., Riebler, A., and Sørbye, S. (2015)
Penalising model component complexity: A principled, practical approach to
constructing priors. arXiv:1403.4630
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_pc_matern">plot_pc_matern()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normal(0, 1)
halfnormal(0, 1)
mvnormal(c(0, 0))
pc_matern(range_gt = 5, sigma_lt = 1)
plot_pc_matern(range_gt = 5, sigma_lt = 1)


d &lt;- subset(pcod, year &gt; 2011)
pcod_spde &lt;- make_mesh(d, c("X", "Y"), cutoff = 30)

# - no priors on population-level effects (`b`)
# - halfnormal(0, 10) prior on dispersion parameter `phi`
# - Matern PC priors on spatial `matern_s` and spatiotemporal
#   `matern_st` random field parameters
m &lt;- sdmTMB(density ~ s(depth, k = 3),
  data = d, mesh = pcod_spde, family = tweedie(),
  share_range = FALSE, time = "year",
  priors = sdmTMBpriors(
    phi = halfnormal(0, 10),
    matern_s = pc_matern(range_gt = 5, sigma_lt = 1),
    matern_st = pc_matern(range_gt = 5, sigma_lt = 1)
  )
)

# - no prior on intercept
# - normal(0, 1) prior on depth coefficient
# - no prior on the dispersion parameter `phi`
# - Matern PC prior
m &lt;- sdmTMB(density ~ depth_scaled,
  data = d, mesh = pcod_spde, family = tweedie(),
  spatiotemporal = "off",
  priors = sdmTMBpriors(
    b = normal(c(NA, 0), c(NA, 1)),
    matern_s = pc_matern(range_gt = 5, sigma_lt = 1)
  )
)

# You get a prior, you get a prior, you get a prior!
# (except on the annual means; see the `NA`s)
m &lt;- sdmTMB(density ~ 0 + depth_scaled + depth_scaled2 + as.factor(year),
  data = d, time = "year", mesh = pcod_spde, family = tweedie(link = "log"),
  share_range = FALSE, spatiotemporal = "AR1",
  priors = sdmTMBpriors(
    b = normal(c(0, 0, NA, NA, NA), c(2, 2, NA, NA, NA)),
    phi = halfnormal(0, 10),
    # tweedie_p = normal(1.5, 2),
    ar1_rho = normal(0, 1),
    matern_s = pc_matern(range_gt = 5, sigma_lt = 1),
    matern_st = pc_matern(range_gt = 5, sigma_lt = 1))
)

</code></pre>

<hr>
<h2 id='set_delta_model'>Set delta model for <code><a href="ggeffects.html#topic+ggpredict">ggeffects::ggpredict()</a></code></h2><span id='topic+set_delta_model'></span>

<h3>Description</h3>

<p>Set a delta model component to predict from with <code><a href="ggeffects.html#topic+ggpredict">ggeffects::ggpredict()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_delta_model(x, model = c(NA, 1, 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_delta_model_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+sdmTMB">sdmTMB()</a></code> model fit with a delta family such as
<code><a href="#topic+delta_gamma">delta_gamma()</a></code>.</p>
</td></tr>
<tr><td><code id="set_delta_model_+3A_model">model</code></td>
<td>
<p>Which delta/hurdle model component to predict/plot with.
<code>NA</code> does the combined prediction, <code>1</code> does the binomial part, and <code>2</code>
does the positive part.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A complete version of the examples below would be:
</p>
<div class="sourceCode"><pre>fit &lt;- sdmTMB(density ~ poly(depth_scaled, 2), data = pcod_2011,
  spatial = "off", family = delta_gamma())

# binomial part:
set_delta_model(fit, model = 1) |&gt;
  ggeffects::ggpredict("depth_scaled [all]")

# gamma part:
set_delta_model(fit, model = 2) |&gt;
  ggeffects::ggpredict("depth_scaled [all]")

# combined:
set_delta_model(fit, model = NA) |&gt;
  ggeffects::ggpredict("depth_scaled [all]")
</pre></div>
<p>But cannot be run on CRAN until a version of <span class="pkg">ggeffects</span> &gt; 1.3.2
is on CRAN. For now, you can install the GitHub version of <span class="pkg">ggeffects</span>.
<a href="https://github.com/strengejacke/ggeffects">https://github.com/strengejacke/ggeffects</a>.
</p>


<h3>Value</h3>

<p>The fitted model with a new attribute named <code>delta_model_predict</code>.
We suggest you use <code>set_delta_model()</code> in a pipe (as in the examples)
so that this attribute does not persist. Otherwise, <code><a href="#topic+predict.sdmTMB">predict.sdmTMB()</a></code>
will choose this model component by default. You can also remove the
attribute yourself after:
</p>
<div class="sourceCode"><pre>attr(fit, "delta_model_predict") &lt;- NULL
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>
fit &lt;- sdmTMB(density ~ poly(depth_scaled, 2), data = pcod_2011,
  spatial = "off", family = delta_gamma())

# binomial part:
set_delta_model(fit, model = 1)

# gamma part:
set_delta_model(fit, model = 2)

# combined:
set_delta_model(fit, model = NA)

</code></pre>

<hr>
<h2 id='simulate.sdmTMB'>Simulate from a fitted sdmTMB model</h2><span id='topic+simulate.sdmTMB'></span>

<h3>Description</h3>

<p><code>simulate.sdmTMB</code> is an S3 method for producing a matrix of simulations from
a fitted model. This is similar to <code><a href="lme4.html#topic+simulate.merMod">lme4::simulate.merMod()</a></code> and
<code><a href="glmmTMB.html#topic+simulate.glmmTMB">glmmTMB::simulate.glmmTMB()</a></code>. It can be used with the <span class="pkg">DHARMa</span> package
among other uses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sdmTMB'
simulate(
  object,
  nsim = 1L,
  seed = sample.int(1e+06, 1L),
  type = c("mle-eb", "mle-mvn"),
  model = c(NA, 1, 2),
  re_form = NULL,
  mcmc_samples = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.sdmTMB_+3A_object">object</code></td>
<td>
<p>sdmTMB model</p>
</td></tr>
<tr><td><code id="simulate.sdmTMB_+3A_nsim">nsim</code></td>
<td>
<p>Number of response lists to simulate. Defaults to 1.</p>
</td></tr>
<tr><td><code id="simulate.sdmTMB_+3A_seed">seed</code></td>
<td>
<p>Random number seed</p>
</td></tr>
<tr><td><code id="simulate.sdmTMB_+3A_type">type</code></td>
<td>
<p>How parameters should be treated. <code>"mle-eb"</code>: fixed effects
are at their maximum likelihood (MLE) estimates  and random effects are at
their empirical Bayes (EB) estimates. <code>"mle-mvn"</code>: fixed effects are at
their MLEs but random effects are taken from a single approximate sample.
This latter option is a suggested approach if these simulations will be
used for goodness of fit testing (e.g., with the DHARMa package).</p>
</td></tr>
<tr><td><code id="simulate.sdmTMB_+3A_model">model</code></td>
<td>
<p>If a delta/hurdle model, which model to simulate from?
<code>NA</code> = combined, <code>1</code> = first model, <code>2</code> = second mdoel.</p>
</td></tr>
<tr><td><code id="simulate.sdmTMB_+3A_re_form">re_form</code></td>
<td>
<p><code>NULL</code> to specify a simulation conditional on fitted random
effects (this only simulates observation error). <code>~0</code> or <code>NA</code> to simulate
new random affects (smoothers, which internally are random effects, will
not be simulated as new).</p>
</td></tr>
<tr><td><code id="simulate.sdmTMB_+3A_mcmc_samples">mcmc_samples</code></td>
<td>
<p>An optional matrix of MCMC samples. See <code>extract_mcmc()</code>
in the <a href="https://github.com/pbs-assess/sdmTMBextra">sdmTMBextra</a>
package.</p>
</td></tr>
<tr><td><code id="simulate.sdmTMB_+3A_...">...</code></td>
<td>
<p>Extra arguments (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix; number of columns is <code>nsim</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sdmTMB_simulate">sdmTMB_simulate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# start with some data simulated from scratch:
set.seed(1)
predictor_dat &lt;- data.frame(X = runif(300), Y = runif(300), a1 = rnorm(300))
mesh &lt;- make_mesh(predictor_dat, xy_cols = c("X", "Y"), cutoff = 0.1)
dat &lt;- sdmTMB_simulate(
  formula = ~ 1 + a1,
  data = predictor_dat,
  mesh = mesh,
  family = poisson(),
  range = 0.5,
  sigma_O = 0.2,
  seed = 42,
  B = c(0.2, -0.4) # B0 = intercept, B1 = a1 slope
)
fit &lt;- sdmTMB(observed ~ 1 + a1, data = dat, family = poisson(), mesh = mesh)

# simulate from the model:
s1 &lt;- simulate(fit, nsim = 300)
dim(s1)

# test whether fitted models are consistent with the observed number of zeros:
sum(s1 == 0)/length(s1)
sum(dat$observed == 0) / length(dat$observed)

# simulate with random effects sampled from their approximate posterior
s2 &lt;- simulate(fit, nsim = 1, params = "mle-mvn")
# these may be useful in conjunction with DHARMa simulation-based residuals

# simulate with new random fields:
s3 &lt;- simulate(fit, nsim = 1, re_form = ~ 0)
</code></pre>

<hr>
<h2 id='spread_sims'>Extract parameter simulations from the joint precision matrix</h2><span id='topic+spread_sims'></span><span id='topic+gather_sims'></span>

<h3>Description</h3>

<p><code>spread_sims()</code> returns a wide-format data frame. <code>gather_sims()</code> returns a
long-format data frame. The format matches the format in the <span class="pkg">tidybayes</span>
<code>spread_draws()</code> and <code>gather_draws()</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spread_sims(object, nsim = 200, n_sims = deprecated())

gather_sims(object, nsim = 200, n_sims = deprecated())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spread_sims_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+sdmTMB">sdmTMB()</a></code>.</p>
</td></tr>
<tr><td><code id="spread_sims_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulation draws.</p>
</td></tr>
<tr><td><code id="spread_sims_+3A_n_sims">n_sims</code></td>
<td>
<p>Deprecated: please use <code>nsim</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame. <code>gather_sims()</code> returns a long-format data frame:
</p>

<ul>
<li> <p><code>.iteration</code>: the sample ID
</p>
</li>
<li> <p><code>.variable</code>: the parameter name
</p>
</li>
<li> <p><code>.value</code>: the parameter sample value
</p>
</li></ul>

<p><code>spread_sims()</code> returns a wide-format data frame:
</p>

<ul>
<li> <p><code>.iteration</code>: the sample ID
</p>
</li>
<li><p> columns for each parameter with a sample per row
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- sdmTMB(density ~ depth_scaled,
  data = pcod_2011, mesh = pcod_mesh_2011, family = tweedie())
head(spread_sims(m, nsim = 10))
head(gather_sims(m, nsim = 10))
samps &lt;- gather_sims(m, nsim = 1000)

if (require("ggplot2", quietly = TRUE)) {
  ggplot(samps, aes(.value)) + geom_histogram() +
    facet_wrap(~.variable, scales = "free_x")
}
</code></pre>

<hr>
<h2 id='tidy.sdmTMB'>Turn sdmTMB model output into a tidy data frame</h2><span id='topic+tidy.sdmTMB'></span>

<h3>Description</h3>

<p>Turn sdmTMB model output into a tidy data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sdmTMB'
tidy(
  x,
  effects = c("fixed", "ran_pars", "ran_vals"),
  model = 1,
  conf.int = FALSE,
  conf.level = 0.95,
  exponentiate = FALSE,
  silent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.sdmTMB_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+sdmTMB">sdmTMB()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.sdmTMB_+3A_effects">effects</code></td>
<td>
<p>A character value. One of <code>"fixed"</code> ('fixed' or main-effect
parameters), <code>"ran_pars"</code> (standard deviations, spatial range, and other
random effect and dispersion-related terms), or <code>"ran_vals"</code> (individual
random intercepts, if included; behaves like <code>ranef()</code>).</p>
</td></tr>
<tr><td><code id="tidy.sdmTMB_+3A_model">model</code></td>
<td>
<p>Which model to tidy if a delta model (1 or 2).</p>
</td></tr>
<tr><td><code id="tidy.sdmTMB_+3A_conf.int">conf.int</code></td>
<td>
<p>Include a confidence interval?</p>
</td></tr>
<tr><td><code id="tidy.sdmTMB_+3A_conf.level">conf.level</code></td>
<td>
<p>Confidence level for CI.</p>
</td></tr>
<tr><td><code id="tidy.sdmTMB_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Whether to exponentiate the fixed-effect coefficient
estimates and confidence intervals.</p>
</td></tr>
<tr><td><code id="tidy.sdmTMB_+3A_silent">silent</code></td>
<td>
<p>Omit any messages?</p>
</td></tr>
<tr><td><code id="tidy.sdmTMB_+3A_...">...</code></td>
<td>
<p>Extra arguments (not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Follows the conventions of the <span class="pkg">broom</span> and <span class="pkg">broom.mixed</span> packages.
</p>
<p>Currently, <code>effects = "ran_pars"</code> also includes dispersion-related terms
(e.g., <code>phi</code>), which are not actually associated with random effects.
</p>
<p>Standard errors for spatial variance terms fit in log space (e.g., variance
terms, range, or parameters associated with the observation error) are
omitted to avoid confusion. Confidence intervals are still available.
</p>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- sdmTMB(density ~ poly(depth_scaled, 2, raw = TRUE),
  data = pcod_2011, mesh = pcod_mesh_2011,
  family = tweedie()
)
tidy(fit)
tidy(fit, conf.int = TRUE)
tidy(fit, "ran_pars", conf.int = TRUE)

pcod_2011$fyear &lt;- as.factor(pcod_2011$year)
fit &lt;- sdmTMB(density ~ poly(depth_scaled, 2, raw = TRUE) + (1 | fyear),
  data = pcod_2011, mesh = pcod_mesh_2011,
  family = tweedie()
)
tidy(fit, "ran_vals")
</code></pre>

<hr>
<h2 id='visreg_delta'>Plot sdmTMB models with the <span class="pkg">visreg</span> package</h2><span id='topic+visreg_delta'></span><span id='topic+visreg2d_delta'></span>

<h3>Description</h3>

<p>sdmTMB models fit with regular (non-delta) families can be passed to
<code><a href="visreg.html#topic+visreg">visreg::visreg()</a></code> or <code><a href="visreg.html#topic+visreg2d">visreg::visreg2d()</a></code> directly. Examples are shown
below. Delta models can use the helper functions <code>visreg_delta()</code> or
<code>visreg2d_delta()</code> described here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visreg_delta(object, ..., model = c(1, 2))

visreg2d_delta(object, ..., model = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visreg_delta_+3A_object">object</code></td>
<td>
<p>Fit from <code><a href="#topic+sdmTMB">sdmTMB()</a></code></p>
</td></tr>
<tr><td><code id="visreg_delta_+3A_...">...</code></td>
<td>
<p>Any arguments passed to <code><a href="visreg.html#topic+visreg">visreg::visreg()</a></code> or
<code><a href="visreg.html#topic+visreg2d">visreg::visreg2d()</a></code></p>
</td></tr>
<tr><td><code id="visreg_delta_+3A_model">model</code></td>
<td>
<p>1st or 2nd delta model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note the residuals are currently randomized quantile residuals,
<em>not</em> deviance residuals as is usual for GLMs with <span class="pkg">visreg</span>.
</p>


<h3>Value</h3>

<p>A plot from the visreg package. Optionally, the data plotted invisibly if
<code>plot = FALSE</code>. This is useful if you want to make your own plot after.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("ggplot2", quietly = TRUE) &amp;&amp;
  require("visreg", quietly = TRUE)) {


  fit &lt;- sdmTMB(
    density ~ s(depth_scaled),
    data = pcod_2011,
    spatial = "off",
    family = tweedie()
  )
  visreg::visreg(fit, xvar = "depth_scaled")

  visreg::visreg(fit, xvar = "depth_scaled", scale = "response")
  v &lt;- visreg::visreg(fit, xvar = "depth_scaled")
  head(v$fit)
  # now use ggplot2 etc. if desired

  # Delta model example:
  fit_dg &lt;- sdmTMB(
    density ~ s(depth_scaled, year, k = 8),
    data = pcod_2011, mesh = pcod_mesh_2011,
    spatial = "off",
    family = delta_gamma()
  )
  visreg_delta(fit_dg, xvar = "depth_scaled", model = 1, gg = TRUE)
  visreg_delta(fit_dg, xvar = "depth_scaled", model = 2, gg = TRUE)
  visreg_delta(fit_dg,
    xvar = "depth_scaled", model = 1,
    scale = "response", gg = TRUE
  )
  visreg_delta(fit_dg,
    xvar = "depth_scaled", model = 2,
    scale = "response"
  )
  visreg_delta(fit_dg,
    xvar = "depth_scaled", model = 2,
    scale = "response", gg = TRUE, rug = FALSE
  )
  visreg2d_delta(fit_dg,
    xvar = "depth_scaled", yvar = "year",
    model = 2, scale = "response"
  )
  visreg2d_delta(fit_dg,
    xvar = "depth_scaled", yvar = "year",
    model = 1, scale = "response", plot.type = "persp"
  )
  visreg2d_delta(fit_dg,
    xvar = "depth_scaled", yvar = "year",
    model = 2, scale = "response", plot.type = "gg"
  )
  
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
