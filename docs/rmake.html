<!DOCTYPE html><html><head><title>Help for package rmake</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rmake}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;&gt;%'><p>A pipe operator for rmake rules</p></a></li>
<li><a href='#defaultVars'><p>Variables used within Makefile generating process</p></a></li>
<li><a href='#expandTemplate'><p>Expand template rules into a list of rules by replacing <code>rmake</code> variables with their values</p></a></li>
<li><a href='#getParam'><p>Wrapper around the <code>params</code> global variable</p></a></li>
<li><a href='#inShell'><p>Convert R code to the character vector of shell commands evaluating the given R code.</p></a></li>
<li><a href='#is.rule'><p>Check if the argument is a valid rule object.</p></a></li>
<li><a href='#make'><p>Run 'make&ldquo; in the system</p></a></li>
<li><a href='#makefile'><p>Generate Makefile from given list of rules (<code>job</code>).</p></a></li>
<li><a href='#markdownRule'><p>Rule for building text documents from Markdown files</p></a></li>
<li><a href='#offlineRule'><p>Rule for requesting manual user action</p></a></li>
<li><a href='#prerequisites'><p>Return given set of properties of all rules in a list</p></a></li>
<li><a href='#replaceSuffix'><p>Replace suffix of the given file name with a new extension (suffix)</p></a></li>
<li><a href='#replaceVariables'><p>Replace <code>rmake</code> variables in a character vector</p></a></li>
<li><a href='#rmake-package'><p>Makefile generator for R analytical projects</p></a></li>
<li><a href='#rmakeSkeleton'><p>Prepare existing project for building with <em>rmake</em>.</p></a></li>
<li><a href='#rRule'><p>Rule for running R scripts</p></a></li>
<li><a href='#rule'><p>General creator of an instance of the S3 <code>rmake.rule</code> class</p></a></li>
<li><a href='#visualize'><p>Visualize dependencies defined by a rule or a list of rules</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Makefile Generator for R Analytical Projects</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Michal Burda</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michal Burda &lt;michal.burda@osu.cz&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Creates and maintains a build process for complex analytic tasks in R.
  Package allows to easily generate Makefile for the (GNU) 'make' tool, which drives the build process
  by (in parallel) executing build commands in order to update results accordingly to given dependencies
  on changed data or updated source files.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3.0)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>tools, pryr, assertthat, rmarkdown, visNetwork</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-08-30 10:04:46 UTC; michal</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-08-30 10:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+26gt+3B+25'>A pipe operator for rmake rules</h2><span id='topic++25+3E+3E+25'></span>

<h3>Description</h3>

<p>This pipe operator simplifies the definition of multiple rmake rules that constitute a chain,
that is, if a first rule depends on the results of a second rule, which depends on the results
of a third rule and so on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A dependency file name or a call to a function that creates a <code>rmake.rule</code>.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A target file or a call to a function that creates a <code>rmake.rule</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The format of proper usage is as follows:
<code>'inFile' %&gt;&gt;% rule() %&gt;&gt;% 'outFile'</code>,
which is equivalent to the call <code>rule(depends='inFile', target='outFile')</code>. <code>rule</code> must be
a function that accepts the named parameters <code>depends</code> and <code>target</code> and creates the
<code>rmake.rule</code> object (see <code><a href="#topic+rule">rule()</a></code>, <code><a href="#topic+rRule">rRule()</a></code>, <code><a href="#topic+markdownRule">markdownRule()</a></code> etc.).
<code>inFile</code> and <code>outFile</code> are file names.
</p>
<p>Multiple rules may be pipe-lined as follows:
<code>'inFile' %&gt;&gt;% rRule('script1.R') %&gt;&gt;% 'medFile' %&gt;&gt;% rRule('script2.R') %&gt;&gt;% 'outFile'</code>,
which is equivalent to a job of two rules created with:
<code>rRule(script='script1.R', depends='inFile', target='medFile')</code> and
<code>rRule(script='script2.R', depends='medFile', target='outFile')</code>.
</p>


<h3>Value</h3>

<p>A list of instances of the <code>rmake.rule</code> class.
</p>


<h3>Author(s)</h3>

<p>Michal Burda (<code>%&gt;&gt;%</code> operator is derived from the code of the <code>magrittr</code> package by
Stefan Milton Bache and Hadley Wickham)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rule">rule()</a></code>, <code><a href="#topic+makefile">makefile()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
job1 &lt;- 'data.csv' %&gt;&gt;%
  rRule('preprocess.R') %&gt;&gt;%
  'data.rds' %&gt;&gt;%
  markdownRule('report.rnw') %&gt;&gt;%
  'report.pdf'

# is equivalent to

job2 &lt;- list(rRule(target='data.rds', script='preprocess.R', depends='data.csv'),
             markdownRule(target='report.pdf', script='report.rnw', depends='data.rds'))
</code></pre>

<hr>
<h2 id='defaultVars'>Variables used within Makefile generating process</h2><span id='topic+defaultVars'></span>

<h3>Description</h3>

<p><code>defaultVars</code> is a reserved variable, a named vector that defines
Makefile variables, i.e. shell variables that will exist during
the execution of Makefile rules. The content of this variable
is written into the resulting Makefile within the execution of
the <code><a href="#topic+makefile">makefile()</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defaultVars
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 3.</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makefile">makefile()</a></code>
</p>

<hr>
<h2 id='expandTemplate'>Expand template rules into a list of rules by replacing <code>rmake</code> variables with their values</h2><span id='topic+expandTemplate'></span>

<h3>Description</h3>

<p>Take a template job (i.e., a list of template rules), or a template rule, and create a job (or rule)
from them by replacing <code>rmake</code> variables in the template with their values. The <code>rmake</code> variable
is a identified by the <code>$[VARIABLE_NAME]</code> string anywhere in the definition of a rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandTemplate(template, vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expandTemplate_+3A_template">template</code></td>
<td>
<p>An instance of the S3 <code>rmake.rule</code> class or a list of such objects.</p>
</td></tr>
<tr><td><code id="expandTemplate_+3A_vars">vars</code></td>
<td>
<p>A named character vector, matrix, or data frame with variable definitions.
For character vector, names are variable names, values are variable values. For matrix or
data frame, colnames are variable names and column values are variable values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>vars</code> is a character vector then all variables in <code>vars</code> are replaced in <code>template</code> so that
the result will contain <code>length(template)</code> rules. If <code>vars</code> is a data frame or a character
matrix then the replacement of variables is performed row-wisely. That is, a new sequence of rules is
created from <code>template</code> for each row of variables in <code>vars</code> so that the result will contain
<code>nrow(vars) * length(template)</code> rules.
</p>


<h3>Value</h3>

<p>A list of rules created from <code>template</code> by replacing <code>rmake</code> variables.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+replaceVariables">replaceVariables()</a></code>, <code><a href="#topic+rule">rule()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmpl &lt;- rRule('data-$[VERSION].csv', 'process-$[TYPE].R', 'output-$[VERSION]-$[TYPE].csv')

job &lt;- expandTemplate(tmpl, c(VERSION='small', TYPE='a'))
# is equivalent to
job &lt;- list(rRule('data-small.csv', 'process-a.R', 'output-small-a.csv'))

job &lt;- expandTemplate(tmpl, expand.grid(VERSION=c('small', 'big'), TYPE=c('a', 'b', 'c')))
# is equivalent to
job &lt;- list(rRule('data-small.csv', 'process-a.R', 'output-small-a.csv'),
            rRule('data-big.csv', 'process-a.R', 'output-big-a.csv'),
            rRule('data-small.csv', 'process-b.R', 'output-small-b.csv'),
            rRule('data-big.csv', 'process-b.R', 'output-big-b.csv'),
            rRule('data-small.csv', 'process-c.R', 'output-small-c.csv'),
            rRule('data-big.csv', 'process-c.R', 'output-big-c.csv'))
</code></pre>

<hr>
<h2 id='getParam'>Wrapper around the <code>params</code> global variable</h2><span id='topic+getParam'></span>

<h3>Description</h3>

<p>Returns an element of the global <code>params</code> variable that is normally used to send parameters
to a script from the <code>Makefile</code> generated by <code>rmake</code>. Script parameters may be defined with
the <code>params</code> argument of the <code><a href="#topic+rRule">rRule()</a></code> or <code><a href="#topic+markdownRule">markdownRule()</a></code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParam(name, default = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParam_+3A_name">name</code></td>
<td>
<p>Name of the parameter</p>
</td></tr>
<tr><td><code id="getParam_+3A_default">default</code></td>
<td>
<p>Default value to be returned if the <code>params</code> global variable does not exist,
which typically occurs if the script is executed not from <code>Makefile</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns an element of given <code>name</code> from the <code>params</code> variable that is created
inside of the <code>Makefile</code> recipe. If the <code>params</code> global variable does not exist (the script
is likely to be executed directly, i.e., not from the Makefile generated by <code>rmake</code>),
the <code>default</code> value is returned and a warning is generated. If the <code>params</code> global variable
exists but it is not a list or the <code>name</code> element does not exist there, an error is thrown.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rRule">rRule()</a></code>, <code><a href="#topic+markdownRule">markdownRule()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>task &lt;- getParam('task', 'default')

</code></pre>

<hr>
<h2 id='inShell'>Convert R code to the character vector of shell commands evaluating the given R code.</h2><span id='topic+inShell'></span>

<h3>Description</h3>

<p>The function takes R commands, deparses them, substitutes existing variables, and converts
everything to character strings, from which a shell command is created that sends the given
R code to the R interpreter. Function is used internally to print the commands of R rules
into <code>Makefile</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inShell(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inShell_+3A_...">...</code></td>
<td>
<p>R commands to be converted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of shell commands, which send the given R code by pipe to the R
interpreter
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rRule">rRule()</a></code>, <code><a href="#topic+markdownRule">markdownRule()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inShell({
  x &lt;- 1
  y &lt;- 2
  print(x+y)
})
</code></pre>

<hr>
<h2 id='is.rule'>Check if the argument is a valid rule object.</h2><span id='topic+is.rule'></span>

<h3>Description</h3>

<p>Function tests whether <code>x</code> is a valid rule object, i.e., whether
it is list a list and inherits from the <code>rmake.rule</code> S3 class. Instances
of <code>rule</code> represent an atomic building unit, i.e. a command that
has to be executed, which optionally depends on some files or other
rules &ndash; see <code><a href="#topic+rule">rule()</a></code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.rule(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.rule_+3A_x">x</code></td>
<td>
<p>An argument to be tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is a valid rule object and <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rule">rule()</a></code>, <code><a href="#topic+makefile">makefile()</a></code>, <code><a href="#topic+rRule">rRule()</a></code>, <code><a href="#topic+markdownRule">markdownRule()</a></code>, <code><a href="#topic+offlineRule">offlineRule()</a></code>
</p>

<hr>
<h2 id='make'>Run 'make&ldquo; in the system</h2><span id='topic+make'></span>

<h3>Description</h3>

<p>This function executes the <code>make</code> command in order to re-build all dependencies, accordingly to <code>Makefile</code>
generated by <code><a href="#topic+makefile">makefile()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_+3A_...">...</code></td>
<td>
<p>Command-line arguments passed to the <code>make</code> command</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Exit status of the command, see <code><a href="base.html#topic+system2">base::system2()</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makefile">makefile()</a></code>, <code><a href="#topic+rmakeSkeleton">rmakeSkeleton()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  make()        # make all
  make('clean') # make the 'clean' task
  make('-j', 4) # make with 4 processes in parallell

## End(Not run)
</code></pre>

<hr>
<h2 id='makefile'>Generate Makefile from given list of rules (<code>job</code>).</h2><span id='topic+makefile'></span>

<h3>Description</h3>

<p>In the (GNU) <code>make</code> jargon, <em>rule</em> is a sequence of commands to build a result. In this package, rule
should be understood similarly: It is a command or a sequence of command that optionally produces some
files and depends on some other files (such as data files, scripts) or other rules. Moreover, a rule
contain a command for cleanup, i.e. for removal of generated files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makefile(job = list(), fileName = NULL, makeScript = "Makefile.R",
  vars = NULL, all = TRUE, tasks = TRUE, clean = TRUE,
  makefile = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makefile_+3A_job">job</code></td>
<td>
<p>A list of rules (i.e. of instances of the S3 class <code>rmake.rule</code> - see <code><a href="#topic+rule">rule()</a></code>)</p>
</td></tr>
<tr><td><code id="makefile_+3A_filename">fileName</code></td>
<td>
<p>A file to write to. If <code>NULL</code>, the result is returned as a character vector instead of
writing to a file.</p>
</td></tr>
<tr><td><code id="makefile_+3A_makescript">makeScript</code></td>
<td>
<p>A name of the file that calls this function (in order to generate
the <code>makefile</code> rule)</p>
</td></tr>
<tr><td><code id="makefile_+3A_vars">vars</code></td>
<td>
<p>A named character vector of shell variables that will be declared in the resulting Makefile
(additionally to <code>[defaultVars]</code>)</p>
</td></tr>
<tr><td><code id="makefile_+3A_all">all</code></td>
<td>
<p><code>TRUE</code> if the <code>all</code> rule should be automatically created and added: created <code>all</code> rule
has dependencies to all the other rules, which causes that everything is built if <code>make all</code> is executed
in shell's command line.</p>
</td></tr>
<tr><td><code id="makefile_+3A_tasks">tasks</code></td>
<td>
<p><code>TRUE</code> if &quot;task&quot; rules should be automatically created and added &ndash; see <code><a href="#topic+rule">rule()</a></code> for
more details.</p>
</td></tr>
<tr><td><code id="makefile_+3A_clean">clean</code></td>
<td>
<p><code>TRUE</code> if the <code>clean</code> rule should be automatically created and added</p>
</td></tr>
<tr><td><code id="makefile_+3A_makefile">makefile</code></td>
<td>
<p><code>TRUE</code> if the <code>Makefile</code> rule should be automatically created and added: this rule
causes that any change in the R script - that generates the <code>Makefile</code> (i.e. that calls <code><a href="#topic+makefile">makefile()</a></code>) -
issues the re-generation of the Makefile in the beginning of any build.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+makefile">makefile()</a></code> function takes a list of rules (see <code><a href="#topic+rule">rule()</a></code>) and generates a <code>Makefile</code> from them.
Additionally, <code>all</code> and <code>clean</code> rules are optionally generated too, which can be executed from shell
by issuing <code>make all</code> or <code>make clean</code> command, respectively, in order to build everything or erase all
generated files.
</p>
<p>If there is a need to group some rules into a group, it can be done either via dependencies or by using
the <code>task</code> mechanism. Each rule may get assigned one or more tasks (see <code>task</code> in <code><a href="#topic+rule">rule()</a></code>). Each
task is then created as a standalone rule depending on assigned rules. That way, executing <code>make task_name</code>
will build all rules with assigned task <code>task_name</code>. By default, all rules are assigned to task <code>all</code>,
which allows <code>make all</code> to build everything.
</p>


<h3>Value</h3>

<p>If <code>fileName</code> is <code>NULL</code>, the function returns a character vector with the contents of the
Makefile. Instead, the content is written to the given <code>fileName</code>.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rule">rule()</a></code>, <code><a href="#topic+rmakeSkeleton">rmakeSkeleton()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some jobs
job &lt;- list(
    rRule('dataset.rds', 'preprocess.R', 'dataset.csv'),
    markdownRule('report.pdf', 'report.Rmd', 'dataset.rds'),
    markdownRule('details.pdf', 'details.Rmd', 'dataset.rds'))

# generate Makefile (output as a character vector)
makefile(job)

# generate to file
tmp &lt;- tempdir()
makefile(job, file.path(tmp, "Makefile"))
</code></pre>

<hr>
<h2 id='markdownRule'>Rule for building text documents from Markdown files</h2><span id='topic+markdownRule'></span>

<h3>Description</h3>

<p>This rule is for execution of Markdown rendering in order to create text file
of various supported formats such as (PDF, DOCX, etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markdownRule(target, script, depends = NULL, format = "all",
  params = list(), task = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markdownRule_+3A_target">target</code></td>
<td>
<p>Name of the output file to be created</p>
</td></tr>
<tr><td><code id="markdownRule_+3A_script">script</code></td>
<td>
<p>Name of the markdown file to be rendered</p>
</td></tr>
<tr><td><code id="markdownRule_+3A_depends">depends</code></td>
<td>
<p>A vector of file names that the markdown script depends on, or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="markdownRule_+3A_format">format</code></td>
<td>
<p>Requested format of the result. Parameter is passed as <code>format</code> argument
to <code><a href="rmarkdown.html#topic+render">rmarkdown::render()</a></code>. Allowed values are: 'all', 'html_document', 'pdf_document',
'word_document', 'odt_document', 'rtf_document', or 'md_document'.</p>
</td></tr>
<tr><td><code id="markdownRule_+3A_params">params</code></td>
<td>
<p>A list of R values that become available within the <code>script</code> in
a <code>params</code> variable.</p>
</td></tr>
<tr><td><code id="markdownRule_+3A_task">task</code></td>
<td>
<p>A character vector of parent task names. The mechanism of tasks allows to
group rules. Anything different from <code>'all'</code> will
cause creation of a new task depending on the given rule. Executing <code>make taskname</code>
will then force building of this rule.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This rule executes the following command in a separate R process:
<code>params &lt;- params; rmarkdown::render(script, output_format=format, output_file=target)</code>
</p>
<p>That is, parameters given in the <code>params</code> argument are stored into the global variable
and then the <code>script</code> is rendered with rmarkdown. That is, the re-generation of the
<code>Makefile</code> with any change to <code>params</code> will not cause the re-execution of the recipe unless
any other script dependencies change.
</p>
<p>Issuing <code>make clean</code> from the shell causes removal of all files specified in <code>target</code> parameter.
</p>


<h3>Value</h3>

<p>Instance of S3 class <code>rmake.rule</code>
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rule">rule()</a></code>, <code><a href="#topic+makefile">makefile()</a></code>, <code><a href="#topic+rRule">rRule()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- markdownRule(target='report.pdf',
                  script='report.Rmd',
                  depends=c('data1.csv', 'data2.csv'))

# generate the content of a makefile (as character vector)
makefile(list(r))

# generate to file
tmp &lt;- tempdir()
makefile(list(r), file.path(tmp, "Makefile"))
</code></pre>

<hr>
<h2 id='offlineRule'>Rule for requesting manual user action</h2><span id='topic+offlineRule'></span>

<h3>Description</h3>

<p>Instead of building the target, this rule simply issues the given error message.
This rule is useful for cases, where the target <code>target</code> depends on <code>depends</code>, but
has to be updated by some manual process. So if <code>target</code> is older than any of its
dependencies, <code>make</code> will throw an error until the user manually updates the target.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>offlineRule(target, message, depends = NULL, task = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="offlineRule_+3A_target">target</code></td>
<td>
<p>A character vector of target file names of the manual (offline) build
command</p>
</td></tr>
<tr><td><code id="offlineRule_+3A_message">message</code></td>
<td>
<p>An error message to be issued if targets are older than dependencies
from <code>depends</code></p>
</td></tr>
<tr><td><code id="offlineRule_+3A_depends">depends</code></td>
<td>
<p>A character vector of file names the targets depend on</p>
</td></tr>
<tr><td><code id="offlineRule_+3A_task">task</code></td>
<td>
<p>A character vector of parent task names. The mechanism of tasks allows to
group rules. Anything different from <code>'all'</code> will
cause creation of a new task depending on the given rule. Executing <code>make taskname</code>
will then force building of this rule.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Instance of S3 class <code>rmake.rule</code>
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rule">rule()</a></code>, <code><a href="#topic+makefile">makefile()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- offlineRule(target='offlinedata.csv',
                 message='Please re-generate manually offlinedata.csv',
                 depends=c('source1.csv', 'source2.csv'))

# generate the content of a makefile (as character vector)
makefile(list(r))

# generate to file
tmp &lt;- tempdir()
makefile(list(r), file.path(tmp, "Makefile"))
</code></pre>

<hr>
<h2 id='prerequisites'>Return given set of properties of all rules in a list</h2><span id='topic+prerequisites'></span><span id='topic+getters'></span><span id='topic+targets'></span><span id='topic+tasks'></span><span id='topic+terminals'></span>

<h3>Description</h3>

<p><code>targets()</code> returns a character vector of all unique values of <code>target</code> properties,
<code>prerequisites()</code> returns <code>depends</code> and <code>script</code> properties,
and <code>tasks()</code> returns <code>task</code> properties of the given <code><a href="#topic+rule">rule()</a></code> or list of rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prerequisites(x)

targets(x)

tasks(x)

terminals(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prerequisites_+3A_x">x</code></td>
<td>
<p>An instance of the <code>rmake.rule</code> class or a list of such instances</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>terminals()</code> returns only such targets that are not prerequisites to any other rule.
</p>


<h3>Value</h3>

<p>A character vector of unique values of the selected property obtained from all rules in <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rule">rule()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>job &lt;- 'data.csv' %&gt;&gt;%
  rRule('process.R', task='basic') %&gt;&gt;%
  'data.rds' %&gt;&gt;%
  markdownRule('report.Rnw', task='basic') %&gt;&gt;%
  'report.pdf'

prerequisites(job)    # returns c('process.R', data.csv', 'report.Rnw', 'data.rds')
targets(job)          # returns c('data.rds', 'report.pdf')
tasks(job)            # returns 'basic'
</code></pre>

<hr>
<h2 id='replaceSuffix'>Replace suffix of the given file name with a new extension (suffix)</h2><span id='topic+replaceSuffix'></span>

<h3>Description</h3>

<p>This helper function takes a file name <code>fileName</code>, removes an extension (a suffix)
from it and adds a new extension <code>newSuffix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replaceSuffix(fileName, newSuffix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replaceSuffix_+3A_filename">fileName</code></td>
<td>
<p>A character vector with original filenames</p>
</td></tr>
<tr><td><code id="replaceSuffix_+3A_newsuffix">newSuffix</code></td>
<td>
<p>A new extension to replace old extensions in file names <code>fileName</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with new file names with old extensions replaced with <code>newSuffix</code>
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>Examples</h3>

<pre><code class='language-R'>replaceSuffix('filename.Rmd', '.pdf')          # 'filename.pdf'
replaceSuffix(c('a.x', 'b.y', 'c.z'), '.csv')  # 'a.csv', 'b.csv', 'c.csv'
</code></pre>

<hr>
<h2 id='replaceVariables'>Replace <code>rmake</code> variables in a character vector</h2><span id='topic+replaceVariables'></span>

<h3>Description</h3>

<p>This function searches for all <code>rmake</code> variables in given vector <code>x</code> and replaces them
with their values that are defined in the <code>vars</code> argument. The <code>rmake</code> variable is a identified
by the <code>$[VARIABLE_NAME]</code> string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replaceVariables(x, vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replaceVariables_+3A_x">x</code></td>
<td>
<p>A character vector where to replace the <code>rmake</code> variables</p>
</td></tr>
<tr><td><code id="replaceVariables_+3A_vars">vars</code></td>
<td>
<p>A named character vector with variable definitions (names are variable names, values
are variable values)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with <code>rmake</code> variables replaced with their values
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expandTemplate">expandTemplate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vars &lt;- c(SIZE='small', METHOD='abc')
replaceVariables('result-$[SIZE]-$[METHOD].csv', vars)   # returns 'result-small-abc.csv'

</code></pre>

<hr>
<h2 id='rmake-package'>Makefile generator for R analytical projects</h2><span id='topic+rmake'></span><span id='topic+rmake-package'></span>

<h3>Description</h3>

<p><span class="pkg">rmake</span> creates and maintains a build process for complex analytic tasks in R.
Package allows to easily generate Makefile for the (GNU) 'make' tool, which drives the build process
by (in parallel) executing build commands in order to update results accordingly to given dependencies
on changed data or updated source files.
</p>


<h3>Details</h3>

<p>Note: The package requires the <code>R_HOME</code> environment variable to be properly set.
</p>


<h3>Basic Usage</h3>

<p>Suppose you have a file <code>dataset.csv</code>. You want to pre-process it and store the results into
<code>dataset.rds</code> within the <code>preprocess.R</code> R script.  After that, <code>dataset.rds</code> is then
an input file for <code>report.Rmd</code> and <code>details.Rmd</code>, which are R-Markdown scripts that generate
<code>report.pdf</code> and <code>details.pdf</code>. The whole project can be initialized with <span class="pkg">rmake</span> as follows:
</p>

<ol>
<li><p> Let us assume that you have <span class="pkg">rmake</span> package as well as the <code>make</code> tool properly installed.
</p>
</li>
<li><p> Create a new directory (or an R studio project) and copy your <code>dataset.csv</code> into it.
</p>
</li>
<li><p> Load <span class="pkg">rmake</span> package and create skeleton files for it: <br />
<code>library(rmake)</code> <br />
<code>rmakeSkeleton('.')</code> <br /><br />
<code>Makefile.R</code> and <code>Makefile</code> will be created in current directory (<code>'.'</code>).
</p>
</li>
<li><p> Create your file <code>preprocess.R</code>, <code>report.Rmd</code> and <code>details.Rmd</code>.
</p>
</li>
<li><p> Edit <code>Makefile.R</code> as follows: <br />
<code>library(rmake)</code> <br />
<code>job &lt;- list(</code> <br />
<code>rRule('dataset.rds', 'preprocess.R', 'dataset.csv'),</code> <br />
<code>markdownRule('report.pdf', 'report.Rmd', 'dataset.rds'),</code> <br />
<code>markdownRule('details.pdf', 'details.Rmd', 'dataset.rds')</code> <br />
<code>)</code> <br />
<code>makefile(job, "Makefile")</code><br /><br />
This will create three build rules: processing of <code>preprocess.R</code> and execution of <code>report.Rmd</code>
and <code>details.Rmd</code> in order to generate resulting PDF files.
</p>
</li>
<li><p> Run <code>make</code> or build your project in R Studio (Build/Build all).
This will automatically re-generate <code>Makefile</code> and execute <code>preprocess.R</code> and the generation
of <code>report.Rmd</code> and <code>details.Rmd</code> accordingly to the changes made to source files.
</p>
</li></ol>


<hr>
<h2 id='rmakeSkeleton'>Prepare existing project for building with <em>rmake</em>.</h2><span id='topic+rmakeSkeleton'></span>

<h3>Description</h3>

<p>This function creates a <code>Makefile.R</code> with an empty <em>rmake</em> project
and generates a basic <code>Makefile</code> from it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmakeSkeleton(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmakeSkeleton_+3A_path">path</code></td>
<td>
<p>Path to the target directory where to create files. Use &quot;.&quot; for the current directory.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makefile">makefile()</a></code>, <code><a href="#topic+rule">rule()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creates/overrides Makefile.R and Makefile in a temporary directory
rmakeSkeleton(path=tempdir())
</code></pre>

<hr>
<h2 id='rRule'>Rule for running R scripts</h2><span id='topic+rRule'></span>

<h3>Description</h3>

<p>This rule is for execution of R scripts in order to create various file outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rRule(target, script, depends = NULL, params = list(), task = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rRule_+3A_target">target</code></td>
<td>
<p>Name of output files to be created</p>
</td></tr>
<tr><td><code id="rRule_+3A_script">script</code></td>
<td>
<p>Name of the R script to be executed</p>
</td></tr>
<tr><td><code id="rRule_+3A_depends">depends</code></td>
<td>
<p>A vector of file names that the R script depends on, or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rRule_+3A_params">params</code></td>
<td>
<p>A list of R values that become available within the <code>script</code> in
a <code>params</code> variable.</p>
</td></tr>
<tr><td><code id="rRule_+3A_task">task</code></td>
<td>
<p>A character vector of parent task names. The mechanism of tasks allows to
group rules. Anything different from <code>'all'</code> will
cause creation of a new task depending on the given rule. Executing <code>make taskname</code>
will then force building of this rule.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In detail, this rule executes the following command in a separate R process:
<code>params &lt;- params; source(script)</code>
</p>
<p>That is, parameters given in the <code>params</code> argument are stored into the global variable
and then the <code>script</code> is sourced. That is, the re-generation of the <code>Makefile</code> with any change
to <code>params</code> will not cause the re-execution of the recipe unless any other script dependencies change.
</p>
<p>Issuing <code>make clean</code> from the shell causes removal of all files specified in <code>target</code> parameter.
</p>


<h3>Value</h3>

<p>Instance of S3 class <code>rmake.rule</code>
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rule">rule()</a></code>, <code><a href="#topic+makefile">makefile()</a></code>, <code><a href="#topic+markdownRule">markdownRule()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rRule(target='cleandata.csv',
           script='clean.R',
           depends=c('data1.csv', 'data2.csv'))

# generate the content of a makefile (as character vector)
makefile(list(r))

# generate to file
tmp &lt;- tempdir()
makefile(list(r), file.path(tmp, "Makefile"))
</code></pre>

<hr>
<h2 id='rule'>General creator of an instance of the S3 <code>rmake.rule</code> class</h2><span id='topic+rule'></span><span id='topic+rmake.rule'></span>

<h3>Description</h3>

<p>Rule is an atomic element of the build process. It defines a set of <code>target</code> file names,
which are to be built with a given <code>build</code> command from a given set <code>depends</code> of files
that targets depend on, and which can be removed by a given <code>clean</code> command.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rule(target, depends = NULL, build = NULL, clean = NULL,
  task = "all", phony = FALSE, type = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rule_+3A_target">target</code></td>
<td>
<p>A character vector of target file names that are created by the given build command</p>
</td></tr>
<tr><td><code id="rule_+3A_depends">depends</code></td>
<td>
<p>A character vector of file names the build command depends on</p>
</td></tr>
<tr><td><code id="rule_+3A_build">build</code></td>
<td>
<p>A shell command that runs the build of the given target</p>
</td></tr>
<tr><td><code id="rule_+3A_clean">clean</code></td>
<td>
<p>A shell command that erases all files produced by the build command</p>
</td></tr>
<tr><td><code id="rule_+3A_task">task</code></td>
<td>
<p>A character vector of parent task names. The mechanism of tasks allows to
group rules. Anything different from <code>'all'</code> will
cause creation of a new task depending on the given rule. Executing <code>make taskname</code>
will then force building of this rule.</p>
</td></tr>
<tr><td><code id="rule_+3A_phony">phony</code></td>
<td>
<p>Whether the rule has a <code>PHONY</code> (i.e. non-file) target. A rule should be marked with
<code>phony</code> if the target is not a file name that would be generated by the <code>build</code> commands.
E.g. <code>all</code> or <code>clean</code> are phony targets. Also all targets representing tasks (see <code>task</code> above) are phony.</p>
</td></tr>
<tr><td><code id="rule_+3A_type">type</code></td>
<td>
<p>A string representing a type of a rule used e.g. while printing a rule in easily readable format.
For instance, <code><a href="#topic+rRule">rRule()</a></code> uses <code>R</code>, <code><a href="#topic+markdownRule">markdownRule()</a></code> uses <code>markdown</code> etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there is a need to group some rules together, one can assign them the same task identifier in
the <code>task</code> argument. Each rule may get assigned one or more tasks. Tasks may be then built
by executing <code>make task_name</code> on the command line, which forces to rebuild all rules assigned to the
task <code>'task_name'</code>. By default, all rules are assigned to task <code>all</code>,
which causes <code>make all</code> command to build everything.
</p>


<h3>Value</h3>

<p>Instance of S3 class <code>rmake.rule</code>
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makefile">makefile()</a></code>, <code><a href="#topic+inShell">inShell()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rule(target='something.abc',
          depends=c('file.a', 'file.b', 'file.c'),
          build='myCompiler file.a file.b file.c -o something.abc',
          clean='$(RM) something.abc')

# generate the content of a makefile (as character vector)
makefile(list(r))

# generate to file
tmp &lt;- tempdir()
makefile(list(r), file.path(tmp, "Makefile"))
</code></pre>

<hr>
<h2 id='visualize'>Visualize dependencies defined by a rule or a list of rules</h2><span id='topic+visualize'></span>

<h3>Description</h3>

<p>Visualize dependencies defined by a rule or a list of rules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualize(x, legend = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualize_+3A_x">x</code></td>
<td>
<p>An instance of the S3 <code>rmake.rule</code> class or a list of such objects</p>
</td></tr>
<tr><td><code id="visualize_+3A_legend">legend</code></td>
<td>
<p>Whether to draw a legend</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makefile">makefile()</a></code>, <code><a href="#topic+rule">rule()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>job &lt;- c('data1.csv', 'data2.csv') %&gt;&gt;%
  rRule('process.R') %&gt;&gt;%
  'data.rds' %&gt;&gt;%
  markdownRule('report.Rmd') %&gt;&gt;%
  'report.pdf'

## Not run: 
visualize(job)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
