<!DOCTYPE html><html><head><title>Help for package tseries</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="/home/deepayan/Rinstall/R-devel/lib/R/doc/html/R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tseries}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adf.test'><p>Augmented Dickey&ndash;Fuller Test</p></a></li>
<li><a href='#arma'><p>Fit ARMA Models to Time Series</p></a></li>
<li><a href='#arma-methods'><p>Methods for Fitted ARMA Models</p></a></li>
<li><a href='#bds.test'><p>BDS Test</p></a></li>
<li><a href='#bev'>
<p>Beveridge Wheat Price Index, 1500&ndash;1869.</p></a></li>
<li><a href='#camp'>
<p>Mount Campito Yearly Treering Data, -3435&ndash;1969.</p></a></li>
<li><a href='#garch'><p>Fit GARCH Models to Time Series</p></a></li>
<li><a href='#garch-methods'><p>Methods for Fitted GARCH Models</p></a></li>
<li><a href='#get.hist.quote'><p>Download Historical Finance Data</p></a></li>
<li><a href='#ice.river'>
<p>Icelandic River Data</p></a></li>
<li><a href='#irts'><p>Irregularly Spaced Time-Series</p></a></li>
<li><a href='#irts-functions'><p>Basic Functions for Irregular Time-Series Objects</p></a></li>
<li><a href='#irts-methods'><p>Methods for Irregular Time-Series Objects</p></a></li>
<li><a href='#jarque.bera.test'><p>Jarque&ndash;Bera Test</p></a></li>
<li><a href='#kpss.test'><p>KPSS Test for Stationarity</p></a></li>
<li><a href='#maxdrawdown'><p>Maximum Drawdown or Maximum Loss</p></a></li>
<li><a href='#na.remove'><p>NA Handling Routines for Time Series</p></a></li>
<li><a href='#NelPlo'>
<p>Nelson&ndash;Plosser Macroeconomic Time Series</p></a></li>
<li><a href='#nino'>
<p>Sea Surface Temperature (SST) Nino 3 and Nino 3.4 Indices</p></a></li>
<li><a href='#plotOHLC'><p>Plot Open-High-Low-Close Bar Chart</p></a></li>
<li><a href='#po.test'><p>Phillips&ndash;Ouliaris Cointegration Test</p></a></li>
<li><a href='#portfolio.optim'><p>Portfolio Optimization</p></a></li>
<li><a href='#pp.test'><p>Phillips&ndash;Perron Unit Root Test</p></a></li>
<li><a href='#quadmap'><p>Quadratic Map (Logistic Equation)</p></a></li>
<li><a href='#read.matrix'><p>Read Matrix Data</p></a></li>
<li><a href='#read.ts'><p>Read Time Series Data</p></a></li>
<li><a href='#runs.test'><p>Runs Test</p></a></li>
<li><a href='#seqplot.ts'><p>Plot Two Time Series</p></a></li>
<li><a href='#sharpe'><p>Sharpe Ratio</p></a></li>
<li><a href='#sterling'><p>Sterling Ratio</p></a></li>
<li><a href='#summary.arma'><p>Summarizing ARMA Model Fits</p></a></li>
<li><a href='#summary.garch'><p>Summarizing GARCH Model Fits</p></a></li>
<li><a href='#surrogate'><p>Generate Surrogate Data and Statistics</p></a></li>
<li><a href='#tcm'>
<p>Monthly Yields on Treasury Securities</p></a></li>
<li><a href='#tcmd'>
<p>Daily Yields on Treasury Securities</p></a></li>
<li><a href='#terasvirta.test'><p>Teraesvirta Neural Network Test for Nonlinearity</p></a></li>
<li><a href='#tsbootstrap'><p>Bootstrap for General Stationary Data</p></a></li>
<li><a href='#USeconomic'>
<p>U.S. Economic Variables</p></a></li>
<li><a href='#white.test'><p>White Neural Network Test for Nonlinearity</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.10-55</td>
</tr>
<tr>
<td>Title:</td>
<td>Time Series Analysis and Computational Finance</td>
</tr>
<tr>
<td>Description:</td>
<td>Time series analysis and computational finance.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, utils, quadprog, zoo, quantmod (&ge; 0.4-9),
jsonlite</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-06 08:27:57 UTC; hornik</td>
</tr>
<tr>
<td>Author:</td>
<td>Adrian Trapletti [aut],
  Kurt Hornik <a href="https://orcid.org/0000-0003-4198-9911"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Blake LeBaron [ctb] (BDS test code)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kurt Hornik &lt;Kurt.Hornik@R-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-06 09:37:51 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; x86_64-pc-linux-gnu; 2024-01-02 07:56:41 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='adf.test'>Augmented Dickey&ndash;Fuller Test</h2><span id='topic+adf.test'></span>

<h3>Description</h3>

<p>Computes the Augmented Dickey-Fuller test for the null that <code>x</code> has
a unit root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adf.test(x, alternative = c("stationary", "explosive"),
         k = trunc((length(x)-1)^(1/3)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adf.test_+3A_x">x</code></td>
<td>
<p>a numeric vector or time series.</p>
</td></tr>
<tr><td><code id="adf.test_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be
one of <code>"stationary"</code> (default) or <code>"explosive"</code>. You can
specify just the initial letter.</p>
</td></tr>
<tr><td><code id="adf.test_+3A_k">k</code></td>
<td>
<p>the lag order to calculate the test statistic.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general regression equation which incorporates a constant and a
linear trend is used and the t-statistic for a first order
autoregressive coefficient equals one is computed. The number of lags
used in the regression is <code>k</code>. The default value of
<code>trunc((length(x)-1)^(1/3))</code> corresponds to the suggested upper
bound on the rate at which the number of lags, <code>k</code>, should be
made to grow with the sample size for the general <code>ARMA(p,q)</code>
setup. Note that for <code>k</code> equals zero the standard Dickey-Fuller
test is computed. The p-values are interpolated from Table 4.2, p. 103
of Banerjee et al. (1993). If the computed statistic is outside the
table of critical values, then a warning message is generated. 
</p>
<p>Missing values are not allowed.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the lag order.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was
performed.</p>
</td></tr> 
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. Trapletti</p>


<h3>References</h3>

<p>A. Banerjee, J. J. Dolado, J. W. Galbraith, and D. F. Hendry (1993):
<em>Cointegration, Error Correction, and the Econometric Analysis of
Non-Stationary Data</em>,
Oxford University Press, Oxford.
</p>
<p>S. E. Said and D. A. Dickey (1984):
Testing for Unit Roots in Autoregressive-Moving Average Models of
Unknown Order.
<em>Biometrika</em> <b>71</b>, 599&ndash;607.
</p>


<h3>See Also</h3>

<p><code><a href="tseries.html#topic+pp.test">pp.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1000)  # no unit-root
adf.test(x)

y &lt;- diffinv(x)   # contains a unit-root
adf.test(y)
</code></pre>

<hr>
<h2 id='arma'>Fit ARMA Models to Time Series</h2><span id='topic+arma'></span>

<h3>Description</h3>

<p>Fit an ARMA model to a univariate time series by conditional least
squares.  For exact maximum likelihood estimation see
<code><a href="stats.html#topic+arima0">arima0</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma(x, order = c(1, 1), lag = NULL, coef = NULL,
     include.intercept = TRUE, series = NULL, qr.tol = 1e-07, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arma_+3A_x">x</code></td>
<td>
<p>a numeric vector or time series.</p>
</td></tr>
<tr><td><code id="arma_+3A_order">order</code></td>
<td>
<p>a two dimensional integer vector giving the orders of the
model to fit. <code>order[1]</code> corresponds to the AR part and
<code>order[2]</code> to the MA part.</p>
</td></tr>
<tr><td><code id="arma_+3A_lag">lag</code></td>
<td>
<p>a list with components <code>ar</code> and <code>ma</code>. Each
component is an integer vector, specifying the AR and MA lags that are
included in the model. If both, <code>order</code> and <code>lag</code>, are
given, only the specification from <code>lag</code> is used.</p>
</td></tr>
<tr><td><code id="arma_+3A_coef">coef</code></td>
<td>
<p>If given this numeric vector is used as the initial estimate
of the ARMA coefficients. The preliminary estimator suggested in
Hannan and Rissanen (1982) is used for the default initialization.</p>
</td></tr>
<tr><td><code id="arma_+3A_include.intercept">include.intercept</code></td>
<td>
<p>Should the model contain an intercept?</p>
</td></tr>
<tr><td><code id="arma_+3A_series">series</code></td>
<td>
<p>name for the series. Defaults to
<code>deparse(substitute(x))</code>.</p>
</td></tr>
<tr><td><code id="arma_+3A_qr.tol">qr.tol</code></td>
<td>
<p>the <code>tol</code> argument for <code><a href="Matrix.html#topic+qr">qr</a></code> when computing
the asymptotic standard errors of <code>coef</code>.</p>
</td></tr>
<tr><td><code id="arma_+3A_...">...</code></td>
<td>
<p>additional arguments for <code><a href="stats.html#topic+optim">optim</a></code> when fitting
the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following parametrization is used for the ARMA(p,q) model:
</p>
<p style="text-align: center;"><code class="reqn">y[t] = a[0] + a[1]y[t-1] + \dots + a[p]y[t-p] + b[1]e[t-1] +
    \dots + b[q]e[t-q] + e[t],</code>
</p>

<p>where <code class="reqn">a[0]</code> is set to zero if no intercept is included. By using
the argument <code>lag</code>, it is possible to fit a parsimonious submodel
by setting arbitrary <code class="reqn">a[i]</code> and <code class="reqn">b[i]</code> to zero.
</p>
<p><code>arma</code> uses <code><a href="stats.html#topic+optim">optim</a></code> to minimize the conditional
sum-of-squared errors. The gradient is computed, if it is needed, by
a finite-difference approximation. Default initialization is done by
fitting a pure high-order AR model (see <code><a href="stats.html#topic+ar.ols">ar.ols</a></code>). 
The estimated residuals are then used for computing a least squares
estimator of the full ARMA model. See Hannan and Rissanen (1982) for
details.
</p>


<h3>Value</h3>

<p>A list of class <code>"arma"</code> with the following elements:
</p>
<table>
<tr><td><code>lag</code></td>
<td>
<p>the lag specification of the fitted model.</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>estimated ARMA coefficients for the fitted model.</p>
</td></tr>
<tr><td><code>css</code></td>
<td>
<p>the conditional sum-of-squared errors.</p>
</td></tr>
<tr><td><code>n.used</code></td>
<td>
<p>the number of observations of <code>x</code>.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the series of residuals.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted series.</p>
</td></tr>
<tr><td><code>series</code></td>
<td>
<p>the name of the series <code>x</code>.</p>
</td></tr>
<tr><td><code>frequency</code></td>
<td>
<p>the frequency of the series <code>x</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call of the <code>arma</code> function.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>estimate of the asymptotic-theory covariance matrix for the
coefficient estimates.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>The <code>convergence</code> integer code from
<code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>include.intercept</code></td>
<td>
<p>Does the model contain an intercept?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. Trapletti
</p>


<h3>References</h3>

<p>E. J. Hannan and J. Rissanen (1982):
Recursive Estimation of Mixed Autoregressive-Moving Average
Order.
<em>Biometrika</em> <b>69</b>, 81&ndash;94. 
</p>


<h3>See Also</h3>

<p><code><a href="tseries.html#topic+summary.arma">summary.arma</a></code> for summarizing ARMA model fits;
<code><a href="tseries.html#topic+arma-methods">arma-methods</a></code> for further methods;
<code><a href="stats.html#topic+arima0">arima0</a></code>, <code><a href="stats.html#topic+ar">ar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tcm)  
r &lt;- diff(tcm10y)
summary(r.arma &lt;- arma(r, order = c(1, 0)))
summary(r.arma &lt;- arma(r, order = c(2, 0)))
summary(r.arma &lt;- arma(r, order = c(0, 1)))
summary(r.arma &lt;- arma(r, order = c(0, 2)))
summary(r.arma &lt;- arma(r, order = c(1, 1)))
plot(r.arma)

data(nino)
s &lt;- nino3.4
summary(s.arma &lt;- arma(s, order=c(20,0)))
summary(s.arma
         &lt;- arma(s, lag=list(ar=c(1,3,7,10,12,13,16,17,19),ma=NULL)))
acf(residuals(s.arma), na.action=na.remove)
pacf(residuals(s.arma), na.action=na.remove)
summary(s.arma
         &lt;- arma(s, lag=list(ar=c(1,3,7,10,12,13,16,17,19),ma=12)))
summary(s.arma
         &lt;- arma(s, lag=list(ar=c(1,3,7,10,12,13,16,17),ma=12)))
plot(s.arma)
</code></pre>

<hr>
<h2 id='arma-methods'>Methods for Fitted ARMA Models</h2><span id='topic+arma-methods'></span><span id='topic+coef.arma'></span><span id='topic+vcov.arma'></span><span id='topic+residuals.arma'></span><span id='topic+fitted.arma'></span><span id='topic+print.arma'></span><span id='topic+plot.arma'></span>

<h3>Description</h3>

<p>Methods for fitted ARMA model objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'arma'
coef(object, ...)
## S3 method for class 'arma'
vcov(object, ...)
## S3 method for class 'arma'
residuals(object, ...)
## S3 method for class 'arma'
fitted(object, ...)
## S3 method for class 'arma'
print(x, digits = max(3, getOption("digits") - 3), ...)
## S3 method for class 'arma'
plot(x, ask = interactive(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arma-methods_+3A_object">object</code>, <code id="arma-methods_+3A_x">x</code></td>
<td>
<p>an object of class <code>"arma"</code>; usually, a result
of a call to <code><a href="tseries.html#topic+arma">arma</a></code>.</p>
</td></tr>
<tr><td><code id="arma-methods_+3A_digits">digits</code></td>
<td>
<p>see <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code>.</p>
</td></tr>
<tr><td><code id="arma-methods_+3A_ask">ask</code></td>
<td>
<p>Should the <code>plot</code> method work interactively?  See
<code><a href="base.html#topic+interactive">interactive</a></code>.</p>
</td></tr>
<tr><td><code id="arma-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>For <code>coef</code>, a numeric vector; for <code>vcov</code>, a numeric matrix;
for <code>residuals</code> and <code>fitted</code> a univariate time series;
for <code>plot</code> and <code>print</code>, the fitted ARMA model object.
</p>


<h3>Author(s)</h3>

<p>A. Trapletti
</p>


<h3>See Also</h3>

<p><code><a href="tseries.html#topic+arma">arma</a></code>
</p>

<hr>
<h2 id='bds.test'>BDS Test</h2><span id='topic+bds.test'></span><span id='topic+print.bdstest'></span>

<h3>Description</h3>

<p>Computes and prints the BDS test statistic for the null that <code>x</code>
is a series of i.i.d. random variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bds.test(x, m = 3, eps = seq(0.5 * sd(x), 2 * sd(x), length.out = 4),
         trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bds.test_+3A_x">x</code></td>
<td>
<p>a numeric vector or time series.</p>
</td></tr>
<tr><td><code id="bds.test_+3A_m">m</code></td>
<td>
<p>an integer indicating that the BDS test statistic is computed
for embedding dimensions <code>2</code>, ..., <code>m</code>.</p>
</td></tr>
<tr><td><code id="bds.test_+3A_eps">eps</code></td>
<td>
<p>a numeric vector of epsilon values for close points.  The
BDS test is computed for each element of <code>eps</code>.  It should be
set in terms of the standard deviation of <code>x</code>.</p>
</td></tr>
<tr><td><code id="bds.test_+3A_trace">trace</code></td>
<td>
<p>a logical indicating whether some informational output is
traced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test examines the &ldquo;spatial dependence&rdquo; of the observed
series.  To do this, the series is embedded in <code>m</code>-space and the
dependence of <code>x</code> is examined by counting &ldquo;near&rdquo; points.
Points for which the distance is less than <code>eps</code> are called
&ldquo;near&rdquo;.  The BDS test statistic is asymptotically standard Normal.
</p>
<p>Missing values are not allowed.
</p>
<p>There is a special print method for objects of class <code>"bdstest"</code>
which by default uses 4 digits to format real numbers.
</p>


<h3>Value</h3>

<p>A list with class <code>"bdstest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the values of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-values of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was
performed.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>a list with the components <code>m</code> and <code>eps</code>
containing the embedding dimensions and epsilon values for which the
statistic is computed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>B. LeBaron, Ported to R by A. Trapletti</p>


<h3>References</h3>

<p>J. B. Cromwell, W. C. Labys and M. Terraza (1994):
<em>Univariate Tests for Time Series Models</em>,
Sage, Thousand Oaks, CA, pages 32&ndash;36.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
bds.test(x)  # i.i.d. example

x &lt;- c(rnorm(50), runif(50))
bds.test(x)  # not identically distributed

x &lt;- quadmap(xi = 0.2, a = 4.0, n = 100)
bds.test(x)  # not independent
</code></pre>

<hr>
<h2 id='bev'>
Beveridge Wheat Price Index, 1500&ndash;1869.
</h2><span id='topic+bev'></span>

<h3>Description</h3>

<p>Contains the well-known Beveridge Wheat Price Index which gives annual
price data from 1500 to 1869, averaged over many locations in western
and central Europe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bev)
</code></pre>


<h3>Format</h3>

<p>A univariate time series with 370 observations.  The object is of
class <code>"ts"</code>.
</p>


<h3>Details</h3>

<p>This data provides an example of long memory time series which has the
appearance of being nonstationary in levels and yet also appears
overdifferenced.  See, e.g., Baillie (1996).
</p>


<h3>Source</h3>

<p>Time Series Data Library:
<a href="https://robjhyndman.com/TSDL/">https://robjhyndman.com/TSDL/</a>
</p>


<h3>References</h3>

<p>R. T. Baillie (1996):
Long Memory Processes and Fractional Integration in Econometrics.
<em>Journal of Econometrics</em>, <b>73</b>, 5&ndash;59.
</p>

<hr>
<h2 id='camp'>
Mount Campito Yearly Treering Data, -3435&ndash;1969.
</h2><span id='topic+camp'></span>

<h3>Description</h3>

<p>Contains annual tree-ring measurements from Mount Campito from 3426 BC
through 1969 AD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(camp)
</code></pre>


<h3>Format</h3>

<p>A univariate time series with 5405 observations. The object is of
class <code>"ts"</code>.
</p>


<h3>Details</h3>

<p>This series is a standard example for the concept of long memory time
series.
</p>
<p>The data was produced and assembled at the Tree Ring Laboratory at the
University of Arizona, Tuscon.
</p>


<h3>Source</h3>

<p>Time Series Data Library:
<a href="https://robjhyndman.com/TSDL/">https://robjhyndman.com/TSDL/</a>
</p>

<hr>
<h2 id='garch'>Fit GARCH Models to Time Series</h2><span id='topic+garch'></span><span id='topic+garch.control'></span>

<h3>Description</h3>

<p>Fit a Generalized Autoregressive Conditional Heteroscedastic GARCH(p,
q) time series model to the data by computing the maximum-likelihood
estimates of the conditionally normal model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>garch(x, order = c(1, 1), series = NULL, control = garch.control(...), ...)

garch.control(maxiter = 200, trace = TRUE, start = NULL,
  grad = c("analytical","numerical"), abstol = max(1e-20, .Machine$double.eps^2),
  reltol = max(1e-10, .Machine$double.eps^(2/3)), xtol = sqrt(.Machine$double.eps),
  falsetol = 1e2 * .Machine$double.eps, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="garch_+3A_x">x</code></td>
<td>
<p>a numeric vector or time series.</p>
</td></tr>
<tr><td><code id="garch_+3A_order">order</code></td>
<td>
<p>a two dimensional integer vector giving the orders of the
model to fit.  <code>order[2]</code> corresponds to the ARCH part and
<code>order[1]</code> to the GARCH part.</p>
</td></tr>
<tr><td><code id="garch_+3A_series">series</code></td>
<td>
<p>name for the series. Defaults to
<code>deparse(substitute(x))</code>.</p>
</td></tr>
<tr><td><code id="garch_+3A_control">control</code></td>
<td>
<p>a list of control parameters as set up by <code>garch.control</code>.</p>
</td></tr>
<tr><td><code id="garch_+3A_maxiter">maxiter</code></td>
<td>
<p>gives the maximum number of log-likelihood function
evaluations <code>maxiter</code> and the maximum number of iterations
<code>2*maxiter</code> the optimizer is allowed to compute.</p>
</td></tr>
<tr><td><code id="garch_+3A_trace">trace</code></td>
<td>
<p>logical. Trace optimizer output?</p>
</td></tr>
<tr><td><code id="garch_+3A_start">start</code></td>
<td>
<p>If given this numeric vector is used as the initial estimate
of the GARCH coefficients.  Default initialization is to set the
GARCH parameters to slightly positive values and to initialize the
intercept such that the unconditional variance of the initial GARCH
is equal to the variance of <code>x</code>.</p>
</td></tr>
<tr><td><code id="garch_+3A_grad">grad</code></td>
<td>
<p>character indicating whether analytical gradients or a numerical
approximation is used for the optimization.</p>
</td></tr>
<tr><td><code id="garch_+3A_abstol">abstol</code></td>
<td>
<p>absolute function convergence tolerance.</p>
</td></tr>
<tr><td><code id="garch_+3A_reltol">reltol</code></td>
<td>
<p>relative function convergence tolerance.</p>
</td></tr>
<tr><td><code id="garch_+3A_xtol">xtol</code></td>
<td>
<p>coefficient-convergence tolerance.</p>
</td></tr>
<tr><td><code id="garch_+3A_falsetol">falsetol</code></td>
<td>
<p>false convergence tolerance.</p>
</td></tr>
<tr><td><code id="garch_+3A_...">...</code></td>
<td>
<p>additional arguments for <code><a href="Matrix.html#topic+qr">qr</a></code> when computing
the asymptotic covariance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>garch</code> uses a Quasi-Newton optimizer to find the maximum
likelihood estimates of the conditionally normal model.  The first
max(p, q) values are assumed to be fixed.  The optimizer uses a hessian
approximation computed from the BFGS update.  Only a Cholesky factor
of the Hessian approximation is stored.  For more details see Dennis
et al. (1981), Dennis and Mei (1979), Dennis and More (1977), and
Goldfarb (1976).  The gradient is either computed analytically or
using a numerical approximation.
</p>


<h3>Value</h3>

<p>A list of class <code>"garch"</code> with the following elements:
</p>
<table>
<tr><td><code>order</code></td>
<td>
<p>the order of the fitted model.</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>estimated GARCH coefficients for the fitted model.</p>
</td></tr>
<tr><td><code>n.likeli</code></td>
<td>
<p>the negative log-likelihood function evaluated at the
coefficient estimates (apart from some constant).</p>
</td></tr>
<tr><td><code>n.used</code></td>
<td>
<p>the number of observations of <code>x</code>.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the series of residuals.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the bivariate series of conditional standard
deviation predictions for <code>x</code>.</p>
</td></tr>
<tr><td><code>series</code></td>
<td>
<p>the name of the series <code>x</code>.</p>
</td></tr>
<tr><td><code>frequency</code></td>
<td>
<p>the frequency of the series <code>x</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call of the <code>garch</code> function.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>outer product of gradient estimate of the asymptotic-theory
covariance matrix for the coefficient estimates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. Trapletti, the whole GARCH part;
D. M. Gay, the FORTRAN optimizer
</p>


<h3>References</h3>

<p>A. K. Bera and M. L. Higgins (1993):
ARCH Models: Properties, Estimation and Testing.
<em>J. Economic Surveys</em> <b>7</b> 305&ndash;362.
</p>
<p>T. Bollerslev (1986):
Generalized Autoregressive Conditional Heteroscedasticity.
<em>Journal of Econometrics</em> <b>31</b>, 307&ndash;327.
</p>
<p>R. F. Engle (1982):
Autoregressive Conditional Heteroscedasticity with Estimates of the
Variance of United Kingdom Inflation.
<em>Econometrica</em> <b>50</b>, 987&ndash;1008.
</p>
<p>J. E. Dennis, D. M. Gay, and R. E. Welsch (1981):
Algorithm 573 &mdash; An Adaptive Nonlinear Least-Squares
Algorithm.
<em>ACM Transactions on Mathematical Software</em> <b>7</b>, 369&ndash;383.
</p>
<p>J. E. Dennis and H. H. W. Mei (1979):
Two New Unconstrained Optimization Algorithms which use Function and
Gradient Values.
<em>J. Optim. Theory Applic.</em> <b>28</b>, 453&ndash;482.
</p>
<p>J. E. Dennis and J. J. More (1977):
Quasi-Newton Methods, Motivation and Theory.
<em>SIAM Rev.</em> <b>19</b>, 46&ndash;89.
</p>
<p>D. Goldfarb (1976):
Factorized Variable Metric Methods for Unconstrained Optimization.
<em>Math. Comput.</em> <b>30</b>, 796&ndash;811.
</p>


<h3>See Also</h3>

<p><code><a href="tseries.html#topic+summary.garch">summary.garch</a></code> for summarizing GARCH model fits;
<code><a href="tseries.html#topic+garch-methods">garch-methods</a></code> for further methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1100
a &lt;- c(0.1, 0.5, 0.2)  # ARCH(2) coefficients
e &lt;- rnorm(n)  
x &lt;- double(n)
x[1:2] &lt;- rnorm(2, sd = sqrt(a[1]/(1.0-a[2]-a[3]))) 
for(i in 3:n)  # Generate ARCH(2) process
{
  x[i] &lt;- e[i]*sqrt(a[1]+a[2]*x[i-1]^2+a[3]*x[i-2]^2)
}
x &lt;- ts(x[101:1100])
x.arch &lt;- garch(x, order = c(0,2))  # Fit ARCH(2) 
summary(x.arch)                     # Diagnostic tests
plot(x.arch)                        

data(EuStockMarkets)  
dax &lt;- diff(log(EuStockMarkets))[,"DAX"]
dax.garch &lt;- garch(dax)  # Fit a GARCH(1,1) to DAX returns
summary(dax.garch)       # ARCH effects are filtered. However, 
plot(dax.garch)          # conditional normality seems to be violated
</code></pre>

<hr>
<h2 id='garch-methods'>Methods for Fitted GARCH Models</h2><span id='topic+garch-methods'></span><span id='topic+predict.garch'></span><span id='topic+coef.garch'></span><span id='topic+vcov.garch'></span><span id='topic+residuals.garch'></span><span id='topic+fitted.garch'></span><span id='topic+print.garch'></span><span id='topic+plot.garch'></span><span id='topic+logLik.garch'></span>

<h3>Description</h3>

<p>Methods for fitted GARCH model objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garch'
predict(object, newdata, genuine = FALSE, ...)
## S3 method for class 'garch'
coef(object, ...)
## S3 method for class 'garch'
vcov(object, ...)
## S3 method for class 'garch'
residuals(object, ...)
## S3 method for class 'garch'
fitted(object, ...)
## S3 method for class 'garch'
print(x, digits = max(3, getOption("digits") - 3), ...)
## S3 method for class 'garch'
plot(x, ask = interactive(), ...)
## S3 method for class 'garch'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="garch-methods_+3A_object">object</code>, <code id="garch-methods_+3A_x">x</code></td>
<td>
<p>an object of class <code>"garch"</code>; usually, a result
of a call to <code><a href="tseries.html#topic+garch">garch</a></code>.</p>
</td></tr>
<tr><td><code id="garch-methods_+3A_newdata">newdata</code></td>
<td>
<p>a numeric vector or time series to compute GARCH
predictions.  Defaults to <code>eval(parse(text=object$series))</code>.</p>
</td></tr>
<tr><td><code id="garch-methods_+3A_genuine">genuine</code></td>
<td>
<p>a logical indicating whether a genuine prediction
should be made, i.e., a prediction for which there is no target
observation available.</p>
</td></tr>
<tr><td><code id="garch-methods_+3A_digits">digits</code></td>
<td>
<p>see <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code>.</p>
</td></tr>
<tr><td><code id="garch-methods_+3A_ask">ask</code></td>
<td>
<p>Should the <code>plot</code> method work interactively?  See
<code><a href="base.html#topic+interactive">interactive</a></code>.</p>
</td></tr>
<tr><td><code id="garch-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>predict</code> returns +/- the conditional standard deviation
predictions from a fitted GARCH model.
</p>
<p><code>coef</code> returns the coefficient estimates.
</p>
<p><code>vcov</code> the associated covariance matrix estimate (outer product of gradients estimator).
</p>
<p><code>residuals</code> returns the GARCH residuals, i.e., the time series
used to fit the model divided by the computed conditional standard
deviation predictions for this series. Under the assumption of
conditional normality the residual series should be i.i.d. standard
normal.  
</p>
<p><code>fitted</code> returns +/- the conditional standard deviation
predictions for the series which has been used to fit the model.
</p>
<p><code>plot</code> graphically investigates normality and remaining ARCH
effects for the residuals.
</p>
<p><code>logLik</code> returns the log-likelihood value of the GARCH(p, q)
model represented by <code>object</code> evaluated at the estimated
coefficients. It is assumed that first max(p, q) values are fixed.
</p>


<h3>Value</h3>

<p>For <code>predict</code> a bivariate time series (two-column matrix) of
predictions. 
</p>
<p>For <code>coef</code>, a numeric vector, for <code>residuals</code> and
<code>fitted</code> a univariate (vector) and a bivariate time series
(two-column matrix), respectively.
</p>
<p>For <code>plot</code> and <code>print</code>, the fitted GARCH model object.
</p>


<h3>Author(s)</h3>

<p>A. Trapletti
</p>

<hr>
<h2 id='get.hist.quote'>Download Historical Finance Data</h2><span id='topic+get.hist.quote'></span>

<h3>Description</h3>

<p>Download historical financial data from a given data provider over
the WWW.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.hist.quote(instrument = "^gdax", start, end,
               quote = c("Open", "High", "Low", "Close"),
               provider = c("yahoo"), method = NULL,
               origin = "1899-12-30", compression = "d",
	       retclass = c("zoo", "ts"), quiet = FALSE, drop = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.hist.quote_+3A_instrument">instrument</code></td>
<td>
<p>a character string giving the name of the quote
symbol to download.  See the web page of the data provider for
information about the available quote symbols.</p>
</td></tr>
<tr><td><code id="get.hist.quote_+3A_start">start</code></td>
<td>
<p>an R object specifying the date of the start of the
period to download.  This must be in a form which is recognized by
<code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>, which includes R POSIX date/time objects,
objects of class <code>"date"</code> (from package <code>date</code>) and
<code>"chron"</code> and <code>"dates"</code> (from package <code>chron</code>), and
character strings representing dates in ISO 8601 format.  Defaults
to 1992-01-02.</p>
</td></tr>
<tr><td><code id="get.hist.quote_+3A_end">end</code></td>
<td>
<p>an R object specifying the end of the download period, see
above.  Defaults to yesterday.</p>
</td></tr>
<tr><td><code id="get.hist.quote_+3A_quote">quote</code></td>
<td>
<p>a character string or vector indicating whether to
download opening, high, low, or closing quotes, or volume.  For the
default provider, this can be specified as <code>"Open"</code>,
<code>"High"</code>, <code>"Low"</code>, <code>"Close"</code>, <code>"Adjusted"</code>, and
<code>"Volume"</code>, respectively.  Abbreviations are allowed.</p>
</td></tr>
<tr><td><code id="get.hist.quote_+3A_provider">provider</code></td>
<td>
<p>a character string with the name of the data
provider.  Currently, only <code>"yahoo"</code> is supported via 
<code><a href="quantmod.html#topic+getSymbols.yahoo">getSymbols</a></code> from package
<span class="pkg">quantmod</span> for the Yahoo Finance source.
Provider <code>"oanda"</code> is no longer available.</p>
</td></tr>
<tr><td><code id="get.hist.quote_+3A_method">method</code></td>
<td>
<p>No longer used.</p>
</td></tr>
<tr><td><code id="get.hist.quote_+3A_origin">origin</code></td>
<td>
<p>an R object specifying the origin of the Julian dates, see
above.  Defaults to 1899-12-30 (Popular spreadsheet programs
internally also use Julian dates with this origin).</p>
</td></tr>
<tr><td><code id="get.hist.quote_+3A_compression">compression</code></td>
<td>
<p>Governs the granularity of the retrieved data;
<code>"d"</code> for daily, <code>"w"</code> for weekly or <code>"m"</code> for
monthly.  Defaults to <code>"d"</code>.  For the provider <code>"oanda"</code>,
this argument is ignored.</p>
</td></tr>
<tr><td><code id="get.hist.quote_+3A_retclass">retclass</code></td>
<td>
<p>character specifying which class the return value
should have: can be either <code>"zoo"</code> (with <code>"Date"</code> index),
or <code>"ts"</code> (with numeric index corresponding to days since
<code>origin</code>).</p>
</td></tr>
<tr><td><code id="get.hist.quote_+3A_quiet">quiet</code></td>
<td>
<p>logical. Should status messages (if any) be suppressed?</p>
</td></tr>
<tr><td><code id="get.hist.quote_+3A_drop">drop</code></td>
<td>
<p>logical.  If <code>TRUE</code> the result is coerced to the
lowest possible dimension.  Default is <code>FALSE</code>.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>A time series containing the data either as a <code>"zoo"</code> series
(default) or a <code>"ts"</code> series.  The <code>"zoo"</code> series is created
with <code><a href="zoo.html#topic+zoo">zoo</a></code> and has an index of class <code>"Date"</code>.
If a <code>"ts"</code> series is returned, the index is in physical time,
i.e., weekends, holidays, and missing days are filled with <code>NA</code>s
if not available.  The time scale is given in Julian dates (days since
the <code>origin</code>).
</p>


<h3>Author(s)</h3>

<p>A. Trapletti</p>


<h3>See Also</h3>

<p><code><a href="quantmod.html#topic+getSymbols">getSymbols</a></code> for downloads from various
providers; 
<code><a href="zoo.html#topic+zoo">zoo</a></code>,
<code><a href="stats.html#topic+ts">ts</a></code>,
<code><a href="base.html#topic+as.Date">as.Date</a></code>,
<code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tryCatch({
  x &lt;- get.hist.quote(instrument = "^gspc", start = "1998-01-01",
                      quote = "Close")
  plot(x)

  x &lt;- get.hist.quote(instrument = "ibm", quote = c("Cl", "Vol"))
  plot(x, main = "International Business Machines Corp")

  spc &lt;- get.hist.quote(instrument = "^gspc", start = "1998-01-01",
         quote = "Close")
  ibm &lt;- get.hist.quote(instrument = "ibm",  start = "1998-01-01",
         quote = "Adj")
  require("zoo")		# For merge() method.
  x &lt;- merge(spc, ibm)
  plot(x, main = "IBM vs S&amp;P 500")
}, error = identity)
</code></pre>

<hr>
<h2 id='ice.river'>
Icelandic River Data
</h2><span id='topic+ice.river'></span><span id='topic+flow.vat'></span><span id='topic+flow.jok'></span><span id='topic+prec'></span><span id='topic+temp'></span>

<h3>Description</h3>

<p>Contains the Icelandic river data as presented in Tong (1990),
pages 432&ndash;440.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ice.river)
</code></pre>


<h3>Format</h3>

<p>4 univariate time series <code>flow.vat</code>, <code>flow.jok</code>,
<code>prec</code>, and <code>temp</code>, each with 1095 observations and the
joint series <code>ice.river</code>.
</p>


<h3>Details</h3>

<p>The series are daily observations from Jan. 1, 1972 to Dec. 31, 1974
on 4 variables: <code>flow.vat</code>, mean daily flow of Vatnsdalsa river
(cms), <code>flow.jok</code>, mean daily flow of Jokulsa Eystri river (cms),
<code>prec</code>, daily precipitation in Hveravellir (mm), and mean daily
temperature in Hveravellir (deg C).
</p>
<p>These datasets were introduced into the literature in a paper by
Tong, Thanoon, and Gudmundsson (1985).
</p>


<h3>Source</h3>

<p>Time Series Data Library:
<a href="https://robjhyndman.com/TSDL/">https://robjhyndman.com/TSDL/</a>
</p>


<h3>References</h3>

<p>H. Tong (1990):
<em>Non-Linear Time Series, A Dynamical System Approach</em>.
Oxford University Press, Oxford.
</p>
<p>H. Tong, B. Thanoon, and G. Gudmundsson (1985):
Threshold time series modelling of two Icelandic riverflow
systems.
<em>Water Resources Bulletin</em>, <b>21</b>, 651&ndash;661.
</p>

<hr>
<h2 id='irts'>Irregularly Spaced Time-Series</h2><span id='topic+irts'></span><span id='topic+is.irts'></span><span id='topic+as.irts'></span><span id='topic+as.irts.default'></span><span id='topic+as.irts.zoo'></span>

<h3>Description</h3>

<p>The function <code>irts</code> is used to create irregular time-series
objects.  
</p>
<p><code>as.irts</code> coerces an object to an irregularly spaced
time-series. <code>is.irts</code> tests whether an object is an irregularly
spaced time series. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irts(time, value)
as.irts(object)
is.irts(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irts_+3A_time">time</code></td>
<td>
<p>a numeric vector or a vector of class <code>"POSIXct"</code>
representing the time-stamps of the irregular time-series
object. The elements of the numeric vector are construed as the
(signed) number of seconds since the beginning of 1970, see
<code><a href="base.html#topic+POSIXct">POSIXct</a></code>.</p>
</td></tr> 
<tr><td><code id="irts_+3A_value">value</code></td>
<td>
<p>a numeric vector or matrix representing the values of the
irregular time-series object.</p>
</td></tr>
<tr><td><code id="irts_+3A_object">object</code></td>
<td>
<p>an R object to be coerced to an irregular time-series
object or an R object to be tested whether it is an irregular
time-series object.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The function <code>irts</code> is used to create irregular time-series
objects. These are scalar or vector valued time series indexed by a
time-stamp of class <code>"POSIXct"</code>. Unlike objects of class
<code>"ts"</code>, they can be used to represent irregularly spaced
time-series.
</p>


<h3>Value</h3>

<p>A list of class <code>"irts"</code> with the following elements:
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>a vector of class <code>"POSIXct"</code>.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>a numeric vector or matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. Trapletti
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ts">ts</a></code>,
<code><a href="base.html#topic+POSIXct">POSIXct</a></code>,
<code><a href="tseries.html#topic+irts-methods">irts-methods</a></code>,
<code><a href="tseries.html#topic+irts-functions">irts-functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10
t &lt;- cumsum(rexp(n, rate = 0.1))
v &lt;- rnorm(n)
x &lt;- irts(t, v)
x

as.irts(cbind(t, v))

is.irts(x)

# Multivariate
u &lt;- rnorm(n)
irts(t, cbind(u, v))
</code></pre>

<hr>
<h2 id='irts-functions'>Basic Functions for Irregular Time-Series Objects</h2><span id='topic+irts-functions'></span><span id='topic+approx.irts'></span><span id='topic+daysecond'></span><span id='topic+is.businessday'></span><span id='topic+is.weekend'></span><span id='topic+read.irts'></span><span id='topic+weekday'></span><span id='topic+write.irts'></span>

<h3>Description</h3>

<p>Basic functions related to irregular time-series objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daysecond(object, tz = "GMT")
approx.irts(object, time, ...)
is.businessday(object, tz = "GMT")
is.weekend(object, tz = "GMT")
read.irts(file, format = "%Y-%m-%d %H:%M:%S", tz = "GMT", ...)
weekday(object, tz = "GMT")
write.irts(object, file = "", append = FALSE, quote = FALSE,
           sep = " ", eol = "\n", na = "NA", dec = ".",
           row.names = FALSE, col.names = FALSE, qmethod = "escape",
           format = "%Y-%m-%d %H:%M:%S", tz = "GMT", usetz = FALSE,
           format.value = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irts-functions_+3A_object">object</code></td>
<td>
<p>an object of class <code>"irts"</code>; usually, a result 
of a call to <code><a href="tseries.html#topic+irts">irts</a></code>.</p>
</td></tr>
<tr><td><code id="irts-functions_+3A_format">format</code>, <code id="irts-functions_+3A_tz">tz</code>, <code id="irts-functions_+3A_usetz">usetz</code></td>
<td>
<p>formatting related arguments, see
<code><a href="base.html#topic+format.POSIXct">format.POSIXct</a></code>.</p>
</td></tr> 
<tr><td><code id="irts-functions_+3A_time">time</code></td>
<td>
<p>an object of class <code>"POSIXct"</code> specifying the times
at which to interpolate the irregularly spaced time-series.</p>
</td></tr>
<tr><td><code id="irts-functions_+3A_file">file</code>, <code id="irts-functions_+3A_append">append</code>, <code id="irts-functions_+3A_quote">quote</code>, <code id="irts-functions_+3A_sep">sep</code>, <code id="irts-functions_+3A_eol">eol</code>, <code id="irts-functions_+3A_na">na</code>, <code id="irts-functions_+3A_dec">dec</code>, <code id="irts-functions_+3A_row.names">row.names</code>, <code id="irts-functions_+3A_col.names">col.names</code>, <code id="irts-functions_+3A_qmethod">qmethod</code></td>
<td>
<p>reading and writing related arguments, see
<code><a href="utils.html#topic+read.table">read.table</a></code> and <code><a href="utils.html#topic+write.table">write.table</a></code>.</p>
</td></tr>
<tr><td><code id="irts-functions_+3A_format.value">format.value</code></td>
<td>
<p>a string which specifies the formatting of the
values when writing an irregular time-series object to a
file. <code>format.value</code> is passed unchanged as argument
<code>format</code> to the function <code><a href="base.html#topic+formatC">formatC</a></code>.</p>
</td></tr> 
<tr><td><code id="irts-functions_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods: for
<code>approx.irts</code> passed to <code><a href="stats.html#topic+approx">approx</a></code>; for
<code>read.irts</code> passed to <code><a href="utils.html#topic+read.table">read.table</a></code>; for
<code>write.irts</code> passed to <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>daysecond</code> and <code>weekday</code> return the number of seconds since
midnight (the same day) and the weekday as a decimal number (0-6,
Sunday is 0), respectively.
</p>
<p><code>is.businessday</code> and <code>is.weekend</code> test which entries of an
irregular time-series object are recorded on business days and
weekends, respectively. 
</p>
<p><code>approx.irts</code> interpolates an irregularly spaced time-series at
prespecified times.
</p>
<p><code>read.irts</code> is the function to read irregular time-series
objects from a file.
</p>
<p><code>write.irts</code> is the function to write irregular time-series
objects to a file.
</p>


<h3>Value</h3>

<p>For <code>daysecond</code> and <code>weekday</code> a vector of decimal numbers
representing the number of seconds and the weekday, respectively.
</p>
<p>For <code>is.businessday</code> and <code>is.weekend</code> a vector of
<code>"logical"</code> representing the test results for each time.
</p>
<p>For <code>approx.irts</code>, <code>read.irts</code> and <code>write.irts</code> an
object of class <code>"irts"</code>.
</p>


<h3>Author(s)</h3>

<p>A. Trapletti
</p>


<h3>See Also</h3>

<p><code><a href="tseries.html#topic+irts">irts</a></code>,
<code><a href="tseries.html#topic+irts-methods">irts-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10
t &lt;- cumsum(rexp(n, rate = 0.1))
v &lt;- rnorm(n)
x &lt;- irts(t, v)

daysecond(x)
weekday(x)
is.businessday(x)
is.weekend(x)
x

approx.irts(x, seq(ISOdatetime(1970, 1, 1, 0, 0, 0, tz = "GMT"),
            by = "10 secs", length.out = 7), rule = 2)

## Not run: 
file &lt;- tempfile()

# To write an irregular time-series object to a file one might use
write.irts(x, file = file)

# To read an irregular time-series object from a file one might use
read.irts(file = file)

unlink(file)

## End(Not run)
</code></pre>

<hr>
<h2 id='irts-methods'>Methods for Irregular Time-Series Objects</h2><span id='topic+irts-methods'></span><span id='topic+lines.irts'></span><span id='topic+plot.irts'></span><span id='topic+points.irts'></span><span id='topic+print.irts'></span><span id='topic+time.irts'></span><span id='topic+value'></span><span id='topic+value.irts'></span><span id='topic++5B.irts'></span>

<h3>Description</h3>

<p>Methods for irregular time-series objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'irts'
lines(x, type = "l", ...)
## S3 method for class 'irts'
plot(x, type = "l", plot.type = c("multiple", "single"), 
     xlab = "Time", ylab = NULL, main = NULL, ylim = NULL,
     oma = c(6, 0, 5, 0), ...)
## S3 method for class 'irts'
points(x, type = "p", ...)                    
## S3 method for class 'irts'
print(x, format = "%Y-%m-%d %H:%M:%S", tz = "GMT",
      usetz = TRUE, format.value = NULL, ...)
## S3 method for class 'irts'
time(x, ...)
## S3 method for class 'irts'
value(x, ...)
## S3 method for class 'irts'
x[i, j, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irts-methods_+3A_x">x</code></td>
<td>
<p>an object of class <code>"irts"</code>; usually, a result 
of a call to <code><a href="tseries.html#topic+irts">irts</a></code>.</p>
</td></tr>
<tr><td><code id="irts-methods_+3A_type">type</code>, <code id="irts-methods_+3A_plot.type">plot.type</code>, <code id="irts-methods_+3A_xlab">xlab</code>, <code id="irts-methods_+3A_ylab">ylab</code>, <code id="irts-methods_+3A_main">main</code>, <code id="irts-methods_+3A_ylim">ylim</code>, <code id="irts-methods_+3A_oma">oma</code></td>
<td>
<p>graphical
arguments, see <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+points">points</a></code>,
<code><a href="graphics.html#topic+lines">lines</a></code>, <code><a href="graphics.html#topic+par">par</a></code>, and <code><a href="stats.html#topic+plot.ts">plot.ts</a></code>.</p>
</td></tr>
<tr><td><code id="irts-methods_+3A_format">format</code>, <code id="irts-methods_+3A_tz">tz</code>, <code id="irts-methods_+3A_usetz">usetz</code></td>
<td>
<p>formatting related arguments, see
<code><a href="base.html#topic+format.POSIXct">format.POSIXct</a></code>.</p>
</td></tr>
<tr><td><code id="irts-methods_+3A_format.value">format.value</code></td>
<td>
<p>a string which specifies the formatting of the
values when printing an irregular time-series 
object. <code>format.value</code> is passed unchanged as argument
<code>format</code> to the function <code><a href="base.html#topic+formatC">formatC</a></code>.</p>
</td></tr>
<tr><td><code id="irts-methods_+3A_i">i</code>, <code id="irts-methods_+3A_j">j</code></td>
<td>
<p>indices specifying the parts to extract from an irregular
time-series object.</p>
</td></tr>
<tr><td><code id="irts-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods: for
<code>lines</code> passed to <code><a href="graphics.html#topic+lines">lines</a></code>; for <code>plot</code> passed
to <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+plot.default">plot.default</a></code>, and
<code><a href="graphics.html#topic+mtext">mtext</a></code>; for <code>points</code> passed to
<code><a href="graphics.html#topic+points">points</a></code>; for <code>print</code> passed to
<code><a href="base.html#topic+formatC">formatC</a></code>; for <code>time</code>, <code>value</code>, and
<code>[.irts</code> unused.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>plot</code> is the method for plotting irregular time-series objects.
</p>
<p><code>points</code> and <code>lines</code> are the methods for drawing a sequence
of points as given by an irregular time-series object and joining the
corresponding points with line segments, respectively.
</p>
<p><code>print</code> is the method for printing irregular time-series objects.
</p>
<p><code>time</code> and <code>value</code> are the methods for extracting the
sequence of times and the sequence of values of an irregular
time-series object.
</p>
<p><code>[.irts</code> is the method for extracting parts of irregular
time-series objects. 
</p>


<h3>Value</h3>

<p>For <code>time</code> an object of class <code>"POSIXct"</code> representing the
sequence of times. For <code>value</code> a vector or matrix representing
the sequence of values. 
</p>
<p>For <code>[.irts</code> an object of class <code>"irts"</code> representing the
extracted part.
</p>
<p>For <code>plot</code>, <code>points</code>, <code>lines</code>, and <code>print</code> the
irregular time-series object. 
</p>


<h3>Author(s)</h3>

<p>A. Trapletti
</p>


<h3>See Also</h3>

<p><code><a href="tseries.html#topic+irts">irts</a></code>,
<code><a href="tseries.html#topic+irts-functions">irts-functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10
t &lt;- cumsum(rexp(n, rate = 0.1))
v &lt;- rnorm(n)
x &lt;- irts(t, v)

x
time(x)
value(x)
plot(x)
points(x)

t &lt;- cumsum(c(t[1], rexp(n-1, rate = 0.2)))
v &lt;- rnorm(n, sd = 0.1)
x &lt;- irts(t, v)

lines(x, col = "red")
points(x, col = "red")

# Multivariate
t &lt;- cumsum(rexp(n, rate = 0.1))
u &lt;- rnorm(n)
v &lt;- rnorm(n)
x &lt;- irts(t, cbind(u, v))

x
x[,1]
x[1:3,]
x[1:3,1]
plot(x)
</code></pre>

<hr>
<h2 id='jarque.bera.test'>Jarque&ndash;Bera Test</h2><span id='topic+jarque.bera.test'></span>

<h3>Description</h3>

<p>Tests the null of normality for <code>x</code> using the Jarque-Bera
test statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jarque.bera.test(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jarque.bera.test_+3A_x">x</code></td>
<td>
<p>a numeric vector or time series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test is a joint statistic using skewness and kurtosis
coefficients.
</p>
<p>Missing values are not allowed.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was
performed.</p>
</td></tr> 
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. Trapletti</p>


<h3>References</h3>

<p>J. B. Cromwell, W. C. Labys and M. Terraza (1994):
<em>Univariate Tests for Time Series Models</em>,
Sage, Thousand Oaks, CA, pages 20&ndash;22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)  # null
jarque.bera.test(x)

x &lt;- runif(100)  # alternative
jarque.bera.test(x)
</code></pre>

<hr>
<h2 id='kpss.test'>KPSS Test for Stationarity</h2><span id='topic+kpss.test'></span>

<h3>Description</h3>

<p>Computes the Kwiatkowski-Phillips-Schmidt-Shin (KPSS) test for the
null hypothesis that <code>x</code> is level or trend stationary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kpss.test(x, null = c("Level", "Trend"), lshort = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kpss.test_+3A_x">x</code></td>
<td>
<p>a numeric vector or univariate time series.</p>
</td></tr>
<tr><td><code id="kpss.test_+3A_null">null</code></td>
<td>
<p>indicates the null hypothesis and must be one of
<code>"Level"</code> (default) or <code>"Trend"</code>.  You can specify just
the initial letter.</p>
</td></tr>
<tr><td><code id="kpss.test_+3A_lshort">lshort</code></td>
<td>
<p>a logical indicating whether the short or long version
of the truncation lag parameter is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To estimate <code>sigma^2</code> the Newey-West estimator is used.
If <code>lshort</code> is <code>TRUE</code>, then the truncation lag parameter is
set to <code>trunc(4*(n/100)^0.25)</code>, otherwise
<code>trunc(12*(n/100)^0.25)</code> is used.  The p-values are interpolated
from Table 1 of Kwiatkowski et al. (1992). If the computed statistic
is outside the table of critical values, then a warning message is
generated.
</p>
<p>Missing values are not handled.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the truncation lag parameter.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was
performed.</p>
</td></tr> 
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. Trapletti</p>


<h3>References</h3>

<p>D. Kwiatkowski, P. C. B. Phillips, P. Schmidt, and Y. Shin (1992):
Testing the Null Hypothesis of Stationarity against the Alternative of
a Unit Root.
<em>Journal of Econometrics</em> <b>54</b>, 159&ndash;178.
</p>


<h3>See Also</h3>

<p><code><a href="tseries.html#topic+pp.test">pp.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1000)  # is level stationary
kpss.test(x)

y &lt;- cumsum(x)  # has unit root
kpss.test(y)

x &lt;- 0.3*(1:1000)+rnorm(1000)  # is trend stationary
kpss.test(x, null = "Trend")
</code></pre>

<hr>
<h2 id='maxdrawdown'>Maximum Drawdown or Maximum Loss</h2><span id='topic+maxdrawdown'></span>

<h3>Description</h3>

<p>This function computes the maximum drawdown or maximum loss of the
univariate time series (or vector) <code>x</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxdrawdown(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxdrawdown_+3A_x">x</code></td>
<td>
<p>a numeric vector or univariate time series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The max drawdown or max loss statistic is defined as the maximum
value drop after one of the peaks of <code>x</code>. For financial
instruments the max drawdown represents the worst investment loss for
a buy-and-hold strategy invested in <code>x</code>.
</p>


<h3>Value</h3>

<p>A list containing the following three components:
</p>
<table>
<tr><td><code>maxdrawdown</code></td>
<td>
<p>double representing the max drawdown or max
loss statistic.</p>
</td></tr>
<tr><td><code>from</code></td>
<td>
<p>the index (or vector of indices) where the max drawdown
period starts.</p>
</td></tr> 
<tr><td><code>to</code></td>
<td>
<p>the index (or vector of indices) where the max drawdown
period ends.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>A. Trapletti</p>


<h3>See Also</h3>

<p><code><a href="tseries.html#topic+sterling">sterling</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Toy example
x &lt;- c(1:10, 9:7, 8:14, 13:8, 9:20)
mdd &lt;- maxdrawdown(x)
mdd

plot(x)
segments(mdd$from, x[mdd$from], mdd$to, x[mdd$from], col="grey")
segments(mdd$from, x[mdd$to], mdd$to, x[mdd$to], col="grey")
mid &lt;- (mdd$from + mdd$to)/2
arrows(mid, x[mdd$from], mid, x[mdd$to], col="red", length = 0.16)

# Realistic example
data(EuStockMarkets)
dax &lt;- log(EuStockMarkets[,"DAX"])
mdd &lt;- maxdrawdown(dax)
mdd

plot(dax)
segments(time(dax)[mdd$from], dax[mdd$from],
         time(dax)[mdd$to], dax[mdd$from], col="grey")
segments(time(dax)[mdd$from], dax[mdd$to],
         time(dax)[mdd$to], dax[mdd$to], col="grey")
mid &lt;- time(dax)[(mdd$from + mdd$to)/2]
arrows(mid, dax[mdd$from], mid, dax[mdd$to], col="red", length = 0.16)
</code></pre>

<hr>
<h2 id='na.remove'>NA Handling Routines for Time Series</h2><span id='topic+na.remove'></span><span id='topic+na.remove.ts'></span><span id='topic+na.remove.default'></span>

<h3>Description</h3>

<p>Observations with missing values in some of the variables are
removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.remove(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na.remove_+3A_object">object</code></td>
<td>
<p>a numeric matrix, vector, univariate, or multivariate
time series.</p>
</td></tr>
<tr><td><code id="na.remove_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>na.remove.ts</code> this changes the &ldquo;intrinsic&rdquo; time scale.  It
is assumed that both, the new and the old time scale are synchronized
at the first and the last valid observation.  In between, the new
series is equally spaced in the new time scale.
</p>


<h3>Value</h3>

<p>An object without missing values.  The attribute <code>"na.removed"</code>
contains the indices of the removed missing values in <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>A. Trapletti</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+na.omit">na.omit</a></code>,
<code><a href="stats.html#topic+na.fail">na.fail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-ts(c(5453.08,5409.24,5315.57,5270.53, # one and a half week stock index
        5211.66,NA,NA,5160.80,5172.37))  # data including a weekend
na.remove(x)  # eliminate weekend and introduce ``business'' time scale
</code></pre>

<hr>
<h2 id='NelPlo'>
Nelson&ndash;Plosser Macroeconomic Time Series
</h2><span id='topic+NelPlo'></span><span id='topic+cpi'></span><span id='topic+ip'></span><span id='topic+gnp.nom'></span><span id='topic+vel'></span><span id='topic+emp'></span><span id='topic+int.rate'></span><span id='topic+nom.wages'></span><span id='topic+gnp.def'></span><span id='topic+money.stock'></span><span id='topic+gnp.real'></span><span id='topic+stock.prices'></span><span id='topic+gnp.capita'></span><span id='topic+real.wages'></span><span id='topic+unemp'></span>

<h3>Description</h3>

<p>These are the extended Nelson-Plosser Data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NelPlo)
</code></pre>


<h3>Format</h3>

<p>14 macroeconomic time series: <code>cpi</code>, <code>ip</code>, <code>gnp.nom</code>,
<code>vel</code>, <code>emp</code>, <code>int.rate</code>, <code>nom.wages</code>,
<code>gnp.def</code>, <code>money.stock</code>, <code>gnp.real</code>,
<code>stock.prices</code>, <code>gnp.capita</code>, <code>real.wages</code>, and
<code>unemp</code> and the joint series <code>NelPlo</code>.
</p>


<h3>Details</h3>

<p>The series are of various lengths but all end in 1988.
The data set contains the following series:
consumer price index, industrial production, nominal GNP, velocity,
employment, interest rate, nominal wages, GNP deflator, money stock,
real GNP, stock prices (S&amp;P500), GNP per capita, real wages,
unemployment.
</p>


<h3>Source</h3>

<p>C. R. Nelson and C. I. Plosser (1982),
Trends and Random Walks in Macroeconomic Time Series.
<em>Journal of Monetary Economics</em>, <b>10</b>, 139&ndash;162.
<a href="https://doi.org/10.1016/0304-3932%2882%2990012-5">doi:10.1016/0304-3932(82)90012-5</a>.
</p>
<p>Formerly in the Journal of Business and Economic Statistics data
archive, currently at
<a href="http://korora.econ.yale.edu/phillips/data/np&amp;enp.dat">http://korora.econ.yale.edu/phillips/data/np&amp;enp.dat</a>.
</p>


<h3>References</h3>

<p>G. Koop and M. F. J. Steel (1994),
A Decision-Theoretic Analysis of the Unit-Root Hypothesis using
Mixtures of Elliptical Models.
<em>Journal of Business and Economic Statistics</em>, <b>12</b>,
95&ndash;107.
<a href="https://doi.org/10.1080/07350015.1994.10509993">doi:10.1080/07350015.1994.10509993</a>.
</p>

<hr>
<h2 id='nino'>
Sea Surface Temperature (SST) Nino 3 and Nino 3.4 Indices
</h2><span id='topic+nino'></span><span id='topic+nino3'></span><span id='topic+nino3.4'></span>

<h3>Description</h3>

<p>These data constitutes of Nino Region 3 and Nino Region 3.4 SST 
indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nino)
</code></pre>


<h3>Format</h3>

<p>Two univariate time series <code>nino3</code> and <code>nino3.4</code> with 598
observations and the joint series <code>nino</code>.
</p>


<h3>Details</h3>

<p>The measurements are given in degrees Celsius.
The Nino 3 Region is bounded by 90W-150W and 5S-5N.
The Nino 3.4 Region is bounded by 120W-170W and 5S-5N.
</p>


<h3>Source</h3>

<p>Climate Prediction Center:
<a href="https://www.cpc.ncep.noaa.gov/data/indices/">https://www.cpc.ncep.noaa.gov/data/indices/</a>
</p>

<hr>
<h2 id='plotOHLC'>Plot Open-High-Low-Close Bar Chart</h2><span id='topic+plotOHLC'></span>

<h3>Description</h3>

<p>Plots open-high-low-close bar chart of a (financial) time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotOHLC(x, xlim = NULL, ylim = NULL, xlab = "Time", ylab, col = par("col"),
         bg = par("bg"), axes = TRUE, frame.plot = axes, ann = par("ann"),
         main = NULL, date = c("calendar", "julian"), format = "%Y-%m-%d",
         origin = "1899-12-30", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotOHLC_+3A_x">x</code></td>
<td>
<p>a multivariate time series object of class <code>"mts"</code>.</p>
</td></tr>
<tr><td><code id="plotOHLC_+3A_xlim">xlim</code>, <code id="plotOHLC_+3A_ylim">ylim</code>, <code id="plotOHLC_+3A_xlab">xlab</code>, <code id="plotOHLC_+3A_ylab">ylab</code>, <code id="plotOHLC_+3A_col">col</code>, <code id="plotOHLC_+3A_bg">bg</code>, <code id="plotOHLC_+3A_axes">axes</code>, <code id="plotOHLC_+3A_frame.plot">frame.plot</code>, <code id="plotOHLC_+3A_ann">ann</code>, <code id="plotOHLC_+3A_main">main</code></td>
<td>
<p>graphical arguments, see <code><a href="graphics.html#topic+plot">plot</a></code>,
<code><a href="graphics.html#topic+plot.default">plot.default</a></code> and <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plotOHLC_+3A_date">date</code></td>
<td>
<p>a string indicating the type of x axis
annotation. Default is calendar dates.</p>
</td></tr>
<tr><td><code id="plotOHLC_+3A_format">format</code></td>
<td>
<p>a string indicating the format of the x axis annotation if
<code>date == "calendar"</code>. For details see
<code><a href="base.html#topic+format.POSIXct">format.POSIXct</a></code>.</p>
</td></tr> 
<tr><td><code id="plotOHLC_+3A_origin">origin</code></td>
<td>
<p>an R object specifying the origin of the Julian dates
if <code>date == "calendar"</code>. Defaults to 1899-12-30 (Popular
spreadsheet programs internally also use Julian dates with this origin).</p>
</td></tr>
<tr><td><code id="plotOHLC_+3A_...">...</code></td>
<td>
<p>further graphical arguments passed to
<code><a href="graphics.html#topic+plot.window">plot.window</a></code>, <code><a href="graphics.html#topic+title">title</a></code>, <code><a href="graphics.html#topic+axis">axis</a></code>,
and <code><a href="graphics.html#topic+box">box</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Within an open-high-low-close bar chart, each bar represents
price information for the time interval between the open and the close
price. The left tick for each bar indicates the open price for the
time interval. The right tick indicates the closing price for the time
interval. The vertical length of the bar represents the price range
for the time interval.
</p>
<p>The time scale of <code>x</code> must be in Julian dates (days since the
<code>origin</code>).
</p>


<h3>Author(s)</h3>

<p>A. Trapletti</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot.default">plot.default</a></code>,
<code><a href="base.html#topic+format.POSIXct">format.POSIXct</a></code>,
<code><a href="tseries.html#topic+get.hist.quote">get.hist.quote</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>con &lt;- url("https://finance.yahoo.com")
if(!inherits(try(open(con), silent = TRUE), "try-error")) {
  close(con)
  ## Plot OHLC bar chart for the last 'nDays' days of the instrument
  ## 'instrument'

  nDays &lt;- 50
  instrument &lt;- "^gspc"

  start &lt;- strftime(as.POSIXlt(Sys.time() - nDays * 24 * 3600),
                    format="%Y-%m-%d") 
  end &lt;- strftime(as.POSIXlt(Sys.time()), format = "%Y-%m-%d") 
  x &lt;- get.hist.quote(instrument = instrument, start = start, end = end,
                      retclass = "ts")

  plotOHLC(x, ylab = "price", main = instrument)
}
</code></pre>

<hr>
<h2 id='po.test'>Phillips&ndash;Ouliaris Cointegration Test</h2><span id='topic+po.test'></span>

<h3>Description</h3>

<p>Computes the Phillips-Ouliaris test for the null hypothesis that
<code>x</code> is not cointegrated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>po.test(x, demean = TRUE, lshort = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="po.test_+3A_x">x</code></td>
<td>
<p>a matrix or multivariate time series.</p>
</td></tr>
<tr><td><code id="po.test_+3A_demean">demean</code></td>
<td>
<p>a logical indicating whether an intercept is included in
the cointegration regression or not.</p>
</td></tr>
<tr><td><code id="po.test_+3A_lshort">lshort</code></td>
<td>
<p>a logical indicating whether the short or long version
of the truncation lag parameter is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Phillips-Perron Z(alpha) statistic for a unit root in the
residuals of the cointegration regression is computed, see also
<code><a href="tseries.html#topic+pp.test">pp.test</a></code>. The unit root is estimated from a regression of
the first variable (column) of <code>x</code> on the remaining variables of
<code>x</code> without a constant and a linear trend.  To estimate
<code>sigma^2</code> the Newey-West estimator is used.  If <code>lshort</code> is
<code>TRUE</code>, then the truncation lag parameter is set to
<code>trunc(n/100)</code>, otherwise <code>trunc(n/30)</code> is used.  The
p-values are interpolated from Table Ia and Ib, p. 189 of Phillips and
Ouliaris (1990).  If the computed statistic is outside the table of
critical values, then a warning message is generated.
</p>
<p>The dimension of <code>x</code> is restricted to six variables.  Missing
values are not handled.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the truncation lag parameter.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was
performed.</p>
</td></tr> 
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. Trapletti</p>


<h3>References</h3>

<p>P. C. B. Phillips and S. Ouliaris (1990):
Asymptotic Properties of Residual Based Tests for Cointegration.
<em>Econometrica</em> <b>58</b>, 165&ndash;193.
</p>


<h3>See Also</h3>

<p><code><a href="tseries.html#topic+pp.test">pp.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ts(diffinv(matrix(rnorm(2000),1000,2)))  # no cointegration
po.test(x)

x &lt;- diffinv(rnorm(1000))
y &lt;- 2.0-3.0*x+rnorm(x,sd=5)
z &lt;- ts(cbind(x,y))  # cointegrated
po.test(z)
</code></pre>

<hr>
<h2 id='portfolio.optim'>Portfolio Optimization</h2><span id='topic+portfolio.optim'></span><span id='topic+portfolio.optim.ts'></span><span id='topic+portfolio.optim.default'></span>

<h3>Description</h3>

<p>Computes an efficient portfolio from the given return series <code>x</code>
in the mean-variance sense.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
portfolio.optim(x, pm = mean(x), riskless = FALSE,
                shorts = FALSE, rf = 0.0, reslow = NULL, reshigh = NULL,
                covmat = cov(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="portfolio.optim_+3A_x">x</code></td>
<td>
<p>a numeric matrix or multivariate time series consisting of a
series of returns.</p>
</td></tr>
<tr><td><code id="portfolio.optim_+3A_pm">pm</code></td>
<td>
<p>the desired mean portfolio return.</p>
</td></tr>
<tr><td><code id="portfolio.optim_+3A_riskless">riskless</code></td>
<td>
<p>a logical indicating whether there is a riskless
lending and borrowing rate.</p>
</td></tr>
<tr><td><code id="portfolio.optim_+3A_shorts">shorts</code></td>
<td>
<p>a logical indicating whether shortsales on the risky
securities are allowed.</p>
</td></tr> 
<tr><td><code id="portfolio.optim_+3A_rf">rf</code></td>
<td>
<p>the riskfree interest rate.</p>
</td></tr>
<tr><td><code id="portfolio.optim_+3A_reslow">reslow</code></td>
<td>
<p>a vector specifying the (optional) lower bound on
allowed portfolio weights.</p>
</td></tr>  
<tr><td><code id="portfolio.optim_+3A_reshigh">reshigh</code></td>
<td>
<p>a vector specifying the (optional) upper bound on
allowed portfolio weights.</p>
</td></tr> 
<tr><td><code id="portfolio.optim_+3A_covmat">covmat</code></td>
<td>
<p>the covariance matrix of asset returns.</p>
</td></tr>
<tr><td><code id="portfolio.optim_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computed portfolio has the desired expected return <code>pm</code> and
no other portfolio exists, which has the same mean return, but a
smaller variance. Inequality restrictions of the form <code class="reqn">w_l \le w
  \le w_h</code> can be imposed using the <code>reslow</code> and
<code>reshigh</code> vectors. An alternative covariance matrix estimate can
be supplied via the <code>covmat</code> argument. To solve the quadratic
program, <code><a href="quadprog.html#topic+solve.QP">solve.QP</a></code> is used.
</p>
<p><code>portfolio.optim</code> is a generic function with methods for
multivariate <code>"ts"</code> and <code>default</code> for matrix.
</p>
<p>Missing values are not allowed.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>pw</code></td>
<td>
<p>the portfolio weights.</p>
</td></tr>
<tr><td><code>px</code></td>
<td>
<p>the returns of the overall portfolio.</p>
</td></tr>
<tr><td><code>pm</code></td>
<td>
<p>the expected portfolio return.</p>
</td></tr>
<tr><td><code>ps</code></td>
<td>
<p>the standard deviation of the portfolio returns.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. Trapletti</p>


<h3>References</h3>

<p>E. J. Elton and M. J. Gruber (1991): <em>Modern Portfolio Theory and
Investment Analysis</em>, 4th Edition, Wiley, NY, pp. 65-93.
</p>
<p>C. Huang and R. H. Litzenberger (1988): <em>Foundations for
Financial Economics</em>, Elsevier, NY, pp. 59-82.
</p>


<h3>See Also</h3>

<p><code><a href="quadprog.html#topic+solve.QP">solve.QP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1000)
dim(x) &lt;- c(500,2)
res &lt;- portfolio.optim(x)
res$pw

require("zoo")			# For diff() method.
X &lt;- diff(log(as.zoo(EuStockMarkets)))
res &lt;- portfolio.optim(X)                 ## Long only
res$pw
res &lt;- portfolio.optim(X, shorts=TRUE)    ## Long/Short
res$pw
</code></pre>

<hr>
<h2 id='pp.test'>Phillips&ndash;Perron Unit Root Test</h2><span id='topic+pp.test'></span>

<h3>Description</h3>

<p>Computes the Phillips-Perron test for the null hypothesis that
<code>x</code> has a unit root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp.test(x, alternative = c("stationary", "explosive"),
        type = c("Z(alpha)", "Z(t_alpha)"), lshort = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp.test_+3A_x">x</code></td>
<td>
<p>a numeric vector or univariate time series.</p>
</td></tr>
<tr><td><code id="pp.test_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be
one of <code>"stationary"</code> (default) or <code>"explosive"</code>.  You can
specify just the initial letter.</p>
</td></tr>
<tr><td><code id="pp.test_+3A_type">type</code></td>
<td>
<p>indicates which variant of the test is computed and must
be one of <code>"Z(alpha)"</code> (default) or <code>"Z(t_alpha)"</code>.</p>
</td></tr>
<tr><td><code id="pp.test_+3A_lshort">lshort</code></td>
<td>
<p>a logical indicating whether the short or long version
of the truncation lag parameter is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general regression equation which incorporates a constant and a
linear trend is used and the <code>Z(alpha)</code> or <code>Z(t_alpha)</code>
statistic for a first order autoregressive coefficient equals one are
computed.  To estimate <code>sigma^2</code> the Newey-West estimator is
used.  If <code>lshort</code> is <code>TRUE</code>, then the truncation lag
parameter is set to <code>trunc(4*(n/100)^0.25)</code>, otherwise
<code>trunc(12*(n/100)^0.25)</code> is used.  The p-values are interpolated
from Table 4.1 and 4.2, p. 103 of Banerjee et al. (1993).  If the
computed statistic is outside the table of critical values, then a
warning message is generated.
</p>
<p>Missing values are not handled.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the truncation lag parameter.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was
performed.</p>
</td></tr> 
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. Trapletti</p>


<h3>References</h3>

<p>A. Banerjee, J. J. Dolado, J. W. Galbraith, and D. F. Hendry (1993):
<em>Cointegration, Error Correction, and the Econometric Analysis
of Non-Stationary Data</em>, Oxford University Press, Oxford.
</p>
<p>P. Perron (1988):
Trends and Random Walks in Macroeconomic Time Series.
<em>Journal of Economic Dynamics and Control</em> <b>12</b>, 297&ndash;332.
</p>


<h3>See Also</h3>

<p><code><a href="tseries.html#topic+adf.test">adf.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1000)  # no unit-root
pp.test(x)

y &lt;- cumsum(x)  # has unit root
pp.test(y)
</code></pre>

<hr>
<h2 id='quadmap'>Quadratic Map (Logistic Equation)</h2><span id='topic+quadmap'></span>

<h3>Description</h3>

<p>Computes the quadratic map simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadmap(xi = 0.2, a = 4.0, n = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadmap_+3A_xi">xi</code></td>
<td>
<p>the initial value for the iteration.</p>
</td></tr>
<tr><td><code id="quadmap_+3A_a">a</code></td>
<td>
<p>the quadratic map parameter.</p>
</td></tr>
<tr><td><code id="quadmap_+3A_n">n</code></td>
<td>
<p>the length of the simulated series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the simulated series.
</p>


<h3>Author(s)</h3>

<p>A. Trapletti</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- quadmap()
acf(x, 10)
</code></pre>

<hr>
<h2 id='read.matrix'>Read Matrix Data</h2><span id='topic+read.matrix'></span>

<h3>Description</h3>

<p>Reads a matrix data file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.matrix(file, header = FALSE, sep = "", skip = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.matrix_+3A_file">file</code></td>
<td>
<p>the name of the file which the data are to be read from.</p>
</td></tr>
<tr><td><code id="read.matrix_+3A_header">header</code></td>
<td>
<p>a logical value indicating whether the file contains the
names of the columns as its first line.</p>
</td></tr>
<tr><td><code id="read.matrix_+3A_sep">sep</code></td>
<td>
<p>the field separator character.  Values on each line of the
file are separated by this character.</p>
</td></tr>
<tr><td><code id="read.matrix_+3A_skip">skip</code></td>
<td>
<p>the number of lines of the data file to skip before
beginning to read data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually each row of the file represents an observation and each column
contains a variable.  The first row possibly contains the names of the
variables (columns).
</p>
<p><code>read.matrix</code> might be more efficient than
<code><a href="utils.html#topic+read.table">read.table</a></code> for very large data sets.
</p>


<h3>Author(s)</h3>

<p>A. Trapletti</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(0, 10, 10)
write(x, "test", ncolumns=10)
x &lt;- read.matrix("test")
x
unlink("test")
</code></pre>

<hr>
<h2 id='read.ts'>Read Time Series Data</h2><span id='topic+read.ts'></span>

<h3>Description</h3>

<p>Reads a time series file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.ts(file, header = FALSE, sep = "", skip = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.ts_+3A_file">file</code></td>
<td>
<p>the name of the file which the data are to be read from.
Each line of the file contains one observation of the variables.</p>
</td></tr>
<tr><td><code id="read.ts_+3A_header">header</code></td>
<td>
<p>a logical value indicating whether the file contains
the names of the variables as its first line.</p>
</td></tr>
<tr><td><code id="read.ts_+3A_sep">sep</code></td>
<td>
<p>the field separator character.  Values on each line of the
file are separated by this character.</p>
</td></tr>
<tr><td><code id="read.ts_+3A_skip">skip</code></td>
<td>
<p>the number of lines of the data file to skip before
beginning to read data.</p>
</td></tr>
<tr><td><code id="read.ts_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code><a href="stats.html#topic+ts">ts</a></code> such as, e.g.,
<code>start</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each row of the file represents an observation and each column
contains a variable.  The first row possibly contains the names of the
variables.
</p>


<h3>Author(s)</h3>

<p>A. Trapletti</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ts">ts</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sunspots)
st &lt;- start(sunspots)
fr &lt;- frequency(sunspots)
write(sunspots, "sunspots", ncolumns=1)
x &lt;- read.ts("sunspots", start=st, frequency=fr)
plot(x)
unlink("sunspots")
</code></pre>

<hr>
<h2 id='runs.test'>Runs Test</h2><span id='topic+runs.test'></span>

<h3>Description</h3>

<p>Computes the runs test for randomness of the dichotomous (binary) data
series <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runs.test(x, alternative = c("two.sided", "less", "greater"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runs.test_+3A_x">x</code></td>
<td>
<p>a dichotomous factor.</p>
</td></tr>
<tr><td><code id="runs.test_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be
one of <code>"two.sided"</code> (default), <code>"less"</code>, or
<code>"greater"</code>. You can specify just the initial letter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test searches for randomness in the observed data series
<code>x</code> by examining the frequency of runs. A &quot;run&quot; is defined as a
series of similar responses.
</p>
<p>Note, that by using the alternative <code>"less"</code> the null of
randomness is tested against some kind of &quot;under-mixing&quot;
(&quot;trend&quot;). By using the alternative <code>"greater"</code> the null of 
randomness is tested against some kind of &quot;over-mixing&quot;
(&quot;mean-reversion&quot;).  
</p>
<p>Missing values are not allowed.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was
performed.</p>
</td></tr> 
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. Trapletti</p>


<h3>References</h3>

<p>S. Siegel (1956): <em>Nonparametric Statistics for the Behavioural
Sciences</em>, McGraw-Hill, New York.
</p>
<p>S. Siegel and N. J. Castellan (1988): <em>Nonparametric Statistics for the
Behavioural Sciences</em>, 2nd edn, McGraw-Hill, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- factor(sign(rnorm(100)))  # randomness
runs.test(x)

x &lt;- factor(rep(c(-1,1),50))  # over-mixing
runs.test(x)
</code></pre>

<hr>
<h2 id='seqplot.ts'>Plot Two Time Series</h2><span id='topic+seqplot.ts'></span>

<h3>Description</h3>

<p>Plot two time series on the same plot frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqplot.ts(x, y, colx = "black", coly = "red", typex = "l",
           typey = "l", pchx = 1, pchy = 1, ltyx = "solid",
           ltyy = "solid", oma = c(6, 0, 5, 0), ann = par("ann"),
           xlab = "Time", ylab = deparse(substitute(x)), main = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqplot.ts_+3A_x">x</code>, <code id="seqplot.ts_+3A_y">y</code></td>
<td>
<p>the time series.</p>
</td></tr>
<tr><td><code id="seqplot.ts_+3A_colx">colx</code>, <code id="seqplot.ts_+3A_coly">coly</code></td>
<td>
<p>color code or name for the <code>x</code> and <code>y</code>
series, see <code><a href="grDevices.html#topic+colors">colors</a></code>, <code><a href="grDevices.html#topic+palette">palette</a></code>.</p>
</td></tr>
<tr><td><code id="seqplot.ts_+3A_typex">typex</code>, <code id="seqplot.ts_+3A_typey">typey</code></td>
<td>
<p>what type of plot should be drawn for the <code>x</code>
and <code>y</code> series, see <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="seqplot.ts_+3A_pchx">pchx</code>, <code id="seqplot.ts_+3A_pchy">pchy</code></td>
<td>
<p>character or integer code for kind of points/lines
for the <code>x</code> and <code>y</code> series.</p>
</td></tr>
<tr><td><code id="seqplot.ts_+3A_ltyx">ltyx</code>, <code id="seqplot.ts_+3A_ltyy">ltyy</code></td>
<td>
<p>line type code for the <code>x</code> and <code>y</code> series,
see <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
<tr><td><code id="seqplot.ts_+3A_oma">oma</code></td>
<td>
<p>a vector giving the size of the outer margins in lines of
text, see <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="seqplot.ts_+3A_ann">ann</code></td>
<td>
<p>annotate the plots? See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="seqplot.ts_+3A_xlab">xlab</code>, <code id="seqplot.ts_+3A_ylab">ylab</code></td>
<td>
<p>titles for the x and y axis.</p>
</td></tr>
<tr><td><code id="seqplot.ts_+3A_main">main</code></td>
<td>
<p>an overall title for the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike <code><a href="stats.html#topic+plot.ts">plot.ts</a></code> the series can have different time bases,
but they should have the same frequency. Unlike <code><a href="stats.html#topic+ts.plot">ts.plot</a></code>
the series can be plotted in different styles and for multivariate
<code>x</code> and <code>y</code> the common variables are plotted together in a
separate array element.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>A. Trapletti</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ts">ts</a></code>, <code><a href="stats.html#topic+plot.ts">plot.ts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USeconomic)
x &lt;- ts.union(log(M1), log(GNP), rs, rl)
m.ar &lt;- ar(x, method = "ols", order.max = 5)
y &lt;- predict(m.ar, x, n.ahead = 200, se.fit = FALSE)
seqplot.ts(x, y)
</code></pre>

<hr>
<h2 id='sharpe'>Sharpe Ratio</h2><span id='topic+sharpe'></span>

<h3>Description</h3>

<p>This function computes the Sharpe ratio of the univariate time series
(or vector) <code>x</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sharpe(x, r = 0, scale = sqrt(250))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sharpe_+3A_x">x</code></td>
<td>
<p>a numeric vector or univariate time series corresponding to a
portfolio's cumulated returns.</p>
</td></tr>
<tr><td><code id="sharpe_+3A_r">r</code></td>
<td>
<p>the risk free rate. Default corresponds to using portfolio
returns not in excess of the riskless return.</p>
</td></tr> 
<tr><td><code id="sharpe_+3A_scale">scale</code></td>
<td>
<p>a scale factor. Default corresponds to an annualization
when working with daily financial time series data.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The Sharpe ratio is defined as a portfolio's mean return in excess of
the riskless return divided by the portfolio's standard deviation. In
finance the Sharpe Ratio represents a measure of the portfolio's
risk-adjusted (excess) return. 
</p>


<h3>Value</h3>

<p>a double representing the Sharpe ratio.
</p>


<h3>Author(s)</h3>

<p>A. Trapletti</p>


<h3>See Also</h3>

<p><code><a href="tseries.html#topic+sterling">sterling</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EuStockMarkets)
dax &lt;- log(EuStockMarkets[,"DAX"])
ftse &lt;- log(EuStockMarkets[,"FTSE"])
sharpe(dax)
sharpe(ftse)
</code></pre>

<hr>
<h2 id='sterling'>Sterling Ratio</h2><span id='topic+sterling'></span>

<h3>Description</h3>

<p>This function computes the Sterling ratio of the univariate time series
(or vector) <code>x</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sterling(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sterling_+3A_x">x</code></td>
<td>
<p>a numeric vector or univariate time series corresponding to a
portfolio's cumulated returns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Sterling ratio is defined as a portfolio's overall return divided
by the portfolio's <code><a href="tseries.html#topic+maxdrawdown">maxdrawdown</a></code> statistic. In finance the
Sterling Ratio represents a measure of the portfolio's risk-adjusted
return.   
</p>


<h3>Value</h3>

<p>a double representing the Sterling ratio.
</p>


<h3>Author(s)</h3>

<p>A. Trapletti</p>


<h3>See Also</h3>

<p><code><a href="tseries.html#topic+maxdrawdown">maxdrawdown</a></code>, <code><a href="tseries.html#topic+sharpe">sharpe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EuStockMarkets)
dax &lt;- log(EuStockMarkets[,"DAX"])
ftse &lt;- log(EuStockMarkets[,"FTSE"])
sterling(dax)
sterling(ftse)
</code></pre>

<hr>
<h2 id='summary.arma'>Summarizing ARMA Model Fits</h2><span id='topic+summary.arma'></span><span id='topic+print.summary.arma'></span>

<h3>Description</h3>

<p>Methods for creating and printing summaries of ARMA model fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'arma'
summary(object, ...)
## S3 method for class 'summary.arma'
print(x, digits = max(3, getOption("digits") - 3),
      signif.stars = getOption("show.signif.stars"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.arma_+3A_object">object</code></td>
<td>
<p>an object of class <code>"arma"</code>; usually, a result of a
call to <code><a href="tseries.html#topic+arma">arma</a></code>.</p>
</td></tr>
<tr><td><code id="summary.arma_+3A_x">x</code></td>
<td>
<p>an object of class <code>"summary.arma"</code>; usually, a result
of a call to the summary method for objects of class <code>"arma"</code>.</p>
</td></tr>
<tr><td><code id="summary.arma_+3A_digits">digits</code>, <code id="summary.arma_+3A_signif.stars">signif.stars</code></td>
<td>
<p>see <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code>.</p>
</td></tr>
<tr><td><code id="summary.arma_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The summary method computes the asymptotic standard errors of the
coefficient estimates from the numerically differentiated Hessian
matrix approximation.  The AIC is computed from the conditional
sum-of-squared errors and not from the true maximum likelihood
function. That may be problematic.
</p>


<h3>Value</h3>

<p>A list of class <code>"summary.arma"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="tseries.html#topic+arma">arma</a></code>
</p>

<hr>
<h2 id='summary.garch'>Summarizing GARCH Model Fits</h2><span id='topic+summary.garch'></span><span id='topic+print.summary.garch'></span>

<h3>Description</h3>

<p>Methods for creating and printing summaries of GARCH model fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garch'
summary(object, ...)
## S3 method for class 'summary.garch'
print(x, digits = max(3, getOption("digits") - 3),
      signif.stars = getOption("show.signif.stars"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.garch_+3A_object">object</code></td>
<td>
<p>an object of class <code>"garch"</code>; usually, a result of a
call to <code><a href="tseries.html#topic+garch">garch</a></code>.</p>
</td></tr>
<tr><td><code id="summary.garch_+3A_x">x</code></td>
<td>
<p>an object of class <code>"summary.garch"</code>; usually, a result
of a call to the summary method for objects of class <code>"garch"</code>.</p>
</td></tr>
<tr><td><code id="summary.garch_+3A_digits">digits</code>, <code id="summary.garch_+3A_signif.stars">signif.stars</code></td>
<td>
<p>see <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code>.</p>
</td></tr>
<tr><td><code id="summary.garch_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary</code> computes the asymptotic standard errors of the
coefficient estimates from an outer-product approximation of the
Hessian evaluated at the estimates, see Bollerslev (1986).  It
furthermore tests the residuals for normality and remaining ARCH
effects, see <code><a href="tseries.html#topic+jarque.bera.test">jarque.bera.test</a></code> and
<code><a href="stats.html#topic+Box.test">Box.test</a></code>. 
</p>


<h3>Value</h3>

<p>A list of class <code>"summary.garch"</code>.
</p>


<h3>References</h3>

<p>T. Bollerslev (1986):
Generalized Autoregressive Conditional Heteroscedasticity.
<em>Journal of Econometrics</em> <b>31</b>, 307&ndash;327.
</p>


<h3>See Also</h3>

<p><code><a href="tseries.html#topic+garch">garch</a></code>
</p>

<hr>
<h2 id='surrogate'>Generate Surrogate Data and Statistics</h2><span id='topic+surrogate'></span>

<h3>Description</h3>

<p>Generates <code>ns</code> surrogate samples from the original data <code>x</code>
and computes the standard error and the bias of <code>statistic</code> as in
a bootstrap setup, if <code>statistic</code> is given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surrogate(x, ns = 1, fft = FALSE, amplitude = FALSE,
          statistic = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surrogate_+3A_x">x</code></td>
<td>
<p>a numeric vector or time series.</p>
</td></tr>
<tr><td><code id="surrogate_+3A_ns">ns</code></td>
<td>
<p>the number of surrogate series to compute.</p>
</td></tr>
<tr><td><code id="surrogate_+3A_fft">fft</code></td>
<td>
<p>a logical indicating whether phase randomized surrogate
data is generated.</p>
</td></tr>
<tr><td><code id="surrogate_+3A_amplitude">amplitude</code></td>
<td>
<p>a logical indicating whether amplitude-adjusted
surrogate data is computed.</p>
</td></tr>
<tr><td><code id="surrogate_+3A_statistic">statistic</code></td>
<td>
<p>a function which when applied to a time series
returns a vector containing the statistic(s) of interest.</p>
</td></tr>
<tr><td><code id="surrogate_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>statistic</code> which are
passed unchanged each time it is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>fft</code> is <code>FALSE</code>, then <code>x</code> is mixed in temporal
order, so that all temporal dependencies are eliminated, but the
histogram of the original data is preserved.  If <code>fft</code> is
<code>TRUE</code>, then surrogate data with the same spectrum as <code>x</code> is
computed by randomizing the phases of the Fourier coefficients of
<code>x</code>.  If in addition <code>amplitude</code> is <code>TRUE</code>, then also
the amplitude distribution of the original series is preserved.
</p>
<p>Note, that the interpretation of the computed standard error and bias
is different than in a bootstrap setup.
</p>
<p>To compute the phase randomized surrogate and the amplitude adjusted
data algorithm 1 and 2 from Theiler et al. (1992), pp. 183, 184 are
used.
</p>
<p>Missing values are not allowed.
</p>


<h3>Value</h3>

<p>If <code>statistic</code> is <code>NULL</code>, then it returns a matrix or time
series with <code>ns</code> columns and <code>length(x)</code> rows containing the
surrogate data. Each column contains one surrogate sample.
</p>
<p>If <code>statistic</code> is given, then a list of class
<code>"resample.statistic"</code> with the following elements is returned:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the results of applying <code>statistic</code> to each of
the simulated time series.</p>
</td></tr>
<tr><td><code>orig.statistic</code></td>
<td>
<p>the results of applying <code>statistic</code> to the
original series.</p>
</td></tr>
<tr><td><code>bias</code></td>
<td>
<p>the bias of the statistics computed as in a bootstrap
setup.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>the standard error of the statistics computed as in a
bootstrap setup.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original call of <code>surrogate</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. Trapletti</p>


<h3>References</h3>

<p>J. Theiler, B. Galdrikian, A. Longtin, S. Eubank, and J. D. Farmer
(1992): Using Surrogate Data to Detect
Nonlinearity in Time Series, in <em>Nonlinear Modelling and
Forecasting</em>, Eds. M. Casdagli and S. Eubank, Santa Fe Institute,
Addison Wesley, 163&ndash;188.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sample">sample</a></code>, <code><a href="tseries.html#topic+tsbootstrap">tsbootstrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10  # Simple example
surrogate(x)

n &lt;- 500  # Generate AR(1) process
e &lt;- rnorm(n)  
x &lt;- double(n)
x[1] &lt;- rnorm(1)
for(i in 2:n) {
  x[i] &lt;- 0.4 * x[i-1] + e[i]
}
x &lt;- ts(x)

theta &lt;- function(x)  # Autocorrelations up to lag 10
  return(acf(x, plot=FALSE)$acf[2:11])

surrogate(x, ns=50, fft=TRUE, statistic=theta) 
</code></pre>

<hr>
<h2 id='tcm'>
Monthly Yields on Treasury Securities
</h2><span id='topic+tcm'></span><span id='topic+tcm1y'></span><span id='topic+tcm3y'></span><span id='topic+tcm5y'></span><span id='topic+tcm10y'></span>

<h3>Description</h3>

<p>This data set contains monthly 1 year, 3 year, 5 year, and 10 year
yields on treasury securities at constant, fixed maturity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tcm)
</code></pre>


<h3>Format</h3>

<p>4 univariate time series <code>tcm1y</code>, <code>tcm3y</code>, <code>tcm5y</code>, and
<code>tcm10y</code> and the joint series <code>tcm</code>.
</p>


<h3>Details</h3>

<p>The yields at constant fixed maturity have been constructed by the
Treasury Department, based on the most actively traded marketable
treasury securities.
</p>


<h3>Source</h3>

<p>U.S. Fed <a href="https://www.federalreserve.gov/Releases/H15/data.htm">https://www.federalreserve.gov/Releases/H15/data.htm</a>
</p>

<hr>
<h2 id='tcmd'>
Daily Yields on Treasury Securities
</h2><span id='topic+tcmd'></span><span id='topic+tcm1yd'></span><span id='topic+tcm3yd'></span><span id='topic+tcm5yd'></span><span id='topic+tcm10yd'></span>

<h3>Description</h3>

<p>This data set contains daily 1 year, 3 year, 5 year, and 10 year
yields on treasury securities at constant, fixed maturity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tcmd)
</code></pre>


<h3>Format</h3>

<p>4 univariate time series <code>tcm1yd</code>, <code>tcm3yd</code>, <code>tcm5yd</code>,
and <code>tcm10yd</code> and the joint series <code>tcmd</code>.
</p>


<h3>Details</h3>

<p>The yields at constant fixed maturity have been constructed by the
Treasury Department, based on the most actively traded marketable
treasury securities.
</p>
<p>Daily refers to business days, i.e., weekends and holidays are
eliminated.
</p>


<h3>Source</h3>

<p>U.S. Fed <a href="https://www.federalreserve.gov/Releases/H15/data.htm">https://www.federalreserve.gov/Releases/H15/data.htm</a>
</p>

<hr>
<h2 id='terasvirta.test'>Teraesvirta Neural Network Test for Nonlinearity</h2><span id='topic+terasvirta.test'></span><span id='topic+terasvirta.test.ts'></span><span id='topic+terasvirta.test.default'></span>

<h3>Description</h3>

<p>Generically computes Teraesvirta's neural network test for neglected
nonlinearity either for the time series <code>x</code> or the regression
<code>y~x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ts'
terasvirta.test(x, lag = 1, type = c("Chisq","F"),
                scale = TRUE, ...)
## Default S3 method:
terasvirta.test(x, y, type = c("Chisq","F"),
                scale = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terasvirta.test_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix, or time series.</p>
</td></tr>
<tr><td><code id="terasvirta.test_+3A_y">y</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="terasvirta.test_+3A_lag">lag</code></td>
<td>
<p>an integer which specifies the model order in terms of
lags.</p>
</td></tr> 
<tr><td><code id="terasvirta.test_+3A_type">type</code></td>
<td>
<p>a string indicating whether the Chi-Squared test or the
F-test is computed. Valid types are <code>"Chisq"</code> and <code>"F"</code>.</p>
</td></tr>
<tr><td><code id="terasvirta.test_+3A_scale">scale</code></td>
<td>
<p>a logical indicating whether the data should be scaled 
before computing the test statistic. The default arguments to
<code><a href="base.html#topic+scale">scale</a></code> are used.</p>
</td></tr>
<tr><td><code id="terasvirta.test_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null is the hypotheses of linearity in
&ldquo;mean&rdquo;. This test uses a Taylor series expansion of the activation
function to arrive at a suitable test statistic. If <code>type</code> equals
<code>"F"</code>, then the F-statistic instead of the Chi-Squared statistic
is used in analogy to the classical linear regression. 
</p>
<p>Missing values are not allowed.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was
performed.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>a list containing the additional parameters used to
compute the test statistic.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
<tr><td><code>arguments</code></td>
<td>
<p>additional arguments used to compute the test statistic.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. Trapletti</p>


<h3>References</h3>

<p>T. Teraesvirta, C. F. Lin, and C. W. J. Granger (1993): Power of the
Neural Network Linearity Test. <em>Journal of Time Series Analysis</em>
14, 209-220.
</p>


<h3>See Also</h3>

<p><code><a href="tseries.html#topic+white.test">white.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1000

x &lt;- runif(1000, -1, 1)  # Non-linear in ``mean'' regression 
y &lt;- x^2 - x^3 + 0.1*rnorm(x)
terasvirta.test(x, y)

## Is the polynomial of order 2 misspecified?
terasvirta.test(cbind(x,x^2,x^3), y)

## Generate time series which is nonlinear in ``mean''
x[1] &lt;- 0.0
for(i in (2:n)) {
  x[i] &lt;- 0.4*x[i-1] + tanh(x[i-1]) + rnorm(1, sd=0.5)
}
x &lt;- as.ts(x)
plot(x)
terasvirta.test(x)
</code></pre>

<hr>
<h2 id='tsbootstrap'>Bootstrap for General Stationary Data</h2><span id='topic+tsbootstrap'></span><span id='topic+print.resample.statistic'></span>

<h3>Description</h3>

<p><code>tsbootstrap</code> generates bootstrap samples for general stationary
data and computes the bootstrap estimate of standard error and bias
if a statistic is given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsbootstrap(x, nb = 1, statistic = NULL, m = 1, b = NULL,
            type = c("stationary","block"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsbootstrap_+3A_x">x</code></td>
<td>
<p>a numeric vector or time series giving the original data.</p>
</td></tr>
<tr><td><code id="tsbootstrap_+3A_nb">nb</code></td>
<td>
<p>the number of bootstrap series to compute.</p>
</td></tr>
<tr><td><code id="tsbootstrap_+3A_statistic">statistic</code></td>
<td>
<p>a function which when applied to a time series
returns a vector containing the statistic(s) of interest.</p>
</td></tr>
<tr><td><code id="tsbootstrap_+3A_m">m</code></td>
<td>
<p>the length of the basic blocks in the block of blocks
bootstrap.</p>
</td></tr> 
<tr><td><code id="tsbootstrap_+3A_b">b</code></td>
<td>
<p>if <code>type</code> is <code>"stationary"</code>, then <code>b</code> is the
mean block length. If <code>type</code> is <code>"block"</code>, then <code>b</code>
is the fixed block length.</p>
</td></tr>
<tr><td><code id="tsbootstrap_+3A_type">type</code></td>
<td>
<p>the type of bootstrap to generate the simulated time
series. The possible input values are <code>"stationary"</code>
(stationary bootstrap with mean block length <code>b</code>) and
<code>"block"</code> (blockwise bootstrap with block length
<code>b</code>). Default to <code>"stationary"</code>.</p>
</td></tr> 
<tr><td><code id="tsbootstrap_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>statistic</code> which are
passed unchanged each time <code>statistic</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>type</code> is <code>"stationary"</code>, then the stationary
bootstrap scheme with mean block length <code>b</code> according to Politis
and Romano (1994) is computed. For <code>type</code> equals <code>"block"</code>,
the blockwise bootstrap with block length <code>b</code> according to
Kuensch (1989) is used. 
</p>
<p>If <code>m &gt; 1</code>, then the block of blocks bootstrap is computed
(see Kuensch, 1989). The basic sampling scheme is the same as for 
the case <code>m = 1</code>, except that the bootstrap is applied to a series
<code>y</code> containing blocks of length <code>m</code>, where each block of <code>y</code> is
defined as <code class="reqn">y[t] = (x[t], \dots, x[t-m+1])</code>. Therefore, for the block
of blocks bootstrap the first argument of <code>statistic</code> is given by
a <code>n x m</code> matrix <code>yb</code>, where each row of <code>yb</code> contains one
bootstrapped basic block observation <code class="reqn">y[t]</code> (<code>n</code> is the number of
observations in <code>x</code>). 
</p>
<p>Note, that for statistics which are functions of the empirical
<code>m</code>-dimensional marginal (<code>m &gt; 1</code>) only this procedure
yields asymptotically valid bootstrap estimates. The 
case <code>m = 1</code> may only be used for symmetric statistics (i.e., for
statistics which are invariant under permutations of <code>x</code>).
<code><a href="boot.html#topic+tsboot">tsboot</a></code> does not implement the block of blocks
bootstrap, and, therefore, the first example in <code><a href="boot.html#topic+tsboot">tsboot</a></code>
yields inconsistent estimates.
</p>
<p>For consistency, the (mean) block length <code>b</code> should grow with
<code>n</code> at an appropriate rate. If <code>b</code> is not given, then a
default growth rate of <code>const * n^(1/3)</code> is used. This rate is
&quot;optimal&quot; under certain conditions (see the references for more
details). However, in general the growth rate depends on the specific
properties of the data generation process. A default value for
<code>const</code> has been determined by a Monte Carlo simulation using a
Gaussian AR(1) process (AR(1)-parameter of 0.5, 500
observations). <code>const</code> has been chosen such that the mean square
error for the bootstrap estimate of the variance of the empirical mean
is minimized.  
</p>
<p>Note, that the computationally intensive parts are fully implemented
in <code>C</code> which makes <code>tsbootstrap</code> about 10 to 30 times faster
than <code><a href="boot.html#topic+tsboot">tsboot</a></code>.  
</p>
<p>Missing values are not allowed.
</p>
<p>There is a special print method for objects of class
<code>"resample.statistic"</code> which by default uses
<code>max(3, getOption("digits") - 3)</code> digits to format real numbers.
</p>


<h3>Value</h3>

<p>If <code>statistic</code> is <code>NULL</code>, then it returns a matrix or time
series with <code>nb</code> columns and <code>length(x)</code> rows containing the
bootstrap data. Each column contains one bootstrap sample.
</p>
<p>If <code>statistic</code> is given, then a list of class
<code>"resample.statistic"</code> with the following elements is returned:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the results of applying <code>statistic</code> to each of
the simulated time series.</p>
</td></tr>
<tr><td><code>orig.statistic</code></td>
<td>
<p>the results of applying <code>statistic</code> to the
original series.</p>
</td></tr>
<tr><td><code>bias</code></td>
<td>
<p>the bootstrap estimate of the bias of <code>statistic</code>.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>the bootstrap estimate of the standard error of <code>statistic</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original call of <code>tsbootstrap</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. Trapletti</p>


<h3>References</h3>

<p>H. R. Kuensch (1989):
The Jackknife and the Bootstrap for General Stationary Observations.
<em>The Annals of Statistics</em> <b>17</b>, 1217&ndash;1241.
</p>
<p>D. N. Politis and J. P. Romano (1994):
The Stationary Bootstrap.
<em>Journal of the American Statistical Association</em> <b>89</b>,
1303&ndash;1313.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sample">sample</a></code>,
<code><a href="tseries.html#topic+surrogate">surrogate</a></code>,
<code><a href="boot.html#topic+tsboot">tsboot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500  # Generate AR(1) process
a &lt;- 0.6
e &lt;- rnorm(n+100)  
x &lt;- double(n+100)
x[1] &lt;- rnorm(1)
for(i in 2:(n+100)) {
  x[i] &lt;- a * x[i-1] + e[i]
}
x &lt;- ts(x[-(1:100)])

tsbootstrap(x, nb=500, statistic=mean)

# Asymptotic formula for the std. error of the mean
sqrt(1/(n*(1-a)^2))

acflag1 &lt;- function(x)
{
  xo &lt;- c(x[,1], x[1,2])
  xm &lt;- mean(xo)
  return(mean((x[,1]-xm)*(x[,2]-xm))/mean((xo-xm)^2))
}

tsbootstrap(x, nb=500, statistic=acflag1, m=2)

# Asymptotic formula for the std. error of the acf at lag one
sqrt(((1+a^2)-2*a^2)/n)
</code></pre>

<hr>
<h2 id='USeconomic'>
U.S. Economic Variables
</h2><span id='topic+USeconomic'></span><span id='topic+M1'></span><span id='topic+GNP'></span><span id='topic+rs'></span><span id='topic+rl'></span>

<h3>Description</h3>

<p>This is the E.3 example data set of Luetkepohl (1991).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(USeconomic)
</code></pre>


<h3>Format</h3>

<p>4 univariate time series <code>M1</code>, <code>GNP</code>, <code>rs</code>, and
<code>rl</code> and the joint series <code>USeconomic</code> containing the
logarithm of <code>M1</code>, the logarithm of <code>GNP</code>, <code>rs</code>, and
<code>rl</code>.
</p>


<h3>Details</h3>

<p>It contains seasonally adjusted real U.S. money <code>M1</code> and GNP in
1982 Dollars; discount rate on 91-Day treasury bills <code>rs</code> and
yield on long-term treasury bonds <code>rl</code>. 
</p>


<h3>Source</h3>

<p>Luetkepohl, H. (1991):
<em>Introduction to Multiple Time Series Analysis</em>.
Springer Verlag, NY, 500&ndash;503.
</p>

<hr>
<h2 id='white.test'>White Neural Network Test for Nonlinearity</h2><span id='topic+white.test'></span><span id='topic+white.test.ts'></span><span id='topic+white.test.default'></span>

<h3>Description</h3>

<p>Generically computes the White neural network test for neglected
nonlinearity either for the time series <code>x</code> or the regression
<code>y~x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ts'
white.test(x, lag = 1, qstar = 2, q = 10, range = 4, 
            type = c("Chisq","F"), scale = TRUE, ...)
## Default S3 method:
white.test(x, y, qstar = 2, q = 10, range = 4,
            type = c("Chisq","F"), scale = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="white.test_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix, or time series.</p>
</td></tr>
<tr><td><code id="white.test_+3A_y">y</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="white.test_+3A_lag">lag</code></td>
<td>
<p>an integer which specifies the model order in terms of
lags.</p>
</td></tr> 
<tr><td><code id="white.test_+3A_q">q</code></td>
<td>
<p>an integer representing the number of phantom hidden units
used to compute the test statistic.</p>
</td></tr>
<tr><td><code id="white.test_+3A_qstar">qstar</code></td>
<td>
<p>the test is conducted using <code>qstar</code> principal
components of the phantom hidden units. The first principal
component is omitted since in most cases it appears to be collinear
with the input vector of lagged variables. This strategy preserves
power while still conserving degrees of freedom.</p>
</td></tr>
<tr><td><code id="white.test_+3A_range">range</code></td>
<td>
<p>the input to hidden unit weights are initialized uniformly
over [-range/2, range/2].</p>
</td></tr>
<tr><td><code id="white.test_+3A_type">type</code></td>
<td>
<p>a string indicating whether the Chi-Squared test or the
F-test is computed. Valid types are <code>"Chisq"</code> and <code>"F"</code>.</p>
</td></tr>
<tr><td><code id="white.test_+3A_scale">scale</code></td>
<td>
<p>a logical indicating whether the data should be scaled 
before computing the test statistic. The default arguments to
<code><a href="base.html#topic+scale">scale</a></code> are used.</p>
</td></tr>
<tr><td><code id="white.test_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null is the hypotheses of linearity in &ldquo;mean&rdquo;. This
type of test is consistent against arbitrary nonlinearity
in mean. If <code>type</code> equals <code>"F"</code>, then the F-statistic
instead of the Chi-Squared statistic is used in analogy to the
classical linear regression. 
</p>
<p>Missing values are not allowed.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was
performed.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>a list containing the additional parameters used to
compute the test statistic.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
<tr><td><code>arguments</code></td>
<td>
<p>additional arguments used to compute the test statistic.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. Trapletti</p>


<h3>References</h3>

<p>T. H. Lee, H. White, and C. W. J. Granger (1993): Testing for
neglected nonlinearity in time series models. <em>Journal of
Econometrics</em> <b>56</b>, 269-290.
</p>


<h3>See Also</h3>

<p><code><a href="tseries.html#topic+terasvirta.test">terasvirta.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1000

x &lt;- runif(1000, -1, 1)  # Non-linear in ``mean'' regression 
y &lt;- x^2 - x^3 + 0.1*rnorm(x)
white.test(x, y)

## Is the polynomial of order 2 misspecified?
white.test(cbind(x,x^2,x^3), y)

## Generate time series which is nonlinear in ``mean''
x[1] &lt;- 0.0
for(i in (2:n)) {
  x[i] &lt;- 0.4*x[i-1] + tanh(x[i-1]) + rnorm(1, sd=0.5)
}
x &lt;- as.ts(x)
plot(x)
white.test(x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
