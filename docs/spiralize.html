<!DOCTYPE html><html lang="en"><head><title>Help for package spiralize</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spiralize}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#current_spiral'><p>Get the current spiral object</p></a></li>
<li><a href='#current_spiral_vp'><p>Viewport name of the current spiral</p></a></li>
<li><a href='#current_track_index'><p>Helper functions for handling tracks</p></a></li>
<li><a href='#get_track_data'><p>Meta-data of a track</p></a></li>
<li><a href='#horizon_legend'><p>Legend for the horizon chart</p></a></li>
<li><a href='#solve_theta_from_spiral_length'><p>Get theta from given spiral lengths</p></a></li>
<li><a href='#spiral_arrow'><p>Draw arrows in the spiral direction</p></a></li>
<li><a href='#spiral_axis'><p>Draw axis along the spiral</p></a></li>
<li><a href='#spiral_bars'><p>Add bars to a track</p></a></li>
<li><a href='#spiral_clear'><p>Clear the spiral curve</p></a></li>
<li><a href='#spiral_dendrogram'><p>Draw dendrogram</p></a></li>
<li><a href='#spiral_git_commits'><p>Visualize git commits</p></a></li>
<li><a href='#spiral_highlight'><p>Highlight a section of the spiral</p></a></li>
<li><a href='#spiral_highlight_by_sector'><p>Highlight a sector</p></a></li>
<li><a href='#spiral_horizon'><p>Draw horizon chart along the spiral</p></a></li>
<li><a href='#spiral_info'><p>Information of the current spiral</p></a></li>
<li><a href='#spiral_initialize'><p>Initialize the spiral</p></a></li>
<li><a href='#spiral_initialize_by_gcoor'><p>Initialize the spiral with genomic coordinates</p></a></li>
<li><a href='#spiral_initialize_by_time'><p>Initialize the spiral from time objects</p></a></li>
<li><a href='#spiral_lines'><p>Add lines to a track</p></a></li>
<li><a href='#spiral_opt'><p>Global options</p></a></li>
<li><a href='#spiral_phylo'><p>Draw phylogenetic tree</p></a></li>
<li><a href='#spiral_pkg_downloads'><p>Visualize package downloads</p></a></li>
<li><a href='#spiral_points'><p>Add points to a track</p></a></li>
<li><a href='#spiral_polygon'><p>Add polygons to a track</p></a></li>
<li><a href='#spiral_raster'><p>Add image to a track</p></a></li>
<li><a href='#spiral_rect'><p>Add rectangles to a track</p></a></li>
<li><a href='#spiral_segments'><p>Add segments to a track</p></a></li>
<li><a href='#spiral_text'><p>Add texts to a track</p></a></li>
<li><a href='#spiral_track'><p>Add a new track or move to an existed track</p></a></li>
<li><a href='#spiral_yaxis'><p>Draw y-axis</p></a></li>
<li><a href='#TRACK_META'><p>Get meta data in the current track</p></a></li>
<li><a href='#xy_to_cartesian'><p>Transform between coordinate systems</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Visualize Data on Spirals</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-14</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), grid</td>
</tr>
<tr>
<td>Imports:</td>
<td>GlobalOptions (&ge; 0.1.1), GetoptLong (&ge; 0.1.8), circlize,
stats, methods, grDevices, lubridate, utils, ComplexHeatmap</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, grImport, grImport2, jpeg, png, tiff,
cranlogs, cowplot, dendextend, bezier, magick, ape</td>
</tr>
<tr>
<td>Description:</td>
<td>It visualizes data along an Archimedean spiral <a href="https://en.wikipedia.org/wiki/Archimedean_spiral">https://en.wikipedia.org/wiki/Archimedean_spiral</a>, 
    makes so-called spiral graph or spiral chart. 
    It has two major advantages for visualization: 1. It is able to visualize data with very long axis with high 
    resolution. 2. It is efficient for time series data to reveal periodic patterns.</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jokergoo/spiralize">https://github.com/jokergoo/spiralize</a>,
<a href="https://jokergoo.github.io/spiralize/">https://jokergoo.github.io/spiralize/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-17 07:02:33 UTC; guz</td>
</tr>
<tr>
<td>Author:</td>
<td>Zuguang Gu <a href="https://orcid.org/0000-0002-7395-8709"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zuguang Gu &lt;z.gu@dkfz.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-18 11:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='current_spiral'>Get the current spiral object</h2><span id='topic+current_spiral'></span>

<h3>Description</h3>

<p>Get the current spiral object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>current_spiral()
</code></pre>


<h3>Details</h3>

<p>The returned value is an object of <code>spiral</code> reference class. The following methods might be useful (assume the object is named <code>s</code>):
</p>

<ul>
<li> <p><code>s$curve()</code>: It returns the radius for given angles (in radians).
</p>
</li>
<li> <p><code>s$spiral_length()</code>: It returns the length of the spiral (from the origin) for a given angle (in radians), thus if you want to get the length of a spiral segment,
it will be <code>s$spiral_length(theta2) - s$spiral_length(theta1)</code>.
</p>
</li></ul>

<p>Also there are the following meta-data for the current spiral:
</p>

<ul>
<li> <p><code>s$xlim</code>: Data range.
</p>
</li>
<li> <p><code>s$xrange</code>: <code>s$xlim[2] - s$xlim[1]</code>.
</p>
</li>
<li> <p><code>s$theta_lim</code>: The corresponding range of theta.
</p>
</li>
<li> <p><code>s$theta_range</code>: <code>s$theta_lim[2] - s$theta_lim[1]</code>.
</p>
</li>
<li> <p><code>s$spiral_length_lim</code>: The corresponding range of spiral length.
</p>
</li>
<li> <p><code>s$spiral_length_range</code>: <code>s$spiral_length_lim[2] - s$spiral_length_lim[1]</code>.
</p>
</li>
<li> <p><code>s$max_radius</code>: Radius at <code>s$theta_lim[2]</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>spiral</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spiral_initialize()
s = current_spiral()
s$curve(2*pi*2)
s$spiral_length(2*pi*2)
</code></pre>

<hr>
<h2 id='current_spiral_vp'>Viewport name of the current spiral</h2><span id='topic+current_spiral_vp'></span>

<h3>Description</h3>

<p>Viewport name of the current spiral
</p>


<h3>Usage</h3>

<pre><code class='language-R'>current_spiral_vp()
</code></pre>


<h3>Value</h3>

<p>A string of the viewport name.
</p>

<hr>
<h2 id='current_track_index'>Helper functions for handling tracks</h2><span id='topic+current_track_index'></span><span id='topic+set_current_track'></span><span id='topic+n_tracks'></span><span id='topic+is_in_track'></span>

<h3>Description</h3>

<p>Helper functions for handling tracks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>current_track_index()

set_current_track(track_index)

n_tracks()

is_in_track(x, y, track_index = current_track_index())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="current_track_index_+3A_track_index">track_index</code></td>
<td>
<p>The index of the track.</p>
</td></tr>
<tr><td><code id="current_track_index_+3A_x">x</code></td>
<td>
<p>X-location of data points.</p>
</td></tr>
<tr><td><code id="current_track_index_+3A_y">y</code></td>
<td>
<p>Y-location of data points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is_in_track()</code> tests whether data points are inside a certain track.
</p>


<h3>Value</h3>

<p><code>current_track_index()</code> returns the index of the current track.
</p>
<p><code>set_current_track()</code> returns no value.
</p>
<p><code>n_tracks()</code> returns the number of available tracks.
</p>
<p><code>is_in_track()</code> returns a logical vector.
</p>

<hr>
<h2 id='get_track_data'>Meta-data of a track</h2><span id='topic+get_track_data'></span>

<h3>Description</h3>

<p>Meta-data of a track
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_track_data(field, track_index = current_track_index())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_track_data_+3A_field">field</code></td>
<td>
<p>Name of the field, see the <strong>Details</strong> section.</p>
</td></tr>
<tr><td><code id="get_track_data_+3A_track_index">track_index</code></td>
<td>
<p>The index of the track.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are following fields that can be retrieved for a given track:
</p>

<ul>
<li> <p><code>ymin</code>: Minimal value on the y-axis.
</p>
</li>
<li> <p><code>ymax</code>: Maximal value on the y-axis.
</p>
</li>
<li> <p><code>ycenter</code>: <code>(ymin + ymax)/2</code>.
</p>
</li>
<li> <p><code>ylim</code>: <code>c(ylim, ymax)</code>.
</p>
</li>
<li> <p><code>yrange</code>: <code>ymax - ymin</code>.
</p>
</li>
<li> <p><code>height</code>: Height of the track, measured as the fraction of the distance between two neighbouring spiral loops.
</p>
</li></ul>

<p>It is more suggested to directly use <code><a href="#topic+TRACK_META">TRACK_META</a></code> to retrieve meta data for the current track.
</p>


<h3>Value</h3>

<p>A numeric vector (of length one or two) for the corresponding field.
</p>

<hr>
<h2 id='horizon_legend'>Legend for the horizon chart</h2><span id='topic+horizon_legend'></span>

<h3>Description</h3>

<p>Legend for the horizon chart
</p>


<h3>Usage</h3>

<pre><code class='language-R'>horizon_legend(
  lt,
  title = "",
  format = "%.2f",
  template = "[{x1}, {x2}]",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="horizon_legend_+3A_lt">lt</code></td>
<td>
<p>The object returned by <code><a href="#topic+spiral_horizon">spiral_horizon()</a></code>.</p>
</td></tr>
<tr><td><code id="horizon_legend_+3A_title">title</code></td>
<td>
<p>Title of the legend.</p>
</td></tr>
<tr><td><code id="horizon_legend_+3A_format">format</code></td>
<td>
<p>Number format of the legend labels.</p>
</td></tr>
<tr><td><code id="horizon_legend_+3A_template">template</code></td>
<td>
<p>Template to construct the labels.</p>
</td></tr>
<tr><td><code id="horizon_legend_+3A_...">...</code></td>
<td>
<p>Pass to <code><a href="ComplexHeatmap.html#topic+Legend">ComplexHeatmap::Legend()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ComplexHeatmap.html#topic+Legend">ComplexHeatmap::Legend</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see examples in `spiral_horizon()`.
</code></pre>

<hr>
<h2 id='solve_theta_from_spiral_length'>Get theta from given spiral lengths</h2><span id='topic+solve_theta_from_spiral_length'></span>

<h3>Description</h3>

<p>Get theta from given spiral lengths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_theta_from_spiral_length(len, interval = NULL, offset = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="solve_theta_from_spiral_length_+3A_len">len</code></td>
<td>
<p>A vector of spiral lengths.</p>
</td></tr>
<tr><td><code id="solve_theta_from_spiral_length_+3A_interval">interval</code></td>
<td>
<p>Interval to search for the solution.</p>
</td></tr>
<tr><td><code id="solve_theta_from_spiral_length_+3A_offset">offset</code></td>
<td>
<p>Offset of the spiral. In the general form: <code> r = a + r*theta</code>, offset is the value of <code>a</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The length of the spiral has a complicated form, see <a href="https://downloads.imagej.net/fiji/snapshots/arc_length.pdf">https://downloads.imagej.net/fiji/snapshots/arc_length.pdf</a>.
Let's say the form is <code>l = f(theta)</code> where <code>f()</code> is the complex equation for calculating <code>l</code>, <code>solve_theta_from_spiral_length()</code> tries to find theta with a known <code>l</code>.
It uses <code><a href="stats.html#topic+uniroot">stats::uniroot()</a></code> to search for the solutions.
</p>


<h3>Value</h3>

<p>The theta value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spiral_initialize()
s = current_spiral()
theta = pi*seq(2, 3, length = 10)
theta
len = s$spiral_length(theta)
solve_theta_from_spiral_length(len) # should be very similar as theta
</code></pre>

<hr>
<h2 id='spiral_arrow'>Draw arrows in the spiral direction</h2><span id='topic+spiral_arrow'></span>

<h3>Description</h3>

<p>Draw arrows in the spiral direction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_arrow(
  x1,
  x2,
  y = get_track_data("ycenter", track_index),
  width = get_track_data("yrange", track_index)/3,
  arrow_head_length = unit(4, "mm"),
  arrow_head_width = width * 2,
  arrow_position = c("end", "start"),
  tail = c("normal", "point"),
  gp = gpar(),
  track_index = current_track_index()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_arrow_+3A_x1">x1</code></td>
<td>
<p>Start of the arrow.</p>
</td></tr>
<tr><td><code id="spiral_arrow_+3A_x2">x2</code></td>
<td>
<p>End of the arrow.</p>
</td></tr>
<tr><td><code id="spiral_arrow_+3A_y">y</code></td>
<td>
<p>Y-location of the arrow.</p>
</td></tr>
<tr><td><code id="spiral_arrow_+3A_width">width</code></td>
<td>
<p>Width of the arrow. The value can be the one measured in the data coordinates or a <code><a href="grid.html#topic+unit">grid::unit()</a></code> object.</p>
</td></tr>
<tr><td><code id="spiral_arrow_+3A_arrow_head_length">arrow_head_length</code></td>
<td>
<p>Length of the arrow head.</p>
</td></tr>
<tr><td><code id="spiral_arrow_+3A_arrow_head_width">arrow_head_width</code></td>
<td>
<p>Width of the arrow head.</p>
</td></tr>
<tr><td><code id="spiral_arrow_+3A_arrow_position">arrow_position</code></td>
<td>
<p>Position of the arrow. If the value is <code>"end"</code>, then the arrow head is drawn at <code>x = x2</code>. If the value
is <code>"start"</code>, then the arrow head is drawn at <code>x = x1</code>.</p>
</td></tr>
<tr><td><code id="spiral_arrow_+3A_tail">tail</code></td>
<td>
<p>The shape of the arrow tail.</p>
</td></tr>
<tr><td><code id="spiral_arrow_+3A_gp">gp</code></td>
<td>
<p>Graphical parameters.</p>
</td></tr>
<tr><td><code id="spiral_arrow_+3A_track_index">track_index</code></td>
<td>
<p>Index of the track.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>See Also</h3>

<p>Note <code><a href="#topic+spiral_segments">spiral_segments()</a></code> also supports drawing line-based arrows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spiral_initialize()
spiral_track()
spiral_arrow(0.3, 0.6, gp = gpar(fill = "red"))
spiral_arrow(0.8, 0.9, gp = gpar(fill = "blue"), tail = "point", arrow_position = "start")
</code></pre>

<hr>
<h2 id='spiral_axis'>Draw axis along the spiral</h2><span id='topic+spiral_axis'></span><span id='topic+spiral_xaxis'></span>

<h3>Description</h3>

<p>Draw axis along the spiral
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_axis(
  h = c("top", "bottom"),
  at = NULL,
  major_at = at,
  labels = TRUE,
  curved_labels = FALSE,
  minor_ticks = 4,
  major_ticks_length = unit(4, "bigpts"),
  minor_ticks_length = unit(2, "bigpts"),
  ticks_gp = gpar(),
  labels_gp = gpar(fontsize = 6),
  track_index = current_track_index()
)

spiral_xaxis(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_axis_+3A_h">h</code></td>
<td>
<p>Position of the axis. The value can be a character of &quot;top&quot; or &quot;bottom&quot;.</p>
</td></tr>
<tr><td><code id="spiral_axis_+3A_at">at</code></td>
<td>
<p>Breaks points on axis.</p>
</td></tr>
<tr><td><code id="spiral_axis_+3A_major_at">major_at</code></td>
<td>
<p>Breaks points on axis. It is the same as <code>at</code>.</p>
</td></tr>
<tr><td><code id="spiral_axis_+3A_labels">labels</code></td>
<td>
<p>The corresponding labels for the break points.</p>
</td></tr>
<tr><td><code id="spiral_axis_+3A_curved_labels">curved_labels</code></td>
<td>
<p>Whether are the labels are curved?</p>
</td></tr>
<tr><td><code id="spiral_axis_+3A_minor_ticks">minor_ticks</code></td>
<td>
<p>Number of minor ticks.</p>
</td></tr>
<tr><td><code id="spiral_axis_+3A_major_ticks_length">major_ticks_length</code></td>
<td>
<p>Length of the major ticks. The value should be a <code><a href="grid.html#topic+unit">grid::unit()</a></code> object.</p>
</td></tr>
<tr><td><code id="spiral_axis_+3A_minor_ticks_length">minor_ticks_length</code></td>
<td>
<p>Length of the minor ticks. The value should be a <code><a href="grid.html#topic+unit">grid::unit()</a></code> object.</p>
</td></tr>
<tr><td><code id="spiral_axis_+3A_ticks_gp">ticks_gp</code></td>
<td>
<p>Graphical parameters for the ticks.</p>
</td></tr>
<tr><td><code id="spiral_axis_+3A_labels_gp">labels_gp</code></td>
<td>
<p>Graphical parameters for the labels.</p>
</td></tr>
<tr><td><code id="spiral_axis_+3A_track_index">track_index</code></td>
<td>
<p>Index of the track.</p>
</td></tr>
<tr><td><code id="spiral_axis_+3A_...">...</code></td>
<td>
<p>All pass to <code>spiral_axis()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spiral_initialize()
spiral_track()
spiral_axis()

# if the spiral is interpolated by the curve length
spiral_initialize(scale_by = "curve_length"); spiral_track()
spiral_axis()

spiral_initialize(xlim = c(0, 360*4), start = 360, end = 360*5); spiral_track()
spiral_axis(major_at = seq(0, 360*4, by = 30))

spiral_initialize(xlim = c(0, 12*4), start = 360, end = 360*5); spiral_track()
spiral_axis(major_at = seq(0, 12*4, by = 1), labels = c("", rep(month.name, 4)))

</code></pre>

<hr>
<h2 id='spiral_bars'>Add bars to a track</h2><span id='topic+spiral_bars'></span>

<h3>Description</h3>

<p>Add bars to a track
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_bars(
  pos,
  value,
  baseline = get_track_data("ymin", track_index),
  bar_width = min(diff(pos)),
  gp = gpar(),
  track_index = current_track_index()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_bars_+3A_pos">pos</code></td>
<td>
<p>X-locations of the center of bars.</p>
</td></tr>
<tr><td><code id="spiral_bars_+3A_value">value</code></td>
<td>
<p>Height of bars. The value can be a simple numeric vector, or a matrix.</p>
</td></tr>
<tr><td><code id="spiral_bars_+3A_baseline">baseline</code></td>
<td>
<p>Baseline of the bars. Note it only works when <code>value</code> is a simple vector.</p>
</td></tr>
<tr><td><code id="spiral_bars_+3A_bar_width">bar_width</code></td>
<td>
<p>Width of bars.</p>
</td></tr>
<tr><td><code id="spiral_bars_+3A_gp">gp</code></td>
<td>
<p>Graphical parameters.</p>
</td></tr>
<tr><td><code id="spiral_bars_+3A_track_index">track_index</code></td>
<td>
<p>Index of the track.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = seq(1, 1000, by = 1) - 0.5
y = runif(1000)
spiral_initialize(xlim = c(0, 1000))
spiral_track(height = 0.8)
spiral_bars(x, y)

# a three-column matrix
y = matrix(runif(3*1000), ncol = 3)
y = y/rowSums(y)
spiral_initialize(xlim = c(0, 1000))
spiral_track(height = 0.8)
spiral_bars(x, y, gp = gpar(fill = 2:4, col = NA))

</code></pre>

<hr>
<h2 id='spiral_clear'>Clear the spiral curve</h2><span id='topic+spiral_clear'></span>

<h3>Description</h3>

<p>Clear the spiral curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_clear(check_vp = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_clear_+3A_check_vp">check_vp</code></td>
<td>
<p>Whether to check the viewport.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It basically sets the internally spiral object to <code>NULL</code>, and reset all the global options.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>

<hr>
<h2 id='spiral_dendrogram'>Draw dendrogram</h2><span id='topic+spiral_dendrogram'></span>

<h3>Description</h3>

<p>Draw dendrogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_dendrogram(dend, gp = gpar(), track_index = current_track_index())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_dendrogram_+3A_dend">dend</code></td>
<td>
<p>A <code><a href="stats.html#topic+dendrogram">stats::dendrogram</a></code> object.</p>
</td></tr>
<tr><td><code id="spiral_dendrogram_+3A_gp">gp</code></td>
<td>
<p>Graphical parameters of the dendrogram edges, mainly as a global setting.</p>
</td></tr>
<tr><td><code id="spiral_dendrogram_+3A_track_index">track_index</code></td>
<td>
<p>Index of the track.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Graphical parameters for individual edges can be set via the <code>edgePar</code> attribute on each node in the dendrogram, see <code><a href="stats.html#topic+dendrogram">stats::dendrogram</a></code>
for how to set <code>edgePar</code>.
</p>
<p>The dendrogram edges can also be rendered by <code><a href="dendextend.html#topic+color_branches">dendextend::color_branches()</a></code>.
</p>


<h3>Value</h3>

<p>Height of the dendrogram.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k = 500
dend = as.dendrogram(hclust(dist(runif(k))))
spiral_initialize(xlim = c(0, k), start = 360, end = 360*3)
spiral_track(height = 0.8, background_gp = gpar(fill = "#EEEEEE", col = NA))
spiral_dendrogram(dend)


require(dendextend)
dend = color_branches(dend, k = 4)
spiral_initialize(xlim = c(0, k), start = 360, end = 360*3)
spiral_track(height = 0.8, background_gp = gpar(fill = "#EEEEEE", col = NA))
spiral_dendrogram(dend)

</code></pre>

<hr>
<h2 id='spiral_git_commits'>Visualize git commits</h2><span id='topic+spiral_git_commits'></span>

<h3>Description</h3>

<p>Visualize git commits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_git_commits(
  repo = ".",
  show_legend = TRUE,
  start = NULL,
  end = Sys.Date(),
  pt_range = c(2, 16),
  commits_range = c(1, ceiling(quantile(n[n &gt; 0], 0.95))),
  type = c("points", "heatmap"),
  colors = c("#3288BD", "#99D594", "#E6F598", "#FFFFBF", "#FEE08B", "#FC8D59", "#D53E4F")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_git_commits_+3A_repo">repo</code></td>
<td>
<p>Path of the git repo. The value can be a single repo or a vector of repos.</p>
</td></tr>
<tr><td><code id="spiral_git_commits_+3A_show_legend">show_legend</code></td>
<td>
<p>Whether to show the legend.</p>
</td></tr>
<tr><td><code id="spiral_git_commits_+3A_start">start</code></td>
<td>
<p>Start date. By default it is the first date of the commit. The value can be a string such as &quot;2022-01-01&quot; or a <code><a href="base.html#topic+Dates">base::Date</a></code> object.</p>
</td></tr>
<tr><td><code id="spiral_git_commits_+3A_end">end</code></td>
<td>
<p>End date. By default it is the current date. The value can be a string such as &quot;2022-01-01&quot; or a <code><a href="base.html#topic+Dates">base::Date</a></code> object.</p>
</td></tr>
<tr><td><code id="spiral_git_commits_+3A_pt_range">pt_range</code></td>
<td>
<p>Range of the point sizes. The default is between 1 and the 90 percentile of daily commits.</p>
</td></tr>
<tr><td><code id="spiral_git_commits_+3A_commits_range">commits_range</code></td>
<td>
<p>Range of the numbers of commits.</p>
</td></tr>
<tr><td><code id="spiral_git_commits_+3A_type">type</code></td>
<td>
<p>Type of the plot.</p>
</td></tr>
<tr><td><code id="spiral_git_commits_+3A_colors">colors</code></td>
<td>
<p>If type is the heatmap, it controls the list of colors.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
spiral_git_commits("~/project/development/ComplexHeatmap")
spiral_git_commits("~/project/development/ComplexHeatmap", type = "heatmap")

## End(Not run)
</code></pre>

<hr>
<h2 id='spiral_highlight'>Highlight a section of the spiral</h2><span id='topic+spiral_highlight'></span>

<h3>Description</h3>

<p>Highlight a section of the spiral
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_highlight(
  x1,
  x2,
  type = c("rect", "line"),
  padding = unit(1, "mm"),
  line_side = c("inside", "outside"),
  line_width = unit(1, "pt"),
  gp = gpar(fill = "red"),
  track_index = current_track_index()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_highlight_+3A_x1">x1</code></td>
<td>
<p>Start location of the highlighted section.</p>
</td></tr>
<tr><td><code id="spiral_highlight_+3A_x2">x2</code></td>
<td>
<p>End location of the highlighted section.</p>
</td></tr>
<tr><td><code id="spiral_highlight_+3A_type">type</code></td>
<td>
<p>Type of the highlighting. &quot;rect&quot; means drawing transparent rectangles covering the whole track.
&quot;line&quot; means drawing annotation lines on top of the track or at the bottom of it.</p>
</td></tr>
<tr><td><code id="spiral_highlight_+3A_padding">padding</code></td>
<td>
<p>When the highlight type is &quot;rect&quot;, it controls the padding of the highlighted region. The value should be a <code><a href="grid.html#topic+unit">grid::unit()</a></code> object
or a numeric value which is the fraction of the length of the highlighted section. The length can be one or two.
Note it only extends in the radial direction.</p>
</td></tr>
<tr><td><code id="spiral_highlight_+3A_line_side">line_side</code></td>
<td>
<p>If the highlight type is &quot;line&quot;, it controls which side of the track to draw the lines.</p>
</td></tr>
<tr><td><code id="spiral_highlight_+3A_line_width">line_width</code></td>
<td>
<p>Width of the annotation line. Value should be a <code><a href="grid.html#topic+unit">grid::unit()</a></code> object.</p>
</td></tr>
<tr><td><code id="spiral_highlight_+3A_gp">gp</code></td>
<td>
<p>Graphical parameters.</p>
</td></tr>
<tr><td><code id="spiral_highlight_+3A_track_index">track_index</code></td>
<td>
<p>Index of the track.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spiral_initialize(); spiral_track()
spiral_highlight(0.4, 0.6)
spiral_highlight(0.1, 0.2, type = "line", gp = gpar(col = "blue"))
spiral_highlight(0.7, 0.8, type = "line", line_side = "outside")
</code></pre>

<hr>
<h2 id='spiral_highlight_by_sector'>Highlight a sector</h2><span id='topic+spiral_highlight_by_sector'></span>

<h3>Description</h3>

<p>Highlight a sector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_highlight_by_sector(
  x1,
  x2,
  x3 = NULL,
  x4 = NULL,
  padding = unit(1, "mm"),
  gp = gpar(fill = "red")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_highlight_by_sector_+3A_x1">x1</code></td>
<td>
<p>Start location which determines the start of the sector.</p>
</td></tr>
<tr><td><code id="spiral_highlight_by_sector_+3A_x2">x2</code></td>
<td>
<p>End location which determines the end of the sector. Note <code>x2</code> should be larger than x1 and the angular difference between <code>x1</code> and <code>x2</code> should be smaller than a circle.</p>
</td></tr>
<tr><td><code id="spiral_highlight_by_sector_+3A_x3">x3</code></td>
<td>
<p>Start location which determines the start of the sector on the upper border.</p>
</td></tr>
<tr><td><code id="spiral_highlight_by_sector_+3A_x4">x4</code></td>
<td>
<p>End location which determines the end of the sector on the upper border.</p>
</td></tr>
<tr><td><code id="spiral_highlight_by_sector_+3A_padding">padding</code></td>
<td>
<p>It controls the radial extension of the sector. The value should be a <code><a href="grid.html#topic+unit">grid::unit()</a></code> object with length one or two.</p>
</td></tr>
<tr><td><code id="spiral_highlight_by_sector_+3A_gp">gp</code></td>
<td>
<p>Graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x1</code> and <code>x2</code> determine the position of the highlighted sector. If <code>x3</code> and <code>x4</code> are not set, the sector extends until the most outside loop.
If <code>x3</code> and <code>x4</code> are set, they determine the outer border of the sector. In this case, if <code>x3</code> and <code>x4</code> are set, <code>x3</code> should be larger than <code>x2</code>.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spiral_initialize(xlim = c(0, 360*4), start = 360, end = 360*5)
spiral_track()
spiral_axis()
spiral_highlight_by_sector(36, 72)
spiral_highlight_by_sector(648, 684)
spiral_highlight_by_sector(216, 252, 936, 972, gp = gpar(fill = "blue"))
</code></pre>

<hr>
<h2 id='spiral_horizon'>Draw horizon chart along the spiral</h2><span id='topic+spiral_horizon'></span>

<h3>Description</h3>

<p>Draw horizon chart along the spiral
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_horizon(
  x,
  y,
  y_max = max(abs(y)),
  n_slices = 4,
  slice_size,
  pos_fill = "#D73027",
  neg_fill = "#313695",
  use_bars = FALSE,
  bar_width = min(diff(x)),
  negative_from_top = FALSE,
  track_index = current_track_index()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_horizon_+3A_x">x</code></td>
<td>
<p>X-locations of the data points.</p>
</td></tr>
<tr><td><code id="spiral_horizon_+3A_y">y</code></td>
<td>
<p>Y-locations of the data points.</p>
</td></tr>
<tr><td><code id="spiral_horizon_+3A_y_max">y_max</code></td>
<td>
<p>Maximal absolute value on y-axis.</p>
</td></tr>
<tr><td><code id="spiral_horizon_+3A_n_slices">n_slices</code></td>
<td>
<p>Number of slices.</p>
</td></tr>
<tr><td><code id="spiral_horizon_+3A_slice_size">slice_size</code></td>
<td>
<p>Size of the slices. The final number of sizes is <code>ceiling(max(abs(y))/slice_size)</code>.</p>
</td></tr>
<tr><td><code id="spiral_horizon_+3A_pos_fill">pos_fill</code></td>
<td>
<p>Colors for positive values.</p>
</td></tr>
<tr><td><code id="spiral_horizon_+3A_neg_fill">neg_fill</code></td>
<td>
<p>Colors for negative values.</p>
</td></tr>
<tr><td><code id="spiral_horizon_+3A_use_bars">use_bars</code></td>
<td>
<p>Whether to use bars?</p>
</td></tr>
<tr><td><code id="spiral_horizon_+3A_bar_width">bar_width</code></td>
<td>
<p>Width of bars.</p>
</td></tr>
<tr><td><code id="spiral_horizon_+3A_negative_from_top">negative_from_top</code></td>
<td>
<p>Should negative distribution be drawn from the top?</p>
</td></tr>
<tr><td><code id="spiral_horizon_+3A_track_index">track_index</code></td>
<td>
<p>Index of the track.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the track height is very small in the spiral, horizon chart visualization is an efficient way to visualize
distribution-like graphics.
</p>


<h3>Value</h3>

<p>A list of the following objects:
</p>

<ul>
<li><p> a color mapping function for colors.
</p>
</li>
<li><p> a vector of intervals that split the data.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+horizon_legend">horizon_legend()</a></code> for generating the legend.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df = readRDS(system.file("extdata", "global_temperature.rds", package = "spiralize"))
df = df[df$Source == "GCAG", ]
spiral_initialize_by_time(xlim = range(df$Date), unit_on_axis = "months", period = "year",
    period_per_loop = 20, polar_lines_by = 360/20)
spiral_track()
spiral_horizon(df$Date, df$Mean, use_bar = TRUE)

# with legend
require(ComplexHeatmap)
spiral_initialize_by_time(xlim = range(df$Date), unit_on_axis = "months", period = "year",
    period_per_loop = 20, polar_lines_by = 360/20, 
    vp_param = list(x = unit(0, "npc"), just = "left"))
spiral_track()
lt = spiral_horizon(df$Date, df$Mean, use_bar = TRUE)
lgd = horizon_legend(lt, title = "Temperature difference")
draw(lgd, x = unit(1, "npc") + unit(2, "mm"), just = "left")

</code></pre>

<hr>
<h2 id='spiral_info'>Information of the current spiral</h2><span id='topic+spiral_info'></span>

<h3>Description</h3>

<p>Information of the current spiral
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_info()
</code></pre>


<h3>Details</h3>

<p>It prints information of the current spiral.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spiral_initialize()
spiral_track(ylim = c(0, 1), height = 0.4)
spiral_track(ylim = c(-10, 10), height = 0.4)
spiral_info()
</code></pre>

<hr>
<h2 id='spiral_initialize'>Initialize the spiral</h2><span id='topic+spiral_initialize'></span>

<h3>Description</h3>

<p>Initialize the spiral
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_initialize(
  xlim = c(0, 1),
  start = 360,
  end = 360 * 5,
  scale_by = c("angle", "curve_length"),
  period = NULL,
  clockwise = FALSE,
  flip = c("none", "vertical", "horizontal", "both"),
  reverse = FALSE,
  polar_lines = scale_by == "angle",
  polar_lines_by = 30,
  polar_lines_gp = gpar(col = "#808080", lty = 3),
  padding = unit(5, "mm"),
  newpage = TRUE,
  vp_param = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_initialize_+3A_xlim">xlim</code></td>
<td>
<p>Range on x-locations.</p>
</td></tr>
<tr><td><code id="spiral_initialize_+3A_start">start</code></td>
<td>
<p>Start of the spiral, in degree. <code>start</code> and <code>end</code> should be positive and <code>start</code> should be smaller than <code>end</code>.</p>
</td></tr>
<tr><td><code id="spiral_initialize_+3A_end">end</code></td>
<td>
<p>End of the spiral, in degree.</p>
</td></tr>
<tr><td><code id="spiral_initialize_+3A_scale_by">scale_by</code></td>
<td>
<p>How scales on x-axis are equally interpolated? The values can be one of &quot;angle&quot; and &quot;curve_length&quot;. If
the value is &quot;angle&quot;, equal angle difference corresponds to equal difference of data. In this case, in outer loops,
the scales are longer than in the inner loops, although the difference on the data are the same. If
the value is &quot;curve_length&quot;, equal curve length difference corresponds to the equal difference of the data.</p>
</td></tr>
<tr><td><code id="spiral_initialize_+3A_period">period</code></td>
<td>
<p>Under &quot;angle&quot; mode, the number of loops can also be controlled by argument <code>period</code> which controls the length
of data a spiral loop corresponds to. Note in this case, argument <code>end</code> is ignored and the value for <code>end</code> is
internally recalculated.</p>
</td></tr>
<tr><td><code id="spiral_initialize_+3A_clockwise">clockwise</code></td>
<td>
<p>Whether the curve is in a closewise direction. If it is set to <code>TRUE</code>, argument <code>flip</code> and <code>reverse</code> are ignored.</p>
</td></tr>
<tr><td><code id="spiral_initialize_+3A_flip">flip</code></td>
<td>
<p>How to flip the spiral? By default, the spiral starts from the origin of the coordinate and grows reverseclockwisely.
The argument controls the growing direction of the spiral.</p>
</td></tr>
<tr><td><code id="spiral_initialize_+3A_reverse">reverse</code></td>
<td>
<p>By default, the most inside of the spiral corresponds to the lower boundary of x-location. Setting the value to <code>FALSE</code>
can reverse the direction.</p>
</td></tr>
<tr><td><code id="spiral_initialize_+3A_polar_lines">polar_lines</code></td>
<td>
<p>Whether draw the polar guiding lines.</p>
</td></tr>
<tr><td><code id="spiral_initialize_+3A_polar_lines_by">polar_lines_by</code></td>
<td>
<p>Increment of the polar lines. Measured in degree. The value can also be a vector that defines where to add polar lines.</p>
</td></tr>
<tr><td><code id="spiral_initialize_+3A_polar_lines_gp">polar_lines_gp</code></td>
<td>
<p>Graphics parameters for the polar lines.</p>
</td></tr>
<tr><td><code id="spiral_initialize_+3A_padding">padding</code></td>
<td>
<p>Padding of the plotting region. The value can be a <code><a href="grid.html#topic+unit">grid::unit()</a></code> of length of one to two.</p>
</td></tr>
<tr><td><code id="spiral_initialize_+3A_newpage">newpage</code></td>
<td>
<p>Whether to apply <code><a href="grid.html#topic+grid.newpage">grid::grid.newpage()</a></code> before making the plot?</p>
</td></tr>
<tr><td><code id="spiral_initialize_+3A_vp_param">vp_param</code></td>
<td>
<p>A list of parameters sent to <code><a href="grid.html#topic+viewport">grid::viewport()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spiral_initialize(); spiral_track()
spiral_initialize(start = 180, end = 360+180); spiral_track()
spiral_initialize(flip = "vertical"); spiral_track()
spiral_initialize(flip = "horizontal"); spiral_track()
spiral_initialize(flip = "both"); spiral_track()
spiral_initialize(); spiral_track(); spiral_axis()
spiral_initialize(scale_by = "curve_length"); spiral_track(); spiral_axis()

# the following example shows the difference of `scale_by` more clearly:
make_plot = function(scale_by) {
    n = 100
    require(circlize)
    col = circlize::colorRamp2(c(0, 0.5, 1), c("blue", "white", "red"))
    spiral_initialize(xlim = c(0, n), scale_by = scale_by)
    spiral_track(height = 0.9)

    x = runif(n)
    spiral_rect(1:n - 1, 0, 1:n, 1, gp = gpar(fill = col(x), col = NA))
}
make_plot("angle")
make_plot("curve_length")
</code></pre>

<hr>
<h2 id='spiral_initialize_by_gcoor'>Initialize the spiral with genomic coordinates</h2><span id='topic+spiral_initialize_by_gcoor'></span>

<h3>Description</h3>

<p>Initialize the spiral with genomic coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_initialize_by_gcoor(xlim, scale_by = "curve_length", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_initialize_by_gcoor_+3A_xlim">xlim</code></td>
<td>
<p>Range of the genomic coordinates.</p>
</td></tr>
<tr><td><code id="spiral_initialize_by_gcoor_+3A_scale_by">scale_by</code></td>
<td>
<p>For genomic plot, axis is linearly scaled by the curve length.</p>
</td></tr>
<tr><td><code id="spiral_initialize_by_gcoor_+3A_...">...</code></td>
<td>
<p>All pass to <code>spiral_initialize</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is basically the same as <code><a href="#topic+spiral_initialize">spiral_initialize()</a></code>. The only difference is the axis labels are automatically
formated for genomic coordinates.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spiral_initialize_by_gcoor(c(0, 1000000000))
spiral_track()
spiral_axis()
</code></pre>

<hr>
<h2 id='spiral_initialize_by_time'>Initialize the spiral from time objects</h2><span id='topic+spiral_initialize_by_time'></span>

<h3>Description</h3>

<p>Initialize the spiral from time objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_initialize_by_time(
  xlim,
  start = NULL,
  end = NULL,
  unit_on_axis = c("days", "months", "weeks", "hours", "mins", "secs"),
  period = c("years", "months", "weeks", "days", "hours", "mins"),
  normalize_year = FALSE,
  period_per_loop = 1,
  polar_lines_by = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_initialize_by_time_+3A_xlim">xlim</code></td>
<td>
<p>Range of the time. The value can be time object such as <code><a href="base.html#topic+Dates">base::Date</a></code>, <code><a href="base.html#topic+DateTimeClasses">base::POSIXlt</a></code> or <code><a href="base.html#topic+DateTimeClasses">base::POSIXct</a></code>. The value can also be characters and it is converted to time objects automatically.</p>
</td></tr>
<tr><td><code id="spiral_initialize_by_time_+3A_start">start</code></td>
<td>
<p>Start of the spiral, in degrees. By default it is automatically calculated.</p>
</td></tr>
<tr><td><code id="spiral_initialize_by_time_+3A_end">end</code></td>
<td>
<p>End of the spiral, in degrees. By default it is automatically calculated.</p>
</td></tr>
<tr><td><code id="spiral_initialize_by_time_+3A_unit_on_axis">unit_on_axis</code></td>
<td>
<p>Units on the axis.</p>
</td></tr>
<tr><td><code id="spiral_initialize_by_time_+3A_period">period</code></td>
<td>
<p>Which period to use?</p>
</td></tr>
<tr><td><code id="spiral_initialize_by_time_+3A_normalize_year">normalize_year</code></td>
<td>
<p>Whether to enforce one spiral loop to represent a complete year?</p>
</td></tr>
<tr><td><code id="spiral_initialize_by_time_+3A_period_per_loop">period_per_loop</code></td>
<td>
<p>How many periods to put in a spiral loop?</p>
</td></tr>
<tr><td><code id="spiral_initialize_by_time_+3A_polar_lines_by">polar_lines_by</code></td>
<td>
<p>By default different value of <code>polar_lines_by</code> is set for different <code>period</code>. E.g. 360/7 is set if <code>period</code> is &quot;weeks&quot; or 360/24 is set if <code>peroid</code> is set to &quot;hours&quot;.
When <code>period</code> is year and <code>unit_on_axis</code> is day, the proportion of sectors by polar lines corresponds to the proportion of month days in a year.</p>
</td></tr>
<tr><td><code id="spiral_initialize_by_time_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print messages?</p>
</td></tr>
<tr><td><code id="spiral_initialize_by_time_+3A_...">...</code></td>
<td>
<p>All pass to <code><a href="#topic+spiral_initialize">spiral_initialize()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;start&quot; and &quot;end&quot; are automatically calculated for different &quot;unit_on_axis&quot; and &quot;period&quot;. For example, if &quot;unit_on_axis&quot; is &quot;days&quot; and &quot;period&quot; is &quot;years&quot;, then
the first day of each each year is always put on <code>theta = 0 + 2*pi*k</code> where <code>k</code> is the index of spiral loops.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spiral_initialize_by_time(xlim = c("2014-01-01", "2021-06-17"))
spiral_track(height = 0.6)
spiral_axis()

spiral_initialize_by_time(xlim = c("2021-01-01 00:00:00", "2021-01-05 00:00:00"))
spiral_track(height = 0.6)
spiral_axis()

spiral_initialize_by_time(xlim = c("2021-01-01 00:00:00", "2021-01-01 00:10:00"),
    unit_on_axis = "secs", period = "mins")
spiral_track(height = 0.6)
spiral_axis()
</code></pre>

<hr>
<h2 id='spiral_lines'>Add lines to a track</h2><span id='topic+spiral_lines'></span>

<h3>Description</h3>

<p>Add lines to a track
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_lines(
  x,
  y,
  type = "l",
  gp = gpar(),
  baseline = "bottom",
  area = FALSE,
  track_index = current_track_index()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_lines_+3A_x">x</code></td>
<td>
<p>X-locations of the data points.</p>
</td></tr>
<tr><td><code id="spiral_lines_+3A_y">y</code></td>
<td>
<p>Y-locations of the data points.</p>
</td></tr>
<tr><td><code id="spiral_lines_+3A_type">type</code></td>
<td>
<p>Type of the line. Value should be one of &quot;l&quot; and &quot;h&quot;. When the value is &quot;h&quot;, vertical lines (or radial lines if you consider the polar coordinates) relative to the baseline will be drawn.</p>
</td></tr>
<tr><td><code id="spiral_lines_+3A_gp">gp</code></td>
<td>
<p>Graphical parameters.</p>
</td></tr>
<tr><td><code id="spiral_lines_+3A_baseline">baseline</code></td>
<td>
<p>Baseline used when <code>type</code> is <code>"l"</code> or <code>area</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="spiral_lines_+3A_area">area</code></td>
<td>
<p>Whether to draw the area under the lines? Note <code>gpar(fill = ...)</code> controls the filled colors of the areas.</p>
</td></tr>
<tr><td><code id="spiral_lines_+3A_track_index">track_index</code></td>
<td>
<p>Index of the track.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = sort(runif(1000))
y = runif(1000)
spiral_initialize()
spiral_track()
spiral_lines(x, y)

spiral_initialize()
spiral_track()
spiral_lines(x, y, type = "h")

spiral_initialize()
spiral_track()
spiral_lines(x, y, area = TRUE, gp = gpar(fill = "red", col = NA))
</code></pre>

<hr>
<h2 id='spiral_opt'>Global options</h2><span id='topic+spiral_opt'></span>

<h3>Description</h3>

<p>Global options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_opt(..., RESET = FALSE, READ.ONLY = NULL, LOCAL = FALSE, ADD = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_opt_+3A_...">...</code></td>
<td>
<p>Arguments for the parameters, see &quot;details&quot; section.</p>
</td></tr>
<tr><td><code id="spiral_opt_+3A_reset">RESET</code></td>
<td>
<p>Whether to reset to default values.</p>
</td></tr>
<tr><td><code id="spiral_opt_+3A_read.only">READ.ONLY</code></td>
<td>
<p>Please ignore.</p>
</td></tr>
<tr><td><code id="spiral_opt_+3A_local">LOCAL</code></td>
<td>
<p>Please ignore.</p>
</td></tr>
<tr><td><code id="spiral_opt_+3A_add">ADD</code></td>
<td>
<p>Please ignore.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are the following global parameters:
</p>

<ul>
<li> <p><code>min_segment_len</code> Minimal length of the segment that partitions a curve.
</p>
</li>
<li> <p><code>help</code> Whether to print the help messages?
</p>
</li></ul>

<p>To access the value of an option: <code>spiral_opt$name</code> where <code>name</code> is the name of the option. To set a new value
for an option: <code>spiral_opt$name = new_value</code>.
</p>


<h3>Value</h3>

<p>A list of options.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spiral_opt
</code></pre>

<hr>
<h2 id='spiral_phylo'>Draw phylogenetic tree</h2><span id='topic+spiral_phylo'></span><span id='topic+phylo_to_dendrogram'></span>

<h3>Description</h3>

<p>Draw phylogenetic tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_phylo(
  obj,
  gp = gpar(),
  log = FALSE,
  reverse = FALSE,
  group = NULL,
  group_col = NULL,
  track_index = current_track_index()
)

phylo_to_dendrogram(obj, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_phylo_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="stats.html#topic+dendrogram">stats::dendrogram</a></code> object.</p>
</td></tr>
<tr><td><code id="spiral_phylo_+3A_gp">gp</code></td>
<td>
<p>Graphical parameters of the tree edges, mainly as a global setting.</p>
</td></tr>
<tr><td><code id="spiral_phylo_+3A_log">log</code></td>
<td>
<p>Whether the height of the tree to be log-transformed <code>log10(x + 1)</code>?</p>
</td></tr>
<tr><td><code id="spiral_phylo_+3A_reverse">reverse</code></td>
<td>
<p>Whether the tree to be reversed?</p>
</td></tr>
<tr><td><code id="spiral_phylo_+3A_group">group</code></td>
<td>
<p>A categorical variable for splitting the tree.</p>
</td></tr>
<tr><td><code id="spiral_phylo_+3A_group_col">group_col</code></td>
<td>
<p>A named vector which contains group colors.</p>
</td></tr>
<tr><td><code id="spiral_phylo_+3A_track_index">track_index</code></td>
<td>
<p>Index of the track.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+phylo_to_dendrogram">phylo_to_dendrogram()</a></code> converts a <code>phylo</code> object to a <code>dendrogram</code> object.
</p>
<p>The motivation is that phylogenetic tree may contain polytomies, which means at a certain node,
there are more than two children branches. Available tools that do the conversion only support binary trees.
</p>
<p>The returned <code>dendrogram</code> object is not in its standard format which means it can not be properly
drawn by the <code><a href="stats.html#topic+dendrogram">stats::plot.dendrogram()</a></code> function. However, you can still apply <code><a href="stats.html#topic+cutree">stats::cutree()</a></code> to the returned
<code>dendrogram</code> object with no problem and the dendrogram can be properly drawn with the <strong>ComplexHeatmap</strong> package (see examples).
</p>


<h3>Value</h3>

<p>Height of the phylogenetic tree.
</p>
<p>A <code><a href="stats.html#topic+dendrogram">stats::dendrogram</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(ape)) {
    data(bird.families)
    n = length(bird.families$tip.label)
    spiral_initialize(xlim = c(0, n), start = 360, end = 360*3)
    spiral_track(height = 0.8)
    spiral_phylo(bird.families)
}
if(require(ape)) {
    data(bird.families)
    d = phylo_to_dendrogram(bird.families)

    ComplexHeatmap::grid.dendrogram(d, test = TRUE)
}
</code></pre>

<hr>
<h2 id='spiral_pkg_downloads'>Visualize package downloads</h2><span id='topic+spiral_pkg_downloads'></span>

<h3>Description</h3>

<p>Visualize package downloads
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_pkg_downloads(
  pkg,
  from = "2012-10-01",
  to = "last-day",
  show_legend = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_pkg_downloads_+3A_pkg">pkg</code></td>
<td>
<p>A single CRAN package name.</p>
</td></tr>
<tr><td><code id="spiral_pkg_downloads_+3A_from">from</code></td>
<td>
<p>Starting date.</p>
</td></tr>
<tr><td><code id="spiral_pkg_downloads_+3A_to">to</code></td>
<td>
<p>Ending date.</p>
</td></tr>
<tr><td><code id="spiral_pkg_downloads_+3A_show_legend">show_legend</code></td>
<td>
<p>Whether to show the legend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <strong>cranlogs</strong> package is used to retrieve the download history from the Rstudio server.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
spiral_pkg_downloads("ggplot2")

</code></pre>

<hr>
<h2 id='spiral_points'>Add points to a track</h2><span id='topic+spiral_points'></span>

<h3>Description</h3>

<p>Add points to a track
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_points(
  x,
  y,
  pch = 1,
  size = unit(0.4, "char"),
  gp = gpar(),
  track_index = current_track_index()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_points_+3A_x">x</code></td>
<td>
<p>X-locations of the data points.</p>
</td></tr>
<tr><td><code id="spiral_points_+3A_y">y</code></td>
<td>
<p>Y-locations of the data points.</p>
</td></tr>
<tr><td><code id="spiral_points_+3A_pch">pch</code></td>
<td>
<p>Point type.</p>
</td></tr>
<tr><td><code id="spiral_points_+3A_size">size</code></td>
<td>
<p>Size of the points. Value should be a <code><a href="grid.html#topic+unit">grid::unit()</a></code> object.</p>
</td></tr>
<tr><td><code id="spiral_points_+3A_gp">gp</code></td>
<td>
<p>Graphical parameters.</p>
</td></tr>
<tr><td><code id="spiral_points_+3A_track_index">track_index</code></td>
<td>
<p>Index of the track.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spiral_initialize()
spiral_track()
spiral_points(x = runif(1000), y = runif(1000))
</code></pre>

<hr>
<h2 id='spiral_polygon'>Add polygons to a track</h2><span id='topic+spiral_polygon'></span>

<h3>Description</h3>

<p>Add polygons to a track
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_polygon(
  x,
  y,
  id = NULL,
  gp = gpar(),
  track_index = current_track_index()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_polygon_+3A_x">x</code></td>
<td>
<p>X-locations of the data points.</p>
</td></tr>
<tr><td><code id="spiral_polygon_+3A_y">y</code></td>
<td>
<p>Y-locations of the data points.</p>
</td></tr>
<tr><td><code id="spiral_polygon_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in x and y into multiple polygons.</p>
</td></tr>
<tr><td><code id="spiral_polygon_+3A_gp">gp</code></td>
<td>
<p>Graphical parameters.</p>
</td></tr>
<tr><td><code id="spiral_polygon_+3A_track_index">track_index</code></td>
<td>
<p>Index of the track.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = seq(0, 2*pi*10, length = 1000)
y = c(sin(x), cos(rev(x)))
x2 = c(x, rev(x))

# in the normal cartesian coordinate system
plot(NULL, xlim = range(x2), ylim = range(y))
polygon(x2, y, col = "red")

# in the spiral coordinate system
spiral_initialize(xlim = range(x2))
spiral_track(ylim = range(y))
spiral_polygon(x2, y, gp = gpar(fill = "red"))

# try a different scale
spiral_initialize(xlim = range(x2), scale_by = "curve_length")
spiral_track(ylim = range(y))
spiral_polygon(x2, y, gp = gpar(fill = "red"))
</code></pre>

<hr>
<h2 id='spiral_raster'>Add image to a track</h2><span id='topic+spiral_raster'></span>

<h3>Description</h3>

<p>Add image to a track
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_raster(
  x,
  y,
  image,
  width = NULL,
  height = NULL,
  facing = c("downward", "inside", "outside", "curved_inside", "curved_outside"),
  nice_facing = FALSE,
  scaling = 1,
  track_index = current_track_index()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_raster_+3A_x">x</code></td>
<td>
<p>X-locations of the center of the image.</p>
</td></tr>
<tr><td><code id="spiral_raster_+3A_y">y</code></td>
<td>
<p>Y-locations of the center of the image.</p>
</td></tr>
<tr><td><code id="spiral_raster_+3A_image">image</code></td>
<td>
<p>A vector of file paths of images. The format of the image is inferred from the suffix name of the image file.
NA value or empty string means no image to drawn. Supported formats are png/svg/pdf/eps/jpeg/jpg/tiff.</p>
</td></tr>
<tr><td><code id="spiral_raster_+3A_width">width</code></td>
<td>
<p>Width of the image. See Details.</p>
</td></tr>
<tr><td><code id="spiral_raster_+3A_height">height</code></td>
<td>
<p>Height of the image. See Details.</p>
</td></tr>
<tr><td><code id="spiral_raster_+3A_facing">facing</code></td>
<td>
<p>Facing of the image.</p>
</td></tr>
<tr><td><code id="spiral_raster_+3A_nice_facing">nice_facing</code></td>
<td>
<p>Whether to adjust the facing.</p>
</td></tr>
<tr><td><code id="spiral_raster_+3A_scaling">scaling</code></td>
<td>
<p>Scaling factor when <code>facing</code> is set to <code>"curved_inside"</code> or <code>"curved_outside"</code>.</p>
</td></tr>
<tr><td><code id="spiral_raster_+3A_track_index">track_index</code></td>
<td>
<p>Index of the track.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>facing</code> is set to one of <code>"downward"</code>, <code>"inside"</code> and <code>"outside"</code>, both of <code>width</code> and <code>height</code> should be <code><a href="grid.html#topic+unit">grid::unit()</a></code> objects.
It is suggested to only set one of <code>width</code> and <code>height</code>, the other dimension will be automatically calculated from the aspect ratio of the image.
</p>
<p>When <code>facing</code> is set to one of <code>"curved_inside"</code> and <code>"curved_outside"</code>, the value can also be numeric, which are the values
measured in the data coordinates. Note when the segment in the spiral that corresponds to <code>width</code> is very long, drawing the curved
image will be very slow because each pixel is actually treated as a single rectangle.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image = system.file("extdata", "Rlogo.png", package = "circlize")
x = seq(0.1, 0.9, length = 10)

spiral_initialize()
spiral_track()
spiral_raster(x, 0.5, image)

spiral_initialize()
spiral_track()
spiral_raster(x, 0.5, image, facing = "inside")

</code></pre>

<hr>
<h2 id='spiral_rect'>Add rectangles to a track</h2><span id='topic+spiral_rect'></span>

<h3>Description</h3>

<p>Add rectangles to a track
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_rect(
  xleft,
  ybottom,
  xright,
  ytop,
  gp = gpar(),
  track_index = current_track_index()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_rect_+3A_xleft">xleft</code></td>
<td>
<p>X-locations of the left bottom of the rectangles.</p>
</td></tr>
<tr><td><code id="spiral_rect_+3A_ybottom">ybottom</code></td>
<td>
<p>Y-locations of the left bottom of the rectangles.</p>
</td></tr>
<tr><td><code id="spiral_rect_+3A_xright">xright</code></td>
<td>
<p>X-locations of the right top of the rectangles.</p>
</td></tr>
<tr><td><code id="spiral_rect_+3A_ytop">ytop</code></td>
<td>
<p>Y-locations of the right top of the rectangles.</p>
</td></tr>
<tr><td><code id="spiral_rect_+3A_gp">gp</code></td>
<td>
<p>Graphical parameters.</p>
</td></tr>
<tr><td><code id="spiral_rect_+3A_track_index">track_index</code></td>
<td>
<p>Index of the track.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to simulate heatmap
n = 1000
require(circlize)
col = circlize::colorRamp2(c(0, 0.5, 1), c("blue", "white", "red"))
spiral_initialize(xlim = c(0, n))
spiral_track(height = 0.9)

x1 = runif(n)
spiral_rect(1:n - 1, 0, 1:n, 0.5, gp = gpar(fill = col(x1), col = NA))
x2 = runif(n)
spiral_rect(1:n - 1, 0.5, 1:n, 1, gp = gpar(fill = col(x2), col = NA))
</code></pre>

<hr>
<h2 id='spiral_segments'>Add segments to a track</h2><span id='topic+spiral_segments'></span>

<h3>Description</h3>

<p>Add segments to a track
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_segments(
  x0,
  y0,
  x1,
  y1,
  gp = gpar(),
  arrow = NULL,
  track_index = current_track_index()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_segments_+3A_x0">x0</code></td>
<td>
<p>X-locations of the start points of the segments.</p>
</td></tr>
<tr><td><code id="spiral_segments_+3A_y0">y0</code></td>
<td>
<p>Y-locations of the start points of the segments.</p>
</td></tr>
<tr><td><code id="spiral_segments_+3A_x1">x1</code></td>
<td>
<p>X-locations of the end points of the segments.</p>
</td></tr>
<tr><td><code id="spiral_segments_+3A_y1">y1</code></td>
<td>
<p>Y-locations of the end points of the segments.</p>
</td></tr>
<tr><td><code id="spiral_segments_+3A_gp">gp</code></td>
<td>
<p>Graphical parameters.</p>
</td></tr>
<tr><td><code id="spiral_segments_+3A_arrow">arrow</code></td>
<td>
<p>A <code><a href="grid.html#topic+arrow">grid::arrow()</a></code> object.</p>
</td></tr>
<tr><td><code id="spiral_segments_+3A_track_index">track_index</code></td>
<td>
<p>Index of the track.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 1000
x0 = runif(n)
y0 = runif(n)
x1 = x0 + runif(n, min = -0.01, max = 0.01)
y1 = 1 - y0

spiral_initialize(xlim = range(c(x0, x1)))
spiral_track()
spiral_segments(x0, y0, x1, y1, gp = gpar(col = circlize::rand_color(n)))

n = 100
x0 = runif(n)
y0 = runif(n)
x1 = x0 + runif(n, min = -0.01, max = 0.01)
y1 = 1 - y0

spiral_initialize(xlim = range(c(x0, x1)))
spiral_track()
col = circlize::rand_color(n, luminosity = "bright")
spiral_segments(x0, y0, x1, y1, 
    arrow = arrow(length = unit(2, "mm")), gp = gpar(col = col))

# if the segments are short and you want the straight "real" segments
spiral_initialize(xlim = range(c(x0, x1)))
spiral_track()
df0 = xy_to_cartesian(x0, y0)
df1 = xy_to_cartesian(x1, y1)
grid.segments(df0$x, df0$y, df1$x, df1$y, default.units = "native", 
    arrow = arrow(length = unit(2, "mm")), gp = gpar(col = col))
</code></pre>

<hr>
<h2 id='spiral_text'>Add texts to a track</h2><span id='topic+spiral_text'></span>

<h3>Description</h3>

<p>Add texts to a track
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_text(
  x,
  y,
  text,
  offset = NULL,
  gp = gpar(),
  facing = c("downward", "inside", "outside", "clockwise", "reverse_clockwise",
    "curved_inside", "curved_outside"),
  letter_spacing = 0,
  nice_facing = FALSE,
  just = "centre",
  hjust = NULL,
  vjust = NULL,
  track_index = current_track_index(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_text_+3A_x">x</code></td>
<td>
<p>X-locations of the texts.</p>
</td></tr>
<tr><td><code id="spiral_text_+3A_y">y</code></td>
<td>
<p>Y-locations of the texts.</p>
</td></tr>
<tr><td><code id="spiral_text_+3A_text">text</code></td>
<td>
<p>A vector of texts.</p>
</td></tr>
<tr><td><code id="spiral_text_+3A_offset">offset</code></td>
<td>
<p>Radial offset of the text. The value should be a <code><a href="grid.html#topic+unit">grid::unit()</a></code> object.</p>
</td></tr>
<tr><td><code id="spiral_text_+3A_gp">gp</code></td>
<td>
<p>Graphical parameters.</p>
</td></tr>
<tr><td><code id="spiral_text_+3A_facing">facing</code></td>
<td>
<p>Facing of the text.</p>
</td></tr>
<tr><td><code id="spiral_text_+3A_letter_spacing">letter_spacing</code></td>
<td>
<p>Space between two letters. The value is a fraction of the width of current letter. It only works for curved texts.</p>
</td></tr>
<tr><td><code id="spiral_text_+3A_nice_facing">nice_facing</code></td>
<td>
<p>If it is true, the facing will be automatically adjusted for texts which locate at different positions of the spiral. Note <code>hjust</code> and <code>vjust</code> will also be adjusted.</p>
</td></tr>
<tr><td><code id="spiral_text_+3A_just">just</code></td>
<td>
<p>The justification of the text relative to (x, y). The same setting as in <code><a href="grid.html#topic+grid.text">grid::grid.text()</a></code>.</p>
</td></tr>
<tr><td><code id="spiral_text_+3A_hjust">hjust</code></td>
<td>
<p>Horizontal justification. Value should be numeric. 0 means the left of the text and 1 means the right of the text.</p>
</td></tr>
<tr><td><code id="spiral_text_+3A_vjust">vjust</code></td>
<td>
<p>Vertical justification. Value should be numeric. 0 means the bottom of the text and 1 means the top of the text.</p>
</td></tr>
<tr><td><code id="spiral_text_+3A_track_index">track_index</code></td>
<td>
<p>Index of the track.</p>
</td></tr>
<tr><td><code id="spiral_text_+3A_...">...</code></td>
<td>
<p>Pass to <code><a href="grid.html#topic+grid.text">grid::grid.text()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the curved text, it only supports one-line text.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = seq(0.1, 0.9, length = 26)
text = strrep(letters, 6)
spiral_initialize(); spiral_track()
spiral_text(x, 0.5, text)

spiral_initialize(); spiral_track()
spiral_text(x, 0.5, text, facing = "inside")

spiral_initialize(); spiral_track()
spiral_text(x, 0.5, text, facing = "outside")

x = seq(0.1, 0.9, length = 10)
text = strrep(letters[1:10], 20)
spiral_initialize(); spiral_track()
spiral_text(x, 0.5, text, facing = "curved_inside")

spiral_initialize(); spiral_track()
spiral_text(x, 0.5, text, facing = "curved_outside")
</code></pre>

<hr>
<h2 id='spiral_track'>Add a new track or move to an existed track</h2><span id='topic+spiral_track'></span>

<h3>Description</h3>

<p>Add a new track or move to an existed track
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_track(
  ylim = c(0, 1),
  height = 0.8,
  background = TRUE,
  background_gp = gpar(fill = "#EEEEEE"),
  reverse_y = FALSE,
  gradient = FALSE,
  track_index = current_track_index() + 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_track_+3A_ylim">ylim</code></td>
<td>
<p>Data range of the y-locations.</p>
</td></tr>
<tr><td><code id="spiral_track_+3A_height">height</code></td>
<td>
<p>Height of the track. The value can be the fraction of the distance of the two neighbour spiral loops. The value can also be a <code><a href="grid.html#topic+unit">grid::unit()</a></code> object.</p>
</td></tr>
<tr><td><code id="spiral_track_+3A_background">background</code></td>
<td>
<p>Whether to draw the background of the track, i.e. border and filled color of background.</p>
</td></tr>
<tr><td><code id="spiral_track_+3A_background_gp">background_gp</code></td>
<td>
<p>Graphical parameters of the background.</p>
</td></tr>
<tr><td><code id="spiral_track_+3A_reverse_y">reverse_y</code></td>
<td>
<p>Whether reverse the direction of y-axis (i.e. pointing to the center of the spiral)?</p>
</td></tr>
<tr><td><code id="spiral_track_+3A_gradient">gradient</code></td>
<td>
<p>Whether draw the background in gradient? The value can be a positive integer of the number of gradients from <code>background_gp$fill</code> to white.</p>
</td></tr>
<tr><td><code id="spiral_track_+3A_track_index">track_index</code></td>
<td>
<p>Index of the track.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the track is already existed, the function simply mark the track as the current track and does nothing else.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spiral_initialize()
spiral_track(height = 0.8)

spiral_initialize()
spiral_track(height = 0.4, background_gp = gpar(fill = "red"))
spiral_track(height = 0.2, background_gp = gpar(fill = "green"))
spiral_track(height = 0.1, background_gp = gpar(fill = "blue"))

spiral_initialize()
spiral_track(height = 0.8, gradient = TRUE) # by default 10 gradients

spiral_initialize()
spiral_track(height = 0.8, background_gp = gpar(fill = "red"), gradient = 5)
</code></pre>

<hr>
<h2 id='spiral_yaxis'>Draw y-axis</h2><span id='topic+spiral_yaxis'></span>

<h3>Description</h3>

<p>Draw y-axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spiral_yaxis(
  side = c("both", "start", "end"),
  at = NULL,
  labels = TRUE,
  ticks_length = unit(2, "bigpts"),
  ticks_gp = gpar(),
  labels_gp = gpar(fontsize = 6),
  track_index = current_track_index()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spiral_yaxis_+3A_side">side</code></td>
<td>
<p>On which side of the spiral the y-axis is drawn? &quot;start&quot; means the inside of the spiral and &quot;end&quot; means the outside of the spiral.
Note if <code>reverse</code> was set to <code>TRUE</code> in <code><a href="#topic+spiral_initialize">spiral_initialize()</a></code>, then &quot;start&quot; corresponds to the outside of the spiral.</p>
</td></tr>
<tr><td><code id="spiral_yaxis_+3A_at">at</code></td>
<td>
<p>Break points.</p>
</td></tr>
<tr><td><code id="spiral_yaxis_+3A_labels">labels</code></td>
<td>
<p>Corresponding labels for the break points.</p>
</td></tr>
<tr><td><code id="spiral_yaxis_+3A_ticks_length">ticks_length</code></td>
<td>
<p>Length of the tick. Value should be a <code><a href="grid.html#topic+unit">grid::unit()</a></code> object.</p>
</td></tr>
<tr><td><code id="spiral_yaxis_+3A_ticks_gp">ticks_gp</code></td>
<td>
<p>Graphical parameters for ticks.</p>
</td></tr>
<tr><td><code id="spiral_yaxis_+3A_labels_gp">labels_gp</code></td>
<td>
<p>Graphical parameters for labels.</p>
</td></tr>
<tr><td><code id="spiral_yaxis_+3A_track_index">track_index</code></td>
<td>
<p>Index of the track.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spiral_initialize(); spiral_track(height = 0.8)
spiral_yaxis("start")
spiral_yaxis("end", at = c(0, 0.25, 0.5, 0.75, 1), labels = letters[1:5])
</code></pre>

<hr>
<h2 id='TRACK_META'>Get meta data in the current track</h2><span id='topic+TRACK_META'></span><span id='topic+names.TRACK_META'></span><span id='topic++24.TRACK_META'></span><span id='topic++5B+5B.TRACK_META'></span><span id='topic++5B.TRACK_META'></span><span id='topic+print.TRACK_META'></span>

<h3>Description</h3>

<p>Get meta data in the current track
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TRACK_META

## S3 method for class 'TRACK_META'
names(x)

## S3 method for class 'TRACK_META'
x$name

## S3 method for class 'TRACK_META'
x[[i, exact = TRUE]]

## S3 method for class 'TRACK_META'
x[i]

## S3 method for class 'TRACK_META'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TRACK_META_+3A_x">x</code></td>
<td>
<p>The <code>TRACK_META</code> object.</p>
</td></tr>
<tr><td><code id="TRACK_META_+3A_name">name</code></td>
<td>
<p>Name of the meta name. For all supported names, type <code>names(TRACK_META)</code>.</p>
</td></tr>
<tr><td><code id="TRACK_META_+3A_i">i</code></td>
<td>
<p>Name of the meta name. For all supported names, type <code>names(TRACK_META)</code>.</p>
</td></tr>
<tr><td><code id="TRACK_META_+3A_exact">exact</code></td>
<td>
<p>Please ignore.</p>
</td></tr>
<tr><td><code id="TRACK_META_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>TRACK_META</code> of length 1.
</p>


<h3>Details</h3>

<p>The variable <code>TRACK_META</code> can only be used to get meta data from the &quot;current&quot; track. If the current track
is not the one you want, you can first use <code><a href="#topic+set_current_track">set_current_track()</a></code> to change the current track.
</p>
<p>Don't directly use <code>TRACK_META</code>. The value of <code>TRACK_META</code> itself is meaningless. Always use in form of <code>TRACK_META$name</code>.
</p>
<p>There are the following meta data for the current track:
</p>

<ul>
<li> <p><code>xlim</code>: Data range on x-axis.
</p>
</li>
<li> <p><code>xmin</code>: <code>xlim[1]</code>.
</p>
</li>
<li> <p><code>xmax</code>: <code>xlim[2]</code>.
</p>
</li>
<li> <p><code>xrange</code>: <code>xlim[2] - xlim[1]</code>.
</p>
</li>
<li> <p><code>xcenter</code>: <code>mean(xlim)</code>.
</p>
</li>
<li> <p><code>theta_lim</code>: Range of the angles on the spiral, measured in radians.
</p>
</li>
<li> <p><code>theta_min</code>: <code>theta_lim[1]</code>.
</p>
</li>
<li> <p><code>theta_max</code>: <code>theta_lim[2]</code>.
</p>
</li>
<li> <p><code>theta_range</code>: <code>theta_lim[2] - theta_lim[1]</code>.
</p>
</li>
<li> <p><code>theta_center</code>: <code>mean(theta_lim)</code>.
</p>
</li>
<li> <p><code>ylim</code>: Data range on y-axis.
</p>
</li>
<li> <p><code>ymin</code>: <code>ylim[1]</code>.
</p>
</li>
<li> <p><code>ymax</code>: <code>ylim[2]</code>.
</p>
</li>
<li> <p><code>yrange</code>: <code>ylim[2] - ylim[1]</code>.
</p>
</li>
<li> <p><code>ycenter</code>: <code>mean(ylim)</code>.
</p>
</li>
<li> <p><code>rel_height</code>: Fraction of height of the track to the distance between two neighbouring loops.
</p>
</li>
<li> <p><code>abs_height</code>: The height of the track, which is <code>rel_height</code> multiplied by the distance between two neighbouring loops.
</p>
</li>
<li> <p><code>track_index</code>: Current track index.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>spiral_initialize(xlim = c(0, 1))
spiral_track(ylim = c(0, 1))
for(nm in names(TRACK_META)) {
    cat(nm, ":\n", sep = "")
    print(TRACK_META[[nm]])
    cat("\n")
}
names(TRACK_META)
</code></pre>

<hr>
<h2 id='xy_to_cartesian'>Transform between coordinate systems</h2><span id='topic+xy_to_cartesian'></span><span id='topic+xy_to_polar'></span><span id='topic+polar_to_cartesian'></span><span id='topic+cartesian_to_polar'></span><span id='topic+cartesian_to_xy'></span>

<h3>Description</h3>

<p>Transform between coordinate systems
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xy_to_cartesian(x, y, track_index = current_track_index())

xy_to_polar(x, y, track_index = current_track_index(), flip = TRUE)

polar_to_cartesian(theta, r)

cartesian_to_polar(x, y)

cartesian_to_xy(x, y, track_index = current_track_index())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xy_to_cartesian_+3A_x">x</code></td>
<td>
<p>X-locations of the data points.</p>
</td></tr>
<tr><td><code id="xy_to_cartesian_+3A_y">y</code></td>
<td>
<p>Y-locations of the data points.</p>
</td></tr>
<tr><td><code id="xy_to_cartesian_+3A_track_index">track_index</code></td>
<td>
<p>Index of the track.</p>
</td></tr>
<tr><td><code id="xy_to_cartesian_+3A_flip">flip</code></td>
<td>
<p>If it is <code>FALSE</code>, it returns theta for the original spiral (before flipping).</p>
</td></tr>
<tr><td><code id="xy_to_cartesian_+3A_theta">theta</code></td>
<td>
<p>Angles, in radians.</p>
</td></tr>
<tr><td><code id="xy_to_cartesian_+3A_r">r</code></td>
<td>
<p>Radius.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three coordinate systems: the data coordinate system (xy), the polar coordinate system (polar)
and the canvas coordinate system (cartesian). The canvas coordinates correspond to the &quot;native&quot; coordinates of the viewport where the graphics are drawn.
</p>
<p>Note different settings of <code>flip</code> and <code>reverse</code> in <code><a href="#topic+spiral_initialize">spiral_initialize()</a></code> affect the conversion.
</p>
<p><code>xy_to_cartesian()</code> converts from the data coordinate system to the canvas coordinate system.
</p>
<p><code>xy_to_polar()</code> converts from the data coordinate system to the polar coordinate system.
</p>
<p><code>polar_to_cartesian()</code> converts from the polar coordinate system to the canvas coordinate system.
</p>
<p><code>cartesian_to_polar()</code> converts from the canvas coordinate system to the polar coordinate system.
</p>
<p><code>cartesian_to_xy()</code> converts from the canvas coordinate system to the data coordinate system.
The data points are assigned to the nearest inner spiral loops (if the point is located inside a certain spiral loop, the distance is zero).
</p>


<h3>Value</h3>

<p><code>xy_to_cartesian()</code> returns A data frame with two columns: <code>x</code> and <code>y</code>.
</p>
<p><code>xy_to_polar()</code> returns a data frame with two columns: <code>theta</code> (in radians) and <code>r</code> (the radius).
</p>
<p><code>polar_to_cartesian()</code> returns a data frame with two columns: <code>x</code> and <code>y</code>.
</p>
<p><code>cartesian_to_polar()</code> returns a data frame with two columns: <code>theta</code> (in radians) and <code>r</code> (the radius).
</p>
<p><code>cartesian_to_xy()</code> returns a data frame with two columns: <code>x</code> and <code>y</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = runif(2)
y = runif(2)
spiral_initialize(xlim = c(0, 1))
spiral_track(ylim = c(0, 1))
spiral_points(x, y)
xy_to_cartesian(x, y)
xy_to_polar(x, y)

x = runif(100, -4, 4)
y = runif(100, -4, 4)
spiral_initialize(xlim = c(0, 1))
spiral_track(ylim = c(0, 1))
df = cartesian_to_xy(x, y)
# directly draw in the viewport
grid.points(x, y, default.units = "native")
# check whether the converted xy are correct (should overlap to the previous points)
spiral_points(df$x, df$y, pch = 16, gp = gpar(col = 2))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
