<!DOCTYPE html><html><head><title>Help for package TailRank</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TailRank}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BetaBinomial'><p>The Beta-Binomial Distribution</p></a></li>
<li><a href='#biomarkerPowerTable'><p>Power tables for the tail-rank test</p></a></li>
<li><a href='#BMPT-class'><p>The BMPT Class</p></a></li>
<li><a href='#tailRankPower'><p>Power of the tail-rank test</p></a></li>
<li><a href='#TailRankTest'><p>The Tail-Rank Test</p></a></li>
<li><a href='#TailRankTest-class'><p>The TailRankTest Class</p></a></li>
<li><a href='#TailRankTest-methods'><p>Methods for TailRankTest objects</p></a></li>
<li><a href='#toleranceBound'><p>Upper tolerance bounds on normal quantiles</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>The Tail-Rank Statistic</td>
</tr>
<tr>
<td>Version:</td>
<td>3.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-02</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin R. Coombes</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the tail-rank statistic for selecting biomarkers
  from a microarray data set, an efficient nonparametric test focused
  on the distributional tails. See
  <a href="https://gitlab.com/krcoombes/coombeslab/-/blob/master/doc/papers/tolstoy-new.pdf">https://gitlab.com/krcoombes/coombeslab/-/blob/master/doc/papers/tolstoy-new.pdf</a>.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin R. Coombes &lt;krc@silicovore.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0), oompaBase (&ge; 3.0.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, graphics, stats, Biobase, oompaData</td>
</tr>
<tr>
<td>Suggests:</td>
<td>xtable</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://oompa.r-forge.r-project.org/">http://oompa.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-03 00:54:41 UTC; KRC</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-03 07:20:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='BetaBinomial'>The Beta-Binomial Distribution</h2><span id='topic+dbb'></span><span id='topic+pbb'></span><span id='topic+qbb'></span><span id='topic+rbb'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and random generation
for the beta-binomial distribution.  A variable with a beta-binomial
distribution is distributed as binomial distribution with parameters
<code>N</code> and <code>p</code>, where the probability <code>p</code> of success iteself
has a beta distribution with parameters <code>u</code> and <code>v</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbb(x, N, u, v, log = FALSE)
pbb(q, N, u, v)
qbb(p, N, u, v)
rbb(n, N, u, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BetaBinomial_+3A_x">x</code></td>
<td>
<p>vector of qauntiles</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_n">N</code></td>
<td>
<p>number of trials ( a positive integer)</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_u">u</code></td>
<td>
<p>first positive parameter of the beta distribution</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_v">v</code></td>
<td>
<p>second positive parameter of the beta distribution</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_log">log</code></td>
<td>
<p>A logical value; if true, values are returned on the log scale</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The beta-binomial distribution with parameters <code class="reqn">N</code>, <code class="reqn">u</code>, and
<code class="reqn">v</code> has density given by
</p>
<p style="text-align: center;"><code class="reqn">
    choose(N, x) * Beta(x + u, N - x + v) / Beta(u,v)
  </code>
</p>

<p>for <code class="reqn">u &gt; 0</code>, <code class="reqn">v &gt; 0</code>, a positive integer <code class="reqn">N</code>, and any
nonnegative integer <code class="reqn">x</code>. Although one can express the integral
in closed form using generalized hypergeometric functions, the
implementation of  distribution function used here simply relies on the
the cumulative sum of the density.
</p>
<p>The mean and variance of the beta-binomial distribution can be
computed explicitly as
</p>
<p style="text-align: center;"><code class="reqn">
    \mu = \frac{Nu}{u+v}
  </code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">
    \sigma^2 = \frac{Nuv(N+u+v)}{(u+v)^2 (1+u+v)}
  </code>
</p>



<h3>Value</h3>

<p><code>dbb</code> gives the density, <code>pbb</code> gives the distribution function,
<code>qbb</code> gives the quantile function, and <code>rbb</code> generates random
deviates. 
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+dbeta">dbeta</a></code> for the beta distribution and
<code><a href="stats.html#topic+dbinom">dbinom</a></code> for the binomial distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up parameters
w &lt;- 10
u &lt;- 0.3*w
v &lt;- 0.7*w
N &lt;- 12
# generate random values from the beta-binomial
x &lt;- rbb(1000, N, u, v)

# check that the empirical summary matches the theoretical one
summary(x)
qbb(c(0.25, 0.50, 0.75), N, u, v)

# check that the empirpical histogram matches te theoretical density
hist(x, breaks=seq(-0.5, N + 0.55), prob=TRUE)
lines(0:N, dbb(0:N, N, u,v), type='b')
</code></pre>

<hr>
<h2 id='biomarkerPowerTable'>Power tables for the tail-rank test</h2><span id='topic+biomarkerPowerTable'></span>

<h3>Description</h3>

<p>Compute an array of power tables for the tail-rank.test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biomarkerPowerTable(G, N1=20, N2=seq(25, 250, by=25),
                    psi = c(0.95, 0.99), conf=0.99,
                    phi = seq(0.10, 0.50, by = 0.05), model="bb")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biomarkerPowerTable_+3A_g">G</code></td>
<td>
<p>An integer; the number of genes being assessed as potential
biomarkers. Statistically, the number of hypotheses being tested.</p>
</td></tr>
<tr><td><code id="biomarkerPowerTable_+3A_n1">N1</code></td>
<td>
<p>An integer; the number of &quot;train&quot; or &quot;healthy&quot; samples used.</p>
</td></tr>
<tr><td><code id="biomarkerPowerTable_+3A_n2">N2</code></td>
<td>
<p>An integer; the number of &quot;test&quot; or &quot;cancer&quot; samples used.</p>
</td></tr>
<tr><td><code id="biomarkerPowerTable_+3A_psi">psi</code></td>
<td>
<p>A real number between 0 and 1; the desired specificity of
the test.</p>
</td></tr>
<tr><td><code id="biomarkerPowerTable_+3A_conf">conf</code></td>
<td>
<p>A real number between 0 and 1; the confidence level of the
results. Can be obtained by subtracting the family-wise Type I error
from 1.</p>
</td></tr>
<tr><td><code id="biomarkerPowerTable_+3A_phi">phi</code></td>
<td>
<p>A real number between 0 and 1; the sensitivity that one
would like to be able to detect, conditional on the specificity.</p>
</td></tr>
<tr><td><code id="biomarkerPowerTable_+3A_model">model</code></td>
<td>
<p>A character string that determines whether power and
significance are computed from abinomial or a beta-binomial (bb)
model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of objects of the <code><a href="#topic+BMPT">BMPT</a></code> class. Each item
in the list consists of a two-dimensional table (indexed by the sample
sizes <code>N</code> and the sensitivities <code>phi</code>) with scalars
recording the values of <code>G</code>, <code>conf</code>, and <code>psi</code> that
were used to generate it.
</p>


<h3>Note</h3>

<p>Default values of the optional arguments (<code>N</code>, <code>psi</code>,
<code>conf</code>, <code>phi</code>)are included in the usage examples.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+TailRankTest">TailRankTest</a></code>,
<code><a href="#topic+tailRankPower">tailRankPower</a></code>,
<code><a href="#topic+biomarkerPowerTable">biomarkerPowerTable</a></code>,
<code><a href="oompaBase.html#topic+matrixMean">matrixMean</a></code>,
<code><a href="#topic+toleranceBound">toleranceBound</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stuff &lt;- biomarkerPowerTable(10000, 20,
                               c(10, 20, 50, 100, 250, 500),
                               c(0.95, 0.99),
                               c(0.99, 0.95),
                               seq(0.1, 0.7, by=0.1))
lapply(stuff, summary)
</code></pre>

<hr>
<h2 id='BMPT-class'>The BMPT Class</h2><span id='topic+BMPT-class'></span><span id='topic+summary+2CBMPT-method'></span><span id='topic+print+2CBMPT-method'></span><span id='topic+BMPT'></span>

<h3>Description</h3>

<p>A class for producing BioMarker Power Tables (BMPT), and methods for
accessing them. This class is primarily an implementation detail for
the function <code><a href="#topic+biomarkerPowerTable">biomarkerPowerTable</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BMPT(G, psi, conf, power)
## S4 method for signature 'BMPT'
print(x,...)
## S4 method for signature 'BMPT'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BMPT-class_+3A_g">G</code></td>
<td>
<p>A positive integer.</p>
</td></tr>
<tr><td><code id="BMPT-class_+3A_psi">psi</code></td>
<td>
<p>A real number between 0 and 1.</p>
</td></tr>
<tr><td><code id="BMPT-class_+3A_conf">conf</code></td>
<td>
<p>A real number between 0 and 1.</p>
</td></tr>
<tr><td><code id="BMPT-class_+3A_power">power</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="BMPT-class_+3A_x">x</code></td>
<td>
<p>A <code>BMPT</code> object.</p>
</td></tr>
<tr><td><code id="BMPT-class_+3A_object">object</code></td>
<td>
<p>A <code>BMPT</code> object.</p>
</td></tr>
<tr><td><code id="BMPT-class_+3A_...">...</code></td>
<td>
<p>Extra graphical parameters</p>
</td></tr>
</table>


<h3>Creating objects</h3>

<p>Although objects can be created using <code>new</code>, the preferred method
is to use the constructor function <code>BMPT</code>. In practice, these
objects are most likely to be created using the more general interface
through <code><a href="#topic+biomarkerPowerTable">biomarkerPowerTable</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>G</code>:</dt><dd><p>A positive integer; the number of genes being
assessed as potential biomarkers. Statistically, the number of
hypotheses being tested.</p>
</dd>
<dt><code>psi</code>:</dt><dd><p>A real number between 0 and 1; the desired
specificity of the test.</p>
</dd>
<dt><code>conf</code>:</dt><dd><p>A real number between 0 and 1; the confidence
level of the results. Can be obtained by subtracting the family-wise
Type I error from 1.</p>
</dd>
<dt><code>power</code>:</dt><dd><p>A data frame containing the power
computations. The rows are indexed by the sample size and the
columns by the sensitivity.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>print(x, ...)</dt><dd><p>Print the power table <code>x</code>.</p>
</dd>
<dt>summary(object, ...)</dt><dd><p>Summarize the power table <code>object</code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>See <code><a href="#topic+biomarkerPowerTable">biomarkerPowerTable</a></code> for examples.</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+TailRankTest">TailRankTest</a></code>,
<code><a href="#topic+tailRankPower">tailRankPower</a></code>,
<code><a href="#topic+biomarkerPowerTable">biomarkerPowerTable</a></code>
</p>

<hr>
<h2 id='tailRankPower'>Power of the tail-rank test</h2><span id='topic+tailRankPower'></span><span id='topic+tailRankCutoff'></span>

<h3>Description</h3>

<p>Compute the significance level and the power of a tail-rank test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tailRankPower(G, N1, N2, psi, phi, conf = 0.95,
              model=c("bb", "betabinom", "binomial"))
tailRankCutoff(G, N1, N2, psi, conf,
               model=c("bb", "betabinom", "binomial"),
               method=c('approx', 'exact'))
                           
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tailRankPower_+3A_g">G</code></td>
<td>
<p>An integer; the number of genes being assessed as potnetial
biomarkers. Statistically, the number of hypotheses being tested.</p>
</td></tr>
<tr><td><code id="tailRankPower_+3A_n1">N1</code></td>
<td>
<p>An integer; the number of &quot;train&quot; or &quot;healthy&quot; samples used.</p>
</td></tr>
<tr><td><code id="tailRankPower_+3A_n2">N2</code></td>
<td>
<p>An integer; the number of &quot;test&quot; or &quot;cancer&quot; samples used.</p>
</td></tr>
<tr><td><code id="tailRankPower_+3A_psi">psi</code></td>
<td>
<p>A real number between 0 and 1; the desired specificity of
the test.</p>
</td></tr>
<tr><td><code id="tailRankPower_+3A_phi">phi</code></td>
<td>
<p>A real number between 0 and 1; the sensitivity that one
would like to be able to detect, conditional on the specificity.</p>
</td></tr>
<tr><td><code id="tailRankPower_+3A_conf">conf</code></td>
<td>
<p>A real number between 0 and 1; the confidence level of the
results. Can be obtained by subtracting the family-wise Type I error
from 1.</p>
</td></tr>
<tr><td><code id="tailRankPower_+3A_model">model</code></td>
<td>
<p>A character string that determines whether significance
and power are computed based on a binomial or a beta-binomial (bb)
model.</p>
</td></tr>
<tr><td><code id="tailRankPower_+3A_method">method</code></td>
<td>
<p>A character string; either &quot;exact&quot; or &quot;approx&quot;. The
deafult is to use a Bonferroni approximation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A power estimate for the tail-rank test can be obtained as follows.
First, let X ~ Binom(N,p) denote a binomial random variable. Under the
null hypotheis that cancer is not different from normal, we let
<code class="reqn">p = 1 - \psi</code> be the expected  proportion of successes in a test of
whether the value exceeds the psi-th quantile.  Now let
</p>
<p style="text-align: center;"><code class="reqn">\alpha = P(X &gt; x,| N, p)</code>
</p>

<p>be one such binomial measurement.  When we make <code class="reqn">G</code> independent
binomial measurements, we take
</p>
<p style="text-align: center;"><code class="reqn">conf = P(all\ G\ of\ the\ X's \le x | N, p).</code>
</p>

<p>(In our paper on the tail-rank statistic, we write everything in terms
of <code class="reqn">\gamma = 1 - conf</code>.) Then we have
</p>
<p style="text-align: center;"><code class="reqn">conf = P(X \le x | N, p)^G = (1 - alpha)^G.</code>
</p>

<p>Using a Bonferroni-like approximation, we can take
</p>
<p style="text-align: center;"><code class="reqn">conf ~= 1 - \alpha*G.</code>
</p>

<p>Solving for <code class="reqn">\alpha</code>, we find that
</p>
<p style="text-align: center;"><code class="reqn">\alpha ~= (1-conf)/G.</code>
</p>

<p>So, the cutoff that ensures that in multiple experiments, each looking
at <code class="reqn">G</code> genes in <code class="reqn">N</code> samples, we have confidence level <code class="reqn">conf</code>
(or significance level <code class="reqn">\gamma = 1 - conf</code>) of no false positives is
computed by the function <code>tailRankCutoff</code>.
</p>
<p>The final point to note is that the quantiles are also defined
in terms of <code class="reqn">q = 1 - \alpha</code>, so there are lots of disfiguring &quot;1's&quot;
in the implementation.
</p>
<p>Now we set <code class="reqn">M</code> to be the significance cutoff using the procedure
detailed above.  A gene with sensitivity <code class="reqn">\phi</code> gets detected if the
observed number of cases above the threshold is greater than or equal to
<code class="reqn">M</code>. The <code>tailRankPower</code> function implements formula (1.3) of
our paper on the tail-rank test.
</p>


<h3>Value</h3>

<p><code>tailRankCutoff</code> returns an integer that is the
maximum expected value of the tail rank statistic under the null
hypothesis.
</p>
<p><code>tailRankPower</code> returns a real numbe between 0 and 1
that is the power of the tail-rank test to detect a marker with
true sensitivity equal to <code class="reqn">phi</code>.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+TailRankTest">TailRankTest</a></code>,
<code><a href="#topic+tailRankPower">tailRankPower</a></code>,
<code><a href="#topic+biomarkerPowerTable">biomarkerPowerTable</a></code>,
<code><a href="oompaBase.html#topic+matrixMean">matrixMean</a></code>,
<code><a href="#topic+toleranceBound">toleranceBound</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>psi.0 &lt;- 0.99
confide &lt;- rev(c(0.8, 0.95, 0.99))
nh &lt;- 20
ng &lt;- c(100, 1000, 10000, 100000)
ns &lt;- c(10, 20, 50, 100, 250, 500)
formal.cut &lt;- array(0, c(length(ns), length(ng), length(confide)))
for (i in 1:length(ng)) {
  for (j in 1:length(ns)) {
    formal.cut[j, i, ] &lt;- tailRankCutoff(ng[i], nh, ns[j], psi.0, confide)
  }
}
dimnames(formal.cut) &lt;- list(ns, ng, confide)
formal.cut

phi &lt;- seq(0.1, 0.7, by=0.1)
N &lt;- c(10, 20, 50, 100, 250, 500)
pows &lt;- matrix(0, ncol=length(phi), nrow=length(N))
for (ph in 1:length(phi)) {
  pows[, ph] &lt;-  tailRankPower(10000, nh, N, 0.95, phi[ph], 0.9)
}
pows &lt;- data.frame(pows)
dimnames(pows) &lt;- list(as.character(N), as.character(round(100*phi)))
pows
</code></pre>

<hr>
<h2 id='TailRankTest'>The Tail-Rank Test</h2><span id='topic+TailRankTest'></span>

<h3>Description</h3>

<p>Perform a tail-rank test to find candidate biomarkers in a microarray
data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TailRankTest(data, classes, specificity = 0.95, tolerance = 0.50,
             model=c("bb", "betabinomial", "binomial"),
             confidence = 0.95, direction = "up")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TailRankTest_+3A_data">data</code></td>
<td>
<p>A matrix or data.frame containing numerical measurements on
which to perform the tail-rank test.</p>
</td></tr>
<tr><td><code id="TailRankTest_+3A_classes">classes</code></td>
<td>
<p>A logical vector or factor splitting the data into two
parts. The length of this vector should equal the number of columns
in the <code>data</code>. The <code>TRUE</code> portion (or the first level of
the factor) represents a &quot;base&quot; or &quot;healthy&quot; group of samples; the
other samples are the &quot;test&quot; or &quot;cancer&quot; group.</p>
</td></tr> 
<tr><td><code id="TailRankTest_+3A_specificity">specificity</code></td>
<td>
<p>a real number between 0 and 1; the desired
specificity used in the test to estimate a quantile from the
&quot;base&quot; group. This is an optional argument with default value 0.95.</p>
</td></tr>
<tr><td><code id="TailRankTest_+3A_tolerance">tolerance</code></td>
<td>
<p>a real number between 0 and 1; the upper tolerance
bound used to estimate the threshold. This is an optional argument
with default value 0.90.</p>
</td></tr>
<tr><td><code id="TailRankTest_+3A_model">model</code></td>
<td>
<p>a character string that determines whther significance
comes from a binomial model or a beta-binomial (bb) model.</p>
</td></tr>
<tr><td><code id="TailRankTest_+3A_confidence">confidence</code></td>
<td>
<p>a real number between 0 and 1; the confidence level
that there are no false positives. This is an optional argument with
default value 0.50, which is equivalent to ignoring the tolerance.</p>
</td></tr> 
<tr><td><code id="TailRankTest_+3A_direction">direction</code></td>
<td>
<p>a character string representing the direction of the
test; can be &quot;up&quot;, &quot;down&quot;, or &quot;two-sided&quot;. The default value is &quot;up&quot;.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function computes the tail rank statistic for each gene (viewed as
one row of the data matrix). The data is split into two groups. The
first (&quot;base&quot;) group is used to estimate a tolerance bound (defaults to
50%) on a specific quantile (defaults to 95%) of the distribution of
each gene. The tail-rank statistic is the defined as the number of
samples in the second (&quot;test&quot;) group that lie outside the bound. The
test can be applied in the &quot;up&quot;, &quot;down&quot;, or &quot;two-sided&quot; direction,
depending on the kinds of markers being sought. Also computes the cutoff
for significance based on a confidence level that is &quot;1 - FWER&quot; for a
desired family-wise error rate.
</p>


<h3>Value</h3>

<p>The return value is an object of class
<a href="#topic+TailRankTest-class">TailRankTest</a>.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>References</h3>

<p>http://bioinformatics.mdanderson.org</p>


<h3>See Also</h3>

<p><code><a href="#topic+TailRankTest-class">TailRankTest-class</a></code>,
<code><a href="#topic+tailRankPower">tailRankPower</a></code>,
<code><a href="#topic+biomarkerPowerTable">biomarkerPowerTable</a></code>,
<code><a href="#topic+toleranceBound">toleranceBound</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate some fake data to use in the example
nr &lt;- 40000
nc &lt;- 110
fake.data &lt;- matrix(rnorm(nr*nc), ncol=nc)
fake.class &lt;- rep(c(TRUE, FALSE), c(40, 70))

# perform the tail-rank test
null.tr &lt;- TailRankTest(fake.data, fake.class)

# get a summary of the results
summary(null.tr)

# plot a histogram of the statistics
hist(null.tr, overlay=TRUE)

# get the actual statistics
stats &lt;- getStatistic(null.tr)

# get a vector that selects the "positive" calls for the test
is.marker &lt;- as.logical(null.tr)

# the following line should evaluate to the number of rows, nr = 40000
sum( is.marker == (stats &gt; null.tr@cutoff) )
</code></pre>

<hr>
<h2 id='TailRankTest-class'>The TailRankTest Class</h2><span id='topic+TailRankTest-class'></span><span id='topic+getStatistic'></span>

<h3>Description</h3>

<p>This is the class representation for the results of a
tail-rank test to find biomarkers in a microarray data set. It
includes methods for summarizing and plotting the results of the
test.</p>


<h3>Creating objects</h3>

<p>Although objects can be created, as usual, using <code>new</code>, the only
reliable way to create valid objects is to use the
<code><a href="#topic+TailRankTest">TailRankTest</a></code> function. See the description of that
function for details on how the tail-rank test works.
</p>


<h3>Slots</h3>


<dl>
<dt><code>statistic</code>:</dt><dd><p>a numeric vector containng the tail-rank
statistic for each row (gene) in a microarray data set</p>
</dd>
<dt><code>direction</code>:</dt><dd><p>a character string representing the
direction of the test; can be &quot;up&quot;, &quot;down&quot;, or &quot;two-sided&quot;</p>
</dd>
<dt><code>N1</code>:</dt><dd><p>an integer; the numnber of samples in the &quot;base&quot; or
&quot;healthy&quot; group</p>
</dd>
<dt><code>N2</code>:</dt><dd><p>an integer; the number of samples in the &quot;test&quot; or
&quot;cancer&quot; group</p>
</dd>
<dt><code>specificity</code>:</dt><dd><p>a real number between 0 and 1; the desired
specificity used in the test to estimate a quantile from the
&quot;base&quot; group</p>
</dd>
<dt><code>tolerance</code>:</dt><dd><p>a real number between 0 and 1; the upper
tolerance bound used to estimate the threshold</p>
</dd>
<dt><code>confidence</code>:</dt><dd><p>a real number between 0 and 1; the
confidence level that there are no false positives</p>
</dd>
<dt><code>cutoff</code>:</dt><dd><p>an integer; the maximum expected value of the
statistic under the null hypothesis</p>
</dd>
<dt><code>model</code>:</dt><dd><p>a character string describing the model
(binomial or beta-binomial) used to decide on cutoffs for significance</p>
</dd>
<dt><code>tau</code>:</dt><dd><p>a numeric vector or NULL; gene-by-gene upper
bounds for significance</p>
</dd>
<dt><code>rho</code>:</dt><dd><p>a numeric vector or NULL; gene-by-gene lower
bounds for significance</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>summary(object, ...)</dt><dd><p>Display a summary of the TailRankTest <code>object</code></p>
</dd>
<dt>hist(x, overlay, ...)</dt><dd><p>Plot a histogram of the statistic in
the TailRankTest object <code>x</code>. The optional argument
<code>overlay</code> is a logical flag. If <code>overlay=TRUE</code>, then the
histogram is overlain with a curve representing the null
distribution. The default value of <code>overlay</code> is <code>FALSE</code>.</p>
</dd>
<dt>as.logical(x, ...)</dt><dd><p>Convert the TailRankTest object
<code>x</code> into a logical vector, which takes on a <code>TRUE</code> value
whenever the tail-rank statistic exceeds the significance cutoff.</p>
</dd>
<dt>getStatistic(object, ...)</dt><dd><p>Obtain the vector of tail-rank
statistics contained in <code>object</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+TailRankTest">TailRankTest</a></code>,
<code><a href="#topic+tailRankPower">tailRankPower</a></code>,
<code><a href="#topic+biomarkerPowerTable">biomarkerPowerTable</a></code>,
<code><a href="oompaBase.html#topic+matrixMean">matrixMean</a></code>,
<code><a href="#topic+toleranceBound">toleranceBound</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate some fake data to use in the example
nr &lt;- 40000
nc &lt;- 110
fake.data &lt;- matrix(rnorm(nr*nc), ncol=nc)
fake.class &lt;- rep(c(TRUE, FALSE), c(40, 70))

# perform the tail-rank test
null.tr &lt;- TailRankTest(fake.data, fake.class)

# get a summary of the results
summary(null.tr)

# plot a histogram of the statistics
hist(null.tr, overlay=TRUE)

# get the actual statistics
stats &lt;- getStatistic(null.tr)

# get a vector that selects the "positive" calls for the test
is.marker &lt;- as.logical(null.tr)

# the following line should evaluate to the number of rows, nr = 40000
sum( is.marker == (stats &gt; null.tr@cutoff) )
</code></pre>

<hr>
<h2 id='TailRankTest-methods'>Methods for TailRankTest objects</h2><span id='topic+getStatistic+2CTailRankTest-method'></span><span id='topic+summary+2CTailRankTest-method'></span><span id='topic+hist+2CTailRankTest-method'></span><span id='topic+as.logical+2CTailRankTest-method'></span>

<h3>Description</h3>

<p>This file describes the methods for an object of the class
<code><a href="#topic+TailRankTest-class">TailRankTest</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TailRankTest'
summary(object, ...)
## S4 method for signature 'TailRankTest'
hist(x, overlay = FALSE,
  xlab = "tail-rank statistic", main = "", ...)
## S4 method for signature 'TailRankTest'
as.logical(x, ...)
## S4 method for signature 'TailRankTest'
getStatistic(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TailRankTest-methods_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+TailRankTest-class">TailRankTest</a> object</code></p>
</td></tr>
<tr><td><code id="TailRankTest-methods_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+TailRankTest-class">TailRankTest</a> object</code></p>
</td></tr>
<tr><td><code id="TailRankTest-methods_+3A_overlay">overlay</code></td>
<td>
<p>An optional logical flag; defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="TailRankTest-methods_+3A_xlab">xlab</code></td>
<td>
<p>A character string</p>
</td></tr>
<tr><td><code id="TailRankTest-methods_+3A_main">main</code></td>
<td>
<p>A character string</p>
</td></tr>
<tr><td><code id="TailRankTest-methods_+3A_...">...</code></td>
<td>
<p>Extra graphical parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>as.logical</code></td>
<td>
<p>Returns a logical vector. <code>TRUE</code> values
pick out candidate biomarkers where the tail-rank test statistic
exceeds the significance cutoff.</p>
</td></tr>
<tr><td><code>getStatistic</code></td>
<td>
<p>Returns the vector of tail-rank statistics
contained in <code>object</code>.</p>
</td></tr>
<tr><td><code>hist</code></td>
<td>
<p>Invisibly returns the TailRankTest object.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>Invisibly returns the TailRankTest object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+TailRankTest-class">TailRankTest-class</a></code>,
<code><a href="#topic+TailRankTest">TailRankTest</a></code>,
<code><a href="#topic+tailRankPower">tailRankPower</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate some fake data to use in the example
nr &lt;- 40000
nc &lt;- 110
fake.data &lt;- matrix(rnorm(nr*nc), ncol=nc)
fake.class &lt;- rep(c(TRUE, FALSE), c(40, 70))

# build an object
null.tr &lt;-  TailRankTest(fake.data, fake.class)

# summarize the object
summary(null.tr)

# plot a histogram
hist(null.tr)
hist(null.tr, breaks=70, col='blue', overlay=TRUE)

# get a logical vector that can select those markers
# identified by the test
selector &lt;- as.logical(null.tr)
</code></pre>

<hr>
<h2 id='toleranceBound'>Upper tolerance bounds on normal quantiles</h2><span id='topic+toleranceBound'></span>

<h3>Description</h3>

<p>The function <code>toleranceBound</code> computes theoretical upper tolerance
bounds on the quantiles of the standard normal distribution. These can
be used to produce reliable data-driven estimates of the quantiles in
any normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toleranceBound(psi, gamma, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toleranceBound_+3A_psi">psi</code></td>
<td>
<p>A real number between 0 and 1 giving the desired quantile </p>
</td></tr>
<tr><td><code id="toleranceBound_+3A_gamma">gamma</code></td>
<td>
<p>A real number between 0 and 1 giving the desired
tolerance bound</p>
</td></tr>
<tr><td><code id="toleranceBound_+3A_n">N</code></td>
<td>
<p>An integer giving the number of observations used to estimate
the quantile</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose that we collect <code class="reqn">N</code> observations from a normal distribution
with unknown mean and variance, and wish to estimate the <code class="reqn">95</code>th
percentile of the distribution. A simple point estimate is given by
<code class="reqn">\tau = \bar{X} + 1.68s</code>. However, only the mean of the distribution is
less than this value <code class="reqn">95\%</code> of the time.  When <code class="reqn">N=40</code>, for example,
almost half of the time (<code class="reqn">43.5\%</code>), fewer than <code class="reqn">95\%</code> of the
observed values will be less than <code class="reqn">\tau</code>. This problem is addressed by
constructing a statistical tolerance interval (more precisely, a one-sided
tolerance bound) that contains a given fraction, <code class="reqn">\psi</code>, of the
population with a given confidence level, <code class="reqn">\gamma</code> [Hahn and Meeker,
1991]. With enough samples, one can obtain distribution-free tolerance
bounds [op.\ cit., Chapter 5]. For instance, one can use bootstrap or
jackknife methods to estimate these bounds empirically.
</p>
<p>Here, however, we assume that the measurements are normally distributed. We
let <code class="reqn">\bar{X}</code> denote the sample mean and let <code class="reqn">s</code> denote the sample
standard deviation. The upper tolerance bound that, <code class="reqn">100 \gamma\%</code> of
the time, exceeds <code class="reqn">100 \psi\%</code> of <code class="reqn">G</code> values from a normal
distribution is approximated by <code class="reqn">X_U = \bar{X} + k_{\gamma,\psi}s</code>,
where
</p>
<p style="text-align: center;"><code class="reqn">
  k_{\gamma, \psi} = {z_{\psi} + \sqrt{z_{\psi}^2 - ab} \over a},
</code>
</p>
<p style="text-align: center;"><code class="reqn">
  a = 1-{z_{1-\gamma}^2\over 2N-2},
</code>
</p>
<p style="text-align: center;"><code class="reqn">
  b = z_{\psi}^2 - {z_{1-\gamma}^2\over N},
</code>
</p>

<p>and, for any <code class="reqn">\pi</code>, <code class="reqn">z_\pi</code> is the critical value of the normal
distribution that is exceeded with probability <code class="reqn">\pi</code> [Natrella, 1963].
</p>


<h3>Value</h3>

<p>Returns the value of <code class="reqn">k_{\gamma, \psi}</code> with the property that the
<code class="reqn">\psi</code>th quantile will be less than the estimate <code class="reqn">X_U =
    \bar{X} + k_{\gamma,\psi}s</code> (based on <code class="reqn">N</code> data points) at least
<code class="reqn">100 \gamma\%</code> of the time. 
</p>


<h3>Note</h3>

<p>Lower tolerance bounds on quantiles with <code>psi</code> less than
one-half can be obtained as <code class="reqn">X_U = \bar{X} - k_{\gamma,1-\psi}s</code>,</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>References</h3>

<p>Natrella, M.G. (1963) <em>Experimental Statistics</em>.
NBS Handbook 91, National Bureau of Standards, Washington DC.
</p>
<p>Hahn, G.J. and Meeker, W.Q. (1991)
<em>Statistical Intervals: A Guide for Practitioners</em>.
John Wiley and Sons, Inc., New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 50
x &lt;- rnorm(N)
tolerance &lt;- 0.90
quant &lt;- 0.95
tolerance.factor &lt;- toleranceBound(quant, tolerance, N)

# upper 90% tolerance bound for 95th percentile
tau &lt;- mean(x) + sd(x)*tolerance.factor

# lower 90% tolerance bound for 5th percentile
rho &lt;- mean(x) - sd(x)*tolerance.factor

# behavior of the tolerance bound as N increases
nn &lt;- 10:100
plot(nn, toleranceBound(quant, tolerance, nn))

# behavior of the bound as the tolerance varies
xx &lt;- seq(0.5, 0.99, by=0.01)
plot(xx, toleranceBound(quant, xx, N))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
