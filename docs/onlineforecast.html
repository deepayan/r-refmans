<!DOCTYPE html><html><head><title>Help for package onlineforecast</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {onlineforecast}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#onlineforecast-package'><p>onlineforecast: Forecast Modelling for Online Applications</p></a></li>
<li><a href='#%**%'><p>Multiplication of list with y, elementwise</p></a></li>
<li><a href='#==.data.list'><p>Determine if two data.lists are identical</p></a></li>
<li><a href='#AR'><p>Auto-Regressive (AR) input</p></a></li>
<li><a href='#as.data.frame.data.list'><p>Convert to data.frame</p></a></li>
<li><a href='#as.data.list'><p>Convert to data.list class</p></a></li>
<li><a href='#aslt'><p>Convertion to POSIXlt</p></a></li>
<li><a href='#bspline'><p>Compute base splines of a variable using the R function <code>splines::bs</code>, use in the transform stage.</p></a></li>
<li><a href='#cache_name'><p>Generation of a name for a cache file for the value of a function.</p></a></li>
<li><a href='#cache_save'><p>Save a cache file (name generated with <code>code_name()</code></p></a></li>
<li><a href='#complete_cases'><p>Find complete cases in forecast matrices</p></a></li>
<li><a href='#ct'><p>Convertion to POSIXct</p></a></li>
<li><a href='#data.list'><p>Make a data.list</p></a></li>
<li><a href='#Dbuilding'><p>Observations and weather forecasts from a single-family building, weather station and Danish Meteorological Institute (DMI)</p></a></li>
<li><a href='#depth'><p>Depth of a list</p></a></li>
<li><a href='#flattenlist'><p>Flattens list</p></a></li>
<li><a href='#forecastmodel'><p>Class for forecastmodels</p></a></li>
<li><a href='#fs'><p>Generation of Fourrier series.</p></a></li>
<li><a href='#getse'><p>Getting subelement from list.</p></a></li>
<li><a href='#gof'><p>Simple wrapper for graphics.off()</p></a></li>
<li><a href='#in_range'><p>Selects a period</p></a></li>
<li><a href='#input_class'><p>Class for forecastmodel inputs</p></a></li>
<li><a href='#lagdf'><p>Lagging which returns a data.frame</p></a></li>
<li><a href='#lagdf.character'><p>Lagging which returns a data.frame</p></a></li>
<li><a href='#lagdf.factor'><p>Lagging which returns a data.frame</p></a></li>
<li><a href='#lagdf.logical'><p>Lagging which returns a data.frame</p></a></li>
<li><a href='#lagdf.matrix'><p>Lagging which returns a data.frame</p></a></li>
<li><a href='#lagdf.numeric'><p>Lagging which returns a data.frame</p></a></li>
<li><a href='#lagdl'><p>Lagging which returns a data.list</p></a></li>
<li><a href='#lagvec'><p>Lag by shifting</p></a></li>
<li><a href='#lapply_cbind'><p>Helper which does lapply and then cbind</p></a></li>
<li><a href='#lapply_cbind_df'><p>Helper which does lapply, cbind and then as.data.frame</p></a></li>
<li><a href='#lapply_rbind'><p>Helper which does lapply and then rbind</p></a></li>
<li><a href='#lapply_rbind_df'><p>Helper which does lapply, rbind and then as.data.frame</p></a></li>
<li><a href='#lm_fit'><p>Fit an onlineforecast model with <code>lm</code></p></a></li>
<li><a href='#lm_optim'><p>Optimize parameters for onlineforecast model fitted with LM</p></a></li>
<li><a href='#lm_predict'><p>Prediction with an lm forecast model.</p></a></li>
<li><a href='#long_format'><p>Long format of prediction data.frame</p></a></li>
<li><a href='#lp'><p>First-order low-pass filtering</p></a></li>
<li><a href='#lp_vector'><p>First-order low-pass filtering</p></a></li>
<li><a href='#lp_vector_cpp'><p>Low pass filtering of a vector.</p></a></li>
<li><a href='#make_input'><p>Make a forecast matrix (as data.frame) from observations.</p></a></li>
<li><a href='#make_periodic'><p>Make an forecast matrix with a periodic time signal.</p></a></li>
<li><a href='#make_tday'><p>Make an hour-of-day forecast matrix</p></a></li>
<li><a href='#nams'><p>Return the column names</p></a></li>
<li><a href='#one'><p>Create ones for model input intercept</p></a></li>
<li><a href='#pairs.data.list'><p>Generation of pairs plot for a data.list.</p></a></li>
<li><a href='#par_ts'><p>Set parameters for <code>plot_ts()</code></p></a></li>
<li><a href='#pbspline'><p>Wrapper for <code>bspline</code> with <code>periodic=TRUE</code></p></a></li>
<li><a href='#persistence'><p>Generate persistence forecasts</p></a></li>
<li><a href='#plot_ts'><p>Time series plotting</p></a></li>
<li><a href='#plotly_ts.data.frame'><p>Time series plotting</p></a></li>
<li><a href='#plotly_ts.data.list'><p>Time series plotting</p></a></li>
<li><a href='#print_to_message'><p>Simple function for capturing from the print function and send it in a message().</p></a></li>
<li><a href='#print.forecastmodel'><p>Print forecast model</p></a></li>
<li><a href='#pst'><p>Simple wrapper for paste0().</p></a></li>
<li><a href='#resample'><p>Resampling to equidistant time series</p></a></li>
<li><a href='#resample.data.frame'><p>Resampling to equidistant time series</p></a></li>
<li><a href='#residuals.data.frame'><p>Calculate the residuals given a forecast matrix and the observations.</p></a></li>
<li><a href='#rls_fit'><p>Fit an onlineforecast model with Recursive Least Squares (RLS).</p></a></li>
<li><a href='#rls_optim'><p>Optimize parameters for onlineforecast model fitted with RLS</p></a></li>
<li><a href='#rls_predict'><p>Prediction with an rls model.</p></a></li>
<li><a href='#rls_prm'><p>Function for generating the parameters for RLS regression</p></a></li>
<li><a href='#rls_summary'><p>Print summary of an onlineforecast model fitted with RLS</p></a></li>
<li><a href='#rls_update'><p>Updates the model fits</p></a></li>
<li><a href='#rls_update_cpp'><p>Calculating k-step recursive least squares estimates</p></a></li>
<li><a href='#rmse'><p>Computes the RMSE score.</p></a></li>
<li><a href='#score'><p>Calculate the score for each horizon.</p></a></li>
<li><a href='#setpar'><p>Setting <code>par()</code> plotting parameters</p></a></li>
<li><a href='#stairs'><p>Plotting stairs with time point at end of interval.</p></a></li>
<li><a href='#state_getval'><p>Get the state value kept in last call.</p></a></li>
<li><a href='#state_setval'><p>Set a state value to be kept for next the transformation function is called.</p></a></li>
<li><a href='#step_optim'><p>Forward and backward model selection</p></a></li>
<li><a href='#subset.data.list'><p>Take a subset of a data.list.</p></a></li>
<li><a href='#summary.data.list'><p>Summary with checks of the data.list for appropriate form.</p></a></li>
<li><a href='#summary.rls_fit'><p>Print summary of an onlineforecast model fitted with RLS</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Forecast Modelling for Online Applications</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>A framework for fitting adaptive forecasting models. Provides a way to use forecasts as input to models, e.g. weather forecasts for energy related forecasting. The models can be fitted recursively and can easily be setup for updating parameters when new data arrives. See the included vignettes, the website <a href="https://onlineforecasting.org">https://onlineforecasting.org</a> and the paper "onlineforecast: An R package for adaptive and recursive forecasting" <a href="https://journal.r-project.org/articles/RJ-2023-031/">https://journal.r-project.org/articles/RJ-2023-031/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.18), R6 (&ge; 2.2.2), splines (&ge; 3.1.1), pbs,
digest</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, R.rsp, testthat (&ge; 3.0.0), data.table,
plotly</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://onlineforecasting.org">https://onlineforecasting.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://lab.compute.dtu.dk/packages/onlineforecast/-/issues">https://lab.compute.dtu.dk/packages/onlineforecast/-/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-12 09:19:34 UTC; pbac</td>
</tr>
<tr>
<td>Author:</td>
<td>Peder Bacher [cre],
  Hjorleifur G Bergsteinsson [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peder Bacher &lt;pbac@dtu.dk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-12 10:30:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='onlineforecast-package'>onlineforecast: Forecast Modelling for Online Applications</h2><span id='topic+onlineforecast'></span><span id='topic+onlineforecast-package'></span>

<h3>Description</h3>

<p>A framework for fitting adaptive forecasting models. Provides a way to use forecasts as input to models, e.g. weather forecasts for energy related forecasting. The models can be fitted recursively and can easily be setup for updating parameters when new data arrives. See the included vignettes, the website <a href="https://onlineforecasting.org">https://onlineforecasting.org</a> and the paper &quot;onlineforecast: An R package for adaptive and recursive forecasting&quot; <a href="https://journal.r-project.org/articles/RJ-2023-031/">https://journal.r-project.org/articles/RJ-2023-031/</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Peder Bacher <a href="mailto:pbac@dtu.dk">pbac@dtu.dk</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Hjorleifur G Bergsteinsson <a href="mailto:hgbe@dtu.dk">hgbe@dtu.dk</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://onlineforecasting.org">https://onlineforecasting.org</a>
</p>
</li>
<li><p> Report bugs at <a href="https://lab.compute.dtu.dk/packages/onlineforecast/-/issues">https://lab.compute.dtu.dk/packages/onlineforecast/-/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+2A+2A+25'>Multiplication of list with y, elementwise</h2><span id='topic++25+2A+2A+25'></span>

<h3>Description</h3>

<p>Multiplication of each element in a list (x) with y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %**% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B2A+2B2A+2B25_+3A_x">x</code></td>
<td>
<p>a list of matrices, data.frames, etc.</p>
</td></tr>
<tr><td><code id="+2B25+2B2A+2B2A+2B25_+3A_y">y</code></td>
<td>
<p>a vector, data.frame or matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each element of x is multiplied with y using the usual elementwise '*' operator.
</p>
<p>Typical use is when a function, e.g. <code><a href="#topic+bspline">bspline</a>()</code>, returns a list of matrices (e.g. one for each base spline) and they should individually be multiplied with y (a vector, matrix, etc.).
</p>
<p>Since this is intended to be used for forecast models in the transformation stage 
then there are some percularities:
</p>
<p>If the number of columns or the names of the columns are not equal for one element in x
and y, then only the columns with same names are used, hence the resulting matrices can be
of lower dimensions.
</p>
<p>See the example <a href="https://onlineforecasting.org/examples/solar-power-forecasting.html">https://onlineforecasting.org/examples/solar-power-forecasting.html</a> where the operator is used.
</p>


<h3>Value</h3>

<p>A list of same length of x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- list(matrix(1:9,3), matrix(9:1,3))
x

y &lt;- matrix(2,3,3)
y

x %**% y

y &lt;- 1:3

x %**% y

# Naming percularity
nams(x[[1]]) &lt;- c("k1","k2","k3")
nams(x[[2]]) &lt;- c("k2","k3","k4")
y &lt;- matrix(2,3,3)
nams(y) &lt;- c("k1","k3","k7")

# Now the only the horizons matching will be used
x %**% y

</code></pre>

<hr>
<h2 id='+3D+3D.data.list'>Determine if two data.lists are identical</h2><span id='topic++3D+3D.data.list'></span>

<h3>Description</h3>

<p>Compare two data.lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.list'
x == y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B3D+2B3D.data.list_+3A_x">x</code></td>
<td>
<p>first data.list</p>
</td></tr>
<tr><td><code id="+2B3D+2B3D.data.list_+3A_y">y</code></td>
<td>
<p>second data.list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns TRUE if the two data.lists are fully identical, so all data, order of variables etc. must be fully identical
</p>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Dbuilding == Dbuilding

D &lt;- Dbuilding
D$Ta$k2[1] &lt;- NA
Dbuilding == D

D &lt;- Dbuilding
names(D)[5] &lt;- "I"
names(D)[6] &lt;- "Ta"
Dbuilding == D


</code></pre>

<hr>
<h2 id='AR'>Auto-Regressive (AR) input</h2><span id='topic+AR'></span>

<h3>Description</h3>

<p>Generate auto-regressive (AR) inputs in a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AR(lags)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AR_+3A_lags">lags</code></td>
<td>
<p>integer vector: The lags of the AR to include.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AR function can be used in an onlineforecast model formulation. It
creates the input matrices for including AR inputs in a model during the
transformation stage. It takes the values from the model output in the provided data
does the needed lagging.
</p>
<p>The lags must be given according to the one-step ahead model, e.g.:
</p>
<p><code>AR(lags=c(0,1))</code> will give: <code class="reqn">Y_{t+1|t} = \phi_1 y_{t-0} + \phi_2 y_{t-1} + \epsilon_{t+1}</code>
</p>
<p>and:
</p>
<p><code>AR(lags=c(0,3,12))</code> will give: <code class="reqn">Y_{t+1|t} = \phi_1 y_{t-0} + \phi_2 y_{t-3} + \phi_3 y_{t-12} + \epsilon_{t+1}</code>
</p>
<p>Note, that 
</p>
<p>For k&gt;1 the coefficients will be fitted individually for each horizon, e.g.:
</p>
<p><code>AR(lags=c(0,1))</code> will be the multi-step AR: <code class="reqn">Y_{t+k|t} = \phi_{1,k} y_{t-0} + \phi_{2,k} y_{t-1} + \epsilon_{t+k|t}</code>
</p>
<p>See the details in examples on <a href="https://onlineforecasting.org">https://onlineforecasting.org</a>.
</p>


<h3>Value</h3>

<p>A list of matrices, one for each lag in lags, each with columns according to model$kseq.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Setup data and a model for the example
D &lt;- Dbuilding
model &lt;- forecastmodel$new()
model$output = "heatload"
# Use the AR in the transformation stage
model$add_inputs(AR = "AR(c(0,1))")
# Regression parameters
model$add_regprm("rls_prm(lambda=0.9)")
# kseq must be added
model$kseq &lt;- 1:4
# In the transformation stage the AR input will be generated
# See that it generates two input matrices, simply with the lagged heat load at t for every k
model$transform_data(subset(D, 1:10))

# Fit with recursive least squares (no parameters prm in the model)
fit &lt;- rls_fit(c(lambda=0.99), model, D, returnanalysis=TRUE)

# Plot the result, see "?plot_ts.rls_fit"
plot_ts(fit, xlim=c(ct("2010-12-20"),max(D$t)))
# Plot for a short period with peaks
plot_ts(fit, xlim=c("2011-01-05","2011-01-07"))

# For online updating, see ??ref{vignette, not yet available}:
# the needed lagged output values are stored in the model for next time new data is available
model$yAR
# The maximum lag needed is also kept
model$maxlagAR

</code></pre>

<hr>
<h2 id='as.data.frame.data.list'>Convert to data.frame</h2><span id='topic+as.data.frame.data.list'></span>

<h3>Description</h3>

<p>Converts a data.list to a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.list'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.data.list_+3A_x">x</code></td>
<td>
<p>The data.list to be converted.</p>
</td></tr>
<tr><td><code id="as.data.frame.data.list_+3A_row.names">row.names</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="as.data.frame.data.list_+3A_optional">optional</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="as.data.frame.data.list_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The forecasts in the data.list will result in columns named <code>varname.kxx</code> in the data.frame.
</p>


<h3>Value</h3>

<p>A data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#' # Use the data.list with building heat load 
D &lt;- Dbuilding
# Take a subset
D &lt;- subset(D, 1:5, nms=c("t","Taobs","Ta","Iobs","I"), kseq=1:3)

# Convert to a data.frame, note the names of the forecasts are appended .kxx (i.e. for Ta and I)
as.data.frame(D)

</code></pre>

<hr>
<h2 id='as.data.list'>Convert to data.list class</h2><span id='topic+as.data.list'></span><span id='topic+as.data.list.data.frame'></span>

<h3>Description</h3>

<p>These functions will convert the object into a data.list.
</p>
<p>Convert a data.frame into a data.list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.data.list(object)

## S3 method for class 'data.frame'
as.data.list(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.list_+3A_object">object</code></td>
<td>
<p>The data.frame to be converted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A data.list is simply a list of vectors and data.frames. For the use in the 
onlineforecast package the following format must be kept:
</p>
<p>- t: A vector of time.
</p>
<p>- vectors with same length as t: Holds observations and values synced to time t.
</p>
<p>- data.frames with number of rows as time t: Holds forecasts in each column named by <code>kxx</code> where <code>xx</code> is the
horizon, e.g. <code>k0</code> is synced as observations, and <code>k1</code> is one-step ahead.
</p>
<p>The convention is that columns with forecasts are postfixed with <code>.kxx</code> where
<code>xx</code> is the horizon. See the examples.
</p>


<h3>Value</h3>

<p>a value of class data.list
</p>
<p>a data.list
</p>


<h3>See Also</h3>

<p><code>For specific detailed info see the children, e.g. <a href="#topic+as.data.list.data.frame">as.data.list.data.frame</a> </code>
</p>
<p>as.data.list
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert a dataframe with time and two observed variables
X &lt;- data.frame(t=1:10, x=1:10, y=1:10)
as.data.list(X)

# Convert a dataframe with time, forecast and an observed variable
X &lt;- data.frame(t=1:10, x.k1=1:10, x.k2=10:1, yobs=1:10, y.k1=1:10, y.k2=1:10)
as.data.list(X)

# Can be converted back and forth
X
as.data.frame(as.data.list(X))

</code></pre>

<hr>
<h2 id='aslt'>Convertion to POSIXlt</h2><span id='topic+aslt'></span><span id='topic+aslt.character'></span><span id='topic+aslt.POSIXct'></span><span id='topic+aslt.POSIXlt'></span><span id='topic+aslt.numeric'></span>

<h3>Description</h3>

<p>The argument is converted into POSIXlt with tz=&quot;GMT&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aslt(object, ...)

## S3 method for class 'character'
aslt(object, tz = "GMT", ...)

## S3 method for class 'POSIXct'
aslt(object, tz = NA, ...)

## S3 method for class 'POSIXlt'
aslt(object, tz = NA, ...)

## S3 method for class 'numeric'
aslt(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aslt_+3A_object">object</code></td>
<td>
<p>The character, POSIXct, POSIClt, or numeric which is converted to POSIXct.</p>
</td></tr>
<tr><td><code id="aslt_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods.</p>
</td></tr>
<tr><td><code id="aslt_+3A_tz">tz</code></td>
<td>
<p>Timezone. If set, then the time zone will be changed of the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class POSIXlt
</p>


<h3>Methods</h3>

<p>- aslt.character: Simply a wrapper for <code>as.POSIXlt</code>
</p>
<p>- aslt.POSIXct: Converts to POSIXct.
</p>
<p>- aslt.POSIXlt: Changes the time zone of the object if tz is given.
</p>
<p>- aslt.numeric: Converts from UNIX time in seconds to POSIXlt.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a POSIXlt with tz="GMT"
aslt("2019-01-01")
class(aslt("2019-01-01"))
aslt("2019-01-01 01:00:05")

# Convert between time zones
x &lt;- aslt("2019-01-01", tz="CET")
aslt(x,tz="GMT")

# To seconds and back again
aslt(as.numeric(x, units="sec"))

</code></pre>

<hr>
<h2 id='bspline'>Compute base splines of a variable using the R function <code>splines::bs</code>, use in the transform stage.</h2><span id='topic+bspline'></span>

<h3>Description</h3>

<p>Simply wraps the <code>splines::bs</code>, such that it can be used in the transformation stage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bspline(
  X,
  Boundary.knots = NA,
  intercept = FALSE,
  df = NULL,
  knots = NULL,
  degree = 3,
  bknots = NA,
  periodic = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bspline_+3A_x">X</code></td>
<td>
<p>data.frame (as part of data.list) with horizons as columns named <code>kxx</code> (i.e. one for each horizon)</p>
</td></tr>
<tr><td><code id="bspline_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>The value is NA: then the boundaries are set to the range of each horizons (columns in X). See <code>?splines::bs</code></p>
</td></tr>
<tr><td><code id="bspline_+3A_intercept">intercept</code></td>
<td>
<p>See <code>?splines::bs</code>.</p>
</td></tr>
<tr><td><code id="bspline_+3A_df">df</code></td>
<td>
<p>See <code>?splines::bs</code></p>
</td></tr>
<tr><td><code id="bspline_+3A_knots">knots</code></td>
<td>
<p>See <code>?splines::bs</code></p>
</td></tr>
<tr><td><code id="bspline_+3A_degree">degree</code></td>
<td>
<p>See <code>?splines::bs</code></p>
</td></tr>
<tr><td><code id="bspline_+3A_bknots">bknots</code></td>
<td>
<p>Is just a short for Boundary.knots and replace Boundary.knots (if Boundary.knots is not given)</p>
</td></tr>
<tr><td><code id="bspline_+3A_periodic">periodic</code></td>
<td>
<p>Default FALSE. If TRUE, then <code>pbs::pbs</code> is called and periodic splines are generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the help for all arguments with <code>?splines::bs</code>. NOTE that two arguments have different default values.
</p>
<p>See the example <a href="https://onlineforecasting.org/examples/solar-power-forecasting.html">https://onlineforecasting.org/examples/solar-power-forecasting.html</a> where the function is used in a model.
</p>


<h3>Value</h3>

<p>List of data frames with the computed base splines, each with columns for the same horizons as in X
</p>


<h3>See Also</h3>

<p>Other Transform stage functions: 
<code><a href="#topic+pbspline">pbspline</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# How to make a diurnal curve using splines
# Select first 54 hours from the load data
D &lt;- subset(Dbuilding, 1:76, kseq=1:4)
# Make the hour of the day as a forecast input
D$tday &lt;- make_tday(D$t, kseq=1:4)
D$tday

# Calculate the base splines for each column in tday
L &lt;- bspline(D$tday)

# Now L holds a data.frame for each base spline
str(L)
# Hence this will result in four inputs for the regression model

# Plot (note that the splines period starts at tday=0)
plot(D$t, L$bs1$k1, type="s")
for(i in 2:length(L)){
  lines(D$t, L[[i]]$k1, col=i, type="s")
}

# In a model formulation it will be:
model &lt;- forecastmodel$new()
model$add_inputs(mutday = "bspline(tday)")
# We set the horizons (actually not needed for the transform, only required for data checks)
model$kseq &lt;- 1:4
# Such that at the transform stage will give the same as above
model$transform_data(D)

# Periodic splines are useful for modelling a diurnal harmonical functions
L &lt;- bspline(D$tday, bknots=c(0,24), df=4, periodic=TRUE)
# or
L &lt;- pbspline(D$tday, bknots=c(0,24), df=4)
# Note, how it has to have high enough df, else it generates an error

# Plot
plot(D$t, L$bs1$k1, type="s")
for(i in 2:length(L)){
   lines(D$t, L[[i]]$k1, col=i, type="s")
}

</code></pre>

<hr>
<h2 id='cache_name'>Generation of a name for a cache file for the value of a function.</h2><span id='topic+cache_name'></span>

<h3>Description</h3>

<p>Caching of the value returned by a function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cache_name(..., cachedir = "cache")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cache_name_+3A_...">...</code></td>
<td>
<p>The objects from which to calculate cache file name.
If no objects given, then all the objects of the calling function are used for generating the checksum for the file name.</p>
</td></tr>
<tr><td><code id="cache_name_+3A_cachedir">cachedir</code></td>
<td>
<p>Path for saving the cache, i.e. prefixed to the generated name, remember to end with '/' to make a directory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use it in the beginning of a function, which runs a time consuming calculation, like fitting a model using optimization.
</p>
<p>It makes a cache name, which can be used to save a unique cache file (see <code><a href="#topic+cache_save">cache_save</a>()</code>).
</p>
<p>The <code>cache_name</code> function must receive all the objects (in <code>...</code>) which influence the value of the function. It simply calculates a checksum using the <code>digest</code> package.
</p>
<p>Further, it finds the name of the calling function and its definition, such that if anything changes in the function definition, then the cache file name changes too.
</p>


<h3>Value</h3>

<p>A generated cache file name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A function for demonstrating the using caching
fun &lt;- function(x, y){
    # Generate the cache name (no argument given, so both x and y is used)
    nm &lt;- cache_name(cachedir=cachedir)
    # If the result is cached, then just return it
    if(file.exists(nm)){ return(readRDS(nm)) }
    # Do the calculation
    res &lt;- x^2 + y + 1
    # Wait 1 sec
    Sys.sleep(1)
    # Save for cache
    cache_save(res, nm)
    # Return
    return(res)
}

# For this example use a temporary directory 
# In real use this should not be temporary! (changes between R sessions with tempdir())
cachedir &lt;- tempdir()

# Uncomment to run:
# First time it takes at least 1 sec.
#fun(x=2,y=2)
# Second time it loads the cache and is much faster
#fun(x=2,y=2)
# Try changing the arguments (x,y) and run again

# See the cache file(s)
#dir(cachedir)
# Delete the cache folder
#unlink(cachedir, recursive=TRUE)

# Demonstrate how cache_name() is functioning
# Cache using the all objects given in the function calling, i.e. both x and y
fun &lt;- function(x,y){
    x^2 + y + 1
    return(cache_name())
}
# These are the same (same values)
fun(x=1,y=2)
fun(1,2)
fun(y=2,x=1)
# But this one is different
fun(x=2,y=1)

# Test: cache using the values specified in the cache_name call
fun2 &lt;- function(x,y){
    x^2 + y + 1
    return(cache_name(x))
}

# So now its only the x value that change the name
fun2(1,2)
fun2(1,3)
# But this one is different 
fun2(3,3)
# And the function named changed the name

</code></pre>

<hr>
<h2 id='cache_save'>Save a cache file (name generated with <code>code_name()</code></h2><span id='topic+cache_save'></span>

<h3>Description</h3>

<p>Saves the object as an .RDS file with the filename
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cache_save(object, filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cache_save_+3A_object">object</code></td>
<td>
<p>The object to cache (i.e. the value of the evaluating function).</p>
</td></tr>
<tr><td><code id="cache_save_+3A_filename">filename</code></td>
<td>
<p>The cache file name (i.e. use the one generated by cache_name, see examples).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the examples for <code><a href="#topic+cache_name">cache_name</a>()</code>.
</p>

<hr>
<h2 id='complete_cases'>Find complete cases in forecast matrices</h2><span id='topic+complete_cases'></span><span id='topic+complete_cases.list'></span><span id='topic+complete_cases.data.frame'></span>

<h3>Description</h3>

<p>Returns a logical vector indicating the time points which
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_cases(object, kseq = NA)

## S3 method for class 'list'
complete_cases(object, kseq = NA)

## S3 method for class 'data.frame'
complete_cases(object, kseq = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_cases_+3A_object">object</code></td>
<td>
<p>A data.frame (with columns named 'kxx') or a list of
data.frames.</p>
</td></tr>
<tr><td><code id="complete_cases_+3A_kseq">kseq</code></td>
<td>
<p>integer vector: If given then only these horizons are processed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a forecast matrix the forecasts are lagged &quot;+k&quot; steps to align them and
then 'complete.cases()' is run on that .
</p>
<p>Gieven a list of forecast matrices the points where all are complete (also all horizons) are complete are TRUE.
</p>


<h3>Value</h3>

<p>A logical vector specifying if there is no missing
values across all horizonsd.
</p>


<h3>Author(s)</h3>

<p>Peder Bacher
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Take a small data set
D &lt;- subset(Dbuilding, 1:20, kseq=1:5)
# Check the forecast matrix of ambient temperature
D$Ta
# Which are complete over all horizons? The first are not since not all horizons
# have a value there (after lagging)
complete_cases(D$Ta)
# Same goes if given as a list
complete_cases(D["Ta"])
# and if more than one is given
complete_cases(D[c("Ta","I")])

# Set some NA of some horizon
D$I$k3[8:9] &lt;- NA
# Now they are recognized as not complete
complete_cases(D[c("Ta","I")])

# If we deal with residuals, which are observations and there for have column names "hxx"
Resid &lt;- residuals(D$Ta, D$Taobs)
names(Resid)
# With columns with "h" instead of "k" no lagging occurs in complete_cases
complete_cases(Resid)
#
Resid2 &lt;- Resid
Resid$h3[8:9] &lt;- NA
complete_cases(list(Resid,Resid2))

</code></pre>

<hr>
<h2 id='ct'>Convertion to POSIXct</h2><span id='topic+ct'></span><span id='topic+ct.character'></span><span id='topic+ct.POSIXct'></span><span id='topic+ct.POSIXlt'></span><span id='topic+ct.numeric'></span>

<h3>Description</h3>

<p>The object is converted into POSIXct with tz=&quot;GMT&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ct(object, ...)

## S3 method for class 'character'
ct(object, tz = "GMT", ...)

## S3 method for class 'POSIXct'
ct(object, tz = NA, duplicatedadd = NA, ...)

## S3 method for class 'POSIXlt'
ct(object, tz = NA, duplicatedadd = NA, ...)

## S3 method for class 'numeric'
ct(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ct_+3A_object">object</code></td>
<td>
<p>The object to convert can be: character, numeric, POSIXct or POSIXlt</p>
</td></tr>
<tr><td><code id="ct_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods.</p>
</td></tr>
<tr><td><code id="ct_+3A_tz">tz</code></td>
<td>
<p>Timezone. If set, then the time zone will be changed of the object.</p>
</td></tr>
<tr><td><code id="ct_+3A_duplicatedadd">duplicatedadd</code></td>
<td>
<p>Seconds to be added to duplicated time stamps, to mitigate the problem of duplicated timestamps at the shift to winter time. So the second time a time stamp occurs (identified with <code>duplicated</code>) then the seconds will be added.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple helper, which wraps <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>' and sets the time zone to &quot;GMT&quot; per default.
</p>


<h3>Value</h3>

<p>An object of class POSIXct
</p>


<h3>Methods</h3>

<p>- ct.character: Simply a wrapper for <code>as.POSIXct</code> with default <code>tz</code>
</p>
<p>- ct.POSIXct: Changes the time zone of the object if <code>tz</code> is given.
</p>
<p>- ct.POSIXlt: Converts to POSIXct.
</p>
<p>- ct.numeric: Converts from UNIX time in seconds to POSIXct with <code>tz</code> as GMT.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Create a POSIXct with tz="GMT"
ct("2019-01-01")
class(ct("2019-01-01"))
ct("2019-01-01 01:00:05")


# Convert to POSIXct
class(ct(as.POSIXlt("2019-01-01")))

# To seconds and back again
ct(as.numeric(1000, units="sec"))


# --------
# Convert character of time which has summer time leaps
# Example from CET (with CEST which is winter time)
# 
# The point of shifting to and from summer time:
# DST Start (Clock Forward)	DST End (Clock Backward)
# Sunday, March 31, 02:00	Sunday, October 27, 03:00

# --------
# From to winter time to summer time
txt &lt;- c("2019-03-31 01:00",
         "2019-03-31 01:30",
         "2019-03-31 03:00",
         "2019-03-31 03:30")
x &lt;- ct(txt, tz="CET")
x
ct(x, tz="GMT")

# BE AWARE of this conversion of the 02:00: to 02:59:59 (exact time of shift) will lead to a
# wrong conversion
txt &lt;- c("2019-03-31 01:30",
         "2019-03-31 02:00",
         "2019-03-31 03:30")
x &lt;- ct(txt, tz="CET")
x
ct(x, tz="GMT")
# Which a diff on the time can detect, since all steps are not equal
plot(diff(ct(x, tz="GMT")))

# --------
# Shift to winter time is more problematic
# It works like this 
txt &lt;- c("2019-10-27 01:30",
         "2019-10-27 02:00",
         "2019-10-27 02:30",
         "2019-10-27 03:00",
         "2019-10-27 03:30")
x &lt;- ct(txt, tz="CET")
x
ct(x, tz="GMT")

# however, timestamps can be given like this
txt &lt;- c("2019-10-27 01:30",
         "2019-10-27 02:00",
         "2019-10-27 02:30",
         "2019-10-27 02:00",
         "2019-10-27 02:30",
         "2019-10-27 03:00",
         "2019-10-27 03:30")
x &lt;- ct(txt, tz="CET")
x
ct(x, tz="GMT")
# Again can be detected, since all steps are not equal
plot(diff(ct(x, tz="GMT")))
# This can be fixed by (note that it can go wrong, e.g. with gaps around convertion etc.)
ct(x, tz="GMT", duplicatedadd=3600)

</code></pre>

<hr>
<h2 id='data.list'>Make a data.list</h2><span id='topic+data.list'></span>

<h3>Description</h3>

<p>Make a data.list of the vectors and data.frames given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.list(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.list_+3A_...">...</code></td>
<td>
<p>Should hold: time t, observations as vectors and forecasts as data.frames</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the vignette 'setup-data' on how a data.list must be setup.
</p>
<p>It's simply a list of class <code>data.list</code> holding:
</p>
<p>- vector <code>t</code>
</p>
<p>- vector(s) of observations
</p>
<p>- data.frames (or matrices) of forecast inputs
</p>


<h3>Value</h3>

<p>a data.list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Put together a data.list
# The time vector
time &lt;- seq(ct("2019-01-01"),ct("2019-01-02"),by=3600)
# Observations time series (as vector)
xobs &lt;- rnorm(length(time))
# Forecast input as a data.frame with columns names 'kxx', where 'xx' is the horizon
X &lt;- data.frame(matrix(rnorm(length(time)*3), ncol=3))
names(X) &lt;- pst("k",1:3)

D &lt;- data.list(t=time, xobs=xobs, X=X)

# Check it (see \code{?\link{summary.data.list}})
summary(D)

</code></pre>

<hr>
<h2 id='Dbuilding'>Observations and weather forecasts from a single-family building, weather station and Danish Meteorological Institute (DMI)</h2><span id='topic+Dbuilding'></span>

<h3>Description</h3>

<p>Data of the period from 2010-12-15 to 2011-03-01. The weather station was located within a range of 10 km from the building.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dbuilding
</code></pre>


<h3>Format</h3>

<p>A data list with 1854 rows and 7 variables:
</p>

<dl>
<dt>t</dt><dd><p>Time in GMT as POSIXct</p>
</dd>
<dt>heatload</dt><dd><p>The heatload of a single family building in W</p>
</dd>
<dt>heatloadtotal</dt><dd><p>The average heatload of a 16 single family buildings in W</p>
</dd>
<dt>Taobs</dt><dd><p>Observed ambient temperature at the weather station in Celcius</p>
</dd>
<dt>Iobs</dt><dd><p>Observed global radiation at the weather station in W/m^2</p>
</dd>
<dt>Ta</dt><dd><p>Weather forecasts of ambient temperature up to 36 hours ahead from DMI in Celcius</p>
</dd>
<dt>Ta</dt><dd><p>Weather forecasts of global radiation up to 36 hours ahead from DMI in W/m^2</p>
</dd>
</dl>



<h3>Details</h3>

<p>Hourly average values. The time point is set in the end of the hour.
</p>
<p>Set in the format of a data.list used as input to forecast models in the onlineforecast package.
</p>


<h3>Source</h3>

<p>See <a href="https://onlineforecasting.org/examples/datasets.html">https://onlineforecasting.org/examples/datasets.html</a>.
</p>

<hr>
<h2 id='depth'>Depth of a list</h2><span id='topic+depth'></span>

<h3>Description</h3>

<p>Depth of a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depth(this)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depth_+3A_this">this</code></td>
<td>
<p>list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the depth of a list
</p>


<h3>Value</h3>

<p>integer
</p>

<hr>
<h2 id='flattenlist'>Flattens list</h2><span id='topic+flattenlist'></span>

<h3>Description</h3>

<p>Flattens list in a single list of data.frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flattenlist(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flattenlist_+3A_x">x</code></td>
<td>
<p>List to flatten.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Flattens list. Can maybe be made better. It might end up copying data in
memory!? It might change the order of the elements.
</p>


<h3>Value</h3>

<p>A flatten list
</p>

<hr>
<h2 id='forecastmodel'>Class for forecastmodels</h2><span id='topic+forecastmodel'></span>

<h3>Description</h3>

<p>R6 class for a forecastmodel
</p>


<h3>Details</h3>

<p>This class holds the variables and functions needed for defining and setting up a forecast model - independent of the fitting scheme.
See the vignettes on how to setup and use a model and the website <a href="https://onlineforecasting.org">https://onlineforecasting.org</a> for more info.
</p>
<p>Holds all the information needed independently of the fitting scheme (e.g. lm_fit or rls_fit), see the fields and functions below.
</p>
<p>The fields are separated into:
- Fields for setting up the model
- Fields used when fitting (e.g. which horizons to fit for is set in <code>kseq</code>
</p>
<p>See the fields description below.
</p>
<p>Note, it's an R6 class, hence an object variable is a pointer (reference), which means two important points:
- In order to make a copy, the function clone_deep() must be used (usually <code>clone(deep=TRUE)</code>, but that will end in an infinite loop).
- It can be manimulated directly in functions (without return). The code is written such that no external functions manipulate the model object, except for online updating.
</p>
<p>For online updating (i.e. receiving new data and updating the fit), then the model definition and the data becomes entangled, since transformation functions like low-pass filtering with <code><a href="#topic+lp">lp</a>()</code> requires past values.
See the vignette ??(ref to online vignette, not yet available) and note that <code><a href="#topic+rls_fit">rls_fit</a>()</code> resets the state, which is also done in all <code>xxx_fit</code> functions (e.g. <code><a href="#topic+rls_fit">rls_fit</a></code>.
</p>


<h3>Public fields used for setting up the model</h3>

<p>- output = NA, character: Name of the output.
</p>
<p>- inputs = list(), add them with add_inputs(): List of inputs (which are R6 objects) (note the &quot;cloning of list of reference objects&quot; issue below in deep_clone function)
</p>
<p>- regprmexpr = NA: The expression (as character) used for generating the regprm, e.g. &quot;<code><a href="#topic+rls_prm">rls_prm</a>()</code>&quot; for RLS.
</p>
<p>- regprm = list(): Regression parameters calculated by evaluating the <code>regprmexpr</code>.
</p>
<p>- prmbounds = as.matrix(data.frame(lower=NA, init=NA, upper=NA)): The bounds for optimization of the parameters, e.g. with <code><a href="#topic+rls_optim">rls_optim</a>()</code>.
</p>
<p>- outputrange = NA, numeric vector of length 2: Limits of the predictions cropped in the range, e.g. outputrange = c(0,Inf) removes all negative output predictions.
</p>


<h3>Public fields used when the model is fitted</h3>

<p>- kseq = NA: The horizons to fit for.
</p>
<p>- kseqopt = NA: The horizons to fit for when optimizing.
</p>
<p>- p = NA: The (transformation stage) parameters used for the fit.
</p>
<p>- Lfits = list(): The regression fits, one for each k in kseq (simply a list with the latest fit).
</p>
<p>- datatr = NA: Transformed input data (data.list with all inputs for regression)
</p>


<h3>Public methods</h3>

<p>All public functions are described below and in examples a section for each is included:
</p>


<h3><code>$new()</code></h3>

<p>Create a new 'forecastmodel' object.
</p>
<p>Returns a forecastmodel object.
</p>


<h3><code>$add_inputs(...)</code></h3>

<p>Add inputs to the model.
</p>
<p>- <code>...</code>: The inputs are given as arguments, see examples.
</p>


<h3><code>$add_regprm(regprm_expr)</code></h3>

<p>Add expression (as character) which generates regression parameters.
</p>


<h3><code>$add_prmbounds(...)</code></h3>

<p>Add the transformation parameters and bounds for optimization.
</p>


<h3><code>$get_prmbounds(...)</code></h3>

<p>Get the transformation parameter bounds, used by optimization functions e.g. <code><a href="#topic+rls_optim">rls_optim</a>()</code>.
</p>


<h3><code>$insert_prm(prm)</code></h3>

<p>Insert the transformation parameters prm in the input expressions and regression expressions, and keep them in $prm (simply string manipulation).
</p>


<h3><code>$transform_data(data)</code></h3>

<p>Function for transforming the input data to the regression stage input data (see <code>vignette("setup-data", package = "onlineforecast")</code>).
</p>


<h3><code>$reset_state()</code></h3>

<p>Resets the input states and stored data for iterative fitting (datatr rows and yAR) (see ??(ref to online updating vignette, not yet available).
</p>


<h3><code>$check(data = NA)</code></h3>

<p>Check if the model is setup correctly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># New object
model &lt;- forecastmodel$new()

# Print it
model


# Add model inputs
model$add_inputs(Ta = "lp(Ta)")
# See it
model$inputs
# Update to use no low-pass filter
model$add_inputs(Ta = "Ta")
model$inputs
# Add another
model$add_inputs(I = "lp(I)")
model$inputs

# Simply a list, so manipulate directly
class(model$inputs$Ta)
model$inputs$Ta$expr &lt;- "lp(Ta, a1=0.9)"

# Add the parameters for the regression stage
model$add_regprm("rls_prm(lambda=0.99)")
# The evaluation is a list, which is set in
model$regprm


# Set the lambda to be optimized between 0.9 and 0.999, starting at 0.99
model$add_prmbounds(lambda = c(0.9, 0.99, 0.999))
# Note the "__" syntax to set parameters for inputs: "input__prm"
model$add_prmbounds(Ta__a1 = c(0.8, 0.95, 0.99))

# Get the lower bounds
model$get_prmbounds("lower")

# Insert the init parameters
prm &lt;- model$get_prmbounds("init")
prm
# Before
model$inputs$Ta$expr
# After
model$insert_prm(prm)
model$inputs$Ta$expr

# Check if the model is setup and can be used with a given data.list
# An error is thrown
try(model$check(Dbuilding))
# Add the model output
model$output &lt;- "heatload"
# Still not error free
try(model$check(Dbuilding))
# Add the horizons to fit for
model$kseq &lt;- 1:4
# Finally, no errors :)
model$check(Dbuilding)
</code></pre>

<hr>
<h2 id='fs'>Generation of Fourrier series.</h2><span id='topic+fs'></span>

<h3>Description</h3>

<p>Function for generating Fourrier series as a function of x E.g. use for
harmonic functions for modelling the diurnal patterns or for basis functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs(X, nharmonics)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fs_+3A_x">X</code></td>
<td>
<p>must be a dataframe with columns k1,k2,..., . One period is from 0 to 1
(so for example if X is hour of day, then divide X by 24 to obtain a daily period).</p>
</td></tr>
<tr><td><code id="fs_+3A_nharmonics">nharmonics</code></td>
<td>
<p>the number of harmonics, so creates double as many inputs! i.e. one sine and one cos for each harmonic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of dataframes (two for each i in <code>1:nharmonics</code>) with same number of columns as X.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a data.frame with time of day in hours for different horizons
tday &lt;- make_tday(seq(ct("2019-01-01"), ct("2019-01-04"), by=3600), kseq=1:5)
# See whats in it
str(tday)
head(tday)

# Now use the function to generate Fourier series
L &lt;- fs(tday/24, nharmonics=2)
# See what is in it
str(L)

# Make a plot to see the harmonics
par(mfrow=c(2,1))
# The first harmonic
plot(L$sin1$k1, type="l")
lines(L$cos1$k1, type="l")
# The second harmonic
plot(L$sin2$k1, type="l")
lines(L$cos2$k1, type="l")


</code></pre>

<hr>
<h2 id='getse'>Getting subelement from list.</h2><span id='topic+getse'></span>

<h3>Description</h3>

<p>A helping function for getting subelemlts from a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getse(L, inm = NA, depth = 2, useregex = FALSE, fun = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getse_+3A_l">L</code></td>
<td>
<p>The list to get sub elements from.</p>
</td></tr>
<tr><td><code id="getse_+3A_inm">inm</code></td>
<td>
<p>Either an integer index or a name of the subelements to return.</p>
</td></tr>
<tr><td><code id="getse_+3A_depth">depth</code></td>
<td>
<p>The depth of the subelements to match names in:
- 1: is directly in the list.
- 2: is in list of each element in the list.
- 3 and more: simply deeper in the sublists.</p>
</td></tr>
<tr><td><code id="getse_+3A_useregex">useregex</code></td>
<td>
<p>logical: should inm be used as regex pattern for returning elements matching, in the specified layer.</p>
</td></tr>
<tr><td><code id="getse_+3A_fun">fun</code></td>
<td>
<p>function: if given, then it will be applied to all the matched subelements before returning them.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Often it is needed to get a subelement from a list, which can be done using lapply.
But to make life easiere here is a small function for getting subelements in a nested list at a certain debth.
</p>


<h3>Value</h3>

<p>A list of the matched elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a nested list
L &lt;- list(x1=list(x=list("val11","val112"),
                  y=list("val12"),
                  test=list("testlist2")),
          x2=list(x=list("val21","val212"),
                  y=list("val22"),
                  test=list("testlist2")),
          x3=list(x=list("val31","val312"),
                  y=list("val32"),
                  test=list("testlist3")))

# Get the subelement "x1"
str(getse(L, "x1", depth=1))
# Same as
str(L[["x1"]])

# Get the element named x in second layer
str(getse(L, "x", depth=2))
# Depth is default to 2
str(getse(L, "y"))

# Nice when splitting string
x &lt;- strsplit(c("x.k1","y.k2"), "\\.")
# Get all before the split "\."
getse(x, 1)
# Get after
getse(x, 2)

# Get an element with an integer index
x &lt;- strsplit(c("x.k1","y.k2","x2"), "\\.")
getse(x, 1)
# if the element is not there, then an error is thrown
try(getse(x, 2))

# Use regex pattern for returning elements matching in the specified layer
getse(L, "^te", depth=2, useregex=TRUE)

</code></pre>

<hr>
<h2 id='gof'>Simple wrapper for graphics.off()</h2><span id='topic+gof'></span>

<h3>Description</h3>

<p>Simple wrapper for graphics.off()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof()
</code></pre>

<hr>
<h2 id='in_range'>Selects a period</h2><span id='topic+in_range'></span>

<h3>Description</h3>

<p>Returns a logical vector of boolean values where TRUE indicates if timestamp is within the
specified period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_range(tstart, time, tend = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in_range_+3A_tstart">tstart</code></td>
<td>
<p>The start of the period.</p>
</td></tr>
<tr><td><code id="in_range_+3A_time">time</code></td>
<td>
<p>The timestamps as POSIX.</p>
</td></tr>
<tr><td><code id="in_range_+3A_tend">tend</code></td>
<td>
<p>The end of the period. If not given then the period will have no end.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a logical vector of boolean values where TRUE indicates if timestamp is within the
specified period spanned by tstart and tend. 
</p>
<p>Note the convention of time stamp in the end of the time intervals causes the time point
which equals <code>tstart</code> not to be included. See last example.
</p>
<p>The times can be given as character or POSIX, per default in tz='GMT'.
</p>


<h3>Value</h3>

<p>A logical vector indicating the selected period with TRUE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Take a subset
D &lt;- subset(Dbuilding, c("2010-12-15", "2011-01-01"))

# Just a logical returning TRUE in a specified period
in_range("2010-12-20", D$t, "2010-12-22")

# Set which period to evaluate when optimizing parameters, like in rls_optim()
# (the points with scoreperiod == false are not included in the score evaluation)
D$scoreperiod &lt;- in_range("2010-12-20", D$t)
D$scoreperiod

# Further, excluding a small period by
D$scoreperiod[in_range("2010-12-26", D$t, "2010-12-27")] &lt;- FALSE
D$scoreperiod

# Note the convention of time stamp in the end of the time intervals
# causes the point with t = 2010-12-26 00:00:00 not to be included
# since it's covering to "2010-12-25 23:00:00" to "2010-12-26 00:00:00"
D$t[in_range("2010-12-26", D$t, "2010-12-27")]

# When characters are given, then they are translated to the time zone of the time vector
D &lt;- subset(Dbuilding, c("2010-12-15", "2010-12-16"))
D$t &lt;- ct(D$t, tz="CET")
D$t[in_range("2010-12-15 02:00", D$t, "2010-12-15 05:00")]

</code></pre>

<hr>
<h2 id='input_class'>Class for forecastmodel inputs</h2><span id='topic+input_class'></span>

<h3>Description</h3>

<p>R6 class for for forecastmodel inputs
</p>


<h3>Details</h3>

<p>Holds variables and functions needed for an input, as added by <code><a href="#topic+forecastmodel">forecastmodel</a>$add_inputs()</code>.
</p>
<p>Details of the class.
</p>


<h3>Public fields</h3>

<p>- expr = NA: The expression as string for transforming the input.
</p>
<p>- state_L = list(): The list holding potential state values kept by the function evaluated in the expression.
</p>
<p>- state_i = integer(1):  index counter for the state list.
</p>


<h3>Public methods</h3>

<p>All public functions are described below and in examples a section for each is included:
</p>


<h3><code>$new(expr)</code></h3>

<p>Create a new input with the expression <code>expr</code>.
</p>


<h3><code>$evaluate(data</code></h3>

<p>Generate (transform) the input by evaluating the expr with the <code>data</code> (data.list) attached.
</p>


<h3><code>$state_reset()</code></h3>

<p>Each function in the expressions (lp, fs, etc.) have the possibility to save a state, which can be read next time the are called.
</p>
<p>Reset the state by deleting <code>state_L</code> and setting <code>state_i</code> to 0.
</p>
<p># After running
model$inputs[[1]]$evaluate(D)
# the lp() has saved it's state for next time
model$inputs[[1]]$state_L
# New data arrives
Dnew &lt;- subset(Dbuilding, 11, kseq=1:4)
# So in lp() the state is read and it continues
model$inputs[[1]]$evaluate(Dnew)
</p>
<p># If we want to reset the state, which is done in all _fit() functions (e.g. rls_fit), such that all transformations starts from scratch
# Reset the state
model$inputs[[1]]$evaluate(D)
# Test resetting
model$inputs[[1]]$state_reset()
# Now there is no state
model$inputs[[1]]$evaluate(Dnew)
# So lp() starts by taking the first data point
Dnew$Ta
</p>


<h3><code>$state_getval(initval)</code></h3>

<p>Get the saved value in state. This function can be used in the beginning of transformation functions to get the current state value.
First time called return the <code>initval</code>.
</p>
<p>Note that since all transformation functions are called in the same order,
then the state can be read and saved by keeping a counter internally, the value is saved in the field $state_i.
</p>
<p>See example of use in <code><a href="#topic+lp">lp</a>()</code>.
</p>


<h3><code>$state_setval(val)</code></h3>

<p>Set the state value, done in the end of a transformation function, see above.
</p>
<p>See example of use in <code><a href="#topic+lp">lp</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># new:

# An input is created in a forecastmodel
model &lt;- forecastmodel$new()
model$add_inputs(Ta = "lp(Ta, a1=0.9)")
# The 'inputs' is now a list 
model$inputs
# With the input object
class(model$inputs[[1]])

# Now the transformation stage can be carried out to create the regression stage data
# Take a data.list subset for the example
D &lt;- subset(Dbuilding, 1:10, kseq=1:4)
# Transform the data
model$inputs[[1]]$evaluate(D)
# What happens is simply that the expression is evaluated with the data
# (Note that since not done in the model some functions are missing)
eval(parse(text=model$inputs[[1]]$expr), D)

</code></pre>

<hr>
<h2 id='lagdf'>Lagging which returns a data.frame</h2><span id='topic+lagdf'></span><span id='topic+lagdf.data.frame'></span>

<h3>Description</h3>

<p>Lagging by shifting the values back or fourth always returning a data.frame.
</p>
<p>Lagging of a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lagdf(x, lagseq)

## S3 method for class 'data.frame'
lagdf(x, lagseq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lagdf_+3A_x">x</code></td>
<td>
<p>The data.frame to have columns lagged</p>
</td></tr>
<tr><td><code id="lagdf_+3A_lagseq">lagseq</code></td>
<td>
<p>The sequence of lags as an integer. Alternatively, as a character &quot;+k&quot;, &quot;-k&quot;, &quot;+h&quot; or &quot;-h&quot;, e.g. &quot;k12&quot; will with &quot;+k&quot; be lagged 12.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function lags (shifts) the values of the vector. A data.frame is always returned with the columns
as the vectors lagged with the values in lagseq. The column names are set to &quot;kxx&quot;, where xx are the lag of the column.
</p>
<p>This function lags the columns with the integer values specified with the argument <code>lagseq</code>.
</p>


<h3>Value</h3>

<p>A data.frame.
</p>
<p>A data.frame with columns that are lagged
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lagdf.data.frame">lagdf.data.frame</a></code> which is run when <code>x</code> is a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The values are simply shifted
# Ahead in time
lagdf(1:10, 3)
# Back in time
lagdf(1:10, -3)
# Works but returns a numeric column
lagdf(as.factor(1:10), 3)
# Works and returns a character column
lagdf(as.character(1:10), 3)
# Giving several lag values
lagdf(1:10, c(1:3))
lagdf(1:10, c(5,3,-1))

# See also how to lag a forecast data.frame with: ?lagdf.data.frame



# dataframe of forecasts
X &lt;- data.frame(k1=1:10, k2=1:10, k3=1:10)
X

# Lag all columns
lagdf(X, 1)


# Lag each column different steps
lagdf(X, 1:3)
# Lag each columns with its k value from the column name
lagdf(X, "+k")

# Also works for columns named hxx
names(X) &lt;- gsub("k", "h", names(X))
lagdf(X, "-h")

# If lagseq must have length as columns in X, it doesn't know how to lag and an error is thrown
try(lagdf(X, 1:2))



</code></pre>

<hr>
<h2 id='lagdf.character'>Lagging which returns a data.frame</h2><span id='topic+lagdf.character'></span>

<h3>Description</h3>

<p>Lagging by shifting the values back or fourth always returning a data.frame.
</p>
<p>Lagging of a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'character'
lagdf(x, lagseq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lagdf.character_+3A_x">x</code></td>
<td>
<p>The data.frame to have columns lagged</p>
</td></tr>
<tr><td><code id="lagdf.character_+3A_lagseq">lagseq</code></td>
<td>
<p>The sequence of lags as an integer. Alternatively, as a character &quot;+k&quot;, &quot;-k&quot;, &quot;+h&quot; or &quot;-h&quot;, e.g. &quot;k12&quot; will with &quot;+k&quot; be lagged 12.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function lags (shifts) the values of the vector. A data.frame is always returned with the columns
as the vectors lagged with the values in lagseq. The column names are set to &quot;kxx&quot;, where xx are the lag of the column.
</p>
<p>This function lags the columns with the integer values specified with the argument <code>lagseq</code>.
</p>


<h3>Value</h3>

<p>A data.frame.
</p>
<p>A data.frame with columns that are lagged
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lagdf.data.frame">lagdf.data.frame</a></code> which is run when <code>x</code> is a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The values are simply shifted
# Ahead in time
lagdf(1:10, 3)
# Back in time
lagdf(1:10, -3)
# Works but returns a numeric column
lagdf(as.factor(1:10), 3)
# Works and returns a character column
lagdf(as.character(1:10), 3)
# Giving several lag values
lagdf(1:10, c(1:3))
lagdf(1:10, c(5,3,-1))

# See also how to lag a forecast data.frame with: ?lagdf.data.frame



# dataframe of forecasts
X &lt;- data.frame(k1=1:10, k2=1:10, k3=1:10)
X

# Lag all columns
lagdf(X, 1)


# Lag each column different steps
lagdf(X, 1:3)
# Lag each columns with its k value from the column name
lagdf(X, "+k")

# Also works for columns named hxx
names(X) &lt;- gsub("k", "h", names(X))
lagdf(X, "-h")

# If lagseq must have length as columns in X, it doesn't know how to lag and an error is thrown
try(lagdf(X, 1:2))



</code></pre>

<hr>
<h2 id='lagdf.factor'>Lagging which returns a data.frame</h2><span id='topic+lagdf.factor'></span>

<h3>Description</h3>

<p>Lagging by shifting the values back or fourth always returning a data.frame.
</p>
<p>Lagging of a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'factor'
lagdf(x, lagseq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lagdf.factor_+3A_x">x</code></td>
<td>
<p>The data.frame to have columns lagged</p>
</td></tr>
<tr><td><code id="lagdf.factor_+3A_lagseq">lagseq</code></td>
<td>
<p>The sequence of lags as an integer. Alternatively, as a character &quot;+k&quot;, &quot;-k&quot;, &quot;+h&quot; or &quot;-h&quot;, e.g. &quot;k12&quot; will with &quot;+k&quot; be lagged 12.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function lags (shifts) the values of the vector. A data.frame is always returned with the columns
as the vectors lagged with the values in lagseq. The column names are set to &quot;kxx&quot;, where xx are the lag of the column.
</p>
<p>This function lags the columns with the integer values specified with the argument <code>lagseq</code>.
</p>


<h3>Value</h3>

<p>A data.frame.
</p>
<p>A data.frame with columns that are lagged
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lagdf.data.frame">lagdf.data.frame</a></code> which is run when <code>x</code> is a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The values are simply shifted
# Ahead in time
lagdf(1:10, 3)
# Back in time
lagdf(1:10, -3)
# Works but returns a numeric column
lagdf(as.factor(1:10), 3)
# Works and returns a character column
lagdf(as.character(1:10), 3)
# Giving several lag values
lagdf(1:10, c(1:3))
lagdf(1:10, c(5,3,-1))

# See also how to lag a forecast data.frame with: ?lagdf.data.frame



# dataframe of forecasts
X &lt;- data.frame(k1=1:10, k2=1:10, k3=1:10)
X

# Lag all columns
lagdf(X, 1)


# Lag each column different steps
lagdf(X, 1:3)
# Lag each columns with its k value from the column name
lagdf(X, "+k")

# Also works for columns named hxx
names(X) &lt;- gsub("k", "h", names(X))
lagdf(X, "-h")

# If lagseq must have length as columns in X, it doesn't know how to lag and an error is thrown
try(lagdf(X, 1:2))



</code></pre>

<hr>
<h2 id='lagdf.logical'>Lagging which returns a data.frame</h2><span id='topic+lagdf.logical'></span>

<h3>Description</h3>

<p>Lagging by shifting the values back or fourth always returning a data.frame.
</p>
<p>Lagging of a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'logical'
lagdf(x, lagseq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lagdf.logical_+3A_x">x</code></td>
<td>
<p>The data.frame to have columns lagged</p>
</td></tr>
<tr><td><code id="lagdf.logical_+3A_lagseq">lagseq</code></td>
<td>
<p>The sequence of lags as an integer. Alternatively, as a character &quot;+k&quot;, &quot;-k&quot;, &quot;+h&quot; or &quot;-h&quot;, e.g. &quot;k12&quot; will with &quot;+k&quot; be lagged 12.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function lags (shifts) the values of the vector. A data.frame is always returned with the columns
as the vectors lagged with the values in lagseq. The column names are set to &quot;kxx&quot;, where xx are the lag of the column.
</p>
<p>This function lags the columns with the integer values specified with the argument <code>lagseq</code>.
</p>


<h3>Value</h3>

<p>A data.frame.
</p>
<p>A data.frame with columns that are lagged
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lagdf.data.frame">lagdf.data.frame</a></code> which is run when <code>x</code> is a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The values are simply shifted
# Ahead in time
lagdf(1:10, 3)
# Back in time
lagdf(1:10, -3)
# Works but returns a numeric column
lagdf(as.factor(1:10), 3)
# Works and returns a character column
lagdf(as.character(1:10), 3)
# Giving several lag values
lagdf(1:10, c(1:3))
lagdf(1:10, c(5,3,-1))

# See also how to lag a forecast data.frame with: ?lagdf.data.frame



# dataframe of forecasts
X &lt;- data.frame(k1=1:10, k2=1:10, k3=1:10)
X

# Lag all columns
lagdf(X, 1)


# Lag each column different steps
lagdf(X, 1:3)
# Lag each columns with its k value from the column name
lagdf(X, "+k")

# Also works for columns named hxx
names(X) &lt;- gsub("k", "h", names(X))
lagdf(X, "-h")

# If lagseq must have length as columns in X, it doesn't know how to lag and an error is thrown
try(lagdf(X, 1:2))



</code></pre>

<hr>
<h2 id='lagdf.matrix'>Lagging which returns a data.frame</h2><span id='topic+lagdf.matrix'></span>

<h3>Description</h3>

<p>Lagging by shifting the values back or fourth always returning a data.frame.
</p>
<p>Lagging of a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
lagdf(x, lagseq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lagdf.matrix_+3A_x">x</code></td>
<td>
<p>The data.frame to have columns lagged</p>
</td></tr>
<tr><td><code id="lagdf.matrix_+3A_lagseq">lagseq</code></td>
<td>
<p>The sequence of lags as an integer. Alternatively, as a character &quot;+k&quot;, &quot;-k&quot;, &quot;+h&quot; or &quot;-h&quot;, e.g. &quot;k12&quot; will with &quot;+k&quot; be lagged 12.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function lags (shifts) the values of the vector. A data.frame is always returned with the columns
as the vectors lagged with the values in lagseq. The column names are set to &quot;kxx&quot;, where xx are the lag of the column.
</p>
<p>This function lags the columns with the integer values specified with the argument <code>lagseq</code>.
</p>


<h3>Value</h3>

<p>A data.frame.
</p>
<p>A data.frame with columns that are lagged
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lagdf.data.frame">lagdf.data.frame</a></code> which is run when <code>x</code> is a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The values are simply shifted
# Ahead in time
lagdf(1:10, 3)
# Back in time
lagdf(1:10, -3)
# Works but returns a numeric column
lagdf(as.factor(1:10), 3)
# Works and returns a character column
lagdf(as.character(1:10), 3)
# Giving several lag values
lagdf(1:10, c(1:3))
lagdf(1:10, c(5,3,-1))

# See also how to lag a forecast data.frame with: ?lagdf.data.frame



# dataframe of forecasts
X &lt;- data.frame(k1=1:10, k2=1:10, k3=1:10)
X

# Lag all columns
lagdf(X, 1)


# Lag each column different steps
lagdf(X, 1:3)
# Lag each columns with its k value from the column name
lagdf(X, "+k")

# Also works for columns named hxx
names(X) &lt;- gsub("k", "h", names(X))
lagdf(X, "-h")

# If lagseq must have length as columns in X, it doesn't know how to lag and an error is thrown
try(lagdf(X, 1:2))



</code></pre>

<hr>
<h2 id='lagdf.numeric'>Lagging which returns a data.frame</h2><span id='topic+lagdf.numeric'></span>

<h3>Description</h3>

<p>Lagging by shifting the values back or fourth always returning a data.frame.
</p>
<p>Lagging of a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
lagdf(x, lagseq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lagdf.numeric_+3A_x">x</code></td>
<td>
<p>The data.frame to have columns lagged</p>
</td></tr>
<tr><td><code id="lagdf.numeric_+3A_lagseq">lagseq</code></td>
<td>
<p>The sequence of lags as an integer. Alternatively, as a character &quot;+k&quot;, &quot;-k&quot;, &quot;+h&quot; or &quot;-h&quot;, e.g. &quot;k12&quot; will with &quot;+k&quot; be lagged 12.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function lags (shifts) the values of the vector. A data.frame is always returned with the columns
as the vectors lagged with the values in lagseq. The column names are set to &quot;kxx&quot;, where xx are the lag of the column.
</p>
<p>This function lags the columns with the integer values specified with the argument <code>lagseq</code>.
</p>


<h3>Value</h3>

<p>A data.frame.
</p>
<p>A data.frame with columns that are lagged
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lagdf.data.frame">lagdf.data.frame</a></code> which is run when <code>x</code> is a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The values are simply shifted
# Ahead in time
lagdf(1:10, 3)
# Back in time
lagdf(1:10, -3)
# Works but returns a numeric column
lagdf(as.factor(1:10), 3)
# Works and returns a character column
lagdf(as.character(1:10), 3)
# Giving several lag values
lagdf(1:10, c(1:3))
lagdf(1:10, c(5,3,-1))

# See also how to lag a forecast data.frame with: ?lagdf.data.frame



# dataframe of forecasts
X &lt;- data.frame(k1=1:10, k2=1:10, k3=1:10)
X

# Lag all columns
lagdf(X, 1)


# Lag each column different steps
lagdf(X, 1:3)
# Lag each columns with its k value from the column name
lagdf(X, "+k")

# Also works for columns named hxx
names(X) &lt;- gsub("k", "h", names(X))
lagdf(X, "-h")

# If lagseq must have length as columns in X, it doesn't know how to lag and an error is thrown
try(lagdf(X, 1:2))



</code></pre>

<hr>
<h2 id='lagdl'>Lagging which returns a data.list</h2><span id='topic+lagdl'></span>

<h3>Description</h3>

<p>Lagging by shifting the values back or fourth always returning a data.list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lagdl(DL, lagseq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lagdl_+3A_dl">DL</code></td>
<td>
<p>The data.list to be lagged.</p>
</td></tr>
<tr><td><code id="lagdl_+3A_lagseq">lagseq</code></td>
<td>
<p>The integer(s) setting the lag steps.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function lags (shifts) the values of the vector. A data.list is always returned with each data.frame lagged with <code>lagdf</code>.
</p>


<h3>Value</h3>

<p>A data.list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The values are simply shifted in each data.frame with lagdf

</code></pre>

<hr>
<h2 id='lagvec'>Lag by shifting</h2><span id='topic+lagvec'></span>

<h3>Description</h3>

<p>Lag by shifting the vecter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lagvec(x, lag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lagvec_+3A_x">x</code></td>
<td>
<p>The vector to lag</p>
</td></tr>
<tr><td><code id="lagvec_+3A_lag">lag</code></td>
<td>
<p>(integer) The steps to lag.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A positive value of <code>lag</code> shifts the values to the right in the vector.
</p>


<h3>Value</h3>

<p>The shifted vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The values are simply shifted
# Ahead in time
lagvec(1:10, 3)
# Back in time
lagvec(1:10, -3)
# Works but returns a numric
lagvec(as.factor(1:10), 3)
# Works and returns a character
lagvec(as.character(1:10), 3)

</code></pre>

<hr>
<h2 id='lapply_cbind'>Helper which does lapply and then cbind</h2><span id='topic+lapply_cbind'></span>

<h3>Description</h3>

<p>Helper which does lapply and then cbind
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lapply_cbind(X, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lapply_cbind_+3A_x">X</code></td>
<td>
<p>object to apply on</p>
</td></tr>
<tr><td><code id="lapply_cbind_+3A_fun">FUN</code></td>
<td>
<p>function to apply</p>
</td></tr>
<tr><td><code id="lapply_cbind_+3A_...">...</code></td>
<td>
<p>passed on to lapply</p>
</td></tr>
</table>

<hr>
<h2 id='lapply_cbind_df'>Helper which does lapply, cbind and then as.data.frame</h2><span id='topic+lapply_cbind_df'></span>

<h3>Description</h3>

<p>Helper which does lapply, cbind and then as.data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lapply_cbind_df(X, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lapply_cbind_df_+3A_x">X</code></td>
<td>
<p>object to apply on</p>
</td></tr>
<tr><td><code id="lapply_cbind_df_+3A_fun">FUN</code></td>
<td>
<p>function to apply</p>
</td></tr>
<tr><td><code id="lapply_cbind_df_+3A_...">...</code></td>
<td>
<p>passed on to lapply</p>
</td></tr>
</table>

<hr>
<h2 id='lapply_rbind'>Helper which does lapply and then rbind</h2><span id='topic+lapply_rbind'></span>

<h3>Description</h3>

<p>Helper which does lapply and then rbind
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lapply_rbind(X, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lapply_rbind_+3A_x">X</code></td>
<td>
<p>object to apply on</p>
</td></tr>
<tr><td><code id="lapply_rbind_+3A_fun">FUN</code></td>
<td>
<p>function to apply</p>
</td></tr>
<tr><td><code id="lapply_rbind_+3A_...">...</code></td>
<td>
<p>passed on to lapply</p>
</td></tr>
</table>

<hr>
<h2 id='lapply_rbind_df'>Helper which does lapply, rbind and then as.data.frame</h2><span id='topic+lapply_rbind_df'></span>

<h3>Description</h3>

<p>Helper which does lapply, rbind and then as.data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lapply_rbind_df(X, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lapply_rbind_df_+3A_x">X</code></td>
<td>
<p>object to apply on</p>
</td></tr>
<tr><td><code id="lapply_rbind_df_+3A_fun">FUN</code></td>
<td>
<p>function to apply</p>
</td></tr>
<tr><td><code id="lapply_rbind_df_+3A_...">...</code></td>
<td>
<p>passed on to lapply</p>
</td></tr>
</table>

<hr>
<h2 id='lm_fit'>Fit an onlineforecast model with <code><a href="stats.html#topic+lm">lm</a></code></h2><span id='topic+lm_fit'></span>

<h3>Description</h3>

<p>Fit a linear regression model given a onlineforecast model, seperately for each prediction horizon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_fit(
  prm = NA,
  model,
  data,
  scorefun = NA,
  returnanalysis = TRUE,
  printout = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm_fit_+3A_prm">prm</code></td>
<td>
<p>as numeric with the parameters to be used when fitting.</p>
</td></tr>
<tr><td><code id="lm_fit_+3A_model">model</code></td>
<td>
<p>object of class forecastmodel with the model to be fitted.</p>
</td></tr>
<tr><td><code id="lm_fit_+3A_data">data</code></td>
<td>
<p>as data.list with the data to fit the model on.</p>
</td></tr>
<tr><td><code id="lm_fit_+3A_scorefun">scorefun</code></td>
<td>
<p>Optional. If scorefun is given, e.g. <code><a href="#topic+rmse">rmse</a></code>, then the value of this is also returned.</p>
</td></tr>
<tr><td><code id="lm_fit_+3A_returnanalysis">returnanalysis</code></td>
<td>
<p>as logical determining if the analysis should be returned. See below.</p>
</td></tr>
<tr><td><code id="lm_fit_+3A_printout">printout</code></td>
<td>
<p>Defaults to TRUE. Prints the parameters for model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depends on:
</p>
<p>- If <code>returnanalysis</code> is TRUE a list containing:
</p>
<p>* <code>Yhat</code>: data.frame with forecasts for <code>model$kseq</code> horizons.
</p>
<p>* <code>model</code>: The forecastmodel object cloned deep, so can be modified without changing the original object.
</p>
<p>* <code>data</code>: data.list with the data used, see examples on how to obtain the transformed data.
</p>
<p>* <code>Lfitval</code>: a character &quot;Find the fits in model$Lfits&quot;, it's a list with the lm fits for each horizon.
</p>
<p>* <code>scoreval</code>: data.frame with the scorefun result on each horizon (only scoreperiod is included).
</p>
<p>- If <code>returnanalysis</code> is FALSE (and <code>scorefun</code> is given): The sum of the score function on all horizons (specified with model$kseq).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Take data
D &lt;- subset(Dbuilding, c("2010-12-15", "2011-01-01"))
D$y &lt;- D$heatload
# Define a simple model 
model &lt;- forecastmodel$new()
model$output &lt;- "y"
model$add_inputs(Ta = "lp(Ta, a1=0.9)",
                 mu = "one()")

# Before fitting the model, define which points to include in the evaluation of the score function
D$scoreperiod &lt;- in_range("2010-12-20", D$t)
# And the sequence of horizons to fit for
model$kseq &lt;- 1:6

# Now we can fit the model with RLS and get the model validation analysis data
fit &lt;- lm_fit(prm=NA, model=model, data=D)
# What did we get back?
names(fit)
class(fit)
# The one-step forecast
plot(D$y, type="l")
lines(lagvec(fit$Yhat$k1,-1), col=2)
# Get the residuals
plot(residuals(fit)$h1)
# Score for each horizon
score(residuals(fit))

# The lm_fit don't put anything in this field
fit$Lfitval
# Find the lm fits here
model$Lfits
# See result for k=1 horizon
summary(model$Lfits$k1)
# Some diurnal pattern is present
acf(residuals(fit)$h1, na.action=na.pass, lag.max=96)

# Run with other parameters and return the RMSE
lm_fit(c(Ta__a1=0.8), model, D, scorefun=rmse, returnanalysis=FALSE)
lm_fit(c(Ta__a1=0.9), model, D, scorefun=rmse, returnanalysis=FALSE)

</code></pre>

<hr>
<h2 id='lm_optim'>Optimize parameters for onlineforecast model fitted with LM</h2><span id='topic+lm_optim'></span>

<h3>Description</h3>

<p>Optimize parameters (transformation stage) of LM model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_optim(
  model,
  data,
  kseq = NA,
  scorefun = rmse,
  cachedir = "",
  cachererun = FALSE,
  printout = TRUE,
  method = "L-BFGS-B",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm_optim_+3A_model">model</code></td>
<td>
<p>The onlineforecast model, including inputs, output, kseq, p</p>
</td></tr>
<tr><td><code id="lm_optim_+3A_data">data</code></td>
<td>
<p>The data.list including the variables used in the model.</p>
</td></tr>
<tr><td><code id="lm_optim_+3A_kseq">kseq</code></td>
<td>
<p>The horizons to fit for (if not set, then model$kseq is used)</p>
</td></tr>
<tr><td><code id="lm_optim_+3A_scorefun">scorefun</code></td>
<td>
<p>The function to be score used for calculating the score to be optimized.</p>
</td></tr>
<tr><td><code id="lm_optim_+3A_cachedir">cachedir</code></td>
<td>
<p>A character specifying the path (and prefix) of the cache file name. If set to <code>""</code>, then no cache will be loaded or written. See <a href="https://onlineforecasting.org/vignettes/nice-tricks.html">https://onlineforecasting.org/vignettes/nice-tricks.html</a> for examples.</p>
</td></tr>
<tr><td><code id="lm_optim_+3A_cachererun">cachererun</code></td>
<td>
<p>A logical controlling whether to run the optimization even if the cache exists.</p>
</td></tr>
<tr><td><code id="lm_optim_+3A_printout">printout</code></td>
<td>
<p>A logical determining if the score function is printed out in each iteration of the optimization.</p>
</td></tr>
<tr><td><code id="lm_optim_+3A_method">method</code></td>
<td>
<p>The method argument for <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="lm_optim_+3A_...">...</code></td>
<td>
<p>Additional parameters to <code><a href="stats.html#topic+optim">optim</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper for <code><a href="stats.html#topic+optim">optim</a></code> to enable easy use of bounds and caching in the optimization.
</p>


<h3>Value</h3>

<p>Result object of optim().
Parameters resulting from the optimization can be found from <code>result$par</code>
</p>


<h3>See Also</h3>

<p><code>link{optim}</code> for how to control the optimization and <code><a href="#topic+rls_optim">rls_optim</a></code> which works very similarly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Take data
D &lt;- subset(Dbuilding, c("2010-12-15", "2011-01-01"))
D$y &lt;- D$heatload
# Define a simple model 
model &lt;- forecastmodel$new()
model$add_inputs(Ta = "lp(Ta, a1=0.9)",
                 mu = "one()")
# Before fitting the model, define which points to include in the evaluation of the score function
D$scoreperiod &lt;- in_range("2010-12-20", D$t)
# And the sequence of horizons to fit for
model$kseq &lt;- 1:6

# Now we can fit the model and get the score, as it is
lm_fit(model=model, data=D, scorefun=rmse, returnanalysis=FALSE)
# Or we can change the low-pass filter coefficient
lm_fit(c(Ta__a1=0.99), model, D, rmse, returnanalysis=FALSE)

# This could be passed to optim() (or any optimizer).
# See \code{forecastmodel$insert_prm()} for more details.
optim(c(Ta__a1=0.98), lm_fit, model=model, data=D, scorefun=rmse, returnanalysis=FALSE,
      lower=c(Ta__a1=0.4), upper=c(Ta__a1=0.999), method="L-BFGS-B")

# lm_optim is simply a helper it makes using bounds easiere and enables caching of the results
# First add bounds for lambda (lower, init, upper)
model$add_prmbounds(Ta__a1 = c(0.4, 0.98, 0.999))

# Now the same optimization as above can be done by
val &lt;- lm_optim(model, D)
val


</code></pre>

<hr>
<h2 id='lm_predict'>Prediction with an lm forecast model.</h2><span id='topic+lm_predict'></span>

<h3>Description</h3>

<p>Use a fitted forecast model to predict its output variable with transformed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_predict(model, datatr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm_predict_+3A_model">model</code></td>
<td>
<p>Onlineforecast model object which has been fitted.</p>
</td></tr>
<tr><td><code id="lm_predict_+3A_datatr">datatr</code></td>
<td>
<p>Transformed data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the ??ref(recursive updating vignette, not yet available).
</p>


<h3>Value</h3>

<p>The Yhat forecast matrix with a forecast for each model$kseq and for each time point in <code>datatr$t</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Take data
D &lt;- subset(Dbuilding, c("2010-12-15", "2011-01-01"))
D$y &lt;- D$heatload
# Define a model 
model &lt;- forecastmodel$new()
model$add_inputs(Ta = "lp(Ta, a1=0.7)", mu = "one()")

# Before fitting the model, define which points to include in the evaluation of the score function
D$scoreperiod &lt;- in_range("2010-12-20", D$t)
# And the sequence of horizons to fit for
model$kseq &lt;- 1:6

# Transform using the mdoel
datatr &lt;- model$transform_data(D)

# See the transformed data
str(datatr)

# The model has not been fitted
model$Lfits

# To fit
lm_fit(model=model, data=D)

# Now the fits for each horizon are there (the latest update)
# For example 
summary(model$Lfits$k1)

# Use the fit for prediction
D$Yhat &lt;- lm_predict(model, datatr)

# Plot it
plot_ts(D, c("y|Yhat"), kseq=1)

</code></pre>

<hr>
<h2 id='long_format'>Long format of prediction data.frame</h2><span id='topic+long_format'></span>

<h3>Description</h3>

<p>Creates a long format of the predictions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>long_format(fit, Time = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="long_format_+3A_fit">fit</code></td>
<td>
<p>The result from either lm_fit or rls_fit</p>
</td></tr>
<tr><td><code id="long_format_+3A_time">Time</code></td>
<td>
<p>If the timestamps are missing from the fit object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions creates a useful prediction data.frame which can be useful for analysis and plotting.
</p>


<h3>Value</h3>

<p>Data.frame of when the prediction where made, also the prediction value and timestamp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Take data
D &lt;- subset(Dbuilding, c("2010-12-15", "2011-01-01"))
D$y &lt;- D$heatload
D$scoreperiod &lt;- in_range("2010-12-20", D$t)
# Define a model
model &lt;- forecastmodel$new()
model$add_inputs(Ta = "Ta",
                 mu = "one()")
model$add_regprm("rls_prm(lambda=0.99)")
model$kseq &lt;- 1:6
# Fit it
fit &lt;- rls_fit(prm=c(lambda=0.99), model, D)

# Get the forecasts (in fit$Yhat) on long format
long_format(fit)

</code></pre>

<hr>
<h2 id='lp'>First-order low-pass filtering</h2><span id='topic+lp'></span>

<h3>Description</h3>

<p>First-order low-pass filtering of time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lp(X, a1, usestate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lp_+3A_x">X</code></td>
<td>
<p>Dataframe or matrix (or list of them) of forecasts in columns to be low-pass filtered.</p>
</td></tr>
<tr><td><code id="lp_+3A_a1">a1</code></td>
<td>
<p>The low-pass filter coefficient.</p>
</td></tr>
<tr><td><code id="lp_+3A_usestate">usestate</code></td>
<td>
<p>logical: Use the state kept in the model$input? if <code>lp()</code> is used outside model$transform_data(), then it must be set to FALSE, otherwise the input$state (which is not there) will be read leading to an error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies a first order unity gain low-pass filter to the columns of <code>X</code>.
The low-pass filter is applied to each column seperately. The stationary gain of the filter i one.
</p>
<p>If a list of dataframes (or matrices) is given, then the low-pass filtering is recursively applied on each.
</p>


<h3>Value</h3>

<p>The low-pass filtered dataframe (as a matrix)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a dataframe for the examples
X &lt;- data.frame(k1=rep(c(0,1),each=5))
X$k2 &lt;- X$k1
Xf &lt;- lp(X, 0.5, usestate=FALSE)
Xf

# See the input and the low-pass filtered result
plot(X$k1)
lines(Xf[ ,"k1"])
# Slower response with higher a1 value
lines(lp(X, 0.8, usestate=FALSE)[ ,"k1"])

# If a list of dataframes is given, then lp() is recursively applied on each
lp(list(X,X), 0.5, usestate=FALSE)


</code></pre>

<hr>
<h2 id='lp_vector'>First-order low-pass filtering</h2><span id='topic+lp_vector'></span>

<h3>Description</h3>

<p>First-order low-pass filtering of a time series vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lp_vector(x, a1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lp_vector_+3A_x">x</code></td>
<td>
<p>vector.</p>
</td></tr>
<tr><td><code id="lp_vector_+3A_a1">a1</code></td>
<td>
<p>The low-pass filter coefficient.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies a first order unity gain low-pass filter vector.
</p>
<p>The <code>lp_vector_cpp</code> function does the same much faster.
</p>


<h3>Value</h3>

<p>The low-pass filtered vector
</p>

<hr>
<h2 id='lp_vector_cpp'>Low pass filtering of a vector.</h2><span id='topic+lp_vector_cpp'></span>

<h3>Description</h3>

<p>This function returns a vector which is x through a unity gain first-order low-pass filter.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="lp_vector_cpp_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="lp_vector_cpp_+3A_a1">a1</code></td>
<td>
<p>the first order low-pass filter coefficient</p>
</td></tr>
</table>

<hr>
<h2 id='make_input'>Make a forecast matrix (as data.frame) from observations.</h2><span id='topic+make_input'></span>

<h3>Description</h3>

<p>This function creates a data.frame with columns for each horizon such that it can be 
added to a data.list and used in a forecast model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_input(observations, kseq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_input_+3A_observations">observations</code></td>
<td>
<p>vector of observations.</p>
</td></tr>
<tr><td><code id="make_input_+3A_kseq">kseq</code></td>
<td>
<p>vector of integers, respresenting the desired &quot;k-steps ahead&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a forecast matrix (as a data.frame) with simply the observation vector copied to each column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data for example
D &lt;- subset(Dbuilding, c("2010-12-15","2010-12-20"))

# Generate the input
make_input(D$heatload, 1:4)

# Set is in D, such that it can be used in input expressions (e.g. by model$add_inputs(AR = "Ar0")
D$AR0 &lt;- make_input(D$heatload, 1:36)

</code></pre>

<hr>
<h2 id='make_periodic'>Make an forecast matrix with a periodic time signal.</h2><span id='topic+make_periodic'></span>

<h3>Description</h3>

<p>This function creates a data.frame with k-steps-ahead values of a periodic time signal,
such that it can be added to a data.list and used inputs to a forecast model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_periodic(time, kseq, period, offset = 0, tstep = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_periodic_+3A_time">time</code></td>
<td>
<p>vector of times of class &quot;POSIXct&quot; &quot;POSIXt&quot;.</p>
</td></tr>
<tr><td><code id="make_periodic_+3A_kseq">kseq</code></td>
<td>
<p>vector of integers, representing the desired &quot;k-steps ahead&quot;.</p>
</td></tr>
<tr><td><code id="make_periodic_+3A_period">period</code></td>
<td>
<p>a numeric setting the length of the period in seconds.</p>
</td></tr>
<tr><td><code id="make_periodic_+3A_offset">offset</code></td>
<td>
<p>a numeric setting an offset in the period start in seconds.</p>
</td></tr>
<tr><td><code id="make_periodic_+3A_tstep">tstep</code></td>
<td>
<p>step time of k in seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a forecast matrix (data.frame) with rownames = times, colnames = k1, k2, k3, ...
The content of the data frame is the hour of day.
</p>


<h3>See Also</h3>

<p>make_tday
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a time sequence of 30 min sample period
tseq &lt;- seq(ct("2019-01-01"), ct("2019-02-01 12:00"), by=1800)

# Make the three hourly periodic sequence
make_periodic(tseq, 1:10, 3*3600)

# With an offset of one hour
make_periodic(tseq, 1:10, 3*3600, 3600)

</code></pre>

<hr>
<h2 id='make_tday'>Make an hour-of-day forecast matrix</h2><span id='topic+make_tday'></span>

<h3>Description</h3>

<p>This function creates a data.frame with k-steps-ahead values of hour of day,
such that it can be added to a data.list and used inputs to a forecast model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_tday(time, kseq, tstep = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_tday_+3A_time">time</code></td>
<td>
<p>vector of times of class &quot;POSIXct&quot; &quot;POSIXt&quot;.</p>
</td></tr>
<tr><td><code id="make_tday_+3A_kseq">kseq</code></td>
<td>
<p>vector of integers, representing the desired &quot;k-steps ahead&quot;.</p>
</td></tr>
<tr><td><code id="make_tday_+3A_tstep">tstep</code></td>
<td>
<p>step time of k in seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a forecast matrix (data.frame) with rownames = times, colnames = k1, k2, k3, ...
The content of the data frame is the hour of day.
</p>


<h3>See Also</h3>

<p>make_periodic
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a time sequence of 30 min sample period
tseq &lt;- seq(ct("2019-01-01"), ct("2019-02-01 12:00"), by=1800)

# Make the time of day sequence (assuming time between k steps is same as for tseq)
make_tday(tseq, 1:10)

# With 0.5 hour steps, kstep in hours
make_tday(tseq, 1:10, tstep=3600)


</code></pre>

<hr>
<h2 id='nams'>Return the column names</h2><span id='topic+nams'></span><span id='topic+nams+3C-'></span>

<h3>Description</h3>

<p>Return the column names of a dataframe or a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nams(x)

nams(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nams_+3A_x">x</code></td>
<td>
<p>The matrix or data.frame to set the column names for.</p>
</td></tr>
<tr><td><code id="nams_+3A_value">value</code></td>
<td>
<p>The names to be given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simply to have a single function for returning the column names, instead of
<code>colnames()</code> for a <code>matrix</code> and <code>names()</code> for a <code>data.frame</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate a matrix
X &lt;- matrix(1, nrow=2, ncol=3)
colnames(X) &lt;- c("c1","c2","c3")
D &lt;- as.data.frame(X)

# Annoyingly this fails (for a matrix)
## Not run: names(X)
# Could use this everywhere
colnames(D)
# but this is shorter
nams(X)
nams(D)

# Also for assignment
nams(D) &lt;- c("x1","x2","x3")
nams(D)

</code></pre>

<hr>
<h2 id='one'>Create ones for model input intercept</h2><span id='topic+one'></span>

<h3>Description</h3>

<p>Returns a data.frame of ones which can be used in forecast model inputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one()
</code></pre>


<h3>Details</h3>

<p>The function returns ones which can be used to generate ones, e.g. to be used as a intercept for a model.
</p>
<p>See vignettes 'setup-data' and 'setup-and-use-model'.
</p>


<h3>Value</h3>

<p>A data.frame of ones
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A model
model &lt;- forecastmodel$new()
# Use the function in the input definition
model$add_inputs(mu = "one()")
# Set the forecast horizons
model$kseq &lt;- 1:4
# During the transformation stage the one will be generated for the horizons
model$transform_data(subset(Dbuilding, 1:7))

</code></pre>

<hr>
<h2 id='pairs.data.list'>Generation of pairs plot for a data.list.</h2><span id='topic+pairs.data.list'></span>

<h3>Description</h3>

<p>Generate a pairs plot for the vectors in the data.list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.list'
pairs(
  x,
  subset = NA,
  nms = NA,
  kseq = NA,
  lagforecasts = TRUE,
  pattern = NA,
  lower.panel = NULL,
  panel = panel.smooth,
  pch = 20,
  cex = 0.7,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs.data.list_+3A_x">x</code></td>
<td>
<p>The data.list from which to plot.</p>
</td></tr>
<tr><td><code id="pairs.data.list_+3A_subset">subset</code></td>
<td>
<p>The subset to be included. Passed to <code><a href="#topic+subset.data.list">subset.data.list</a>()</code>.</p>
</td></tr>
<tr><td><code id="pairs.data.list_+3A_nms">nms</code></td>
<td>
<p>The names of the variables to be included. Passed to <code><a href="#topic+subset.data.list">subset.data.list</a>()</code>.</p>
</td></tr>
<tr><td><code id="pairs.data.list_+3A_kseq">kseq</code></td>
<td>
<p>The horizons to be included. Passed to <code><a href="#topic+subset.data.list">subset.data.list</a>()</code>.</p>
</td></tr>
<tr><td><code id="pairs.data.list_+3A_lagforecasts">lagforecasts</code></td>
<td>
<p>Lag the forecasts such that they are synced with obervations. Passed to <code><a href="#topic+subset.data.list">subset.data.list</a>()</code>.</p>
</td></tr>
<tr><td><code id="pairs.data.list_+3A_pattern">pattern</code></td>
<td>
<p>Regex pattern to select the included variables. Passed to <code><a href="#topic+subset.data.list">subset.data.list</a>()</code>.</p>
</td></tr>
<tr><td><code id="pairs.data.list_+3A_lower.panel">lower.panel</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+pairs">pairs</a>()</code>.</p>
</td></tr>
<tr><td><code id="pairs.data.list_+3A_panel">panel</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+pairs">pairs</a>()</code>.</p>
</td></tr>
<tr><td><code id="pairs.data.list_+3A_pch">pch</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+pairs">pairs</a>()</code>.</p>
</td></tr>
<tr><td><code id="pairs.data.list_+3A_cex">cex</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+pairs">pairs</a>()</code>.</p>
</td></tr>
<tr><td><code id="pairs.data.list_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+pairs">pairs</a>()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A very useful plot for checking what is in the forecasts, how they are synced and match the observations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Take a subset for the example
D &lt;- subset(Dbuilding, c("2010-12-15","2011-01-15"), pattern="^Ta|^I", kseq=1:3)
pairs(D)

# If the forecasts and the observations are not aligned in time,
# which is easy to see by comparing to the previous plot.
pairs(D, lagforecasts=FALSE)
# Especially for the solar I syncronization is really important!
# Hence if the forecasts were not synced properly, then it can be detected using this type of plot.

# Alternatively, lag when taking the subset
D &lt;- subset(Dbuilding, c("2010-12-15","2011-01-15"), pattern="^Ta|^I", kseq=1:3, lagforecasts=TRUE)
pairs(D, lagforecasts=FALSE)

</code></pre>

<hr>
<h2 id='par_ts'>Set parameters for <code><a href="#topic+plot_ts">plot_ts</a>()</code></h2><span id='topic+par_ts'></span>

<h3>Description</h3>

<p>Set parameters for <code><a href="#topic+plot_ts">plot_ts</a>()</code> globally
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par_ts(fromoptions = FALSE, p = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par_ts_+3A_fromoptions">fromoptions</code></td>
<td>
<p>logical: Read the list of parameters set in <code><a href="base.html#topic+options">options</a>("par_ts")$par_ts</code>, then the additional parameters set in <code>...</code> are replaced before the list is returned.</p>
</td></tr>
<tr><td><code id="par_ts_+3A_p">p</code></td>
<td>
<p>List of the parameters, as returned by the function itself. If given, the additional parameters set in <code>...</code> are replaced before the list is returned.</p>
</td></tr>
<tr><td><code id="par_ts_+3A_...">...</code></td>
<td>
<p>any of the following parameters can be set replacing the default values:
</p>
<p><code>xnm</code> &quot;t&quot;: The name of the time
</p>
<p><code>legendspace</code> 10:
Horizontal space for the lengend in character spaces
</p>
<p><code>legendcex</code> 1: Scaling of the legend
</p>
<p><code>legendrangeshow</code> TRUE: Include the range for each variable in the legend
</p>
<p><code>ylimextend</code> c(lower,upper): Extend the ylim for each plot with a proportion, seperately for the lower and upper limit
</p>
<p><code>yaxisextend</code> c(lower,upper): Extend the yaxis for each plot with a proportion, seperately for the lower and upper limit
</p>
<p><code>mainsline</code> (numeric): with the <code>line</code> for the main in the plots.
</p>
<p><code>cex</code> (numeric): The cex to use for the <code>plot_ts</code> plots.
</p>
<p><code>plotfun</code>: The function used for plotting, as default <code>lines</code>.
</p>
<p><code>xaxisformat</code> (character): The format of the xaxis, see <code><a href="base.html#topic+strptime">strptime</a>()</code>.
</p>
<p><code>colorramp</code> colorRampPalette: The colorramp used for setting multiple colors in each plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Often in a report some plot parameters must be set for all plots, which is done with <code><a href="graphics.html#topic+par">par</a>()</code>.
</p>
<p>The parameters which are general for <code><a href="#topic+plot_ts">plot_ts</a>()</code> can be set and saved in <code><a href="base.html#topic+options">options</a>()</code>,
and they will then be applied as default in all calls to plot_ts(). See the examples how to do this.
</p>
<p>If any of these parameters are given to <code><a href="#topic+plot_ts">plot_ts</a>()</code>, then it will be used over the default.
</p>


<h3>Value</h3>

<p>A list of the parameters above, which can be set globally (see examples) or passed to <code><a href="#topic+plot_ts">plot_ts</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data for plots
D &lt;- subset(Dbuilding, 1:192)

# See the parameters which can be set
p &lt;- par_ts()
names(p)
p$xnm

# Using the default values
plot_ts(D, c("heatload","Ta"), kseq=1:24)

# Set the parameters directly
plot_ts(D, c("heatload","Ta"), kseq=1:24, legendcex=0.8, legendspace=8)

# Set parameters to be given in a list
p &lt;- par_ts()
p$legendcex &lt;- 0.8
p$legendspace &lt;- 8

# Use those parameters
plot_ts(D, c("heatload","Ta"), kseq=1:24, p=p)

# Set globally (if not set specifed the default values will be used)
options(par_ts=p)

# Now the global parameters will be used
plot_ts(D, c("heatload","Ta"), kseq=1:24)

# Still providing a parameter directly it will used, e.g. change the plotting function
plot_ts(D, c("heatload","Ta"), kseq=1:24, plotfun=points)

# Control more precisely the plotting function
plot_ts(D, c("heatload","Ta"), kseq=1:24, plotfun=function(x, ...){ points(x, type="b", ...)})

# Another colorramp function
p$colorramp &lt;- rainbow
options(par_ts=p)
plot_ts(D, c("heatload","Ta"), kseq=1:24)

</code></pre>

<hr>
<h2 id='pbspline'>Wrapper for <code>bspline</code> with <code>periodic=TRUE</code></h2><span id='topic+pbspline'></span>

<h3>Description</h3>

<p>Wrapper for <code>bspline</code> with <code>periodic=TRUE</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbspline(
  X,
  Boundary.knots = NA,
  intercept = FALSE,
  df = NULL,
  knots = NULL,
  degree = 3,
  bknots = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pbspline_+3A_x">X</code></td>
<td>
<p>see <code>?bspline</code></p>
</td></tr>
<tr><td><code id="pbspline_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>see <code>?bspline</code></p>
</td></tr>
<tr><td><code id="pbspline_+3A_intercept">intercept</code></td>
<td>
<p>see <code>?bspline</code></p>
</td></tr>
<tr><td><code id="pbspline_+3A_df">df</code></td>
<td>
<p>see <code>?bspline</code></p>
</td></tr>
<tr><td><code id="pbspline_+3A_knots">knots</code></td>
<td>
<p>see <code>?bspline</code></p>
</td></tr>
<tr><td><code id="pbspline_+3A_degree">degree</code></td>
<td>
<p>see <code>?bspline</code></p>
</td></tr>
<tr><td><code id="pbspline_+3A_bknots">bknots</code></td>
<td>
<p>see <code>?bspline</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simply a wrapper.
</p>


<h3>See Also</h3>

<p>Other Transform stage functions: 
<code><a href="#topic+bspline">bspline</a>()</code>
</p>

<hr>
<h2 id='persistence'>Generate persistence forecasts</h2><span id='topic+persistence'></span>

<h3>Description</h3>

<p>Generate persistence and periodic persistence forecasts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>persistence(y, kseq, perlen = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="persistence_+3A_y">y</code></td>
<td>
<p>(numeric) The model output to be forecasted.</p>
</td></tr>
<tr><td><code id="persistence_+3A_kseq">kseq</code></td>
<td>
<p>(integer) The horizons to be forecasted.</p>
</td></tr>
<tr><td><code id="persistence_+3A_perlen">perlen</code></td>
<td>
<p>(integer) The period length for seasonal persistence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generate a forecast matrix using persistence. The simple persistence is with the current value of y, i.e. the value at time t is used as forecast
</p>
<p>A seasonal persistence with a specific period can be generated by setting the argument <code>perlen</code> to the length of the period in steps. The value used for the forecast is then the latest available, which is matches the seasonality for time t+k, see the examples.
</p>


<h3>Value</h3>

<p>Forecast matrix as a <code>data.frame</code> (named <code>Yhat</code> in similar functions)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simple persistence just copies the current value for the forecasts
persistence(1:10, kseq=1:4)

# Seasonal persistence takes the value perlen steps back
persistence(1:10, kseq=1:4, perlen=4)

# If the horizons are longer than perlen, then the perlen*i steps back is taken (i is an integer)
persistence(1:10, kseq=1:12, perlen=4)


</code></pre>

<hr>
<h2 id='plot_ts'>Time series plotting</h2><span id='topic+plot_ts'></span><span id='topic+plot_ts.data.list'></span><span id='topic+plot_ts.data.frame'></span><span id='topic+plot_ts.matrix'></span><span id='topic+plot_ts_iseq'></span><span id='topic+plot_ts_series'></span><span id='topic+plot_ts.rls_fit'></span><span id='topic+plotly_ts'></span>

<h3>Description</h3>

<p>Plot time series of observations and forecasts (lagged to be aligned in time).
</p>
<p>Plot forecasts, residuals, cumulated residuals and RLS coefficients
</p>
<p>Simply the same as <code><a href="#topic+plot_ts">plot_ts</a>()</code> with <code>usely=TRUE</code>, such that plotly is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ts(
  object,
  patterns = ".*",
  xlim = NA,
  ylims = NA,
  xlab = "",
  ylabs = NA,
  mains = "",
  mainouter = "",
  legendtexts = NA,
  colormaps = NA,
  xat = NA,
  usely = FALSE,
  plotit = TRUE,
  p = NA,
  ...
)

## S3 method for class 'data.list'
plot_ts(
  object,
  patterns = ".*",
  xlim = NA,
  ylims = NA,
  xlab = "",
  ylabs = NA,
  mains = "",
  mainouter = "",
  legendtexts = NA,
  colormaps = NA,
  xat = NA,
  usely = FALSE,
  plotit = TRUE,
  p = NA,
  kseq = NA,
  ...
)

## S3 method for class 'data.frame'
plot_ts(
  object,
  patterns = ".*",
  xlim = NA,
  ylims = NA,
  xlab = "",
  ylabs = NA,
  mains = NA,
  mainouter = "",
  legendtexts = NA,
  colormaps = NA,
  xat = NA,
  usely = FALSE,
  plotit = TRUE,
  p = NA,
  namesdata = NA,
  ...
)

## S3 method for class 'matrix'
plot_ts(
  object,
  patterns = ".*",
  xlim = NA,
  ylims = NA,
  xlab = "",
  ylabs = NA,
  mains = NA,
  mainouter = "",
  legendtexts = NA,
  colormaps = NA,
  xat = NA,
  usely = FALSE,
  plotit = TRUE,
  p = NA,
  namesdata = NA,
  ...
)

plot_ts_iseq(data, pattern, xnm, namesdata)

plot_ts_series(
  data,
  pattern,
  iplot = 1,
  ylim = NA,
  xlab = "",
  main = "",
  mainline = -1.2,
  colormap = NA,
  legendtext = NA,
  xat = NA,
  plotit = TRUE,
  p = NA,
  namesdata = NA,
  xaxis = TRUE,
  ...
)

## S3 method for class 'rls_fit'
plot_ts(
  object,
  patterns = c("^y$|^Yhat$", "^Residuals$", "CumAbsResiduals$", pst("^",
    names(fit$Lfitval[[1]]), "$")),
  xlim = NA,
  ylims = NA,
  xlab = "",
  ylabs = NA,
  mains = "",
  mainouter = "",
  legendtexts = NA,
  colormaps = NA,
  xat = NA,
  usely = FALSE,
  plotit = TRUE,
  p = NA,
  kseq = NA,
  ...
)

plotly_ts(
  object,
  patterns = ".*",
  xlim = NA,
  ylims = NA,
  xlab = "",
  ylabs = NA,
  mains = "",
  mainouter = "",
  legendtexts = NA,
  colormaps = NA,
  xat = NA,
  usely = FALSE,
  p = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_ts_+3A_object">object</code></td>
<td>
<p>A <code>data.list</code> or <code>data.frame</code> with observations and forecasts, note diffe</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_patterns">patterns</code></td>
<td>
<p>See <code><a href="#topic+plot_ts">plot_ts</a></code>. The default pattern finds the generated series in the function, '!!RLSinputs!!' will be replaced with the names of the RLS inputs (regression stage inputs).</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_xlim">xlim</code></td>
<td>
<p>The time range as a character of length 2 and form &quot;YYYY-MM-DD&quot; or POSIX. Date to start and end the plot.</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_ylims">ylims</code></td>
<td>
<p>The <code>ylim</code> for each plot given in a list.</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_xlab">xlab</code></td>
<td>
<p>A character with the label for the x-axis.</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_ylabs">ylabs</code></td>
<td>
<p>A character vector with labels for the y-axes.</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_mains">mains</code></td>
<td>
<p>A character vector with the main for each plot.</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_mainouter">mainouter</code></td>
<td>
<p>A character with the main at the top of the plot (can also be added afterwards with <code>title(main, outer=TRUE)</code>).</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_legendtexts">legendtexts</code></td>
<td>
<p>A list with the legend texts for each plot (replaces the names of the variables).</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_colormaps">colormaps</code></td>
<td>
<p>A list of colormaps, which will be used in each plot.</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_xat">xat</code></td>
<td>
<p>POSIXt specifying where the ticks on x-axis should be put.</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_usely">usely</code></td>
<td>
<p>If TRUE then plotly will be used.</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_plotit">plotit</code></td>
<td>
<p>If FALSE then the plot will not be generated, only data returned.</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_p">p</code></td>
<td>
<p>The plot_ts parameters in a list, as generated with the function <code><a href="#topic+par_ts">par_ts</a>()</code>.</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_...">...</code></td>
<td>
<p>Parameters passed to <code><a href="#topic+par_ts">par_ts</a></code>, see the list of parameters in <code>?<a href="#topic+par_ts">par_ts</a></code>.</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_kseq">kseq</code></td>
<td>
<p>For <code>class(object)=="data.list"</code> an integer vector, default = NA. Control which forecast horizons to include in the plots. If NA all the horizons will be included.</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_namesdata">namesdata</code></td>
<td>
<p>For <code>class(object)=="data.frame"</code> a character vector. Names of columns in object to be searched in, instead of <code>names(object)</code>.</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_data">data</code></td>
<td>
<p>The data.frame from where to find columns to plot</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_pattern">pattern</code></td>
<td>
<p>The regex pattern</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_xnm">xnm</code></td>
<td>
<p>The name of the column</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_iplot">iplot</code></td>
<td>
<p>The plot index</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_ylim">ylim</code></td>
<td>
<p>ylim in the plot</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_main">main</code></td>
<td>
<p>main title</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_mainline">mainline</code></td>
<td>
<p>line for the main title</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_colormap">colormap</code></td>
<td>
<p>the colormap for the lines</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_legendtext">legendtext</code></td>
<td>
<p>Text for the legend</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_xaxis">xaxis</code></td>
<td>
<p>Boolean determining to include the xaxis</p>
</td></tr>
<tr><td><code id="plot_ts_+3A_fit">fit</code></td>
<td>
<p>An <code>rls_fit</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates time series plots depending on the variables matched by each regular expression given in the <code>patterns</code> argument.
</p>
<p>The forecasts matrices in the <code>data.list</code> given in <code>object</code> will be lagged to be aligned in time (i.e. k-step forecasts will be lagged by k).
</p>
<p>Use the plotly package if argument <code>usely</code> is TRUE, see <code><a href="#topic+plotly_ts">plotly_ts</a>()</code>.
</p>
<p>A useful plot for residual analysis and model validation of an RLS fitted forecast model.
</p>
<p>All parameters, except those described below, are simply passed to <code><a href="#topic+plot_ts">plot_ts</a>()</code>.
</p>
<p>The <code>plotly</code> package must be installed and loaded.
</p>
<p>Note that the plot parameters set with <code><a href="#topic+par_ts">par_ts</a>()</code> have no effect on the <code>plotly</code> plots.
</p>
<p>See <a href="https://onlineforecasting.org/vignettes/nice-tricks.html">https://onlineforecasting.org/vignettes/nice-tricks.html</a>.
</p>


<h3>Value</h3>

<p>A list with a data.frame with the data for each plot, if usely=TRUE, then a list of the figures (drawn with print(subplot(L, shareX=TRUE, nrows=length(L), titleY = TRUE))).
</p>
<p>The plotted data in a <code>data.list</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+par_ts">par_ts</a></code> for setting plot control parameters.
</p>
<p><code><a href="base.html#topic+regex">regex</a></code> for regular expressions to select which variables to plot.
</p>
<p><code><a href="#topic+plot_ts">plot_ts</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Time series plots for \code{data.list}, same as for \code{data.frame} except use of \code{kseq}
D &lt;- Dbuilding
plot_ts(D, c("heatload","Ta"), kseq=c(1,24))
# Make two plots (and set the space for the legend)
plot_ts(D, c("heatload","Ta"), kseq=c(1,24), legendspace=11)
# Only the Ta observations 
plot_ts(D, c("heatload","Taobs$"), kseq=c(1,24), legendspace=11)

# Give labels
plot_ts(D, c("heatload","Ta"), kseq=c(1,24), xlab="Time", ylabs=c("Heat (kW)","Temperature (C)"))
# Mains (see mainsline in par_ts())
plot_ts(D, c("heatload","Ta"), kseq=c(1,24), mains=c("Heatload","Temperature"), mainsline=c(-1,-2))

# Format of the xaxis (see par_ts())
plot_ts(D, c("heatload","Ta"), kseq=c(1,24), xaxisformat="%Y-%m-%d %H:%m")

# Return the data, for other plots etc.
L &lt;- plot_ts(D, c("heatload","Ta"), kseq=c(1,24))
names(L[[1]])
names(L[[2]])



# Fit a model (see vignette 'setup-and-use-model'
D &lt;- Dbuilding
D$scoreperiod &lt;- in_range("2010-12-22", D$t)
model &lt;- forecastmodel$new()
model$output = "heatload"
model$add_inputs(Ta = "Ta",
                 mu = "one()")
model$add_regprm("rls_prm(lambda=0.9)")
model$kseq &lt;- c(3,18)
fit1 &lt;- rls_fit(NA, model, D, returnanalysis = TRUE)

# Plot it
plot_ts(fit1)

# Return the data
Dplot &lt;- plot_ts(fit1)

# The RLS coefficients are now in a nice format
head(Dplot$mu)


# See the website link above

</code></pre>

<hr>
<h2 id='plotly_ts.data.frame'>Time series plotting</h2><span id='topic+plotly_ts.data.frame'></span>

<h3>Description</h3>

<p>Plot time series of observations and forecasts (lagged to be aligned in time).
</p>
<p>Plot forecasts, residuals, cumulated residuals and RLS coefficients
</p>
<p>Simply the same as <code><a href="#topic+plot_ts">plot_ts</a>()</code> with <code>usely=TRUE</code>, such that plotly is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
plotly_ts(
  object,
  patterns = ".*",
  xlim = NA,
  ylims = NA,
  xlab = "",
  ylabs = NA,
  mains = "",
  mainouter = "",
  legendtexts = NA,
  colormaps = NA,
  xat = NA,
  usely = TRUE,
  p = NA,
  namesdata = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotly_ts.data.frame_+3A_object">object</code></td>
<td>
<p>A <code>data.list</code> or <code>data.frame</code> with observations and forecasts, note diffe</p>
</td></tr>
<tr><td><code id="plotly_ts.data.frame_+3A_patterns">patterns</code></td>
<td>
<p>See <code><a href="#topic+plot_ts">plot_ts</a></code>. The default pattern finds the generated series in the function, '!!RLSinputs!!' will be replaced with the names of the RLS inputs (regression stage inputs).</p>
</td></tr>
<tr><td><code id="plotly_ts.data.frame_+3A_xlim">xlim</code></td>
<td>
<p>The time range as a character of length 2 and form &quot;YYYY-MM-DD&quot; or POSIX. Date to start and end the plot.</p>
</td></tr>
<tr><td><code id="plotly_ts.data.frame_+3A_ylims">ylims</code></td>
<td>
<p>The <code>ylim</code> for each plot given in a list.</p>
</td></tr>
<tr><td><code id="plotly_ts.data.frame_+3A_xlab">xlab</code></td>
<td>
<p>A character with the label for the x-axis.</p>
</td></tr>
<tr><td><code id="plotly_ts.data.frame_+3A_ylabs">ylabs</code></td>
<td>
<p>A character vector with labels for the y-axes.</p>
</td></tr>
<tr><td><code id="plotly_ts.data.frame_+3A_mains">mains</code></td>
<td>
<p>A character vector with the main for each plot.</p>
</td></tr>
<tr><td><code id="plotly_ts.data.frame_+3A_mainouter">mainouter</code></td>
<td>
<p>A character with the main at the top of the plot (can also be added afterwards with <code>title(main, outer=TRUE)</code>).</p>
</td></tr>
<tr><td><code id="plotly_ts.data.frame_+3A_legendtexts">legendtexts</code></td>
<td>
<p>A list with the legend texts for each plot (replaces the names of the variables).</p>
</td></tr>
<tr><td><code id="plotly_ts.data.frame_+3A_colormaps">colormaps</code></td>
<td>
<p>A list of colormaps, which will be used in each plot.</p>
</td></tr>
<tr><td><code id="plotly_ts.data.frame_+3A_xat">xat</code></td>
<td>
<p>POSIXt specifying where the ticks on x-axis should be put.</p>
</td></tr>
<tr><td><code id="plotly_ts.data.frame_+3A_usely">usely</code></td>
<td>
<p>If TRUE then plotly will be used.</p>
</td></tr>
<tr><td><code id="plotly_ts.data.frame_+3A_p">p</code></td>
<td>
<p>The plot_ts parameters in a list, as generated with the function <code><a href="#topic+par_ts">par_ts</a>()</code>.</p>
</td></tr>
<tr><td><code id="plotly_ts.data.frame_+3A_namesdata">namesdata</code></td>
<td>
<p>For <code>class(object)=="data.frame"</code> a character vector. Names of columns in object to be searched in, instead of <code>names(object)</code>.</p>
</td></tr>
<tr><td><code id="plotly_ts.data.frame_+3A_...">...</code></td>
<td>
<p>Parameters passed to <code><a href="#topic+par_ts">par_ts</a></code>, see the list of parameters in <code>?<a href="#topic+par_ts">par_ts</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates time series plots depending on the variables matched by each regular expression given in the <code>patterns</code> argument.
</p>
<p>The forecasts matrices in the <code>data.list</code> given in <code>object</code> will be lagged to be aligned in time (i.e. k-step forecasts will be lagged by k).
</p>
<p>Use the plotly package if argument <code>usely</code> is TRUE, see <code><a href="#topic+plotly_ts">plotly_ts</a>()</code>.
</p>
<p>A useful plot for residual analysis and model validation of an RLS fitted forecast model.
</p>
<p>All parameters, except those described below, are simply passed to <code><a href="#topic+plot_ts">plot_ts</a>()</code>.
</p>
<p>The <code>plotly</code> package must be installed and loaded.
</p>
<p>Note that the plot parameters set with <code><a href="#topic+par_ts">par_ts</a>()</code> have no effect on the <code>plotly</code> plots.
</p>
<p>See <a href="https://onlineforecasting.org/vignettes/nice-tricks.html">https://onlineforecasting.org/vignettes/nice-tricks.html</a>.
</p>


<h3>Value</h3>

<p>A list with a data.frame with the data for each plot, if usely=TRUE, then a list of the figures (drawn with print(subplot(L, shareX=TRUE, nrows=length(L), titleY = TRUE))).
</p>
<p>The plotted data in a <code>data.list</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+par_ts">par_ts</a></code> for setting plot control parameters.
</p>
<p><code><a href="base.html#topic+regex">regex</a></code> for regular expressions to select which variables to plot.
</p>
<p><code><a href="#topic+plot_ts">plot_ts</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Time series plots for \code{data.list}, same as for \code{data.frame} except use of \code{kseq}
D &lt;- Dbuilding
plot_ts(D, c("heatload","Ta"), kseq=c(1,24))
# Make two plots (and set the space for the legend)
plot_ts(D, c("heatload","Ta"), kseq=c(1,24), legendspace=11)
# Only the Ta observations 
plot_ts(D, c("heatload","Taobs$"), kseq=c(1,24), legendspace=11)

# Give labels
plot_ts(D, c("heatload","Ta"), kseq=c(1,24), xlab="Time", ylabs=c("Heat (kW)","Temperature (C)"))
# Mains (see mainsline in par_ts())
plot_ts(D, c("heatload","Ta"), kseq=c(1,24), mains=c("Heatload","Temperature"), mainsline=c(-1,-2))

# Format of the xaxis (see par_ts())
plot_ts(D, c("heatload","Ta"), kseq=c(1,24), xaxisformat="%Y-%m-%d %H:%m")

# Return the data, for other plots etc.
L &lt;- plot_ts(D, c("heatload","Ta"), kseq=c(1,24))
names(L[[1]])
names(L[[2]])



# Fit a model (see vignette 'setup-and-use-model'
D &lt;- Dbuilding
D$scoreperiod &lt;- in_range("2010-12-22", D$t)
model &lt;- forecastmodel$new()
model$output = "heatload"
model$add_inputs(Ta = "Ta",
                 mu = "one()")
model$add_regprm("rls_prm(lambda=0.9)")
model$kseq &lt;- c(3,18)
fit1 &lt;- rls_fit(NA, model, D, returnanalysis = TRUE)

# Plot it
plot_ts(fit1)

# Return the data
Dplot &lt;- plot_ts(fit1)

# The RLS coefficients are now in a nice format
head(Dplot$mu)


# See the website link above

</code></pre>

<hr>
<h2 id='plotly_ts.data.list'>Time series plotting</h2><span id='topic+plotly_ts.data.list'></span>

<h3>Description</h3>

<p>Plot time series of observations and forecasts (lagged to be aligned in time).
</p>
<p>Plot forecasts, residuals, cumulated residuals and RLS coefficients
</p>
<p>Simply the same as <code><a href="#topic+plot_ts">plot_ts</a>()</code> with <code>usely=TRUE</code>, such that plotly is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.list'
plotly_ts(
  object,
  patterns = ".*",
  xlim = NA,
  ylims = NA,
  xlab = "",
  ylabs = NA,
  mains = "",
  mainouter = "",
  legendtexts = NA,
  colormaps = NA,
  xat = NA,
  usely = TRUE,
  p = NA,
  kseq = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotly_ts.data.list_+3A_object">object</code></td>
<td>
<p>A <code>data.list</code> or <code>data.frame</code> with observations and forecasts, note diffe</p>
</td></tr>
<tr><td><code id="plotly_ts.data.list_+3A_patterns">patterns</code></td>
<td>
<p>See <code><a href="#topic+plot_ts">plot_ts</a></code>. The default pattern finds the generated series in the function, '!!RLSinputs!!' will be replaced with the names of the RLS inputs (regression stage inputs).</p>
</td></tr>
<tr><td><code id="plotly_ts.data.list_+3A_xlim">xlim</code></td>
<td>
<p>The time range as a character of length 2 and form &quot;YYYY-MM-DD&quot; or POSIX. Date to start and end the plot.</p>
</td></tr>
<tr><td><code id="plotly_ts.data.list_+3A_ylims">ylims</code></td>
<td>
<p>The <code>ylim</code> for each plot given in a list.</p>
</td></tr>
<tr><td><code id="plotly_ts.data.list_+3A_xlab">xlab</code></td>
<td>
<p>A character with the label for the x-axis.</p>
</td></tr>
<tr><td><code id="plotly_ts.data.list_+3A_ylabs">ylabs</code></td>
<td>
<p>A character vector with labels for the y-axes.</p>
</td></tr>
<tr><td><code id="plotly_ts.data.list_+3A_mains">mains</code></td>
<td>
<p>A character vector with the main for each plot.</p>
</td></tr>
<tr><td><code id="plotly_ts.data.list_+3A_mainouter">mainouter</code></td>
<td>
<p>A character with the main at the top of the plot (can also be added afterwards with <code>title(main, outer=TRUE)</code>).</p>
</td></tr>
<tr><td><code id="plotly_ts.data.list_+3A_legendtexts">legendtexts</code></td>
<td>
<p>A list with the legend texts for each plot (replaces the names of the variables).</p>
</td></tr>
<tr><td><code id="plotly_ts.data.list_+3A_colormaps">colormaps</code></td>
<td>
<p>A list of colormaps, which will be used in each plot.</p>
</td></tr>
<tr><td><code id="plotly_ts.data.list_+3A_xat">xat</code></td>
<td>
<p>POSIXt specifying where the ticks on x-axis should be put.</p>
</td></tr>
<tr><td><code id="plotly_ts.data.list_+3A_usely">usely</code></td>
<td>
<p>If TRUE then plotly will be used.</p>
</td></tr>
<tr><td><code id="plotly_ts.data.list_+3A_p">p</code></td>
<td>
<p>The plot_ts parameters in a list, as generated with the function <code><a href="#topic+par_ts">par_ts</a>()</code>.</p>
</td></tr>
<tr><td><code id="plotly_ts.data.list_+3A_kseq">kseq</code></td>
<td>
<p>For <code>class(object)=="data.list"</code> an integer vector, default = NA. Control which forecast horizons to include in the plots. If NA all the horizons will be included.</p>
</td></tr>
<tr><td><code id="plotly_ts.data.list_+3A_...">...</code></td>
<td>
<p>Parameters passed to <code><a href="#topic+par_ts">par_ts</a></code>, see the list of parameters in <code>?<a href="#topic+par_ts">par_ts</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates time series plots depending on the variables matched by each regular expression given in the <code>patterns</code> argument.
</p>
<p>The forecasts matrices in the <code>data.list</code> given in <code>object</code> will be lagged to be aligned in time (i.e. k-step forecasts will be lagged by k).
</p>
<p>Use the plotly package if argument <code>usely</code> is TRUE, see <code><a href="#topic+plotly_ts">plotly_ts</a>()</code>.
</p>
<p>A useful plot for residual analysis and model validation of an RLS fitted forecast model.
</p>
<p>All parameters, except those described below, are simply passed to <code><a href="#topic+plot_ts">plot_ts</a>()</code>.
</p>
<p>The <code>plotly</code> package must be installed and loaded.
</p>
<p>Note that the plot parameters set with <code><a href="#topic+par_ts">par_ts</a>()</code> have no effect on the <code>plotly</code> plots.
</p>
<p>See <a href="https://onlineforecasting.org/vignettes/nice-tricks.html">https://onlineforecasting.org/vignettes/nice-tricks.html</a>.
</p>


<h3>Value</h3>

<p>A list with a data.frame with the data for each plot, if usely=TRUE, then a list of the figures (drawn with print(subplot(L, shareX=TRUE, nrows=length(L), titleY = TRUE))).
</p>
<p>The plotted data in a <code>data.list</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+par_ts">par_ts</a></code> for setting plot control parameters.
</p>
<p><code><a href="base.html#topic+regex">regex</a></code> for regular expressions to select which variables to plot.
</p>
<p><code><a href="#topic+plot_ts">plot_ts</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Time series plots for \code{data.list}, same as for \code{data.frame} except use of \code{kseq}
D &lt;- Dbuilding
plot_ts(D, c("heatload","Ta"), kseq=c(1,24))
# Make two plots (and set the space for the legend)
plot_ts(D, c("heatload","Ta"), kseq=c(1,24), legendspace=11)
# Only the Ta observations 
plot_ts(D, c("heatload","Taobs$"), kseq=c(1,24), legendspace=11)

# Give labels
plot_ts(D, c("heatload","Ta"), kseq=c(1,24), xlab="Time", ylabs=c("Heat (kW)","Temperature (C)"))
# Mains (see mainsline in par_ts())
plot_ts(D, c("heatload","Ta"), kseq=c(1,24), mains=c("Heatload","Temperature"), mainsline=c(-1,-2))

# Format of the xaxis (see par_ts())
plot_ts(D, c("heatload","Ta"), kseq=c(1,24), xaxisformat="%Y-%m-%d %H:%m")

# Return the data, for other plots etc.
L &lt;- plot_ts(D, c("heatload","Ta"), kseq=c(1,24))
names(L[[1]])
names(L[[2]])



# Fit a model (see vignette 'setup-and-use-model'
D &lt;- Dbuilding
D$scoreperiod &lt;- in_range("2010-12-22", D$t)
model &lt;- forecastmodel$new()
model$output = "heatload"
model$add_inputs(Ta = "Ta",
                 mu = "one()")
model$add_regprm("rls_prm(lambda=0.9)")
model$kseq &lt;- c(3,18)
fit1 &lt;- rls_fit(NA, model, D, returnanalysis = TRUE)

# Plot it
plot_ts(fit1)

# Return the data
Dplot &lt;- plot_ts(fit1)

# The RLS coefficients are now in a nice format
head(Dplot$mu)


# See the website link above

</code></pre>

<hr>
<h2 id='print_to_message'>Simple function for capturing from the print function and send it in a message().</h2><span id='topic+print_to_message'></span>

<h3>Description</h3>

<p>Simple function for capturing from the print function and send it in a message().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_to_message(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_to_message_+3A_...">...</code></td>
<td>
<p>Passed to print which passed to message.</p>
</td></tr>
</table>

<hr>
<h2 id='print.forecastmodel'>Print forecast model</h2><span id='topic+print.forecastmodel'></span>

<h3>Description</h3>

<p>Prints a forecast model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'forecastmodel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.forecastmodel_+3A_x">x</code></td>
<td>
<p>A forecastmodel object</p>
</td></tr>
<tr><td><code id="print.forecastmodel_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple print out of the model output and inputs
</p>

<hr>
<h2 id='pst'>Simple wrapper for paste0().</h2><span id='topic+pst'></span>

<h3>Description</h3>

<p>Simple wrapper for paste0().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pst(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pst_+3A_...">...</code></td>
<td>
<p>Passed to paste0().</p>
</td></tr>
</table>

<hr>
<h2 id='resample'>Resampling to equidistant time series</h2><span id='topic+resample'></span>

<h3>Description</h3>

<p>Make a downsampling to a lower sampling frequency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample(
  object,
  ts,
  tstart = NA,
  tend = NA,
  timename = "t",
  fun = mean,
  quantizetime = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_+3A_object">object</code></td>
<td>
<p>Can be data.frame</p>
</td></tr>
<tr><td><code id="resample_+3A_ts">ts</code></td>
<td>
<p>(numeric) New sample period in seconds</p>
</td></tr>
<tr><td><code id="resample_+3A_tstart">tstart</code></td>
<td>
<p>A POSIXxx (or charater or numeric), which indicates the first time point in the series returned</p>
</td></tr>
<tr><td><code id="resample_+3A_tend">tend</code></td>
<td>
<p>A POSIXxx (or charater or numeric), which indicates the last time point in the series returned</p>
</td></tr>
<tr><td><code id="resample_+3A_timename">timename</code></td>
<td>
<p>(character) The name of the time column in object</p>
</td></tr>
<tr><td><code id="resample_+3A_fun">fun</code></td>
<td>
<p>(function) The function of apply. Default is mean, such that average values are obtained</p>
</td></tr>
<tr><td><code id="resample_+3A_quantizetime">quantizetime</code></td>
<td>
<p>(logical) Should the new time points be set to the end of the time intervals, or should they also be the result of the fun function</p>
</td></tr>
<tr><td><code id="resample_+3A_...">...</code></td>
<td>
<p>Passed on to the fun function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an object with a column indicating the time points of the observations the
function returns a similar object, where the function is applied for each new (and longer)
interval.
</p>
<p>Typically it is used if for example 15 minute values should be made into 1 hour values.
</p>
<p>NOTE that it is always assumed that the time point is at the end of the time interval,
e.g. if hourly values are returned, then &quot;2019-01-01 01:00&quot; indicates the first hour in 2019.
</p>
<p>All time points at the time point (border) of between two intervals is assigned to the
first interval of the two.
</p>


<h3>Value</h3>

<p>A downsampled data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate some test data with 10 minutes sampling frequency for one day
X &lt;- data.frame(t=seq(ct("2019-01-01 00:10"),ct("2019-01-02"), by=10*60))

# A single sine over the day
X$val &lt;- sin(as.numeric(X$t)/3600*2*pi/(24))

# Resample to hourly average values
Xre &lt;- resample(X, 3600)
plot(X$t, X$val)
lines(Xre$t, Xre$val, type="b", col=2)

# Resample to hourly max values
Xre &lt;- resample(X, 3600, fun=max)
lines(Xre$t, Xre$val, type="b", col=3)

# Another starting time point
Xre &lt;- resample(X, 3600, tstart="2019-01-01 00:30")
lines(Xre$t, Xre$val, type="b", col=4)


</code></pre>

<hr>
<h2 id='resample.data.frame'>Resampling to equidistant time series</h2><span id='topic+resample.data.frame'></span>

<h3>Description</h3>

<p>Make a downsampling to a lower sampling frequency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
resample(
  object,
  ts,
  tstart = NA,
  tend = NA,
  timename = "t",
  fun = mean,
  quantizetime = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample.data.frame_+3A_object">object</code></td>
<td>
<p>Can be data.frame</p>
</td></tr>
<tr><td><code id="resample.data.frame_+3A_ts">ts</code></td>
<td>
<p>(numeric) New sample period in seconds</p>
</td></tr>
<tr><td><code id="resample.data.frame_+3A_tstart">tstart</code></td>
<td>
<p>A POSIXxx (or charater or numeric), which indicates the first time point in the series returned</p>
</td></tr>
<tr><td><code id="resample.data.frame_+3A_tend">tend</code></td>
<td>
<p>A POSIXxx (or charater or numeric), which indicates the last time point in the series returned</p>
</td></tr>
<tr><td><code id="resample.data.frame_+3A_timename">timename</code></td>
<td>
<p>(character) The name of the time column in object</p>
</td></tr>
<tr><td><code id="resample.data.frame_+3A_fun">fun</code></td>
<td>
<p>(function) The function of apply. Default is mean, such that average values are obtained</p>
</td></tr>
<tr><td><code id="resample.data.frame_+3A_quantizetime">quantizetime</code></td>
<td>
<p>(logical) Should the new time points be set to the end of the time intervals, or should they also be the result of the fun function</p>
</td></tr>
<tr><td><code id="resample.data.frame_+3A_...">...</code></td>
<td>
<p>Passed on to the fun function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an object with a column indicating the time points of the observations the
function returns a similar object, where the function is applied for each new (and longer)
interval.
</p>
<p>Typically it is used if for example 15 minute values should be made into 1 hour values.
</p>
<p>NOTE that it is always assumed that the time point is at the end of the time interval,
e.g. if hourly values are returned, then &quot;2019-01-01 01:00&quot; indicates the first hour in 2019.
</p>
<p>All time points at the time point (border) of between two intervals is assigned to the
first interval of the two.
</p>


<h3>Value</h3>

<p>A downsampled data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate some test data with 10 minutes sampling frequency for one day
X &lt;- data.frame(t=seq(ct("2019-01-01 00:10"),ct("2019-01-02"), by=10*60))

# A single sine over the day
X$val &lt;- sin(as.numeric(X$t)/3600*2*pi/(24))

# Resample to hourly average values
Xre &lt;- resample(X, 3600)
plot(X$t, X$val)
lines(Xre$t, Xre$val, type="b", col=2)

# Resample to hourly max values
Xre &lt;- resample(X, 3600, fun=max)
lines(Xre$t, Xre$val, type="b", col=3)

# Another starting time point
Xre &lt;- resample(X, 3600, tstart="2019-01-01 00:30")
lines(Xre$t, Xre$val, type="b", col=4)


</code></pre>

<hr>
<h2 id='residuals.data.frame'>Calculate the residuals given a forecast matrix and the observations.</h2><span id='topic+residuals.data.frame'></span><span id='topic+residuals.matrix'></span><span id='topic+residuals.list'></span><span id='topic+residuals.forecastmodel_fit'></span>

<h3>Description</h3>

<p>Calculate the residuals given a forecast matrix and the observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
residuals(object, y, ...)

## S3 method for class 'matrix'
residuals(object, y, ...)

## S3 method for class 'list'
residuals(object, y, ...)

## S3 method for class 'forecastmodel_fit'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.data.frame_+3A_object">object</code></td>
<td>
<p>The forecast matrix (a data.frame with kxx as column names, Yhat in returned fits).</p>
</td></tr>
<tr><td><code id="residuals.data.frame_+3A_y">y</code></td>
<td>
<p>The observations vector.</p>
</td></tr>
<tr><td><code id="residuals.data.frame_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simply give the forecast matrix and the observations to get the residuals for each horizon in the forecast matrix.
</p>
<p>The residuals returned are synced with the observations (i.e. k0) and the columns are names &quot;hxx&quot; (not kxx) to indicate this and will not be lagged in <code><a href="#topic+plot_ts">plot_ts</a>()</code>.
</p>


<h3>Value</h3>

<p>If object is a matrix or data.frame: a data.frame with the residuals for each horizon.
If object is a list: A list with residuals from each element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ?? list example
# Just a vector to be forecasted
n &lt;- 100
D &lt;- data.list()
D$t &lt;- 1:n
D$y &lt;- c(filter(rnorm(n), 0.95, "recursive"))
plot(D$y, type="l")

# Generate a forecast matrix with a simple persistence model
D$Yhat &lt;- persistence(D$y, kseq=1:4)

# The residuals for each horizon
D$Resid &lt;- residuals(D$Yhat, D$y)
D$Resid
# Note the names of the columns
names(D$Resid)
# which means that they are aligned with the observations and will not be lagged in the plot
plot_ts(D, c("y|Yhat","Resid"))

# Check that it matches (the forecasts is lagged in the plot_ts
# such that the forecast for t+k is at t+k (and not t))
plot_ts(D, c("y|Yhat","Resid"), xlim=c(1,10), kseq=1,
        plotfun=function(x,...){lines(x,...,type="b")})

# Just for fun, see the auto-correlation function of the persistence 
acf(D$Resid$h1, na.action=na.pass)
acf(D$Resid$h4, na.action=na.pass)

</code></pre>

<hr>
<h2 id='rls_fit'>Fit an onlineforecast model with Recursive Least Squares (RLS).</h2><span id='topic+rls_fit'></span>

<h3>Description</h3>

<p>This function fits the onlineforecast model to the data and returns either: model validation data or just the score value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rls_fit(
  prm = NA,
  model,
  data,
  scorefun = NA,
  returnanalysis = TRUE,
  runcpp = TRUE,
  printout = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rls_fit_+3A_prm">prm</code></td>
<td>
<p>vector with the parameters for fitting. Deliberately as the first element to be able to use <code><a href="stats.html#topic+optim">optim</a></code> or other optimizer. If NA then the model will be fitted with the current values in the input expressions, see examples.</p>
</td></tr>
<tr><td><code id="rls_fit_+3A_model">model</code></td>
<td>
<p>as an object of class forecastmodel: The model to be fitted.</p>
</td></tr>
<tr><td><code id="rls_fit_+3A_data">data</code></td>
<td>
<p>as a data.list with the data to fit the model on.</p>
</td></tr>
<tr><td><code id="rls_fit_+3A_scorefun">scorefun</code></td>
<td>
<p>as a function (optional), default is <code><a href="#topic+rmse">rmse</a></code>. If the score function is given it will be applied to the residuals of each horizon (only data$scoreperiod is included).</p>
</td></tr>
<tr><td><code id="rls_fit_+3A_returnanalysis">returnanalysis</code></td>
<td>
<p>as a logical. If FALSE then the sum of the scoreval on all horizons are returned, if TRUE a list with values for analysis.</p>
</td></tr>
<tr><td><code id="rls_fit_+3A_runcpp">runcpp</code></td>
<td>
<p>logical: If true the c++ implementation of RLS is run, if false the R implementation is run (slower).</p>
</td></tr>
<tr><td><code id="rls_fit_+3A_printout">printout</code></td>
<td>
<p>logical: If TRUE the offline parameters and the score function value are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has three main purposes (in the examples these three are demonstrated in the examples):
</p>
<p>- Returning model validation data, such as residuals and recursive estimated parameters.
</p>
<p>- For optimizing the parameters using an R optimizer function. The parameters to optimize for is given in <code>prm</code>
</p>
<p>- Fitting a model to data and saving the final state in the model object (such that from that point the model can be updated recursively as new data is received).
</p>
<p>Note, if the <code>scorefun</code> is given the <code>data$scoreperiod</code> must be set to (int or logical) define which points to be evaluated in the scorefun.
</p>


<h3>Value</h3>

<p>Depends on:
</p>
<p>- If <code>returnanalysis</code> is TRUE a list containing:
</p>
<p>* <code>Yhat</code>: data.frame with forecasts for <code>model$kseq</code> horizons.
</p>
<p>* <code>model</code>: The forecastmodel object cloned deep, so can be modified without changing the original object.
</p>
<p>* <code>data</code>: data.list with the data used, see examples on how to obtain the transformed data.
</p>
<p>* <code>Lfitval</code>: list with RLS coefficients in a data.frame for each horizon, use <code><a href="#topic+plot_ts.rls_fit">plot_ts.rls_fit</a></code> to plot them and to obtain them as a data.frame for each coefficient.
</p>
<p>* <code>scoreval</code>: data.frame with the scorefun result on each horizon (only scoreperiod is included).
</p>
<p>- If <code>returnanalysis</code> is FALSE (and <code>scorefun</code> is given): The sum of the score function on all horizons (specified with model$kseq).
</p>


<h3>See Also</h3>

<p>For optimizing parameters <code><a href="#topic+rls_optim">rls_optim</a>()</code>, for summary <code>summary.rls_fit</code>, for plotting <code><a href="#topic+plot_ts.rls_fit">plot_ts.rls_fit</a>()</code>, and the other functions starting with 'rls_'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Take data
D &lt;- subset(Dbuilding, c("2010-12-15", "2011-01-01"))
D$y &lt;- D$heatload
# Define a simple model 
model &lt;- forecastmodel$new()
model$output &lt;- "y"
model$add_inputs(Ta = "Ta",
		    mu = "one()")
model$add_regprm("rls_prm(lambda=0.99)")

# Before fitting the model, define which points to include in the evaluation of the score function
D$scoreperiod &lt;- in_range("2010-12-20", D$t)
# And the sequence of horizons to fit for
model$kseq &lt;- 1:6

# Now we can fit the model with RLS and get the model validation analysis data
fit &lt;- rls_fit(model = model, data = D)
# What did we get back?
names(fit)
# The one-step forecast
plot(D$y, type="l")
lines(fit$Yhat$k1, col=2)
# The one-step RLS coefficients over time (Lfitval is a list of the fits for each horizon)
plot(fit$Lfitval$k1$Ta, type="l")

# A summary
summary(fit)
# Plot the fit
plot_ts(fit, kseq=1)

# Fitting with lower lambda makes the RLS coefficients change faster
fit2 &lt;- rls_fit(prm = c(lambda=0.9), model, D)
plot_ts(fit2, kseq=1)


# It can return a score
rls_fit(c(lambda=0.9), model, D, scorefun=rmse, returnanalysis=FALSE)

# Such that it can be passed to an optimzer (see ?rls_optim for a nice wrapper of optim)
val &lt;- optim(c(lambda=0.99), rls_fit, model = model, data = D, scorefun = rmse,
             returnanalysis=FALSE)
val$par
# Which can then simply be applied
rls_fit(val$par, model, D, scorefun=rmse, returnanalysis=FALSE)
# see ?rls_optim, how optim is wrapped for a little easiere use

# See rmse as a function of horizon
fit &lt;- rls_fit(val$par, model, D, scorefun = rmse)
plot(fit$scoreval, xlab="Horizon k", ylab="RMSE")
# See ?score for a little more consistent way of calculating this


# Try adding a low-pass filter to Ta
model$add_inputs(Ta = "lp(Ta, a1=0.92)")
# To obtain the transformed data, i.e. the data which is used as input to the RLS
model$reset_state()
# Generate the the transformed data
datatr &lt;- model$transform_data(D)
# What did we get?
str(datatr)
# See the effect of low-pass filtering
plot(D$Ta$k1, type="l")
lines(datatr$Ta$k1, col=2)
# Try changing the 'a1' coefficient and rerun
# ?rls_optim for how to optimize also this coefficient


</code></pre>

<hr>
<h2 id='rls_optim'>Optimize parameters for onlineforecast model fitted with RLS</h2><span id='topic+rls_optim'></span>

<h3>Description</h3>

<p>Optimize parameters (transformation stage) of RLS model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rls_optim(
  model,
  data,
  kseq = NA,
  scorefun = rmse,
  cachedir = "",
  cachererun = FALSE,
  printout = TRUE,
  method = "L-BFGS-B",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rls_optim_+3A_model">model</code></td>
<td>
<p>The onlineforecast model, including inputs, output, kseq, p</p>
</td></tr>
<tr><td><code id="rls_optim_+3A_data">data</code></td>
<td>
<p>The data.list which holds the data on which the model is fitted.</p>
</td></tr>
<tr><td><code id="rls_optim_+3A_kseq">kseq</code></td>
<td>
<p>The horizons to fit for (if not set, then model$kseq is used)</p>
</td></tr>
<tr><td><code id="rls_optim_+3A_scorefun">scorefun</code></td>
<td>
<p>The function to be score used for calculating the score to be optimized.</p>
</td></tr>
<tr><td><code id="rls_optim_+3A_cachedir">cachedir</code></td>
<td>
<p>A character specifying the path (and prefix) of the cache file name. If set to <code>""</code>, then no cache will be loaded or written. See <a href="https://onlineforecasting.org/vignettes/nice-tricks.html">https://onlineforecasting.org/vignettes/nice-tricks.html</a> for examples.</p>
</td></tr>
<tr><td><code id="rls_optim_+3A_cachererun">cachererun</code></td>
<td>
<p>A logical controlling whether to run the optimization even if the cache exists.</p>
</td></tr>
<tr><td><code id="rls_optim_+3A_printout">printout</code></td>
<td>
<p>A logical determining if the score function is printed out in each iteration of the optimization.</p>
</td></tr>
<tr><td><code id="rls_optim_+3A_method">method</code></td>
<td>
<p>The method argument for <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="rls_optim_+3A_...">...</code></td>
<td>
<p>Additional parameters to <code><a href="stats.html#topic+optim">optim</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper for <code><a href="stats.html#topic+optim">optim</a></code> to enable easy use of bounds and caching in the optimization.
</p>
<p>One smart trick, is to cache the optimization results. Caching can be done by providing a path to the
<code>cachedir</code> argument (relative to the current working directory).
E.g. <code>rls_optim(model, D, cachedir="cache")</code> will write a file in the folder 'cache', such that
next time the same call is carried out, then the file is read instead of running the optimization again.
See the example in <a href="https://onlineforecasting.org/vignettes/nice-tricks.html">https://onlineforecasting.org/vignettes/nice-tricks.html</a>.
</p>


<h3>Value</h3>

<p>Result object of optim().
Parameters resulting from the optimization can be found from <code>result$par</code>
</p>


<h3>See Also</h3>

<p><code>link{optim}</code> for how to control the optimization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Take data
D &lt;- subset(Dbuilding, c("2010-12-15", "2011-01-01"))
D$y &lt;- D$heatload
# Define a simple model 
model &lt;- forecastmodel$new()
model$add_inputs(Ta = "Ta", mu = "one()")
model$add_regprm("rls_prm(lambda=0.99)")

# Before fitting the model, define which points to include in the evaluation of the score function
D$scoreperiod &lt;- in_range("2010-12-20", D$t)
# And the sequence of horizons to fit for
model$kseq &lt;- 1:6
# Now we can fit the model and get the score, as it is
rls_fit(model=model, data=D, scorefun=rmse, returnanalysis=FALSE)
# Or we can change the lambda
rls_fit(c(lambda=0.9), model, D, rmse, returnanalysis=FALSE)

# This could be passed to optim() (or any optimizer, see forecastmodel$insert_prm()).
optim(c(lambda=0.98), rls_fit, model=model, data=D, scorefun=rmse, returnanalysis=FALSE,
      lower=c(lambda=0.9), upper=c(lambda=0.999), method="L-BFGS-B")

# rls_optim is simply a helper, it's makes using bounds easiere and enables caching of the results
# First add bounds for lambda (lower, init, upper)
model$add_prmbounds(lambda = c(0.9, 0.98, 0.999))

# Now the same optimization as above can be done by
val &lt;- rls_optim(model, D)
val


</code></pre>

<hr>
<h2 id='rls_predict'>Prediction with an rls model.</h2><span id='topic+rls_predict'></span>

<h3>Description</h3>

<p>Use a fitted forecast model to predict its output variable with transformed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rls_predict(model, datatr = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rls_predict_+3A_model">model</code></td>
<td>
<p>Onlineforecast model object which has been fitted.</p>
</td></tr>
<tr><td><code id="rls_predict_+3A_datatr">datatr</code></td>
<td>
<p>Transformed data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the ??ref(recursive updating vignette, not yet available).
</p>


<h3>Value</h3>

<p>The Yhat forecast matrix with a forecast for each model$kseq and for each time point in <code>datatr$t</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Take data
D &lt;- subset(Dbuilding, c("2010-12-15", "2011-01-01"))
D$y &lt;- D$heatload
# Define a simple model 
model &lt;- forecastmodel$new()
model$add_inputs(Ta = "Ta", mu = "one()")
model$add_regprm("rls_prm(lambda=0.99)")

# Before fitting the model, define which points to include in the evaluation of the score function
D$scoreperiod &lt;- in_range("2010-12-20", D$t)
# And the sequence of horizons to fit for
model$kseq &lt;- 1:6

# Transform using the mdoel
datatr &lt;- model$transform_data(D)

# See the transformed data
str(datatr)

# The model has not been fitted
model$Lfits

# To fit
rls_fit(model=model, data=D)

# Now the fits for each horizon are there (the latest update)
# For example the current parameter estimates
model$Lfits$k1$theta

# Use the current values for prediction
D$Yhat &lt;- rls_predict(model, datatr)

# Plot it
plot_ts(D, c("y|Yhat"), kseq=1)

# Recursive updating and prediction
Dnew &lt;- subset(Dbuilding, c("2011-01-01", "2011-01-02"))

for(i in 1:length(Dnew$t)){
    # New data arrives
    Dt &lt;- subset(Dnew, i)
    # Remember that the transformation must only be done once if some transformation
    # which is has a state, e.g. lp(), is used
    datatr &lt;- model$transform_data(Dt)
    # Update, remember that this must only be once for each new point
    # (it updates the parameter estimates, i.e. model$Lfits)
    rls_update(model, datatr, Dt$heatload)
    # Now predict to generate the new forecast
    print(rls_predict(model, datatr))
}

</code></pre>

<hr>
<h2 id='rls_prm'>Function for generating the parameters for RLS regression</h2><span id='topic+rls_prm'></span>

<h3>Description</h3>

<p>Function for generating the parameters for RLS regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rls_prm(lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rls_prm_+3A_lambda">lambda</code></td>
<td>
<p>The forgetting factor</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The RLS needs only a forgetting factor parameter.
</p>


<h3>Value</h3>

<p>A list of the parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Take data
D &lt;- subset(Dbuilding, c("2010-12-15", "2011-01-01"))
D$y &lt;- D$heatload
D$scoreperiod &lt;- in_range("2010-12-20", D$t)
# Define a simple model 
model &lt;- forecastmodel$new()
model$add_inputs(Ta = "Ta", mu = "one()")
model$kseq &lt;- 1:6

# Here the expression which sets the parameters is defined
model$add_regprm("rls_prm(lambda=0.99)")
model$regprmexpr

# These will fit with lambda=0.99
rls_fit(prm=NA, model, D)
rls_fit(prm=c(lambda=0.99), model, D)

# The expression is evaluated when the model is fitted
rls_fit(prm=c(lambda=0.85), model, D)

# What happens is simply that the expression was manipulated
model$regprmexpr
model$regprm

# Same change could be done by
model$regprm &lt;- list(lambda=0.3)
model$regprm
val &lt;- rls_fit(prm=NA, model, D)

</code></pre>

<hr>
<h2 id='rls_summary'>Print summary of an onlineforecast model fitted with RLS</h2><span id='topic+rls_summary'></span>

<h3>Description</h3>

<p>The summary of an onlineforecast model fitted with RLS with simple stats providing a simple overview.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rls_summary(object, scoreperiod = NA, scorefun = rmse, printit = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rls_summary_+3A_object">object</code></td>
<td>
<p>of class <code>rls_fit</code>, so a fit calculated by <code><a href="#topic+rls_fit">rls_fit</a></code>.</p>
</td></tr>
<tr><td><code id="rls_summary_+3A_scoreperiod">scoreperiod</code></td>
<td>
<p>logical (or index). If this scoreperiod is given, then it will be used over the one in the fit.</p>
</td></tr>
<tr><td><code id="rls_summary_+3A_scorefun">scorefun</code></td>
<td>
<p>The score function to be applied on each horizon.</p>
</td></tr>
<tr><td><code id="rls_summary_+3A_printit">printit</code></td>
<td>
<p>Print the result.</p>
</td></tr>
<tr><td><code id="rls_summary_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following is printed:
</p>
<p>* The model.
</p>
<p>* Number of observations included in the scoreperiod.
</p>
<p>* RLS coefficients summary statistics for the estimated coefficient time series (since observations are correlated, then usual statistics cannot be applied directly):
</p>
<p>- mean: the sample mean of the series.
</p>
<p>- sd: sample standard deviation of the series.
</p>
<p>- min: minimum of the series.
</p>
<p>- max: maximum of the series.
</p>
<p>* Scorefunction applied for each horizon, per default the RMSE.
</p>


<h3>Value</h3>

<p>A list of:
</p>
<p>- scorefun.
</p>
<p>- scoreval (value of the scorefun for each horizon).
</p>
<p>- scoreperiod is the scoreperiod used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Take data
D &lt;- subset(Dbuilding, c("2010-12-15", "2011-01-01"))
D$y &lt;- D$heatload
D$scoreperiod &lt;- in_range("2010-12-20", D$t)
# Define a model
model &lt;- forecastmodel$new()
model$add_inputs(Ta = "Ta",
                 mu = "one()")
model$add_regprm("rls_prm(lambda=0.99)")
model$kseq &lt;- 1:6
# Fit it
fit &lt;- rls_fit(prm=c(lambda=0.99), model, D)

# Print the summary
summary(fit)
# We see:
#   - The model (output, inputs, lambda)
#   - The Ta coefficient is around -0.12 in average (for all horizons) with a standard dev. of 0.03,
#     so not varying extremely (between -0.18 and -0.027).
#   - The intercept mu is around 5.5 and varying very little.
#   - The RMSE is around 0.9 for all horizons.

# The residuals and coefficient series can be seen by
plot_ts(fit)

</code></pre>

<hr>
<h2 id='rls_update'>Updates the model fits</h2><span id='topic+rls_update'></span>

<h3>Description</h3>

<p>Calculates the RLS update of the model coefficients with the provived data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rls_update(model, datatr = NA, y = NA, runcpp = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rls_update_+3A_model">model</code></td>
<td>
<p>A model object</p>
</td></tr>
<tr><td><code id="rls_update_+3A_datatr">datatr</code></td>
<td>
<p>a data.list with transformed data (from model$transform_data(D))</p>
</td></tr>
<tr><td><code id="rls_update_+3A_y">y</code></td>
<td>
<p>A vector of the model output for the corresponding time steps in <code>datatr</code></p>
</td></tr>
<tr><td><code id="rls_update_+3A_runcpp">runcpp</code></td>
<td>
<p>Optional, default = TRUE. If TRUE, a c++ implementation of the update is run, otherwise a slower R implementation is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See vignette ??ref(recursive updating, not yet finished) on how to use the function.
</p>


<h3>Value</h3>

<p>Returns a named list for each horizon (<code>model$kseq</code>) containing the variables needed for the RLS fit (for each horizon, which is saved in model$Lfits):
</p>
<p>It will update variables in the forecast model object.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+rls_predict">rls_predict</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# See rls_predict examples

</code></pre>

<hr>
<h2 id='rls_update_cpp'>Calculating k-step recursive least squares estimates</h2><span id='topic+rls_update_cpp'></span>

<h3>Description</h3>

<p>This function applies the k-step recursive least squares scheme to estimate
parameters in a linear regression model.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="rls_update_cpp_+3A_y">y</code></td>
<td>
<p>Vector of observation</p>
</td></tr>
<tr><td><code id="rls_update_cpp_+3A_x">X</code></td>
<td>
<p>Matrix of input variables (design matrix)</p>
</td></tr>
<tr><td><code id="rls_update_cpp_+3A_theta">theta</code></td>
<td>
<p>Vector of parameters (initial value)</p>
</td></tr>
<tr><td><code id="rls_update_cpp_+3A_p">P</code></td>
<td>
<p>Covariance matrix (initial value)</p>
</td></tr>
<tr><td><code id="rls_update_cpp_+3A_lambda">lambda</code></td>
<td>
<p>Forgetting factor</p>
</td></tr>
<tr><td><code id="rls_update_cpp_+3A_k">k</code></td>
<td>
<p>Forecast horizon</p>
</td></tr>
<tr><td><code id="rls_update_cpp_+3A_n">n</code></td>
<td>
<p>Length of the input</p>
</td></tr>
<tr><td><code id="rls_update_cpp_+3A_np">np</code></td>
<td>
<p>Dimension of P (np x np)</p>
</td></tr>
<tr><td><code id="rls_update_cpp_+3A_istart">istart</code></td>
<td>
<p>Start index</p>
</td></tr>
<tr><td><code id="rls_update_cpp_+3A_kmax">kmax</code></td>
<td>
<p>Keep only the last kmax rows for next time</p>
</td></tr>
</table>

<hr>
<h2 id='rmse'>Computes the RMSE score.</h2><span id='topic+rmse'></span>

<h3>Description</h3>

<p>Returns the RMSE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmse(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmse_+3A_x">x</code></td>
<td>
<p>a numerical vector of residuals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used for forecast evaluation evaluation and optimization of parameters in model fitting.
</p>
<p>Note that <code>NA</code>s are ignored (i.e. <code>mean</code> is called with <code>na.rm=TRUE</code>).
</p>


<h3>Value</h3>

<p>The RMSE score.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+score">score</a>()</code> for calculation of a score for the k'th horizon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 # Just a vector to be forecasted
 y &lt;- c(filter(rnorm(100), 0.95, "recursive"))
 # Generate a forecast matrix with a simple persistence model
 Yhat &lt;- persistence(y, kseq=1:4)
 # The residuals for each horizon
 Resid &lt;- residuals(Yhat, y)

# Calculate the score for the k1 horizon
rmse(Resid$h1)

# For all horizons
apply(Resid, 2, rmse)


</code></pre>

<hr>
<h2 id='score'>Calculate the score for each horizon.</h2><span id='topic+score'></span><span id='topic+score.list'></span><span id='topic+score.data.frame'></span>

<h3>Description</h3>

<p>Calculates the score for each horizon for a matrix with residuals for each horizon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score(object, scoreperiod = NA, usecomplete = TRUE, scorefun = rmse, ...)

## S3 method for class 'list'
score(object, scoreperiod = NA, usecomplete = TRUE, scorefun = rmse, ...)

## S3 method for class 'data.frame'
score(object, scoreperiod = NA, usecomplete = TRUE, scorefun = rmse, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_+3A_object">object</code></td>
<td>
<p>??list or A matrix with residuals (columns named <code>hxx</code>) for which to calculate the score for each horizon.</p>
</td></tr>
<tr><td><code id="score_+3A_scoreperiod">scoreperiod</code></td>
<td>
<p>as a logical vector controlling which points to be included in the score calculation. If NA then all values are included (depeding on 'complete').</p>
</td></tr>
<tr><td><code id="score_+3A_usecomplete">usecomplete</code></td>
<td>
<p>TRUE then only the values available for all horizons are included (i.e. if at one time point there is a missing value, then values for this time point is removed for all horizons in the calculation).</p>
</td></tr>
<tr><td><code id="score_+3A_scorefun">scorefun</code></td>
<td>
<p>The score function.</p>
</td></tr>
<tr><td><code id="score_+3A_...">...</code></td>
<td>
<p>is passed on to the score function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applies the <code>scorefun</code> on all horizons (each column) of the residuals matrix. See the description of each parameter for more details.
</p>


<h3>Value</h3>

<p>A list with the a numeric vector with the score value for each horizon and the applied <code>scoreperiod</code> (note can be different from the given scoreperiod, if only complete observations are used (as per default)).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Just a vector to be forecasted
y &lt;- c(filter(rnorm(100), 0.95, "recursive"))
# Generate a forecast matrix with a simple persistence model
Yhat &lt;- persistence(y, kseq=1:4)
# The residuals for each horizon
Resid &lt;- residuals(Yhat, y)

# Calculate the score for the k1 horizon
score(Resid)

# In the beginning the horizons have NAs
head(Resid)
# Default is that only complete cases over all horizons are included
score(Resid)
# So including all cases for each horizon will give different values
score(Resid, usecomplete=FALSE)

# Given a list
# The residuals for each horizon
Resid2 &lt;- residuals(persistence(y,kseq=1:4)+rnorm(100), y)

score(list(Resid,Resid2))
</code></pre>

<hr>
<h2 id='setpar'>Setting <code><a href="graphics.html#topic+par">par</a>()</code> plotting parameters</h2><span id='topic+setpar'></span>

<h3>Description</h3>

<p>Setting <code><a href="graphics.html#topic+par">par</a>()</code> plotting parameters to a set of default values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setpar(tmpl = "ts", mfrow = c(1, 1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setpar_+3A_tmpl">tmpl</code></td>
<td>
<p>The name of the parameter template, give &quot;ts&quot; as default</p>
</td></tr>
<tr><td><code id="setpar_+3A_mfrow">mfrow</code></td>
<td>
<p>The mfrow for <code>par</code>.</p>
</td></tr>
<tr><td><code id="setpar_+3A_...">...</code></td>
<td>
<p>More parameters for <code>par</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple function, which sets the <code><a href="graphics.html#topic+par">par</a>()</code> plotting parameters to a default set of values.
</p>
<p>Actually, only really used for setting useful <code>par</code> values for multiple time series plots with same x-axis.
Give <code>tmpl="ts"</code> and <code>mfrow=c(x,1)</code>, where x is the number of plots.
</p>


<h3>Value</h3>

<p>Return the original set of parameters, such that they can be reset after plotting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Make some data
D &lt;- data.frame(t=seq(ct("2020-01-01"),ct("2020-01-10"),len=100), x=rnorm(100), y=runif(100))
# Remember the currect par values
oldpar &lt;- setpar()

# Generate two stacked plots with same x-axis
setpar("ts", mfrow=c(2,1))
plot(D$t, D$x, type="l")
plot(D$t, D$y, type="l")
# Note xaxt="s" must be set
axis.POSIXct(1, D$t, xaxt="s", format="%Y-%m-%d")

# Set back the par to the previous
par(oldpar)

# In a function, where this is used and a plot is generated,
# then do like this in order to automatically reset on exit
oldpar &lt;- setpar(mfrow=c(2,1))
on.exit(par(oldpar))        

</code></pre>

<hr>
<h2 id='stairs'>Plotting stairs with time point at end of interval.</h2><span id='topic+stairs'></span>

<h3>Description</h3>

<p>Plotting steps with time point at end of interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stairs(x, y, type = "b", preline = FALSE, pch = 19, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stairs_+3A_x">x</code></td>
<td>
<p>x values for plot.</p>
</td></tr>
<tr><td><code id="stairs_+3A_y">y</code></td>
<td>
<p>y values for plot.</p>
</td></tr>
<tr><td><code id="stairs_+3A_type">type</code></td>
<td>
<p>if 'b' then include points.</p>
</td></tr>
<tr><td><code id="stairs_+3A_preline">preline</code></td>
<td>
<p>if TRUE, then a line backwards from the first point is added.</p>
</td></tr>
<tr><td><code id="stairs_+3A_pch">pch</code></td>
<td>
<p>Passed to <code>points()</code>.</p>
</td></tr>
<tr><td><code id="stairs_+3A_...">...</code></td>
<td>
<p>Passed to <code>lines()</code> and <code>points()</code> when they are called in the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It's easy to plot stairs with <code>plot(x,y,type="s")</code>, however that makes the steps forward from <code>x</code>, for time series this works if the time points are at the beginning of the intervals.
</p>
<p>Often with time series the time points are in the end of the intervals, so the steps should go backaward, this is achieved with this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Usual stairs plot has steps forward from x
x &lt;- rnorm(10)
plot(1:10, x, type="s")

# Stairs with step backward from x
plot(1:10, x, type="n")
stairs(1:10, x)

# Use for time series plotting
plot_ts(Dbuilding, "heatload", c("2010-12-15","2010-12-16"), plotfun=stairs)

# Set it globally for all plot_ts
p &lt;- par_ts()
p$plotfun &lt;- stairs
options(par_ts=p)
plot_ts(Dbuilding, "heatload", c("2010-12-15","2010-12-16"))

# Modify it to only lines
plot_ts(Dbuilding, "heatload", c("2010-12-15","2010-12-16"),
        plotfun=function(x,y,...){stairs(x,y, type="l")})

</code></pre>

<hr>
<h2 id='state_getval'>Get the state value kept in last call.</h2><span id='topic+state_getval'></span>

<h3>Description</h3>

<p>Get the state value kept in last call to the transformation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>state_getval(initval)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="state_getval_+3A_initval">initval</code></td>
<td>
<p>If no state was kept, then this init value is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transformation functions (e.g. <code><a href="#topic+lp">lp</a></code>, <code><a href="#topic+fs">fs</a></code>, <code><a href="#topic+bspline">bspline</a></code>) can need to keep a state value between calls, e.g. when new data arrives and must be transformed. This function is used to getting the state values set in last call to the function.
</p>
<p>Uses the <code>input_class$state_getval()</code>.
</p>


<h3>Value</h3>

<p>The state value, but if not found, then the initval.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+state_setval">state_setval</a>()</code> for setting the state value and <code><a href="#topic+input_class">input_class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# See how it can be used in lp, which needs to save the state of the filter
# Note how it is not needed to do anything else than getting and setting the state
# in transformations (model$transform_data()), then multiple transformation functions can be called,
# but they are always in the same order, so the state (set,get) functions keep a counter internally
# to make sure that the correct values are set and returned when called again.
lp


</code></pre>

<hr>
<h2 id='state_setval'>Set a state value to be kept for next the transformation function is called.</h2><span id='topic+state_setval'></span>

<h3>Description</h3>

<p>Set a state value to be kept for next the transformation function is called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>state_setval(val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="state_setval_+3A_val">val</code></td>
<td>
<p>The value to set and kept for next call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transformation functions (e.g. <code><a href="#topic+lp">lp</a></code>, <code><a href="#topic+fs">fs</a></code>, <code><a href="#topic+bspline">bspline</a></code>) can need to keep a state value between calls, e.g. when new data arrives and must be transformed. This function is used to setting the state values set in last call to the function.
</p>
<p>Uses the <code>input_class$state_getval()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+state_setval">state_setval</a>()</code> for setting the state value and <code><a href="#topic+input_class">input_class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# See how it can be used in lp, which needs to save the state of the filter
# Note how it is not needed to do anything else than getting and setting the state
# in transformations (model$transform_data()), then multiple transformation functions can be called,
# but they are always in the same order, so the state (set,get) functions keep a counter internally
# to make sure that the correct values are set and returned when called again.
lp


</code></pre>

<hr>
<h2 id='step_optim'>Forward and backward model selection</h2><span id='topic+step_optim'></span>

<h3>Description</h3>

<p>Forward and backward model selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_optim(
  modelfull,
  data,
  prm = list(NA),
  direction = c("both", "backward", "forward", "backwardboth", "forwardboth"),
  modelstart = NA,
  keepinputs = FALSE,
  optimfun = rls_optim,
  fitfun = NA,
  scorefun = rmse,
  printout = FALSE,
  mc.cores = getOption("mc.cores", 2L),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_optim_+3A_modelfull">modelfull</code></td>
<td>
<p>The full forecastmodel containing all inputs which will be
can be included in the selection.</p>
</td></tr>
<tr><td><code id="step_optim_+3A_data">data</code></td>
<td>
<p>The data.list which holds the data on which the model is fitted.</p>
</td></tr>
<tr><td><code id="step_optim_+3A_prm">prm</code></td>
<td>
<p>A list of integer parameters to be stepped. Given using the same
syntax as parameters for optimization, e.g. 'list(I__degree = c(min=3,
max=7))' will step the &quot;degree&quot; for input &quot;I&quot;.</p>
</td></tr>
<tr><td><code id="step_optim_+3A_direction">direction</code></td>
<td>
<p>The direction to be used in the selection process.</p>
</td></tr>
<tr><td><code id="step_optim_+3A_modelstart">modelstart</code></td>
<td>
<p>A forecastmodel. If it's set then it will be used as the
selected model from the first step of the stepping. It should be a sub
model of the full model.</p>
</td></tr>
<tr><td><code id="step_optim_+3A_keepinputs">keepinputs</code></td>
<td>
<p>If TRUE no inputs can be removed in a step, if FALSE then
any input can be removed. If given as a character vector with names of
inputs, then they cannot be removed in any step.</p>
</td></tr>
<tr><td><code id="step_optim_+3A_optimfun">optimfun</code></td>
<td>
<p>The function which will carry out the optimization in each
step.</p>
</td></tr>
<tr><td><code id="step_optim_+3A_fitfun">fitfun</code></td>
<td>
<p>A fit function, should be the same as used in optimfun(). If
provided, then the score is caculated with this function (instead of the
one called in optimfun(), hence the default is rls_fit(), which is called
in rls_optim()). Furthermore, information on complete cases are printed
and returned.</p>
</td></tr>
<tr><td><code id="step_optim_+3A_scorefun">scorefun</code></td>
<td>
<p>The score function used.</p>
</td></tr>
<tr><td><code id="step_optim_+3A_printout">printout</code></td>
<td>
<p>Logical. Passed on to fitting functions.</p>
</td></tr>
<tr><td><code id="step_optim_+3A_mc.cores">mc.cores</code></td>
<td>
<p>The mc.cores argument of mclapply. If debugging it can be
necessary to set it to 1 to stop execution.</p>
</td></tr>
<tr><td><code id="step_optim_+3A_...">...</code></td>
<td>
<p>Additional arguments which will be passed on to optimfun. For
example control how many steps</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a model and carry out a model selection by stepping
backward, forward or in both directions.
</p>
<p>Note that mclapply is used. In order to control the number of cores to use,
then set it, e.g. to one core 'options(mc.cores=1)', which is needed for
debugging to work.
</p>
<p>The full model containing all inputs must be given. In each step new models
are generated, with either one removed input or one added input, and then all
the generated models are optimized and their scores compared. If any new
model have an improved score compared to the currently selected model, then
the new is selected and the process is repeated until no new improvement is
obtained.
</p>
<p>In addition to selecting inputs, then integer parameters can also be stepped
through, e.g. the order of basis splined or the number of harmonics in
Fourier series.
</p>
<p>The stepping process is different depending on the direction. In addition to
the full model, a starting model can be given, then the selection process
will start from that model.
</p>
<p>If the direction is &quot;both&quot;, which is default (same as &quot;backwardboth&quot;) then the
stepping is:
- In first step inputs are removed one-by-one
- In following steps, inputs still in the model are removed one-by-one, and
inputs not in the model are added one-by-one
</p>
<p>If the direction is &quot;backwards&quot;:
- Inputs are only removed in each step
</p>
<p>If the direction is &quot;forwardboth&quot;:
- In the first step all inputs are removed
- In following steps (same as &quot;both&quot;)
</p>
<p>If the direction is &quot;forward&quot;:
- In the first step all inputs are removed and from there inputs are only added
</p>
<p>For stepping through integer variables in the transformation stage, then
these have to be set in the &quot;prm&quot; argument. The stepping process will follow
the input selection described above.
</p>
<p>In case of missing values, especially in combination with auto-regressive
models, it can be very important to make sure that only complete cases are
included when calculating the score. By providing the 'fitfun' argument then
the score will be calculated using only the complete cases across horizons
and models in each step, see the last examples.
</p>
<p>Note, that either kseq or kseqopt must be set on the modelfull object. If kseqopt
is set, then it is used no matter the value of kseq.
</p>


<h3>Value</h3>

<p>A list with the result of each step:
- '$model' is the model selected in each step
- '$score' is the score for the model selected in each step
- '$optimresult' the result return by the the optimfun
- '$completecases' a logical vector (NA if fitfun argument is not given) indicating which time points were complete across all horizons and models for the particular step.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# The data, just a rather short period to keep running times short
D &lt;- subset(Dbuilding, c("2010-12-15", "2011-02-01"))
# Set the score period
D$scoreperiod &lt;- in_range("2010-12-22", D$t)
#
D$tday &lt;- make_tday(D$t, 1:36)
# Generate an input which is just random noise, i.e. should be removed in the selection
set.seed(83792)
D$noise &lt;- make_input(rnorm(length(D$t)), 1:36)

# The full model
model &lt;- forecastmodel$new()
# Set the model output
model$output = "heatload"
# Inputs (transformation step)
model$add_inputs(Ta = "Ta",
                 noise = "noise",
                 mu_tday = "fs(tday/24, nharmonics=5)",
                 mu = "one()")
# Regression step parameters
model$add_regprm("rls_prm(lambda=0.9)")
# Optimization bounds for parameters
model$add_prmbounds(lambda = c(0.9, 0.99, 0.9999))

# Select a model, in the optimization just run it for a single horizon
# Note that kseqopt could also be set
model$kseq &lt;- 5

# Set the parameters to step on, note the 
prm &lt;- list(mu_tday__nharmonics = c(min=3, max=7))

# Note the control argument, which is passed to optim, it's now set to few
# iterations in the offline parameter optimization (MUST be increased in real applications)
control &lt;- list(maxit=1)

# On Windows multi cores are not supported, so for the examples use only one core
mc.cores &lt;- 1

# Run the default selection scheme, which is "both"
# (same as "backwardboth" if no start model is given)
L &lt;- step_optim(model, D, prm, control=control, mc.cores=mc.cores)

# The optim value from each step is returned
getse(L, "optimresult")
getse(L,"score")

# The final model
L$final$model

# Other selection schemes
Lforward &lt;- step_optim(model, D, prm, "forward", control=control, mc.cores=mc.cores)
Lbackward &lt;- step_optim(model, D, prm, "backward", control=control, mc.cores=mc.cores)
Lbackwardboth &lt;- step_optim(model, D, prm, "backwardboth", control=control, mc.cores=mc.cores)
Lforwardboth &lt;- step_optim(model, D, prm, "forwardboth", control=control, mc.cores=mc.cores)

# It's possible avoid removing specified inputs
L &lt;- step_optim(model, D, prm, keepinputs=c("mu","mu_tday"), control=control, mc.cores=mc.cores)

# Give a starting model
modelstart &lt;- model$clone_deep()
modelstart$inputs[2:3] &lt;- NULL
L &lt;- step_optim(model, D, prm, modelstart=modelstart, control=control, mc.cores=mc.cores)

# If a fitting function is given, then it will be used for calculating the forecasts.
# Below it's the rls_fit function, so the same as used internally in rls_fit, so only 
# difference is that now ONLY on the complete cases for all models in each step are used
# when calculating the score in each step
L1 &lt;- step_optim(model, D, prm, fitfun=rls_fit, control=control, mc.cores=mc.cores)

# The easiest way to conclude if missing values have an influence is to
# compare the selection result running with and without
L2 &lt;- step_optim(model, D, prm, control=control, mc.cores=mc.cores)

# Compare the selected models
tmp1 &lt;- capture.output(getse(L1, "model"))
tmp2 &lt;- capture.output(getse(L2, "model"))
identical(tmp1, tmp2)


# Note that caching can be really smart (the cache files are located in the
# cachedir folder (folder in current working directory, can be removed with
# unlink(foldername)) See e.g. `?rls_optim` for how the caching works
# L &lt;- step_optim(model, D, prm, "forward", cachedir="cache", cachererun=FALSE, mc.cores=mc.cores)

</code></pre>

<hr>
<h2 id='subset.data.list'>Take a subset of a data.list.</h2><span id='topic+subset.data.list'></span>

<h3>Description</h3>

<p>Take a subset of a data.list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.list'
subset(
  x,
  subset = NA,
  nms = NA,
  kseq = NA,
  lagforecasts = FALSE,
  pattern = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.data.list_+3A_x">x</code></td>
<td>
<p>The data.list to take a subset of.</p>
</td></tr>
<tr><td><code id="subset.data.list_+3A_subset">subset</code></td>
<td>
<p>Given as the integer indexes or a logical vector, or alternatively <code>c(tstart,tend)</code>, where tstart and tend are either as POSIX or characters.</p>
</td></tr>
<tr><td><code id="subset.data.list_+3A_nms">nms</code></td>
<td>
<p>The names of the variables in <code>x</code> to be included.</p>
</td></tr>
<tr><td><code id="subset.data.list_+3A_kseq">kseq</code></td>
<td>
<p>The k horizons of forecasts to be included.</p>
</td></tr>
<tr><td><code id="subset.data.list_+3A_lagforecasts">lagforecasts</code></td>
<td>
<p>Should the forecasts be lagged k steps (thus useful for plotting etc.).</p>
</td></tr>
<tr><td><code id="subset.data.list_+3A_pattern">pattern</code></td>
<td>
<p>Regex pattern applied to select the variables in x to be included.</p>
</td></tr>
<tr><td><code id="subset.data.list_+3A_...">...</code></td>
<td>
<p>Not implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different arguments can be given to select the subset. See the examples.
</p>


<h3>Value</h3>

<p>a data.list with the subset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the data.list with building heat load 
D &lt;- Dbuilding
# Take a subset for the example
D &lt;- subset(D, 1:10, nms=c("t","Taobs","Ta","Iobs","I"), kseq=1:3)

# Take subset index 2:4
subset(D, 2:4)

# Take subset for a period
subset(D, c("2010-12-15 02:00","2010-12-15 04:00"))

# Cannot request a variable not there
try(subset(D, nms=c("x","Ta")))

# Take specific horizons
subset(D, nms=c("I","Ta"), kseq = 1:2)
subset(D, nms=c("I","Ta"), kseq = 1)

# Lag the forecasts such that they are aligned in time with observations
subset(D, nms=c("Taobs","Ta"), kseq = 2:3, lagforecasts = TRUE)

# The order follows the order in nms
subset(D, nms=c("Ta","I"), kseq = 2)

# Return variables mathing a regex
subset(D, kseq=2, pattern="^I")

# Take data for Ta and lag the forecasts (good for plotting and fitting a model)
X &lt;- subset(Dbuilding, 1:1000, pattern="^Ta", kseq = 10, lagforecasts = TRUE)

# A scatter plot between the forecast and the observations
# (try lagforecasts = FALSE and see the difference)
plot(X$Ta$k10, X$Taobs)

# Fit a model for the 10-step horizon
abline(lm(Taobs ~ Ta.k10, as.data.frame(X)), col=2)

</code></pre>

<hr>
<h2 id='summary.data.list'>Summary with checks of the data.list for appropriate form.</h2><span id='topic+summary.data.list'></span>

<h3>Description</h3>

<p>Summary including checks of the data.list for appropriate form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.list'
summary(
  object,
  printit = TRUE,
  stopit = TRUE,
  nms = names(object),
  msgextra = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.data.list_+3A_object">object</code></td>
<td>
<p>The object to be summarized and checked</p>
</td></tr>
<tr><td><code id="summary.data.list_+3A_printit">printit</code></td>
<td>
<p>A boolean deciding if check results tables are printed</p>
</td></tr>
<tr><td><code id="summary.data.list_+3A_stopit">stopit</code></td>
<td>
<p>A boolean deciding if the function stop with an error if the check is not ok</p>
</td></tr>
<tr><td><code id="summary.data.list_+3A_nms">nms</code></td>
<td>
<p>A character vector. If given specifies the variables (vectors or matrices) in object to check</p>
</td></tr>
<tr><td><code id="summary.data.list_+3A_msgextra">msgextra</code></td>
<td>
<p>A character which is added in the printout of an (potential) error message</p>
</td></tr>
<tr><td><code id="summary.data.list_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints on table form the result of the checks.
</p>


<h3>Value</h3>

<p>The tables generated.
</p>
<p>Checking the data.list for appropriate form:
</p>
<p>A check of the time vector t, which must have equidistant time points and no NAs.
</p>
<p>Then the results of checks of vectors (observations):
</p>
<p>- NAs: Proportion of NAs
</p>
<p>- length: Same length as the 't' vector?
</p>
<p>- class: The class of the vector
</p>
<p>Then the results of checking data.frames and matrices (forecasts):
</p>
<p>- maxHorizonNAs: The proportion of NAs for the horizon (i.e. column) with the highest proportion of NAs
</p>
<p>- meanNAs: The proportion of NAs of the entire matrix
</p>
<p>- nrow: Same length as the 't' vector?
</p>
<p>- colnames: Columns must be names 'kx', where 'x' is the horizon (e.g. k12 is 12-step horizon)
</p>
<p>- sameclass: Error if not all columns are the same class
</p>
<p>- class: Prints the class of the columns if they are all the same
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
summary(Dbuilding)

# Some NAs in k1 forecast
D &lt;- Dbuilding
D$Ta$k1[1:1500] &lt;- NA
summary(D)

# Vector with observations not same length as t throws error
D &lt;- Dbuilding
D$heatload &lt;- D$heatload[1:10]
try(summary(D))

# Forecasts wrong count
D &lt;- Dbuilding
D$Ta &lt;- D$Ta[1:10, ]
try(summary(D))

# Wrong column names
D &lt;- Dbuilding
names(D$Ta)[4] &lt;- "xk"
names(D$Ta)[2] &lt;- "x2"
try(summary(D))

# No column names
D &lt;- Dbuilding
names(D$Ta) &lt;- NULL
try(summary(D))

# Don't stop or only print if stopped 
onlineforecast:::summary.data.list(D, stopit=FALSE)
try(onlineforecast:::summary.data.list(D, printit=FALSE))

# Only check for specified variables
# (e.g. do like this in model functions to check only variables used in model)
onlineforecast:::summary.data.list(D, nms=c("heatload","I"))

</code></pre>

<hr>
<h2 id='summary.rls_fit'>Print summary of an onlineforecast model fitted with RLS</h2><span id='topic+summary.rls_fit'></span>

<h3>Description</h3>

<p>The summary of an onlineforecast model fitted with RLS with simple stats providing a simple overview.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rls_fit'
summary(object, scoreperiod = NA, scorefun = rmse, printit = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.rls_fit_+3A_object">object</code></td>
<td>
<p>of class <code>rls_fit</code>, so a fit calculated by <code><a href="#topic+rls_fit">rls_fit</a></code>.</p>
</td></tr>
<tr><td><code id="summary.rls_fit_+3A_scoreperiod">scoreperiod</code></td>
<td>
<p>logical (or index). If this scoreperiod is given, then it will be used over the one in the fit.</p>
</td></tr>
<tr><td><code id="summary.rls_fit_+3A_scorefun">scorefun</code></td>
<td>
<p>The score function to be applied on each horizon.</p>
</td></tr>
<tr><td><code id="summary.rls_fit_+3A_printit">printit</code></td>
<td>
<p>Print the result.</p>
</td></tr>
<tr><td><code id="summary.rls_fit_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following is printed:
</p>
<p>* The model.
</p>
<p>* Number of observations included in the scoreperiod.
</p>
<p>* RLS coefficients summary statistics for the estimated coefficient time series (since observations are correlated, then usual statistics cannot be applied directly):
</p>
<p>- mean: the sample mean of the series.
</p>
<p>- sd: sample standard deviation of the series.
</p>
<p>- min: minimum of the series.
</p>
<p>- max: maximum of the series.
</p>
<p>* Scorefunction applied for each horizon, per default the RMSE.
</p>


<h3>Value</h3>

<p>A list of:
</p>
<p>- scorefun.
</p>
<p>- scoreval (value of the scorefun for each horizon).
</p>
<p>- scoreperiod is the scoreperiod used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Take data
D &lt;- subset(Dbuilding, c("2010-12-15", "2011-01-01"))
D$y &lt;- D$heatload
D$scoreperiod &lt;- in_range("2010-12-20", D$t)
# Define a model
model &lt;- forecastmodel$new()
model$add_inputs(Ta = "Ta",
                 mu = "one()")
model$add_regprm("rls_prm(lambda=0.99)")
model$kseq &lt;- 1:6
# Fit it
fit &lt;- rls_fit(prm=c(lambda=0.99), model, D)

# Print the summary
summary(fit)
# We see:
#   - The model (output, inputs, lambda)
#   - The Ta coefficient is around -0.12 in average (for all horizons) with a standard dev. of 0.03,
#     so not varying extremely (between -0.18 and -0.027).
#   - The intercept mu is around 5.5 and varying very little.
#   - The RMSE is around 0.9 for all horizons.

# The residuals and coefficient series can be seen by
plot_ts(fit)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
