<!DOCTYPE html><html lang="en"><head><title>Help for package MaxMC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MaxMC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MaxMC-package'><p>Maximized Monte Carlo</p></a></li>
<li><a href='#get_control'><p>Format the optimization method controls</p></a></li>
<li><a href='#mc'><p>Monte Carlo with Tie-Breaker</p></a></li>
<li><a href='#mmc'><p>Find the Maximized Monte Carlo (MMC) p-value on a set of nuisance</p>
parameters.</a></li>
<li><a href='#monitor_mmc'><p>Format the optimization method controls</p></a></li>
<li><a href='#plot.mmc'><p>Plot a <code>mmc</code> Object</p></a></li>
<li><a href='#print.mc'><p>Print a Summary of a <code>mc</code> Object</p></a></li>
<li><a href='#print.mmc'><p>Print a Summary of a <code>mmc</code> Object</p></a></li>
<li><a href='#pvalue'><p>p-value Function</p></a></li>
<li><a href='#return_mc'><p>S3 class <code>mc</code> object generating function</p></a></li>
<li><a href='#return_mmc'><p>S3 class <code>mmc</code> object generating function</p></a></li>
<li><a href='#simulation_mc'><p>Monte Carlo Simulation</p></a></li>
<li><a href='#simulation_mmc'><p>Maximized Monte Carlo Simulation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Maximized Monte Carlo</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-29</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gabriel Rodriguez-Rondon &lt;gabriel.rodriguezrondon@mail.mcgill.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the Monte Carlo techniques described in details by Dufour (2006) &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2005.06.007">doi:10.1016/j.jeconom.2005.06.007</a>&gt; and Dufour and Khalaf (2007) &lt;<a href="https://doi.org/10.1002%2F9780470996249.ch24">doi:10.1002/9780470996249.ch24</a>&gt;. The two main features available are the Monte Carlo method with tie-breaker, mc(), for discrete statistics, and the Maximized Monte Carlo, mmc(), for statistics with nuisance parameters.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/julienneves/MaxMC">https://github.com/julienneves/MaxMC</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>fUnitRoots, microbenchmark, boot, MASS, knitr, rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>GenSA, pso, GA, NMOF, scales, stats, graphics, utils,</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-01 12:22:57 UTC; gabrielrodriguez</td>
</tr>
<tr>
<td>Author:</td>
<td>Julien Neves [aut],
  Jean-Marie Dufour [aut, ths],
  Gabriel Rodriguez-Rondon [cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-02 16:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='MaxMC-package'>Maximized Monte Carlo</h2><span id='topic+MaxMC-package'></span>

<h3>Description</h3>

<p>Functions that implement the Maximized Monte Carlo technique based on
Dufour, J.-M. (2006), Monte Carlo Tests with nuisance parameters:
A general approach to finite sample inference and nonstandard asymptotics in econometrics.
<em>Journal of Econometrics</em>, <b>133(2)</b>, 443-447.
</p>
<p>The main functions of <span class="pkg">MaxMC</span> are <code><a href="#topic+mmc">mmc</a></code> and <code><a href="#topic+mc">mc</a></code>.
</p>


<h3>Author(s)</h3>

<p>Julien Neves, jmn252@cornell.edu (Maintainer)
</p>
<p>Jean-Marie Dufour, jean-marie.dufour@mcgill.ca
</p>


<h3>References</h3>

<p>Dufour, J.-M. (2006), Monte Carlo Tests with nuisance parameters:
A general approach to finite sample inference and nonstandard asymptotics in econometrics.
<em>Journal of Econometrics</em>, <b>133(2)</b>, 443-447.
</p>
<p>Dufour, J.-M. and Khalaf L. (2003), Monte Carlo Test Methods in Econometrics.
in Badi H. Baltagi, ed., <em>A Companion to Theoretical Econometrics</em>, Blackwell Publishing Ltd, 494-519.
</p>

<hr>
<h2 id='get_control'>Format the optimization method controls</h2><span id='topic+get_control'></span>

<h3>Description</h3>

<p>This function provides a way to merge the user specified controls for the
optimization methods with their respective default controls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_control(method, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_control_+3A_method">method</code></td>
<td>
<p>A character string. Type of algorithm to be
used for global optimization. The four available methods
are simulated annealing (<code><a href="GenSA.html#topic+GenSA">GenSA</a></code>), particle swarm (<code><a href="pso.html#topic+psoptim">psoptim</a></code>),
genetic algorithm (<code><a href="GA.html#topic+GA">GA</a></code>), and grid search (<code><a href="NMOF.html#topic+gridSearch">gridSearch</a></code>)
Default is <code>GenSA</code>,</p>
</td></tr>
<tr><td><code id="get_control_+3A_control">control</code></td>
<td>
<p>A list. Arguments to be used to control the
behavior of the algorithm chosen in <code>method</code>. See controls section for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list. Arguments to be used to control the behavior
of the algorithm chosen in <code>method</code>.
</p>

<hr>
<h2 id='mc'>Monte Carlo with Tie-Breaker</h2><span id='topic+mc'></span>

<h3>Description</h3>

<p>Find the Monte Carlo (MC) p-value by generating N replications
of a statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc(
  y,
  statistic,
  ...,
  dgp = function(y) sample(y, replace = TRUE),
  N = 99,
  type = c("geq", "leq", "absolute", "two-tailed")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mc_+3A_y">y</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="mc_+3A_statistic">statistic</code></td>
<td>
<p>A function or a character string that specifies
how the statistic is computed. The function needs to input the
<code>y</code> and output a scalar.</p>
</td></tr>
<tr><td><code id="mc_+3A_...">...</code></td>
<td>
<p>Other named arguments for statistic which are
passed unchanged each time it is called</p>
</td></tr>
<tr><td><code id="mc_+3A_dgp">dgp</code></td>
<td>
<p>A function. The function inputs the first argument
<code>y</code> and outputs a simulated <code>y</code>. It should represent the
data generating process under the null. Default value is the function
<code>sample(y, replace = TRUE)</code>, i.e. the
bootstrap resampling of <code>y</code>.</p>
</td></tr>
<tr><td><code id="mc_+3A_n">N</code></td>
<td>
<p>An atomic vector. Number of replications of the test
statistic.</p>
</td></tr>
<tr><td><code id="mc_+3A_type">type</code></td>
<td>
<p>A character string. It specifies the type of test
the p-value function produces. The possible values are
<code>geq</code>, <code>leq</code>, <code>absolute</code> and <code>two-tailed</code>.
Default is <code>geq</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>dgp</code> function defined by the user is used to
generate new observations in order to compute the simulated
statistics.
</p>
<p>Then <code><a href="#topic+pvalue">pvalue</a></code> is applied to the statistic and
its simulated values. <code><a href="#topic+pvalue">pvalue</a></code> computes the
p-value by ranking the statistic compared to its simulated
values. Ties in the ranking are broken according to a uniform
distribution.
</p>
<p>We allow for four types of p-value: <code>leq</code>, <code>geq</code>,
<code>absolute</code> and <code>two-tailed</code>. For one-tailed test,
<code>leq</code> returns the proportion of simulated values smaller
than the statistic while <code>geq</code> returns the proportion of
simulated values greater than the statistic. For two-tailed
test with a symmetric statistic, one can use the
absolute value of the statistic and its simulated values to
retrieve a two-tailed test (i.e. type = <code>absolute</code>).
If the statistic is not symmetric, one can specify the p-value
type as <code>two-tailed</code> which is equivalent to twice the minimum
of <code>leq</code> and <code>geq</code>.
</p>
<p>Ties in the ranking are broken according to a uniform
distribution.
</p>


<h3>Value</h3>

<p>The returned value is an object of class <code>mc</code>
containing the following components:
</p>
<table role = "presentation">
<tr><td><code>S0</code></td>
<td>
<p>Observed value of <code>statistic</code>.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>Monte Carlo p-value of <code>statistic</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Data specified in call.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p><code>statistic</code> function specified in call.</p>
</td></tr>
<tr><td><code>dgp</code></td>
<td>
<p><code>dgp</code> function specified in call.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Number of replications specified in call.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p><code>type</code> of p-value specified in call.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Original call to <code>mmc</code>.</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>Value of <code>.Random.seed</code> at the start of
<code>mc</code> call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Dufour, J.-M. (2006), Monte Carlo Tests with nuisance parameters:
A general approach to finite sample inference and nonstandard asymptotics in econometrics.
<em>Journal of Econometrics</em>, <b>133(2)</b>, 443-447.
</p>
<p>Dufour, J.-M. and Khalaf L. (2003), Monte Carlo Test Methods in Econometrics.
in Badi H. Baltagi, ed., <em>A Companion to Theoretical Econometrics</em>, Blackwell Publishing Ltd, 494-519.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmc">mmc</a></code>, <code><a href="#topic+pvalue">pvalue</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1
## Kolmogorov-Smirnov Test using Monte Carlo

# Set seed
set.seed(999)

# Generate sample data
y &lt;- rgamma(8, shape = 2, rate = 1)

# Set data generating process function
dgp &lt;- function(y)  rgamma(length(y), shape = 2, rate = 1)

# Set the statistic function to the Kolomogorov-Smirnov test for gamma distribution
statistic &lt;- function(y){
    out &lt;- ks.test(y, "pgamma", shape = 2, rate = 1)
    return(out$statistic)
}

# Apply the Monte Carlo test with tie-breaker
mc(y, statistic = statistic, dgp = dgp, N = 999, type = "two-tailed")

</code></pre>

<hr>
<h2 id='mmc'>Find the Maximized Monte Carlo (MMC) p-value on a set of nuisance
parameters.</h2><span id='topic+mmc'></span>

<h3>Description</h3>

<p>The <code>dgp</code> function defined by the user is used to
generate new observations in order to compute the simulated
statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmc(
  y,
  statistic,
  ...,
  dgp = function(y, v) sample(y, replace = TRUE),
  est = NULL,
  lower,
  upper,
  N = 99,
  type = c("geq", "leq", "absolute", "two-tailed"),
  method = c("GenSA", "pso", "GA", "gridSearch"),
  control = list(),
  alpha = NULL,
  monitor = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mmc_+3A_y">y</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="mmc_+3A_statistic">statistic</code></td>
<td>
<p>A function or a character string that specifies
how the statistic is computed. The function needs to input the
<code>y</code> and output a scalar.</p>
</td></tr>
<tr><td><code id="mmc_+3A_...">...</code></td>
<td>
<p>Other named arguments for statistic which are
passed unchanged each time it is called</p>
</td></tr>
<tr><td><code id="mmc_+3A_dgp">dgp</code></td>
<td>
<p>A function. The function inputs the first argument
<code>y</code> and a vector of nuisance parameters <code>v</code> and outputs a simulated <code>y</code>.
It should represent the data generating process under the null.
Default value is the function <code>sample(y, replace = TRUE)</code>, i.e. the
bootstrap resampling of <code>y</code>.</p>
</td></tr>
<tr><td><code id="mmc_+3A_est">est</code></td>
<td>
<p>A vector with length of v. It is the starting
point of the algorithm. If <code>est</code> is a consistent estimate
of <code>v</code> then <code>mmc</code> will return both the MMC and Local Monte Carlo (LMC).
Default is NULL, in which case, default values will be generated automatically.</p>
</td></tr>
<tr><td><code id="mmc_+3A_lower">lower</code></td>
<td>
<p>A vector with length of v. Lower bounds for
nuisance parameters under the null. See Details.</p>
</td></tr>
<tr><td><code id="mmc_+3A_upper">upper</code></td>
<td>
<p>A vector with length of v. Upper bounds for
nuisance parameters under the null. See Details.</p>
</td></tr>
<tr><td><code id="mmc_+3A_n">N</code></td>
<td>
<p>An atomic vector. Number of replications of the test
statistic.</p>
</td></tr>
<tr><td><code id="mmc_+3A_type">type</code></td>
<td>
<p>A character string. It specifies the type of test
the p-value function produces. The possible values are
<code>geq</code>, <code>leq</code>, <code>absolute</code> and <code>two-tailed</code>.
Default is <code>geq</code>.</p>
</td></tr>
<tr><td><code id="mmc_+3A_method">method</code></td>
<td>
<p>A character string. Type of algorithm to be
used for global optimization. The four available methods
are simulated annealing (<code><a href="GenSA.html#topic+GenSA">GenSA</a></code>), particle swarm (<code><a href="pso.html#topic+psoptim">psoptim</a></code>),
genetic algorithm (<code><a href="GA.html#topic+GA">GA</a></code>), and grid search (<code><a href="NMOF.html#topic+gridSearch">gridSearch</a></code>)
Default is <code>GenSA</code>,</p>
</td></tr>
<tr><td><code id="mmc_+3A_control">control</code></td>
<td>
<p>A list. Arguments to be used to control the
behavior of the algorithm chosen in <code>method</code>. See controls section for more details.</p>
</td></tr>
<tr><td><code id="mmc_+3A_alpha">alpha</code></td>
<td>
<p>An atomic vector. If <code>mmc</code> finds a
p-value over <code>alpha</code>, then the algorithm will stop. This is particularly
useful if we are only looking at testing a hypothesis at a particular level.
Default is NULL.</p>
</td></tr>
<tr><td><code id="mmc_+3A_monitor">monitor</code></td>
<td>
<p>A logical. If set to TRUE, then the p-values at every
iteration and the cumulative maximum p-value are plotted on a graphical device.
Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Then <code><a href="#topic+pvalue">pvalue</a></code> is applied to the statistic and
its simulated values.<code><a href="#topic+pvalue">pvalue</a></code> computes the
p-value by ranking the statistic compared to its simulated
values. Ties in the ranking are broken according to a
uniform distribution.
</p>
<p>We allow for four types of p-value: <code>leq</code>, <code>geq</code>,
<code>absolute</code> and <code>two-tailed</code>. For one-tailed test,
<code>leq</code> returns the proportion of simulated values smaller
than the statistic while <code>geq</code> returns the proportion of
simulated values greater than the statistic. For two-tailed
test with a symmetric statistic, one can use the
absolute value of the statistic and its simulated values to
retrieve a two-tailed test (i.e. type = <code>absolute</code>).
If the statistic is not symmetric, one can specify the p-value
type as <code>two-tailed</code> which is equivalent to twice the minimum
of <code>leq</code> and <code>geq</code>.
</p>
<p>Ties in the ranking are broken according to a uniform
distribution.
</p>
<p>Usually, to ensure that the MMC procedure is exact, <code>lower</code> and
<code>upper</code> must be set such that any theoretically possible
values for the nuisance parameters under the null are covered. This
can be computationally expansive.
</p>
<p>Alternatively, the consistent set estimate MMC method (CSEMMC)
which is applicable when a consistent set estimator of the nuisance
parameters is available can be used. If such set is available, by setting
<code>lower</code> and <code>upper</code> accordingly, <code>mmc</code> will yield
an asymptotically justified version of the MMC procedure.
</p>
<p>One version of this procedure is the Two-stage constrained maximized
Monte Carlo test, where first a confidence set of level
<code class="reqn">1-\alpha_1</code> for the nuisance parameters is obtained and then the MMC with
confidence level <code class="reqn">\alpha_2</code> is taken over this particular set.
This procedure yields a conservative test with level
<code class="reqn">\alpha=\alpha_1+\alpha_2</code>. Note that we generally advise
against using asymptotic Wald-type confidence intervals based on
their poor performance. Instead, it is simply best to build
confidence set using problem-specific tools.
</p>


<h3>Value</h3>

<p>The returned value is an object of class <code>mmc</code>
containing the following components:
</p>
<table role = "presentation">
<tr><td><code>S0</code></td>
<td>
<p>Observed value of <code>statistic</code>.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>Maximized Monte Carlo p-value of <code>statistic</code> under null.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Data specified in call.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p><code>statistic</code> function specified in
call.</p>
</td></tr>
<tr><td><code>dgp</code></td>
<td>
<p><code>dgp</code> function specified in call.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p><code>est</code> vector if specified in call.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p><code>lower</code> vector if specified in call.</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p><code>upper</code> vector if specified in call.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Number of replications specified in call.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p><code>type</code> of p-value specified in call.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p><code>method</code> specified in call.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Original call to <code>mmc</code>.</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>Value of <code>.Random.seed</code> at the start of
<code>mmc</code> call.</p>
</td></tr>
<tr><td><code>lmc</code></td>
<td>
<p>If <code>par</code> is specified, it returns an
object of class <code>mc</code> corresponding to the Local Monte
Carlo test.</p>
</td></tr>
<tr><td><code>opt_result</code></td>
<td>
<p>An object returning the optimization
results.</p>
</td></tr>
<tr><td><code>rejection</code></td>
<td>
<p>If <code>alpha</code> is specified, it returns
a vector specifying whether the hypothesis was rejected at level <code>alpha</code>.</p>
</td></tr>
</table>


<h3>Controls</h3>



<h4>Controls - <code><a href="GenSA.html#topic+GenSA">GenSA</a></code></h4>


<dl>
<dt>maxit</dt><dd><p>Integer. Maximum number of iterations of
the algorithm. Defaults to
1000.</p>
</dd>
<dt>nb.stop.improvement</dt><dd><p>Integer. The program will
stop when there is no any improvement in
nb.stop.improvement steps. Defaults to 25</p>
</dd>
<dt>smooth</dt><dd><p>Logical.TRUE when the objective function
is smooth, or differentiable almost everywhere in the
region of par, FALSE otherwise. Default value is TRUE.</p>
</dd>
<dt>max.call</dt><dd><p>Integer. Maximum number of call of the
objective function. Default is set to 1e7.</p>
</dd>
<dt>max.time</dt><dd><p>Numeric. Maximum running time in seconds.</p>
</dd>
<dt>temperature</dt><dd><p>Numeric. Initial value for temperature.</p>
</dd>
<dt>visiting.param</dt><dd><p>Numeric. Parameter for visiting
distribution.</p>
</dd>
<dt>acceptance.param</dt><dd><p>Numeric. Parameter for acceptance
distribution.</p>
</dd>
<dt>simple.function</dt><dd><p>Logical. FALSE means that the
objective function has only a few local minima. Default
is FALSE which means that the objective function is
complicated with many local minima.</p>
</dd>
</dl>




<h4>Controls - <code><a href="pso.html#topic+psoptim">psoptim</a></code></h4>


<dl>
<dt>maxit</dt><dd><p>The maximum number of iterations. Defaults to
1000.</p>
</dd>
<dt>maxf</dt><dd><p>The maximum number of function evaluations
(not considering any performed during numerical gradient
computation). Defaults to Inf.</p>
</dd>
<dt>reltol</dt><dd><p>The tolerance for restarting. Once the
maximal distance between the best particle and all other
particles is less than reltol*d the algorithm restarts.
Defaults to 0 which disables the check for restarting.</p>
</dd>
<dt>s</dt><dd><p>The swarm size. Defaults to
floor(10+2*sqrt(length(par))) unless type is &quot;SPSO2011&quot;
in which case the default is 40.</p>
</dd>
<dt>k</dt><dd><p>The exponent for calculating number of informants.
Defaults to 3.</p>
</dd>
<dt>p</dt><dd><p>The average percentage of informants for each
particle. A value of 1 implies that all particles are
fully informed. Defaults to 1-(1-1/s)^k.</p>
</dd>
<dt>w</dt><dd><p>The exploitation constant. A vector of length 1
or 2. If the length is two, the actual constant used is
gradially changed from w[1] to w[2] as the number of
iterations or function evaluations approach the limit
provided. Defaults to 1/(2*log(2)).</p>
</dd>
<dt>c.p</dt><dd><p>The local exploration constant. Defaults to
.5+log(2).</p>
</dd>
<dt>c.g</dt><dd><p>The global exploration constant. Defaults to
.5+log(2).</p>
</dd>
<dt>d</dt><dd><p>The diameter of the search space. Defaults to the
euclidean distance between upper and lower.</p>
</dd>
<dt>v.max</dt><dd><p>The maximal (euclidean) length of the velocity
vector. Defaults to NA which disables clamping of the
velocity. However, if specified the actual clamping of the
length is v.max*d.</p>
</dd>
<dt>rand.order</dt><dd><p>Logical; if TRUE the particles are
processed in random order. If vectorize is TRUE then the
value of rand.order does not matter. Defaults to TRUE.</p>
</dd>
<dt>max.restart</dt><dd><p>The maximum number of restarts.
Defaults to Inf.</p>
</dd>
<dt>maxit.stagnate</dt><dd><p>The maximum number of iterations
without improvement. Defaults to 25</p>
</dd>
<dt>vectorize</dt><dd><p>Logical; if TRUE the particles are
processed in a vectorized manner. This reduces the
overhead associated with iterating over each particle and
may be more time efficient for cheap function evaluations.
Defaults to TRUE.</p>
</dd>
<dt>type</dt><dd><p>Character vector which describes which
reference implementation of SPSO is followed. Can take
the value of &quot;SPSO2007&quot; or &quot;SPSO2011&quot;. Defaults to
&quot;SPSO2007&quot;.</p>
</dd>
</dl>




<h4>Controls - <code><a href="GA.html#topic+GA">GA</a></code></h4>


<dl>
<dt>popSize</dt><dd><p>the population size.</p>
</dd>
<dt>pcrossover</dt><dd><p>the probability of crossover between
pairs of chromosomes. Typically this is a large value and
by default is set to 0.8.</p>
</dd>
<dt>pmutation</dt><dd><p>the probability of mutation in a parent
chromosome. Usually mutation occurs with a small
probability, and by default is set to 0.1.</p>
</dd>
<dt>updatePop</dt><dd><p>a logical defaulting to FALSE. If set at
TRUE the first attribute attached to the value returned by
the user-defined fitness function is used to update the
population. Be careful though, this is an experimental
feature!</p>
</dd>
<dt>postFitness</dt><dd><p>a user-defined function which, if
provided, receives the current ga-class object as input,
performs post fitness-evaluation steps, then returns an
updated version of the object which is used to update the
GA search. Be careful though, this is an experimental
feature!</p>
</dd>
<dt>maxiter</dt><dd><p>the maximum number of iterations to run
before the GA search is halted.</p>
</dd>
<dt>run</dt><dd><p>the number of consecutive generations without
any improvement in the best fitness value before the GA
is stopped.</p>
</dd>
<dt>optim</dt><dd><p>a logical defaulting to FALSE determining
whether or not a local search using general-purpose
optimisation algorithms should be used. See argument
optimArgs for further details and finer control.</p>
</dd>
<dt>optimArgs</dt><dd><p>a list controlling the local search
algorithm with the following components:
</p>

<dl>
<dt>method</dt><dd><p>a string specifying the general-purpose
optimisation method to be used, by default is set to
&quot;L-BFGS-B&quot;. Other possible methods are those reported
in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</dd>
<dt>poptim</dt><dd><p>a value in the range [0,1] specifying the
probability of performing a local search at each
iteration of GA (default 0.1).</p>
</dd>
<dt>pressel</dt><dd><p>a value in the range [0,1] specifying the
pressure selection (default 0.5). The local search is
started from a random solution selected with probability
proportional to fitness. High values of pressel tend to
select the solutions with the largest fitness, whereas
low values of pressel assign quasi-uniform probabilities
to any solution.</p>
</dd>
<dt>control</dt><dd><p>a list of control parameters. See 'Details'
section in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</dd></dl>

</dd>
<dt>keepBest</dt><dd><p>a logical argument specifying if best
solutions at each iteration should be saved in a slot
called bestSol. See ga-class.</p>
</dd>
<dt>parallel</dt><dd><p>a logical argument specifying if parallel
computing should be used (TRUE) or not (FALSE, default)
for evaluating the fitness function. This argument could
also be used to specify the number of cores to employ; by
default, this is taken from detectCores. Finally, the
functionality of parallelization depends on system OS:
on Windows only 'snow' type functionality is available,
while on Unix/Linux/Mac OSX both 'snow' and 'multicore'
(default) functionalities are available.</p>
</dd>
</dl>




<h4>Controls - <code><a href="NMOF.html#topic+gridSearch">gridSearch</a></code></h4>


<dl>
<dt>n</dt><dd><p>the number of levels. Default is 10.</p>
</dd>
<dt>printDetail</dt><dd><p>print information on the number of
objective function evaluations</p>
</dd>
<dt>method</dt><dd><p>can be loop (the default), multicore or
snow. See Details.</p>
</dd>
<dt>mc.control</dt><dd><p>a list containing settings that will be
passed to mclapply if method is multicore. Must be a list
of named elements; see the documentation of mclapply in
parallel.</p>
</dd>
<dt>cl</dt><dd><p>default is NULL. If method snow is used, this
must be a cluster object or an integer (the number of
cores).</p>
</dd>
<dt>keepNames</dt><dd><p>logical: should the names of levels be
kept?</p>
</dd>
<dt>asList</dt><dd><p>does fun expect a list? Default is FALSE</p>
</dd>
</dl>




<h3>References</h3>

<p>Dufour, J.-M. (2006), Monte Carlo Tests with nuisance parameters:
A general approach to finite sample inference and nonstandard asymptotics in econometrics.
<em>Journal of Econometrics</em>, <b>133(2)</b>, 443-447.
</p>
<p>Dufour, J.-M. and Khalaf L. (2003), Monte Carlo Test Methods in Econometrics.
in Badi H. Baltagi, ed., <em>A Companion to Theoretical Econometrics</em>, Blackwell Publishing Ltd, 494-519.
</p>
<p>Y. Xiang, S. Gubian. B. Suomela, J. Hoeng (2013). Generalized Simulated Annealing for
Efficient Global Optimization: the GenSA Package for R. <em>The R Journal</em>, Volume
<b>5/1</b>, June 2013.
URL <a href="https://journal.r-project.org/">https://journal.r-project.org/</a>.
</p>
<p>Claus Bendtsen. (2012). pso: Particle Swarm Optimization. R package version 1.0.3.
<a href="https://CRAN.R-project.org/package=pso">https://CRAN.R-project.org/package=pso</a>
</p>
<p>Luca Scrucca (2013). GA: A Package for Genetic Algorithms in R. <em>Journal of
Statistical
Software</em>, <b>53(4)</b>, 1-37. URL <a href="https://www.jstatsoft.org/article/view/v053i04">https://www.jstatsoft.org/article/view/v053i04</a>.
</p>
<p>Luca Scrucca (2016). On some extensions to GA package: hybrid optimisation,
parallelisation and islands evolution. Submitted to <em>R Journal</em>. Pre-print available at
arXiv URL <a href="http://arxiv.org/abs/1605.01931">http://arxiv.org/abs/1605.01931</a>.
</p>
<p>Manfred Gilli (2011), Dietmar Maringer and Enrico Schumann. Numerical Methods and
Optimization
in Finance. <em>Academic Press</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mc">mc</a></code>, <code><a href="#topic+pvalue">pvalue</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1
## Exact Unit Root Test
library(fUnitRoots)

# Set seed
set.seed(123)

# Generate an AR(2) process with phi = (-1.5,0.5), and n = 25
y &lt;- filter(rnorm(25), c(-1.5, 0.5), method = "recursive")

# Set bounds for the nuisance parameter v
lower &lt;- -1
upper &lt;- 1

# Set the function to generate an AR(2) integrated process
dgp &lt;- function(y, v) {
    ran.y &lt;- filter(rnorm(length(y)), c(1-v,v), method = "recursive")
}

# Set the Augmented-Dicky Fuller statistic
statistic &lt;- function(y){
    out &lt;- suppressWarnings(adfTest(y, lags = 2, type = "nc"))
    return(out@test$statistic)
}

# Apply the mmc procedure
mmc(y, statistic = statistic , dgp = dgp, lower = lower,
    upper = upper, N = 99, type = "leq", method = "GenSA",
    control = list(max.time = 2))


## Example 2
## Behrens-Fisher Problem
library(MASS)

# Set seed
set.seed(123)

# Generate sample x1 ~ N(0,1) and x2 ~ N(0,4)
x1 &lt;- rnorm(15, mean = 0, sd = 1)
x2 &lt;- rnorm(25, mean = 0, sd = 2)
data &lt;- list(x1 = x1, x2 = x2)

# Fit a normal distribution on x1 and x2 using maximum likelihood
fit1 &lt;- fitdistr(x1, "normal")
fit2 &lt;- fitdistr(x2, "normal")

# Extract the estimate for the nuisance parameters v = (sd_1, sd_2)
est &lt;- c(fit1$estimate["sd"], fit2$estimate["sd"])

# Set the bounds of the nuisance parameters equal to the 99% CI
lower &lt;- est - 2.577 * c(fit2$sd["sd"], fit1$sd["sd"])
upper &lt;- est + 2.577 * c(fit2$sd["sd"], fit1$sd["sd"])

# Set the function for the DGP under the null (i.e. two population means are equal)
dgp &lt;- function(data, v) {
    x1 &lt;- rnorm(length(data$x1), mean = 0, sd = v[1])
    x2 &lt;- rnorm(length(data$x2), mean = 0, sd = v[2])
    return(list(x1 = x1, x2 = x2))
}

# Set the statistic function to Welch's t-test
welch &lt;- function(data) {
    test &lt;- t.test(data$x2, data$x1)
    return(test$statistic)
}

# Apply Welch's t-test
t.test(data$x2, data$x1)

# Apply the mmc procedure
mmc(y = data, statistic = welch, dgp = dgp, est = est,
    lower = lower, upper = upper, N = 99,	type = "absolute",
    method = "pso")

</code></pre>

<hr>
<h2 id='monitor_mmc'>Format the optimization method controls</h2><span id='topic+monitor_mmc'></span>

<h3>Description</h3>

<p>This function provides a way to merge the user specified controls for the
optimization methods with their respective default controls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monitor_mmc(object, alpha = NULL, monitor = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="monitor_mmc_+3A_object">object</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="monitor_mmc_+3A_alpha">alpha</code></td>
<td>
<p>An atomic vector. If <code>mmc</code> finds a
p-value over <code>alpha</code>, then the algorithm will stop. This is particularly
useful if we are only looking at testing a hypothesis at a particular level.
Default is NULL.</p>
</td></tr>
<tr><td><code id="monitor_mmc_+3A_monitor">monitor</code></td>
<td>
<p>A logical. If set to TRUE, then the p-values at every
iteration and the cumulative maximum p-value are plotted on a graphical device.
Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list. Arguments to be used to control the behavior
of the algorithm chosen in <code>method</code>.
</p>

<hr>
<h2 id='plot.mmc'>Plot a <code>mmc</code> Object</h2><span id='topic+plot.mmc'></span>

<h3>Description</h3>

<p>The <code>plot()</code> method for objects of the
class <code>mmc</code> gives a plot of the best and current p-value found during the iterations of <code>mmc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmc'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mmc_+3A_x">x</code></td>
<td>
<p>An object of class <code>mmc</code>.</p>
</td></tr>
<tr><td><code id="plot.mmc_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as <a href="graphics.html#topic+graphical+20parameters">graphical parameters</a> (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>mmc</code> object is returned invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example
library(fUnitRoots)
# Set seed
set.seed(123)

# Generate an AR(2) process with phi = (-1.5,0.5), and n = 25
y &lt;- filter(rnorm(25), c(-1.5, 0.5), method = "recursive")

# Set bounds for the nuisance parameter v
lower &lt;- -1
upper &lt;- 1

# Set the function to generate an AR(2) integrated process
dgp &lt;- function(y, v) {
    ran.y &lt;- filter(rnorm(length(y)), c(1-v,v), method = "recursive")
}

# Set the Augmented-Dicky Fuller statistic
statistic &lt;- function(y){
    out &lt;- suppressWarnings(adfTest(y, lags = 2, type = "nc"))
    return(out@test$statistic)
}

# Apply the mmc procedure
est &lt;- mmc(y, statistic = statistic , dgp = dgp, lower = lower,
           upper = upper, N = 99, type = "leq", method = "GenSA",
           control = list(max.time = 2))

# Plot result of object of class 'mmc'
plot(est)
</code></pre>

<hr>
<h2 id='print.mc'>Print a Summary of a <code>mc</code> Object</h2><span id='topic+print.mc'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects of the
class <code>mc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mc'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mc_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.mc_+3A_digits">digits</code></td>
<td>
<p>minimal number of <em>significant</em> digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.mc_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>mc</code> object is returned invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example
# Set seed
set.seed(999)

# Generate sample data
y &lt;- rgamma(8, shape = 2, rate = 1)

# Set data generating process function
dgp &lt;- function(y)  rgamma(length(y), shape = 2, rate = 1)

# Set the statistic function to the Kolomogorov-Smirnov test for gamma distribution
statistic &lt;- function(y){
    out &lt;- ks.test(y, "pgamma", shape = 2, rate = 1)
    return(out$statistic)
}

# Apply the Monte Carlo test with tie-breaker
est &lt;- mc(y, statistic = statistic, dgp = dgp, N = 999, type = "two-tailed")

# Print result of object of class 'mc'
print(est)
</code></pre>

<hr>
<h2 id='print.mmc'>Print a Summary of a <code>mmc</code> Object</h2><span id='topic+print.mmc'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects of the
class <code>mmc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmc'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mmc_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.mmc_+3A_digits">digits</code></td>
<td>
<p>minimal number of <em>significant</em> digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.mmc_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>mmc</code> object is returned invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example
library(fUnitRoots)
# Set seed
set.seed(123)

# Generate an AR(2) process with phi = (-1.5,0.5), and n = 25
y &lt;- filter(rnorm(25), c(-1.5, 0.5), method = "recursive")

# Set bounds for the nuisance parameter v
lower &lt;- -1
upper &lt;- 1

# Set the function to generate an AR(2) integrated process
dgp &lt;- function(y, v) {
    ran.y &lt;- filter(rnorm(length(y)), c(1-v,v), method = "recursive")
}

# Set the Augmented-Dicky Fuller statistic
statistic &lt;- function(y){
    out &lt;- suppressWarnings(adfTest(y, lags = 2, type = "nc"))
    return(out@test$statistic)
}

# Apply the mmc procedure
est &lt;- mmc(y, statistic = statistic , dgp = dgp, lower = lower,
           upper = upper, N = 99, type = "leq", method = "GenSA",
           control = list(max.time = 2))

# Print result of object of class 'mmc'
print(est)
</code></pre>

<hr>
<h2 id='pvalue'>p-value Function</h2><span id='topic+pvalue'></span>

<h3>Description</h3>

<p>Computes the p-value of the statistic by computing its rank
compared to its simulated values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pvalue(S0, S, type = c("geq", "leq", "absolute", "two-tailed"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pvalue_+3A_s0">S0</code></td>
<td>
<p>An atomic vector. Value of the test statistic
applied to the data.</p>
</td></tr>
<tr><td><code id="pvalue_+3A_s">S</code></td>
<td>
<p>A vector. It consists of replications of the test statistic.
<code>S</code> must have length greater than one.</p>
</td></tr>
<tr><td><code id="pvalue_+3A_type">type</code></td>
<td>
<p>A character string. It specifies the type of test
the p-value function produces. The possible values are
<code>geq</code>, <code>leq</code>, <code>absolute</code> and <code>two-tailed</code>.
Default is <code>geq</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We allow for four types of p-value: <code>leq</code>, <code>geq</code>,
<code>absolute</code> and <code>two-tailed</code>. For one-tailed test,
<code>leq</code> returns the proportion of simulated values smaller
than the statistic while <code>geq</code> returns the proportion of
simulated values greater than the statistic. For two-tailed
test with a symmetric satistic, one can use the
absolute value of the statistic and its simulated values to
retrieve a two-tailed test (i.e. type = <code>absolute</code>).
If the statistic is not symmetric, one can specify the p-value
type as <code>two-tailed</code> which is equivalent to twice the minimum
of <code>leq</code> and <code>geq</code>.
</p>
<p>Ties in the ranking are broken according to a uniform
distribution.
</p>


<h3>Value</h3>

<p>The p-value of the statistic <code>S0</code> given a vector of replications <code>S</code>.
</p>


<h3>References</h3>

<p>Dufour, J.-M. (2006), Monte Carlo Tests with nuisance parameters:
A general approach to finite sample inference and nonstandard asymptotics in econometrics.
<em>Journal of Econometrics</em>, <b>133(2)</b>, 443-447.
</p>
<p>Dufour, J.-M. and Khalaf L. (2003), Monte Carlo Test Methods in Econometrics.
in Badi H. Baltagi, ed., <em>A Companion to Theoretical Econometrics</em>, Blackwell Publishing Ltd, 494-519.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate sample S0 and simulate statistics
S0 = 0
S = rnorm(99)

# Compute p-value
pvalue(S0, S, type = "geq")
</code></pre>

<hr>
<h2 id='return_mc'>S3 class <code>mc</code> object generating function</h2><span id='topic+return_mc'></span>

<h3>Description</h3>

<p>S3 class <code>mc</code> object generating function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>return_mc(S0, y, statistic, dgp, N, type, call, seed, pval)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="return_mc_+3A_s0">S0</code></td>
<td>
<p>An atomic vector. Value of the test statistic
applied to the data.</p>
</td></tr>
<tr><td><code id="return_mc_+3A_y">y</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="return_mc_+3A_statistic">statistic</code></td>
<td>
<p>A function or a character string that specifies
how the statistic is computed. The function needs to input the
<code>y</code> and output a scalar.</p>
</td></tr>
<tr><td><code id="return_mc_+3A_dgp">dgp</code></td>
<td>
<p>A function. The function inputs the first argument
<code>y</code> and outputs a simulated <code>y</code>. It should represent the
data generating process under the null. Default value is the function
<code>sample(y, replace = TRUE)</code>, i.e. the
bootstrap resampling of <code>y</code>.</p>
</td></tr>
<tr><td><code id="return_mc_+3A_n">N</code></td>
<td>
<p>An atomic vector. Number of replications of the test
statistic.</p>
</td></tr>
<tr><td><code id="return_mc_+3A_type">type</code></td>
<td>
<p>A character string. It specifies the type of test
the p-value function produces. The possible values are
<code>geq</code>, <code>leq</code>, <code>absolute</code> and <code>two-tailed</code>.
Default is <code>geq</code>.</p>
</td></tr>
<tr><td><code id="return_mc_+3A_call">call</code></td>
<td>
<p>An object of class <code>call</code>. Original call to <code>mmc</code></p>
</td></tr>
<tr><td><code id="return_mc_+3A_seed">seed</code></td>
<td>
<p>An integer vector. Value of <code>.Random.seed</code> at the start of
<code>mmc</code> call.</p>
</td></tr>
<tr><td><code id="return_mc_+3A_pval">pval</code></td>
<td>
<p>An atomic vector. Monte Carlo p-value of <code>statistic</code></p>
</td></tr>
</table>

<hr>
<h2 id='return_mmc'>S3 class <code>mmc</code> object generating function</h2><span id='topic+return_mmc'></span>

<h3>Description</h3>

<p>S3 class <code>mmc</code> object generating function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>return_mmc(
  S0,
  y,
  statistic,
  dgp,
  est,
  lower,
  upper,
  N,
  type,
  method,
  alpha,
  control,
  call,
  seed,
  lmc,
  opt_result,
  opt_trace
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="return_mmc_+3A_s0">S0</code></td>
<td>
<p>An atomic vector. Value of the test statistic
applied to the data.</p>
</td></tr>
<tr><td><code id="return_mmc_+3A_y">y</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="return_mmc_+3A_statistic">statistic</code></td>
<td>
<p>A function or a character string that specifies
how the statistic is computed. The function needs to input the
<code>y</code> and output a scalar.</p>
</td></tr>
<tr><td><code id="return_mmc_+3A_dgp">dgp</code></td>
<td>
<p>A function. The function inputs the first argument
<code>y</code> and a vector of nuisance parameters <code>v</code> and outputs a simulated <code>y</code>.
It should represent the data generating process under the null.
Default value is the function <code>sample(y, replace = TRUE)</code>, i.e. the
bootstrap resampling of <code>y</code>.</p>
</td></tr>
<tr><td><code id="return_mmc_+3A_est">est</code></td>
<td>
<p>A vector with length of v. It is the starting
point of the algorithm. If <code>est</code> is a consistent estimate
of <code>v</code> then <code>mmc</code> will return both the MMC and Local Monte Carlo (LMC).
Default is NULL, in which case, default values will be generated automatically.</p>
</td></tr>
<tr><td><code id="return_mmc_+3A_lower">lower</code></td>
<td>
<p>A vector with length of v. Lower bounds for
nuisance parameters under the null. See Details.</p>
</td></tr>
<tr><td><code id="return_mmc_+3A_upper">upper</code></td>
<td>
<p>A vector with length of v. Upper bounds for
nuisance parameters under the null. See Details.</p>
</td></tr>
<tr><td><code id="return_mmc_+3A_n">N</code></td>
<td>
<p>An atomic vector. Number of replications of the test
statistic.</p>
</td></tr>
<tr><td><code id="return_mmc_+3A_type">type</code></td>
<td>
<p>A character string. It specifies the type of test
the p-value function produces. The possible values are
<code>geq</code>, <code>leq</code>, <code>absolute</code> and <code>two-tailed</code>.
Default is <code>geq</code>.</p>
</td></tr>
<tr><td><code id="return_mmc_+3A_method">method</code></td>
<td>
<p>A character string. Type of algorithm to be
used for global optimization. The four available methods
are simulated annealing (<code><a href="GenSA.html#topic+GenSA">GenSA</a></code>), particle swarm (<code><a href="pso.html#topic+psoptim">psoptim</a></code>),
genetic algorithm (<code><a href="GA.html#topic+GA">GA</a></code>), and grid search (<code><a href="NMOF.html#topic+gridSearch">gridSearch</a></code>)
Default is <code>GenSA</code>,</p>
</td></tr>
<tr><td><code id="return_mmc_+3A_alpha">alpha</code></td>
<td>
<p>An atomic vector. If <code>mmc</code> finds a
p-value over <code>alpha</code>, then the algorithm will stop. This is particularly
useful if we are only looking at testing a hypothesis at a particular level.
Default is NULL.</p>
</td></tr>
<tr><td><code id="return_mmc_+3A_control">control</code></td>
<td>
<p>A list. Arguments to be used to control the
behavior of the algorithm chosen in <code>method</code>. See controls section for more details.</p>
</td></tr>
<tr><td><code id="return_mmc_+3A_call">call</code></td>
<td>
<p>An object of class <code>call</code>. Original call to <code>mmc</code></p>
</td></tr>
<tr><td><code id="return_mmc_+3A_seed">seed</code></td>
<td>
<p>An integer vector. Value of <code>.Random.seed</code> at the start of
<code>mmc</code> call.</p>
</td></tr>
<tr><td><code id="return_mmc_+3A_lmc">lmc</code></td>
<td>
<p>An object of class <code>mc</code>. If <code>par</code> is specified, it returns an object
of class <code>mc</code> corresponding the Local Monte Carlo test.</p>
</td></tr>
<tr><td><code id="return_mmc_+3A_opt_result">opt_result</code></td>
<td>
<p>An object returning the optimization results.</p>
</td></tr>
<tr><td><code id="return_mmc_+3A_opt_trace">opt_trace</code></td>
<td>
<p>An object returning the optimization results.</p>
</td></tr>
</table>

<hr>
<h2 id='simulation_mc'>Monte Carlo Simulation</h2><span id='topic+simulation_mc'></span>

<h3>Description</h3>

<p>Generates N Monte Carlo replicates of a statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulation_mc(
  y,
  statistic,
  dgp = function(y) sample(y, replace = TRUE),
  N = 99,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulation_mc_+3A_y">y</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="simulation_mc_+3A_statistic">statistic</code></td>
<td>
<p>A function or a character string that specifies
how the statistic is computed. The function needs to input the
<code>y</code> and output a scalar.</p>
</td></tr>
<tr><td><code id="simulation_mc_+3A_dgp">dgp</code></td>
<td>
<p>A function. The function inputs the first argument
<code>y</code> and outputs a simulated <code>y</code>. It should represent the
data generating process under the null. Default value is the function
<code>sample(y, replace = TRUE)</code>, i.e. the
bootstrap resampling of <code>y</code>.</p>
</td></tr>
<tr><td><code id="simulation_mc_+3A_n">N</code></td>
<td>
<p>An atomic vector. Number of replications of the test
statistic.</p>
</td></tr>
<tr><td><code id="simulation_mc_+3A_...">...</code></td>
<td>
<p>Other named arguments for statistic which are
passed unchanged each time it is called</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of replication of test statistic.
</p>

<hr>
<h2 id='simulation_mmc'>Maximized Monte Carlo Simulation</h2><span id='topic+simulation_mmc'></span>

<h3>Description</h3>

<p>Generates N Monte Carlo replicates of a statistic for given nuisance parameter value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulation_mmc(
  y,
  statistic,
  dgp = function(y, v) sample(y, replace = TRUE),
  v,
  N = 99,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulation_mmc_+3A_y">y</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="simulation_mmc_+3A_statistic">statistic</code></td>
<td>
<p>A function or a character string that specifies
how the statistic is computed. The function needs to input the
<code>y</code> and output a scalar.</p>
</td></tr>
<tr><td><code id="simulation_mmc_+3A_dgp">dgp</code></td>
<td>
<p>A function. The function inputs the first argument
<code>y</code> and a vector of nuisance parameters <code>v</code> and outputs a simulated <code>y</code>.
It should represent the data generating process under the null.
Default value is the function <code>sample(y, replace = TRUE)</code>, i.e. the
bootstrap resampling of <code>y</code>.</p>
</td></tr>
<tr><td><code id="simulation_mmc_+3A_v">v</code></td>
<td>
<p>A vector parameters. The vector <code>v</code> is use to
specify the <code>dgp</code>. Note that if <code>dgp</code> is a
function  of only <code>y</code> then we do not need to specify
<code>v</code>. Default value is NULL.</p>
</td></tr>
<tr><td><code id="simulation_mmc_+3A_n">N</code></td>
<td>
<p>An atomic vector. Number of replications of the test
statistic.</p>
</td></tr>
<tr><td><code id="simulation_mmc_+3A_...">...</code></td>
<td>
<p>Other named arguments for statistic which are
passed unchanged each time it is called</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of replication of test statistic.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
