<!DOCTYPE html><html lang="en"><head><title>Help for package HQM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HQM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#auc.hqm'><p>AUC for the High Quality Marker estimator</p></a></li>
<li><a href='#b_selection'><p>Cross validation bandwidth selection</p></a></li>
<li><a href='#b_selection_prep_g'><p>Preparations for bandwidth selection</p></a></li>
<li><a href='#bs.hqm'><p>Brier score for the High Quality Marker estimator</p></a></li>
<li><a href='#Conf_bands'><p>Confidence bands</p></a></li>
<li><a href='#dataset_split'><p>Split dataset for K-fold cross validation</p></a></li>
<li><a href='#dij'><p>D matrix entries, used for the implementation of the local linear kernel</p></a></li>
<li><a href='#Epan'><p>Epanechnikov kernel</p></a></li>
<li><a href='#g_xt'><p>Computation of a key component for wild bootstrap</p></a></li>
<li><a href='#get_alpha'><p>Marker-only hazard rate</p></a></li>
<li><a href='#get_h_x'><p>Local constant future conditional hazard rate estimator</p></a></li>
<li><a href='#get_h_xll'><p>Local linear future conditional hazard rate estimator</p></a></li>
<li><a href='#h_xt'><p>Local constant future conditional hazard rate estimation at a single time point</p></a></li>
<li><a href='#h_xt_vec'><p>Hqm estimator on the marker grid</p></a></li>
<li><a href='#h_xtll'><p>Local linear future conditional hazard rate estimation at a single time point</p></a></li>
<li><a href='#Kernels'><p>Classical (unmodified) kernel and related functionals</p></a></li>
<li><a href='#lin_interpolate'><p>Linear interpolation</p></a></li>
<li><a href='#llK_b'><p>Local linear kernel</p></a></li>
<li><a href='#llweights'><p>Local linear weight functions</p></a></li>
<li><a href='#make_N+2C+20make_Ni+2C+20make_Y+2C+20make_Yi'><p>Occurance and Exposure on grids</p></a></li>
<li><a href='#make_sf'><p>Survival function from a hazard</p></a></li>
<li><a href='#pbc2'><p>Mayo Clinic Primary Biliary Cirrhosis Data</p></a></li>
<li><a href='#prep_boot'><p>Precomputation for wild bootstrap</p></a></li>
<li><a href='#prep_cv'><p>Prepare for Cross validation bandwidth selection</p></a></li>
<li><a href='#Q1'><p>Bandwidth selection score Q1</p></a></li>
<li><a href='#R_K'><p>Bandwidth selection score R</p></a></li>
<li><a href='#to_id'><p>Event data frame</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Superefficient Estimation of Future Conditional Hazards Based on
Marker Information</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dimitrios Bagkavos &lt;dimitrios.bagkavos@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a nonparametric smoothed kernel estimator for the future conditional hazard rate function when time-dependent covariates are present, a bandwidth selector for the estimator's implementation and pointwise and uniform confidence bands. Methods used in the package refer to Bagkavos, Isakson, Mammen, Nielsen and Proust-Lima (2025)  &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasaf008">doi:10.1093/biomet/asaf008</a>&gt;.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, survival, pec, timeROC, nlme, JM</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-01 12:45:52 UTC; bagav</td>
</tr>
<tr>
<td>Author:</td>
<td>Dimitrios Bagkavos [aut, cre],
  Alex Isakson [ctb],
  Enno Mammen [ctb],
  Jens Nielsen [ctb],
  Cecile Proust-Lima [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-01 14:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='auc.hqm'>AUC for the High Quality Marker estimator</h2><span id='topic+auc.hqm'></span>

<h3>Description</h3>

<p>Calculates the AUC for the HQM estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc.hqm(xin, est, landm, th, event_time_name, status_name)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auc.hqm_+3A_xin">xin</code></td>
<td>
<p>A data frame containing event times and the patient status.</p>
</td></tr>
<tr><td><code id="auc.hqm_+3A_est">est</code></td>
<td>
<p>The HQM estimator values, typically the output of <code><a href="#topic+get_h_x">get_h_x</a></code>. </p>
</td></tr>
<tr><td><code id="auc.hqm_+3A_landm">landm</code></td>
<td>
<p>Landmark time.</p>
</td></tr>
<tr><td><code id="auc.hqm_+3A_th">th</code></td>
<td>
<p>Time horizon.</p>
</td></tr>
<tr><td><code id="auc.hqm_+3A_event_time_name">event_time_name</code></td>
<td>
<p>The column name of the event times in the <code>xin</code> data frame. </p>
</td></tr>
<tr><td><code id="auc.hqm_+3A_status_name">status_name</code></td>
<td>
<p>The column name of the status variable in the <code>xin</code>  frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+auc.hqm">auc.hqm</a></code> implements the AUC calculation for the HQM estimator estimator.
</p>


<h3>Value</h3>

<p>A vector of two values: the landmark time of the calculation and the AUC value.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+bs.hqm">bs.hqm</a> </code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeROC)
library(survival)
 Landmark &lt;- 2
 pbcT1 &lt;- pbc2[which(pbc2$year&lt; Landmark  &amp; pbc2$years&gt; Landmark),]
 timesS2 &lt;- seq(Landmark,14,by=0.5)
 b=0.9
 arg1&lt;- get_h_x(pbcT1, 'albumin', event_time_name = 'years',  
                time_name = 'year', event_name = 'status2', 2, 0.9) 
 br_s2  = seq(Landmark, 14,  length=99)
 sfalb2&lt;- make_sf(    (br_s2[2]-br_s2[1])/4 , arg1)
 tHor &lt;- 1.5
 auc.hq.use&lt;-auc.hqm(pbcT1, sfalb2, Landmark,tHor,  
              event_time_name = 'years', status_name = 'status2')
 auc.hq.use
</code></pre>

<hr>
<h2 id='b_selection'>Cross validation bandwidth selection</h2><span id='topic+b_selection'></span>

<h3>Description</h3>

<p>Implements the bandwidth selection for the future conditional hazard rate <code class="reqn">\hat h_x(t)</code> based on K-fold cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>b_selection(data, marker_name, event_time_name = 'years',
            time_name = 'year', event_name = 'status2', I, b_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="b_selection_+3A_data">data</code></td>
<td>
<p>A data frame of time dependent data points.  Missing values are allowed.</p>
</td></tr>
<tr><td><code id="b_selection_+3A_marker_name">marker_name</code></td>
<td>
<p>The column name of the marker values in the data frame <code><a href="utils.html#topic+data">data</a></code>. </p>
</td></tr>
<tr><td><code id="b_selection_+3A_event_time_name">event_time_name</code></td>
<td>
<p>The column name of the event times in the data frame <code><a href="utils.html#topic+data">data</a></code>. </p>
</td></tr>
<tr><td><code id="b_selection_+3A_time_name">time_name</code></td>
<td>
<p>The column name of the times the marker values were observed in the data frame <code><a href="utils.html#topic+data">data</a></code>.</p>
</td></tr>
<tr><td><code id="b_selection_+3A_event_name">event_name</code></td>
<td>
<p>The column name of the events in the data frame <code><a href="utils.html#topic+data">data</a></code>.</p>
</td></tr>
<tr><td><code id="b_selection_+3A_i">I</code></td>
<td>
<p>Number of observations leave out for a K cross validation.</p>
</td></tr>
<tr><td><code id="b_selection_+3A_b_list">b_list</code></td>
<td>
<p>Vector of bandwidths that need to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+b_selection">b_selection</a></code> implements the cross validation bandwidth selection for the future conditional hazard rate <code class="reqn">\hat h_x(t)</code> given by
</p>
<p style="text-align: center;"><code class="reqn"> b_{CV} = arg min_b \sum_{i = 1}^N \int_0^T \int_s^T Z_i(t)Z_i(s)(\hat{h}_{X_i(s)}(t-s)- h_{X_i(s)}(t-s))^2 dt ds,</code>
</p>

<p>where <code class="reqn">\hat h_x(t)</code> is a smoothed kernel density estimator of <code class="reqn"> h_x(t)</code> and <code class="reqn">Z_i</code> the exposure process of individual <code class="reqn">i</code>. Note that <code class="reqn">\hat h_x(t)</code> is dependent on <code class="reqn">b</code>.
</p>


<h3>Value</h3>

<p>A list with the tested bandwidths and its cross validation scores.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+b_selection_prep_g">b_selection_prep_g</a>, <a href="#topic+Q1">Q1</a>, <a href="#topic+R_K">R_K</a>, <a href="#topic+prep_cv">prep_cv</a>, <a href="#topic+dataset_split">dataset_split</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
I = 26
b_list = seq(0.9, 1.3, 0.1)

b_scores_alb = b_selection(pbc2, 'albumin', 'years', 'year', 'status2', I, b_list)
b_scores_alb[[2]][which.min(b_scores_alb[[1]])]
</code></pre>

<hr>
<h2 id='b_selection_prep_g'>Preparations for bandwidth selection</h2><span id='topic+b_selection_prep_g'></span>

<h3>Description</h3>

<p>Calculates an intermediate part for the K-fold cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>b_selection_prep_g(h_mat, int_X, size_X_grid, n, Yi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="b_selection_prep_g_+3A_h_mat">h_mat</code></td>
<td>
<p>A matrix of the estimator for the future conditional hazard rate for all values <code>x</code> and <code>t</code>.</p>
</td></tr>
<tr><td><code id="b_selection_prep_g_+3A_int_x">int_X</code></td>
<td>
<p>Vector of the position of the observed marker values in the grid for marker values.</p>
</td></tr>
<tr><td><code id="b_selection_prep_g_+3A_size_x_grid">size_X_grid</code></td>
<td>
<p>Numeric value indicating the number of grid points for marker values.</p>
</td></tr>
<tr><td><code id="b_selection_prep_g_+3A_n">n</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
<tr><td><code id="b_selection_prep_g_+3A_yi">Yi</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Yi">make_Yi</a></code> indicating the exposure. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+b_selection_prep_g">b_selection_prep_g</a></code> calculates a key component for the bandwidth selection
</p>
<p style="text-align: center;"><code class="reqn">\hat{g}^{-I_j}_i(t) = \int_0^t Z_i(s) \hat{h}^{-I_j}_{X_i(s)}(t-s) ds,</code>
</p>

<p>where <code class="reqn">\hat{h}^{-I_j}</code> is estimated without information from all counting processes <code class="reqn">i</code> with <code class="reqn">i \in I_j</code> and <code class="reqn">Z</code> is the exposure.
</p>


<h3>Value</h3>

<p>A matrix with <code class="reqn">\hat{g}^{-I_j}_i(t)</code> for all individuals <code>i</code> and time grid points <code>t</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+b_selection">b_selection</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>pbc2_id = to_id(pbc2)
size_s_grid &lt;- size_X_grid &lt;- 100
n = max(as.numeric(pbc2$id))
s = pbc2$year
X = pbc2$serBilir
XX = pbc2_id$serBilir
ss &lt;- pbc2_id$years
delta &lt;- pbc2_id$status2
br_s = seq(0, max(s), max(s)/( size_s_grid-1))
br_X = seq(min(X), max(X), (max(X)-min(X))/( size_X_grid-1))

X_lin = lin_interpolate(br_s, pbc2_id$id, pbc2$id, X, s)

int_X &lt;- findInterval(X_lin, br_X)
int_s = rep(1:length(br_s), n)

N &lt;- make_N(pbc2, pbc2_id, breaks_X=br_X, breaks_s=br_s, ss, XX, delta)
Y &lt;- make_Y(pbc2, pbc2_id, X_lin, br_X, br_s, size_s_grid, size_X_grid, int_s, int_X, 'years', n)

b = 1.7
alpha&lt;-get_alpha(N, Y, b, br_X, K=Epan )

Yi &lt;- make_Yi(pbc2, pbc2_id, X_lin, br_X, br_s, size_s_grid, size_X_grid, int_s, int_X,'years', n)
Ni  &lt;- make_Ni(breaks_s=br_s, size_s_grid, ss, delta, n)

t = 2

h_xt_mat = t(sapply(br_s[1:99], function(si){
                    h_xt_vec(br_X, br_s, size_s_grid, alpha, t, b, Yi, int_X, n)}))

b_selection_prep_g(h_xt_mat, int_X, size_X_grid, n, Yi)
</code></pre>

<hr>
<h2 id='bs.hqm'>Brier score for the High Quality Marker estimator</h2><span id='topic+bs.hqm'></span>

<h3>Description</h3>

<p>Calculates the Brier score for the HQM estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bs.hqm(xin, est, landm, th, event_time_name, status_name)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bs.hqm_+3A_xin">xin</code></td>
<td>
<p>A data frame containing event times and the patient status.</p>
</td></tr>
<tr><td><code id="bs.hqm_+3A_est">est</code></td>
<td>
<p>The HQM estimator values, typically the output of <code><a href="#topic+get_h_x">get_h_x</a></code>. </p>
</td></tr>
<tr><td><code id="bs.hqm_+3A_landm">landm</code></td>
<td>
<p>Landmark time.</p>
</td></tr>
<tr><td><code id="bs.hqm_+3A_th">th</code></td>
<td>
<p>Time horizon.</p>
</td></tr>
<tr><td><code id="bs.hqm_+3A_event_time_name">event_time_name</code></td>
<td>
<p>The column name of the event times in the data frame <code>xin</code>. </p>
</td></tr>
<tr><td><code id="bs.hqm_+3A_status_name">status_name</code></td>
<td>
<p>The column name of the status variable in the data frame <code>xin</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+bs.hqm">bs.hqm</a></code> implements the Brier score calculation for the HQM estimator estimator.
</p>


<h3>Value</h3>

<p>Scalar: the Brier score of the HQM estimator.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+auc.hqm">auc.hqm</a> </code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pec)
library(survival)
Landmark &lt;- 2

pbcT1 &lt;- pbc2[which(pbc2$year&lt; Landmark  &amp; pbc2$years&gt; Landmark),]
timesS2 &lt;- seq(Landmark,14,by=0.5)


b=0.9
arg1&lt;- get_h_x(pbcT1, 'albumin', event_time_name = 'years',  
               time_name = 'year', event_name = 'status2', 2, 0.9) 
br_s2  = seq(Landmark, 14,  length=99)
sfalb2&lt;- make_sf(    (br_s2[2]-br_s2[1])/4 , arg1)


tHor &lt;- 1.5
bs.use&lt;-bs.hqm(pbcT1, sfalb2, Landmark,tHor, 
                event_time_name = 'years', status_name = 'status2')
bs.use
</code></pre>

<hr>
<h2 id='Conf_bands'>Confidence bands</h2><span id='topic+Conf_bands'></span>

<h3>Description</h3>

<p>Implements the uniform and pointwise confidence bands for the future conditional hazard rate based on the last observed marker measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Conf_bands(data, marker_name, event_time_name = 'years',
            time_name = 'year', event_name = 'status2', x, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Conf_bands_+3A_data">data</code></td>
<td>
<p>A data frame of time dependent data points.  Missing values are allowed.</p>
</td></tr>
<tr><td><code id="Conf_bands_+3A_marker_name">marker_name</code></td>
<td>
<p>The column name of the marker values in the data frame <code><a href="utils.html#topic+data">data</a></code>. </p>
</td></tr>
<tr><td><code id="Conf_bands_+3A_event_time_name">event_time_name</code></td>
<td>
<p>The column name of the event times in the data frame <code><a href="utils.html#topic+data">data</a></code>. </p>
</td></tr>
<tr><td><code id="Conf_bands_+3A_time_name">time_name</code></td>
<td>
<p>The column name of the times the marker values were observed in the data frame <code><a href="utils.html#topic+data">data</a></code>.</p>
</td></tr>
<tr><td><code id="Conf_bands_+3A_event_name">event_name</code></td>
<td>
<p>The column name of the events in the data frame <code><a href="utils.html#topic+data">data</a></code>.</p>
</td></tr>
<tr><td><code id="Conf_bands_+3A_x">x</code></td>
<td>
<p>Numeric value of the last observed marker value.</p>
</td></tr>
<tr><td><code id="Conf_bands_+3A_b">b</code></td>
<td>
<p>Bandwidth.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+Conf_bands">Conf_bands</a></code> implements the pointwise and uniform confidence bands for the estimator of the future conditional hazard rate <code class="reqn">\hat h_x(t)</code>. The confidence bands are based on a wild bootstrap approach <code class="reqn">{h^*}_{{x_*},B}(t)</code>.
</p>
<p>Pointwise:
For a given <code class="reqn">t\in (0,T)</code> generate <code class="reqn">{h^*}_{{x_*},B}^{(1)}(t),...,{h^*}_{{x_*},B}^{(N)}(t)</code> for <code class="reqn">N = 1000</code> and order it <code class="reqn">{h^*}_{{x_*},B}^{[1]}(t)\leq ...\leq {h^*}_{{x_*},B}^{[N]}(t)</code>. Then
</p>
<p style="text-align: center;"><code class="reqn">
\hat{I}^1_{n,N} = \Bigg[\hat{h}_{x_*}(t) - \hat{\sigma}_{{G}_{x_*}}(t)\frac{{h^*}_{{x_*},B}^{[ N(1-\frac{\alpha}{2})]}(t)}{\sqrt{n}}, \hat{h}_{x_*}(t) -  \hat{\sigma}_{ {G}_x}(t)\frac{{h^*}_{{x_*},B}^{[ N\frac{\alpha}{2}]}(t)}{\sqrt{n}}\Bigg]
</code>
</p>

<p>is a <code class="reqn">1-\alpha</code> pointwise confidence band for <code class="reqn">h_{x_*}(t)</code>, where <code class="reqn">\hat{\sigma}_{{G}_{x_*}}(t)</code> is a bootrap estimate of the variance. For more details on the wild bootstrap approach, please see <code><a href="#topic+prep_boot">prep_boot</a></code> and <code><a href="#topic+g_xt">g_xt</a></code>.
</p>
<p>Uniform:
Generate <code class="reqn">\bar{h}_{{x_*},B}^{(1)}(t),...,\bar{h}_{{x_*},B}^{(N)}(t)</code> for <code class="reqn">N = 1000</code> for all <code class="reqn">t\in [\delta_T,T-\delta_T]</code> and define <code class="reqn">W^{(i)} = \sup_{t\in[0,T]}\big|\bar{h}_{{x_*},B}^{(i)}(t)|</code> for <code class="reqn">i = 1,...,N</code>. Order <code class="reqn">W^{[1]} \leq ... \leq W^{[N]}</code>. Then
</p>
<p style="text-align: center;"><code class="reqn">\hat{I}^2_{n,N} = \Bigg[\hat{h}_{x_*}(t) \pm \hat{\sigma}_{{G}_{x_*}}(t) \frac{W^{[ N(1 - \alpha)]}}{\sqrt{n}} \Bigg]</code>
</p>

<p>is a <code class="reqn">1-\alpha</code> uniform confidence band for <code class="reqn">h_{x_*}(t)</code>.
</p>


<h3>Value</h3>

<p>A list with pointwise, uniform confidence bands and the estimator <code class="reqn">\hat h_x(t)</code> for all possible time points <code class="reqn">t</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+g_xt">g_xt</a>, <a href="#topic+prep_boot">prep_boot</a> </code></p>


<h3>Examples</h3>

<pre><code class='language-R'>b = 10
x = 3
size_s_grid &lt;- 100
s = pbc2$year
br_s = seq(0, max(s), max(s)/( size_s_grid-1))


c_bands = Conf_bands(pbc2, 'serBilir', event_time_name = 'years',
                    time_name = 'year', event_name = 'status2', x, b)

J = 60
plot(br_s[1:J], c_bands$h_hat[1:J], type = "l", ylim = c(0,1), ylab = 'Hazard', xlab = 'Years')

lines(br_s[1:J], c_bands$I_p_up[1:J], col = "red")
lines(br_s[1:J], c_bands$I_p_do[1:J], col = "red")
lines(br_s[1:J], c_bands$I_nu[1:J], col = "blue")
lines(br_s[1:J], c_bands$I_nd[1:J], col = "blue")
</code></pre>

<hr>
<h2 id='dataset_split'>Split dataset for K-fold cross validation</h2><span id='topic+dataset_split'></span>

<h3>Description</h3>

<p>Creates multiple splits of a dataset which is then used in the bandwidth selection with K-fold cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataset_split(I, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dataset_split_+3A_data">data</code></td>
<td>
<p>A data frame of time dependent data points.  Missing values are allowed.</p>
</td></tr>
<tr><td><code id="dataset_split_+3A_i">I</code></td>
<td>
<p>The number of individuals that should be left out. Optimally, <code class="reqn">K = n/I</code> should be an integer, where <code class="reqn">n</code> is the number of individuals.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+dataset_split">dataset_split</a></code> takes a data frame and transforms it into <code class="reqn">K = n/I</code> data frames with <code class="reqn">I</code> individuals missing from each data frame. Let <code class="reqn">I_j</code> be sets of indices with <code class="reqn">\cup_{j=1}^K I_j = \{1,...,n\}</code>, <code class="reqn">I_k\cap I_j =  \emptyset</code> and <code class="reqn">|I_j| = |I_k| = I</code> for all <code class="reqn">j, k \in \{1,...,K\}</code>. Then data frames with <code class="reqn">\{1,...,n \}/I_j</code> individuals are created.
</p>


<h3>Value</h3>

<p>A list of data frames with <code><a href="base.html#topic+I">I</a></code> individuals missing in the above way.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+b_selection">b_selection</a> </code></p>


<h3>Examples</h3>

<pre><code class='language-R'>splitted_dataset = dataset_split(26, pbc2)
</code></pre>

<hr>
<h2 id='dij'>D matrix entries, used for the implementation of the local linear kernel</h2><span id='topic+dij'></span>

<h3>Description</h3>

<p>Calculates the entries of the <code class="reqn">D</code> matrix in the definition of the local linear kernel</p>


<h3>Usage</h3>

<pre><code class='language-R'>dij(b,x,y, K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dij_+3A_x">x</code></td>
<td>
<p> A vector of design points where the kernel will be evaluated.</p>
</td></tr>
<tr><td><code id="dij_+3A_y">y</code></td>
<td>
<p> A vector of sample data points.</p>
</td></tr>
<tr><td><code id="dij_+3A_b">b</code></td>
<td>
<p> The bandwidth to use (a scalar).</p>
</td></tr>
<tr><td><code id="dij_+3A_k">K</code></td>
<td>
<p> The kernel function to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements the  caclulation of all <code class="reqn">d \times d</code> entries of matrix <code class="reqn">D</code>, which is part of the definition of the local linear kernel. The actual calculation is performed by
</p>
<p style="text-align: center;"><code class="reqn">
d_{jk}  =  \sum_{i=1}^n \int_0^T K_b(x-X_i(s))\{x-X_{ij}(s)\}\{x-X_{ik}(s)\} Z_i(s)ds,
</code>
</p>



<h3>Value</h3>

<p>scalar value, the result of  <code class="reqn">d_{jk}</code>.
</p>

<hr>
<h2 id='Epan'>Epanechnikov kernel</h2><span id='topic+Epan'></span>

<h3>Description</h3>

<p>Implements the Epanechnikov kernel function</p>


<h3>Usage</h3>

<pre><code class='language-R'>Epan(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Epan_+3A_x">x</code></td>
<td>
<p> A vector of design points where the kernel will be evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements the   Epanechnikov kernel function
</p>
<p style="text-align: center;"><code class="reqn"> K(x) = \frac{3}{4}(1-x^2)*(|x|&lt;1)),</code>
</p>



<h3>Value</h3>

<p>Scalar, the value of the Epanechnikov kernel at <code class="reqn">x</code>.
</p>

<hr>
<h2 id='g_xt'>Computation of a key component for wild bootstrap</h2><span id='topic+g_xt'></span>

<h3>Description</h3>

<p>Implements a key part for the wild bootstrap of the hqm estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_xt(br_X, br_s, size_s_grid, int_X, x, t, b, Yi, Y, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="g_xt_+3A_br_x">br_X</code></td>
<td>
<p>Marker value grid points that will be used in the evaluatiuon.</p>
</td></tr>
<tr><td><code id="g_xt_+3A_br_s">br_s</code></td>
<td>
<p>Time value grid points that will be used in the evaluatiuon.</p>
</td></tr>
<tr><td><code id="g_xt_+3A_size_s_grid">size_s_grid</code></td>
<td>
<p>Size of the time grid.</p>
</td></tr>
<tr><td><code id="g_xt_+3A_int_x">int_X</code></td>
<td>
<p>Position of the linear interpolated marker values on the marker grid.</p>
</td></tr>
<tr><td><code id="g_xt_+3A_x">x</code></td>
<td>
<p>Numeric value of the last observed marker value.</p>
</td></tr>
<tr><td><code id="g_xt_+3A_t">t</code></td>
<td>
<p>Numeric value of the time the function should be evaluated.</p>
</td></tr>
<tr><td><code id="g_xt_+3A_b">b</code></td>
<td>
<p>Bandwidth.</p>
</td></tr>
<tr><td><code id="g_xt_+3A_yi">Yi</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Yi">make_Yi</a></code> indicating the exposure. </p>
</td></tr>
<tr><td><code id="g_xt_+3A_y">Y</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Y">make_Y</a></code> indicating the exposure. </p>
</td></tr>
<tr><td><code id="g_xt_+3A_n">n</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements
</p>
<p style="text-align: center;"><code class="reqn">\hat{g}_{t,x}(z) =  \frac{1}{n}  \sum_{ j = 1}^n \int^{T-t}_0 \hat{E}(X_j(t+s))^{-1} K_b(z,X_j(t+s)) Z_j(t+s)Z_j(s)K_b(x,X_j(s))ds,</code>
</p>

<p>for every value <code class="reqn">z</code> on the marker grid, where <code class="reqn">\hat{E}(x) = \frac{1}{n} \sum_{j=1}^n \int_0^T K_b(x,X_j(s))Z_j(s)ds</code>, <code class="reqn">Z</code> the exposure and <code class="reqn">X</code> the marker.
</p>


<h3>Value</h3>

<p>A vector of <code class="reqn">\hat{g}_{t,x}(z)</code> for all values <code class="reqn">z</code> on the marker grid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbc2_id = to_id(pbc2)
size_s_grid &lt;- size_X_grid &lt;- 100
n = max(as.numeric(pbc2$id))
X = pbc2$serBilir
s = pbc2$year
br_s = seq(0, max(s), max(s)/( size_s_grid-1))
br_X = seq(min(X), max(X), (max(X)-min(X))/( size_X_grid-1))

X_lin = lin_interpolate(br_s, pbc2_id$id, pbc2$id, X, s)

int_X &lt;- findInterval(X_lin, br_X)
int_s = rep(1:length(br_s), n)

Yi&lt;-make_Yi(pbc2, pbc2_id, X_lin, br_X, br_s, size_s_grid, size_X_grid, int_s, int_X, 'years', n)
Y&lt;-make_Y(pbc2, pbc2_id, X_lin, br_X, br_s,size_s_grid,size_X_grid, int_s,int_X, 'years', n)

t = 2
x = 2
b = 10

g_xt(br_X, br_s, size_s_grid, int_X, x, t, b, Yi, Y, n)
</code></pre>

<hr>
<h2 id='get_alpha'>Marker-only hazard rate</h2><span id='topic+get_alpha'></span>

<h3>Description</h3>

<p>Calculates the marker-only hazard rate for time dependent data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_alpha(N, Y, b, br_X, K=Epan )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_alpha_+3A_n">N</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_N">make_N</a></code> indicating the occurences of events.</p>
</td></tr>
<tr><td><code id="get_alpha_+3A_y">Y</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Y">make_Y</a></code> indicating the exposure. </p>
</td></tr>
<tr><td><code id="get_alpha_+3A_b">b</code></td>
<td>
<p>Bandwidth.</p>
</td></tr>
<tr><td><code id="get_alpha_+3A_br_x">br_X</code></td>
<td>
<p>Vector of grid points for the marker values <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="get_alpha_+3A_k">K</code></td>
<td>
<p>Used kernel function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+get_alpha">get_alpha</a></code> implements the marker-only hazard estimator
</p>
<p style="text-align: center;"><code class="reqn">\hat{\alpha}_i(z) = \frac{\sum_{k\neq i}\int_0^T K_{b_1}(z-X_k(s))\mathrm{d}N_k(s)}{\sum_{k\neq i}\int_0^T K_{b_1}(z-X_k(s))Z_k(s)\mathrm{d}s},</code>
</p>

<p>where <code class="reqn">X</code> is the marker and <code class="reqn">Z</code> is the exposure. The marker-only hazard is defined as the underlying hazard which is not dependent on time
</p>
<p style="text-align: center;"><code class="reqn">\alpha(X(t),t) = \alpha(X(t))</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>A vector of marker-only values for <code>br_X</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+h_xt">h_xt</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>pbc2_id = to_id(pbc2)
size_s_grid &lt;- size_X_grid &lt;- 100
n = max(as.numeric(pbc2$id))
s = pbc2$year
X = pbc2$serBilir
XX = pbc2_id$serBilir
ss &lt;- pbc2_id$years
delta &lt;- pbc2_id$status2
br_s = seq(0, max(s), max(s)/( size_s_grid-1))
br_X = seq(min(X), max(X), (max(X)-min(X))/( size_X_grid-1))

X_lin = lin_interpolate(br_s, pbc2_id$id, pbc2$id, X, s)

int_X &lt;- findInterval(X_lin, br_X)
int_s = rep(1:length(br_s), n)

N  &lt;- make_N(pbc2, pbc2_id, breaks_X=br_X, breaks_s=br_s, ss, XX, delta)
Y &lt;- make_Y(pbc2, pbc2_id, X_lin, br_X, br_s, size_s_grid,
            size_X_grid, int_s, int_X, event_time = 'years', n)

b = 1.7
alpha&lt;-get_alpha(N, Y, b, br_X, K=Epan )
</code></pre>

<hr>
<h2 id='get_h_x'>Local constant future conditional hazard rate estimator</h2><span id='topic+get_h_x'></span>

<h3>Description</h3>

<p>Calculates the local constant future hazard rate function, conditional on a marker value <code>x</code>, across across a set of time values <code>t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_h_x(data, marker_name, event_time_name, time_name, event_name, x, b)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_h_x_+3A_data">data</code></td>
<td>
<p>A data frame of time dependent data points.  Missing values are allowed.</p>
</td></tr>
<tr><td><code id="get_h_x_+3A_marker_name">marker_name</code></td>
<td>
<p>The column name of the marker values in the data frame <code><a href="utils.html#topic+data">data</a></code>. </p>
</td></tr>
<tr><td><code id="get_h_x_+3A_event_time_name">event_time_name</code></td>
<td>
<p>The column name of the event times in the data frame <code><a href="utils.html#topic+data">data</a></code>. </p>
</td></tr>
<tr><td><code id="get_h_x_+3A_time_name">time_name</code></td>
<td>
<p>The column name of the times the marker values were observed in the data frame <code><a href="utils.html#topic+data">data</a></code>.</p>
</td></tr>
<tr><td><code id="get_h_x_+3A_event_name">event_name</code></td>
<td>
<p>The column name of the events in the data frame <code><a href="utils.html#topic+data">data</a></code>.</p>
</td></tr>
<tr><td><code id="get_h_x_+3A_x">x</code></td>
<td>
<p>Numeric value of the last observed marker value.</p>
</td></tr>
<tr><td><code id="get_h_x_+3A_b">b</code></td>
<td>
<p>Bandwidth parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+get_h_x">get_h_x</a></code> implements the future local constant conditional hazard estimator
</p>
<p style="text-align: center;"><code class="reqn">\hat{h}_x(t) = \frac{\sum_{i=1}^n \int_0^T\hat{\alpha}_i(X_i(t+s))Z_i(t+s)Z_i(s)K_{b}(x-X_i(s))\mathrm {d}s}{\sum_{i=1}^n\int_0^TZ_i(t+s)Z_i(s)K_{b}(x-X_i(s))\mathrm {d}s},</code>
</p>

<p>across a grid of possible time values <code class="reqn">t</code>, where <code class="reqn">X</code> is the marker, <code class="reqn">Z</code> is the exposure and <code class="reqn">\alpha(z)</code> is the marker-only hazard, see <code><a href="#topic+get_alpha">get_alpha</a></code> for more details.
</p>


<h3>Value</h3>

<p>A vector of <code class="reqn">\hat h_x(t)</code> for a grid of possible time values <code class="reqn">t</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+get_alpha">get_alpha</a>, <a href="#topic+h_xt">h_xt</a> </code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
b = 10
x = 3
Landmark &lt;- 2
pbcT1 &lt;- pbc2[which(pbc2$year&lt; Landmark  &amp; pbc2$years&gt; Landmark),]
b=0.9

arg1ll&lt;-get_h_xll(pbcT1,'albumin',event_time_name='years',
                  time_name='year',event_name='status2',2,0.9) 
arg1lc&lt;-get_h_x(pbcT1,'albumin',event_time_name='years',
                time_name='year',event_name='status2',2,0.9) 

#Caclulate the local contant and local linear survival functions
br_s  = seq(Landmark, 14,  length=99)
sfalb2ll&lt;- make_sf(    (br_s[2]-br_s[1])/4 , arg1ll)
sfalb2lc&lt;- make_sf(    (br_s[2]-br_s[1])/4 , arg1lc)

#For comparison, also calculate the Kaplan-Meier
kma2&lt;- survfit(Surv(years , status2) ~ 1, data = pbcT1)

#Plot the survival functions:
plot(br_s, sfalb2ll,  type="l", col=1, lwd=2, ylab="Survival probability", xlab="Marker level")
lines(br_s, sfalb2lc,  lty=2, lwd=2, col=2)
lines(kma2$time, kma2$surv, type="s",  lty=2, lwd=2, col=3)

legend("topright", c(  "Local linear HQM", "Local constant HQM", 
        "Kaplan-Meier"), lty=c(1, 2, 2), col=1:3, lwd=2, cex=1.7)
</code></pre>

<hr>
<h2 id='get_h_xll'>Local linear future conditional hazard rate estimator</h2><span id='topic+get_h_xll'></span>

<h3>Description</h3>

<p>Calculates the local linear future hazard rate function, conditional on a marker value <code>x</code>, across a set of time values <code>t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> get_h_xll(data, marker_name, event_time_name, time_name, event_name, x, b)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_h_xll_+3A_data">data</code></td>
<td>
<p>A data frame of time dependent data points.  Missing values are allowed.</p>
</td></tr>
<tr><td><code id="get_h_xll_+3A_marker_name">marker_name</code></td>
<td>
<p>The column name of the marker values in the data frame <code><a href="utils.html#topic+data">data</a></code>. </p>
</td></tr>
<tr><td><code id="get_h_xll_+3A_event_time_name">event_time_name</code></td>
<td>
<p>The column name of the event times in the data frame <code><a href="utils.html#topic+data">data</a></code>. </p>
</td></tr>
<tr><td><code id="get_h_xll_+3A_time_name">time_name</code></td>
<td>
<p>The column name of the times the marker values were observed in the data frame <code><a href="utils.html#topic+data">data</a></code>.</p>
</td></tr>
<tr><td><code id="get_h_xll_+3A_event_name">event_name</code></td>
<td>
<p>The column name of the events in the data frame <code><a href="utils.html#topic+data">data</a></code>.</p>
</td></tr>
<tr><td><code id="get_h_xll_+3A_x">x</code></td>
<td>
<p>Numeric value of the last observed marker value.</p>
</td></tr>
<tr><td><code id="get_h_xll_+3A_b">b</code></td>
<td>
<p>Bandwidth parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+get_h_xll">get_h_xll</a></code> implements the local linear future conditional hazard estimator
</p>
<p style="text-align: center;"><code class="reqn">\hat{h}_x(t) = \frac{\sum_{i=1}^n \int_0^T\hat{\alpha}_i(X_i(t+s))Z_i(t+s)Z_i(s)K_{b}(x-X_i(s))\mathrm {d}s}{\sum_{i=1}^n\int_0^TZ_i(t+s)Z_i(s)K_{b}(x-X_i(s))\mathrm {d}s},</code>
</p>

<p>across a grid of possible time values <code class="reqn">t</code>, where <code class="reqn">X</code> is the marker, <code class="reqn">Z</code> is the exposure and <code class="reqn">\alpha(z)</code> is the marker-only hazard, see <code><a href="#topic+get_alpha">get_alpha</a></code> for more details.
</p>


<h3>Value</h3>

<p>A vector of <code class="reqn">\hat h_x(t)</code> for a grid of possible time values <code class="reqn">t</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+get_alpha">get_alpha</a>, <a href="#topic+h_xt">h_xt</a> </code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
library(JM)

# Compare Local constant and local linear estimator, use KM for reference
# Albumin marker, use landmarking
Landmark &lt;- 2
pbcT1 &lt;- pbc2[which(pbc2$year&lt; Landmark  &amp; pbc2$years&gt; Landmark),]
b=0.9

arg1ll&lt;-get_h_xll(pbcT1, 'albumin', event_time_name = 'years', time_name = 'year',
                  event_name = 'status2', 2, 0.9) 
arg1lc&lt;-get_h_x(pbcT1, 'albumin', event_time_name = 'years', time_name = 'year',
                event_name = 'status2', 2, 0.9) 

#Caclulate the local contant and local linear survival functions
br_s  = seq(Landmark, 14,  length=99)
sfalb2ll&lt;- make_sf(    (br_s[2]-br_s[1])/4 , arg1ll)
sfalb2lc&lt;- make_sf(    (br_s[2]-br_s[1])/4 , arg1lc)

#For comparison, also calculate the Kaplan-Meier
kma2&lt;- survfit(Surv(years , status2) ~ 1, data = pbcT1)

#Plot the survival functions:
plot(br_s, sfalb2ll,  type="l", col=1, lwd=2, ylab="Survival probability", xlab="Marker level")
lines(br_s, sfalb2lc,  lty=2, lwd=2, col=2)
lines(kma2$time, kma2$surv, type="s",  lty=2, lwd=2, col=3)

legend("topright", c(  "Local linear HQM", "Local constant HQM", "Kaplan-Meier"), 
        lty=c(1, 2, 2), col=1:3, lwd=2, cex=1.7)
        

## Not run:        
#Compare JM, HQM and KM for Bilirubin       
b = 10 
Landmark &lt;- 1
lmeFit &lt;- lme(serBilir ~ year, random = ~ year | id, data = pbc2)
coxFit &lt;- coxph(Surv(years, status2) ~ serBilir, data = pbc2.id, x = TRUE)

 
jointFit0 &lt;- jointModel(lmeFit, coxFit, timeVar = "year", 
                                method = "piecewise-PH-aGH")
pbcT1 &lt;- pbc2[which(pbc2$year&lt; Landmark  &amp; pbc2$years&gt; Landmark),]
 

timesS1 &lt;- seq(1,14,by=0.5)
predT1 &lt;- survfitJM(jointFit0, newdata = pbcT1,survTimes = timesS1)
nm&lt;-length(predT1$summaries)

mat.out1&lt;-matrix(nrow=length(timesS1), ncol=nm)
for(r in 1:nm)
{
  SurvLand &lt;- predT1$summaries[[r]][,"Mean"][1]
  mat.out1[,r] &lt;- predT1$summaries[[r]][,"Mean"]/SurvLand
}
sfit1y&lt;-rowMeans(mat.out1, na.rm=TRUE)


arg1&lt;- get_h_x(pbcT1, 'serBilir', event_time_name = 'years',  
        time_name = 'year', event_name = 'status2', 1, 10) 
br_s1  = seq(Landmark, 14,  length=99)
sfbil1&lt;- make_sf(  (br_s1[2]-br_s1[1])/5.4 , arg1)
kma1&lt;- survfit(Surv(years , status2) ~ 1, data = pbcT1)

plot(br_s1, sfbil1, type="l", ylim=c(0,1), xlim=c(Landmark,14), 
                    ylab="Survival probability", xlab="years",lwd=2)
lines(timesS1, sfit1y, col=2,  lwd=2, lty=2)
lines(kma1$time, kma1$surv, type="s", lty=2, lwd=2, col=3 )
legend("bottomleft", c("HQM est.", "Joint Model est.", "Kaplan-Meier"), 
                                    lty=c(1,2,2), col=1:3, lwd=2, cex=1.7)

## End(Not run)


</code></pre>

<hr>
<h2 id='h_xt'>Local constant future conditional hazard rate estimation at a single time point</h2><span id='topic+h_xt'></span>

<h3>Description</h3>

<p>Calculates the future conditional hazard rate for a marker value <code>x</code> and a time value <code>t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_xt(br_X, br_s, int_X, size_s_grid, alpha, x,t, b, Yi,n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h_xt_+3A_br_x">br_X</code></td>
<td>
<p>Vector of grid points for the marker values <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="h_xt_+3A_br_s">br_s</code></td>
<td>
<p>Vector of grid points for the time values <code class="reqn">s</code>.</p>
</td></tr>
<tr><td><code id="h_xt_+3A_int_x">int_X</code></td>
<td>
<p>Position of the linear interpolated marker values on the marker grid.</p>
</td></tr>
<tr><td><code id="h_xt_+3A_size_s_grid">size_s_grid</code></td>
<td>
<p>Size of the time grid.</p>
</td></tr>
<tr><td><code id="h_xt_+3A_alpha">alpha</code></td>
<td>
<p>Marker-hazard obtained from <code><a href="#topic+get_alpha">get_alpha</a></code>.</p>
</td></tr>
<tr><td><code id="h_xt_+3A_x">x</code></td>
<td>
<p>Numeric value of the last observed marker value.</p>
</td></tr>
<tr><td><code id="h_xt_+3A_t">t</code></td>
<td>
<p>Numeric time value.</p>
</td></tr>
<tr><td><code id="h_xt_+3A_b">b</code></td>
<td>
<p>Bandwidth.</p>
</td></tr>
<tr><td><code id="h_xt_+3A_yi">Yi</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Yi">make_Yi</a></code> indicating the exposure. </p>
</td></tr>
<tr><td><code id="h_xt_+3A_n">n</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code><a href="#topic+h_xt">h_xt</a></code>   implements the future conditional hazard estimator
</p>
<p style="text-align: center;"><code class="reqn">\hat{h}_x(t) = \frac{\sum_{i=1}^n \int_0^T\hat{\alpha}_i(X_i(t+s))Z_i(t+s)Z_i(s)K_{b}(x-X_i(s))\mathrm {d}s}{\sum_{i=1}^n\int_0^TZ_i(t+s)Z_i(s)K_{b}(x-X_i(s))\mathrm {d}s},</code>
</p>

<p>where <code class="reqn">X</code> is the marker, <code class="reqn">Z</code> is the exposure and <code class="reqn">\alpha(z)</code> is the marker-only hazard, see <code><a href="#topic+get_alpha">get_alpha</a></code> for more details. The future conditional hazard is defined as
</p>
<p style="text-align: center;"><code class="reqn">h_{x,T}(t) = P\left(T_i\in (t+T, t+T+dt)| X_i(T)=x, T_i &gt; t+T\right),</code>
</p>

<p>where <code class="reqn">T_i</code> is the survival time and <code class="reqn">X_i</code> the marker of individual <code class="reqn">i</code> observed in the time frame <code class="reqn">[0,T]</code>. Function <code><a href="#topic+h_xt">h_xt</a></code> uses an classic (unmodified) kernel function <code class="reqn">K_b()</code>, e.g. the Epanechnikov kernel.
</p>


<h3>Value</h3>

<p>A single numeric value of <code class="reqn">\hat h_x(t)</code>.
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1080/03461238.1998.10413997">doi:10.1080/03461238.1998.10413997</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+get_alpha">get_alpha</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>pbc2_id = to_id(pbc2)
size_s_grid &lt;- size_X_grid &lt;- 100
n = max(as.numeric(pbc2$id))
s = pbc2$year
X = pbc2$serBilir
XX = pbc2_id$serBilir
ss &lt;- pbc2_id$years
delta &lt;- pbc2_id$status2
br_s = seq(0, max(s), max(s)/( size_s_grid-1))
br_X = seq(min(X), max(X), (max(X)-min(X))/( size_X_grid-1))

X_lin = lin_interpolate(br_s, pbc2_id$id, pbc2$id, X, s)

int_X &lt;- findInterval(X_lin, br_X)
int_s = rep(1:length(br_s), n)

N &lt;- make_N(pbc2, pbc2_id, breaks_X=br_X, breaks_s=br_s, ss, XX, delta)
Y &lt;- make_Y(pbc2, pbc2_id, X_lin, br_X, br_s, size_s_grid, size_X_grid, int_s, int_X, 'years', n)

b = 1.7
alpha&lt;-get_alpha(N, Y, b, br_X, K=Epan )

Yi &lt;- make_Yi(pbc2, pbc2_id, X_lin, br_X, br_s, size_s_grid, size_X_grid, int_s, int_X,'years', n)

x = 2
t = 2
h_hat = h_xt(br_X, br_s, int_X, size_s_grid, alpha, x, t, b, Yi, n)
</code></pre>

<hr>
<h2 id='h_xt_vec'>Hqm estimator on the marker grid</h2><span id='topic+h_xt_vec'></span>

<h3>Description</h3>

<p>Computes the hqm estimator on the marker grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_xt_vec(br_X, br_s, size_s_grid, alpha, t, b, Yi, int_X, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h_xt_vec_+3A_br_x">br_X</code></td>
<td>
<p>Marker value grid points that will be used in the evaluatiuon.</p>
</td></tr>
<tr><td><code id="h_xt_vec_+3A_br_s">br_s</code></td>
<td>
<p>Time value grid points that will be used in the evaluatiuon.</p>
</td></tr>
<tr><td><code id="h_xt_vec_+3A_size_s_grid">size_s_grid</code></td>
<td>
<p>Size of the time grid.</p>
</td></tr>
<tr><td><code id="h_xt_vec_+3A_alpha">alpha</code></td>
<td>
<p>Marker-hazard obtained from <code><a href="#topic+get_alpha">get_alpha</a></code>.</p>
</td></tr>
<tr><td><code id="h_xt_vec_+3A_t">t</code></td>
<td>
<p>Numeric value of the time the function should be evaluated.</p>
</td></tr>
<tr><td><code id="h_xt_vec_+3A_b">b</code></td>
<td>
<p>Bandwidth.</p>
</td></tr>
<tr><td><code id="h_xt_vec_+3A_yi">Yi</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Yi">make_Yi</a></code> indicating the exposure. </p>
</td></tr>
<tr><td><code id="h_xt_vec_+3A_int_x">int_X</code></td>
<td>
<p>Position of the linear interpolated marker values on the marker grid.</p>
</td></tr>
<tr><td><code id="h_xt_vec_+3A_n">n</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the future conditional hazard estimator
</p>
<p style="text-align: center;"><code class="reqn">\hat{h}_x(t) = \frac{\sum_{i=1}^n \int_0^T\hat{\alpha}_i(X_i(t+s))Z_i(t+s)Z_i(s)K_{b}(x-X_i(s))\mathrm {d}s}{\sum_{i=1}^n\int_0^TZ_i(t+s)Z_i(s)K_{b}(x-X_i(s))\mathrm {d}s},</code>
</p>

<p>for every <code class="reqn">x</code> on the marker grid where <code class="reqn">X</code> is the marker, <code class="reqn">Z</code> is the exposure and <code class="reqn">\alpha(z)</code> is the marker-only hazard, see <code><a href="#topic+get_alpha">get_alpha</a></code> for more details.
</p>


<h3>Value</h3>

<p>A vector of <code class="reqn">\hat{h}_{x}(t)</code> for all values <code class="reqn">x</code> on the marker grid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Longitudinal data example

pbc2_id = to_id(pbc2)
size_s_grid &lt;- size_X_grid &lt;- 100
n = max(as.numeric(pbc2$id))
s = pbc2$year
X = pbc2$serBilir
XX = pbc2_id$serBilir
ss &lt;- pbc2_id$years
delta &lt;- pbc2_id$status2
br_s = seq(0, max(s), max(s)/( size_s_grid-1))
br_X = seq(min(X), max(X), (max(X)-min(X))/( size_X_grid-1))

X_lin = lin_interpolate(br_s, pbc2_id$id, pbc2$id, X, s)

int_X &lt;- findInterval(X_lin, br_X)
int_s = rep(1:length(br_s), n)

N &lt;- make_N(pbc2, pbc2_id, br_X, br_s, ss, XX, delta)
Y &lt;- make_Y(pbc2, pbc2_id, X_lin, br_X, br_s,
            size_s_grid, size_X_grid, int_s, int_X, event_time = 'years', n)

b = 1.7
alpha&lt;-get_alpha(N, Y, b, br_X, K=Epan )

Yi &lt;- make_Yi(pbc2, pbc2_id, X_lin, br_X, br_s,
              size_s_grid, size_X_grid, int_s, int_X, event_time = 'years', n)

t = 2

h_xt_vec(br_X, br_s, size_s_grid, alpha, t, b, Yi, int_X, n)

# Time-invariant data example:
# pbc2 dataset, single event per individual version:
# 312 observations, most recent event per individual.
# Use landmarking to produce comparable curve with KM.
library(survival)
Landmark &lt;- 3 #set the landmark to 3 years
pbc2.use&lt;- to_id(pbc2) # keep only the most recent row per patient
pbcT1 &lt;- pbc2.use[which(pbc2.use$year&lt; Landmark  &amp; pbc2.use$years&gt; Landmark),]

timesS2 &lt;- seq(Landmark,14,by=0.5)
b=0.9
arg1&lt;- get_h_x(pbcT1, 'albumin', event_time_name = 'years',  time_name = 'year', 
                                                    event_name = 'status2', 2, b) 
br_s2  = seq(Landmark, 14,  length=99)
sfalb2&lt;- make_sf(    (br_s2[2]-br_s2[1])/1.35 , arg1)
kma2&lt;- survfit(Surv(years , status2) ~ 1, data = pbcT1)

#Plot the survival functions:
plot(br_s2, sfalb2, type="l", ylim=c(0,1), xlim=c(Landmark,14), ylab="Survival probability", 
            xlab="years",lwd=2, main="HQM and KM survival functions, conditional on albumin=2, 
            for the time-invariant pbc dataset")
lines(kma2$time, kma2$surv, type="s",lty=2, lwd=2, col=2)
legend("bottomleft", c("HQM est.", "Kaplan-Meier"), lty=c(1,2), col=1:2, lwd=2, cex=1.7)

 


</code></pre>

<hr>
<h2 id='h_xtll'>Local linear future conditional hazard rate estimation at a single time point</h2><span id='topic+h_xtll'></span>

<h3>Description</h3>

<p>Calculates the local linear future conditional hazard rate for a marker value <code>x</code> and a time value <code>t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_xtll(br_X, br_s, int_X, size_s_grid, alpha, x,t, b, Yi,n, Y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h_xtll_+3A_br_x">br_X</code></td>
<td>
<p>Vector of grid points for the marker values <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="h_xtll_+3A_br_s">br_s</code></td>
<td>
<p>Vector of grid points for the time values <code class="reqn">s</code>.</p>
</td></tr>
<tr><td><code id="h_xtll_+3A_int_x">int_X</code></td>
<td>
<p>Position of the linear interpolated marker values on the marker grid.</p>
</td></tr>
<tr><td><code id="h_xtll_+3A_size_s_grid">size_s_grid</code></td>
<td>
<p>Size of the time grid.</p>
</td></tr>
<tr><td><code id="h_xtll_+3A_alpha">alpha</code></td>
<td>
<p>Marker-hazard obtained from <code><a href="#topic+get_alpha">get_alpha</a></code>.</p>
</td></tr>
<tr><td><code id="h_xtll_+3A_x">x</code></td>
<td>
<p>Numeric value of the last observed marker value.</p>
</td></tr>
<tr><td><code id="h_xtll_+3A_t">t</code></td>
<td>
<p>Numeric time value.</p>
</td></tr>
<tr><td><code id="h_xtll_+3A_b">b</code></td>
<td>
<p>Bandwidth.</p>
</td></tr>
<tr><td><code id="h_xtll_+3A_yi">Yi</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Yi">make_Yi</a></code> indicating the exposure. </p>
</td></tr>
<tr><td><code id="h_xtll_+3A_n">n</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
<tr><td><code id="h_xtll_+3A_y">Y</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Y">make_Y</a></code> indicating the exposure. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code><a href="#topic+h_xtll">h_xtll</a></code> implements the future conditional hazard estimator
</p>
<p style="text-align: center;"><code class="reqn">\hat{h}_x(t) = \frac{\sum_{i=1}^n \int_0^T\hat{\alpha}_i(X_i(t+s))Z_i(t+s)Z_i(s)K_{b}(x-X_i(s))\mathrm {d}s}{\sum_{i=1}^n\int_0^TZ_i(t+s)Z_i(s)K_{b}(x-X_i(s))\mathrm {d}s},</code>
</p>

<p>where <code class="reqn">X</code> is the marker, <code class="reqn">Z</code> is the exposure and <code class="reqn">\alpha(z)</code> is the marker-only hazard, see <code><a href="#topic+get_alpha">get_alpha</a></code> for more details. The future conditional hazard is defined as
</p>
<p style="text-align: center;"><code class="reqn">h_{x,T}(t) = P\left(T_i\in (t+T, t+T+dt)| X_i(T)=x, T_i &gt; t+T\right),</code>
</p>

<p>where <code class="reqn">T_i</code> is the survival time and <code class="reqn">X_i</code> the marker of individual <code class="reqn">i</code> observed in the time frame <code class="reqn">[0,T]</code>.
</p>
<p>The function <code><a href="#topic+h_xtll">h_xtll</a></code>, in the place of <code class="reqn">K_b()</code> uses the kernel    
</p>
<p style="text-align: center;"><code class="reqn">K_{x,b}(u)= \frac{K_b(u)-K_b(u)u^T D^{-1}c_1}{c_0 - c_1^T D^{-1} c_1}, </code>
</p>

<p>where <code class="reqn">c_1 = (c_{11}, \dots, c_{1d})^T, D = (d_{ij})_{(d+1) \times (d+1)}</code> with
</p>
<p style="text-align: center;"><code class="reqn">
c_0  = \sum_{i=1}^n \int_0^T K_b(x-X_i(s)) Z_i(s)ds, \\
c_{ij}  = \sum_{i=1}^n \int_0^T K_b(x-X_i(s))\{x-X_{ij}(s)\} Z_i(s)ds, \\
d_{jk}  =  \sum_{i=1}^n \int_0^T K_b(x-X_i(s))\{x-X_{ij}(s)\}\{x-X_{ik}(s)\} Z_i(s)ds,
</code>
</p>

<p>see also Nielsen (1998).
</p>


<h3>Value</h3>

<p>A single numeric value of <code class="reqn">\hat h_x(t)</code>.
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1080/03461238.1998.10413997">doi:10.1080/03461238.1998.10413997</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+get_alpha">get_alpha</a></code>, <code><a href="#topic+dij">dij</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>pbc2_id = to_id(pbc2)
size_s_grid &lt;- size_X_grid &lt;- 100
n = max(as.numeric(pbc2$id))
s = pbc2$year
X = pbc2$serBilir
XX = pbc2_id$serBilir
ss &lt;- pbc2_id$years
delta &lt;- pbc2_id$status2
br_s = seq(0, max(s), max(s)/( size_s_grid-1))
br_X = seq(min(X), max(X), (max(X)-min(X))/( size_X_grid-1))

X_lin = lin_interpolate(br_s, pbc2_id$id, pbc2$id, X, s)

int_X &lt;- findInterval(X_lin, br_X)
int_s = rep(1:length(br_s), n)

N &lt;- make_N(pbc2, pbc2_id, breaks_X=br_X, breaks_s=br_s, ss, XX, delta)
Y &lt;- make_Y(pbc2, pbc2_id, X_lin, br_X, br_s, size_s_grid, size_X_grid, int_s, int_X, 'years', n)

b = 1.7
alpha&lt;-get_alpha(N, Y, b, br_X, K=Epan )

Yi &lt;- make_Yi(pbc2, pbc2_id, X_lin, br_X, br_s, size_s_grid, size_X_grid, int_s, int_X,'years', n)

x = 2
t = 2
h_hat = h_xtll(br_X, br_s, int_X, size_s_grid, alpha, x, t, b, Yi, n, Y)
</code></pre>

<hr>
<h2 id='Kernels'>Classical (unmodified) kernel and related functionals</h2><span id='topic+K_b'></span><span id='topic+xK_b'></span><span id='topic+K_b_mat'></span>

<h3>Description</h3>

<p>Implements the classical kernel function and related functionals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>K_b(b,x,y, K)
xK_b(b,x,y, K)
K_b_mat(b,x,y, K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Kernels_+3A_x">x</code></td>
<td>
<p> A vector of design points where the kernel will be evaluated.</p>
</td></tr>
<tr><td><code id="Kernels_+3A_y">y</code></td>
<td>
<p> A vector of sample data points.</p>
</td></tr>
<tr><td><code id="Kernels_+3A_b">b</code></td>
<td>
<p> The bandwidth to use (a scalar).</p>
</td></tr>
<tr><td><code id="Kernels_+3A_k">K</code></td>
<td>
<p> The kernel function to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>K_b</code> implements the classical kernel function calculation
</p>
<p style="text-align: center;"><code class="reqn"> h^{-1} K \left ( \frac{x-y}{h} \right )</code>
</p>

<p>for scalars <code class="reqn">x</code> and <code class="reqn">y</code> while <code>xK_b</code> implements the functional 
</p>
<p style="text-align: center;"><code class="reqn"> h^{-1} K \left ( \frac{x-y}{h} \right )(x-y)</code>
</p>

<p>again for for scalars <code class="reqn">x</code> and <code class="reqn">y</code>. The function <code>K_b_mat</code> is the vectorized version of <code>K_b</code>. It uses as inputs the vectors <code class="reqn">(X_1, \dots, X_n)</code> and <code class="reqn">(Y_1, \dots, Y_n)</code> and returns a <code class="reqn">n \times n</code> matrix with entries 
</p>
<p style="text-align: center;"><code class="reqn"> h^{-1} K \left ( \frac{X_i-Y_j}{h} \right )</code>
</p>



<h3>Value</h3>

<p>Scalar values for <code>K_b</code> and <code>xK_b</code> and matrix outputs for <code>K_b_mat</code>.
</p>

<hr>
<h2 id='lin_interpolate'>Linear interpolation</h2><span id='topic+lin_interpolate'></span>

<h3>Description</h3>

<p>Implements a linear interpolation between observered marker values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lin_interpolate(t, i, data_id, data_marker, data_time)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lin_interpolate_+3A_t">t</code></td>
<td>
<p>A vector of time values where the function should be evaluated.</p>
</td></tr>
<tr><td><code id="lin_interpolate_+3A_i">i</code></td>
<td>
<p>A vector of ids of individuals for whom the marker values should be interpolated.</p>
</td></tr>
<tr><td><code id="lin_interpolate_+3A_data_id">data_id</code></td>
<td>
<p>The vector of ids from a data frame of time dependent variables.</p>
</td></tr>
<tr><td><code id="lin_interpolate_+3A_data_marker">data_marker</code></td>
<td>
<p>The vector of marker values from a data frame of time dependent variables.</p>
</td></tr>
<tr><td><code id="lin_interpolate_+3A_data_time">data_time</code></td>
<td>
<p>The vector of time values from a data frame of time dependent variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given time points <code class="reqn">t_1,...,t_K</code> and marker values <code class="reqn">m_1,...,m_J</code> at different time points <code class="reqn">t^m_1,...,t^m_J</code>, the function calculates a linear interpolation <code class="reqn">f</code> with <code class="reqn">f(t^m_i) = m_i</code> at the time points <code class="reqn">t_1,...,t_K</code> for all indicated individuals. Returned are then <code class="reqn">(f(t_1),...,f(t_K))</code>. Note that the first value is always observed at time point <code class="reqn">0</code> and the function <code class="reqn">f</code> is extrapolated constantly after the last observed marker value.
</p>


<h3>Value</h3>

<p>A matrix with columns <code class="reqn">(f(t_1),...,f(t_K))</code> as described above for every individual in the vector <code>i</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>size_s_grid &lt;- 100
X = pbc2$serBilir
s = pbc2$year
br_s = seq(0, max(s), max(s)/( size_s_grid-1))
pbc2_id = to_id(pbc2)

X_lin = lin_interpolate(br_s, pbc2_id$id, pbc2$id, X, s)
</code></pre>

<hr>
<h2 id='llK_b'>Local linear kernel</h2><span id='topic+llK_b'></span>

<h3>Description</h3>

<p>Implements the local linear kernel function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>llK_b(b,x,y, K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llK_b_+3A_x">x</code></td>
<td>
<p> A vector of design points where the kernel will be evaluated.</p>
</td></tr>
<tr><td><code id="llK_b_+3A_y">y</code></td>
<td>
<p> A vector of sample data points.</p>
</td></tr>
<tr><td><code id="llK_b_+3A_b">b</code></td>
<td>
<p> The bandwidth to use (a scalar).</p>
</td></tr>
<tr><td><code id="llK_b_+3A_k">K</code></td>
<td>
<p> The kernel function to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements the local linear kernel
</p>
<p style="text-align: center;"><code class="reqn">K_{x,b}(u)= \frac{K_b(u)-K_b(u)u^T D^{-1}c_1}{c_0 - c_1^T D^{-1} c_1}, </code>
</p>

<p>where <code class="reqn">c_1 = (c_{11}, \dots, c_{1d})^T, D = (d_{ij})_{(d+1) \times (d+1)}</code> with
</p>
<p style="text-align: center;"><code class="reqn">
c_0  = \sum_{i=1}^n \int_0^T K_b(x-X_i(s)) Z_i(s)ds, \\
c_{ij}  = \sum_{i=1}^n \int_0^T K_b(x-X_i(s))\{x-X_{ij}(s)\} Z_i(s)ds, \\
d_{jk}  =  \sum_{i=1}^n \int_0^T K_b(x-X_i(s))\{x-X_{ij}(s)\}\{x-X_{ik}(s)\} Z_i(s)ds,
</code>
</p>

<p>see also Nielsen (1998).
</p>


<h3>Value</h3>

<p>Matrix output with entries the values of the kernel function at each point.
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1080/03461238.1998.10413997">doi:10.1080/03461238.1998.10413997</a>
</p>

<hr>
<h2 id='llweights'>Local linear weight functions</h2><span id='topic+sn.0'></span><span id='topic+sn.1'></span><span id='topic+sn.2'></span>

<h3>Description</h3>

<p>Implements the weights to be used in the local linear HQM estimator.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sn.0(xin, xout, h, kfun)
sn.1(xin, xout, h, kfun)
sn.2(xin, xout, h, kfun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llweights_+3A_xin">xin</code></td>
<td>
<p>Sample values.</p>
</td></tr>
<tr><td><code id="llweights_+3A_xout">xout</code></td>
<td>
<p>Grid points where the estimator will be evaluated.</p>
</td></tr>
<tr><td><code id="llweights_+3A_h">h</code></td>
<td>
<p>Bandwidth parameter.</p>
</td></tr>
<tr><td><code id="llweights_+3A_kfun">kfun</code></td>
<td>
<p>Kernel function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the local linear weights in the definition of the estimator <code class="reqn">\hat{h}_x(t)</code>, see also <code><a href="#topic+h_xt">h_xt</a></code> 
</p>


<h3>Value</h3>

<p> A vector of <code class="reqn">s_n(x)</code> for all values <code class="reqn">x</code> on the marker grid. </p>

<hr>
<h2 id='make_N+2C+20make_Ni+2C+20make_Y+2C+20make_Yi'>Occurance and Exposure on grids</h2><span id='topic+make_N'></span><span id='topic+make_Ni'></span><span id='topic+make_Y'></span><span id='topic+make_Yi'></span>

<h3>Description</h3>

<p>Auxiliary functions that help automate the process of calculating integrals with occurances or exposure processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_N(data, data.id, breaks_X, breaks_s, ss, XX, delta)
make_Ni(breaks_s, size_s_grid, ss, delta, n)
make_Y(data, data.id, X_lin, breaks_X, breaks_s,
        size_s_grid, size_X_grid, int_s, int_X, event_time = 'years', n)
make_Yi(data, data.id, X_lin, breaks_X, breaks_s,
        size_s_grid, size_X_grid, int_s,int_X, event_time = 'years', n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_data">data</code></td>
<td>
<p>A data frame of time dependent data points.  Missing values are allowed.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_data.id">data.id</code></td>
<td>
<p>An id data frame obtained from <code><a href="#topic+to_id">to_id</a></code>.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_breaks_x">breaks_X</code></td>
<td>
<p>Marker value grid points where the function will be evaluated.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_breaks_s">breaks_s</code></td>
<td>
<p>Time value grid points where the function will be evaluated.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_ss">ss</code></td>
<td>
<p>Vector with event times.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_xx">XX</code></td>
<td>
<p>Vector of last observed marker values.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_delta">delta</code></td>
<td>
<p>0-1 vector of whether events happened.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_size_s_grid">size_s_grid</code></td>
<td>
<p>Size of the time grid.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_size_x_grid">size_X_grid</code></td>
<td>
<p>Size of the marker grid.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_n">n</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_x_lin">X_lin</code></td>
<td>
<p>Linear interpolation of observed marker values evaluated on the marker grid.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_int_s">int_s</code></td>
<td>
<p>Position of the observed time values on the time grid.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_int_x">int_X</code></td>
<td>
<p>Position of the linear interpolated marker values on the marker grid.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_event_time">event_time</code></td>
<td>
<p>String of the column name with the event times.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements matrices for the computation of integrals with occurences and exposures of the form
</p>
<p style="text-align: center;"><code class="reqn">\int f(s)Z(s)Z(s+t)ds, \int f(s) Z(s)ds, \int f(s) dN(s).</code>
</p>

<p>where <code class="reqn">N</code> is a 0-1 counting process, <code class="reqn">Z</code> the exposure and <code class="reqn">f</code> an arbitrary function.
</p>


<h3>Value</h3>

<p>The functions <code><a href="#topic+make_N">make_N</a></code> and <code><a href="#topic+make_Y">make_Y</a></code> return a matrix on the time grid and marker grid for occurence and exposure, respectively, while <code><a href="#topic+make_Ni">make_Ni</a></code> and <code><a href="#topic+make_Yi">make_Yi</a></code> return a matrix on the time grid for evey individual again for occurence and exposure, respectively.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+h_xt">h_xt</a>, <a href="#topic+g_xt">g_xt</a>, <a href="#topic+get_alpha">get_alpha</a> </code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pbc2_id = to_id(pbc2)
size_s_grid &lt;- size_X_grid &lt;- 100
n = max(as.numeric(pbc2$id))
s = pbc2$year
X = pbc2$serBilir
XX = pbc2_id$serBilir
ss &lt;- pbc2_id$years
delta &lt;- pbc2_id$status2
br_s = seq(0, max(s), max(s)/( size_s_grid-1))
br_X = seq(min(X), max(X), (max(X)-min(X))/( size_X_grid-1))

X_lin = lin_interpolate(br_s, pbc2_id$id, pbc2$id, X, s)

int_X &lt;- findInterval(X_lin, br_X)
int_s = rep(1:length(br_s), n)

N &lt;- make_N(pbc2, pbc2_id, br_X, br_s, ss, XX, delta)
Y &lt;- make_Y(pbc2, pbc2_id, X_lin, br_X, br_s,
            size_s_grid, size_X_grid, int_s, int_X, event_time = 'years', n)
Yi &lt;- make_Yi(pbc2, pbc2_id, X_lin, br_X, br_s,
              size_s_grid, size_X_grid, int_s, int_X, event_time = 'years', n)
Ni  &lt;- make_Ni(br_s, size_s_grid, ss, delta, n)

</code></pre>

<hr>
<h2 id='make_sf'>Survival function from a hazard</h2><span id='topic+make_sf'></span>

<h3>Description</h3>

<p>Creates a survival function from a hazard rate which was calculated on a grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_sf(step_size_s_grid, haz)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_sf_+3A_step_size_s_grid">step_size_s_grid</code></td>
<td>
<p>Numeric value indicating the distance between two grid continuous grid points.</p>
</td></tr>
<tr><td><code id="make_sf_+3A_haz">haz</code></td>
<td>
<p>Vector of hazard values. Hazard rate must have been calculated on a time grid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+make_sf">make_sf</a></code> calculates the survival function
</p>
<p style="text-align: center;"><code class="reqn">S(t) = \exp (-\int_0^t h(t) dt),</code>
</p>

<p>where <code class="reqn">h</code> is the hazard rate. Here, a discritisation via an equidistant grid <code class="reqn">\{ t_i \}</code> on <code class="reqn">[0,t]</code> is used to calculate the integral and it is assumed that <code class="reqn">h</code> has been calculated for exactly these time points <code class="reqn"> t_i </code>.
</p>


<h3>Value</h3>

<p>A vector of values <code class="reqn">S(t_i)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_sf(0.1, rep(0.1,10))
</code></pre>

<hr>
<h2 id='pbc2'>Mayo Clinic Primary Biliary Cirrhosis Data</h2><span id='topic+pbc2'></span><span id='topic+pbc2.id'></span>

<h3>Description</h3>

<p>Followup of 312 randomised patients with primary biliary cirrhosis, a rare autoimmune liver disease, at Mayo Clinic.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pbc2 </code></pre>


<h3>Format</h3>

<p>A data frame with 1945 observations on the following 20 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>patients identifier; in total there are 312 patients.</p>
</dd>
<dt><code>years</code></dt><dd><p>number of years between registration and the earlier of death, transplantion, or study
analysis time.</p>
</dd>
<dt><code>status</code></dt><dd><p>a factor with levels <code>alive</code>, <code>transplanted</code> and <code>dead</code>.</p>
</dd>
<dt><code>drug</code></dt><dd><p>a factor with levels <code>placebo</code> and <code>D-penicil</code>.</p>
</dd>
<dt><code>age</code></dt><dd><p>at registration in years.</p>
</dd>
<dt><code>sex</code></dt><dd><p>a factor with levels <code>male</code> and <code>female</code>.</p>
</dd>
<dt><code>year</code></dt><dd><p>number of years between enrollment and this visit date, remaining values on the line of
data refer to this visit.</p>
</dd>
<dt><code>ascites</code></dt><dd><p>a factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
<dt><code>hepatomegaly</code></dt><dd><p>a factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
<dt><code>spiders</code></dt><dd><p>a factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
<dt><code>edema</code></dt><dd><p>a factor with levels <code>No edema</code> (i.e., no edema and no diuretic therapy for edema),
<code>edema no diuretics</code> (i.e., edema present without diuretics, or edema resolved by diuretics), and
<code>edema despite diuretics</code> (i.e., edema despite diuretic therapy).</p>
</dd>
<dt><code>serBilir</code></dt><dd><p>serum bilirubin in mg/dl.</p>
</dd>
<dt><code>serChol</code></dt><dd><p>serum cholesterol in mg/dl.</p>
</dd>
<dt><code>albumin</code></dt><dd><p>albumin in gm/dl.</p>
</dd>
<dt><code>alkaline</code></dt><dd><p>alkaline phosphatase in U/liter.</p>
</dd>
<dt><code>SGOT</code></dt><dd><p>SGOT in U/ml.</p>
</dd>
<dt><code>platelets</code></dt><dd><p>platelets per cubic ml / 1000.</p>
</dd>
<dt><code>prothrombin</code></dt><dd><p>prothrombin time in seconds.</p>
</dd>
<dt><code>histologic</code></dt><dd><p>histologic stage of disease.</p>
</dd>
<dt><code>status2</code></dt><dd><p>a numeric vector with the value 1 denoting if the patient was dead,
and 0 if the patient was alive or transplanted.</p>
</dd>
</dl>



<h3>References</h3>

<p>Fleming, T. and Harrington, D. (1991) <em>Counting Processes and Survival Analysis</em>. Wiley, New York.
</p>
<p>Therneau, T. and Grambsch, P. (2000) <em>Modeling Survival Data: Extending the Cox Model</em>. Springer-Verlag, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  summary(pbc2)
  </code></pre>

<hr>
<h2 id='prep_boot'>Precomputation for wild bootstrap</h2><span id='topic+prep_boot'></span>

<h3>Description</h3>

<p>Implements key components for the wild bootstrap of the hqm estimator in preparation for obtaining confidence bands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_boot(g_xt, alpha, Ni, Yi, size_s_grid, br_X, br_s, t, b, int_X, x, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_boot_+3A_g_xt">g_xt</code></td>
<td>
<p>A vector obtained by <code><a href="#topic+g_xt">g_xt</a></code>.</p>
</td></tr>
<tr><td><code id="prep_boot_+3A_alpha">alpha</code></td>
<td>
<p>A vector of the marker only hazard on the marker grid obtained by <code><a href="#topic+get_alpha">get_alpha</a></code>.</p>
</td></tr>
<tr><td><code id="prep_boot_+3A_ni">Ni</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Ni">make_Ni</a></code> indicating the occurence.</p>
</td></tr>
<tr><td><code id="prep_boot_+3A_yi">Yi</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Yi">make_Yi</a></code> indicating the exposure. </p>
</td></tr>
<tr><td><code id="prep_boot_+3A_size_s_grid">size_s_grid</code></td>
<td>
<p>Size of the time grid.</p>
</td></tr>
<tr><td><code id="prep_boot_+3A_br_x">br_X</code></td>
<td>
<p>Vector of grid points for the marker values.</p>
</td></tr>
<tr><td><code id="prep_boot_+3A_br_s">br_s</code></td>
<td>
<p>Time value grid points that will be used in the evaluatiuon.</p>
</td></tr>
<tr><td><code id="prep_boot_+3A_t">t</code></td>
<td>
<p>Numeric value of the time the function should be evaluated.</p>
</td></tr>
<tr><td><code id="prep_boot_+3A_b">b</code></td>
<td>
<p>Bandwidth.</p>
</td></tr>
<tr><td><code id="prep_boot_+3A_int_x">int_X</code></td>
<td>
<p>Position of the linear interpolated marker values on the marker grid.</p>
</td></tr>
<tr><td><code id="prep_boot_+3A_x">x</code></td>
<td>
<p>Numeric value of the last observed marker value.</p>
</td></tr>
<tr><td><code id="prep_boot_+3A_n">n</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements
</p>
<p style="text-align: center;"><code class="reqn">A_B(t)  =  \frac{1}{\sqrt{n}} \sum_{i=1}^n \int^{T}_0 \hat{g}_{i,t,x_*}(X_i(s))  V_i\{dN_i(s) - \hat{\alpha}_i(X_i(s))Z_i(s)ds\},</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">
B_B(t)  = \frac{1}{\sqrt{n}}\sum_{i = 1}^n V_i\{\hat{\Gamma}(t,x_*)^{-1}W_i(t,x_*) - \hat{h}_{x_*}(t)\},</code>
</p>

<p>where <code class="reqn">V \sim N(0,1)</code>,
</p>
<p style="text-align: center;"><code class="reqn">W_i(t) =\int_0^T\hat{\alpha}_i(X_i(t+s))Z_i(t+s)Z_i(s)K_b(x_*,X_i(s))\mathrm {d}s,</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\hat{\Gamma}(t,x)  = \frac{1}{n}  \sum_{i = 1}^n \int_{0}^{T-t} Z_i(t+s)Z_i(s) K_b(x,X_i(s))ds,</code>
</p>

<p>with <code class="reqn">Z</code> being the exposure and <code class="reqn">X</code> the marker.
</p>


<h3>Value</h3>

<p>A list of 5 items. The first two are vectors for calculating <code class="reqn">A_B</code> and the third one a vector for <code class="reqn">B_B</code>. The 4th one is the value of the hqm estimator that can also be obtained by <code><a href="#topic+h_xt">h_xt</a></code> and the last one is the value of <code class="reqn">\Gamma</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+Conf_bands">Conf_bands</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>pbc2_id = to_id(pbc2)
size_s_grid &lt;- size_X_grid &lt;- 100
n = max(as.numeric(pbc2$id))
s = pbc2$year
X = pbc2$serBilir
XX = pbc2_id$serBilir
ss &lt;- pbc2_id$years
delta &lt;- pbc2_id$status2
br_s = seq(0, max(s), max(s)/( size_s_grid-1))
br_X = seq(min(X), max(X), (max(X)-min(X))/( size_X_grid-1))

X_lin = lin_interpolate(br_s, pbc2_id$id, pbc2$id, X, s)

int_X &lt;- findInterval(X_lin, br_X)
int_s = rep(1:length(br_s), n)

N &lt;- make_N(pbc2, pbc2_id, br_X, br_s, ss, XX, delta)
Y &lt;- make_Y(pbc2, pbc2_id, X_lin, br_X, br_s,
            size_s_grid, size_X_grid, int_s, int_X, event_time = 'years', n)

b = 1.7
alpha&lt;-get_alpha(N, Y, b, br_X, K=Epan )

Yi &lt;- make_Yi(pbc2, pbc2_id, X_lin, br_X, br_s,
              size_s_grid, size_X_grid, int_s, int_X, event_time = 'years', n)
Ni  &lt;- make_Ni(br_s, size_s_grid, ss, delta, n)

t = 2
x = 2

g = g_xt(br_X, br_s, size_s_grid, int_X, x, t, b, Yi, Y, n)

Boot_all = prep_boot(g, alpha, Ni, Yi, size_s_grid, br_X, br_s, t, b, int_X, x, n)
Boot_all
</code></pre>

<hr>
<h2 id='prep_cv'>Prepare for Cross validation bandwidth selection</h2><span id='topic+prep_cv'></span>

<h3>Description</h3>

<p>Implements the calculation of the hqm estimator on cross validation data sets. This is a preparation for the cross validation bandwidth selection technique for future conditional hazard rate estimation based on marker information data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_cv(data, data.id, marker_name, event_time_name = 'years',
        time_name = 'year',event_name = 'status2', n, I, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_cv_+3A_data">data</code></td>
<td>
<p>A data frame of time dependent data points.  Missing values are allowed.</p>
</td></tr>
<tr><td><code id="prep_cv_+3A_data.id">data.id</code></td>
<td>
<p>An id data frame obtained from <code><a href="#topic+to_id">to_id</a></code>.</p>
</td></tr>
<tr><td><code id="prep_cv_+3A_marker_name">marker_name</code></td>
<td>
<p>The column name of the marker values in the data frame <code><a href="utils.html#topic+data">data</a></code>. </p>
</td></tr>
<tr><td><code id="prep_cv_+3A_event_time_name">event_time_name</code></td>
<td>
<p>The column name of the event times in the data frame <code><a href="utils.html#topic+data">data</a></code>. </p>
</td></tr>
<tr><td><code id="prep_cv_+3A_time_name">time_name</code></td>
<td>
<p>The column name of the times the marker values were observed in the data frame <code><a href="utils.html#topic+data">data</a></code>.</p>
</td></tr>
<tr><td><code id="prep_cv_+3A_event_name">event_name</code></td>
<td>
<p>The column name of the events in the data frame <code><a href="utils.html#topic+data">data</a></code>.</p>
</td></tr>
<tr><td><code id="prep_cv_+3A_n">n</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
<tr><td><code id="prep_cv_+3A_i">I</code></td>
<td>
<p>Number of observations leave out for a K cross validation.</p>
</td></tr>
<tr><td><code id="prep_cv_+3A_b">b</code></td>
<td>
<p>Bandwidth.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function splits the data set via <code><a href="#topic+dataset_split">dataset_split</a></code> and calculates for every splitted data set the hqm estimator
</p>
<p style="text-align: center;"><code class="reqn">\hat{h}_x(t) = \frac{\sum_{i=1}^n \int_0^T\hat{\alpha}_i(X_i(t+s))Z_i(t+s)Z_i(s)K_{b}(x-X_i(s))\mathrm {d}s}{\sum_{i=1}^n\int_0^TZ_i(t+s)Z_i(s)K_{b}(x-X_i(s))\mathrm {d}s},</code>
</p>

<p>for all <code class="reqn">x</code> on the marker grid and <code class="reqn">t</code> on the time grid, where <code class="reqn">X</code> is the marker, <code class="reqn">Z</code> is the exposure and <code class="reqn">\alpha(z)</code> is the marker-only hazard, see <code><a href="#topic+get_alpha">get_alpha</a></code> for more details.
</p>


<h3>Value</h3>

<p>A list of matrices for every cross validation data set with <code class="reqn">\hat{h}_x(t)</code> for all <code class="reqn">x</code> on the marker grid and <code class="reqn">t</code> on the time grid.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+b_selection">b_selection</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
pbc2_id = to_id(pbc2)
n = max(as.numeric(pbc2$id))
b = 1.5
I = 26
h_xt_mat_list = prep_cv(pbc2, pbc2_id, 'serBilir', 'years', 'year', 'status2', n, I, b)
</code></pre>

<hr>
<h2 id='Q1'>Bandwidth selection score Q1</h2><span id='topic+Q1'></span>

<h3>Description</h3>

<p>Calculates a part for the K-fold cross validation score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q1(h_xt_mat, int_X, size_X_grid, n, Yi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Q1_+3A_h_xt_mat">h_xt_mat</code></td>
<td>
<p>A matrix of the estimator for the future conditional hazard rate for all values <code>x</code> and <code>t</code>.</p>
</td></tr>
<tr><td><code id="Q1_+3A_int_x">int_X</code></td>
<td>
<p>Vector of the position of the observed marker values in the grid for marker values.</p>
</td></tr>
<tr><td><code id="Q1_+3A_size_x_grid">size_X_grid</code></td>
<td>
<p>Numeric value indicating the number of grid points for marker values.</p>
</td></tr>
<tr><td><code id="Q1_+3A_n">n</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
<tr><td><code id="Q1_+3A_yi">Yi</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Yi">make_Yi</a></code> indicating the exposure. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements
</p>
<p style="text-align: center;"><code class="reqn">Q_1 =  \sum_{i = 1}^N \int_0^T \int_s^T Z_i(t)Z_i(s)\hat{h}_{X_i(s)}^2(t-s) dt ds,</code>
</p>

<p>where <code class="reqn">\hat{h}</code> is the hqm estimator, <code class="reqn">Z</code> the exposure and <code class="reqn">X</code> the marker.
</p>


<h3>Value</h3>

<p>A value of the score Q1.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+b_selection">b_selection</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>pbc2_id = to_id(pbc2)
size_s_grid &lt;- size_X_grid &lt;- 100
n = max(as.numeric(pbc2$id))
s = pbc2$year
X = pbc2$serBilir
XX = pbc2_id$serBilir
ss &lt;- pbc2_id$years
delta &lt;- pbc2_id$status2
br_s = seq(0, max(s), max(s)/( size_s_grid-1))
br_X = seq(min(X), max(X), (max(X)-min(X))/( size_X_grid-1))

X_lin = lin_interpolate(br_s, pbc2_id$id, pbc2$id, X, s)

int_X &lt;- findInterval(X_lin, br_X)
int_s = rep(1:length(br_s), n)

N &lt;- make_N(pbc2, pbc2_id, br_X, br_s, ss, XX, delta)
Y &lt;- make_Y(pbc2, pbc2_id, X_lin, br_X, br_s,
            size_s_grid, size_X_grid, int_s, int_X, event_time = 'years', n)

b = 1.7
alpha&lt;-get_alpha(N, Y, b, br_X, K=Epan )

Yi &lt;- make_Yi(pbc2, pbc2_id, X_lin, br_X, br_s,
              size_s_grid, size_X_grid, int_s, int_X, event_time = 'years', n)
Ni  &lt;- make_Ni(br_s, size_s_grid, ss, delta, n)

t = 2

h_xt_mat = t(sapply(br_s[1:99],
            function(si){h_xt_vec(br_X, br_s, size_s_grid, alpha, t, b, Yi, int_X, n)}))

Q = Q1(h_xt_mat, int_X, size_X_grid, n, Yi)
</code></pre>

<hr>
<h2 id='R_K'>Bandwidth selection score R</h2><span id='topic+R_K'></span>

<h3>Description</h3>

<p>Calculates a part for the K-fold cross validation score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R_K(h_xt_mat_list, int_X, size_X_grid, Yi, Ni, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R_K_+3A_h_xt_mat_list">h_xt_mat_list</code></td>
<td>
<p>A list of matrices for all cross validation data sets. Each matrix contains the estimator with the future conditional hazard rate for all values <code>x</code> and <code>t</code> and the respected data set.</p>
</td></tr>
<tr><td><code id="R_K_+3A_int_x">int_X</code></td>
<td>
<p>Vector of the position of the observed marker values in the grid for marker values.</p>
</td></tr>
<tr><td><code id="R_K_+3A_size_x_grid">size_X_grid</code></td>
<td>
<p>Numeric value indicating the number of grid points for marker values.</p>
</td></tr>
<tr><td><code id="R_K_+3A_yi">Yi</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Yi">make_Yi</a></code> indicating the exposure. </p>
</td></tr>
<tr><td><code id="R_K_+3A_ni">Ni</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Ni">make_Ni</a></code> indicating the occurence. </p>
</td></tr>
<tr><td><code id="R_K_+3A_n">n</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the estimator
</p>
<p style="text-align: center;"><code class="reqn">\hat{R}_K =  \sum_{j = 1}^K\sum_{i \in I_j} \int_0^T  g^{-I_j}_i(t)  dN_i(t),</code>
</p>

<p>where <code class="reqn">\hat{g}^{-I_j}_i(t) = \int_0^t Z_i(s) \hat{h}^{-I_j}_{X_i(s)}(t-s) ds,</code> and <code class="reqn">\hat{h}^{-I_j}</code> is estimated without information from all counting processes <code class="reqn">i</code> with <code class="reqn">i \in I_j</code>.
This function estimates
</p>
<p style="text-align: center;"><code class="reqn">R =  \sum_{i = 1}^N \int_0^T \int_s^T Z_i(t)Z_i(s)\hat{h}_{X_i(s)}(t-s) h_{X_i(s)}(t-s) dt ds .</code>
</p>

<p>where <code class="reqn">\hat{h}</code> is the hqm estimator, <code class="reqn">Z</code> the exposure and <code class="reqn">X</code> the marker.
</p>


<h3>Value</h3>

<p>A matrix with <code class="reqn">\hat{g}^{-I_j}_i(t)</code> for all individuals <code>i</code> and time grid points <code>t</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+b_selection">b_selection</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>pbc2_id = to_id(pbc2)
n = max(as.numeric(pbc2$id))
b = 1.5
I = 104
h_xt_mat_list = prep_cv(pbc2, pbc2_id, 'serBilir', 'years', 'year', 'status2', n, I, b)


size_s_grid &lt;- size_X_grid &lt;- 100
s = pbc2$year
X = pbc2$serBilir
br_s = seq(0, max(s), max(s)/( size_s_grid-1))
br_X = seq(min(X), max(X), (max(X)-min(X))/( size_X_grid-1))

ss &lt;- pbc2_id$years
delta &lt;- pbc2_id$status2

X_lin = lin_interpolate(br_s, pbc2_id$id, pbc2$id, X, s)
int_X &lt;- findInterval(X_lin, br_X)
int_s = rep(1:length(br_s), n)

Yi &lt;- make_Yi(pbc2, pbc2_id, X_lin, br_X, br_s,
              size_s_grid, size_X_grid, int_s, int_X, 'years', n)
Ni  &lt;- make_Ni(br_s, size_s_grid, ss, delta, n)

R = R_K(h_xt_mat_list, int_X, size_X_grid, Yi, Ni, n)
R
</code></pre>

<hr>
<h2 id='to_id'>Event data frame</h2><span id='topic+to_id'></span>

<h3>Description</h3>

<p>Creates a data frame with only one entry per individual from a data frame with time dependent data. The resulting data frame focusses on the event time and the last observed marker value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_id(data_set)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to_id_+3A_data_set">data_set</code></td>
<td>
<p>A data frame of time dependent data points.  Missing values are allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+to_id">to_id</a></code> uses a data frame of time dependent marker data to create a smaller data frame with only one entry per individual, the last observed marker value and the event time. Note that the column indicating the individuals must have the name <code>id</code>. Note also that this data frame is similar to <code>pbc2.id</code> from the <code>JM</code> package with the difference that the last observed marker value instead of the first one is captured.
</p>


<h3>Value</h3>

<p>A data frame with only one entry per individual.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_set.id = to_id(pbc2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
