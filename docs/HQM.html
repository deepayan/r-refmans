<!DOCTYPE html><html><head><title>Help for package HQM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HQM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#b_selection'><p>Cross validation bandwidth selection</p></a></li>
<li><a href='#b_selection_prep_g'><p>Preparations for bandwidth selection</p></a></li>
<li><a href='#Conf_bands'><p>Confidence bands</p></a></li>
<li><a href='#dataset_split'><p>Split dataset for K-fold cross validation</p></a></li>
<li><a href='#g_xt'><p>Computation of a key component for wild bootstrap</p></a></li>
<li><a href='#get_alpha'><p>Marker-only hazard rate</p></a></li>
<li><a href='#get_h_x'><p>Future conditional hazard rate for all time values</p></a></li>
<li><a href='#h_xt'><p>Future conditional hazard rate</p></a></li>
<li><a href='#h_xt_vec'><p>Hqm estimator on the marker grid</p></a></li>
<li><a href='#Kernels'><p>Epanechnikov kernel and pdf kernel estimate</p></a></li>
<li><a href='#lin_interpolate'><p>Linear interpolation</p></a></li>
<li><a href='#make_N, make_Ni, make_Y, make_Yi'><p>Occurance and Exposure on grids</p></a></li>
<li><a href='#make_sf'><p>Survival function from a hazard</p></a></li>
<li><a href='#pbc2'><p>Mayo Clinic Primary Biliary Cirrhosis Data</p></a></li>
<li><a href='#prep_boot'><p>Precomputation for wild bootstrap</p></a></li>
<li><a href='#prep_cv'><p>Prepare for Cross validation bandwidth selection</p></a></li>
<li><a href='#Q1'><p>Bandwidth selection score Q1</p></a></li>
<li><a href='#R_K'><p>Bandwidth selection score R</p></a></li>
<li><a href='#to_id'><p>Event data frame</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Superefficient Estimation of Future Conditional Hazards Based on
Marker Information</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alex Isakson &lt;alex.isakson@bayes.city.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a nonparametric smoothed kernel density estimator for the future conditional hazard when time-dependent covariates are present. It also provides pointwise and uniform confidence bands and a bandwidth selection.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-09 11:43:03 UTC; Alex</td>
</tr>
<tr>
<td>Author:</td>
<td>Alex Isakson [aut, cre],
  Dimitrios Bagkavos [ctb],
  Enno Mammen [ctb],
  Jens Nielsen [ctb],
  Cecile Proust-Lima [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-12 07:52:55 UTC</td>
</tr>
</table>
<hr>
<h2 id='b_selection'>Cross validation bandwidth selection</h2><span id='topic+b_selection'></span>

<h3>Description</h3>

<p>Implements the bandwidth selection for the future conditional hazard rate <code class="reqn">\hat h_x(t)</code> based on K-fold cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>b_selection(data, marker_name, event_time_name = 'years',
            time_name = 'year', event_name = 'status2', I, b_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b_selection_+3A_data">data</code></td>
<td>
<p>A data frame of time dependent data points.  Missing values are allowed.</p>
</td></tr>
<tr><td><code id="b_selection_+3A_marker_name">marker_name</code></td>
<td>
<p>The column name of the marker values in the data frame <code><a href="utils.html#topic+data">data</a></code>. </p>
</td></tr>
<tr><td><code id="b_selection_+3A_event_time_name">event_time_name</code></td>
<td>
<p>The column name of the event times in the data frame <code><a href="utils.html#topic+data">data</a></code>. </p>
</td></tr>
<tr><td><code id="b_selection_+3A_time_name">time_name</code></td>
<td>
<p>The column name of the times the marker values were observed in the data frame <code><a href="utils.html#topic+data">data</a></code>.</p>
</td></tr>
<tr><td><code id="b_selection_+3A_event_name">event_name</code></td>
<td>
<p>The column name of the events in the data frame <code><a href="utils.html#topic+data">data</a></code>.</p>
</td></tr>
<tr><td><code id="b_selection_+3A_i">I</code></td>
<td>
<p>Number of observations leave out for a K cross validation.</p>
</td></tr>
<tr><td><code id="b_selection_+3A_b_list">b_list</code></td>
<td>
<p>Vector of bandwidths that need to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+b_selection">b_selection</a></code> implements the cross validation bandwidth selection for the future conditional hazard rate <code class="reqn">\hat h_x(t)</code> given by
</p>
<p style="text-align: center;"><code class="reqn"> b_{CV} = arg min_b \sum_{i = 1}^N \int_0^T \int_s^T Z_i(t)Z_i(s)(\hat{h}_{X_i(s)}(t-s)- h_{X_i(s)}(t-s))^2 dt ds,</code>
</p>

<p>where <code class="reqn">\hat h_x(t)</code> is a smoothed kernel density estimator of <code class="reqn"> h_x(t)</code> and <code class="reqn">Z_i</code> the exposure process of individual <code class="reqn">i</code>. Note that <code class="reqn">\hat h_x(t)</code> is dependent on <code class="reqn">b</code>.
</p>


<h3>Value</h3>

<p>A list with the tested bandwidths and its cross validation scores.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+b_selection_prep_g">b_selection_prep_g</a>, <a href="#topic+Q1">Q1</a>, <a href="#topic+R_K">R_K</a>, <a href="#topic+prep_cv">prep_cv</a>, <a href="#topic+dataset_split">dataset_split</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
I = 26
b_list = seq(0.9, 1.3, 0.1)

b_scores_alb = b_selection(pbc2, 'albumin', 'years', 'year', 'status2', I, b_list)
b_scores_alb[[2]][which.min(b_scores_alb[[1]])]
</code></pre>

<hr>
<h2 id='b_selection_prep_g'>Preparations for bandwidth selection</h2><span id='topic+b_selection_prep_g'></span>

<h3>Description</h3>

<p>Calculates an intermediate part for the K-fold cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>b_selection_prep_g(h_mat, int_X, size_X_grid, n, Yi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b_selection_prep_g_+3A_h_mat">h_mat</code></td>
<td>
<p>A matrix of the estimator for the future conditional hazard rate for all values <code>x</code> and <code>t</code>.</p>
</td></tr>
<tr><td><code id="b_selection_prep_g_+3A_int_x">int_X</code></td>
<td>
<p>Vector of the position of the observed marker values in the grid for marker values.</p>
</td></tr>
<tr><td><code id="b_selection_prep_g_+3A_size_x_grid">size_X_grid</code></td>
<td>
<p>Numeric value indicating the number of grid points for marker values.</p>
</td></tr>
<tr><td><code id="b_selection_prep_g_+3A_n">n</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
<tr><td><code id="b_selection_prep_g_+3A_yi">Yi</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Yi">make_Yi</a></code> indicating the exposure. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+b_selection_prep_g">b_selection_prep_g</a></code> calculates a key component for the bandwidth selection
</p>
<p style="text-align: center;"><code class="reqn">\hat{g}^{-I_j}_i(t) = \int_0^t Z_i(s) \hat{h}^{-I_j}_{X_i(s)}(t-s) ds,</code>
</p>

<p>where <code class="reqn">\hat{h}^{-I_j}</code> is estimated without information from all counting processes <code class="reqn">i</code> with <code class="reqn">i \in I_j</code> and <code class="reqn">Z</code> is the exposure.
</p>


<h3>Value</h3>

<p>A matrix with <code class="reqn">\hat{g}^{-I_j}_i(t)</code> for all individuals <code>i</code> and time grid points <code>t</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+b_selection">b_selection</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>pbc2_id = to_id(pbc2)
size_s_grid &lt;- size_X_grid &lt;- 100
n = max(as.numeric(pbc2$id))
s = pbc2$year
X = pbc2$serBilir
XX = pbc2_id$serBilir
ss &lt;- pbc2_id$years
delta &lt;- pbc2_id$status2
br_s = seq(0, max(s), max(s)/( size_s_grid-1))
br_X = seq(min(X), max(X), (max(X)-min(X))/( size_X_grid-1))

X_lin = lin_interpolate(br_s, pbc2_id$id, pbc2$id, X, s)

int_X &lt;- findInterval(X_lin, br_X)
int_s = rep(1:length(br_s), n)

N &lt;- make_N(pbc2, pbc2_id, breaks_X=br_X, breaks_s=br_s, ss, XX, delta)
Y &lt;- make_Y(pbc2, pbc2_id, X_lin, br_X, br_s, size_s_grid, size_X_grid, int_s, int_X, 'years', n)

b = 1.7
alpha&lt;-get_alpha(N, Y, b, br_X, K=Epan )

Yi &lt;- make_Yi(pbc2, pbc2_id, X_lin, br_X, br_s, size_s_grid, size_X_grid, int_s, int_X,'years', n)
Ni  &lt;- make_Ni(breaks_s=br_s, size_s_grid, ss, delta, n)

t = 2

h_xt_mat = t(sapply(br_s[1:99], function(si){
                    h_xt_vec(br_X, br_s, size_s_grid, alpha, t, b, Yi, int_X, n)}))

b_selection_prep_g(h_xt_mat, int_X, size_X_grid, n, Yi)
</code></pre>

<hr>
<h2 id='Conf_bands'>Confidence bands</h2><span id='topic+Conf_bands'></span>

<h3>Description</h3>

<p>Implements the uniform and pointwise confidence bands for the future conditional hazard rate based on the last observed marker measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Conf_bands(data, marker_name, event_time_name = 'years',
            time_name = 'year', event_name = 'status2', x, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Conf_bands_+3A_data">data</code></td>
<td>
<p>A data frame of time dependent data points.  Missing values are allowed.</p>
</td></tr>
<tr><td><code id="Conf_bands_+3A_marker_name">marker_name</code></td>
<td>
<p>The column name of the marker values in the data frame <code><a href="utils.html#topic+data">data</a></code>. </p>
</td></tr>
<tr><td><code id="Conf_bands_+3A_event_time_name">event_time_name</code></td>
<td>
<p>The column name of the event times in the data frame <code><a href="utils.html#topic+data">data</a></code>. </p>
</td></tr>
<tr><td><code id="Conf_bands_+3A_time_name">time_name</code></td>
<td>
<p>The column name of the times the marker values were observed in the data frame <code><a href="utils.html#topic+data">data</a></code>.</p>
</td></tr>
<tr><td><code id="Conf_bands_+3A_event_name">event_name</code></td>
<td>
<p>The column name of the events in the data frame <code><a href="utils.html#topic+data">data</a></code>.</p>
</td></tr>
<tr><td><code id="Conf_bands_+3A_x">x</code></td>
<td>
<p>Numeric value of the last observed marker value.</p>
</td></tr>
<tr><td><code id="Conf_bands_+3A_b">b</code></td>
<td>
<p>Bandwidth.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+Conf_bands">Conf_bands</a></code> implements the pointwise and uniform confidence bands for the estimator of the future conditional hazard rate <code class="reqn">\hat h_x(t)</code>. The confidence bands are based on a wild bootstrap approach <code class="reqn">{h^*}_{{x_*},B}(t)</code>.
</p>
<p>Pointwise:
For a given <code class="reqn">t\in (0,T)</code> generate <code class="reqn">{h^*}_{{x_*},B}^{(1)}(t),...,{h^*}_{{x_*},B}^{(N)}(t)</code> for <code class="reqn">N = 1000</code> and order it <code class="reqn">{h^*}_{{x_*},B}^{[1]}(t)\leq ...\leq {h^*}_{{x_*},B}^{[N]}(t)</code>. Then
</p>
<p style="text-align: center;"><code class="reqn">
\hat{I}^1_{n,N} = \Bigg[\hat{h}_{x_*}(t) - \hat{\sigma}_{{G}_{x_*}}(t)\frac{{h^*}_{{x_*},B}^{[ N(1-\frac{\alpha}{2})]}(t)}{\sqrt{n}}, \hat{h}_{x_*}(t) -  \hat{\sigma}_{ {G}_x}(t)\frac{{h^*}_{{x_*},B}^{[ N\frac{\alpha}{2}]}(t)}{\sqrt{n}}\Bigg]
</code>
</p>

<p>is a <code class="reqn">1-\alpha</code> pointwise confidence band for <code class="reqn">h_{x_*}(t)</code>, where <code class="reqn">\hat{\sigma}_{{G}_{x_*}}(t)</code> is a bootrap estimate of the variance. For more details on the wild bootstrap approach, please see <code><a href="#topic+prep_boot">prep_boot</a></code> and <code><a href="#topic+g_xt">g_xt</a></code>.
</p>
<p>Uniform:
Generate <code class="reqn">\bar{h}_{{x_*},B}^{(1)}(t),...,\bar{h}_{{x_*},B}^{(N)}(t)</code> for <code class="reqn">N = 1000</code> for all <code class="reqn">t\in [\delta_T,T-\delta_T]</code> and define <code class="reqn">W^{(i)} = \sup_{t\in[0,T]}\big|\bar{h}_{{x_*},B}^{(i)}(t)|</code> for <code class="reqn">i = 1,...,N</code>. Order <code class="reqn">W^{[1]} \leq ... \leq W^{[N]}</code>. Then
</p>
<p style="text-align: center;"><code class="reqn">\hat{I}^2_{n,N} = \Bigg[\hat{h}_{x_*}(t) \pm \hat{\sigma}_{{G}_{x_*}}(t) \frac{W^{[ N(1 - \alpha)]}}{\sqrt{n}} \Bigg]</code>
</p>

<p>is a <code class="reqn">1-\alpha</code> uniform confidence band for <code class="reqn">h_{x_*}(t)</code>.
</p>


<h3>Value</h3>

<p>A list with pointwise, uniform confidence bands and the estimator <code class="reqn">\hat h_x(t)</code> for all possible time points <code class="reqn">t</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+g_xt">g_xt</a>, <a href="#topic+prep_boot">prep_boot</a> </code></p>


<h3>Examples</h3>

<pre><code class='language-R'>b = 10
x = 3
size_s_grid &lt;- 100
s = pbc2$year
br_s = seq(0, max(s), max(s)/( size_s_grid-1))


c_bands = Conf_bands(pbc2, 'serBilir', event_time_name = 'years',
                    time_name = 'year', event_name = 'status2', x, b)

J = 60
plot(br_s[1:J], c_bands$h_hat[1:J], type = "l", ylim = c(0,1), ylab = 'Hazard', xlab = 'Years')

lines(br_s[1:J], c_bands$I_p_up[1:J], col = "red")
lines(br_s[1:J], c_bands$I_p_do[1:J], col = "red")
lines(br_s[1:J], c_bands$I_nu[1:J], col = "blue")
lines(br_s[1:J], c_bands$I_nd[1:J], col = "blue")
</code></pre>

<hr>
<h2 id='dataset_split'>Split dataset for K-fold cross validation</h2><span id='topic+dataset_split'></span>

<h3>Description</h3>

<p>Creates multiple splits of a dataset which is then used in the bandwidth selection with K-fold cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataset_split(I, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataset_split_+3A_data">data</code></td>
<td>
<p>A data frame of time dependent data points.  Missing values are allowed.</p>
</td></tr>
<tr><td><code id="dataset_split_+3A_i">I</code></td>
<td>
<p>The number of individuals that should be left out. Optimally, <code class="reqn">K = n/I</code> should be an integer, where <code class="reqn">n</code> is the number of individuals.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+dataset_split">dataset_split</a></code> takes a data frame and transforms it into <code class="reqn">K = n/I</code> data frames with <code class="reqn">I</code> individuals missing from each data frame. Let <code class="reqn">I_j</code> be sets of indices with <code class="reqn">\cup_{j=1}^K I_j = \{1,...,n\}</code>, <code class="reqn">I_k\cap I_j =  \emptyset</code> and <code class="reqn">|I_j| = |I_k| = I</code> for all <code class="reqn">j, k \in \{1,...,K\}</code>. Then data frames with <code class="reqn">\{1,...,n \}/I_j</code> individuals are created.
</p>


<h3>Value</h3>

<p>A list of data frames with <code><a href="base.html#topic+I">I</a></code> individuals missing in the above way.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+b_selection">b_selection</a> </code></p>


<h3>Examples</h3>

<pre><code class='language-R'>splitted_dataset = dataset_split(26, pbc2)
</code></pre>

<hr>
<h2 id='g_xt'>Computation of a key component for wild bootstrap</h2><span id='topic+g_xt'></span>

<h3>Description</h3>

<p>Implements a key part for the wild bootstrap of the hqm estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_xt(br_X, br_s, size_s_grid, int_X, x, t, b, Yi, Y, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g_xt_+3A_br_x">br_X</code></td>
<td>
<p>Marker value grid points that will be used in the evaluatiuon.</p>
</td></tr>
<tr><td><code id="g_xt_+3A_br_s">br_s</code></td>
<td>
<p>Time value grid points that will be used in the evaluatiuon.</p>
</td></tr>
<tr><td><code id="g_xt_+3A_size_s_grid">size_s_grid</code></td>
<td>
<p>Size of the time grid.</p>
</td></tr>
<tr><td><code id="g_xt_+3A_int_x">int_X</code></td>
<td>
<p>Position of the linear interpolated marker values on the marker grid.</p>
</td></tr>
<tr><td><code id="g_xt_+3A_x">x</code></td>
<td>
<p>Numeric value of the last observed marker value.</p>
</td></tr>
<tr><td><code id="g_xt_+3A_t">t</code></td>
<td>
<p>Numeric value of the time the function should be evaluated.</p>
</td></tr>
<tr><td><code id="g_xt_+3A_b">b</code></td>
<td>
<p>Bandwidth.</p>
</td></tr>
<tr><td><code id="g_xt_+3A_yi">Yi</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Yi">make_Yi</a></code> indicating the exposure. </p>
</td></tr>
<tr><td><code id="g_xt_+3A_y">Y</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Y">make_Y</a></code> indicating the exposure. </p>
</td></tr>
<tr><td><code id="g_xt_+3A_n">n</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements
</p>
<p style="text-align: center;"><code class="reqn">\hat{g}_{t,x}(z) =  \frac{1}{n}  \sum_{ j = 1}^n \int^{T-t}_0 \hat{E}(X_j(t+s))^{-1} K_b(z,X_j(t+s)) Z_j(t+s)Z_j(s)K_b(x,X_j(s))ds,</code>
</p>

<p>for every value <code class="reqn">z</code> on the marker grid, where <code class="reqn">\hat{E}(x) = \frac{1}{n} \sum_{j=1}^n \int_0^T K_b(x,X_j(s))Z_j(s)ds</code>, <code class="reqn">Z</code> the exposure and <code class="reqn">X</code> the marker.
</p>


<h3>Value</h3>

<p>A vector of <code class="reqn">\hat{g}_{t,x}(z)</code> for all values <code class="reqn">z</code> on the marker grid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbc2_id = to_id(pbc2)
size_s_grid &lt;- size_X_grid &lt;- 100
n = max(as.numeric(pbc2$id))
X = pbc2$serBilir
s = pbc2$year
br_s = seq(0, max(s), max(s)/( size_s_grid-1))
br_X = seq(min(X), max(X), (max(X)-min(X))/( size_X_grid-1))

X_lin = lin_interpolate(br_s, pbc2_id$id, pbc2$id, X, s)

int_X &lt;- findInterval(X_lin, br_X)
int_s = rep(1:length(br_s), n)

Yi&lt;-make_Yi(pbc2, pbc2_id, X_lin, br_X, br_s, size_s_grid, size_X_grid, int_s, int_X, 'years', n)
Y&lt;-make_Y(pbc2, pbc2_id, X_lin, br_X, br_s,size_s_grid,size_X_grid, int_s,int_X, 'years', n)

t = 2
x = 2
b = 10

g_xt(br_X, br_s, size_s_grid, int_X, x, t, b, Yi, Y, n)
</code></pre>

<hr>
<h2 id='get_alpha'>Marker-only hazard rate</h2><span id='topic+get_alpha'></span>

<h3>Description</h3>

<p>Calculates the marker-only hazard rate for time dependent data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_alpha(N, Y, b, br_X, K=Epan )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_alpha_+3A_n">N</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_N">make_N</a></code> indicating the occurences of events.</p>
</td></tr>
<tr><td><code id="get_alpha_+3A_y">Y</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Y">make_Y</a></code> indicating the exposure. </p>
</td></tr>
<tr><td><code id="get_alpha_+3A_b">b</code></td>
<td>
<p>Bandwidth.</p>
</td></tr>
<tr><td><code id="get_alpha_+3A_br_x">br_X</code></td>
<td>
<p>Vector of grid points for the marker values <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="get_alpha_+3A_k">K</code></td>
<td>
<p>Used kernel function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+get_alpha">get_alpha</a></code> implements the marker-only hazard estimator
</p>
<p style="text-align: center;"><code class="reqn">\hat{\alpha}_i(z) = \frac{\sum_{k\neq i}\int_0^T K_{b_1}(z-X_k(s))\mathrm{d}N_k(s)}{\sum_{k\neq i}\int_0^T K_{b_1}(z-X_k(s))Z_k(s)\mathrm{d}s},</code>
</p>

<p>where <code class="reqn">X</code> is the marker and <code class="reqn">Z</code> is the exposure. The marker-only hazard is defined as the underlying hazard which is not dependent on time
</p>
<p style="text-align: center;"><code class="reqn">\alpha(X(t),t) = \alpha(X(t))</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>A vector of marker-only values for <code>br_X</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+h_xt">h_xt</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>pbc2_id = to_id(pbc2)
size_s_grid &lt;- size_X_grid &lt;- 100
n = max(as.numeric(pbc2$id))
s = pbc2$year
X = pbc2$serBilir
XX = pbc2_id$serBilir
ss &lt;- pbc2_id$years
delta &lt;- pbc2_id$status2
br_s = seq(0, max(s), max(s)/( size_s_grid-1))
br_X = seq(min(X), max(X), (max(X)-min(X))/( size_X_grid-1))

X_lin = lin_interpolate(br_s, pbc2_id$id, pbc2$id, X, s)

int_X &lt;- findInterval(X_lin, br_X)
int_s = rep(1:length(br_s), n)

N  &lt;- make_N(pbc2, pbc2_id, breaks_X=br_X, breaks_s=br_s, ss, XX, delta)
Y &lt;- make_Y(pbc2, pbc2_id, X_lin, br_X, br_s, size_s_grid,
            size_X_grid, int_s, int_X, event_time = 'years', n)

b = 1.7
alpha&lt;-get_alpha(N, Y, b, br_X, K=Epan )
</code></pre>

<hr>
<h2 id='get_h_x'>Future conditional hazard rate for all time values</h2><span id='topic+get_h_x'></span>

<h3>Description</h3>

<p>Calculates the future conditional hazard rate for a marker value <code>x</code> and all possible time values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_h_x(data, marker_name, event_time_name = 'years',
        time_name = 'year', event_name = 'status2', x, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_h_x_+3A_data">data</code></td>
<td>
<p>A data frame of time dependent data points.  Missing values are allowed.</p>
</td></tr>
<tr><td><code id="get_h_x_+3A_marker_name">marker_name</code></td>
<td>
<p>The column name of the marker values in the data frame <code><a href="utils.html#topic+data">data</a></code>. </p>
</td></tr>
<tr><td><code id="get_h_x_+3A_event_time_name">event_time_name</code></td>
<td>
<p>The column name of the event times in the data frame <code><a href="utils.html#topic+data">data</a></code>. </p>
</td></tr>
<tr><td><code id="get_h_x_+3A_time_name">time_name</code></td>
<td>
<p>The column name of the times the marker values were observed in the data frame <code><a href="utils.html#topic+data">data</a></code>.</p>
</td></tr>
<tr><td><code id="get_h_x_+3A_event_name">event_name</code></td>
<td>
<p>The column name of the events in the data frame <code><a href="utils.html#topic+data">data</a></code>.</p>
</td></tr>
<tr><td><code id="get_h_x_+3A_x">x</code></td>
<td>
<p>Numeric value of the last observed marker value.</p>
</td></tr>
<tr><td><code id="get_h_x_+3A_b">b</code></td>
<td>
<p>Bandwidth.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+h_xt">h_xt</a></code> implements the future conditional hazard estimator
</p>
<p style="text-align: center;"><code class="reqn">\hat{h}_x(t) = \frac{\sum_{i=1}^n \int_0^T\hat{\alpha}_i(X_i(t+s))Z_i(t+s)Z_i(s)K_{b}(x-X_i(s))\mathrm {d}s}{\sum_{i=1}^n\int_0^TZ_i(t+s)Z_i(s)K_{b}(x-X_i(s))\mathrm {d}s},</code>
</p>

<p>where <code class="reqn">X</code> is the marker, <code class="reqn">Z</code> is the exposure and <code class="reqn">\alpha(z)</code> is the marker-only hazard, see <code><a href="#topic+get_alpha">get_alpha</a></code> for more details.
</p>


<h3>Value</h3>

<p>A vector of <code class="reqn">\hat h_x(t)</code> for a grid of possible time values <code class="reqn">t</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+get_alpha">get_alpha</a>, <a href="#topic+h_xt">h_xt</a> </code></p>


<h3>Examples</h3>

<pre><code class='language-R'>b = 10
x = 3

get_h_x(pbc2, 'serBilir', event_time_name = 'years',
        time_name = 'year', event_name = 'status2', x, b)
</code></pre>

<hr>
<h2 id='h_xt'>Future conditional hazard rate</h2><span id='topic+h_xt'></span>

<h3>Description</h3>

<p>Calculates the future conditional hazard rate for a marker value <code>x</code> and a time value <code>t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_xt(br_X, br_s, int_X, size_s_grid, alpha, x,t, b, Yi,n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_xt_+3A_br_x">br_X</code></td>
<td>
<p>Vector of grid points for the marker values <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="h_xt_+3A_br_s">br_s</code></td>
<td>
<p>Vector of grid points for the time values <code class="reqn">s</code>.</p>
</td></tr>
<tr><td><code id="h_xt_+3A_int_x">int_X</code></td>
<td>
<p>Position of the linear interpolated marker values on the marker grid.</p>
</td></tr>
<tr><td><code id="h_xt_+3A_size_s_grid">size_s_grid</code></td>
<td>
<p>Size of the time grid.</p>
</td></tr>
<tr><td><code id="h_xt_+3A_alpha">alpha</code></td>
<td>
<p>Marker-hazard obtained from <code><a href="#topic+get_alpha">get_alpha</a></code>.</p>
</td></tr>
<tr><td><code id="h_xt_+3A_x">x</code></td>
<td>
<p>Numeric value of the last observed marker value.</p>
</td></tr>
<tr><td><code id="h_xt_+3A_t">t</code></td>
<td>
<p>Numeric time value.</p>
</td></tr>
<tr><td><code id="h_xt_+3A_b">b</code></td>
<td>
<p>Bandwidth.</p>
</td></tr>
<tr><td><code id="h_xt_+3A_yi">Yi</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Yi">make_Yi</a></code> indicating the exposure. </p>
</td></tr>
<tr><td><code id="h_xt_+3A_n">n</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+h_xt">h_xt</a></code> implements the future conditional hazard estimator
</p>
<p style="text-align: center;"><code class="reqn">\hat{h}_x(t) = \frac{\sum_{i=1}^n \int_0^T\hat{\alpha}_i(X_i(t+s))Z_i(t+s)Z_i(s)K_{b}(x-X_i(s))\mathrm {d}s}{\sum_{i=1}^n\int_0^TZ_i(t+s)Z_i(s)K_{b}(x-X_i(s))\mathrm {d}s},</code>
</p>

<p>where <code class="reqn">X</code> is the marker, <code class="reqn">Z</code> is the exposure and <code class="reqn">\alpha(z)</code> is the marker-only hazard, see <code><a href="#topic+get_alpha">get_alpha</a></code> for more details. The future conditional hazard is defined as
</p>
<p style="text-align: center;"><code class="reqn">h_{x,T}(t) = P\left(T_i\in (t+T, t+T+dt)| X_i(T)=x, T_i &gt; t+T\right),</code>
</p>

<p>where <code class="reqn">T_i</code> is the survival time and <code class="reqn">X_i</code> the marker of individual <code class="reqn">i</code> observed in the time frame <code class="reqn">[0,T]</code>.
</p>


<h3>Value</h3>

<p>A single numeric value of <code class="reqn">\hat h_x(t)</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+get_alpha">get_alpha</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>pbc2_id = to_id(pbc2)
size_s_grid &lt;- size_X_grid &lt;- 100
n = max(as.numeric(pbc2$id))
s = pbc2$year
X = pbc2$serBilir
XX = pbc2_id$serBilir
ss &lt;- pbc2_id$years
delta &lt;- pbc2_id$status2
br_s = seq(0, max(s), max(s)/( size_s_grid-1))
br_X = seq(min(X), max(X), (max(X)-min(X))/( size_X_grid-1))

X_lin = lin_interpolate(br_s, pbc2_id$id, pbc2$id, X, s)

int_X &lt;- findInterval(X_lin, br_X)
int_s = rep(1:length(br_s), n)

N &lt;- make_N(pbc2, pbc2_id, breaks_X=br_X, breaks_s=br_s, ss, XX, delta)
Y &lt;- make_Y(pbc2, pbc2_id, X_lin, br_X, br_s, size_s_grid, size_X_grid, int_s, int_X, 'years', n)

b = 1.7
alpha&lt;-get_alpha(N, Y, b, br_X, K=Epan )

Yi &lt;- make_Yi(pbc2, pbc2_id, X_lin, br_X, br_s, size_s_grid, size_X_grid, int_s, int_X,'years', n)

x = 2
t = 2
h_hat = h_xt(br_X, br_s, int_X, size_s_grid, alpha, x, t, b, Yi, n)
</code></pre>

<hr>
<h2 id='h_xt_vec'>Hqm estimator on the marker grid</h2><span id='topic+h_xt_vec'></span>

<h3>Description</h3>

<p>Computes the hqm estimator on the marker grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_xt_vec(br_X, br_s, size_s_grid, alpha, t, b, Yi, int_X, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_xt_vec_+3A_br_x">br_X</code></td>
<td>
<p>Marker value grid points that will be used in the evaluatiuon.</p>
</td></tr>
<tr><td><code id="h_xt_vec_+3A_br_s">br_s</code></td>
<td>
<p>Time value grid points that will be used in the evaluatiuon.</p>
</td></tr>
<tr><td><code id="h_xt_vec_+3A_size_s_grid">size_s_grid</code></td>
<td>
<p>Size of the time grid.</p>
</td></tr>
<tr><td><code id="h_xt_vec_+3A_alpha">alpha</code></td>
<td>
<p>Marker-hazard obtained from <code><a href="#topic+get_alpha">get_alpha</a></code>.</p>
</td></tr>
<tr><td><code id="h_xt_vec_+3A_t">t</code></td>
<td>
<p>Numeric value of the time the function should be evaluated.</p>
</td></tr>
<tr><td><code id="h_xt_vec_+3A_b">b</code></td>
<td>
<p>Bandwidth.</p>
</td></tr>
<tr><td><code id="h_xt_vec_+3A_yi">Yi</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Yi">make_Yi</a></code> indicating the exposure. </p>
</td></tr>
<tr><td><code id="h_xt_vec_+3A_int_x">int_X</code></td>
<td>
<p>Position of the linear interpolated marker values on the marker grid.</p>
</td></tr>
<tr><td><code id="h_xt_vec_+3A_n">n</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the future conditional hazard estimator
</p>
<p style="text-align: center;"><code class="reqn">\hat{h}_x(t) = \frac{\sum_{i=1}^n \int_0^T\hat{\alpha}_i(X_i(t+s))Z_i(t+s)Z_i(s)K_{b}(x-X_i(s))\mathrm {d}s}{\sum_{i=1}^n\int_0^TZ_i(t+s)Z_i(s)K_{b}(x-X_i(s))\mathrm {d}s},</code>
</p>

<p>for every <code class="reqn">x</code> on the marker grid where <code class="reqn">X</code> is the marker, <code class="reqn">Z</code> is the exposure and <code class="reqn">\alpha(z)</code> is the marker-only hazard, see <code><a href="#topic+get_alpha">get_alpha</a></code> for more details.
</p>


<h3>Value</h3>

<p>A vector of <code class="reqn">\hat{h}_{x}(t)</code> for all values <code class="reqn">x</code> on the marker grid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbc2_id = to_id(pbc2)
size_s_grid &lt;- size_X_grid &lt;- 100
n = max(as.numeric(pbc2$id))
s = pbc2$year
X = pbc2$serBilir
XX = pbc2_id$serBilir
ss &lt;- pbc2_id$years
delta &lt;- pbc2_id$status2
br_s = seq(0, max(s), max(s)/( size_s_grid-1))
br_X = seq(min(X), max(X), (max(X)-min(X))/( size_X_grid-1))

X_lin = lin_interpolate(br_s, pbc2_id$id, pbc2$id, X, s)

int_X &lt;- findInterval(X_lin, br_X)
int_s = rep(1:length(br_s), n)

N &lt;- make_N(pbc2, pbc2_id, br_X, br_s, ss, XX, delta)
Y &lt;- make_Y(pbc2, pbc2_id, X_lin, br_X, br_s,
            size_s_grid, size_X_grid, int_s, int_X, event_time = 'years', n)

b = 1.7
alpha&lt;-get_alpha(N, Y, b, br_X, K=Epan )

Yi &lt;- make_Yi(pbc2, pbc2_id, X_lin, br_X, br_s,
              size_s_grid, size_X_grid, int_s, int_X, event_time = 'years', n)

t = 2

h_xt_vec(br_X, br_s, size_s_grid, alpha, t, b, Yi, int_X, n)
</code></pre>

<hr>
<h2 id='Kernels'>Epanechnikov kernel and pdf kernel estimate</h2><span id='topic+Epan'></span><span id='topic+K_b'></span><span id='topic+K_b_mat'></span>

<h3>Description</h3>

<p>Implements the Epanechnikov kernel function and the standard kernel function estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Epan(x)
K_b(b,x,y, K)
K_b_mat(b,x,y, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kernels_+3A_x">x</code></td>
<td>
<p> A vector of design points where the kernel will be evaluated.</p>
</td></tr>
<tr><td><code id="Kernels_+3A_y">y</code></td>
<td>
<p> A vector of sample data points.</p>
</td></tr>
<tr><td><code id="Kernels_+3A_b">b</code></td>
<td>
<p> The bandwidth to use (a scalar).</p>
</td></tr>
<tr><td><code id="Kernels_+3A_k">K</code></td>
<td>
<p> The kernel function to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements the   Epanechnikov kernel function
</p>
<p style="text-align: center;"><code class="reqn"> K(x) = \frac{3}{4}(1-x^2)*(|x|&lt;1)),</code>
</p>

<p>and the classical kernel density estimate
</p>
<p style="text-align: center;"><code class="reqn"> \hat{f}(x) = n^{-1}\sum_{i=1}^n K_h(x-X_i).</code>
</p>



<h3>Value</h3>

<p>In all three cases the functions return the value calculated at <code class="reqn">x</code>.
</p>

<hr>
<h2 id='lin_interpolate'>Linear interpolation</h2><span id='topic+lin_interpolate'></span>

<h3>Description</h3>

<p>Implements a linear interpolation between observered marker values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lin_interpolate(t, i, data_id, data_marker, data_time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lin_interpolate_+3A_t">t</code></td>
<td>
<p>A vector of time values where the function should be evaluated.</p>
</td></tr>
<tr><td><code id="lin_interpolate_+3A_i">i</code></td>
<td>
<p>A vector of ids of individuals for whom the marker values should be interpolated.</p>
</td></tr>
<tr><td><code id="lin_interpolate_+3A_data_id">data_id</code></td>
<td>
<p>The vector of ids from a data frame of time dependent variables.</p>
</td></tr>
<tr><td><code id="lin_interpolate_+3A_data_marker">data_marker</code></td>
<td>
<p>The vector of marker values from a data frame of time dependent variables.</p>
</td></tr>
<tr><td><code id="lin_interpolate_+3A_data_time">data_time</code></td>
<td>
<p>The vector of time values from a data frame of time dependent variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given time points <code class="reqn">t_1,...,t_K</code> and marker values <code class="reqn">m_1,...,m_J</code> at different time points <code class="reqn">t^m_1,...,t^m_J</code>, the function calculates a linear interpolation <code class="reqn">f</code> with <code class="reqn">f(t^m_i) = m_i</code> at the time points <code class="reqn">t_1,...,t_K</code> for all indicated individuals. Returned are then <code class="reqn">(f(t_1),...,f(t_K))</code>. Note that the first value is always observed at time point <code class="reqn">0</code> and the function <code class="reqn">f</code> is extrapolated constantly after the last observed marker value.
</p>


<h3>Value</h3>

<p>A matrix with columns <code class="reqn">(f(t_1),...,f(t_K))</code> as described above for every individual in the vector <code>i</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>size_s_grid &lt;- 100
X = pbc2$serBilir
s = pbc2$year
br_s = seq(0, max(s), max(s)/( size_s_grid-1))
pbc2_id = to_id(pbc2)

X_lin = lin_interpolate(br_s, pbc2_id$id, pbc2$id, X, s)
</code></pre>

<hr>
<h2 id='make_N+2C+20make_Ni+2C+20make_Y+2C+20make_Yi'>Occurance and Exposure on grids</h2><span id='topic+make_N'></span><span id='topic+make_Ni'></span><span id='topic+make_Y'></span><span id='topic+make_Yi'></span>

<h3>Description</h3>

<p>Auxiliary functions that help automate the process of calculating integrals with occurances or exposure processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_N(data, data.id, breaks_X, breaks_s, ss, XX, delta)
make_Ni(breaks_s, size_s_grid, ss, delta, n)
make_Y(data, data.id, X_lin, breaks_X, breaks_s,
        size_s_grid, size_X_grid, int_s, int_X, event_time = 'years', n)
make_Yi(data, data.id, X_lin, breaks_X, breaks_s,
        size_s_grid, size_X_grid, int_s,int_X, event_time = 'years', n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_data">data</code></td>
<td>
<p>A data frame of time dependent data points.  Missing values are allowed.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_data.id">data.id</code></td>
<td>
<p>An id data frame obtained from <code><a href="#topic+to_id">to_id</a></code>.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_breaks_x">breaks_X</code></td>
<td>
<p>Marker value grid points where the function will be evaluated.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_breaks_s">breaks_s</code></td>
<td>
<p>Time value grid points where the function will be evaluated.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_ss">ss</code></td>
<td>
<p>Vector with event times.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_xx">XX</code></td>
<td>
<p>Vector of last observed marker values.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_delta">delta</code></td>
<td>
<p>0-1 vector of whether events happened.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_size_s_grid">size_s_grid</code></td>
<td>
<p>Size of the time grid.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_size_x_grid">size_X_grid</code></td>
<td>
<p>Size of the marker grid.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_n">n</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_x_lin">X_lin</code></td>
<td>
<p>Linear interpolation of observed marker values evaluated on the marker grid.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_int_s">int_s</code></td>
<td>
<p>Position of the observed time values on the time grid.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_int_x">int_X</code></td>
<td>
<p>Position of the linear interpolated marker values on the marker grid.</p>
</td></tr>
<tr><td><code id="make_N+2B2C+2B20make_Ni+2B2C+2B20make_Y+2B2C+2B20make_Yi_+3A_event_time">event_time</code></td>
<td>
<p>String of the column name with the event times.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements matrices for the computation of integrals with occurences and exposures of the form
</p>
<p style="text-align: center;"><code class="reqn">\int f(s)Z(s)Z(s+t)ds, \int f(s) Z(s)ds, \int f(s) dN(s).</code>
</p>

<p>where <code class="reqn">N</code> is a 0-1 counting process, <code class="reqn">Z</code> the exposure and <code class="reqn">f</code> an arbitrary function.
</p>


<h3>Value</h3>

<p>The functions <code><a href="#topic+make_N">make_N</a></code> and <code><a href="#topic+make_Y">make_Y</a></code> return a matrix on the time grid and marker grid for occurence and exposure, respectively, while <code><a href="#topic+make_Ni">make_Ni</a></code> and <code><a href="#topic+make_Yi">make_Yi</a></code> return a matrix on the time grid for evey individual again for occurence and exposure, respectively.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+h_xt">h_xt</a>, <a href="#topic+g_xt">g_xt</a>, <a href="#topic+get_alpha">get_alpha</a> </code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pbc2_id = to_id(pbc2)
size_s_grid &lt;- size_X_grid &lt;- 100
n = max(as.numeric(pbc2$id))
s = pbc2$year
X = pbc2$serBilir
XX = pbc2_id$serBilir
ss &lt;- pbc2_id$years
delta &lt;- pbc2_id$status2
br_s = seq(0, max(s), max(s)/( size_s_grid-1))
br_X = seq(min(X), max(X), (max(X)-min(X))/( size_X_grid-1))

X_lin = lin_interpolate(br_s, pbc2_id$id, pbc2$id, X, s)

int_X &lt;- findInterval(X_lin, br_X)
int_s = rep(1:length(br_s), n)

N &lt;- make_N(pbc2, pbc2_id, br_X, br_s, ss, XX, delta)
Y &lt;- make_Y(pbc2, pbc2_id, X_lin, br_X, br_s,
            size_s_grid, size_X_grid, int_s, int_X, event_time = 'years', n)
Yi &lt;- make_Yi(pbc2, pbc2_id, X_lin, br_X, br_s,
              size_s_grid, size_X_grid, int_s, int_X, event_time = 'years', n)
Ni  &lt;- make_Ni(br_s, size_s_grid, ss, delta, n)

</code></pre>

<hr>
<h2 id='make_sf'>Survival function from a hazard</h2><span id='topic+make_sf'></span>

<h3>Description</h3>

<p>Creates a survival function from a hazard rate which was calculated on a grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_sf(step_size_s_grid, haz)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_sf_+3A_step_size_s_grid">step_size_s_grid</code></td>
<td>
<p>Numeric value indicating the distance between two grid continuous grid points.</p>
</td></tr>
<tr><td><code id="make_sf_+3A_haz">haz</code></td>
<td>
<p>Vector of hazard values. Hazard rate must have been calculated on a time grid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+make_sf">make_sf</a></code> calculates the survival function
</p>
<p style="text-align: center;"><code class="reqn">S(t) = \exp (-\int_0^t h(t) dt),</code>
</p>

<p>where <code class="reqn">h</code> is the hazard rate. Here, a discritisation via an equidistant grid <code class="reqn">\{ t_i \}</code> on <code class="reqn">[0,t]</code> is used to calculate the integral and it is assumed that <code class="reqn">h</code> has been calculated for exactly these time points <code class="reqn"> t_i </code>.
</p>


<h3>Value</h3>

<p>A vector of values <code class="reqn">S(t_i)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_sf(0.1, rep(0.1,10))
</code></pre>

<hr>
<h2 id='pbc2'>Mayo Clinic Primary Biliary Cirrhosis Data</h2><span id='topic+pbc2'></span><span id='topic+pbc2.id'></span>

<h3>Description</h3>

<p>Followup of 312 randomised patients with primary biliary cirrhosis, a rare autoimmune liver disease, at Mayo Clinic.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pbc2 </code></pre>


<h3>Format</h3>

<p>A data frame with 1945 observations on the following 20 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>patients identifier; in total there are 312 patients.</p>
</dd>
<dt><code>years</code></dt><dd><p>number of years between registration and the earlier of death, transplantion, or study
analysis time.</p>
</dd>
<dt><code>status</code></dt><dd><p>a factor with levels <code>alive</code>, <code>transplanted</code> and <code>dead</code>.</p>
</dd>
<dt><code>drug</code></dt><dd><p>a factor with levels <code>placebo</code> and <code>D-penicil</code>.</p>
</dd>
<dt><code>age</code></dt><dd><p>at registration in years.</p>
</dd>
<dt><code>sex</code></dt><dd><p>a factor with levels <code>male</code> and <code>female</code>.</p>
</dd>
<dt><code>year</code></dt><dd><p>number of years between enrollment and this visit date, remaining values on the line of
data refer to this visit.</p>
</dd>
<dt><code>ascites</code></dt><dd><p>a factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
<dt><code>hepatomegaly</code></dt><dd><p>a factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
<dt><code>spiders</code></dt><dd><p>a factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
<dt><code>edema</code></dt><dd><p>a factor with levels <code>No edema</code> (i.e., no edema and no diuretic therapy for edema),
<code>edema no diuretics</code> (i.e., edema present without diuretics, or edema resolved by diuretics), and
<code>edema despite diuretics</code> (i.e., edema despite diuretic therapy).</p>
</dd>
<dt><code>serBilir</code></dt><dd><p>serum bilirubin in mg/dl.</p>
</dd>
<dt><code>serChol</code></dt><dd><p>serum cholesterol in mg/dl.</p>
</dd>
<dt><code>albumin</code></dt><dd><p>albumin in gm/dl.</p>
</dd>
<dt><code>alkaline</code></dt><dd><p>alkaline phosphatase in U/liter.</p>
</dd>
<dt><code>SGOT</code></dt><dd><p>SGOT in U/ml.</p>
</dd>
<dt><code>platelets</code></dt><dd><p>platelets per cubic ml / 1000.</p>
</dd>
<dt><code>prothrombin</code></dt><dd><p>prothrombin time in seconds.</p>
</dd>
<dt><code>histologic</code></dt><dd><p>histologic stage of disease.</p>
</dd>
<dt><code>status2</code></dt><dd><p>a numeric vector with the value 1 denoting if the patient was dead,
and 0 if the patient was alive or transplanted.</p>
</dd>
</dl>



<h3>References</h3>

<p>Fleming, T. and Harrington, D. (1991) <em>Counting Processes and Survival Analysis</em>. Wiley, New York.
</p>
<p>Therneau, T. and Grambsch, P. (2000) <em>Modeling Survival Data: Extending the Cox Model</em>. Springer-Verlag, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  summary(pbc2)
  </code></pre>

<hr>
<h2 id='prep_boot'>Precomputation for wild bootstrap</h2><span id='topic+prep_boot'></span>

<h3>Description</h3>

<p>Implements key components for the wild bootstrap of the hqm estimator in preparation for obtaining confidence bands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_boot(g_xt, alpha, Ni, Yi, size_s_grid, br_X, br_s, t, b, int_X, x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_boot_+3A_g_xt">g_xt</code></td>
<td>
<p>A vector obtained by <code><a href="#topic+g_xt">g_xt</a></code>.</p>
</td></tr>
<tr><td><code id="prep_boot_+3A_alpha">alpha</code></td>
<td>
<p>A vector of the marker only hazard on the marker grid obtained by <code><a href="#topic+get_alpha">get_alpha</a></code>.</p>
</td></tr>
<tr><td><code id="prep_boot_+3A_ni">Ni</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Ni">make_Ni</a></code> indicating the occurence.</p>
</td></tr>
<tr><td><code id="prep_boot_+3A_yi">Yi</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Yi">make_Yi</a></code> indicating the exposure. </p>
</td></tr>
<tr><td><code id="prep_boot_+3A_size_s_grid">size_s_grid</code></td>
<td>
<p>Size of the time grid.</p>
</td></tr>
<tr><td><code id="prep_boot_+3A_br_x">br_X</code></td>
<td>
<p>Vector of grid points for the marker values.</p>
</td></tr>
<tr><td><code id="prep_boot_+3A_br_s">br_s</code></td>
<td>
<p>Time value grid points that will be used in the evaluatiuon.</p>
</td></tr>
<tr><td><code id="prep_boot_+3A_t">t</code></td>
<td>
<p>Numeric value of the time the function should be evaluated.</p>
</td></tr>
<tr><td><code id="prep_boot_+3A_b">b</code></td>
<td>
<p>Bandwidth.</p>
</td></tr>
<tr><td><code id="prep_boot_+3A_int_x">int_X</code></td>
<td>
<p>Position of the linear interpolated marker values on the marker grid.</p>
</td></tr>
<tr><td><code id="prep_boot_+3A_x">x</code></td>
<td>
<p>Numeric value of the last observed marker value.</p>
</td></tr>
<tr><td><code id="prep_boot_+3A_n">n</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements
</p>
<p style="text-align: center;"><code class="reqn">A_B(t)  =  \frac{1}{\sqrt{n}} \sum_{i=1}^n \int^{T}_0 \hat{g}_{i,t,x_*}(X_i(s))  V_i\{dN_i(s) - \hat{\alpha}_i(X_i(s))Z_i(s)ds\},</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">
B_B(t)  = \frac{1}{\sqrt{n}}\sum_{i = 1}^n V_i\{\hat{\Gamma}(t,x_*)^{-1}W_i(t,x_*) - \hat{h}_{x_*}(t)\},</code>
</p>

<p>where <code class="reqn">V \sim N(0,1)</code>,
</p>
<p style="text-align: center;"><code class="reqn">W_i(t) =\int_0^T\hat{\alpha}_i(X_i(t+s))Z_i(t+s)Z_i(s)K_b(x_*,X_i(s))\mathrm {d}s,</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\hat{\Gamma}(t,x)  = \frac{1}{n}  \sum_{i = 1}^n \int_{0}^{T-t} Z_i(t+s)Z_i(s) K_b(x,X_i(s))ds,</code>
</p>

<p>with <code class="reqn">Z</code> being the exposure and <code class="reqn">X</code> the marker.
</p>


<h3>Value</h3>

<p>A list of 5 items. The first two are vectors for calculating <code class="reqn">A_B</code> and the third one a vector for <code class="reqn">B_B</code>. The 4th one is the value of the hqm estimator that can also be obtained by <code><a href="#topic+h_xt">h_xt</a></code> and the last one is the value of <code class="reqn">\Gamma</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+Conf_bands">Conf_bands</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>pbc2_id = to_id(pbc2)
size_s_grid &lt;- size_X_grid &lt;- 100
n = max(as.numeric(pbc2$id))
s = pbc2$year
X = pbc2$serBilir
XX = pbc2_id$serBilir
ss &lt;- pbc2_id$years
delta &lt;- pbc2_id$status2
br_s = seq(0, max(s), max(s)/( size_s_grid-1))
br_X = seq(min(X), max(X), (max(X)-min(X))/( size_X_grid-1))

X_lin = lin_interpolate(br_s, pbc2_id$id, pbc2$id, X, s)

int_X &lt;- findInterval(X_lin, br_X)
int_s = rep(1:length(br_s), n)

N &lt;- make_N(pbc2, pbc2_id, br_X, br_s, ss, XX, delta)
Y &lt;- make_Y(pbc2, pbc2_id, X_lin, br_X, br_s,
            size_s_grid, size_X_grid, int_s, int_X, event_time = 'years', n)

b = 1.7
alpha&lt;-get_alpha(N, Y, b, br_X, K=Epan )

Yi &lt;- make_Yi(pbc2, pbc2_id, X_lin, br_X, br_s,
              size_s_grid, size_X_grid, int_s, int_X, event_time = 'years', n)
Ni  &lt;- make_Ni(br_s, size_s_grid, ss, delta, n)

t = 2
x = 2

g = g_xt(br_X, br_s, size_s_grid, int_X, x, t, b, Yi, Y, n)

Boot_all = prep_boot(g, alpha, Ni, Yi, size_s_grid, br_X, br_s, t, b, int_X, x, n)
Boot_all
</code></pre>

<hr>
<h2 id='prep_cv'>Prepare for Cross validation bandwidth selection</h2><span id='topic+prep_cv'></span>

<h3>Description</h3>

<p>Implements the calculation of the hqm estimator on cross validation data sets. This is a preparation for the cross validation bandwidth selection technique for future conditional hazard rate estimation based on marker information data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_cv(data, data.id, marker_name, event_time_name = 'years',
        time_name = 'year',event_name = 'status2', n, I, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_cv_+3A_data">data</code></td>
<td>
<p>A data frame of time dependent data points.  Missing values are allowed.</p>
</td></tr>
<tr><td><code id="prep_cv_+3A_data.id">data.id</code></td>
<td>
<p>An id data frame obtained from <code><a href="#topic+to_id">to_id</a></code>.</p>
</td></tr>
<tr><td><code id="prep_cv_+3A_marker_name">marker_name</code></td>
<td>
<p>The column name of the marker values in the data frame <code><a href="utils.html#topic+data">data</a></code>. </p>
</td></tr>
<tr><td><code id="prep_cv_+3A_event_time_name">event_time_name</code></td>
<td>
<p>The column name of the event times in the data frame <code><a href="utils.html#topic+data">data</a></code>. </p>
</td></tr>
<tr><td><code id="prep_cv_+3A_time_name">time_name</code></td>
<td>
<p>The column name of the times the marker values were observed in the data frame <code><a href="utils.html#topic+data">data</a></code>.</p>
</td></tr>
<tr><td><code id="prep_cv_+3A_event_name">event_name</code></td>
<td>
<p>The column name of the events in the data frame <code><a href="utils.html#topic+data">data</a></code>.</p>
</td></tr>
<tr><td><code id="prep_cv_+3A_n">n</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
<tr><td><code id="prep_cv_+3A_i">I</code></td>
<td>
<p>Number of observations leave out for a K cross validation.</p>
</td></tr>
<tr><td><code id="prep_cv_+3A_b">b</code></td>
<td>
<p>Bandwidth.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function splits the data set via <code><a href="#topic+dataset_split">dataset_split</a></code> and calculates for every splitted data set the hqm estimator
</p>
<p style="text-align: center;"><code class="reqn">\hat{h}_x(t) = \frac{\sum_{i=1}^n \int_0^T\hat{\alpha}_i(X_i(t+s))Z_i(t+s)Z_i(s)K_{b}(x-X_i(s))\mathrm {d}s}{\sum_{i=1}^n\int_0^TZ_i(t+s)Z_i(s)K_{b}(x-X_i(s))\mathrm {d}s},</code>
</p>

<p>for all <code class="reqn">x</code> on the marker grid and <code class="reqn">t</code> on the time grid, where <code class="reqn">X</code> is the marker, <code class="reqn">Z</code> is the exposure and <code class="reqn">\alpha(z)</code> is the marker-only hazard, see <code><a href="#topic+get_alpha">get_alpha</a></code> for more details.
</p>


<h3>Value</h3>

<p>A list of matrices for every cross validation data set with <code class="reqn">\hat{h}_x(t)</code> for all <code class="reqn">x</code> on the marker grid and <code class="reqn">t</code> on the time grid.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+b_selection">b_selection</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
pbc2_id = to_id(pbc2)
n = max(as.numeric(pbc2$id))
b = 1.5
I = 26
h_xt_mat_list = prep_cv(pbc2, pbc2_id, 'serBilir', 'years', 'year', 'status2', n, I, b)
</code></pre>

<hr>
<h2 id='Q1'>Bandwidth selection score Q1</h2><span id='topic+Q1'></span>

<h3>Description</h3>

<p>Calculates a part for the K-fold cross validation score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q1(h_xt_mat, int_X, size_X_grid, n, Yi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Q1_+3A_h_xt_mat">h_xt_mat</code></td>
<td>
<p>A matrix of the estimator for the future conditional hazard rate for all values <code>x</code> and <code>t</code>.</p>
</td></tr>
<tr><td><code id="Q1_+3A_int_x">int_X</code></td>
<td>
<p>Vector of the position of the observed marker values in the grid for marker values.</p>
</td></tr>
<tr><td><code id="Q1_+3A_size_x_grid">size_X_grid</code></td>
<td>
<p>Numeric value indicating the number of grid points for marker values.</p>
</td></tr>
<tr><td><code id="Q1_+3A_n">n</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
<tr><td><code id="Q1_+3A_yi">Yi</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Yi">make_Yi</a></code> indicating the exposure. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements
</p>
<p style="text-align: center;"><code class="reqn">Q_1 =  \sum_{i = 1}^N \int_0^T \int_s^T Z_i(t)Z_i(s)\hat{h}_{X_i(s)}^2(t-s) dt ds,</code>
</p>

<p>where <code class="reqn">\hat{h}</code> is the hqm estimator, <code class="reqn">Z</code> the exposure and <code class="reqn">X</code> the marker.
</p>


<h3>Value</h3>

<p>A value of the score Q1.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+b_selection">b_selection</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>pbc2_id = to_id(pbc2)
size_s_grid &lt;- size_X_grid &lt;- 100
n = max(as.numeric(pbc2$id))
s = pbc2$year
X = pbc2$serBilir
XX = pbc2_id$serBilir
ss &lt;- pbc2_id$years
delta &lt;- pbc2_id$status2
br_s = seq(0, max(s), max(s)/( size_s_grid-1))
br_X = seq(min(X), max(X), (max(X)-min(X))/( size_X_grid-1))

X_lin = lin_interpolate(br_s, pbc2_id$id, pbc2$id, X, s)

int_X &lt;- findInterval(X_lin, br_X)
int_s = rep(1:length(br_s), n)

N &lt;- make_N(pbc2, pbc2_id, br_X, br_s, ss, XX, delta)
Y &lt;- make_Y(pbc2, pbc2_id, X_lin, br_X, br_s,
            size_s_grid, size_X_grid, int_s, int_X, event_time = 'years', n)

b = 1.7
alpha&lt;-get_alpha(N, Y, b, br_X, K=Epan )

Yi &lt;- make_Yi(pbc2, pbc2_id, X_lin, br_X, br_s,
              size_s_grid, size_X_grid, int_s, int_X, event_time = 'years', n)
Ni  &lt;- make_Ni(br_s, size_s_grid, ss, delta, n)

t = 2

h_xt_mat = t(sapply(br_s[1:99],
            function(si){h_xt_vec(br_X, br_s, size_s_grid, alpha, t, b, Yi, int_X, n)}))

Q = Q1(h_xt_mat, int_X, size_X_grid, n, Yi)
</code></pre>

<hr>
<h2 id='R_K'>Bandwidth selection score R</h2><span id='topic+R_K'></span>

<h3>Description</h3>

<p>Calculates a part for the K-fold cross validation score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R_K(h_xt_mat_list, int_X, size_X_grid, Yi, Ni, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R_K_+3A_h_xt_mat_list">h_xt_mat_list</code></td>
<td>
<p>A list of matrices for all cross validation data sets. Each matrix contains the estimator with the future conditional hazard rate for all values <code>x</code> and <code>t</code> and the respected data set.</p>
</td></tr>
<tr><td><code id="R_K_+3A_int_x">int_X</code></td>
<td>
<p>Vector of the position of the observed marker values in the grid for marker values.</p>
</td></tr>
<tr><td><code id="R_K_+3A_size_x_grid">size_X_grid</code></td>
<td>
<p>Numeric value indicating the number of grid points for marker values.</p>
</td></tr>
<tr><td><code id="R_K_+3A_yi">Yi</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Yi">make_Yi</a></code> indicating the exposure. </p>
</td></tr>
<tr><td><code id="R_K_+3A_ni">Ni</code></td>
<td>
<p>A matrix made by <code><a href="#topic+make_Ni">make_Ni</a></code> indicating the occurence. </p>
</td></tr>
<tr><td><code id="R_K_+3A_n">n</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the estimator
</p>
<p style="text-align: center;"><code class="reqn">\hat{R}_K =  \sum_{j = 1}^K\sum_{i \in I_j} \int_0^T  g^{-I_j}_i(t)  dN_i(t),</code>
</p>

<p>where <code class="reqn">\hat{g}^{-I_j}_i(t) = \int_0^t Z_i(s) \hat{h}^{-I_j}_{X_i(s)}(t-s) ds,</code> and <code class="reqn">\hat{h}^{-I_j}</code> is estimated without information from all counting processes <code class="reqn">i</code> with <code class="reqn">i \in I_j</code>.
This function estimates
</p>
<p style="text-align: center;"><code class="reqn">R =  \sum_{i = 1}^N \int_0^T \int_s^T Z_i(t)Z_i(s)\hat{h}_{X_i(s)}(t-s) h_{X_i(s)}(t-s) dt ds .</code>
</p>

<p>where <code class="reqn">\hat{h}</code> is the hqm estimator, <code class="reqn">Z</code> the exposure and <code class="reqn">X</code> the marker.
</p>


<h3>Value</h3>

<p>A matrix with <code class="reqn">\hat{g}^{-I_j}_i(t)</code> for all individuals <code>i</code> and time grid points <code>t</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+b_selection">b_selection</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>pbc2_id = to_id(pbc2)
n = max(as.numeric(pbc2$id))
b = 1.5
I = 104
h_xt_mat_list = prep_cv(pbc2, pbc2_id, 'serBilir', 'years', 'year', 'status2', n, I, b)


size_s_grid &lt;- size_X_grid &lt;- 100
s = pbc2$year
X = pbc2$serBilir
br_s = seq(0, max(s), max(s)/( size_s_grid-1))
br_X = seq(min(X), max(X), (max(X)-min(X))/( size_X_grid-1))

ss &lt;- pbc2_id$years
delta &lt;- pbc2_id$status2

X_lin = lin_interpolate(br_s, pbc2_id$id, pbc2$id, X, s)
int_X &lt;- findInterval(X_lin, br_X)
int_s = rep(1:length(br_s), n)

Yi &lt;- make_Yi(pbc2, pbc2_id, X_lin, br_X, br_s,
              size_s_grid, size_X_grid, int_s, int_X, 'years', n)
Ni  &lt;- make_Ni(br_s, size_s_grid, ss, delta, n)

R = R_K(h_xt_mat_list, int_X, size_X_grid, Yi, Ni, n)
R
</code></pre>

<hr>
<h2 id='to_id'>Event data frame</h2><span id='topic+to_id'></span>

<h3>Description</h3>

<p>Creates a data frame with only one entry per individual from a data frame with time dependent data. The resulting data frame focusses on the event time and the last observed marker value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_id(data_set)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_id_+3A_data_set">data_set</code></td>
<td>
<p>A data frame of time dependent data points.  Missing values are allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+to_id">to_id</a></code> uses a data frame of time dependent marker data to create a smaller data frame with only one entry per individual, the last observed marker value and the event time. Note that the column indicating the individuals must have the name <code>id</code>. Note also that this data frame is similar to <code>pbc2.id</code> from the <code>JM</code> package with the difference that the last observed marker value instead of the first one is captured.
</p>


<h3>Value</h3>

<p>A data frame with only one entry per individual.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_set.id = to_id(pbc2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
