<!DOCTYPE html><html lang="en"><head><title>Help for package ggvfields</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggvfields}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ggvfields'><p>ggvfields: Vector Field Visualizations with ggplot2</p></a></li>
<li><a href='#efield'><p>Electric field</p></a></li>
<li><a href='#geom_gradient_field'><p>Create a Gradient Field Layer in ggplot2</p></a></li>
<li><a href='#geom_gradient_smooth'><p>Create a Gradient Smoothed Field Layer</p></a></li>
<li><a href='#geom_potential'><p>Compute and Plot Potential Function from a Conservative Vector Field</p></a></li>
<li><a href='#geom_stream'><p>Create a Streamline Plot Layer in ggplot2</p></a></li>
<li><a href='#geom_stream_field'><p>Create a Stream Field Layer in ggplot2</p></a></li>
<li><a href='#geom_stream_smooth'><p>Create a Smoothed Vector Field Layer</p></a></li>
<li><a href='#geom_vector'><p>Vector Layers for ggplot2</p></a></li>
<li><a href='#geom_vector_field'><p>Vector Field Layers for ggplot2</p></a></li>
<li><a href='#geom_vector_smooth'><p>Create a Smooth Vector Plot Layer</p></a></li>
<li><a href='#grid_hex'><p>Generate a Hexagonal Lattice</p></a></li>
<li><a href='#scale_length_continuous'><p>Create a Continuous Scale for Vector Length</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Vector Field Visualizations with 'ggplot2'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dusty Turner &lt;dusty.s.turner@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A 'ggplot2' extension for visualizing vector fields in two-dimensional 
           space. Provides flexible tools for creating vector and stream field layers, 
           visualizing gradients and potential fields, and smoothing vector and 
           scalar data to estimate underlying patterns. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0), ggplot2 (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>farver, tibble, numDeriv, deSolve, grid, utils, scales, cli</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dusty-turner/ggvfields">https://github.com/dusty-turner/ggvfields</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dusty-turner/ggvfields/issues">https://github.com/dusty-turner/ggvfields/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggdensity, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-08</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-13 15:33:55 UTC; Dusty_Turner1</td>
</tr>
<tr>
<td>Author:</td>
<td>Dusty Turner [aut, cre],
  David Kahle [aut],
  Rodney X. Sturdivant [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-15 17:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='ggvfields'>ggvfields: Vector Field Visualizations with ggplot2</h2><span id='topic+ggvfields'></span><span id='topic+ggvfields-package'></span>

<h3>Description</h3>

<p>A ggplot2 extension for visualizing vector fields in a two-dimensional space.
Provides functions to create vector field layers using user-defined vector
field functions.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://jamesotto852.github.io/ggdensity/">https://jamesotto852.github.io/ggdensity/</a>
</p>
</li>
<li> <p><a href="https://github.com/dusty-turner/ggvfields/">https://github.com/dusty-turner/ggvfields/</a>
</p>
</li></ul>


<hr>
<h2 id='efield'>Electric field</h2><span id='topic+efield'></span><span id='topic+efield_maker'></span>

<h3>Description</h3>

<p>The vector field generated by collection of fixed electrical charges, as
dictated by Coulomb's law. This function is mainly used to provide examples
for visualizing vector fields with ggvfields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efield(u, charge_positions, charges, k = 1, q_test = +1)

efield_maker(
  charge_positions = rbind(c(-1, -1), c(1, 1)),
  charges = c(-1, +1),
  k = 1,
  q_test = +1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="efield_+3A_u">u</code></td>
<td>
<p>The position of the test charge.</p>
</td></tr>
<tr><td><code id="efield_+3A_charge_positions">charge_positions</code></td>
<td>
<p>The positions of the fixed charges generating the
electric field. Defaulted in <code><a href="#topic+efield_maker">efield_maker()</a></code>.</p>
</td></tr>
<tr><td><code id="efield_+3A_charges">charges</code></td>
<td>
<p>The charges of the points placed at the positions of
charge_positions. Defaulted in <code><a href="#topic+efield_maker">efield_maker()</a></code>.</p>
</td></tr>
<tr><td><code id="efield_+3A_k">k</code></td>
<td>
<p>The constant of proportionality, defaulted to 1. See examples for a
more rigorous use of physical constants.</p>
</td></tr>
<tr><td><code id="efield_+3A_q_test">q_test</code></td>
<td>
<p>The test charge, defaulted to +1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the force felt by the test charge on account of
the electric field.
</p>


<h3>See Also</h3>

<p><a href="https://en.wikipedia.org/wiki/Coulomb%27s_law">https://en.wikipedia.org/wiki/Coulomb%27s_law</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# set a - charge at (-1,-1) and a + charge at (1,1)
charge_positions &lt;- rbind(c(-1,-1), c(1,1))
charges &lt;- c(-1, +1)


# calculate force on test charge (+1) at c(0,1), ignoring physical constants
efield(c(0,1), charge_positions, charges)


# efield_maker() simply wraps this function, defaulting to those charges
f &lt;- efield_maker()
f(c(0,1))

ggplot() +
  geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2)) +
  scale_color_viridis_c(trans = "log10")

# electric constant from https://en.wikipedia.org/wiki/Vacuum_permittivity
ep0 &lt;- 8.854187818814e-12
k &lt;- (4*pi*ep0)^-1
efield(c(0,1), charge_positions, charges, k)

</code></pre>

<hr>
<h2 id='geom_gradient_field'>Create a Gradient Field Layer in ggplot2</h2><span id='topic+geom_gradient_field'></span><span id='topic+stat_gradient_field'></span><span id='topic+geom_gradient_field2'></span><span id='topic+stat_gradient_field2'></span>

<h3>Description</h3>

<p>These functions provide convenient ggplot2 layers for drawing gradient fields
by computing the gradient of a scalar field. A user-defined function (<code>fun</code>)
specifies the behavior of the scalar field by taking a numeric vector of
length 2 (representing <code class="reqn">(x, y)</code>) and returning a single numeric value.
The underlying <a href="#topic+StatStreamField">StatStreamField</a> computes the gradient via numerical
differentiation (using <code>numDeriv::grad()</code>) and <a href="#topic+GeomStream">GeomStream</a> renders the
resulting vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_gradient_field(
  mapping = NULL,
  data = NULL,
  stat = StatStreamField,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = TRUE,
  inherit.aes = TRUE,
  fun,
  xlim = NULL,
  ylim = NULL,
  n = 11,
  max_it = 1000,
  T = NULL,
  L = NULL,
  center = TRUE,
  type = "vector",
  normalize = TRUE,
  tail_point = FALSE,
  eval_point = FALSE,
  grid = NULL,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  arrow = grid::arrow(angle = 30, length = grid::unit(0.02, "npc"), type = "closed")
)

stat_gradient_field(
  mapping = NULL,
  data = NULL,
  geom = GeomStream,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = TRUE,
  inherit.aes = TRUE,
  fun,
  xlim = NULL,
  ylim = NULL,
  n = 11,
  max_it = 1000,
  T = NULL,
  L = NULL,
  center = TRUE,
  type = "vector",
  normalize = TRUE,
  tail_point = FALSE,
  eval_point = FALSE,
  grid = NULL,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  arrow = grid::arrow(angle = 30, length = grid::unit(0.02, "npc"), type = "closed")
)

geom_gradient_field2(
  mapping = NULL,
  data = NULL,
  stat = StatStreamField,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = TRUE,
  inherit.aes = TRUE,
  fun,
  xlim = NULL,
  ylim = NULL,
  n = 11,
  max_it = 1000,
  T = NULL,
  L = NULL,
  center = FALSE,
  type = "stream",
  normalize = TRUE,
  tail_point = TRUE,
  eval_point = FALSE,
  grid = NULL,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  arrow = NULL
)

stat_gradient_field2(
  mapping = NULL,
  data = NULL,
  geom = GeomStream,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = TRUE,
  inherit.aes = TRUE,
  fun,
  xlim = NULL,
  ylim = NULL,
  n = 11,
  max_it = 1000,
  T = NULL,
  L = NULL,
  center = FALSE,
  type = "stream",
  normalize = TRUE,
  tail_point = TRUE,
  eval_point = FALSE,
  grid = NULL,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  arrow = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_gradient_field_+3A_mapping">mapping</code></td>
<td>
<p>A set of aesthetic mappings created by <code>ggplot2::aes()</code>.
Additional aesthetics such as <code>color</code>, <code>size</code>, <code>linetype</code>, and <code>alpha</code> can
be defined. In
<strong>geom_gradient_field</strong> the default mapping includes <code>color = after_stat(norm)</code>,
whereas in <strong>geom_gradient_field2</strong> the default mapping includes <code>length = after_stat(norm)</code>.</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_data">data</code></td>
<td>
<p>A data frame containing the input data.</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
Defaults to <a href="#topic+StatStreamField">StatStreamField</a>.</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string or the result of a
position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code>grid::layer()</code>.</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. If <code>FALSE</code> (the default), missing values are removed
with a warning.</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical. Should this layer be included in the legends?</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>Logical. If <code>FALSE</code>, overrides the default aesthetics
rather than combining with them.</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_fun">fun</code></td>
<td>
<p>A function that defines the scalar field. It should take a numeric
vector of length 2 (representing <code class="reqn">(x, y)</code>) and return a single numeric
value. <strong>(Required)</strong></p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_xlim">xlim</code></td>
<td>
<p>Numeric vector of length two. Specifies the limits of the x-axis
domain. Defaults to <code>c(-1, 1)</code>.</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vector of length two. Specifies the limits of the y-axis
domain. Defaults to <code>c(-1, 1)</code>.</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_n">n</code></td>
<td>
<p>Integer. Grid resolution specifying the number of seed points along
each axis. Higher values produce a denser gradient field. Defaults to <code>11</code>.</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_max_it">max_it</code></td>
<td>
<p>Integer. Maximum number of integration steps allowed when
computing the gradient stream. Defaults to <code>1000</code>.</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_t">T</code></td>
<td>
<p>Numeric. Time increment used for numerical integration when
<code>normalize</code> is FALSE. If not provided, it is computed automatically based
on grid spacing and the vector field’s magnitude.</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_l">L</code></td>
<td>
<p>Numeric. Target length for the gradient vectors or streamlines. When
<code>normalize</code> is TRUE, computed vectors are scaled to have length L. If not
provided, L is computed automatically from the grid spacing.</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_center">center</code></td>
<td>
<p>Logical. If <code>TRUE</code>, centers the seed points so that the
original (x, y) becomes the midpoint.</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_type">type</code></td>
<td>
<p>Character. Specifies the type of field to compute: use <code>"stream"</code>
to generate integrated streamlines or <code>"vector"</code> for individual vector
segments. Defaults to <code>"stream"</code>.</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If <code>TRUE</code>, gradient vectors are normalized based on
grid spacing. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_tail_point">tail_point</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a point is drawn at the tail of each
gradient vector.</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_eval_point">eval_point</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a point is drawn at the evaluation
point where the gradient was computed. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_grid">grid</code></td>
<td>
<p>A data frame containing precomputed grid points for seed
placement. If <code>NULL</code> (default), a regular Cartesian grid is generated based
on <code>xlim</code>, <code>ylim</code>, and <code>n</code>.</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_arrow">arrow</code></td>
<td>
<p>A <code>grid::arrow()</code> specification to add arrowheads to the
gradient vectors. In <strong>geom_gradient_field</strong>, the default is a closed arrow
with a 30° angle and length <code>0.02</code> npc; in <code>geom_gradient_field2()</code>, the
default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="geom_gradient_field_+3A_geom">geom</code></td>
<td>
<p>The geometric object used to render the streamline (only used in
<code>stat_stream()</code>; defaults to <a href="#topic+GeomStream">GeomStream</a>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two variants are provided:
</p>

<ul>
<li> <p><strong>geom_gradient_field()</strong> uses a default mapping that sets <code>color = after_stat(norm)</code>.
</p>
</li>
<li> <p><strong>geom_gradient_field2()</strong> uses a default mapping that sets <code>length = after_stat(norm)</code>
(with <code>color</code> unmapped by default).
</p>
</li></ul>



<h3>Value</h3>

<p>A ggplot2 layer that computes and plots a gradient field by
numerically differentiating a scalar field.
</p>


<h3>Aesthetics</h3>

<p><code>geom_gradient_field()</code> and <code>geom_gradient_field2()</code>
understand the following aesthetics (required aesthetics are in <strong>bold</strong>):
</p>

<ul>
<li> <p><strong><code>x</code></strong>: The x-coordinate of the seed point.
</p>
</li>
<li> <p><strong><code>y</code></strong>: The y-coordinate of the seed point.
</p>
</li>
<li> <p><strong><code>color</code></strong>: In <strong>geom_gradient_field</strong>, the color of the gradient vector.
In <strong>geom_gradient_field2</strong>, color is not mapped by default.
</p>
</li>
<li> <p><strong><code>length</code></strong>: In <strong>geom_gradient_field2</strong>, the computed vector norm.
</p>
</li>
<li> <p><code>size</code>, <code>linetype</code>, <code>alpha</code>: Additional aesthetics to control appearance.
</p>
</li></ul>



<h3>Computed Variables</h3>

<p>The following variables are computed internally by <a href="#topic+StatStreamField">StatStreamField</a> when
generating the gradient field from a scalar function:
</p>

<dl>
<dt>norm</dt><dd><p>The Euclidean norm of the gradient vector, calculated as
<code class="reqn">\sqrt{fx^2 + fy^2}</code>. This value is used, by default, for mapping color or scaling
arrow lengths in the visualization.</p>
</dd>
<dt>avg_spd</dt><dd><p>This variable may represent an average speed computed
from the gradient magnitude. In the default mapping for <strong>geom_gradient_field</strong>, the
color aesthetic is mapped to <code>after_stat(avg_spd)</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>Si &lt;- matrix(c(1, 0.75, 0.75, 1), nrow = 2)
f &lt;- function(u) exp(-as.numeric(u %*% solve(Si) %*% u) / 2) / (2 * pi * det(Si))

ggplot() +
  geom_gradient_field(fun = f, xlim = c(-3, 3), ylim = c(-3, 3))


df &lt;- expand.grid(x = seq(-3, 3, 0.1), y = seq(-3, 3, 0.1)) |&gt;
  transform(fxy = apply(cbind(x, y), 1, f))

ggplot() +
  geom_raster(aes(x, y, fill = fxy), data = df) +
  geom_gradient_field(fun = f, xlim = c(-3, 3), ylim = c(-3, 3)) +
  coord_equal()

fxy &lt;- function(x, y) apply(cbind(x,y), 1, f)

ggplot() +
  ggdensity::geom_hdr_fun(fun = fxy, xlim = c(-3,3), ylim = c(-3,3)) +
  geom_gradient_field(fun = f, xlim = c(-3,3), ylim = c(-3,3)) +
  coord_equal()

  library("ggdensity")
  fxy &lt;- function(x, y) apply(cbind(x, y), 1, f)
  fxy(1, 2)
  f(1:2)

  ggplot() +
    geom_hdr_fun(fun = fxy, xlim = c(-3, 3), ylim = c(-3, 3)) +
    geom_gradient_field(fun = f, xlim = c(-3, 3), ylim = c(-3, 3)) +
    coord_equal()

</code></pre>

<hr>
<h2 id='geom_gradient_smooth'>Create a Gradient Smoothed Field Layer</h2><span id='topic+geom_gradient_smooth'></span><span id='topic+stat_gradient_smooth'></span>

<h3>Description</h3>

<p><code>geom_gradient_smooth()</code> creates a ggplot2 layer that visualizes the gradient
of a scalar field computed from raw data. A linear model is fitted using the
supplied <code>formula</code> (default: <code>z ~ x + y + I(x^2) + I(y^2)</code>) on the raw data,
and the numerical gradient is computed using numDeriv::grad(). The computed
gradient field is then visualized using <code><a href="#topic+GeomStream">GeomStream()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_gradient_smooth(
  mapping = NULL,
  data = NULL,
  stat = StatStreamField,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = TRUE,
  inherit.aes = TRUE,
  formula = z ~ x + y + I(x^2) + I(y^2),
  xlim = NULL,
  ylim = NULL,
  n = 11,
  max_it = 1000,
  T = NULL,
  L = NULL,
  center = TRUE,
  type = "vector",
  normalize = TRUE,
  tail_point = FALSE,
  eval_point = FALSE,
  grid = NULL,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  arrow = grid::arrow(angle = 30, length = grid::unit(0.02, "npc"), type = "closed")
)

stat_gradient_smooth(
  mapping = NULL,
  data = NULL,
  geom = GeomStream,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = TRUE,
  inherit.aes = TRUE,
  formula = z ~ x + y + I(x^2) + I(y^2),
  xlim = NULL,
  ylim = NULL,
  n = 11,
  max_it = 1000,
  T = NULL,
  L = NULL,
  center = TRUE,
  type = "vector",
  normalize = TRUE,
  tail_point = FALSE,
  eval_point = FALSE,
  grid = NULL,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  arrow = grid::arrow(angle = 30, length = grid::unit(0.02, "npc"), type = "closed")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_gradient_smooth_+3A_mapping">mapping</code></td>
<td>
<p>A set of aesthetic mappings created by <code>ggplot2::aes()</code>.
<strong>Required:</strong> Must include <strong><code>x</code></strong> and <strong><code>y</code></strong>; vector displacements are defined
by <strong><code>fx</code></strong> and <strong><code>fy</code></strong>.</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_data">data</code></td>
<td>
<p>A data frame containing the raw vector data.</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data. Defaults to
<code>"vector_smooth"</code>.</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string or the result of a
position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the layer.</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. If <code>FALSE</code> (the default), missing values are removed
with a warning.</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical. Should this layer be included in the legends?</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>Logical. If <code>FALSE</code>, overrides the default aesthetics
rather than combining with them.</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the linear model for the scalar field.
Defaults to <code>z ~ x + y + I(x^2) + I(y^2)</code>.</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_xlim">xlim</code></td>
<td>
<p>Numeric vector of length 2 specifying the domain limits in the
<code class="reqn">x</code>-direction. Defaults to <code class="reqn">c(-1, 1)</code>.</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vector of length 2 specifying the domain limits in the
<code class="reqn">y</code>-direction. Defaults to <code class="reqn">c(-1, 1)</code>.</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_n">n</code></td>
<td>
<p>An integer vector specifying the grid resolution for smoothing.</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_max_it">max_it</code></td>
<td>
<p>Maximum number of iterations for field integration (when used in streamlines).</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_t">T</code></td>
<td>
<p>If <code>normalize = FALSE</code>, this controls the time length for growing streams.</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_l">L</code></td>
<td>
<p>If <code>normalize = TRUE</code>, this controls the fixed length of streams or vectors.</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_center">center</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the vector is recentered so that the
original <code style="white-space: pre;">&#8288;(x, y)&#8288;</code> becomes the midpoint (default is <code>TRUE</code> for
<code>geom_vector()</code> and <code>FALSE</code> for <code>geom_vector2()</code>).</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_type">type</code></td>
<td>
<p>Character. Either <code>"stream"</code> (default) or <code>"vector"</code>. <code>"stream"</code>
computes a full streamline by integrating in both directions (if <code>center = TRUE</code>), while <code>"vector"</code> computes a single vector.</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the vector endpoints are scaled to unit
length before being scaled by <code>L</code> (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_tail_point">tail_point</code></td>
<td>
<p>Logical. If <code>TRUE</code>, draws the tail point of vectors/streams (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_eval_point">eval_point</code></td>
<td>
<p>Logical. If <code>TRUE</code>, marks the evaluation points used to fit gradients.</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_grid">grid</code></td>
<td>
<p>A user-supplied data frame or pattern (e.g., &quot;hex&quot;) for specifying custom evaluation points.</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_arrow">arrow</code></td>
<td>
<p>An optional <code>grid::arrow()</code> specification to add arrowheads to
the vectors (default: <code>grid::arrow(angle = 25, length = unit(0.025, "npc"), type = "closed")</code>).</p>
</td></tr>
<tr><td><code id="geom_gradient_smooth_+3A_geom">geom</code></td>
<td>
<p>The geometric object used to render the streamline (only used in
<code>stat_stream()</code>; defaults to <a href="#topic+GeomStream">GeomStream</a>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 layer that can be added to a ggplot object.
</p>


<h3>Aesthetics</h3>

<p><code>geom_gradient_smooth()</code> supports the following aesthetics (required aesthetics are in <strong>bold</strong>):
</p>

<ul>
<li> <p><strong><code>x</code></strong>: The x-coordinate of the data point.
</p>
</li>
<li> <p><strong><code>y</code></strong>: The y-coordinate of the data point.
</p>
</li>
<li> <p><strong><code>z</code></strong>: The scalar value used for computing the gradient.
</p>
</li>
<li> <p><code>color</code>: The color used for the gradient vectors. Defaults depend on the
selected <code>type</code>.
</p>
</li></ul>



<h3>Details</h3>

<p><strong>Gradient Calculation:</strong>
A linear model is fitted using the provided <code>formula</code> and the raw data. The scalar
field defined by the model is then differentiated numerically with
<code>numDeriv::grad()</code> to yield gradient vectors.
</p>
<p><strong>Visualization:</strong>
The resulting gradient field is visualized using <code><a href="#topic+GeomStream">GeomStream()</a></code>. Since <code>z</code> is only
used internally, it is dropped from the final visual output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define several scalar field functions:

# Example 1: f(x, y) = x^2 - y^2
f &lt;- function(u) {
  x &lt;- u[1]
  y &lt;- u[2]
  x^2 - y^2
}

# Example 2: g(x, y) = sin(x) * cos(y)
g &lt;- function(u) {
  x &lt;- u[1]
  y &lt;- u[2]
  sin(x) * cos(y)
}

# Example 3: h(x, y) = log(|x| + 1) + sqrt(|y|)
h &lt;- function(u) {
  x &lt;- u[1]
  y &lt;- u[2]
  log(abs(x) + 1) + sqrt(abs(y))
}

# Create a grid of evaluation points
grid_data &lt;- expand.grid(
  x = seq(-5, 5, length.out = 30),
  y = seq(-5, 5, length.out = 30)
)

# Compute the scalar field for f and plot its gradient
grid_data$z &lt;- apply(grid_data, 1, f)

ggplot(grid_data, aes(x = x, y = y, z = z)) +
  geom_gradient_smooth()

# Compute and plot for g:
grid_data$z &lt;- apply(grid_data, 1, g)
ggplot(grid_data, aes(x = x, y = y, z = z)) +
  geom_gradient_smooth()

# Compute and plot for h:
grid_data$z &lt;- apply(grid_data, 1, h)
ggplot(grid_data, aes(x = x, y = y, z = z)) +
  geom_gradient_smooth()

</code></pre>

<hr>
<h2 id='geom_potential'>Compute and Plot Potential Function from a Conservative Vector Field</h2><span id='topic+geom_potential'></span><span id='topic+stat_potential'></span><span id='topic+StatPotential'></span><span id='topic+GeomPotential'></span>

<h3>Description</h3>

<p><code>geom_potential()</code> adds a raster layer to a ggplot object, visualizing the
potential function derived from a conservative vector field. It computes the
potential numerically over a specified grid and displays it as a heatmap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_potential(
  mapping = NULL,
  data = NULL,
  stat = StatPotential,
  position = "identity",
  ...,
  na.rm = FALSE,
  inherit.aes = TRUE,
  show.legend = NA,
  fun,
  xlim = NULL,
  ylim = NULL,
  n = 51,
  tol = 1e-06,
  verify_conservative = FALSE
)

stat_potential(
  mapping = NULL,
  data = NULL,
  geom = GeomPotential,
  position = "identity",
  ...,
  na.rm = FALSE,
  inherit.aes = TRUE,
  show.legend = NA,
  fun,
  xlim = NULL,
  ylim = NULL,
  n = 51,
  tol = 1e-06,
  verify_conservative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_potential_+3A_mapping">mapping</code></td>
<td>
<p>A set of aesthetic mappings created by <code>ggplot2::aes()</code>.
(Optional)</p>
</td></tr>
<tr><td><code id="geom_potential_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. If <code>NULL</code>, data is
inherited from the plot.</p>
</td></tr>
<tr><td><code id="geom_potential_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data (default:
<a href="#topic+StatPotential">StatPotential</a>).</p>
</td></tr>
<tr><td><code id="geom_potential_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string or the result of a
position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_potential_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>grid::layer()</code> and underlying
methods.</p>
</td></tr>
<tr><td><code id="geom_potential_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default), missing values are removed with a
warning.</p>
</td></tr>
<tr><td><code id="geom_potential_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>Logical. If <code>FALSE</code>, overrides the default aesthetics
rather than combining with them.</p>
</td></tr>
<tr><td><code id="geom_potential_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical. Should this layer be included in the legends?</p>
</td></tr>
<tr><td><code id="geom_potential_+3A_fun">fun</code></td>
<td>
<p>A function that takes a numeric vector of length 2 (<code>c(x, y)</code>) and
returns a numeric value, defining the conservative vector field.
<strong>(Required)</strong></p>
</td></tr>
<tr><td><code id="geom_potential_+3A_xlim">xlim</code></td>
<td>
<p>Numeric vector of length 2 defining the domain limits on the
x-axis. Defaults to <code>c(-1, 1)</code>.</p>
</td></tr>
<tr><td><code id="geom_potential_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vector of length 2 defining the domain limits on the
y-axis. Defaults to <code>c(-1, 1)</code>.</p>
</td></tr>
<tr><td><code id="geom_potential_+3A_n">n</code></td>
<td>
<p>Integer. Number of grid points along each axis for computing the
potential. Defaults to <code>21</code>.</p>
</td></tr>
<tr><td><code id="geom_potential_+3A_tol">tol</code></td>
<td>
<p>Numeric. Tolerance for verifying if the vector field is
conservative. Defaults to <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="geom_potential_+3A_verify_conservative">verify_conservative</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the function verifies that the
provided vector field is conservative (i.e., that the mixed partial
derivatives are equal within the specified tolerance). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="geom_potential_+3A_geom">geom</code></td>
<td>
<p>The geometric object used to render the potential function.
Defaults to <a href="#topic+GeomPotential">GeomPotential</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: the potential is only known up to a constant. The point of reference
used is the lower left corner <code>c(xlim[1], ylim[1])</code>, where the potential is
assumed to be 0.
</p>


<h3>Value</h3>

<p>A ggplot2 layer that produces a potential function heatmap.
</p>


<h3>Aesthetics</h3>

<p><code>geom_potential()</code> accepts all aesthetics supported by
<code>GeomRaster</code>. In particular, the key aesthetics include:
</p>

<ul>
<li> <p><strong>fill</strong>: The computed potential value at each grid cell, which is mapped to a color scale.
</p>
</li>
<li> <p><code>x</code> and <code>y</code>: The coordinates of the grid cell centers. (calculated)
</p>
</li>
<li> <p><code>alpha</code>: Controls the transparency of the raster fill.
</p>
</li></ul>

<p>Additional raster-specific aesthetics (e.g. those controlled by
<code>scale_fill_gradient()</code>, <code>scale_fill_viridis_c()</code>, etc.) can be applied to
modify the appearance of the potential heatmap.
</p>


<h3>Computed Variables</h3>

<p>The following variable is computed internally by <a href="#topic+StatPotential">StatPotential</a> during the
potential function calculation:
</p>

<dl>
<dt>Potential</dt><dd><p>The scalar potential value computed numerically at each grid point.
It represents the accumulated potential from a reference point (typically the lower
bounds of <code>xlim</code> and <code>ylim</code>) to the given point. This value is mapped to
the <code>fill</code> aesthetic in the raster layer.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>

scalar_field &lt;- function(u){
  x &lt;- u[1]; y &lt;- u[2]
  (x + y)^2 + 4*(x - y)^2 - 8*(.5)^2
}

gradient_field &lt;- function(u) numDeriv::grad(scalar_field, u)

s &lt;- seq(-1, 1, length.out = 51)

expand.grid("x" = s, "y" = s) |&gt;
  transform(phi = apply(cbind(x, y), 1, scalar_field)) |&gt;
  ggplot(aes(x, y)) + geom_raster(aes(fill = phi))

ggplot() + geom_potential(fun = gradient_field)

ggplot() + geom_potential(fun = gradient_field, verify_conservative = TRUE)


</code></pre>

<hr>
<h2 id='geom_stream'>Create a Streamline Plot Layer in ggplot2</h2><span id='topic+geom_stream'></span><span id='topic+stat_stream'></span><span id='topic+StatStream'></span><span id='topic+GeomStream'></span>

<h3>Description</h3>

<p><code>geom_stream()</code> generates a ggplot2 layer that visualizes data as continuous
streams over a temporal variable <strong><code>t</code></strong>. Each stream is defined by the
required aesthetics <strong><code>x</code></strong>, <strong><code>y</code></strong>, and <strong><code>t</code></strong>, and optionally grouped by
<strong><code>group</code></strong> (or mapped from <code>id</code>). Within each group, data points are
automatically ordered by <code>t</code> to form a continuous path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_stream(
  mapping = NULL,
  data = NULL,
  stat = StatStream,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  arrow.fill = NULL,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  arrow = grid::arrow(angle = 25, length = unit(0.025, "npc"), type = "closed")
)

stat_stream(
  mapping = NULL,
  data = NULL,
  geom = GeomStream,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  arrow.fill = NULL,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  arrow = grid::arrow(angle = 25, length = unit(0.025, "npc"), type = "closed")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_stream_+3A_mapping">mapping</code></td>
<td>
<p>A set of aesthetic mappings created by <code>ggplot2::aes()</code>.
<strong>Required:</strong> Must include <strong><code>x</code></strong>, <strong><code>y</code></strong>, and <strong><code>t</code></strong>; additionally,
<strong><code>group</code></strong> is used to differentiate streams (if not provided, <code>id</code> will be mapped to
<code>group</code> automatically).</p>
</td></tr>
<tr><td><code id="geom_stream_+3A_data">data</code></td>
<td>
<p>A data frame or other object, as in <code>grid::layer()</code>.</p>
</td></tr>
<tr><td><code id="geom_stream_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer;
defaults to <a href="#topic+StatStream">StatStream</a>.</p>
</td></tr>
<tr><td><code id="geom_stream_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string or the result of a
position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_stream_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the underlying layers for further
customization.</p>
</td></tr>
<tr><td><code id="geom_stream_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. If <code>FALSE</code> (the default), missing values are removed
with a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_stream_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical. Should this layer be included in the legends?</p>
</td></tr>
<tr><td><code id="geom_stream_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>Logical. If <code>FALSE</code>, overrides the default aesthetics
rather than combining with them.</p>
</td></tr>
<tr><td><code id="geom_stream_+3A_arrow.fill">arrow.fill</code></td>
<td>
<p>An optional parameter specifying the color of the arrow
head. Defaults to <code>NULL</code> and inherets fill/alpha of <code>aes()</code>.</p>
</td></tr>
<tr><td><code id="geom_stream_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_stream_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_stream_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_stream_+3A_arrow">arrow</code></td>
<td>
<p>An optional <code><a href="grid.html#topic+arrow">grid::arrow()</a></code> specification to place arrowheads on
the streamline.</p>
</td></tr>
<tr><td><code id="geom_stream_+3A_geom">geom</code></td>
<td>
<p>The geometric object used to render the streamline (only used in
<code>stat_stream()</code>; defaults to <a href="#topic+GeomStream">GeomStream</a>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two variants:
</p>

<ul>
<li> <p><code>geom_stream()</code>: A convenient wrapper that sets <code>stat = StatStream</code> and uses
<a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::GeomPath</a> by default.
</p>
</li>
<li> <p><code>stat_stream()</code>: Provides direct access to the reordering stat (i.e. <code>StatStream</code>)
for advanced customization, using <a href="#topic+GeomStream">GeomStream</a> for drawing.
</p>
</li></ul>



<h3>Value</h3>

<p>A ggplot2 layer that can be added to a plot to produce a streamline
visualization.
</p>


<h3>Aesthetics</h3>

<p><code>geom_stream()</code> and <code>stat_stream()</code> understand the
following aesthetics (required aesthetics are in <strong>bold</strong>):
</p>

<ul>
<li> <p><strong><code>x</code></strong>: Horizontal position.
</p>
</li>
<li> <p><strong><code>y</code></strong>: Vertical position.
</p>
</li>
<li> <p><strong><code>t</code></strong>: Temporal or ordered variable used to sequence data points.
</p>
</li>
<li> <p><code>group</code>: Grouping variable for multiple streams (automatically mapped from <code>id</code> if absent).
</p>
</li>
<li> <p><code>color</code>: Color of the stream.
</p>
</li>
<li> <p><code>linetype</code>: Type of line used to draw the stream.
</p>
</li>
<li> <p><code>linewidth</code>: Thickness of the stream line.
</p>
</li>
<li> <p><code>alpha</code>: Transparency of the stream.
</p>
</li></ul>



<h3>Details</h3>


<ul>
<li> <p><strong>Data Ordering</strong>: If <code>t</code> is not provided, an error is thrown. When present,
points within each group are sorted by <code>t</code> prior to drawing the stream.
</p>
</li>
<li> <p><strong>Arrows</strong>: The <code>arrow</code> parameter can be used to indicate direction along each stream.
</p>
</li></ul>



<h3>Computed Variables</h3>

<p>These are calculated by the 'stat' part of layers and can be accessed with
delayed evaluation.
</p>

<dl>
<dt>norm</dt><dd><p>This variable is calculated as the Euclidean distance derived
from the ranges of the <code>x</code> and <code>y</code> values. It serves as a
normalization factor for vector lengths when the <code>normalize</code>
parameter is active.</p>
</dd>
<dt>avg_spd</dt><dd><p>Represents the average speed, which is defined as the length
of the stream divided by the time it took to traverse that distance.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 25
s &lt;- seq(0, 1, length.out = n+1)[-(n+1)]
df &lt;- data.frame( "t" = s, "x" = cos(2*pi*s), "y" = sin(2*pi*s) )

ggplot(df) +
  geom_stream(aes(x, y, t = t)) +
  coord_equal()

ggplot(df) +
  geom_stream(aes(x, y, t = t, alpha = t), size = 5) +
  coord_equal()

ggplot(df) +
  geom_path(aes(x, y, alpha = t), size = 5) +
  coord_equal()


stream_1 &lt;- data.frame(
  x = c(0, 3),
  y = c(0, 0),
  t = 0:1
)

stream_2 &lt;- data.frame(
  x = c(1, 1),
  y = c(1, 5),
  t = 0:1
)

stream_3 &lt;- data.frame(
  x = c(2, 5),
  y = c(2, 6),
  t = 0:1
)

streams &lt;- rbind(
  cbind(stream_1, id = 1),
  cbind(stream_2, id = 2),
  cbind(stream_3, id = 3)
)

ggplot(stream_1) +
  geom_stream(aes(x = x, y = y, t = t))

# set group aes if multiple vectors
ggplot(streams) +
  geom_stream(aes(x = x, y = y, t = t, group = id))

</code></pre>

<hr>
<h2 id='geom_stream_field'>Create a Stream Field Layer in ggplot2</h2><span id='topic+geom_stream_field'></span><span id='topic+stat_stream_field'></span><span id='topic+geom_stream_field2'></span><span id='topic+stat_stream_field2'></span><span id='topic+StatStreamField'></span>

<h3>Description</h3>

<p><code><a href="#topic+geom_stream_field">geom_stream_field()</a></code> creates a ggplot2 layer that integrates a user-defined
vector field function <code class="reqn">f(x, y) \to (dx, dy)</code> over a grid of seed points
within a specified domain. The function numerically integrates the field
starting from these seeds, producing streamlines that visualize the flow.
This is useful for visualizing vector fields, flow patterns, or trajectories,
such as in fluid dynamics or gradient fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_stream_field(
  mapping = NULL,
  data = NULL,
  stat = StatStreamField,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = FALSE,
  fun,
  xlim = NULL,
  ylim = NULL,
  n = 11,
  args = list(),
  max_it = 1000L,
  tol = sqrt(.Machine$double.eps),
  T = NULL,
  L = NULL,
  center = TRUE,
  type = "stream",
  normalize = TRUE,
  tail_point = FALSE,
  eval_point = FALSE,
  grid = NULL,
  method = "rk4",
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  arrow = grid::arrow(angle = 30, length = unit(0.02, "npc"), type = "closed")
)

stat_stream_field(
  mapping = NULL,
  data = NULL,
  geom = GeomStream,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  fun,
  xlim = NULL,
  ylim = NULL,
  n = 11,
  args = list(),
  max_it = 1000,
  tol = sqrt(.Machine$double.eps),
  T = NULL,
  L = NULL,
  center = TRUE,
  type = "stream",
  normalize = TRUE,
  tail_point = FALSE,
  eval_point = FALSE,
  grid = NULL,
  method = "rk4",
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  arrow = grid::arrow(angle = 30, length = unit(0.02, "npc"), type = "closed")
)

geom_stream_field2(
  mapping = NULL,
  data = NULL,
  stat = StatStreamField,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = FALSE,
  fun,
  xlim = NULL,
  ylim = NULL,
  n = 11,
  args = list(),
  max_it = 1000,
  tol = sqrt(.Machine$double.eps),
  L = NULL,
  center = FALSE,
  type = "stream",
  tail_point = TRUE,
  eval_point = FALSE,
  grid = NULL,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  method = "rk4"
)

stat_stream_field2(
  mapping = NULL,
  data = NULL,
  geom = GeomStream,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = FALSE,
  fun,
  xlim = NULL,
  ylim = NULL,
  n = 11,
  args = list(),
  max_it = 1000,
  tol = sqrt(.Machine$double.eps),
  L = NULL,
  center = FALSE,
  type = "stream",
  tail_point = TRUE,
  eval_point = FALSE,
  grid = NULL,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  method = "rk4"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_stream_field_+3A_mapping">mapping</code></td>
<td>
<p>A set of aesthetic mappings created by <code>ggplot2::aes()</code>.
(Optional)</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_data">data</code></td>
<td>
<p>A data frame or other object, as in <code>ggplot2::layer()</code>.
(Optional)</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data (default:
<a href="#topic+StatStreamField">StatStreamField</a>).</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string or the result of a
position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>ggplot2::layer()</code> and the underlying
geometry/stat.</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. If <code>FALSE</code> (the default), missing values are removed
with a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical. Should this layer be included in the legends?</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>Logical. If <code>FALSE</code>, overrides the default aesthetics
rather than combining with them.</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_fun">fun</code></td>
<td>
<p>A function of two variables, <code>fun(x, y)</code>, returning a two-element
vector <code class="reqn">(dx, dy)</code> that defines the local flow direction at any point.</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_xlim">xlim</code></td>
<td>
<p>Numeric vector of length 2 specifying the domain limits in the
<code class="reqn">x</code>-direction. Defaults to <code class="reqn">c(-1, 1)</code>.</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vector of length 2 specifying the domain limits in the
<code class="reqn">y</code>-direction. Defaults to <code class="reqn">c(-1, 1)</code>.</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_n">n</code></td>
<td>
<p>Integer or two-element numeric vector specifying the grid resolution
(number of seed points) along each axis. Defaults to <code>11</code>, producing an
<code class="reqn">11 \times 11</code> grid.</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_args">args</code></td>
<td>
<p>A list of additional arguments passed to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_max_it">max_it</code></td>
<td>
<p><code>integer(1)</code>; Maximum number of integration steps per
streamline (default: <code>1000L</code>).</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_tol">tol</code></td>
<td>
<p><code>numeric(1)</code>; a tolerance used to determine if a sink has been
hit, among other things (default: <code>sqrt(.Machine$double.eps)</code>).</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_t">T</code></td>
<td>
<p>Numeric. When <code>normalize = FALSE</code>, each streamline is integrated for
a fixed time <code>T</code> before being cropped to match the duration of the fastest
streamline reaching the arc length <code>L</code>. When <code>normalize = TRUE</code>,
integration instead stops when the cumulative arc length reaches <code>L</code>, and
the parameter <code>T</code> is ignored.</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_l">L</code></td>
<td>
<p>Numeric. Maximum arc length for each streamline. When <code>normalize = TRUE</code>, integration stops once the cumulative arc length reaches <code>L</code>. When
<code>normalize = FALSE</code>, streamlines are initially computed for a fixed time
<code>T</code> and then cropped so that all are truncated to the duration it takes the
fastest streamline to reach the arc length <code>L</code>. Defaults to <code>NULL</code> (a
suitable default is computed from the grid spacing).</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_center">center</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), centers the seed points (or
resulting streamlines) so that the original (x, y) becomes the midpoint.</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_type">type</code></td>
<td>
<p>Character. Either <code>"stream"</code> (default) or <code>"vector"</code>. <code>"stream"</code>
computes a full streamline by integrating in both directions (if <code>center = TRUE</code>), while <code>"vector"</code> computes a single vector.</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_normalize">normalize</code></td>
<td>
<p>Logical.
When <code>normalize = TRUE</code> (the default), each streamline is integrated until its
cumulative arc length reaches the specified value <code>L</code>, ensuring that all streams
have a uniform, normalized length based on grid spacing.
When <code>normalize = FALSE</code>, the integration runs for a fixed time (<code>T</code>), and afterward,
all streamlines are cropped to the duration it takes for the fastest one to reach
the length <code>L</code>, allowing for variations in arc lengths that reflect differences in
flow speeds.</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_tail_point">tail_point</code></td>
<td>
<p>Logical. If <code>TRUE</code>, draws a point at the tail (starting
point) of each streamline. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_eval_point">eval_point</code></td>
<td>
<p>Logical. If <code>TRUE</code>, draws a point at the evaluation point
where the field was computed. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_grid">grid</code></td>
<td>
<p>A data frame containing precomputed grid points for seed
placement. If <code>NULL</code> (default), a regular Cartesian grid is generated based
on <code>xlim</code>, <code>ylim</code>, and <code>n</code>.</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_method">method</code></td>
<td>
<p>Character. Integration method (e.g. <code>"rk4"</code> for Runge-Kutta 4,
<code>"euler"</code> for Euler's method). Defaults to <code>"rk4"</code>.</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_arrow">arrow</code></td>
<td>
<p>A <code>grid::arrow()</code> specification for adding arrowheads to the
streamlines. Defaults to a closed arrow with a 30° angle and length <code>0.02</code>
npc.</p>
</td></tr>
<tr><td><code id="geom_stream_field_+3A_geom">geom</code></td>
<td>
<p>The geometric object used to render the streamlines (defaults to
<a href="#topic+GeomStream">GeomStream</a>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 layer that computes and renders streamlines over the
specified domain.
</p>


<h3>Aesthetics</h3>

<p><code>geom_stream_field()</code> (and its stat variant) inherit
aesthetics from <a href="#topic+GeomStream">GeomStream</a> and understand the following:
</p>

<ul>
<li> <p><strong><code>x</code></strong>: x-coordinate of the seed point.
</p>
</li>
<li> <p><strong><code>y</code></strong>: y-coordinate of the seed point.
</p>
</li>
<li> <p><code>color</code>: Color, typically used to represent computed statistics (e.g. average speed).
</p>
</li>
<li> <p><code>linetype</code>: Type of line used to draw the streamlines.
</p>
</li>
<li> <p><code>linewidth</code>: Thickness of the streamlines.
</p>
</li>
<li> <p><code>alpha</code>: Transparency of the streamlines.
</p>
</li></ul>



<h3>Details</h3>

<p>The streamlines are generated by numerically integrating
the vector field defined by <code>fun(x, y)</code>. When <code>normalize = TRUE</code>,
integration stops once the cumulative arc length reaches <code>L</code>; otherwise,
integration runs until time <code>T</code> is reached. If both <code>T</code> and <code>L</code> are
provided in incompatible combinations, one parameter is ignored. The
computed paths are rendered by <a href="#topic+GeomStream">GeomStream</a>.
</p>


<h3>Computed Variables</h3>

<p>The following variables are computed internally by <a href="#topic+StatStreamField">StatStreamField</a> during the
integration of the vector field:
</p>

<dl>
<dt>avg_spd</dt><dd><p>For vector fields, this is computed as the total arc length divided
by the integration time, providing an estimate of the average speed. It is used to
scale the vector lengths when mapping <code>length = after_stat(norm)</code>.</p>
</dd>
<dt>t</dt><dd><p>The integration time at each computed point along a streamline.</p>
</dd>
<dt>d</dt><dd><p>The distance between consecutive points along the computed path.</p>
</dd>
<dt>l</dt><dd><p>The cumulative arc length along the streamline, calculated as the cumulative
sum of <code>d</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- function(u) c(-u[2], u[1])

# the basic usage involves providing a fun, xlim, and ylim
ggplot() + geom_stream_field(fun = f, xlim = c(-1,1), ylim = c(-1,1))

# if unspecified, xlim and ylim default to c(-1,1). we use this in what
# follows to focus on other parts of the code
ggplot() + geom_stream_field(fun = f)
ggplot() + geom_stream_field(fun = f, center = FALSE)

ggplot() + geom_stream_field(fun = f, normalize = FALSE)
ggplot() + geom_stream_field(fun = f, normalize = FALSE, center = FALSE)

# run systems until specified lengths
ggplot() + geom_stream_field(fun = f, normalize = TRUE, L = .8)
ggplot() + geom_vector_field(fun = f, normalize = TRUE, L = .3)
ggplot() + geom_vector_field(fun = f, normalize = FALSE, L = 2)

# run systems for specified times
ggplot() + geom_stream_field(fun = f, normalize = FALSE, T = .1)

# tail and eval points
ggplot() + geom_stream_field(fun = f, tail_point = TRUE)
ggplot() + geom_stream_field(fun = f, eval_point = TRUE)

# changing the grid of evaluation
ggplot() + geom_stream_field(fun = f)
ggplot() + geom_stream_field(fun = f, grid = "hex")
ggplot() + geom_stream_field(fun = f, grid = "hex", n = 5)
ggplot() + geom_stream_field(fun = f, n = 5)
ggplot() + geom_stream_field(fun = f, xlim = c(-5, 5)) + coord_equal()
ggplot() + geom_stream_field(fun = f, xlim = c(-5, 5), n = c(21, 11)) + coord_equal()
ggplot() + geom_stream_field(fun = f)
ggplot() + geom_stream_field(fun = f, grid = grid_hex(c(-1,1), c(-1,1), .2))

# using other ggplot2 tools
f &lt;- efield_maker()

ggplot() + geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2))

ggplot() +
  geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2)) +
  scale_color_viridis_c(trans = "log10")

ggplot() +
  geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2)) +
  scale_color_viridis_c(trans = "log10") +
  coord_equal()


# other vector fields
f &lt;- function(u) u
ggplot() + geom_stream_field(fun = f, xlim = c(-1,1), ylim = c(-1,1))

f &lt;- function(u) c(2,1)
ggplot() + geom_stream_field(fun = f, xlim = c(-1,1), ylim = c(-1,1))



# neat examples
f &lt;- function(u) {
  x &lt;- u[1]; y &lt;- u[2]
  c(y, y*(-x^2 - 2*y^2 + 1) - x)
}
ggplot() + geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2))
ggplot() + geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2), type = "vector")

f &lt;- function(u) {
  x &lt;- u[1]; y &lt;- u[2]
  c(y, x - x^3)
}
ggplot() + geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2))
ggplot() + geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2),
  grid = grid_hex(c(-2,2), c(-2,2), .35))

f &lt;- function(u) {
  x &lt;- u[1]; y &lt;- u[2]
  c(x^2 - y^2, x^2 + y^2 - 2)
}
ggplot() + geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2))
ggplot() + geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2),
  grid = grid_hex(c(-2,2), c(-2,2), .35))

ggplot() +
  geom_stream_field(fun = f, aes(alpha = after_stat(t)), xlim = c(-2,2), ylim = c(-2,2)) +
  scale_alpha(range  = c(0,1))

ggplot() +
  geom_stream_field(
    fun = f, xlim = c(-1,1), ylim = c(-1,1),
    linewidth = .75, arrow = arrow(length = unit(0.015, "npc"))
  )


</code></pre>

<hr>
<h2 id='geom_stream_smooth'>Create a Smoothed Vector Field Layer</h2><span id='topic+geom_stream_smooth'></span><span id='topic+stat_stream_smooth'></span>

<h3>Description</h3>

<p><code>geom_stream_smooth()</code> creates a ggplot2 layer that visualizes a smooth
vector field based on raw vector data. The function fits a multivariate
linear model (by default, using the formula <code>cbind(fx, fy) ~ x * y</code>) to
predict the vector displacements at any given location. It also handles
different input formats by converting polar coordinates or endpoint data to
vector displacements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_stream_smooth(
  mapping = NULL,
  data = NULL,
  stat = StatStreamField,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  n = 11,
  xlim = NULL,
  ylim = NULL,
  normalize = TRUE,
  center = FALSE,
  type = "vector",
  formula = cbind(fx, fy) ~ x * y,
  eval_points = NULL,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  arrow = grid::arrow(angle = 20, length = unit(0.015, "npc"), type = "closed")
)

stat_stream_smooth(
  mapping = NULL,
  data = NULL,
  geom = GeomStream,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  n = 11,
  xlim = NULL,
  ylim = NULL,
  normalize = TRUE,
  center = FALSE,
  type = "vector",
  formula = cbind(fx, fy) ~ x * y,
  eval_points = NULL,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  arrow = grid::arrow(angle = 20, length = unit(0.015, "npc"), type = "closed")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_stream_smooth_+3A_mapping">mapping</code></td>
<td>
<p>A set of aesthetic mappings created by <code>ggplot2::aes()</code>.
<strong>Required:</strong> Must include <strong><code>x</code></strong> and <strong><code>y</code></strong>; vector displacements are defined
by <strong><code>fx</code></strong> and <strong><code>fy</code></strong>.</p>
</td></tr>
<tr><td><code id="geom_stream_smooth_+3A_data">data</code></td>
<td>
<p>A data frame containing the raw vector data.</p>
</td></tr>
<tr><td><code id="geom_stream_smooth_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data. Defaults to
<code>"vector_smooth"</code>.</p>
</td></tr>
<tr><td><code id="geom_stream_smooth_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string or the result of a
position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_stream_smooth_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the layer. If a fixed parameter
<code>color</code> is not provided, then <code>color = "blue"</code> is used.</p>
</td></tr>
<tr><td><code id="geom_stream_smooth_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. If <code>FALSE</code> (the default), missing values are removed
with a warning.</p>
</td></tr>
<tr><td><code id="geom_stream_smooth_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical. Should this layer be included in the legends?</p>
</td></tr>
<tr><td><code id="geom_stream_smooth_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>Logical. If <code>FALSE</code>, overrides the default aesthetics
rather than combining with them.</p>
</td></tr>
<tr><td><code id="geom_stream_smooth_+3A_n">n</code></td>
<td>
<p>An integer vector specifying the grid resolution for smoothing.</p>
</td></tr>
<tr><td><code id="geom_stream_smooth_+3A_xlim">xlim</code></td>
<td>
<p>Numeric vector of length 2 specifying the domain limits in the
<code class="reqn">x</code>-direction. Defaults to <code class="reqn">c(-1, 1)</code>.</p>
</td></tr>
<tr><td><code id="geom_stream_smooth_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vector of length 2 specifying the domain limits in the
<code class="reqn">y</code>-direction. Defaults to <code class="reqn">c(-1, 1)</code>.</p>
</td></tr>
<tr><td><code id="geom_stream_smooth_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the vector endpoints are scaled to unit
length before being scaled by <code>L</code> (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="geom_stream_smooth_+3A_center">center</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the vector is recentered so that the
original <code style="white-space: pre;">&#8288;(x, y)&#8288;</code> becomes the midpoint (default is <code>TRUE</code> for
<code>geom_vector()</code> and <code>FALSE</code> for <code>geom_vector2()</code>).</p>
</td></tr>
<tr><td><code id="geom_stream_smooth_+3A_type">type</code></td>
<td>
<p>Character. Either <code>"stream"</code> (default) or <code>"vector"</code>. <code>"stream"</code>
computes a full streamline by integrating in both directions (if <code>center = TRUE</code>), while <code>"vector"</code> computes a single vector.</p>
</td></tr>
<tr><td><code id="geom_stream_smooth_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the multivariate linear model used for
smoothing. Defaults to <code>cbind(fx, fy) ~ x * y</code>.</p>
</td></tr>
<tr><td><code id="geom_stream_smooth_+3A_eval_points">eval_points</code></td>
<td>
<p>A data frame of evaluation points, or <code>NULL</code>. When
provided, it specifies the grid where the smoothing model is evaluated; if
<code>NULL</code>, a grid is generated based on <code>n</code>.</p>
</td></tr>
<tr><td><code id="geom_stream_smooth_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_stream_smooth_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_stream_smooth_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_stream_smooth_+3A_arrow">arrow</code></td>
<td>
<p>An optional <code>grid::arrow()</code> specification to add arrowheads to
the vectors (default: <code>grid::arrow(angle = 25, length = unit(0.025, "npc"), type = "closed")</code>).</p>
</td></tr>
<tr><td><code id="geom_stream_smooth_+3A_geom">geom</code></td>
<td>
<p>The geometric object used to render the streamline (only used in
<code>stat_stream()</code>; defaults to <a href="#topic+GeomStream">GeomStream</a>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 layer that can be added to a ggplot object to display a
smoothed vector field.
</p>

<dl>
<dt>norm</dt><dd><p>Computed as the Euclidean norm of the displacement,
<code class="reqn">\sqrt{fx^2 + fy^2}</code>, this variable is used to normalize and scale the
vector lengths.</p>
</dd>
<dt>t</dt><dd><p>The integration time or evaluation time at each computed point along
the smoothed field (when applicable).</p>
</dd>
<dt>d</dt><dd><p>The incremental distance between consecutive computed points.</p>
</dd>
<dt>l</dt><dd><p>The cumulative arc length along the smoothed vector field, calculated
as the cumulative sum of <code>d</code>.</p>
</dd>
</dl>



<h3>Aesthetics</h3>

<p><code>geom_stream_smooth()</code> supports the following aesthetics
(required aesthetics are in <strong>bold</strong>):
</p>

<ul>
<li> <p><strong><code>x</code></strong>: The x-coordinate of the vector's starting point.
</p>
</li>
<li> <p><strong><code>y</code></strong>: The y-coordinate of the vector's starting point.
</p>
</li>
<li> <p><strong><code>fx</code></strong>: The displacement along the x-axis.
</p>
</li>
<li> <p><strong><code>fy</code></strong>: The displacement along the y-axis.
</p>
</li>
<li> <p><code>color</code>: The fixed color for the vector. Defaults to <code>"blue"</code>.
</p>
</li>
<li> <p><code>linewidth</code>: The thickness of the vector line.
</p>
</li>
<li> <p><code>linetype</code>: The type of the vector line (e.g., solid or dashed).
</p>
</li>
<li> <p><code>alpha</code>: The transparency level of the vector.
</p>
</li>
<li> <p><code>arrow</code>: Specifies arrowheads for the vectors.
</p>
</li></ul>



<h3>Details</h3>

<p><strong>Data Conversion:</strong>
If <code>xend</code>/<code>yend</code> are missing or all <code>NA</code>, the function computes them. It
first checks for vector displacements (<code>fx</code> and <code>fy</code>); if present, it
computes <code class="reqn">xend = x + fx,\quad yend = y + fy.</code> Otherwise, it checks for
polar coordinates (<code>angle</code> and <code>distance</code>) and computes <code class="reqn">xend = x +
  distance \times \cos(angle \times 180/\pi),\quad yend = y + distance \times
  \sin(angle \times 180/\pi).</code> An error is thrown if neither set is
available.
</p>
<p><strong>Smoothing:</strong>
The multivariate linear model is fitted using the provided <code>formula</code> and
<code>data</code>. This model is then used to predict vector displacements at any
specified grid point, generating a smooth approximation of the vector
field.
</p>
<p><strong>Prediction Intervals:</strong>
Two types of prediction intervals can be displayed:
</p>

<ul>
<li> <p><strong>Ellipse:</strong> Depicts the joint uncertainty (covariance) in the predicted <code>fx</code> and <code>fy</code>.
</p>
</li>
<li> <p><strong>Wedge:</strong> Indicates the range of possible vector directions and magnitudes.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

# Define a true vector field function
f &lt;- function(u) {
  x &lt;- u[1]; y &lt;- u[2]
  c(x^2 - y^2, x^2 + y^2 - 2)
}

# Alternative example function
f &lt;- function(u) c(-u[2], u[1])

# Visualize the vector field
ggplot() + geom_stream_field(fun = f, xlim = c(-2, 2), ylim = c(-2, 2))

# Generate design points
n &lt;- 20
df &lt;- data.frame(x = runif(n, -2, 2), y = runif(n, -2, 2))

# Sample function values at design points
fdf &lt;- as.data.frame(t(apply(df, 1, f)))
colnames(fdf) &lt;- c("fx", "fy")
df &lt;- cbind(df, fdf)

# Visualize raw vector field data
ggplot(df) + geom_vector(aes(x, y, fx = fx, fy = fy))

# Add smoothed layer using default model
ggplot(df) +
  geom_vector(aes(x, y, fx = fx, fy = fy)) +
  geom_stream_smooth(formula = cbind(fx, fy) ~ x * y)

# Use a more complex polynomial model
ggplot(df) +
  geom_vector(aes(x, y, fx = fx, fy = fy)) +
  geom_stream_smooth(formula = cbind(fx, fy) ~ poly(x, 2) * poly(y, 2), data = df)

# Fit a linear model and use it for prediction
fhat &lt;- function(u) {
  model &lt;- lm(cbind(fx, fy) ~ x * y, data = df)
  predict(model, newdata = data.frame(x = u[1], y = u[2])) |&gt; as.numeric()
}

# Visualize estimated field with the raw vector field
ggplot(df) +
  geom_stream_field(fun = fhat, normalize = FALSE, color = "#3366FF") +
  geom_vector(aes(x, y, fx = fx, fy = fy))

# Generate a hexagonal grid
hex_lattice &lt;- grid_hex(xlim = c(-5, 5), ylim = c(-5, 5), d = 1)

# Use the hexagonal grid in geom_stream_field
ggplot(data = df) +
  geom_vector(aes(x, y, fx = fx, fy = fy), color = "black", normalize = FALSE) +
  geom_stream_smooth(eval_points = hex_lattice)

# user specified point

eval_pts &lt;- data.frame(x = c(0, 1), y = c(2, -1))

ggplot(data = df) +
  geom_vector(aes(x, y, fx = fx, fy = fy), color = "black", normalize = FALSE) +
  geom_stream_smooth(eval_points = eval_pts)


</code></pre>

<hr>
<h2 id='geom_vector'>Vector Layers for ggplot2</h2><span id='topic+geom_vector'></span><span id='topic+stat_vector'></span><span id='topic+geom_vector2'></span><span id='topic+stat_vector2'></span><span id='topic+StatVector'></span>

<h3>Description</h3>

<p>Create layers for drawing vectors on ggplot2 plots. These functions accept
wide-format data with the required aesthetics <strong><code>x</code></strong> and <strong><code>y</code></strong> plus either
<strong><code>xend</code></strong> and <strong><code>yend</code></strong> or one of the alternative specifications: <strong><code>fx</code></strong>
and <strong><code>fy</code></strong>, or <strong><code>angle</code></strong>/ <strong><code>angle_deg</code></strong> and <strong><code>distance</code></strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_vector(
  mapping = NULL,
  data = NULL,
  stat = StatVector,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  center = TRUE,
  normalize = TRUE,
  tail_point = FALSE,
  eval_point = FALSE,
  L = NULL,
  arrow = grid::arrow(angle = 25, length = unit(0.025, "npc"), type = "closed")
)

stat_vector(
  mapping = NULL,
  data = NULL,
  geom = GeomStream,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  center = TRUE,
  normalize = TRUE,
  tail_point = FALSE,
  eval_point = FALSE,
  L = NULL,
  arrow = grid::arrow(angle = 25, length = unit(0.025, "npc"), type = "closed")
)

geom_vector2(
  mapping = NULL,
  data = NULL,
  stat = StatVector,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  center = FALSE,
  tail_point = TRUE,
  eval_point = FALSE,
  L = NULL,
  arrow = NULL
)

stat_vector2(
  mapping = NULL,
  data = NULL,
  geom = GeomStream,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  center = FALSE,
  tail_point = TRUE,
  eval_point = FALSE,
  L = NULL,
  arrow = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_vector_+3A_mapping">mapping</code></td>
<td>
<p>A set of aesthetic mappings created by <code>ggplot2::aes()</code>.
<strong>Required:</strong> Must include <strong><code>x</code></strong> and <strong><code>y</code></strong>; in addition, either <strong><code>xend</code></strong>
and <strong><code>yend</code></strong> or one of the alternative specifications (<strong><code>fx</code></strong>/ <strong><code>fy</code></strong>
or <strong><code>angle</code></strong>/ <strong><code>angle_deg</code></strong> and <strong><code>distance</code></strong>) must be provided.</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_data">data</code></td>
<td>
<p>A data frame containing the vector data in wide format.</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data (default:
<a href="#topic+StatVector">StatVector</a>).</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string or the result of a
position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code>grid::layer()</code>.</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. If <code>FALSE</code> (the default), missing values are removed
with a warning.</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical. Should this layer be included in the legends?</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>Logical. If <code>FALSE</code>, overrides the default aesthetics
rather than combining with them.</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_center">center</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the vector is recentered so that the
original <code style="white-space: pre;">&#8288;(x, y)&#8288;</code> becomes the midpoint (default is <code>TRUE</code> for
<code>geom_vector()</code> and <code>FALSE</code> for <code>geom_vector2()</code>).</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the vector endpoints are scaled to unit
length before being scaled by <code>L</code> (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_tail_point">tail_point</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a point is drawn at the tail (the
starting point) of each vector (default is <code>FALSE</code> for <code>geom_vector()</code> and
<code>TRUE</code> for <code>geom_vector2()</code>).</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_eval_point">eval_point</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a point is drawn at the evaluation
point corresponding to the original (untransformed) seed point before any
centering or normalization (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_l">L</code></td>
<td>
<p>Numeric scalar. The desired length for the vectors in data units. If
<code>NULL</code> (the default), a value is computed automatically based on the plot’s
x and y limits.</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_arrow">arrow</code></td>
<td>
<p>An optional <code>grid::arrow()</code> specification to add arrowheads to
the vectors (default: <code>grid::arrow(angle = 25, length = unit(0.025, "npc"), type = "closed")</code>).</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_geom">geom</code></td>
<td>
<p>The geometric object used to render the streamline (only used in
<code>stat_stream()</code>; defaults to <a href="#topic+GeomStream">GeomStream</a>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When specifying the vector direction using polar coordinates, you can provide
either:
</p>

<ul>
<li> <p><strong><code>angle</code></strong>: the vector direction in <strong>radians</strong>.
</p>
</li>
<li> <p><strong><code>angle_deg</code></strong>: the vector direction in <strong>degrees</strong> (which is
automatically converted to radians).
</p>
</li></ul>

<p>The endpoints are computed by translating the starting point using these
polar coordinates along with the supplied <strong><code>distance</code></strong>.
</p>
<p>The data is converted to long format (two rows per vector) via <a href="#topic+StatVector">StatVector</a>
and rendered with <a href="#topic+GeomStream">GeomStream</a>. Optionally, arrowheads can be added to
indicate direction.
</p>
<p>There are two variants:
</p>

<ul>
<li> <p><code>geom_vector()</code>: Uses the user-supplied aesthetic mapping.
</p>
</li>
<li> <p><code>geom_vector2()</code>: Uses the same underlying stat (<a href="#topic+StatVector">StatVector</a>) but adds a
default mapping for <code>length = after_stat(norm)</code>, making the computed vector
norm available as an aesthetic.
</p>
</li></ul>



<h3>Value</h3>

<p>A ggplot2 layer that can be added to a plot.
</p>


<h3>Aesthetics</h3>

<p><code>geom_vector()</code> and <code>geom_vector2()</code> understand the following aesthetics
(required aesthetics are in bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> xend
</p>
</li>
<li><p> yend
</p>
</li>
<li><p> fx (alternative specification)
</p>
</li>
<li><p> fy (alternative specification)
</p>
</li>
<li><p> angle (vector direction in radians; alternative specification)
</p>
</li>
<li><p> angle_deg (vector direction in degrees; alternative specification, converted to radians)
</p>
</li>
<li><p> distance (with angle/angle_deg, used to compute endpoints)
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> color
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> group
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> size
</p>
</li></ul>



<h3>Computed Variables</h3>

<p>These are calculated by the 'stat' part of layers and can be accessed with
delayed evaluation.
</p>

<dl>
<dt>norm</dt><dd><p>Calculated as the Euclidean distance between the starting point
(<code>x</code>, <code>y</code>) and the computed endpoint (<code>xend</code>, <code>yend</code>). This
value is used to normalize the vector length when the <code>normalize</code> parameter
is set to <code>TRUE</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
n &lt;- 10

# Generate wind data in polar coordinates
data &lt;- data.frame(
  x = rnorm(n),
  y = rnorm(n),
  dir = runif(n, -pi, pi), # angle in radians
  spd = rchisq(n, df = 2)  # speed
) |&gt;
  transform(fx = spd * cos(dir), fy = spd * sin(dir))

# Using fx/fy to compute endpoints
ggplot(data, aes(x, y)) +
  geom_vector(aes(fx = fx, fy = fy))

# Using angle (in radians) and distance to compute endpoints
ggplot(data, aes(x, y)) +
  geom_vector(aes(angle = dir, distance = spd))

# Using angle_deg (in degrees) and distance to compute endpoints
vectors3 &lt;- data.frame(
  x = c(0, 1, 2),
  y = c(0, 1, 2),
  angle_deg = c(0, 90, 45),
  angle = c(0, pi/2, pi/4),
  distance = c(3, 4, 5)
)
ggplot(vectors3, aes(x, y)) +
  geom_vector(aes(angle_deg = angle_deg, distance = distance))

# Basic usage with explicit start and end points:
vectors1 &lt;- data.frame(
  x    = c(0, 1, 2),
  y    = c(0, 1, 2),
  xend = c(3, 1, 5),
  yend = c(0, 5, 6)
)
ggplot(vectors1, aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_vector()

# Using center = TRUE to recenter vectors:
ggplot(vectors1, aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_vector(center = TRUE)

# Using normalize = TRUE to adjust vectors to unit length:
ggplot(vectors3, aes(x = x, y = y, angle = angle, distance = distance)) +
  geom_vector(normalize = TRUE)

# Using geom_vector2, which adds a default mapping for `length`
ggplot(vectors1, aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_vector2()

</code></pre>

<hr>
<h2 id='geom_vector_field'>Vector Field Layers for ggplot2</h2><span id='topic+geom_vector_field'></span><span id='topic+stat_vector_field'></span><span id='topic+geom_vector_field2'></span><span id='topic+stat_vector_field2'></span>

<h3>Description</h3>

<p>These functions provide convenient ggplot2 layers for drawing vector fields
using streamlines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_vector_field(
  mapping = NULL,
  data = NULL,
  stat = StatStreamField,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = FALSE,
  fun,
  xlim = NULL,
  ylim = NULL,
  n = 11,
  args = list(),
  center = TRUE,
  normalize = TRUE,
  tail_point = FALSE,
  eval_point = FALSE,
  grid = NULL,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  arrow = grid::arrow(angle = 30, length = unit(0.02, "npc"), type = "closed")
)

stat_vector_field(
  mapping = NULL,
  data = NULL,
  stat = StatStreamField,
  geom = GeomStream,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = FALSE,
  fun,
  xlim = NULL,
  ylim = NULL,
  n = 11,
  args = list(),
  center = TRUE,
  normalize = TRUE,
  tail_point = FALSE,
  eval_point = FALSE,
  grid = NULL,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  arrow = grid::arrow(angle = 30, length = unit(0.02, "npc"), type = "closed")
)

geom_vector_field2(
  mapping = NULL,
  data = NULL,
  stat = StatStreamField,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = TRUE,
  inherit.aes = FALSE,
  fun,
  xlim = NULL,
  ylim = NULL,
  n = 11,
  args = list(),
  center = FALSE,
  tail_point = TRUE,
  eval_point = FALSE,
  grid = NULL,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  arrow = NULL
)

stat_vector_field2(
  mapping = NULL,
  data = NULL,
  geom = GeomStream,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = TRUE,
  inherit.aes = FALSE,
  fun,
  xlim = NULL,
  ylim = NULL,
  n = 11,
  args = list(),
  center = FALSE,
  tail_point = TRUE,
  eval_point = FALSE,
  grid = NULL,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  arrow = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_vector_field_+3A_mapping">mapping</code></td>
<td>
<p>A set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>.
Additional aesthetics such as <code>color</code>, <code>size</code>, <code>linetype</code>, and <code>alpha</code> can
be defined. In
<strong>geom_vector_field</strong>, the default mapping includes <code>color = after_stat(norm)</code>,
whereas in <strong>geom_vector_field2</strong> the default mapping includes <code>length = after_stat(norm)</code>.</p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_data">data</code></td>
<td>
<p>A data frame containing the input data.</p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
Defaults to <a href="#topic+StatStreamField">StatStreamField</a>.</p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string or the result of a
call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code>grid::layer()</code>.</p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. If <code>FALSE</code> (the default), missing values are removed
with a warning.</p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical. Should this layer be included in the legends?</p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>Logical. If <code>FALSE</code>, overrides the default aesthetics
rather than combining with them.</p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_fun">fun</code></td>
<td>
<p>A function that defines the vector field. It should take a numeric
vector of length 2 (representing <code class="reqn">(x, y)</code>) and return a numeric vector
of length 2 (representing <code class="reqn">(dx, dy)</code>). <strong>(Required)</strong></p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_xlim">xlim</code></td>
<td>
<p>Numeric vector of length two. Specifies the limits of the x-axis
domain. Defaults to <code>c(-1, 1)</code>.</p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vector of length two. Specifies the limits of the y-axis
domain. Defaults to <code>c(-1, 1)</code>.</p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_n">n</code></td>
<td>
<p>Integer. Grid resolution specifying the number of seed points along
each axis. Higher values produce a denser vector field. Defaults to <code>11</code>.</p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_args">args</code></td>
<td>
<p>List of additional arguments passed on to the function defined by
<code>fun</code>.</p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_center">center</code></td>
<td>
<p>Logical. If <code>TRUE</code>, centers the seed points or the vectors so
that the original (x, y) becomes the midpoint. Defaults differ between the
variants.</p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If <code>TRUE</code>, stream lengths are normalized based on
grid spacing. If <code>FALSE</code>, a default arc length is used. (Default is <code>TRUE</code>;
if <code>TRUE</code>, it is converted internally to <code>"vector"</code>.)</p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_tail_point">tail_point</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a point is drawn at the tail of each
streamline.</p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_eval_point">eval_point</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a point is drawn at the evaluation
point, corresponding to the original (untransformed) seed point before any
centering or normalization is applied.</p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_grid">grid</code></td>
<td>
<p>A data frame containing precomputed grid points for seed
placement. If <code>NULL</code> (default), a regular Cartesian grid is generated based
on <code>xlim</code>, <code>ylim</code>, and <code>n</code>.</p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_arrow">arrow</code></td>
<td>
<p>A <code>grid::arrow()</code> specification to add arrowheads to the
streamlines. In <strong>geom_vector_field</strong>, the default is a closed arrow with a
30° angle and length <code>0.02</code> npc; in <strong>geom_vector_field2</strong> the default is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="geom_vector_field_+3A_geom">geom</code></td>
<td>
<p>The geometric object used to render the streamline (only used in
<code>stat_stream()</code>; defaults to <a href="#topic+GeomStream">GeomStream</a>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A user-defined function (<code>fun</code>) specifies the behavior of the vector field by
taking a numeric vector of length 2 (representing <code class="reqn">(x, y)</code>) and returning
a numeric vector of length 2 (representing <code class="reqn">(dx, dy)</code>). The underlying
<a href="#topic+StatStreamField">StatStreamField</a> computes the streamlines based on the vector field
function, and <a href="#topic+GeomStream">GeomStream</a> renders them.
</p>
<p>Two variants are provided:
</p>

<ul>
<li> <p><strong>geom_vector_field()</strong> uses a default mapping that sets <code>color = after_stat(norm)</code>.
</p>
</li>
<li> <p><strong>geom_vector_field2()</strong> uses a default mapping that sets <code>length = after_stat(norm)</code>
(with <code>color</code> unmapped by default).
</p>
</li></ul>



<h3>Value</h3>

<p>A ggplot2 layer that computes and plots a vector field using
streamlines.
</p>

<dl>
<dt>norm</dt><dd><p>Calculated as the Euclidean distance between the starting point
(<code>x</code>, <code>y</code>) and the computed endpoint. Used to normalize the
vector.</p>
</dd>
</dl>



<h3>Aesthetics</h3>

<p><code>geom_vector_field()</code> and <code>geom_vector_field2()</code>
understand the following aesthetics (required aesthetics are in <strong>bold</strong>):
</p>

<ul>
<li> <p><strong><code>x</code></strong>: The x-coordinate of the vector's starting point.
</p>
</li>
<li> <p><strong><code>y</code></strong>: The y-coordinate of the vector's starting point.
</p>
</li>
<li> <p><strong><code>fx</code></strong>: The horizontal component of the vector displacement.
</p>
</li>
<li> <p><strong><code>fy</code></strong>: The vertical component of the vector displacement.
</p>
</li>
<li> <p><code>color</code>: The color of the vector lines (default mapping in <strong>geom_vector_field</strong>).
</p>
</li>
<li> <p><code>length</code>: The computed vector norm (default mapping in <strong>geom_vector_field2</strong>).
</p>
</li>
<li> <p><code>linetype</code>: The type of the vector line (e.g., solid, dashed).
</p>
</li>
<li> <p><code>linewidth</code>: The thickness of the vector line.
</p>
</li>
<li> <p><code>alpha</code>: The transparency of the vector.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+geom_stream_field">geom_stream_field()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- function(u) c(-u[2], u[1])
ggplot() + geom_vector_field(fun = f, xlim = c(-1,1), ylim = c(-1,1))

# xlim and ylim default to (-1,1), so for ease of illustration we remove them

ggplot() + geom_vector_field(fun = f)
ggplot() + geom_vector_field(fun = f, grid = "hex")

ggplot() + geom_vector_field2(fun = f)
ggplot() + geom_vector_field2(fun = f, grid = "hex")

f &lt;- efield_maker()
ggplot() + geom_vector_field(fun = f, xlim = c(-2,2), ylim = c(-2,2))
ggplot() + geom_vector_field2(fun = f, xlim = c(-2,2), ylim = c(-2,2))


</code></pre>

<hr>
<h2 id='geom_vector_smooth'>Create a Smooth Vector Plot Layer</h2><span id='topic+geom_vector_smooth'></span><span id='topic+stat_vector_smooth'></span><span id='topic+geom_vector_smooth2'></span><span id='topic+stat_vector_smooth2'></span><span id='topic+StatVectorSmooth'></span><span id='topic+GeomVectorSmooth'></span>

<h3>Description</h3>

<p><code>geom_vector_smooth()</code> creates a ggplot2 layer that visualizes a smooth
vector field. It takes raw vector data and applies smoothing (via a
multivariate linear model) to estimate the underlying vector field. This
functionality is analogous to <code>geom_smooth()</code> in ggplot2 but is tailored for
vector data rather than scalar responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_vector_smooth(
  mapping = NULL,
  data = NULL,
  stat = "vector_smooth",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  n = c(11, 11),
  method = "lm",
  se = TRUE,
  se.circle = TRUE,
  pi_type = "ellipse",
  conf_level = c(0.95, NA),
  formula = cbind(fx, fy) ~ x * y,
  eval_points = NULL,
  arrow = grid::arrow(angle = 20, length = unit(0.015, "npc"), type = "closed")
)

GeomVectorSmooth
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_vector_smooth_+3A_mapping">mapping</code></td>
<td>
<p>A set of aesthetic mappings created by <code>ggplot2::aes()</code>.
<strong>Required:</strong> Must include <strong><code>x</code></strong> and <strong><code>y</code></strong>; vector displacements are defined by
<strong><code>fx</code></strong> and <strong><code>fy</code></strong>.</p>
</td></tr>
<tr><td><code id="geom_vector_smooth_+3A_data">data</code></td>
<td>
<p>A data frame containing the raw vector data.</p>
</td></tr>
<tr><td><code id="geom_vector_smooth_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data (default:
<code>"vector_smooth"</code>).</p>
</td></tr>
<tr><td><code id="geom_vector_smooth_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string or the result of a
position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_vector_smooth_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>ggplot2::layer()</code> and the underlying
geometry/stat.</p>
</td></tr>
<tr><td><code id="geom_vector_smooth_+3A_n">n</code></td>
<td>
<p>An integer vector specifying the number of grid points along each
axis for smoothing.</p>
</td></tr>
<tr><td><code id="geom_vector_smooth_+3A_method">method</code></td>
<td>
<p>Character. Specifies the smoothing method. Currently, the only
supported method is <code>"lm"</code>, which fits a multivariate linear model to
predict the vector displacements (<code>fx</code>, <code>fy</code>) from <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="geom_vector_smooth_+3A_se">se</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prediction (confidence) intervals are computed
and plotted.</p>
</td></tr>
<tr><td><code id="geom_vector_smooth_+3A_se.circle">se.circle</code></td>
<td>
<p>Logical. If <code>TRUE</code>, circles are drawn around the origin of
each vector to represent the radius of the prediction interval.</p>
</td></tr>
<tr><td><code id="geom_vector_smooth_+3A_pi_type">pi_type</code></td>
<td>
<p>Character. Determines the display style for prediction
intervals:
</p>

<ul>
<li> <p><code>"wedge"</code> (default): Angular wedges are drawn.
</p>
</li>
<li> <p><code>"ellipse"</code>: Ellipses are used to represent the covariance of the predictions.
If <code>pi_type</code> is set to <code>"ellipse"</code> and <code>eval_points</code> is <code>NULL</code>, it will
revert to <code>"wedge"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_vector_smooth_+3A_conf_level">conf_level</code></td>
<td>
<p>Numeric. Specifies the confidence level for the prediction
intervals. Default is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="geom_vector_smooth_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the multivariate linear model used for
smoothing. The default is <code>cbind(fx, fy) ~ x * y</code>.</p>
</td></tr>
<tr><td><code id="geom_vector_smooth_+3A_eval_points">eval_points</code></td>
<td>
<p>A data frame of evaluation points. If provided, these
specify the grid where the smoothing model is evaluated. If <code>NULL</code>, a grid
is generated based on <code>n</code>.</p>
</td></tr>
<tr><td><code id="geom_vector_smooth_+3A_arrow">arrow</code></td>
<td>
<p>A <code>grid::arrow()</code> specification for arrowheads on the smoothed
vectors.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>GeomVectorSmooth</code> (inherits from <code>GeomSegment</code>, <code>Geom</code>, <code>ggproto</code>, <code>gg</code>) of length 6.
</p>


<h3>Value</h3>

<p>A ggplot2 layer that can be added to a plot to create a smooth vector
field visualization.
</p>


<h3>Aesthetics</h3>

<p><code>geom_vector_smooth()</code> supports the following aesthetics
(required aesthetics are in <strong>bold</strong>):
</p>

<ul>
<li> <p><strong><code>x</code></strong>: The x-coordinate of the vector's starting point.
</p>
</li>
<li> <p><strong><code>y</code></strong>: The y-coordinate of the vector's starting point.
</p>
</li>
<li> <p><strong><code>fx</code></strong>: The horizontal component of the vector displacement.
</p>
</li>
<li> <p><strong><code>fy</code></strong>: The vertical component of the vector displacement.
</p>
</li>
<li> <p><code>color</code>: The color of the vector lines.
</p>
</li>
<li> <p><code>linewidth</code>: The thickness of the vector lines.
</p>
</li>
<li> <p><code>linetype</code>: The type of the vector lines (e.g., solid, dashed).
</p>
</li>
<li> <p><code>alpha</code>: The transparency level of the vectors.
</p>
</li>
<li> <p><code>arrow</code>: An aesthetic that can be used to modify arrowhead properties.
</p>
</li></ul>



<h3>Details</h3>

<p><strong>Multivariate Linear Model:</strong>
The <code>"lm"</code> method fits a multivariate linear model to predict vector
displacements (<code>fx</code> and <code>fy</code>) based on the coordinates <code>x</code> and <code>y</code>, including
interaction terms (<code>x * y</code>). This model smooths the raw vector data to
provide an estimate of the underlying vector field.
</p>
<p><strong>Prediction Intervals:</strong>
When <code>se = TRUE</code>, prediction intervals are computed for the smoothed vectors.
Two types of intervals are supported:
</p>

<ul>
<li> <p><strong>Ellipse:</strong> Ellipses represent the joint uncertainty (covariance) in the predicted <code>fx</code> and <code>fy</code>.
</p>
</li>
<li> <p><strong>Wedge:</strong> Wedges (angular sectors) indicate the range of possible vector directions and magnitudes.
The type of interval displayed is controlled by <code>pi_type</code>, and the confidence
level is set via <code>conf_level</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Function to generate vectors
generate_vectors &lt;- function(v) {
  x &lt;- v[1]
  y &lt;- v[2]
  c(
    sin(x) + sin(y) + rnorm(1, 5, 1),
    sin(x) - sin(y) - rnorm(1, 5, 1)
  )
}

# Set seed for reproducibility
set.seed(123)

# Create sample points and compute vectors
sample_points &lt;- data.frame(
  x = runif(30, 0, 10),
  y = runif(30, 0, 10)
)

result &lt;- t(apply(sample_points, 1, generate_vectors))

sample_points$xend &lt;- result[, 1]
sample_points$yend &lt;- result[, 2]
sample_points$fx &lt;- sample_points$xend - sample_points$x
sample_points$fy &lt;- sample_points$yend - sample_points$y
sample_points$distance &lt;- sqrt(sample_points$fx^2 + sample_points$fy^2)
sample_points$angle &lt;- atan2(sample_points$fy, sample_points$fx)

# Define evaluation points
eval_points &lt;- data.frame(
  x = c(0, 7.5),
  y = c(10, 5)
)

# Example 1:
ggplot(sample_points, aes(x = x, y = y)) +
  geom_vector(aes(fx = fx, fy = fy, color = NULL), center = FALSE, alpha = 0.2) +
  geom_vector_smooth(aes(fx = fx, fy = fy), n = 5) +
  ggtitle("Smoothed Vector Field")

# Example 2: Ellipse with eval_points
ggplot(sample_points, aes(x = x, y = y)) +
  geom_vector(aes(fx = fx, fy = fy, color = NULL), center = FALSE, alpha = 0.2) +
  geom_vector_smooth(aes(fx = fx, fy = fy), eval_points = eval_points, conf_level = c(0.9)) +
  ggtitle("Smoothed Vector Field with Ellipse Intervals")

# Example 3: Wedge with eval_points
ggplot(sample_points, aes(x = x, y = y)) +
  geom_vector(aes(fx = fx, fy = fy, color = NULL), center = FALSE, alpha = 0.2) +
  geom_vector_smooth(aes(fx = fx, fy = fy), eval_points = eval_points, pi_type = "ellipse") +
  ggtitle("Smoothed Vector Field with Wedge Intervals")

</code></pre>

<hr>
<h2 id='grid_hex'>Generate a Hexagonal Lattice</h2><span id='topic+grid_hex'></span>

<h3>Description</h3>

<p>This function generates a hexagonal lattice of points within the given x and
y limits, using a specified hexagon diameter. The diameter is 2 times the
distance between adjacent x (and y) values, see examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_hex(xlim, ylim, d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid_hex_+3A_xlim">xlim</code></td>
<td>
<p>A numeric vector of length 2 specifying the x-axis limits.</p>
</td></tr>
<tr><td><code id="grid_hex_+3A_ylim">ylim</code></td>
<td>
<p>A numeric vector of length 2 specifying the y-axis limits.</p>
</td></tr>
<tr><td><code id="grid_hex_+3A_d">d</code></td>
<td>
<p>A numeric value specifying the hexagon diameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with two columns, <code>x</code> and <code>y</code>, containing the
coordinates of the hexagonal grid points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
xlim &lt;- c(-1, 1)
ylim &lt;- c(-1, 0)

grid &lt;- grid_hex(xlim, ylim, .25)

head( grid )
str( grid )
plot( grid, asp = 1 )

diff(sort(unique(grid$x)))


</code></pre>

<hr>
<h2 id='scale_length_continuous'>Create a Continuous Scale for Vector Length</h2><span id='topic+scale_length_continuous'></span>

<h3>Description</h3>

<p><code><a href="#topic+scale_length_continuous">scale_length_continuous()</a></code> provides a continuous scale for controlling the
length aesthetic in a ggplot. This is particularly useful when working with
vector plots where vector lengths are mapped to a continuous scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_length_continuous(max_range = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_length_continuous_+3A_max_range">max_range</code></td>
<td>
<p>The maximum value to which the input is rescaled. Numeric
scalar specifying the upper bound of the output range. Should be between 0
and 1.</p>
</td></tr>
<tr><td><code id="scale_length_continuous_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>continuous_scale()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>max_range</code> is less than or equal to 0.5 (the default), a
continuous scale object (typically of class <code>"ScaleContinuous"</code>)
mapping the <code>length</code> aesthetic is returned. If <code>max_range</code> is
greater than 0.5, a list is returned with two components:
</p>

<ul>
<li><p> the continuous scale object, and
</p>
</li>
<li><p> a theme modification (a <code>theme</code> object) that adjusts the legend key width based
on the value of <code>max_range</code>.
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
