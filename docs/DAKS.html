<!DOCTYPE html><html><head><title>Help for package DAKS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DAKS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DAKS-package'>
<p>Data Analysis and Knowledge Spaces: The R Package DAKS</p></a></li>
<li><a href='#corr_iita'><p>Corrected Inductive Item Tree Analysis</p></a></li>
<li><a href='#hasse'>
<p>Hasse Diagram of Surmise Relation</p></a></li>
<li><a href='#iita'>
<p>Inductive Item Tree Analysis</p></a></li>
<li><a href='#imp2state'>
<p>Transformation from Implications to Knowledge States</p></a></li>
<li><a href='#ind_gen'><p>Inductive Generation Procedure</p></a></li>
<li><a href='#mini_iita'><p>Minimized Corrected Inductive Item Tree Analysis</p></a></li>
<li><a href='#ob_counter'><p>Computation of Numbers of Counterexamples</p></a></li>
<li><a href='#orig_iita'><p>Original Inductive Item Tree Analysis</p></a></li>
<li><a href='#pattern'><p>Frequencies of Response Patterns and Knowledge States</p></a></li>
<li><a href='#pisa'><p>Programme for International Student Assessment (PISA) Data</p></a></li>
<li><a href='#pop_iita'>
<p>Population Inductive Item Tree Analysis</p></a></li>
<li><a href='#pop_variance'><p>Population Asymptotic Variance</p></a></li>
<li><a href='#print.iita'><p>Print Method for Objects of Class iita</p></a></li>
<li><a href='#print.pat'><p>Print Method for Objects of Class pat</p></a></li>
<li><a href='#print.popiita'><p>Print Method for Objects of Class popiita</p></a></li>
<li><a href='#print.summpopiita'><p>Print Method for Objects of Class summpopiita</p></a></li>
<li><a href='#print.ztest'><p>Print Method for Objects of Class ztest</p></a></li>
<li><a href='#simu'>
<p>Data and Quasi Order Simulation Tool</p></a></li>
<li><a href='#state2imp'>
<p>Transformation from Knowledge States to Implications</p></a></li>
<li><a href='#summary.iita'><p>Summary Method for Objects of Class iita</p></a></li>
<li><a href='#summary.popiita'><p>Summary Method for Objects of Class popiita</p></a></li>
<li><a href='#variance'><p>Estimated Asymptotic Variance</p></a></li>
<li><a href='#z_test'><p>One- and Two-Sample Z-Tests for diff Values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.1-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-06-05</td>
</tr>
<tr>
<td>Title:</td>
<td>Data Analysis and Knowledge Spaces</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions and an example dataset for the psychometric theory of
  knowledge spaces.  This package implements data analysis methods and
  procedures for simulating data and quasi orders and transforming different
  formulations in knowledge space theory.  See package?DAKS for an overview.</td>
</tr>
<tr>
<td>Author:</td>
<td>Ali Uenlue [aut, cre],
  Anatol Sargin [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ali Uenlue &lt;ali.uenlue@tum.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), relations, sets</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.meb.edu.tum.de">http://www.meb.edu.tum.de</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-06-05 21:30:37 UTC; Ali</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-06-06 13:14:35</td>
</tr>
</table>
<hr>
<h2 id='DAKS-package'>
Data Analysis and Knowledge Spaces: The R Package DAKS
</h2><span id='topic+DAKS-package'></span>

<h3>Description</h3>

<p>The package <span class="pkg">DAKS</span> implements three inductive item tree analysis
algorithms for deriving quasi orders from binary data, the original,
corrected, and minimized corrected algorithms.  It provides
functions for computing population and estimated asymptotic
variances of the <em>diff</em> fit measures, and for switching between
test item and knowledge state representations.  Other features are a
Hasse diagram drawing device, a data and quasi order simulation tool
based on a finite mixture latent variable model, and a function for
computing response pattern and knowledge state frequencies.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> <span class="pkg">DAKS</span></td>
</tr>
<tr>
 <td style="text-align: left;">
    Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 2.1-3</td>
</tr>
<tr>
 <td style="text-align: left;">
    Date: </td><td style="text-align: left;"> 2016-06-05</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> <abbr><span class="acronym">GPL</span></abbr> (&gt;= 2)
  </td>
</tr>

</table>

<p>Knowledge space theory is a recent psychometric test theory based on
combinatorial mathematical structures (order and lattice theory);
see <cite>Doignon and Falmagne (1999)</cite>.  Solvability dependencies
between dichotomous test items play an important role in knowledge
space theory.  Utilizing hypothesized dependencies between items,
knowledge space theory has been successfully applied for the
computerized, adaptive assessment and training of knowledge.  For
instance, see the <abbr><span class="acronym">ALEKS</span></abbr> system, a fully automated math
tutor on the Internet (<a href="http://www.aleks.com/">http://www.aleks.com/</a>).
</p>
<p>The package <span class="pkg">DAKS</span> is implemented based on the S3 system.  It
comes with a namespace and consists of the following functions (all
functions are external, there are no internal functions):
<code><a href="#topic+corr_iita">corr_iita</a></code>, <code><a href="#topic+hasse">hasse</a></code>, <code><a href="#topic+iita">iita</a></code>,
<code><a href="#topic+imp2state">imp2state</a></code>, <code><a href="#topic+ind_gen">ind_gen</a></code>,
<code><a href="#topic+mini_iita">mini_iita</a></code>, <code><a href="#topic+ob_counter">ob_counter</a></code>,
<code><a href="#topic+orig_iita">orig_iita</a></code>, <code><a href="#topic+pattern">pattern</a></code>,
<code><a href="#topic+pop_iita">pop_iita</a></code>, <code><a href="#topic+pop_variance">pop_variance</a></code>,
<code><a href="#topic+print.iita">print.iita</a></code>, <code><a href="#topic+print.pat">print.pat</a></code>,
<code><a href="#topic+print.popiita">print.popiita</a></code>, <code><a href="#topic+print.summpopiita">print.summpopiita</a></code>,
<code><a href="#topic+print.ztest">print.ztest</a></code>, <code><a href="#topic+simu">simu</a></code>, <code><a href="#topic+state2imp">state2imp</a></code>,
<code><a href="#topic+summary.iita">summary.iita</a></code>, <code><a href="#topic+summary.popiita">summary.popiita</a></code>,
<code><a href="#topic+variance">variance</a></code>, and <code><a href="#topic+z_test">z_test</a></code>.  There is an empirical
dataset, <code><a href="#topic+pisa">pisa</a></code>, accompanying the package <span class="pkg">DAKS</span>.  This
dataset is part of the 2003 Programme for International Student
Assessment (PISA; <a href="http://www.pisa.oecd.org/">http://www.pisa.oecd.org/</a>).
</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>
<p>Maintainer: Ali Uenlue <a href="mailto:ali.uenlue@tum.de">ali.uenlue@tum.de</a>
</p>


<h3>References</h3>

<p>Doignon, J.-P. and Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>.
Berlin, Heidelberg, and New York: Springer-Verlag.
</p>
<p>Sargin, A. and Uenlue, A. (2009) Inductive item tree analysis:
Corrections, improvements, and comparisons. <em>Mathematical Social Sciences</em>, <b>58</b>, 376&ndash;392.
</p>
<p>Schrepp, M. (1999) On the empirical construction of implications
between bi-valued test items. <em>Mathematical Social Sciences</em>,
<b>38</b>, 361&ndash;375.
</p>
<p>Schrepp, M. (2003) A method for the analysis of hierarchical
dependencies between items of a questionnaire. <em>Methods of
Psychological Research</em>, <b>19</b>, 43&ndash;79.
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>

<hr>
<h2 id='corr_iita'>Corrected Inductive Item Tree Analysis</h2><span id='topic+corr_iita'></span>

<h3>Description</h3>

<p><code>corr_iita</code> performs the corrected inductive item tree analysis 
procedure and returns the corresponding <em>diff</em> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_iita(dataset, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_iita_+3A_dataset">dataset</code></td>
<td>
<p>a required data frame or matrix consisting of binary,
<code class="reqn">1</code> or <code class="reqn">0</code>, numeric data.</p>
</td></tr>
<tr><td><code id="corr_iita_+3A_a">A</code></td>
<td>
<p>a required list of competing quasi orders (surmise
relations), for instance obtained from a call to
<code><a href="#topic+ind_gen">ind_gen</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Corrected inductive item tree analysis is a data analysis method for
deriving knowledge structures (more precisely, surmise relations)
from binary data.  Details on this procedure can be found in
<code><a href="#topic+iita">iita</a></code>.  The set of competing quasi orders is passed via
the argument <code>A</code>, so any selection set of quasi orders can be
used.
</p>
<p>The set of competing quasi orders must be a list of objects of the
class <code><a href="sets.html#topic+set">set</a></code>.  These objects (quasi orders) consist
of <code class="reqn">2</code>-tuples <code class="reqn">(i, j)</code> of the class
<code><a href="sets.html#topic+tuple">tuple</a></code>,  where a <code class="reqn">2</code>-tuple <code class="reqn">(i, j)</code> is
interpreted as 'mastering item <code class="reqn">j</code> implies mastering item
<code class="reqn">i</code>.'
</p>
<p>The data must contain only ones and zeros, which encode solving or
failing to solve an item, respectively.
</p>


<h3>Value</h3>

<p>If the arguments <code>dataset</code> and <code>A</code> are of required types,
<code>corr_iita</code> returns a named list of the following components:
</p>
<table>
<tr><td><code>diff.value</code></td>
<td>
<p>a vector of the <em>diff</em> values
corresponding to the competing quasi orders in <code>A</code>.</p>
</td></tr>
<tr><td><code>error.rate</code></td>
<td>
<p>a vector of the error rates corresponding to the competing quasi orders in <code>A</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function <code><a href="#topic+iita">iita</a></code> can be used to perform one of the
three inductive item tree analysis procedures (including the
corrected inductive item tree analysis method) selectively.  Whereas
for the function <code>corr_iita</code> a selection set of competing quasi
orders has to be passed via the argument <code>A</code> manually,
<code>iita</code> automatically generates a selection set from the data
using the inductive generation procedure implemented in
<code><a href="#topic+ind_gen">ind_gen</a></code>.
</p>
<p>The latter approach using <code><a href="#topic+iita">iita</a></code> is common so far, in
knowledge space theory, where the inductive data analysis methods
have been utilized for exploratory derivations of surmise relations
from data.  The function <code>corr_iita</code>, on the other hand, can be
used to select among surmise relations for instance obtained from
querying experts or from competing psychological theories.
</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Sargin, A. and Uenlue, A. (2009) Inductive item tree analysis:
Corrections, improvements, and comparisons. <em>Mathematical Social
Sciences</em>, <b>58</b>, 376&ndash;392.
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orig_iita">orig_iita</a></code> for original inductive item tree analysis;
<code><a href="#topic+mini_iita">mini_iita</a></code> for minimized corrected inductive item tree
analysis; <code><a href="#topic+iita">iita</a></code>, the interface that provides the three
inductive item tree analysis methods under one umbrella;
<code><a href="#topic+pop_variance">pop_variance</a></code> for population asymptotic variances of
<em>diff</em> coefficients; <code><a href="#topic+variance">variance</a></code> for estimated
asymptotic variances of <em>diff</em> coefficients;
<code><a href="#topic+pop_iita">pop_iita</a></code> for population inductive item tree analysis.
See also <code><a href="#topic+DAKS-package">DAKS-package</a></code> for general information about
this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ind &lt;- ind_gen(ob_counter(pisa))
corr_iita(pisa, ind)
</code></pre>

<hr>
<h2 id='hasse'>
Hasse Diagram of Surmise Relation
</h2><span id='topic+hasse'></span>

<h3>Description</h3>

<p><code>hasse</code> plots the Hasse diagram of a surmise relation (more
precisely, of its corresponding quotient set).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasse(imp, items)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasse_+3A_imp">imp</code></td>
<td>
<p>a required object of class <code><a href="sets.html#topic+set">set</a></code>
representing the set of implications, for instance obtained from a
call to <code><a href="#topic+iita">iita</a></code>.</p>
</td></tr>
<tr><td><code id="hasse_+3A_items">items</code></td>
<td>
<p>a required numeric giving the number of items of the
domain taken as basis for <code>imp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the arguments <code>imp</code> and <code>items</code> are of required types,
<code>hasse</code> produces a plot, and returns a list of the equally
informative items.
</p>


<h3>Note</h3>

<p>The function <code>hasse</code> is not capable of plotting equally
informative items.  This is why equally informative items are
returned in a list.
</p>
<p>A set of implications, an object of the class
<code><a href="sets.html#topic+set">set</a></code>, consists of <code class="reqn">2</code>-tuples <code class="reqn">(i, j)</code> of
the class <code><a href="sets.html#topic+tuple">tuple</a></code>, where a <code class="reqn">2</code>-tuple
<code class="reqn">(i, j)</code> is interpreted as 'mastering item <code class="reqn">j</code> implies
mastering item <code class="reqn">i</code>.'
</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Doignon, J.-P. and Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>.
Berlin, Heidelberg, and New York: Springer-Verlag.
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iita">iita</a></code>, the interface that provides the three
inductive item tree analysis methods under one umbrella. See also
<code><a href="#topic+DAKS-package">DAKS-package</a></code> for general information about this
package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## requires the package Rgraphviz from Bioconductor
## users must have installed Graphviz on their computers
## Not run: 
hasse(iita(pisa, v = 2)$implications, 5)

## End(Not run)
</code></pre>

<hr>
<h2 id='iita'>
Inductive Item Tree Analysis
</h2><span id='topic+iita'></span>

<h3>Description</h3>

<p><code>iita</code> can be used to perform one of the three inductive item
tree analysis algorithms (original, corrected, and minimized
corrected) selectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iita(dataset, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iita_+3A_dataset">dataset</code></td>
<td>
<p>a required data frame or matrix consisting of binary,
<code class="reqn">1</code> or <code class="reqn">0</code>, numeric data.</p>
</td></tr>
<tr><td><code id="iita_+3A_v">v</code></td>
<td>
<p>a required numeric giving the inductive item tree analysis
algorithm to be performed; <code>v = 1</code> (minimized corrected),
<code>v = 2</code> (corrected), and <code>v = 3</code> (original).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The three inductive item tree analysis algorithms are exploratory
methods for extracting quasi orders (surmise relations) from data.
In each algorithm, competing binary relations are generated (in the
same way for all three versions), and a fit measure (differing from
version to version) is computed for every relation of the selection
set in order to find the quasi order that fits the data best.  In
all three algorithms, the idea is to estimate the numbers of
counterexamples for each quasi order, and to find, over all
competing quasi orders, the minimum value for the discrepancy
between the observed and expected numbers of counterexamples.  The
three data analysis methods differ in their choices of estimates for
the expected numbers of counterexamples.  (For an item pair
<code class="reqn">(i, j)</code>, the number of subjects solving item <code class="reqn">j</code> but
failing to solve item <code class="reqn">i</code>, is the corresponding number of
counterexamples.  Their response patterns contradict the
interpretation of <code class="reqn">(i, j)</code> as 'mastering item <code class="reqn">j</code> implies
mastering item <code class="reqn">i</code>.') The algorithms are described in the paper
about the <span class="pkg">DAKS</span> package by <cite>Uenlue and Sargin (2010)</cite>, and
in the paper by <cite>Sargin and Uenlue (2009)</cite>.
</p>
<p><code>iita</code> calls <code><a href="#topic+ind_gen">ind_gen</a></code> for constructing the set of
competing quasi orders according to the inductive generation
procedure.  Subject to the selected version to be performed,
<code>iita</code> computes the discrepancies between observed and expected
numbers of counterexamples under each relation, and finds a quasi
order with the minimum discrepancy (<em>diff</em>) value.
</p>
<p>A set of implications, an object of the class
<code><a href="sets.html#topic+set">set</a></code>, consists of <code class="reqn">2</code>-tuples <code class="reqn">(i, j)</code> of
the class <code><a href="sets.html#topic+tuple">tuple</a></code>, where a <code class="reqn">2</code>-tuple
<code class="reqn">(i, j)</code> is interpreted as 'mastering item <code class="reqn">j</code> implies
mastering item <code class="reqn">i</code>.'
</p>
<p>The data must contain only ones and zeros, which encode solving or
failing to solve an item, respectively.
</p>


<h3>Value</h3>

<p>If the arguments <code>dataset</code> and <code>v</code> are of required types,
<code>iita</code> returns a named list consisting of the following five
components:
</p>
<table>
<tr><td><code>diff</code></td>
<td>
<p>a vector giving the <em>diff</em> values corresponding to
the (inductively generated) competing quasi orders.</p>
</td></tr>
<tr><td><code>implications</code></td>
<td>
<p>an object of class <code><a href="sets.html#topic+set">set</a></code>
representing the solution quasi order (with smallest <em>diff</em>
value) under the selected algorithm.</p>
</td></tr>
<tr><td><code>error.rate</code></td>
<td>
<p>a value giving the estimated error rate corresponding to the best fitting quasi order.</p>
</td></tr>
<tr><td><code>selection.set.index</code></td>
<td>
<p>a numeric giving the index of the
solution quasi order in the selection set.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>the version used; <code>v = 1</code> (minimized corrected),
<code>v = 2</code> (corrected), and <code>v = 3</code> (original).</p>
</td></tr> 
</table>


<h3>Note</h3>

<p>The function <code><a href="#topic+iita">iita</a></code> can be used to perform one of the
three inductive item tree analysis procedures selectively.  Whereas
for the functions <code><a href="#topic+orig_iita">orig_iita</a></code>, <code><a href="#topic+corr_iita">corr_iita</a></code>,
<code><a href="#topic+mini_iita">mini_iita</a></code> selection sets of competing quasi orders
have to be passed via an argument manually, <code>iita</code>
automatically generates a selection set from the data using the
inductive generation procedure implemented in <code><a href="#topic+ind_gen">ind_gen</a></code>.
</p>
<p>The latter approach using <code>iita</code> is common so far, in knowledge
space theory, where the inductive data analysis methods have been
utilized for exploratory derivations of surmise relations from data. 
The functions <code><a href="#topic+orig_iita">orig_iita</a></code>, <code><a href="#topic+corr_iita">corr_iita</a></code>,
<code><a href="#topic+mini_iita">mini_iita</a></code>, on the other hand, can be used to select
among surmise relations for instance obtained from querying experts
or from competing psychological theories.
</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Sargin, A. and Uenlue, A. (2009) Inductive item tree analysis:
Corrections, improvements, and comparisons. <em>Mathematical Social Sciences</em>, <b>58</b>, 376&ndash;392.
</p>
<p>Schrepp, M. (1999) On the empirical construction of implications
between bi-valued test items. <em>Mathematical Social Sciences</em>,
<b>38</b>, 361&ndash;375.
</p>
<p>Schrepp, M. (2003) A method for the analysis of hierarchical
dependencies between items of a questionnaire. <em>Methods of
Psychological Research</em>, <b>19</b>, 43&ndash;79.
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orig_iita">orig_iita</a></code> for original inductive item tree analysis;
<code><a href="#topic+corr_iita">corr_iita</a></code> for corrected inductive item tree analysis;
<code><a href="#topic+mini_iita">mini_iita</a></code> for minimized corrected inductive item tree
analysis; <code><a href="#topic+ind_gen">ind_gen</a></code> for inductive generation procedure;
<code><a href="#topic+pop_variance">pop_variance</a></code> for population asymptotic variances of
<em>diff</em> coefficients; <code><a href="#topic+variance">variance</a></code> for estimated
asymptotic variances of <em>diff</em> coefficients; <code><a href="#topic+z_test">z_test</a></code> for one- and two-sample Z-tests; 
<code><a href="#topic+pop_iita">pop_iita</a></code> for population inductive item tree analysis.
See also <code><a href="#topic+DAKS-package">DAKS-package</a></code> for general information about
this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iita(pisa, v = 1)
iita(pisa, v = 3)
</code></pre>

<hr>
<h2 id='imp2state'>
Transformation from Implications to Knowledge States
</h2><span id='topic+imp2state'></span>

<h3>Description</h3>

<p><code>imp2state</code> transforms a set of implications (ought to be
a surmise relation) to the corresponding set of knowledge states
(the quasi ordinal knowledge space).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imp2state(imp, items)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imp2state_+3A_imp">imp</code></td>
<td>
<p>a required object of class <code><a href="sets.html#topic+set">set</a></code>
representing the set of implications, for instance obtained from a
call to <code><a href="#topic+iita">iita</a></code>.</p>
</td></tr>
<tr><td><code id="imp2state_+3A_items">items</code></td>
<td>
<p>a required numeric giving the number of items of the
domain taken as basis for <code>imp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the arguments <code>imp</code> and <code>items</code> are of required types,
<code>imp2state</code> returns a matrix consisting of ones or zeros (the
quasi ordinal knowledge space), in which each row represents the
<code class="reqn">1</code>/<code class="reqn">0</code>-pattern of a knowledge state.
</p>


<h3>Note</h3>

<p>For any set of implications the returned knowledge structure is a
quasi ordinal knowledge space.  In case of a surmise relation this
is Birkhoff's theorem.  For details refer to <cite>Doignon and
Falmagne (1999, Theorem 1.49)</cite>.
</p>
<p>A set of implications, an object of the class
<code><a href="sets.html#topic+set">set</a></code>, consists of <code class="reqn">2</code>-tuples <code class="reqn">(i, j)</code> of
the class <code><a href="sets.html#topic+tuple">tuple</a></code>, where a <code class="reqn">2</code>-tuple
<code class="reqn">(i, j)</code> is interpreted as 'mastering item <code class="reqn">j</code> implies
mastering item <code class="reqn">i</code>.'
</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Doignon, J.-P. and Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>.
Berlin, Heidelberg, and New York: Springer-Verlag.
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+state2imp">state2imp</a></code> for transformation from knowledge states to
implications.  See also <code><a href="#topic+DAKS-package">DAKS-package</a></code> for general
information about this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- iita(pisa, v = 1)
imp2state(x$implications, ncol(pisa))
</code></pre>

<hr>
<h2 id='ind_gen'>Inductive Generation Procedure</h2><span id='topic+ind_gen'></span>

<h3>Description</h3>

<p><code>ind_gen</code> generates inductively a set of competing quasi
orders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_gen(b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ind_gen_+3A_b">b</code></td>
<td>
<p>a required matrix of the numbers of counterexamples for all
pairs of items, for instance obtained from a call to
<code><a href="#topic+ob_counter">ob_counter</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the argument <code>b</code> is of required type, <code>ind_gen</code> returns
a list of the inductively generated quasi orders.
</p>


<h3>Note</h3>

<p>The function <code><a href="#topic+iita">iita</a></code> calls <code><a href="#topic+ind_gen">ind_gen</a></code> for
constructing the set of competing quasi orders according to the
inductive generation procedure.
</p>
<p>The set of competing quasi orders is a list of objects of the class
<code><a href="sets.html#topic+set">set</a></code>.  These objects (quasi orders) consist of
<code class="reqn">2</code>-tuples <code class="reqn">(i, j)</code> of the class <code><a href="sets.html#topic+tuple">tuple</a></code>,
where a <code class="reqn">2</code>-tuple <code class="reqn">(i, j)</code> is interpreted as 'mastering item
<code class="reqn">j</code> implies mastering item <code class="reqn">i</code>.'
</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Sargin, A. and Uenlue, A. (2009) Inductive item tree analysis:
Corrections, improvements, and comparisons. <em>Mathematical Social Sciences</em>, <b>58</b>, 376&ndash;392.
</p>
<p>Schrepp, M. (1999) On the empirical construction of implications
between bi-valued test items. <em>Mathematical Social Sciences</em>,
<b>38</b>, 361&ndash;375.
</p>
<p>Schrepp, M. (2003) A method for the analysis of hierarchical
dependencies between items of a questionnaire. <em>Methods of
Psychological Research</em>, <b>19</b>, 43&ndash;79.
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ob_counter">ob_counter</a></code> for computation of numbers of
counterexamples; <code><a href="#topic+iita">iita</a></code>, the interface that provides the
three inductive item tree analysis methods under one umbrella;
<code><a href="#topic+z_test">z_test</a></code> for one- and two-sample Z-tests.  See
also <code><a href="#topic+DAKS-package">DAKS-package</a></code> for general information about this
package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ob &lt;- ob_counter(pisa)
ind_gen(ob)
</code></pre>

<hr>
<h2 id='mini_iita'>Minimized Corrected Inductive Item Tree Analysis</h2><span id='topic+mini_iita'></span>

<h3>Description</h3>

<p><code>mini_iita</code> performs the minimized corrected inductive item
tree analysis procedure and returns the corresponding <em>diff</em>
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mini_iita(dataset, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mini_iita_+3A_dataset">dataset</code></td>
<td>
<p>a required data frame or matrix consisting of binary,
<code class="reqn">1</code> or <code class="reqn">0</code>, numeric data.</p>
</td></tr>
<tr><td><code id="mini_iita_+3A_a">A</code></td>
<td>
<p>a required list of competing quasi orders (surmise
relations), for instance obtained from a call to
<code><a href="#topic+ind_gen">ind_gen</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Minimized corrected inductive item tree analysis is a data analysis
method for deriving knowledge structures (more precisely, surmise
relations) from binary data.  Details on this procedure can be found
in <code><a href="#topic+iita">iita</a></code>.  The set of competing quasi orders is passed
via the argument <code>A</code>, so any selection set of quasi orders can
be used.
</p>
<p>The set of competing quasi orders must be a list of objects of the
class <code><a href="sets.html#topic+set">set</a></code>.  These objects (quasi orders) consist
of <code class="reqn">2</code>-tuples <code class="reqn">(i, j)</code> of the class
<code><a href="sets.html#topic+tuple">tuple</a></code>,  where a <code class="reqn">2</code>-tuple <code class="reqn">(i, j)</code> is
interpreted as 'mastering item <code class="reqn">j</code> implies mastering item
<code class="reqn">i</code>.'
</p>
<p>The data must contain only ones and zeros, which encode solving or
failing to solve an item, respectively.
</p>


<h3>Value</h3>

<p>If the arguments <code>dataset</code> and <code>A</code> are of required types,
<code>corr_iita</code> returns a named list of the following components:
</p>
<table>
<tr><td><code>diff.value</code></td>
<td>
<p>a vector of the <em>diff</em> values
corresponding to the competing quasi orders in <code>A</code>.</p>
</td></tr>
<tr><td><code>error.rate</code></td>
<td>
<p>a vector of the error rates corresponding to the competing quasi orders in <code>A</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function <code><a href="#topic+iita">iita</a></code> can be used to perform one of the
three inductive item tree analysis procedures (including the
minimized corrected inductive item tree analysis method)
selectively.  Whereas for the function <code>mini_iita</code> a selection
set of competing quasi orders has to be passed via the argument
<code>A</code> manually, <code>iita</code> automatically generates a selection
set from the data using the inductive generation procedure
implemented in <code><a href="#topic+ind_gen">ind_gen</a></code>.
</p>
<p>The latter approach using <code><a href="#topic+iita">iita</a></code> is common so far, in
knowledge space theory, where the inductive data analysis methods
have been utilized for exploratory derivations of surmise relations
from data.  The function <code>mini_iita</code>, on the other hand, can be
used to select among surmise relations for instance obtained from
querying experts or from competing psychological theories.
</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Sargin, A. and Uenlue, A. (2009) Inductive item tree analysis:
Corrections, improvements, and comparisons. <em>Mathematical Social Sciences</em>, <b>58</b>, 376&ndash;392.
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orig_iita">orig_iita</a></code> for original inductive item tree analysis;
<code><a href="#topic+corr_iita">corr_iita</a></code> for corrected inductive item tree analysis;
<code><a href="#topic+iita">iita</a></code>, the interface that provides the three inductive
item tree analysis methods under one umbrella;
<code><a href="#topic+pop_variance">pop_variance</a></code> for population asymptotic variances of
<em>diff</em> coefficients; <code><a href="#topic+variance">variance</a></code> for estimated
asymptotic variances of <em>diff</em> coefficients;
<code><a href="#topic+pop_iita">pop_iita</a></code> for population inductive item tree analysis.
See also <code><a href="#topic+DAKS-package">DAKS-package</a></code> for general information about
this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ind &lt;- ind_gen(ob_counter(pisa))
mini_iita(pisa, ind)
</code></pre>

<hr>
<h2 id='ob_counter'>Computation of Numbers of Counterexamples</h2><span id='topic+ob_counter'></span>

<h3>Description</h3>

<p><code>ob_counter</code> computes from a dataset for all item pairs the
corresponding numbers of counterexamples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ob_counter(dataset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ob_counter_+3A_dataset">dataset</code></td>
<td>
<p>a required data frame or matrix consisting of binary,
<code class="reqn">1</code> or <code class="reqn">0</code>, numeric data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an item pair <code class="reqn">(i, j)</code>, the number of subjects solving item
<code class="reqn">j</code> but failing to solve item <code class="reqn">i</code>, is the corresponding
number of counterexamples.  Their response patterns contradict the
interpretation of <code class="reqn">(i, j)</code> as 'mastering item <code class="reqn">j</code> implies
mastering item <code class="reqn">i</code>.'
</p>
<p>The data must contain only ones and zeros, which encode solving or
failing to solve an item, respectively.
</p>


<h3>Value</h3>

<p>If the argument <code>dataset</code> is of required type,
<code>ob_counter</code> returns a matrix of the numbers of counterexamples 
for all pairs of items.
</p>


<h3>Note</h3>

<p>The function <code>ind_gen</code> can be used to inductively generate from
the returned matrix of the numbers of counterexamples a set of quasi
orders.
</p>
<p>The function <code><a href="#topic+iita">iita</a></code> calls <code><a href="#topic+ob_counter">ob_counter</a></code>.
</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Sargin, A. and Uenlue, A. (2009) Inductive item tree analysis:
Corrections, improvements, and comparisons. <em>Mathematical Social Sciences</em>, <b>58</b>, 376&ndash;392.
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ind_gen">ind_gen</a></code> for inductive generation procedure using
numbers of counterexamples; <code><a href="#topic+iita">iita</a></code>, the interface that
provides the three inductive item tree analysis methods under one
umbrella. See also <code><a href="#topic+DAKS-package">DAKS-package</a></code> for general
information about this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ob_counter(pisa)
</code></pre>

<hr>
<h2 id='orig_iita'>Original Inductive Item Tree Analysis </h2><span id='topic+orig_iita'></span>

<h3>Description</h3>

<p><code>orig_iita</code> performs the original inductive item tree analysis
procedure and returns the corresponding <em>diff</em> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orig_iita(dataset, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orig_iita_+3A_dataset">dataset</code></td>
<td>
<p>a required data frame or matrix consisting of binary,
<code class="reqn">1</code> or <code class="reqn">0</code>, numeric data.</p>
</td></tr>
<tr><td><code id="orig_iita_+3A_a">A</code></td>
<td>
<p>a required list of competing quasi orders (surmise
relations), for instance obtained from a call to
<code><a href="#topic+ind_gen">ind_gen</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Original inductive item tree analysis is a data analysis method for
deriving knowledge structures (more precisely, surmise relations)
from binary data.  Details on this procedure can be found in
<code><a href="#topic+iita">iita</a></code>.  The set of competing quasi orders is passed via
the argument <code>A</code>, so any selection set of quasi orders can be
used.
</p>
<p>The set of competing quasi orders must be a list of objects of the
class <code><a href="sets.html#topic+set">set</a></code>.  These objects (quasi orders) consist
of <code class="reqn">2</code>-tuples <code class="reqn">(i, j)</code> of the class
<code><a href="sets.html#topic+tuple">tuple</a></code>,  where a <code class="reqn">2</code>-tuple <code class="reqn">(i, j)</code> is
interpreted as 'mastering item <code class="reqn">j</code> implies mastering item
<code class="reqn">i</code>.'
</p>
<p>The data must contain only ones and zeros, which encode solving or
failing to solve an item, respectively.
</p>


<h3>Value</h3>

<p>If the arguments <code>dataset</code> and <code>A</code> are of required types,
<code>corr_iita</code> returns a named list of the following components:
</p>
<table>
<tr><td><code>diff.value</code></td>
<td>
<p>a vector of the <em>diff</em> values
corresponding to the competing quasi orders in <code>A</code>.</p>
</td></tr>
<tr><td><code>error.rate</code></td>
<td>
<p>a vector of the error rates corresponding to the competing quasi orders in <code>A</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function <code><a href="#topic+iita">iita</a></code> can be used to perform one of the
three inductive item tree analysis procedures (including the
original inductive item tree analysis method) selectively.  Whereas
for the function <code>orig_iita</code> a selection set of competing quasi
orders has to be passed via the argument <code>A</code> manually,
<code>iita</code> automatically generates a selection set from the data
using the inductive generation procedure implemented in
<code><a href="#topic+ind_gen">ind_gen</a></code>.
</p>
<p>The latter approach using <code><a href="#topic+iita">iita</a></code> is common so far, in
knowledge space theory, where the inductive data analysis methods
have been utilized for exploratory derivations of surmise relations
from data.  The function <code>orig_iita</code>, on the other hand, can be
used to select among surmise relations for instance obtained from
querying experts or from competing psychological theories.
</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Sargin, A. and Uenlue, A. (2009) Inductive item tree analysis:
Corrections, improvements, and comparisons. <em>Mathematical Social Sciences</em>, <b>58</b>, 376&ndash;392.
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corr_iita">corr_iita</a></code> for corrected inductive item tree analysis;
<code><a href="#topic+mini_iita">mini_iita</a></code> for minimized corrected inductive item tree
analysis; <code><a href="#topic+iita">iita</a></code>, the interface that provides the three
inductive item tree analysis methods under one umbrella;
<code><a href="#topic+pop_variance">pop_variance</a></code> for population asymptotic variances of
<em>diff</em> coefficients; <code><a href="#topic+variance">variance</a></code> for estimated
asymptotic variances of <em>diff</em> coefficients;
<code><a href="#topic+pop_iita">pop_iita</a></code> for population inductive item tree analysis.
See also <code><a href="#topic+DAKS-package">DAKS-package</a></code> for general information about
this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ind &lt;- ind_gen(ob_counter(pisa))
orig_iita(pisa, ind)
</code></pre>

<hr>
<h2 id='pattern'>Frequencies of Response Patterns and Knowledge States</h2><span id='topic+pattern'></span>

<h3>Description</h3>

<p><code>pattern</code> computes the absolute frequencies of the (occurring)
response patterns, and optionally, the absolute frequencies of a
collection of specified knowledge states in a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pattern(dataset, n = 5, P = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pattern_+3A_dataset">dataset</code></td>
<td>
<p>a required data frame or matrix consisting of binary,
<code class="reqn">1</code> or <code class="reqn">0</code>, numeric data.</p>
</td></tr>
<tr><td><code id="pattern_+3A_n">n</code></td>
<td>
<p>an optional numeric, with default <code>n = 5</code>, giving the
<code class="reqn">n</code> highest frequencies and their corresponding response
patterns to be returned.</p>
</td></tr>
<tr><td><code id="pattern_+3A_p">P</code></td>
<td>
<p>an optional matrix of ones and zeros giving the knowledge
states to be used.  The default <code>P = NULL</code> corresponds to no
knowledge states being specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to retrieve information about how often
response patterns and knowledge states occur in a dataset.  The
argument <code>n</code> refers to response patterns, not knowledge states,
and in particular is independent of specifications of the argument
<code>P</code>.  If <code>pattern</code> is called without specifying <code class="reqn">n</code>
explicitly, the response patterns with the five highest frequencies
are returned (along with their frequencies).  If <code class="reqn">n</code> is
specified, the response patterns with the <code class="reqn">n</code> highest
frequencies are returned (along with their frequencies).  If <code class="reqn">n</code>
is larger than the number of different response patterns in the
dataset, <code class="reqn">n</code> is set the number of different response patterns.
</p>
<p>The knowledge states are represented as <code class="reqn">1</code>/<code class="reqn">0</code>-patterns and
are the rows of the argument matrix <code>P</code>.  The matrix <code>P</code>
must contain only ones and zeros, which encode whether or not an
item belongs to a knowledge state, respectively.  If <code>P</code> is not
specified, <code>pattern</code> only returns information about response
patterns (as described previously).
</p>
<p>The data must contain only ones and zeros, which encode solving or
failing to solve an item, respectively.
</p>


<h3>Value</h3>

<p>If the arguments <code>dataset</code>, <code>n</code>, and <code>P</code> are of
required types, <code>pattern</code> returns a named list consisting of
the following three components:
</p>
<table>
<tr><td><code>response.patterns</code></td>
<td>
<p>an array giving the response patterns (with
the <code class="reqn">n</code> highest frequencies) and their absolute frequencies in 
<code>dataset</code>.</p>
</td></tr>
<tr><td><code>states</code></td>
<td>
<p>a matrix of the knowledge states and their absolute
frequencies in <code>dataset</code>.  Each row represents a knowledge
state, the last column gives the frequencies of the states.  If
<code>P = NULL</code>, the component <code>states</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>a numeric giving the number of response patterns that are
returned.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Although <code>pattern</code> is intended for use with dichotomous data, it
also works with polytomously scored items.
</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Sargin, A. and Uenlue, A. (2009) Inductive item tree analysis:
Corrections, improvements, and comparisons. <em>Mathematical Social Sciences</em>, <b>58</b>, 376&ndash;392.
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ob_counter">ob_counter</a></code> for computation of numbers of
counterexamples; <code><a href="#topic+simu">simu</a></code> for data simulation tool;
<code><a href="#topic+iita">iita</a></code>, the interface that provides the three inductive
item tree analysis methods under one umbrella.  See also
<code><a href="#topic+DAKS-package">DAKS-package</a></code> for general information about this
package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pattern(pisa, n = 3)
pattern(pisa)
</code></pre>

<hr>
<h2 id='pisa'>Programme for International Student Assessment (PISA) Data</h2><span id='topic+pisa'></span>

<h3>Description</h3>

<p>The accompanying binary dataset is part of the empirical 2003
Programme for International Student Assessment (PISA) data.  It
contains the item responses by <code class="reqn">340</code> German students on a
<code class="reqn">5</code>-item dichotomously scored mathematical literacy test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pisa
</code></pre>


<h3>Format</h3>

<p>The <code>pisa</code> data frame consists of <code class="reqn">340</code> rows and <code class="reqn">5</code>
columns, representing the response patterns of the students to the
test items.  Each number, an integer, <code class="reqn">1</code> or <code class="reqn">0</code>, encodes a
correct or incorrect response, respectively.
</p>


<h3>Note</h3>

<p>The dataset <code>pisa</code> was obtained after dichotomizing the
original multiple-choice or open format test data.  Wording of the
test items used in the assessment is not known (not available
publicly).
</p>


<h3>Source</h3>

<p>OECD Programme for International Student Assessment (PISA;
<a href="http://www.pisa.oecd.org/">http://www.pisa.oecd.org/</a>)
</p>


<h3>References</h3>

<p>Sargin, A. and Uenlue, A. (2009) Inductive item tree analysis:
Corrections, improvements, and comparisons. <em>Mathematical Social Sciences</em>, <b>58</b>, 376&ndash;392.
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+DAKS-package">DAKS-package</a></code> for general information about this
package.
</p>

<hr>
<h2 id='pop_iita'>
Population Inductive Item Tree Analysis
</h2><span id='topic+pop_iita'></span>

<h3>Description</h3>

<p><code>pop_iita</code> can be used to perform one of the three inductive
item tree analysis algorithms (original, corrected, and minimized
corrected) in population quantities (in a known population)
selectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop_iita(imp, ce, lg, items, dataset = NULL, A = NULL, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop_iita_+3A_imp">imp</code></td>
<td>
<p>a required object of class <code><a href="sets.html#topic+set">set</a></code>
representing the underlying set of implications (assumed to be a
quasi order), for instance obtained from a call to
<code><a href="#topic+iita">iita</a></code>.</p>
</td></tr>
<tr><td><code id="pop_iita_+3A_ce">ce</code></td>
<td>
<p>a required numeric giving the probability for a careless
error.</p>
</td></tr>
<tr><td><code id="pop_iita_+3A_lg">lg</code></td>
<td>
<p>a required numeric giving the probability for a lucky
guess.</p>
</td></tr>
<tr><td><code id="pop_iita_+3A_items">items</code></td>
<td>
<p>a required numeric giving the number of items of the
domain taken as basis for <code>imp</code>.</p>
</td></tr>
<tr><td><code id="pop_iita_+3A_dataset">dataset</code></td>
<td>
<p>an optional data frame or matrix consisting of
binary, <code class="reqn">1</code> or <code class="reqn">0</code>, numeric data.  The default
<code>dataset = NULL</code> corresponds to no dataset being used.</p>
</td></tr>
<tr><td><code id="pop_iita_+3A_a">A</code></td>
<td>
<p>an optional list of competing quasi orders (surmise
relations).</p>
</td></tr>
<tr><td><code id="pop_iita_+3A_v">v</code></td>
<td>
<p>a required numeric giving the inductive item tree analysis
algorithm to be performed, in population quantities; <code>v = 1</code>
(minimized corrected), <code>v = 2</code> (corrected), and <code>v = 3</code>
(original).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The three inductive item tree analysis algorithms are exploratory
methods for extracting quasi orders (surmise relations) from data.
In each algorithm, competing binary relations are generated (in the
same way for all three versions), and a fit measure (differing from
version to version) is computed for every relation of the selection
set in order to find the quasi order that fits the data best.  In
all three algorithms, the idea is to estimate the numbers of
counterexamples for each quasi order, and to find, over all
competing quasi orders, the minimum value for the discrepancy
between the observed and expected numbers of counterexamples.  The
three data analysis methods differ in their choices of estimates for
the expected numbers of counterexamples.  For details see
<code><a href="#topic+iita">iita</a></code>.  The algorithms are described in the paper about
the <span class="pkg">DAKS</span> package by <cite>Uenlue and Sargin (2010)</cite>, and in
the paper by <cite>Sargin and Uenlue (2009)</cite>.
</p>
<p>Compared to <code><a href="#topic+iita">iita</a></code>, the function <code>pop_iita</code>
implements the three inductive item tree analysis algorithms in
population, <b>not</b> sample, quantities.  The argument <code>imp</code>
must give a quasi order, and equipped with the error probabilities
<code>ce</code> and <code>lg</code>, it is considered a special case of the
basic local independence model (<cite>Doignon and Falmagne, 1999</cite>).
The latter then is considered as the underlying population model.
If <code>dataset = NULL</code> a set of competing quasi orders is
constructed based on a population analog of the inductive generation
procedure implemented in sample quantities in <code><a href="#topic+ind_gen">ind_gen</a></code>.
If a dataset is specified explicitly, that data are used to generate
the set of competing quasi orders based on the sample version of the
inductive generation procedure.
</p>
<p>A set of implications, an object of the class
<code><a href="sets.html#topic+set">set</a></code>, consists of <code class="reqn">2</code>-tuples <code class="reqn">(i, j)</code> of
the class <code><a href="sets.html#topic+tuple">tuple</a></code>, where a <code class="reqn">2</code>-tuple
<code class="reqn">(i, j)</code> is interpreted as 'mastering item <code class="reqn">j</code> implies
mastering item <code class="reqn">i</code>.'
</p>
<p>The data (in <code>dataset</code>) must contain only ones and zeros, which
encode solving or failing to solve an item, respectively.
</p>


<h3>Value</h3>

<p>If the arguments <code>imp</code>, <code>ce</code>, <code>lg</code>, <code>items</code>,
<code>dataset</code>, <code>A</code>, and <code>v</code> are of required types,
<code>pop_iita</code> returns a named list consisting of the following five
components:
</p>
<table>
<tr><td><code>pop.diff</code></td>
<td>
<p>a vector giving the population <em>diff</em> values
corresponding to the (inductively generated) competing quasi
orders (subject to selected version that was performed).</p>
</td></tr>
<tr><td><code>pop.matrix</code></td>
<td>
<p>a matrix of all possible response patterns and
their corresponding population occurrence probabilities.</p>
</td></tr>
<tr><td><code>error.pop</code></td>
<td>
<p>a vector of the population <code class="reqn">\gamma</code>
rates corresponding to the (inductively generated) competing quasi
orders (subject to selected version that was performed).</p>
</td></tr>
<tr><td><code>selection.set</code></td>
<td>
<p>a list of the (inductively generated) competing
quasi orders.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>the version used; <code>v = 1</code> (minimized corrected),
<code>v = 2</code> (corrected), and <code>v = 3</code> (original).</p>
</td></tr> 
</table>


<h3>Note</h3>

<p>The single careless error <code>ce</code> and lucky guess <code>lg</code>
probabilities are assumed to be constant over all items.  The most
general case that can be specified thus includes two error
probabilities, which are the same for all items.
</p>
<p>The sample <em>diff</em> coefficients of the three inductive item tree
analysis algorithms can be transformed into maximum likelihood
estimators, by division through the square of sample size.  These
transformed <em>diff</em> coefficients are considered in population
quantities.  The <code class="reqn">\gamma</code> rates are the algorithms'
specific estimates of the postulated response error probability.
</p>
<p>Population and estimated asymptotic variances of the maximum
likelihood estimators <em>diff</em> are implemented in the functions
<code><a href="#topic+pop_variance">pop_variance</a></code> and <code><a href="#topic+variance">variance</a></code>, respectively.
</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Doignon, J.-P. and Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>.
Berlin, Heidelberg, and New York: Springer-Verlag.
</p>
<p>Sargin, A. and Uenlue, A. (2009) Inductive item tree analysis:
Corrections, improvements, and comparisons. <em>Mathematical Social Sciences</em>, <b>58</b>, 376&ndash;392.
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pop_variance">pop_variance</a></code> for population asymptotic variances of
<em>diff</em> coefficients; <code><a href="#topic+variance">variance</a></code> for estimated
asymptotic variances of <em>diff</em> coefficients; <code><a href="#topic+simu">simu</a></code>
for data simulation tool; <code><a href="#topic+ind_gen">ind_gen</a></code> for (sample)
inductive generation procedure; <code><a href="#topic+iita">iita</a></code>, the interface
that provides the three (sample) inductive item tree analysis
methods under one umbrella.  See also <code><a href="#topic+DAKS-package">DAKS-package</a></code> for
general information about this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- simu(3, 10000, ce = 0.05, lg = 0.05, delta = 0.12)
y &lt;- iita(x$dataset, v = 2)
z &lt;- pop_iita(x$implications, 0.05, 0.05, 3, x$dataset, v = 2)

## similar sample and population diff values are obtained
(y$diff) / (10000^2)
z
</code></pre>

<hr>
<h2 id='pop_variance'>Population Asymptotic Variance</h2><span id='topic+pop_variance'></span>

<h3>Description</h3>

<p><code>pop_variance</code> computes the population (exact) asymptotic
variances of the maximum likelihood estimators <em>diff</em>, assuming
a multinomial probability distribution on the set of all response
patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop_variance(pop_matrix, imp, error_pop, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop_variance_+3A_pop_matrix">pop_matrix</code></td>
<td>
<p>a required matrix of all possible response
patterns and their corresponding population occurrence
probabilities, for instance obtained from a call to
<code><a href="#topic+pop_iita">pop_iita</a></code>.</p>
</td></tr>
<tr><td><code id="pop_variance_+3A_imp">imp</code></td>
<td>
<p>a required object of class <code><a href="sets.html#topic+set">set</a></code>
representing the set of implications (ought to be a quasi order)
for which <em>diff</em> is computed, for instance obtained from a
call to <code><a href="#topic+pop_iita">pop_iita</a></code>.</p>
</td></tr>
<tr><td><code id="pop_variance_+3A_error_pop">error_pop</code></td>
<td>
<p>a required numeric giving the <code class="reqn">\gamma</code>
rate to be used for computing <em>diff</em>, for instance obtained
from a call to <code><a href="#topic+pop_iita">pop_iita</a></code>.</p>
</td></tr>
<tr><td><code id="pop_variance_+3A_v">v</code></td>
<td>
<p>a required numeric giving the inductive item tree analysis
algorithm to be performed, in population quantities; <code>v = 1</code>
(minimized corrected) and <code>v = 2</code> (corrected).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Subject to the selected version to be performed, <code>pop_variance</code>
computes the population asymptotic variance of the maximum
likelihood estimator <em>diff</em>, which here is formulated for the
relation specified in <code>imp</code> and for the <code class="reqn">\gamma</code>
rate in <code>error_pop</code>.  This population variance is obtained
using the delta method, which requires calculating the Jacobian
matrix of the <em>diff</em> coefficient and the inverse of the
expected Fisher information matrix for the multinomial distribution
with cell probabilities as specified in <code>pop_matrix</code>.
</p>
<p>A set of implications, an object of the class
<code><a href="sets.html#topic+set">set</a></code>, consists of <code class="reqn">2</code>-tuples <code class="reqn">(i, j)</code> of
the class <code><a href="sets.html#topic+tuple">tuple</a></code>, where a <code class="reqn">2</code>-tuple
<code class="reqn">(i, j)</code> is interpreted as 'mastering item <code class="reqn">j</code> implies
mastering item <code class="reqn">i</code>.'
</p>


<h3>Value</h3>

<p>If the arguments <code>pop_matrix</code>, <code>imp</code>, <code>error_pop</code>,
and <code>v</code> are of required types, <code>pop_variance</code> returns a
numeric giving the population asymptotic variance of the maximum
likelihood estimator <em>diff</em> (formulated for the relation in
<code>imp</code> and the <code class="reqn">\gamma</code> rate in <code>error_pop</code>).
</p>


<h3>Note</h3>

<p>The current version of the package <span class="pkg">DAKS</span> does not support
computing population asymptotic variances for the original inductive
item tree analysis algorithm; population asymptotic variances can be
calculated only for the corrected and minimized corrected
algorithms.
</p>
<p>The sample <em>diff</em> coefficients of the three inductive item tree
analysis algorithms can be transformed into maximum likelihood
estimators, by division through the square of sample size.  These
transformed <em>diff</em> coefficients are considered in population
quantities.  The <code class="reqn">\gamma</code> rates are the algorithms'
specific estimates of the postulated response error probability.
</p>
<p>Estimated asymptotic variances of the maximum likelihood estimators
<em>diff</em> are implemented in the function <code><a href="#topic+variance">variance</a></code>.
</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Sargin, A. and Uenlue, A. (2009) Inductive item tree analysis:
Corrections, improvements, and comparisons. <em>Mathematical Social Sciences</em>, <b>58</b>, 376&ndash;392.
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+variance">variance</a></code> for estimated asymptotic variances of
<em>diff</em> coefficients; <code><a href="#topic+pop_iita">pop_iita</a></code> for population
inductive item tree analysis; <code><a href="#topic+ind_gen">ind_gen</a></code> for (sample)
inductive generation procedure; <code><a href="#topic+iita">iita</a></code>, the interface
that provides the three (sample) inductive item tree analysis
methods under one umbrella.  See also <code><a href="#topic+DAKS-package">DAKS-package</a></code> for
general information about this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- simu(5, 100, 0.05, 0.05, delta = 0.15)
y &lt;- pop_iita(x$implications, 0.05, 0.05, 5, x$dataset, v = 2)
pop_variance(y$pop.matrix, 
             y$selection.set[[which(y$pop.diff == min(y$pop.diff))]],
             y$error.pop[which(y$pop.diff == min(y$pop.diff))], v = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='print.iita'>Print Method for Objects of Class iita</h2><span id='topic+print.iita'></span>

<h3>Description</h3>

<p>S3 method to print objects of class <code>iita</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iita'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.iita_+3A_x">x</code></td>
<td>
<p>a required object of class <code>iita</code>, obtained from a call to the function iita.</p>
</td></tr>
<tr><td><code id="print.iita_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints the main results from inductive item tree analysis algorithms.    
</p>


<h3>Value</h3>

<p>If the argument <code>x</code> is of required type, <code>print.iita</code> prints the set of implications.</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Sargin, A. and Uenlue, A. (2009) Inductive item tree analysis:
Corrections, improvements, and comparisons. <em>Mathematical Social Sciences</em>, <b>58</b>, 376&ndash;392. 
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iita">iita</a></code>, the interface that provides the three (sample) inductive item tree analysis methods
under one umbrella. See also <code><a href="#topic+DAKS-package">DAKS-package</a></code> for general
information about this package.
</p>

<hr>
<h2 id='print.pat'>Print Method for Objects of Class pat</h2><span id='topic+print.pat'></span>

<h3>Description</h3>

<p>S3 method to print objects of class <code>pat</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pat'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pat_+3A_x">x</code></td>
<td>
<p>a required object of class <code>pat</code>, obtained from a call to the function <code><a href="#topic+pattern">pattern</a></code>.</p>
</td></tr>
<tr><td><code id="print.pat_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints the main results from inductive item tree analysis algorithms.    
</p>


<h3>Value</h3>

<p>If the argument <code>x</code> is of required type, <code>print.pat</code> prints
the response patterns with the <code class="reqn">n</code> highest frequencies in the
dataset and optionally returns the absolute frequencies of specified
knowledge states in the dataset.
</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Sargin, A. and Uenlue, A. (2009) Inductive item tree analysis:
Corrections, improvements, and comparisons. <em>Mathematical Social Sciences</em>, <b>58</b>, 376&ndash;392. 
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+DAKS-package">DAKS-package</a></code> for general information about this package.
</p>

<hr>
<h2 id='print.popiita'>Print Method for Objects of Class popiita</h2><span id='topic+print.popiita'></span>

<h3>Description</h3>

<p>S3 method to print objects of class <code>popiita</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'popiita'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.popiita_+3A_x">x</code></td>
<td>
<p>a required object of class <code>popiita</code>, obtained from a call
to the function <code><a href="#topic+pop_iita">pop_iita</a></code>.</p>
</td></tr>
<tr><td><code id="print.popiita_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints the main results from inductive item tree analysis algorithms in population values.    
</p>


<h3>Value</h3>

<p>If the argument <code>x</code> is of required type, <code>print.popiita</code> prints
a vector of population <em>diff</em> values, a vector of population error
rates, and the quasi order with minimum population <em>diff</em> value.
</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Sargin, A. and Uenlue, A. (2009) Inductive item tree analysis:
Corrections, improvements, and comparisons. <em>Mathematical Social Sciences</em>, <b>58</b>, 376&ndash;392. 
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pop_iita">pop_iita</a></code>. See also <code><a href="#topic+DAKS-package">DAKS-package</a></code> for general
information about this package.
</p>

<hr>
<h2 id='print.summpopiita'>Print Method for Objects of Class summpopiita</h2><span id='topic+print.summpopiita'></span>

<h3>Description</h3>

<p>S3 method to print objects of class <code>summpopiita</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summpopiita'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summpopiita_+3A_x">x</code></td>
<td>
<p>a required object of class <code>summpopiita</code>, obtained from a call to the function <code><a href="#topic+summary.popiita">summary.popiita</a></code>.</p>
</td></tr>
<tr><td><code id="print.summpopiita_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints the main results from inductive item tree analysis algorithms in population values.    
</p>


<h3>Value</h3>

<p>If the argument <code>x</code> is of required type, <code>print.summpopiita</code> prints a vector of population <em>diff</em> values, a vector of population error rates, the population matrix, and the obtained selection set.
</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Sargin, A. and Uenlue, A. (2009) Inductive item tree analysis:
Corrections, improvements, and comparisons. <em>Mathematical Social Sciences</em>, <b>58</b>, 376&ndash;392.
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pop_iita">pop_iita</a></code>. See also <code><a href="#topic+DAKS-package">DAKS-package</a></code> for general
information about this package.
</p>

<hr>
<h2 id='print.ztest'>Print Method for Objects of Class ztest</h2><span id='topic+print.ztest'></span>

<h3>Description</h3>

<p>S3 method to print objects of class <code>ztest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ztest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ztest_+3A_x">x</code></td>
<td>
<p>a required object of class <code>ztest</code>, obtained from a call to
the function <code><a href="#topic+z_test">z_test</a></code>.</p>
</td></tr>
<tr><td><code id="print.ztest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints the main results from inductive item tree analysis algorithms.    
</p>


<h3>Value</h3>

<p>If the argument <code>x</code> is of required type, <code>print.ztest</code> prints
the Z- and p-value, the alternative hypothesis, the confidence interval,
and the sample estimates. 
</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Sargin, A. and Uenlue, A. (2009) Inductive item tree analysis:
Corrections, improvements, and comparisons. <em>Mathematical Social Sciences</em>, <b>58</b>, 376&ndash; 392. 
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+z_test">z_test</a></code>, the function for performing a Z-test. See also <code><a href="#topic+DAKS-package">DAKS-package</a></code> for general
information about this package.
</p>

<hr>
<h2 id='simu'>
Data and Quasi Order Simulation Tool
</h2><span id='topic+simu'></span>

<h3>Description</h3>

<p><code>simu</code> can be used to simulate binary, of type <code class="reqn">1</code>/<code class="reqn">0</code>,
data using a basic local independence model. The number of
items, the sample size, and two parameters for the careless error
and lucky guess probabilities can be set explicitly. The underlying
combinatorial structure used for simulating the data can either be
specified manually or is generated randomly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu(items, size, ce, lg, imp = NULL, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simu_+3A_items">items</code></td>
<td>
<p>a required numeric giving the number of items of the
domain taken as basis for the simulation.</p>
</td></tr>
<tr><td><code id="simu_+3A_size">size</code></td>
<td>
<p>a required numeric giving the number of response
patterns to be simulated (the sample size).</p>
</td></tr>
<tr><td><code id="simu_+3A_ce">ce</code></td>
<td>
<p>a required numeric giving the probability for a careless
error.</p>
</td></tr>
<tr><td><code id="simu_+3A_lg">lg</code></td>
<td>
<p>a required numeric giving the probability for a lucky
guess.</p>
</td></tr>
<tr><td><code id="simu_+3A_imp">imp</code></td>
<td>
<p>an optional object of class <code><a href="sets.html#topic+set">set</a></code>
representing the underlying set of implications (assumed to be a
quasi order) used for simulating the data, for instance obtained
from a call to <code><a href="#topic+iita">iita</a></code>.  The default <code>imp = NULL</code>
corresponds to generating the quasi order used for simulating the
data randomly.</p>
</td></tr>
<tr><td><code id="simu_+3A_delta">delta</code></td>
<td>
<p>a required (if <code>imp = NULL</code>) numeric giving the
probability for adding an item pair to the randomly generated
quasi order (reflexive pairs are always included a priori).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>simu</code> simulates data using a special case of the
basic local independence model, which is a fundamental restricted
latent class model in knowledge space theory
(<cite>Doignon and Falmagne, 1999</cite>).  The single careless error
<code>ce</code> and lucky guess <code>lg</code> probabilities are assumed to be
constant over all items.  The most general case that can be
specified thus includes two error probabilities at each item, the
same two rates for all items.  The general form of the basic local
independence model allows for varying careless error and lucky guess
rates from item to item (not identifiable in general, however).
</p>
<p>If a quasi order is specified in <code>imp</code> explicitly, Birkhoff's
theorem is used to derive its corresponding quasi ordinal knowledge
space, which is equipped with the error probabilities <code>ce</code> and
<code>lg</code> to give the basic local independence model used for
simulating the data.  If <code>imp = NULL</code>, the underlying quasi
order is generated randomly as follows.  All reflexive pairs are
added to the relation.  The constant specified in <code>delta</code> is
utilized as the probability for adding each of the remaining
non-reflexive item pairs to the relation.  The transitive closure of
this relation is computed, and the resulting quasi order is then the
relation underlying the simulation.
</p>
<p>A set of implications, an object of the class
<code><a href="sets.html#topic+set">set</a></code>, consists of <code class="reqn">2</code>-tuples <code class="reqn">(i, j)</code> of
the class <code><a href="sets.html#topic+tuple">tuple</a></code>, where a <code class="reqn">2</code>-tuple
<code class="reqn">(i, j)</code> is interpreted as 'mastering item <code class="reqn">j</code> implies
mastering item <code class="reqn">i</code>.'
</p>
<p>The simulated dataset contains only ones and zeros, which encode
solving or failing to solve an item, respectively.
</p>


<h3>Value</h3>

<p>If the arguments <code>items</code>, <code>size</code>, <code>ce</code>, <code>lg</code>,
<code>imp</code>, and <code>delta</code> are of required types, <code>simu</code>
returns a named list consisting of the following three components:
</p>
<table>
<tr><td><code>dataset</code></td>
<td>
<p>a matrix of binary, <code class="reqn">1</code> or <code class="reqn">0</code>, numeric
data.</p>
</td></tr>
<tr><td><code>implications</code></td>
<td>
<p>an object of class <code><a href="sets.html#topic+set">set</a></code>
representing the underlying set of implications (assumed to be a
quasi order) used for simulating the data.  If <code>imp = NULL</code>,
this is the quasi order that was randomly generated; otherwise
identical to the set of implications specified in the argument
<code>imp</code>.</p>
</td></tr>
<tr><td><code>states</code></td>
<td>
<p>a matrix consisting of ones or zeros (the quasi
ordinal knowledge space), in which each row represents the
<code class="reqn">1</code>/<code class="reqn">0</code>-pattern of a knowledge state.  This is the
knowledge structure corresponding to the set of implications
specified in <code>implications</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>To pass a quasi order as the argument <code>imp</code> to <code>simu</code> it
may be more convenient to transform from knowledge states to
implications using the function <code><a href="#topic+state2imp">state2imp</a></code>.
</p>
<p>The probability specified in <code>delta</code> does not necessarily
correspond to the ratio of implications in the randomly generated
quasi order, because the transitive closure is formed after having
added item pairs.  In <cite>Sargin and Uenlue (2009)</cite> a normal
sampling scheme for drawing <code>delta</code> values using
<code class="reqn">\mu = 0.16</code> and <code class="reqn">\sigma = 0.06</code> for
nine items has been proposed.  This sampling scheme provides far
better representative samples of quasi orders than sampling
<code>delta</code> values uniformly from the unit interval.
</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Doignon, J.-P. and Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>.
Berlin, Heidelberg, and New York: Springer-Verlag.
</p>
<p>Sargin, A. and Uenlue, A. (2009) Inductive item tree analysis:
Corrections, improvements, and comparisons. <em>Mathematical Social Sciences</em>, <b>58</b>, 376&ndash;392. 
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+state2imp">state2imp</a></code> for transformation from knowledge states to
implications; <code><a href="#topic+imp2state">imp2state</a></code> for transformation from
implications to knowledge states; <code><a href="#topic+pop_iita">pop_iita</a></code> for
population inductive item tree analysis; <code><a href="#topic+iita">iita</a></code>, the
interface that provides the three (sample) inductive item tree
analysis methods under one umbrella.  See also
<code><a href="#topic+DAKS-package">DAKS-package</a></code> for general information about this
package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simu(7, 20, 0.1, 0.1, delta = 0.15)
</code></pre>

<hr>
<h2 id='state2imp'>
Transformation from Knowledge States to Implications
</h2><span id='topic+state2imp'></span>

<h3>Description</h3>

<p><code>state2imp</code> transforms a set of knowledge states (ought to
be a quasi ordinal knowledge space) to the corresponding set of
implications (the surmise relation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>state2imp(P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="state2imp_+3A_p">P</code></td>
<td>
<p>a required matrix of ones and zeros giving the knowledge
states to be used.  Each row represents the
<code class="reqn">1</code>/<code class="reqn">0</code>-pattern of a knowledge state.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the argument <code>P</code> is of required type, <code>state2imp</code>
returns an object of class <code><a href="sets.html#topic+set">set</a></code> (the surmise
relation) representing the set of implications.
</p>


<h3>Note</h3>

<p>For any set of knowledge states the returned binary relation is a
surmise relation.  In case of a quasi ordinal knowledge space this
is Birkhoff's theorem.  For details refer to <cite>Doignon and
Falmagne (1999, Theorem 1.49)</cite>.
</p>
<p>A set of implications, an object of the class
<code><a href="sets.html#topic+set">set</a></code>, consists of <code class="reqn">2</code>-tuples <code class="reqn">(i, j)</code> of
the class <code><a href="sets.html#topic+tuple">tuple</a></code>, where a <code class="reqn">2</code>-tuple
<code class="reqn">(i, j)</code> is interpreted as 'mastering item <code class="reqn">j</code> implies
mastering item <code class="reqn">i</code>.'
</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Doignon, J.-P. and Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>.
Berlin, Heidelberg, and New York: Springer-Verlag.
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+imp2state">imp2state</a></code> for transformation from implications to
knowledge states.  See also <code><a href="#topic+DAKS-package">DAKS-package</a></code> for general
information about this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## an arbitrary matrix of knowledge states is defined
x &lt;- matrix(0, nrow = 5, ncol = 3)
x[1, ] &lt;- c(0, 0, 0)
x[2, ] &lt;- c(0, 0, 1)
x[3, ] &lt;- c(0, 1, 0)
x[4, ] &lt;- c(0, 1, 1)
x[5, ] &lt;- c(1, 1, 1)

state2imp(x)
</code></pre>

<hr>
<h2 id='summary.iita'>Summary Method for Objects of Class iita</h2><span id='topic+summary.iita'></span>

<h3>Description</h3>

<p>S3 method to summarize objects of class <code>iita</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iita'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.iita_+3A_object">object</code></td>
<td>
<p>a required object of class <code>iita</code>, obtained from a call to the function <code><a href="#topic+iita">iita</a></code>.</p>
</td></tr>
<tr><td><code id="summary.iita_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarizes the main results from inductive item tree analysis algorithms.    
</p>


<h3>Value</h3>

<p>If the argument <code>object</code> is of required type, <code>summary.iita</code>
returns the vector of <em>diff</em> values, the quasi order, the error
rate, and the index in the selection set of the quasi order with minimum
<em>diff</em> value.
</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Sargin, A. and Uenlue, A. (2009) Inductive item tree analysis:
Corrections, improvements, and comparisons. <em>Mathematical Social Sciences</em>, <b>58</b>, 376&ndash;392. 
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iita">iita</a></code>, the interface that provides the three (sample) inductive item tree analysis methods
under one umbrella. See also <code><a href="#topic+DAKS-package">DAKS-package</a></code> for general
information about this package.
</p>

<hr>
<h2 id='summary.popiita'>Summary Method for Objects of Class popiita</h2><span id='topic+summary.popiita'></span>

<h3>Description</h3>

<p>S3 method to summarize objects of class <code>popiita</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'popiita'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.popiita_+3A_object">object</code></td>
<td>
<p>a required object of class <code>popiita</code>, obtained from a call to the function <code><a href="#topic+pop_iita">pop_iita</a></code>.</p>
</td></tr>
<tr><td><code id="summary.popiita_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarizes the main results from inductive item tree analysis algorithms in population values.    
</p>


<h3>Value</h3>

<p>If the argument <code>object</code> is of required type, <code>summary.popiita</code>
returns the results obtained from <code><a href="#topic+pop_iita">pop_iita</a></code>.</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Sargin, A. and Uenlue, A. (2009) Inductive item tree analysis:
Corrections, improvements, and comparisons. <em>Mathematical Social Sciences</em>, <b>58</b>, 376&ndash;392. 
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pop_iita">pop_iita</a></code>. See also <code><a href="#topic+DAKS-package">DAKS-package</a></code> for general
information about this package.
</p>

<hr>
<h2 id='variance'>Estimated Asymptotic Variance</h2><span id='topic+variance'></span>

<h3>Description</h3>

<p><code>variance</code> computes estimated asymptotic variances of the
maximum likelihood estimators <em>diff</em> from data, assuming a
multinomial probability distribution on the set of all response
patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variance(dataset, imp, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variance_+3A_dataset">dataset</code></td>
<td>
<p>a required data frame or matrix consisting of binary,
<code class="reqn">1</code> or <code class="reqn">0</code>, numeric data.</p>
</td></tr>
<tr><td><code id="variance_+3A_imp">imp</code></td>
<td>
<p>a required object of class <code><a href="sets.html#topic+set">set</a></code>
representing the set of implications (ought to be a quasi order)
for which <em>diff</em> is computed, for instance obtained from a
call to <code><a href="#topic+simu">simu</a></code>.</p>
</td></tr>
<tr><td><code id="variance_+3A_v">v</code></td>
<td>
<p>a required numeric giving the inductive item tree analysis
algorithm to be performed; <code>v = 1</code> (minimized corrected) and
<code>v = 2</code> (corrected).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Subject to the selected version to be performed, <code>variance</code>
computes a consistent estimator for the population asymptotic
variance of the maximum likelihood estimator <em>diff</em>, which here
is formulated for the relation specified in <code>imp</code> and for the
data in <code>dataset</code>.  This estimated asymptotic variance is
obtained using the delta method, which requires calculating the
Jacobian matrix of the <em>diff</em> coefficient and the inverse of
the expected Fisher information matrix for the multinomial
distribution on the set of all response patterns.  In the expression
for the exact asymptotic variance, the true parameter vector of
multinomial probabilities is estimated by its corresponding maximum
likelihood estimate (vector of the relative frequencies of the
response patterns).
</p>
<p>A set of implications, an object of the class
<code><a href="sets.html#topic+set">set</a></code>, consists of <code class="reqn">2</code>-tuples <code class="reqn">(i, j)</code> of
the class <code><a href="sets.html#topic+tuple">tuple</a></code>, where a <code class="reqn">2</code>-tuple
<code class="reqn">(i, j)</code> is interpreted as 'mastering item <code class="reqn">j</code> implies
mastering item <code class="reqn">i</code>.'
</p>
<p>The data must contain only ones and zeros, which encode solving or
failing to solve an item, respectively.
</p>


<h3>Value</h3>

<p>If the arguments <code>dataset</code>, <code>imp</code>, and <code>v</code> are of
required types, <code>variance</code> returns a numeric giving the
estimated asymptotic variance of the maximum likelihood estimator
<em>diff</em> (formulated for the relation in <code>imp</code> and the data
in <code>dataset</code>).
</p>


<h3>Note</h3>

<p>The current version of the package <span class="pkg">DAKS</span> does not support
computing estimated asymptotic variances for the original inductive
item tree analysis algorithm; population asymptotic variances can be
estimated only for the corrected and minimized corrected algorithms.
</p>
<p>The two types of estimators for the population asymptotic variances
of the <em>diff</em> coefficients obtained using the expected Fisher
information matrix on the one hand, and the observed Fisher
information matrix on the other, yield the same result, in the case
of the multinomial distribution.  Since computation based on
expected Fisher information is faster, this is implemented in
<code>variance</code>.
</p>
<p>The sample <em>diff</em> coefficients of the three inductive item tree
analysis algorithms can be transformed into maximum likelihood
estimators, by division through the square of sample size.  These
transformed <em>diff</em> coefficients are considered in sample and
population quantities.
</p>
<p>Population (exact) asymptotic variances of the maximum likelihood
estimators <em>diff</em> are implemented in the function
<code><a href="#topic+pop_variance">pop_variance</a></code>.
</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Sargin, A. and Uenlue, A. (2009) Inductive item tree analysis:
Corrections, improvements, and comparisons. <em>Mathematical Social Sciences</em>, <b>58</b>, 376&ndash;392.
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pop_variance">pop_variance</a></code> for population asymptotic variances of
<em>diff</em> coefficients; <code><a href="#topic+pop_iita">pop_iita</a></code> for population
inductive item tree analysis; <code><a href="#topic+iita">iita</a></code>, the interface that
provides the three (sample) inductive item tree analysis methods
under one umbrella; <code><a href="#topic+z_test">z_test</a></code> for one- and two-sample Z-tests.  See also <code><a href="#topic+DAKS-package">DAKS-package</a></code> for general
information about this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- simu(5, 100, 0.05, 0.05, delta = 0.15)
variance(x$dataset, x$implications, v = 2)
</code></pre>

<hr>
<h2 id='z_test'>One- and Two-Sample Z-Tests for diff Values</h2><span id='topic+z_test'></span>

<h3>Description</h3>

<p><code>z_test</code> performs one- and two-sample Z-tests for the <em>diff</em>
values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>z_test(dataset, imp, imp_alt = NULL,
       alternative = c("two.sided", "less", "greater"), mu = 0, 
       conf.level = 0.95, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="z_test_+3A_dataset">dataset</code></td>
<td>
<p>a required data frame or matrix consisting of binary,
<code class="reqn">1</code> or <code class="reqn">0</code>, numeric data.</p>
</td></tr>
<tr><td><code id="z_test_+3A_imp">imp</code></td>
<td>
<p>a required object of class <code><a href="sets.html#topic+set">set</a></code>
representing the set of implications (ought to be a quasi order).</p>
</td></tr>
<tr><td><code id="z_test_+3A_imp_alt">imp_alt</code></td>
<td>
<p>an optional set of implications, representing the alternative quasi order.</p>
</td></tr>
<tr><td><code id="z_test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of <code>"two.sided"</code> (default), <code>"less"</code>, or
<code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="z_test_+3A_mu">mu</code></td>
<td>
<p>a number indicating the true value of the mean (or difference in means if you are performing a two sample test).</p>
</td></tr>
<tr><td><code id="z_test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval.</p>
</td></tr>
<tr><td><code id="z_test_+3A_v">v</code></td>
<td>
<p>a required numeric giving the inductive item tree analysis
algorithm to be performed; <code>v = 1</code> (minimized corrected) and
<code>v = 2</code> (corrected).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a Z-test for the <em>diff</em> values of one or two
quasi orders.
</p>


<h3>Value</h3>

<p>If the arguments are of required types, <code>z_test</code> returns a named
list consisting of the following seven components:
</p>
<table>
<tr><td><code>Z.value</code></td>
<td>
<p>the value of the Z-statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>conf</code></td>
<td>
<p>a confidence interval for the mean appropriate to the specified alternative hypothesis.</p>
</td></tr>
<tr><td><code>diff_value</code></td>
<td>
<p>the corresponding <em>diff</em> values for the used quasi orders according to the specified method.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>a number indicating the true value of the mean (or difference in means if you are performing a two sample test).</p>
</td></tr>
<tr><td><code>conf.level</code></td>
<td>
<p>the level of the confidence interval.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The current version of the package <span class="pkg">DAKS</span> does not support
performing a Z-test for the original inductive item tree analysis
algorithm.
</p>


<h3>Author(s)</h3>

<p>Anatol Sargin, Ali Uenlue
</p>


<h3>References</h3>

<p>Sargin, A. and Uenlue, A. (2009) Inductive item tree analysis:
Corrections, improvements, and comparisons. <em>Mathematical Social Sciences</em>, <b>58</b>, 376&ndash;392.
</p>
<p>Uenlue, A. and Sargin, A. (2010) <span class="pkg">DAKS</span>: An <span class="rlang"><b>R</b></span> package for data
analysis methods in knowledge space theory. <em>Journal of Statistical
Software</em>, <b>37</b>(2), 1&ndash;31.
URL <a href="http://www.jstatsoft.org/v37/i02/">http://www.jstatsoft.org/v37/i02/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iita">iita</a></code>, the interface that provides the three (sample)
inductive item tree analysis methods under one umbrella;
<code><a href="#topic+variance">variance</a></code> for estimated asymptotic variances of <em>diff</em>
coefficients.  See also <code><a href="#topic+DAKS-package">DAKS-package</a></code> for general
information about this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sel_set&lt;-ind_gen(ob_counter(pisa[, 1:3]))
z_test(pisa[, 1:3], sel_set[[2]], sel_set[[3]], v = 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
