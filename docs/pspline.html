<!DOCTYPE html><html><head><title>Help for package pspline</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pspline}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#predict.smooth.Pspline'>
<p>Smoothing Spline of Arbitrary Order at New Data</p></a></li>
<li><a href='#smooth.Pspline'>
<p>Fit a Polynomial Smoothing Spline of Arbitrary Order</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0-19</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-02-19</td>
</tr>
<tr>
<td>Title:</td>
<td>Penalized Smoothing Splines</td>
</tr>
<tr>
<td>Author:</td>
<td>S original by Jim Ramsey &lt;ramsay@psych.mcgill.ca&gt;. 
        R port by  Brian Ripley &lt;ripley@stats.ox.ac.uk&gt;.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brian Ripley &lt;ripley@stats.ox.ac.uk&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.0.0), stats, graphics</td>
</tr>
<tr>
<td>Description:</td>
<td>Smoothing splines with penalties on order m derivatives.</td>
</tr>
<tr>
<td>License:</td>
<td>Unlimited</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-19 16:41:41 UTC; ripley</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-20 12:26:52 UTC</td>
</tr>
</table>
<hr>
<h2 id='predict.smooth.Pspline'>
Smoothing Spline of Arbitrary Order at New Data
</h2><span id='topic+predict.smooth.Pspline'></span>

<h3>Description</h3>

<p>Uses an object of class <code>"smooth.Pspline"</code> to evaluate a
polynomial smoothing spline of arbitrary order or one of its
derivatives at new argument values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smooth.Pspline'
predict(object, xarg, nderiv = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.smooth.Pspline_+3A_object">object</code></td>
<td>
<p>a fitted <code>smooth.Pspline</code> object.</p>
</td></tr>
<tr><td><code id="predict.smooth.Pspline_+3A_xarg">xarg</code></td>
<td>
<p>the argument values at which the spline or its derivative
is to be evaluated.</p>
</td></tr>
<tr><td><code id="predict.smooth.Pspline_+3A_nderiv">nderiv</code></td>
<td>
<p>the order of the derivative required &ndash; the default is 0,
the function itself.</p>
</td></tr>
<tr><td><code id="predict.smooth.Pspline_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method produces results similar to function the <code>predict</code>
method for <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>, but the smoothing function is
a natural smoothing spline rather than a B-spline smooth, and the
order of the spline can be chosen freely, where order in this case
means the order of the derivative that is
penalized. <code>smooth.spline</code> penalizes the second derivative, and
consequently only derivatives or order 0 or 1 are useful, but because
<code><a href="#topic+smooth.Pspline">smooth.Pspline</a></code> penalizes a derivative of order m,
derivatives up to order m-1 are useful. The general recommendation is
to penalize the derivative two beyond the highest order derivative to
be evaluated.
</p>


<h3>Value</h3>

<p>A list with components <code>xarg</code> and <code>dy</code>; the <code>xarg</code>
component is identical to the input <code>xarg</code> sequence, the
<code>dy</code> component is the evaluated derivative of order <code>deriv</code>.
</p>


<h3>References</h3>

<p>Heckman, N. and Ramsay, J. O. (1996) Spline smoothing with model based
penalties.  McGill University, unpublished manuscript.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.Pspline">smooth.Pspline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(smooth.Pspline)
## smoother line is given by
xx &lt;- seq(4, 25, length=100)
lines(xx, predict(sm.spline(speed, dist, df=5), xx), col = "red")
## add plots of derivatives
lines(xx, 10*predict(sm.spline(speed, dist), xx, 1), col = "blue")
lines(xx, 100*predict(sm.spline(speed, dist), xx, 2), col = "green")
</code></pre>

<hr>
<h2 id='smooth.Pspline'>
Fit a Polynomial Smoothing Spline of Arbitrary Order
</h2><span id='topic+smooth.Pspline'></span><span id='topic+lines.smooth.Pspline'></span><span id='topic+plot.smooth.Pspline'></span><span id='topic+print.smooth.Pspline'></span><span id='topic+sm.spline'></span>

<h3>Description</h3>

<p>Returns an object of class <code>"smooth.Pspline"</code> which is a natural 
polynomial smooth of the input data of order fixed by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.Pspline(x, y, w=rep(1, length(x)), norder=2, df=norder + 2, 
               spar=0, method=1)
sm.spline(x, y, w, cv=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.Pspline_+3A_x">x</code></td>
<td>

<p>values of the predictor variable.  These must be strictly increasing,
and there must be at least <code>2*norder + 1</code> of them.
</p>
<p><code>sm.spline</code> provides a simplified interface, in which the <code>x</code>
values can be unsorted, or a list with components <code>"x"</code> and
<code>"y"</code> or a two-column matrix or a complex vector.
</p>
</td></tr>
<tr><td><code id="smooth.Pspline_+3A_y">y</code></td>
<td>

<p>one or more sets of response variable values.  If there is one
response variable, <code>y</code> is an array of the same length as <code>x</code>; if more
than one, then <code>y</code> is a matrix with <code>length(x)</code> rows and number of
columns equal to the number of variables.
</p>
</td></tr>
<tr><td><code id="smooth.Pspline_+3A_w">w</code></td>
<td>

<p>vector of positive weights for smoothing of the same length as <code>x</code>.
If measurements at different values of <code>x</code> have different
variances, <code>w</code>
should be inversely proportional to the variances.  The default is
that all weights are one.
</p>
</td></tr>
<tr><td><code id="smooth.Pspline_+3A_norder">norder</code></td>
<td>

<p>the order of the spline.  <code>norder = 2</code> gives the cubic smoothing
spline, and more generally the smoothing function is a piecewise
polynomial of degree <code>2*norder - 1</code>.  If derivatives are to be
computed from the smoothing using <code>predict.smooth.Pspline</code>, the order
should be one or two more than the highest order of derivative.
</p>
</td></tr>
<tr><td><code id="smooth.Pspline_+3A_df">df</code></td>
<td>

<p>a number which specifies the degrees of freedom = trace(S).  Here S is
the implicit smoothing matrix.  <code>df</code> controls the amount of smoothing
if <code>method = 2</code>.
</p>
</td></tr>
<tr><td><code id="smooth.Pspline_+3A_spar">spar</code></td>
<td>

<p>the usual smoothing parameter for smoothing splines, which is the
coefficient of the integrated squared derivative of order <code>norder</code>.
<code>spar</code> controls the amount of smoothing if <code>method = 1</code>.
</p>
</td></tr>
<tr><td><code id="smooth.Pspline_+3A_cv">cv</code></td>
<td>
<p>logical: should ordinary cross-validation be used (true) or
generalized cross-validation.</p>
</td></tr>
<tr><td><code id="smooth.Pspline_+3A_method">method</code></td>
<td>

<p>the method for controlling the amount of smoothing.  <code>method = 1</code> uses
the value supplied for <code>spar</code>.  <code>method = 2</code> adjusts <code>spar</code> so that the
degrees of freedom is equal to <code>df</code>.  <code>method = 3</code> adjusts <code>spar</code> so
that the generalized cross-validation criterion is minimized.
<code>method = 4</code> adjusts <code>spar</code> so that the ordinary cross-validation criterion is
minimized.  If <code>method = 3</code> or <code>method = 4</code>, <code>spar</code> defines the initial
value for the minimization algorithm if positive; otherwise an
internally generated value is used.
</p>
<p><code>sm.spline</code> chooses this automatically based on the supplied values
and that of <code>cv</code>.
</p>
</td></tr>
<tr><td><code id="smooth.Pspline_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to <code>smooth.Pspline</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method produces results similar to function <code>smooth.spline</code>, but
the smoothing function is a natural smoothing spline rather than a B-spline
smooth, and as a consequence will differ slightly for <code>norder = 2</code> over the
initial and final intervals.  
</p>
<p>The main extension is the possibility of setting the order of
derivative to be penalized, so that derivatives of any order can be
computed using the companion function <code>predict.smooth.Pspline</code>.  The
algorithm is of order N, meaning that the number of floating point
operations is proportional to the number of values being smoothed.
Note that the argument values must be strictly increasing, a condition
that is not required by <code>smooth.spline</code>.
</p>
<p>Note that the appropriate or minimized value of the smoothing parameter
<code>spar</code> will depend heavily on the order; the larger the order, the smaller
this parameter will tend to be.
</p>


<h3>Value</h3>

<p>an object of class <code>"smooth.Pspline"</code> is returned, consisting of the fitted
smoothing spline evaluated at the supplied data, some fitting criteria
and constants.  This object contains the information necessary to evaluate
the smoothing spline or one of its derivatives at arbitrary argument
values using <code>predict.smooth.Pspline</code>.  The components of the returned
list are
</p>
<table>
<tr><td><code>norder</code></td>
<td>

<p>the order of the spline  
</p>
</td></tr>
<tr><td><code>x</code></td>
<td>

<p>values of the predictor variable
</p>
</td></tr>
<tr><td><code>ysmth</code></td>
<td>

<p>a matrix with <code>length(x)</code> rows, each column of which contains
the smoothed response variable values for the corresponding column of <code>y</code>.  
</p>
</td></tr>
<tr><td><code>lev</code></td>
<td>

<p>leverage values, which are the diagonal elements of the smoother matrix S.
</p>
</td></tr>
<tr><td><code>gcv</code></td>
<td>

<p>generalized cross-validation criterion value
</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>

<p>ordinary cross-validation criterion value
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>a number which supplies the degrees of freedom = trace(S) rather than
a smoothing parameter.
</p>
</td></tr>
<tr><td><code>spar</code></td>
<td>

<p>the final smoothing parameter for smoothing splines.  This
is unchanged if <code>method = 1</code>, but adjusted otherwise.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>the call that produced the fit.
</p>
</td></tr></table>


<h3>References</h3>

<p>Heckman, N. and Ramsay, J. O. (1996) Spline smoothing with model based
penalties.  McGill University, unpublished manuscript.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.smooth.Pspline">predict.smooth.Pspline</a></code>, <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cars)
attach(cars)
plot(speed, dist, main = "data(cars)  &amp;  smoothing splines")
cars.spl &lt;- sm.spline(speed, dist)
cars.spl
lines(cars.spl, col = "blue")
lines(sm.spline(speed, dist, df=10), lty=2, col = "red")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
