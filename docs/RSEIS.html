<!DOCTYPE html><html><head><title>Help for package RSEIS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RSEIS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addpoints.hodo'><p>Add points to a hodogram plot</p></a></li>
<li><a href='#addtix'><p>add tix to plot</p></a></li>
<li><a href='#addWPX'>
<p>Add one pick to WPX file</p></a></li>
<li><a href='#applytaper'><p>Apply taper to seismic trace</p></a></li>
<li><a href='#ASCII.SEISN'><p>ASCII RSEIS data dump</p></a></li>
<li><a href='#attime12'><p>Epoch Time Window</p></a></li>
<li><a href='#AUGMENTbutfilt'><p>Butterworth filter with Augmentation</p></a></li>
<li><a href='#autoreg'><p>Auto-Regressive Spectrum Estimate</p></a></li>
<li><a href='#brune.doom'><p>Brune Modeling</p></a></li>
<li><a href='#brune.func'><p>Brune Earquake Model</p></a></li>
<li><a href='#brune.search'><p>Search for Brune fit to displacement spectrum</p></a></li>
<li><a href='#butfilt'><p>Butterworth filter</p></a></li>
<li><a href='#BUTREPLOT'><p>Replot Function for SELBUT</p></a></li>
<li><a href='#catWPX'>
<p>Concatenate two WPX lists</p></a></li>
<li><a href='#CE1'><p>Single Seismogram</p></a></li>
<li><a href='#checkWPX'><p>Check WPX</p></a></li>
<li><a href='#choosfilt'><p>INteractive CHoice of Filter</p></a></li>
<li><a href='#CHOP.SEISN'><p>CHOP SEISmic structure</p></a></li>
<li><a href='#circ'><p>Draw a circle</p></a></li>
<li><a href='#cleanpickfile'><p>Clean up Pickfile structure</p></a></li>
<li><a href='#cleanWPX'><p>Clean WPX</p></a></li>
<li><a href='#colorwig'><p>Plot a seimic trace colored in time</p></a></li>
<li><a href='#combineSEIS'><p>Combine SEIS lists</p></a></li>
<li><a href='#comp.env'><p>Compare Envelopes</p></a></li>
<li><a href='#Comp1Dvel'><p>Compare a pair of 1D models</p></a></li>
<li><a href='#Comp1Dvels'><p>Compare 1D models</p></a></li>
<li><a href='#complex.hodo'><p>HodoGram Plot</p></a></li>
<li><a href='#COMPorder'><p>Seismic Component Order</p></a></li>
<li><a href='#contwlet'><p>Contour Wavelet Transform</p></a></li>
<li><a href='#convert2Rseis'><p>Convert Seismic data to RSEIS</p></a></li>
<li><a href='#convertATT'><p>DateHour to List</p></a></li>
<li><a href='#correct.moveout'><p>Moveout Correction</p></a></li>
<li><a href='#DAYSperYEAR'><p>Days per Year</p></a></li>
<li><a href='#DECIMATE.SEISN'><p> Decimate a set of traces</p></a></li>
<li><a href='#deconinst'><p>Deconvolve instrument response from seismic data</p></a></li>
<li><a href='#deleteWPX'>
<p>Delete  picks to WPX file</p></a></li>
<li><a href='#detail.pick'><p>Detail Pick on 3-component seismogram</p></a></li>
<li><a href='#detrend'><p>Remove trend from time series signal</p></a></li>
<li><a href='#DISPLACE.SEISN'><p>Displacement seismogram</p></a></li>
<li><a href='#distseisnXY'><p>Distances from an RSEIS list</p></a></li>
<li><a href='#DISTxsec'><p>Distance Cross section</p></a></li>
<li><a href='#DO.PMOT.ARR'><p>Particle Motion Analysis with arrows</p></a></li>
<li><a href='#doGABOR.AR'><p>Gabor Transform with AR spectrum method</p></a></li>
<li><a href='#doGABOR.MTM'><p>Evolutive MTM Spectrum</p></a></li>
<li><a href='#doMYBUTTS'><p>Dummy Button Function</p></a></li>
<li><a href='#DOsgram'><p>Gabor transform</p></a></li>
<li><a href='#dowiggles'><p>Plot wiggles</p></a></li>
<li><a href='#editDB'><p>Edit Data Base</p></a></li>
<li><a href='#EmptyPickfile'><p>Create an empty RSEIS pickfile structure</p></a></li>
<li><a href='#EmptySEIS'><p>Create an empty RSEIS structure</p></a></li>
<li><a href='#envelope'><p>Envelope Function with Hilbert Transform</p></a></li>
<li><a href='#EPOCHday'><p>Epoch Day</p></a></li>
<li><a href='#EPOCHyear'><p>Epoch Year</p></a></li>
<li><a href='#ETECTG'><p>Event Detection</p></a></li>
<li><a href='#evolAR'><p> Evolutive Auto-Regressive Spectrum</p></a></li>
<li><a href='#evolfft'><p>Spectrogram fft</p></a></li>
<li><a href='#evolMTM'><p>Evolutive Multi-taper Spectrum</p></a></li>
<li><a href='#filedatetime'><p>Create a character string from a date</p></a></li>
<li><a href='#FILT.SEISN'><p>Filter Traces</p></a></li>
<li><a href='#FILT.spread'><p>Filter trace with a spread of filters</p></a></li>
<li><a href='#filterstamp'><p>Make  Filter Stamp</p></a></li>
<li><a href='#finteg'><p>Integration in Frequency Domain</p></a></li>
<li><a href='#fixcompname'><p>Fix component names for uniformity</p></a></li>
<li><a href='#fixcomps'><p>Fix Station Component Names</p></a></li>
<li><a href='#fixNA'><p>Fix NA values.</p></a></li>
<li><a href='#fixUWstasLL'><p>fixUWstasLL</p></a></li>
<li><a href='#fromjul'><p>given julian day and year get month/day</p></a></li>
<li><a href='#FRWDft'><p>Forward fourier Transform</p></a></li>
<li><a href='#gaddtix'><p>add tic marks</p></a></li>
<li><a href='#GAZI'><p>Get azimuthal particle motion</p></a></li>
<li><a href='#genrick'><p>Ricker Wavelet</p></a></li>
<li><a href='#get.corner'><p>Get Corner Frequency: Linear Model</p></a></li>
<li><a href='#GET.seis'><p>Reads various seismic file formats</p></a></li>
<li><a href='#get.slepians'><p>Get Slepian Tapers</p></a></li>
<li><a href='#Get1Dvel'><p>Read 1D velocity model</p></a></li>
<li><a href='#GETARAIC'><p>Auto-Regressive AIC estimate of arrival time</p></a></li>
<li><a href='#getb1b2'><p>Event Detection</p></a></li>
<li><a href='#getEcard'><p>Error Card</p></a></li>
<li><a href='#getFcard'><p>Parse UW F Card</p></a></li>
<li><a href='#getGHtime'><p>Get Seismic reference time</p></a></li>
<li><a href='#getHcard'><p>Parse UW Hires location Card</p></a></li>
<li><a href='#getIRIS'><p>get Hypocenters from IRIS web site</p></a></li>
<li><a href='#getjul'><p>Get Julian day</p></a></li>
<li><a href='#getmoday'><p>Get Month Day</p></a></li>
<li><a href='#getNcard'><p>Parse Name Card</p></a></li>
<li><a href='#getPDEcsv'><p>Unpack PDE file</p></a></li>
<li><a href='#getpfile'><p>Get Pick File</p></a></li>
<li><a href='#getphaselag2'><p>Phase Lag</p></a></li>
<li><a href='#getrdpix'><p>get read picks</p></a></li>
<li><a href='#getseis24'><p>Get 24 Hours of Seismic Data</p></a></li>
<li><a href='#getvertsorder'><p>Get Order of Picks from P-wave Arrivals</p></a></li>
<li><a href='#GH'><p>Earthquake Seismic Data</p></a></li>
<li><a href='#ghstamp'><p>Identification stamp for RSEIS data</p></a></li>
<li><a href='#GLUE.GET.seis'><p>GLUE.GET.seis</p></a></li>
<li><a href='#GLUEseisMAT'><p>GLUEseisMAT</p></a></li>
<li><a href='#gpoly'><p>Convert Poles and Zeros to  Polynomial</p></a></li>
<li><a href='#GreatDist'><p>Distance Along Great Circle Arc</p></a></li>
<li><a href='#grotseis'><p>Get seismic rotation matrix</p></a></li>
<li><a href='#hilbert'><p>Hilbert Transform</p></a></li>
<li><a href='#hilow'><p>Find Maxima and Minima</p></a></li>
<li><a href='#hodogram'><p>HodoGram Plot</p></a></li>
<li><a href='#hypot'><p>Hypot</p></a></li>
<li><a href='#idpoints.hodo'><p>ID points on Hodogram</p></a></li>
<li><a href='#info.seis'><p>Information on a Seismic record</p></a></li>
<li><a href='#infoDB'><p>Print information about the seismic database</p></a></li>
<li><a href='#insertNAs'><p>Insert NA in a vector at given break points</p></a></li>
<li><a href='#INSTFREQS'><p>Instrument Frequencies</p></a></li>
<li><a href='#INSTresponse'><p>Instrument Respnse Function</p></a></li>
<li><a href='#integ1'><p>Integrate seismogram</p></a></li>
<li><a href='#INVRft'><p>Inverse Fourier Transform</p></a></li>
<li><a href='#j2posix'><p>Convert RSEIS date list to Posix</p></a></li>
<li><a href='#jadjust.length'><p>Zero Padding</p></a></li>
<li><a href='#JBLACK'><p>Gray scale Color Palette</p></a></li>
<li><a href='#JGRAY'><p>Gray scale Color Palette</p></a></li>
<li><a href='#jitter.lab'><p>Jitter a set of labels</p></a></li>
<li><a href='#jlegend'><p>plot a legend</p></a></li>
<li><a href='#jpolyval'><p>Polynomial Value</p></a></li>
<li><a href='#JSAC.seis'><p>JSAC.seis</p></a></li>
<li><a href='#jstats'><p>statistics of a vector</p></a></li>
<li><a href='#Jtim'><p>Decimal Julian Day</p></a></li>
<li><a href='#KH'><p>Volcano Seismic Data</p></a></li>
<li><a href='#lagplot'><p>Plot phase lags</p></a></li>
<li><a href='#leests'><p>Time Series Structure</p></a></li>
<li><a href='#legitpix'><p>Legitimate picks in swig</p></a></li>
<li><a href='#letter.it'><p>Add letters to the corners of plots in multiple figures</p></a></li>
<li><a href='#LocalUnwrap'><p>Unwrap spectrum phase</p></a></li>
<li><a href='#logspace'><p>Logarithm</p></a></li>
<li><a href='#longfft'><p>Long FFT Spectrogram</p></a></li>
<li><a href='#makeDB'><p>Create a seismic Waveform Database</p></a></li>
<li><a href='#makefreq'><p>Make Frequency</p></a></li>
<li><a href='#markseis24'><p>Mark 24 hour seismic display</p></a></li>
<li><a href='#matsquiggle'><p>Matrix Seismic Record</p></a></li>
<li><a href='#Mine.seis'><p>Mine a seismic data base to extract secions of time limited data</p></a></li>
<li><a href='#mirror.matrix'><p>mirror matrix</p></a></li>
<li><a href='#Mmorlet'><p>Morlet Wavelet</p></a></li>
<li><a href='#mtapspec'><p>MTM spectrum</p></a></li>
<li><a href='#MTM.drive'><p>Interactive MTM driver</p></a></li>
<li><a href='#MTMdisp'><p> MTMdisp</p></a></li>
<li><a href='#MTMgabor'><p>Evolutive MTM Spectrum</p></a></li>
<li><a href='#MTMplot'><p>Plot Multi-taper Spectrum</p></a></li>
<li><a href='#NEW.getUWSTAS'><p>get UW station file</p></a></li>
<li><a href='#NEWPLOT.WPX'><p>Plot Window Picks (WPX)</p></a></li>
<li><a href='#next2'><p>Next Power of Two</p></a></li>
<li><a href='#OH'><p>Delta-O18 isotpe record</p></a></li>
<li><a href='#one'><p>one plotting region</p></a></li>
<li><a href='#P2GH'><p>XTR button to RSEIS</p></a></li>
<li><a href='#parse.pde'><p>Parse PDE file</p></a></li>
<li><a href='#parseFN2STA'><p>get station from file name</p></a></li>
<li><a href='#partmotnet'><p>Particle Motion on Stereonet</p></a></li>
<li><a href='#PDE2list'><p>Convert PDEs to List</p></a></li>
<li><a href='#peaks'><p>Peaks</p></a></li>
<li><a href='#PICK.DOC'><p>Documentation for swig</p></a></li>
<li><a href='#pickgeninfo'><p>print swig information</p></a></li>
<li><a href='#pickhandler'><p>Handle Pick in RSEIS</p></a></li>
<li><a href='#pickit'><p> Automatic Picking Algorithm</p></a></li>
<li><a href='#pickseis24'><p>Pick zooms on 24 hour display</p></a></li>
<li><a href='#plocator'><p>Specialized Locator function</p></a></li>
<li><a href='#PLOT.ALLPX'><p>plot all phase arrival picks</p></a></li>
<li><a href='#PLOT.MATN'><p>plot a matrix of several seismograms</p></a></li>
<li><a href='#PLOT.SEISN'><p>Plot Seismic Section</p></a></li>
<li><a href='#PLOT.TTCURVE'><p>Plot Seismic Section, travel time curve</p></a></li>
<li><a href='#Plot1Dvel'><p>Plot 1D Velocity Model</p></a></li>
<li><a href='#plotarrivals'><p>plot theoretical arrival times for a seismic section</p></a></li>
<li><a href='#plotDB'><p>Plot a time line of a DB set in RSEIS</p></a></li>
<li><a href='#plotevol'><p>Plot Spectrogram</p></a></li>
<li><a href='#plotGH'><p>Plot a seismic trace.</p></a></li>
<li><a href='#plotJGET'><p>Plot JGET output</p></a></li>
<li><a href='#plotseis24'><p>Plot 24 hours of seismic data</p></a></li>
<li><a href='#plotwlet'><p>Plot Wavelet Transform</p></a></li>
<li><a href='#plt.MTM0'><p>Plot MTM structure</p></a></li>
<li><a href='#PLTpicks'><p>Plot picks on seismic record</p></a></li>
<li><a href='#PMOT.drive'><p>Interactive Particle Motion Plot</p></a></li>
<li><a href='#posix2RSEIS'><p>Posix to RSEIS DATE/TIME</p></a></li>
<li><a href='#PPIX'><p>P-picking</p></a></li>
<li><a href='#prep1wig'><p>Prepare structure for RSEIS</p></a></li>
<li><a href='#prepSEIS'><p>Prepare structure for RSEIS</p></a></li>
<li><a href='#PreSet.Instr'><p>Set up Standard Instrument Responses</p></a></li>
<li><a href='#PSTLTcurve'><p>Short Term/Long Term curve</p></a></li>
<li><a href='#Put1Dvel'><p>Dump a velocity model to an ascii file</p></a></li>
<li><a href='#pwlet2freqs'><p>Convert Wavelet Axis to Frequency</p></a></li>
<li><a href='#rangedatetime'><p>Range of Date Time</p></a></li>
<li><a href='#Ray.time1D'><p>Seismic 1D Travel Time and raypath</p></a></li>
<li><a href='#rdistaz'><p>Distance and Azimuth from two points</p></a></li>
<li><a href='#rDUMPLOC'><p>DUMP vectors to screen in list format</p></a></li>
<li><a href='#read1segy'><p>Read one SEGY/SAC file</p></a></li>
<li><a href='#ReadInstr'><p>Read Instrument Response in  IRIS SEED format</p></a></li>
<li><a href='#ReadSet.Instr'><p>Read Instrument Response file</p></a></li>
<li><a href='#readUW.OSTAS'><p>Parse UW  O-Cards</p></a></li>
<li><a href='#recdate'><p>Rectify Date</p></a></li>
<li><a href='#repairWPX'><p>Repair WPX</p></a></li>
<li><a href='#replaceWPX'>
<p>Replace  picks in WPX file</p></a></li>
<li><a href='#RSEIS-package'>
<p>Seismic Analysis and Display</p></a></li>
<li><a href='#rseis2segy'><p>Convert RSEIS to SEGY/SAC format</p></a></li>
<li><a href='#rseis2ts'><p>Convert RSEIS to TS</p></a></li>
<li><a href='#rsspec.taper'><p>Taper spectrum</p></a></li>
<li><a href='#ruler'><p>Column Ruler</p></a></li>
<li><a href='#save.wpix'><p>Save WPIX from swig output</p></a></li>
<li><a href='#saveWPX'><p>Save WPX</p></a></li>
<li><a href='#scal2freqs'><p>Wavelet Frequency Scale</p></a></li>
<li><a href='#screens'><p>screens</p></a></li>
<li><a href='#SEARCHPIX'><p>Search Pix</p></a></li>
<li><a href='#secdif'><p>Return difference in seconds</p></a></li>
<li><a href='#secdifL'><p>Seconds Difference</p></a></li>
<li><a href='#secdifv'><p>Seconds Difference</p></a></li>
<li><a href='#segy2rseis'><p>Read in multiple segy files.</p></a></li>
<li><a href='#SEIS2list'><p>Convert a SEIS list to a list of seismograms</p></a></li>
<li><a href='#seiscols'><p>Set colors for seismic display</p></a></li>
<li><a href='#SEISNtime'><p>Minimum time in an RSEIS list</p></a></li>
<li><a href='#seisorder'><p>Order seismic traces</p></a></li>
<li><a href='#selAPX'><p>Select Picks</p></a></li>
<li><a href='#SELBUT'><p>Select Buttons</p></a></li>
<li><a href='#selpgen'><p>Pick stations and components</p>
interactively</a></li>
<li><a href='#SELSTA'><p>Pick stations and components</p>
interactively</a></li>
<li><a href='#selstas'><p>Select Stations</p></a></li>
<li><a href='#SENSORsensitivity'><p>Sensor Sensitivity from a known set of seismo/acoustic sensor</p></a></li>
<li><a href='#setPrePix'><p>Set list of arrival times for swig.</p></a></li>
<li><a href='#setstas'><p>Set Station information</p></a></li>
<li><a href='#setupDB'><p>Set up a seismic data base</p></a></li>
<li><a href='#setwelch'><p>Set up Matrix of fft for Welch method</p></a></li>
<li><a href='#setwpix'><p>Set Window Pix for swig</p></a></li>
<li><a href='#setWPX'><p>Set WPX</p></a></li>
<li><a href='#setypx'><p>Create an empty window pick list</p></a></li>
<li><a href='#showdatetime'><p>Print Date/TIME</p></a></li>
<li><a href='#sigconv'><p>Convolve spikes with wavelets</p></a></li>
<li><a href='#sigconvGR'><p>convolve for Ground roll</p></a></li>
<li><a href='#SNET.drive'><p>stereonet representation of particle motion</p></a></li>
<li><a href='#SPECT.drive'><p>Interactive Spectrogram Driver</p></a></li>
<li><a href='#Spectrum'><p>Calculate Different Spectrum Types in Physical Units</p></a></li>
<li><a href='#STALTA'><p>Short term, long term  average ratio</p></a></li>
<li><a href='#STLTcurve'><p>Short-term/Long-term Average curve</p></a></li>
<li><a href='#swig'><p>Seismic Wiggle Analysis</p></a></li>
<li><a href='#swig.ALLPX'><p>plot all phase arrival picks</p></a></li>
<li><a href='#symshot1'><p>Simulate a seismic shot</p></a></li>
<li><a href='#sysinfo'><p>System Information</p></a></li>
<li><a href='#T12.pix'><p>Get T1, T2</p></a></li>
<li><a href='#TAPER.SEISN'><p>Taper Traces</p></a></li>
<li><a href='#Thresh.J'><p>Threshold Adjuster</p></a></li>
<li><a href='#TOCART'><p>Convert to Cartesian coordinates</p></a></li>
<li><a href='#tojul'><p>Julian Day</p></a></li>
<li><a href='#tomo.colors'><p>Tomography Colors</p></a></li>
<li><a href='#trapz'><p>Integrate using trapezoidal rule</p></a></li>
<li><a href='#travel.time1D'><p>Seismic Travel Time 1D</p></a></li>
<li><a href='#tung.pulse'><p>Volcanic Pulse Analysis</p></a></li>
<li><a href='#unpackAcard'><p>Parse Acard from UW-format pickfile</p></a></li>
<li><a href='#uwpfile2ypx'><p>UW pickfile to pphase pick data.frame</p></a></li>
<li><a href='#varsquig'><p>Var-Squiggle plot</p></a></li>
<li><a href='#varsquiggle'><p>Var-Squiggle Plot</p></a></li>
<li><a href='#VELMOD1D'><p>Sample Velocity Model</p></a></li>
<li><a href='#VELOCITY.SEISN'><p>Velocity Seismogram</p></a></li>
<li><a href='#view.seis'><p>Veiw seismic data window</p></a></li>
<li><a href='#vlen'><p>vector length</p></a></li>
<li><a href='#vline'><p>vertical line on trace panel</p></a></li>
<li><a href='#wiggle.env'><p>Plot time series envelope</p></a></li>
<li><a href='#wiggleimage'><p>Seismic section</p></a></li>
<li><a href='#WINGH'><p>Window a GH structure and extract data</p></a></li>
<li><a href='#winmark'><p>Window Mark</p></a></li>
<li><a href='#winseis24'><p>Locator for plotseis24</p></a></li>
<li><a href='#wlet.do'><p>Return Wavelet transform</p></a></li>
<li><a href='#wlet.drive'><p>Interactive wavelet transform driver</p></a></li>
<li><a href='#write1segy'><p>Write One segy file</p></a></li>
<li><a href='#writeUW.Acard'><p>writeUW.Acard</p></a></li>
<li><a href='#writeUW.Commentcard'><p>writeUW.Commentcard</p></a></li>
<li><a href='#writeUW.DOTcard'><p>writeUW.DOTcard</p></a></li>
<li><a href='#writeUW.Ecard'><p>writeUW.Ecard</p></a></li>
<li><a href='#writeUW.Fcard'><p>writeUW.Fcard</p></a></li>
<li><a href='#writeUW.Hcard'><p>writeUW.Hcard</p></a></li>
<li><a href='#writeUW.Ncard'><p>writeUW.Ncard</p></a></li>
<li><a href='#writeUW.OSTAScard'><p>writeUW.OSTAScard</p></a></li>
<li><a href='#writeUWpickfile'><p>UW formatted ascii pickfile</p></a></li>
<li><a href='#X2RSEIS'><p>Extract data to RSEIS file</p></a></li>
<li><a href='#X2SAC'><p>Extract Data to SAC format</p></a></li>
<li><a href='#xcor2'><p>Cross Correlation</p></a></li>
<li><a href='#xprod'><p>Vector Cross Product</p></a></li>
<li><a href='#XTR'><p>Buttons for swig</p></a></li>
<li><a href='#xtract.trace'><p>Extract trace</p></a></li>
<li><a href='#yeardate'><p>time in decimal years</p></a></li>
<li><a href='#YPIX'><p>PICK Buttons for swig</p></a></li>
<li><a href='#YRsecdif'><p>Return difference in seconds</p></a></li>
<li><a href='#Zdate'><p>Date functions</p></a></li>
<li><a href='#zlocator'><p>zlocator</p></a></li>
<li><a href='#ZOOM.SEISN'><p>ZOOM SEISMIC Panel</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Seismic Time Series Analysis Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>4.2-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-22</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>RPMG, Rwave</td>
</tr>
<tr>
<td>Suggests:</td>
<td>stats</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonathan M. Lees [aut, cre],
  Jake Anderson [ctb],
  Leonard Lisapaly [ctb],
  Dave Harris [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Multiple interactive codes to view and analyze seismic data, via spectrum analysis, wavelet transforms, particle motion, hodograms.  Includes general time-series tools, plotting, filtering, interactive display.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Copyright:</td>
<td>see inst/COPYRIGHTS</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-25 21:53:21 UTC; lees</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-25 22:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='addpoints.hodo'>Add points to a hodogram plot </h2><span id='topic+addpoints.hodo'></span>

<h3>Description</h3>

<p>Add points to a hodogram plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addpoints.hodo(nbaz, dt, sx, flag = 1:10, pch = 3, col = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addpoints.hodo_+3A_nbaz">nbaz</code></td>
<td>
<p>matrix 3 by n </p>
</td></tr>
<tr><td><code id="addpoints.hodo_+3A_dt">dt</code></td>
<td>
<p>sample interval, s </p>
</td></tr>
<tr><td><code id="addpoints.hodo_+3A_sx">sx</code></td>
<td>
<p>x vector</p>
</td></tr>
<tr><td><code id="addpoints.hodo_+3A_flag">flag</code></td>
<td>
<p>output of idpoints.hodo </p>
</td></tr>
<tr><td><code id="addpoints.hodo_+3A_pch">pch</code></td>
<td>
<p>plot character </p>
</td></tr>
<tr><td><code id="addpoints.hodo_+3A_col">col</code></td>
<td>
<p>color for plotting </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side Effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>PMOT.drive, idpoints.hodo</p>

<hr>
<h2 id='addtix'>add tix to plot</h2><span id='topic+addtix'></span>

<h3>Description</h3>

<p>Add tick marks to edge of plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addtix(side = 3, pos = 0, tck = 0.005, at =c(0, 1), labels = FALSE, col = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addtix_+3A_side">side</code></td>
<td>
<p>side of plot 1-4</p>
</td></tr>
<tr><td><code id="addtix_+3A_pos">pos</code></td>
<td>
<p>position relative to side</p>
</td></tr>
<tr><td><code id="addtix_+3A_tck">tck</code></td>
<td>
<p>tick size</p>
</td></tr>
<tr><td><code id="addtix_+3A_at">at</code></td>
<td>
<p>locations along axis</p>
</td></tr>
<tr><td><code id="addtix_+3A_labels">labels</code></td>
<td>
<p>labels for tics</p>
</td></tr>
<tr><td><code id="addtix_+3A_col">col</code></td>
<td>
<p>color for ticks</p>
</td></tr>
<tr><td><code id="addtix_+3A_...">...</code></td>
<td>
<p>graphical parameters, par</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side Effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>par</p>

<hr>
<h2 id='addWPX'>
Add one pick to WPX file
</h2><span id='topic+addWPX'></span>

<h3>Description</h3>

<p>Add one pick to WPX file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addWPX(WPX, ppx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addWPX_+3A_wpx">WPX</code></td>
<td>
<p>WPX list
</p>
</td></tr>
<tr><td><code id="addWPX_+3A_ppx">ppx</code></td>
<td>
<p>WPX list
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adds one pick to end of list.
</p>


<h3>Value</h3>

<p>WPX list
</p>


<h3>Note</h3>

<p>Uses, the last pick as a reference.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>catWPX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s1 &lt;- setWPX(name="HI", yr=2011, jd=231, hr=4, mi=3, sec = runif(5)) 
s2 &lt;- setWPX(name="HI", yr=2011, jd=231, hr=4, mi=3, sec = runif(1)) 

s3 &lt;- addWPX(s1, s2)



</code></pre>

<hr>
<h2 id='applytaper'>Apply taper to seismic trace</h2><span id='topic+applytaper'></span>

<h3>Description</h3>

<p>Apply taper to ends of a time series for spectrum analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applytaper(f, p = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applytaper_+3A_f">f</code></td>
<td>
<p>signal</p>
</td></tr>
<tr><td><code id="applytaper_+3A_p">p</code></td>
<td>
<p>percent taper</p>
</td></tr>
</table>


<h3>Details</h3>

<p>10 percent taper is 5 percent on each end.
</p>


<h3>Value</h3>

<p>Tapered time series.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CE1)
Xamp  &lt;-  CE1$y[CE1$x&gt;5.443754 &amp; CE1$x&lt;5.615951]
Tamp  &lt;-  applytaper(Xamp, p = 0.05)
</code></pre>

<hr>
<h2 id='ASCII.SEISN'>ASCII RSEIS data dump
</h2><span id='topic+ASCII.SEISN'></span>

<h3>Description</h3>

<p>Write RSEIS list to a  file in ASCII format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ASCII.SEISN(GH, sel = 1, HEAD = TRUE, destdir='.' )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ASCII.SEISN_+3A_gh">GH</code></td>
<td>
<p>RSEIS list</p>
</td></tr>
<tr><td><code id="ASCII.SEISN_+3A_sel">sel</code></td>
<td>
<p>vector, select which ttraces to write</p>
</td></tr>
<tr><td><code id="ASCII.SEISN_+3A_head">HEAD</code></td>
<td>
<p>logical, TRUE will put a header in the file</p>
</td></tr>
<tr><td><code id="ASCII.SEISN_+3A_destdir">destdir</code></td>
<td>
<p>character, path to folder to deposit output file </p>
</td></tr>
</table>


<h3>Details</h3>

<p>  Used for data exchange for users who do not want to
use RSEIS.  The header consists of one line
start date (yr, jd, hr, min, sec) and sample rate (dt).
</p>


<h3>Value</h3>

<p>Side effects - files are created.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 
data("GH")
tempd = tempdir()
sel &lt;-  which(GH$COMPS == "V" &amp; GH$STNS=="CE1"  , destdir=tempd )
ASCII.SEISN(GH, sel = 1, HEAD = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='attime12'>Epoch Time Window</h2><span id='topic+attime12'></span>

<h3>Description</h3>

<p>Set a time window in Epoch days for extraction from a DB file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attime12(t1, t2 = t1, origyr = 1972, pre = 0, post = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attime12_+3A_t1">t1</code></td>
<td>
<p>list date-time 1</p>
</td></tr>
<tr><td><code id="attime12_+3A_t2">t2</code></td>
<td>
<p>list date-time 2</p>
</td></tr>
<tr><td><code id="attime12_+3A_origyr">origyr</code></td>
<td>
<p>origin year</p>
</td></tr>
<tr><td><code id="attime12_+3A_pre">pre</code></td>
<td>
<p>seconds before time 1</p>
</td></tr>
<tr><td><code id="attime12_+3A_post">post</code></td>
<td>
<p>seconds afer time 2</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If t2 is missing, t1=t2.
</p>


<h3>Value</h3>

<table>
<tr><td><code>vector</code></td>
<td>
<p>c(t1, t2) </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
j1  &lt;-  list(yr = 2005, jd= 214 , hr= 7 , mi= 1 ,sec= 0.5235)
j2  &lt;-  list(yr=2005, jd= 214 , hr= 7 , mi= 1 ,sec= 0.5235+6)

at &lt;-  attime12(j1, t2=j1, origyr=2005, pre=100, post=100)

### given an RSEIS format list
data(GH)
AT =  SEISNtime(GH)
ats = attime12(AT[[1]], t2 = AT[[2]],
   origyr =AT[[1]]$yr , pre = 0, post= 0)


</code></pre>

<hr>
<h2 id='AUGMENTbutfilt'>Butterworth filter with Augmentation
</h2><span id='topic+AUGMENTbutfilt'></span>

<h3>Description</h3>

<p>Design and apply butterworth low/high/band pass filters with augmentation of
the signal on either end to suppress edge effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AUGMENTbutfilt(a, fl = 0, fh = 0.5, deltat = 1, type = "BP",
proto = "BU", npoles = 5, chebstop = 30, trbndw = 0.3,
RM = FALSE, zp = TRUE, pct = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AUGMENTbutfilt_+3A_a">a</code></td>
<td>
<p>vector signal</p>
</td></tr>
<tr><td><code id="AUGMENTbutfilt_+3A_fl">fl</code></td>
<td>
<p>low frequency cut-off, default=0 </p>
</td></tr>
<tr><td><code id="AUGMENTbutfilt_+3A_fh">fh</code></td>
<td>
<p>high frequency cut-off, DEFAULT= (1/2dt) </p>
</td></tr>
<tr><td><code id="AUGMENTbutfilt_+3A_deltat">deltat</code></td>
<td>
<p>sample rate, s, deFAULT=1</p>
</td></tr>
<tr><td><code id="AUGMENTbutfilt_+3A_type">type</code></td>
<td>
<p>type of filter, one of c(&quot;LP&quot;,  &quot;HP&quot;,&quot;BP&quot; ,&quot;BR&quot; ), DEFAULT=&quot;BP&quot; </p>
</td></tr>
<tr><td><code id="AUGMENTbutfilt_+3A_proto">proto</code></td>
<td>
<p>prototype, c(&quot;BU&quot;, &quot;BE&quot; , &quot;C1&quot; ,&quot;C2&quot;), DEFAULT=&quot;BU&quot;  </p>
</td></tr>
<tr><td><code id="AUGMENTbutfilt_+3A_npoles">npoles</code></td>
<td>
<p>number of poles or order, DEFAULT=5</p>
</td></tr>
<tr><td><code id="AUGMENTbutfilt_+3A_chebstop">chebstop</code></td>
<td>
<p>Chebyshev stop band attenuation, DEFAULT=30.0</p>
</td></tr>
<tr><td><code id="AUGMENTbutfilt_+3A_trbndw">trbndw</code></td>
<td>
<p>Chebyshev transition bandwidth, DEFAULT=0.3</p>
</td></tr>
<tr><td><code id="AUGMENTbutfilt_+3A_rm">RM</code></td>
<td>
<p>Remove mean value from trace, default=FALSE</p>
</td></tr>
<tr><td><code id="AUGMENTbutfilt_+3A_zp">zp</code></td>
<td>
<p>zero phase filter, default=TRUE</p>
</td></tr>
<tr><td><code id="AUGMENTbutfilt_+3A_pct">pct</code></td>
<td>
<p>Percent augmentation applied to each side, default=0.1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creation of butfilt is a described by the following arguments:
</p>

<dl>
<dt>LP</dt><dd><p>low pass  </p>
</dd>
<dt>HP</dt><dd><p>high pass </p>
</dd>
<dt>BP</dt><dd><p>band pass </p>
</dd>
<dt>BR</dt><dd><p>band reject </p>
</dd>
<dt>BU</dt><dd><p>Butterworth </p>
</dd>
<dt>BE</dt><dd><p>Bessel </p>
</dd>
<dt>C1</dt><dd><p>Chebyshev type 1 </p>
</dd>
<dt>C2</dt><dd><p>Chebyshev type 2 </p>
</dd>
</dl>

<p>Arguments chebstop , trbndw  are ignored for non-chebyshev filters.
LP and HP filters are seet by specifying fl for HP filters and fh for
LP filters, the other argumentin each case is ignored.
</p>
<p>Mean values should be removed prior to calling this function, and then set RM=FALSE.
This is true especially if tapering is applied prior to filtering.
</p>
<p>Zero phase filter is achived by running filter back and forth.  Otherwise
a single pass is returned.  This should be equivalent to package signal filtfilt (from MATLAB).
</p>
<p>Augmentation involves copying the first and last percent of the signal,
reversiing the time and adding to the signal on each end.  This is then filtered,
and removed after filter is complete.  It is assumed that the important part of the signal is in
the center of the time series and the edges are less critical.  Then the augmented part has the same statistical
content as the edges of the signal (presumably noise) and will not affect the filtered signal considerably.
This is then thrown away prior to return.
</p>


<h3>Value</h3>

<p>Filtered time series with the augmentation removed after filter.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>butfilt</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CE1)

ts1  &lt;-  CE1$y
zz  &lt;-  AUGMENTbutfilt(ts1, fl=1, fh=15,  deltat=CE1$dt, type="LP" ,  proto="BU",
npoles=5 )



###  try plotting:
## Not run: 


data(KH, package ='RSEIS' )
w = KH$JSTR[[1]]
dt = KH$dt[1]

x = seq(from=0, by=dt, length=length(w));
plot(x,w, type='l')

par(mfrow=c(2,1) )
        
i=1
       fl = 1/50
fh= 1/2
       ftype = 'BP'
       ##########  normal band pass filter
        
 zz = butfilt(w, fl, fh,  dt, ftype ,  "BU")
     f.stamp =   filterstamp(fl=fl, fh=fh, type=ftype)

plot(x, zz, type='l', xlab='s', ylab='amp', main= f.stamp)
title(sub='butfilt')
       
       ####  
   zz1 = AUGMENTbutfilt(w, fl, fh,  dt,    type=ftype ,  proto="BU", zp=TRUE, pct=0.2 )
     f.stamp =   filterstamp(fl=fl, fh=fh, type=ftype)
plot(x, zz1, type='l', xlab='s', ylab='amp', main= f.stamp)
title(sub='AUGMENTbutfilt')




## End(Not run)


</code></pre>

<hr>
<h2 id='autoreg'>Auto-Regressive Spectrum Estimate</h2><span id='topic+autoreg'></span>

<h3>Description</h3>

<p>Auto-Regressive Spectrum Estimate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoreg(a, numf = 1024, pord = 100, PLOT = FALSE, f1 = 0.01, f2 = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoreg_+3A_a">a</code></td>
<td>
<p>signal </p>
</td></tr>
<tr><td><code id="autoreg_+3A_numf">numf</code></td>
<td>
<p>number of frequency points to calculate </p>
</td></tr>
<tr><td><code id="autoreg_+3A_pord">pord</code></td>
<td>
<p>order </p>
</td></tr>
<tr><td><code id="autoreg_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE=plot </p>
</td></tr>
<tr><td><code id="autoreg_+3A_f1">f1</code></td>
<td>
<p>low frequency </p>
</td></tr>
<tr><td><code id="autoreg_+3A_f2">f2</code></td>
<td>
<p>high frequency </p>
</td></tr>
</table>


<h3>Value</h3>

<p>LIST:
</p>
<table>
<tr><td><code>amp</code></td>
<td>
<p>amplitudes</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>frequencies, Hz</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>fft, mtapspec, plt.MTM0 </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CE1)
Xamp &lt;- CE1$y[CE1$x&gt;5.443754 &amp; CE1$x&lt;5.615951]

ZIM &lt;- autoreg(Xamp , numf=length(Xamp) , pord = 100, PLOT=FALSE,  f1=.01, f2=50)

</code></pre>

<hr>
<h2 id='brune.doom'>Brune Modeling</h2><span id='topic+brune.doom'></span>

<h3>Description</h3>

<p>Modeling the Brune spectrum with Graphical Diagnostics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brune.doom(amp, dt = 1, f1 = 0.01, f2 = 15, PLOTB = FALSE, tit = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brune.doom_+3A_amp">amp</code></td>
<td>
<p>signal </p>
</td></tr>
<tr><td><code id="brune.doom_+3A_dt">dt</code></td>
<td>
<p>deltaT </p>
</td></tr>
<tr><td><code id="brune.doom_+3A_f1">f1</code></td>
<td>
<p>low frequency for modeling</p>
</td></tr>
<tr><td><code id="brune.doom_+3A_f2">f2</code></td>
<td>
<p> high  frequency for modeling </p>
</td></tr>
<tr><td><code id="brune.doom_+3A_plotb">PLOTB</code></td>
<td>
<p>logical, TRUE=show diagnostic plots </p>
</td></tr>
<tr><td><code id="brune.doom_+3A_tit">tit</code></td>
<td>
<p>title for plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>SUCCESS</code></td>
<td>
<p>(0,1) for success or failure of modeling</p>
</td></tr>
<tr><td><code>WARN</code></td>
<td>
<p>flag = &quot;OK&quot;</p>
</td></tr>
<tr><td><code>tstar0</code></td>
<td>
<p> tstar0</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p> gamma</p>
</td></tr>
<tr><td><code>omega0</code></td>
<td>
<p>omega0</p>
</td></tr>
<tr><td><code>fc</code></td>
<td>
<p> fc</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>alpha</p>
</td></tr>
<tr><td><code>chisqrd</code></td>
<td>
<p>chi-squared misfit over region of fitting</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>References</h3>

<p>Lees, J. M. and G. T. Lindley  (1994): Three-dimensional Attenuation
Tomography at Loma Prieta:Inverting t* for Q, J. Geophys. Res., 99(B4), 6843-6863.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CE1)
plot(CE1$x, CE1$y, type='l')
Xamp = CE1$y[CE1$x&gt;5.443754 &amp; CE1$x&lt;5.615951]

BF = brune.doom( Xamp, CE1$dt ,f1=.5, f2=12 ,  PLOTB = TRUE)

</code></pre>

<hr>
<h2 id='brune.func'>Brune Earquake Model</h2><span id='topic+brune.func'></span>

<h3>Description</h3>

<p>Calculate Forward Brune model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brune.func(freq, omega0, tstar0, fc, alpha, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brune.func_+3A_freq">freq</code></td>
<td>
<p>frequency vector</p>
</td></tr>
<tr><td><code id="brune.func_+3A_omega0">omega0</code></td>
<td>
<p>low freq asymptote </p>
</td></tr>
<tr><td><code id="brune.func_+3A_tstar0">tstar0</code></td>
<td>
<p>T-star value</p>
</td></tr>
<tr><td><code id="brune.func_+3A_fc">fc</code></td>
<td>
<p>corner frequency </p>
</td></tr>
<tr><td><code id="brune.func_+3A_alpha">alpha</code></td>
<td>
<p>alpha parameter</p>
</td></tr>
<tr><td><code id="brune.func_+3A_gamma">gamma</code></td>
<td>
<p>gamma parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Brune model.
</p>


<h3>Value</h3>

<p>returns displacement spectrum from given parameters
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>References</h3>

<p>Lees, J. M. and G. T. Lindley  (1994): Three-dimensional Attenuation
Tomography at Loma Prieta:Inverting t* for Q, J. Geophys. Res., 99(B4), 6843-6863.
</p>


<h3>See Also</h3>

<p>brune.doom</p>

<hr>
<h2 id='brune.search'>Search for Brune fit to displacement spectrum </h2><span id='topic+brune.search'></span>

<h3>Description</h3>

<p>Model of the spectrum of a seismic arrival.  Uses Brune's Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brune.search(infreq, inspec, f1, f2, omega0, fcorn, tstar0, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brune.search_+3A_infreq">infreq</code></td>
<td>
<p>vector of frequencies</p>
</td></tr>
<tr><td><code id="brune.search_+3A_inspec">inspec</code></td>
<td>
<p>spectrum</p>
</td></tr>
<tr><td><code id="brune.search_+3A_f1">f1</code></td>
<td>
<p>low frequency, Hz</p>
</td></tr>
<tr><td><code id="brune.search_+3A_f2">f2</code></td>
<td>
<p> high frequency, Hz</p>
</td></tr>
<tr><td><code id="brune.search_+3A_omega0">omega0</code></td>
<td>
<p>initial starting low frequency asymptote</p>
</td></tr>
<tr><td><code id="brune.search_+3A_fcorn">fcorn</code></td>
<td>
<p> initial starting corner frequency</p>
</td></tr>
<tr><td><code id="brune.search_+3A_tstar0">tstar0</code></td>
<td>
<p>initial starting t* </p>
</td></tr>
<tr><td><code id="brune.search_+3A_gamma">gamma</code></td>
<td>
<p>initial starting gamma</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see paper by Lees and Lindley
</p>


<h3>Value</h3>

<p>list(omega0=omega0,tstar0=tstar3[3]  , fc=fcorn,  alpha=0,
gamma=gam3[3])
</p>
<table>
<tr><td><code>omega0</code></td>
<td>
<p> low frequency asymptote</p>
</td></tr>
<tr><td><code>fc</code></td>
<td>
<p>  corner frequency</p>
</td></tr>
<tr><td><code>tstar0</code></td>
<td>
<p>  t* </p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p> gamma</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>alpha parameter</p>
</td></tr>
<tr><td><code>chisqrd</code></td>
<td>
<p>chi-squared misfit over region of fitting</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>References</h3>

<p>Lees and Lindley</p>


<h3>See Also</h3>

<p>MTM</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(CE1)

####   set frequency range for modeling
f1  &lt;-  0.01
f2  &lt;-  14.0

##  set up data and parameters
amp  &lt;-   CE1$y
len2  &lt;-  2*next2(length(amp))
a  &lt;-  list(y=amp, dt=CE1$dt)

Spec  &lt;- MTMdisp(a, f1=f1, f2=f2, len2=len2, PLOT=FALSE )
 
lspec  &lt;-  Spec$displ

###  get initial estimate of parameters
xc  &lt;-  get.corner(  Spec$f , lspec, dt, f1, f2, PLOT=FALSE)

jmod  &lt;-  brune.search(Spec$f, lspec, f1, f2,
                 xc$omega0, xc$corn, xc$tstar0, 2.0)

</code></pre>

<hr>
<h2 id='butfilt'>Butterworth filter</h2><span id='topic+butfilt'></span>

<h3>Description</h3>

<p>Design and apply butterworth low/high/band pass filters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>butfilt(a, fl=0, fh=0.5, deltat=1, type="BP", proto="BU",
 npoles=5, chebstop=30.0, trbndw=0.3, RM=FALSE, zp=TRUE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="butfilt_+3A_a">a</code></td>
<td>
<p>vector signal</p>
</td></tr>
<tr><td><code id="butfilt_+3A_fl">fl</code></td>
<td>
<p>low frequency cut-off, default=0 </p>
</td></tr>
<tr><td><code id="butfilt_+3A_fh">fh</code></td>
<td>
<p>high frequency cut-off, DEFAULT= (1/2dt) </p>
</td></tr>
<tr><td><code id="butfilt_+3A_deltat">deltat</code></td>
<td>
<p>sample rate, s, deFAULT=1</p>
</td></tr>
<tr><td><code id="butfilt_+3A_type">type</code></td>
<td>
<p>type of filter, one of c(&quot;LP&quot;,  &quot;HP&quot;,&quot;BP&quot; ,&quot;BR&quot; ), DEFAULT=&quot;BP&quot; </p>
</td></tr>
<tr><td><code id="butfilt_+3A_proto">proto</code></td>
<td>
<p>prototype, c(&quot;BU&quot;, &quot;BE&quot; , &quot;C1&quot; ,&quot;C2&quot;), DEFAULT=&quot;BU&quot;  </p>
</td></tr>
<tr><td><code id="butfilt_+3A_npoles">npoles</code></td>
<td>
<p>number of poles or order, DEFAULT=5</p>
</td></tr>
<tr><td><code id="butfilt_+3A_chebstop">chebstop</code></td>
<td>
<p>Chebyshev stop band attenuation, DEFAULT=30.0</p>
</td></tr>
<tr><td><code id="butfilt_+3A_trbndw">trbndw</code></td>
<td>
<p>Chebyshev transition bandwidth, DEFAULT=0.3</p>
</td></tr>
<tr><td><code id="butfilt_+3A_rm">RM</code></td>
<td>
<p>Remove mean value from trace, default=FALSE</p>
</td></tr>
<tr><td><code id="butfilt_+3A_zp">zp</code></td>
<td>
<p>zero phase filter, default=TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creation of butfilt is a described by the following arguments:
</p>

<dl>
<dt>LP</dt><dd><p>low pass  </p>
</dd>
<dt>HP</dt><dd><p>high pass </p>
</dd>
<dt>BP</dt><dd><p>band pass </p>
</dd>
<dt>BR</dt><dd><p>band reject </p>
</dd>
<dt>BU</dt><dd><p>Butterworth </p>
</dd>
<dt>BE</dt><dd><p>Bessel </p>
</dd>
<dt>C1</dt><dd><p>Chebyshev type 1 </p>
</dd>
<dt>C2</dt><dd><p>Chebyshev type 2 </p>
</dd>
</dl>

<p>Arguments chebstop , trbndw  are ignored for non-chebyshev filters.
LP and HP filters are seet by specifying fl for HP filters and fh for
LP filters, the other argumentin each case is ignored.
</p>
<p>Mean values should be removed prior to calling this function, and then set RM=FALSE.
This is true especially if tapering is applied prior to filtering.
</p>
<p>Zero phase filter is achived by running filter back and forth.  Otherwise
a single pass is returned.  This should be equivalent to package signal filtfilt (from MATLAB).
</p>


<h3>Value</h3>

<p>Filtered time series. 
</p>


<h3>Author(s)</h3>

<p>originally written in FORTRAN by David Harris,
converted to C and modified by Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>Harris, D., 1990: XAPiir: A recursive digital filtering
package. United States: N. p., Web. doi:10.2172/6416972.</p>


<h3>See Also</h3>

<p>AUGMENTbutfilt</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CE1)

ts1  &lt;-  CE1$y
zz  &lt;-  butfilt(ts1, fl=1, fh=15,  deltat=CE1$dt, type="LP" ,  proto="BU",
npoles=5 )



###  try plotting:
## Not run: 
### the above, by default, is zero phase.
#####  next filter with non-zero-phase
z2  &lt;-  butfilt(ts1, fl=1, fh=15,  deltat=CE1$dt, type="LP" ,  proto="BU",
npoles=5, zp=FALSE )
ex = seq(from=0, by=CE1$dt, length=length(ts1))

plot(ex,  ts1, type='l')
lines(ex, zz, col='red')
lines(ex, z2, col='blue')


plot(ex[ex&lt;0.5],  ts1[ex&lt;0.5], type='l')
lines(ex[ex&lt;0.5], zz[ex&lt;0.5], col='red')
lines(ex[ex&lt;0.5], z2[ex&lt;0.5], col='blue')




## End(Not run)


</code></pre>

<hr>
<h2 id='BUTREPLOT'>Replot Function for SELBUT
</h2><span id='topic+BUTREPLOT'></span>

<h3>Description</h3>

<p>Replot Function for SELBUT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BUTREPLOT(opts, ncol = 5, HOZ = TRUE, TOP = TRUE,
 cols = "white", main = "", xlim = c(0, 1),
        ylim = c(0, 1), newplot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BUTREPLOT_+3A_opts">opts</code></td>
<td>
<p>character list of options
</p>
</td></tr>
<tr><td><code id="BUTREPLOT_+3A_ncol">ncol</code></td>
<td>
<p>number of columns
</p>
</td></tr>
<tr><td><code id="BUTREPLOT_+3A_hoz">HOZ</code></td>
<td>
<p>logical, TRUE=plot horizontally
</p>
</td></tr>
<tr><td><code id="BUTREPLOT_+3A_top">TOP</code></td>
<td>
<p>logical, TRUE=plot top-down
</p>
</td></tr>
<tr><td><code id="BUTREPLOT_+3A_cols">cols</code></td>
<td>
<p>colors
</p>
</td></tr>
<tr><td><code id="BUTREPLOT_+3A_main">main</code></td>
<td>
<p>character title
</p>
</td></tr>
<tr><td><code id="BUTREPLOT_+3A_xlim">xlim</code></td>
<td>
<p>x-limits in plotting region (user coordinates)
</p>
</td></tr>
<tr><td><code id="BUTREPLOT_+3A_ylim">ylim</code></td>
<td>
<p>y-limits in plotting region (user coordinates)
</p>
</td></tr>
<tr><td><code id="BUTREPLOT_+3A_newplot">newplot</code></td>
<td>
<p>logical, new plot?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used internally in SELBUT as a replotting function
</p>


<h3>Value</h3>

<p>list
</p>
<table>
<tr><td><code>M</code></td>
<td>
<p>x,y matrix of grid</p>
</td></tr>
<tr><td><code>dx</code></td>
<td>
<p>delta x</p>
</td></tr>
<tr><td><code>dy</code></td>
<td>
<p>delta y</p>
</td></tr>
<tr><td><code>rx</code></td>
<td>
<p>range of x</p>
</td></tr>
<tr><td><code>ry</code></td>
<td>
<p>range of y</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>SELBUT, swig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

STDLAB &lt;- c("DONE", "QUIT", "zoom.out", "zoom.in",
  "SELBUT", "FILT","UNFILT", "PSEL", "SGRAM",
       "WLET", "SPEC", "XTR" )
BUTREPLOT(STDLAB)


</code></pre>

<hr>
<h2 id='catWPX'>
Concatenate two WPX lists
</h2><span id='topic+catWPX'></span>

<h3>Description</h3>

<p>Concatenate (combine) two WPX lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catWPX(WPX, ppx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catWPX_+3A_wpx">WPX</code></td>
<td>
<p>WPX list
</p>
</td></tr>
<tr><td><code id="catWPX_+3A_ppx">ppx</code></td>
<td>
<p>WPX list
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adds second list to the end of the first list.
</p>


<h3>Value</h3>

<p>WPX list
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>addWPX,	setWPX,	checkWPX,	cleanWPX,	clusterWPX,	repairWPX,	saveWPX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
s1  &lt;-  setWPX(name="HI", yr=2011, jd=231, hr=4, mi=3, sec = runif(5)) 

s2  &lt;-  setWPX(name="BYE", yr=2011, jd=231, hr=4, mi=3, sec = runif(5)) 

s3  &lt;-  catWPX(s1, s2)

</code></pre>

<hr>
<h2 id='CE1'>Single Seismogram</h2><span id='topic+CE1'></span>

<h3>Description</h3>

<p>Single Seismogram from Coso California
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CE1)</code></pre>


<h3>Format</h3>

<p>list(x=0,  y=0,     dt=0,      name =&quot;&quot;,   Tpick=0,   mark =&quot;&quot;,  deltat=0)
</p>


<h3>References</h3>

<p>Lees, J.M., 2004. Scattering from a fault interface in the Coso geothermal field. Journal of Volcanology and Geothermal Research, 130(1-2):
61-75.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CE1)
plot(CE1$x, CE1$y, type='l')


</code></pre>

<hr>
<h2 id='checkWPX'>Check WPX
</h2><span id='topic+checkWPX'></span>

<h3>Description</h3>

<p>Check and verify WPX list for compliance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkWPX(wpx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkWPX_+3A_wpx">wpx</code></td>
<td>
<p>WPX list
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Perform several checks on completeness, length of components,
station names, component names and date-times 
of the WPX lists.
</p>


<h3>Value</h3>


<ul>
<li><p> 0 no problems
</p>
</li>
<li><p> 1 list incomplete
</p>
</li>
<li><p> 2 names incomplete
</p>
</li>
<li><p> 3 components incomplete
</p>
</li>
<li><p> 4 dates incomplete
</p>
</li></ul>



<h3>Note</h3>

<p>No action taken in the event an error occurs - 
see repairWPX to fix problems.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>addWPX,catWPX,	saveWPX,cleanWPX,clusterWPX,repairWPX,setWPX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
s1 &lt;- setWPX(name="HI", yr=2011, jd=231, hr=4, mi=3, sec = runif(5)) 

s1$col=NULL



</code></pre>

<hr>
<h2 id='choosfilt'>INteractive CHoice of Filter</h2><span id='topic+choosfilt'></span>

<h3>Description</h3>

<p>Choose Butterworth filter from a selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choosfilt(thefilts = thefilts, ncol = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choosfilt_+3A_thefilts">thefilts</code></td>
<td>
<p>list of filter parameters</p>
</td></tr>
<tr><td><code id="choosfilt_+3A_ncol">ncol</code></td>
<td>
<p>number of columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used for interactive choices in swig.
See example below.
</p>


<h3>Value</h3>

<p>filter parameter list:
</p>
<table>
<tr><td><code>ON</code></td>
<td>
<p>logical, TRUE=filter is on</p>
</td></tr>
<tr><td><code>fl</code></td>
<td>
<p>low frequency cut-off </p>
</td></tr>
<tr><td><code>fh</code></td>
<td>
<p>high frequency cut-off</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>type of filter, one of c(&quot;LP&quot;,  &quot;HP&quot;,&quot;BP&quot; ,&quot;BR&quot; )  </p>
</td></tr>
<tr><td><code>proto</code></td>
<td>
<p>prototype, c(&quot;BU&quot;, &quot;BE&quot; , &quot;C1&quot; ,&quot;C2&quot;)  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>butfilt, RPMG</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 thefilts &lt;-
          list(flo=
               c(0.02, 0.02, 0.02, 0.02, 0.02,   0.02,
                 0.02, 0.02, 0.02,  0.02, 0.02,  0.02,
                 0.02,
                 1/2, 1/50,1/100, 1/100,1,1,
                 0.2, 15, 5, 2,1,
                 100),
               fhi=
               c(1/10, 1/6, 1/5, 1/4, 1/3, 1/2,
                 0.2,  0.5, 1.0,  2.0, 3.0,  4.0,
                 7.0,
                 8, 1/2.0,1/5.0,1/10.0,10,5,
                 7.0, 100, 100, 100,10,
                 100),
             type =
               c("LP","LP", "LP", "LP", "LP", "LP",
                 "LP","LP", "LP", "LP", "LP", "LP",
                 "LP",
                 "BP", "BP","BP","BP","BP","BP",
                 "HP", "HP","HP", "HP","HP",
                 "None"))

if(interactive() ) choosfilt(thefilts = thefilts, ncol = 5)


</code></pre>

<hr>
<h2 id='CHOP.SEISN'>CHOP SEISmic structure</h2><span id='topic+CHOP.SEISN'></span>

<h3>Description</h3>

<p>Take a seismic structure and return a time limited version
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CHOP.SEISN(GH, sel = 1:4, WIN = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CHOP.SEISN_+3A_gh">GH</code></td>
<td>
<p>Seismic trace structure</p>
</td></tr>
<tr><td><code id="CHOP.SEISN_+3A_sel">sel</code></td>
<td>
<p>selection of traces</p>
</td></tr>
<tr><td><code id="CHOP.SEISN_+3A_win">WIN</code></td>
<td>
<p>time window c(0,1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Seismic trace structure
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>swig</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("GH")
sel &lt;-  which(GH$COMPS=="V")

KF  &lt;-  CHOP.SEISN(GH, sel=sel, WIN = c(0 , 5)  )

swig(KF, SHOWONLY=0)

</code></pre>

<hr>
<h2 id='circ'>Draw a circle</h2><span id='topic+circ'></span>

<h3>Description</h3>

<p>Draw a circle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ()
</code></pre>


<h3>Details</h3>

<p>Draw  a circle on new plot.
</p>


<h3>Value</h3>

<p>Graphical Side Effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>net</p>


<h3>Examples</h3>

<pre><code class='language-R'>circ()

</code></pre>

<hr>
<h2 id='cleanpickfile'>Clean up Pickfile structure</h2><span id='topic+cleanpickfile'></span>

<h3>Description</h3>

<p>Given a pickfile, clean out stations that do not ocnform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanpickfile(P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cleanpickfile_+3A_p">P</code></td>
<td>
<p>Pickfile list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>stations with name=&quot;&quot; are removed
</p>


<h3>Value</h3>

<table>
<tr><td><code>P</code></td>
<td>
<p>Pickfile list</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>EmptyPickfile</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- EmptyPickfile()
cleanpickfile(P)
</code></pre>

<hr>
<h2 id='cleanWPX'>Clean WPX
</h2><span id='topic+cleanWPX'></span>

<h3>Description</h3>

<p>Return an empty (clean) WPX.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanWPX()
</code></pre>


<h3>Details</h3>

<p>Returns an empty list with NA's and 0's 
</p>


<h3>Value</h3>

<p>WPX list
</p>


<h3>Note</h3>

<p>Used internally.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>addWPX,	catWPX,	checkWPX,repairWPX,clusterWPX,saveWPX, setWPX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
s0 &lt;- cleanWPX()

</code></pre>

<hr>
<h2 id='colorwig'>Plot a seimic trace colored in time</h2><span id='topic+colorwig'></span>

<h3>Description</h3>

<p>Plot a seimic trace colored in time.  useful for coordinating other
plots to specific times along a seismic trace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorwig(x1, y1, COL = rainbow(100))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorwig_+3A_x1">x1</code></td>
<td>
<p>x-coordinate (time)</p>
</td></tr>
<tr><td><code id="colorwig_+3A_y1">y1</code></td>
<td>
<p>y-coordinate (amplitude)</p>
</td></tr>
<tr><td><code id="colorwig_+3A_col">COL</code></td>
<td>
<p>color palette</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(KH)

x &lt;- KH$ex[KH$ex&gt;95&amp; KH$ex&lt;125]
y &lt;- KH$JSTR[[1]][KH$ex&gt;95&amp; KH$ex&lt;125]


colorwig(x , y , rainbow(100))




</code></pre>

<hr>
<h2 id='combineSEIS'>Combine SEIS lists
</h2><span id='topic+combineSEIS'></span>

<h3>Description</h3>

<p>Combine 2 SEIS format lists into one list suitable for swig.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineSEIS(IH, IV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineSEIS_+3A_ih">IH</code></td>
<td>
<p>SEIS list (swig input)
</p>
</td></tr>
<tr><td><code id="combineSEIS_+3A_iv">IV</code></td>
<td>
<p>SEIS list (swig input)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This will take two SEIS lists and merge them into one.
</p>


<h3>Value</h3>

<p>SEIS list suitable for swig.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>swig, Mine.seis, prepSEIS
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#######  say you have 2 databases - extract from each:
GH = Mine.seis(at1, at2, DB1, grepsta, grepcomp, kind = -1)
JH = Mine.seis(at1, at2, DB2, grepsta, grepcomp, kind = -1)
#### merge the 2 structures
BH = combineSEIS(GH, JH)
###### plot and interact
swig(BH)


## End(Not run)


</code></pre>

<hr>
<h2 id='comp.env'>Compare Envelopes</h2><span id='topic+comp.env'></span>

<h3>Description</h3>

<p>calculate and plot signal envelopes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp.env(ex, Y, PLOT = TRUE, stamps = stamps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comp.env_+3A_ex">ex</code></td>
<td>
<p>x-axis</p>
</td></tr>
<tr><td><code id="comp.env_+3A_y">Y</code></td>
<td>
<p>matrix of Y values</p>
</td></tr>
<tr><td><code id="comp.env_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE=plot</p>
</td></tr>
<tr><td><code id="comp.env_+3A_stamps">stamps</code></td>
<td>
<p>character vectors of ids</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes in an common x predictor and
compares the envelopes of each column in the Y matrix.
All the Y's must have the same length as ex.
</p>


<h3>Value</h3>

<p>Graphical Side effects.
returns envelope series.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>swig</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("GH")

temp &lt;- cbind(GH$JSTR[[1]], GH$JSTR[[2]], GH$JSTR[[3]])

atemp &lt;- temp[1168:1500, ]
ex  &lt;- seq(from=0,length=length(temp[1168:1500, 1]), by=GH$dt[1])

comp.env(ex, atemp, PLOT = TRUE, stamps = c("1","2", "3") )
</code></pre>

<hr>
<h2 id='Comp1Dvel'>Compare a pair of 1D models </h2><span id='topic+Comp1Dvel'></span>

<h3>Description</h3>

<p>plot a pair of 1D velocity Models for comparison
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Comp1Dvel(v, v2, col=c('blue', 'brown'), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Comp1Dvel_+3A_v">v</code></td>
<td>
<p>List structure for model 1</p>
</td></tr>
<tr><td><code id="Comp1Dvel_+3A_v2">v2</code></td>
<td>
<p>List structure for model 2</p>
</td></tr>
<tr><td><code id="Comp1Dvel_+3A_col">col</code></td>
<td>
<p>2-colors for P and swave</p>
</td></tr>
<tr><td><code id="Comp1Dvel_+3A_...">...</code></td>
<td>
<p>other graphical parameters (e.g. lty, lwd) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>Plot1Dvel, Get1Dvel, travel.time1D</p>


<h3>Examples</h3>

<pre><code class='language-R'>VEL &lt;- list()
VEL$'zp' &lt;- c(0,0.25,0.5,0.75,1,2,4,5,10,12)
VEL$'vp' &lt;- c(1.1,2.15,3.2,4.25,5.3,6.25,6.7,6.9,7,7.2)
VEL$'ep' &lt;- c(0,0,0,0,0,0,0,0,0,0)
VEL$'zs' &lt;- c(0,0.25,0.5,0.75,1,2,4,5,10,12)
VEL$'vs' &lt;- c(0.62,1.21,1.8,2.39,2.98,3.51,3.76,3.88,3.93,4.04)
VEL$'es' &lt;- c(0,0,0,0,0,0,0,0,0,0)
VEL$'name'  &lt;-  '/data/wadati/lees/Site/Hengil/krafla.vel'

VELNish &lt;-  list()
VELNish$'zp' &lt;- c(0,0.1,0.6,1.1,21.1)
VELNish$'vp' &lt;- c(2.8,3.4,4.1,4.7,4.7)
VELNish$'ep' &lt;- c(0,0,0,0,0)
VELNish$'zs' &lt;- c(0,0.1,0.6,1.1,21.1)
VELNish$'vs' &lt;- c(1.6,2,2.4,2.7,2.7)
VELNish$'es' &lt;- c(0,0,0,0,0)
VELNish$'name' &lt;- 'Nish'

Comp1Dvel(VEL, VELNish)

</code></pre>

<hr>
<h2 id='Comp1Dvels'>Compare 1D models </h2><span id='topic+Comp1Dvels'></span>

<h3>Description</h3>

<p>Plot 1D velocity Models for comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Comp1Dvels(INV, depth = 1:50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Comp1Dvels_+3A_inv">INV</code></td>
<td>
<p>vector of velocity models in memory</p>
</td></tr>
<tr><td><code id="Comp1Dvels_+3A_depth">depth</code></td>
<td>
<p>depth range for plotting</p>
</td></tr>
</table>


<h3>Details</h3>

<p>takes several velocity models, finds the range of all,
makes a plot so that all models fit on figure.
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>Plot1Dvel, Comp1Dvel, Get1Dvel</p>


<h3>Examples</h3>

<pre><code class='language-R'>
VEL &lt;- list()
VEL$'zp' &lt;- c(0,0.25,0.5,0.75,1,2,4,5,10,12)
VEL$'vp' &lt;- c(1.1,2.15,3.2,4.25,5.3,6.25,6.7,6.9,7,7.2)
VEL$'ep' &lt;- c(0,0,0,0,0,0,0,0,0,0)
VEL$'zs' &lt;- c(0,0.25,0.5,0.75,1,2,4,5,10,12)
VEL$'vs' &lt;- c(0.62,1.21,1.8,2.39,2.98,3.51,3.76,3.88,3.93,4.04)
VEL$'es' &lt;- c(0,0,0,0,0,0,0,0,0,0)
VEL$'name' &lt;- '/data/wadati/lees/Site/Hengil/krafla.vel'

VELNish &lt;- list()
VELNish$'zp' &lt;- c(0,0.1,0.6,1.1,21.1)
VELNish$'vp' &lt;- c(2.8,3.4,4.1,4.7,4.7)
VELNish$'ep' &lt;- c(0,0,0,0,0)
VELNish$'zs' &lt;- c(0,0.1,0.6,1.1,21.1)
VELNish$'vs' &lt;- c(1.6,2,2.4,2.7,2.7)
VELNish$'es' &lt;- c(0,0,0,0,0)
VELNish$'name' &lt;- 'Nish'

Comp1Dvels(c("VEL", "VELNish"))




</code></pre>

<hr>
<h2 id='complex.hodo'>HodoGram Plot</h2><span id='topic+complex.hodo'></span>

<h3>Description</h3>

<p>HodoGram Plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complex.hodo(nbaz, dt = dt, labs = c("Vertical", "North", "East"),
 COL = rainbow(100), STAMP = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complex.hodo_+3A_nbaz">nbaz</code></td>
<td>
<p>n by 3 matrix </p>
</td></tr>
<tr><td><code id="complex.hodo_+3A_dt">dt</code></td>
<td>
<p>time sample rate </p>
</td></tr>
<tr><td><code id="complex.hodo_+3A_labs">labs</code></td>
<td>
<p>labels for the components</p>
</td></tr>
<tr><td><code id="complex.hodo_+3A_col">COL</code></td>
<td>
<p>color palette</p>
</td></tr>
<tr><td><code id="complex.hodo_+3A_stamp">STAMP</code></td>
<td>
<p>character stamp for identification </p>
</td></tr>
</table>


<h3>Value</h3>

<p>sx = list
graphical side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("GH")

temp &lt;- cbind(GH$JSTR[[1]][1168:1500], GH$JSTR[[2]][1168:1500],
GH$JSTR[[3]][1168:1500])

pmolabs &lt;- c("Vertical", "North", "East")


sx &lt;- complex.hodo(temp, dt=GH$dt[1]  ,labs=pmolabs,
STAMP="Example",  COL=rainbow(100) )


</code></pre>

<hr>
<h2 id='COMPorder'>Seismic Component Order
</h2><span id='topic+COMPorder'></span>

<h3>Description</h3>

<p>Set seismic component order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>COMPorder(STNS, COMPS)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="COMPorder_+3A_stns">STNS</code></td>
<td>
<p>stations
</p>
</td></tr>
<tr><td><code id="COMPorder_+3A_comps">COMPS</code></td>
<td>
<p>components
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sets up components so they are ordered
according to V, N, E. used internally in swig.
</p>


<h3>Value</h3>

<p>order vector
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>

<hr>
<h2 id='contwlet'>Contour Wavelet Transform</h2><span id='topic+contwlet'></span>

<h3>Description</h3>

<p>Contour Wavelet Transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contwlet(baha, Ysig, dt, clev = 0.75, NLEV = 12,
 zscale = 1, zbound = NULL, col = col, ygrid = FALSE,
 WUNITS = "Volts", PEAX = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contwlet_+3A_baha">baha</code></td>
<td>
<p>Output of wavelet transform (image)</p>
</td></tr>
<tr><td><code id="contwlet_+3A_ysig">Ysig</code></td>
<td>
<p>input signal to wavelet transform</p>
</td></tr>
<tr><td><code id="contwlet_+3A_dt">dt</code></td>
<td>
<p>DeltaT, sample rate </p>
</td></tr>
<tr><td><code id="contwlet_+3A_clev">clev</code></td>
<td>
<p>levels for contours</p>
</td></tr>
<tr><td><code id="contwlet_+3A_nlev">NLEV</code></td>
<td>
<p>number of levels </p>
</td></tr>
<tr><td><code id="contwlet_+3A_zscale">zscale</code></td>
<td>
<p>scale of amplitudes </p>
</td></tr>
<tr><td><code id="contwlet_+3A_zbound">zbound</code></td>
<td>
<p>bounds for scale of interest</p>
</td></tr>
<tr><td><code id="contwlet_+3A_col">col</code></td>
<td>
<p>color for contour lines</p>
</td></tr>
<tr><td><code id="contwlet_+3A_ygrid">ygrid</code></td>
<td>
<p>logical, TRUE=add grid lines</p>
</td></tr>
<tr><td><code id="contwlet_+3A_wunits">WUNITS</code></td>
<td>
<p>Units of wavelet transform</p>
</td></tr>
<tr><td><code id="contwlet_+3A_peax">PEAX</code></td>
<td>
<p>peaks structure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side Effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>plotwlet, wlet.do, wlet.drive</p>

<hr>
<h2 id='convert2Rseis'>Convert Seismic data to RSEIS
</h2><span id='topic+convert2Rseis'></span>

<h3>Description</h3>

<p>Convert Seismic in SAC or SEGY format
to RSEIS native format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2Rseis(FLS, NEWDIR = ".", kind = 1, Iendian = "little", BIGLONG =
FALSE, NEWsta = "", NEWcomp = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert2Rseis_+3A_fls">FLS</code></td>
<td>
<p> array of File names
</p>
</td></tr>
<tr><td><code id="convert2Rseis_+3A_newdir">NEWDIR</code></td>
<td>
<p>Destination directory path
</p>
</td></tr>
<tr><td><code id="convert2Rseis_+3A_kind">kind</code></td>
<td>
<p>an integer 1, 2, 3; 0=R(DAT) , 1 = segy, 2 = sac, 3 = AH.
</p>
</td></tr>
<tr><td><code id="convert2Rseis_+3A_iendian">Iendian</code></td>
<td>
<p>Endian-ness of the data: 1,2,3: &quot;little&quot;, &quot;big&quot;, &quot;swap&quot;.
Default = 1 (little)
</p>
</td></tr>
<tr><td><code id="convert2Rseis_+3A_biglong">BIGLONG</code></td>
<td>
<p>logical, TRUE=long=8 bytes
</p>
</td></tr>
<tr><td><code id="convert2Rseis_+3A_newsta">NEWsta</code></td>
<td>
<p>character vector, stations associated with the vector of files
</p>
</td></tr>
<tr><td><code id="convert2Rseis_+3A_newcomp">NEWcomp</code></td>
<td>
<p>character vector, component name associated with the vector of files
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts the data to R format so it can be loaded with the load
command.
After this conversion, files should be loaded in subsequent
calls by using kind=0.
</p>


<h3>Value</h3>

<p>Side effects - creates new files on local system
</p>


<h3>Note</h3>

<p>JGET.seis  extracts digital seismic data from binary files
stored in the file system.  The program uses readBin for I/O
and passes data back to R.  Currently SAC, SEGY formats
are installed but it is easy to extend.  AH format
is available for LINUX systems, but there were problems compiling in
WINDOWS and MACOS so this feature was removed.
A filter for mseed format is currently being developed.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>JGET.seis, JSAC.seis , Mine.seis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

############   example of different scenarios
###  make list of the files
fls &lt;- list.files(path="/home/lees/SAC", pat="sac")

###  convert them to R

####   was created on a little endian machine
###          and is being read on a little endian
convert2Rseis(fls, NEWDIR = "/home/lees/MY_RDATA", kind = 2,
 Iendian = "little", BIGLONG = FALSE)


####   was created on a little endian machine
###     and is being read on a big endian
convert2Rseis(fls, NEWDIR = "/home/lees/MY_RDATA",
kind = 2, Iendian = "swap", BIGLONG = FALSE)

####   was created on a little endian machine and is being read on a big
####                       endian, with  the 64 bit machine used LONG=8
convert2Rseis(fls, NEWDIR = "/home/lees/MY_RDATA",
kind = 2, Iendian = "swap", BIGLONG = TRUE)


F90dir &lt;- "/mnt/flash/FUEGO/2009/F900"
kfl &lt;- list.files(path=F90dir, full.names=TRUE)

bname &lt;- basename(kfl)

###  now we want to convert the station names

###  extract the STA name from the file names:
STA &lt;- unlist( lapply(  strsplit(split="\.", bname), getmem , 3) )
###   extract comp name - in this case needs further extraction
COMP1 &lt;- unlist( lapply(  strsplit(split="\.", bname), getmem , 4) )
COMP &lt;- substr(COMP1, 3, 3)

convert2Rseis(kfl, NEWDIR="/home/lees/Site/Fuego/2009",
kind &lt;- 2, Iendian="swap" , BIGLONG=FALSE, NEWsta=STA, NEWcomp=COMP )







## End(Not run)


</code></pre>

<hr>
<h2 id='convertATT'>DateHour to List
</h2><span id='topic+convertATT'></span>

<h3>Description</h3>

<p>Convert a julian day+time to an RSEIS date list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertATT(at1, yr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertATT_+3A_at1">at1</code></td>
<td>
<p>julian day in Year, plus (hr+minutes+seconds)
</p>
</td></tr>
<tr><td><code id="convertATT_+3A_yr">yr</code></td>
<td>
<p>Year
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the data-list that RSEIS uses in calculations.  The Month and Day-of-month are also returned.
</p>


<h3>Value</h3>

<p>List with date and time
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>recdate, recdatel, dateList, dateStamp, filedatetime,
rangedatetime, yeardate, Zdate, as.POSIXct
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
yr = 2014
j = 233.1234
convertATT(j, yr)

</code></pre>

<hr>
<h2 id='correct.moveout'>Moveout Correction
</h2><span id='topic+correct.moveout'></span>

<h3>Description</h3>

<p>Shift traces accoring to given moveout times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct.moveout(GH, sel = 1, tims = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correct.moveout_+3A_gh">GH</code></td>
<td>
<p>RSEIS structure list
</p>
</td></tr>
<tr><td><code id="correct.moveout_+3A_sel">sel</code></td>
<td>
<p>index of which traces to be shifted 
</p>
</td></tr>
<tr><td><code id="correct.moveout_+3A_tims">tims</code></td>
<td>
<p>time shifts for each trace
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each trace listed in sel gets shifted forward or backward according to
time in tims.  This is useful for shifting traces according to a given
moveout curve.
</p>


<h3>Value</h3>

<p>RSEIS list structure returned with adjusted traces
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>

<hr>
<h2 id='DAYSperYEAR'>Days per Year</h2><span id='topic+DAYSperYEAR'></span>

<h3>Description</h3>

<p>Calculate the number of days per calendar year
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DAYSperYEAR(yr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DAYSperYEAR_+3A_yr">yr</code></td>
<td>
<p>year</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>days</code></td>
<td>
<p>integer number of days for a given year</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
years &lt;- seq(from=1850, to=2010, by=1)

DAYSperYEAR(years)


</code></pre>

<hr>
<h2 id='DECIMATE.SEISN'> Decimate a set of traces </h2><span id='topic+DECIMATE.SEISN'></span>

<h3>Description</h3>

<p>Decimate, or reduce the sample rate of
a set of traces stored in RSEIS format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DECIMATE.SEISN(TH, sel=1:length(TH$JSTR), dec=5 ,
 type="LP", proto="BU" , fl=2,  fh=10, RM=FALSE, zp=TRUE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DECIMATE.SEISN_+3A_th">TH</code></td>
<td>
<p>RSEIS list </p>
</td></tr>
<tr><td><code id="DECIMATE.SEISN_+3A_sel">sel</code></td>
<td>
<p>numeric,  which traces to select </p>
</td></tr>
<tr><td><code id="DECIMATE.SEISN_+3A_dec">dec</code></td>
<td>
<p>numeric, number of samples to skip </p>
</td></tr>
<tr><td><code id="DECIMATE.SEISN_+3A_type">type</code></td>
<td>
<p>type of filter (see butfilt)  </p>
</td></tr>
<tr><td><code id="DECIMATE.SEISN_+3A_proto">proto</code></td>
<td>
<p>filter proto type </p>
</td></tr>
<tr><td><code id="DECIMATE.SEISN_+3A_fl">fl</code></td>
<td>
<p>low pass frequency cut off </p>
</td></tr>
<tr><td><code id="DECIMATE.SEISN_+3A_fh">fh</code></td>
<td>
<p>high pass frequency cut off </p>
</td></tr>
<tr><td><code id="DECIMATE.SEISN_+3A_rm">RM</code></td>
<td>
<p>Remove mean value from trace, default=FALSE</p>
</td></tr>
<tr><td><code id="DECIMATE.SEISN_+3A_zp">zp</code></td>
<td>
<p>zero phase filter, default=TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reduces the number of samples by skipping every &quot;dec&quot;
sample.  A filter is applied prior to decimation.
</p>


<h3>Value</h3>

<p>an RSEIS list.
</p>


<h3>Note</h3>

<p> The dt, n and t2 are modified in info.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>butfilt </p>

<hr>
<h2 id='deconinst'>Deconvolve instrument response from seismic data</h2><span id='topic+deconinst'></span>

<h3>Description</h3>

<p>Deconvolve instrument response from seismic data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deconinst(data, sintr, KAL, key, Calibnew, waterlevel = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deconinst_+3A_data">data</code></td>
<td>
<p>Real vector of data</p>
</td></tr>
<tr><td><code id="deconinst_+3A_sintr">sintr</code></td>
<td>
<p>sample interval </p>
</td></tr>
<tr><td><code id="deconinst_+3A_kal">KAL</code></td>
<td>
<p>Kalibrated response list </p>
</td></tr>
<tr><td><code id="deconinst_+3A_key">key</code></td>
<td>
<p>number of instrument </p>
</td></tr>
<tr><td><code id="deconinst_+3A_calibnew">Calibnew</code></td>
<td>
<p>new instrument, complex vector or </p>
</td></tr>
<tr><td><code id="deconinst_+3A_waterlevel">waterlevel</code></td>
<td>
<p>waterlevel for low frequency division </p>
</td></tr>
</table>


<h3>Details</h3>

<p>To avoid problems with dividing by very small numbers,
water level is set =1.e-8
</p>


<h3>Value</h3>

<p>deconvolved signal
</p>


<h3>Note</h3>

<p>Calibnew(1)==3 then use a cos (hanning) taper
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>PreSet.Instr, ReadSet.Instr, INSTresponse</p>


<h3>Examples</h3>

<pre><code class='language-R'>

Kal &lt;- PreSet.Instr()
amp &lt;- rnorm(1024)
Calibnew &lt;- c(1,1.0, 0.0 )

dy  &lt;- deconinst(amp, 0.008, Kal,1, Calibnew, waterlevel=1.e-8)



</code></pre>

<hr>
<h2 id='deleteWPX'>
Delete  picks to WPX file
</h2><span id='topic+deleteWPX'></span>

<h3>Description</h3>

<p>Delete pick to WPX file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deleteWPX(WPX, ind=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deleteWPX_+3A_wpx">WPX</code></td>
<td>
<p>WPX list
</p>
</td></tr>
<tr><td><code id="deleteWPX_+3A_ind">ind</code></td>
<td>
<p>integer, index to delete
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Deletes one pick to end of list.
</p>


<h3>Value</h3>

<p>WPX list
</p>


<h3>Note</h3>

<p>Uses, the last pick as a reference.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>addWPX, catWPX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s1 &lt;- setWPX(name="HI", yr=2011, jd=231, hr=4, mi=3, sec = runif(5)) 
s2 &lt;- setWPX(name="HI", yr=2011, jd=231, hr=4, mi=3, sec = runif(1)) 

s3 &lt;- addWPX(s1, s2)

s4 &lt;- deleteWPX(s3, ind=2:3)

</code></pre>

<hr>
<h2 id='detail.pick'>Detail Pick on 3-component seismogram</h2><span id='topic+detail.pick'></span>

<h3>Description</h3>

<p>Pops up three components and prepares menu items for picking
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detail.pick(y, ex, dt, TIT = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detail.pick_+3A_y">y</code></td>
<td>
<p>signal amplitudes</p>
</td></tr>
<tr><td><code id="detail.pick_+3A_ex">ex</code></td>
<td>
<p>x-axis </p>
</td></tr>
<tr><td><code id="detail.pick_+3A_dt">dt</code></td>
<td>
<p>deltaT, sample rate, s</p>
</td></tr>
<tr><td><code id="detail.pick_+3A_tit">TIT</code></td>
<td>
<p>title</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates interactive session for picking seismograms.  Is called from swig.
</p>


<h3>Value</h3>

<p>KSAVE = list(x=xsave, y=ysave)
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>swig</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CE1)

  detail.pick(CE1$y, CE1$x, CE1$dt, TIT = "")
   

</code></pre>

<hr>
<h2 id='detrend'>Remove trend from time series signal</h2><span id='topic+detrend'></span>

<h3>Description</h3>

<p>Remove trend from time series signal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detrend(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detrend_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Removes the trend from a signal.
</p>


<h3>Value</h3>

<p>vector with linear trend removed.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>mean</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dt &lt;- 0.001

 t &lt;- seq(0, 6, by=0.001)


y &lt;- 5*sin(2*pi*10*t)

plot(t,y, type='l')

y &lt;- y  + 3 * t
plot(t,y, type='l')


dy &lt;- detrend(y)

plot(t,dy, type='l')

</code></pre>

<hr>
<h2 id='DISPLACE.SEISN'>Displacement seismogram</h2><span id='topic+DISPLACE.SEISN'></span>

<h3>Description</h3>

<p>Removes seismic instrument response and integrates to displacement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DISPLACE.SEISN(TH, sel = 1:length(TH$JSTR), inst = 1,
Kal = Kal,waterlevel = 1e-08,  FILT = list(ON = FALSE,
 fl = 1/30, fh = 7, type = "HP", proto = "BU",RM=FALSE, zp=TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DISPLACE.SEISN_+3A_th">TH</code></td>
<td>
<p>list structure of seismic traces</p>
</td></tr>
<tr><td><code id="DISPLACE.SEISN_+3A_sel">sel</code></td>
<td>
<p>select which tracesin list to deconvolve</p>
</td></tr>
<tr><td><code id="DISPLACE.SEISN_+3A_inst">inst</code></td>
<td>
<p>index to instrument in Kal list for calibration and
instrument response </p>
</td></tr>
<tr><td><code id="DISPLACE.SEISN_+3A_kal">Kal</code></td>
<td>
<p>list of instrument responses</p>
</td></tr>
<tr><td><code id="DISPLACE.SEISN_+3A_waterlevel">waterlevel</code></td>
<td>
<p>waterlevel for low frequency division </p>
</td></tr>
<tr><td><code id="DISPLACE.SEISN_+3A_filt">FILT</code></td>
<td>
<p>filter output, after instrumentation, see butfilt</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Instrument responses are lists of poles and zeros for each instrument defined.
</p>


<h3>Value</h3>

<p>Same as input list with new traces representing displacement versus velocity
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>VELOCITY.SEISN, deconinst, butfilt </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
Majorevent   &lt;-  250+8/24+2250/(24*3600)

at1  &lt;-  Majorevent - 1/24
at2  &lt;-  Majorevent + 1/24


TH  &lt;-   Mine.seis(at1, at2, DB99, NULL, NULL , kind = 1,
 Iendian=1, BIGLONG=FALSE, CHOP=TRUE, verbose=FALSE)
inst  &lt;-  rep(0, length(TH$STNS))
inst[TH$COMPS %in% c("V", "N", "E")]  &lt;-  1
inst[TH$STNS=="krm2" &amp;  TH$COMPS %in% c("V", "N", "E")]  &lt;-  2
inst[TH$STNS=="krm0" &amp;  TH$COMPS %in% c("V", "N", "E")]  &lt;-  2


DH  &lt;-   DISPLACE.SEISN(TH, sel = which(inst&gt;0) , inst = inst,
Kal = Kal, FILT = list(ON = FALSE, fl = 1/200, fh = 7,
type = "BP", proto = "BU"))

  SOUT  &lt;-   swig(DH, PADDLAB=c("CENTER", "fspread", "HALF", "PREV"),
filters=thefilts  )



## End(Not run)



</code></pre>

<hr>
<h2 id='distseisnXY'>Distances from an RSEIS list</h2><span id='topic+distseisnXY'></span>

<h3>Description</h3>

<p>Calculate euclidian distances from an RSEIS seismic data list,
stations and event location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distseisnXY(GH, sta=list(nam="", x=0 , y=0 , z=0) , LOC=list(x=0, y=0 , z=0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distseisnXY_+3A_gh">GH</code></td>
<td>
<p> Rseis list structure</p>
</td></tr>
<tr><td><code id="distseisnXY_+3A_sta">sta</code></td>
<td>
<p>station list(x,y,z) </p>
</td></tr>
<tr><td><code id="distseisnXY_+3A_loc">LOC</code></td>
<td>
<p>location list(x,y,z)  </p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>d</code></td>
<td>
<p>vector of distances in km, matching the stations in the RSEIS
list.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Locations of stations and source should be projected.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(GH)
###   assume the lat lon in GH are x, y (projected)

staxy &lt;-  list(nam=GH$stafile$name, x=GH$stafile$lon,
               y=GH$stafile$lat, z=GH$stafile$z)
 LOC &lt;- list(x=GH$pickfile$LOC$lon, y=GH$pickfile$LOC$lat,
             z=GH$pickfile$LOC$z)
distseisnXY(GH, sta =staxy, LOC = LOC)



</code></pre>

<hr>
<h2 id='DISTxsec'>Distance Cross section
</h2><span id='topic+DISTxsec'></span>

<h3>Description</h3>

<p>Plot time series vertically at specified distances.
Produces a seismic cross section with correct spacing between traces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DISTxsec(GH, dist, TIM.WIN = c(0, 3600), sel, trace.width = 10,
col = "black", text.col = "blue", text.font = 2, text.size = 0.8,
 add = FALSE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DISTxsec_+3A_gh">GH</code></td>
<td>
<p>RSEIS seismic trace structure, output of prepSEIS used in swig
</p>
</td></tr>
<tr><td><code id="DISTxsec_+3A_dist">dist</code></td>
<td>
<p>distance for each station along x-axis
</p>
</td></tr>
<tr><td><code id="DISTxsec_+3A_tim.win">TIM.WIN</code></td>
<td>
<p>time window for cross section
</p>
</td></tr>
<tr><td><code id="DISTxsec_+3A_sel">sel</code></td>
<td>
<p>numeric, index of selected traces to plot.  
</p>
</td></tr>
<tr><td><code id="DISTxsec_+3A_trace.width">trace.width</code></td>
<td>
<p>Width of each trace in plot.  Should be in same
units as x-axis
</p>
</td></tr>
<tr><td><code id="DISTxsec_+3A_col">col</code></td>
<td>
<p>color for traces.  If vector, each trace is plotted with
assigned color.
</p>
</td></tr>
<tr><td><code id="DISTxsec_+3A_text.col">text.col</code></td>
<td>
<p>color for text identifying each trace.
</p>
</td></tr>
<tr><td><code id="DISTxsec_+3A_text.font">text.font</code></td>
<td>
<p>font  for text identifying each trace.
</p>
</td></tr>
<tr><td><code id="DISTxsec_+3A_text.size">text.size</code></td>
<td>
<p>size of text  for identifying each trace.
</p>
</td></tr>
<tr><td><code id="DISTxsec_+3A_add">add</code></td>
<td>
<p>logical, Whether to add traces, or just set up the figure
</p>
</td></tr>
<tr><td><code id="DISTxsec_+3A_plot">plot</code></td>
<td>
<p>logical, whether to plotthe traces.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Distances should be a vector for each trace in the RSEIS list.
</p>


<h3>Value</h3>

<p>vector of x-y coordinates of the plot.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>swig, prepSEIS
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#### example using data in the RSEIS package
data(GH)
####  get the source location
lat.org  = GH$pickfile$LOC$lat
lon.org  = GH$pickfile$LOC$lon
####  get the station locations
g1 =GH$stafile
#### find the distance to each station
gd = rdistaz(lat.org, lon.org, g1$lat, g1$lon )

##### optional, filter the data
sel= which( GH$COMPS == 'V')
### filter traces
Fdef  &lt;-  list(ON=TRUE, fl=1, fh=1, type="HP", proto="BU", RM=TRUE, zp=TRUE )
KF  &lt;-  FILT.SEISN(GH, FILT=Fdef)

### match the stations in GH to the station distances
m1 = match(GH$STNS  , g1$name) 
dist.GH = gd$dist[m1]
TIM.WIN = range(GH$ex) 


#######  prepare plot, but do not add traces
A = DISTxsec(KF, dist.GH, TIM.WIN, sel, trace.width = 0.5 , add=FALSE,
plot=FALSE )
#####  add traces
B = DISTxsec(KF, dist.GH, TIM.WIN, sel, trace.width = 0.5 , add=TRUE,
plot=TRUE, col='black'  , text.col='red', text.size=1  )





## End(Not run)





</code></pre>

<hr>
<h2 id='DO.PMOT.ARR'>Particle Motion Analysis with arrows</h2><span id='topic+DO.PMOT.ARR'></span>

<h3>Description</h3>

<p>Plot particle motion arrows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DO.PMOT.ARR(E, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DO.PMOT.ARR_+3A_e">E</code></td>
<td>
<p>East component</p>
</td></tr>
<tr><td><code id="DO.PMOT.ARR_+3A_n">N</code></td>
<td>
<p>East Component</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>PMOT.drive</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run:  DO.PMOT.ARR(x,y) 

</code></pre>

<hr>
<h2 id='doGABOR.AR'>Gabor Transform with AR spectrum method
</h2><span id='topic+doGABOR.AR'></span>

<h3>Description</h3>

<p>Gabor Transform with AR spectrum method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doGABOR.AR(Xamp, DT = 0.008, multi = 1, scale.def = 0, TWIN = 2, TSKIP =
0.2, PCTTAP = 0.05, pord=100, PLOT=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doGABOR.AR_+3A_xamp">Xamp</code></td>
<td>
<p>signal
</p>
</td></tr>
<tr><td><code id="doGABOR.AR_+3A_dt">DT</code></td>
<td>
<p>sample rate interval (s)
</p>
</td></tr>
<tr><td><code id="doGABOR.AR_+3A_multi">multi</code></td>
<td>
<p>Multiples of time window estimate
</p>
</td></tr>
<tr><td><code id="doGABOR.AR_+3A_scale.def">scale.def</code></td>
<td>
<p>scaling flag for plotting (0=raw, 1=log, 2=sqrt)
</p>
</td></tr>
<tr><td><code id="doGABOR.AR_+3A_twin">TWIN</code></td>
<td>
<p>time for window
</p>
</td></tr>
<tr><td><code id="doGABOR.AR_+3A_tskip">TSKIP</code></td>
<td>
<p>time for skip
</p>
</td></tr>
<tr><td><code id="doGABOR.AR_+3A_pcttap">PCTTAP</code></td>
<td>
<p>percent of taper to apply to individual windows
</p>
</td></tr>
<tr><td><code id="doGABOR.AR_+3A_pord">pord</code></td>
<td>
<p> order for the AR process (default=100) </p>
</td></tr>
<tr><td><code id="doGABOR.AR_+3A_plot">PLOT</code></td>
<td>
<p> logical, TRUE=plot to device </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This is a spectrogram function similar to the Gabor Transform
but uses the AR method  for spectrum estimation.
</p>


<h3>Value</h3>

<p>list
</p>
<table>
<tr><td><code>sig</code></td>
<td>
<p>input signal</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>deltat</p>
</td></tr>
<tr><td><code>numfreqs</code></td>
<td>
<p>Number of frequencies output</p>
</td></tr>
<tr><td><code>wpars</code></td>
<td>
<p>input parameters list(Nfft=numfreqs,  Ns=Ns, Nov=Nov, fl=fl, fh=fh)</p>
</td></tr>
<tr><td><code>DSPEC</code></td>
<td>
<p>spectrum image</p>
</td></tr>
<tr><td><code>HIMAT</code></td>
<td>
<p>matrix with high values of F-test at 90 percent confidence </p>
</td></tr>
<tr><td><code>freqs</code></td>
<td>
<p>output frequencies (y axis)</p>
</td></tr>
<tr><td><code>tims</code></td>
<td>
<p>output times (x-axis) </p>
</td></tr>
</table>


<h3>Note</h3>

<p>The main difference between this and other similar calls is the
way the windows are determined.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Lees, J. M. and Park, J., 1995: Multiple-taper spectral analysis: A
stand-alone C-subroutine, <em>Computers and Geology</em>, 21(2), 199-236.
</p>
<p>Percival, Donald B.,Walden, Andrew T. (1993):Spectral Analysis for
Physical Applications,Cambridge University Press, Cambridge,  583p.
</p>


<h3>See Also</h3>

<p>evolfft, evolMTM, MTM.drive, GETARAIC, doGABOR.AR, DOsgram, doGABOR.MTM
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(KH)
###   swig(KH)

Xamp &lt;- KH$JSTR[[1]]
Xamp &lt;- Xamp[57914:72989]


EV &lt;- doGABOR.AR(Xamp, DT = KH$dt[1] , multi = 1, scale.def = 0,
TWIN = 2, TSKIP = 0.2, PCTTAP = 0.05)


</code></pre>

<hr>
<h2 id='doGABOR.MTM'>Evolutive MTM Spectrum
</h2><span id='topic+doGABOR.MTM'></span>

<h3>Description</h3>

<p> Time varying Auto-Regressive Spectrum (Gabor Transform)
using MTM.  This is a driver for MTMgabor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doGABOR.MTM(Xamp, DT = 0.008, ppoint=95 , multi = 1,
 scale.def = 0, TWIN = 2, TSKIP = 0.2, PCTTAP = 0.05,  PLOT=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doGABOR.MTM_+3A_xamp">Xamp</code></td>
<td>
<p>signal
</p>
</td></tr>
<tr><td><code id="doGABOR.MTM_+3A_dt">DT</code></td>
<td>
<p>sample rate interval (s)
</p>
</td></tr>
<tr><td><code id="doGABOR.MTM_+3A_ppoint">ppoint</code></td>
<td>
<p>percent confidence for F-test (default=95) </p>
</td></tr>
<tr><td><code id="doGABOR.MTM_+3A_multi">multi</code></td>
<td>
<p>Multiples of time window estimate
</p>
</td></tr>
<tr><td><code id="doGABOR.MTM_+3A_scale.def">scale.def</code></td>
<td>
<p>scaling flag for plotting (0=raw, 1=log, 2=sqrt)
</p>
</td></tr>
<tr><td><code id="doGABOR.MTM_+3A_twin">TWIN</code></td>
<td>
<p>time for window
</p>
</td></tr>
<tr><td><code id="doGABOR.MTM_+3A_tskip">TSKIP</code></td>
<td>
<p>time for skip
</p>
</td></tr>
<tr><td><code id="doGABOR.MTM_+3A_pcttap">PCTTAP</code></td>
<td>
<p>percent of taper to apply to individual windows
</p>
</td></tr>
<tr><td><code id="doGABOR.MTM_+3A_plot">PLOT</code></td>
<td>
<p> logical, TRUE=plot to device </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This is a spectrogram function similar to the Gabor Transform
but uses the MTM (multi-taper method) for spectrum estimation.
This is a non-interactive version of MTM.drive.
</p>


<h3>Value</h3>

<p>list output of MTMgabor:
</p>
<table>
<tr><td><code>sig</code></td>
<td>
<p>input signal</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>deltat</p>
</td></tr>
<tr><td><code>numfreqs</code></td>
<td>
<p>Number of frequencies output</p>
</td></tr>
<tr><td><code>wpars</code></td>
<td>
<p>input parameters list(Nfft=numfreqs,
Ns=Ns, Nov=Nov, fl=fl, fh=fh)</p>
</td></tr>
<tr><td><code>DSPEC</code></td>
<td>
<p>spectrum image</p>
</td></tr>
<tr><td><code>HIMAT</code></td>
<td>
<p>matrix with high values of F-test at 90 percent confidence
</p>
</td></tr>
<tr><td><code>DOFMAT</code></td>
<td>
<p>Matrix image of degrees of freedom</p>
</td></tr>
<tr><td><code>FVMAT</code></td>
<td>
<p>Matrix image of F-test values</p>
</td></tr>
<tr><td><code>kdof</code></td>
<td>
<p>test degrees of freedom=2*nwin-2</p>
</td></tr>
<tr><td><code>ppoint</code></td>
<td>
<p>percentage point for confidence bounds</p>
</td></tr>
<tr><td><code>freqs</code></td>
<td>
<p>output frequencies (y axis)</p>
</td></tr>
<tr><td><code>tims</code></td>
<td>
<p>output times (x-axis) </p>
</td></tr>
</table>


<h3>Note</h3>

<p>The main difference between this and other similar calls is the
way the windows are determined.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Lees, J. M. and Park, J., 1995: Multiple-taper spectral analysis: A
stand-alone C-subroutine, <em>Computers and Geology</em>, 21(2), 199-236.
</p>
<p>Percival, Donald B.,Walden, Andrew T. (1993):Spectral Analysis for
Physical Applications,Cambridge University Press, Cambridge,  583p.
</p>


<h3>See Also</h3>

<p>MTMgabor, evolfft, evolMTM, MTM.drive, GETARAIC, doGABOR.AR, DOsgram</p>


<h3>Examples</h3>

<pre><code class='language-R'>


data(KH)
###   swig(KH)

Xamp = KH$JSTR[[1]]
Xamp = Xamp[57914:64914]

EV = doGABOR.MTM(Xamp, DT = KH$dt[1], multi = 1, scale.def = 0,
TWIN = 1, TSKIP = .1, PCTTAP = 0.05)

</code></pre>

<hr>
<h2 id='doMYBUTTS'>Dummy Button Function</h2><span id='topic+doMYBUTTS'></span>

<h3>Description</h3>

<p>This is a dummy button function showing how buttons can be created on
the fly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doMYBUTTS(butt = "", clicks = NULL, x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doMYBUTTS_+3A_butt">butt</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="doMYBUTTS_+3A_clicks">clicks</code></td>
<td>
<p>clicks</p>
</td></tr>
<tr><td><code id="doMYBUTTS_+3A_x">x</code></td>
<td>
<p>locations</p>
</td></tr>
</table>

<hr>
<h2 id='DOsgram'>Gabor transform
</h2><span id='topic+DOsgram'></span>

<h3>Description</h3>

<p>Gabor transform with simple spectrum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DOsgram(Xamp, DT = 0.008, multi = 1, scale.def = 0,
 TWIN = 2, TSKIP = 0.2, PCTTAP = 0.05, PLOT=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DOsgram_+3A_xamp">Xamp</code></td>
<td>
<p>signal
</p>
</td></tr>
<tr><td><code id="DOsgram_+3A_dt">DT</code></td>
<td>
<p>sample rate interval (s)
</p>
</td></tr>
<tr><td><code id="DOsgram_+3A_multi">multi</code></td>
<td>
<p>Multiples of time window estimate
</p>
</td></tr>
<tr><td><code id="DOsgram_+3A_scale.def">scale.def</code></td>
<td>
<p>scaling flag for plotting (0=raw, 1=log, 2=sqrt)
</p>
</td></tr>
<tr><td><code id="DOsgram_+3A_twin">TWIN</code></td>
<td>
<p>time for window
</p>
</td></tr>
<tr><td><code id="DOsgram_+3A_tskip">TSKIP</code></td>
<td>
<p>time for skip
</p>
</td></tr>
<tr><td><code id="DOsgram_+3A_pcttap">PCTTAP</code></td>
<td>
<p>percent of taper to apply to individual windows
</p>
</td></tr>
<tr><td><code id="DOsgram_+3A_plot">PLOT</code></td>
<td>
<p> logical, TRUE=plot to device </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This is a non-interactive version of SPECT.drive.
</p>


<h3>Value</h3>

<p>list
</p>
<table>
<tr><td><code>sig</code></td>
<td>
<p>input signal</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>deltat</p>
</td></tr>
<tr><td><code>numfreqs</code></td>
<td>
<p>Number of frequencies output</p>
</td></tr>
<tr><td><code>wpars</code></td>
<td>
<p>input parameters list(Nfft=numfreqs,
Ns=Ns, Nov=Nov, fl=fl, fh=fh)</p>
</td></tr>
<tr><td><code>DSPEC</code></td>
<td>
<p>spectrum image</p>
</td></tr>
<tr><td><code>freqs</code></td>
<td>
<p>output frequencies (y axis)</p>
</td></tr>
<tr><td><code>tims</code></td>
<td>
<p>output times (x-axis) </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Lees, J. M. and Park, J., 1995: Multiple-taper spectral analysis: A
stand-alone C-subroutine, <em>Computers and Geology</em>, 21(2), 199-236.
</p>


<h3>See Also</h3>

<p>evolMTM, evolfft, evolAR, plotevol
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(KH)
###   swig(KH)

Xamp  &lt;-  KH$JSTR[[1]]
Xamp  &lt;-  Xamp[57914:72989]

Nfft &lt;- 1024   ###  fft length
Ns &lt;- 512      ###  number of samples in a window
Nov &lt;- 480    ###  number of samples of overlap per window
fl &lt;- 0        ###  low frequency to return
fh &lt;- 12     ###  high frequency to return


EV  &lt;-  DOsgram(Xamp, DT = 0.008, multi = 1, scale.def = 0,
TWIN = 2, TSKIP = 0.2, PCTTAP = 0.05)






</code></pre>

<hr>
<h2 id='dowiggles'>Plot wiggles
</h2><span id='topic+dowiggles'></span>

<h3>Description</h3>

<p>Plot wiggles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dowiggles(AMAT, dt, dx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dowiggles_+3A_amat">AMAT</code></td>
<td>
<p>Matrix of seismic time series
</p>
</td></tr>
<tr><td><code id="dowiggles_+3A_dt">dt</code></td>
<td>
<p>time interval, sec
</p>
</td></tr>
<tr><td><code id="dowiggles_+3A_dx">dx</code></td>
<td>
<p>x-spacing
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>graphical side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>wiggleimage, matsquiggle
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S1 = symshot1()

dowiggles(S1$smograms,S1$dt, S1$x)



</code></pre>

<hr>
<h2 id='editDB'>Edit Data Base
</h2><span id='topic+editDB'></span><span id='topic+pathDB'></span>

<h3>Description</h3>

<p>Edit, or remove items from
an RSEIS data base after it has been read in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editDB(DB, w)
pathDB(DB,  path1="", path2="")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="editDB_+3A_db">DB</code></td>
<td>
<p>RSEIS data base
</p>
</td></tr>
<tr><td><code id="editDB_+3A_w">w</code></td>
<td>
<p>vector of index items to remove
</p>
</td></tr>
<tr><td><code id="editDB_+3A_path1">path1</code></td>
<td>
<p>character for old path 
</p>
</td></tr>
<tr><td><code id="editDB_+3A_path2">path2</code></td>
<td>
<p>character for new path to replace old path 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The DB is a list.  The program cycles through the elements of the list
and removes all lnes that correspond to the
idecies given in w.
</p>


<h3>Value</h3>

<p>Returns a DB list
</p>


<h3>Note</h3>

<p>A problem arises if the makeDB program reads in, or tries to read
in
files that have not data base header information.
This program can eliminate these from the data base.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>makeDB, infoDB 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

DB &lt;- makeDB('/media/disk-1/TUNG_2010', "2010",
kind=2,Iendian=1, BIGLONG=FALSE )

sw &lt;- which(DB$yr&gt;2011)

##########   remove the bad lines from the DB
DDB &lt;- editDB(DB, -sw)
infoDB(DB)

#############  to change the path names if the data
##   moves to a different server:

###for example: 
###  

path1&lt;-"/data/wadati/soju"
path2&lt;-"/mnt"

newDB &lt;- pathDB(DB, path1, path2 )


## End(Not run)


</code></pre>

<hr>
<h2 id='EmptyPickfile'>Create an empty RSEIS pickfile structure</h2><span id='topic+EmptyPickfile'></span>

<h3>Description</h3>

<p>Creates a structure list with no data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EmptyPickfile(GH)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EmptyPickfile_+3A_gh">GH</code></td>
<td>
<p>RSEIS list structure </p>
</td></tr>
</table>


<h3>Value</h3>

<p>RSEIS pickfile list
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>EmptySEIS</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(GH)
EmptyPickfile(GH)


</code></pre>

<hr>
<h2 id='EmptySEIS'>Create an empty RSEIS structure</h2><span id='topic+EmptySEIS'></span>

<h3>Description</h3>

<p>Creates a structure list with no data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EmptySEIS()
</code></pre>


<h3>Value</h3>

<p>RSEIS list
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>EmptyPickfile</p>


<h3>Examples</h3>

<pre><code class='language-R'>EmptySEIS()
</code></pre>

<hr>
<h2 id='envelope'>Envelope Function with Hilbert Transform</h2><span id='topic+envelope'></span>

<h3>Description</h3>

<p>Envelope Function with Hilbert Transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>envelope(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="envelope_+3A_x">x</code></td>
<td>
<p>signal vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the hilbert transform to get the envelope function.
</p>


<h3>Value</h3>

<p>vector of the absolute of the hilbert transform
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CE1)
ev &lt;- envelope(CE1$y)
plot(CE1$x, CE1$y, type='l')
lines(CE1$x,ev, col='red')


</code></pre>

<hr>
<h2 id='EPOCHday'>Epoch Day</h2><span id='topic+EPOCHday'></span>

<h3>Description</h3>

<p>Number of days since Origin  Year</p>


<h3>Usage</h3>

<pre><code class='language-R'>EPOCHday(yr, jd = 1, origyr = 1972)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EPOCHday_+3A_yr">yr</code></td>
<td>
<p>year</p>
</td></tr>
<tr><td><code id="EPOCHday_+3A_jd">jd</code></td>
<td>
<p>Julian Day</p>
</td></tr>
<tr><td><code id="EPOCHday_+3A_origyr">origyr</code></td>
<td>
<p>origin year, default=1972</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either jd or mo, dom can be provided
</p>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>jday</code></td>
<td>
<p>number of days since the start of origin year</p>
</td></tr>
<tr><td><code>origyr</code></td>
<td>
<p>origin year used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>EPOCHyear, recdate</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tyears   &lt;-  1973:2009

E1  &lt;-  EPOCHday(tyears, jd=1,   origyr=1972       )

EPOCHyear(E1$jday,   origyr=1972  )


</code></pre>

<hr>
<h2 id='EPOCHyear'>Epoch Year</h2><span id='topic+EPOCHyear'></span>

<h3>Description</h3>

<p>Get year and julian day given number of days since origin</p>


<h3>Usage</h3>

<pre><code class='language-R'>EPOCHyear(iday, origyr = 1972)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EPOCHyear_+3A_iday">iday</code></td>
<td>
<p>Number of days since origin</p>
</td></tr>
<tr><td><code id="EPOCHyear_+3A_origyr">origyr</code></td>
<td>
<p>origin year, default=1972 </p>
</td></tr>
</table>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>yr</code></td>
<td>
<p>Year</p>
</td></tr>
<tr><td><code>jd</code></td>
<td>
<p>Julian day in Year</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>EPOCHday, recdate</p>


<h3>Examples</h3>

<pre><code class='language-R'>

tyears   &lt;-  1973:2009

E1  &lt;-  EPOCHday(tyears, jd=1,   origyr=1972       )

EPOCHyear(E1$jday,   origyr=1972  )

#######  here is an example using year Month and day of month
###  use March 19 for each year:
ii  &lt;-  tojul(tyears, 3, 19)-tojul(tyears, 1, 1)

E1  &lt;-  EPOCHday(tyears, jd=ii,  origyr=1972       )

EPOCHyear(E1$jday,   origyr=1972  )



</code></pre>

<hr>
<h2 id='ETECTG'>Event Detection</h2><span id='topic+ETECTG'></span>

<h3>Description</h3>

<p>Event Detection for a seismic section
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ETECTG(GH, sel = sel, FRWD = 8, BKWD = 8, sbef = 1,
saft = 6, DFRWD = 0.5, DBKWD = 0.5, thresh = 2,
Tthresh2 = 7, stretch = 1000, flo = 0.1, fhi = 5,
 PLOT = FALSE, Kmin = 7, perc = 0.05, kind = 1, DOARAIC = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ETECTG_+3A_gh">GH</code></td>
<td>
<p>Seismic Structure</p>
</td></tr>
<tr><td><code id="ETECTG_+3A_sel">sel</code></td>
<td>
<p>select traces</p>
</td></tr>
<tr><td><code id="ETECTG_+3A_frwd">FRWD</code></td>
<td>
<p>forward window, s</p>
</td></tr>
<tr><td><code id="ETECTG_+3A_bkwd">BKWD</code></td>
<td>
<p>backward window </p>
</td></tr>
<tr><td><code id="ETECTG_+3A_sbef">sbef</code></td>
<td>
<p>seconds before</p>
</td></tr>
<tr><td><code id="ETECTG_+3A_saft">saft</code></td>
<td>
<p>seconds after</p>
</td></tr>
<tr><td><code id="ETECTG_+3A_dfrwd">DFRWD</code></td>
<td>
<p>seconds before</p>
</td></tr>
<tr><td><code id="ETECTG_+3A_dbkwd">DBKWD</code></td>
<td>
<p>seconds after</p>
</td></tr>
<tr><td><code id="ETECTG_+3A_thresh">thresh</code></td>
<td>
<p>threshold 1</p>
</td></tr>
<tr><td><code id="ETECTG_+3A_tthresh2">Tthresh2</code></td>
<td>
<p>threshold 2</p>
</td></tr>
<tr><td><code id="ETECTG_+3A_stretch">stretch</code></td>
<td>
<p>stretch factor</p>
</td></tr>
<tr><td><code id="ETECTG_+3A_flo">flo</code></td>
<td>
<p>low frequency for BP filter</p>
</td></tr>
<tr><td><code id="ETECTG_+3A_fhi">fhi</code></td>
<td>
<p>low frequency for BP  filter</p>
</td></tr>
<tr><td><code id="ETECTG_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE=plot diagnostics</p>
</td></tr>
<tr><td><code id="ETECTG_+3A_kmin">Kmin</code></td>
<td>
<p>min number of picks per window</p>
</td></tr>
<tr><td><code id="ETECTG_+3A_perc">perc</code></td>
<td>
<p>percentage of Kmin allowed</p>
</td></tr>
<tr><td><code id="ETECTG_+3A_kind">kind</code></td>
<td>
<p>kind of picking</p>
</td></tr>
<tr><td><code id="ETECTG_+3A_doaraic">DOARAIC</code></td>
<td>
<p>TRUE=do auto-regressive AIC method </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Very complicated picking routine - designed for volcanic
regions with emergent arrivals.  Works with lots of tuning.
</p>


<h3>Value</h3>

<table>
<tr><td><code>sel</code></td>
<td>
<p>input selection</p>
</td></tr>
<tr><td><code>JJ</code></td>
<td>
<p>index</p>
</td></tr>
<tr><td><code>PPTIM</code></td>
<td>
<p>p-arrivals</p>
</td></tr>
<tr><td><code>PP</code></td>
<td>
<p>all arrivals</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>

<hr>
<h2 id='evolAR'> Evolutive Auto-Regressive Spectrum </h2><span id='topic+evolAR'></span>

<h3>Description</h3>

<p>Time varying Auto-Regressive Spectrum (Gabor Transform)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evolAR(a, dt = 0, numf = 1024, pord = 100, Ns = 0, Nov = 0, fl = 0, fh = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evolAR_+3A_a">a</code></td>
<td>
<p>signal</p>
</td></tr>
<tr><td><code id="evolAR_+3A_dt">dt</code></td>
<td>
<p>sample rate interval (s)</p>
</td></tr>
<tr><td><code id="evolAR_+3A_numf">numf</code></td>
<td>
<p>Number of frequencies</p>
</td></tr>
<tr><td><code id="evolAR_+3A_pord">pord</code></td>
<td>
<p>Order for Auto-regressive calculation </p>
</td></tr>
<tr><td><code id="evolAR_+3A_ns">Ns</code></td>
<td>
<p>Number of sample in sub-window </p>
</td></tr>
<tr><td><code id="evolAR_+3A_nov">Nov</code></td>
<td>
<p>Number of sample to overlap</p>
</td></tr>
<tr><td><code id="evolAR_+3A_fl">fl</code></td>
<td>
<p>low frequency to display</p>
</td></tr>
<tr><td><code id="evolAR_+3A_fh">fh</code></td>
<td>
<p>high frequency to display</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a spectrogram function similar to the Gabor Transform
but uses the   Auto-Regressive method for spectrum estimation.
</p>


<h3>Value</h3>

<p>List
</p>
<table>
<tr><td><code>sig</code></td>
<td>
<p>input signal</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>deltat</p>
</td></tr>
<tr><td><code>wpars</code></td>
<td>
<p>input parameters</p>
</td></tr>
<tr><td><code>DSPEC</code></td>
<td>
<p>spectrum image</p>
</td></tr>
<tr><td><code>freqs</code></td>
<td>
<p>output frequencies (y axis)</p>
</td></tr>
<tr><td><code>tims</code></td>
<td>
<p>output times (x-axis) </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>evolfft, evolMTM, MTM.drive, GETARAIC </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(KH)
###   swig(KH)

Xamp &lt;- KH$JSTR[[1]]

dt &lt;- KH$dt[1]
plot(seq(from=0, length=length(Xamp), by=dt), Xamp, type='l')
##  limit the trace, somewhat
Xamp &lt;- Xamp[12670:22669]
plot(seq(from=0, length=length(Xamp), by=dt), Xamp, type='l')


Nfft&lt;-1024   ###  fft length
Ns&lt;-512      ###  number of samples in a window
Nov&lt;-480    ###  number of samples of overlap per window
fl&lt;-0        ###  low frequency to return
fh&lt;-12     ###  high frequency to return

EV &lt;- evolAR(Xamp, dt = dt, numf =Nfft , pord = 100, Ns = Ns,
       Nov = Nov, fl = fl, fh = fh)


PE &lt;- plotevol(EV, log=1, fl=0.01, fh=fh,
      col=rainbow(100), ygrid=FALSE,
      STAMP="", STYLE="ar")


</code></pre>

<hr>
<h2 id='evolfft'>Spectrogram fft</h2><span id='topic+evolfft'></span>

<h3>Description</h3>

<p>Spectrogram using simple fft (Gabor Transform)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evolfft(a, dt = 0, Nfft = 0, Ns = 0, Nov = 0, fl = 0, fh = 10, pcttap =
0.05, adjust=TRUE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evolfft_+3A_a">a</code></td>
<td>
<p>signal</p>
</td></tr>
<tr><td><code id="evolfft_+3A_dt">dt</code></td>
<td>
<p>sample rate interval (s) </p>
</td></tr>
<tr><td><code id="evolfft_+3A_nfft">Nfft</code></td>
<td>
<p>Number of points in fft </p>
</td></tr>
<tr><td><code id="evolfft_+3A_ns">Ns</code></td>
<td>
<p>NUmber of sample in sub-window </p>
</td></tr>
<tr><td><code id="evolfft_+3A_nov">Nov</code></td>
<td>
<p>number of sample to overlap </p>
</td></tr>
<tr><td><code id="evolfft_+3A_fl">fl</code></td>
<td>
<p> low frequency to display </p>
</td></tr>
<tr><td><code id="evolfft_+3A_fh">fh</code></td>
<td>
<p>high frequency to display  </p>
</td></tr>
<tr><td><code id="evolfft_+3A_pcttap">pcttap</code></td>
<td>
<p>Percent cosine taper for each window  </p>
</td></tr>
<tr><td><code id="evolfft_+3A_adjust">adjust</code></td>
<td>
<p>logical, if TRUE adjust the parameters
so the plot looks good (DEFAULT).  If FALSE, keep user parameters. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a duplication of the spectrogram function in matlab  which
applies Welsh's Method.
Each mini-window is tapered with a cosine window.
</p>


<h3>Value</h3>

<p>List
</p>
<table>
<tr><td><code>sig</code></td>
<td>
<p>input signal</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>deltat</p>
</td></tr>
<tr><td><code>wpars</code></td>
<td>
<p>input parameters</p>
</td></tr>
<tr><td><code>DSPEC</code></td>
<td>
<p>spectrum image</p>
</td></tr>
<tr><td><code>freqs</code></td>
<td>
<p>output frequencies (y axis)</p>
</td></tr>
<tr><td><code>tims</code></td>
<td>
<p>output times (x-axis) </p>
</td></tr>
</table>


<h3>Note</h3>

<p>Parameter adjust is by default TRUE so that the
choice of Ns, Nov, and kcol will be optimized, more or less.
Set this logical to FALSE to force the function to
use user input parameters.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>evolMTM, evolAR, MTM.drive</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(CE1)

####  plot signals
plot(CE1$x, CE1$y, type='l')

###  set parameters
Nfft&lt;-1024   ###  fft length
Ns&lt;-250      ###  number of samples in a window
Nov&lt;-240     ###  number of samples of overlap per window
fl&lt;-0        ###  low frequency to return
fh&lt;-1/(2*CE1$dt)     ###  high frequency to return

########  calculate the evolutive fft (Gabor Transform)
EV &lt;- evolfft(CE1$y, dt =CE1$dt , Nfft = Nfft, Ns =Ns , Nov =Nov , fl =fl
, fh = 25)

### plot image, but it does not look too interesting
image(EV$DSPEC)


### plot Gabor transform with special function
PE &lt;- plotevol(EV, log=0, fl=0.01, fh=100, col=rainbow(100), ygrid=FALSE,
STAMP="", STYLE="fft")


</code></pre>

<hr>
<h2 id='evolMTM'>Evolutive Multi-taper Spectrum  </h2><span id='topic+evolMTM'></span>

<h3>Description</h3>

<p>Time varying Multi-taper Spectrum (Gabor Transform)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evolMTM(a, dt = 0, numf = 1024, Ns = 0, Nov = 0, fl = 0, fh = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evolMTM_+3A_a">a</code></td>
<td>
<p>Signal</p>
</td></tr>
<tr><td><code id="evolMTM_+3A_dt">dt</code></td>
<td>
<p>Sample rate interval (s) </p>
</td></tr>
<tr><td><code id="evolMTM_+3A_numf">numf</code></td>
<td>
<p>Number of points in fft </p>
</td></tr>
<tr><td><code id="evolMTM_+3A_ns">Ns</code></td>
<td>
<p>Number of sample in sub-window </p>
</td></tr>
<tr><td><code id="evolMTM_+3A_nov">Nov</code></td>
<td>
<p>Number of sample to overlap </p>
</td></tr>
<tr><td><code id="evolMTM_+3A_fl">fl</code></td>
<td>
<p> low frequency to display </p>
</td></tr>
<tr><td><code id="evolMTM_+3A_fh">fh</code></td>
<td>
<p>high frequency to display  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a spectrogram function similar to the Gabor Transform
but uses the MTM method for spectrum estimation.
</p>


<h3>Value</h3>

<p>List
</p>
<table>
<tr><td><code>sig</code></td>
<td>
<p>input signal</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>deltat</p>
</td></tr>
<tr><td><code>wpars</code></td>
<td>
<p>input parameters</p>
</td></tr>
<tr><td><code>DSPEC</code></td>
<td>
<p>spectrum image</p>
</td></tr>
<tr><td><code>freqs</code></td>
<td>
<p>output frequencies (y axis)</p>
</td></tr>
<tr><td><code>tims</code></td>
<td>
<p>output times (x-axis) </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>Lees, J. M. and Park, J., 1995: Multiple-taper spectral
analysis: A stand-alone C-subroutine,
<em>Computers and Geology</em>, 21(2), 199-236.</p>


<h3>See Also</h3>

<p>evolfft, MTM.drive</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(KH)
###   swig(KH)

Xamp &lt;- KH$JSTR[[1]]

dt &lt;- KH$dt[1]
plot(seq(from=0, length=length(Xamp), by=dt), Xamp, type='l')
##  limit the trace, somewhat
Xamp &lt;- Xamp[12670:22669]
plot(seq(from=0, length=length(Xamp), by=dt), Xamp, type='l')


Nfft&lt;-4096   ###  fft length
Ns&lt;-512      ###  number of samples in a window
Nov&lt;-480    ###  number of samples of overlap per window
fl&lt;-0        ###  low frequency to return
fh&lt;-12     ###  high frequency to return

EV &lt;- evolMTM(Xamp, dt = dt, numf = Nfft, Ns = Ns, Nov = Nov, fl = fl, fh
= fh)


PE &lt;- plotevol(EV, log=1, fl=0.01, fh=fh, col=rainbow(100), ygrid=FALSE,
STAMP="", STYLE="ar")


##   compare with:
## EVf &lt;- evolfft(Xamp, dt = dt, Nfft =Nfft , Ns =Ns , Nov =Nov , fl =fl, fh = fh)

##  PE &lt;- plotevol(EVf, log=1, fl=fl, fh=fh, col=rainbow(100), ygrid=FALSE,STAMP="", STYLE="fft")



</code></pre>

<hr>
<h2 id='filedatetime'>Create a character string from a date</h2><span id='topic+filedatetime'></span>

<h3>Description</h3>

<p>Create a character string from a date for
naming unique output files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filedatetime(orgtim, tims=0, datesep="-", timesep=":", secsep="_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filedatetime_+3A_orgtim">orgtim</code></td>
<td>
<p>time vector of length 5: c(yr, jd, hr, mi, sec)  </p>
</td></tr>
<tr><td><code id="filedatetime_+3A_tims">tims</code></td>
<td>
<p>seconds to add to orgtim, default=0</p>
</td></tr>
<tr><td><code id="filedatetime_+3A_datesep">datesep</code></td>
<td>
<p>character, seperater for the date</p>
</td></tr>
<tr><td><code id="filedatetime_+3A_timesep">timesep</code></td>
<td>
<p>character, seperator for the time</p>
</td></tr>
<tr><td><code id="filedatetime_+3A_secsep">secsep</code></td>
<td>
<p>character, seperator for the seconds</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>filename</code></td>
<td>
<p>character string</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(GH)

g1 &lt;- getGHtime(GH)
g2 &lt;- unlist(g1)

filedatetime(g2, 1)



</code></pre>

<hr>
<h2 id='FILT.SEISN'>Filter Traces</h2><span id='topic+FILT.SEISN'></span>

<h3>Description</h3>

<p>Filter Traces in a seismic structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FILT.SEISN(TH, sel = 1:length(TH$JSTR),
FILT = list(ON = TRUE, fl = 0.5, fh = 7, type = "HP",
 proto = "BU", RM=FALSE, zp=TRUE ), TAPER = 0.1, POSTTAPER = 0.1, AUGMENT=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FILT.SEISN_+3A_th">TH</code></td>
<td>
<p>Seismic structure</p>
</td></tr>
<tr><td><code id="FILT.SEISN_+3A_sel">sel</code></td>
<td>
<p>selection of traces </p>
</td></tr>
<tr><td><code id="FILT.SEISN_+3A_filt">FILT</code></td>
<td>
<p>filter definition </p>
</td></tr>
<tr><td><code id="FILT.SEISN_+3A_taper">TAPER</code></td>
<td>
<p>filter taper</p>
</td></tr>
<tr><td><code id="FILT.SEISN_+3A_posttaper">POSTTAPER</code></td>
<td>
<p>taper after filter</p>
</td></tr>
<tr><td><code id="FILT.SEISN_+3A_augment">AUGMENT</code></td>
<td>
<p>Logical, FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>RSEIS Seismic structure is filtered, trace by trace.
If AUGMENT is TRUE, traces are augmented at beginning and end,
filtered and then truncated to suppress edge effects. In that case
no tapering is applied post fitler.
</p>


<h3>Value</h3>

<p>RSEIS Seismic structure, traces are filtered and a proc is added to the
trace history.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>butfilt</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##   Fdef = choosfilt()
Fdef  &lt;-  list(ON=FALSE, fl=0.5, fh=7.0, type="BP", proto="BU", RM=FALSE, zp=TRUE )
data("GH")
sel &lt;-  which(GH$COMPS=="V")

sel  &lt;-  1:3
 KF  &lt;-  FILT.SEISN(GH, sel = sel, FILT=Fdef)
swig(KF, sel=sel, SHOWONLY=0)


</code></pre>

<hr>
<h2 id='FILT.spread'>Filter trace with a spread of filters</h2><span id='topic+FILT.spread'></span>

<h3>Description</h3>

<p>Show a time series and a spread of user defined filters to show signal
at a variety of bandwidths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FILT.spread(x, y, dt, fl = fl, fh = fh, sfact = 1,
 WIN = NULL, PLOT = TRUE, TIT = NULL, TAPER = 0.05,
 POSTTAPER=0.05, RM=FALSE, zp=TRUE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FILT.spread_+3A_x">x</code></td>
<td>
<p>x-axis</p>
</td></tr>
<tr><td><code id="FILT.spread_+3A_y">y</code></td>
<td>
<p>y-amplitude</p>
</td></tr>
<tr><td><code id="FILT.spread_+3A_dt">dt</code></td>
<td>
<p>delta-t, sec</p>
</td></tr>
<tr><td><code id="FILT.spread_+3A_fl">fl</code></td>
<td>
<p>vector of low frequency cut offs</p>
</td></tr>
<tr><td><code id="FILT.spread_+3A_fh">fh</code></td>
<td>
<p>vector of high frequency cut offs</p>
</td></tr>
<tr><td><code id="FILT.spread_+3A_sfact">sfact</code></td>
<td>
<p>scale factor, 0,1 </p>
</td></tr>
<tr><td><code id="FILT.spread_+3A_win">WIN</code></td>
<td>
<p>xlimits to constrain plotting</p>
</td></tr>
<tr><td><code id="FILT.spread_+3A_plot">PLOT</code></td>
<td>
<p>logical, plotting</p>
</td></tr>
<tr><td><code id="FILT.spread_+3A_tit">TIT</code></td>
<td>
<p>title</p>
</td></tr>
<tr><td><code id="FILT.spread_+3A_taper">TAPER</code></td>
<td>
<p>taper data prior to filter, percent cosine, default=NULL</p>
</td></tr>
<tr><td><code id="FILT.spread_+3A_posttaper">POSTTAPER</code></td>
<td>
<p>taper output after filter, percent cosine, default=0.05</p>
</td></tr>
<tr><td><code id="FILT.spread_+3A_rm">RM</code></td>
<td>
<p>Remove mean value from trace, default=FALSE</p>
</td></tr>
<tr><td><code id="FILT.spread_+3A_zp">zp</code></td>
<td>
<p>zero phase filter, default=TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use the TAPER and POSTTAPER to reduce the edge effects
prior to and after filtering.
</p>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>FMAT</code></td>
<td>
<p>matrix of time series filtered</p>
</td></tr>
<tr><td><code>Notes</code></td>
<td>
<p>Notes for filter of each element of FMAT</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>butfilt, PLOT.MATN</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(KH)
dt  &lt;-  KH$dt[1]

y  &lt;-   KH$JSTR[[1]]

x  &lt;-   seq(from=0, by=dt, length=length(y))



fl &lt;- rep(1/100, 5)
fh &lt;- 1/c(1,2,5,10,20)

FILT.spread(x, y, dt, fl = fl, fh = fh, sfact = 1,
   WIN = NULL, PLOT = TRUE, TIT = NULL, TAPER = 0.05)


</code></pre>

<hr>
<h2 id='filterstamp'>Make  Filter Stamp</h2><span id='topic+filterstamp'></span>

<h3>Description</h3>

<p>Create an text stamp describing a filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterstamp(fl=1/2, fh=10, type="BP")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterstamp_+3A_fl">fl</code></td>
<td>
<p>vector, low frequency</p>
</td></tr>
<tr><td><code id="filterstamp_+3A_fh">fh</code></td>
<td>
<p>vector,high frequency</p>
</td></tr>
<tr><td><code id="filterstamp_+3A_type">type</code></td>
<td>
<p>vector,type of filter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the frequency is less than 1, the period is displayed.
For now only 3 digits are displayed.  If the first argument, fl, is a
list the parameters are extracted from the list and the other arguments
are ignored.
</p>


<h3>Value</h3>

<table>
<tr><td><code>stamps</code></td>
<td>
<p>text strings</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>FILT.spread</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fl &lt;- c(0.01, 2)
fh &lt;- c(10, 20)
type &lt;- "BP"
filterstamp(fl, fh, type)

FILT&lt;-list(ON=TRUE, fl=1/2, fh=12, type="HP", proto="BU")
filterstamp(FILT)

FILT&lt;-list(ON=TRUE, fl=1/2, fh=12, type="BP", proto="BU")
filterstamp(FILT)

FILT&lt;-list(ON=TRUE, fl=1/2, fh=12, type="LP", proto="BU")
filterstamp(FILT)



</code></pre>

<hr>
<h2 id='finteg'>Integration in Frequency Domain</h2><span id='topic+finteg'></span>

<h3>Description</h3>

<p>Integration of seismic signal in Frequency Domain.
Used for converting velocity seismogram to displacement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finteg(data, dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finteg_+3A_data">data</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="finteg_+3A_dt">dt</code></td>
<td>
<p>sample interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integrated time series signal
</p>


<h3>Note</h3>

<p>To avoid problems with dividing by very small numbers,
water level is set =1.e-8
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ##  waterlevel=1.e-8


    dfor5 &lt;- rnorm(1000)

  idfor5 &lt;- finteg(dfor5, 0.008)
 
</code></pre>

<hr>
<h2 id='fixcompname'>Fix component names for uniformity</h2><span id='topic+fixcompname'></span>

<h3>Description</h3>

<p>Fix component names for uniformity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixcompname(comp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixcompname_+3A_comp">comp</code></td>
<td>
<p>4, &quot;SHV&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Translate the component names to
something uniform that can be used for sorting and other
functions.
</p>


<h3>Value</h3>

<p>one of &quot;V&quot;, &quot;N&quot;, &quot;E&quot; 
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fixcompname("SHV")
fixcompname("SHE")

</code></pre>

<hr>
<h2 id='fixcomps'>Fix Station Component Names</h2><span id='topic+fixcomps'></span>

<h3>Description</h3>

<p>Convert components to common names: V N E
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixcomps(oldcomps, SEGY = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixcomps_+3A_oldcomps">oldcomps</code></td>
<td>
<p>vector of compnents</p>
</td></tr>
<tr><td><code id="fixcomps_+3A_segy">SEGY</code></td>
<td>
<p>logical, TRUE= segy data with compnents 4,5,6 or 1,2,3</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Attemps to convert irregular component names to common format for later
processing.
</p>


<h3>Value</h3>

<p>character vector
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>fixcompname </p>


<h3>Examples</h3>

<pre><code class='language-R'>comp &lt;- c("v", "e")
fixcomps(comp)
</code></pre>

<hr>
<h2 id='fixNA'>Fix NA values.
</h2><span id='topic+fixNA'></span>

<h3>Description</h3>

<p>Replace NA values in a time series
with mean values between end points of missing segments,
or first and last real values in case the NA's are at the beginning or ends of traces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixNA(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixNA_+3A_y">y</code></td>
<td>
<p>numeric vector
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>fixNA searches for stretches of NA 's in a time series
and replaces the NA values with numeric values based ont he two end
points of each section.
</p>


<h3>Value</h3>

<p>numeric vector with no NA values.
</p>


<h3>Note</h3>

<p>function is used primarily in filter applications.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>butfilt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## source("~/Site/TA_DATA/CODE/fixNA.R")

### last samples are NA
zig = rnorm(25)
zig[10:15] = NA

noNA = fixNA(zig)

### first samples are NA
zig = rnorm(25)
zig[1:5] = NA
noNA = fixNA(zig)


zig = rnorm(25)
zig[1:5] = NA
zig[21:25] = NA

noNA = fixNA(zig)



zig = rnorm(25)
zig[1] = NA
zig[21:25] = NA
zig[10:12] = NA

noNA = fixNA(zig)
cbind(zig, noNA)




</code></pre>

<hr>
<h2 id='fixUWstasLL'>fixUWstasLL</h2><span id='topic+fixUWstasLL'></span>

<h3>Description</h3>

<p>Matches station locations  to pickfile stations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixUWstasLL(STAS, stafile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixUWstasLL_+3A_stas">STAS</code></td>
<td>
<p>structure of station lat, lon, z</p>
</td></tr>
<tr><td><code id="fixUWstasLL_+3A_stafile">stafile</code></td>
<td>
<p>station file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Matches station locations  to pickfile stations
</p>


<h3>Value</h3>

<p>structure of station lat, lon, z
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>

<hr>
<h2 id='fromjul'>given julian day and year get month/day</h2><span id='topic+fromjul'></span>

<h3>Description</h3>

<p>given julian day and year get month/day
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fromjul(jul, yy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fromjul_+3A_jul">jul</code></td>
<td>
<p>Julian Day</p>
</td></tr>
<tr><td><code id="fromjul_+3A_yy">yy</code></td>
<td>
<p>year</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list(mo=mm, dom=dd)
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>tojul</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iyear &lt;- 2001
 jul &lt;- 233
inine &lt;-   tojul(iyear,1,1);
ijul &lt;-    inine + jul - 1;
fromjul( ijul, iyear);


</code></pre>

<hr>
<h2 id='FRWDft'>Forward fourier Transform</h2><span id='topic+FRWDft'></span>

<h3>Description</h3>

<p>Forward fourier Transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FRWDft(g, n, tstart, dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FRWDft_+3A_g">g</code></td>
<td>
<p>input signal</p>
</td></tr>
<tr><td><code id="FRWDft_+3A_n">n</code></td>
<td>
<p>number of points</p>
</td></tr>
<tr><td><code id="FRWDft_+3A_tstart">tstart</code></td>
<td>
<p>start of trace </p>
</td></tr>
<tr><td><code id="FRWDft_+3A_dt">dt</code></td>
<td>
<p>sample interval, s </p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>G</code></td>
<td>
<p>fourier compnents</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>frequency vector</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>time vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>INVRft</p>


<h3>Examples</h3>

<pre><code class='language-R'>zil  &lt;-  rnorm(300)
fss  &lt;-  FRWDft( zil, length(zil), 0, 0.004)   




</code></pre>

<hr>
<h2 id='gaddtix'>add tic marks</h2><span id='topic+gaddtix'></span>

<h3>Description</h3>

<p>Add tic marks to plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaddtix(side = 3, pos = 0, tck = 0.005, at = c(0, 1),
labels = NULL, col = 2, addline = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaddtix_+3A_side">side</code></td>
<td>
<p>side = 1, 2, 3, 4</p>
</td></tr>
<tr><td><code id="gaddtix_+3A_pos">pos</code></td>
<td>
<p>relative to axis</p>
</td></tr>
<tr><td><code id="gaddtix_+3A_tck">tck</code></td>
<td>
<p>tic length</p>
</td></tr>
<tr><td><code id="gaddtix_+3A_at">at</code></td>
<td>
<p>vector of positions</p>
</td></tr>
<tr><td><code id="gaddtix_+3A_labels">labels</code></td>
<td>
<p>vector of labels</p>
</td></tr>
<tr><td><code id="gaddtix_+3A_col">col</code></td>
<td>
<p>color for plotting </p>
</td></tr>
<tr><td><code id="gaddtix_+3A_addline">addline</code></td>
<td>
<p>add lines</p>
</td></tr>
<tr><td><code id="gaddtix_+3A_...">...</code></td>
<td>
<p>graphical parameters from par </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>par </p>


<h3>Examples</h3>

<pre><code class='language-R'>

plot(c(0,1), c(0,1), type='n', ann=FALSE, axes=FALSE)

gaddtix(side=1, pos=0,   tck=-0.01, at=seq(from=0, to=.5, by=.2) ,
labels=seq(from=0, to=.5, by=.2), col=1)

</code></pre>

<hr>
<h2 id='GAZI'>Get azimuthal particle motion</h2><span id='topic+GAZI'></span>

<h3>Description</h3>

<p>Do particle motion analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GAZI(ADAT, dt = 1, ex = seq(0, 100),
comp = c(4, 5, 6), sta = "ZZZ", az = 0,
len = 50, shift = 10, prev = 1, fileid = "", picks = NA, labs = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GAZI_+3A_adat">ADAT</code></td>
<td>
<p>Matrix of 3 component seismic data</p>
</td></tr>
<tr><td><code id="GAZI_+3A_dt">dt</code></td>
<td>
<p>delta T (s)</p>
</td></tr>
<tr><td><code id="GAZI_+3A_ex">ex</code></td>
<td>
<p>x-axis vector</p>
</td></tr>
<tr><td><code id="GAZI_+3A_comp">comp</code></td>
<td>
<p>component names</p>
</td></tr>
<tr><td><code id="GAZI_+3A_sta">sta</code></td>
<td>
<p>station name</p>
</td></tr>
<tr><td><code id="GAZI_+3A_az">az</code></td>
<td>
<p>azimuth of station orientation</p>
</td></tr>
<tr><td><code id="GAZI_+3A_len">len</code></td>
<td>
<p>length of time series</p>
</td></tr>
<tr><td><code id="GAZI_+3A_shift">shift</code></td>
<td>
<p>amount to shift per window</p>
</td></tr>
<tr><td><code id="GAZI_+3A_prev">prev</code></td>
<td>
<p>length of buffer at beginning of trace</p>
</td></tr>
<tr><td><code id="GAZI_+3A_fileid">fileid</code></td>
<td>
<p>character string to put on plot</p>
</td></tr>
<tr><td><code id="GAZI_+3A_picks">picks</code></td>
<td>
<p>arrival times for annotation</p>
</td></tr>
<tr><td><code id="GAZI_+3A_labs">labs</code></td>
<td>
<p>labels for arrival times for annotation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list(aex=aex[1:jall], rateig=rateig[1:jall],
aaz=aaz[1:jall], ai=ai[1:jall], figaz=figaz,
azpar=azpar, incpar=incpar )
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("GH")


temp  &lt;-  cbind(GH$JSTR[[4]], GH$JSTR[[5]], GH$JSTR[[6]])

pmolabs &lt;- c("Vertical", "North", "East")


 G   &lt;-  GAZI(temp, dt =GH$dt[4]  , comp = pmolabs, sta = GH$STNS[4] ,
az = 0, len =75, shift = 10, prev = 1)

</code></pre>

<hr>
<h2 id='genrick'>Ricker Wavelet
</h2><span id='topic+genrick'></span>

<h3>Description</h3>

<p>Generate a ricker wavelet of a specfied
frequency and length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genrick(freq, dt, nw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genrick_+3A_freq">freq</code></td>
<td>
<p> frequency of ricker wavelet
</p>
</td></tr>
<tr><td><code id="genrick_+3A_dt">dt</code></td>
<td>
<p> Time sample rate (s)
</p>
</td></tr>
<tr><td><code id="genrick_+3A_nw">nw</code></td>
<td>
<p> length of wavelet.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ricker wavelet as a vector.
</p>


<h3>Note</h3>

<p>Original code by
Leonard Lisapaly (leonardl@fisika.ui.ac.id), converted to R by J.M. Lees.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dt &lt;- 0.01
freq &lt;- 16
nlen &lt;- 35

G &lt;- genrick(freq, dt, nlen)

tee &lt;- seq(from=0, by=dt, length=length(G))

plot(tee, G, type='l')

</code></pre>

<hr>
<h2 id='get.corner'>Get Corner Frequency: Linear Model</h2><span id='topic+get.corner'></span>

<h3>Description</h3>

<p>Search for low frequency asymptote, corner frequency, and fall off
slope of seismic spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.corner(INfreq, INspec, dt, f1, f2, PLOT = FALSE, VERBOSE = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.corner_+3A_infreq">INfreq</code></td>
<td>
<p>frequency vector</p>
</td></tr>
<tr><td><code id="get.corner_+3A_inspec">INspec</code></td>
<td>
<p>spectrum</p>
</td></tr>
<tr><td><code id="get.corner_+3A_dt">dt</code></td>
<td>
<p>deltaT</p>
</td></tr>
<tr><td><code id="get.corner_+3A_f1">f1</code></td>
<td>
<p>low frequency for modeling, Hz</p>
</td></tr>
<tr><td><code id="get.corner_+3A_f2">f2</code></td>
<td>
<p>High frequency for modeling, Hz</p>
</td></tr>
<tr><td><code id="get.corner_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE=plot  </p>
</td></tr>
<tr><td><code id="get.corner_+3A_verbose">VERBOSE</code></td>
<td>
<p>TRUE=diagnostics</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine does not assume any particular mathematical model.
It searches for a three parameters that describe
two lines that mimic the displacement spectrum.
The search is done via least squares.
</p>


<h3>Value</h3>

<p>Model of 3 parameters, best fit.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>brune.doom</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CE1)

##   set frequency range for modeling for this high frequency data
##   we use f2 = 50, but for volcano data should be f2&lt;15

f1 &lt;- 0.01
f2 &lt;- 50.0  

##  set up data and parameters
amp &lt;-  CE1$y
len2 &lt;- 2*next2(length(amp))
a &lt;- list(y=amp, dt=CE1$dt)

Spec &lt;- MTMdisp(a, f1=f1, f2=f2, len2=len2, PLOT=FALSE )

lspec &lt;- Spec$displ

###  get initial estimate of parameters
xc &lt;- get.corner(  Spec$f , lspec, CE1$dt, f1, f2, PLOT=FALSE)



</code></pre>

<hr>
<h2 id='GET.seis'>Reads various seismic file formats</h2><span id='topic+GET.seis'></span><span id='topic+JGET.seis'></span>

<h3>Description</h3>

<p>This fuction calls binary routines to read in &lsquo;segy&rsquo;, &lsquo;sac&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GET.seis(fnames, kind = 1, Iendian=1, BIGLONG=FALSE ,
HEADONLY=FALSE,  PLOT = -1, RAW=FALSE)

JGET.seis(fnames, kind = 1, Iendian=1, BIGLONG=FALSE ,
HEADONLY=FALSE,  PLOT = -1, RAW=FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GET.seis_+3A_fnames">fnames</code></td>
<td>
<p>list of file names.</p>
</td></tr>
<tr><td><code id="GET.seis_+3A_kind">kind</code></td>
<td>
<p>an integer -1, 0, 1, 2 ; 0=&quot;RDATA&quot; , -1=&quot;RDS&quot;, 0=&quot;RDATA&quot;, 1 = &quot;segy&quot;,
2 = &quot;sac&quot;, see notes below</p>
</td></tr>
<tr><td><code id="GET.seis_+3A_iendian">Iendian</code></td>
<td>
<p> vector,   Endian-ness of the data: 1,2,3: &quot;little&quot;, &quot;big&quot;, &quot;swap&quot;.
Default = 1 (little)
</p>
</td></tr>
<tr><td><code id="GET.seis_+3A_biglong">BIGLONG</code></td>
<td>
<p> logical, TRUE=long=8 bytes
</p>
</td></tr>
<tr><td><code id="GET.seis_+3A_headonly">HEADONLY</code></td>
<td>
<p> logical, TRUE= header information only; not seismic
trace will be returned (runs a little faster).
</p>
</td></tr>
<tr><td><code id="GET.seis_+3A_plot">PLOT</code></td>
<td>
<p>integer, &lt;0 no plot; 0 
interactive; &gt;0 number of seconds to sleep</p>
</td></tr>
<tr><td><code id="GET.seis_+3A_raw">RAW</code></td>
<td>
<p>logical, default=FALSE(convert to volts) , TRUE (return counts intead of
volts) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;kind&quot; can be numeric or character: options are
'RDS', 'RDATA', 'SEGY', 'SAC', corresponding to (-1, 0, 1, 2).
</p>
<p>Uses readBin to extract data in SAC/SEGY format.
User must know what kind of machine the data
was created on for I/O purposes.
</p>
<p>If data was created on a little endian machine but
is being read on big endian machine, need to call
the endian &quot;swap&quot; for swapping.
</p>
<p>Iendian can be a vector if input files have different endian-ness.
</p>
<p>If data was created on a machine with LONG=4 bytes,
be sure to call the program with BIGLONG=FALSE.
</p>
<p>The data returned is a list of lists, each element is one
trace not necessarily related to the other traces in the list.
</p>
<p>Once the data is read in, use prepSEIS to reformat
the data into a list more amenable to further analysis in RSEIS.
</p>
<p>See examples below for different cases.
</p>


<h3>Value</h3>

<p>List containing the seismic data and header information.
Each trace consists of a list with:
</p>
<table>
<tr><td><code>fn</code></td>
<td>
<p>original file name</p>
</td></tr>
<tr><td><code>sta</code></td>
<td>
<p>station name</p>
</td></tr>
<tr><td><code>comp</code></td>
<td>
<p>compnent</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>delta t in seconds</p>
</td></tr>
<tr><td><code>DATTIM</code></td>
<td>
<p>time list</p>
</td></tr>
<tr><td><code>yr</code></td>
<td>
<p>year</p>
</td></tr>
<tr><td><code>jd</code></td>
<td>
<p>julian day</p>
</td></tr>
<tr><td><code>mo</code></td>
<td>
<p>month</p>
</td></tr>
<tr><td><code>dom</code></td>
<td>
<p>day of month</p>
</td></tr>
<tr><td><code>hr</code></td>
<td>
<p>hour</p>
</td></tr>
<tr><td><code>mi</code></td>
<td>
<p>minute</p>
</td></tr>
<tr><td><code>sec</code></td>
<td>
<p>sec</p>
</td></tr>
<tr><td><code>msec</code></td>
<td>
<p>milliseconds</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>delta t in seconds</p>
</td></tr>
<tr><td><code>t1</code></td>
<td>
<p>time start of trace</p>
</td></tr>
<tr><td><code>t2</code></td>
<td>
<p>time end of trace</p>
</td></tr>
<tr><td><code>off</code></td>
<td>
<p>off-set</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>number of points in trace</p>
</td></tr>
<tr><td><code>units</code></td>
<td>
<p>units</p>
</td></tr>
<tr><td><code>amp</code></td>
<td>
<p>vector of trace values</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The easiext way to process datais to convert the data to
an R-format type, using either save (kind=0) or saveRDS (kind=-1).
If these are used then I/O is simple.
</p>
<p>OLDER:
</p>
<p>Information in the file names is ignored, so be sure to modify headers
prior to using this method of extracting meta-data. (Or modify
the meta data from the file names after reading in the data.)
</p>
<p>For SEGY files, in LINUX-UNIX, use:
rename,    segymod (PASSCAL) to modify the headers
</p>
<p>JGET.seis  extracts digital seismic data from binary files
stored in the file system.  The program uses readBin for I/O
and passes data back to R.  Currently SAC, SEGY formats
are installed but it is easy to extend.  AH format
is available for LINUX systems, but there were problems compiling in
WINDOWS and MACOS so this feature was removed.
</p>
<p>A filter for mseed format is currently being developed.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>plotJGET, JSAC.seis , prepSEIS, Mine.seis</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
## Not run: 

Lname  &lt;-  list.files(path='/data/wadati/bourbon/LaurelCanNC/R005.01' ,
         pattern="08.005.01.41.23.9024", full.names=TRUE)

S1   &lt;-  GET.seis(Lname, kind = 1, PLOT = -1)

###   for data created on UNIX (SUN) but read on linux:

S1   &lt;-  GET.seis(Lname, kind = 1, Iendian="swap", BIGLONG=FALSE, PLOT = -1)

###   for data created on linux (32 bit)  but read on linux 64 bit:

S1   &lt;-  GET.seis(Lname, kind = 1, Iendian="little", BIGLONG=FALSE, PLOT = -1)

###   for SEGY data created on linux (64 bit)  but read on linux 32 bit:

S1   &lt;-  GET.seis(Lname, kind = 1, Iendian="little", BIGLONG=TRUE, PLOT = -1)


###   for SAC data created on MAC-OS (64 bit)  but read on linux 32 bit:

S1   &lt;-  GET.seis(Lname, kind = 2, Iendian="swap", BIGLONG=TRUE, PLOT = -1)


##################   



##########    to use other parts of the seismic
############               analysis package convert to rseis format:


####  prepare the data for further processing:

S1   &lt;-  JGET.seis(Lname, kind = 2, Iendian="swap", BIGLONG=TRUE, PLOT = -1)

 GH &lt;- prepSEIS(S1)
####   plot the data, and interact with the data
swig(GH, SHOWONLY=0)

###  or simply:

plotJGET(S1)


## End(Not run)


</code></pre>

<hr>
<h2 id='get.slepians'>Get Slepian Tapers</h2><span id='topic+get.slepians'></span>

<h3>Description</h3>

<p>Return a matrix of Slepian tapers 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.slepians(npoints = 900, nwin = 5, npi = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.slepians_+3A_npoints">npoints</code></td>
<td>
<p>Number of points to return</p>
</td></tr>
<tr><td><code id="get.slepians_+3A_nwin">nwin</code></td>
<td>
<p> Number of windows (default =5) </p>
</td></tr>
<tr><td><code id="get.slepians_+3A_npi">npi</code></td>
<td>
<p> Pi-Prolate numerber (3)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function onlyu returns the tapers for inspection.  To apply the
tapers use the function mtapspec.
</p>


<h3>Value</h3>

<p>Matrix: nwin vectors of npoints  Slepian tapers
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>References</h3>

<p>Lees, J. M. and Park, J., 1995: Multiple-taper spectral
analysis: A stand-alone C-subroutine, <em>Computers and Geology</em>, 21(2), 199-236.</p>


<h3>See Also</h3>

<p>mtapspec</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nwin &lt;- 5
npi &lt;- 3
npoints &lt;- 900
sleps &lt;- get.slepians(npoints, nwin, npi)

matplot(sleps, type='l', xlab="Index", ylab="Taper Amplitude")
legend('topleft', legend=1:nwin, lty=1:nwin, col=1:nwin)



</code></pre>

<hr>
<h2 id='Get1Dvel'>Read 1D velocity model</h2><span id='topic+Get1Dvel'></span>

<h3>Description</h3>

<p>Read in a velocity model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Get1Dvel(infile, PLOT = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Get1Dvel_+3A_infile">infile</code></td>
<td>
<p>Path to ascii-text model</p>
</td></tr>
<tr><td><code id="Get1Dvel_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE=plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reads Velocity model from a text file
</p>


<h3>Value</h3>

<p>LIST:
</p>
<table>
<tr><td><code>zp</code></td>
<td>
<p>vector of Tops of Layers, P-wave, (km)</p>
</td></tr>
<tr><td><code>vp</code></td>
<td>
<p>vector of velocities of Layers, P-wave,(km/s)</p>
</td></tr>
<tr><td><code>ep</code></td>
<td>
<p>errors for velocities, P-wave,(km/s) </p>
</td></tr>
<tr><td><code>zs</code></td>
<td>
<p>vector of Tops of Layers, S-wave, (km)</p>
</td></tr>
<tr><td><code>vs</code></td>
<td>
<p>vector of velocities of Layers, S-wave,(km/s)</p>
</td></tr>
<tr><td><code>es</code></td>
<td>
<p>errors for velocities, S-wave,(km/s) </p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>character, name of model </p>
</td></tr>
<tr><td><code>descriptor</code></td>
<td>
<p>character vector description of model </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>Plot1Dvel, Comp1Dvel, Comp1Dvels, travel.time1D</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  VELMOD1D = Get1Dvel("/home/lees/Progs/R_PAX/wu_coso.vel", PLOT=TRUE)
## Not run: 
data(VELMOD1D)

Get1Dvel(VELMOD1D, PLOT=TRUE)

## End(Not run)
 </code></pre>

<hr>
<h2 id='GETARAIC'>Auto-Regressive AIC estimate of arrival time</h2><span id='topic+GETARAIC'></span>

<h3>Description</h3>

<p>Auto-Regressive AIC for arrival estimate, signal detection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GETARAIC(z4, DT = 0.008, Mar = 8, O1 = 2, O2 = 0.2, WW = 2, T1 = 1, PLOT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GETARAIC_+3A_z4">z4</code></td>
<td>
<p>signal time series</p>
</td></tr>
<tr><td><code id="GETARAIC_+3A_dt">DT</code></td>
<td>
<p>sample rate,s</p>
</td></tr>
<tr><td><code id="GETARAIC_+3A_mar">Mar</code></td>
<td>
<p>AR Model Order</p>
</td></tr>
<tr><td><code id="GETARAIC_+3A_o1">O1</code></td>
<td>
<p>window before, s</p>
</td></tr>
<tr><td><code id="GETARAIC_+3A_o2">O2</code></td>
<td>
<p>window after, s</p>
</td></tr>
<tr><td><code id="GETARAIC_+3A_ww">WW</code></td>
<td>
<p>window length, s</p>
</td></tr>
<tr><td><code id="GETARAIC_+3A_t1">T1</code></td>
<td>
<p>initial guess, number of samples from beginning of trace</p>
</td></tr>
<tr><td><code id="GETARAIC_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE =plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method of Sleeman for automatic phase determination.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Taic</code></td>
<td>
<p>Arrival time of wave</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>References</h3>

<p>Sleeman</p>


<h3>See Also</h3>

<p>PSTLTcurve</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(CE1)
plot(CE1$x, CE1$y, type='l')

Xamp = CE1$y[CE1$x&gt;4.443754 &amp; CE1$x&lt;6.615951]
Mar=8
z4 = Xamp
DT = CE1$dt
 T1 = 50

O1 = 10*DT
O2 =  10*DT
WW = 10*DT
Nz4 = length(z4)


 araict = GETARAIC(Xamp, DT=CE1$dt, Mar=8, T1=T1, O1=O1, O2=O2, WW=WW,   PLOT=TRUE)


</code></pre>

<hr>
<h2 id='getb1b2'>Event Detection</h2><span id='topic+getb1b2'></span>

<h3>Description</h3>

<p>Used for event detection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getb1b2(J, L, zwin, maxx, max2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getb1b2_+3A_j">J</code></td>
<td>
<p>Thresh.J</p>
</td></tr>
<tr><td><code id="getb1b2_+3A_l">L</code></td>
<td>
<p>Thresh.J</p>
</td></tr>
<tr><td><code id="getb1b2_+3A_zwin">zwin</code></td>
<td>
<p>maximum of forwd and bakwrd windows</p>
</td></tr>
<tr><td><code id="getb1b2_+3A_maxx">maxx</code></td>
<td>
<p>max number of points</p>
</td></tr>
<tr><td><code id="getb1b2_+3A_max2">max2</code></td>
<td>
<p>all points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector c(b1,b2) 
</p>


<h3>Note</h3>

<p> Used for thresholding on event detection.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>Thresh.J, ETECTG</p>

<hr>
<h2 id='getEcard'>Error Card</h2><span id='topic+getEcard'></span>

<h3>Description</h3>

<p>Location Error Card
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEcard(ECARD)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEcard_+3A_ecard">ECARD</code></td>
<td>
<p>error card from Lquake </p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>LOC</code></td>
<td>
<p>character, location </p>
</td></tr>
<tr><td><code>rms</code></td>
<td>
<p>root mean square error</p>
</td></tr>
<tr><td><code>meanres</code></td>
<td>
<p>mean residual</p>
</td></tr>
<tr><td><code>sdres</code></td>
<td>
<p>standard deviation of residuals</p>
</td></tr>
<tr><td><code>sdmean</code></td>
<td>
<p>standard error of mean</p>
</td></tr>
<tr><td><code>sswres</code></td>
<td>
<p>sum squares</p>
</td></tr>
<tr><td><code>ndf</code></td>
<td>
<p>number degrees of freedom</p>
</td></tr>
<tr><td><code>fixflgs</code></td>
<td>
<p>flags for inversion</p>
</td></tr>
<tr><td><code>sterrx</code></td>
<td>
<p>error in x-direction</p>
</td></tr>
<tr><td><code>sterry</code></td>
<td>
<p>error in y-direction</p>
</td></tr>
<tr><td><code>sterrz</code></td>
<td>
<p>error in z-direction</p>
</td></tr>
<tr><td><code>sterrt</code></td>
<td>
<p>error in origin time</p>
</td></tr>
<tr><td><code>mag</code></td>
<td>
<p>mag</p>
</td></tr>
<tr><td><code>sterrmag</code></td>
<td>
<p>error for mag</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>

<hr>
<h2 id='getFcard'>Parse UW F Card</h2><span id='topic+getFcard'></span>

<h3>Description</h3>

<p>get F-card information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFcard(FCARD)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFcard_+3A_fcard">FCARD</code></td>
<td>
<p>Error Ellipsoid card </p>
</td></tr>
</table>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>azim1</code></td>
<td>
<p>angle, degrees </p>
</td></tr>
<tr><td><code>plunge1</code></td>
<td>
<p>angle, degrees </p>
</td></tr>
<tr><td><code>val1</code></td>
<td>
<p>value </p>
</td></tr>
<tr><td><code>azim2</code></td>
<td>
<p>angle, degrees </p>
</td></tr>
<tr><td><code>plunge2</code></td>
<td>
<p>angle, degrees </p>
</td></tr>
<tr><td><code>val2</code></td>
<td>
<p>value </p>
</td></tr>
<tr><td><code>azim3</code></td>
<td>
<p>angle, degrees </p>
</td></tr>
<tr><td><code>plunge3</code></td>
<td>
<p>angle, degrees </p>
</td></tr>
<tr><td><code>val3</code></td>
<td>
<p>value </p>
</td></tr>
<tr><td><code>herr</code></td>
<td>
<p>error </p>
</td></tr>
<tr><td><code>verr</code></td>
<td>
<p>vertical error </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>

<hr>
<h2 id='getGHtime'>Get Seismic reference time</h2><span id='topic+getGHtime'></span>

<h3>Description</h3>

<p>Extract the times of all traces relative to a reference
trace on a seismic RSEIS list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGHtime(GH, wi = 1, pix = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGHtime_+3A_gh">GH</code></td>
<td>
<p>RSEIS seismic data list</p>
</td></tr>
<tr><td><code id="getGHtime_+3A_wi">wi</code></td>
<td>
<p>which event to use as a reference baseline</p>
</td></tr>
<tr><td><code id="getGHtime_+3A_pix">pix</code></td>
<td>
<p>list of time to difference</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list:  times relative to reference time:
</p>
<table>
<tr><td><code>yr</code></td>
<td>
<p>year</p>
</td></tr>
<tr><td><code>jd</code></td>
<td>
<p>julian day</p>
</td></tr>
<tr><td><code>hr</code></td>
<td>
<p>hour</p>
</td></tr>
<tr><td><code>mi</code></td>
<td>
<p>minute</p>
</td></tr>
<tr><td><code>sec</code></td>
<td>
<p>second</p>
</td></tr>
<tr><td><code>spix</code></td>
<td>
<p>seconds after reference</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>secdifL, secdif</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(GH)

getGHtime(GH)

</code></pre>

<hr>
<h2 id='getHcard'>Parse UW Hires location Card</h2><span id='topic+getHcard'></span>

<h3>Description</h3>

<p>Extract High resolution information from H-card
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getHcard(hcard)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getHcard_+3A_hcard">hcard</code></td>
<td>
<p>ascii h-card</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>yr</code></td>
<td>
<p>Year</p>
</td></tr>
<tr><td><code>mo</code></td>
<td>
<p>Month</p>
</td></tr>
<tr><td><code>dom</code></td>
<td>
<p>Day of Month</p>
</td></tr>
<tr><td><code>hr</code></td>
<td>
<p>Hour</p>
</td></tr>
<tr><td><code>mi</code></td>
<td>
<p>minute</p>
</td></tr>
<tr><td><code>sec</code></td>
<td>
<p>second</p>
</td></tr>
<tr><td><code>lat</code></td>
<td>
<p>latitude</p>
</td></tr>
<tr><td><code>lon</code></td>
<td>
<p>longitude</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>depth</p>
</td></tr>
<tr><td><code>mag</code></td>
<td>
<p>magnitude</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>EmptyPickfile</p>

<hr>
<h2 id='getIRIS'>get Hypocenters from IRIS web site
</h2><span id='topic+getIRIS'></span><span id='topic+getANSS'></span>

<h3>Description</h3>

<p>Convert hypocenters from the
IRIS website and prepare for plotting in GEOmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIRIS(fn, skip=0)
getANSS(fn, skip=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIRIS_+3A_fn">fn</code></td>
<td>
<p>character, file path name
</p>
</td></tr>
<tr><td><code id="getIRIS_+3A_skip">skip</code></td>
<td>
<p>numeric, number of lines to skip (e.g. for the header)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reads in a file dumped out
by the website selection box.
</p>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>yr</code></td>
<td>
<p>vector year</p>
</td></tr>
<tr><td><code>dom</code></td>
<td>
<p>vector, day of month</p>
</td></tr>
<tr><td><code>mo</code></td>
<td>
<p>vector, mo</p>
</td></tr>
<tr><td><code>hr</code></td>
<td>
<p>vector, hour</p>
</td></tr>
<tr><td><code>mi</code></td>
<td>
<p>vector, minute</p>
</td></tr>
<tr><td><code>sec</code></td>
<td>
<p>vector, sec</p>
</td></tr>
<tr><td><code>lat</code></td>
<td>
<p>vector, latitude</p>
</td></tr>
<tr><td><code>lon</code></td>
<td>
<p>vector, longitude</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>vector, depth</p>
</td></tr>
<tr><td><code>mag</code></td>
<td>
<p>vector, magnitude</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Be careful about headers and lines that need to be skipped.
</p>
<p>for  IRIS:
http://www.iris.washington.edu/data/event/eventsearch.htm
</p>
<p>For   ANSS:
http://www.quake.geo.berkeley.edu/anss/catalog-search.html
</p>
<p>For NEIC (yet to be added)
http://earthquake.usgs.gov/earthquakes/eqarchives/epic/epic_global.php
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>getjul
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fn &lt;- "/home/lees/WORK/SENDAI.EVENT/catsearch.8757"

g &lt;- getANSS(fn)
g$jd &lt;- getjul(g$yr, g$mo, g$dom)

## End(Not run)

</code></pre>

<hr>
<h2 id='getjul'>Get Julian day</h2><span id='topic+getjul'></span>

<h3>Description</h3>

<p>Get Julian day
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getjul(year, month, day)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getjul_+3A_year">year</code></td>
<td>
<p>year</p>
</td></tr>
<tr><td><code id="getjul_+3A_month">month</code></td>
<td>
<p>month</p>
</td></tr>
<tr><td><code id="getjul_+3A_day">day</code></td>
<td>
<p>day of month </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Julian Day
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>getmoday</p>


<h3>Examples</h3>

<pre><code class='language-R'>getjul(2003, 11, 13)
</code></pre>

<hr>
<h2 id='getmoday'>Get Month Day</h2><span id='topic+getmoday'></span>

<h3>Description</h3>

<p>Get month day from julian day and year
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getmoday(jul, iyear)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getmoday_+3A_jul">jul</code></td>
<td>
<p>julian day</p>
</td></tr>
<tr><td><code id="getmoday_+3A_iyear">iyear</code></td>
<td>
<p>Year</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>mo</code></td>
<td>
<p>Month</p>
</td></tr>
<tr><td><code>dom</code></td>
<td>
<p>day of month</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>getmoday(234, 2005)
</code></pre>

<hr>
<h2 id='getNcard'>Parse Name Card</h2><span id='topic+getNcard'></span>

<h3>Description</h3>

<p>extract name from N-card
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNcard(ncard)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNcard_+3A_ncard">ncard</code></td>
<td>
<p>ncard from UW-pickfile</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ncard
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>EmptyPickfile</p>

<hr>
<h2 id='getPDEcsv'>Unpack PDE file
</h2><span id='topic+getPDEcsv'></span><span id='topic+getPDEscreen'></span>

<h3>Description</h3>

<p>Unpack PDE file as CSV file or ascii screen dump
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPDEcsv(pde = "/home/lees/Site/Santiaguito/pdq.eqs")
getPDEscreen(pde = "/home/lees/Site/Santiaguito/pdq.eqs")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPDEcsv_+3A_pde">pde</code></td>
<td>
<p>character, file name
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Download pde from: http://neic.usgs.gov/neis/epic/epic.html.
csv version uses comma separated values.  screen versions uses the
screen dump and a parser
</p>


<h3>Value</h3>

<p>list of locations, times and magnitude
</p>


<h3>Note</h3>

<p>if using screen dump, may need to clean up file a bit first.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>http://neic.usgs.gov/neis/epic/epic.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 


eq1 &lt;- getPDEcsv(pde = "/home/lees/Site/Santiaguito/pdq.eqs")

############################ 
######  copy/paste  from the screen dump at the NEIC web site
#####  then:
eq1 &lt;- getPDEscreen(pde = "EQS.txt")

nk &lt;- names(eq1[[1]])
k &lt;- length(nk)

##########   get a matrix of values instead
jim &lt;-  matrix( unlist(eq1), ncol=k, byrow=TRUE)
colnames(jim) &lt;- nk




## End(Not run)


</code></pre>

<hr>
<h2 id='getpfile'>Get Pick File</h2><span id='topic+getpfile'></span>

<h3>Description</h3>

<p>Read Pick File to R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getpfile(uwpickfile, stafile = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getpfile_+3A_uwpickfile">uwpickfile</code></td>
<td>
<p>pick file</p>
</td></tr>
<tr><td><code id="getpfile_+3A_stafile">stafile</code></td>
<td>
<p>station file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>University of washington Format pickfiles are used.  See EmptyPickfile
for the structure stored.
</p>


<h3>Value</h3>

<p>pickfile structure
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>EmptyPickfile</p>

<hr>
<h2 id='getphaselag2'>Phase Lag</h2><span id='topic+getphaselag2'></span>

<h3>Description</h3>

<p>Use MTM spectrum to estimate phase lag between two signals. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getphaselag2(y1, y2, DT = 0.008, frange = c(0, 20),
PLOT = FALSE, PLOT1 = FALSE, PLOT2 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getphaselag2_+3A_y1">y1</code></td>
<td>
<p>vector times series one</p>
</td></tr>
<tr><td><code id="getphaselag2_+3A_y2">y2</code></td>
<td>
<p>vector times series two </p>
</td></tr>
<tr><td><code id="getphaselag2_+3A_dt">DT</code></td>
<td>
<p>deltaT sample rate, s </p>
</td></tr>
<tr><td><code id="getphaselag2_+3A_frange">frange</code></td>
<td>
<p>vector, frequency bounds for analysis</p>
</td></tr>
<tr><td><code id="getphaselag2_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE=diagnostic plot</p>
</td></tr>
<tr><td><code id="getphaselag2_+3A_plot1">PLOT1</code></td>
<td>
<p>logical, TRUE=diagnostic plot</p>
</td></tr>
<tr><td><code id="getphaselag2_+3A_plot2">PLOT2</code></td>
<td>
<p>logical, TRUE=diagnostic plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>uses the slope of the cross spectrum to estimate the phase lag.
</p>


<h3>Value</h3>

<p>phase lag, seconds
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>mtapspec</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("GH")

Xamp1&lt;-GH$JSTR[[1]]
Xamp1&lt;-Xamp1[1123:2000]

Xamp2&lt;- GH$JSTR[[4]]
Xamp2&lt;-Xamp2[1123:2000]
plot(Xamp1,type='l')
lines(Xamp2,type='l',col='red')

 pshift &lt;- getphaselag2(Xamp1, Xamp2,  DT=GH$info$dt[1],
 frange=c(5, 15),  PLOT=TRUE)

</code></pre>

<hr>
<h2 id='getrdpix'>get read picks
</h2><span id='topic+getrdpix'></span>

<h3>Description</h3>

<p>get read picks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getrdpix(zloc, zenclick, sel, NH)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getrdpix_+3A_zloc">zloc</code></td>
<td>
<p>location list
</p>
</td></tr>
<tr><td><code id="getrdpix_+3A_zenclick">zenclick</code></td>
<td>
<p>number of picks
</p>
</td></tr>
<tr><td><code id="getrdpix_+3A_sel">sel</code></td>
<td>
<p>sel vector in swig
</p>
</td></tr>
<tr><td><code id="getrdpix_+3A_nh">NH</code></td>
<td>
<p>RSEIS list
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used internally in swig
</p>


<h3>Value</h3>

<p>list: rd: date/times of picks for stations and comps
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>swig
</p>

<hr>
<h2 id='getseis24'>Get 24 Hours of Seismic Data
</h2><span id='topic+getseis24'></span>

<h3>Description</h3>

<p>Get 24 Hours of Seismic Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getseis24(DB, iyear = 2009, iday = 1, usta = "",
 acomp = "", kind = 1,  Iendian=1, BIGLONG=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getseis24_+3A_db">DB</code></td>
<td>

<p>Data base of meta-data about the seismic trace files
</p>
</td></tr>
<tr><td><code id="getseis24_+3A_iyear">iyear</code></td>
<td>
<p>Year for extraction
</p>
</td></tr>
<tr><td><code id="getseis24_+3A_iday">iday</code></td>
<td>
<p>Julian day for extraction
</p>
</td></tr>
<tr><td><code id="getseis24_+3A_usta">usta</code></td>
<td>
<p>station to show
</p>
</td></tr>
<tr><td><code id="getseis24_+3A_acomp">acomp</code></td>
<td>
<p>component to show
</p>
</td></tr>
<tr><td><code id="getseis24_+3A_kind">kind</code></td>
<td>
<p>kind of data, default=1, 0=&quot;RDATA&quot; , -1=&quot;RDS&quot;, 0=&quot;RDATA&quot;, 1 = &quot;segy&quot;,
2 = &quot;sac&quot;
</p>
</td></tr>
<tr><td><code id="getseis24_+3A_iendian">Iendian</code></td>
<td>
<p> Endian-ness of the data: 1,2,3: &quot;little&quot;, &quot;big&quot;, &quot;swap&quot;.
Default = 1 (little)
</p>
</td></tr>
<tr><td><code id="getseis24_+3A_biglong">BIGLONG</code></td>
<td>
<p> logical, TRUE=long=8 bytes
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The DB file consists of a list of information on
where to find the data and what times are covered.
DB is </p>

<dl>
<dt>fn</dt><dd><p>full path to file</p>
</dd>
<dt>yr</dt><dd><p>year</p>
</dd>
<dt>jd</dt><dd><p>julian day</p>
</dd>
<dt>hr</dt><dd><p>hour</p>
</dd>
<dt>mi</dt><dd><p>minute</p>
</dd>
<dt>sec</dt><dd><p>second</p>
</dd>
<dt>dur</dt><dd><p>duration, seconds</p>
</dd>
<dt>origyr</dt><dd><p>origin time for epoch calculations</p>
</dd>
</dl>



<h3>Value</h3>

<table>
<tr><td><code>yr</code></td>
<td>
<p>start year</p>
</td></tr>
<tr><td><code>jd</code></td>
<td>
<p>start julian day</p>
</td></tr>
<tr><td><code>t1</code></td>
<td>
<p>start t1 (with epoch) </p>
</td></tr>
<tr><td><code>t2</code></td>
<td>
<p>start t2 (with epoch day) </p>
</td></tr>
<tr><td><code>ed</code></td>
<td>
<p> epoch day</p>
</td></tr>
<tr><td><code>hr</code></td>
<td>
<p>start  hour</p>
</td></tr>
<tr><td><code>mi</code></td>
<td>
<p>start  minute</p>
</td></tr>
<tr><td><code>sec</code></td>
<td>
<p>start  seconds</p>
</td></tr>
<tr><td><code>gamp</code></td>
<td>
<p>Amplitude of each trace</p>
</td></tr>
<tr><td><code>gdt</code></td>
<td>
<p>delta-t, sample interval, in seconds</p>
</td></tr>
<tr><td><code>gnam</code></td>
<td>
<p>station name</p>
</td></tr>
<tr><td><code>gfile</code></td>
<td>
<p>file information</p>
</td></tr>
<tr><td><code>sigs</code></td>
<td>
<p>List of time series</p>
</td></tr>
<tr><td><code>zna</code></td>
<td>
<p>List of NA values in each time series</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>setupDB, plotseis24
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
JJ &lt;- getseis24(DB, 2008, 366, usta, acomp, kind = 1)
 
pjj &lt;- plotseis24(JJ, dy=1/18, FIX=24, SCALE=1,
FILT=list(ON&lt;-FALSE, fl=0.05 , fh=20.0, type="BP", proto="BU"),
RCOLS=c(rgb(0.2, .2, 1), rgb(.2, .2, .2))  )


## End(Not run)



</code></pre>

<hr>
<h2 id='getvertsorder'>Get Order of Picks from P-wave Arrivals</h2><span id='topic+getvertsorder'></span>

<h3>Description</h3>

<p>Uses a Pickfile and the Waveform file,
and creates a vector ordering the waveforms
by P-wave arrival.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getvertsorder(P, GU)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getvertsorder_+3A_p">P</code></td>
<td>
<p>Pickfile Structure</p>
</td></tr>
<tr><td><code id="getvertsorder_+3A_gu">GU</code></td>
<td>
<p>Waveform structure</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Waveforms structure may already have pickfile,
but this is overridden by input pickfile P.
</p>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>sel</code></td>
<td>
<p>index of traces in order of first P-wave arrival</p>
</td></tr>
<tr><td><code>win</code></td>
<td>
<p>vector, c(1,2), time window from the first arrival to the last</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>swig</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GH)

vertord &lt;-  getvertsorder(GH$pickfile, GH)

swig(GH,  sel=vertord$sel, WIN=vertord$win,   SHOWONLY=TRUE)


</code></pre>

<hr>
<h2 id='GH'>Earthquake Seismic Data</h2><span id='topic+GH'></span>

<h3>Description</h3>

<p>Example of seismic data structure. Geothermal Earthquake.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> data(GH) </code></pre>


<h3>Format</h3>

<p>List, consisting of:
</p>

<dl>
<dt>JSTR</dt><dd><p>list of digital seismic data traces</p>
</dd>
<dt>STNS</dt><dd><p>vector of stations</p>
</dd>
<dt>dir</dt><dd><p>directory</p>
</dd>
<dt>ifile</dt><dd><p>original file names</p>
</dd>
<dt>COMPS</dt><dd><p>Component names, V N E, e.g.</p>
</dd>
<dt>OCOMPS</dt><dd><p>Old Component names</p>
</dd>
<dt>dt</dt><dd><p>vector of delta-t, sampling time intervals</p>
</dd>
<dt>KNOTES</dt><dd><p>Notes for plotting on panels</p>
</dd>
<dt>info</dt><dd><p>List, detailed information about traces, including</p>
</dd>
<dt>dat</dt><dd><p>not used</p>
</dd>
<dt>nn</dt><dd><p>Number of traces</p>
</dd>
<dt>ex</dt><dd><p>time axis for plotting</p>
</dd>
<dt>pcol</dt><dd><p>colors for plotting</p>
</dd>
<dt>ok</dt><dd><p>which traces are okay</p>
</dd>
<dt>wintim</dt><dd><p>window span time, seconds</p>
</dd>
<dt>ftime</dt><dd><p>alphanumeric time stamp</p>
</dd>
<dt>pickfile</dt><dd><p>pickfile, see below</p>
</dd>
<dt>velfile</dt><dd><p>velocity model list</p>
</dd>
<dt>stafile</dt><dd><p>station information list including lat, lon, z</p>
</dd>
<dt>aname</dt><dd><p>source name for loading</p>
</dd>
<dt>UWFILEID</dt><dd><p>event ID number</p>
</dd>
</dl>

<p>The info list consists of:
</p>

<dl>
<dt>fn</dt><dd><p>file name</p>
</dd>
<dt>name</dt><dd><p>identification name</p>
</dd>
<dt>yr</dt><dd><p>start year</p>
</dd>
<dt>jd</dt><dd><p>start julianday</p>
</dd>
<dt>mo</dt><dd><p>month</p>
</dd>
<dt>dom</dt><dd><p>day of month</p>
</dd>
<dt>hr</dt><dd><p>hour</p>
</dd>
<dt>mi</dt><dd><p>minute</p>
</dd>
<dt>sec</dt><dd><p>second</p>
</dd>
<dt>msec</dt><dd><p>millisecond</p>
</dd>
<dt>dt</dt><dd><p>delta-t</p>
</dd>
<dt>t1</dt><dd><p>time 1</p>
</dd>
<dt>t2</dt><dd><p>time 2</p>
</dd>
<dt>off</dt><dd><p>offset</p>
</dd>
<dt>n1</dt><dd><p>number of samples</p>
</dd>
<dt>n2</dt><dd><p>not used</p>
</dd>
<dt>n3</dt><dd><p>not used</p>
</dd>
<dt>n</dt><dd><p>number of samples</p>
</dd>
</dl>

<p>The pickfile consists of:
</p>

<dl>
<dt>LOC</dt><dd><p>list(yr, jd, mo, dom, hr, mi,
sec, lat, lon, z, mag, gap,
delta , rms, hozerr)</p>
</dd>
<dt>MC</dt><dd><p>list(az1, dip1, az2, dip2,  dir, rake1,
dipaz1, rake2, dipaz2,
F=list(az, dip), G=list(az, dip), U=list(az, dip),
V=list(az, dip), P=list(az, dip),
T=list(az,dip),sense,M=list( az1, d1,  az2, d2,
uaz, ud, vaz, vd, paz, pd , taz, td), UP=TRUE,
icol=1, ileg,  fcol='red', CNVRG, LIM =c(0,0,0,0))</p>
</dd>
<dt>STAS</dt><dd><p>list(tag, name, comp, c3, phase, sec, err, pol, flg , res)</p>
</dd>
<dt>LIP</dt><dd><p>vector, length=6</p>
</dd>
<dt>H</dt><dd><p>list(yr,mo,dom,hr,mi,sec,lat,lon,z,mag)</p>
</dd>
<dt>N</dt><dd><p>name card</p>
</dd>
<dt>E</dt><dd><p>list(rms,meanres,sdres,sdmean,
sswres,ndf,fixflgs,sterrx,sterry,sterrz,sterrt,mag,sterrmag)</p>
</dd>
<dt>filename</dt><dd><p>file name</p>
</dd>
<dt>PICKER</dt><dd><p>Name of Picker</p>
</dd>
<dt>UWFILEID</dt><dd><p>numeric ID</p>
</dd>
<dt>winID1</dt><dd><p>win format ID</p>
</dd>
<dt>comments</dt><dd><p>Vector of comments</p>
</dd>
<dt>OSTAS</dt><dd><p>Old station names</p>
</dd>
</dl>



<h3>References</h3>

<p>Lees, J.M., 2004. Scattering from a fault interface in the Coso geothermal field. Journal of Volcanology and Geothermal Research, 130(1-2):
61-75.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GH)

</code></pre>

<hr>
<h2 id='ghstamp'>Identification stamp for RSEIS data
</h2><span id='topic+ghstamp'></span>

<h3>Description</h3>

<p>Prepare a character string stamp for
idenitication of plots of of signals in swig.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghstamp(GH, sel, WIN = c(485, 600))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ghstamp_+3A_gh">GH</code></td>
<td>
<p>RSEIS list structure
</p>
</td></tr>
<tr><td><code id="ghstamp_+3A_sel">sel</code></td>
<td>
<p>numeric index vector, selection of traces
</p>
</td></tr>
<tr><td><code id="ghstamp_+3A_win">WIN</code></td>
<td>
<p>time window within a trace
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The character string can be used as
a stamp on plots for unique identification.  Uses
the info list in the RSEIS list.  This function combines Zdate
with the window time information.
</p>


<h3>Value</h3>

<p>character array for each component in the sel vector.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>Zdate, MTM.drive, plotwlet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(KH)
ghstamp(KH)

data(GH)
ghstamp(GH, sel=1:3)


</code></pre>

<hr>
<h2 id='GLUE.GET.seis'>GLUE.GET.seis</h2><span id='topic+GLUE.GET.seis'></span>

<h3>Description</h3>

<p>Once a database has been mined this program re-arranges the
seismograms and creates a structure used in other programs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLUE.GET.seis(GG)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLUE.GET.seis_+3A_gg">GG</code></td>
<td>
<p>list of seismograms with headers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>structure of seismograms glued together
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>Mine.seis</p>

<hr>
<h2 id='GLUEseisMAT'>GLUEseisMAT</h2><span id='topic+GLUEseisMAT'></span>

<h3>Description</h3>

<p>Find duplicated stations in a matrix and fill in the traces that are continuations,
return the new matrix and the vector duplicates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLUEseisMAT(GFIL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLUEseisMAT_+3A_gfil">GFIL</code></td>
<td>
<p>list of data and headers, with duplicated stations glued</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New List of data and headers with same sensors/components glued together
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>Mine.seis</p>

<hr>
<h2 id='gpoly'>Convert Poles and Zeros to  Polynomial</h2><span id='topic+gpoly'></span>

<h3>Description</h3>

<p>Get Polynomial from Poles and Zeros
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpoly(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpoly_+3A_x">x</code></td>
<td>
<p>complex vector of poles or zeros</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of coefficients
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
K &lt;- PreSet.Instr()

##  convert zeros to polynomial coefficients

gpoly(K[[1]]$zeros)

</code></pre>

<hr>
<h2 id='GreatDist'>Distance Along Great Circle Arc</h2><span id='topic+GreatDist'></span>

<h3>Description</h3>

<p>Distance Along Great Circle Arc in degrees, kilometers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GreatDist(LON1, LAT1, LON2, LAT2, EARTHRAD= 6371)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GreatDist_+3A_lon1">LON1</code></td>
<td>
<p>Longitude, point1</p>
</td></tr>
<tr><td><code id="GreatDist_+3A_lat1">LAT1</code></td>
<td>
<p>Latitude, point1</p>
</td></tr>
<tr><td><code id="GreatDist_+3A_lon2">LON2</code></td>
<td>
<p>Longitude, point2</p>
</td></tr>
<tr><td><code id="GreatDist_+3A_lat2">LAT2</code></td>
<td>
<p>Latitude, point2</p>
</td></tr>
<tr><td><code id="GreatDist_+3A_earthrad">EARTHRAD</code></td>
<td>
<p>optional earth radius,  default  = 6371</p>
</td></tr>
</table>


<h3>Value</h3>

<p>LIST:
</p>
<table>
<tr><td><code>drad</code></td>
<td>
<p>distance in radians</p>
</td></tr>
<tr><td><code>ddeg</code></td>
<td>
<p>distance in degrees</p>
</td></tr>
<tr><td><code>dkm</code></td>
<td>
<p>distance in kilometers</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###  get distance between London, England and Santiago, Chile
london  &lt;-  c(51.53333, -0.08333333)
santiago  &lt;-  c(-33.46667, -70.75)

GreatDist(london[2], london[1], santiago[2], santiago[1])

</code></pre>

<hr>
<h2 id='grotseis'>Get seismic rotation matrix</h2><span id='topic+grotseis'></span>

<h3>Description</h3>

<p>Set up a rotation matrix for a seismic trace.
Rotation matrix is 3D, although this rotation only
creates a rotation for conversion to radial-transverse orientation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grotseis(ang, flip = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grotseis_+3A_ang">ang</code></td>
<td>
<p>Angle to rotate horizontal components, degrees</p>
</td></tr>
<tr><td><code id="grotseis_+3A_flip">flip</code></td>
<td>
<p>Logical, TRUE=flip the vertical axis, default=FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a 3 by 3 matrix used for rotationg a 3-component seismic
record, usually stored as an N by 3 matrix.  Only the N-E components
are rotated, North component is assumed to be in position 2
and the east compnent is assumed to be in position 3.
The vertical component can be flipped.
</p>
<p>If Back-Azimuth is used, radial is directed towards the source. If azimuth is used,
radial is directed away from the source.
</p>


<h3>Value</h3>

<p>3 by 3 rotation matrix.
</p>


<h3>Note</h3>

<p>Positive radial is away from the source (direction of wave
propagation).
Positive transverse is to
the right when facing the direction of wave propagation.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>rdistaz</p>


<h3>Examples</h3>

<pre><code class='language-R'>
####  simple case:


vecs  &lt;- rbind(c(0,0,1), c(0,1,0))
rbaz &lt;- grotseis(21.76, flip=FALSE) 
bvec  &lt;- vecs %*%  rbaz

plot(c(-2,2) , c(-2,2) , asp=1, xaxs="r"  , yaxs="r" , type='n' )

  arrows(0, 0, 0+bvec[,2], 0+bvec[,3],
     col=c("red", "blue"), length=.08)
     
  arrows(0, 0, vecs[,2], vecs[,3],
     col=c("red", "blue"), length=.08, lty=2)

text(0+bvec[1,2], 0+bvec[1,3], labels='radial', pos=3)
text(0+bvec[2,2], 0+bvec[2,3], labels='transverse', pos=4)

text(0+vecs[1,2], 0+vecs[1,3], labels='North', pos=3)
text(0+vecs[2,2], 0+vecs[2,3], labels='East', pos=4)

 
####  realistic case:
STAXY&lt;-list()

STAXY$'x'&lt;-c(-2.9162198461534,-2.49599248511068,
-2.85909405321704,-1.96135073099434,
-6.50413342506259,2.64026676599765,
-3.95701139503518,-2.84082134537436,
-0.0457817300378462,-2.74214190991955)
STAXY$'y'&lt;-c(-7.83435541676815,-4.46180337254565,
-6.46036190991833,-5.01212763828746,
-2.56091416028758,
5.31173503708142,2.10545324503380,-0.87490923667824,
-0.172422188354707,-1.52055218789877)

STAXY$'lat'&lt;-c(14.685621984127,14.7159182222222,
14.6979647030651,14.710975070028,
14.7329873333333,14.8037143111518
,14.7749104943935,14.7481391460905,
14.7544511215933,14.7423394025875)

STAXY$'lon'&lt;-c(268.420918730159,268.424817925926,
268.421447725096,268.429783940243,268.387586722222,
268.472531954619,268.41123843527,268.421611351166,
268.447574716981,268.422528671994)

STAXY$'z'&lt;-c(0.92522857142857,1.48225333333333,
1.14740517241379,1.4423781512605,1.51148,
2.53268681318681,2.70014678899083,2.04094444444444,
2.90827547169811,2.31817123287671)

STAXY$'cen'&lt;-c(14.756,-91.552)

STAXY$name&lt;-c('OBS','CAR','MAR','CAS','MTB','STA','STE','MOT','SUM','DOM')
sguitoXY&lt;-list()
sguitoXY$'x'&lt;-c(-1.78551922571555)
sguitoXY$'y'&lt;-c(-1.80850340813817)
sguitoXY$'lat'&lt;-c(14.7397535236)
sguitoXY$'lon'&lt;-c(268.4314147874)
sguitoXY$'z'&lt;-c(2.501)

DAZ &lt;- rdistaz( sguitoXY$lat, sguitoXY$lon ,       STAXY$lat, STAXY$lon)

STAXY$az &lt;- DAZ$baz

####  plotting
plot(STAXY$x, STAXY$y, asp=1, xaxs="r"  , yaxs="r" )
text(STAXY$x, STAXY$y,STAXY$name, pos=3)
points(0,0, pch=3)
points(sguitoXY$x,sguitoXY$y , pch=8)
segments(sguitoXY$x, sguitoXY$y, STAXY$x, STAXY$y, col="green", lty=2)

#### be aware of the convention used: (V-N-E) or (V-E-N)
### here first vector is east, second vector is north
###       if you use the V-N-E convention
vecs  &lt;- rbind( c(0,1,0), c(0,0,1))

for( i in 1:length(STAXY$x))
  {
rbaz &lt;- grotseis(STAXY$az[i], flip=FALSE)
bvec  &lt;- vecs %*%  rbaz
##############   red is north, blue east
########         red is radial positive away or toward  source, blue is transverse
##########       blue is positive rotated to the right of red
##
arrows(STAXY$x[i],STAXY$y[i], STAXY$x[i]+bvec[,2], STAXY$y[i]+bvec[,3],
col=c("red", "blue"), length=.08)

}






</code></pre>

<hr>
<h2 id='hilbert'>Hilbert Transform</h2><span id='topic+hilbert'></span>

<h3>Description</h3>

<p>Hilbert transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hilbert(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hilbert_+3A_x">x</code></td>
<td>
<p>time series vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the hilbert transform.  Used for calculating
the envelope function.
</p>


<h3>Value</h3>

<p>vector
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>fft, envelope </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
y &lt;- hilbert(x)

</code></pre>

<hr>
<h2 id='hilow'>Find Maxima and Minima</h2><span id='topic+hilow'></span>

<h3>Description</h3>

<p>Search for Extrema along time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hilow(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hilow_+3A_y">y</code></td>
<td>
<p>time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>LIST:
</p>
<table>
<tr><td><code>hi</code></td>
<td>
<p>indexes to peaks</p>
</td></tr>
<tr><td><code>lo</code></td>
<td>
<p>indexes to valleys</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>peaks</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex &lt;- seq(from=0, to=4*pi, length = 200)

y &lt;- sin(ex)
plot(ex, y, type='l')

peakval &lt;- hilow(y)

abline(v=ex[peakval$hi], col='green')
abline(v=ex[peakval$lo], col='red')


</code></pre>

<hr>
<h2 id='hodogram'>HodoGram Plot</h2><span id='topic+hodogram'></span>

<h3>Description</h3>

<p>HodoGram Plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hodogram(nbaz, dt = dt, labs = c("Vertical", "North", "East"),
COL =rainbow(140)[1:100] , STAMP = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hodogram_+3A_nbaz">nbaz</code></td>
<td>
<p>n by 3 matrix </p>
</td></tr>
<tr><td><code id="hodogram_+3A_dt">dt</code></td>
<td>
<p>time sample rate </p>
</td></tr>
<tr><td><code id="hodogram_+3A_labs">labs</code></td>
<td>
<p>labels for the components</p>
</td></tr>
<tr><td><code id="hodogram_+3A_col">COL</code></td>
<td>
<p>color palette</p>
</td></tr>
<tr><td><code id="hodogram_+3A_stamp">STAMP</code></td>
<td>
<p>character stamp for identification </p>
</td></tr>
</table>


<h3>Value</h3>

<p>sx = list
graphical side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("GH")

temp &lt;- cbind(GH$JSTR[[1]][1168:1500], GH$JSTR[[2]][1168:1500],
GH$JSTR[[3]][1168:1500])

pmolabs &lt;- c("Vertical", "North", "East")


sx &lt;- hodogram(temp, dt=GH$dt[1]  ,labs=pmolabs,
STAMP="Example",  COL=rainbow(100) )


</code></pre>

<hr>
<h2 id='hypot'>Hypot</h2><span id='topic+hypot'></span>

<h3>Description</h3>

<p>length of line connecting two points in a plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypot(x1, y1, x2, y2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypot_+3A_x1">x1</code></td>
<td>
<p>x-location point 1 </p>
</td></tr>
<tr><td><code id="hypot_+3A_y1">y1</code></td>
<td>
<p> y-location point 1 </p>
</td></tr>
<tr><td><code id="hypot_+3A_x2">x2</code></td>
<td>
<p>x-location point 2  </p>
</td></tr>
<tr><td><code id="hypot_+3A_y2">y2</code></td>
<td>
<p> y-location point 2 </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Euclidean distance
</p>


<h3>Value</h3>

<p>numeric distance
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hypot(34, 12, 56, 89)

</code></pre>

<hr>
<h2 id='idpoints.hodo'>ID points on Hodogram</h2><span id='topic+idpoints.hodo'></span>

<h3>Description</h3>

<p>Identification of points on a hodogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idpoints.hodo(nbaz, sx, X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idpoints.hodo_+3A_nbaz">nbaz</code></td>
<td>
<p>matrix 3 by n</p>
</td></tr>
<tr><td><code id="idpoints.hodo_+3A_sx">sx</code></td>
<td>
<p>x vector </p>
</td></tr>
<tr><td><code id="idpoints.hodo_+3A_x">X</code></td>
<td>
<p>x-coordinates to id</p>
</td></tr>
<tr><td><code id="idpoints.hodo_+3A_y">Y</code></td>
<td>
<p>y-coordinates to id</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used in conjunction with other interative plots.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>PMOT.drive</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data("GH")
sel&lt;- which(GH$STNS == "CE1")


temp &lt;- cbind(GH$JSTR[[sel[1]]][1168:1500],
 GH$JSTR[[sel[2]]][1168:1500], GH$JSTR[[sel[3]]][1168:1500])
dt &lt;-  GH$dt[ sel[1] ]
STAMP &lt;- "GH"

PMOT.drive(temp, dt,
 pmolabs = c("Vertical", "North", "East"), STAMP = STAMP)


## ids &lt;- idpoints.hodo(temp, sx, zloc$x[sn1], zloc$y[sn1])

</code></pre>

<hr>
<h2 id='info.seis'>Information on a Seismic record
</h2><span id='topic+info.seis'></span>

<h3>Description</h3>

<p>Retrieve information on a seismic record
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info.seis(GH)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="info.seis_+3A_gh">GH</code></td>
<td>
<p>RSEIS seismic record list
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints summary infromation on the traces in the seismic record
</p>


<h3>Value</h3>

<p>Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(KH)
info.seis(KH)


</code></pre>

<hr>
<h2 id='infoDB'>Print information about the seismic database
</h2><span id='topic+infoDB'></span>

<h3>Description</h3>

<p>Print information about the seismic database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infoDB(DB, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infoDB_+3A_db">DB</code></td>
<td>
<p>Database list
</p>
</td></tr>
<tr><td><code id="infoDB_+3A_verbose">verbose</code></td>
<td>
<p>logical, print information to screen, default=TRUE
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list(
</p>
<table>
<tr><td><code>usta</code></td>
<td>
<p>Unique station names</p>
</td></tr>
<tr><td><code>ucomp</code></td>
<td>
<p>Unique component names</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>starting date</p>
</td></tr>
<tr><td><code>end</code></td>
<td>
<p>ending date</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>makeDB
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

 path  &lt;-  '/home/lees/Site/Santiaguito/SG09'
     pattern  &lt;-  "R0*"

     ###   get DB information
     XDB   &lt;-   makeDB(path, pattern, kind =1)

infoDB(XDB)



## End(Not run)



</code></pre>

<hr>
<h2 id='insertNAs'>Insert NA in a vector at given break points
</h2><span id='topic+insertNAs'></span>

<h3>Description</h3>

<p>Insert NA in a vector at given break points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insertNAs(v, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insertNAs_+3A_v">v</code></td>
<td>
<p>original vector
</p>
</td></tr>
<tr><td><code id="insertNAs_+3A_w">w</code></td>
<td>
<p>break points
</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Used for plotting lines that
wrap around.
</p>


<h3>Value</h3>

<p> vector with NA inserted
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a  &lt;-  1:20
b  &lt;-  insertNAs(a, c(5, 12))
b 


</code></pre>

<hr>
<h2 id='INSTFREQS'>Instrument Frequencies</h2><span id='topic+INSTFREQS'></span>

<h3>Description</h3>

<p>Vector of frequencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>INSTFREQS(b, a, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="INSTFREQS_+3A_b">b</code></td>
<td>
<p>numerator, zeros</p>
</td></tr>
<tr><td><code id="INSTFREQS_+3A_a">a</code></td>
<td>
<p>denominator, poles</p>
</td></tr>
<tr><td><code id="INSTFREQS_+3A_w">w</code></td>
<td>
<p>frequency</p>
</td></tr>
</table>


<h3>Details</h3>

<p>h = jpolyval(b,s) / jpolyval(a,s)
</p>


<h3>Value</h3>

<p>h = jpolyval(b,s) / jpolyval(a,s)
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
K  &lt;-  PreSet.Instr()
b  &lt;-  K[[1]]$zeros
a  &lt;-  K[[1]]$poles
INSTFREQS(b, a, 2*pi*12)



</code></pre>

<hr>
<h2 id='INSTresponse'>Instrument Respnse Function</h2><span id='topic+INSTresponse'></span>

<h3>Description</h3>

<p>Extract Instrument Response from Poles and Zeros
</p>


<h3>Usage</h3>

<pre><code class='language-R'>INSTresponse(Kal, key, ff, tt = tt, plotkey = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="INSTresponse_+3A_kal">Kal</code></td>
<td>
<p>Calibration</p>
</td></tr>
<tr><td><code id="INSTresponse_+3A_key">key</code></td>
<td>
<p>index to list of instruments</p>
</td></tr>
<tr><td><code id="INSTresponse_+3A_ff">ff</code></td>
<td>
<p>frequency vector</p>
</td></tr>
<tr><td><code id="INSTresponse_+3A_tt">tt</code></td>
<td>
<p>time vector</p>
</td></tr>
<tr><td><code id="INSTresponse_+3A_plotkey">plotkey</code></td>
<td>
<p>TRUE = plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>response is fourier transform of delta function run through the filter
</p>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>transfer</code></td>
<td>
<p>transfer function</p>
</td></tr>
<tr><td><code>aa</code></td>
<td>
<p>a coeficients</p>
</td></tr>
<tr><td><code>bb</code></td>
<td>
<p>b coeficients</p>
</td></tr>
<tr><td><code>resp</code></td>
<td>
<p>real part of response</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>References</h3>

<p>Adapted from Ken Creager's Matseis</p>


<h3>See Also</h3>

<p>deconinst</p>


<h3>Examples</h3>

<pre><code class='language-R'>

########  set list of possible instruments:
Kal  &lt;-  PreSet.Instr()
###  get instrument reponse for first in list:
resp1   &lt;-  INSTresponse(Kal, 1, c(0,100)  , tt=c(1,0.008), plotkey=TRUE)
###  plots amplitude and phase
</code></pre>

<hr>
<h2 id='integ1'>Integrate seismogram</h2><span id='topic+integ1'></span>

<h3>Description</h3>

<p>integrate under the curve of a pulse
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integ1(x, y, dm = -Inf, hm = +Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integ1_+3A_x">x</code></td>
<td>
<p>x-axis vector</p>
</td></tr>
<tr><td><code id="integ1_+3A_y">y</code></td>
<td>
<p>y-axis vector</p>
</td></tr>
<tr><td><code id="integ1_+3A_dm">dm</code></td>
<td>
<p>lower bound</p>
</td></tr>
<tr><td><code id="integ1_+3A_hm">hm</code></td>
<td>
<p>upper bound</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector: c(osum,cista)
one with the bottom triangle included one without
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>

<hr>
<h2 id='INVRft'>Inverse Fourier Transform</h2><span id='topic+INVRft'></span>

<h3>Description</h3>

<p>Inverse Fourier Transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>INVRft(G, n, tstart, dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="INVRft_+3A_g">G</code></td>
<td>
<p>Input fourier transform</p>
</td></tr>
<tr><td><code id="INVRft_+3A_n">n</code></td>
<td>
<p>length of time vector </p>
</td></tr>
<tr><td><code id="INVRft_+3A_tstart">tstart</code></td>
<td>
<p>time series starts at tstart</p>
</td></tr>
<tr><td><code id="INVRft_+3A_dt">dt</code></td>
<td>
<p>Delta t, sample rate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>G is a vector spectrum evaluated at positive and negative
frequencies as defined by makefreq.
tstart, dt and n define the output time vector as described above.
</p>
<p>g is the Inverse Fourier Transform of G scaled by dt.
time shift theorem has been used to account for time not starting at t=0.
</p>


<h3>Value</h3>

<table>
<tr><td><code>g</code></td>
<td>
<p>truncate time vector to N points</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>frequencies</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>times</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>makefreq, FRWDft, INSTresponse</p>


<h3>Examples</h3>

<pre><code class='language-R'>zil  &lt;-  rnorm(300)
fss  &lt;-  FRWDft( zil, length(zil), 0, 0.004)   
INVRft(fss$G, length(zil), 0, 0.004)


</code></pre>

<hr>
<h2 id='j2posix'>Convert RSEIS date list to Posix
</h2><span id='topic+j2posix'></span>

<h3>Description</h3>

<p>Convert RSEIS date list to a cmpatable date/time
for calculating dates and times with base R codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>j2posix(timeinput)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="j2posix_+3A_timeinput">timeinput</code></td>
<td>
<p> RSEIS date-time list
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Code here converts to posix, but works only down to the second, i.e.
fractions of a second are dropped.
</p>


<h3>Value</h3>

<p>POSIX compatable date time structure.
</p>


<h3>Note</h3>

<p>If you need to preserve the fractional seconds (as we do in seismology)
it is recommended to cut them off and add them later.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>recdate, recdatel, dateList, dateStamp, filedatetime,
rangedatetime, yeardate, Zdate, as.POSIXct
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
yr = 2014
j = 233.1234
A = convertATT(j, yr)
j2posix(A)
### note fractional seconds are truncated.
</code></pre>

<hr>
<h2 id='jadjust.length'>Zero Padding</h2><span id='topic+jadjust.length'></span>

<h3>Description</h3>

<p>Add zeros to the end of the data if necessary so that  its length
is a power of 2.  It returns the data with zeros added if nessary
and the length of the adjusted data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jadjust.length(inputdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jadjust.length_+3A_inputdata">inputdata</code></td>
<td>
<p>either a text file or an S object containing data </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Zero-padded 1D array.
</p>


<h3>References</h3>

<p>See discussions in the text of &quot;Practical Time-Frequency Analysis&quot;.</p>

<hr>
<h2 id='JBLACK'>Gray scale Color Palette</h2><span id='topic+JBLACK'></span>

<h3>Description</h3>

<p>generate a gray scale color palette
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JBLACK(n, acol=rgb(0,0,0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JBLACK_+3A_n">n</code></td>
<td>
<p>number of colors to produce </p>
</td></tr>
<tr><td><code id="JBLACK_+3A_acol">acol</code></td>
<td>
<p>RGB color </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a black color palette suitable for
replacing rainbow for B/W color plots.  This is inserted in case user
needs to completely elliminate color from a plot that uses
color palettes for fixing colors.
</p>


<h3>Value</h3>

<p>n characters used for color palette
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>shade.col, rainbow, colors </p>


<h3>Examples</h3>

<pre><code class='language-R'>pal &lt;- JBLACK(100)

</code></pre>

<hr>
<h2 id='JGRAY'>Gray scale Color Palette</h2><span id='topic+JGRAY'></span>

<h3>Description</h3>

<p>generate a gray scale color palette
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JGRAY(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JGRAY_+3A_n">n</code></td>
<td>
<p>number of colors to produce </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a grey scale color palette suitable for
replacing rainbow for grey shade plots.
</p>


<h3>Value</h3>

<p>n characters used for color palette
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>shade.col, rainbow, colors </p>


<h3>Examples</h3>

<pre><code class='language-R'>pal &lt;- JGRAY(100)
data(volcano)
image(volcano, col=pal)

</code></pre>

<hr>
<h2 id='jitter.lab'>Jitter a set of labels
</h2><span id='topic+jitter.lab'></span>

<h3>Description</h3>

<p>Jitter a set of labels so they do not overlap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jitter.lab(x, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jitter.lab_+3A_x">x</code></td>
<td>
<p>X-positions
</p>
</td></tr>
<tr><td><code id="jitter.lab_+3A_w">w</code></td>
<td>
<p>widths of the labels
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>New label positions are computed
such that they do not overlap.  They are shifted up or down. Works only on horizontal labels.
</p>


<h3>Value</h3>

<p>vector of integer shifts.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
Jake Anderson&lt;ajakef@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>textrect
</p>


<h3>Examples</h3>

<pre><code class='language-R'> APAL  &lt;- 
   c('tan2','red2','lightpink3','chocolate4','blue3','thistle4','lightcyan4',
   'orangered1','purple4','darkred','dodgerblue1','gold3','chartreuse','sienna4',
   'aquamarine3','mistyrose4','sienna1','darkkhaki','darkgoldenrod4','magenta4',
   'pink3','orangered','darkslategray4','red3','goldenrod3','palegreen4','deepskyblue3',
   'turquoise3','seagreen4','springgreen4','gold4','lightsalmon4','limegreen','orchid4',
   'darkseagreen4','chartreuse3','goldenrod4','salmon2','deeppink3','forestgreen',
   'lightskyblue4','mediumorchid3','deepskyblue2','chocolate2','violetred4','blue1',
    'honeydew4','darkgreen','royalblue1','lightseagreen')

  
s &lt;- sort(sample.int(100,25))
plot(c(1,110),c(0,8),col='white')  #### set up plot area


PplusPHASE &lt;- c( "P-up","P","Pdiff","PKP","PKiKP","PcP",
"pP","pPdiff","pPKP","pPKiKP","sP","sPdiff","sPKP","sPKiKP")
 SplusPHASE  &lt;-  c("S-up","S","Sdiff","SKS","sS",
"sSdiff","sSKS","pS","pSdiff","pSKS")
basic1  &lt;-   c("ScP", "SKP", "PKKP", "SKKP", "PP",  "PKPPKP")
basicPHASE  &lt;-  c(PplusPHASE,SplusPHASE, basic1)  
PHS  &lt;-  basicPHASE[1:25]

x  &lt;-  s
y  &lt;-  rep(0, length(x))

RMAT  &lt;-    RPMG::textrect(x,y, PHS, xpd=TRUE, add=FALSE, font=1, cex=.8 )

    newjitx  &lt;-  jitter.lab(RMAT[,1]  , RMAT[,3]-RMAT[,1])
    y  &lt;-  y+newjitx*(RMAT[,4]-RMAT[,2])


MCOL  &lt;- length(PHS)

    PASTCOL &lt;- APAL[1:MCOL]
    RMAT &lt;- RPMG::textrect(x,y, PHS, xpd=TRUE,
            add=TRUE, textcol=PASTCOL,  font=1, cex=.8 )


</code></pre>

<hr>
<h2 id='jlegend'>plot a legend</h2><span id='topic+jlegend'></span>

<h3>Description</h3>

<p>Add legend to side of figure
</p>


<h3>Details</h3>

<p>Rewrite of the legend function for easier manipulation.
</p>


<h3>Value</h3>

<p>See legend() for details on input
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>legend</p>


<h3>Examples</h3>

<pre><code class='language-R'>

plot(c(0,1), c(0,1))
u  &lt;-  par('usr')
LEG  &lt;-  jlegend( u[1], u[4], c("Vp", "Vs"),
            lwd=2, col=c(4,3), plot=FALSE  )

 
</code></pre>

<hr>
<h2 id='jpolyval'>Polynomial Value</h2><span id='topic+jpolyval'></span>

<h3>Description</h3>

<p>Polynomila value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jpolyval(p, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jpolyval_+3A_p">p</code></td>
<td>
<p>coefficients</p>
</td></tr>
<tr><td><code id="jpolyval_+3A_x">x</code></td>
<td>
<p>input value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sum of polynomial: <code class="reqn">p_1+p_2*x^1+p_3*x^2...</code>
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>jpolyval(c(2,3,5), 7)

</code></pre>

<hr>
<h2 id='JSAC.seis'>JSAC.seis
</h2><span id='topic+JSAC.seis'></span><span id='topic+JSEGY.seis'></span>

<h3>Description</h3>

<p>Read SEGY/SAC format binary data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JSAC.seis(fnames, Iendian = 1 , HEADONLY=FALSE,
BIGLONG=FALSE, PLOT = -1, RAW=FALSE)
JSEGY.seis(fnames, Iendian = 1 , HEADONLY=FALSE,
BIGLONG=FALSE, PLOT = -1, RAW=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JSAC.seis_+3A_fnames">fnames</code></td>
<td>
<p>vector of file names to be extracted and converted.
</p>
</td></tr>
<tr><td><code id="JSAC.seis_+3A_iendian">Iendian</code></td>
<td>
<p> vector, Endian-ness of the data: 1,2,3: &quot;little&quot;, &quot;big&quot;, &quot;swap&quot;.
Default = 1 (little) 
</p>
</td></tr>
<tr><td><code id="JSAC.seis_+3A_headonly">HEADONLY</code></td>
<td>
<p> logical, TRUE= header information only
</p>
</td></tr>
<tr><td><code id="JSAC.seis_+3A_biglong">BIGLONG</code></td>
<td>
<p> logical, TRUE=long=8 bytes
</p>
</td></tr>
<tr><td><code id="JSAC.seis_+3A_plot">PLOT</code></td>
<td>
<p>integer, &lt;0 no plot; 0 
interactive; &gt;0 number of seconds to sleep
</p>
</td></tr>
<tr><td><code id="JSAC.seis_+3A_raw">RAW</code></td>
<td>
<p>logical, default=FALSE(convert to volts) , TRUE (return counts intead of
volts) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses readBin to extract data in SAC format.
user must know what kind of machine the data
was created on for I/O purposes.
</p>
<p>For SEGY data the program is the same, although SEGY data
does not have the problem of the BIGLONG so that is ignored.
</p>
<p>For either code, a full header is returned, although the
header for each format may be different.
</p>


<h3>Value</h3>

<p>List containing the seismic data and header information.
Each trace consists of a list with:
</p>
<table>
<tr><td><code>fn</code></td>
<td>
<p>original file name</p>
</td></tr>
<tr><td><code>sta</code></td>
<td>
<p>station name</p>
</td></tr>
<tr><td><code>comp</code></td>
<td>
<p>compnent</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>delta t in seconds</p>
</td></tr>
<tr><td><code>DATTIM</code></td>
<td>
<p>time list</p>
</td></tr>
<tr><td><code>yr</code></td>
<td>
<p>year</p>
</td></tr>
<tr><td><code>jd</code></td>
<td>
<p>julian day</p>
</td></tr>
<tr><td><code>mo</code></td>
<td>
<p>month</p>
</td></tr>
<tr><td><code>dom</code></td>
<td>
<p>day of month</p>
</td></tr>
<tr><td><code>hr</code></td>
<td>
<p>hour</p>
</td></tr>
<tr><td><code>mi</code></td>
<td>
<p>minute</p>
</td></tr>
<tr><td><code>sec</code></td>
<td>
<p>sec</p>
</td></tr>
<tr><td><code>msec</code></td>
<td>
<p>milliseconds</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>delta t in seconds</p>
</td></tr>
<tr><td><code>t1</code></td>
<td>
<p>time start of trace</p>
</td></tr>
<tr><td><code>t2</code></td>
<td>
<p>time end of trace</p>
</td></tr>
<tr><td><code>off</code></td>
<td>
<p>off-set</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>number of points in trace</p>
</td></tr>
<tr><td><code>units</code></td>
<td>
<p>units</p>
</td></tr>
<tr><td><code>amp</code></td>
<td>
<p>vector of trace values</p>
</td></tr>
<tr><td><code>HEAD</code></td>
<td>
<p>Full header as a data-frame of values (mixture of float
and character strings) </p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Number of samples in trace </p>
</td></tr>
<tr><td><code>units</code></td>
<td>
<p>Units of samples, possibly: counts, volts, s, m/s, Pa, etc </p>
</td></tr>
<tr><td><code>IO</code></td>
<td>
<p>list: kind, Iendian, BIGLONG flags for I/O </p>
</td></tr>
</table>


<h3>Note</h3>

<p>SAC created on PC (windows) or LINUX machines typically will be
in little endian format.
SAC created on a SUN will be in big endian format.
If you want to swap endian-ness , choose swap.
</p>
<p>MAC uses different convention.
</p>
<p>Iendian can be a vector if input files have different endian-ness.
</p>
<p>SAC inserts -12345  for no data.
</p>
<p>There are other issues regarding the size of long.
</p>
<p>The units are often questionable and depend on the processing.
The user should be careful and check to see that the
proper conversions and multipliers have been applied.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>Mine.seis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 


####  this will return a list of traces
Lname  &lt;-  list.files(path='/data/wadati/bourbon/LaurelCanNC/R005.01' ,
 pattern="08.005.01.41.23.9024", full.names=TRUE)

S1   &lt;-  JSAC.seis(Lname, Iendian = 1, PLOT = -1)


#####################   from a data base example: this will return one
#####                    trace header
f1  &lt;-  DB$fn[200]

j1  &lt;-  JSAC.seis(f1, Iendian=1, HEADONLY=TRUE , BIGLONG=FALSE, PLOT=-1)

print( j1[[1]]$HEAD )


#############   example for SEGY data: one SEGY  header

dir  &lt;-  "/data/wadati/soju/SEISMIC_DATA/Reventador2005/rev05/SEGY/R251.01"
lf  &lt;-  list.files(path=dir, pat="05.251", full.names=TRUE)
f1  &lt;-  lf[1]
j1  &lt;-  JSEGY.seis(f1, Iendian=1, HEADONLY=TRUE , BIGLONG=FALSE, PLOT=-1)


print( j1[[1]]$HEAD )


## End(Not run)




</code></pre>

<hr>
<h2 id='jstats'>statistics of a vector</h2><span id='topic+jstats'></span>

<h3>Description</h3>

<p>returns relevant stats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jstats(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jstats_+3A_d">d</code></td>
<td>
<p> vector </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Program calls R routines to gather important statistics for later use.
</p>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>mean value</p>
</td></tr>
<tr><td><code>std</code></td>
<td>
<p>standard deviation</p>
</td></tr>
<tr><td><code>med</code></td>
<td>
<p>median</p>
</td></tr>
<tr><td><code>qdist</code></td>
<td>
<p>quartile distance</p>
</td></tr>
<tr><td><code>bstats</code></td>
<td>
<p>boxplot quantiles</p>
</td></tr>
<tr><td><code>mstats</code></td>
<td>
<p>vector of mean and std</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>number of points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>boxplot, mean, median</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x   &lt;-  rnorm(100, m=43)
jstats(x)

</code></pre>

<hr>
<h2 id='Jtim'>Decimal Julian Day</h2><span id='topic+Jtim'></span><span id='topic+JtimL'></span>

<h3>Description</h3>

<p>convert JD, HR, MIN SEC to Decimal Julian Day
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jtim(jj, hr = hr, mi = mi, sec = sec, yr=NULL, origyr=NULL)
JtimL(j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Jtim_+3A_jj">jj</code></td>
<td>
<p>Julian day</p>
</td></tr>
<tr><td><code id="Jtim_+3A_hr">hr</code></td>
<td>
<p>Hour</p>
</td></tr>
<tr><td><code id="Jtim_+3A_mi">mi</code></td>
<td>
<p>Minute</p>
</td></tr>
<tr><td><code id="Jtim_+3A_sec">sec</code></td>
<td>
<p>Second</p>
</td></tr>
<tr><td><code id="Jtim_+3A_yr">yr</code></td>
<td>
<p>year, default = NULL</p>
</td></tr>
<tr><td><code id="Jtim_+3A_origyr">origyr</code></td>
<td>
<p>default = NULL</p>
</td></tr>	
</table>
<p>or
</p>
<table>
<tr><td><code id="Jtim_+3A_j">j</code></td>
<td>
<p>list of the above</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using a NULL value for yr gives the fractional julian day
in a year.  If yr is a legitimate year, and the origyr is provided,
then the EPOCH number of days
from origyr are added onto the fractional julian day.
The default for origyr is 1972 for most of seismology.
</p>
<p>If the dates span a new year, sometimes it is useful to
use the earliest year as the origyr.	
</p>


<h3>Value</h3>

<p>Julian day
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>secdif</p>


<h3>Examples</h3>

<pre><code class='language-R'>Jtim( 9 , hr= 14 , mi= 53 ,sec= 16.7807606880087 )

Jtim( 9 , hr= 14 , mi= 53 ,sec= 16.7807606880087, yr=2019, origyr=1972 )


########   or,
j = list(jd=9 , hr= 14 , mi= 53 ,sec= 16.7807606880087)

JtimL(j)




</code></pre>

<hr>
<h2 id='KH'>Volcano Seismic Data</h2><span id='topic+KH'></span>

<h3>Description</h3>

<p>Seismic data from erupting Reventador Volcano.  Vertical component only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> data(KH) </code></pre>


<h3>Format</h3>

<p>KH = 
list( LOC=list(yr=0, jd=0, mo=0, dom=0, hr=0, mi=0, sec=0, lat=0,
lon=0, z=0, mag=0, gap=0,
delta=0 , rms=0, hozerr=0),
MC=list(az1=0, dip1=0, az2=0, dip2=0,  dir=0,
rake1=0, dipaz1=0, rake2=0, dipaz2=0,
F=list(az=0, dip=0), G=list(az=0, dip=0), U=list(az=0, dip=0),
V=list(az=0, dip=0), P=list(az=0, dip=0), T=list(az=0,
dip=0),sense=0,M=list( az1=0, d1=0,  az2=0, d2=0, uaz=0, ud=0, vaz=0,
vd=0, paz=0, pd =0, taz=0, td=0), UP=TRUE, icol=1, ileg=&quot;&quot;,
fcol='red', CNVRG=&quot;&quot;, LIM =c(0,0,0,0)
),
</p>
<p>STAS=list(tag=&quot;&quot;, name=&quot;&quot;, comp=&quot;&quot;, c3=&quot;&quot;,
phase=&quot;&quot;, sec=0, err=0, pol=&quot;&quot;, flg=0 , res=0),
</p>
<p>LIP=vector(length=6),
</p>
<p>H=list(yr=0,mo=0,dom=0,hr=0,mi=0,sec=0,lat=0,lon=0,z=0,mag=0),
</p>
<p>N=list(name=&quot;&quot;),
</p>
<p>E=list(rms=0,meanres=0,sdres=0,sdmean=0,sswres=0,ndf=0,fixflgs=0,
sterrx=0,sterry=0,sterrz=0,sterrt=0,mag=0,sterrmag=0),
</p>
<p>filename=&quot;&quot;,
</p>
<p>PICKER=&quot;&quot;,
UWFILEID=&quot;&quot;,winID1=&quot;&quot;,comments=&quot;&quot;, OSTAS=&quot;&quot;)
</p>


<h3>References</h3>

<p>Lees, J. M., J. B. Johnson, M. Ruiz, L. Troncoso, M. Welsh, Reventador Volcano 2005: Eruptive Activity Inferred from Seismo-Acoustic Observation <em>Journal of Volcanology and Geothermal Research</em> in Press, 2007.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(KH)
######  set SHOWONLY=FALSE for interactive
swig(KH, SHOWONLY=0)

</code></pre>

<hr>
<h2 id='lagplot'>Plot phase lags</h2><span id='topic+lagplot'></span>

<h3>Description</h3>

<p>adds a bar showing phase lag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lagplot(y1, dt, lag, PLOT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lagplot_+3A_y1">y1</code></td>
<td>
<p>seismic signal </p>
</td></tr>
<tr><td><code id="lagplot_+3A_dt">dt</code></td>
<td>
<p>DeltaT, s </p>
</td></tr>
<tr><td><code id="lagplot_+3A_lag">lag</code></td>
<td>
<p>lag, s </p>
</td></tr>
<tr><td><code id="lagplot_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE=plot </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side Effects.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>getphaselag2</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 
plot(MTS1$freq, nphase,  main=paste(sep=' ', "thelag=",phaselag) )
     abline(MOD)
    
 lagplot(ts1, DT, phaselag, PLOT=TRUE )

## End(Not run)



</code></pre>

<hr>
<h2 id='leests'>Time Series Structure</h2><span id='topic+leests'></span>

<h3>Description</h3>

<p>return time series structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leests(a, dt = 0.008)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leests_+3A_a">a</code></td>
<td>
<p>vector signal</p>
</td></tr>
<tr><td><code id="leests_+3A_dt">dt</code></td>
<td>
<p>sample rate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list(y=y, dt=dt)
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x  &lt;-  rnorm(10)

leests(x, dt = 0.01)


</code></pre>

<hr>
<h2 id='legitpix'>Legitimate picks in swig
</h2><span id='topic+legitpix'></span>

<h3>Description</h3>

<p>Legitimate picks in swig (used internally)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legitpix(sel, zloc, zenclick)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="legitpix_+3A_sel">sel</code></td>
<td>
<p>seleceted traces in swig
</p>
</td></tr>
<tr><td><code id="legitpix_+3A_zloc">zloc</code></td>
<td>
<p>location list
</p>
</td></tr>
<tr><td><code id="legitpix_+3A_zenclick">zenclick</code></td>
<td>
<p>number of legitimate picks
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list: ypick, ppick
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>swig
</p>

<hr>
<h2 id='letter.it'>Add letters to the corners of plots in multiple figures</h2><span id='topic+letter.it'></span>

<h3>Description</h3>

<p>Add letters to the corners of plots in multiple figures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>letter.it(a, corn = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="letter.it_+3A_a">a</code></td>
<td>
<p>character letter for marking figure</p>
</td></tr>
<tr><td><code id="letter.it_+3A_corn">corn</code></td>
<td>
<p>corner to put letter in</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can use uppercase or lower case letters, or roman numerals.
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow=c(2,2))
for(i in 1:4)
{
x  &lt;-  1:10
y  &lt;-  rnorm(10)
plot(x,y)
letter.it(letters[i], 2)

  }
</code></pre>

<hr>
<h2 id='LocalUnwrap'>Unwrap spectrum phase</h2><span id='topic+LocalUnwrap'></span>

<h3>Description</h3>

<p>unwrap the phase spectrum so it does not wrap around 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LocalUnwrap(p, cutoff = cutoff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LocalUnwrap_+3A_p">p</code></td>
<td>
<p>phase spectrum</p>
</td></tr>
<tr><td><code id="LocalUnwrap_+3A_cutoff">cutoff</code></td>
<td>
<p>cut off angle = pi </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Unwrapped spectrum
</p>


<h3>Note</h3>

 
<p>Algorithm minimizes the incremental phase variation by
constraining it to the range [-pi,pi]
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x  &lt;-  1:512
amp &lt;- sin(1*2*pi*x/16) + sin(2*2*pi*x/16)  + sin(3*2*pi*x/16)


spc &lt;- fft(amp)

plot(Mod(spc), type='l')

angle  &lt;-  Arg(spc)

plot(angle, type='l')

unang  &lt;-  LocalUnwrap(angle, cutoff =pi )
plot(unang, type='l')

</code></pre>

<hr>
<h2 id='logspace'>Logarithm</h2><span id='topic+logspace'></span>

<h3>Description</h3>

<p>Logarithmically spaced vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logspace(d1, d2, n = n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logspace_+3A_d1">d1</code></td>
<td>
<p>lower frequency</p>
</td></tr>
<tr><td><code id="logspace_+3A_d2">d2</code></td>
<td>
<p>upper frequency</p>
</td></tr>
<tr><td><code id="logspace_+3A_n">n</code></td>
<td>
<p>number of frequencies</p>
</td></tr>
</table>


<h3>Details</h3>

<p>generates a row vector of n logarithmically equally spaced
points between decades <code class="reqn">10^{X1}</code> and<code class="reqn">10^{X2}</code>
</p>


<h3>Value</h3>

<p>vector
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- logspace(1, 25)

</code></pre>

<hr>
<h2 id='longfft'>Long FFT Spectrogram
</h2><span id='topic+longfft'></span><span id='topic+longpstart'></span><span id='topic+longreset'></span>

<h3>Description</h3>

<p>Creates hourly spectrograms,
either alternating seismic and infrasound data or
sequences of one component. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>longfft(DB, DAYS = c(233, 234), HRS = 1:24, sta = "KR1", comp = c("V",
"I"), NPP = 6, CSCALE = FALSE, pal = rainbow(100), PS = FALSE, kind = 1,
Iendian = 1, BIGLONG = FALSE)

longreset(NPP, PS)

longpstart(NPP = 6, asta = "", acomp = "", theday = 1, hr = 0)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="longfft_+3A_db">DB</code></td>
<td>
<p>RSEIS Data base
</p>
</td></tr>
<tr><td><code id="longfft_+3A_days">DAYS</code></td>
<td>
<p>vector of Days to display 
</p>
</td></tr>
<tr><td><code id="longfft_+3A_hrs">HRS</code></td>
<td>
<p>vector of hours to display
</p>
</td></tr>
<tr><td><code id="longfft_+3A_sta">sta</code></td>
<td>
<p>stations to extract
</p>
</td></tr>
<tr><td><code id="longfft_+3A_comp">comp</code></td>
<td>
<p>component to extract
</p>
</td></tr>
<tr><td><code id="longfft_+3A_npp">NPP</code></td>
<td>
<p>Number of plot strips per page, default = 6
</p>
</td></tr>
<tr><td><code id="longfft_+3A_cscale">CSCALE</code></td>
<td>
<p>scaling
</p>
</td></tr>
<tr><td><code id="longfft_+3A_pal">pal</code></td>
<td>
<p>palettes to use (given two will alternate these) 
</p>
</td></tr>
<tr><td><code id="longfft_+3A_ps">PS</code></td>
<td>
<p>logical, TRUE postscript output
</p>
</td></tr>
<tr><td><code id="longfft_+3A_kind">kind</code></td>
<td>
<p>data type, an integer -1, 0, 1, 2 ; 0=R(DAT) , -1=RDS, 0=RDATA, 1 = segy,
2 = sac
</p>
</td></tr>
<tr><td><code id="longfft_+3A_iendian">Iendian</code></td>
<td>
<p>Endian-ness of binary data
</p>
</td></tr>
<tr><td><code id="longfft_+3A_biglong">BIGLONG</code></td>
<td>
<p>logical, TRUE=long is 8 bytes
</p>
</td></tr>
<tr><td><code id="longfft_+3A_asta">asta</code></td>
<td>
<p>character, one station
</p>
</td></tr>
<tr><td><code id="longfft_+3A_acomp">acomp</code></td>
<td>
<p>character, one component
</p>
</td></tr>
<tr><td><code id="longfft_+3A_theday">theday</code></td>
<td>
<p>one day
</p>
</td></tr>
<tr><td><code id="longfft_+3A_hr">hr</code></td>
<td>
<p>one hour
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extracts dats from the DB data base
and plots strips of spectrograms for perusal.
</p>
<p>longpstart, longreset are auxilliary codes used to set up the
postscript files and initialize the plotting.
</p>


<h3>Value</h3>

<p>Graphical Side effects
</p>


<h3>Note</h3>

<p>Program is set for data being ready from external
sources in binary (SAC, SEGY) format.
If data is in R-format already, the code may
not work.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>SPECT.drive
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
###  output directory
setwd("/home/lees/MARIO_TUNG/LONGFFT")

###  2 color palettes
p1 &lt;- Gcols(plow=5, phi=0,  N=100, pal="topo.colors", mingray=0.8)
p2 &lt;- Gcols(plow=5, phi=0,  N=100, pal="rainbow", mingray=0.8)

###   one station, vertical component
longfft(DB, DAYS=c(148:156) , HRS=1:24 ,
sta="BBIL", comp=c("BHZ") , NPP=6 , CSCALE=FALSE, 
pal = list(p1=p1, p2=p2), PS=TRUE ,  kind = 2,
Iendian=1, BIGLONG=FALSE )

###   one station, infrasound
longfft(DB, DAYS=c(148:156) , HRS=1:24 , sta="BBIL",
comp=c("BDF") , NPP=6 , CSCALE=FALSE, 
pal = list(p1=p2, p2=p1), PS=TRUE ,  kind = 2,
Iendian=1, BIGLONG=FALSE )

###  one station, both vertical and infrasound, alternating
longfft(DB, DAYS=c(148:156) , HRS=1:24 , sta="BBIL",
comp=c("BHZ", "BDF") , NPP=6 , CSCALE=FALSE, 
pal = list(p1=p2, p2=p1), PS=TRUE ,  kind = 2,
Iendian=1, BIGLONG=FALSE )






## End(Not run)


</code></pre>

<hr>
<h2 id='makeDB'>Create a seismic Waveform Database </h2><span id='topic+makeDB'></span><span id='topic+FmakeDB'></span>

<h3>Description</h3>

<p>Create a seismic Waveform Database</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDB(path=".", pattern="R", dirs="", kind = 1,
Iendian=1, BIGLONG=FALSE)
FmakeDB(LF2, kind =1, Iendian=1, BIGLONG=FALSE)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDB_+3A_path">path</code></td>
<td>
<p>character, Path to directory where files and directories exist</p>
</td></tr>
<tr><td><code id="makeDB_+3A_pattern">pattern</code></td>
<td>
<p>character, pattern for listing of files</p>
</td></tr>
<tr><td><code id="makeDB_+3A_dirs">dirs</code></td>
<td>
<p>character, vector of directories to be scanned</p>
</td></tr>
<tr><td><code id="makeDB_+3A_kind">kind</code></td>
<td>
<p>kind of data: RDS=-1, R(DAT)=0, segy=1; sac=2</p>
</td></tr>
<tr><td><code id="makeDB_+3A_iendian">Iendian</code></td>
<td>
<p>default=1, Endian-ness of the data: 1,2,3: &quot;little&quot;, &quot;big&quot;, &quot;swap&quot;.
Default = 1 (little)</p>
</td></tr>
<tr><td><code id="makeDB_+3A_biglong">BIGLONG</code></td>
<td>
<p> logical, TRUE means long=8 bytes
</p>
</td></tr>
<tr><td><code id="makeDB_+3A_lf2">LF2</code></td>
<td>
<p> list of files
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The files are typically located in a directory structure
created by programs like ref2segy, a PASSCAL program for
downloading data in the field.  Each file contains one seismogram,
with a header.  makeDB reads in all the headers and
creates a list of meta-data for later use in RSEIS.
</p>
<p>&quot;kind&quot; can be numeric or character: options are
'RDS', 'RDATA', 'SEGY', 'SAC', corresponding to (-1, 0, 1, 2).
</p>
<p>Uses readBin to extract data in SAC format.
user must know what kind of machine the data
was created on for I/O purposes.
</p>
<p>If data was created on a little endian machine but
is being read on big endian machine, need to call
the endian &quot;swap&quot; for swapping.
</p>
<p>If data was created on a machine with LONG=4 bytes,
be sure to call the program with BIGLONG=FALSE.
</p>
<p>If the base directory, or the subdirectories,  contain files that are
not seismic data then care must be taken.  Perhaps use FmakeDB
to explicitly names the files for the DataBase.
</p>
<p>If using FmakeDB a simple vector of files
(full path names) should be provided.
</p>
<p>The origin year, used for getting the Epoch year,
is stored as attribute origyr.
</p>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>fn</code></td>
<td>
<p>file name</p>
</td></tr>
<tr><td><code>yr</code></td>
<td>
<p>year</p>
</td></tr>
<tr><td><code>jd</code></td>
<td>
<p>julian day</p>
</td></tr>
<tr><td><code>hr</code></td>
<td>
<p>hour</p>
</td></tr>
<tr><td><code>mi</code></td>
<td>
<p>minute</p>
</td></tr>
<tr><td><code>sec</code></td>
<td>
<p>second</p>
</td></tr>
<tr><td><code>dur</code></td>
<td>
<p>duration, seconds</p>
</td></tr>
<tr><td><code>t1</code></td>
<td>
<p>time 1 in Epoch days</p>
</td></tr>
<tr><td><code>t2</code></td>
<td>
<p>time 2 in Epoch days</p>
</td></tr>
<tr><td><code>sta</code></td>
<td>
<p>station name</p>
</td></tr>
<tr><td><code>comp</code></td>
<td>
<p>component name</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>sample rate, seconds</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Epoch times are used to accomodate problems where
julian days cross year end boundaries, so that
day 366 comes before day 1 of the next year.
</p>
<p>The origyr, kind , Iendian, BIGLONG are stored as attributes
in the Database.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>setupDB, Mine.seis , getseis24, plotseis24, EPOCHday, swig</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#####  set directory
path &lt;- '/home/lees/Site/Santiaguito/SG09'
pattern &lt;- "R0*"

###   get DB information
XDB  &lt;-  makeDB(path, pattern, kind =1)

##### select a station
usta &lt;- "CAL"
acomp &lt;- "V"

#####   extract 24 hours worht of data
JJ &lt;- getseis24(DB, 2009, 2, usta, acomp, kind = 1)


#####  plot 24 hours worth of data

pjj &lt;- plotseis24(JJ, dy=1/18, FIX=24, SCALE=0,
FILT=list(ON=FALSE, fl=0.05 , fh=20.0, type="BP", proto="BU"),
RCOLS=c(rgb(0.2, .2, 1), rgb(.2, .2, .2))  )


###  window a small portion on 24 hour display
w &lt;- winseis24(pjj)

###  open a new window
X11()
VNE &lt;- c("V", "N", "E")
###  IJK &lt;- c("I", "J", "K")

gsta &lt;- c("CAL", "KAM", "DOM",  "LAV")

ucomp&lt;-VNE

###  or:   ucomp&lt;-IJK

###   set epoch day and get the times
 eday &lt;- EPOCHday(w$yr, jd = w$jd, origyr = DB$origyr)

##  using epoch day, set times for beginning and end of window
        at1 &lt;- eday$jday + (w$hr[1])/24
        at2 &lt;- eday$jday + (w$hr[2])/24
###  extract data from the data base:
        GH &lt;- Mine.seis(at1, at2, DB, gsta, ucomp)

###  show data:
        swig(GH)


## End(Not run)


</code></pre>

<hr>
<h2 id='makefreq'>Make Frequency</h2><span id='topic+makefreq'></span>

<h3>Description</h3>

<p>Create a frequency value for integration and differentiation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makefreq(n, dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makefreq_+3A_n">n</code></td>
<td>
<p>number of freqs</p>
</td></tr>
<tr><td><code id="makefreq_+3A_dt">dt</code></td>
<td>
<p>deltat</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of frequencies
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>INVRft</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 256
dt &lt;- 0.008
f &lt;- makefreq(N,dt)


</code></pre>

<hr>
<h2 id='markseis24'>Mark 24 hour seismic display
</h2><span id='topic+markseis24'></span>

<h3>Description</h3>

<p>Mark a 24 hour seismic display
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markseis24(pjj, pix = list(yr = 2009, jd = 1, hr = 0, mi = 0, sec = 0,
dur = 0), col = "red", LEGON = 3, BARON = TRUE, ARROWS = TRUE, lwd=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markseis24_+3A_pjj">pjj</code></td>
<td>
<p>Output information from plotseis24 (x,y, yr, jd)
</p>
</td></tr>
<tr><td><code id="markseis24_+3A_pix">pix</code></td>
<td>
<p>list:
date list consisting of: yr, jd, hr, mi, sec, dur)
</p>
</td></tr>
<tr><td><code id="markseis24_+3A_col">col</code></td>
<td>
<p>Color, specified as color index, character string or rgb
</p>
</td></tr>
<tr><td><code id="markseis24_+3A_legon">LEGON</code></td>
<td>

<p>plotting flag for legs: 0=no legs, 1=left leg, 2=right leg, 3=both legs(def
ault)
</p>
</td></tr>
<tr><td><code id="markseis24_+3A_baron">BARON</code></td>
<td>

<p>logical:plotting flag for bar
</p>
</td></tr>
<tr><td><code id="markseis24_+3A_arrows">ARROWS</code></td>
<td>
<p>logical: plot arrows FALSE=no arrows
</p>
</td></tr>
<tr><td><code id="markseis24_+3A_lwd">lwd</code></td>
<td>
<p>numeric, graphical parameter, line width
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the LEGON parameter controls the small marks at the ends: Either left(1)
right(2) both(3) or no legs(0) are plotted.  window bars should wrap
around the ends of the hour to the next hour below.
The durations of the windows are supplied in seconds.  If no duration
is supplied, it is set to 0.  If one duration is supplied it is copied
to all other windows.
</p>


<h3>Value</h3>

<p>Graphical Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>winmark, getseis24,  plotseis24
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
##  the database DB was constructed with makeDB

usta = "CAL"
acomp = "V"

iday = 2

###   get one day's worth of data
JJ &lt;- getseis24(DB, 2009, iday, "CAL", "V", kind = 1)

###  plot day
pjj &lt;- plotseis24(JJ, dy=1/18, FIX=24, SCALE=0,
FILT &lt;- list(ON=FALSE, fl=0.5 , fh=20.0, type="BP", proto="BU"),
RCOLS=c(rgb(0.2, .2, 1), rgb(.2, .2, .2))  )
title(paste("CAL", "V"))

###   set up pix
WINS2 &lt;- win15
Apix &lt;- WINS2$hr[seq(from=1, to=length(WINS2$hr), by=2) ]
dur &lt;- (WINS2$hr[seq(from=2, to=length(WINS2$hr), by=2) ]-Apix)*3600

## dur &lt;- rep(0, times=length(Apix))

##  mark the 24 hour plot
markseis24(pjj, pix =list(yr=rep(pjj$yr, length(Apix)),
 jd=rep(pjj$jd, length(Apix)) , hr=Apix, mi=rep(0, length(Apix)),
sec=rep(0, length(Apix)), dur=dur), col='red', ARROWS=FALSE )





## End(Not run)


</code></pre>

<hr>
<h2 id='matsquiggle'>Matrix Seismic Record</h2><span id='topic+matsquiggle'></span>

<h3>Description</h3>

<p>Plot a matrix of time series as a var-squiggle display (filled in half
traces)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matsquiggle(XMAT, dt1, dist = NULL, thick = 1,
 FLIP = FALSE, filcol='blue', tracecol="black", add=FALSE, PLOT=TRUE,xpd=TRUE, plotdir=1 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matsquiggle_+3A_xmat">XMAT</code></td>
<td>
<p>matrix of traces</p>
</td></tr>
<tr><td><code id="matsquiggle_+3A_dt1">dt1</code></td>
<td>
<p>sample interval, s</p>
</td></tr>
<tr><td><code id="matsquiggle_+3A_dist">dist</code></td>
<td>
<p>distance for each trace in the matrix</p>
</td></tr>
<tr><td><code id="matsquiggle_+3A_thick">thick</code></td>
<td>
<p>thickness for each trace to be plotted</p>
</td></tr>
<tr><td><code id="matsquiggle_+3A_flip">FLIP</code></td>
<td>
<p>logical, FALSE (default) plot horizontal, TRUE=plot
vertical</p>
</td></tr>
<tr><td><code id="matsquiggle_+3A_filcol">filcol</code></td>
<td>
<p>color for shading</p>
</td></tr>
<tr><td><code id="matsquiggle_+3A_tracecol">tracecol</code></td>
<td>
<p>color for trace</p>
</td></tr>
<tr><td><code id="matsquiggle_+3A_add">add</code></td>
<td>
<p>add traces to existing plot</p>
</td></tr>
<tr><td><code id="matsquiggle_+3A_plot">PLOT</code></td>
<td>
<p>whether to create a new plotting region</p>
</td></tr>
<tr><td><code id="matsquiggle_+3A_xpd">xpd</code></td>
<td>
<p>logical, set xpd parameter (see par) </p>
</td></tr>	
<tr><td><code id="matsquiggle_+3A_plotdir">plotdir</code></td>
<td>
<p>1=left to right, 0=right to left (default=1) </p>
</td></tr>
</table>


<h3>Details</h3>

<p> see varsquiggle for more details
</p>


<h3>Value</h3>

<p>side effects.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>varsquiggle, varsquig</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(GH)
m &lt;- match( GH$STNS,    GH$stafile$name)
LATS &lt;- GH$stafile$lat[m]
LONS &lt;- GH$stafile$lon[m]
dees &lt;- rdistaz( GH$pickfile$LOC$lat, GH$pickfile$LOC$lon, LATS, LONS)

sel &lt;- which(GH$COMPS=="V")
sel &lt;- sel[order(dees$dist[sel])]

###  plot normal way:
### swig(GH, sel=sel, WIN=c(5,10), SHOWONLY=TRUE)


###  plot with varsquiggle
### varsquiggle(GH, sel=sel, WIN=c(5,10))

ex &lt;- seq(from=0, by=GH$dt[sel[1]], length=length(GH$JSTR[[sel[1]]]))
wx &lt;- ex&gt;=5 &amp; ex&lt;=10
XMAT &lt;- matrix(ncol=length(sel), nrow=length(which(wx)))

for(i in 1:length(sel))
{
XMAT[,i] &lt;-  GH$JSTR[[sel[i]]][wx]

}


matsquiggle(XMAT, GH$dt[sel[1]] , dist = dees$dist[sel] , thick = 1,
FLIP = FALSE)

axis(1)
axis(2)
title(xlab="Time, s", ylab="Distance, km")


</code></pre>

<hr>
<h2 id='Mine.seis'>Mine a seismic data base to extract secions of time limited data</h2><span id='topic+Mine.seis'></span>

<h3>Description</h3>

<p>Mine a seismic data base to extract secions of time limited data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mine.seis(at1, at2, DB, grepsta, grepcomp, kind = 1, Iendian=1,
BIGLONG=FALSE, CHOP=TRUE, verbose=FALSE, chtoken=NULL, statoken=NULL, RAW=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mine.seis_+3A_at1">at1</code></td>
<td>
<p>time 1 in julian days</p>
</td></tr>
<tr><td><code id="Mine.seis_+3A_at2">at2</code></td>
<td>
<p>time 2 in julian days</p>
</td></tr>
<tr><td><code id="Mine.seis_+3A_db">DB</code></td>
<td>
<p>data base structure to searcth through that provides the
files where data is to extracted from</p>
</td></tr>
<tr><td><code id="Mine.seis_+3A_grepsta">grepsta</code></td>
<td>
<p>which stations to extract</p>
</td></tr>
<tr><td><code id="Mine.seis_+3A_grepcomp">grepcomp</code></td>
<td>
<p>which components to extract</p>
</td></tr>
<tr><td><code id="Mine.seis_+3A_kind">kind</code></td>
<td>
<p>kind of data, -1=&quot;RDS&quot;, 0=&quot;RDATA&quot; ,  0=&quot;RDATA&quot;, 1 = &quot;segy&quot;,
2 = &quot;sac&quot;</p>
</td></tr>
<tr><td><code id="Mine.seis_+3A_iendian">Iendian</code></td>
<td>
<p> Endian-ness of the data: 1,2,3: &quot;little&quot;, &quot;big&quot;, &quot;swap&quot;.
Default = 1 (little)
</p>
</td></tr>
<tr><td><code id="Mine.seis_+3A_biglong">BIGLONG</code></td>
<td>
<p> logical, TRUE=long=8 bytes
</p>
</td></tr>
<tr><td><code id="Mine.seis_+3A_chop">CHOP</code></td>
<td>
<p>cut the data to a window using CHOP.SEISN </p>
</td></tr>
<tr><td><code id="Mine.seis_+3A_verbose">verbose</code></td>
<td>
<p>print out intermediate information for debugging </p>
</td></tr>
<tr><td><code id="Mine.seis_+3A_chtoken">chtoken</code></td>
<td>
<p>channel token for selecting channels (NULL) </p>
</td></tr>
<tr><td><code id="Mine.seis_+3A_statoken">statoken</code></td>
<td>
<p>station token for selecting stations (NULL) </p>
</td></tr>
<tr><td><code id="Mine.seis_+3A_raw">RAW</code></td>
<td>
<p>logical, default=FALSE(convert to volts) , TRUE (return counts intead of
volts) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data base is a list or dataframe containing the files names, the
beginning time (t1) and ending time (t2) for each file in the data
base.  Mine.seis uses grep on the file names to
extract specific files from the DB list.
</p>
<p>Mine.seis needs to know what format the data was
created in: little/big endian and the size of the LONG.
</p>
<p>If data was created on a little endian machine but
is being read on big endian machine, need to call
the endian &quot;swap&quot; for swapping.
</p>
<p>If data was created on a machine with LONG=4 bytes,
be sure to call the program with BIGLONG=FALSE.
</p>
<p>Use sysinfo to findout the system parameters for the local
system.  You need to know, however, what machine the binary files
were created on.
</p>
<p>In some situation the chanel name and the station name are not embedded in the
file headers - in that case use the token from the file name.
</p>


<h3>Value</h3>

<p>List of seismograms cut from the database
</p>


<h3>Note</h3>

<p>The headers in the digital (segy or SAC) data files
may not necessarily match the file names.  Note that
program JGET.seis extracts the station name and component
name from the digital header and does not use the
file name.  It may be prudent to force the file names
and header files to match prior to using Mine.seis.
For SEGY files, in LINUX-UNIX, use:
rename,    segymod (PASSCAL) to modify the headers.
</p>
<p>For SAC files, use sac software.
</p>
<p>For R-based codes save the files in
a format that has the relevant information (DAT format).
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>makeDB, GLUEseisMAT, JGET.seis, JSAC.seis, JSEGY.seis, sysinfo</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

#######   Assume  k97DB already exists
for(i in 1:24)
{
at1 &lt;- 232+(i-1)/24
at2 &lt;- at1+1/24

GH &lt;- Mine.seis(at1, at2, k97DB, "kar1", c("4", "1") )
w &lt;- swig(GH)
if(identical(w$but, "QUIT"))break
}





## End(Not run)




</code></pre>

<hr>
<h2 id='mirror.matrix'>mirror matrix</h2><span id='topic+mirror.matrix'></span>

<h3>Description</h3>

<p>mirrored representation of image matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mirror.matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mirror.matrix_+3A_x">x</code></td>
<td>
<p>matrix </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used for flipping the output of the wavelet transform for
more convenient plotting.
</p>


<h3>Value</h3>

<p>matrix
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>References</h3>

<p>Rwave, plotwlet, wlet.do, wlet.drive</p>


<h3>Examples</h3>

<pre><code class='language-R'>
xy &lt;- matrix(rnorm(100), ncol=10)
mirror.matrix(xy)


</code></pre>

<hr>
<h2 id='Mmorlet'>Morlet Wavelet</h2><span id='topic+Mmorlet'></span>

<h3>Description</h3>

<p>Make Morlet Wavelet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mmorlet(UB = -4, LB = 4, N = 256, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mmorlet_+3A_ub">UB</code></td>
<td>
<p>upper bound </p>
</td></tr>
<tr><td><code id="Mmorlet_+3A_lb">LB</code></td>
<td>
<p>lower bound</p>
</td></tr>
<tr><td><code id="Mmorlet_+3A_n">N</code></td>
<td>
<p>number of points</p>
</td></tr>
<tr><td><code id="Mmorlet_+3A_plot">plot</code></td>
<td>
<p>logical, TRUE=plot </p>
</td></tr>
</table>


<h3>Details</h3>

<p>create a morlet function based on the matlab style routines
</p>


<h3>Value</h3>

<p>time series list:
</p>
<table>
<tr><td><code>xval</code></td>
<td>
<p>x-output</p>
</td></tr>
<tr><td><code>morl</code></td>
<td>
<p>y-output</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>scal2freqs, Rwave </p>


<h3>Examples</h3>

<pre><code class='language-R'>
mm  &lt;- Mmorlet(-8, 8, 256)



</code></pre>

<hr>
<h2 id='mtapspec'>MTM spectrum</h2><span id='topic+mtapspec'></span>

<h3>Description</h3>

<p>Multi-tape Method Spectrum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtapspec(a, dt, klen = length(a), MTP = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtapspec_+3A_a">a</code></td>
<td>
<p>vector time series</p>
</td></tr>
<tr><td><code id="mtapspec_+3A_dt">dt</code></td>
<td>
<p>sample rate</p>
</td></tr>
<tr><td><code id="mtapspec_+3A_klen">klen</code></td>
<td>
<p>length of fft</p>
</td></tr>
<tr><td><code id="mtapspec_+3A_mtp">MTP</code></td>
<td>
<p>MTM parameters, list:
</p>

<dl>
<dt>kind</dt><dd><p>kind of taper average</p>
</dd>
<dt>nwin</dt><dd><p>number of windows</p>
</dd>
<dt>npi</dt><dd><p>number of Pi-prolate functions</p>
</dd>
<dt>inorm</dt><dd><p>normalization flag</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p>MTP represent parameters that control the multi-tape pi-prolate
functions used by mtapspec.  See reference for details.
</p>


<h3>Value</h3>

<p>LIST
</p>
<table>
<tr><td><code>dat</code></td>
<td>
<p>input data</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>sample rate</p>
</td></tr>
<tr><td><code>spec</code></td>
<td>
<p>Estimated power spectrum</p>
</td></tr>
<tr><td><code>dof</code></td>
<td>
<p>degrees of freedom for each frequency</p>
</td></tr>
<tr><td><code>Fv</code></td>
<td>
<p>F-values for each frequency</p>
</td></tr>
<tr><td><code>Rspec</code></td>
<td>
<p>real part of complex spectrum</p>
</td></tr>
<tr><td><code>Ispec</code></td>
<td>
<p>imaginary part of complex spectrum</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>frequencies</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>delta frequency</p>
</td></tr>
<tr><td><code>numfreqs</code></td>
<td>
<p>number of frequencies</p>
</td></tr>
<tr><td><code>klen</code></td>
<td>
<p>length used in fft</p>
</td></tr>
<tr><td><code>mtm</code></td>
<td>
<p>input MTM parameters, see above</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>References</h3>

<p>Lees, J. M. and Park, J., 1995: Multiple-taper spectral analysis: A stand-alone C-subroutine, <em>Computers and Geology</em>, 21(2), 199-236. </p>


<h3>See Also</h3>

<p>fft </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CE1)
a &lt;- list(y=CE1$y[CE1$x&gt;5.443754 &amp; CE1$x&lt;5.615951], dt=CE1$dt)

    Mspec &lt;-  mtapspec(a$y,a$dt, klen=4096,
             MTP=list(kind=2,nwin=5, npi=3,inorm=0)  )   

</code></pre>

<hr>
<h2 id='MTM.drive'>Interactive MTM driver</h2><span id='topic+MTM.drive'></span>

<h3>Description</h3>

<p>MTM analysis of signals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MTM.drive(a, f1 = f1, f2 = f2, len2 = 1024, COL = 2, PLOT = FALSE,
PADDLAB = NULL, GUI = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MTM.drive_+3A_a">a</code></td>
<td>
<p>list(y=time series amp, dt=delta-ts, stamps=text stamps) </p>
</td></tr>
<tr><td><code id="MTM.drive_+3A_f1">f1</code></td>
<td>
<p>low frequency </p>
</td></tr>
<tr><td><code id="MTM.drive_+3A_f2">f2</code></td>
<td>
<p>high frequency </p>
</td></tr>
<tr><td><code id="MTM.drive_+3A_len2">len2</code></td>
<td>
<p>power of two length </p>
</td></tr>
<tr><td><code id="MTM.drive_+3A_col">COL</code></td>
<td>
<p>colors </p>
</td></tr>
<tr><td><code id="MTM.drive_+3A_plot">PLOT</code></td>
<td>
<p>logical PLOT=TRUE </p>
</td></tr>
<tr><td><code id="MTM.drive_+3A_paddlab">PADDLAB</code></td>
<td>
<p>vector of buttons</p>
</td></tr>
<tr><td><code id="MTM.drive_+3A_gui">GUI</code></td>
<td>
<p>Whether to be in GUI (interactive) mode</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>References</h3>

<p>Lees, J. M. and Park, J., 1995: Multiple-taper spectral analysis: A stand-alone C-subroutine, <em>Computers and Geology</em>, 21(2), 199-236.</p>


<h3>See Also</h3>

<p>plt.MTM0</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("GH")
sel &lt;-  which(GH$COMPS=="V")

amp  &lt;-  list()
dees  &lt;-  list()
stamps  &lt;-  list()

for( i in 1:3)
{
amp[[i]]  &lt;-  GH$JSTR[[sel[i]]]
dees[i]  &lt;-  GH$dt[sel[i]]
stamps[i]  &lt;-  paste(GH$STNS[sel[i]], GH$COMPS[sel[i]])
}

 a  &lt;-  list(y=amp, dt=dees, stamps=stamps)


 f1  &lt;-  0.1

f2  &lt;-  floor(0.33*(1/a$dt[[1]]))

speccol   &lt;-  c('red', 'blue', 'purple')


MTM.drive(a, f1, f2, COL=speccol, PLOT=TRUE)


</code></pre>

<hr>
<h2 id='MTMdisp'> MTMdisp</h2><span id='topic+MTMdisp'></span>

<h3>Description</h3>

<p>Display MTM displacement spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MTMdisp(a, f1 = f1, f2 = f2, len2 = 1024, PLOT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MTMdisp_+3A_a">a</code></td>
<td>
<p>seismic velocity trace, as a ts structure (list(y=trace,
dt=sample rate) </p>
</td></tr>
<tr><td><code id="MTMdisp_+3A_f1">f1</code></td>
<td>
<p> low frequency </p>
</td></tr>
<tr><td><code id="MTMdisp_+3A_f2">f2</code></td>
<td>
<p>high frequency </p>
</td></tr>
<tr><td><code id="MTMdisp_+3A_len2">len2</code></td>
<td>
<p>length of fft </p>
</td></tr>
<tr><td><code id="MTMdisp_+3A_plot">PLOT</code></td>
<td>
<p> logical, TRUE=plot </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses Multi-taper estimate of spectrum and divides the spectrum by
1/(2*pi*f) to get integration of velocity seismogram.
</p>


<h3>Value</h3>

<p>Returns displacement spectrum.
Graphical Side effect.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>References</h3>

<p>Lees, J. M. and Park, J., 1995: Multiple-taper spectral
analysis: A stand-alone C-subroutine, <em>Computers and  Geology</em>, 21(2), 199-236.</p>


<h3>See Also</h3>

<p>mtapspec  </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CE1)
xvel &lt;- list(y=CE1$y[CE1$x&gt;5.443754 &amp; CE1$x&lt;5.615951], dt=CE1$dt)

len2 &lt;- next2(length(xvel$y))
Spec &lt;- MTMdisp(xvel, f1=.01, f2=25, len2=len2, PLOT=FALSE )

</code></pre>

<hr>
<h2 id='MTMgabor'>Evolutive MTM Spectrum
</h2><span id='topic+MTMgabor'></span>

<h3>Description</h3>

<p>Time varying Auto-Regressive Spectrum (Gabor Transform) using MTM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MTMgabor(a, dt = 0, ppoint=95 , numf = 1024, Ns = 0, Nov = 0, fl = 0, fh = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MTMgabor_+3A_a">a</code></td>
<td>
<p>signal</p>
</td></tr>
<tr><td><code id="MTMgabor_+3A_dt">dt</code></td>
<td>
<p>sample rate interval (s)</p>
</td></tr>
<tr><td><code id="MTMgabor_+3A_ppoint">ppoint</code></td>
<td>
<p>percent confidence for F-test (default=95) </p>
</td></tr>
<tr><td><code id="MTMgabor_+3A_numf">numf</code></td>
<td>
<p>Number of frequencies</p>
</td></tr>
<tr><td><code id="MTMgabor_+3A_ns">Ns</code></td>
<td>
<p>Number of sample in sub-window </p>
</td></tr>
<tr><td><code id="MTMgabor_+3A_nov">Nov</code></td>
<td>
<p>Number of sample to overlap</p>
</td></tr>
<tr><td><code id="MTMgabor_+3A_fl">fl</code></td>
<td>
<p>low frequency to display</p>
</td></tr>
<tr><td><code id="MTMgabor_+3A_fh">fh</code></td>
<td>
<p>high frequency to display</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a spectrogram function similar to the Gabor Transform
but uses the MTM (multi-taper method) for spectrum estimation.
This is a non-interactive version of MTM.drive.
</p>


<h3>Value</h3>

<p>List
</p>
<table>
<tr><td><code>sig</code></td>
<td>
<p>input signal</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>deltat</p>
</td></tr>
<tr><td><code>numfreqs</code></td>
<td>
<p>Number of frequencies output</p>
</td></tr>
<tr><td><code>wpars</code></td>
<td>
<p>input parameters list(Nfft=numfreqs,  Ns=Ns, Nov=Nov, fl=fl, fh=fh)</p>
</td></tr>
<tr><td><code>DSPEC</code></td>
<td>
<p>spectrum image</p>
</td></tr>
<tr><td><code>HIMAT</code></td>
<td>
<p>matrix with high values of F-test at 90 percent confidence
</p>
</td></tr>
<tr><td><code>DOFMAT</code></td>
<td>
<p>Matrix image of degrees of freedom</p>
</td></tr>
<tr><td><code>FVMAT</code></td>
<td>
<p>Matrix image of F-test values</p>
</td></tr>
<tr><td><code>kdof</code></td>
<td>
<p>test degrees of freedom=2*nwin-2</p>
</td></tr>
<tr><td><code>ppoint</code></td>
<td>
<p>percentage point for confidence bounds</p>
</td></tr>
<tr><td><code>freqs</code></td>
<td>
<p>output frequencies (y axis)</p>
</td></tr>
<tr><td><code>tims</code></td>
<td>
<p>output times (x-axis) </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Percival and Walden;
</p>
<p>Lees, J. M. and Park, J., 1995: Multiple-taper spectral analysis: A
stand-alone C-subroutine, <em>Computers and Geology</em>, 21(2), 199-236.
</p>
<p>Percival, Donald B.,Walden, Andrew T. (1993):Spectral Analysis for
Physical Applications,Cambridge University Press, Cambridge,  583p.
</p>


<h3>See Also</h3>

<p>evolfft, evolMTM, MTM.drive, GETARAIC, doGABOR.AR, DOsgram, doGABOR.MTM
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 
data(KH)
###   swig(KH)

Xamp &lt;- KH$JSTR[[1]]
Nfft &lt;- 1024   ###  fft length
Ns &lt;- 512      ###  number of samples in a window
Nov &lt;- 480    ###  number of samples of overlap per window
fl &lt;- 0        ###  low frequency to return
fh &lt;- 12     ###  high frequency to return
 dt  &lt;-  KH$dt[1]


EV &lt;-   MTMgabor(Xamp, dt = dt, numf =Nfft , Ns = Ns, Nov = Nov, fl = fl, fh= fh)

PE   &lt;- plotevol(EV, log=1, fl=0.01, fh=fh, col=rainbow(100),
              ygrid=FALSE, STAMP="", STYLE="ar")


## End(Not run)


</code></pre>

<hr>
<h2 id='MTMplot'>Plot Multi-taper Spectrum</h2><span id='topic+MTMplot'></span>

<h3>Description</h3>

<p>Plots output of MTM specturm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MTMplot(a, f1 = f1, f2 = f2, len2 = 1024, PLOT = FALSE, PADDLAB = NULL, GUI = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MTMplot_+3A_a">a</code></td>
<td>
<p>signal</p>
</td></tr>
<tr><td><code id="MTMplot_+3A_f1">f1</code></td>
<td>
<p>lower frequency</p>
</td></tr>
<tr><td><code id="MTMplot_+3A_f2">f2</code></td>
<td>
<p>upper frequency</p>
</td></tr>
<tr><td><code id="MTMplot_+3A_len2">len2</code></td>
<td>
<p>number of points in spectrum</p>
</td></tr>
<tr><td><code id="MTMplot_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE=plot</p>
</td></tr>
<tr><td><code id="MTMplot_+3A_paddlab">PADDLAB</code></td>
<td>
<p>Labels for buttons</p>
</td></tr>
<tr><td><code id="MTMplot_+3A_gui">GUI</code></td>
<td>
<p>use a GUI to display for other interactions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses Lees' MTM code.
</p>


<h3>Value</h3>

<p>list(len2=len2, f=f, f1=f1, f2=f2, displ=displ, ampsp=amp, flag=flag )
</p>
<table>
<tr><td><code>len2</code></td>
<td>
<p>next power of 2 for fft calculation</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>frequencies</p>
</td></tr>
<tr><td><code>f1</code></td>
<td>
<p>lower freq</p>
</td></tr>
<tr><td><code>f2</code></td>
<td>
<p>upper freq</p>
</td></tr>
<tr><td><code>displ</code></td>
<td>
<p>kind of display</p>
</td></tr>
<tr><td><code>ampsp</code></td>
<td>
<p>amplitude spectrum</p>
</td></tr>
<tr><td><code>flag</code></td>
<td>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>MTM.drive, MTMdisp, plt.MTM0</p>

<hr>
<h2 id='NEW.getUWSTAS'>get UW station file</h2><span id='topic+NEW.getUWSTAS'></span>

<h3>Description</h3>

<p>Match Picks with stations and return station structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NEW.getUWSTAS(PICS)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NEW.getUWSTAS_+3A_pics">PICS</code></td>
<td>
<p>Picks in pickfile</p>
</td></tr>
</table>


<h3>Details</h3>

<p>matches Picks with stations
</p>


<h3>Value</h3>

<p>STAS structure
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>

<hr>
<h2 id='NEWPLOT.WPX'>Plot Window Picks (WPX) </h2><span id='topic+NEWPLOT.WPX'></span>

<h3>Description</h3>

<p>adds picks to existing seismic section
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NEWPLOT.WPX(t0, STNS, COMPS, YPX, FILL = FALSE, FORCE = TRUE, cex = cex, srt = srt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NEWPLOT.WPX_+3A_t0">t0</code></td>
<td>
<p>starting time for window</p>
</td></tr>
<tr><td><code id="NEWPLOT.WPX_+3A_stns">STNS</code></td>
<td>
<p>stations to match</p>
</td></tr>
<tr><td><code id="NEWPLOT.WPX_+3A_comps">COMPS</code></td>
<td>
<p>components to match</p>
</td></tr>
<tr><td><code id="NEWPLOT.WPX_+3A_ypx">YPX</code></td>
<td>
<p>list of picks</p>
</td></tr>
<tr><td><code id="NEWPLOT.WPX_+3A_fill">FILL</code></td>
<td>
<p>fill color</p>
</td></tr>
<tr><td><code id="NEWPLOT.WPX_+3A_force">FORCE</code></td>
<td>
<p>logical, TRUE=plot picks on all traces</p>
</td></tr>
<tr><td><code id="NEWPLOT.WPX_+3A_cex">cex</code></td>
<td>
<p>character expansion</p>
</td></tr>
<tr><td><code id="NEWPLOT.WPX_+3A_srt">srt</code></td>
<td>
<p>string rotation angle</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used in conjunction with swig program
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>swig</p>


<h3>Examples</h3>

<pre><code class='language-R'>########  no example available now
</code></pre>

<hr>
<h2 id='next2'>Next Power of Two</h2><span id='topic+next2'></span>

<h3>Description</h3>

<p>Return next power of two greater than n
</p>


<h3>Usage</h3>

<pre><code class='language-R'>next2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="next2_+3A_x">x</code></td>
<td>
<p>length of vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer value
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>k &lt;- 1236
next2(k)

</code></pre>

<hr>
<h2 id='OH'>Delta-O18 isotpe record</h2><span id='topic+OH'></span>

<h3>Description</h3>

<p>Data from Delta-O18 Isotope record of climate change.
Periodicities of this data show the Milancovic cycles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> data(OH) </code></pre>


<h3>Format</h3>

<p>OH = 
list( LOC=list(yr=0, jd=0, mo=0, dom=0, hr=0, mi=0, sec=0,
lat=0, lon=0, z=0, mag=0, gap=0,
delta=0 , rms=0, hozerr=0),
MC=list(az1=0, dip1=0, az2=0, dip2=0,  dir=0, rake1=0,
dipaz1=0, rake2=0, dipaz2=0,
F=list(az=0, dip=0), G=list(az=0, dip=0), U=list(az=0, dip=0),
V=list(az=0, dip=0), P=list(az=0, dip=0), T=list(az=0,
dip=0),sense=0,M=list( az1=0, d1=0,  az2=0, d2=0, uaz=0,
ud=0, vaz=0,
vd=0, paz=0, pd =0, taz=0, td=0), UP=TRUE, icol=1, ileg=&quot;&quot;,
fcol='red', CNVRG=&quot;&quot;, LIM =c(0,0,0,0)
),
</p>
<p>STAS=list(tag=&quot;&quot;, name=&quot;&quot;, comp=&quot;&quot;, c3=&quot;&quot;, phase=&quot;&quot;,
sec=0, err=0, pol=&quot;&quot;, flg=0 , res=0),
</p>
<p>LIP=vector(length=6),
</p>
<p>H=list(yr=0,mo=0,dom=0,hr=0,mi=0,sec=0,lat=0,lon=0,z=0,mag=0),
</p>
<p>N=list(name=&quot;&quot;),
</p>
<p>E=list(rms=0,meanres=0,sdres=0,sdmean=0,sswres=0,ndf=0,
fixflgs=0,sterrx=0,sterry=0,sterrz=0,sterrt=0,mag=0,sterrmag=0),
</p>
<p>filename=&quot;&quot;,
</p>
<p>PICKER=&quot;&quot;,
UWFILEID=&quot;&quot;,winID1=&quot;&quot;,comments=&quot;&quot;, OSTAS=&quot;&quot;)
</p>


<h3>Note</h3>

<p>The sample unit here is set to 0.3 which
is 10000 times the correct sample rat.
</p>


<h3>References</h3>

<p>Lees, J. M. and J. Park (1995): Multiple-taper spectral analysis: A stand-alone C-subroutine: Computers &amp; Geology: 21, 199-236.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(OH)
xx &lt;-  swig( OH, sel=which(OH$COMPS == "V"), SHOWONLY=0)

</code></pre>

<hr>
<h2 id='one'>one plotting region</h2><span id='topic+one'></span>

<h3>Description</h3>

<p>change from multiple R-screens to one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>
par(mfrow=c(2,1))

plot(rnorm(10), rnorm(10) )

plot(rnorm(10), rnorm(10) )

one()
plot(rnorm(10), rnorm(10) )


</code></pre>

<hr>
<h2 id='P2GH'>XTR button to RSEIS
</h2><span id='topic+P2GH'></span>

<h3>Description</h3>

<p>Convert output of XTR button to RSEIS list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>P2GH(P1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="P2GH_+3A_p1">P1</code></td>
<td>

<p>Output of swig after clicking XTR
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Running swig out after a selection of a window and
the XTR button, one can create an RSEIS structure for further use
in swig.
</p>


<h3>Value</h3>

<p>RSEIS list
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;
</p>


<h3>See Also</h3>

<p>swig,
prepSEIS
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

P1 &lt;- swig(GH)
LH &lt;- P2GH(P1)


## End(Not run)

</code></pre>

<hr>
<h2 id='parse.pde'>Parse PDE file
</h2><span id='topic+parse.pde'></span>

<h3>Description</h3>

<p>Parse and Extact information from a screen dump of
PDE (preliminary earthquake estimates) from the internet,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse.pde(card)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse.pde_+3A_card">card</code></td>
<td>
<p>character, one line from the PDE file
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parsing is done by column specification.  Uses screen dump format.
see http://neic.usgs.gov/neis/epic/epic.html
</p>


<h3>Value</h3>

<p>Time, Location and Magnitude:
list(yr, jd, mo, dom, hr, mi, sec,  lat, lon, depth, z, mag)  
</p>


<h3>Note</h3>

<p>May try using the CSV version of the dump.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>http://neic.usgs.gov/neis/epic/epic.html
</p>


<h3>See Also</h3>

<p>getPDEcsv, getPDEscreen
</p>

<hr>
<h2 id='parseFN2STA'>get station from file name</h2><span id='topic+parseFN2STA'></span>

<h3>Description</h3>

<p>station and component are assumed to be the last elements
of a file name - this function returns a list with these text strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseFN2STA(fn, ista, icomp, sep="\\.", dir=0  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseFN2STA_+3A_fn">fn</code></td>
<td>
<p>text file name </p>
</td></tr>
<tr><td><code id="parseFN2STA_+3A_ista">ista</code></td>
<td>
<p>index of station name counting from the end of the file name </p>
</td></tr>
<tr><td><code id="parseFN2STA_+3A_icomp">icomp</code></td>
<td>
<p>index of station name counting from the end of the file name </p>
</td></tr>
<tr><td><code id="parseFN2STA_+3A_sep">sep</code></td>
<td>
<p>separator token in file name </p>
</td></tr>
<tr><td><code id="parseFN2STA_+3A_dir">dir</code></td>
<td>
<p>integer, default=0, direction for counting. see details </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some seismic data formats store the station in the file name
rather than the seismic header.
The default (dir=0) assumes that the station name and the component name
are the last items on the file name seperated by a period.
So ista and icomp are computed from the end of the file name,
i.e. ista=1 and icomp=0.
If (dir=1) the counting is from the beginning
of the string and the count starts at 1.
Remember to count double tokens, they return a blank.
</p>


<h3>Value</h3>

<p>list(sta='text station name', comp='compname')
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
parseFN2STA('/data/wadati/bourbon/GUATEMALA/SEGY/R009.01/07.009.22.25.34.CAS.E')

fn  &lt;- "2011-11-06-0637-21S.SI01__003_SI01__SH_N_SAC"

parseFN2STA(fn, 4, 1, sep="_"  )
### or:
parseFN2STA(fn, 4, 7, sep="_", dir=1  )


</code></pre>

<hr>
<h2 id='partmotnet'>Particle Motion on Stereonet</h2><span id='topic+partmotnet'></span>

<h3>Description</h3>

<p>Show Particle Motion on Stereonet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partmotnet(temp, LINES = FALSE, STAMP = STAMP, COL = rainbow(100))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partmotnet_+3A_temp">temp</code></td>
<td>
<p>matrix of 3-component seismic data</p>
</td></tr>
<tr><td><code id="partmotnet_+3A_lines">LINES</code></td>
<td>
<p>logical, TRUE=draw lines</p>
</td></tr>
<tr><td><code id="partmotnet_+3A_stamp">STAMP</code></td>
<td>
<p>identification stamp</p>
</td></tr>
<tr><td><code id="partmotnet_+3A_col">COL</code></td>
<td>
<p>color palette</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Show seismic particle motion on a sphere color coded by time.
</p>


<h3>Value</h3>

<p>graphical side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data("GH")

temp = list(x=GH$JSTR[[1]][1168:1500],
y=GH$JSTR[[2]][1168:1500], z=GH$JSTR[[3]][1168:1500])

sx = partmotnet(temp, STAMP="Example",
LINES=TRUE, COL=rainbow(100) )



</code></pre>

<hr>
<h2 id='PDE2list'>Convert PDEs to List
</h2><span id='topic+PDE2list'></span>

<h3>Description</h3>

<p>Converta list of individual PDE events
to a list of lat, lon, z...etc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PDE2list(PDF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PDE2list_+3A_pdf">PDF</code></td>
<td>
<p>list of individual events
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>uses getmem
</p>


<h3>Value</h3>

<p>list
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>getmem, getPDEcsv, parse.pde,getPDEscreen
</p>

<hr>
<h2 id='peaks'>Peaks</h2><span id='topic+peaks'></span>

<h3>Description</h3>

<p>Find peak amplitudes in a time series signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peaks(series, span = 3, do.pad = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peaks_+3A_series">series</code></td>
<td>
<p>signal</p>
</td></tr>
<tr><td><code id="peaks_+3A_span">span</code></td>
<td>
<p>span for window</p>
</td></tr>
<tr><td><code id="peaks_+3A_do.pad">do.pad</code></td>
<td>
<p>padding</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function originated in a note from Brian Ripley.
</p>


<h3>Value</h3>

<p>vector of peak indexes
</p>


<h3>Author(s)</h3>

<p>Brian Ripley</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CE1)
plot(CE1$x, CE1$y, type='l')


pp &lt;- seq(from=53, to=80, by=1)

plot(CE1$x[pp], CE1$y[pp], type='l')


aa &lt;- peaks(CE1$y[pp], span=3)


abline(v=CE1$x[pp[aa]], col='red')



</code></pre>

<hr>
<h2 id='PICK.DOC'>Documentation for swig</h2><span id='topic+PICK.DOC'></span>

<h3>Description</h3>

<p>Prints brief documentation for buttons in swig
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PICK.DOC(w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PICK.DOC_+3A_w">w</code></td>
<td>
<p>vector of buttons needed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Buttons are defined in advance
</p>


<h3>Value</h3>

<p>printed side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>swig</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive() ) PICK.DOC(6:23)
</code></pre>

<hr>
<h2 id='pickgeninfo'>print swig information</h2><span id='topic+pickgeninfo'></span>

<h3>Description</h3>

<p>print swig information to screen
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pickgeninfo()
</code></pre>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>swig</p>


<h3>Examples</h3>

<pre><code class='language-R'>pickgeninfo()
</code></pre>

<hr>
<h2 id='pickhandler'>Handle Pick in RSEIS</h2><span id='topic+pickhandler'></span>

<h3>Description</h3>

<p>Update the WPX (pick data frame) list with a new pick.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pickhandler(i1 = 1, ppick = 0, kzap = "Y", err = NA, res=0, ycol =
rgb(0, 0, 1), pol=0, flg=0, onoff=1, NPX = 1, WPX = WPX, NH)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pickhandler_+3A_i1">i1</code></td>
<td>
<p>Index of trace</p>
</td></tr>
<tr><td><code id="pickhandler_+3A_ppick">ppick</code></td>
<td>
<p>time for pick in seconds</p>
</td></tr>
<tr><td><code id="pickhandler_+3A_kzap">kzap</code></td>
<td>
<p>character label of pick</p>
</td></tr>
<tr><td><code id="pickhandler_+3A_err">err</code></td>
<td>
<p>error for pick</p>
</td></tr>
<tr><td><code id="pickhandler_+3A_res">res</code></td>
<td>
<p>residual(or duration)</p>
</td></tr>
<tr><td><code id="pickhandler_+3A_ycol">ycol</code></td>
<td>
<p>color for pick</p>
</td></tr>
<tr><td><code id="pickhandler_+3A_pol">pol</code></td>
<td>
<p>polarity of pick</p>
</td></tr>
<tr><td><code id="pickhandler_+3A_flg">flg</code></td>
<td>
<p>flag for pick</p>
</td></tr>
<tr><td><code id="pickhandler_+3A_onoff">onoff</code></td>
<td>
<p>turn or off for pick</p>
</td></tr>
<tr><td><code id="pickhandler_+3A_npx">NPX</code></td>
<td>
<p>index of pick in WPX</p>
</td></tr>
<tr><td><code id="pickhandler_+3A_wpx">WPX</code></td>
<td>
<p>Pick data frame</p>
</td></tr>
<tr><td><code id="pickhandler_+3A_nh">NH</code></td>
<td>
<p>List of traces</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns WPX data frame with new pick added (or replaced).
</p>


<h3>Note</h3>

<p>If WPX is missing, it is created.
If NH is missing (no seismic traces) program returns NULL.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>swig, YPIX, WPIX, NOPIX, REPIX, PickWin, pADDPIX, Ppic,
POLSWITCH, Pup</p>

<hr>
<h2 id='pickit'> Automatic Picking Algorithm</h2><span id='topic+pickit'></span>

<h3>Description</h3>

<p>Automatic Picking Algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pickit(ay, deltat = 0.008, MED = 225, FRWD = 8, BKWD = 8,
 sbef = 1, saft = 6, thresh = 2, Tthresh2 = 7,
stretch = 1000, flo = 0.1, fhi = 5, Kmin = 7,
dthresh = 0.01, threshbot = 1.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pickit_+3A_ay">ay</code></td>
<td>
<p>signal</p>
</td></tr>
<tr><td><code id="pickit_+3A_deltat">deltat</code></td>
<td>
<p> sample rate </p>
</td></tr>
<tr><td><code id="pickit_+3A_med">MED</code></td>
<td>
<p>use median smoothing? </p>
</td></tr>
<tr><td><code id="pickit_+3A_frwd">FRWD</code></td>
<td>
<p>forward window, s</p>
</td></tr>
<tr><td><code id="pickit_+3A_bkwd">BKWD</code></td>
<td>
<p>backward window </p>
</td></tr>
<tr><td><code id="pickit_+3A_sbef">sbef</code></td>
<td>
<p>seconds before</p>
</td></tr>
<tr><td><code id="pickit_+3A_saft">saft</code></td>
<td>
<p>seconds after</p>
</td></tr>
<tr><td><code id="pickit_+3A_thresh">thresh</code></td>
<td>
<p>threshold 1</p>
</td></tr>
<tr><td><code id="pickit_+3A_tthresh2">Tthresh2</code></td>
<td>
<p>threshold 2</p>
</td></tr>
<tr><td><code id="pickit_+3A_stretch">stretch</code></td>
<td>
<p>stretch factor</p>
</td></tr>
<tr><td><code id="pickit_+3A_flo">flo</code></td>
<td>
<p>low frequency for BP filter</p>
</td></tr>
<tr><td><code id="pickit_+3A_fhi">fhi</code></td>
<td>
<p>low frequency for BP  filter</p>
</td></tr>
<tr><td><code id="pickit_+3A_kmin">Kmin</code></td>
<td>
<p>min number of picks per window</p>
</td></tr>
<tr><td><code id="pickit_+3A_dthresh">dthresh</code></td>
<td>
<p>delta threshold </p>
</td></tr>
<tr><td><code id="pickit_+3A_threshbot">threshbot</code></td>
<td>
<p>threshold bottom limit </p>
</td></tr>
</table>


<h3>Details</h3>

<p>used internally.
This code uses several methods for getting best pick.
</p>


<h3>Value</h3>

<p>list(RAT=A$rat, x=x, ay=ay, fy=fy, deltat=deltat, J=J$J ,
Z=Z, a1=a1, a2=a2, thresh=thresh, Tthresh2=Tthresh2, Kmin=Kmin)
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>ETECTG</p>

<hr>
<h2 id='pickseis24'>Pick zooms on 24 hour display
</h2><span id='topic+pickseis24'></span>

<h3>Description</h3>

<p>Pick zooms on 24 hour display.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pickseis24(pjj, DB, usta, ucomp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pickseis24_+3A_pjj">pjj</code></td>
<td>
<p>output of plotseis24</p>
</td></tr>
<tr><td><code id="pickseis24_+3A_db">DB</code></td>
<td>
<p>Database of seismic trace meta data</p>
</td></tr>
<tr><td><code id="pickseis24_+3A_usta">usta</code></td>
<td>
<p>stations to extract</p>
</td></tr>
<tr><td><code id="pickseis24_+3A_ucomp">ucomp</code></td>
<td>
<p>components to extract</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use only 2 clicks on the plotseis24 display.
</p>


<h3>Value</h3>

<p>Graphical Side effects.  Program starts swig
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>swig, winseis24 , plotseis24 , getseis24
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

dev.new(width=8, height=12)
dev.new(width=12, height=8)

dev.set(2)
usta &lt;- "CAL"
acomp &lt;- "V"
JJ &lt;- getseis24(DB, 2009, 2, usta, acomp, kind = 1)
pjj &lt;- plotseis24(JJ, dy=1/18, FIX=24, SCALE=1, FILT=list(ON=FALSE,
fl=0.05 , fh=20.0, type="BP", proto="BU"), RCOLS=c(rgb(0.2, .2, 1),
rgb(.2, .2, .2))  )

ucomp &lt;- c("V", "N", "E", "I")

pickseis24(pjj, DB, usta, ucomp )



## End(Not run)


</code></pre>

<hr>
<h2 id='plocator'>Specialized Locator function</h2><span id='topic+plocator'></span>

<h3>Description</h3>

<p>Locator function with set parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plocator(COL = 1, NUM = FALSE, YN = NULL, style = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plocator_+3A_col">COL</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code id="plocator_+3A_num">NUM</code></td>
<td>
<p>number of points </p>
</td></tr>
<tr><td><code id="plocator_+3A_yn">YN</code></td>
<td>
<p>number of windows to span for lines</p>
</td></tr>
<tr><td><code id="plocator_+3A_style">style</code></td>
<td>
<p>0,1,2 for differnt style of plotting vertical lines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if the window is divided into YN horizontal regions,
style =2 will plot segments only within regions
based on y-value of locator().
</p>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>x-locations</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y-locations</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>locator </p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(c(0,1), c(0,1), type='n')
for(i in 1:5) { abline(h=i/6) }

if(interactive()) plocator(COL = 1, NUM = 4, YN = 6, style = 2)

</code></pre>

<hr>
<h2 id='PLOT.ALLPX'>plot all phase arrival picks</h2><span id='topic+PLOT.ALLPX'></span>

<h3>Description</h3>

<p>plot all phase arrival picks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLOT.ALLPX(t0, STNS, COMPS, YPX, PHASE = NULL, POLS = TRUE,
 FILL = FALSE, FORCE = TRUE, cex = cex, srt = srt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLOT.ALLPX_+3A_t0">t0</code></td>
<td>
<p>time for start of window, s</p>
</td></tr>
<tr><td><code id="PLOT.ALLPX_+3A_stns">STNS</code></td>
<td>
<p>station names to plot</p>
</td></tr>
<tr><td><code id="PLOT.ALLPX_+3A_comps">COMPS</code></td>
<td>
<p>components to plot </p>
</td></tr>
<tr><td><code id="PLOT.ALLPX_+3A_ypx">YPX</code></td>
<td>
<p>y-picks (times) </p>
</td></tr>
<tr><td><code id="PLOT.ALLPX_+3A_phase">PHASE</code></td>
<td>
<p>Phases to plot</p>
</td></tr>
<tr><td><code id="PLOT.ALLPX_+3A_pols">POLS</code></td>
<td>
<p>polaritiy information (up, down) </p>
</td></tr>
<tr><td><code id="PLOT.ALLPX_+3A_fill">FILL</code></td>
<td>
<p>fill color</p>
</td></tr>
<tr><td><code id="PLOT.ALLPX_+3A_force">FORCE</code></td>
<td>
<p>logical, force all phases plotted on all traces </p>
</td></tr>
<tr><td><code id="PLOT.ALLPX_+3A_cex">cex</code></td>
<td>
<p>character expansion</p>
</td></tr>
<tr><td><code id="PLOT.ALLPX_+3A_srt">srt</code></td>
<td>
<p>string rotation angle, degrees</p>
</td></tr>
</table>


<h3>Details</h3>

<p>for use in conjunction with PLOT.SEISN program
</p>


<h3>Value</h3>

<p>Graphical Side Effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>PLOT.SEISN, swig</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 
PLOT.ALLPX(Torigin, STNS, COMPS, WPX, PHASE=PHASE,
FORCE=forcepix) 
## End(Not run)

</code></pre>

<hr>
<h2 id='PLOT.MATN'>plot a matrix of several seismograms</h2><span id='topic+PLOT.MATN'></span>

<h3>Description</h3>

<p>Matrix of several seismograms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLOT.MATN(ascd, tim=1, dt=1, T1=0,  WIN=c(0,1), labs="",
notes=notes, sfact=1,ampboost=0,  shift=NULL, LOG="",
COL='red', add=1, AXES=1, units=NULL, VS=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLOT.MATN_+3A_ascd">ascd</code></td>
<td>
<p>N by K matrix of seismograms where </p>
</td></tr>
<tr><td><code id="PLOT.MATN_+3A_tim">tim</code></td>
<td>
<p>time values fo x-axis</p>
</td></tr>
<tr><td><code id="PLOT.MATN_+3A_dt">dt</code></td>
<td>
<p>sample interval, seconds</p>
</td></tr>
<tr><td><code id="PLOT.MATN_+3A_t1">T1</code></td>
<td>
<p>Time for starting sample (default=0)</p>
</td></tr>
<tr><td><code id="PLOT.MATN_+3A_win">WIN</code></td>
<td>
<p>vector, time window for zoom</p>
</td></tr>
<tr><td><code id="PLOT.MATN_+3A_labs">labs</code></td>
<td>
<p>vector of labels for each panel</p>
</td></tr>
<tr><td><code id="PLOT.MATN_+3A_notes">notes</code></td>
<td>
<p>vector of notes for each panel</p>
</td></tr>
<tr><td><code id="PLOT.MATN_+3A_sfact">sfact</code></td>
<td>
<p>scaling factor, 1=window, 2=trace</p>
</td></tr>
<tr><td><code id="PLOT.MATN_+3A_ampboost">ampboost</code></td>
<td>
<p>increase each amplitude by this multiplier</p>
</td></tr>
<tr><td><code id="PLOT.MATN_+3A_shift">shift</code></td>
<td>
<p>vector, shift each trace by these time</p>
</td></tr>
<tr><td><code id="PLOT.MATN_+3A_log">LOG</code></td>
<td>
<p>log x-axis</p>
</td></tr>
<tr><td><code id="PLOT.MATN_+3A_col">COL</code></td>
<td>
<p>vector of colors or indexes to colors</p>
</td></tr>
<tr><td><code id="PLOT.MATN_+3A_add">add</code></td>
<td>
<p>numeric, to existing plot.
add = 1,2,3  if add=1 plot and add traces,
add =2 plot, but no traces,
add = 3 no plot, but add traces.  DEFAULT=1
</p>
</td></tr>
<tr><td><code id="PLOT.MATN_+3A_axes">AXES</code></td>
<td>
<p>numeric, 0,1,2,3,4; default=1</p>
</td></tr>
<tr><td><code id="PLOT.MATN_+3A_units">units</code></td>
<td>
<p>label for units of Y-axis</p>
</td></tr>
<tr><td><code id="PLOT.MATN_+3A_vs">VS</code></td>
<td>
<p> var-squiggle display</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots a matrix of seismograms that each have the same starting time.
For the AXES argument, 0 = no axes,    AXES=1  plot scale for largest
amplitude band and a multiplier for all others,
AXES=2 left side, AXES=3 right side, AXES=4 alternate sides
</p>


<h3>Value</h3>

<p>Graphical side effects and,
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>n</p>
</td></tr>
<tr><td><code>windiv</code></td>
<td>
<p>matrix of n rows, with columns=(window Y min, window Y
max, user Y min, user Y max) </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>swig, matsquiggle, dowiggles, varsquiggle</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dt  &lt;-  0.001

 t  &lt;-  seq(0, 6, by=0.001)

thefreqs  &lt;-  seq(from=10, to=100, by=10)
theamps  &lt;-   runif(length(thefreqs))

#   sample rate is 1000 Hz, 0.001 seconds 601 samples
 x  &lt;-  NULL

for(i in 1:length(thefreqs))
{
x  &lt;-  cbind(x, theamps[i]*sin(2*pi*thefreqs[i]*t))


}

PLOT.MATN(x,  dt = dt)


</code></pre>

<hr>
<h2 id='PLOT.SEISN'>Plot Seismic Section</h2><span id='topic+PLOT.SEISN'></span>

<h3>Description</h3>

<p>Seismic traces are plotted on a panel horizontally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLOT.SEISN(GH, tim = 1, dt = 1, sel =c(1:4) , WIN =c(1,0) ,
labs=c("CE1") ,
notes = "CE1.V", subnotes=NA, tags ="CE1.V" ,
sfact = 1, LOG = "", COL = 'red', add = 1, pts = FALSE,
YAX = 1, TIT = NULL, SHIFT = NULL,COLLAPSE=FALSE,   rm.mean = TRUE, UNITS = "volts",
MARK = TRUE, xtickfactor = 1, vertline=NA )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLOT.SEISN_+3A_gh">GH</code></td>
<td>
<p>RSEIS  data structure</p>
</td></tr>
<tr><td><code id="PLOT.SEISN_+3A_tim">tim</code></td>
<td>
<p>tim axis vector, seconds</p>
</td></tr>
<tr><td><code id="PLOT.SEISN_+3A_dt">dt</code></td>
<td>
<p> deltaT, sample rate </p>
</td></tr>
<tr><td><code id="PLOT.SEISN_+3A_sel">sel</code></td>
<td>
<p>select which traces from GH</p>
</td></tr>
<tr><td><code id="PLOT.SEISN_+3A_win">WIN</code></td>
<td>
<p>initial time window for plot</p>
</td></tr>
<tr><td><code id="PLOT.SEISN_+3A_labs">labs</code></td>
<td>
<p>character string vector, labels for units on y-axes,
depends on YAX</p>
</td></tr>
<tr><td><code id="PLOT.SEISN_+3A_notes">notes</code></td>
<td>
<p>character string vector, labels on upper right of each
panel</p>
</td></tr>
<tr><td><code id="PLOT.SEISN_+3A_subnotes">subnotes</code></td>
<td>
<p>character string vector, labels on lower-right of each
panel</p>
</td></tr>
<tr><td><code id="PLOT.SEISN_+3A_tags">tags</code></td>
<td>
<p>character string vector, labels next to right end of trace
(usually numbers) </p>
</td></tr>
<tr><td><code id="PLOT.SEISN_+3A_sfact">sfact</code></td>
<td>
<p>scaling flag, 1=scale individually(DEFAULT),  2 = scale by window</p>
</td></tr>
<tr><td><code id="PLOT.SEISN_+3A_log">LOG</code></td>
<td>
<p>log for x-axis</p>
</td></tr>
<tr><td><code id="PLOT.SEISN_+3A_col">COL</code></td>
<td>
<p>color vector for plotting traces</p>
</td></tr>
<tr><td><code id="PLOT.SEISN_+3A_add">add</code></td>
<td>
<p>integer: add to plot=1,2,3, add=1 plot and add traces, add
=2 plot, but no traces, add = 3 no plot, but add traces</p>
</td></tr>
<tr><td><code id="PLOT.SEISN_+3A_pts">pts</code></td>
<td>
<p>add points</p>
</td></tr>
<tr><td><code id="PLOT.SEISN_+3A_yax">YAX</code></td>
<td>
<p> type of Yaxis label, 1,2,3 DEFAULT=1 only one y-axis
others scaled; 2=all y-axes are plotted on left; 3=all y-axes plotted,
alternating left and right</p>
</td></tr>
<tr><td><code id="PLOT.SEISN_+3A_tit">TIT</code></td>
<td>
<p>title</p>
</td></tr>
<tr><td><code id="PLOT.SEISN_+3A_shift">SHIFT</code></td>
<td>
<p>vector, shift each trace along x-axis by associated moveout time</p>
</td></tr>
<tr><td><code id="PLOT.SEISN_+3A_collapse">COLLAPSE</code></td>
<td>
<p>logical, Collapse all traces onto one panel, default=FALSE</p>
</td></tr></table>
<p>, 
</p>
<table>
<tr><td><code id="PLOT.SEISN_+3A_rm.mean">rm.mean</code></td>
<td>
<p>remove mean from traces</p>
</td></tr>
<tr><td><code id="PLOT.SEISN_+3A_units">UNITS</code></td>
<td>
<p>character, units of traces (see labs) </p>
</td></tr>
<tr><td><code id="PLOT.SEISN_+3A_mark">MARK</code></td>
<td>
<p>character marking for earthquake</p>
</td></tr>
<tr><td><code id="PLOT.SEISN_+3A_xtickfactor">xtickfactor</code></td>
<td>
<p>Factor for multiplying the x-axis tick markers  (default=1; for minutes=60, hrs=3600, days=24*3600) </p>
</td></tr>
<tr><td><code id="PLOT.SEISN_+3A_vertline">vertline</code></td>
<td>
<p>time list (yr, jd, hr, mi sec) for plotting vertical lines on window.
Default=NA </p>
</td></tr>
</table>


<h3>Details</h3>

<p>panel of N traces are plotted.  For YAX, default is YAX=1, plot an axis
with no units label and scale all the traces to 
</p>


<h3>Value</h3>

<p>Graphical Side effect.
list(n=nn, dy=dy,  minS=minS, maxS=maxS, meanS=meanS, DX=range(tim[tflag]) )
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>swig </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("GH")
m  &lt;-  match( GH$STNS,    GH$stafile$name)
LATS  &lt;-  GH$stafile$lat[m]
LONS  &lt;-  GH$stafile$lon[m]
dees  &lt;-  rdistaz( GH$pickfile$LOC$lat, GH$pickfile$LOC$lon, LATS, LONS)

sel  &lt;-  which(GH$COMPS=="V")
sel  &lt;-  sel[order(dees$dist[sel])]


###   set up good colors
pcols  &lt;-  seiscols(GH)

### select only vertical components

PLOT.SEISN(GH, sel=sel)

GH$units  &lt;-  rep("m/s", times=length(GH$KNOTES))
GH$pcols  &lt;-  pcols


######  simple plot of GH structure
YN  &lt;-  PLOT.SEISN(GH, WIN=c(5,12))

######  a color must be provided for all traces.
######  simple plot of GH structure, with selection and colors

YN  &lt;-  PLOT.SEISN(GH, WIN=c(5,12), sel=sel, COL=rainbow(length(sel)) )


####   alternating Y axes
 YN  &lt;-  PLOT.SEISN(GH, WIN=c(5,12) ,  dt=GH$dt[sel], sel=sel, sfact=1 ,
notes=GH$KNOTES[sel], YAX =3, UNITS = TRUE ,labs = GH$units[sel],
COL=pcols    , TIT="test")


#### Y  axes on same side
 YN  &lt;-  PLOT.SEISN(GH, WIN=c(5,12) ,  dt=GH$dt[sel], sel=sel, sfact=1 ,
notes=GH$KNOTES[sel], YAX =2, UNITS = TRUE ,labs = GH$units[sel],
COL=pcols    , TIT="test")








</code></pre>

<hr>
<h2 id='PLOT.TTCURVE'>Plot Seismic Section, travel time curve </h2><span id='topic+PLOT.TTCURVE'></span>

<h3>Description</h3>

<p>Seismic traces are plotted on a panel horizontally, with spacing
according to distance from source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLOT.TTCURVE(GH, STAXY = NULL, DIST = c(0, 10), DY = 0.1,
tim = 1, dt = 1, sel = c(1:4), WIN = c(1, 0), labs = c("CE1"),
 notes = "CE1.V", tags = "CE1.V", sfact = 1, COL = "red",
add = 1, pts = FALSE, YAX = FALSE, TIT = NULL, SHIFT = NULL,
 rm.mean = TRUE, UNITS = "volts", MARK = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLOT.TTCURVE_+3A_gh">GH</code></td>
<td>
<p>Seismic data Structure</p>
</td></tr>
<tr><td><code id="PLOT.TTCURVE_+3A_staxy">STAXY</code></td>
<td>
<p>Station Locations and distances in KM </p>
</td></tr>
<tr><td><code id="PLOT.TTCURVE_+3A_dist">DIST</code></td>
<td>
<p>Distance range, km</p>
</td></tr>
<tr><td><code id="PLOT.TTCURVE_+3A_dy">DY</code></td>
<td>
<p>height of each wiggle</p>
</td></tr>
<tr><td><code id="PLOT.TTCURVE_+3A_tim">tim</code></td>
<td>
<p>time span for plotting</p>
</td></tr>
<tr><td><code id="PLOT.TTCURVE_+3A_dt">dt</code></td>
<td>
<p>sample interval, seconds </p>
</td></tr>
<tr><td><code id="PLOT.TTCURVE_+3A_sel">sel</code></td>
<td>
<p>select which traces to plot</p>
</td></tr>
<tr><td><code id="PLOT.TTCURVE_+3A_win">WIN</code></td>
<td>
<p>vector, time window for zoom </p>
</td></tr>
<tr><td><code id="PLOT.TTCURVE_+3A_labs">labs</code></td>
<td>
<p>vector of labels for each panel </p>
</td></tr>
<tr><td><code id="PLOT.TTCURVE_+3A_notes">notes</code></td>
<td>
<p>vector of notes for each panel </p>
</td></tr>
<tr><td><code id="PLOT.TTCURVE_+3A_tags">tags</code></td>
<td>
<p>character string vector, labels </p>
</td></tr>
<tr><td><code id="PLOT.TTCURVE_+3A_sfact">sfact</code></td>
<td>
<p>scaling flag </p>
</td></tr>
<tr><td><code id="PLOT.TTCURVE_+3A_col">COL</code></td>
<td>
<p>col vector </p>
</td></tr>
<tr><td><code id="PLOT.TTCURVE_+3A_add">add</code></td>
<td>
<p>add to plot</p>
</td></tr>
<tr><td><code id="PLOT.TTCURVE_+3A_pts">pts</code></td>
<td>
<p>add points</p>
</td></tr>
<tr><td><code id="PLOT.TTCURVE_+3A_yax">YAX</code></td>
<td>
<p>Yaxis label </p>
</td></tr>
<tr><td><code id="PLOT.TTCURVE_+3A_tit">TIT</code></td>
<td>
<p>title </p>
</td></tr>
<tr><td><code id="PLOT.TTCURVE_+3A_shift">SHIFT</code></td>
<td>
<p>shift traces </p>
</td></tr>
<tr><td><code id="PLOT.TTCURVE_+3A_rm.mean">rm.mean</code></td>
<td>
<p>remove mean from traces </p>
</td></tr>
<tr><td><code id="PLOT.TTCURVE_+3A_units">UNITS</code></td>
<td>
<p>character, units of traces </p>
</td></tr>
<tr><td><code id="PLOT.TTCURVE_+3A_mark">MARK</code></td>
<td>
<p>character marking for earthquake </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side effect.
</p>
<p>list(n=nn, dy=dy,  minS=minS, maxS=maxS, meanS=meanS,
DX=range(tim[tflag]), DY=DY, DIST=DIST )
</p>


<h3>Note</h3>

<p>This program is similar to PLOT.SEISN
but traces are plotting with increasing distance from a set point.
The distances are calculated prior to execution and passed as a vector
or structure.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>PLOT.SEISN</p>

<hr>
<h2 id='Plot1Dvel'>Plot 1D Velocity Model
</h2><span id='topic+Plot1Dvel'></span>

<h3>Description</h3>

<p>Plot 1D velocity model
showing P-wave and S-wave layered models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot1Dvel(v, tit = NULL, col=c('blue', 'brown'), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plot1Dvel_+3A_v">v</code></td>
<td>
<p>Velocity models 
</p>
</td></tr>
<tr><td><code id="Plot1Dvel_+3A_tit">tit</code></td>
<td>
<p>Title for plot (character)
</p>
</td></tr>
<tr><td><code id="Plot1Dvel_+3A_col">col</code></td>
<td>
<p>2-colors for P and swave
</p>
</td></tr>
<tr><td><code id="Plot1Dvel_+3A_...">...</code></td>
<td>
<p>other graphical parameters (e.g. lty, lwd) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Velocity model consists of a list
of P and S depths and layer velocity values.
See example below.
</p>


<h3>Value</h3>

<p>Graphical Side effect
</p>


<h3>Note</h3>

<p> Errors are not required, although future
versions may include the plotting of error bars.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>Get1Dvel, Comp1Dvel, Comp1Dvels, travel.time1D</p>


<h3>Examples</h3>

<pre><code class='language-R'>

VEL &lt;- list()
VEL$'zp' &lt;- c(0,0.25,0.5,0.75,1,2,4,5,10,12)
VEL$'vp' &lt;- c(1.1,2.15,3.2,4.25,5.3,6.25,6.7,6.9,7,7.2)
VEL$'ep' &lt;- c(0,0,0,0,0,0,0,0,0,0)
VEL$'zs' &lt;- c(0,0.25,0.5,0.75,1,2,4,5,10,12)
VEL$'vs' &lt;- c(0.62,1.21,1.8,2.39,2.98,3.51,3.76,3.88,3.93,4.04)
VEL$'es' &lt;- c(0,0,0,0,0,0,0,0,0,0)
VEL$'name' &lt;- '/data/wadati/lees/Site/Hengil/krafla.vel'

Plot1Dvel(VEL, tit = 'This is an Example' )

</code></pre>

<hr>
<h2 id='plotarrivals'>plot theoretical arrival times for a seismic section
</h2><span id='topic+plotarrivals'></span>

<h3>Description</h3>

<p>plot theoretical arrival times for a seismic section
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotarrivals(x, THEORY, add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotarrivals_+3A_x">x</code></td>
<td>
<p>matrix of wiggles
</p>
</td></tr>
<tr><td><code id="plotarrivals_+3A_theory">THEORY</code></td>
<td>
<p>theoretical arrivals
</p>
</td></tr>
<tr><td><code id="plotarrivals_+3A_add">add</code></td>
<td>
<p>logical, if TRUE=Add to existing plot
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plots go from top of page down
</p>


<h3>Value</h3>

<p>graphical side effect
</p>


<h3>Note</h3>

<p>Used for adding information to wiggle plots.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>symshot1, wiggleimage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
S1 &lt;- symshot1()

wiggleimage(S1$smograms  , dt=(-S1$dt), dx=S1$dx)

plotarrivals(S1$x, S1$THEORY, add = TRUE)



</code></pre>

<hr>
<h2 id='plotDB'>Plot a time line of a DB set in RSEIS</h2><span id='topic+plotDB'></span>

<h3>Description</h3>

<p>makes a plot of the data base files stored on disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDB(DB)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDB_+3A_db">DB</code></td>
<td>
<p>List, Data Base created by makeDB or setupDB</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>makeDB, setupDB</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

  path &lt;- '/home/lees/Site/Santiaguito/SG09'
     pattern &lt;- "R0*"

     ###   get DB information
     XDB  &lt;-  makeDB(path, pattern, kind =1)

plotDB(DB)


## End(Not run)

</code></pre>

<hr>
<h2 id='plotevol'>Plot Spectrogram</h2><span id='topic+plotevol'></span><span id='topic+blankevol'></span><span id='topic+plotevol2'></span>

<h3>Description</h3>

<p>Plot Spectrogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotevol(DEVOL, log = 0, fl = 0, fh = 10, col = col, ylog = FALSE, ygrid
= FALSE, AXE = c(1, 2, 3, 4), CSCALE = FALSE, WUNITS = "Volts", STAMP =
NULL, STYLE = "fft")

plotevol2(DEVOL, log = 0, fl = 0, fh = 10, col = col, ylog = FALSE, ygrid
= FALSE, AXE = c(1, 2, 3, 4), CSCALE = FALSE, WUNITS = "Volts", STAMP =
NULL, STYLE = "fft", add=FALSE, IMAGE=TRUE, WIG=TRUE )

blankevol(DEVOL, log=0,  fl=0, fh=10 , col=col, ylog=FALSE, ygrid=FALSE,
AXE=c(1,2,3,4),
CSCALE=FALSE, WUNITS="Volts", STAMP=NULL, STYLE="fft", WIG=TRUE  )


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotevol_+3A_devol">DEVOL</code></td>
<td>
<p>spectrogram structure </p>
</td></tr>
<tr><td><code id="plotevol_+3A_log">log</code></td>
<td>
<p>scale by logarithm</p>
</td></tr>
<tr><td><code id="plotevol_+3A_fl">fl</code></td>
<td>
<p>low frequency </p>
</td></tr>
<tr><td><code id="plotevol_+3A_fh">fh</code></td>
<td>
<p>high frequency </p>
</td></tr>
<tr><td><code id="plotevol_+3A_col">col</code></td>
<td>
<p>color palette </p>
</td></tr>
<tr><td><code id="plotevol_+3A_ylog">ylog</code></td>
<td>
<p>scale Y-axis by log</p>
</td></tr>
<tr><td><code id="plotevol_+3A_ygrid">ygrid</code></td>
<td>
<p>logical, TRUE=add grid</p>
</td></tr>
<tr><td><code id="plotevol_+3A_axe">AXE</code></td>
<td>
<p>sides to add axis</p>
</td></tr>
<tr><td><code id="plotevol_+3A_cscale">CSCALE</code></td>
<td>
<p>logical, TRUE=add color scale</p>
</td></tr>
<tr><td><code id="plotevol_+3A_wunits">WUNITS</code></td>
<td>
<p>character string for units</p>
</td></tr>
<tr><td><code id="plotevol_+3A_stamp">STAMP</code></td>
<td>
<p>character string for identification </p>
</td></tr>
<tr><td><code id="plotevol_+3A_style">STYLE</code></td>
<td>
<p>Plotting style.  Default, &quot;fft&quot;=plot half the spectrum
image , else plot whole spectrum</p>
</td></tr>
<tr><td><code id="plotevol_+3A_add">add</code></td>
<td>
<p>logical, add to existing plot, default=FALSE</p>
</td></tr>
<tr><td><code id="plotevol_+3A_image">IMAGE</code></td>
<td>
<p>logical, whether to plot the image or not</p>
</td></tr>
<tr><td><code id="plotevol_+3A_wig">WIG</code></td>
<td>
<p>logical, whether to plot the wiggle or not</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot Spectrogram.
Because the fft function returns positive and negative frequencies,
ff STYLE=&quot;fft&quot; then
the image matrix is reduced IMAT = t(DSPEC[1:(numfreqs/2),])  otherwise
IMAT = t(DSPEC).
</p>
<p>plotevol2  is used to add secondary spectra to ones already plotted,
or to manage graphical paramters, or create other plots that match
the graphical presentation of the spectrogram (plots of frequency
versus time, but not images)
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>evolfft</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(CE1)

Xamp &lt;- CE1$y

DT &lt;- CE1$dt

 tsecs &lt;- DT*(length(Xamp)*.02)
    multi &lt;- 2
scale.def &lt;- 1
  TWOSEC &lt;- tsecs*(1/DT)
    
  NS &lt;- floor(multi*TWOSEC)
  NOV &lt;- floor(multi*(TWOSEC-.2*TWOSEC))

    
    Nfft&lt;-4096

    pal &lt;- rainbow(100)

    fl  &lt;- 0
   fh &lt;- 1/(2*DT)

   flshow &lt;-  .5
   fhshow &lt;- 120

   DEV &lt;- evolfft(Xamp,DT , Nfft=Nfft, Ns=NS , Nov=NOV,  fl=fl, fh=fh  )

  PE &lt;-  plotevol(DEV, log=scale.def, fl=flshow, fh=fhshow,
                 col=pal, ygrid=FALSE, STAMP="HITHERE", STYLE="fft")




</code></pre>

<hr>
<h2 id='plotGH'>Plot a seismic trace.
</h2><span id='topic+plotGH'></span>

<h3>Description</h3>

<p>Quick and dirty plot of a seismic trace as recorded and
save using stream2GHnosens or other RSEIS savers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGH(h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGH_+3A_h">h</code></td>
<td>

<p>This is a standard GH object as defined in RSEIS
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code converts the amp component to a ts object.
</p>


<h3>Value</h3>

<p>Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>RSEIS::prepSEIS, RSEIS::prep1wig, RSEIS::PLOT.SEISN, RSEIS::swig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
zh = JGET.seis(file='file.RDATA', kind=-1)
plotGH(zh)


## End(Not run)



</code></pre>

<hr>
<h2 id='plotJGET'>Plot JGET output
</h2><span id='topic+plotJGET'></span>

<h3>Description</h3>

<p>Plot JGET output using interactive swig
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotJGET(J, SHOWONLY = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotJGET_+3A_j">J</code></td>
<td>
<p>list, output of JGETseis
</p>
</td></tr>
<tr><td><code id="plotJGET_+3A_showonly">SHOWONLY</code></td>
<td>
<p>logical, if SHOWONLY== TRUE, no interaction
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Program combines prepSEIS  and swig
</p>


<h3>Value</h3>

<p>GH list ready for use in other RSEIS programs.
See prepSEIS for details
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>JGET.seis, prepSEIS, swig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

fn &lt;- '/home/lees/taurus_2050_20100302_100000_BHE.sac'

J  &lt;- JGET.seis(fn,kind=2,BIGLONG=FALSE,HEADONLY=FALSE,Iendian=3,PLOT=0)

plotJGET(J)


## End(Not run)



</code></pre>

<hr>
<h2 id='plotseis24'>Plot 24 hours of seismic data
</h2><span id='topic+plotseis24'></span>

<h3>Description</h3>

<p>Plot 24 hours of seismic data using output
of getseis24.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotseis24(JJ, dy = 1/18, FIX = 24, SCALE = 0, FILT = list(ON = FALSE,
fl = 0.05, fh = 20, type = "BP", proto = "BU"), RCOLS = c(rgb(0.2, 0.2,
1), rgb(0.2, 0.2, 0.2)), add=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotseis24_+3A_jj">JJ</code></td>
<td>
<p>output list of getseis24
</p>
</td></tr>
<tr><td><code id="plotseis24_+3A_dy">dy</code></td>
<td>
<p>Delta-y in percentage of trace
</p>
</td></tr>
<tr><td><code id="plotseis24_+3A_fix">FIX</code></td>
<td>
<p>Fix 24 hour plot.  If FIX is less than 24, the plot will
show only that number of hours.
</p>
</td></tr>
<tr><td><code id="plotseis24_+3A_scale">SCALE</code></td>
<td>
<p>scale, 0=scale each trace, 1=scale window
</p>
</td></tr>
<tr><td><code id="plotseis24_+3A_filt">FILT</code></td>
<td>
<p>filter data
</p>
</td></tr>
<tr><td><code id="plotseis24_+3A_rcols">RCOLS</code></td>
<td>
<p>colors
</p>
</td></tr>
<tr><td><code id="plotseis24_+3A_add">add</code></td>
<td>
<p>logical, if TRUE, add to existing plot (i.e. do not issue a
plot command)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots full 24 hours of data.
The list returned can be used by winseis24
to get picks and windows for zooming.
</p>
<p>The FIX argument is currently not available.
</p>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>x-axis</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y-axis</p>
</td></tr>
<tr><td><code>yr</code></td>
<td>
<p>year</p>
</td></tr>
<tr><td><code>jd</code></td>
<td>
<p>julian day</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>getseis24, winseis24
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
JJ &lt;- getseis24(DB, 2008, 366, usta, acomp, kind = 1)

### show with no scaling
pjj &lt;- plotseis24(JJ, dy=1/18, FIX=24, SCALE=0, FILT=list(ON=FALSE,
fl=0.05 , fh=20.0, type="BP", proto="BU"), RCOLS=c(grey(0.8) , grey(0.8)), add=FALSE  )


pjj &lt;- plotseis24(JJ, dy=1/18, FIX=24, SCALE=1, FILT=list(ON=FALSE,
fl=0.05 , fh=20.0, type="BP", proto="BU"), RCOLS=c(rgb(0.2, .2, 1),
rgb(.2, .2, .2)), add=TRUE  )





## End(Not run)


</code></pre>

<hr>
<h2 id='plotwlet'>Plot Wavelet Transform</h2><span id='topic+plotwlet'></span>

<h3>Description</h3>

<p>Plot Wavelet Transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotwlet(baha, Ysig, dt, zscale = 1, zbound = NULL,
col = rainbow(100), ygrid = FALSE,
STAMP = "", xlab="Time, s" , units="", scaleloc=c(0.4,0.95))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotwlet_+3A_baha">baha</code></td>
<td>
<p>Output of wlet.do</p>
</td></tr>
<tr><td><code id="plotwlet_+3A_ysig">Ysig</code></td>
<td>
<p>signal processed</p>
</td></tr>
<tr><td><code id="plotwlet_+3A_dt">dt</code></td>
<td>
<p>sample rate</p>
</td></tr>
<tr><td><code id="plotwlet_+3A_zscale">zscale</code></td>
<td>
<p>scale of image</p>
</td></tr>
<tr><td><code id="plotwlet_+3A_zbound">zbound</code></td>
<td>
<p>limits on scale</p>
</td></tr>
<tr><td><code id="plotwlet_+3A_col">col</code></td>
<td>
<p>color palette</p>
</td></tr>
<tr><td><code id="plotwlet_+3A_ygrid">ygrid</code></td>
<td>
<p>add grid</p>
</td></tr>
<tr><td><code id="plotwlet_+3A_stamp">STAMP</code></td>
<td>
<p>character string for identification</p>
</td></tr>
<tr><td><code id="plotwlet_+3A_xlab">xlab</code></td>
<td>
<p>character, label for the x-axis</p>
</td></tr>
<tr><td><code id="plotwlet_+3A_units">units</code></td>
<td>
<p>character, units on signal</p>
</td></tr>
<tr><td><code id="plotwlet_+3A_scaleloc">scaleloc</code></td>
<td>
<p>2-vector, percentatge of bottom margin for the color
scale</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function plots the wavelet transform in a way that is similar to
the spectogram plots.
</p>


<h3>Value</h3>

<p>list( y=, why=why, yBounds=c(0,perc), x=x, yat=raxspec)
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>input signal</p>
</td></tr>
<tr><td><code>why</code></td>
<td>
<p>scaled image</p>
</td></tr>
<tr><td><code>yBounds</code></td>
<td>
<p>vector of boundaries</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>x axis</p>
</td></tr>
<tr><td><code>yat</code></td>
<td>
<p>y axis tic marks</p>
</td></tr>
</table>
<p>Graphical side effects.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>cwt, pwlet2freqs, wlet.do, wlet.drive</p>

<hr>
<h2 id='plt.MTM0'>Plot MTM structure</h2><span id='topic+plt.MTM0'></span>

<h3>Description</h3>

<p>Plot MTM structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plt.MTM0(frange, prange, plxy, M, freqs, amp, a, dof = dof, Fv = Fv, COL = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plt.MTM0_+3A_frange">frange</code></td>
<td>
<p>frequency range</p>
</td></tr>
<tr><td><code id="plt.MTM0_+3A_prange">prange</code></td>
<td>
<p>point range </p>
</td></tr>
<tr><td><code id="plt.MTM0_+3A_plxy">plxy</code></td>
<td>
<p>log x,y axes </p>
</td></tr>
<tr><td><code id="plt.MTM0_+3A_m">M</code></td>
<td>
<p>structure from MTM</p>
</td></tr>
<tr><td><code id="plt.MTM0_+3A_freqs">freqs</code></td>
<td>
<p>frequencies </p>
</td></tr>
<tr><td><code id="plt.MTM0_+3A_amp">amp</code></td>
<td>
<p> amplitude </p>
</td></tr>
<tr><td><code id="plt.MTM0_+3A_a">a</code></td>
<td>
<p>list(y=original data, dt=deltat)</p>
</td></tr>
<tr><td><code id="plt.MTM0_+3A_dof">dof</code></td>
<td>
<p>degrees of freedom </p>
</td></tr>
<tr><td><code id="plt.MTM0_+3A_fv">Fv</code></td>
<td>
<p>F-values </p>
</td></tr>
<tr><td><code id="plt.MTM0_+3A_col">COL</code></td>
<td>
<p> color </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side Effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>References</h3>

<p>Lees, J. M. and Park, J., 1995: Multiple-taper spectral analysis: A stand-alone C-subroutine, <em>Computers and Geology</em>, 21(2), 199-236.</p>


<h3>See Also</h3>

<p>MTM.drive</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CE1)
plot(CE1$x, CE1$y, type='l')

len &lt;- length(CE1$y)
 len2 &lt;- 2*next2(len)
 Mspec &lt;- mtapspec(CE1$y,  CE1$dt, klen=len2, MTP=list(kind=1,nwin=5,
               npi=3,inorm=0)  )


f&lt;-Mspec$freq
M &lt;- 1
 f1 &lt;- 0.01
f2 &lt;- 100
 plxy &lt;- ''
 flag &lt;- f&gt;=f1 &amp; f &lt;= f2;
    freqs &lt;- list(f[flag])
 mydof &lt;- NULL
      myFv &lt;- NULL
 amp &lt;- Mspec$spec[1:length(f)]

      amp &lt;- list(amp[flag])


a &lt;- list(y=CE1$y, dt=CE1$dt)
frange &lt;- range(freqs, na.rm = TRUE)
 prange &lt;- range(amp  , na.rm = TRUE)

###  plot(freqs[[1]], amp[[1]])


 plt.MTM0(frange, prange, plxy, M, freqs, amp, a,
        dof=mydof, Fv=myFv, COL=4)



</code></pre>

<hr>
<h2 id='PLTpicks'>Plot picks on seismic record</h2><span id='topic+PLTpicks'></span>

<h3>Description</h3>

<p>Add lines at phase arrival times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLTpicks(picks, labs = NA, cols = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLTpicks_+3A_picks">picks</code></td>
<td>
<p>vector of times relative to the start of the plot</p>
</td></tr>
<tr><td><code id="PLTpicks_+3A_labs">labs</code></td>
<td>
<p>labels for picks </p>
</td></tr>
<tr><td><code id="PLTpicks_+3A_cols">cols</code></td>
<td>
<p>colors for picks </p>
</td></tr>
</table>


<h3>Details</h3>

<p>picks = vector of times relative to the start of the plot (seismogram)
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ex  &lt;-  seq(from=0, to=4*pi, length = 200)

y  &lt;-  sin(ex)
picks = c(0.5*pi, 2.3*pi)
plot(ex, y, type='l')


PLTpicks(picks, labs =c("P","P")  , cols =c('red','green')  )

PLTpicks(picks+2, labs =c("S","PKIKP") , cols ='blue'  )

</code></pre>

<hr>
<h2 id='PMOT.drive'>Interactive Particle Motion Plot</h2><span id='topic+PMOT.drive'></span>

<h3>Description</h3>

<p>Plot Hodogram and show seismic particle motion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PMOT.drive(temp, dt, pmolabs = c("Vertical", "North", "East"), STAMP = "", baz = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PMOT.drive_+3A_temp">temp</code></td>
<td>
<p>matrix of 3-component seismic signal</p>
</td></tr>
<tr><td><code id="PMOT.drive_+3A_dt">dt</code></td>
<td>
<p>sample interval (delta-T, seconds)</p>
</td></tr>
<tr><td><code id="PMOT.drive_+3A_pmolabs">pmolabs</code></td>
<td>
<p>labels for traces</p>
</td></tr>
<tr><td><code id="PMOT.drive_+3A_stamp">STAMP</code></td>
<td>
<p>Character string Identification stamp</p>
</td></tr>
<tr><td><code id="PMOT.drive_+3A_baz">baz</code></td>
<td>
<p>Back Azimuth, degrees</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input matrix should V, N, E.  Baz is not implemented yet.
</p>


<h3>Value</h3>

<p>Graphical Side Effect.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("GH")
sel &lt;-  which(GH$STNS == "CE1")


YMAT  &lt;-  cbind(GH$JSTR[[sel[1]]][1168:1500],
GH$JSTR[[sel[2]]][1168:1500],
GH$JSTR[[sel[3]]][1168:1500])

dt  &lt;-   GH$dt[ sel[1] ]
ftime  &lt;-  Zdate(GH$info, sel[1], 1)

## Not run: 
PMOT.drive(YMAT, dt, pmolabs = c("Vertical", "North", "East"),
STAMP =ftime )


## End(Not run)


</code></pre>

<hr>
<h2 id='posix2RSEIS'>Posix to RSEIS DATE/TIME
</h2><span id='topic+posix2RSEIS'></span>

<h3>Description</h3>

<p>Reformat posix time stamp to RSEIS list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posix2RSEIS(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posix2RSEIS_+3A_p">p</code></td>
<td>
<p>posix time, either lt or ct
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of data/time in format RSEIS understands
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>j2posix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### make up a time:
P1 = as.POSIXct(Sys.time(), "America/New_York")  # in New York
R1 = posix2RSEIS(P1)
## also
unlist( as.POSIXlt(P1))  
</code></pre>

<hr>
<h2 id='PPIX'>P-picking</h2><span id='topic+PPIX'></span>

<h3>Description</h3>

<p>Add Pick Marks and Labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PPIX(zloc, YN = NULL, col = 1, lab = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PPIX_+3A_zloc">zloc</code></td>
<td>
<p>locator output</p>
</td></tr>
<tr><td><code id="PPIX_+3A_yn">YN</code></td>
<td>
<p>number of panels</p>
</td></tr>
<tr><td><code id="PPIX_+3A_col">col</code></td>
<td>
<p>color for picks</p>
</td></tr>
<tr><td><code id="PPIX_+3A_lab">lab</code></td>
<td>
<p>labels for picks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>

<hr>
<h2 id='prep1wig'>Prepare structure for RSEIS</h2><span id='topic+prep1wig'></span>

<h3>Description</h3>

<p>Takes list of traces and prepares new list
for analysis in RSEIS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep1wig(wig=vector(), dt=1, sta="STA", comp="CMP",
units="UNITS", starttime=list(yr=0, jd=1,mo=1,dom=1,
hr=1,mi=1,sec=0) )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep1wig_+3A_wig">wig</code></td>
<td>
<p>vector of time series</p>
</td></tr>
<tr><td><code id="prep1wig_+3A_dt">dt</code></td>
<td>
<p>sample interval</p>
</td></tr>
<tr><td><code id="prep1wig_+3A_sta">sta</code></td>
<td>
<p>character, station name</p>
</td></tr>
<tr><td><code id="prep1wig_+3A_comp">comp</code></td>
<td>
<p>character,component name</p>
</td></tr>
<tr><td><code id="prep1wig_+3A_units">units</code></td>
<td>
<p>character, units of signal</p>
</td></tr>
<tr><td><code id="prep1wig_+3A_starttime">starttime</code></td>
<td>
<p>list(yr=1972, jd=1,mo=1,dom=1,hr=1,mi=1,sec=0)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>prep1wig is offered to reformat a time series
</p>
<p>for input to program swig()
</p>


<h3>Value</h3>

<p>Rsac output list
</p>
<table>
<tr><td><code>amp</code></td>
<td>
<p>amplitude</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>sample rate</p>
</td></tr>
<tr><td><code>nzyear</code></td>
<td>
<p>year</p>
</td></tr>
<tr><td><code>nzhour</code></td>
<td>
<p>hour</p>
</td></tr>
<tr><td><code>nzmin</code></td>
<td>
<p>minutes</p>
</td></tr>
<tr><td><code>nzsec</code></td>
<td>
<p>seconds</p>
</td></tr>
<tr><td><code>nzmsec</code></td>
<td>
<p>msec</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>sac stuff</p>
</td></tr>
<tr><td><code>e</code></td>
<td>
<p>sac stuff</p>
</td></tr>
<tr><td><code>o</code></td>
<td>
<p>sac stuff</p>
</td></tr>
<tr><td><code>fn</code></td>
<td>
<p>character, file name</p>
</td></tr>
<tr><td><code>sta</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code>comp</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code>DATTIM</code></td>
<td>
<p>list of date and time</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>number of points</p>
</td></tr>
<tr><td><code>units</code></td>
<td>
<p>character</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>swig, prepSEIS</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sunspots)
AA &lt;- attributes(sunspots)
starttime&lt;-list(yr=AA$tsp[1], jd=1,mo=1,dom=1,hr=0,mi=0,sec=0)
ES &lt;- prep1wig(wig=sunspots, dt=1/12, sta="STA", comp="CMP",
units="UNITS", starttime=starttime     )

EH&lt;-prepSEIS(ES)

STDLAB &lt;- c("DONE",  "zoom out", "refresh", "restore",
 "XTR", "SPEC", "SGRAM" ,"WLET")

######  set SHOWONLY=FALSE for interactive
xx &lt;-  swig( EH, STDLAB = STDLAB, SHOWONLY=0)

####################
####################
####################   example with multiple signals

dt &lt;- 0.001
t &lt;- seq(0, 6, by=0.001)
######    sample rate = 1000 Hz, 0.001 seconds 601 samples

###  set up the fequencies and amplitudes for signals that have 2 frequencies
afreqs1 &lt;- c(50, 40,10, 5 )
amps1 &lt;- c(6, 2,3, 2 )
####
afreqs2 &lt;- c(120,30,20, 30  )
amps2 &lt;- c(10,5, 9, 2 )


 x &lt;- cbind( amps1[1]*sin(2*pi*afreqs1[1]*t) +
amps2[1]* sin(2*pi*afreqs2[1]*t),
amps1[2]*sin(2*pi*afreqs1[2]*t) + amps2[2]* sin(2*pi*afreqs2[2]*t),
amps1[3]*sin(2*pi*afreqs1[3]*t) + amps2[3]* sin(2*pi*afreqs2[3]*t),
amps1[4]*sin(2*pi*afreqs1[4]*t) + amps2[4]* sin(2*pi*afreqs2[4]*t))

d &lt;- dim(x)

########  names of signals
mysta&lt;-c("R1", "R2", "R3", "R4")

MYLIST &lt;- list()
starttime &lt;- list(yr=2008, jd=1,mo=1,dom=1,hr=0,mi=0,sec=0)
############  set up the initial list of wiggles
for(i in 1:d[2])
{

A &lt;- prep1wig(wig =x[,i], sta=mysta[i], dt=dt, comp="DO",
units= "amp", starttime=starttime)

A[[1]]$DATTIM$yr &lt;- 2000
MYLIST &lt;- c(MYLIST, A)

}

###  reorganize into RSEIS format:
PH1 &lt;- prepSEIS(MYLIST)

STDLAB &lt;- c("DONE",  "zoom out", "refresh", "restore",
"XTR", "SPEC", "SGRAM" ,"WLET")

swig(PH1, STDLAB = STDLAB)



</code></pre>

<hr>
<h2 id='prepSEIS'>Prepare structure for RSEIS</h2><span id='topic+prepSEIS'></span>

<h3>Description</h3>

<p>Takes list of traces and prepares new list
for analysis in RSEIS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepSEIS(GG)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepSEIS_+3A_gg">GG</code></td>
<td>
<p>Output list of Rsac function GET.seis </p>
</td></tr>
</table>


<h3>Details</h3>

<p>prepSEIS is offered to reformat the
output of a list of seismic traces (or other time series)
for inpout to program swig()
</p>


<h3>Value</h3>

<p>RSEIS list
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>swig, JGET.seis, GET.seis(package=&quot;Rsac&quot;), Package:Rsac</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sunspots)

ES &lt;- prep1wig(wig=sunspots, dt=1/12, sta="STA",
           comp="CMP", units="UNITS" )

EH &lt;- prepSEIS(ES)

STDLAB &lt;- c("DONE",  "zoom out", "refresh", "restore",
      "XTR", "SPEC", "SGRAM" ,"WLET")

xx &lt;-  swig( EH, STDLAB = STDLAB)
###################################
###################################


####################   example with multiple signals

dt &lt;- 0.01
t &lt;- seq(0, 60, by=0.01)
######    sample rate = 100 Hz, 0.001 seconds 601 samples

###  set up the fequencies and amplitudes for signals that have 2 frequencies
afreqs1 &lt;- c(8, 13,12, 5 )
amps1 &lt;- c(6, 2,3, 2 )
####
afreqs2 &lt;- c(4,3,2, 3  )
amps2 &lt;- c(10,5, 9, 2 )


 x &lt;- cbind( amps1[1]*sin(2*pi*afreqs1[1]*t) + amps2[1]* sin(2*pi*afreqs2[1]*t),
amps1[2]*sin(2*pi*afreqs1[2]*t) + amps2[2]* sin(2*pi*afreqs2[2]*t),
amps1[3]*sin(2*pi*afreqs1[3]*t) + amps2[3]* sin(2*pi*afreqs2[3]*t),
amps1[4]*sin(2*pi*afreqs1[4]*t) + amps2[4]* sin(2*pi*afreqs2[4]*t))

d &lt;- dim(x)

########  names of signals
mysta &lt;- c("R1", "R2", "R3", "R4")

MYLIST &lt;- list()

############  set up the initial list of wiggles
for(i in 1:d[2])
{

A &lt;- prep1wig(wig =x[,i], sta=mysta[i], dt=dt, comp="DO", units="amp") 
A[[1]]$DATTIM$yr &lt;- 2000
MYLIST &lt;- c(MYLIST, A)

}

###  reorganize into RSEIS format:
PH1 &lt;- prepSEIS(MYLIST)

STDLAB &lt;- c("DONE",  "zoom out", "refresh", "restore",
           "XTR", "SPEC", "SGRAM" ,"WLET")

swig(PH1, STDLAB = STDLAB)




## Not run: 
######  this example shows how to read data from SEGY files using Rsac
#####  and entering RSEIS
KG4 &lt;- JGET.seis(c(fnames), kind = 1, PLOT = -1)

KH &lt;- prepSEIS(KG4)

STDLAB &lt;- c("DONE",  "zoom out", "refresh", "restore",
                "XTR", "SPEC", "SGRAM" ,"WLET")

xx &lt;-  swig( KH, sel=which(KH$COMPS == "V"), STDLAB = STDLAB)







## End(Not run)

</code></pre>

<hr>
<h2 id='PreSet.Instr'>Set up Standard Instrument Responses</h2><span id='topic+PreSet.Instr'></span>

<h3>Description</h3>

<p>A set of standard known instrument responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PreSet.Instr()
</code></pre>


<h3>Value</h3>

<p>List of instrument responses. Each is a list:
</p>
<table>
<tr><td><code>np</code></td>
<td>
<p>Number of poles</p>
</td></tr>
<tr><td><code>poles</code></td>
<td>
<p>complex vector of poles</p>
</td></tr>
<tr><td><code>nz</code></td>
<td>
<p>number of zeros</p>
</td></tr>
<tr><td><code>zeros</code></td>
<td>
<p>complex vector of zeros</p>
</td></tr>
<tr><td><code>Knorm</code></td>
<td>
<p>normalization factor</p>
</td></tr>
<tr><td><code>Sense</code></td>
<td>
<p>sensitivity factor </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>ReadSet.Instr</p>


<h3>Examples</h3>

<pre><code class='language-R'>MYset &lt;- PreSet.Instr()
MYset[[1]]
</code></pre>

<hr>
<h2 id='PSTLTcurve'>Short Term/Long Term curve</h2><span id='topic+PSTLTcurve'></span>

<h3>Description</h3>

<p>ST/LT ratio curve for sutomated picking routines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSTLTcurve(y, dt = 0.008, fwlen = 125, bwlen = 125,
 perc = 0.05, stretch = 1000, MED = 255, PLOT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PSTLTcurve_+3A_y">y</code></td>
<td>
<p>signal</p>
</td></tr>
<tr><td><code id="PSTLTcurve_+3A_dt">dt</code></td>
<td>
<p>deltaT (s)</p>
</td></tr>
<tr><td><code id="PSTLTcurve_+3A_fwlen">fwlen</code></td>
<td>
<p>forward window </p>
</td></tr>
<tr><td><code id="PSTLTcurve_+3A_bwlen">bwlen</code></td>
<td>
<p>backward window</p>
</td></tr>
<tr><td><code id="PSTLTcurve_+3A_perc">perc</code></td>
<td>
<p>percent cut-off </p>
</td></tr>
<tr><td><code id="PSTLTcurve_+3A_stretch">stretch</code></td>
<td>
<p>stretch curve </p>
</td></tr>
<tr><td><code id="PSTLTcurve_+3A_med">MED</code></td>
<td>
<p>Median smoothing parameter </p>
</td></tr>
<tr><td><code id="PSTLTcurve_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE=PLOT</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list(flag=1, ind=ix, eye=eye, mix=mix, SNR=SNR,  s2=s2, rat=therat)
</p>
<table>
<tr><td><code>flag</code></td>
<td>
<p>flag on success</p>
</td></tr>
<tr><td><code>ind</code></td>
<td>
<p>index of pick estimate 1</p>
</td></tr>
<tr><td><code>eye</code></td>
<td>
<p>index of pick estimate 2</p>
</td></tr>
<tr><td><code>mix</code></td>
<td>
<p>index of pick estimate 3</p>
</td></tr>
<tr><td><code>SNR</code></td>
<td>
<p>Signal/Noise ratio</p>
</td></tr>
<tr><td><code>s2</code></td>
<td>
<p>sum squared</p>
</td></tr>
<tr><td><code>rat</code></td>
<td>
<p>ratio curve</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(stats)

data(CE1)
plot(CE1$x, CE1$y, type='l')

z &lt;- CE1$y[ CE1$x&gt;5.352622 &amp; CE1$x&lt;5.589836]
x &lt;- CE1$x[ CE1$x&gt;5.352622 &amp; CE1$x&lt;5.589836]

G &lt;- PSTLTcurve(z, dt = CE1$dt, fwlen = 10,
bwlen = 10, perc = 0.05,
stretch = 10, MED = 11, PLOT = FALSE)

### get time from beginning of trace
tpick &lt;- x[G$ind]
abline(v=x[G$ind], col='red', lty=2)


</code></pre>

<hr>
<h2 id='Put1Dvel'>Dump a velocity model to an ascii file</h2><span id='topic+Put1Dvel'></span>

<h3>Description</h3>

<p>Dump a velocity model to an ascii file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Put1Dvel(vel, outfile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Put1Dvel_+3A_vel">vel</code></td>
<td>
<p>Velocity Model Structure</p>
</td></tr>
<tr><td><code id="Put1Dvel_+3A_outfile">outfile</code></td>
<td>
<p>File name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>Get1Dvel, travel.time1D</p>

<hr>
<h2 id='pwlet2freqs'>Convert Wavelet Axis to Frequency</h2><span id='topic+pwlet2freqs'></span>

<h3>Description</h3>

<p>Convert Wavelet Axis to Frequency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwlet2freqs(noctave, nvoice, dt, flip = TRUE,
tab.FREQ, plot = FALSE, perc = 0.85)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pwlet2freqs_+3A_noctave">noctave</code></td>
<td>
<p>number of octives</p>
</td></tr>
<tr><td><code id="pwlet2freqs_+3A_nvoice">nvoice</code></td>
<td>
<p>number of voices </p>
</td></tr>
<tr><td><code id="pwlet2freqs_+3A_dt">dt</code></td>
<td>
<p>sample rate (s)</p>
</td></tr>
<tr><td><code id="pwlet2freqs_+3A_flip">flip</code></td>
<td>
<p>logical,  whether to flip the orientation </p>
</td></tr>
<tr><td><code id="pwlet2freqs_+3A_tab.freq">tab.FREQ</code></td>
<td>
<p>vector of frequencies</p>
</td></tr>
<tr><td><code id="pwlet2freqs_+3A_plot">plot</code></td>
<td>
<p>logical, TRUE=add to plot</p>
</td></tr>
<tr><td><code id="pwlet2freqs_+3A_perc">perc</code></td>
<td>
<p>percent of range to consider</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to add a y-axis to a wavelet transform plot.
</p>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>why</code></td>
<td>
<p>y-axis coordinate on wavelet transform</p>
</td></tr>
<tr><td><code>Iat</code></td>
<td>
<p>location</p>
</td></tr>
<tr><td><code>efs</code></td>
<td>
<p>frequencies</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>wlet.do</p>


<h3>Examples</h3>

<pre><code class='language-R'>pfreqs &lt;- c(0.5, 1, 2,3,4,5, 10, 14)

zp &lt;- pwlet2freqs(noctave= 6, nvoice= 20, 0.004,
 flip = TRUE, pfreqs, plot = FALSE, perc = 0.85)
  
</code></pre>

<hr>
<h2 id='rangedatetime'>Range of Date Time</h2><span id='topic+rangedatetime'></span>

<h3>Description</h3>

<p>Return the range of dates and times for any list with a date/time list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rangedatetime(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rangedatetime_+3A_d">D</code></td>
<td>
<p>info list from RSEIS seismic data list</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>min</code></td>
<td>
<p>date time list</p>
</td></tr>
<tr><td><code>max</code></td>
<td>
<p>date time list</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GH)

rangedatetime(GH$info)


</code></pre>

<hr>
<h2 id='Ray.time1D'>Seismic 1D Travel Time and raypath</h2><span id='topic+Ray.time1D'></span>

<h3>Description</h3>

<p>Travel time and raypath from source to reciever in 1D local model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ray.time1D(indelta, inhpz, instaz, inlay, ztop, vel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ray.time1D_+3A_indelta">indelta</code></td>
<td>
<p>distance in KM</p>
</td></tr>
<tr><td><code id="Ray.time1D_+3A_inhpz">inhpz</code></td>
<td>
<p>depth of hypocenter, km</p>
</td></tr>
<tr><td><code id="Ray.time1D_+3A_instaz">instaz</code></td>
<td>
<p>elevation of station</p>
</td></tr>
<tr><td><code id="Ray.time1D_+3A_inlay">inlay</code></td>
<td>
<p>number of layers</p>
</td></tr>
<tr><td><code id="Ray.time1D_+3A_ztop">ztop</code></td>
<td>
<p>vector, tops of layers</p>
</td></tr>
<tr><td><code id="Ray.time1D_+3A_vel">vel</code></td>
<td>
<p>vector, velocities in layers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses local  1D velocity model, not appropriate for spherical earth.
</p>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>dtdr</code></td>
<td>
<p>derivative of t w.r.t. horizontal distance</p>
</td></tr>
<tr><td><code>dtdz</code></td>
<td>
<p>derivative of t w.r.t. z, depth</p>
</td></tr>
<tr><td><code>angle</code></td>
<td>
<p>incidence angle, degrees</p>
</td></tr>
<tr><td><code>tt</code></td>
<td>
<p>travel time, s</p>
</td></tr>
<tr><td><code>nnod</code></td>
<td>
<p>number of nodes</p>
</td></tr>
<tr><td><code>znod</code></td>
<td>
<p>node depths, km</p>
</td></tr>
<tr><td><code>rnod</code></td>
<td>
<p>node offset distances, km</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>travel.time1D,  Get1Dvel</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(VELMOD1D)

v &lt;-  VELMOD1D
indelta=23.;
 inhpz=7.;
 instaz=0.;
nz = length(v$zp)

tees  &lt;-  travel.time1D(indelta, inhpz, instaz, nz , v$zp , v$vp)
rays  &lt;-  Ray.time1D(indelta, inhpz, instaz, nz , v$zp , v$vp)



plot(rays$rnod[1:rays$nnod] , -rays$znod[1:rays$nnod],type="n",
 xlab="distance, km" , ylab="Depth, km")

abline(h=-v$zp, lty=2, col=grey(0.80) )
points(rays$rnod[1:rays$nnod] , -rays$znod[1:rays$nnod], pch=8, col='green')
lines(rays$rnod[1:rays$nnod] , -rays$znod[1:rays$nnod])
points(rays$rnod[rays$nnod] , -rays$znod[rays$nnod], pch=6, col='red', cex=2)
#####  to coordinate this in space, need to rotate about
#####    the line between source and receiver locations

</code></pre>

<hr>
<h2 id='rdistaz'>Distance and Azimuth from two points </h2><span id='topic+rdistaz'></span>

<h3>Description</h3>

<p>Calculate distance, Azimuth and Back-Azimuth from two points on Globe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdistaz(olat, olon, tlat, tlon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdistaz_+3A_olat">olat</code></td>
<td>
<p>origin latitude, degrees </p>
</td></tr>
<tr><td><code id="rdistaz_+3A_olon">olon</code></td>
<td>
<p>origin longitude, degrees </p>
</td></tr>
<tr><td><code id="rdistaz_+3A_tlat">tlat</code></td>
<td>
<p>target latitude, degrees </p>
</td></tr>
<tr><td><code id="rdistaz_+3A_tlon">tlon</code></td>
<td>
<p>target longitude, degrees  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Program is set up for one origin (olat, olon) pair and many
target (tlat, tlon) pairs given as vectors.
</p>
<p>If multiple olat and olon are given, the program returns a list
of outputs for each.
</p>
<p>If olat or any tlat is greater than 90 or less than -90,  NA is returned
and error flag is 0.
</p>
<p>If any tlat and tlon is equal to olat and olon, the points are
coincident.
In that case the distances are set to zero, but the az and baz are NA,
and the error flag is set to 0.
</p>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>del</code></td>
<td>
<p>Delta, angle in degrees</p>
</td></tr>
<tr><td><code>az</code></td>
<td>
<p>Azimuth, angle in degrees</p>
</td></tr>
<tr><td><code>baz</code></td>
<td>
<p>Back Azimuth, angle in degrees from target to origin</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>Distance in km</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>0 or 1, error flag.  0=error, 1=no error, see details</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>along.great, getgreatarc</p>


<h3>Examples</h3>

<pre><code class='language-R'>

####  one point
d &lt;- rdistaz(12, 23, -32,    -65)
d

####  many random target points
org &lt;- c(80.222, -100.940)
targ &lt;- cbind(runif(10, 10, 50), runif(10, 20, 100))


rdistaz(org[1], org[2], targ[,1], targ[,2])

############  if origin and target are identical
#####  the distance is zero, but the az and baz are not defined
rdistaz(80.222, -100.940, 80.222, -100.940)


########################   set one of the targets equal to the origin
targ[7,1] &lt;- org[1]
targ[7,2] &lt;- org[2]

rdistaz(org[1], org[2], targ[,1], targ[,2])

####  put in erroneous latitude data

targ[3,1] &lt;-  -91.3


rdistaz(org[1], org[2], targ[,1], targ[,2])


</code></pre>

<hr>
<h2 id='rDUMPLOC'>DUMP vectors to screen in list format</h2><span id='topic+rDUMPLOC'></span>

<h3>Description</h3>

<p>For saving vectors to a file after the locator function
has been executed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rDUMPLOC(zloc, dig = 12)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rDUMPLOC_+3A_zloc">zloc</code></td>
<td>
<p>x,y list of locator positions</p>
</td></tr>
<tr><td><code id="rDUMPLOC_+3A_dig">dig</code></td>
<td>
<p>number of digits in output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Side effects: print to screen
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>G &lt;- list()
G$x &lt;- c(-1.0960,-0.9942,-0.8909,-0.7846,-0.6738,-0.5570,-0.4657,-0.3709,
-0.2734,-0.1740,-0.0734, 0.0246, 0.1218, 0.2169, 0.3086, 0.3956, 0.4641, 
0.5293, 0.5919, 0.6530, 0.7131)
G$y &lt;- c(-0.72392,-0.62145,-0.52135,-0.42599,-0.33774,-0.25896,-0.20759,
-0.16160,-0.11981,-0.08105,-0.04414,-0.00885, 0.02774, 0.06759, 0.11262, 
0.16480, 0.21487, 0.27001, 0.32895, 0.39044, 0.45319)

g &lt;- G
rDUMPLOC(g, dig = 5)


</code></pre>

<hr>
<h2 id='read1segy'>Read one SEGY/SAC file
</h2><span id='topic+read1segy'></span><span id='topic+read1sac'></span>

<h3>Description</h3>

<p>Read one SEGY/SAC file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read1segy(fname, Iendian = 1, HEADONLY = FALSE, BIGLONG = FALSE)
read1sac(fname, Iendian = 1, HEADONLY = FALSE, BIGLONG = FALSE )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read1segy_+3A_fname">fname</code></td>
<td>
<p>character, file name
</p>
</td></tr>
<tr><td><code id="read1segy_+3A_iendian">Iendian</code></td>
<td>
<p>Endian of the input file name
</p>
</td></tr>
<tr><td><code id="read1segy_+3A_headonly">HEADONLY</code></td>
<td>
<p>logical, TRUE=return only header (default=FALSE)
</p>
</td></tr>
<tr><td><code id="read1segy_+3A_biglong">BIGLONG</code></td>
<td>
<p>logical, indicating whether long is 8 or 4 bytes.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Segy format files are in integer format.
The time series ususally represents counts
recorded in a data acquisition system.  The header includes
meta-data and other identifying information.
</p>
<p>SAC data is stored as floats, typically volts.
</p>


<h3>Value</h3>

<p>list of header and times series
</p>


<h3>Note</h3>

<p>The Endian-ness of the input files is set by
the system that created them.
If the read1segy or read1sac does not make sense,
try a different endian or BIGLONG setting.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>write1sac, write1segy, sac2rseis, segy2rseis, prepSEIS
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

fnames = list.files(path="/Users/lees/Site/Buf2014/ALL_SEGY",
                                     pattern=NULL, full.names=TRUE )

for(i in 1:length(fnames))
{
fn1  = fnames[i]

bed =  read1segy(fn1   , Iendian = 1 , HEADONLY=TRUE, BIGLONG=FALSE)
scaly[i] =  bed$HEAD$scale_fac
print(paste(i, fn1, bed$HEAD$station_name , bed$HEAD$channel_name,
       bed$HEAD$scale_fac, bed$HEAD$gainConst)  )

}



## End(Not run)

</code></pre>

<hr>
<h2 id='ReadInstr'>Read Instrument Response in  IRIS SEED format
</h2><span id='topic+ReadInstr'></span>

<h3>Description</h3>

<p>Read Instrument Response, poles and zeros, in  IRIS SEED
format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadInstr(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadInstr_+3A_fn">fn</code></td>
<td>
<p>File name with Poles and Zeros
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>RSEIS currently has a function (ReadSet.Instr) to read pole/zero files,
but it seems to expect a format different from what one gets from
IRIS.  
This one is compatible with pole/zero files produced by rdseed
when converting seed files from the DMC to SAC files.
</p>


<h3>Value</h3>

<p>List of poles and zeros compatible for swig decon
</p>


<h3>Author(s)</h3>

<p>Jake Anderson&lt;ajakef@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>ReadSet.Instr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(RSEIS)
source('ReadInstr.R')
S  &lt;-  JSAC.seis('2010.012.21.54.46.6195.IU.OTAV.00.BHZ.R.SAC', BIGLONG = FALSE)
GH  &lt;-  prepSEIS(S)
swig(GH)
RESP &lt;-
ReadInstr('SAC_PZs_IU_OTAV_BHZ_00_2009.091.00.00.00.0000_2010.136.22.12.60.99999')
GHV  &lt;-  VELOCITY.SEISN(GH, Kal = RESP,  FILT = list(ON = TRUE, fl = 1/160,
fh = 7, type = "HP", proto = "BU"))
swig(GHV)
GHD  &lt;-  DISPLACE.SEISN(GH, Kal = RESP,  FILT = list(ON = TRUE, fl = 1/160,
fh = 7, type = "HP", proto = "BU"))
swig(GHD)



## End(Not run)


</code></pre>

<hr>
<h2 id='ReadSet.Instr'>Read Instrument Response file</h2><span id='topic+ReadSet.Instr'></span>

<h3>Description</h3>

<p>Read in an instrument response file, or 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadSet.Instr(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadSet.Instr_+3A_file">file</code></td>
<td>
<p>name of file to read, or vector of character strings from
the file </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If file is a path to a file it is read in and processed.  If file is a
vector of character strings from a file that has already been read in,
the file is processed directly.
</p>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>np</code></td>
<td>
<p>NUmber of poles</p>
</td></tr>
<tr><td><code>poles</code></td>
<td>
<p>complex vector of poles</p>
</td></tr>
<tr><td><code>nz</code></td>
<td>
<p>number of zeros</p>
</td></tr>
<tr><td><code>zeros</code></td>
<td>
<p>complex vector of zeros</p>
</td></tr>
<tr><td><code>Knorm</code></td>
<td>
<p>normalization factor</p>
</td></tr>
<tr><td><code>Sense</code></td>
<td>
<p>sensitivity factor</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>###  in this case a file has already been read in:
CMG &lt;- c(
      "ZEROS 2",
      "0.0000E+00 0.0000E+00",
      "0.0000E+00 0.0000E+00",
      "POLES 3",
      "-0.1480E+00 0.1480E+00",
      "-0.1480E+00 -0.1480E+00",
      "-50.0 0.0",
      "CONSTANT 1.0",
      "SENSE 800")

ReadSet.Instr(CMG)

## Not run: 
RL28  &lt;-  ReadSet.Instr('/pathto/Equipment/Sensors/L28.inst.response')

## End(Not run)


</code></pre>

<hr>
<h2 id='readUW.OSTAS'>Parse UW  O-Cards</h2><span id='topic+readUW.OSTAS'></span>

<h3>Description</h3>

<p>PArse out UW O-cards from Pickfile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readUW.OSTAS(OS1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readUW.OSTAS_+3A_os1">OS1</code></td>
<td>
<p>cards starting with O</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of station names not picked
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>

<hr>
<h2 id='recdate'>Rectify Date </h2><span id='topic+recdate'></span><span id='topic+recdatel'></span>

<h3>Description</h3>

<p>Rectify a date that may be out of wack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recdate(jd=0, hr=0, mi=0, sec=0, yr=0)
recdatel(X)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recdate_+3A_jd">jd</code></td>
<td>
<p>Julian Day</p>
</td></tr>
<tr><td><code id="recdate_+3A_hr">hr</code></td>
<td>
<p>hours</p>
</td></tr>
<tr><td><code id="recdate_+3A_mi">mi</code></td>
<td>
<p>minutes</p>
</td></tr>
<tr><td><code id="recdate_+3A_sec">sec</code></td>
<td>
<p>seconds</p>
</td></tr>
<tr><td><code id="recdate_+3A_yr">yr</code></td>
<td>
<p>year</p>
</td></tr>
</table>
<p>or
</p>
<table>
<tr><td><code id="recdate_+3A_x">X</code></td>
<td>
<p>list of date</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns date with correct numbers. So if number of seconds is
greater than 60, will add to minutes...
</p>


<h3>Value</h3>

<table>
<tr><td><code>jd</code></td>
<td>
<p>Julian Day</p>
</td></tr>
<tr><td><code>hr</code></td>
<td>
<p>hours</p>
</td></tr>
<tr><td><code>mi</code></td>
<td>
<p>minutes</p>
</td></tr>
<tr><td><code>sec</code></td>
<td>
<p>seconds</p>
</td></tr>
<tr><td><code>yr</code></td>
<td>
<p>year </p>
</td></tr>
</table>


<h3>Note</h3>

<p>Default value for jd is 1, the rest are 0. This function now
should successfully span year breaks.  Leap years are correctly
accounted for too.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>showdatetime, DAYSperYEAR, fromjul,getjul, tojul, getmoday </p>


<h3>Examples</h3>

<pre><code class='language-R'>
recdate(76, 23, 22, yr=2000)

###########  example spanning leap year
##  start on Day 1, but subtract 36 hours and proceed to plus 36 hours
hrs &lt;- seq(from=-36, to=36, by=2)
rd &lt;- recdate(jd=1, hr=hrs, mi=34,
       sec=23+runif(n=length(hrs), 0, 59) , yr=2009)
write.table(data.frame(rd))

###########  example spanning non-leap year
rd2 &lt;- recdate(jd=1, hr=hrs, mi=34,
     sec=23+runif(n=length(hrs), 0, 59) , yr=2008)
write.table(data.frame(rd2))


</code></pre>

<hr>
<h2 id='repairWPX'>Repair WPX
</h2><span id='topic+repairWPX'></span>

<h3>Description</h3>

<p>Repair a WPX list that may be deficient 
in one or more of its components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repairWPX(wpx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repairWPX_+3A_wpx">wpx</code></td>
<td>
<p>Pick information, dataframe
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Program checks a few of the elelments
and tries to fix potential problems.
</p>


<h3>Value</h3>

<p>WPX dataframe
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>addWPX,	catWPX,	checkWPX,cleanWPX,clusterWPX,saveWPX, setWPX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
s1 &lt;- setWPX(name="HI", yr=2011, jd=231, hr=4, mi=3, sec = runif(5)) 

s1$col &lt;- NULL

s2 &lt;- repairWPX(s1)




</code></pre>

<hr>
<h2 id='replaceWPX'>
Replace  picks in WPX file
</h2><span id='topic+replaceWPX'></span>

<h3>Description</h3>

<p>Replace pick in WPX file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replaceWPX(WPX, onepx , ind=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replaceWPX_+3A_wpx">WPX</code></td>
<td>
<p>WPX list
</p>
</td></tr>
<tr><td><code id="replaceWPX_+3A_onepx">onepx</code></td>
<td>
<p>WPX list with one pick
</p>
</td></tr>  
<tr><td><code id="replaceWPX_+3A_ind">ind</code></td>
<td>
<p>integer, index to replace
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Replaces one pick at index provided.
</p>


<h3>Value</h3>

<p>WPX list
</p>


<h3>Note</h3>

<p>Replaces in the location provided. No test is made to
determine if there is a pick already there.
Maybe future versions will allow multiple replacements.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>addWPX, catWPX, deleteWPX, selWPX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s1 &lt;- setWPX(name="HI", yr=2011, jd=231, hr=4, mi=3, sec = runif(5)) 
s2 &lt;- setWPX(name="HI", yr=2011, jd=231, hr=4, mi=3, sec = runif(1)) 


s4 &lt;- replaceWPX(s1,s2, ind=4)

</code></pre>

<hr>
<h2 id='RSEIS-package'>
Seismic Analysis and Display
</h2><span id='topic+RSEIS-package'></span><span id='topic+RSEIS'></span>

<h3>Description</h3>

<p>Multiple interactive codes to view and analyze seismic data, via spectrum analysis, wavelet transforms, particle motion, hodograms.  Includes general time-series tools, plotting, filtering, interactive display.
</p>


<h3>Note</h3>

 
<dl>
<dt>Seismic Sections</dt><dd>
<p>JGET.seis
view.seis
swig
Mine.seis
VELOCITY.SEISN  
DISPLACE.SEISN
ZOOM.SEISN 
wlet.drive 
SENSORsensitivity
PLOT.MATN
PLOT.SEISN
PLOT.TTCURVE
PLOT.ALLPX
plotevol
MTMdisp
MTMplot
NEW.getUWSTAS
NEWPLOT.WPX
INSTFREQS
INSTresponse
GLUE.GET.seis
GLUEseisMAT
FILT.SEISN
FILT.spread
CHOP.SEISN
get.corner
grotseis
</p>
</dd>
<dt>Velocity-Travel Time:</dt><dd>
<p>Put1Dvel
Ray.time1D
setLQUAKE
selAPX
Get1Dvel
Comp1Dvel
Comp1Dvels
travel.time1D
</p>
</dd>
<dt>Particle Motion:</dt><dd>
<p>hodogram
PMOT.drive
complex.hodo
addpoints.hodo
idpoints.hodo
DO.PMOT.ARR
partmotnet
prep1wig
prepSEIS
EmptySEIS
GAZI
</p>
</dd>
<dt>Time series:</dt><dd>
<p>xcor2  
wlet.drive 
wlet.do  
wiggle.env 
plotwlet
STLTcurve
SPECT.drive
rsspec.taper
evolfft
GETARAIC
PSTLTcurve
getphaselag2
envelope
hilbert
LocalUnwrap
lagplot
applytaper
autoreg
butfilt
choosfilt
MTM.drive
</p>
</dd>
<dt>Date-Time Functions:</dt><dd>
<p>yeardate YRsecdif  Zdate 
recdatel
recdate
tojul
getjul
getmoday
secdifL
secdif
secdifv
JtimL
Jtim
fromjul
</p>
</dd>
<dt>Graphics:</dt><dd>
<p>plocator
ilocator
meshgrid
ymarginfo
zlocator winmark
vline
screens
RESCALE
pwlet2freqs
addtix
circle
circ
letter.it
jpostscript
JBLACK
JGRAY
HOZscale
gaddtix
Gcols
jlegend
tomo.colors
</p>
</dd>
<dt>Misc:</dt><dd>
<p>BKpfile2ypx
brune.doom
brune.func
brune.search
comp.env
contwlet
deconinst
detail.pick
rdistaz
rDUMPLOC
EmptyPickfile
ETECTG
finteg
fixcompname
fixcomps
fixUWstasLL
fmod
FRWDft
getb1b2
getNcard
getpfile
getseisinfo
getvertsorder
gpoly
GreatDist
gwpix2ypx
hilow
hypot
integ1
INVRft
itoxyz
jadjust.length
jpolyval
jstats
local.file
logspace
makefreq
mirror.matrix
Mmorlet
mtapspec
peaks
PICK.DOC
pickit
plt.MTM0
PLTpicks
PPIX
PreSet.Instr
ReadSet.Instr
readUW.OSTAS
scal2freqs
SEARCHPIX
setstas
setwelch
shade.col
SNET.drive
T12.pix
Thresh.J
TOCART
trapz
tung.pulse
unpackAcard
uwpfile2ypx
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;
Maintainer:Jonathan M. Lees&lt;jonathan.lees.edu&gt;
</p>


<h3>See Also</h3>

<p>RPGM, RFOC
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("GH")
swig(GH)

</code></pre>

<hr>
<h2 id='rseis2segy'>Convert RSEIS to SEGY/SAC format
</h2><span id='topic+rseis2segy'></span><span id='topic+rseis2sac'></span>

<h3>Description</h3>

<p>Convert RSEIS to SEGY/SAC format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rseis2segy(GH, sel = 1, win = c(0, 1), path = ".", BIGLONG = FALSE)
rseis2sac(GH, sel = 1, win = c(0, 1), path = ".", BIGLONG = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rseis2segy_+3A_gh">GH</code></td>
<td>
<p>RSEIS format list
</p>
</td></tr>
<tr><td><code id="rseis2segy_+3A_sel">sel</code></td>
<td>
<p> select traces to convert
</p>
</td></tr>
<tr><td><code id="rseis2segy_+3A_win">win</code></td>
<td>
<p> vector, t1 and t2  window each trace
</p>
</td></tr>
<tr><td><code id="rseis2segy_+3A_path">path</code></td>
<td>
<p>path to directory where files are created
</p>
</td></tr>
<tr><td><code id="rseis2segy_+3A_biglong">BIGLONG</code></td>
<td>
<p>logical, indicating whether long is 8 or 4 bytes.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the converse of the segy2rseis routine.
</p>
<p>Segy format files are in integer format.
The time series ususally represents counts
recorded in a data acquisition system.  The header includes
meta-data and other identifying information.
</p>


<h3>Value</h3>

<p>Side effects in file system
</p>


<h3>Note</h3>

<p>The Endian-ness of the output file will
be the native endian-ness of the system.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>write1segy, write1sac, read1sac,
read1segy, sac2rseis, segy2rseis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

rseis2segy(GH,  path="./MYSEGFILES", BIGLONG=FALSE )


## End(Not run)

</code></pre>

<hr>
<h2 id='rseis2ts'>Convert RSEIS to TS
</h2><span id='topic+rseis2ts'></span>

<h3>Description</h3>

<p>Convert one trace from an RSEIS seismic list to a ts time-series object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rseis2ts(GH, sel = 1, notes = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rseis2ts_+3A_gh">GH</code></td>
<td>
<p>List structure of seismic traces from RSEIS
</p>
</td></tr>
<tr><td><code id="rseis2ts_+3A_sel">sel</code></td>
<td>
<p>numeric index of one trace.
</p>
</td></tr>
<tr><td><code id="rseis2ts_+3A_notes">notes</code></td>
<td>
<p>character string of notes
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function extracts one trace and associated information from an RSEIS structure and returns a ts, time-series, object.
</p>


<h3>Value</h3>

<p>ts object
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(GH)
H = rseis2ts(GH, 1, notes='Coso Trace 1')
plot(H)
title(main=attr(H, 'info')$notes)

</code></pre>

<hr>
<h2 id='rsspec.taper'>Taper spectrum</h2><span id='topic+rsspec.taper'></span>

<h3>Description</h3>

<p>Taper function for spectrum analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsspec.taper(x, p = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsspec.taper_+3A_x">x</code></td>
<td>
<p>time series trace</p>
</td></tr>
<tr><td><code id="rsspec.taper_+3A_p">p</code></td>
<td>
<p>percent taper</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cosine taper at ends of trace.
</p>


<h3>Value</h3>

<p>tapered trace is returned.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CE1)
Xamp &lt;- CE1$y[CE1$x &gt; 5.443754 &amp; CE1$x&lt;5.615951]
###  10% cosine taper:
xtap &lt;- rsspec.taper(Xamp, p = 0.1)


</code></pre>

<hr>
<h2 id='ruler'>Column Ruler
</h2><span id='topic+ruler'></span>

<h3>Description</h3>

<p>Column Ruler for determining columns to read.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruler(a = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ruler_+3A_a">a</code></td>
<td>
<p>character string, optional</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine is set up to help get the columns
for specific column oriented data.  The ruler is
dumped out below the character string for comparison.
If no string is provided, just the rule is dumped.
Use routine substr to extract the data from the columns.
</p>


<h3>Value</h3>

<p>Side effects</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>substr </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
aa &lt;- paste(runif(n=5), collapse='-')
ruler(aa)

## End(Not run)

</code></pre>

<hr>
<h2 id='save.wpix'>Save WPIX from swig output</h2><span id='topic+save.wpix'></span>

<h3>Description</h3>

<p>Save WPIX from swig output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save.wpix(KOUT, fn = "wpix.out")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save.wpix_+3A_kout">KOUT</code></td>
<td>
<p>List output from swig</p>
</td></tr>
<tr><td><code id="save.wpix_+3A_fn">fn</code></td>
<td>
<p>file name for saving.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes the output list from swig, specifically the WPX
component and writes a table to the file system.
This function is embedded in view.seis.
</p>


<h3>Value</h3>

<p>Side effects: file is created and appended to.
</p>


<h3>Note</h3>

<p>User must have write permission to the file.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>view.seis, swig</p>

<hr>
<h2 id='saveWPX'>Save WPX 
</h2><span id='topic+saveWPX'></span>

<h3>Description</h3>

<p>Save a WPX list to a file on the local file system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveWPX(twpx, destdir = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveWPX_+3A_twpx">twpx</code></td>
<td>
<p>WPX list
</p>
</td></tr>
<tr><td><code id="saveWPX_+3A_destdir">destdir</code></td>
<td>
<p>character, destination directory, default=getwd() 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a file with the list as in native
binary format.  This file can
be loaded with the standard load function in R.
The name of the file is 
created by using the minimum time extracted from the WPX list.
The suffix on the file name is RDATA.
When reading in, the object created is named &quot;twpx&quot;
for further processing.
</p>


<h3>Value</h3>

<p>Side effects on file system.  The name of the output file is returned.
</p>


<h3>Note</h3>

<p>User must have write access to the destination directory.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>addWPX,	catWPX,	checkWPX,	cleanWPX,	clusterWPX,	repairWPX,	setWPX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
tdir = tempdir()
s1 &lt;- setWPX(name="HI", yr=2011, jd=231, hr=4, mi=3, sec = runif(5)) 
hh &lt;- saveWPX(s1, destdir = tdir )

###   read in the data


load(hh)

data.frame(twpx)




## End(Not run)

</code></pre>

<hr>
<h2 id='scal2freqs'>Wavelet Frequency Scale</h2><span id='topic+scal2freqs'></span>

<h3>Description</h3>

<p>Get frequencies associated with the wavelet transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scal2freqs(octs, dt, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scal2freqs_+3A_octs">octs</code></td>
<td>
<p>number of octaves</p>
</td></tr>
<tr><td><code id="scal2freqs_+3A_dt">dt</code></td>
<td>
<p> sample rate, s </p>
</td></tr>
<tr><td><code id="scal2freqs_+3A_plot">plot</code></td>
<td>
<p>logical, TRUE=plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use morelet wavelet to estimate frequency from
wavelet transform.
</p>


<h3>Value</h3>

<p>frequency values
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>Mmorlet, fft</p>


<h3>Examples</h3>

<pre><code class='language-R'>noctave &lt;- 6
nvoice &lt;- 20
dt &lt;- 0.004
i1 &lt;- sort(rep(c(1:noctave), times=nvoice))
  jj &lt;- rep(c(0:(nvoice-1)), times=noctave)

  sa &lt;- 2^(i1+jj/nvoice)

  efs &lt;- scal2freqs(sa, dt)




</code></pre>

<hr>
<h2 id='screens'>screens</h2><span id='topic+screens'></span>

<h3>Description</h3>

<p>Open n devices for plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>screens(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="screens_+3A_n">n</code></td>
<td>
<p>number of devices required</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If k screens are open and k &gt;= n, nothing is done.
</p>


<h3>Value</h3>

<p>Graphical Side Effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>devices</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive() ) screens(2)
</code></pre>

<hr>
<h2 id='SEARCHPIX'>Search Pix</h2><span id='topic+SEARCHPIX'></span>

<h3>Description</h3>

<p>Search through pick strucutre to select phase arrivals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEARCHPIX(KPX, IPX, tol = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SEARCHPIX_+3A_kpx">KPX</code></td>
<td>
<p>user locator pix</p>
</td></tr>
<tr><td><code id="SEARCHPIX_+3A_ipx">IPX</code></td>
<td>
<p> set of pix in memory</p>
</td></tr>
<tr><td><code id="SEARCHPIX_+3A_tol">tol</code></td>
<td>
<p>tolerance, s</p>
</td></tr>
</table>


<h3>Details</h3>

<p>returns index vector of picks that satisfy:
wn = which(  abs(t2-t1) &lt; tol)
</p>


<h3>Value</h3>

<p>index vector
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: SEARCHPIX(KPX, IPX, tol = 0.5) 


</code></pre>

<hr>
<h2 id='secdif'>Return difference in seconds</h2><span id='topic+secdif'></span>

<h3>Description</h3>

<p>Difference between two Date/Times (Julian Day)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secdif(jd1, hr1, mi1, sec1, jd2, hr2, mi2, sec2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="secdif_+3A_jd1">jd1</code></td>
<td>
<p>Julian Day</p>
</td></tr>
<tr><td><code id="secdif_+3A_hr1">hr1</code></td>
<td>
<p>hour</p>
</td></tr>
<tr><td><code id="secdif_+3A_mi1">mi1</code></td>
<td>
<p>minute</p>
</td></tr>
<tr><td><code id="secdif_+3A_sec1">sec1</code></td>
<td>
<p>second</p>
</td></tr>
<tr><td><code id="secdif_+3A_jd2">jd2</code></td>
<td>
<p>Julian Day</p>
</td></tr>
<tr><td><code id="secdif_+3A_hr2">hr2</code></td>
<td>
<p> hour </p>
</td></tr>
<tr><td><code id="secdif_+3A_mi2">mi2</code></td>
<td>
<p> minute </p>
</td></tr>
<tr><td><code id="secdif_+3A_sec2">sec2</code></td>
<td>
<p>second</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns T2-T1.  Year is not included.
</p>


<h3>Value</h3>

<table>
<tr><td><code>numeric</code></td>
<td>
<p>seconds</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>secdifL </p>


<h3>Examples</h3>

<pre><code class='language-R'>T1 &lt;- list(jd=12, hr=13, mi=23, sec=21)
T2 &lt;- list(jd=14, hr=23, mi=23, sec=2)
secdif(T1$jd, T1$hr, T1$mi, T1$sec,  T2$jd, T2$hr, T2$mi, T2$sec)

</code></pre>

<hr>
<h2 id='secdifL'>Seconds Difference</h2><span id='topic+secdifL'></span>

<h3>Description</h3>

<p>Given two date/time lists, return seconds diffrence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secdifL(T1, T2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="secdifL_+3A_t1">T1</code></td>
<td>
<p>list(jd, hr, mi, sec)</p>
</td></tr>
<tr><td><code id="secdifL_+3A_t2">T2</code></td>
<td>
<p>list(jd, hr, mi, sec)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Year is not included in this calculation.
</p>


<h3>Value</h3>

<table>
<tr><td><code>numeric</code></td>
<td>
<p>seconds</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>secdif</p>


<h3>Examples</h3>

<pre><code class='language-R'>T1 &lt;- list(jd=12, hr=13, mi=23, sec=21)
T2 &lt;- list(jd=14, hr=23, mi=23, sec=2)
secdifL(T1, T2)


</code></pre>

<hr>
<h2 id='secdifv'>Seconds Difference</h2><span id='topic+secdifv'></span>

<h3>Description</h3>

<p>Given two date/time vectors, return seconds diffrence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secdifv(T1, T2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="secdifv_+3A_t1">T1</code></td>
<td>
<p>c(jd, hr, mi, sec)</p>
</td></tr>
<tr><td><code id="secdifv_+3A_t2">T2</code></td>
<td>
<p>c(jd, hr, mi, sec)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Year is not included in this calculation.
</p>


<h3>Value</h3>

<table>
<tr><td><code>numeric</code></td>
<td>
<p>seconds</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>secdif</p>


<h3>Examples</h3>

<pre><code class='language-R'>T1 &lt;- c(12, 13, 23, 21)
T2 &lt;- c(14, 23, 23, 2)
secdifv(T1, T2)


</code></pre>

<hr>
<h2 id='segy2rseis'>Read in multiple segy files.
</h2><span id='topic+segy2rseis'></span><span id='topic+sac2rseis'></span>

<h3>Description</h3>

<p>Read in multiple segy files,
and create a list of seismic traces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segy2rseis(fnames, Iendian = 1, HEADONLY = FALSE, BIGLONG = FALSE, PLOT
= -1, RAW = FALSE)
sac2rseis(fnames, Iendian = 1, HEADONLY = FALSE,
BIGLONG = FALSE, PLOT = -1, RAW = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segy2rseis_+3A_fnames">fnames</code></td>
<td>
<p>character vector of file names.
</p>
</td></tr>
<tr><td><code id="segy2rseis_+3A_iendian">Iendian</code></td>
<td>
<p>Endian-ness of the files
</p>
</td></tr>
<tr><td><code id="segy2rseis_+3A_headonly">HEADONLY</code></td>
<td>
<p>logical, TRUE=read only the header information. default=FALSE
</p>
</td></tr>
<tr><td><code id="segy2rseis_+3A_biglong">BIGLONG</code></td>
<td>
<p>logical, indicating whether long is 8 or 4 bytes.
</p>
</td></tr>
<tr><td><code id="segy2rseis_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE = plot traces 
</p>
</td></tr>
<tr><td><code id="segy2rseis_+3A_raw">RAW</code></td>
<td>
<p>logical, TRUE=do not convert data to volts
</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Segy format files are in integer format.
The time series ususally represents counts
recorded in a data acquisition system.  The header includes
meta-data and other identifying information.
</p>


<h3>Value</h3>

<p>List of seismic traces.
</p>


<h3>Note</h3>

<p>The Endian-ness of the input files is set by
the system that created them.
If the read1segy or read1sac does not make sense,
try a different endian or BIGLONG setting.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>read1sac, read1segy, sac2rseis, prepSEIS
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

fnames =
list.files(path="./SEISMIC_DATA/KARYMSKY/1999/kar99/Day254",
pattern="", full.names=TRUE )

MANY = segy2rseis(fnames, Iendian=1 , HEADONLY=FALSE,
    BIGLONG=FALSE,  PLOT=1, RAW=FALSE )



## End(Not run)

</code></pre>

<hr>
<h2 id='SEIS2list'>Convert a SEIS list to a list of seismograms
</h2><span id='topic+SEIS2list'></span>

<h3>Description</h3>

<p>Convert a SEIS list to a list of seismograms each
independent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEIS2list(GH)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SEIS2list_+3A_gh">GH</code></td>
<td>
<p>SEIS list (swig input)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list returned is useful for editing
or modifying the seismic data prior to swig.
</p>


<h3>Value</h3>

<p>List of seismograms.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>plotGH, swig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(GH)
gg = SEIS2list(GH)
for(i in 1:length(gg) )
{
plotGH(gg[[i]]); Sys.sleep(0.2) 
}



## End(Not run)



</code></pre>

<hr>
<h2 id='seiscols'>Set colors for seismic display</h2><span id='topic+seiscols'></span>

<h3>Description</h3>

<p>Given an RSEIS list of seismic data return a set of
colors associated with the structure that colors each trace
and its components the same color.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seiscols(GH, acols="black", M="STNS")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seiscols_+3A_gh">GH</code></td>
<td>
<p>Seismic RSEIS list</p>
</td></tr>
<tr><td><code id="seiscols_+3A_acols">acols</code></td>
<td>
<p>vector of colors to choose from</p>
</td></tr>
<tr><td><code id="seiscols_+3A_m">M</code></td>
<td>
<p>character, &quot;STNS&quot; = stations, &quot;COMPS&quot; = components</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>colors</code></td>
<td>
<p>alpha/numeric vector of colors  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(GH)

GH$pcol &lt;- seiscols(GH)
swig(GH, sel=which(GH$COMPS=="V"),    WIN=c(3, 10), SHOWONLY=TRUE)

xcol &lt;-  seiscols(GH, acols=c("black", "darkmagenta", "forestgreen") )

GH$pcol &lt;- xcol

swig(GH, sel=which(GH$COMPS=="V"), , SHOWONLY=TRUE)


</code></pre>

<hr>
<h2 id='SEISNtime'>Minimum time in an RSEIS list</h2><span id='topic+SEISNtime'></span>

<h3>Description</h3>

<p>Return date/time of trace with earliest date/time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEISNtime(GH)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SEISNtime_+3A_gh">GH</code></td>
<td>
<p>RSEIS seismic list</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>yr</code></td>
<td>
<p>year</p>
</td></tr>
<tr><td><code>jd</code></td>
<td>
<p>julian day</p>
</td></tr>
<tr><td><code>hr</code></td>
<td>
<p>hour</p>
</td></tr>
<tr><td><code>mi</code></td>
<td>
<p>minute</p>
</td></tr>
<tr><td><code>sec</code></td>
<td>
<p>second</p>
</td></tr>
<tr><td><code>w1</code></td>
<td>
<p>which one, index to GH</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(GH)
SEISNtime(GH)


</code></pre>

<hr>
<h2 id='seisorder'>Order seismic traces</h2><span id='topic+seisorder'></span>

<h3>Description</h3>

<p>Use RSEIS structure to get convenient ordering of seismic data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seisorder(GH, ORD, VNE = c("V", "N", "E"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seisorder_+3A_gh">GH</code></td>
<td>
<p>RSEIS list</p>
</td></tr>
<tr><td><code id="seisorder_+3A_ord">ORD</code></td>
<td>
<p>predetermined ordering, list(name, dist)</p>
</td></tr>
<tr><td><code id="seisorder_+3A_vne">VNE</code></td>
<td>
<p>Order, for components, default=c(&quot;V&quot;, &quot;N&quot;, &quot;E&quot;) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses information aboutthe location of the stations
to determine appropriate order.  Order can be determined from the
location of the stations, or from the travel times.
</p>


<h3>Value</h3>

<p>Vector of indeces of GH in correct order
</p>


<h3>Note</h3>

<p>If ORD is provided from travel times, it uses this instead
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>JGET.seis</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(GH)
staf &lt;- GH$stafile

################   get the distances from the source to the stations
d1  &lt;- GreatDist(GH$pickfile$LOC$lon, GH$pickfile$LOC$lat,
              staf$lon, staf$lat)

###  staf has the names of the stations already, so insert the order via
###                       dist
staf$dist &lt;- d1$dkm

sorder &lt;- seisorder(GH, staf, VNE= c("V", "N", "E"))

## Not run: 
swig(GH, sel=sorder)

## End(Not run)

</code></pre>

<hr>
<h2 id='selAPX'>Select Picks</h2><span id='topic+selAPX'></span><span id='topic+selWPX'></span>

<h3>Description</h3>

<p>select a subset of picks from a larger data base
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selAPX(APX, ista = NULL, icomp = c("V", "N", "E"))
selWPX(APX, ind=NULL, ista = NULL, icomp = c("V", "N", "E"))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selAPX_+3A_apx">APX</code></td>
<td>
<p>Pick Data Frame</p>
</td></tr>
<tr><td><code id="selAPX_+3A_ista">ista</code></td>
<td>
<p>vector of stations to select</p>
</td></tr>
<tr><td><code id="selAPX_+3A_icomp">icomp</code></td>
<td>
<p>vector of components</p>
</td></tr>
<tr><td><code id="selAPX_+3A_ind">ind</code></td>
<td>
<p>index of picks to select (negitive values imply omission) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns subset list 
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>

<hr>
<h2 id='SELBUT'>Select Buttons
</h2><span id='topic+SELBUT'></span>

<h3>Description</h3>

<p>Select buttons interactively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SELBUT(OPTS, onoff = 1, ocols = "white", default = "opt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SELBUT_+3A_opts">OPTS</code></td>
<td>
<p>character list of buttons
</p>
</td></tr>
<tr><td><code id="SELBUT_+3A_onoff">onoff</code></td>
<td>
<p>which buttons are active
</p>
</td></tr>
<tr><td><code id="SELBUT_+3A_ocols">ocols</code></td>
<td>
<p>colors for plotting
</p>
</td></tr>
<tr><td><code id="SELBUT_+3A_default">default</code></td>
<td>
<p>default list of buttons
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used in swig.
OPtions can be added, subtracted, deleted, or completely
filled out based on interactive choice.
</p>


<h3>Value</h3>

<p>character list of chosen options.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>swig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
STDLAB &lt;- c("DONE", "QUIT", "zoom.out", "zoom.in", "SELBUT",
"FILT","UNFILT", "PSEL", "SGRAM", "WLET", "SPEC", "XTR" )
onoff = rep(0, length(STDLAB))
onoff[1:5] &lt;- 1
SELBUT(STDLAB, onoff=onoff)


## End(Not run)

</code></pre>

<hr>
<h2 id='selpgen'>Pick stations and components
interactively
</h2><span id='topic+selpgen'></span>

<h3>Description</h3>

<p>Pick stations and components
interactively.  This is a routine
used in swig.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selpgen(MH, newdev = TRUE, STAY = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selpgen_+3A_mh">MH</code></td>
<td>
<p>RSEIS list
</p>
</td></tr>
<tr><td><code id="selpgen_+3A_newdev">newdev</code></td>
<td>
<p>logical, whether
to create a new device.
</p>
</td></tr>
<tr><td><code id="selpgen_+3A_stay">STAY</code></td>
<td>
<p>logical, whether
to keep device active.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of index to list of stations and components
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>swig
</p>

<hr>
<h2 id='SELSTA'>Pick stations and components
interactively
</h2><span id='topic+SELSTA'></span>

<h3>Description</h3>

<p>Pick stations and components
interactively.  This is a routine
used in swig.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SELSTA(GH, sel=1,  newdev = TRUE, STAY = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SELSTA_+3A_gh">GH</code></td>
<td>
<p>RSEIS list
</p>
</td></tr>
<tr><td><code id="SELSTA_+3A_sel">sel</code></td>
<td>
<p>vector of index to selected traces
</p>
</td></tr>
<tr><td><code id="SELSTA_+3A_newdev">newdev</code></td>
<td>
<p>logical, whether
to create a new device.
</p>
</td></tr>
<tr><td><code id="SELSTA_+3A_stay">STAY</code></td>
<td>
<p>logical, whether
to keep device active.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of index to list of stations and components
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>swig</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GH)

SELSTA(GH, sel=1:7 , newdev = TRUE, STAY = FALSE)

</code></pre>

<hr>
<h2 id='selstas'>Select Stations
</h2><span id='topic+selstas'></span>

<h3>Description</h3>

<p>Extract a set of stations from a
longer station file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selstas(sta, ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selstas_+3A_sta">sta</code></td>
<td>
<p>station list (name, lat, lon, z)
</p>
</td></tr>
<tr><td><code id="selstas_+3A_ind">ind</code></td>
<td>
<p>index to station list = positive is select, negative is remove
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> station list with those indeces either removed or save.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>

<hr>
<h2 id='SENSORsensitivity'>Sensor Sensitivity from a known set of seismo/acoustic sensor</h2><span id='topic+SENSORsensitivity'></span>

<h3>Description</h3>

<p>From published sensitivities of seismic and acoustic sensors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SENSORsensitivity(K = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SENSORsensitivity_+3A_k">K</code></td>
<td>
<p>number of sensor from list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sensitivity
</p>


<h3>Note</h3>

<p>Current choices are:
c(&quot;40T&quot;, &quot;3T&quot;,  &quot;L28&quot;, &quot;LD&quot;,    &quot;EL&quot;, &quot;MC&quot;, &quot;EL(SANGAY)&quot;)
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>References</h3>

<p>Johnson, J.B., R.C. Aster, M.C. Ruiz, S.D. Malone,
P.J. McChesney,J.M. Lees, and P.R. Kyle, Interpretation and utility of
infrasonic records from erupting volcanoes, J. Volc. Geoth. Res., 121 (1-2), 15-63, 2003. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SENSORsensitivity(3)
SENSORsensitivity(5)

</code></pre>

<hr>
<h2 id='setPrePix'>Set list of arrival times for swig.
</h2><span id='topic+setPrePix'></span>

<h3>Description</h3>

<p>Prepare a set of arrival picks for swig plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPrePix(R1, tt, name, flag = "K", col = "blue")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPrePix_+3A_r1">R1</code></td>
<td>
<p>Location and time of event source. (list)
</p>
</td></tr>
<tr><td><code id="setPrePix_+3A_tt">tt</code></td>
<td>
<p>Vector of travel times, seconds.
</p>
</td></tr>
<tr><td><code id="setPrePix_+3A_name">name</code></td>
<td>
<p>Station names
</p>
</td></tr>
<tr><td><code id="setPrePix_+3A_flag">flag</code></td>
<td>
<p>Phase Identifier, character
</p>
</td></tr>
<tr><td><code id="setPrePix_+3A_col">col</code></td>
<td>
<p>Color
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> List of picks suitable for swig plotting.
</p>


<h3>Note</h3>

<p>R1 should have yr, jp, hr, mi, sec at the least.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>setWPX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
T1 = as.POSIXct("2020-08-20 06:30:17.15 UTC", "UTC")

     R1 = posix2RSEIS(T1)

name = c("MERT", "KRN", "KUA")
tt = c(1,2,3)
wpx = setPrePix(R1, tt, name, flag = "K", col = "blue") 


</code></pre>

<hr>
<h2 id='setstas'>Set Station information</h2><span id='topic+setstas'></span>

<h3>Description</h3>

<p>Read station information and set in list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setstas(stafile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setstas_+3A_stafile">stafile</code></td>
<td>
<p>character, station file name path</p>
</td></tr>
</table>


<h3>Details</h3>

<p>reads in ASCII data file.
</p>


<h3>Value</h3>

<p>LIST
</p>
<table>
<tr><td><code>name</code></td>
<td>
<p>character, station name</p>
</td></tr>
<tr><td><code>lat</code></td>
<td>
<p>numeric, decimal degrees</p>
</td></tr>
<tr><td><code>lon</code></td>
<td>
<p>numeric, decimal degrees</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>numeric, decimal degrees</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
sta &lt;- setstas("/pathto/stationfile")

## End(Not run)
</code></pre>

<hr>
<h2 id='setupDB'>Set up a seismic data base
</h2><span id='topic+setupDB'></span>

<h3>Description</h3>

<p>Set up a data base storing the location
and times for a set of seismic data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setupDB(DB, token = TRUE, split = "\\.")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setupDB_+3A_db">DB</code></td>
<td>


<dl>
<dt>fn</dt><dd><p>full path to file</p>
</dd>
<dt>yr</dt><dd><p>year</p>
</dd>
<dt>jd</dt><dd><p>julian day</p>
</dd>
<dt>hr</dt><dd><p>hour</p>
</dd>
<dt>mi</dt><dd><p>minute</p>
</dd>
<dt>sec</dt><dd><p>second</p>
</dd>
<dt>dur</dt><dd><p>duration, seconds</p>
</dd>
<dt>origyr</dt><dd><p>origin time for epoch calculations</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="setupDB_+3A_token">token</code></td>
<td>
<p>logical, use tokens in the file names of the fn's to
extract station and component names for selection. default=TRUE
</p>
</td></tr>
<tr><td><code id="setupDB_+3A_split">split</code></td>
<td>
<p> character string to split if using token,
default is a period.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If token is FALSE, then the station name and component
are selected using substr, i.e. by column number.
</p>


<h3>Value</h3>

<p>DB with epoch time and station information appended,
</p>
<table>
<tr><td><code>t1</code></td>
<td>
<p>epoch start time  </p>
</td></tr>
<tr><td><code>t2</code></td>
<td>
<p>expoch end time  = t1+nsamps*sample rate n seconds</p>
</td></tr>
<tr><td><code>sta</code></td>
<td>
<p>station</p>
</td></tr>
<tr><td><code>comp</code></td>
<td>
<p>component</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Program attaches station identification used for grepping. 
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>EPOCHday, T12.pix, Mine.seis</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

###  location of data base file
datadir1  &lt;-  '/home/lees/Site/Santiaguito/SG09'
d1  &lt;-  'segyDB'
#### scan in the data base file
DB  &lt;-  scan(file=paste(sep="/", datadir1, d1), list(fn="", yr=0, jd=0,
hr=0, mi=0, sec=0, dur=0))
#### interactively fix the DB list
DB  &lt;-  setupDB(DB)



## End(Not run)




</code></pre>

<hr>
<h2 id='setwelch'>Set up Matrix of fft for Welch method</h2><span id='topic+setwelch'></span>

<h3>Description</h3>

<p>Prepares a matrix for estimation of power spectrum via Welch's method.
Also, is can be used for spectrogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setwelch(X, win = min(80, floor(length(X)/10)),
inc = min(24, floor(length(X)/30)), coef = 64, wintaper=0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setwelch_+3A_x">X</code></td>
<td>
<p>Time series vector</p>
</td></tr>
<tr><td><code id="setwelch_+3A_win">win</code></td>
<td>
<p>window length</p>
</td></tr>
<tr><td><code id="setwelch_+3A_inc">inc</code></td>
<td>
<p>increment</p>
</td></tr>
<tr><td><code id="setwelch_+3A_coef">coef</code></td>
<td>
<p>coefficient for fft</p>
</td></tr>
<tr><td><code id="setwelch_+3A_wintaper">wintaper</code></td>
<td>
<p>percent taper window taper</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>values</code></td>
<td>
<p>Matrix of fft's staggered along the trace</p>
</td></tr>
<tr><td><code>windowsize</code></td>
<td>
<p>window length used</p>
</td></tr>
<tr><td><code>increment</code></td>
<td>
<p>increment used</p>
</td></tr>
<tr><td><code>wintaper</code></td>
<td>
<p>percent taper window taper</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>originally written by Andreas Weingessel, modified Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>Welch, P.D. (1967) The use of Fast Fourier Transform for the estimation of power spectra:
a method based on time averaging over short, modified periodograms IEEE Trans. Audio
Electroacoustics 15, 70-73. 
</p>


<h3>See Also</h3>

<p>stft</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  
dt &lt;- 0.001

 t &lt;- seq(0, 6, by=dt)
x &lt;- 6*sin(2*pi*50*t) + 10* sin(2*pi*120*t)
 y &lt;- x + rnorm(length(x), mean=0, sd=10)

plot(t,y, type='l')

title('sin(2*pi*50*t) + sin(2*pi*120*t)+ rnorm')

Y &lt;- fft(y)

Pyy &lt;- Y * Conj(Y)

N &lt;- length(y)

n &lt;- length(Pyy)/2

Syy &lt;- (Mod(Pyy[1:n])^2)/N

fn &lt;- 1/(2*dt)


f &lt;- (0:(length(Syy)-1))*fn/length(Syy)

plot(f, Syy, type='l', log='y' , xlim=c(0, 150));
abline(v=c(50, 120),col='blue', lty=2)


plot(f, Syy, type='l', log='y' , xlim=c(0, 150));
abline(v=c(50, 120),col='blue', lty=2)


win &lt;- 1024

inc &lt;- min(24, floor(length(y)/30))
coef &lt;- 2048


 w &lt;- setwelch(y, win=win, inc=inc, coef=coef, wintaper=0.2)

    KK &lt;- apply(w$values, 2, FUN="mean")


fw &lt;- seq(from=0, to=0.5, length=coef)/(dt)

plot(fw, KK^2, log='', type='l' , xlim=c(0, 150)) ;
abline(v=c(50, 120), col='blue', lty=2)


Wyy &lt;- (KK^2)/w$windowsize
plot(f, Syy, type='l', log='y' , xlim=c(0, 150))
lines(fw,Wyy , col='red')


DBSYY &lt;- 20*log10(Syy/max(Syy))
DBKK &lt;- 20*log10(Wyy/max(Wyy))


plot(f, DBSYY, type='l' , xlim=c(0, 150), ylab="Db", xlab="Hz")

lines(fw, DBKK, col='red')
title("Compare simple periodogam with Welch's Method")



</code></pre>

<hr>
<h2 id='setwpix'>Set Window Pix for swig</h2><span id='topic+setwpix'></span>

<h3>Description</h3>

<p>Create list of windows picks suitable for plotting in
swig.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setwpix(phase = NULL, col = NULL, yr = NULL, jd = NULL,
hr = NULL, mi = NULL, sec = NULL, dur = NULL, name = NULL,
 comp = NULL, dispcomp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setwpix_+3A_phase">phase</code></td>
<td>
<p>phase name</p>
</td></tr>
<tr><td><code id="setwpix_+3A_col">col</code></td>
<td>
<p>color for plotting</p>
</td></tr>
<tr><td><code id="setwpix_+3A_yr">yr</code></td>
<td>
<p>year</p>
</td></tr>
<tr><td><code id="setwpix_+3A_jd">jd</code></td>
<td>
<p>julian day</p>
</td></tr>
<tr><td><code id="setwpix_+3A_hr">hr</code></td>
<td>
<p>hour</p>
</td></tr>
<tr><td><code id="setwpix_+3A_mi">mi</code></td>
<td>
<p>minute</p>
</td></tr>
<tr><td><code id="setwpix_+3A_sec">sec</code></td>
<td>
<p>second</p>
</td></tr>
<tr><td><code id="setwpix_+3A_dur">dur</code></td>
<td>
<p>duration</p>
</td></tr>
<tr><td><code id="setwpix_+3A_name">name</code></td>
<td>
<p>name of station</p>
</td></tr>
<tr><td><code id="setwpix_+3A_comp">comp</code></td>
<td>
<p>component</p>
</td></tr>
<tr><td><code id="setwpix_+3A_dispcomp">dispcomp</code></td>
<td>
<p>display on which component </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some phases should be displayed on only certain components of a station.
</p>


<h3>Value</h3>

<p>list of window picks
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>swig</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(KH)

orgtim &lt;- c( 2005,214,7,1,10.7313152551651 )
tims &lt;- c( 0,46.7119,102.438451,113.092049,123.54077 )
psecs  &lt;-  NULL
nam  &lt;-  NULL

aphases  &lt;- NULL
sta  &lt;- "9024"


for(j in 1:length(tims))
{
psecs  &lt;-  c(psecs, tims[j]+orgtim[5])
nam  &lt;-  c(nam, sta)
aphases  &lt;-  c(aphases, paste(sep="", "K", j) )
}


pp  &lt;-  setwpix(phase=aphases , col="blue", yr=orgtim[1], jd=orgtim[2],
hr=orgtim[3],  mi=orgtim[4], sec=psecs, dur=0, name=nam , comp="V")



W  &lt;-  secdifL(KH$info, pp)

win  &lt;-  c(min(W)-5, max(W)+5    )  
 swig(KH, APIX=pp, WIN=win , SHOWONLY=TRUE)


</code></pre>

<hr>
<h2 id='setWPX'>Set WPX
</h2><span id='topic+setWPX'></span>

<h3>Description</h3>

<p>Create a WPX list from vector input
or relavent parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setWPX(phase = NULL, col = NULL, yr = NULL, jd = NULL,
hr = NULL, mi = NULL, sec = NULL, dur = NULL, name = NULL,
comp = NULL, dispcomp = NULL, onoff = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setWPX_+3A_phase">phase</code></td>
<td>
<p>character, phase names
</p>
</td></tr>
<tr><td><code id="setWPX_+3A_col">col</code></td>
<td>
<p>character, colors
</p>
</td></tr>
<tr><td><code id="setWPX_+3A_yr">yr</code></td>
<td>
<p>numeric, year
</p>
</td></tr>
<tr><td><code id="setWPX_+3A_jd">jd</code></td>
<td>
<p>numeric, julian day
</p>
</td></tr>
<tr><td><code id="setWPX_+3A_hr">hr</code></td>
<td>
<p>numeric, hour
</p>
</td></tr>
<tr><td><code id="setWPX_+3A_mi">mi</code></td>
<td>
<p>numeric, minute
</p>
</td></tr>
<tr><td><code id="setWPX_+3A_sec">sec</code></td>
<td>
<p>numeric, second
</p>
</td></tr>
<tr><td><code id="setWPX_+3A_dur">dur</code></td>
<td>
<p>numeric, duration(s)
</p>
</td></tr>
<tr><td><code id="setWPX_+3A_name">name</code></td>
<td>
<p>character, station name
</p>
</td></tr>
<tr><td><code id="setWPX_+3A_comp">comp</code></td>
<td>
<p>character, component
</p>
</td></tr>
<tr><td><code id="setWPX_+3A_dispcomp">dispcomp</code></td>
<td>
<p>character, display string
</p>
</td></tr>
<tr><td><code id="setWPX_+3A_onoff">onoff</code></td>
<td>
<p>numeric, flag for turning pick on or off
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Utility for setting up a WPX list for further
processing.
</p>


<h3>Value</h3>

<p>WPX list.
</p>


<h3>Note</h3>

<p>Used internally.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>addWPX,	catWPX,	checkWPX,	cleanWPX,	clusterWPX,	repairWPX,	saveWPX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
s1 &lt;- setWPX(name="HI", yr=2011, jd=231, hr=4, mi=3, sec = runif(5)) 


</code></pre>

<hr>
<h2 id='setypx'>Create an empty window pick list</h2><span id='topic+setypx'></span>

<h3>Description</h3>

<p>Create an empty window pick list.  This is used primarily internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setypx()
</code></pre>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>tag</code></td>
<td>
<p>tag for identification of station and component</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>station name</p>
</td></tr>
<tr><td><code>comp</code></td>
<td>
<p>component name</p>
</td></tr>
<tr><td><code>c3</code></td>
<td>
<p>compnent name with secondary tags</p>
</td></tr>
<tr><td><code>phase</code></td>
<td>
<p>phase</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>error</p>
</td></tr>
<tr><td><code>pol</code></td>
<td>
<p>polarity</p>
</td></tr>
<tr><td><code>flg</code></td>
<td>
<p>flag</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>residual</p>
</td></tr>
<tr><td><code>dur</code></td>
<td>
<p>duration</p>
</td></tr>
<tr><td><code>yr</code></td>
<td>
<p>year</p>
</td></tr>
<tr><td><code>mo</code></td>
<td>
<p>month</p>
</td></tr>
<tr><td><code>dom</code></td>
<td>
<p>day of month</p>
</td></tr>
<tr><td><code>jd</code></td>
<td>
<p>julian day</p>
</td></tr>
<tr><td><code>hr</code></td>
<td>
<p>hour</p>
</td></tr>
<tr><td><code>mi</code></td>
<td>
<p>minute</p>
</td></tr>
<tr><td><code>sec</code></td>
<td>
<p>second</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code>onoff</code></td>
<td>
<p>logical, ON or OFF for plotting</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>setwpix</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- setypx()

print(a)

</code></pre>

<hr>
<h2 id='showdatetime'>Print Date/TIME</h2><span id='topic+showdatetime'></span>

<h3>Description</h3>

<p>Print Date and Time as yyyy-mo-do hr:mi:se msec
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showdatetime(rd, AMPM = FALSE, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showdatetime_+3A_rd">rd</code></td>
<td>
<p> date time list, jd  hr  mi sec yr </p>
</td></tr>
<tr><td><code id="showdatetime_+3A_ampm">AMPM</code></td>
<td>
<p>24 hour time (AMPM=FALSE) or 12 hour clock (AMPM=TRUE)  </p>
</td></tr>
<tr><td><code id="showdatetime_+3A_verbose">verbose</code></td>
<td>
<p>logical, print information to screen, default=TRUE
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>hrs &lt;- seq(from=-36, to=36, by=2)

rd &lt;- recdate(jd=1, hr=hrs, mi=34,
         sec=23+runif(n=length(hrs), 0, 59) , yr=2009)

showdatetime(rd)

showdatetime(rd, AMPM=TRUE)


</code></pre>

<hr>
<h2 id='sigconv'>Convolve spikes with wavelets
</h2><span id='topic+sigconv'></span>

<h3>Description</h3>

<p>Convolve spikes with wavelets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigconv(wigmat, wavepulse)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigconv_+3A_wigmat">wigmat</code></td>
<td>
<p>matrix, spikes
</p>
</td></tr>
<tr><td><code id="sigconv_+3A_wavepulse">wavepulse</code></td>
<td>
<p>wavelet for convolution
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convolution is done in Frequency domain on each trace
</p>


<h3>Value</h3>

<p>Matrix, waveforms
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>wiggleimage, symshot1, genrick
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S1 &lt;- symshot1()

##############   S1$THEORY$treflex

d &lt;- dim(S1$smograms)
G1 &lt;- matrix( rep(0, length=d[1]*d[2]), ncol=d[2], nrow=d[1])

############   set up the spike set for reflexions
for(i in 1:3){
p &lt;- round( S1$THEORY$treflex[i,]/S1$dt );

G1[cbind(p , 1:d[2])  ] &lt;- 1

}

#### plot the spikes
wiggleimage(0.1*G1, dt = -S1$dt, dx = S1$x, col = "black")

###  make a ricker wavelet
wavelet &lt;- genrick(25,S1$dt,35)
klem &lt;- 11
### 
nwave &lt;- RPMG::RESCALE(wavelet, 0, 1, wavelet[1], max(wavelet))

##############  convolve the wavelet with the set of spikes
H1 &lt;- sigconv(G1, nwave)

############  plot
wiggleimage(0.1*H1, dt = -S1$dt, dx = S1$x, col = "black")


</code></pre>

<hr>
<h2 id='sigconvGR'>convolve for Ground roll
</h2><span id='topic+sigconvGR'></span>

<h3>Description</h3>

<p>convolve a set of spikes
for extended ground roll.  This is a special case of sigconv.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigconvGR(wigmat, wavepulse, dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigconvGR_+3A_wigmat">wigmat</code></td>
<td>
<p>matrix of traces with spikes
</p>
</td></tr>
<tr><td><code id="sigconvGR_+3A_wavepulse">wavepulse</code></td>
<td>
<p>wavelet
</p>
</td></tr>
<tr><td><code id="sigconvGR_+3A_dt">dt</code></td>
<td>
<p>sampling interval
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is similar to the sigconv program but it
assumes that the ground roll is extrened in time and space as the wave
expands.
</p>


<h3>Value</h3>

<p>Matrix, waveforms
</p>


<h3>Note</h3>

<p>the program spreads the sinusoidal wavelet along a band to
simulate ground-roll
head wave noise.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>wiggleimage, symshot1, genrick, sigconv
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
S1 &lt;- symshot1()
dt &lt;- S1$dt
###########    these are the reflections S1$GRrec

d &lt;- dim(S1$smograms)
G1 &lt;- matrix( rep(0, length=d[1]*d[2]), ncol=d[2], nrow=d[1])

###   these are the refractions S1$THEORY$trefrac
p &lt;- round( S1$THEORY$trefrac[1,]/S1$dt );
G1[cbind(p , 1:d[2])  ] &lt;- 1


#### plot the spikes
wiggleimage(0.1*G1, dt = -S1$dt, dx = S1$x, col = "black")

grlen &lt;- floor(.6/dt)
fgr &lt;- 10
tape &lt;- applytaper( rep(1, grlen), p = 0.2)
tgr &lt;- seq(from=0, by=dt, length=grlen)
siggr &lt;- tape*sin(2*pi*fgr*tgr)

##############  convolve the wavelet with the set of spikes
H1 &lt;- sigconvGR(G1, siggr, dt)

############  plot
wiggleimage(0.1*H1, dt = -S1$dt, dx = S1$x, col = "black")

</code></pre>

<hr>
<h2 id='SNET.drive'>stereonet representation of particle motion</h2><span id='topic+SNET.drive'></span>

<h3>Description</h3>

<p>stereonet representation of particle motion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SNET.drive(intempmat, pmolabs = c("Vertical", "North", "East"), STAMP = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SNET.drive_+3A_intempmat">intempmat</code></td>
<td>
<p>matrix of 3-component seismogram</p>
</td></tr>
<tr><td><code id="SNET.drive_+3A_pmolabs">pmolabs</code></td>
<td>
<p>labels for components</p>
</td></tr>
<tr><td><code id="SNET.drive_+3A_stamp">STAMP</code></td>
<td>
<p>Identification stamp </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Interactive driver for partmotnet.
</p>


<h3>Value</h3>

<p>Graphical Side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>partmotnet</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data("GH")

temp  &lt;-  cbind(GH$JSTR[[1]], GH$JSTR[[2]], GH$JSTR[[3]])

atemp  &lt;- temp[1168:1500, ]
SNET.drive(atemp, pmolabs = c("Vertical", "North", "East"), STAMP = "")

</code></pre>

<hr>
<h2 id='SPECT.drive'>Interactive Spectrogram Driver</h2><span id='topic+SPECT.drive'></span>

<h3>Description</h3>

<p>Interactive Spectrogram Driver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPECT.drive(Xamp, DT = 0.008, NEW = TRUE, STAMP = NULL ,
 freqlim=c(0, 20, 0, 20), winparams=c(4096,256, 204 ))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SPECT.drive_+3A_xamp">Xamp</code></td>
<td>
<p>signal trace</p>
</td></tr>
<tr><td><code id="SPECT.drive_+3A_dt">DT</code></td>
<td>
<p>deltaT sample interval, s</p>
</td></tr>
<tr><td><code id="SPECT.drive_+3A_new">NEW</code></td>
<td>
<p>logical, TRUE=recalculate spectrum</p>
</td></tr>
<tr><td><code id="SPECT.drive_+3A_stamp">STAMP</code></td>
<td>
<p>character stamp for identification</p>
</td></tr>
<tr><td><code id="SPECT.drive_+3A_freqlim">freqlim</code></td>
<td>
<p>vector of 4 frequency limits: min max for calculations,
min max for display.  Default=see below </p>
</td></tr>
<tr><td><code id="SPECT.drive_+3A_winparams">winparams</code></td>
<td>
<p>vector of 3 window parameters: Number of points for
FFT, number of time samples for window, number of overlap samples:
default=see below </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Interactive buttons are set internally.  The parameters freqlim and
winparams can be changed - these are simply the starting parameters
for the initial display.
</p>
<p>For winparams, the parameters are set to be appropriate
for sample rates of typical seismic data, 100-125 samples per second.
The number of points in the FFT are initially set to 4096 and the time
window is set to 256.  The overlap is calculated by subtracting 20
percent of the time
window, so the overlap is 80 percent.
Of course, the number of samples in a window must be less than the
length of input time series.
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>plotevol, RPMG</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CE1)

#########  Xamp = CE1$y[CE1$x&gt;5.443754 &amp; CE1$x&lt;5.615951]

Xamp = CE1$y
plot(Xamp, type='l')


DT = CE1$dt

if(interactive() ) SPECT.drive(Xamp, DT = DT, NEW = TRUE, STAMP = NULL)

## Not run: 
data(KH)

Xamp  &lt;-  KH$JSTR[[1]]
DT  &lt;-   KH$dt[1]
SPECT.drive(Xamp, DT = DT, NEW = TRUE, STAMP = NULL)

SPECT.drive(Xamp, DT = DT, NEW = FALSE, STAMP = NULL,
freqlim=c(0, 8,0, 8) , winparams=c(4*1024, 6*250, 6*250-1) )




TWIN  &lt;-  100 # seconds
NWIN  &lt;-  TWIN/DT  # samples
NSKIP  &lt;-  1/DT    ##  samples


SPECT.drive(Xamp, DT = DT, NEW = FALSE,
 STAMP = NULL, freqlim=c(0, 8,0, 8) ,
winparams=c(8*1024, NWIN, NWIN-NSKIP) )





## End(Not run)


</code></pre>

<hr>
<h2 id='Spectrum'>Calculate Different Spectrum Types in Physical Units</h2><span id='topic+Spectrum'></span>

<h3>Description</h3>

<p>Spectrum is a wrapper function for stats::fft and
RSEIS::mtapspec. For a given method (multi-taper spectrum or fft
spectrum) and spectrum type (power, energy, amplitude, or phase), it
returns the spectrum in physical units (obeying Parseval's theorem)
and the corresponding frequency axis.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Spectrum(x, dt, one_sided = TRUE, type = 1, method = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Spectrum_+3A_x">x</code></td>
<td>
<p>Time series for which a spectrum is to be calculated (assumed
to be in volts)</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_dt">dt</code></td>
<td>
<p>Sample interval for x (assumed to be in seconds)</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_one_sided">one_sided</code></td>
<td>
<p>Logical: should the spectrum be a function of
positive frequencies only (f &lt; nyquist frequency) and spectral
density doubled to be consistent with that (TRUE, default), or
should the spectrum be provided for all frequencies, positive and
negative?</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_type">type</code></td>
<td>
<p>Type of spectrum: 1 (default) is power spectrum; 2 is
energy spectrum; 3 is amplitude spectrum; 4 is phase spectrum</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_method">method</code></td>
<td>
<p>Method used to calculate spectrum. 1 (default) is fft; 2
is multi-taper.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Phase spectrum is currently enabled only for method = 1 (fft). All
possible energy and power spectra obey Parseval's relation (sum(s)*df
~= mean(x^2) for power; sum(s)*df ~= sum(x^2)*dt for
energy). Parseval's relation may not be exact due to approximations
used in making the spectrum one-sided or in the multi-taper method.
</p>
<p>Input units are assumed to be volts and seconds; if other input units
are used, adjust output units accordingly.
</p>


<h3>Value</h3>

<p>List with following elements.
</p>
<table>
<tr><td><code>f</code></td>
<td>
<p>frequency axis (Hz; cycles per second, not radians per
second)</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>interval for frequency axis (Hz)</p>
</td></tr>
<tr><td><code>spectrum</code></td>
<td>
<p>spectral values corresponding to f</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>spectrum type: Power, Energy, Amplitude, or Phase</p>
</td></tr>
<tr><td><code>units</code></td>
<td>
<p>Units of spectrum (assuming that input units are volts
and seconds)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jake Anderson
</p>


<h3>See Also</h3>

<p>RSEIS::mtapspec
stats::fft
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example time series
x = rnorm(1000)
dt = 0.01

## power spectrum, multi-taper method, one-sided
S = Spectrum(x, dt, type = 1, method = 2, one_sided = TRUE)
sum(S$spectrum) * S$df ## frequency-domain power
mean(x^2) ## time-domain power

## energy spectrum, fft method, two-sided
S = Spectrum(x, dt, type = 2, method = 1, one_sided = FALSE)
sum(S$spectrum) * S$df ## frequency-domain energy
sum(x^2) * dt ## time-domain energy
</code></pre>

<hr>
<h2 id='STALTA'>Short term, long term  average ratio
</h2><span id='topic+STALTA'></span>

<h3>Description</h3>

<p>Calculate the short term, long term average ratios of the squared
amplitude in a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STALTA(y, fwlen = 125, bwlen = 125)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="STALTA_+3A_y">y</code></td>
<td>
<p> vector, or time series
</p>
</td></tr>
<tr><td><code id="STALTA_+3A_fwlen">fwlen</code></td>
<td>
<p>forward number of samples 
</p>
</td></tr>
<tr><td><code id="STALTA_+3A_bwlen">bwlen</code></td>
<td>
<p>backward number of samples 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the ratio of the forward/backard mean square sum.
</p>


<h3>Value</h3>

<p>vector of ratios
</p>


<h3>Note</h3>

<p>All filtering or pre and post analysis should be done outside of ratio
curve estimate.  
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>STLTcurve, PSTLTcurve
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### easy example find P and S-wave arrivals, low noise
data(GH)
i = 6
z = GH$JSTR[[i]]

z.curve = STALTA(z, fwlen = 10, bwlen = 325)

ex = seq(from=0, length=length(z), by=GH$dt[i])
par(mfrow=c(2, 1) )
plot(ex, z, type='l')
plot(ex, z.curve, type = 'l' )

aa = peaks(z.curve, span = 11, do.pad = TRUE)
wa = which( aa &amp; z.curve&gt;50 )

abline(v=wa*GH$dt[i]  , col='red')
par(mfg=c(1,1) )
abline(v=wa*GH$dt[i]  , col='red')



</code></pre>

<hr>
<h2 id='STLTcurve'>Short-term/Long-term Average curve</h2><span id='topic+STLTcurve'></span>

<h3>Description</h3>

<p>Get short-term average long-term verage ratio curve for picking
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STLTcurve(y, dt = 0.008, fwlen = 125, bwlen = 125,
stretch = 1000, MED = 255, PLOT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="STLTcurve_+3A_y">y</code></td>
<td>
<p>signal</p>
</td></tr>
<tr><td><code id="STLTcurve_+3A_dt">dt</code></td>
<td>
<p>sample rate </p>
</td></tr>
<tr><td><code id="STLTcurve_+3A_fwlen">fwlen</code></td>
<td>
<p>forward window, number of samples </p>
</td></tr>
<tr><td><code id="STLTcurve_+3A_bwlen">bwlen</code></td>
<td>
<p>back window length, number of samples </p>
</td></tr>
<tr><td><code id="STLTcurve_+3A_stretch">stretch</code></td>
<td>
<p>stretch multiplier</p>
</td></tr>
<tr><td><code id="STLTcurve_+3A_med">MED</code></td>
<td>
<p>median smoother</p>
</td></tr>
<tr><td><code id="STLTcurve_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE=plot diagnostics</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses C-code and fast tanking algorithm written at UW
</p>


<h3>Value</h3>

<p>sample to significant change in ratio curve
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>PSTLTcurve </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CE1)

y  = CE1$y

DT = CE1$dt



sy = STLTcurve(y, dt=DT, fwlen =  25,  bwlen  = 25,
stretch=1000, MED=255, PLOT=FALSE)

par(mfrow=c(2,1))

plot(CE1$x, CE1$y, type='l')
plot(CE1$x,sy$rat, type='l')




</code></pre>

<hr>
<h2 id='swig'>Seismic Wiggle Analysis </h2><span id='topic+swig'></span>

<h3>Description</h3>

<p>Main Interactive Program for plotting and analyzing seismic waveform data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swig(GH, sel = 1:length(GH$dt), ORD = NULL, WIN = NULL, APIX = NULL,
PHASE = NULL,
STDLAB = NULL, PADDLAB = NULL, TEMPBUT=NULL,
SHOWONLY = FALSE, CHOP = FALSE, TIT = "",
pts = FALSE, forcepix = FALSE, pcex=0.7, SCALE = 1, ilocstyle=1,
velfile = "", stafile = "", LOC = NULL,
prefilt=list(fl=.2, fh=15,  type="HP", proto="BU"), filters=NULL,
 YAX = 1  ,  xtickfactor = 1, vertline=NA, destdir='.')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swig_+3A_gh">GH</code></td>
<td>
<p>Seismic data structure</p>
</td></tr>
<tr><td><code id="swig_+3A_sel">sel</code></td>
<td>
<p>selection of traces from structure </p>
</td></tr>
<tr><td><code id="swig_+3A_ord">ORD</code></td>
<td>
<p>order to plot traces </p>
</td></tr>
<tr><td><code id="swig_+3A_win">WIN</code></td>
<td>
<p>vector c(t1, t2) for window of traces to be shown </p>
</td></tr>
<tr><td><code id="swig_+3A_apix">APIX</code></td>
<td>
<p>structure of arrival time picks </p>
</td></tr>
<tr><td><code id="swig_+3A_phase">PHASE</code></td>
<td>
<p>phase to display, &quot;P&quot;, &quot;S&quot;, etc </p>
</td></tr>
<tr><td><code id="swig_+3A_stdlab">STDLAB</code></td>
<td>
<p>label of buttons</p>
</td></tr>
<tr><td><code id="swig_+3A_paddlab">PADDLAB</code></td>
<td>
<p>label of phase-pick buttons</p>
</td></tr>
<tr><td><code id="swig_+3A_tempbut">TEMPBUT</code></td>
<td>
<p>temporary, user defined buttons</p>
</td></tr>
<tr><td><code id="swig_+3A_showonly">SHOWONLY</code></td>
<td>
<p>logical, TRUE=non-interactive </p>
</td></tr>
<tr><td><code id="swig_+3A_chop">CHOP</code></td>
<td>
<p>whether to chop the signal </p>
</td></tr>
<tr><td><code id="swig_+3A_tit">TIT</code></td>
<td>
<p>title for the top of plot</p>
</td></tr>
<tr><td><code id="swig_+3A_pts">pts</code></td>
<td>
<p>whether to plot specific points on the plot</p>
</td></tr>
<tr><td><code id="swig_+3A_forcepix">forcepix</code></td>
<td>
<p>logical, force all phase picks to be shown on all
traces </p>
</td></tr>
<tr><td><code id="swig_+3A_pcex">pcex</code></td>
<td>
<p> Pick label size expansion (cex), default=0.7 </p>
</td></tr>
<tr><td><code id="swig_+3A_scale">SCALE</code></td>
<td>
<p>flag, 1,2= scale according to window or trace (default=1,
scale by trace)</p>
</td></tr>
<tr><td><code id="swig_+3A_ilocstyle">ilocstyle</code></td>
<td>
<p>integer, style of click graphic, one of -1, 0, 1, 2,
3, indicating: 
points, abline, segs, segs+abline,
segs+long-abline  , default=1  </p>
</td></tr>
<tr><td><code id="swig_+3A_velfile">velfile</code></td>
<td>
<p>velocity structure or file name </p>
</td></tr>
<tr><td><code id="swig_+3A_stafile">stafile</code></td>
<td>
<p>station structure or file name </p>
</td></tr>
<tr><td><code id="swig_+3A_loc">LOC</code></td>
<td>
<p>source location structure (lat, lon, depth) </p>
</td></tr>
<tr><td><code id="swig_+3A_prefilt">prefilt</code></td>
<td>
<p>default filter definition list(fl=.2, fh=15,  type=&quot;HP&quot;,
proto=&quot;BU&quot;)</p>
</td></tr>
<tr><td><code id="swig_+3A_filters">filters</code></td>
<td>
<p> a list of filters for choosfilt, the list consists of
3 vectors: flo, fhi and type defining the filter choices.</p>
</td></tr>
<tr><td><code id="swig_+3A_yax">YAX</code></td>
<td>
<p> type of Yaxis label, 1,2,3 DEFAULT=1 only one y-axis
others scaled; 2=all y-axes are plotted on left; 3=all y-axes plotted,
alternating left and right</p>
</td></tr>
<tr><td><code id="swig_+3A_xtickfactor">xtickfactor</code></td>
<td>
<p>Factor for multiplying the x-axis tick markers
(default=1; for minutes=60, hrs=3600, days=24*3600) </p>
</td></tr>
<tr><td><code id="swig_+3A_vertline">vertline</code></td>
<td>
<p>time list (yr, jd, hr, mi sec) for plotting vertical lines on window.
Default=NA </p>
</td></tr>
<tr><td><code id="swig_+3A_destdir">destdir</code></td>
<td>
<p> Destination directory(folder) for writing output to
disk, default = current directory</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main program that drives the other analysis in RSEIS.
GH is a list consisting of header (meta-data) and time series
information.  See documentation on GH to get complete description.
</p>
<p>A set of filters can be defined by the user, see choosfilt
</p>
<p>Default Buttons, can be created by:
STDLAB = c(&quot;DONE&quot;, &quot;QUIT&quot;,&quot;zoom out&quot;, &quot;zoom in&quot;, &quot;Left&quot;, &quot;Right&quot;, &quot;restore&quot;, &quot;Pinfo&quot;,&quot;WINFO&quot;,
&quot;XTR&quot;, &quot;SPEC&quot;, &quot;SGRAM&quot; ,&quot;WLET&quot;, &quot;FILT&quot;, &quot;UNFILT&quot;, &quot;SCALE&quot;,
&quot;Postscript&quot;)
</p>
<p>If the user has defined STDLAB.DEFAULT and PADDLAB.DEFAULT
in the .Rprofile or .First commands, these will override
the default in the function definition.
</p>


<h3>Value</h3>

<p>Various structures are returned
based on interactive selections of the user.
</p>
<p>Howeverr, the default return list:
</p>
<table>
<tr><td><code>but</code></td>
<td>
<p>last button pushed</p>
</td></tr>
<tr><td><code>sloc</code></td>
<td>
<p>location of last set of clicks</p>
</td></tr>
<tr><td><code>WPX</code></td>
<td>
<p>set of saved WPIX (window picks</p>
</td></tr>
<tr><td><code>BRUNINFO</code></td>
<td>
<p>Brune Model information</p>
</td></tr>
<tr><td><code>DETLINFO</code></td>
<td>
<p>Detailed information about traces</p>
</td></tr>
<tr><td><code>mark</code></td>
<td>
<p>mark (MARK button was pressed</p>
</td></tr>
<tr><td><code>PUSHED</code></td>
<td>
<p>list of all buttons pressed prior to exit</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If using the filters for button FILT, it is useful to have a &quot;None&quot;
in case no filter is desired (i.e. user changes mind).
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>PICK.DOC, GH, RPGM, choosfilt</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("GH")
###  This loads a structure


STDLAB &lt;- c("DONE", "QUIT","zoom out", "zoom in", "Left",
"Right", "restore", "Pinfo","WINFO",
"XTR", "SPEC", "SGRAM" ,"WLET",
"FILT", "UNFILT", "SCALE", "Postscript")

sel &lt;- GH$COMPS=="V" 
if(interactive() ) {  p &lt;- swig(GH, sel=sel, STDLAB=STDLAB)
print(p)
}
if(interactive()) {
p &lt;- swig(GH, sel=sel, WIN=c(4,14) , STDLAB=c("DONE", "LAME", "DAME")  )

print(p)
}

############    example with filter
data(KH)

thefilts &lt;-
list(flo=
c(0.02, 0.02, 0.02, 0.02, 0.02,   0.02,
0.02, 0.02, 0.02,  0.02, 0.02,  0.02,
0.02,
1/2, 1/50,1/100, 1/100,
1/100,1/100,1/100,1,1,
0.2, 15, 5, 2,1,
100),
fhi=
c(1/10, 1/6, 1/5, 1/4, 1/3, 1/2,
0.2,  0.5, 1.0,  2.0, 3.0,  4.0,
7.0,
8, 1/2.0,1/5.0,1/10.0,
1/20, 1/30,1/40,10,5,
7.0, 100, 100, 100,10,
100),
type =
c("LP","LP", "LP", "LP", "LP", "LP",
"LP","LP", "LP", "LP", "LP", "LP",
"LP",
"BP", "BP","BP","BP","BP","BP",
"BP","BP","BP",
"HP", "HP","HP", "HP","HP",
"None"))



if(interactive()) {
swig(KH, filters=thefilts)
}else{
swig(KH, filters=thefilts, SHOWONLY=TRUE )
}





</code></pre>

<hr>
<h2 id='swig.ALLPX'>plot all phase arrival picks</h2><span id='topic+swig.ALLPX'></span>

<h3>Description</h3>

<p>plot all phase arrival picks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swig.ALLPX(t0, STNS, COMPS, YPX, PHASE = NULL, POLS = TRUE,
 FILL = FALSE, FORCE = TRUE, cex = cex, srt = srt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swig.ALLPX_+3A_t0">t0</code></td>
<td>
<p>time for start of window, s</p>
</td></tr>
<tr><td><code id="swig.ALLPX_+3A_stns">STNS</code></td>
<td>
<p>station names to plot</p>
</td></tr>
<tr><td><code id="swig.ALLPX_+3A_comps">COMPS</code></td>
<td>
<p>components to plot </p>
</td></tr>
<tr><td><code id="swig.ALLPX_+3A_ypx">YPX</code></td>
<td>
<p>y-picks (times) </p>
</td></tr>
<tr><td><code id="swig.ALLPX_+3A_phase">PHASE</code></td>
<td>
<p>Phases to plot</p>
</td></tr>
<tr><td><code id="swig.ALLPX_+3A_pols">POLS</code></td>
<td>
<p>polaritiy information (up, down) </p>
</td></tr>
<tr><td><code id="swig.ALLPX_+3A_fill">FILL</code></td>
<td>
<p>fill color</p>
</td></tr>
<tr><td><code id="swig.ALLPX_+3A_force">FORCE</code></td>
<td>
<p>logical, force all phases plotted on all traces </p>
</td></tr>
<tr><td><code id="swig.ALLPX_+3A_cex">cex</code></td>
<td>
<p>character expansion</p>
</td></tr>
<tr><td><code id="swig.ALLPX_+3A_srt">srt</code></td>
<td>
<p>string rotation angle, degrees</p>
</td></tr>
</table>


<h3>Details</h3>

<p>for use in conjunction with PLOT.SEISN program
</p>


<h3>Value</h3>

<p>Graphical Side Effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>PLOT.SEISN, swig</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 
swig.ALLPX(Torigin, STNS, COMPS, WPX, PHASE=PHASE,
FORCE=forcepix) 
## End(Not run)

</code></pre>

<hr>
<h2 id='symshot1'>Simulate a seismic shot</h2><span id='topic+symshot1'></span>

<h3>Description</h3>

<p>Simulate an exploration style seismic shot with ground roll, air wave,
refractions and reflections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symshot1(PLOT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symshot1_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE=plot the wiggles.  DEFAULT=FALSE
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arrivals are calculated based on geometric
considerations with a 1D layered model.
</p>


<h3>Value</h3>

<table>
<tr><td><code>smograms</code></td>
<td>
<p>Matrix: columns are individual traces</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>sample interval in time, s</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>x locations</p>
</td></tr>
<tr><td><code>dx</code></td>
<td>
<p>spacing in X-direction</p>
</td></tr>
<tr><td><code>REFL</code></td>
<td>
<p>reflection information</p>
</td></tr>
<tr><td><code>REFR</code></td>
<td>
<p>refraction image</p>
</td></tr>
<tr><td><code>GRrec</code></td>
<td>
<p>ground roll image</p>
</td></tr>
<tr><td><code>AIRrec</code></td>
<td>
<p>air wave image</p>
</td></tr>
<tr><td><code>THEORY</code></td>
<td>
<p>List of theoretical values</p>
</td></tr>
<tr><td><code>trefrac</code></td>
<td>
<p>refraction arrival times</p>
</td></tr>
<tr><td><code>treflex</code></td>
<td>
<p>reflection arrival times</p>
</td></tr>
<tr><td><code>tair</code></td>
<td>
<p>Air arrival times</p>
</td></tr>
<tr><td><code>velair</code></td>
<td>
<p>velocity for the air wave</p>
</td></tr>
<tr><td><code>mod</code></td>
<td>
<p>Layered Model</p>
</td></tr>
</table>


<h3>Note</h3>

<p>MOdel is relatively simple:
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>Sherrif</p>


<h3>See Also</h3>

<p>wiggleimage, symshot</p>


<h3>Examples</h3>

<pre><code class='language-R'>
S1 &lt;- symshot1()
wiggleimage(S1$smograms, dt = -S1$dt, dx = S1$x, col = "black")


</code></pre>

<hr>
<h2 id='sysinfo'>System Information
</h2><span id='topic+sysinfo'></span>

<h3>Description</h3>

<p>Extract OS system information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sysinfo()
</code></pre>


<h3>Details</h3>

<p>Returns parts of the output of variables .Machine and
.Platform.
</p>
<p>Endian Problem
</p>
<p>these should be used for reading binary data when crossing platforms.
If binary files are created on a little-endian platform, but are being
read on a big-endian platform, then one should use &quot;swap&quot;.
</p>
<p>SizeOf Problem
</p>
<p>Many older machines use 4 bytes for LONG.  Newer 64 bit machines use 8
bytes for LONG = so this is a big problem.
</p>


<h3>Value</h3>

<p>A=.Machine, B=.Platform
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>.Machine, .Platform
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sysinfo()


</code></pre>

<hr>
<h2 id='T12.pix'>Get T1, T2</h2><span id='topic+T12.pix'></span>

<h3>Description</h3>

<p>Modify opick data frame and add T2=T1+dur
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T12.pix(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T12.pix_+3A_a">A</code></td>
<td>
<p>pick data.frame </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given t1 and duration, returns to structure, t2=t1+dur.
</p>


<h3>Value</h3>

<p>pick data.frame with t2 as a member.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>

<hr>
<h2 id='TAPER.SEISN'>Taper Traces</h2><span id='topic+TAPER.SEISN'></span>

<h3>Description</h3>

<p>Taper  traces in a seismic structure using a cosine function on the ends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TAPER.SEISN(TH, sel = 1:length(TH$JSTR),  TAPER = 0.1 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TAPER.SEISN_+3A_th">TH</code></td>
<td>
<p>Seismic structure</p>
</td></tr>
<tr><td><code id="TAPER.SEISN_+3A_sel">sel</code></td>
<td>
<p>selection of traces </p>
</td></tr>
<tr><td><code id="TAPER.SEISN_+3A_taper">TAPER</code></td>
<td>
<p>filter taper, percent cosine taper</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Seismic structure
</p>


<h3>Value</h3>

<p>Seismic structure
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>butfilt</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data("GH")
sel &lt;-  which(GH$COMPS=="V")

sel  &lt;-  1:3
 KF  &lt;-  TAPER.SEISN(GH, sel = sel, TAPER=0.1)
swig(KF, sel=sel, SHOWONLY=0)


</code></pre>

<hr>
<h2 id='Thresh.J'>Threshold Adjuster</h2><span id='topic+Thresh.J'></span>

<h3>Description</h3>

<p>determine cut off for ratio curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Thresh.J(y, thresh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Thresh.J_+3A_y">y</code></td>
<td>
<p>signal</p>
</td></tr>
<tr><td><code id="Thresh.J_+3A_thresh">thresh</code></td>
<td>
<p>inital threshold</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Attempts to automatically optimize the threshold for automated
picking.
Used deep in picking algorithm.
</p>


<h3>Value</h3>

<p>list(J=J, L=L)
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>

<hr>
<h2 id='TOCART'>Convert to Cartesian coordinates</h2><span id='topic+TOCART'></span>

<h3>Description</h3>

<p>Convert to cartesian coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TOCART(az, nadir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TOCART_+3A_az">az</code></td>
<td>
<p>degrees, azimuth </p>
</td></tr>
<tr><td><code id="TOCART_+3A_nadir">nadir</code></td>
<td>
<p>degrees, dip </p>
</td></tr>
</table>


<h3>Value</h3>

<p>LIST
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>x-coordinate</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y-coordinate</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>z-coordinate</p>
</td></tr>
<tr><td><code>az</code></td>
<td>
<p>degrees, azimuth </p>
</td></tr>
<tr><td><code>nadir</code></td>
<td>
<p>degrees, dip </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>tocartL</p>


<h3>Examples</h3>

<pre><code class='language-R'>TOCART(132, 69)
</code></pre>

<hr>
<h2 id='tojul'>Julian Day</h2><span id='topic+tojul'></span>

<h3>Description</h3>

<p>Convert to Julian Day. Used for calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tojul(year, month, day)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tojul_+3A_year">year</code></td>
<td>
<p>year</p>
</td></tr>
<tr><td><code id="tojul_+3A_month">month</code></td>
<td>
<p>month</p>
</td></tr>
<tr><td><code id="tojul_+3A_day">day</code></td>
<td>
<p>day</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Julian Days
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>tojul(1953, 3, 19)
</code></pre>

<hr>
<h2 id='tomo.colors'>Tomography Colors</h2><span id='topic+tomo.colors'></span>

<h3>Description</h3>

<p>Color Palette ranging from red to blue through black.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tomo.colors(n, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tomo.colors_+3A_n">n</code></td>
<td>
<p>number of colors </p>
</td></tr>
<tr><td><code id="tomo.colors_+3A_alpha">alpha</code></td>
<td>
<p>hsv color parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>color palette
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>rainbow, colors, hsv</p>


<h3>Examples</h3>

<pre><code class='language-R'>tomo.colors(25, alpha = 1)
</code></pre>

<hr>
<h2 id='trapz'>Integrate using trapezoidal rule</h2><span id='topic+trapz'></span>

<h3>Description</h3>

<p>Integrate using trapezoidal rule
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trapz(y, dt, rm.mean=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trapz_+3A_y">y</code></td>
<td>
<p>Input signal</p>
</td></tr>
<tr><td><code id="trapz_+3A_dt">dt</code></td>
<td>
<p>sample interval time, seconds</p>
</td></tr>
<tr><td><code id="trapz_+3A_rm.mean">rm.mean</code></td>
<td>
<p>logical, whether to remove the mean prior to integration (TRUE) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector: Integrated signal
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
trapz(x, 0.01)

</code></pre>

<hr>
<h2 id='travel.time1D'>Seismic Travel Time 1D</h2><span id='topic+travel.time1D'></span><span id='topic+many.time1D'></span>

<h3>Description</h3>

<p>Travel time from source to reciever in 1D local model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>travel.time1D(indelta, inhpz, instaz, inlay, ztop, vel)
many.time1D(indelta, inhpz, instaz, inlay, ztop, vel)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="travel.time1D_+3A_indelta">indelta</code></td>
<td>
<p>distance in KM</p>
</td></tr>
<tr><td><code id="travel.time1D_+3A_inhpz">inhpz</code></td>
<td>
<p>depth of hypocenter, km</p>
</td></tr>
<tr><td><code id="travel.time1D_+3A_instaz">instaz</code></td>
<td>
<p>elevation of station</p>
</td></tr>
<tr><td><code id="travel.time1D_+3A_inlay">inlay</code></td>
<td>
<p>number of layers</p>
</td></tr>
<tr><td><code id="travel.time1D_+3A_ztop">ztop</code></td>
<td>
<p>vector, tops of layers</p>
</td></tr>
<tr><td><code id="travel.time1D_+3A_vel">vel</code></td>
<td>
<p>vector, velocities in layers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses local  1D velocity model, not appropriate for spherical earth.
The many.time1D version will take a vector of distances (indelta)
and either one station elevation or a vector.
</p>
<p>The station elevation should be referenced to the top of the velocity
model, not necessarily sea level.  Usually this is set to zero
and a station correction is used to take into account the
topographic and other geologic effects.
</p>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>dtdr</code></td>
<td>
<p>derivative of t   w.r.t. horizontal distance</p>
</td></tr>
<tr><td><code>dtdz</code></td>
<td>
<p>derivative of t  w.r.t. z, depth</p>
</td></tr>
<tr><td><code>angle</code></td>
<td>
<p>incidence angle, degrees</p>
</td></tr>
<tr><td><code>tt</code></td>
<td>
<p>travel time, s</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>Ray.time1D, Get1Dvel</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(VELMOD1D)

v &lt;- VELMOD1D

tees &lt;- travel.time1D(23, 7, 0, length(v$zs) , v$zp , v$vp)

print(tees)

</code></pre>

<hr>
<h2 id='tung.pulse'>Volcanic Pulse Analysis</h2><span id='topic+tung.pulse'></span>

<h3>Description</h3>

<p>given a seiries of pulses, do analysis on each one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tung.pulse(r, q, dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tung.pulse_+3A_r">r</code></td>
<td>
<p>x-coordinates</p>
</td></tr>
<tr><td><code id="tung.pulse_+3A_q">q</code></td>
<td>
<p>y-coordinates</p>
</td></tr>
<tr><td><code id="tung.pulse_+3A_dt">dt</code></td>
<td>
<p>deltat, sample interval</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates, min, max of edges and center, then
models the pulse with a triangular pulse and integegrates.
</p>


<h3>Value</h3>

<p>vector=c(Ex[1], Ex[2], Ey[1], Ey[2], Cx, Cy, ar2, DefInt[1],
DefInt[2], sum0)
where:
</p>
<table>
<tr><td><code>Ex</code></td>
<td>
<p>left minimum </p>
</td></tr>
<tr><td><code>Ey</code></td>
<td>
<p> right  minimum</p>
</td></tr>
<tr><td><code>Cx</code>, <code>Cy</code></td>
<td>
<p> center (max?)</p>
</td></tr>
<tr><td><code>ar2</code></td>
<td>
<p> area of triangle</p>
</td></tr>
<tr><td><code>DefInt[1]</code></td>
<td>
<p>integral under curve</p>
</td></tr>
<tr><td><code>DefInt[2]</code></td>
<td>
<p>integral under curve ( bottom triangle removed) </p>
</td></tr>
<tr><td><code>sum0</code></td>
<td>
<p> RMS amplitude</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>peaks</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(CE1)

ex &lt;- CE1$x[CE1$x&gt;5.453291 &amp;CE1$x&lt; 5.507338]
why &lt;- CE1$y[CE1$x&gt;5.453291 &amp;CE1$x&lt; 5.507338]
plot(ex, why, type='l')
tung.pulse(ex, why, CE1$dt)

## End(Not run)


</code></pre>

<hr>
<h2 id='unpackAcard'>Parse Acard from UW-format pickfile</h2><span id='topic+unpackAcard'></span>

<h3>Description</h3>

<p>Parse Acard from UW-format pickfile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpackAcard(AC)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpackAcard_+3A_ac">AC</code></td>
<td>
<p>ascii acard</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reads and Parses A-cards from UW foprmatted data.
</p>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>yr</code></td>
<td>
<p>Year</p>
</td></tr>
<tr><td><code>mo</code></td>
<td>
<p>Month</p>
</td></tr>
<tr><td><code>dom</code></td>
<td>
<p>Day of Month</p>
</td></tr>
<tr><td><code>hr</code></td>
<td>
<p>Hour</p>
</td></tr>
<tr><td><code>mi</code></td>
<td>
<p>minute</p>
</td></tr>
<tr><td><code>sec</code></td>
<td>
<p>second</p>
</td></tr>
<tr><td><code>lat</code></td>
<td>
<p>latitude</p>
</td></tr>
<tr><td><code>lon</code></td>
<td>
<p>longitude</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>depth</p>
</td></tr>
<tr><td><code>mag</code></td>
<td>
<p>magnitude</p>
</td></tr>
<tr><td><code>gap</code></td>
<td>
<p>gap in station coverage</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>distance to nearest station</p>
</td></tr>
<tr><td><code>rms</code></td>
<td>
<p>root mean square residual</p>
</td></tr>
<tr><td><code>hozerr</code></td>
<td>
<p>horizontal error</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>

<hr>
<h2 id='uwpfile2ypx'>UW pickfile to pphase pick data.frame</h2><span id='topic+uwpfile2ypx'></span>

<h3>Description</h3>

<p>Read in ASCII version of pickfile.  This is the
output list used to plot picks on swig, often called WPX or YPX
in other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uwpfile2ypx(P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uwpfile2ypx_+3A_p">P</code></td>
<td>
<p>pickfile</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>STAS</code></td>
<td>
<p>input structure</p>
</td></tr>
<tr><td><code>yr</code></td>
<td>
<p>year</p>
</td></tr>
<tr><td><code>mo</code></td>
<td>
<p>month</p>
</td></tr>
<tr><td><code>dom</code></td>
<td>
<p>day of month</p>
</td></tr>
<tr><td><code>jd</code></td>
<td>
<p>julian day</p>
</td></tr>
<tr><td><code>hr</code></td>
<td>
<p>hour</p>
</td></tr>
<tr><td><code>mi</code></td>
<td>
<p>minute</p>
</td></tr>
<tr><td><code>sec</code></td>
<td>
<p>second</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code>onoff</code></td>
<td>
<p>logical, TRUE plot trace</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("GH")
WW = RSEIS::uwpfile2ypx(GH$pickfile)
vertord &lt;-  getvertsorder(GH$pickfile, GH)
R1 = rangedatetime(WW)
R2 = rangedatetime(GH$info)
S1 = secdifL(R2$min, R1$min)



swig(GH, sel=vertord$sel, APIX=WW, WIN=c(S1-1, 15) , SHOWONLY=0)

</code></pre>

<hr>
<h2 id='varsquig'>Var-Squiggle plot</h2><span id='topic+varsquig'></span>

<h3>Description</h3>

<p>Plot one seismogram in Var-Squiggle mode - like on an exploration record
section with half the wiggled shaded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varsquig(x, y, L = locator(2), FLIP = FALSE, filcol="blue",
tracecol="red", var = 0, xpd=TRUE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varsquig_+3A_x">x</code></td>
<td>
<p>X (time axis) coordinates</p>
</td></tr>
<tr><td><code id="varsquig_+3A_y">y</code></td>
<td>
<p>Y amplitudes</p>
</td></tr>
<tr><td><code id="varsquig_+3A_l">L</code></td>
<td>
<p>rectangular region on plot where plotting occurs</p>
</td></tr>
<tr><td><code id="varsquig_+3A_flip">FLIP</code></td>
<td>
<p>logical - whether to flip the amplitudes by -1</p>
</td></tr>
<tr><td><code id="varsquig_+3A_filcol">filcol</code></td>
<td>
<p>color for shading</p>
</td></tr>
<tr><td><code id="varsquig_+3A_tracecol">tracecol</code></td>
<td>
<p>color for trace</p>
</td></tr>
<tr><td><code id="varsquig_+3A_var">var</code></td>
<td>
<p>logical, whether to shade</p>
</td></tr>
<tr><td><code id="varsquig_+3A_xpd">xpd</code></td>
<td>
<p>logical, set xpd parameter (see par) </p>
</td></tr>	
</table>


<h3>Details</h3>

<p>A set of traces can be plotted after the plotting region has been set.
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Note</h3>

<p>varsquig is meant to be used within other program not as a stand alone
routine.  The plotting region must be set up prior to plotting.  The
time series is scaled to fitt in the rectangular region defined by L.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>varsquiggle</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(KH)

x &lt;- KH$ex[KH$ex&gt;95&amp; KH$ex&lt;125]
y &lt;- KH$JSTR[[1]][KH$ex&gt;95&amp; KH$ex&lt;125]


plot(x , y , type='l')


u &lt;- par('usr')
L &lt;- list(x=c(u[1], u[2]), y = c(u[3], u[4]))

plot(L$x, L$y, type='n')
 varsquig(x, y, L=L , FLIP=FALSE, filcol="blue", tracecol="blue", var=TRUE)
plot(L$x, L$y, type='n')
 varsquig(x, y, L=L , FLIP=FALSE, filcol="red", tracecol="blue",   var=FALSE)



</code></pre>

<hr>
<h2 id='varsquiggle'>Var-Squiggle Plot</h2><span id='topic+varsquiggle'></span>

<h3>Description</h3>

<p>Plot A seismic section using Var-Squiggle, like an exploration
seismic record.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varsquiggle(GH, sel = c(1, 2), WIN = c(0, 1), dist=NULL, thick=1 ,
FLIP=FALSE, filcol='blue', tracecol='blue', xpd=TRUE, plotdir=1 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varsquiggle_+3A_gh">GH</code></td>
<td>
<p>Seismic List</p>
</td></tr>
<tr><td><code id="varsquiggle_+3A_sel">sel</code></td>
<td>
<p>selection of seismic traces</p>
</td></tr>
<tr><td><code id="varsquiggle_+3A_win">WIN</code></td>
<td>
<p>time window</p>
</td></tr>
<tr><td><code id="varsquiggle_+3A_dist">dist</code></td>
<td>
<p>distance from the source</p>
</td></tr>
<tr><td><code id="varsquiggle_+3A_thick">thick</code></td>
<td>
<p>thickness of plotting region per trace</p>
</td></tr>
<tr><td><code id="varsquiggle_+3A_flip">FLIP</code></td>
<td>
<p>logical, whether to plot vertical or horizontal, default
FALSE,  TRUE = vertical</p>
</td></tr>
<tr><td><code id="varsquiggle_+3A_filcol">filcol</code></td>
<td>
<p>color for shading</p>
</td></tr>
<tr><td><code id="varsquiggle_+3A_tracecol">tracecol</code></td>
<td>
<p>color for trace</p>
</td></tr>
<tr><td><code id="varsquiggle_+3A_xpd">xpd</code></td>
<td>
<p>logical, set xpd parameter (see par) </p>
</td></tr>	
<tr><td><code id="varsquiggle_+3A_plotdir">plotdir</code></td>
<td>
<p>1=left to right, 0=right to left (default=1) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Traces are plotted and scaled each with its own window. The distance
vector provides the location on the seismic record.  
</p>


<h3>Value</h3>

<p>Graphical Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>matsquiggle, varsquig</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GH)
m &lt;- match( GH$STNS,    GH$stafile$name)
LATS &lt;- GH$stafile$lat[m]
LONS &lt;- GH$stafile$lon[m]
dees &lt;- rdistaz( GH$pickfile$LOC$lat, GH$pickfile$LOC$lon, LATS, LONS)

sel &lt;- which(GH$COMPS=="V")
sel &lt;-  sel[order(dees$dist[sel])]

###  plot normal way:
swig(GH, sel=sel, WIN=c(5,10), SHOWONLY=TRUE)


###  plot with varsquiggle
varsquiggle(GH, sel=sel, WIN=c(5,10))


</code></pre>

<hr>
<h2 id='VELMOD1D'>Sample Velocity Model</h2><span id='topic+VELMOD1D'></span>

<h3>Description</h3>

<p>Seismic Velocity Model for Coso California
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(VELMOD1D)</code></pre>


<h3>Format</h3>

<p>LIST:
</p>

<dl>
<dt>zp</dt><dd><p>vector of Tops of Layers, P-wave, (km)</p>
</dd>
<dt>vp</dt><dd><p>vector of velocities of Layers, P-wave,(km/s)</p>
</dd>
<dt>ep</dt><dd><p>errors for velocities, P-wave,(km/s) </p>
</dd>
<dt>zs</dt><dd><p>vector of Tops of Layers, S-wave, (km)</p>
</dd>
<dt>vs</dt><dd><p>vector of velocities of Layers, S-wave,(km/s)</p>
</dd>
<dt>es</dt><dd><p>errors for velocities, S-wave,(km/s) </p>
</dd>
<dt>name</dt><dd><p>character, name of model </p>
</dd>
<dt>descriptor</dt><dd><p>character vector description of model </p>
</dd>
</dl>



<h3>Details</h3>

<p>Velocity model from a text file
</p>


<h3>References</h3>

<p>Wu, H., and J. M. Lees (1999), Three-dimensional P- and S-wave velocity structures of the Coso Geothermal Area, California, from microseismic traveltime data, J. Geophys. Res. 104, 13,217-13,233.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(VELMOD1D)
Get1Dvel(VELMOD1D, PLOT=TRUE)


</code></pre>

<hr>
<h2 id='VELOCITY.SEISN'>Velocity Seismogram</h2><span id='topic+VELOCITY.SEISN'></span>

<h3>Description</h3>

<p>Removes seismic instrument response and corrects for sensitivity of
seismoc instrument, returning units of m/s rather than volts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VELOCITY.SEISN(TH, sel = 1:length(TH$JSTR), inst = 1,
Kal = Kal,waterlevel = 1e-08,  FILT = list(ON = FALSE,
fl = 1/30, fh = 7, type = "HP", proto = "BU"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VELOCITY.SEISN_+3A_th">TH</code></td>
<td>
<p>list structure of seismic traces</p>
</td></tr>
<tr><td><code id="VELOCITY.SEISN_+3A_sel">sel</code></td>
<td>
<p>select which tracesin list to deconvolve</p>
</td></tr>
<tr><td><code id="VELOCITY.SEISN_+3A_inst">inst</code></td>
<td>
<p>index to instrument in Kal list for calibration and
instrument response </p>
</td></tr>
<tr><td><code id="VELOCITY.SEISN_+3A_kal">Kal</code></td>
<td>
<p>list of instrument responses</p>
</td></tr>
<tr><td><code id="VELOCITY.SEISN_+3A_waterlevel">waterlevel</code></td>
<td>
<p>waterlevel for low frequency division </p>
</td></tr>
<tr><td><code id="VELOCITY.SEISN_+3A_filt">FILT</code></td>
<td>
<p>filter output, after instrumentation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Instrument responses are lists of poles and zeros for each instrument defined.
</p>


<h3>Value</h3>

<p>Same as input list with new traces representing  velocity versus volts
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>DISPLACE.SEISN, deconinst </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
Kal  &lt;-  PreSet.Instr()
Majorevent   &lt;-  250+8/24+2250/(24*3600)

at1  &lt;-  Majorevent - 1/24
at2  &lt;-  Majorevent + 1/24


TH  &lt;-   Mine.seis(at1, at2, DB99, NULL, NULL , kind = 1, Iendian=1,
BIGLONG=FALSE, CHOP=TRUE, verbose=FALSE)
inst  &lt;-  rep(0, length(TH$STNS))
inst[TH$COMPS %in% c("V", "N", "E")]  &lt;-  1
inst[TH$STNS=="krm2" &amp;  TH$COMPS %in% c("V", "N", "E")]  &lt;-  2
inst[TH$STNS=="krm0" &amp;  TH$COMPS %in% c("V", "N", "E")]  &lt;-  2

VH  &lt;-     VELOCITY.SEISN(TH, sel = 1:length(TH$JSTR), inst = 1,
Kal = Kal, FILT = list(ON = FALSE, fl = 1/30, fh = 7,
type = "HP", proto = "BU"))



## End(Not run)



</code></pre>

<hr>
<h2 id='view.seis'>Veiw seismic data window</h2><span id='topic+view.seis'></span>

<h3>Description</h3>

<p>Veiw seismic data (segy) window on an hourly basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view.seis(aday, ihour, inkhour, SAVEFILE, days,
DB, usta, acomp,  STDLAB =c("QUIT",  "NEXT", "PREV", "HALF"),
TZ=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view.seis_+3A_aday">aday</code></td>
<td>
<p>index of which day to use in vector days </p>
</td></tr>
<tr><td><code id="view.seis_+3A_ihour">ihour</code></td>
<td>
<p>hour to start </p>
</td></tr>
<tr><td><code id="view.seis_+3A_inkhour">inkhour</code></td>
<td>
<p>increment in hours for viewing panel </p>
</td></tr>
<tr><td><code id="view.seis_+3A_savefile">SAVEFILE</code></td>
<td>
<p>file to save window picks in </p>
</td></tr>
<tr><td><code id="view.seis_+3A_days">days</code></td>
<td>
<p>vector of days to select from </p>
</td></tr>
<tr><td><code id="view.seis_+3A_db">DB</code></td>
<td>
<p>data base list of file names and start-times and durations </p>
</td></tr>
<tr><td><code id="view.seis_+3A_usta">usta</code></td>
<td>
<p>stations to select </p>
</td></tr>
<tr><td><code id="view.seis_+3A_acomp">acomp</code></td>
<td>
<p>compnents to select </p>
</td></tr>
<tr><td><code id="view.seis_+3A_stdlab">STDLAB</code></td>
<td>
<p>vector of buttons,  DEFAULT = c(&quot;QUIT&quot;,  &quot;NEXT&quot;, &quot;PREV&quot;, &quot;HALF&quot;,  &quot;WPIX&quot;, &quot;zoom out&quot;,
&quot;refresh&quot;, &quot;restore&quot;,  &quot;SPEC&quot;, &quot;SGRAM&quot; ,&quot;WLET&quot;, &quot;FILT&quot;,
&quot;Pinfo&quot;, &quot;WINFO&quot;) </p>
</td></tr>
<tr><td><code id="view.seis_+3A_tz">TZ</code></td>
<td>
<p>Number of hours to add to GMT to get local time</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The program view.seis assumes the data is stored in files accessable
by the user and that the DB list has been scanned
in and parsed.
</p>


<h3>Value</h3>

<p>Graphical side effects and save.wpix stores appended picks.
</p>


<h3>Note</h3>

<p>On LINUX systems I wrote these (non-R) programs
to set up the data base for segy data:FLS.prl, segydatabase.
To get these contact me directly.  TZ is (-6) for Guatemala.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>swig, save.wpix</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 


##############  method one:
#######  read in data base from files:
DB  &lt;- scan(file="/home/lees/Site/Santiaguito/SG09/segyDB", list(fn="",
yr=0, jd=0, hr=0, mi=0, sec=0, dur=0))


##  note: the file name includes the station SMI and the component J

##########  extract names of stations and components
das1  &lt;- substr(DB$fn, 58, 60)
comp1 &lt;- substr(DB$fn, 62,62))

###########  set up times (start and end) in julian days for selection
 DB$t1 &lt;- DB$jd + DB$hr/24 + DB$mi/(24*60) + DB$sec/(24*3600)
DB$t2 &lt;- DB$t1 + DB$dur/(24*3600)


#######   method 2:

DB &lt;- makeDB("/Users/lees/Site/Santiaguito/SG09", pattern = "R", kind = 1)
udays &lt;- unique(paste(DB$yr, DB$jd))
sdays &lt;-  as.numeric( unlist( strsplit(udays, split=" ") ) )


ye &lt;- sdays[seq(from=1, to=length(sdays), by=2)]
d  &lt;- sdays[seq(from=2, to=length(sdays), by=2)]
o &lt;- order(ye+d/366)

days &lt;- list(yr = ye[o], jd=d[o])



 das1  &lt;- DB$sta
  comp1 &lt;-  DB$comp

#######   get unique stations from list:
usta &lt;- unique(das1)

###########   choose the desired components 
acomp &lt;- c('I','V')

####   aday refers to one of the days listed in the days structure


###  days is a list of days (and associated years) that are in teh DB
days &lt;- list(jd=c(365,366, 1,2,3,4), yr=c(2008, 2008, rep(2009, times=4)))


#### extract days from the DB list:
udays &lt;- unique(paste(DB$yr, DB$jd))
sdays &lt;-  as.numeric( unlist( strsplit(udays, split=" ") ) )
ye &lt;- sdays[seq(from=1, to=length(sdays), by=2)]
d  &lt;- sdays[seq(from=2, to=length(sdays), by=2)]
o &lt;- order(ye+d/366)

days &lt;- list(yr = ye[o], jd=d[o])

####

aday &lt;- 3
SAVEFILE &lt;- 'wpix.out'
ihour &lt;- 15
inkhour &lt;- .5

####   aday refers to one of the days listed in the days structure


view.seis(aday, ihour, inkhour, SAVEFILE, days, DB, usta, acomp, TZ=(-6))




## End(Not run)



</code></pre>

<hr>
<h2 id='vlen'>vector length </h2><span id='topic+vlen'></span>

<h3>Description</h3>

<p>calculate euclidian vector length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vlen(A1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vlen_+3A_a1">A1</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Euclidian Length
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vlen(c(23, 43))




</code></pre>

<hr>
<h2 id='vline'>vertical line on trace panel</h2><span id='topic+vline'></span>

<h3>Description</h3>

<p>add vertical line on trace panel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vline(x, per = 1, COL = 1, NUM = FALSE, LAB = 1:length(x), lwd = 0, lty = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vline_+3A_x">x</code></td>
<td>
<p>vector of x-locations</p>
</td></tr>
<tr><td><code id="vline_+3A_per">per</code></td>
<td>
<p>percent of window</p>
</td></tr>
<tr><td><code id="vline_+3A_col">COL</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code id="vline_+3A_num">NUM</code></td>
<td>
<p>number lines </p>
</td></tr>
<tr><td><code id="vline_+3A_lab">LAB</code></td>
<td>
<p>character labels </p>
</td></tr>
<tr><td><code id="vline_+3A_lwd">lwd</code></td>
<td>
<p>line width </p>
</td></tr>
<tr><td><code id="vline_+3A_lty">lty</code></td>
<td>
<p>line type</p>
</td></tr>
</table>


<h3>Details</h3>

<p>adds vertical lines to plot
</p>


<h3>Value</h3>

<p>Graphical side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>plocator</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(c(0,1), c(0,1), type='n')

vline(runif(4),  COL ='red')


</code></pre>

<hr>
<h2 id='wiggle.env'>Plot time series envelope</h2><span id='topic+wiggle.env'></span>

<h3>Description</h3>

<p>Gets an envelope and lpots on a time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wiggle.env(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wiggle.env_+3A_x">x</code></td>
<td>
<p>x-coordinate</p>
</td></tr>
<tr><td><code id="wiggle.env_+3A_y">y</code></td>
<td>
<p>y-coordinate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses Peaks and smooth.pline to estimate envelope
</p>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>structure from smooth.spline</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>smooth.spline, peaks, hilbert</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##  data("CE1.Example.RDATA")
##   load("CE1.Example.RDATA")
data(CE1)
plot(CE1$x, CE1$y, type='l')
wiggle.env(CE1$x, CE1$y)
we = wiggle.env(CE1$x, CE1$y)
lines(we$x, we$y, col='red')

</code></pre>

<hr>
<h2 id='wiggleimage'>Seismic section
</h2><span id='topic+wiggleimage'></span>

<h3>Description</h3>

<p>Plot a seismic section as shot record
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wiggleimage(Arot, dt = 1, dx = 1, col = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wiggleimage_+3A_arot">Arot</code></td>
<td>
<p>Matrix: columns are individual traces
</p>
</td></tr>
<tr><td><code id="wiggleimage_+3A_dt">dt</code></td>
<td>
<p>Sample rate, seconds
</p>
</td></tr>
<tr><td><code id="wiggleimage_+3A_dx">dx</code></td>
<td>
<p>spacing in x-direction.  If a vector is given,
it is used instead and dx is taken from the difference of the first
to elements.
</p>
</td></tr>
<tr><td><code id="wiggleimage_+3A_col">col</code></td>
<td>
<p>color for plotting wiggles
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot is arranged with time going down the page
</p>


<h3>Value</h3>

<p>Graphical side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>matsquiggle, varsquiggle
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

S1 = symshot1()
wiggleimage(S1$smograms, dt = -S1$dt, dx = S1$x, col = "black")

</code></pre>

<hr>
<h2 id='WINGH'>Window a GH structure and extract data
</h2><span id='topic+WINGH'></span>

<h3>Description</h3>

<p>Window a time slice of seismic data and extract from
a GH structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WINGH(GH, sel = 1, WIN = c(0,1) )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WINGH_+3A_gh">GH</code></td>
<td>
<p>RSEIS seismic list
</p>
</td></tr>
<tr><td><code id="WINGH_+3A_sel">sel</code></td>
<td>
<p>Select which traces to extract
</p>
</td></tr>
<tr><td><code id="WINGH_+3A_win">WIN</code></td>
<td>
<p>Time window to extract (seconds from the beginning
of the first trace.)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Preserves the data structure of the GH list.
The purpose of this function is to extract a small subset
of data from a larger data set (or longer time series)
for subsequent processing.
</p>


<h3>Value</h3>

<p>New GH structure.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>swig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(GH)

swig(GH, sel=which(GH$COMPS=="V" ))


jh = WINGH(GH, sel = which(GH$COMPS=="V" ), WIN = c(3.821281, 12.861820) )

swig(jh)
## compare with:
swig(GH, sel=which(GH$COMPS=="V" ), WIN = c(3.821281, 12.861820))




## End(Not run)
</code></pre>

<hr>
<h2 id='winmark'>Window Mark</h2><span id='topic+winmark'></span>

<h3>Description</h3>

<p>Add Mark up to current seismic trace with a bar desgnating a window
selection.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>winmark(a1, a2, side = 1, bar = NULL,
leg = NULL, col = col, lwd = 1, lty = 1,
arrows = FALSE, alen = 0.1, leglen = 0.15,
 LEGON = 3, BARON = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="winmark_+3A_a1">a1</code></td>
<td>
<p>x1-location</p>
</td></tr>
<tr><td><code id="winmark_+3A_a2">a2</code></td>
<td>
<p>x2-location </p>
</td></tr>
<tr><td><code id="winmark_+3A_side">side</code></td>
<td>
<p>side where bar is drawn, as in axes: 1=bottom,2=left,3=top,4=right  </p>
</td></tr>
<tr><td><code id="winmark_+3A_bar">bar</code></td>
<td>
<p>location of bar</p>
</td></tr>
<tr><td><code id="winmark_+3A_leg">leg</code></td>
<td>
<p>location of leg</p>
</td></tr>
<tr><td><code id="winmark_+3A_col">col</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code id="winmark_+3A_lwd">lwd</code></td>
<td>
<p>line width</p>
</td></tr>
<tr><td><code id="winmark_+3A_lty">lty</code></td>
<td>
<p>line type</p>
</td></tr>
<tr><td><code id="winmark_+3A_arrows">arrows</code></td>
<td>
<p>logical, add arrows to ends of legs</p>
</td></tr>
<tr><td><code id="winmark_+3A_alen">alen</code></td>
<td>
<p>length of arrow heads, inches, default=0.125</p>
</td></tr>
<tr><td><code id="winmark_+3A_leglen">leglen</code></td>
<td>
<p>length of arrows aas percent of usr(&quot;par&quot;), default=0.125 </p>
</td></tr>
<tr><td><code id="winmark_+3A_legon">LEGON</code></td>
<td>

<p>plotting flag for legs: 0=no legs, 1=left leg, 2=right leg, 3=both legs(default)
</p>
</td></tr>
<tr><td><code id="winmark_+3A_baron">BARON</code></td>
<td>

<p>logical:plotting flag for bar
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used for marking seismic
traces.  The window marker looks like a staple, three segments are drawn, a bar
and two legs. The thickness of the legs are determined by
bar and leg, unless these are missing.
if they are missing parameter side is used to set the locations, and
leglen determines the length of the legs.
If either bar or leg are missing the
parameters are derived from par(&quot;usr&quot;) and are applied to whole
window.
side switches the orientation
of the staple mark, with the legs pointing according away from named the
axis.
</p>


<h3>Value</h3>

<p>Graphical Side Effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(c(0,1), c(0,1), type='n', xlab='', ylab='' )


winmark(.3, .7,       side=3, col='brown', arrows=TRUE, leglen=.4)
winmark(.3, .7,       side=1, col='blue', arrows=TRUE, leglen=.5)

winmark(.3, .7,        side=2, col='green',
arrows=TRUE, alen=.05, leglen=.4)


winmark(.3, .7,      leg=.65, bar=.6,
side=4, col='orange', arrows=TRUE, alen=.1, leglen=.125)


winmark(.3, .7,      bar=.65, leg=.6,
side=4, col='seagreen', arrows=TRUE, alen=.1, leglen=.125)
#############  examples with different legs showing
plot(c(0,1), c(0,1), type='n', xlab='', ylab='' )

winmark(.3, .7,       side=3, col='brown',
arrows=TRUE, leglen=.4, LEGON=1)
winmark(.3, .4,       side=1, col='brown',
 arrows=TRUE, leglen=.4, LEGON=2)
winmark(.7, .9,       side=1, col='blue',
arrows=TRUE, leglen=.4, LEGON=0)


</code></pre>

<hr>
<h2 id='winseis24'>Locator for plotseis24
</h2><span id='topic+winseis24'></span>

<h3>Description</h3>

<p>Locator for plotseis24
</p>


<h3>Usage</h3>

<pre><code class='language-R'>winseis24(pjj, pch = 3, col = "red")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="winseis24_+3A_pjj">pjj</code></td>
<td>
<p>out put of plotseis24</p>
</td></tr>
<tr><td><code id="winseis24_+3A_pch">pch</code></td>
<td>
<p>plotting character when clicking</p>
</td></tr>
<tr><td><code id="winseis24_+3A_col">col</code></td>
<td>
<p>color for plotting when clicking</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After extracting 24 hours and plotting with
plotseis24, use winseis24 to click on the plot and
return times for further analysis or zooming.
</p>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>hr</code></td>
<td>
<p>hours picked</p>
</td></tr>
<tr><td><code>yr</code></td>
<td>
<p>year</p>
</td></tr>
<tr><td><code>jd</code></td>
<td>
<p>julian day</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>plotseis24, getseis24
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 
JJ &lt;- getseis24(DB, 2008, 366, usta, acomp, kind = 1)
 
pjj &lt;- plotseis24(JJ, dy=1/18, FIX=24, SCALE=1,
FILT=list(ON=FALSE, fl=0.05 , fh=20.0, type="BP", proto="BU"),
RCOLS=c(rgb(0.2, .2, 1), rgb(.2, .2, .2))  )

winseis24(pjj)



## End(Not run)


</code></pre>

<hr>
<h2 id='wlet.do'>Return Wavelet transform</h2><span id='topic+wlet.do'></span>

<h3>Description</h3>

<p>Wavelet transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wlet.do(why, dt, noctave = 6, nvoice = 20, w0=5,
flip = TRUE, ploty = TRUE, zscale = 1,
col = terrain.colors(100), STAMP = STAMP, units="", scaleloc=c(0.4,0.95))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wlet.do_+3A_why">why</code></td>
<td>
<p>signal</p>
</td></tr>
<tr><td><code id="wlet.do_+3A_dt">dt</code></td>
<td>
<p>sample rate (s)</p>
</td></tr>
<tr><td><code id="wlet.do_+3A_noctave">noctave</code></td>
<td>
<p>number of octaves, default=6</p>
</td></tr>
<tr><td><code id="wlet.do_+3A_nvoice">nvoice</code></td>
<td>
<p>number of voices, nvoice = 20 </p>
</td></tr>
<tr><td><code id="wlet.do_+3A_w0">w0</code></td>
<td>
<p>central frequency for morlet wavelet, default=5</p>
</td></tr>
<tr><td><code id="wlet.do_+3A_flip">flip</code></td>
<td>
<p>logical,  whether to flip the orientation </p>
</td></tr>
<tr><td><code id="wlet.do_+3A_ploty">ploty</code></td>
<td>
<p>logical, whether to plot y </p>
</td></tr>
<tr><td><code id="wlet.do_+3A_zscale">zscale</code></td>
<td>
<p>scale of the image </p>
</td></tr>
<tr><td><code id="wlet.do_+3A_col">col</code></td>
<td>
<p>color palette</p>
</td></tr>
<tr><td><code id="wlet.do_+3A_stamp">STAMP</code></td>
<td>
<p>cahracter stamp for identification</p>
</td></tr>
<tr><td><code id="wlet.do_+3A_units">units</code></td>
<td>
<p>character, units to put on plot</p>
</td></tr>
<tr><td><code id="wlet.do_+3A_scaleloc">scaleloc</code></td>
<td>
<p>2-vector, percentatge of bottom margin for the color
scale</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the cwt (package:Rwave) code to calculate the continuous wavelet
transform,
but plots it differently.
Morelet wavelet is used by default.   The cwt produces an
image, the modulus of the transform, which is passed on to wlet.do
along with the number of octaves and the number of voices.
Plotting parameters are passed to the function so that replotting can
be accomplished (use plotwlet) without having to recalculate the
transform.
</p>
<p>Plotting parameters are passed on to the plotting function, plotwlet.
</p>


<h3>Value</h3>

<table>
<tr><td><code>baha</code></td>
<td>
<p>list:
wavelet transform image,
noctave = number of  octaves,
nvoice = number of voices, w0= central freq, 
flip = logical, whether image is flipped (default=TRUE) </p>
</td></tr>
<tr><td><code>PE</code></td>
<td>
<p>plotting information list:
why=y-axis,
dt=time series sample,
interval,
zscale=(1,2,3) image scaling,
col=color map,
ygrid = logical(default=FALSE),
STAMP = character string </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>Rwave,  cwt , plotwlet, contwlet , pwlet2freqs, wlet.drive</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(CE1)

plot(CE1$x, CE1$y, type='l')

require(Rwave)

out &lt;- wlet.do(CE1$y, CE1$dt, flip = FALSE, ploty = TRUE)


####  show with different scalings:
plotwlet(out$baha, CE1$y, CE1$dt , zscale=3,
col=rainbow(100) ,  ygrid=FALSE)

plotwlet(out$baha, CE1$y, CE1$dt , zscale=1,  col=terrain.colors(100) ,
ygrid=TRUE)

##############  add frequency scale on the right hand side of image
pfreqs &lt;- c(0.5, 1, 2,3,4,5, 10, 14)

 zp &lt;- pwlet2freqs(noctave=out$baha$noctave , nvoice=out$baha$nvoice,
     CE1$dt,
     flip = TRUE, pfreqs, plot = TRUE,
     perc = 0.85)





## End(Not run)

</code></pre>

<hr>
<h2 id='wlet.drive'>Interactive wavelet transform driver</h2><span id='topic+wlet.drive'></span>

<h3>Description</h3>

<p>interactive wavelet transform driver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wlet.drive(Xamp, DT = 0.008, noctave = 6, nvoice = 20, w0=5, STAMP = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wlet.drive_+3A_xamp">Xamp</code></td>
<td>
<p>vector of signal</p>
</td></tr>
<tr><td><code id="wlet.drive_+3A_dt">DT</code></td>
<td>
<p>sample interval (s) </p>
</td></tr>
<tr><td><code id="wlet.drive_+3A_noctave">noctave</code></td>
<td>
<p>number of octaves, default=6</p>
</td></tr>
<tr><td><code id="wlet.drive_+3A_nvoice">nvoice</code></td>
<td>
<p>number of voices, nvoice = 20 </p>
</td></tr>
<tr><td><code id="wlet.drive_+3A_w0">w0</code></td>
<td>
<p>central frequency for morlet wavelet, default=5</p>
</td></tr>
<tr><td><code id="wlet.drive_+3A_stamp">STAMP</code></td>
<td>
<p>character string for identification</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>RPGM, plotwlet, wlet.do </p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(CE1)
plot(CE1$x, CE1$y, type='l')

if(interactive() ) wlet.drive(CE1$y, CE1$dt, STAMP=CE1$name)



</code></pre>

<hr>
<h2 id='write1segy'>Write One segy file
</h2><span id='topic+write1segy'></span><span id='topic+write1sac'></span>

<h3>Description</h3>

<p>Write out one segy binary format file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write1segy(alist, fn = NULL, BIGLONG = FALSE)
write1sac(alist, fn = NULL, BIGLONG = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write1segy_+3A_alist">alist</code></td>
<td>

<p>list of traces with  segy/sac header and an integer/real format time series
</p>
</td></tr>
<tr><td><code id="write1segy_+3A_fn">fn</code></td>
<td>

<p>Output file name
</p>
</td></tr>
<tr><td><code id="write1segy_+3A_biglong">BIGLONG</code></td>
<td>

<p>logical, indicating whether long is 8 or 4 bytes.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Segy format files are in integer format.
The time series ususally represents counts
recorded in a data acquisition system.  The header includes
meta-data and other identifying information.
</p>


<h3>Value</h3>

<p>Side effects in the file system.
</p>


<h3>Note</h3>

<p>The Endian-ness of the output file will
be the native endian-ness of the system.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>rseis2segy, read1sac, read1segy
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tdir = tempdir()

bed =  read1segy(fn1   , Iendian = 1 , HEADONLY=FALSE, BIGLONG=FALSE)

haname =  write1segy(bed  , fn=paste(tdir,"jimmy.SEGY", sep='/') , BIGLONG=FALSE)


## End(Not run)

</code></pre>

<hr>
<h2 id='writeUW.Acard'>writeUW.Acard</h2><span id='topic+writeUW.Acard'></span>

<h3>Description</h3>

<p>write UW pickfile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeUW.Acard(LOC)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeUW.Acard_+3A_loc">LOC</code></td>
<td>
<p> location structure </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>

<hr>
<h2 id='writeUW.Commentcard'>writeUW.Commentcard</h2><span id='topic+writeUW.Commentcard'></span>

<h3>Description</h3>

<p>write UW pickfile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeUW.Commentcard(comments)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeUW.Commentcard_+3A_comments">comments</code></td>
<td>
<p>comment vector </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>

<hr>
<h2 id='writeUW.DOTcard'>writeUW.DOTcard</h2><span id='topic+writeUW.DOTcard'></span>

<h3>Description</h3>

<p>write UW pickfile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeUW.DOTcard(STAS)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeUW.DOTcard_+3A_stas">STAS</code></td>
<td>
<p>station structure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>

<hr>
<h2 id='writeUW.Ecard'>writeUW.Ecard</h2><span id='topic+writeUW.Ecard'></span>

<h3>Description</h3>

<p>write UW pickfile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeUW.Ecard(E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeUW.Ecard_+3A_e">E</code></td>
<td>
<p>Ecard</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>

<hr>
<h2 id='writeUW.Fcard'>writeUW.Fcard</h2><span id='topic+writeUW.Fcard'></span>

<h3>Description</h3>

<p>write UW pickfile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeUW.Fcard(F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeUW.Fcard_+3A_f">F</code></td>
<td>
<p>F-card info</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>

<hr>
<h2 id='writeUW.Hcard'>writeUW.Hcard</h2><span id='topic+writeUW.Hcard'></span>

<h3>Description</h3>

<p>write UW pickfile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeUW.Hcard(H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeUW.Hcard_+3A_h">H</code></td>
<td>
<p>H-card</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>

<hr>
<h2 id='writeUW.Ncard'>writeUW.Ncard</h2><span id='topic+writeUW.Ncard'></span>

<h3>Description</h3>

<p>write UW pickfile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeUW.Ncard(N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeUW.Ncard_+3A_n">N</code></td>
<td>
<p>Name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>

<hr>
<h2 id='writeUW.OSTAScard'>writeUW.OSTAScard</h2><span id='topic+writeUW.OSTAScard'></span>

<h3>Description</h3>

<p>write UW pickfile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeUW.OSTAScard(OSTAS)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeUW.OSTAScard_+3A_ostas">OSTAS</code></td>
<td>
<p>OSTAS</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>

<hr>
<h2 id='writeUWpickfile'>UW formatted ascii pickfile</h2><span id='topic+writeUWpickfile'></span>

<h3>Description</h3>

<p>Write UW formatted ascii pickfile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeUWpickfile(A, output = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeUWpickfile_+3A_a">A</code></td>
<td>
<p>Pickfile structure</p>
</td></tr>
<tr><td><code id="writeUWpickfile_+3A_output">output</code></td>
<td>
<p>output file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Side Effects. Used to save ASCII versions of pickfiles for other processing.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>EmptyPickfile</p>

<hr>
<h2 id='X2RSEIS'>Extract data to RSEIS file
</h2><span id='topic+X2RSEIS'></span>

<h3>Description</h3>

<p>swig Button Extract seismic data in RSEIS
and save in GH format for exchange.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>X2RSEIS(nh, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="X2RSEIS_+3A_nh">nh</code></td>
<td>
<p>RSEIS seismic data format
</p>
</td></tr>
<tr><td><code id="X2RSEIS_+3A_g">g</code></td>
<td>
<p>swig parameters
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used internally in
RSEIS as a button in swig.  The program should be run in
a directory that has write permission.
</p>
<p>The data is saved as  a GH list.
</p>


<h3>Value</h3>

<p>No value, writes to disk
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>XTR, X2SAC, swig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
###  get data:
GH &lt;-  Mine.seis(at1, at2, DB, NULL , NULL,
        kind = 1, Iendian=1)
w &lt;- swig(GH, PADDLAB=c("X2SAC","X2RSEIS","YPIX" ) )


## End(Not run)
</code></pre>

<hr>
<h2 id='X2SAC'>Extract Data to SAC format
</h2><span id='topic+X2SAC'></span>

<h3>Description</h3>

<p>swig Button Extract seismic data in RSEIS
and save in SAC format for exchange.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>X2SAC(nh, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="X2SAC_+3A_nh">nh</code></td>
<td>
<p>RSEIS seismic data format
</p>
</td></tr>
<tr><td><code id="X2SAC_+3A_g">g</code></td>
<td>
<p>swig parameters
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used internally in
RSEIS as a button in swig.  The program should be run in
a directory that has write permission.
</p>


<h3>Value</h3>

<p>No value, writes to disk
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>XTR, X2RSEIS, swig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
###  get data:
GH &lt;-  Mine.seis(at1, at2, DB, NULL , NULL,
        kind = 1, Iendian=1)
w &lt;- swig(GH, PADDLAB=c("X2SAC","X2RSEIS","YPIX" ) )


## End(Not run)
</code></pre>

<hr>
<h2 id='xcor2'>Cross Correlation</h2><span id='topic+xcor2'></span>

<h3>Description</h3>

<p>Cross correlation of two signals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xcor2(a1, a2, DT, PLOT = FALSE, LAG = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xcor2_+3A_a1">a1</code></td>
<td>
<p>input signal 1</p>
</td></tr>
<tr><td><code id="xcor2_+3A_a2">a2</code></td>
<td>
<p>input signal 1</p>
</td></tr>
<tr><td><code id="xcor2_+3A_dt">DT</code></td>
<td>
<p>deltaT in seconds</p>
</td></tr>
<tr><td><code id="xcor2_+3A_plot">PLOT</code></td>
<td>
<p>logical TRUE=plot</p>
</td></tr>
<tr><td><code id="xcor2_+3A_lag">LAG</code></td>
<td>
<p> time lag for correlation function </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Illustrates the cross correlation of two time series.
</p>


<h3>Value</h3>

<table>
<tr><td><code>ccf</code></td>
<td>
<p>Return list from function ccf</p>
</td></tr>
<tr><td><code>mlag</code></td>
<td>
<p>maximum lag in time</p>
</td></tr>
<tr><td><code>mccx</code></td>
<td>
<p>value of ccf at max lag mlag</p>
</td></tr>
<tr><td><code>mlag2</code></td>
<td>
<p>maximum absolute value lag </p>
</td></tr>
<tr><td><code>mccx2</code></td>
<td>
<p>value of ccf at mlag2</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>ccf</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CE1)

ts1 &lt;- CE1$y[CE1$x&gt;5.443754 &amp; CE1$x&lt;5.615951]

ts2 &lt;- CE1$y[CE1$x&gt;5.760959]
ts2 &lt;- ts2[1:length(ts1)]

ts1 &lt;- ts1-mean(ts1)
ts2 &lt;- ts2-mean(ts2)

xc &lt;- xcor2(ts1, ts2, CE1$dt , PLOT = TRUE)

</code></pre>

<hr>
<h2 id='xprod'>Vector Cross Product</h2><span id='topic+xprod'></span>

<h3>Description</h3>

<p>Cross product of two vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xprod(A1, A2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xprod_+3A_a1">A1</code></td>
<td>
<p>3 component vector of x,y,z</p>
</td></tr>
<tr><td><code id="xprod_+3A_a2">A2</code></td>
<td>
<p>3 component vector of x,y,z </p>
</td></tr>
</table>


<h3>Value</h3>

<p>3 component vector of A1 cross  A2
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>B1 &lt;- c(4,9,2)
B2 &lt;- c(2,-5,4)

xprod(B1, B2)


</code></pre>

<hr>
<h2 id='XTR'>Buttons for swig
</h2><span id='topic+XTR'></span><span id='topic+NEXT'></span><span id='topic+PREV'></span><span id='topic+HALF'></span><span id='topic+MARK'></span><span id='topic+DOC'></span><span id='topic+REFRESH'></span><span id='topic+RESTORE'></span><span id='topic+ZOOM.out'></span><span id='topic+ZOOM.in'></span><span id='topic+LEFT'></span><span id='topic+RIGHT'></span><span id='topic+SCALE'></span><span id='topic+PSEL'></span><span id='topic+FLIP'></span><span id='topic+PTS'></span><span id='topic+FILT'></span><span id='topic+UNFILT'></span><span id='topic+SPEC'></span><span id='topic+WWIN'></span><span id='topic+SGRAM'></span><span id='topic+WLET'></span><span id='topic+XTR'></span><span id='topic+Pinfo'></span><span id='topic+TSHIFT'></span><span id='topic+RMS'></span><span id='topic+LocStyle'></span><span id='topic+CENTER'></span><span id='topic+fspread'></span><span id='topic+Xwin'></span>

<h3>Description</h3>

<p>defining functions for swig
</p>


<h3>Usage</h3>

<pre><code class='language-R'>XTR(nh, g)
NEXT(nh, g)
PREV(nh, g)
HALF(nh, g)
MARK(nh, g)
DOC(nh, g)
REFRESH(nh, g)
RESTORE(nh, g)
ZOOM.out(nh, g)
ZOOM.in(nh, g)
RIGHT(nh, g)
LEFT(nh, g)
SCALE(nh, g)
PSEL(nh, g)
FLIP(nh, g)
PTS(nh, g)
FILT(nh, g)
UNFILT(nh, g)
SPEC(nh, g)
WWIN(nh, g)
SGRAM(nh, g)
WLET(nh, g)
XTR(nh, g)
Pinfo(nh, g)
TSHIFT(nh, g)
RMS(nh, g)
LocStyle(nh, g)
CENTER(nh, g)
fspread(nh, g)
Xwin(nh, g)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="XTR_+3A_nh">nh</code></td>
<td>
<p>waveform list for RSEIS
</p>
</td></tr>
<tr><td><code id="XTR_+3A_g">g</code></td>
<td>
<p>plotting parameter list for interactive program
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Buttons can be defined on the fly.
</p>


<h3>Value</h3>

<p>The return value depends on the nature of the function
as it is returned to the main code swig.
Choices for returning to swig are: break, replot, revert, replace,
donothing, exit.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>swig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

MYFUNC&lt;-function(nh, g)
  {
    print("pressed MYFUNC")
    g$sel
    d  &lt;-  data.frame(list(stations=nh$STNS[g$sel],
                   components=nh$COMPS[g$sel]))
     print(d)        
    g$action  &lt;-  "replot"
    invisible(list(global.vars=g))	
  }

STDLAB &lt;- c("DONE", "QUIT", "SELBUT" , "PSEL", "MYFUNC" )
data(GH)
JJ  &lt;-  swig(GH, sel=1:10, STDLAB=STDLAB)


## End(Not run)


</code></pre>

<hr>
<h2 id='xtract.trace'>Extract trace</h2><span id='topic+xtract.trace'></span>

<h3>Description</h3>

<p>Extract one time series trace from an RSEIS data list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xtract.trace(GH, sel = 1, WIN = c(0, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xtract.trace_+3A_gh">GH</code></td>
<td>
<p>RSEIS list</p>
</td></tr>
<tr><td><code id="xtract.trace_+3A_sel">sel</code></td>
<td>
<p>select trace index</p>
</td></tr>
<tr><td><code id="xtract.trace_+3A_win">WIN</code></td>
<td>
<p>time window on trace, relative to start</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An attribute of dt (sample time interval)
is attached to the time series for
use in plotting.
</p>


<h3>Value</h3>

<table>
<tr><td><code>vector</code></td>
<td>
<p>amplitudes</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(GH)

x1  &lt;- xtract.trace(GH, sel = 1, WIN = c(0, 1))
plot(x1, type='l')

</code></pre>

<hr>
<h2 id='yeardate'>time in decimal years</h2><span id='topic+yeardate'></span>

<h3>Description</h3>

<p>contract a date to decimal years
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yeardate(yr, jd, hr, mi, sec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yeardate_+3A_yr">yr</code></td>
<td>
<p>year</p>
</td></tr>
<tr><td><code id="yeardate_+3A_jd">jd</code></td>
<td>
<p>julian day</p>
</td></tr>
<tr><td><code id="yeardate_+3A_hr">hr</code></td>
<td>
<p>hour</p>
</td></tr>
<tr><td><code id="yeardate_+3A_mi">mi</code></td>
<td>
<p>minute</p>
</td></tr>
<tr><td><code id="yeardate_+3A_sec">sec</code></td>
<td>
<p>second</p>
</td></tr>
</table>


<h3>Value</h3>

<p>decimal time
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>secdif</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   yeardate(2005, 98, 12, 16, 32)
   
</code></pre>

<hr>
<h2 id='YPIX'>PICK Buttons for swig
</h2><span id='topic+YPIX'></span><span id='topic+WPIX'></span><span id='topic+NOPIX'></span><span id='topic+REPIX'></span><span id='topic+DELpix'></span><span id='topic+PickWin'></span><span id='topic+pADDPIX'></span><span id='topic+Ppic'></span><span id='topic+Spic'></span><span id='topic+Apic'></span><span id='topic+POLSWITCH'></span><span id='topic+Pup'></span><span id='topic+Pnil'></span><span id='topic+Pdown'></span><span id='topic+FILLPIX'></span><span id='topic+RIDPIX'></span><span id='topic+SEEPIX'></span><span id='topic+ROT.RT'></span><span id='topic+JustV'></span><span id='topic+JustE'></span><span id='topic+JustN'></span><span id='topic+JustF'></span><span id='topic+SHOW3'></span><span id='topic+iNEXT'></span><span id='topic+noPS'></span>

<h3>Description</h3>

<p>defining functions for swig
</p>


<h3>Usage</h3>

<pre><code class='language-R'>YPIX(nh, g)
WPIX(nh, g)
NOPIX(nh, g)
REPIX(nh, g)
DELpix(nh, g)
PickWin(nh, g)
pADDPIX(nh, g, phase)
Ppic(nh, g)
Spic(nh, g)
Apic(nh, g)
POLSWITCH(nh, g, dir)
Pup(nh, g)
Pnil(nh, g)
Pdown(nh, g)
FILLPIX(nh, g)
RIDPIX(nh, g)
SEEPIX(nh, g)
ROT.RT(nh, g)
JustV(nh, g)
JustE(nh, g)
JustN(nh, g)
JustF(nh, g)
SHOW3(nh, g)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="YPIX_+3A_nh">nh</code></td>
<td>
<p>waveform list for RSEIS
</p>
</td></tr>
<tr><td><code id="YPIX_+3A_g">g</code></td>
<td>
<p>plotting parameter list for interactive program
</p>
</td></tr>
<tr><td><code id="YPIX_+3A_phase">phase</code></td>
<td>
<p>phase name (P, S, A, etc...)
</p>
</td></tr>
<tr><td><code id="YPIX_+3A_dir">dir</code></td>
<td>
<p>vertical up, down or nil
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Buttons can be defined on the fly.
</p>

<dl>
<dt>YPIX</dt><dd><p>Multiple picks on a panel</p>
</dd>
<dt>WPIX</dt><dd><p>window picks (start and end)</p>
</dd>
<dt>NOPIX</dt><dd><p>remove the picks</p>
</dd>
<dt>REPIX</dt><dd><p>un-remove the picks</p>
</dd>
<dt>DELpix</dt><dd><p>Delete pix near clicks</p>
</dd>
<dt>PickWin</dt><dd><p>Pick window for 3 component picking</p>
</dd>
<dt>pADDPIX</dt><dd><p>add picks</p>
</dd>
<dt>Ppic</dt><dd><p>P-wave arrival (only one per station) </p>
</dd>
<dt>Spic</dt><dd><p>S-wave arrival (only one per station)</p>
</dd>
<dt>Apic</dt><dd><p>acoustic-wave arrival (only one per station)</p>
</dd>
<dt>POLSWITCH</dt><dd><p>flip polarity</p>
</dd>
<dt>Pup</dt><dd><p>Polarity Up</p>
</dd>
<dt>Pnil</dt><dd><p>Polarity nil</p>
</dd>
<dt>Pdown</dt><dd><p>Polarity down</p>
</dd>
<dt>FILLPIX</dt><dd><p>Fill the pick from bottom to top of panel</p>
</dd>
<dt>RIDPIX</dt><dd><p>remove pick</p>
</dd>
<dt>SEEPIX</dt><dd><p>print current picks to screen</p>
</dd>
<dt>ROT.RT</dt><dd><p>Rotate to radial and transverse (need event and
station locations</p>
</dd>
<dt>JustV</dt><dd><p>Display only vertical components</p>
</dd>
<dt>JustE</dt><dd><p>Display only east components</p>
</dd>
<dt>JustN</dt><dd><p>Display only north components</p>
</dd>
<dt>JustF</dt><dd><p>Display only infrasound (F) components</p>
</dd>
<dt>SHOW3</dt><dd><p>Display All 3 components</p>
</dd>
<dt>iNEXT</dt><dd><p>Used internally in PickWin to move to next station</p>
</dd>
</dl>



<h3>Value</h3>

<p>The return value depends on the nature of the function
as it is returned to the main code swig.
Choices for returning to swig are: break, replot, revert, replace,
donothing, exit.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>swig, XTR
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

MYFUNC&lt;-function(nh, g)
  {
    print("pressed MYFUNC")
    d  &lt;-  data.frame(list(stations=nh$STNS, components=nh$COMPS))
print(d)        
    g$action  &lt;-  "replot"
    invisible(list(global.vars=g))	
  }

STDLAB &lt;- c("DONE", "QUIT", "SELBUT" , "MYFUNC" )
data(GH)
JJ  &lt;-  swig(GH, sel=1:10, STDLAB=STDLAB)


## End(Not run)


</code></pre>

<hr>
<h2 id='YRsecdif'>Return difference in seconds</h2><span id='topic+YRsecdif'></span><span id='topic+YRsecdifL'></span>

<h3>Description</h3>

<p>Difference between two Date/Times (Julian Day)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>YRsecdif(jd1, hr1, mi1, sec1, jd2, hr2, mi2, sec2, yr1 = 0, yr2 = 0)

YRsecdifL(T1, T2)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="YRsecdif_+3A_jd1">jd1</code></td>
<td>
<p>Julian Day</p>
</td></tr>
<tr><td><code id="YRsecdif_+3A_hr1">hr1</code></td>
<td>
<p>hour</p>
</td></tr>
<tr><td><code id="YRsecdif_+3A_mi1">mi1</code></td>
<td>
<p>minute</p>
</td></tr>
<tr><td><code id="YRsecdif_+3A_sec1">sec1</code></td>
<td>
<p>second</p>
</td></tr>
<tr><td><code id="YRsecdif_+3A_jd2">jd2</code></td>
<td>
<p>Julian Day</p>
</td></tr>
<tr><td><code id="YRsecdif_+3A_hr2">hr2</code></td>
<td>
<p> hour </p>
</td></tr>
<tr><td><code id="YRsecdif_+3A_mi2">mi2</code></td>
<td>
<p> minute </p>
</td></tr>
<tr><td><code id="YRsecdif_+3A_sec2">sec2</code></td>
<td>
<p>second</p>
</td></tr>
<tr><td><code id="YRsecdif_+3A_yr1">yr1</code></td>
<td>
<p>year 1</p>
</td></tr>
<tr><td><code id="YRsecdif_+3A_yr2">yr2</code></td>
<td>
<p> year 2</p>
</td></tr>
<tr><td><code id="YRsecdif_+3A_t1">T1</code></td>
<td>
<p>list 1 with date time</p>
</td></tr>
<tr><td><code id="YRsecdif_+3A_t2">T2</code></td>
<td>
<p>list 2 with date time</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns T2-T1, year is used.
</p>


<h3>Value</h3>

<table>
<tr><td><code>numeric</code></td>
<td>
<p>seconds</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>secdifL, secdif </p>


<h3>Examples</h3>

<pre><code class='language-R'>

T1  &lt;-  list(jd=12, hr=13, mi=23, sec=21, yr=1964 )
T2  &lt;-  list(jd=14, hr=23, mi=23, sec=2, yr=1976)

YRsecdif(T1$jd, T1$hr, T1$mi, T1$sec,  T2$jd, T2$hr, T2$mi, T2$sec,
1964, 1976)

####  or

YRsecdifL(T1, T2)

</code></pre>

<hr>
<h2 id='Zdate'>Date functions</h2><span id='topic+Zdate'></span><span id='topic+dateList'></span><span id='topic+dateStamp'></span>

<h3>Description</h3>

<p>Make character vector from dates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Zdate(info, sel=1, t1=0, sep=':')
dateList(datevec)
dateStamp(datelist, sep=':')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Zdate_+3A_info">info</code></td>
<td>
<p>info structure from trace structure</p>
</td></tr>
<tr><td><code id="Zdate_+3A_sel">sel</code></td>
<td>
<p>selection of which ones to extract,
default=1:length(info$jd) </p>
</td></tr>
<tr><td><code id="Zdate_+3A_t1">t1</code></td>
<td>
<p> time offset, seconds, default=0 </p>
</td></tr>
<tr><td><code id="Zdate_+3A_sep">sep</code></td>
<td>
<p> character for separating the components in the string, default=&quot;:&quot; </p>
</td></tr>
<tr><td><code id="Zdate_+3A_datevec">datevec</code></td>
<td>
<p> vector with yr, jd, mo, day, hr, mi, sec  </p>
</td></tr>
<tr><td><code id="Zdate_+3A_datelist">datelist</code></td>
<td>
<p> output of dateList </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Format date stamp for plotting and identification. Used for STAMP.
</p>


<h3>Value</h3>

<p>character strings
</p>


<h3>Note</h3>

<p>If using Zdate to create a file name, becareful about the separator.  A colon
in the file name on PC and MAC systems can be confusing for the OS.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>swig, dateStamp, ghstamp, filedatetime</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("GH")

sel &lt;-  which(GH$COMPS == "V")

ftime  &lt;-  Zdate(GH$info, sel[1:5], 1)

dvec  &lt;-  c(2009, 134, 5, 14, 10, 32, 24.5, 0)
A  &lt;-  dateList(dvec)
dateStamp(A)

dateStamp(A, sep="_")



</code></pre>

<hr>
<h2 id='zlocator'>zlocator</h2><span id='topic+zlocator'></span>

<h3>Description</h3>

<p>Locator function with set parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zlocator(COL = 1, ID = FALSE, NUM = FALSE, YN = NULL, style = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zlocator_+3A_col">COL</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code id="zlocator_+3A_id">ID</code></td>
<td>
<p>logical, identify points</p>
</td></tr>
<tr><td><code id="zlocator_+3A_num">NUM</code></td>
<td>
<p>number of points </p>
</td></tr>
<tr><td><code id="zlocator_+3A_yn">YN</code></td>
<td>
<p>number of windows to span for lines</p>
</td></tr>
<tr><td><code id="zlocator_+3A_style">style</code></td>
<td>
<p>0,1,2 for differnt style of plotting vertical lines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if the window is divided into YN horizontal regions,
style =2 will plot segments only within regions
based on y-value of locator().
</p>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>x-locations</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y-locations</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>plocator, locator</p>


<h3>Examples</h3>

<pre><code class='language-R'>

plot(c(0,1), c(0,1), type='n')
for(i in 1:5) { abline(h=i/6) }

if(interactive() )zlocator(COL = 1, NUM = 4, YN = 6, style = 2)


</code></pre>

<hr>
<h2 id='ZOOM.SEISN'>ZOOM SEISMIC Panel </h2><span id='topic+ZOOM.SEISN'></span>

<h3>Description</h3>

<p>Zoom interactively on Seismic panel data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZOOM.SEISN(GH, sel = 1:length(GH$dt), WIN = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZOOM.SEISN_+3A_gh">GH</code></td>
<td>
<p>Seismic trace structure </p>
</td></tr>
<tr><td><code id="ZOOM.SEISN_+3A_sel">sel</code></td>
<td>
<p>selection of traces </p>
</td></tr>
<tr><td><code id="ZOOM.SEISN_+3A_win">WIN</code></td>
<td>
<p>time window c(0,1) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Seismic trace structure
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>swig</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

data("GH")
sel &lt;-  which(GH$COMPS=="V")

KF  &lt;-  ZOOM.SEISN(GH, sel=sel, WIN = c(0 , 5)  )

swig(KF)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
