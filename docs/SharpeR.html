<!DOCTYPE html><html><head><title>Help for package SharpeR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SharpeR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.del_sropt'><p>Compute the Sharpe ratio of a hedged Markowitz portfolio.</p></a></li>
<li><a href='#as.sr'><p>Compute the Sharpe ratio.</p></a></li>
<li><a href='#as.sropt'><p>Compute the Sharpe ratio of the Markowitz portfolio.</p></a></li>
<li><a href='#confint.sr'><p>Confidence Interval on (optimal) Signal-Noise Ratio</p></a></li>
<li><a href='#del_sropt'><p>Create an 'del_sropt' object.</p></a></li>
<li><a href='#dsr'><p>The (non-central) Sharpe ratio.</p></a></li>
<li><a href='#dsropt'><p>The (non-central) maximal Sharpe ratio distribution.</p></a></li>
<li><a href='#inference'><p>Inference on noncentrality parameter of F-like statistic</p></a></li>
<li><a href='#is.del_sropt'><p>Is this in the &quot;del_sropt&quot; class?</p></a></li>
<li><a href='#is.sr'><p>Is this in the &quot;sr&quot; class?</p></a></li>
<li><a href='#is.sropt'><p>Is this in the &quot;sropt&quot; class?</p></a></li>
<li><a href='#ism_vcov'><p>Compute variance covariance of Inverse 'Unified' Second Moment</p></a></li>
<li><a href='#pco_sropt'><p>The 'confidence distribution' for maximal Sharpe ratio.</p></a></li>
<li><a href='#plambdap'><p>The lambda-prime distribution.</p></a></li>
<li><a href='#power.sr_test'><p>Power calculations for Sharpe ratio tests</p></a></li>
<li><a href='#power.sropt_test'><p>Power calculations for optimal Sharpe ratio tests</p></a></li>
<li><a href='#predint'><p>prediction interval for Sharpe ratio</p></a></li>
<li><a href='#print.sr'><p>Print values.</p></a></li>
<li><a href='#reannualize'><p>Change the annualization of a Sharpe ratio.</p></a></li>
<li><a href='#se'><p>Standard error computation</p></a></li>
<li><a href='#SharpeR-NEWS'><p>News for package 'SharpeR':</p></a></li>
<li><a href='#SharpeR-package'><p>statistics concerning Sharpe ratio and Markowitz portfolio</p></a></li>
<li><a href='#sm_vcov'><p>Compute variance covariance of 'Unified' Second Moment</p></a></li>
<li><a href='#sr'><p>Create an 'sr' object.</p></a></li>
<li><a href='#sr_bias'><p>sr_bias .</p></a></li>
<li><a href='#sr_equality_test'><p>Paired test for equality of Sharpe ratio</p></a></li>
<li><a href='#sr_test'><p>test for Sharpe ratio</p></a></li>
<li><a href='#sr_unpaired_test'><p>test for equation on unpaired Sharpe ratios</p></a></li>
<li><a href='#sr_variance'><p>sr_variance .</p></a></li>
<li><a href='#sr_vcov'><p>Compute variance covariance of Sharpe Ratios.</p></a></li>
<li><a href='#sric'><p>Sharpe Ratio Information Coefficient</p></a></li>
<li><a href='#sropt'><p>Create an 'sropt' object.</p></a></li>
<li><a href='#sropt_test'><p>test for optimal Sharpe ratio</p></a></li>
<li><a href='#stock_returns'><p>Stock Returns Data</p></a></li>
<li><a href='#summary.sr'><p>Summarize a Sharpe, or (delta) optimal Sharpe object.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Maintainer:</td>
<td>Steven E. Pav &lt;shabbychef@gmail.com&gt;</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-08-15</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Significance of the Sharpe Ratio</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/shabbychef/SharpeR/issues">https://github.com/shabbychef/SharpeR/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of tools for analyzing significance of assets,
    funds, and trading strategies, based on the Sharpe ratio and overfit 
    of the same. Provides density, distribution, quantile and random generation 
    of the Sharpe ratio distribution based on normal returns, as well
    as the optimal Sharpe ratio over multiple assets. Computes confidence intervals
    on the Sharpe and provides a test of equality of Sharpe ratios based on 
    the Delta method. The statistical foundations of the Sharpe can be found in
    the author's Short Sharpe Course  &lt;<a href="https://doi.org/10.2139%2Fssrn.3036276">doi:10.2139/ssrn.3036276</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>matrixcalc, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>xtable, xts, timeSeries, quantmod, MASS, TTR, testthat,
sandwich, txtplot, knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/shabbychef/SharpeR">https://github.com/shabbychef/SharpeR</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'SharpeR.r' 'data.r' 'utils.r' 'distributions.r' 'sr.r'
'estimation.r' 'sr_bias.r' 'tests.r' 'unified.r'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-08-18 00:50:02 UTC; spav</td>
</tr>
<tr>
<td>Author:</td>
<td>Steven E. Pav <a href="https://orcid.org/0000-0002-4197-6195"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-08-18 09:10:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.del_sropt'>Compute the Sharpe ratio of a hedged Markowitz portfolio.</h2><span id='topic+as.del_sropt'></span><span id='topic+as.del_sropt.default'></span><span id='topic+as.del_sropt.xts'></span>

<h3>Description</h3>

<p>Computes the Sharpe ratio of the hedged Markowitz portfolio of some observed returns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.del_sropt(X, G, drag = 0, ope = 1, epoch = "yr")

## Default S3 method:
as.del_sropt(X, G, drag = 0, ope = 1, epoch = "yr")

## S3 method for class 'xts'
as.del_sropt(X, G, drag = 0, ope = 1, epoch = "yr")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.del_sropt_+3A_x">X</code></td>
<td>
<p>matrix of returns, or <code>xts</code> object.</p>
</td></tr>
<tr><td><code id="as.del_sropt_+3A_g">G</code></td>
<td>
<p>an <code class="reqn">g \times q</code> matrix of hedge constraints. A 
garden variety application would have <code>G</code> be one row of the
identity matrix, with a one in the column of the instrument to be
'hedged out'.</p>
</td></tr>
<tr><td><code id="as.del_sropt_+3A_drag">drag</code></td>
<td>
<p>the 'drag' term, <code class="reqn">c_0/R</code>. defaults to 0. It is assumed
that <code>drag</code> has been annualized, <em>i.e.</em> has been multiplied
by <code class="reqn">\sqrt{ope}</code>. This is in contrast to the <code>c0</code>
term given to <code><a href="#topic+sr">sr</a></code>.</p>
</td></tr>
<tr><td><code id="as.del_sropt_+3A_ope">ope</code></td>
<td>
<p>the number of observations per 'epoch'. For convenience of
interpretation, The Sharpe ratio is typically quoted in 'annualized' 
units for some epoch, that is, 'per square root epoch', though returns 
are observed at a frequency of <code>ope</code> per epoch. 
The default value is 1, meaning the code will not attempt to guess
what the observation frequency is, and no annualization adjustments
will be made.</p>
</td></tr>
<tr><td><code id="as.del_sropt_+3A_epoch">epoch</code></td>
<td>
<p>the string representation of the 'epoch', defaulting
to 'yr'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">x_i</code> are <code class="reqn">n</code> independent draws of a <code class="reqn">q</code>-variate
normal random variable with mean <code class="reqn">\mu</code> and covariance matrix
<code class="reqn">\Sigma</code>. Let <code class="reqn">G</code> be a <code class="reqn">g \times q</code> matrix
of rank <code class="reqn">g</code>.
Let <code class="reqn">\bar{x}</code> be the (vector) sample mean, and 
<code class="reqn">S</code> be the sample covariance matrix (using Bessel's correction). 
Let
</p>
<p style="text-align: center;"><code class="reqn">\zeta(w) = \frac{w^{\top}\bar{x} - c_0}{\sqrt{w^{\top}S w}}</code>
</p>

<p>be the (sample) Sharpe ratio of the portfolio <code class="reqn">w</code>, subject to 
risk free rate <code class="reqn">c_0</code>.
</p>
<p>Let <code class="reqn">w_*</code> be the solution to the portfolio optimization 
problem:
</p>
<p style="text-align: center;"><code class="reqn">\max_{w: 0 &lt; w^{\top}S w \le R^2,\,G S w = 0} \zeta(w),</code>
</p>

<p>with maximum value <code class="reqn">z_* = \zeta\left(w_*\right)</code>.
</p>
<p>Note that if <code>ope</code> and <code>epoch</code> are not given, the 
converter from <code>xts</code> attempts to infer the observations per epoch,
assuming yearly epoch.
</p>


<h3>Value</h3>

<p>An object of class <code>del_sropt</code>.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+del_sropt">del_sropt</a></code>, <code><a href="#topic+sropt">sropt</a></code>, 
<code><a href="#topic+sr">sr</a></code>
</p>
<p>Other del_sropt: 
<code><a href="#topic+del_sropt">del_sropt</a></code>,
<code><a href="#topic+is.del_sropt">is.del_sropt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nfac &lt;- 5
nyr &lt;- 10
ope &lt;- 253
# simulations with no covariance structure.
# under the null:
set.seed(as.integer(charToRaw("be determinstic")))
Returns &lt;- matrix(rnorm(ope*nyr*nfac,mean=0,sd=0.0125),ncol=nfac)
# hedge out the first one:
G &lt;- matrix(diag(nfac)[1,],nrow=1)
asro &lt;- as.del_sropt(Returns,G,drag=0,ope=ope)
print(asro)
G &lt;- diag(nfac)[c(1:3),]
asro &lt;- as.del_sropt(Returns,G,drag=0,ope=ope)
# compare to sropt on the remaining assets
# they should be close, but not exact.
asro.alt &lt;- as.sropt(Returns[,4:nfac],drag=0,ope=ope)

# using real data.
if (require(xts)) {
  data(stock_returns)
  # hedge out SPY
  G &lt;- diag(dim(stock_returns)[2])[3,]
  asro &lt;- as.del_sropt(stock_returns,G=G)
}
</code></pre>

<hr>
<h2 id='as.sr'>Compute the Sharpe ratio.</h2><span id='topic+as.sr'></span><span id='topic+as.sr.default'></span><span id='topic+as.sr.matrix'></span><span id='topic+as.sr.data.frame'></span><span id='topic+as.sr.lm'></span><span id='topic+as.sr.xts'></span><span id='topic+as.sr.timeSeries'></span>

<h3>Description</h3>

<p>Computes the Sharpe ratio of some observed returns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.sr(x, c0 = 0, ope = 1, na.rm = FALSE, epoch = "yr", higher_order = FALSE)

## Default S3 method:
as.sr(x, c0 = 0, ope = 1, na.rm = FALSE, epoch = "yr", higher_order = FALSE)

## S3 method for class 'matrix'
as.sr(x, c0 = 0, ope = 1, na.rm = FALSE, epoch = "yr", higher_order = FALSE)

## S3 method for class 'data.frame'
as.sr(x, c0 = 0, ope = 1, na.rm = FALSE, epoch = "yr", higher_order = FALSE)

## S3 method for class 'lm'
as.sr(x, c0 = 0, ope = 1, na.rm = FALSE, epoch = "yr", higher_order = FALSE)

## S3 method for class 'xts'
as.sr(x, c0 = 0, ope = 1, na.rm = FALSE, epoch = "yr", higher_order = FALSE)

## S3 method for class 'timeSeries'
as.sr(x, c0 = 0, ope = 1, na.rm = FALSE, epoch = "yr", higher_order = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.sr_+3A_x">x</code></td>
<td>
<p>vector of returns, or object of class <code>data.frame</code>, <code>xts</code>,
or <code>lm</code>.</p>
</td></tr>
<tr><td><code id="as.sr_+3A_c0">c0</code></td>
<td>
<p>the 'risk-free' or 'disastrous' rate of return. this is
assumed to be given in the same units as x, <em>not</em>
in 'annualized' terms.</p>
</td></tr>
<tr><td><code id="as.sr_+3A_ope">ope</code></td>
<td>
<p>the number of observations per 'epoch'. For convenience of
interpretation, The Sharpe ratio is typically quoted in 'annualized' 
units for some epoch, that is, 'per square root epoch', though returns 
are observed at a frequency of <code>ope</code> per epoch. 
The default value is 1, meaning the code will not attempt to guess
what the observation frequency is, and no annualization adjustments
will be made.</p>
</td></tr>
<tr><td><code id="as.sr_+3A_na.rm">na.rm</code></td>
<td>
<p>logical.  Should missing values be removed?</p>
</td></tr>
<tr><td><code id="as.sr_+3A_epoch">epoch</code></td>
<td>
<p>the string representation of the 'epoch', defaulting
to 'yr'.</p>
</td></tr>
<tr><td><code id="as.sr_+3A_higher_order">higher_order</code></td>
<td>
<p>a Boolean. If true, we compute 
cumulants of the returns to leverage higher order accuracy formulae
when possible.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">x_i</code> are <code class="reqn">n</code> independent returns of some
asset.
Let <code class="reqn">\bar{x}</code> be the sample mean, and <code class="reqn">s</code> be
the sample standard deviation (using Bessel's correction). Let <code class="reqn">c_0</code>
be the 'risk free rate'.  Then
</p>
<p style="text-align: center;"><code class="reqn">z = \frac{\bar{x} - c_0}{s}</code>
</p>
 
<p>is the (sample) Sharpe ratio.
</p>
<p>The units of <code class="reqn">z</code> are <code class="reqn">\mbox{time}^{-1/2}</code>.
Typically the Sharpe ratio is <em>annualized</em> by multiplying by
<code class="reqn">\sqrt{\mbox{ope}}</code>, where <code class="reqn">\mbox{ope}</code> 
is the number of observations
per year (or whatever the target annualization epoch.)
</p>
<p>Note that if <code>ope</code> is not given, the converter from <code>xts</code>
attempts to infer the observations per year, without regard to 
the name of the <code>epoch</code> given.
</p>


<h3>Value</h3>

<p>a list containing the following components:
</p>

<dl>
<dt>sr</dt><dd><p>the annualized Sharpe ratio.</p>
</dd>
<dt>df</dt><dd><p>the t-stat degrees of freedom.</p>
</dd>
<dt>c0</dt><dd><p>the risk free term.</p>
</dd>
<dt>ope</dt><dd><p>the annualization factor.</p>
</dd>
<dt>rescal</dt><dd><p>the rescaling factor.</p>
</dd>
<dt>epoch</dt><dd><p>the string epoch.</p>
</dd>
</dl>

<p>cast to class <code>sr</code>.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Sharpe, William F. &quot;Mutual fund performance.&quot; Journal of business (1966): 119-138.
<a href="https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html">https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html</a>
</p>
<p>Lo, Andrew W. &quot;The statistics of Sharpe ratios.&quot; Financial Analysts Journal 58, no. 4 
(2002): 36-52. <a href="https://www.ssrn.com/paper=377260">https://www.ssrn.com/paper=377260</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reannualize">reannualize</a></code>
</p>
<p>sr-distribution functions, <code><a href="#topic+dsr">dsr</a>, <a href="#topic+psr">psr</a>, <a href="#topic+qsr">qsr</a>, <a href="#topic+rsr">rsr</a></code>
</p>
<p>Other sr: 
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+dsr">dsr</a>()</code>,
<code><a href="#topic+is.sr">is.sr</a>()</code>,
<code><a href="#topic+plambdap">plambdap</a>()</code>,
<code><a href="#topic+power.sr_test">power.sr_test</a>()</code>,
<code><a href="#topic+predint">predint</a>()</code>,
<code><a href="#topic+print.sr">print.sr</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+se">se</a>()</code>,
<code><a href="#topic+sr_equality_test">sr_equality_test</a>()</code>,
<code><a href="#topic+sr_test">sr_test</a>()</code>,
<code><a href="#topic+sr_unpaired_test">sr_unpaired_test</a>()</code>,
<code><a href="#topic+sr_vcov">sr_vcov</a>()</code>,
<code><a href="#topic+sr">sr</a></code>,
<code><a href="#topic+summary.sr">summary.sr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sharpe's 'model': just given a bunch of returns.
asr &lt;- as.sr(rnorm(253*3),ope=253)
# or a matrix, with a name
my.returns &lt;- matrix(rnorm(253*3),ncol=1)
colnames(my.returns) &lt;- c("my strategy")
asr &lt;- as.sr(my.returns)

# given an xts object:
if (require(xts)) {
 data(stock_returns)
 IBM &lt;- stock_returns[,'IBM']
 asr &lt;- as.sr(IBM,na.rm=TRUE)
}

# on a linear model, find the 'Sharpe' of the residual term
nfac &lt;- 5
nyr &lt;- 10
ope &lt;- 253
set.seed(as.integer(charToRaw("determinstic")))
Factors &lt;- matrix(rnorm(ope*nyr*nfac,mean=0,sd=0.0125),ncol=nfac)
Betas &lt;- exp(0.1 * rnorm(dim(Factors)[2]))
Returns &lt;- (Factors %*% Betas) + rnorm(dim(Factors)[1],mean=0.0005,sd=0.012)
APT_mod &lt;- lm(Returns ~ Factors)
asr &lt;- as.sr(APT_mod,ope=ope)
# try again, but make the Returns independent of the Factors.
Returns &lt;- rnorm(dim(Factors)[1],mean=0.0005,sd=0.012)
APT_mod &lt;- lm(Returns ~ Factors)
asr &lt;- as.sr(APT_mod,ope=ope)

# compute the Sharpe of a bunch of strategies:
my.returns &lt;- matrix(rnorm(253*3*4),ncol=4)
asr &lt;- as.sr(my.returns)  # without sensible colnames?
colnames(my.returns) &lt;- c("strat a","strat b","strat c","strat d")
asr &lt;- as.sr(my.returns)
  
</code></pre>

<hr>
<h2 id='as.sropt'>Compute the Sharpe ratio of the Markowitz portfolio.</h2><span id='topic+as.sropt'></span><span id='topic+as.sropt.default'></span><span id='topic+as.sropt.xts'></span>

<h3>Description</h3>

<p>Computes the Sharpe ratio of the Markowitz portfolio of some observed returns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.sropt(X, drag = 0, ope = 1, epoch = "yr")

## Default S3 method:
as.sropt(X, drag = 0, ope = 1, epoch = "yr")

## S3 method for class 'xts'
as.sropt(X, drag = 0, ope = 1, epoch = "yr")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.sropt_+3A_x">X</code></td>
<td>
<p>matrix of returns, or <code>xts</code> object.</p>
</td></tr>
<tr><td><code id="as.sropt_+3A_drag">drag</code></td>
<td>
<p>the 'drag' term, <code class="reqn">c_0/R</code>. defaults to 0. It is assumed
that <code>drag</code> has been annualized, <em>i.e.</em> has been multiplied
by <code class="reqn">\sqrt{ope}</code>. This is in contrast to the <code>c0</code>
term given to <code><a href="#topic+sr">sr</a></code>.</p>
</td></tr>
<tr><td><code id="as.sropt_+3A_ope">ope</code></td>
<td>
<p>the number of observations per 'epoch'. For convenience of
interpretation, The Sharpe ratio is typically quoted in 'annualized' 
units for some epoch, that is, 'per square root epoch', though returns 
are observed at a frequency of <code>ope</code> per epoch. 
The default value is 1, meaning the code will not attempt to guess
what the observation frequency is, and no annualization adjustments
will be made.</p>
</td></tr>
<tr><td><code id="as.sropt_+3A_epoch">epoch</code></td>
<td>
<p>the string representation of the 'epoch', defaulting
to 'yr'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">x_i</code> are <code class="reqn">n</code> independent draws of a <code class="reqn">q</code>-variate
normal random variable with mean <code class="reqn">\mu</code> and covariance matrix
<code class="reqn">\Sigma</code>. Let <code class="reqn">\bar{x}</code> be the (vector) sample mean, and 
<code class="reqn">S</code> be the sample covariance matrix (using Bessel's correction). Let
</p>
<p style="text-align: center;"><code class="reqn">\zeta(w) = \frac{w^{\top}\bar{x} - c_0}{\sqrt{w^{\top}S w}}</code>
</p>

<p>be the (sample) Sharpe ratio of the portfolio <code class="reqn">w</code>, subject to 
risk free rate <code class="reqn">c_0</code>.
</p>
<p>Let <code class="reqn">w_*</code> be the solution to the portfolio optimization problem:
</p>
<p style="text-align: center;"><code class="reqn">\max_{w: 0 &lt; w^{\top}S w \le R^2} \zeta(w),</code>
</p>

<p>with maximum value <code class="reqn">z_* = \zeta\left(w_*\right)</code>.
Then 
</p>
<p style="text-align: center;"><code class="reqn">w_* = R \frac{S^{-1}\bar{x}}{\sqrt{\bar{x}^{\top}S^{-1}\bar{x}}}</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">z_* = \sqrt{\bar{x}^{\top} S^{-1} \bar{x}} - \frac{c_0}{R}</code>
</p>

<p>The units of <code class="reqn">z_*</code> are <code class="reqn">\mbox{time}^{-1/2}</code>.
Typically the Sharpe ratio is <em>annualized</em> by multiplying by
<code class="reqn">\sqrt{\mbox{ope}}</code>, where <code class="reqn">\mbox{ope}</code> 
is the number of observations
per year (or whatever the target annualization epoch.)
</p>
<p>Note that if <code>ope</code> and <code>epoch</code> are not given, the 
converter from <code>xts</code> attempts to infer the observations per epoch,
assuming yearly epoch.
</p>


<h3>Value</h3>

<p>An object of class <code>sropt</code>.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sropt">sropt</a></code>, <code><a href="#topic+sr">sr</a></code>, sropt-distribution functions, 
<code><a href="#topic+dsropt">dsropt</a>, <a href="#topic+psropt">psropt</a>, <a href="#topic+qsropt">qsropt</a>, <a href="#topic+rsropt">rsropt</a></code>
</p>
<p>Other sropt: 
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+dsropt">dsropt</a>()</code>,
<code><a href="#topic+is.sropt">is.sropt</a>()</code>,
<code><a href="#topic+pco_sropt">pco_sropt</a>()</code>,
<code><a href="#topic+power.sropt_test">power.sropt_test</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+sropt_test">sropt_test</a>()</code>,
<code><a href="#topic+sropt">sropt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nfac &lt;- 5
nyr &lt;- 10
ope &lt;- 253
# simulations with no covariance structure.
# under the null:
set.seed(as.integer(charToRaw("be determinstic")))
Returns &lt;- matrix(rnorm(ope*nyr*nfac,mean=0,sd=0.0125),ncol=nfac)
asro &lt;- as.sropt(Returns,drag=0,ope=ope)
# under the alternative:
Returns &lt;- matrix(rnorm(ope*nyr*nfac,mean=0.0005,sd=0.0125),ncol=nfac)
asro &lt;- as.sropt(Returns,drag=0,ope=ope)
# generating correlated multivariate normal data in a more sane way
if (require(MASS)) {
  nstok &lt;- 10
  nfac &lt;- 3
  nyr &lt;- 10
  ope &lt;- 253
  X.like &lt;- 0.01 * matrix(rnorm(500*nfac),ncol=nfac) %*% 
    matrix(runif(nfac*nstok),ncol=nstok)
  Sigma &lt;- cov(X.like) + diag(0.003,nstok)
  # under the null:
  Returns &lt;- mvrnorm(ceiling(ope*nyr),mu=matrix(0,ncol=nstok),Sigma=Sigma)
  asro &lt;- as.sropt(Returns,ope=ope)
  # under the alternative
  Returns &lt;- mvrnorm(ceiling(ope*nyr),mu=matrix(0.001,ncol=nstok),Sigma=Sigma)
  asro &lt;- as.sropt(Returns,ope=ope)
}

# using real data.
if (require(xts)) {
 data(stock_returns)
 asro &lt;- as.sropt(stock_returns)
}  
</code></pre>

<hr>
<h2 id='confint.sr'>Confidence Interval on (optimal) Signal-Noise Ratio</h2><span id='topic+confint.sr'></span><span id='topic+confint.sropt'></span><span id='topic+confint.del_sropt'></span>

<h3>Description</h3>

<p>Computes approximate confidence intervals on the (optimal) Signal-Noise ratio 
given the (optimal) Sharpe ratio.
Works on objects of class <code>sr</code> and <code>sropt</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sr'
confint(
  object,
  parm,
  level = 0.95,
  level.lo = (1 - level)/2,
  level.hi = 1 - level.lo,
  type = c("exact", "t", "Z", "Mertens", "Bao"),
  ...
)

## S3 method for class 'sropt'
confint(
  object,
  parm,
  level = 0.95,
  level.lo = (1 - level)/2,
  level.hi = 1 - level.lo,
  ...
)

## S3 method for class 'del_sropt'
confint(
  object,
  parm,
  level = 0.95,
  level.lo = (1 - level)/2,
  level.hi = 1 - level.lo,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.sr_+3A_object">object</code></td>
<td>
<p>an observed Sharpe ratio statistic, of class <code>sr</code> or
<code>sropt</code>.</p>
</td></tr>
<tr><td><code id="confint.sr_+3A_parm">parm</code></td>
<td>
<p>ignored here, but required for the general method.</p>
</td></tr>
<tr><td><code id="confint.sr_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="confint.sr_+3A_level.lo">level.lo</code></td>
<td>
<p>the lower confidence level required.</p>
</td></tr>
<tr><td><code id="confint.sr_+3A_level.hi">level.hi</code></td>
<td>
<p>the upper confidence level required.</p>
</td></tr>
<tr><td><code id="confint.sr_+3A_type">type</code></td>
<td>
<p>which method to apply.</p>
</td></tr>
<tr><td><code id="confint.sr_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constructs confidence intervals on the Signal-Noise ratio given observed
Sharpe ratio statistic. The available methods are:
</p>

<dl>
<dt>exact</dt><dd><p>The default, which is only exact when returns are
normal, based on inverting the non-central t distribution.</p>
</dd>
<dt>t</dt><dd><p>Uses the Johnson Welch approximation to the standard error, centered around
the sample value.</p>
</dd>
<dt>Z</dt><dd><p>Uses the Johnson Welch approximation to the standard error,
performing a simple correction for the bias of the Sharpe ratio based on 
Miller and Gehr formula.</p>
</dd>
<dt>Mertens</dt><dd><p>Uses the Mertens higher order approximation to the standard
error, centered around the sample value.</p>
</dd>
<dt>Bao</dt><dd><p>Uses the Bao higher order approximation to the standard error,
performing a higher order correction for the bias of the Sharpe ratio.</p>
</dd>
</dl>

<p>Suppose <code class="reqn">x_i</code> are <code class="reqn">n</code> independent draws of a <code class="reqn">q</code>-variate
normal random variable with mean <code class="reqn">\mu</code> and covariance matrix
<code class="reqn">\Sigma</code>. Let <code class="reqn">\bar{x}</code> be the (vector) sample mean, and 
<code class="reqn">S</code> be the sample covariance matrix (using Bessel's correction). 
Let 
</p>
<p style="text-align: center;"><code class="reqn">z_* = \sqrt{\bar{x}^{\top} S^{-1} \bar{x}}</code>
</p>

<p>Given observations of <code class="reqn">z_*</code>, compute confidence intervals on the
population analogue, defined as
</p>
<p style="text-align: center;"><code class="reqn">\zeta_* = \sqrt{\mu^{\top} \Sigma^{-1} \mu}</code>
</p>



<h3>Value</h3>

<p>A matrix (or vector) with columns giving lower and upper
confidence limits for the parameter. These will be labelled as
level.lo and level.hi in %, <em>e.g.</em> <code>"2.5 %"</code>
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Sharpe, William F. &quot;Mutual fund performance.&quot; Journal of business (1966): 119-138.
<a href="https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html">https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+confint">confint</a></code>, <code><a href="#topic+se">se</a></code>, <code><a href="#topic+predint">predint</a></code>
</p>
<p>Other sr: 
<code><a href="#topic+as.sr">as.sr</a>()</code>,
<code><a href="#topic+dsr">dsr</a>()</code>,
<code><a href="#topic+is.sr">is.sr</a>()</code>,
<code><a href="#topic+plambdap">plambdap</a>()</code>,
<code><a href="#topic+power.sr_test">power.sr_test</a>()</code>,
<code><a href="#topic+predint">predint</a>()</code>,
<code><a href="#topic+print.sr">print.sr</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+se">se</a>()</code>,
<code><a href="#topic+sr_equality_test">sr_equality_test</a>()</code>,
<code><a href="#topic+sr_test">sr_test</a>()</code>,
<code><a href="#topic+sr_unpaired_test">sr_unpaired_test</a>()</code>,
<code><a href="#topic+sr_vcov">sr_vcov</a>()</code>,
<code><a href="#topic+sr">sr</a></code>,
<code><a href="#topic+summary.sr">summary.sr</a></code>
</p>
<p>Other sropt: 
<code><a href="#topic+as.sropt">as.sropt</a>()</code>,
<code><a href="#topic+dsropt">dsropt</a>()</code>,
<code><a href="#topic+is.sropt">is.sropt</a>()</code>,
<code><a href="#topic+pco_sropt">pco_sropt</a>()</code>,
<code><a href="#topic+power.sropt_test">power.sropt_test</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+sropt_test">sropt_test</a>()</code>,
<code><a href="#topic+sropt">sropt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# using "sr" class:
ope &lt;- 253
df &lt;- ope * 6
xv &lt;- rnorm(df, 1 / sqrt(ope))
mysr &lt;- as.sr(xv,ope=ope)
confint(mysr,level=0.90)
# using "lm" class
yv &lt;- xv + rnorm(length(xv))
amod &lt;- lm(yv ~ xv)
mysr &lt;- as.sr(amod,ope=ope)
confint(mysr,level.lo=0.05,level.hi=1.0)
# rolling your own.
ope &lt;- 253
df &lt;- ope * 6
zeta &lt;- 1.0
rvs &lt;- rsr(128, df, zeta, ope)
roll.own &lt;- sr(sr=rvs,df=df,c0=0,ope=ope)
aci &lt;- confint(roll.own,level=0.95)
coverage &lt;- 1 - mean((zeta &lt; aci[,1]) | (aci[,2] &lt; zeta))
# using "sropt" class
ope &lt;- 253
df1 &lt;- 4
df2 &lt;- ope * 3
rvs &lt;- as.matrix(rnorm(df1*df2),ncol=df1)
sro &lt;- as.sropt(rvs,ope=ope)
aci &lt;- confint(sro)
# on sropt, rolling your own.
zeta.s &lt;- 1.0
rvs &lt;- rsropt(128, df1, df2, zeta.s, ope)
roll.own &lt;- sropt(z.s=rvs,df1,df2,drag=0,ope=ope)
aci &lt;- confint(roll.own,level=0.95)
coverage &lt;- 1 - mean((zeta.s &lt; aci[,1]) | (aci[,2] &lt; zeta.s))
# using "del_sropt" class
nfac &lt;- 5
nyr &lt;- 10
ope &lt;- 253
set.seed(as.integer(charToRaw("be determinstic")))
Returns &lt;- matrix(rnorm(ope*nyr*nfac,mean=0,sd=0.0125),ncol=nfac)
# hedge out the first one:
G &lt;- matrix(diag(nfac)[1,],nrow=1)
asro &lt;- as.del_sropt(Returns,G,drag=0,ope=ope)
aci &lt;- confint(asro,level=0.95)
# under the alternative
Returns &lt;- matrix(rnorm(ope*nyr*nfac,mean=0.001,sd=0.0125),ncol=nfac)
asro &lt;- as.del_sropt(Returns,G,drag=0,ope=ope)
aci &lt;- confint(asro,level=0.95)

</code></pre>

<hr>
<h2 id='del_sropt'>Create an 'del_sropt' object.</h2><span id='topic+del_sropt'></span>

<h3>Description</h3>

<p>Spawns an object of class <code>del_sropt</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>del_sropt(z.s, z.sub, df1, df2, df1.sub, drag = 0, ope = 1, epoch = "yr")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="del_sropt_+3A_z.s">z.s</code></td>
<td>
<p>an optimum Sharpe ratio statistic, on some set of assets.</p>
</td></tr>
<tr><td><code id="del_sropt_+3A_z.sub">z.sub</code></td>
<td>
<p>an optimum Sharpe ratio statistic, on a linear subspace
of the assets.  If larger than <code>z.s</code> an error is thrown.</p>
</td></tr>
<tr><td><code id="del_sropt_+3A_df1">df1</code></td>
<td>
<p>the number of assets in the portfolio.</p>
</td></tr>
<tr><td><code id="del_sropt_+3A_df2">df2</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code id="del_sropt_+3A_df1.sub">df1.sub</code></td>
<td>
<p>the rank of the linear subspace of the hedge
constraint. 
by restricting attention to the subspace.</p>
</td></tr>
<tr><td><code id="del_sropt_+3A_drag">drag</code></td>
<td>
<p>the 'drag' term, <code class="reqn">c_0/R</code>. defaults to 0. It is assumed
that <code>drag</code> has been annualized, <em>i.e.</em> has been multiplied
by <code class="reqn">\sqrt{ope}</code>. This is in contrast to the <code>c0</code>
term given to <code><a href="#topic+sr">sr</a></code>.</p>
</td></tr>
<tr><td><code id="del_sropt_+3A_ope">ope</code></td>
<td>
<p>the number of observations per 'epoch'. For convenience of
interpretation, The Sharpe ratio is typically quoted in 'annualized' 
units for some epoch, that is, 'per square root epoch', though returns 
are observed at a frequency of <code>ope</code> per epoch. 
The default value is 1, meaning the code will not attempt to guess
what the observation frequency is, and no annualization adjustments
will be made.</p>
</td></tr>
<tr><td><code id="del_sropt_+3A_epoch">epoch</code></td>
<td>
<p>the string representation of the 'epoch', defaulting
to 'yr'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>del_sropt</code> class contains information about the difference
between two rescaled T^2-statistics, useful for spanning
tests, and inference on hedged portfolios.
The following are list attributes of the object:
</p>

<dl>
<dt>sropt</dt><dd><p>The (optimal) Sharpe ratio statistic of
the 'full' set of assets.</p>
</dd>
<dt>sropt_sub</dt><dd><p>The (optimal) Sharpe ratio statistic on
some subset, or linear subspace, of the assets.</p>
</dd>
<dt>df1</dt><dd><p>The number of assets.</p>
</dd>
<dt>df2</dt><dd><p>The number of observations.</p>
</dd>
<dt>df1.sub</dt><dd><p>The number of degrees of freedom in the 
hedge constraint.</p>
</dd>
<dt>drag</dt><dd><p>The drag term, which is the 'risk free rate' divided by
the maximum risk.</p>
</dd>
<dt>ope</dt><dd><p>The 'observations per epoch'.</p>
</dd>
<dt>epoch</dt><dd><p>The string name of the 'epoch'.</p>
</dd>
</dl>

<p>For the most part, this constructor should <em>not</em> be called directly,
rather <code><a href="#topic+as.del_sropt">as.del_sropt</a></code> should be called instead to compute the
needed statistics.
</p>


<h3>Value</h3>

<p>a list cast to class <code>del_sropt</code>, with attributes
</p>

<dl>
<dt>sropt</dt><dd><p>the optimal Sharpe statistic.</p>
</dd>
<dt>sropt.sub</dt><dd><p>the optimal Sharpe statistic on the subspace.</p>
</dd>
<dt>df1</dt><dd><p>the number of assets.</p>
</dd>
<dt>df2</dt><dd><p>the number of observed vectors.</p>
</dd>
<dt>df1.sub</dt><dd><p>the input <code>df1.sub</code> term.</p>
</dd>
<dt>drag</dt><dd><p>the input <code>drag</code> term.</p>
</dd>
<dt>ope</dt><dd><p>the input <code>ope</code> term.</p>
</dd>
<dt>T2</dt><dd><p>the Hotelling <code class="reqn">T^2</code> statistic.</p>
</dd>
<dt>T2.sub</dt><dd><p>the Hotelling <code class="reqn">T^2</code> statistic on the subspace.</p>
</dd>
</dl>



<h3>Note</h3>

<p><b>WARNING:</b> This function is not well tested, may contain errors, may change in the
next package update. Take caution.
</p>
<p>2FIX: allow rownames?
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reannualize">reannualize</a></code>
</p>
<p><code><a href="#topic+as.del_sropt">as.del_sropt</a></code>
</p>
<p>Other del_sropt: 
<code><a href="#topic+as.del_sropt">as.del_sropt</a>()</code>,
<code><a href="#topic+is.del_sropt">is.del_sropt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># roll your own.
ope &lt;- 253

set.seed(as.integer(charToRaw("be determinstic")))
n.stock &lt;- 10
X &lt;- matrix(rnorm(1000*n.stock),nrow=1000)
Sigma &lt;- cov(X)
mu &lt;- colMeans(X)
w &lt;- solve(Sigma,mu)
z &lt;- t(mu) %*% w
n.sub &lt;- 6
w.sub &lt;- solve(Sigma[1:n.sub,1:n.sub],mu[1:n.sub])
z.sub &lt;- t(mu[1:n.sub]) %*% w.sub
df1.sub &lt;- n.stock - n.sub

roll.own &lt;- del_sropt(z.s=z,z.sub=z.sub,df1=10,df2=1000,
 df1.sub=df1.sub,ope=ope)
print(roll.own)

</code></pre>

<hr>
<h2 id='dsr'>The (non-central) Sharpe ratio.</h2><span id='topic+dsr'></span><span id='topic+psr'></span><span id='topic+qsr'></span><span id='topic+rsr'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the Sharpe ratio distribution with <code>df</code> degrees of freedom
(and optional signal-noise-ratio <code>zeta</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsr(x, df, zeta, ope, ...)

psr(q, df, zeta, ope, ...)

qsr(p, df, zeta, ope, ...)

rsr(n, df, zeta, ope)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsr_+3A_x">x</code>, <code id="dsr_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dsr_+3A_df">df</code></td>
<td>
<p>the number of observations the statistic is based on. This 
is one more than the number of degrees of freedom in the
corresponding t-statistic, although the effect will be small
when <code>df</code> is large.</p>
</td></tr>
<tr><td><code id="dsr_+3A_zeta">zeta</code></td>
<td>
<p>the 'signal-to-noise' parameter, <code class="reqn">\zeta</code> defined as the population
mean divided by the population standard deviation, 'annualized'.</p>
</td></tr>
<tr><td><code id="dsr_+3A_ope">ope</code></td>
<td>
<p>the number of observations per 'epoch'. For convenience of
interpretation, The Sharpe ratio is typically quoted in 'annualized' 
units for some epoch, that is, 'per square root epoch', though returns 
are observed at a frequency of <code>ope</code> per epoch. 
The default value is 1, meaning the code will not attempt to guess
what the observation frequency is, and no annualization adjustments
will be made.</p>
</td></tr>
<tr><td><code id="dsr_+3A_...">...</code></td>
<td>
<p>arguments passed on to the respective t-distribution functions, namely
<code>lower.tail</code> with default <code>TRUE</code>, <code>log</code> with default <code>FALSE</code>, 
and <code>log.p</code> with default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="dsr_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dsr_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">x_i</code> are <code class="reqn">n</code> independent draws of a normal random
variable with mean <code class="reqn">\mu</code> and variance <code class="reqn">\sigma^2</code>.
Let <code class="reqn">\bar{x}</code> be the sample mean, and <code class="reqn">s</code> be
the sample standard deviation (using Bessel's correction). Let <code class="reqn">c_0</code>
be the 'risk free rate'.  Then
</p>
<p style="text-align: center;"><code class="reqn">z = \frac{\bar{x} - c_0}{s}</code>
</p>
 
<p>is the (sample) Sharpe ratio.
</p>
<p>The units of <code class="reqn">z</code> is <code class="reqn">\mbox{time}^{-1/2}</code>.
Typically the Sharpe ratio is <em>annualized</em> by multiplying by
<code class="reqn">\sqrt{d}</code>, where <code class="reqn">d</code> is the number of observations
per epoch (typically a year).
</p>
<p>Letting <code class="reqn">z = \sqrt{d}\frac{\bar{x}-c_0}{s}</code>,
where the sample estimates are based on <code class="reqn">n</code> observations, 
then <code class="reqn">z</code> takes a (non-central) Sharpe ratio distribution
parametrized by <code class="reqn">n</code> 'degrees of freedom', non-centrality parameter
<code class="reqn">\zeta = \frac{\mu - c_0}{\sigma}</code>, and 
annualization parameter <code class="reqn">d</code>. 
</p>
<p>The parameters are encoded as follows:
</p>

<ul>
<li> <p><code class="reqn">n</code> is denoted by <code>df</code>.
</p>
</li>
<li> <p><code class="reqn">\zeta</code> is denoted by <code>zeta</code>.
</p>
</li>
<li> <p><code class="reqn">d</code> is denoted by <code>ope</code>. ('Observations Per Year')
</p>
</li></ul>

<p>If the returns violate the assumptions of normality, independence, etc
(<em>as they always should in the real world</em>), the sample Sharpe Ratio
will not follow this distribution. It does provide, however, a reasonable
approximation in many cases.
</p>
<p>See &lsquo;The Sharpe Ratio: Statistics and Applications&rsquo;,
section 2.2.
</p>


<h3>Value</h3>

<p><code>dsr</code> gives the density, <code>psr</code> gives the distribution function,
<code>qsr</code> gives the quantile function, and <code>rsr</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code> with a warning.
</p>


<h3>Note</h3>

<p>This is a thin wrapper on the t distribution. 
The functions <code><a href="stats.html#topic+dt">dt</a>, <a href="stats.html#topic+pt">pt</a>, <a href="stats.html#topic+qt">qt</a></code> can accept ncp from
limited range (<code class="reqn">|\delta|\le 37.62</code>). Some corrections
may have to be made here for large <code>zeta</code>.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Sharpe, William F. &quot;Mutual fund performance.&quot; Journal of business (1966): 119-138.
<a href="https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html">https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html</a>
</p>
<p>Pav, S. E. &quot;The Sharpe Ratio: Statistics and Applications.&quot; CRC Press, 2021.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reannualize">reannualize</a></code>
</p>
<p>t-distribution functions, <code><a href="stats.html#topic+dt">dt</a>, <a href="stats.html#topic+pt">pt</a>, <a href="stats.html#topic+qt">qt</a>, <a href="stats.html#topic+rt">rt</a></code>
</p>
<p>Other sr: 
<code><a href="#topic+as.sr">as.sr</a>()</code>,
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+is.sr">is.sr</a>()</code>,
<code><a href="#topic+plambdap">plambdap</a>()</code>,
<code><a href="#topic+power.sr_test">power.sr_test</a>()</code>,
<code><a href="#topic+predint">predint</a>()</code>,
<code><a href="#topic+print.sr">print.sr</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+se">se</a>()</code>,
<code><a href="#topic+sr_equality_test">sr_equality_test</a>()</code>,
<code><a href="#topic+sr_test">sr_test</a>()</code>,
<code><a href="#topic+sr_unpaired_test">sr_unpaired_test</a>()</code>,
<code><a href="#topic+sr_vcov">sr_vcov</a>()</code>,
<code><a href="#topic+sr">sr</a></code>,
<code><a href="#topic+summary.sr">summary.sr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rvs &lt;- rsr(128, 253*6, 0, 253)
dvs &lt;- dsr(rvs, 253*6, 0, 253)
pvs.H0 &lt;- psr(rvs, 253*6, 0, 253)
pvs.HA &lt;- psr(rvs, 253*6, 1, 253)

plot(ecdf(pvs.H0))
plot(ecdf(pvs.HA))


</code></pre>

<hr>
<h2 id='dsropt'>The (non-central) maximal Sharpe ratio distribution.</h2><span id='topic+dsropt'></span><span id='topic+psropt'></span><span id='topic+qsropt'></span><span id='topic+rsropt'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the maximal Sharpe ratio distribution with 
<code>df1</code> and <code>df2</code> degrees of freedom
(and optional maximal signal-noise-ratio <code>zeta.s</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsropt(x, df1, df2, zeta.s, ope, drag = 0, log = FALSE)

psropt(q, df1, df2, zeta.s, ope, drag = 0, ...)

qsropt(p, df1, df2, zeta.s, ope, drag = 0, ...)

rsropt(n, df1, df2, zeta.s, ope, drag = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsropt_+3A_x">x</code>, <code id="dsropt_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dsropt_+3A_df1">df1</code></td>
<td>
<p>the number of assets in the portfolio.</p>
</td></tr>
<tr><td><code id="dsropt_+3A_df2">df2</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code id="dsropt_+3A_zeta.s">zeta.s</code></td>
<td>
<p>the non-centrality parameter, defined as 
<code class="reqn">\zeta_* = \sqrt{\mu^{\top}\Sigma^{-1}\mu},</code>
for population parameters.
defaults to 0, <em>i.e.</em> a central maximal Sharpe ratio distribution.</p>
</td></tr>
<tr><td><code id="dsropt_+3A_ope">ope</code></td>
<td>
<p>the number of observations per 'epoch'. For convenience of
interpretation, The Sharpe ratio is typically quoted in 'annualized' 
units for some epoch, that is, 'per square root epoch', though returns 
are observed at a frequency of <code>ope</code> per epoch. 
The default value is 1, meaning the code will not attempt to guess
what the observation frequency is, and no annualization adjustments
will be made.</p>
</td></tr>
<tr><td><code id="dsropt_+3A_drag">drag</code></td>
<td>
<p>the 'drag' term, <code class="reqn">c_0/R</code>. defaults to 0. It is assumed
that <code>drag</code> has been annualized, <em>i.e.</em> is given in the
same units as <code>x</code> and <code>q</code>.</p>
</td></tr>
<tr><td><code id="dsropt_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, densities <code class="reqn">f</code> are given as <code class="reqn">\mbox{log}(f)</code>.</p>
</td></tr>
<tr><td><code id="dsropt_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dsropt_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="dsropt_+3A_...">...</code></td>
<td>
<p>arguments passed on to the respective Hotelling <code class="reqn">T^2</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">x_i</code> are <code class="reqn">n</code> independent draws of a <code class="reqn">q</code>-variate
normal random variable with mean <code class="reqn">\mu</code> and covariance matrix
<code class="reqn">\Sigma</code>. Let <code class="reqn">\bar{x}</code> be the (vector) sample mean, and 
<code class="reqn">S</code> be the sample covariance matrix (using Bessel's correction). Let
</p>
<p style="text-align: center;"><code class="reqn">Z(w) = \frac{w^{\top}\bar{x} - c_0}{\sqrt{w^{\top}S w}}</code>
</p>

<p>be the (sample) Sharpe ratio of the portfolio <code class="reqn">w</code>, subject to 
risk free rate <code class="reqn">c_0</code>.
</p>
<p>Let <code class="reqn">w_*</code> be the solution to the portfolio optimization problem:
</p>
<p style="text-align: center;"><code class="reqn">\max_{w: 0 &lt; w^{\top}S w \le R^2} Z(w),</code>
</p>

<p>with maximum value <code class="reqn">z_* = Z\left(w_*\right)</code>.
Then 
</p>
<p style="text-align: center;"><code class="reqn">w_* = R \frac{S^{-1}\bar{x}}{\sqrt{\bar{x}^{\top}S^{-1}\bar{x}}}</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">z_* = \sqrt{\bar{x}^{\top} S^{-1} \bar{x}} - \frac{c_0}{R}</code>
</p>

<p>The variable <code class="reqn">z_*</code> follows an <em>Optimal Sharpe ratio</em>
distribution. For convenience, we may assume that the sample statistic
has been annualized in the same manner as the Sharpe ratio, that is 
by multiplying by <code class="reqn">d</code>, the number of observations per
epoch.
</p>
<p>The Optimal Sharpe Ratio distribution is parametrized by the number 
of assets, <code class="reqn">q</code>, the number of independent observations, <code class="reqn">n</code>, the 
noncentrality parameter, 
</p>
<p style="text-align: center;"><code class="reqn">\zeta_* = \sqrt{\mu^{\top}\Sigma^{-1}\mu},</code>
</p>

<p>the 'drag' term, <code class="reqn">c_0/R</code>, and the annualization factor, <code class="reqn">d</code>.
The drag term makes this a location family of distributions, and 
by default we assume it is zero.
</p>
<p>The parameters are encoded as follows:
</p>

<ul>
<li> <p><code class="reqn">q</code> is denoted by <code>df1</code>.
</p>
</li>
<li> <p><code class="reqn">n</code> is denoted by <code>df2</code>.
</p>
</li>
<li> <p><code class="reqn">\zeta_*</code> is denoted by <code>zeta.s</code>.
</p>
</li>
<li> <p><code class="reqn">d</code> is denoted by <code>ope</code>.
</p>
</li>
<li> <p><code class="reqn">c_0/R</code> is denoted by <code>drag</code>.
</p>
</li></ul>

<p>See &lsquo;The Sharpe Ratio: Statistics and Applications&rsquo;,
section 6.1.4.
</p>


<h3>Value</h3>

<p><code>dsropt</code> gives the density, <code>psropt</code> gives the distribution function,
<code>qsropt</code> gives the quantile function, and <code>rsropt</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code> with a warning.
</p>


<h3>Note</h3>

<p>This is a thin wrapper on the Hotelling T-squared distribution, which is a
wrapper on the F distribution.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Kan, Raymond and Smith, Daniel R. &quot;The Distribution of the Sample Minimum-Variance Frontier.&quot;
Journal of Management Science 54, no. 7 (2008): 1364&ndash;1380.
doi: <a href="https://doi.org/10.1287/mnsc.1070.0852">10.1287/mnsc.1070.0852</a>
</p>
<p>Pav, S. E. &quot;The Sharpe Ratio: Statistics and Applications.&quot; CRC Press, 2021.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reannualize">reannualize</a></code>
</p>
<p>F-distribution functions, <code><a href="stats.html#topic+df">df</a>, <a href="stats.html#topic+pf">pf</a>, <a href="stats.html#topic+qf">qf</a>, <a href="stats.html#topic+rf">rf</a></code>, 
Sharpe ratio distribution, <code><a href="#topic+dsr">dsr</a>, <a href="#topic+psr">psr</a>, <a href="#topic+qsr">qsr</a>, <a href="#topic+rsr">rsr</a></code>.
</p>
<p>Other sropt: 
<code><a href="#topic+as.sropt">as.sropt</a>()</code>,
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+is.sropt">is.sropt</a>()</code>,
<code><a href="#topic+pco_sropt">pco_sropt</a>()</code>,
<code><a href="#topic+power.sropt_test">power.sropt_test</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+sropt_test">sropt_test</a>()</code>,
<code><a href="#topic+sropt">sropt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate some variates 
ngen &lt;- 128
ope &lt;- 253
df1 &lt;- 8
df2 &lt;- ope * 10
drag &lt;- 0
# sample
rvs &lt;- rsropt(ngen, df1, df2, drag, ope)
hist(rvs)
# these should be uniform:
isp &lt;- psropt(rvs, df1, df2, drag, ope)
plot(ecdf(isp))

</code></pre>

<hr>
<h2 id='inference'>Inference on noncentrality parameter of F-like statistic</h2><span id='topic+inference'></span><span id='topic+inference.sropt'></span><span id='topic+inference.del_sropt'></span>

<h3>Description</h3>

<p>Estimates the non-centrality parameter associated with an observed
statistic following an optimal Sharpe Ratio distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inference(z.s, type = c("KRS", "MLE", "unbiased"))

## S3 method for class 'sropt'
inference(z.s, type = c("KRS", "MLE", "unbiased"))

## S3 method for class 'del_sropt'
inference(z.s, type = c("KRS", "MLE", "unbiased"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inference_+3A_z.s">z.s</code></td>
<td>
<p>an object of type <code>sropt</code>, or <code>del_sropt</code></p>
</td></tr>
<tr><td><code id="inference_+3A_type">type</code></td>
<td>
<p>the estimator type. one of <code>c("KRS", "MLE", "unbiased")</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">F</code> be an observed statistic distributed as a non-central F with 
<code class="reqn">\nu_1</code>, <code class="reqn">\nu_2</code> degrees of freedom and non-centrality 
parameter <code class="reqn">\delta^2</code>. Three methods are presented to
estimate the non-centrality parameter from the statistic:
</p>

<ul>
<li><p> an unbiased estimator, which, unfortunately, may be negative.
</p>
</li>
<li><p> the Maximum Likelihood Estimator, which may be zero, but not
negative.
</p>
</li>
<li><p> the estimator of Kubokawa, Roberts, and Shaleh (KRS), which
is a shrinkage estimator.
</p>
</li></ul>

<p>The sropt distribution is equivalent to an F distribution up to a 
square root and some rescalings. 
</p>
<p>The non-centrality parameter of the sropt distribution is 
the square root of that of the Hotelling, <em>i.e.</em> has
units 'per square root time'. As such, the <code>'unbiased'</code>
type can be problematic!
</p>


<h3>Value</h3>

<p>an estimate of the non-centrality parameter, which is
the maximal population Sharpe ratio.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Kubokawa, T., C. P. Robert, and A. K. Saleh. &quot;Estimation of noncentrality parameters.&quot; 
Canadian Journal of Statistics 21, no. 1 (1993): 45-57. <a href="https://www.jstor.org/stable/3315657">https://www.jstor.org/stable/3315657</a>
</p>
<p>Spruill, M. C. &quot;Computation of the maximum likelihood estimate of a noncentrality parameter.&quot; 
Journal of multivariate analysis 18, no. 2 (1986): 216-224.
<a href="https://www.sciencedirect.com/science/article/pii/0047259X86900709">https://www.sciencedirect.com/science/article/pii/0047259X86900709</a>
</p>


<h3>See Also</h3>

<p>F-distribution functions, <code><a href="stats.html#topic+df">df</a></code>.
</p>
<p>Other sropt Hotelling: 
<code><a href="#topic+sric">sric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate some sropts
nfac &lt;- 3
nyr &lt;- 5
ope &lt;- 253
# simulations with no covariance structure.
# under the null:
set.seed(as.integer(charToRaw("determinstic")))
Returns &lt;- matrix(rnorm(ope*nyr*nfac,mean=0,sd=0.0125),ncol=nfac)
asro &lt;- as.sropt(Returns,drag=0,ope=ope)
est1 &lt;- inference(asro,type='unbiased')  
est2 &lt;- inference(asro,type='KRS')  
est3 &lt;- inference(asro,type='MLE')

# under the alternative:
Returns &lt;- matrix(rnorm(ope*nyr*nfac,mean=0.0005,sd=0.0125),ncol=nfac)
asro &lt;- as.sropt(Returns,drag=0,ope=ope)
est1 &lt;- inference(asro,type='unbiased')  
est2 &lt;- inference(asro,type='KRS')  
est3 &lt;- inference(asro,type='MLE')

# sample many under the alternative, look at the estimator.
df1 &lt;- 3
df2 &lt;- 512
ope &lt;- 253
zeta.s &lt;- 1.25
rvs &lt;- rsropt(128, df1, df2, zeta.s, ope)
roll.own &lt;- sropt(z.s=rvs,df1,df2,drag=0,ope=ope)
est1 &lt;- inference(roll.own,type='unbiased')  
est2 &lt;- inference(roll.own,type='KRS')  
est3 &lt;- inference(roll.own,type='MLE')

# for del_sropt:
nfac &lt;- 5
nyr &lt;- 10
ope &lt;- 253
set.seed(as.integer(charToRaw("fix seed")))
Returns &lt;- matrix(rnorm(ope*nyr*nfac,mean=0.0005,sd=0.0125),ncol=nfac)
# hedge out the first one:
G &lt;- matrix(diag(nfac)[1,],nrow=1)
asro &lt;- as.del_sropt(Returns,G,drag=0,ope=ope)
est1 &lt;- inference(asro,type='unbiased')  
est2 &lt;- inference(asro,type='KRS')  
est3 &lt;- inference(asro,type='MLE')

</code></pre>

<hr>
<h2 id='is.del_sropt'>Is this in the &quot;del_sropt&quot; class?</h2><span id='topic+is.del_sropt'></span>

<h3>Description</h3>

<p>Checks if an object is in the class <code>'del_sropt'</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.del_sropt(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.del_sropt_+3A_x">x</code></td>
<td>
<p>an object of some kind.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To satisfy the minimum requirements of an S3 class.
</p>


<h3>Value</h3>

<p>a boolean.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p>del_sropt
</p>
<p>Other del_sropt: 
<code><a href="#topic+as.del_sropt">as.del_sropt</a>()</code>,
<code><a href="#topic+del_sropt">del_sropt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>roll.own &lt;- del_sropt(z.s=2,z.sub=1,df1=10,df2=1000,df1.sub=3,ope=1,epoch="yr")
is.sropt(roll.own)
</code></pre>

<hr>
<h2 id='is.sr'>Is this in the &quot;sr&quot; class?</h2><span id='topic+is.sr'></span>

<h3>Description</h3>

<p>Checks if an object is in the class <code>'sr'</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.sr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.sr_+3A_x">x</code></td>
<td>
<p>an object of some kind.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To satisfy the minimum requirements of an S3 class.
</p>


<h3>Value</h3>

<p>a boolean.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p>sr
</p>
<p>Other sr: 
<code><a href="#topic+as.sr">as.sr</a>()</code>,
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+dsr">dsr</a>()</code>,
<code><a href="#topic+plambdap">plambdap</a>()</code>,
<code><a href="#topic+power.sr_test">power.sr_test</a>()</code>,
<code><a href="#topic+predint">predint</a>()</code>,
<code><a href="#topic+print.sr">print.sr</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+se">se</a>()</code>,
<code><a href="#topic+sr_equality_test">sr_equality_test</a>()</code>,
<code><a href="#topic+sr_test">sr_test</a>()</code>,
<code><a href="#topic+sr_unpaired_test">sr_unpaired_test</a>()</code>,
<code><a href="#topic+sr_vcov">sr_vcov</a>()</code>,
<code><a href="#topic+sr">sr</a></code>,
<code><a href="#topic+summary.sr">summary.sr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rvs &lt;- as.sr(rnorm(253*8),ope=253)
is.sr(rvs)
</code></pre>

<hr>
<h2 id='is.sropt'>Is this in the &quot;sropt&quot; class?</h2><span id='topic+is.sropt'></span>

<h3>Description</h3>

<p>Checks if an object is in the class <code>'sropt'</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.sropt(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.sropt_+3A_x">x</code></td>
<td>
<p>an object of some kind.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To satisfy the minimum requirements of an S3 class.
</p>


<h3>Value</h3>

<p>a boolean.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p>sropt
</p>
<p>Other sropt: 
<code><a href="#topic+as.sropt">as.sropt</a>()</code>,
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+dsropt">dsropt</a>()</code>,
<code><a href="#topic+pco_sropt">pco_sropt</a>()</code>,
<code><a href="#topic+power.sropt_test">power.sropt_test</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+sropt_test">sropt_test</a>()</code>,
<code><a href="#topic+sropt">sropt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nfac &lt;- 5
nyr &lt;- 10
ope &lt;- 253
# simulations with no covariance structure.
# under the null:
set.seed(as.integer(charToRaw("be determinstic")))
Returns &lt;- matrix(rnorm(ope*nyr*nfac,mean=0,sd=0.0125),ncol=nfac)
asro &lt;- as.sropt(Returns,drag=0,ope=ope)
is.sropt(asro)
</code></pre>

<hr>
<h2 id='ism_vcov'>Compute variance covariance of Inverse 'Unified' Second Moment</h2><span id='topic+ism_vcov'></span>

<h3>Description</h3>

<p>Computes the variance covariance matrix of the inverse unified 
second moment matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ism_vcov(X,vcov.func=vcov,fit.intercept=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ism_vcov_+3A_x">X</code></td>
<td>
<p>an <code class="reqn">n \times p</code> matrix of observed returns.</p>
</td></tr>
<tr><td><code id="ism_vcov_+3A_vcov.func">vcov.func</code></td>
<td>
<p>a function which takes an object of class <code>lm</code>,
and computes a variance-covariance matrix. If equal to the string
&quot;normal&quot;, we assume multivariate normal returns.</p>
</td></tr>
<tr><td><code id="ism_vcov_+3A_fit.intercept">fit.intercept</code></td>
<td>
<p>a boolean controlling whether we add a column
of ones to the data, or fit the raw uncentered second moment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">p</code>-vector <code class="reqn">x</code> with mean <code class="reqn">\mu</code> and
covariance, <code class="reqn">\Sigma</code>, let <code class="reqn">y</code> be <code class="reqn">x</code>
with a one prepended. Then let 
<code class="reqn">\Theta = E\left(y y^{\top}\right)</code>,
the uncentered second moment matrix. The inverse of
<code class="reqn">\Theta</code> contains the (negative) Markowitz portfolio 
and the precision matrix. 
</p>
<p>Given <code class="reqn">n</code> contemporaneous observations of <code class="reqn">p</code>-vectors,
stacked as rows in the <code class="reqn">n \times p</code> matrix <code class="reqn">X</code>,
this function estimates the mean and the asymptotic 
variance-covariance matrix of <code class="reqn">\Theta^{-1}</code>.
</p>
<p>One may use the default method for computing covariance,
via the <code><a href="stats.html#topic+vcov">vcov</a></code> function, or via a 'fancy' estimator,
like <code>sandwich:vcovHAC</code>, <code>sandwich:vcovHC</code>, <em>etc.</em>
</p>


<h3>Value</h3>

<p>a list containing the following components:
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>a <code class="reqn">q = p(p+3)/2</code> vector of the negative Markowitz 
portfolio, then the vech'd precision matrix of the sample data</p>
</td></tr>
<tr><td><code>Ohat</code></td>
<td>
<p>the <code class="reqn">q \times q</code> estimated variance 
covariance matrix.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of rows in <code>X</code>.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the number of assets.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>By flipping the sign of <code class="reqn">X</code>, the inverse of 
<code class="reqn">\Theta</code> contains the <em>positive</em> Markowitz
portfolio and the precision matrix on <code class="reqn">X</code>. Performing
this transform before passing the data to this function
should be considered idiomatic.
</p>
<p>This function will be deprecated in future releases of this package.
Users should migrate at that time to a similar function in the
MarkowitzR package.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Pav, S. E. &quot;Asymptotic Distribution of the Markowitz Portfolio.&quot;
2013 <a href="https://arxiv.org/abs/1312.0557">https://arxiv.org/abs/1312.0557</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sm_vcov">sm_vcov</a></code>, <code><a href="#topic+sr_vcov">sr_vcov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(1000*3),ncol=3)
# putting in -X is idiomatic:
ism &lt;- ism_vcov(-X)
iSigmas.n &lt;- ism_vcov(-X,vcov.func="normal")
iSigmas.n &lt;- ism_vcov(-X,fit.intercept=FALSE)
# compute the marginal Wald test statistics:
ism.mu &lt;- ism$mu[1:ism$p]
ism.Sg &lt;- ism$Ohat[1:ism$p,1:ism$p]
wald.stats &lt;- ism.mu / sqrt(diag(ism.Sg))

# make it fat tailed:
X &lt;- matrix(rt(1000*3,df=5),ncol=3)
ism &lt;- ism_vcov(X)
wald.stats &lt;- ism$mu[1:ism$p] / sqrt(diag(ism$Ohat[1:ism$p,1:ism$p]))

if (require(sandwich)) {
 ism &lt;- ism_vcov(X,vcov.func=vcovHC)
 wald.stats &lt;- ism$mu[1:ism$p] / sqrt(diag(ism$Ohat[1:ism$p,1:ism$p]))
}

# add some autocorrelation to X
Xf &lt;- filter(X,c(0.2),"recursive")
colnames(Xf) &lt;- colnames(X)
ism &lt;- ism_vcov(Xf)
wald.stats &lt;- ism$mu[1:ism$p] / sqrt(diag(ism$Ohat[1:ism$p,1:ism$p]))

if (require(sandwich)) {
ism &lt;- ism_vcov(Xf,vcov.func=vcovHAC)
 wald.stats &lt;- ism$mu[1:ism$p] / sqrt(diag(ism$Ohat[1:ism$p,1:ism$p]))
}


</code></pre>

<hr>
<h2 id='pco_sropt'>The 'confidence distribution' for maximal Sharpe ratio.</h2><span id='topic+pco_sropt'></span><span id='topic+qco_sropt'></span>

<h3>Description</h3>

<p>Distribution function and quantile function for the 'confidence
distribution' of the maximal Sharpe ratio. This is just an inversion
to perform inference on <code class="reqn">\zeta_*</code> given observed statistic 
<code class="reqn">z_*</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pco_sropt(q,df1,df2,z.s,ope,lower.tail=TRUE,log.p=FALSE) 

qco_sropt(p,df1,df2,z.s,ope,lower.tail=TRUE,log.p=FALSE,lb=0,ub=Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pco_sropt_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="pco_sropt_+3A_df1">df1</code></td>
<td>
<p>the number of assets in the portfolio.</p>
</td></tr>
<tr><td><code id="pco_sropt_+3A_df2">df2</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code id="pco_sropt_+3A_z.s">z.s</code></td>
<td>
<p>an observed Sharpe ratio statistic, annualized.</p>
</td></tr>
<tr><td><code id="pco_sropt_+3A_ope">ope</code></td>
<td>
<p>the number of observations per 'epoch'. For convenience of
interpretation, The Sharpe ratio is typically quoted in 'annualized' 
units for some epoch, that is, 'per square root epoch', though returns 
are observed at a frequency of <code>ope</code> per epoch. 
The default value is 1, meaning the code will not attempt to guess
what the observation frequency is, and no annualization adjustments
will be made.</p>
</td></tr>
<tr><td><code id="pco_sropt_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="pco_sropt_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as <code class="reqn">\mbox{log}(p)</code>.</p>
</td></tr>
<tr><td><code id="pco_sropt_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="pco_sropt_+3A_lb">lb</code></td>
<td>
<p>the lower bound for the output of <code>qco_sropt</code>.</p>
</td></tr>
<tr><td><code id="pco_sropt_+3A_ub">ub</code></td>
<td>
<p>the upper bound for the output of <code>qco_sropt</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">z_*</code> follows a <em>Maximal Sharpe ratio</em> distribution
(see <code><a href="#topic+SharpeR-package">SharpeR-package</a></code>) for known degrees of freedom, and 
unknown non-centrality parameter <code class="reqn">\zeta_*</code>. The 
'confidence distribution' views <code class="reqn">\zeta_*</code> as a random
quantity once <code class="reqn">z_*</code> is observed. As such, the CDF of
the confidence distribution is the same as that of the 
Maximal Sharpe ratio (up to a flip of <code>lower.tail</code>);
while the quantile function is used to compute confidence
intervals on <code class="reqn">\zeta_*</code> given <code class="reqn">z_*</code>.
</p>


<h3>Value</h3>

<p><code>pco_sropt</code> gives the distribution function, and
<code>qco_sropt</code> gives the quantile function.
</p>
<p>Invalid arguments will result in return value <code>NaN</code> with a warning.
</p>


<h3>Note</h3>

<p>When <code>lower.tail</code> is true, <code>pco_sropt</code> is monotonic increasing 
with respect to <code>q</code>, and decreasing in <code>sropt</code>; these are reversed
when <code>lower.tail</code> is false. Similarly, <code>qco_sropt</code> is increasing
in <code>sign(as.double(lower.tail) - 0.5) * p</code> and
<code>- sign(as.double(lower.tail) - 0.5) * sropt</code>.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reannualize">reannualize</a></code>
</p>
<p><code><a href="#topic+dsropt">dsropt</a>,<a href="#topic+psropt">psropt</a>,<a href="#topic+qsropt">qsropt</a>,<a href="#topic+rsropt">rsropt</a></code>
</p>
<p>Other sropt: 
<code><a href="#topic+as.sropt">as.sropt</a>()</code>,
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+dsropt">dsropt</a>()</code>,
<code><a href="#topic+is.sropt">is.sropt</a>()</code>,
<code><a href="#topic+power.sropt_test">power.sropt_test</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+sropt_test">sropt_test</a>()</code>,
<code><a href="#topic+sropt">sropt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
zeta.s &lt;- 2.0
ope &lt;- 253
ntest &lt;- 50
df1 &lt;- 4
df2 &lt;- 6 * ope
rvs &lt;- rsropt(ntest,df1=df1,df2=df2,zeta.s=zeta.s)
qvs &lt;- seq(0,10,length.out=51)
pps &lt;- pco_sropt(qvs,df1,df2,rvs[1],ope)

if (require(txtplot))
 txtplot(qvs,pps)

pps &lt;- pco_sropt(qvs,df1,df2,rvs[1],ope,lower.tail=FALSE)

if (require(txtplot))
 txtplot(qvs,pps)


svs &lt;- seq(0,4,length.out=51)
pps &lt;- pco_sropt(2,df1,df2,svs,ope)
pps &lt;- pco_sropt(2,df1,df2,svs,ope,lower.tail=FALSE)

pps &lt;- pco_sropt(qvs,df1,df2,rvs[1],ope,lower.tail=FALSE)
pco_sropt(-1,df1,df2,rvs[1],ope)

qvs &lt;- qco_sropt(0.05,df1=df1,df2=df2,z.s=rvs)
mean(qvs &gt; zeta.s)
qvs &lt;- qco_sropt(0.5,df1=df1,df2=df2,z.s=rvs)
mean(qvs &gt; zeta.s)
qvs &lt;- qco_sropt(0.95,df1=df1,df2=df2,z.s=rvs)
mean(qvs &gt; zeta.s)
# test vectorization:
qv &lt;- qco_sropt(0.1,df1,df2,rvs)
qv &lt;- qco_sropt(c(0.1,0.2),df1,df2,rvs)
qv &lt;- qco_sropt(c(0.1,0.2),c(df1,2*df1),df2,rvs)
qv &lt;- qco_sropt(c(0.1,0.2),c(df1,2*df1),c(df2,2*df2),rvs)

</code></pre>

<hr>
<h2 id='plambdap'>The lambda-prime distribution.</h2><span id='topic+plambdap'></span><span id='topic+qlambdap'></span><span id='topic+rlambdap'></span>

<h3>Description</h3>

<p>Distribution function and quantile function for LeCoutre's
lambda-prime distribution with <code>df</code> degrees of freedom
and the observed t-statistic, <code>tstat</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plambdap(q, df, tstat, lower.tail = TRUE, log.p = FALSE)

qlambdap(p, df, tstat, lower.tail = TRUE, log.p = FALSE)

rlambdap(n, df, tstat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plambdap_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="plambdap_+3A_df">df</code></td>
<td>
<p>the degrees of freedom of the t-statistic.</p>
</td></tr>
<tr><td><code id="plambdap_+3A_tstat">tstat</code></td>
<td>
<p>the observed (non-central) t-statistic.</p>
</td></tr>
<tr><td><code id="plambdap_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="plambdap_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as <code class="reqn">\mbox{log}(p)</code>.</p>
</td></tr>
<tr><td><code id="plambdap_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="plambdap_+3A_n">n</code></td>
<td>
<p>number of observations. If 'length(n) &gt; 1', the length is
taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">t</code> be distributed
as a non-central t with <code class="reqn">\nu</code> degrees of freedom and non-centrality
parameter <code class="reqn">\delta</code>. We can view this as
</p>
<p style="text-align: center;"><code class="reqn">t = \frac{Z + \delta}{\sqrt{V/\nu}}.</code>
</p>

<p>where <code class="reqn">Z</code> is a standard normal, <code class="reqn">\delta</code> is the
non-centrality parameter, <code class="reqn">V</code> is a chi-square RV with <code class="reqn">\nu</code>
degrees of freedom, independent of <code class="reqn">Z</code>.  We can rewrite this as
</p>
<p style="text-align: center;"><code class="reqn">\delta = t\sqrt{V/\nu} + Z.</code>
</p>

<p>Thus a 'lambda-prime' random variable with parameters <code class="reqn">t</code> and
<code class="reqn">\nu</code> is one expressable as a sum
</p>
<p style="text-align: center;"><code class="reqn">t\sqrt{V/\nu} + Z</code>
</p>

<p>for Chi-square <code class="reqn">V</code> with <code class="reqn">\nu</code> d.f., independent from
standard normal <code class="reqn">Z</code>
</p>
<p>See &lsquo;The Sharpe Ratio: Statistics and Applications&rsquo;,
section 2.4.
</p>


<h3>Value</h3>

<p><code>dlambdap</code> gives the density, <code>plambdap</code> gives the distribution function,
<code>qlambdap</code> gives the quantile function, and <code>rlambdap</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code> with a warning.
</p>


<h3>Note</h3>

<p><code>plambdap</code> should be an increasing function of the argument <code>q</code>,
and decreasing in <code>tstat</code>. <code>qlambdap</code> should be increasing
in <code>p</code>
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Pav, S. E. &quot;The Sharpe Ratio: Statistics and Applications.&quot; CRC Press, 2021.
</p>
<p>Lecoutre, Bruno. &quot;Another look at confidence intervals for the noncentral t distribution.&quot; 
Journal of Modern Applied Statistical Methods 6, no. 1 (2007): 107&ndash;116.
<a href="https://eris62.eu/telechargements/Lecoutre_Another_look-JMSAM2007_6(1).pdf">https://eris62.eu/telechargements/Lecoutre_Another_look-JMSAM2007_6(1).pdf</a>
</p>
<p>Lecoutre, Bruno. &quot;Two useful distributions for Bayesian predictive procedures under normal models.&quot;
Journal of Statistical Planning and Inference 79  (1999): 93&ndash;105.
</p>


<h3>See Also</h3>

<p>t-distribution functions, <code><a href="stats.html#topic+dt">dt</a>,<a href="stats.html#topic+pt">pt</a>,<a href="stats.html#topic+qt">qt</a>,<a href="stats.html#topic+rt">rt</a></code>
</p>
<p>Other sr: 
<code><a href="#topic+as.sr">as.sr</a>()</code>,
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+dsr">dsr</a>()</code>,
<code><a href="#topic+is.sr">is.sr</a>()</code>,
<code><a href="#topic+power.sr_test">power.sr_test</a>()</code>,
<code><a href="#topic+predint">predint</a>()</code>,
<code><a href="#topic+print.sr">print.sr</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+se">se</a>()</code>,
<code><a href="#topic+sr_equality_test">sr_equality_test</a>()</code>,
<code><a href="#topic+sr_test">sr_test</a>()</code>,
<code><a href="#topic+sr_unpaired_test">sr_unpaired_test</a>()</code>,
<code><a href="#topic+sr_vcov">sr_vcov</a>()</code>,
<code><a href="#topic+sr">sr</a></code>,
<code><a href="#topic+summary.sr">summary.sr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rvs &lt;- rnorm(128)
pvs &lt;- plambdap(rvs, 253*6, 0.5)
plot(ecdf(pvs))
pvs &lt;- plambdap(rvs, 253*6, 1)
plot(ecdf(pvs))
pvs &lt;- plambdap(rvs, 253*6, -0.5)
plot(ecdf(pvs))
# test vectorization:
qv &lt;- qlambdap(0.1,128,2)
qv &lt;- qlambdap(c(0.1),128,2)
qv &lt;- qlambdap(c(0.2),128,2)
qv &lt;- qlambdap(c(0.2),253,2)
qv &lt;- qlambdap(c(0.1,0.2),128,2)
qv &lt;- qlambdap(c(0.1,0.2),c(128,253),2)
qv &lt;- qlambdap(c(0.1,0.2),c(128,253),c(2,4))
qv &lt;- qlambdap(c(0.1,0.2),c(128,253),c(2,4,8,16))
# random generation
rv &lt;- rlambdap(1000,252,2)

</code></pre>

<hr>
<h2 id='power.sr_test'>Power calculations for Sharpe ratio tests</h2><span id='topic+power.sr_test'></span>

<h3>Description</h3>

<p>Compute power of test, or determine parameters to obtain target power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.sr_test(n=NULL,zeta=NULL,sig.level=0.05,power=NULL,
              alternative=c("one.sided","two.sided"),ope=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power.sr_test_+3A_n">n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code id="power.sr_test_+3A_zeta">zeta</code></td>
<td>
<p>the 'signal-to-noise' parameter, defined as the population
mean divided by the population standard deviation, 'annualized'.</p>
</td></tr>
<tr><td><code id="power.sr_test_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level (Type I error probability).</p>
</td></tr>
<tr><td><code id="power.sr_test_+3A_power">power</code></td>
<td>
<p>Power of test (1 minus Type II error probability).</p>
</td></tr>
<tr><td><code id="power.sr_test_+3A_alternative">alternative</code></td>
<td>
<p>One- or two-sided test.</p>
</td></tr>
<tr><td><code id="power.sr_test_+3A_ope">ope</code></td>
<td>
<p>the number of observations per 'epoch'. For convenience of
interpretation, The Sharpe ratio is typically quoted in 'annualized' 
units for some epoch, that is, 'per square root epoch', though returns 
are observed at a frequency of <code>ope</code> per epoch. 
The default value is 1, meaning the code will not attempt to guess
what the observation frequency is, and no annualization adjustments
will be made.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose you perform a single-sample test for significance of the
Sharpe ratio based on the corresponding single-sample t-test. 
Given any three of: the effect size (the population SNR, <code class="reqn">\zeta</code>), 
the number of observations, and the type I and type II rates,
this function computes the fourth.
</p>
<p>See &lsquo;The Sharpe Ratio: Statistics and Applications&rsquo;,
section 2.5.8.
</p>
<p>This is a thin wrapper on <code><a href="stats.html#topic+power.t.test">power.t.test</a></code>.
</p>
<p>Exactly one of the parameters <code>n</code>, <code>zeta</code>, <code>power</code>, and 
<code>sig.level</code> must be passed as NULL, and that parameter is determined 
from the others.  Notice that <code>sig.level</code> has non-NULL default, so NULL 
must be explicitly passed if you want to compute it.
</p>


<h3>Value</h3>

<p>Object of class <code>power.htest</code>, a list of the arguments
(including the computed one) augmented with <code>method</code>, <code>note</code>
and <code>n.epoch</code> elements, the latter is the number of epochs 
under the given annualization (<code>ope</code>), <code>NA</code> if none given.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Sharpe, William F. &quot;Mutual fund performance.&quot; Journal of business (1966): 119-138.
<a href="https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html">https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html</a>
</p>
<p>Johnson, N. L., and Welch, B. L. &quot;Applications of the non-central t-distribution.&quot;
Biometrika 31, no. 3-4 (1940): 362-389. doi: <a href="https://doi.org/10.1093/biomet/31.3-4.362">10.1093/biomet/31.3-4.362</a>
</p>
<p>Pav, S. E. &quot;The Sharpe Ratio: Statistics and Applications.&quot; CRC Press, 2021.
</p>
<p>Lehr, R. &quot;Sixteen S-squared over D-squared: A relation for crude 
sample size estimates.&quot; Statist. Med., 11, no 8 (1992): 1099&ndash;1102. 
doi: <a href="https://doi.org/10.1002/sim.4780110811">10.1002/sim.4780110811</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reannualize">reannualize</a></code>
</p>
<p><code><a href="stats.html#topic+power.t.test">power.t.test</a></code>, <code><a href="#topic+sr_test">sr_test</a></code>
</p>
<p>Other sr: 
<code><a href="#topic+as.sr">as.sr</a>()</code>,
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+dsr">dsr</a>()</code>,
<code><a href="#topic+is.sr">is.sr</a>()</code>,
<code><a href="#topic+plambdap">plambdap</a>()</code>,
<code><a href="#topic+predint">predint</a>()</code>,
<code><a href="#topic+print.sr">print.sr</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+se">se</a>()</code>,
<code><a href="#topic+sr_equality_test">sr_equality_test</a>()</code>,
<code><a href="#topic+sr_test">sr_test</a>()</code>,
<code><a href="#topic+sr_unpaired_test">sr_unpaired_test</a>()</code>,
<code><a href="#topic+sr_vcov">sr_vcov</a>()</code>,
<code><a href="#topic+sr">sr</a></code>,
<code><a href="#topic+summary.sr">summary.sr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>anex &lt;- power.sr_test(253,1,0.05,NULL,ope=253) 
anex &lt;- power.sr_test(n=253,zeta=NULL,sig.level=0.05,power=0.5,ope=253) 
anex &lt;- power.sr_test(n=NULL,zeta=0.6,sig.level=0.05,power=0.5,ope=253) 
# Lehr's Rule 
zetas &lt;- seq(0.1,2.5,length.out=51)
ssizes &lt;- sapply(zetas,function(zed) { 
  x &lt;- power.sr_test(n=NULL,zeta=zed,sig.level=0.05,power=0.8,
       alternative="two.sided",ope=253)
  x$n / 253})
# should be around 8.
print(summary(ssizes * zetas * zetas))
# e = n z^2 mnemonic approximate rule for 0.05 type I, 50% power
ssizes &lt;- sapply(zetas,function(zed) { 
  x &lt;- power.sr_test(n=NULL,zeta=zed,sig.level=0.05,power=0.5,ope=253)
  x$n / 253 })
print(summary(ssizes * zetas * zetas - exp(1)))

</code></pre>

<hr>
<h2 id='power.sropt_test'>Power calculations for optimal Sharpe ratio tests</h2><span id='topic+power.sropt_test'></span>

<h3>Description</h3>

<p>Compute power of test, or determine parameters to obtain target power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.sropt_test(df1=NULL,df2=NULL,zeta.s=NULL,
                 sig.level=0.05,power=NULL,ope=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power.sropt_test_+3A_df1">df1</code></td>
<td>
<p>the number of assets in the portfolio.</p>
</td></tr>
<tr><td><code id="power.sropt_test_+3A_df2">df2</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code id="power.sropt_test_+3A_zeta.s">zeta.s</code></td>
<td>
<p>the 'signal-to-noise' parameter, defined as ...</p>
</td></tr>
<tr><td><code id="power.sropt_test_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level (Type I error probability).</p>
</td></tr>
<tr><td><code id="power.sropt_test_+3A_power">power</code></td>
<td>
<p>Power of test (1 minus Type II error probability).</p>
</td></tr>
<tr><td><code id="power.sropt_test_+3A_ope">ope</code></td>
<td>
<p>the number of observations per 'epoch'. For convenience of
interpretation, The Sharpe ratio is typically quoted in 'annualized' 
units for some epoch, that is, 'per square root epoch', though returns 
are observed at a frequency of <code>ope</code> per epoch. 
The default value is 1, meaning the code will not attempt to guess
what the observation frequency is, and no annualization adjustments
will be made.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose you perform a single-sample test for significance of the
optimal Sharpe ratio based on the corresponding single-sample T^2-test. 
Given any four of: the effect size (the population optimal SNR, 
<code class="reqn">\zeta_*</code>), the number of assets, the number of observations, 
and the type I and type II rates, this function computes the fifth.
</p>
<p>See &lsquo;The Sharpe Ratio: Statistics and Applications&rsquo;,
section 6.3.3.
</p>
<p>Exactly one of the parameters <code>df1</code>, <code>df2</code>, 
<code>zeta.s</code>, <code>power</code>, and 
<code>sig.level</code> must be passed as NULL, and that parameter is determined 
from the others.  Notice that <code>sig.level</code> has non-NULL default, so NULL 
must be explicitly passed if you want to compute it.
</p>


<h3>Value</h3>

<p>Object of class <code>power.htest</code>, a list of the arguments
(including the computed one) augmented with <code>method</code>, <code>note</code>
and <code>n.epoch</code> elements, the latter is the number of epochs 
under the given annualization (<code>ope</code>), <code>NA</code> if none given.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Pav, S. E. &quot;The Sharpe Ratio: Statistics and Applications.&quot; CRC Press, 2021.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reannualize">reannualize</a></code>
</p>
<p><code><a href="stats.html#topic+power.t.test">power.t.test</a></code>, <code><a href="#topic+sropt_test">sropt_test</a></code>
</p>
<p>Other sropt: 
<code><a href="#topic+as.sropt">as.sropt</a>()</code>,
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+dsropt">dsropt</a>()</code>,
<code><a href="#topic+is.sropt">is.sropt</a>()</code>,
<code><a href="#topic+pco_sropt">pco_sropt</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+sropt_test">sropt_test</a>()</code>,
<code><a href="#topic+sropt">sropt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>anex &lt;- power.sropt_test(8,4*253,1,0.05,NULL,ope=253) 

</code></pre>

<hr>
<h2 id='predint'>prediction interval for Sharpe ratio</h2><span id='topic+predint'></span>

<h3>Description</h3>

<p>Computes the prediction interval for Sharpe ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predint(
  x,
  oosdf,
  oosrescal = 1/sqrt(oosdf + 1),
  ope = NULL,
  level = 0.95,
  level.lo = (1 - level)/2,
  level.hi = 1 - level.lo,
  type = c("t", "Z", "Mertens", "Bao")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predint_+3A_x">x</code></td>
<td>
<p>a (non-empty) numeric vector of data values, or an
object of class <code>sr</code>.</p>
</td></tr>
<tr><td><code id="predint_+3A_oosdf">oosdf</code></td>
<td>
<p>the future (or 'out of sample', thus 'oos') degrees of freedom.
In the vanilla Sharpe case, this is the number of future observations
<em>minus one</em>.</p>
</td></tr>
<tr><td><code id="predint_+3A_oosrescal">oosrescal</code></td>
<td>
<p>the rescaling parameter for the future Sharpe ratio. The default value
holds for the case of unattributed models ('vanilla Shape'), but can be set
to some other value to deal with the magnitude of attribution factors in the
future period.</p>
</td></tr>
<tr><td><code id="predint_+3A_ope">ope</code></td>
<td>
<p>the number of observations per 'epoch'. For convenience of
interpretation, The Sharpe ratio is typically quoted in 'annualized' 
units for some epoch, that is, 'per square root epoch', though returns 
are observed at a frequency of <code>ope</code> per epoch. 
The default value is to take the same <code>ope</code> from the input <code>x</code>
object, if it is unambiguous.</p>
</td></tr>
<tr><td><code id="predint_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="predint_+3A_level.lo">level.lo</code></td>
<td>
<p>the lower confidence level required.</p>
</td></tr>
<tr><td><code id="predint_+3A_level.hi">level.hi</code></td>
<td>
<p>the upper confidence level required.</p>
</td></tr>
<tr><td><code id="predint_+3A_type">type</code></td>
<td>
<p>which method to apply. Only methods based on an approximate
standard error are supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">n_0</code> observations <code class="reqn">x_i</code> from a normal random variable,
with mean <code class="reqn">\mu</code> and standard deviation <code class="reqn">\sigma</code>, computes
an interval <code class="reqn">[y_1,y_2]</code> such that with a fixed probability,
the sample Sharpe ratio over <code class="reqn">n</code> future observations will fall in the
given interval. The coverage is over repeated draws of both the past and
future data, thus this computation takes into account error in both the
estimate of Sharpe and the as yet unrealized returns.
Coverage is approximate. Prediction intervals are computed by
inflating a confidence interval by an amount which depends on the sample
sizes.
</p>
<p>See &lsquo;The Sharpe Ratio: Statistics and Applications&rsquo;,
sections 2.5.9 and 3.5.2.
</p>


<h3>Value</h3>

<p>A matrix (or vector) with columns giving lower and upper
confidence limits for the parameter. These will be labelled as
level.lo and level.hi in %, <em>e.g.</em> <code>"2.5 %"</code>
</p>


<h3>Note</h3>

<p>if <code>level.lo &lt; 0</code> or <code>level.hi &gt; 1</code>, <code>NaN</code> will be
returned.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Pav, S. E. &quot;The Sharpe Ratio: Statistics and Applications.&quot; CRC Press, 2021.
</p>
<p>Sharpe, William F. &quot;Mutual fund performance.&quot; Journal of business (1966): 119-138.
<a href="https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html">https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+confint.sr">confint.sr</a></code>.
</p>
<p>Other sr: 
<code><a href="#topic+as.sr">as.sr</a>()</code>,
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+dsr">dsr</a>()</code>,
<code><a href="#topic+is.sr">is.sr</a>()</code>,
<code><a href="#topic+plambdap">plambdap</a>()</code>,
<code><a href="#topic+power.sr_test">power.sr_test</a>()</code>,
<code><a href="#topic+print.sr">print.sr</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+se">se</a>()</code>,
<code><a href="#topic+sr_equality_test">sr_equality_test</a>()</code>,
<code><a href="#topic+sr_test">sr_test</a>()</code>,
<code><a href="#topic+sr_unpaired_test">sr_unpaired_test</a>()</code>,
<code><a href="#topic+sr_vcov">sr_vcov</a>()</code>,
<code><a href="#topic+sr">sr</a></code>,
<code><a href="#topic+summary.sr">summary.sr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# should reject null
set.seed(1234)
etc &lt;- predint(rnorm(1000,mean=0.5,sd=0.1),oosdf=127,ope=1)
etc &lt;- predint(matrix(rnorm(1000*5,mean=0.05),ncol=5),oosdf=63,ope=1)

# check coverage
mu &lt;- 0.0005
sg &lt;- 0.013
n1 &lt;- 512
n2 &lt;- 256
p  &lt;- 100
x1 &lt;- matrix(rnorm(n1*p,mean=mu,sd=sg),ncol=p)
x2 &lt;- matrix(rnorm(n2*p,mean=mu,sd=sg),ncol=p)
sr1 &lt;- as.sr(x1)
sr2 &lt;- as.sr(x2)
# check coverage of prediction interval
etc1 &lt;- predint(sr1,oosdf=n2-1,level=0.95)
is.ok &lt;- (etc1[,1] &lt;= sr2$sr) &amp; (sr2$sr &lt;= etc1[,2])
covr &lt;- mean(is.ok)

</code></pre>

<hr>
<h2 id='print.sr'>Print values.</h2><span id='topic+print.sr'></span><span id='topic+print.sropt'></span><span id='topic+print.del_sropt'></span>

<h3>Description</h3>

<p>Displays an object, returning it <em>invisibly</em>, 
(via <code>invisible(x)</code>.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sr'
print(x, ...)

## S3 method for class 'sropt'
print(x, ...)

## S3 method for class 'del_sropt'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sr_+3A_x">x</code></td>
<td>
<p>an object of class <code>sr</code> or <code>sropt</code>.</p>
</td></tr>
<tr><td><code id="print.sr_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object, wrapped in <code>invisible</code>.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Sharpe, William F. &quot;Mutual fund performance.&quot; Journal of business (1966): 119-138.
<a href="https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html">https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html</a>
</p>


<h3>See Also</h3>

<p>Other sr: 
<code><a href="#topic+as.sr">as.sr</a>()</code>,
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+dsr">dsr</a>()</code>,
<code><a href="#topic+is.sr">is.sr</a>()</code>,
<code><a href="#topic+plambdap">plambdap</a>()</code>,
<code><a href="#topic+power.sr_test">power.sr_test</a>()</code>,
<code><a href="#topic+predint">predint</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+se">se</a>()</code>,
<code><a href="#topic+sr_equality_test">sr_equality_test</a>()</code>,
<code><a href="#topic+sr_test">sr_test</a>()</code>,
<code><a href="#topic+sr_unpaired_test">sr_unpaired_test</a>()</code>,
<code><a href="#topic+sr_vcov">sr_vcov</a>()</code>,
<code><a href="#topic+sr">sr</a></code>,
<code><a href="#topic+summary.sr">summary.sr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute a 'daily' Sharpe
mysr &lt;- as.sr(rnorm(253*8),ope=1,epoch="day")
print(mysr)
# roll your own.
ope &lt;- 253
zeta &lt;- 1.0
n &lt;- 6 * ope
rvs &lt;- rsr(1,n,zeta,ope=ope)
roll.own &lt;- sr(sr=rvs,df=n-1,ope=ope,rescal=sqrt(1/n))
print(roll.own)
# put a bunch in. naming becomes a problem.
rvs &lt;- rsr(5,n,zeta,ope=ope)
roll.own &lt;- sr(sr=rvs,df=n-1,ope=ope,rescal=sqrt(1/n))
print(roll.own)
# for sropt objects:
nfac &lt;- 5
nyr &lt;- 10
ope &lt;- 253
# simulations with no covariance structure.
# under the null:
set.seed(as.integer(charToRaw("be determinstic")))
Returns &lt;- matrix(rnorm(ope*nyr*nfac,mean=0,sd=0.0125),ncol=nfac)
asro &lt;- as.sropt(Returns,drag=0,ope=ope)
print(asro)
</code></pre>

<hr>
<h2 id='reannualize'>Change the annualization of a Sharpe ratio.</h2><span id='topic+reannualize'></span><span id='topic+reannualize.sr'></span><span id='topic+reannualize.sropt'></span>

<h3>Description</h3>

<p>Changes the annualization factor of a Sharpe ratio statistic, or the rate at
which observations are made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reannualize(object, new.ope = NULL, new.epoch = NULL)

## S3 method for class 'sr'
reannualize(object, new.ope = NULL, new.epoch = NULL)

## S3 method for class 'sropt'
reannualize(object, new.ope = NULL, new.epoch = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reannualize_+3A_object">object</code></td>
<td>
<p>an object of class <code>sr</code> or <code>sropt</code>.</p>
</td></tr>
<tr><td><code id="reannualize_+3A_new.ope">new.ope</code></td>
<td>
<p>the new observations per epoch. If none given, it is
not updated.</p>
</td></tr>
<tr><td><code id="reannualize_+3A_new.epoch">new.epoch</code></td>
<td>
<p>a string representation of the epoch. If none given, it is not
updated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input object with the annualization and/or epoch updated.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p>sr
</p>
<p>sropt
</p>
<p>Other sr: 
<code><a href="#topic+as.sr">as.sr</a>()</code>,
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+dsr">dsr</a>()</code>,
<code><a href="#topic+is.sr">is.sr</a>()</code>,
<code><a href="#topic+plambdap">plambdap</a>()</code>,
<code><a href="#topic+power.sr_test">power.sr_test</a>()</code>,
<code><a href="#topic+predint">predint</a>()</code>,
<code><a href="#topic+print.sr">print.sr</a>()</code>,
<code><a href="#topic+se">se</a>()</code>,
<code><a href="#topic+sr_equality_test">sr_equality_test</a>()</code>,
<code><a href="#topic+sr_test">sr_test</a>()</code>,
<code><a href="#topic+sr_unpaired_test">sr_unpaired_test</a>()</code>,
<code><a href="#topic+sr_vcov">sr_vcov</a>()</code>,
<code><a href="#topic+sr">sr</a></code>,
<code><a href="#topic+summary.sr">summary.sr</a></code>
</p>
<p>Other sropt: 
<code><a href="#topic+as.sropt">as.sropt</a>()</code>,
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+dsropt">dsropt</a>()</code>,
<code><a href="#topic+is.sropt">is.sropt</a>()</code>,
<code><a href="#topic+pco_sropt">pco_sropt</a>()</code>,
<code><a href="#topic+power.sropt_test">power.sropt_test</a>()</code>,
<code><a href="#topic+sropt_test">sropt_test</a>()</code>,
<code><a href="#topic+sropt">sropt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute a 'daily' Sharpe
mysr &lt;- as.sr(rnorm(253*8),ope=1,epoch="day")
# turn into annual 
mysr2 &lt;- reannualize(mysr,new.ope=253,new.epoch="yr")

# for sropt
ope &lt;- 253
zeta.s &lt;- 1.0  
df1 &lt;- 10
df2 &lt;- 6 * ope
rvs &lt;- rsropt(1,df1,df2,zeta.s,ope,drag=0)
roll.own &lt;- sropt(z.s=rvs,df1,df2,drag=0,ope=ope,epoch="yr")
# make 'monthly'
roll.monthly &lt;- reannualize(roll.own,new.ope=21,new.epoch="mo.")
# make 'daily'
roll.daily &lt;- reannualize(roll.own,new.ope=1,new.epoch="day")
</code></pre>

<hr>
<h2 id='se'>Standard error computation</h2><span id='topic+se'></span><span id='topic+se.sr'></span>

<h3>Description</h3>

<p>Estimates the standard error of the Sharpe ratio statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se(z, type)

## S3 method for class 'sr'
se(z, type = c("t", "Lo", "Mertens", "Bao"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se_+3A_z">z</code></td>
<td>
<p>an observed Sharpe ratio statistic, of class <code>sr</code>.</p>
</td></tr>
<tr><td><code id="se_+3A_type">type</code></td>
<td>
<p>estimator type. one of <code>"t", "Lo", "Mertens", "Bao"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an observed Sharpe ratio, estimate the standard error.
The following methods are recognized:
</p>

<dl>
<dt>t</dt><dd><p>The default, based on Johnson &amp; Welch, with a correction
for small sample size. Also known as <code>'Lo'</code>.</p>
</dd>
<dt>Mertens</dt><dd><p>An approximation to the standard error taking into
skewness and kurtosis of the returns distribution.</p>
</dd>
<dt>Bao</dt><dd><p>An even higher accuracty approximation using higher order
moments.</p>
</dd>
</dl>

<p>There should be very little difference between these except for very small
sample sizes.
</p>
<p>See &lsquo;The Sharpe Ratio: Statistics and Applications&rsquo;,
sections 2.5.1 and 3.2.3.
</p>


<h3>Value</h3>

<p>an estimate of standard error.
</p>


<h3>Note</h3>

<p>The units of the standard error are consistent with those of the
input <code>sr</code> object.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Sharpe, William F. &quot;Mutual fund performance.&quot; Journal of business (1966): 119-138.
<a href="https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html">https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html</a>
</p>
<p>Johnson, N. L., and Welch, B. L. &quot;Applications of the non-central t-distribution.&quot;
Biometrika 31, no. 3-4 (1940): 362-389. doi: <a href="https://doi.org/10.1093/biomet/31.3-4.362">10.1093/biomet/31.3-4.362</a>
</p>
<p>Lo, Andrew W. &quot;The statistics of Sharpe ratios.&quot; Financial Analysts Journal 58, no. 4 
(2002): 36-52. <a href="https://www.ssrn.com/paper=377260">https://www.ssrn.com/paper=377260</a>
</p>
<p>Bao, Yong. &quot;Estimation Risk-Adjusted Sharpe Ratio and Fund Performance Ranking 
Under a General Return Distribution.&quot; Journal of Financial Econometrics 7, 
no. 2 (2009): 152-173. doi: <a href="https://doi.org/10.1093/jjfinec/nbn022">10.1093/jjfinec/nbn022</a>
</p>
<p>Opdyke, J. D. &quot;Comparing Sharpe Ratios: So Where are the p-values?&quot; Journal of Asset
Management 8, no. 5 (2006): 308-336. <a href="https://www.ssrn.com/paper=886728">https://www.ssrn.com/paper=886728</a>
</p>
<p>Pav, S. E. &quot;The Sharpe Ratio: Statistics and Applications.&quot; CRC Press, 2021.
</p>
<p>Walck, C. &quot;Hand-book on STATISTICAL DISTRIBUTIONS for experimentalists.&quot;
1996. <a href="http://www.stat.rice.edu/~dobelman/textfiles/DistributionsHandbook.pdf">http://www.stat.rice.edu/~dobelman/textfiles/DistributionsHandbook.pdf</a>
</p>


<h3>See Also</h3>

<p>sr-distribution functions, <code><a href="#topic+dsr">dsr</a></code>,
<code><a href="#topic+sr_variance">sr_variance</a></code>.
</p>
<p>Other sr: 
<code><a href="#topic+as.sr">as.sr</a>()</code>,
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+dsr">dsr</a>()</code>,
<code><a href="#topic+is.sr">is.sr</a>()</code>,
<code><a href="#topic+plambdap">plambdap</a>()</code>,
<code><a href="#topic+power.sr_test">power.sr_test</a>()</code>,
<code><a href="#topic+predint">predint</a>()</code>,
<code><a href="#topic+print.sr">print.sr</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+sr_equality_test">sr_equality_test</a>()</code>,
<code><a href="#topic+sr_test">sr_test</a>()</code>,
<code><a href="#topic+sr_unpaired_test">sr_unpaired_test</a>()</code>,
<code><a href="#topic+sr_vcov">sr_vcov</a>()</code>,
<code><a href="#topic+sr">sr</a></code>,
<code><a href="#topic+summary.sr">summary.sr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>asr &lt;- as.sr(rnorm(128,0.2))
anse &lt;- se(asr,type="t")
anse &lt;- se(asr,type="Lo")

</code></pre>

<hr>
<h2 id='SharpeR-NEWS'>News for package 'SharpeR':</h2><span id='topic+SharpeR-NEWS'></span>

<h3>Description</h3>

<p>News for package 'SharpeR'
</p>




<h3>Changes in <a href="https://cran.r-project.org/package=SharpeR"><span class="pkg">SharpeR</span></a> Version 1.3.0 (2021-08-15) </h3>


<ul>
<li><p> Remove tests based on upsilon distribution. Also removes dependency on sadists package.
</p>
</li></ul>



<h3>Changes in <a href="https://cran.r-project.org/package=SharpeR"><span class="pkg">SharpeR</span></a> Version 1.2.1 (2020-02-06) </h3>


<ul>
<li><p> CRAN fix for warnings about ellipsis.
</p>
</li></ul>



<h3>Changes in <a href="https://cran.r-project.org/package=SharpeR"><span class="pkg">SharpeR</span></a> Version 1.2.0 (2018-10-07) </h3>


<ul>
<li><p> move github figures to location CRAN understands
</p>
</li>
<li><p> be smarter about S3 classes: do not redefine summary and print.
</p>
</li>
<li><p> add bias and variance from Bao (2009).
</p>
</li>
<li><p> support estimation of higher order moments in <code>as.sr</code>, 
and expands methods for se and confidence interval computations.
</p>
</li>
<li><p> incorporate higher order methods into one sample sr tests.
</p>
</li></ul>



<h3>Changes in <a href="https://cran.r-project.org/package=SharpeR"><span class="pkg">SharpeR</span></a> Version 1.1.0 (2016-03-14) </h3>


<ul>
<li><p> fix sr_vcov on array input.
</p>
</li>
<li><p> add SRIC method.
</p>
</li>
<li><p> add SRIC to print.sropt.
</p>
</li>
<li><p> change predint output to matrix.
</p>
</li></ul>



<h3>Changes in <a href="https://cran.r-project.org/package=SharpeR"><span class="pkg">SharpeR</span></a> Version 1.0.0 (2015-06-18) </h3>


<ul>
<li><p> sane version numbers.
</p>
</li>
<li><p> unpaired k sample test of Sharpe.
</p>
</li>
<li><p> rely on same for unpaired 2 sample test.
</p>
</li>
<li><p> prediction intervals for Sharpe based on upsilon.
</p>
</li>
<li><p> more tests.
</p>
</li></ul>



<h3>Changes in <a href="https://cran.r-project.org/package=SharpeR"><span class="pkg">SharpeR</span></a> Version 0.1501 (2014-12-06) </h3>


<ul>
<li><p> fix inference of mark frequency from e.g. xts objects.
</p>
</li>
<li><p> add rlambdap.
</p>
</li></ul>



<h3>Changes in <a href="https://cran.r-project.org/package=SharpeR"><span class="pkg">SharpeR</span></a> Version 0.1401 (2014-01-05) </h3>


<ul>
<li><p> fix second moment asymptotic covariance.
</p>
</li>
<li><p> add confidence distribution functions for sr, sr.opt.
</p>
</li></ul>



<h3>Changes in <a href="https://cran.r-project.org/package=SharpeR"><span class="pkg">SharpeR</span></a> Version 0.1310 (2013-10-30) </h3>


<ul>
<li><p> inverse second moment asymptotic covariance.
</p>
</li></ul>



<h3>Changes in <a href="https://cran.r-project.org/package=SharpeR"><span class="pkg">SharpeR</span></a> Version 0.1309 (2013-09-20) </h3>


<ul>
<li><p> spanning/hedging tests.
</p>
</li>
<li><p> sr equality test via callback variance covariance computation.
</p>
</li>
<li><p> split vignette in two.
</p>
</li></ul>



<h3>Changes in <a href="https://cran.r-project.org/package=SharpeR"><span class="pkg">SharpeR</span></a> Version 0.1307 (2013-05-30) </h3>


<ul>
<li><p> proper d.f. in sr objects with different nan fill.
</p>
</li>
<li><p> restore vignette.
</p>
</li></ul>



<h3><a href="https://cran.r-project.org/package=SharpeR"><span class="pkg">SharpeR</span></a> Initial Version 0.1306 (2013-05-21) </h3>


<ul>
<li><p> put on CRAN
</p>
</li></ul>


<hr>
<h2 id='SharpeR-package'>statistics concerning Sharpe ratio and Markowitz portfolio</h2><span id='topic+SharpeR-package'></span>

<h3>Description</h3>

<p>Inference on Sharpe ratio and Markowitz portfolio.
</p>


<h3>Sharpe Ratio</h3>

<p>Suppose <code class="reqn">x_i</code> are <code class="reqn">n</code> independent draws of a normal random
variable with mean <code class="reqn">\mu</code> and variance <code class="reqn">\sigma^2</code>.
Let <code class="reqn">\bar{x}</code> be the sample mean, and <code class="reqn">s</code> be
the sample standard deviation (using Bessel's correction). Let <code class="reqn">c_0</code>
be the 'risk free' or 'disastrous rate' of return.  Then
</p>
<p style="text-align: center;"><code class="reqn">z = \frac{\bar{x} - c_0}{s}</code>
</p>
 
<p>is the (sample) Sharpe ratio.
</p>
<p>The units of <code class="reqn">z</code> are <code class="reqn">\mbox{time}^{-1/2}</code>.
Typically the Sharpe ratio is <em>annualized</em> by multiplying by
<code class="reqn">\sqrt{d}</code>, where <code class="reqn">d</code> is the number of observations
per year (or whatever the target annualization epoch.) It is <em>not</em>
common practice to include units when quoting Sharpe ratio, though
doing so could avoid confusion.
</p>
<p>The Sharpe ratio follows a rescaled non-central t distribution. That
is, <code class="reqn">z/K</code> follows a non-central t-distribution
with <code class="reqn">m</code> degrees of freedom and non-centrality parameter
<code class="reqn">\zeta / K</code>, for some <code class="reqn">K</code>, <code class="reqn">m</code> and <code class="reqn">\zeta</code>.
</p>
<p>We can generalize Sharpe's model to APT, wherein we write
</p>
<p style="text-align: center;"><code class="reqn">x_i = \alpha + \sum_j \beta_j F_{j,i} + \epsilon_i,</code>
</p>

<p>where the <code class="reqn">F_{j,i}</code> are observed 'factor returns', and
the variance of the noise term is <code class="reqn">\sigma^2</code>.
Via linear regression, one can compute estimates <code class="reqn">\hat{\alpha}</code>,
and <code class="reqn">\hat{\sigma}</code>, and then let the 'Sharpe ratio' be
</p>
<p style="text-align: center;"><code class="reqn">z = \frac{\hat{\alpha} - c_0}{\hat{\sigma}}.</code>
</p>

<p>As above, this Sharpe ratio follows a rescaled t-distribution
under normality, <em>etc.</em>
</p>
<p>The parameters are encoded as follows:
</p>

<ul>
<li> <p><code>df</code> stands for the degrees of freedom, typically <code class="reqn">n-1</code>, but
<code class="reqn">n-J-1</code> in general.
</p>
</li>
<li> <p><code class="reqn">\zeta</code> is denoted by <code>zeta</code>.
</p>
</li>
<li> <p><code class="reqn">d</code> is denoted by <code>ope</code>. ('Observations Per Year')
</p>
</li>
<li><p> For the APT form of Sharpe, <code>K</code> stands for the
rescaling parameter.
</p>
</li></ul>



<h3>Optimal Sharpe Ratio</h3>

<p>Suppose <code class="reqn">x_i</code> are <code class="reqn">n</code> independent draws of a <code class="reqn">q</code>-variate
normal random variable with mean <code class="reqn">\mu</code> and covariance matrix
<code class="reqn">\Sigma</code>. Let <code class="reqn">\bar{x}</code> be the (vector) sample mean, and 
<code class="reqn">S</code> be the sample covariance matrix (using Bessel's correction). Let
</p>
<p style="text-align: center;"><code class="reqn">Z(w) = \frac{w^{\top}\bar{x} - c_0}{\sqrt{w^{\top}S w}}</code>
</p>

<p>be the (sample) Sharpe ratio of the portfolio <code class="reqn">w</code>, subject to 
risk free rate <code class="reqn">c_0</code>.
</p>
<p>Let <code class="reqn">w_*</code> be the solution to the portfolio optimization problem:
</p>
<p style="text-align: center;"><code class="reqn">\max_{w: 0 &lt; w^{\top}S w \le R^2} Z(w),</code>
</p>

<p>with maximum value <code class="reqn">z_* = Z\left(w_*\right)</code>.
Then 
</p>
<p style="text-align: center;"><code class="reqn">w_* = R \frac{S^{-1}\bar{x}}{\sqrt{\bar{x}^{\top}S^{-1}\bar{x}}}</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">z_* = \sqrt{\bar{x}^{\top} S^{-1} \bar{x}} - \frac{c_0}{R}</code>
</p>

<p>The variable <code class="reqn">z_*</code> follows an <em>Optimal Sharpe ratio</em>
distribution. For convenience, we may assume that the sample statistic
has been annualized in the same manner as the Sharpe ratio, that is 
by multiplying by <code class="reqn">d</code>, the number of observations per
epoch.
</p>
<p>The Optimal Sharpe Ratio distribution is parametrized by the number 
of assets, <code class="reqn">q</code>, the number of independent observations, <code class="reqn">n</code>, the 
noncentrality parameter, 
</p>
<p style="text-align: center;"><code class="reqn">\zeta_* = \sqrt{\mu^{\top}\Sigma^{-1}\mu},</code>
</p>

<p>the 'drag' term, <code class="reqn">c_0/R</code>, and the annualization factor, <code class="reqn">d</code>.
The drag term makes this a location family of distributions, and 
by default we assume it is zero.
</p>
<p>The parameters are encoded as follows:
</p>

<ul>
<li> <p><code class="reqn">q</code> is denoted by <code>df1</code>.
</p>
</li>
<li> <p><code class="reqn">n</code> is denoted by <code>df2</code>.
</p>
</li>
<li> <p><code class="reqn">\zeta_*</code> is denoted by <code>zeta.s</code>.
</p>
</li>
<li> <p><code class="reqn">d</code> is denoted by <code>ope</code>.
</p>
</li>
<li> <p><code class="reqn">c_0/R</code> is denoted by <code>drag</code>.
</p>
</li></ul>



<h3>Spanning and Hedging</h3>

<p>As above, let 
</p>
<p style="text-align: center;"><code class="reqn">Z(w) = \frac{w^{\top}\bar{x} - c_0}{\sqrt{w^{\top}S w}}</code>
</p>

<p>be the (sample) Sharpe ratio of the portfolio <code class="reqn">w</code>, subject to 
risk free rate <code class="reqn">c_0</code>.
</p>
<p>Let <code class="reqn">G</code> be a <code class="reqn">g \times q</code> matrix of 'hedge constraints'. 
Let <code class="reqn">w_*</code> be the solution to the portfolio optimization problem:
</p>
<p style="text-align: center;"><code class="reqn">\max_{w: 0 &lt; w^{\top}S w \le R^2,\,G S w = 0} Z(w),</code>
</p>

<p>with maximum value <code class="reqn">z_* = Z\left(w_*\right)</code>.
Then <code class="reqn">z_*^2</code> can be expressed as the difference of two squared
optimal Sharpe ratio random variables. A monotonic transform takes this
difference to the LRT statistic for portfolio spanning, first described by
Rao, and refined by Giri.
</p>


<h3>Legal Mumbo Jumbo</h3>

<p>SharpeR is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.
</p>


<h3>Note</h3>

<p>The following are still in the works:
</p>

<ol>
<li><p> Corrections for standard error based on skew, kurtosis and
autocorrelation.
</p>
</li>
<li><p> Tests on Sharpe under positivity constraint. (<em>c.f.</em> Silvapulle)
</p>
</li>
<li><p> Portfolio spanning tests.
</p>
</li>
<li><p> Tests on portfolio weights.
</p>
</li></ol>

<p>This package is maintained as a hobby.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Sharpe, William F. &quot;Mutual fund performance.&quot; Journal of business (1966): 119-138.
<a href="https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html">https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html</a>
</p>
<p>Johnson, N. L., and Welch, B. L. &quot;Applications of the non-central t-distribution.&quot;
Biometrika 31, no. 3-4 (1940): 362-389. doi: <a href="https://doi.org/10.1093/biomet/31.3-4.362">10.1093/biomet/31.3-4.362</a>
</p>
<p>Lo, Andrew W. &quot;The statistics of Sharpe ratios.&quot; Financial Analysts Journal 58, no. 4 
(2002): 36-52. <a href="https://www.ssrn.com/paper=377260">https://www.ssrn.com/paper=377260</a>
</p>
<p>Opdyke, J. D. &quot;Comparing Sharpe Ratios: So Where are the p-values?&quot; Journal of Asset
Management 8, no. 5 (2006): 308-336. <a href="https://www.ssrn.com/paper=886728">https://www.ssrn.com/paper=886728</a>
</p>
<p>Ledoit, O., and Wolf, M. &quot;Robust performance hypothesis testing with the 
Sharpe ratio.&quot; Journal of Empirical Finance 15, no. 5 (2008): 850-859.
doi: <a href="https://doi.org/10.1016/j.jempfin.2008.03.002">10.1016/j.jempfin.2008.03.002</a>
</p>
<p>Giri, N. &quot;On the likelihood ratio test of a normal multivariate testing problem.&quot;
Annals of Mathematical Statistics 35, no. 1 (1964): 181-189. 
doi: <a href="https://doi.org/10.1214/aoms/1177703740">10.1214/aoms/1177703740</a>
</p>
<p>Rao, C. R. &quot;Advanced Statistical Methods in Biometric Research.&quot; Wiley
(1952).
</p>
<p>Rao, C. R. &quot;On Some Problems Arising out of Discrimination with Multiple 
Characters.&quot; Sankhya, 9, no. 4 (1949): 343-366.
<a href="https://www.jstor.org/stable/25047988">https://www.jstor.org/stable/25047988</a>
</p>
<p>Kan, Raymond and Smith, Daniel R. &quot;The Distribution of the Sample Minimum-Variance Frontier.&quot;
Journal of Management Science 54, no. 7 (2008): 1364&ndash;1380.
doi: <a href="https://doi.org/10.1287/mnsc.1070.0852">10.1287/mnsc.1070.0852</a>
</p>
<p>Kan, Raymond and Zhou, GuoFu. &quot;Tests of Mean-Variance Spanning.&quot;
Annals of Economics and Finance 13, no. 1 (2012)
<a href="https://econpapers.repec.org/article/cufjournl/y_3a2012_3av_3a13_3ai_3a1_3akanzhou.htm">https://econpapers.repec.org/article/cufjournl/y_3a2012_3av_3a13_3ai_3a1_3akanzhou.htm</a>
</p>
<p>Britten-Jones, Mark. &quot;The Sampling Error in Estimates of Mean-Variance 
Efficient Portfolio Weights.&quot; The Journal of Finance 54, no. 2 (1999):
655&ndash;671. <a href="https://www.jstor.org/stable/2697722">https://www.jstor.org/stable/2697722</a>
</p>
<p>Silvapulle, Mervyn. J. &quot;A Hotelling's T2-type statistic for testing against 
one-sided hypotheses.&quot; Journal of Multivariate Analysis 55, no. 2 (1995):
312&ndash;319. doi: <a href="https://doi.org/10.1006/jmva.1995.1081">10.1006/jmva.1995.1081</a>
</p>
<p>Bodnar, Taras and Okhrin, Yarema. &quot;On the Product of Inverse Wishart
and Normal Distributions with Applications to Discriminant Analysis 
and Portfolio Theory.&quot; Scandinavian Journal of Statistics 38, no. 2 (2011):
311&ndash;331. doi: <a href="https://doi.org/10.1111/j.1467-9469.2011.00729.x">10.1111/j.1467-9469.2011.00729.x</a>
</p>

<hr>
<h2 id='sm_vcov'>Compute variance covariance of 'Unified' Second Moment</h2><span id='topic+sm_vcov'></span>

<h3>Description</h3>

<p>Computes the variance covariance matrix of sample mean and second moment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm_vcov(X,vcov.func=vcov,fit.intercept=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sm_vcov_+3A_x">X</code></td>
<td>
<p>an <code class="reqn">n \times p</code> matrix of observed returns.</p>
</td></tr>
<tr><td><code id="sm_vcov_+3A_vcov.func">vcov.func</code></td>
<td>
<p>a function which takes an object of class <code>lm</code>,
and computes a variance-covariance matrix. If equal to the string
&quot;normal&quot;, we assume multivariate normal returns.</p>
</td></tr>
<tr><td><code id="sm_vcov_+3A_fit.intercept">fit.intercept</code></td>
<td>
<p>a boolean controlling whether we add a column
of ones to the data, or fit the raw uncentered second moment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">p</code>-vector <code class="reqn">x</code>, the 'unified' sample is the 
<code class="reqn">p(p+3)/2</code> vector of <code class="reqn">x</code> stacked on top 
of <code class="reqn">\mbox{vech}(x x^{\top})</code>. 
Given <code class="reqn">n</code> contemporaneous observations of <code class="reqn">p</code>-vectors,
stacked as rows in the <code class="reqn">n \times p</code> matrix <code class="reqn">X</code>,
this function computes the mean and the variance-covariance
matrix of the 'unified' sample. 
</p>
<p>One may use the default method for computing covariance,
via the <code><a href="stats.html#topic+vcov">vcov</a></code> function, or via a 'fancy' estimator,
like <code>sandwich:vcovHAC</code>, <code>sandwich:vcovHC</code>, <em>etc.</em>
</p>


<h3>Value</h3>

<p>a list containing the following components:
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>a <code class="reqn">q = p(p+3)/2</code> vector of the mean, then the vech'd second
moment of the sample data</p>
</td></tr>
<tr><td><code>Ohat</code></td>
<td>
<p>the <code class="reqn">q \times q</code> estimated variance covariance 
matrix. Only the informative part is returned: one may assume a row and
column of zeros in the upper left.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of rows in <code>X</code>.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the number of assets.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function will be deprecated in future releases of this package.
Users should migrate at that time to a similar function in the
MarkowitzR package.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Pav, S. E. &quot;Asymptotic Distribution of the Markowitz Portfolio.&quot;
2013 <a href="https://arxiv.org/abs/1312.0557">https://arxiv.org/abs/1312.0557</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ism_vcov">ism_vcov</a></code>, <code><a href="#topic+sr_vcov">sr_vcov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(1000*3),ncol=3)
Sigmas &lt;- sm_vcov(X)
Sigmas.n &lt;- sm_vcov(X,vcov.func="normal")
Sigmas.n &lt;- sm_vcov(X,fit.intercept=FALSE)

# make it fat tailed:
X &lt;- matrix(rt(1000*3,df=5),ncol=3)
Sigmas &lt;- sm_vcov(X)

if (require(sandwich)) {
 Sigmas &lt;- sm_vcov(X,vcov.func=vcovHC)
}

# add some autocorrelation to X
Xf &lt;- filter(X,c(0.2),"recursive")
colnames(Xf) &lt;- colnames(X)
Sigmas &lt;- sm_vcov(Xf)

if (require(sandwich)) {
Sigmas &lt;- sm_vcov(Xf,vcov.func=vcovHAC)
}


</code></pre>

<hr>
<h2 id='sr'>Create an 'sr' object.</h2><span id='topic+sr'></span>

<h3>Description</h3>

<p>Spawns an object of class <code>sr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sr(
  sr,
  df,
  c0 = 0,
  ope = 1,
  rescal = sqrt(1/(df + 1)),
  epoch = "yr",
  cumulants = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sr_+3A_sr">sr</code></td>
<td>
<p>a Sharpe ratio statistic.</p>
</td></tr>
<tr><td><code id="sr_+3A_df">df</code></td>
<td>
<p>the degrees of freedom of the equivalent t-statistic.</p>
</td></tr>
<tr><td><code id="sr_+3A_c0">c0</code></td>
<td>
<p>the 'risk-free' or 'disastrous' rate of return. this is
assumed to be given in the same units as x, <em>not</em>
in 'annualized' terms.</p>
</td></tr>
<tr><td><code id="sr_+3A_ope">ope</code></td>
<td>
<p>the number of observations per 'epoch'. For convenience of
interpretation, The Sharpe ratio is typically quoted in 'annualized' 
units for some epoch, that is, 'per square root epoch', though returns 
are observed at a frequency of <code>ope</code> per epoch. 
The default value is 1, meaning the code will not attempt to guess
what the observation frequency is, and no annualization adjustments
will be made.</p>
</td></tr>
<tr><td><code id="sr_+3A_rescal">rescal</code></td>
<td>
<p>the rescaling parameter.</p>
</td></tr>
<tr><td><code id="sr_+3A_epoch">epoch</code></td>
<td>
<p>the string representation of the 'epoch', defaulting
to 'yr'.</p>
</td></tr>
<tr><td><code id="sr_+3A_cumulants">cumulants</code></td>
<td>
<p>an optional array of the higher order cumulants
of the returns distribution. The first element shall
be the skew; the second the excess kurtosis. Up to the
sixth cumulant can be given.  Higher order
approximations for the moments of the Sharpe ratio can be
computed based on these cumulants.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>sr</code> class contains information about a rescaled t-statistic.
The following are list attributes of the object:
</p>

<dl>
<dt>sr</dt><dd><p>The Sharpe ratio statistic.</p>
</dd>
<dt>df</dt><dd><p>The d.f. of the equivalent t-statistic.</p>
</dd>
<dt>c0</dt><dd><p>The drag 'risk free rate' used.</p>
</dd>
<dt>ope</dt><dd><p>The 'observations per epoch'.</p>
</dd>
<dt>rescal</dt><dd><p>The rescaling parameter.</p>
</dd>
<dt>epoch</dt><dd><p>The string name of the 'epoch'.</p>
</dd>
</dl>

<p>The stored Sharpe statistic, <code>sr</code> is equal to the t-statistic 
times <code class="reqn">rescal * sqrt{ope}</code>.
</p>
<p>For the most part, this constructor should <em>not</em> be called directly,
rather <code><a href="#topic+as.sr">as.sr</a></code> should be called instead to compute the
Sharpe ratio.
</p>


<h3>Value</h3>

<p>a list cast to class <code>sr</code>.
</p>


<h3>Note</h3>

<p>2FIX: allow rownames?
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Sharpe, William F. &quot;Mutual fund performance.&quot; Journal of business (1966): 119-138.
<a href="https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html">https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reannualize">reannualize</a></code>
</p>
<p><code><a href="#topic+as.sr">as.sr</a></code>
</p>
<p>Other sr: 
<code><a href="#topic+as.sr">as.sr</a>()</code>,
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+dsr">dsr</a>()</code>,
<code><a href="#topic+is.sr">is.sr</a>()</code>,
<code><a href="#topic+plambdap">plambdap</a>()</code>,
<code><a href="#topic+power.sr_test">power.sr_test</a>()</code>,
<code><a href="#topic+predint">predint</a>()</code>,
<code><a href="#topic+print.sr">print.sr</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+se">se</a>()</code>,
<code><a href="#topic+sr_equality_test">sr_equality_test</a>()</code>,
<code><a href="#topic+sr_test">sr_test</a>()</code>,
<code><a href="#topic+sr_unpaired_test">sr_unpaired_test</a>()</code>,
<code><a href="#topic+sr_vcov">sr_vcov</a>()</code>,
<code><a href="#topic+summary.sr">summary.sr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># roll your own.
ope &lt;- 253
zeta &lt;- 1.0
n &lt;- 3 * ope
rvs &lt;- rsr(1,n,zeta,ope=ope)
roll.own &lt;- sr(sr=rvs,df=n-1,ope=ope,rescal=sqrt(1/n))
# put a bunch in. naming becomes a problem.
rvs &lt;- rsr(5,n,zeta,ope=ope)
roll.own &lt;- sr(sr=rvs,df=n-1,ope=ope,rescal=sqrt(1/n))

</code></pre>

<hr>
<h2 id='sr_bias'>sr_bias .</h2><span id='topic+sr_bias'></span>

<h3>Description</h3>

<p>Computes the asymptotic bias of the sample Sharpe ratio based on moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sr_bias(snr, n, cumulants, type = c("simple", "second_order"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sr_bias_+3A_snr">snr</code></td>
<td>
<p>the population Signal Noise ratio. Often one will use
the population estimate instead.</p>
</td></tr>
<tr><td><code id="sr_bias_+3A_n">n</code></td>
<td>
<p>the sample size that the Shapre ratio is observed on.</p>
</td></tr>
<tr><td><code id="sr_bias_+3A_cumulants">cumulants</code></td>
<td>
<p>a vector of the third through fourth, or the third
through seventh population cumulants of the random variable.
More terms are needed for the higher accuracy approximation.</p>
</td></tr>
<tr><td><code id="sr_bias_+3A_type">type</code></td>
<td>
<p>determines the order of accuracy of the bias approximation.
Takes values of
</p>

<dl>
<dt>simple</dt><dd><p>We compute the simple approximation using only the skewness
and excess kurtosis.</p>
</dd>
<dt>second_order</dt><dd><p>We compute the more accurate approximation, given by
Bao, which is accurate to <code class="reqn">o\left(n^{-2}\right)</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The sample Sharpe ratio has bias of the form
</p>
<p style="text-align: center;"><code class="reqn">B = \left(\frac{3}{4n} + 3 \frac{\gamma_2}{8n}\right) \zeta - 
\frac{1}{2n} \gamma_1 + o\left(n^{-3/2}\right),</code>
</p>

<p>where <code class="reqn">\zeta</code> is the population Signal Noise ratio, 
<code class="reqn">n</code> is the sample size, <code class="reqn">\gamma_1</code> is the population skewness,
and <code class="reqn">\gamma_2</code> is the population excess kurtosis.
This form of the bias appears as Equation (5) in Bao, which
claims an accuracy of only <code class="reqn">o\left(n^{-1}\right)</code>. The
author believes this approximation is slightly more accurate.
</p>
<p>A more accurate form is given by Bao (Equation (3)) as 
</p>
<p style="text-align: center;"><code class="reqn">B = \frac{3\zeta}{4n}\zeta + \frac{49\zeta}{32n^2} - \gamma_1 \left(\frac{1}{2n} + \frac{3}{8n^2}\right) + \gamma_2 \zeta
\left(\frac{3}{8n} - \frac{15}{32n^2}\right) + \frac{3\gamma_3}{8n^2} - \frac{5\gamma_4 \zeta}{16n^2} - \frac{5\gamma_1^2\zeta}{4n^2}
+ \frac{105\gamma_2^2 \zeta}{128 n^2} - \frac{15 \gamma_1 \gamma_2}{16n^2} + o\left(n^{-2}\right),</code>
</p>

<p>where <code class="reqn">\gamma_3</code> through <code class="reqn">\gamma_5</code> are the fifth through
seventh cumulants of the error term.
</p>
<p>See &lsquo;The Sharpe Ratio: Statistics and Applications&rsquo;,
section 3.2.3.
</p>


<h3>Value</h3>

<p>the approximate bias of the Sharpe ratio. The bias is the
expected value of the sample Sharpe minus the Signal Noise ratio.
</p>


<h3>Note</h3>

<p>much of the code is adapted from Gauss code provided by Yong Bao.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Bao, Yong. &quot;Estimation Risk-Adjusted Sharpe Ratio and Fund Performance Ranking 
Under a General Return Distribution.&quot; Journal of Financial Econometrics 7, 
no. 2 (2009): 152-173. doi: <a href="https://doi.org/10.1093/jjfinec/nbn022">10.1093/jjfinec/nbn022</a>
</p>
<p>Pav, S. E. &quot;The Sharpe Ratio: Statistics and Applications.&quot; CRC Press, 2021.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sr_variance">sr_variance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# bias under normality:
sr_bias(1, 100, rep(0,2), type='simple')
sr_bias(1, 100, rep(0,5), type='second_order')

# plugging in sample estimates
x &lt;- rnorm(1000)
n &lt;- length(x)
mu &lt;- mean(x)
sdv &lt;- sd(x)
snr &lt;- mu / sdv
# these are not great estimates, but close enough:
sku &lt;- mean((x-mu)^3) / sdv^3
kur &lt;- (mean((x-mu)^4) / sdv^4) - 4
sr_bias(snr, n, c(sku,kur), type='simple')

</code></pre>

<hr>
<h2 id='sr_equality_test'>Paired test for equality of Sharpe ratio</h2><span id='topic+sr_equality_test'></span>

<h3>Description</h3>

<p>Performs a hypothesis test of equality of Sharpe ratios of p assets
given paired observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sr_equality_test(X,type=c("chisq","F","t"),
                 alternative=c("two.sided","less","greater"),
                 contrasts=NULL,
                 vcov.func=vcov)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sr_equality_test_+3A_x">X</code></td>
<td>
<p>an <code class="reqn">n \times p</code> matrix of paired observations.</p>
</td></tr>
<tr><td><code id="sr_equality_test_+3A_type">type</code></td>
<td>
<p>which approximation to use. <code>"chisq"</code> is preferred when
the returns are non-normal, but the approximation is asymptotic.
the <code>"t"</code> test is only supported when <code class="reqn">k = 1</code>.</p>
</td></tr>
<tr><td><code id="sr_equality_test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must be one of <code>"two.sided"</code> (default), <code>"greater"</code> or
<code>"less"</code>. You can specify just the initial letter.
This is only relevant for the <code>"t"</code> test.
<code>"greater"</code> corresponds to <code class="reqn">H_a: E s &gt; 0</code>.</p>
</td></tr>
<tr><td><code id="sr_equality_test_+3A_contrasts">contrasts</code></td>
<td>
<p>an <code class="reqn">k \times p</code> matrix of the contrasts</p>
</td></tr>
<tr><td><code id="sr_equality_test_+3A_vcov.func">vcov.func</code></td>
<td>
<p>a function which takes a model of class lm (one of
the form x ~ 1), and produces a variance-covariance matrix.
The default is <code><a href="stats.html#topic+vcov">vcov</a></code>, which produces a 'vanilla'
estimate of covariance. Other sensible options are
<code>vcovHAC</code> from the <code>sandwich</code> package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">n</code> <em>i.i.d.</em> observations of the excess returns of
<code class="reqn">p</code> strategies, we test
</p>
<p style="text-align: center;"><code class="reqn">H_0: \frac{\mu_i}{\sigma_i} = \frac{\mu_j}{\sigma_j}, 1 \le i &lt; j \le p</code>
</p>

<p>using the method of Wright, et. al. 
</p>
<p>More generally, a matrix of constrasts, <code class="reqn">E</code> can be given, and we can
test
</p>
<p style="text-align: center;"><code class="reqn">H_0: E s = 0,</code>
</p>

<p>where <code class="reqn">s</code> is the vector of Sharpe ratios of the <code class="reqn">p</code> strategies.
</p>
<p>When <code class="reqn">E</code> consists of a single row (a single contrast), as is the
case when the default contrasts are used and only two strategies are
compared, then an approximate t-test can be performed against the
alternative hypothesis <code class="reqn">H_a: E s &gt; 0</code>
</p>
<p>Both chi-squared and F- approximations are supported; the former is
described by Wright. <em>et. al.</em>, the latter by Leung and Wong.
</p>
<p>See &lsquo;The Sharpe Ratio: Statistics and Applications&rsquo;,
section 3.3.1.
</p>


<h3>Value</h3>

<p>Object of class <code>htest</code>, a list of the test statistic,
the size of <code>X</code>, and the <code>method</code> noted.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Sharpe, William F. &quot;Mutual fund performance.&quot; Journal of business (1966): 119-138.
<a href="https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html">https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html</a>
</p>
<p>Wright, J. A., Yam, S. C. P., and Yung, S. P. &quot;A note on the test for the
equality of multiple Sharpe ratios and its application on the evaluation
of iShares.&quot; J. Risk. to appear. 
<a href="https://www.risk.net/journal-risk/2340067/test-equality-multiple-sharpe-ratios">https://www.risk.net/journal-risk/2340067/test-equality-multiple-sharpe-ratios</a>
</p>
<p>Leung, P.-L., and Wong, W.-K. &quot;On testing the equality of multiple Sharpe ratios, with 
application on the evaluation of iShares.&quot; J. Risk 10, no. 3 (2008): 15&ndash;30.
<a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=907270">https://papers.ssrn.com/sol3/papers.cfm?abstract_id=907270</a>
</p>
<p>Memmel, C. &quot;Performance hypothesis testing with the Sharpe ratio.&quot; Finance
Letters 1 (2003): 21&ndash;23.
</p>
<p>Ledoit, O., and Wolf, M. &quot;Robust performance hypothesis testing with the 
Sharpe ratio.&quot; Journal of Empirical Finance 15, no. 5 (2008): 850-859.
doi: <a href="https://doi.org/10.1016/j.jempfin.2008.03.002">10.1016/j.jempfin.2008.03.002</a>
</p>
<p>Lo, Andrew W. &quot;The statistics of Sharpe ratios.&quot; Financial Analysts Journal 58, no. 4 
(2002): 36-52. <a href="https://www.ssrn.com/paper=377260">https://www.ssrn.com/paper=377260</a>
</p>
<p>Pav, S. E. &quot;The Sharpe Ratio: Statistics and Applications.&quot; CRC Press, 2021.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sr_test">sr_test</a></code>
</p>
<p>Other sr: 
<code><a href="#topic+as.sr">as.sr</a>()</code>,
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+dsr">dsr</a>()</code>,
<code><a href="#topic+is.sr">is.sr</a>()</code>,
<code><a href="#topic+plambdap">plambdap</a>()</code>,
<code><a href="#topic+power.sr_test">power.sr_test</a>()</code>,
<code><a href="#topic+predint">predint</a>()</code>,
<code><a href="#topic+print.sr">print.sr</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+se">se</a>()</code>,
<code><a href="#topic+sr_test">sr_test</a>()</code>,
<code><a href="#topic+sr_unpaired_test">sr_unpaired_test</a>()</code>,
<code><a href="#topic+sr_vcov">sr_vcov</a>()</code>,
<code><a href="#topic+sr">sr</a></code>,
<code><a href="#topic+summary.sr">summary.sr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># under the null 
set.seed(1234)
rv &lt;- sr_equality_test(matrix(rnorm(500*5),ncol=5))

# under the alternative (but with identity covariance)
ope &lt;- 253
nyr &lt;- 10
nco &lt;- 5
set.seed(909)
rets &lt;- 0.01 * sapply(seq(0,1.7/sqrt(ope),length.out=nco),
  function(mu) { rnorm(ope*nyr,mean=mu,sd=1) })
rv &lt;- sr_equality_test(rets)

# using real data
if (require(xts)) {
 data(stock_returns)
 pvs &lt;- sr_equality_test(stock_returns)
}

# test for uniformity
pvs &lt;- replicate(1024,{ x &lt;- sr_equality_test(matrix(rnorm(400*5),400,5),type="chisq")
                       x$p.value })
plot(ecdf(pvs))
abline(0,1,col='red') 


if (require(sandwich)) {
  set.seed(as.integer(charToRaw("0b2fd4e9-3bdf-4e3e-9c75-25c6d18c331f")))
  n.manifest &lt;- 10
  n.latent &lt;- 4
  n.day &lt;- 1024
  snr &lt;- 0.95
  la_A &lt;- matrix(rnorm(n.day*n.latent),ncol=n.latent)
  la_B &lt;- matrix(runif(n.latent*n.manifest),ncol=n.manifest)
  latent.rets &lt;- la_A %*% la_B
  noise.rets &lt;- matrix(rnorm(n.day*n.manifest),ncol=n.manifest)
  some.rets &lt;- snr * latent.rets + sqrt(1-snr^2) * noise.rets
  # naive vcov
  pvs0 &lt;- sr_equality_test(some.rets)
  # HAC vcov
  pvs1 &lt;- sr_equality_test(some.rets,vcov.func=vcovHAC)
  # more elaborately:
  pvs &lt;- sr_equality_test(some.rets,vcov.func=function(amod) {
	vcovHAC(amod,prewhite=TRUE) })
}


</code></pre>

<hr>
<h2 id='sr_test'>test for Sharpe ratio</h2><span id='topic+sr_test'></span>

<h3>Description</h3>

<p>Performs one and two sample tests of Sharpe ratio on vectors of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sr_test(
  x,
  y = NULL,
  alternative = c("two.sided", "less", "greater"),
  zeta = 0,
  ope = 1,
  paired = FALSE,
  conf.level = 0.95,
  type = c("exact", "t", "Z", "Mertens", "Bao"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sr_test_+3A_x">x</code></td>
<td>
<p>a (non-empty) numeric vector of data values, or an
object of class <code>sr</code>, containing a scalar sample Sharpe estimate.</p>
</td></tr>
<tr><td><code id="sr_test_+3A_y">y</code></td>
<td>
<p>an optional (non-empty) numeric vector of data values, or
an object of class <code>sr</code>, containing a scalar sample Sharpe estimate.
Only an unpaired test can be performed when at least one of <code>x</code> and <code>y</code> are
of class <code>sr</code></p>
</td></tr>
<tr><td><code id="sr_test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must be one of <code>"two.sided"</code> (default), <code>"greater"</code> or
<code>"less"</code>.  You can specify just the initial letter.</p>
</td></tr>
<tr><td><code id="sr_test_+3A_zeta">zeta</code></td>
<td>
<p>a number indicating the null hypothesis offset value, the
<code class="reqn">S</code> value.</p>
</td></tr>
<tr><td><code id="sr_test_+3A_ope">ope</code></td>
<td>
<p>the number of observations per 'epoch'. For convenience of
interpretation, The Sharpe ratio is typically quoted in 'annualized' 
units for some epoch, that is, 'per square root epoch', though returns 
are observed at a frequency of <code>ope</code> per epoch. 
The default value is 1, meaning the code will not attempt to guess
what the observation frequency is, and no annualization adjustments
will be made.</p>
</td></tr>
<tr><td><code id="sr_test_+3A_paired">paired</code></td>
<td>
<p>a logical indicating whether you want a paired test.</p>
</td></tr>
<tr><td><code id="sr_test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval.</p>
</td></tr>
<tr><td><code id="sr_test_+3A_type">type</code></td>
<td>
<p>which method to apply.</p>
</td></tr>
<tr><td><code id="sr_test_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">n</code> observations <code class="reqn">x_i</code> from a normal random variable,
with mean <code class="reqn">\mu</code> and standard deviation <code class="reqn">\sigma</code>, tests
</p>
<p style="text-align: center;"><code class="reqn">H_0: \frac{\mu}{\sigma} = S</code>
</p>

<p>against two or one sided alternatives.
</p>
<p>Can also perform two sample tests of Sharpe ratio. For paired observations
<code class="reqn">x_i</code> and <code class="reqn">y_i</code>, tests
</p>
<p style="text-align: center;"><code class="reqn">H_0: \frac{\mu_x}{\sigma_x} = \frac{\mu_u}{\sigma_y}</code>
</p>

<p>against two or one sided alternative, via 
<code><a href="#topic+sr_equality_test">sr_equality_test</a></code>.
</p>
<p>For unpaired (and independent) observations, tests
</p>
<p style="text-align: center;"><code class="reqn">H_0: \frac{\mu_x}{\sigma_x} - \frac{\mu_u}{\sigma_y} = S</code>
</p>

<p>against two or one-sided alternatives via an asymptotic
approximation.
</p>
<p>The one sample test admits a number of different methods:
</p>

<dl>
<dt>exact</dt><dd><p>The default, which is only exact when returns are
normal, based on inverting the non-central t distribution.</p>
</dd>
<dt>t</dt><dd><p>Uses the Johnson Welch approximation to the standard error, 
centered around the sample value.</p>
</dd>
<dt>Z</dt><dd><p>Uses the Johnson Welch approximation to the standard error,
performing a simple correction for the bias of the Sharpe ratio based on 
Miller and Gehr formula.</p>
</dd>
<dt>Mertens</dt><dd><p>Uses the Mertens higher order approximation to the standard
error, centered around the sample value.</p>
</dd>
<dt>Bao</dt><dd><p>Uses the Bao higher order approximation to the standard error,
performing a higher order correction for the bias of the Sharpe ratio.</p>
</dd>
</dl>

<p>See <code><a href="#topic+confint.sr">confint.sr</a></code> for more information on these types
</p>
<p>See &lsquo;The Sharpe Ratio: Statistics and Applications&rsquo;,
section 3.2.1, 3.2.2, and 3.3.1.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the t- or Z-statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>a confidence interval appropriate to the specified alternative hypothesis. NYI for some cases.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated Sharpe or difference in Sharpes depending on whether it was a one-sample test or a two-sample test. Annualized</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified hypothesized value of the Sharpe or difference of Sharpes depending on whether it was a one-sample test or a two-sample test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Sharpe, William F. &quot;Mutual fund performance.&quot; Journal of business (1966): 119-138.
<a href="https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html">https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html</a>
</p>
<p>Pav, S. E. &quot;The Sharpe Ratio: Statistics and Applications.&quot; CRC Press, 2021.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reannualize">reannualize</a></code>
</p>
<p><code><a href="#topic+sr_equality_test">sr_equality_test</a></code>, <code><a href="#topic+sr_unpaired_test">sr_unpaired_test</a></code>, <code><a href="stats.html#topic+t.test">t.test</a></code>.
</p>
<p>Other sr: 
<code><a href="#topic+as.sr">as.sr</a>()</code>,
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+dsr">dsr</a>()</code>,
<code><a href="#topic+is.sr">is.sr</a>()</code>,
<code><a href="#topic+plambdap">plambdap</a>()</code>,
<code><a href="#topic+power.sr_test">power.sr_test</a>()</code>,
<code><a href="#topic+predint">predint</a>()</code>,
<code><a href="#topic+print.sr">print.sr</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+se">se</a>()</code>,
<code><a href="#topic+sr_equality_test">sr_equality_test</a>()</code>,
<code><a href="#topic+sr_unpaired_test">sr_unpaired_test</a>()</code>,
<code><a href="#topic+sr_vcov">sr_vcov</a>()</code>,
<code><a href="#topic+sr">sr</a></code>,
<code><a href="#topic+summary.sr">summary.sr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># should reject null
x &lt;- sr_test(rnorm(1000,mean=0.5,sd=0.1),zeta=2,ope=1,alternative="greater")
x &lt;- sr_test(rnorm(1000,mean=0.5,sd=0.1),zeta=2,ope=1,alternative="two.sided")
# should not reject null
x &lt;- sr_test(rnorm(1000,mean=0.5,sd=0.1),zeta=2,ope=1,alternative="less")

# test for uniformity
pvs &lt;- replicate(128,{ x &lt;- sr_test(rnorm(1000),ope=253,alternative="two.sided")
                        x$p.value })
plot(ecdf(pvs))
abline(0,1,col='red') 
# testing an object of class sr
asr &lt;- as.sr(rnorm(1000,1 / sqrt(253)),ope=253)
checkit &lt;- sr_test(asr,zeta=0)

</code></pre>

<hr>
<h2 id='sr_unpaired_test'>test for equation on unpaired Sharpe ratios</h2><span id='topic+sr_unpaired_test'></span>

<h3>Description</h3>

<p>Performs hypothesis tests on a single equation on k independent samples of Sharpe ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sr_unpaired_test(
  srs,
  contrasts = NULL,
  null.value = 0,
  alternative = c("two.sided", "less", "greater"),
  ope = NULL,
  conf.level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sr_unpaired_test_+3A_srs">srs</code></td>
<td>
<p>a (non-empty) list of objects of class <code>sr</code>, each containing
a scalar sample Sharpe estimate. Or a single object of class <code>sr</code> with
multiple Sharpe estimates. If the <code>sr</code> objects have different
annualizations (<code>ope</code> parameters), a warning is thrown, since
it is presumed that the contrasts all have the same units, but the
test proceeds.</p>
</td></tr>
<tr><td><code id="sr_unpaired_test_+3A_contrasts">contrasts</code></td>
<td>
<p>an array of the constrasts, the <code class="reqn">a_j</code> values.
Defaults to <code>c(1,-1,1,...)</code>.</p>
</td></tr>
<tr><td><code id="sr_unpaired_test_+3A_null.value">null.value</code></td>
<td>
<p>the constant null value, the <code class="reqn">b</code>.
Defaults to 0.</p>
</td></tr>
<tr><td><code id="sr_unpaired_test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must be one of <code>"two.sided"</code> (default), <code>"greater"</code> or
<code>"less"</code>.  You can specify just the initial letter.</p>
</td></tr>
<tr><td><code id="sr_unpaired_test_+3A_ope">ope</code></td>
<td>
<p>the number of observations per 'epoch'. For convenience of
interpretation, The Sharpe ratio is typically quoted in 'annualized' 
units for some epoch, that is, 'per square root epoch', though returns 
are observed at a frequency of <code>ope</code> per epoch. 
The default value is to take the same <code>ope</code> from the input <code>srs</code>
object, if it is unambiguous. Otherwise, it defaults to 1, with a warning
thrown.</p>
</td></tr>
<tr><td><code id="sr_unpaired_test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code class="reqn">1 \le j \le k</code>, suppose you have <code class="reqn">n_j</code>
observations of a normal random variable with mean <code class="reqn">\mu_j</code> and
standard deviation <code class="reqn">\sigma_j</code>, with all observations
independent. Given constants <code class="reqn">a_j</code> and value <code class="reqn">b</code>, this
code tests the null hypothesis
</p>
<p style="text-align: center;"><code class="reqn">H_0: \sum_j a_j \frac{\mu_j}{\sigma_j} = b</code>
</p>

<p>against two or one sided alternatives.
</p>
<p>See &lsquo;The Sharpe Ratio: Statistics and Applications&rsquo;,
section 3.3.1.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The Wald statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>The degrees of freedom of the Wald statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>a confidence interval appropriate to the specified alternative hypothesis.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated equation value, just the weighted sum of the sample Sharpe ratios. Annualized</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified hypothesized value of the sum of Sharpes.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Sharpe, William F. &quot;Mutual fund performance.&quot; Journal of business (1966): 119-138.
<a href="https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html">https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html</a>
</p>
<p>Pav, S. E. &quot;The Sharpe Ratio: Statistics and Applications.&quot; CRC Press, 2021.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sr_equality_test">sr_equality_test</a></code>, <code><a href="#topic+sr_test">sr_test</a></code>, <code><a href="stats.html#topic+t.test">t.test</a></code>.
</p>
<p>Other sr: 
<code><a href="#topic+as.sr">as.sr</a>()</code>,
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+dsr">dsr</a>()</code>,
<code><a href="#topic+is.sr">is.sr</a>()</code>,
<code><a href="#topic+plambdap">plambdap</a>()</code>,
<code><a href="#topic+power.sr_test">power.sr_test</a>()</code>,
<code><a href="#topic+predint">predint</a>()</code>,
<code><a href="#topic+print.sr">print.sr</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+se">se</a>()</code>,
<code><a href="#topic+sr_equality_test">sr_equality_test</a>()</code>,
<code><a href="#topic+sr_test">sr_test</a>()</code>,
<code><a href="#topic+sr_vcov">sr_vcov</a>()</code>,
<code><a href="#topic+sr">sr</a></code>,
<code><a href="#topic+summary.sr">summary.sr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># basic usage
set.seed(as.integer(charToRaw("set the seed")))
# default contrast is 1,-1,1,-1,1,-1
etc &lt;- sr_unpaired_test(as.sr(matrix(rnorm(1000*6,mean=0.02,sd=0.1),ncol=6)))
print(etc)

etc &lt;- sr_unpaired_test(as.sr(matrix(rnorm(1000*4,mean=0.0005,sd=0.01),ncol=4)),
  alternative='greater')
print(etc)

etc &lt;- sr_unpaired_test(as.sr(matrix(rnorm(1000*4,mean=0.0005,sd=0.01),ncol=4)),
  contrasts=c(1,1,1,1),null.value=-0.1,alternative='greater')
print(etc)

inp &lt;- list(as.sr(rnorm(500)),as.sr(runif(200)-0.5),
            as.sr(rnorm(30)),as.sr(rnorm(100)))
etc &lt;- sr_unpaired_test(inp)

inp &lt;- list(as.sr(rnorm(500)),as.sr(rnorm(100,mean=0.2,sd=1)))
etc &lt;- sr_unpaired_test(inp,contrasts=c(1,1),null.value=0.2)
etc$conf.int

</code></pre>

<hr>
<h2 id='sr_variance'>sr_variance .</h2><span id='topic+sr_variance'></span>

<h3>Description</h3>

<p>Computes the variance of the sample Sharpe ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sr_variance(snr, n, cumulants)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sr_variance_+3A_snr">snr</code></td>
<td>
<p>the population Signal Noise ratio. Often one will use
the population estimate instead.</p>
</td></tr>
<tr><td><code id="sr_variance_+3A_n">n</code></td>
<td>
<p>the sample size that the Shapre ratio is observed on.</p>
</td></tr>
<tr><td><code id="sr_variance_+3A_cumulants">cumulants</code></td>
<td>
<p>a vector of the third through fourth, or the third
through seventh population cumulants of the random variable.
More terms are needed for the higher accuracy approximation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sample Sharpe ratio has variance of the form
</p>
<p style="text-align: center;"><code class="reqn">V = \frac{1}{n}\left(1 + \frac{\zeta^2}{2}\right)
+\frac{1}{n^2}\left(\frac{19\zeta^2}{8} + 2\right)
-\gamma_1\zeta\left(\frac{1}{n} + \frac{5}{2n^2}\right)
+\gamma_2\zeta^2\left(\frac{1}{4n} + \frac{3}{8n^2}\right)
+\frac{5\gamma_3\zeta}{4n^2} 
+\gamma_1^2\left(\frac{7}{4n^2} - \frac{3\zeta^2}{2n^2}\right)
+\frac{39\gamma_2^2\zeta^2}{32n^2} 
-\frac{15\gamma_1\gamma_2\zeta}{4n^2} 
+o\left(n^{-2}\right),</code>
</p>

<p>where <code class="reqn">\zeta</code> is the population Signal Noise ratio, 
<code class="reqn">n</code> is the sample size, <code class="reqn">\gamma_1</code> is the population skewness,
and <code class="reqn">\gamma_2</code> is the population excess kurtosis, and
<code class="reqn">\gamma_3</code> through <code class="reqn">\gamma_5</code> are the fifth through
seventh cumulants of the error term.
This form of the variance appears as Equation (4) in Bao.
</p>
<p>See &lsquo;The Sharpe Ratio: Statistics and Applications&rsquo;,
section 3.2.3.
</p>


<h3>Value</h3>

<p>the variance of the sample statistic.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Bao, Yong. &quot;Estimation Risk-Adjusted Sharpe Ratio and Fund Performance Ranking 
Under a General Return Distribution.&quot; Journal of Financial Econometrics 7, 
no. 2 (2009): 152-173. doi: <a href="https://doi.org/10.1093/jjfinec/nbn022">10.1093/jjfinec/nbn022</a>
</p>
<p>Pav, S. E. &quot;The Sharpe Ratio: Statistics and Applications.&quot; CRC Press, 2021.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sr_bias">sr_bias</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># variance under normality:
sr_variance(1, 100, rep(0,5))
</code></pre>

<hr>
<h2 id='sr_vcov'>Compute variance covariance of Sharpe Ratios.</h2><span id='topic+sr_vcov'></span>

<h3>Description</h3>

<p>Computes the variance covariance matrix of sample Sharpe ratios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sr_vcov(X,vcov.func=vcov,ope=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sr_vcov_+3A_x">X</code></td>
<td>
<p>an <code class="reqn">n \times p</code> matrix of observed returns.
It not a matrix, but a numeric of length <code class="reqn">n</code>, then it is
coerced into a <code class="reqn">n \times 1</code> matrix.</p>
</td></tr>
<tr><td><code id="sr_vcov_+3A_vcov.func">vcov.func</code></td>
<td>
<p>a function which takes an object of class <code>lm</code>,
and computes a variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="sr_vcov_+3A_ope">ope</code></td>
<td>
<p>the number of observations per 'epoch'. For convenience of
interpretation, The Sharpe ratio is typically quoted in 'annualized' 
units for some epoch, that is, 'per square root epoch', though returns 
are observed at a frequency of <code>ope</code> per epoch. 
The default value is 1, meaning the code will not attempt to guess
what the observation frequency is, and no annualization adjustments
will be made.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">n</code> contemporaneous observations of <code class="reqn">p</code> returns
streams, this function estimates the asymptotic variance
covariance matrix of the vector of sample Sharpes, 
<code class="reqn">\left[\zeta_1,\zeta_2,\ldots,\zeta_p\right]</code>
</p>
<p>One may use the default method for computing covariance,
via the <code><a href="stats.html#topic+vcov">vcov</a></code> function, or via a 'fancy' estimator,
like <code>sandwich:vcovHAC</code>, <code>sandwich:vcovHC</code>, <em>etc.</em>
</p>
<p>This code first estimates the covariance of the <code class="reqn">2p</code> vector of 
the vector <code class="reqn">x</code> stacked on its Hadamard square, <code class="reqn">x^2</code>. This is
then translated back to a variance covariance on the vector of
sample Sharpe ratios via the Delta method.
</p>


<h3>Value</h3>

<p>a list containing the following components:
</p>
<table>
<tr><td><code>SR</code></td>
<td>
<p>a vector of (annualized) Sharpe ratios.</p>
</td></tr>
<tr><td><code>Ohat</code></td>
<td>
<p>a <code class="reqn">p \times p</code> variance covariance matrix.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the number of assets.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Sharpe, William F. &quot;Mutual fund performance.&quot; Journal of business (1966): 119-138.
<a href="https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html">https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html</a>
</p>
<p>Lo, Andrew W. &quot;The statistics of Sharpe ratios.&quot; Financial Analysts Journal 58, no. 4 
(2002): 36-52. <a href="https://www.ssrn.com/paper=377260">https://www.ssrn.com/paper=377260</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reannualize">reannualize</a></code>
</p>
<p>sr-distribution functions, <code><a href="#topic+dsr">dsr</a></code>
</p>
<p>Other sr: 
<code><a href="#topic+as.sr">as.sr</a>()</code>,
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+dsr">dsr</a>()</code>,
<code><a href="#topic+is.sr">is.sr</a>()</code>,
<code><a href="#topic+plambdap">plambdap</a>()</code>,
<code><a href="#topic+power.sr_test">power.sr_test</a>()</code>,
<code><a href="#topic+predint">predint</a>()</code>,
<code><a href="#topic+print.sr">print.sr</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+se">se</a>()</code>,
<code><a href="#topic+sr_equality_test">sr_equality_test</a>()</code>,
<code><a href="#topic+sr_test">sr_test</a>()</code>,
<code><a href="#topic+sr_unpaired_test">sr_unpaired_test</a>()</code>,
<code><a href="#topic+sr">sr</a></code>,
<code><a href="#topic+summary.sr">summary.sr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(1000*3),ncol=3)
colnames(X) &lt;- c("ABC","XYZ","WORM")
Sigmas &lt;- sr_vcov(X)
# make it fat tailed:
X &lt;- matrix(rt(1000*3,df=5),ncol=3)
Sigmas &lt;- sr_vcov(X)

if (require(sandwich)) {
Sigmas &lt;- sr_vcov(X,vcov.func=vcovHC)
}

# add some autocorrelation to X
Xf &lt;- filter(X,c(0.2),"recursive")
colnames(Xf) &lt;- colnames(X)
Sigmas &lt;- sr_vcov(Xf)

if (require(sandwich)) {
Sigmas &lt;- sr_vcov(Xf,vcov.func=vcovHAC)
}

# should run for a vector as well
X &lt;- rnorm(1000)
SS &lt;- sr_vcov(X)

</code></pre>

<hr>
<h2 id='sric'>Sharpe Ratio Information Coefficient</h2><span id='topic+sric'></span>

<h3>Description</h3>

<p>Computes the Sharpe Ratio Information Coefficient of
Paulsen and Soehl, an asymptotically unbiased estimate of
the out-of-sample Sharpe of the in-sample Markowitz portfolio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sric(z.s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sric_+3A_z.s">z.s</code></td>
<td>
<p>an object of type <code>sropt</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">X</code> be an observed <code class="reqn">T \times k</code> matrix whose
rows are i.i.d. normal. Let <code class="reqn">\mu</code> and <code class="reqn">\Sigma</code> be
the sample mean and sample covariance. The Markowitz portfolio is
</p>
<p style="text-align: center;"><code class="reqn">w = \Sigma^{-1}\mu,</code>
</p>

<p>which has an in-sample Sharpe of 
<code class="reqn">\zeta = \sqrt{\mu^{\top}\Sigma^{-1}\mu}.</code>
</p>
<p>The <em>Sharpe Ratio Information Criterion</em> is defined as
</p>
<p style="text-align: center;"><code class="reqn">SRIC = \zeta - \frac{k-1}{T\zeta}.</code>
</p>

<p>The expected value (over draws of <code class="reqn">X</code> and of future returns)
of the <code class="reqn">SRIC</code> is equal to the expected value of the out-of-sample
Sharpe of the (in-sample) portfolio <code class="reqn">w</code> (again, over the same draws.)
</p>


<h3>Value</h3>

<p>The Sharpe Ratio Information Coefficient.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Paulsen, D., and Soehl, J. &quot;Noise Fit, Estimation Error, and Sharpe Information Criterion.&quot;
arxiv preprint (2016): <a href="https://arxiv.org/abs/1602.06186">https://arxiv.org/abs/1602.06186</a>
</p>


<h3>See Also</h3>

<p>Other sropt Hotelling: 
<code><a href="#topic+inference">inference</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate some sropts
nfac &lt;- 3
nyr &lt;- 5
ope &lt;- 253
# simulations with no covariance structure.
# under the null:
set.seed(as.integer(charToRaw("fix seed")))
Returns &lt;- matrix(rnorm(ope*nyr*nfac,mean=0,sd=0.0125),ncol=nfac)
asro &lt;- as.sropt(Returns,drag=0,ope=ope)
srv &lt;- sric(asro)

</code></pre>

<hr>
<h2 id='sropt'>Create an 'sropt' object.</h2><span id='topic+sropt'></span>

<h3>Description</h3>

<p>Spawns an object of class <code>sropt</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sropt(z.s, df1, df2, drag = 0, ope = 1, epoch = "yr", T2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sropt_+3A_z.s">z.s</code></td>
<td>
<p>an optimum Sharpe ratio statistic.</p>
</td></tr>
<tr><td><code id="sropt_+3A_df1">df1</code></td>
<td>
<p>the number of assets in the portfolio.</p>
</td></tr>
<tr><td><code id="sropt_+3A_df2">df2</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code id="sropt_+3A_drag">drag</code></td>
<td>
<p>the 'drag' term, <code class="reqn">c_0/R</code>. defaults to 0. It is assumed
that <code>drag</code> has been annualized, <em>i.e.</em> has been multiplied
by <code class="reqn">\sqrt{ope}</code>. This is in contrast to the <code>c0</code>
term given to <code><a href="#topic+sr">sr</a></code>.</p>
</td></tr>
<tr><td><code id="sropt_+3A_ope">ope</code></td>
<td>
<p>the number of observations per 'epoch'. For convenience of
interpretation, The Sharpe ratio is typically quoted in 'annualized' 
units for some epoch, that is, 'per square root epoch', though returns 
are observed at a frequency of <code>ope</code> per epoch. 
The default value is 1, meaning the code will not attempt to guess
what the observation frequency is, and no annualization adjustments
will be made.</p>
</td></tr>
<tr><td><code id="sropt_+3A_epoch">epoch</code></td>
<td>
<p>the string representation of the 'epoch', defaulting
to 'yr'.</p>
</td></tr>
<tr><td><code id="sropt_+3A_t2">T2</code></td>
<td>
<p>the Hotelling <code class="reqn">T^2</code> statistic. If not given, it is
computed from the given information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>sropt</code> class contains information about a rescaled T^2-statistic.
The following are list attributes of the object:
</p>

<dl>
<dt>sropt</dt><dd><p>The (optimal) Sharpe ratio statistic.</p>
</dd>
<dt>df1</dt><dd><p>The number of assets.</p>
</dd>
<dt>df2</dt><dd><p>The number of observations.</p>
</dd>
<dt>drag</dt><dd><p>The drag term, which is the 'risk free rate' divided by
the maximum risk.</p>
</dd>
<dt>ope</dt><dd><p>The 'observations per epoch'.</p>
</dd>
<dt>epoch</dt><dd><p>The string name of the 'epoch'.</p>
</dd>
</dl>

<p>For the most part, this constructor should <em>not</em> be called directly,
rather <code><a href="#topic+as.sropt">as.sropt</a></code> should be called instead to compute the
needed statistics.
</p>


<h3>Value</h3>

<p>a list cast to class <code>sropt</code>, with the following attributes:
</p>

<dl>
<dt>sropt</dt><dd><p>the optimal Sharpe statistic.</p>
</dd>
<dt>df1</dt><dd><p>the number of assets.</p>
</dd>
<dt>df2</dt><dd><p>the number of observed vectors.</p>
</dd>
<dt>drag</dt><dd><p>the input <code>drag</code> term.</p>
</dd>
<dt>ope</dt><dd><p>the input <code>ope</code> term.</p>
</dd>
<dt>epoch</dt><dd><p>the input <code>epoch</code> term.</p>
</dd>
<dt>T2</dt><dd><p>the Hotelling <code class="reqn">T^2</code> statistic.</p>
</dd>
</dl>



<h3>Note</h3>

<p>2FIX: allow rownames?
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reannualize">reannualize</a></code>
</p>
<p><code><a href="#topic+as.sropt">as.sropt</a></code>
</p>
<p>Other sropt: 
<code><a href="#topic+as.sropt">as.sropt</a>()</code>,
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+dsropt">dsropt</a>()</code>,
<code><a href="#topic+is.sropt">is.sropt</a>()</code>,
<code><a href="#topic+pco_sropt">pco_sropt</a>()</code>,
<code><a href="#topic+power.sropt_test">power.sropt_test</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+sropt_test">sropt_test</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># roll your own.
ope &lt;- 253
zeta.s &lt;- 1.0
df1 &lt;- 10
df2 &lt;- 6 * ope
set.seed(as.integer(charToRaw("fix seed")))
rvs &lt;- rsropt(1,df1,df2,zeta.s,ope,drag=0)
roll.own &lt;- sropt(z.s=rvs,df1,df2,drag=0,ope=ope)
print(roll.own)
# put a bunch in. naming becomes a problem.
rvs &lt;- rsropt(5,df1,df2,zeta.s,ope,drag=0)
roll.own &lt;- sropt(z.s=rvs,df1,df2,drag=0,ope=ope)
print(roll.own)
</code></pre>

<hr>
<h2 id='sropt_test'>test for optimal Sharpe ratio</h2><span id='topic+sropt_test'></span>

<h3>Description</h3>

<p>Performs one sample tests of Sharpe ratio of the Markowitz portfolio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sropt_test(X,alternative=c("greater","two.sided","less"),
            zeta.s=0,ope=1,conf.level=0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sropt_test_+3A_x">X</code></td>
<td>
<p>a (non-empty) numeric matrix of data values, each row independent,
each column representing an asset, or an object of 
class <code>sropt</code>.</p>
</td></tr>
<tr><td><code id="sropt_test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must be one of <code>"two.sided"</code>, <code>"greater"</code> (default) or
<code>"less"</code>.  You can specify just the initial letter.</p>
</td></tr>
<tr><td><code id="sropt_test_+3A_zeta.s">zeta.s</code></td>
<td>
<p>a number indicating the null hypothesis value.</p>
</td></tr>
<tr><td><code id="sropt_test_+3A_ope">ope</code></td>
<td>
<p>the number of observations per 'epoch'. For convenience of
interpretation, The Sharpe ratio is typically quoted in 'annualized' 
units for some epoch, that is, 'per square root epoch', though returns 
are observed at a frequency of <code>ope</code> per epoch. 
The default value is 1, meaning the code will not attempt to guess
what the observation frequency is, and no annualization adjustments
will be made.</p>
</td></tr>
<tr><td><code id="sropt_test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval. (not used yet)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">x_i</code> are <code class="reqn">n</code> independent draws of a <code class="reqn">q</code>-variate
normal random variable with mean <code class="reqn">\mu</code> and covariance matrix
<code class="reqn">\Sigma</code>. This code tests the hypothesis
</p>
<p style="text-align: center;"><code class="reqn">H_0: \mu^{\top}\Sigma^{-1}\mu = \delta_0^2</code>
</p>

<p>The default alternative hypothesis is the one-sided 
</p>
<p style="text-align: center;"><code class="reqn">H_1: \mu^{\top}\Sigma^{-1}\mu &gt; \delta_0^2</code>
</p>

<p>but this can be set otherwise.
</p>
<p>Note there is no 'drag' term here since this represents a linear offset of
the population parameter.
</p>
<p>See &lsquo;The Sharpe Ratio: Statistics and Applications&rsquo;,
section 6.3.2.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the <code class="reqn">T^2</code>-statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>a list of the degrees of freedom for the statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>a confidence interval appropriate to the specified alternative hypothesis. NYI.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated optimal Sharpe, annualized</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified hypothesized value of the optimal Sharpe.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Pav, S. E. &quot;The Sharpe Ratio: Statistics and Applications.&quot; CRC Press, 2021.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reannualize">reannualize</a></code>
</p>
<p><code><a href="#topic+sr_test">sr_test</a></code>, <code><a href="stats.html#topic+t.test">t.test</a></code>.
</p>
<p>Other sropt: 
<code><a href="#topic+as.sropt">as.sropt</a>()</code>,
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+dsropt">dsropt</a>()</code>,
<code><a href="#topic+is.sropt">is.sropt</a>()</code>,
<code><a href="#topic+pco_sropt">pco_sropt</a>()</code>,
<code><a href="#topic+power.sropt_test">power.sropt_test</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+sropt">sropt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# test for uniformity
pvs &lt;- replicate(128,{ x &lt;- sropt_test(matrix(rnorm(1000*4),ncol=4),alternative="two.sided")
                        x$p.value })
plot(ecdf(pvs))
abline(0,1,col='red') 

# input a sropt objects:
nfac &lt;- 5
nyr &lt;- 10
ope &lt;- 253
# simulations with no covariance structure.
# under the null:
set.seed(as.integer(charToRaw("be determinstic")))
Returns &lt;- matrix(rnorm(ope*nyr*nfac,mean=0,sd=0.0125),ncol=nfac)
asro &lt;- as.sropt(Returns,drag=0,ope=ope)
stest &lt;- sropt_test(asro,alternative="two.sided")

</code></pre>

<hr>
<h2 id='stock_returns'>Stock Returns Data</h2><span id='topic+stock_returns'></span>

<h3>Description</h3>

<p>Nineteen years of daily log returns on three stocks and an ETF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stock_returns)
</code></pre>


<h3>Format</h3>

<p>An <code>xts</code> object with 4777 observations and 4 columns. 
</p>
<p>The columns are the daily log returns for the tickers IBM, AAPL, SPY and XOM, 
as sourced from Yahoo finance using the <code>quantmod</code> package.
Daily returns span from January, 2000 through December, 2018.  
Returns are &lsquo;log returns&rsquo;, which are the differences of the logs of
daily adjusted closing price series, as defined by Yahoo finance (thus presumably
including adjustments for splits and dividends). Dates of observations are
the date of the second close defining the return, not the first.
</p>


<h3>Note</h3>

<p>The author makes no guarantees regarding correctness of this data.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>Source</h3>

<p>Data were collected on October 2, 2019, from Yahoo finance using the
<code>quantmod</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(xts)) {
 data(stock_returns)
 as.sr(stock_returns)
}
</code></pre>

<hr>
<h2 id='summary.sr'>Summarize a Sharpe, or (delta) optimal Sharpe object.</h2><span id='topic+summary.sr'></span><span id='topic+summary.sropt'></span>

<h3>Description</h3>

<p>Computes a &lsquo;summary&rsquo; of an object, adding in some statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sr'
summary(object, ...)

## S3 method for class 'sropt'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sr_+3A_object">object</code></td>
<td>
<p>an object of class <code>sr</code>, <code>sropt</code> or <code>del_sropt</code>.</p>
</td></tr>
<tr><td><code id="summary.sr_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced, though ignored here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Enhances an object of class <code>sr</code>, <code>sropt</code> or <code>del_sropt</code> to also 
include t- or T-statistics, p-values, and so on.
</p>


<h3>Value</h3>

<p>When an <code>sr</code> object is input, the object cast to class <code>summary.sr</code> with some
additional fields:
</p>

<dl>
<dt>tval</dt><dd><p>the equivalent t-statistic.</p>
</dd>
<dt>pval</dt><dd><p>the p-value under the null.</p>
</dd>
<dt>serr</dt><dd><p>the standard error of the Sharpe ratio.</p>
</dd>
</dl>

<p>When an <code>sropt</code> object is input, the object cast to class <code>summary.sropt</code> with some
additional fields:
</p>

<dl>
<dt>pval</dt><dd><p>the p-value under the null.</p>
</dd>
<dt>SRIC</dt><dd><p>the SRIC value, see <code><a href="#topic+sric">sric</a></code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Sharpe, William F. &quot;Mutual fund performance.&quot; Journal of business (1966): 119-138.
<a href="https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html">https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.sr">print.sr</a></code>.
</p>
<p>Other sr: 
<code><a href="#topic+as.sr">as.sr</a>()</code>,
<code><a href="#topic+confint.sr">confint.sr</a>()</code>,
<code><a href="#topic+dsr">dsr</a>()</code>,
<code><a href="#topic+is.sr">is.sr</a>()</code>,
<code><a href="#topic+plambdap">plambdap</a>()</code>,
<code><a href="#topic+power.sr_test">power.sr_test</a>()</code>,
<code><a href="#topic+predint">predint</a>()</code>,
<code><a href="#topic+print.sr">print.sr</a>()</code>,
<code><a href="#topic+reannualize">reannualize</a>()</code>,
<code><a href="#topic+se">se</a>()</code>,
<code><a href="#topic+sr_equality_test">sr_equality_test</a>()</code>,
<code><a href="#topic+sr_test">sr_test</a>()</code>,
<code><a href="#topic+sr_unpaired_test">sr_unpaired_test</a>()</code>,
<code><a href="#topic+sr_vcov">sr_vcov</a>()</code>,
<code><a href="#topic+sr">sr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sharpe's 'model': just given a bunch of returns.
set.seed(1234)
asr &lt;- as.sr(rnorm(253*3),ope=253)
summary(asr)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
