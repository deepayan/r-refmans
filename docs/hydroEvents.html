<!DOCTYPE html><html><head><title>Help for package hydroEvents</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hydroEvents}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#baseflowA'><p>Baseflow removal (after Fuka et al. 2018)</p></a></li>
<li><a href='#baseflowB'><p>Baseflow removal (after Ladson et al)</p></a></li>
<li><a href='#calcStats'><p>Extract statistics from events</p></a></li>
<li><a href='#data_P_WL'><p>Example sub-daily rainfall and tidal water level data</p></a></li>
<li><a href='#dataBassRiver'><p>Streamflow data</p></a></li>
<li><a href='#dataCatchment'><p>Catchment data</p></a></li>
<li><a href='#dataLoch'><p>Rainfall data</p></a></li>
<li><a href='#eventBaseflow'><p>Event identification (using baseflow index)</p></a></li>
<li><a href='#eventMaxima'><p>Event identification (using local maxima as a basis)</p></a></li>
<li><a href='#eventMinima'><p>Event identification (using local minima as a basis)</p></a></li>
<li><a href='#eventPOT'><p>Event identification (using a peak over threshold algorithm)</p></a></li>
<li><a href='#limbs'><p>Extract rising/falling limbs</p></a></li>
<li><a href='#localMin'><p>Local minima</p></a></li>
<li><a href='#pairEvents'><p>Pair Events</p></a></li>
<li><a href='#plotEvents'><p>Plot Events</p></a></li>
<li><a href='#plotPairs'><p>Plot Paired Events</p></a></li>
<li><a href='#WQ_Q'><p>Example water quality and streamflow data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Extract Event Statistics in Hydrologic Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>0.11</td>
</tr>
<tr>
<td>Author:</td>
<td>Conrad Wasko [aut, cre], Danlu Guo [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Conrad Wasko &lt;conrad.wasko@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Events from individual hydrologic time series are extracted, and events from multiple time series can be matched to each other.
	Tang, W. &amp; Carey, S. K. (2017) &lt;<a href="https://doi.org/10.1002%2Fhyp.11185">doi:10.1002/hyp.11185</a>&gt;.
	Kaur, S., Horne, A., Stewardson, M.J., Nathan, R., Costa, A.M., Szemis, J.M., &amp; Webb, J.A. (2017) &lt;<a href="https://doi.org/10.1080%2F24705357.2016.1276418">doi:10.1080/24705357.2016.1276418</a>&gt;.
	Ladson, A., Brown, R., Neal, B., &amp; Nathan, R. J. (2013) &lt;<a href="https://doi.org/10.7158%2FW12-028.2013.17.1">doi:10.7158/W12-028.2013.17.1</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/conradwasko/hydroEvents">https://github.com/conradwasko/hydroEvents</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-20 20:55:36 UTC; cwasko</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-21 00:10:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='baseflowA'>Baseflow removal (after Fuka et al. 2018)</h2><span id='topic+baseflowA'></span>

<h3>Description</h3>

<p>This function calculates baseflow using a recursive digital filter and is based on
the implementation in the EcoHydRology package.
</p>
<p>The formulation is originally after Lyne and Hollick (1979) and described in Furey and Gupta (2001).
Recommended parameters are after Nathan and McMahon (1990).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseflowA(q, alpha = 0.925, passes = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseflowA_+3A_q">q</code></td>
<td>
<p>The vector series of streamflow</p>
</td></tr>
<tr><td><code id="baseflowA_+3A_alpha">alpha</code></td>
<td>
<p>Filter parameter</p>
</td></tr>
<tr><td><code id="baseflowA_+3A_passes">passes</code></td>
<td>
<p>Number of passes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the baseflow and baseflow index at each timestep.
</p>


<h3>References</h3>

<p>Fuka D. R., Walter, M.T., Archiblad, J.A., Steenhuis, T.S., &amp; Easton, Z. M. (2018).
A Community Modeling Foundation for Eco-Hydrology, R package version 0.4.12.1
Flow from Streamflow Time Series. Water Resources Research, 37(11), 2709–2722.
</p>
<p>Furey, P., &amp; Gupta, V. (2001). A Physically Based Filter for Spearating Base
Flow from Streamflow Time Series. Water Resources Research, 37(11), 2709–2722.
</p>
<p>Lyne, V., &amp; Hollick, M. (1979). Stochastic time-variable rainfall-runoff modelling.
Institute of Engineers Australia National Conference, 89-92.
</p>
<p>Nathan, R. J., &amp; McMahon, T. A. (1990). Evaluation of automated techniques for base flow and recession analyses.
Water Resources Research, 26(7), 1465–1473.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(hydroEvents)
data(dataBassRiver)
alpha.list = c(0, 0.9, 0.925, 0.95, 0.98, 0.987)
BFI.1 = numeric(length(alpha.list))
for (i in 1:length(alpha.list)) {
  bf.1 = baseflowA(dataBassRiver, alpha = alpha.list[i])
  BFI.1[i] = sum(bf.1$bf)/sum(dataBassRiver)
}
print(cbind(alpha.list, BFI.1))
</code></pre>

<hr>
<h2 id='baseflowB'>Baseflow removal (after Ladson et al)</h2><span id='topic+baseflowB'></span>

<h3>Description</h3>

<p>This function calculates baseflow using a recursive digital filter and is based on
the implementation described in Ladson et al (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseflowB(q, alpha = 0.925, passes = 3, r = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseflowB_+3A_q">q</code></td>
<td>
<p>The vector series of streamflow</p>
</td></tr>
<tr><td><code id="baseflowB_+3A_alpha">alpha</code></td>
<td>
<p>Filter parameter</p>
</td></tr>
<tr><td><code id="baseflowB_+3A_passes">passes</code></td>
<td>
<p>Number of passes</p>
</td></tr>
<tr><td><code id="baseflowB_+3A_r">r</code></td>
<td>
<p>number of points reflected at start and end of data set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The reflected points act to resolve spin up issues and are removed before the baseflow is removed.
</p>


<h3>Value</h3>

<p>A list of the baseflow and baseflow index at each timestep.
</p>


<h3>References</h3>

<p>Ladson, A., Brown, R., Neal, B., &amp; Nathan, R. (2013). A standard approach to baseflow separation using the Lyne and Hollick filter.
Australian Journal of Water Resources, 17(1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(hydroEvents)
data(dataBassRiver)
alpha.list = c(0, 0.9, 0.925, 0.95, 0.98, 0.987)
BFI = numeric(length(alpha.list))
for (i in 1:length(alpha.list)) {
  bf = baseflowB(dataBassRiver, alpha = alpha.list[i])
  BFI[i] = sum(bf$bf)/sum(dataBassRiver)
}
print(cbind(alpha.list, BFI))
</code></pre>

<hr>
<h2 id='calcStats'>Extract statistics from events</h2><span id='topic+calcStats'></span>

<h3>Description</h3>

<p>Given the start and end indices of events statistics are calculated for the values in
between the start and end points inclusive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcStats(srt, end, data, f.vec = c("which.max", "max", "min"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcStats_+3A_srt">srt</code></td>
<td>
<p>Vector of indices for the event start</p>
</td></tr>
<tr><td><code id="calcStats_+3A_end">end</code></td>
<td>
<p>Vector of indices for the event end</p>
</td></tr>
<tr><td><code id="calcStats_+3A_data">data</code></td>
<td>
<p>Vector of data</p>
</td></tr>
<tr><td><code id="calcStats_+3A_f.vec">f.vec</code></td>
<td>
<p>c(&quot;which.max&quot;, &quot;max&quot;, &quot;min&quot;) Functions to be applied to the events</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe where the row is each event and the column is each statistic. If <code>which.min</code> or
<code>which.max</code> are called the indices returned are global, that is, relative to the start of <code>data</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eventPOT">eventPOT</a></code> <code><a href="#topic+eventBaseflow">eventBaseflow</a></code> <code><a href="#topic+eventMaxima">eventMaxima</a></code> <code><a href="#topic+eventMinima">eventMinima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Extract event statistics and plot the maxima
event.indices = eventPOT(dataLoch, out.style = "none")
event.stats = calcStats(event.indices$srt, event.indices$end, dataLoch)
print(event.stats)

plot(1:length(dataLoch), dataLoch, type = "h", lwd = 2, col = "steelblue",
     ylab = "Rainfall (mm)", xlab = "Time index", mgp = c(2, 0.6, 0))
points(event.stats$which.max, event.stats$max, col = "red", pch = 16, cex = 1.2)
legend("topright", legend = c("Rainfall", "Max"), cex = 0.8,
       lwd = c(2, NA), pch = c(NA, 16), col = c("steelblue", "red"), bty = "n")
</code></pre>

<hr>
<h2 id='data_P_WL'>Example sub-daily rainfall and tidal water level data</h2><span id='topic+data_P_WL'></span>

<h3>Description</h3>

<p>Hourly rainfall (P) and water level (WL) at Burnie, Tasmania for 1997-01-14 to 1997-02-14 (Pluvio ID: 091009; Tide gauge: IDO71005)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_P_WL
</code></pre>


<h3>Format</h3>

<p>Each of P and WL data is a simple vector with no time stamp. The original data is in hourly time step.
</p>


<h3>Source</h3>

<p>Sub-daily rainfall data are from Australian Bureau of Meteorology:
<a href="http://www.bom.gov.au/climate/data/stations/">http://www.bom.gov.au/climate/data/stations/</a>
Sub-daily tidal water level data are from Australian Bureau of Meteorolgy Australian Baseline Sea Level Monitoring Project:
<a href="http://www.bom.gov.au/oceanography/projects/abslmp/data/index.shtml">http://www.bom.gov.au/oceanography/projects/abslmp/data/index.shtml</a>
</p>

<hr>
<h2 id='dataBassRiver'>Streamflow data</h2><span id='topic+dataBassRiver'></span>

<h3>Description</h3>

<p>Streamflow data for Bass River at Loch (227219A) for 30/06/1974-04/09/1974
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataBassRiver
</code></pre>


<h3>Format</h3>

<p>A vector of 67 daily streamflow values in (ML/day)
</p>


<h3>Details</h3>

<p>This data is obtained from Grayson et al (1996)
</p>


<h3>References</h3>

<p>Grayson, R., Argent, R. M., Nathan, R. J., McMahon, T. A. &amp; Mein, R. G. (1996) Hydrological
Recipes, Cooperative Research Centre for Catchment Hydrology, Melbourne.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dataLoch">dataLoch</a></code>
</p>

<hr>
<h2 id='dataCatchment'>Catchment data</h2><span id='topic+dataCatchment'></span>

<h3>Description</h3>

<p>Example data for five sites across Australia
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataCatchment
</code></pre>


<h3>Format</h3>

<p>A list with streamflow and catchment average precipitation and temperature for the following sites:
120301B, 602004, 235203, 410044, 105105A, corresponding to Arid, Mediterranean, Temperate, Subtropical, and Tropical climates.
Catchment areas are 35326, 2433, 721, 1072, 297 km2 respectively.
Streamflow is from the Australian Bureau of Meteorology Hydrologic Reference Station network and catchment average climate variables
were extracted using AWAPer.
</p>


<h3>Source</h3>

<p><a href="http://www.bom.gov.au/water/hrs/">http://www.bom.gov.au/water/hrs/</a>
</p>


<h3>References</h3>

<p>Peterson, T.J., Wasko, C., Saft., &amp; Peel, M.C. (2020) AWAPer: An R package for area weighted catchment
daily meteorological data anywhere within Australia, Hydrological Processes, 34, 1301-1306.
</p>
<p>Jones, D., Wang, W., &amp; Fawcett, R., 2009. High-quality spatial climate data-sets for Australia. Aust. Meteorol. Oceanogr. J. 58, 233–248.
</p>

<hr>
<h2 id='dataLoch'>Rainfall data</h2><span id='topic+dataLoch'></span>

<h3>Description</h3>

<p>Rainfall data for Loch (Station ID 086067) for 30/06/1974-04/09/1974
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataLoch
</code></pre>


<h3>Format</h3>

<p>A vector of 67 daily rainfall values in (mm)
</p>


<h3>Source</h3>

<p><a href="http://www.bom.gov.au/climate/data/stations/">http://www.bom.gov.au/climate/data/stations/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dataBassRiver">dataBassRiver</a></code>
</p>

<hr>
<h2 id='eventBaseflow'>Event identification (using baseflow index)</h2><span id='topic+eventBaseflow'></span>

<h3>Description</h3>

<p>Events are identified on the basis of the Baseflow Index (BFI).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eventBaseflow(
  data,
  BFI_Th = 0.5,
  bfi = baseflowB(data)$bfi,
  min.diff = 1,
  out.style = "summary"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eventBaseflow_+3A_data">data</code></td>
<td>
<p>The data vector (e.g. a streamflow time series)</p>
</td></tr>
<tr><td><code id="eventBaseflow_+3A_bfi_th">BFI_Th</code></td>
<td>
<p>Minimum BFI to identify baseflow</p>
</td></tr>
<tr><td><code id="eventBaseflow_+3A_bfi">bfi</code></td>
<td>
<p>If no BFI is provided the BFI is calculated automatically using baseflowB</p>
</td></tr>
<tr><td><code id="eventBaseflow_+3A_min.diff">min.diff</code></td>
<td>
<p>Minimum length for an event</p>
</td></tr>
<tr><td><code id="eventBaseflow_+3A_out.style">out.style</code></td>
<td>
<p>The type of output (currently either &quot;summary&quot; or &quot;none&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any flow above the <code>BFI_Th</code> will be considered an event with a minimum event separation of <code>min.diff</code>.
</p>


<h3>Value</h3>

<p>By default, the <code>out.style</code> returns the indices of the maximum in each event, as well as the value of
the maximum and the sum of the <code>data</code> in each event, alongside the start and end of the events. Otherwise just
the indices of start and end of events as a two column dataframe are returned.
</p>


<h3>References</h3>

<p>Kaur, S., Horne, A., Stewardson, M.J., Nathan, R., Costa, A.M., Szemis, J.M., &amp; Webb, J.A., (2017)
Challenges for determining frequency of high flow spells for varying thresholds in environmental flows programmes. J. Ecohydraulics 2, 28–37.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcStats">calcStats</a></code> <code><a href="#topic+eventBaseflow">eventBaseflow</a></code> <code><a href="#topic+eventMaxima">eventMaxima</a></code> <code><a href="#topic+eventPOT">eventPOT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example
BFI_res = eventBaseflow(dataBassRiver, BFI_Th = 0.5, min.diff = 1)
</code></pre>

<hr>
<h2 id='eventMaxima'>Event identification (using local maxima as a basis)</h2><span id='topic+eventMaxima'></span>

<h3>Description</h3>

<p>Events are identified on the basis of local maxima with an &quot;event&quot; considered to have
occurred if the maxima is above a tolerable threshold of the neighbouring troughs/valleys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eventMaxima(
  data,
  delta.y = 200,
  delta.x = 1,
  threshold = -1,
  out.style = "summary"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eventMaxima_+3A_data">data</code></td>
<td>
<p>The data vector</p>
</td></tr>
<tr><td><code id="eventMaxima_+3A_delta.y">delta.y</code></td>
<td>
<p>Minimum allowable difference from a peak to a trough</p>
</td></tr>
<tr><td><code id="eventMaxima_+3A_delta.x">delta.x</code></td>
<td>
<p>Minimum spacing between peaks</p>
</td></tr>
<tr><td><code id="eventMaxima_+3A_threshold">threshold</code></td>
<td>
<p>Value above which an event is considered to have occurred</p>
</td></tr>
<tr><td><code id="eventMaxima_+3A_out.style">out.style</code></td>
<td>
<p>The type of output (currently either &quot;summary&quot; or &quot;none&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>delta.y</code> is negative it is applied a fractional decrease from the peak, otherwise it is
treated as an absolute value. The <code>threshold</code> is applied after the event separation meaning that if a trough
goes below the threshold but was originally considered one event it will continue to be considered one event.
This makes this method distinct from the peaks over threshold algorithm in <code>eventPOT</code>. The <code>threshold</code>
here should be thought of as a filter to remove trace amounts that are not part of an event rather than event separation
metric.
</p>


<h3>Value</h3>

<p>By default, the <code>out.style</code> returns the indices of the maximum in each event, as well as the value of
the maximum and the sum of the <code>data</code> in each event, alongside the start and end of the events. Otherwise just
the indices of start and end of events as a two column dataframe are returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcStats">calcStats</a></code> <code><a href="#topic+eventBaseflow">eventBaseflow</a></code> <code><a href="#topic+eventMaxima">eventMaxima</a></code> <code><a href="#topic+eventPOT">eventPOT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example extracting events from quickflow
bf = baseflowB(dataBassRiver, alpha = 0.925)
qf = dataBassRiver - bf$bf
events = eventMaxima(qf, delta.y = 200, delta.x = 1, threshold = 0)
print(events)
plotEvents(qf, dates = NULL, events = events, type = "lineover", main = "")
# Other examples to try
# delta.y = 200; delta.x = 1 # 5 events identified
# delta.y = 500; delta.x = 1 # 3 events identified
# delta.y = 10;  delta.x = 7 # 2 events identified
</code></pre>

<hr>
<h2 id='eventMinima'>Event identification (using local minima as a basis)</h2><span id='topic+eventMinima'></span>

<h3>Description</h3>

<p>Events are identified on the basis of local minima with an &quot;event&quot; considered to have
occurred once the data has returned to within a threshold level of the start of the event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eventMinima(
  data,
  delta.y = 20,
  delta.x = 5,
  threshold = -1,
  out.style = "summary"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eventMinima_+3A_data">data</code></td>
<td>
<p>The data vector</p>
</td></tr>
<tr><td><code id="eventMinima_+3A_delta.y">delta.y</code></td>
<td>
<p>Maximum allowable difference between troughs</p>
</td></tr>
<tr><td><code id="eventMinima_+3A_delta.x">delta.x</code></td>
<td>
<p>Minimum length for an event</p>
</td></tr>
<tr><td><code id="eventMinima_+3A_threshold">threshold</code></td>
<td>
<p>Value above which an event is considered to have occurred</p>
</td></tr>
<tr><td><code id="eventMinima_+3A_out.style">out.style</code></td>
<td>
<p>The type of output (currently either &quot;summary&quot; or &quot;none&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>threshold</code> is applied after the event separation meaning that if a trough
goes below the threshold but was originally considered one event it will continue to be considered one event.
This makes this method distinct from the peaks over threshold algorithm in <code>eventPOT</code>. The <code>threshold</code>
here should be thought of as a filter to remove trace amounts that are not part of an event rather than event separation
metric.
</p>


<h3>Value</h3>

<p>By default, the <code>out.style</code> returns the indices of the maximum in each event, as well as the value of
the maximum and the sum of the <code>data</code> in each event, alongside the start and end of the events. Otherwise just
the indices of start and end of events as a two column dataframe are returned.
</p>


<h3>References</h3>

<p>Tang, W., &amp; Carey, S. K. (2017) HydRun: A MATLAB toolbox for rainfall-runoff analysis,
Hydrological Processes (31) 2670-2682
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcStats">calcStats</a></code> <code><a href="#topic+eventBaseflow">eventBaseflow</a></code> <code><a href="#topic+eventMaxima">eventMaxima</a></code> <code><a href="#topic+eventPOT">eventPOT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example extracting events from quickflow
bf = baseflowB(dataBassRiver, alpha = 0.925)
qf = dataBassRiver - bf$bf
events = eventMinima(qf, delta.x = 5, delta.y = 20)
print(events)
plotEvents(qf, dates = NULL, events = events, type = "lineover", main = "")
# delta.x = 5, delta.y = 20 # 5 events identified
# delta.x = 5, delta.y = 10 # 4 events identified
# delta.x = 1, delta.y = 20 # 6 events identified
</code></pre>

<hr>
<h2 id='eventPOT'>Event identification (using a peak over threshold algorithm)</h2><span id='topic+eventPOT'></span>

<h3>Description</h3>

<p>Identify events using a specified threshold value over which an event is considered to have occurred.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eventPOT(data, threshold = 0, min.diff = 1, out.style = "summary")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eventPOT_+3A_data">data</code></td>
<td>
<p>A data vector</p>
</td></tr>
<tr><td><code id="eventPOT_+3A_threshold">threshold</code></td>
<td>
<p>Value above which an event is considered to have occurred</p>
</td></tr>
<tr><td><code id="eventPOT_+3A_min.diff">min.diff</code></td>
<td>
<p>Spacing required for two events to be considered separate</p>
</td></tr>
<tr><td><code id="eventPOT_+3A_out.style">out.style</code></td>
<td>
<p>The type of output (currently either &quot;summary&quot; or &quot;none&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>threshold</code> can be thought of a value below which the <code>data</code> are considered to be &quot;zero&quot;.
The <code>min.diff</code> can be viewed as the minimum spacing for event independence.
</p>


<h3>Value</h3>

<p>By default, the <code>out.style</code> returns the indices of the maximum in each event, as well as the value of
the maximum and the sum of the <code>data</code> in each event, alongside the start and end of the events. Otherwise just
the indices of start and end of events as a two column dataframe are returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcStats">calcStats</a></code> <code><a href="#topic+eventBaseflow">eventBaseflow</a></code> <code><a href="#topic+eventMaxima">eventMaxima</a></code> <code><a href="#topic+eventMinima">eventMinima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example using streamflow data
bf = baseflowB(dataBassRiver, alpha = 0.925)
qf = dataBassRiver - bf$bf
events = eventPOT(qf)
plotEvents(qf, dates = NULL, events = events, type = "lineover",
   main = "Events (plotted on quickflow)")
plotEvents(dataBassRiver, dates = NULL, events = events, type = "lineover",
   main = "Events (plotted on streamflow)")

# Examples using rainfall data
events = eventPOT(dataLoch, threshold = 0, min.diff = 1)
plotEvents(dataLoch, dates = NULL, events = events, type = "hyet",
   main = "Rainfall Events (threshold = 0, min.diff = 1)")

events = eventPOT(dataLoch, threshold = 2, min.diff = 2)
plotEvents(dataLoch, dates = NULL, events = events, type = "hyet",
   main = "Rainfall Events (threshold = 2, min.diff = 2)")
</code></pre>

<hr>
<h2 id='limbs'>Extract rising/falling limbs</h2><span id='topic+limbs'></span>

<h3>Description</h3>

<p>Identify the rising and falling limbs within each event (and optionally plot)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>limbs(
  data,
  dates = NULL,
  events,
  to.plot = TRUE,
  ymin = min(data),
  ymax = max(data),
  xlab = "",
  ylab = "",
  main = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="limbs_+3A_data">data</code></td>
<td>
<p>The data vector (e.g. a streamflow time series)</p>
</td></tr>
<tr><td><code id="limbs_+3A_dates">dates</code></td>
<td>
<p>Date variable, default to NULL (inputting data as a simple vector)</p>
</td></tr>
<tr><td><code id="limbs_+3A_events">events</code></td>
<td>
<p>Event extracted</p>
</td></tr>
<tr><td><code id="limbs_+3A_to.plot">to.plot</code></td>
<td>
<p>c(TRUE,FALSE) whether a plot is produced for the limbs</p>
</td></tr>
<tr><td><code id="limbs_+3A_ymin">ymin</code></td>
<td>
<p>Minimum plot extend in vertical direction</p>
</td></tr>
<tr><td><code id="limbs_+3A_ymax">ymax</code></td>
<td>
<p>Maximum plot extent in vertical direction</p>
</td></tr>
<tr><td><code id="limbs_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="limbs_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label</p>
</td></tr>
<tr><td><code id="limbs_+3A_main">main</code></td>
<td>
<p>Plot title</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns indices of start and end of events and the rising/falling limbs within each event
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
library(hydroEvents)
qdata = WQ_Q$qdata[[1]]
BF_res = eventBaseflow(qdata$Q_cumecs)
limbs(data = qdata$Q_cumecs, dates = NULL, events = BF_res, main = "with 'eventBaseflow'")
BFI_res = eventBaseflow(dataBassRiver)

# Example 2
library(hydroEvents)
BFI_res = eventBaseflow(dataBassRiver)
d = as.Date("1974-06-30") + 0:(length(dataBassRiver)-1)
limbs(data = dataBassRiver, dates = NULL, events = BFI_res)
limbs(data = dataBassRiver, dates = d, events = BFI_res)
</code></pre>

<hr>
<h2 id='localMin'>Local minima</h2><span id='topic+localMin'></span>

<h3>Description</h3>

<p>Returns the index of local minima.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localMin(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localMin_+3A_x">x</code></td>
<td>
<p>The data vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If values are repeated it returns the first index of occurrence.
If the first value is repeated it is ignored as a local minima.
</p>


<h3>Value</h3>

<p>Returns indices of local minima
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find minima (with repeated values)
x = c(1, 2, 9, 9, 2, 1, 1, 5, 5, 1)
m = localMin(x)
plot(x, type = "l", lwd = 2, xlab = "", ylab = "", mgp = c(2, 0.6, 0))
points(m, x[m], pch = 16, col = "red")

# Find maxima (with repeated values)
x = c(1, 2, 9, 9, 2, 1, 1, 5, 5, 1)
m = localMin(-x)
plot(x, type = "l", lwd = 2, xlab = "", ylab = "", mgp = c(2, 0.6, 0))
points(m, x[m], pch = 16, col = "red")

# Minima in streamflow
m = localMin(dataBassRiver)
plot(dataBassRiver, type = "l", col = "steelblue", lwd = 2, ylab = "Flow (ML/d)",
   xlab = "Time index", mgp = c(2, 0.6, 0))
points(m, dataBassRiver[m], col = "red", pch = 16)

# Minima in quickflow
bf = baseflowA(dataBassRiver, alpha = 0.925)
qf = dataBassRiver - bf$bf
m = localMin(qf)
plot(qf, type = "l", lwd = 2, ylab = "Quickflow (ML/d)", xlab = "Time index", mgp = c(2, 0.6, 0))
points(m, qf[m], col = "red", pch = 16)

# Maxima in quickflow
bf = baseflowA(dataBassRiver, alpha = 0.925)
qf = dataBassRiver - bf$bf
m = localMin(-qf)
plot(qf, type = "l", lwd = 2, ylab = "Quickflow (ML/d)", xlab = "Time index", mgp = c(2, 0.6, 0))
points(m, qf[m], col = "red", pch = 16)
</code></pre>

<hr>
<h2 id='pairEvents'>Pair Events</h2><span id='topic+pairEvents'></span>

<h3>Description</h3>

<p>Pairing of events performed either forwards or backwards within specified lag times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairEvents(events.1, events.2, lag = 5, type = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairEvents_+3A_events.1">events.1</code></td>
<td>
<p>Events of first data set</p>
</td></tr>
<tr><td><code id="pairEvents_+3A_events.2">events.2</code></td>
<td>
<p>Events of second data set</p>
</td></tr>
<tr><td><code id="pairEvents_+3A_lag">lag</code></td>
<td>
<p>Maximum lag time (search radius) for pairing</p>
</td></tr>
<tr><td><code id="pairEvents_+3A_type">type</code></td>
<td>
<p>Method used to pair events (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pairing can be performed forwards and backwards and centrally.<code>events.1</code> and <code>events.2</code> need to be
a dataframe with column names appropriate to the method type.
That is, if pairing needs a time of maximum then &quot;which.max&quot; is expected (see examples). Column names are taken from
the function event matching functions. The method types are:
</p>

<ul>
<li><p>Type = 1: Search for the peak in <code>events.2</code> within the start of <code>event.1</code> to the end of <code>event.1</code> + <code>lag</code>
</p>
</li>
<li><p>Type = 2: Search for an end in <code>events.2</code> within the start of <code>event.1</code> to the end of <code>event.1</code> + <code>lag</code>
</p>
</li>
<li><p>Type = 3: Search for the peak in <code>events.1</code> within the start of <code>event.2</code> - <code>lag</code> to the peak in <code>event.2</code>
</p>
</li>
<li><p>Type = 4: Search for a start in <code>events.1</code> within the start of <code>event.2</code> - <code>lag</code> to the start of <code>event.2</code>
</p>
</li>
<li><p>Type = 5: Search for the peak in <code>events.2</code> within the peak of <code>event.1</code> - <code>lag</code> to the peak of <code>event.1</code> + <code>lag</code>
</p>
</li></ul>

<p>It is appropriate to pick a lag time that is equivalent to the catchment time of concentration if matching rainfall to streamflow.
</p>


<h3>Value</h3>

<p>Returns indices of start and end of events as well as the matched events as a four column dataframe.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcStats">calcStats</a></code> <code><a href="#topic+eventBaseflow">eventBaseflow</a></code> <code><a href="#topic+eventMaxima">eventMaxima</a></code> <code><a href="#topic+eventMinima">eventMinima</a></code> <code><a href="#topic+eventPOT">eventPOT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load package
library(hydroEvents)
# Identify events
srt = as.Date("2015-02-05")
end = as.Date("2015-04-01")
idx = which(dataCatchment$`105105A`$Date &gt;= srt &amp; dataCatchment$`105105A`$Date &lt;= end)
dat = dataCatchment$`105105A`[idx,]
events.P = eventPOT(dat$Precip_mm, threshold = 1, min.diff = 2)
events.Q = eventMaxima(dat$Flow_ML, delta.y = 2, delta.x = 1, thresh = 70)
# Plot events
oldpar &lt;- par(mfrow = c(2, 1), mar = c(3, 2.7, 2, 1))
plotEvents(dat$Precip_mm, events = events.P, type = "hyet", colpnt = "#E41A1C",
   colline = "#E41A1C", ylab = "Precipitation (mm)", xlab = "Index", main = "2015")
plotEvents(dat$Flow_ML, events = events.Q, type = "lineover", colpnt = "#E41A1C",
   colline = "#377EB8", ylab = "Flow (ML/day)", xlab = "Index", main = "")
par(oldpar)
# Pair events
matched.1 = pairEvents(events.P, events.Q, lag = 5,  type = 1)
matched.2 = pairEvents(events.P, events.Q, lag = 5,  type = 2)
matched.3 = pairEvents(events.P, events.Q, lag = 3,  type = 3)
matched.4 = pairEvents(events.P, events.Q, lag = 7, type = 4)
matched.5 = pairEvents(events.P, events.Q, lag = 5, type = 5)
# Plot Pairs
oldpar &lt;- par(mfrow = c(5, 1), mar = c(2, 3, 2, 3))
plotPairs(data.1 = dat$Precip_mm, data.2 = dat$Flow_ML, events = matched.1,
   col = rainbow(nrow(events.P)), ylab.1 = "P (mm)", ylab.2 = "Q (ML/day)", cex.2 = 0.66)
plotPairs(data.1 = dat$Precip_mm, data.2 = dat$Flow_ML, events = matched.2,
   col = rainbow(nrow(events.P)), ylab.1 = "P (mm)", ylab.2 = "Q (ML/day)", cex.2 = 0.66)
plotPairs(data.1 = dat$Precip_mm, data.2 = dat$Flow_ML, events = matched.3,
   col = rainbow(nrow(events.P)), ylab.1 = "Q (ML/day)", ylab.2 = "P (mm)", cex.2 = 0.66)
plotPairs(data.1 = dat$Precip_mm, data.2 = dat$Flow_ML, events = matched.4,
   col = rainbow(nrow(events.P)), ylab.1 = "Q (ML/day)", ylab.2 = "P (mm)", cex.2 = 0.66)
plotPairs(data.1 = dat$Precip_mm, data.2 = dat$Flow_ML, events = matched.5,
   col = rainbow(nrow(events.P)), ylab.1 = "P (mm)", ylab.2 = "Q ML/day)", cex.2 = 0.66)
par(oldpar)
</code></pre>

<hr>
<h2 id='plotEvents'>Plot Events</h2><span id='topic+plotEvents'></span>

<h3>Description</h3>

<p>Wrapper function for plotting identified events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEvents(
  data,
  dates = NULL,
  events,
  type = "lineover",
  colline = "red",
  colpnt = "blue",
  colbound = "red",
  ymin = min(data),
  ymax = max(data),
  xlab = "",
  ylab = "",
  main = "events"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotEvents_+3A_data">data</code></td>
<td>
<p>The data vector</p>
</td></tr>
<tr><td><code id="plotEvents_+3A_dates">dates</code></td>
<td>
<p>Optional date vector</p>
</td></tr>
<tr><td><code id="plotEvents_+3A_events">events</code></td>
<td>
<p>Events data frame</p>
</td></tr>
<tr><td><code id="plotEvents_+3A_type">type</code></td>
<td>
<p>The type of plot (see details)</p>
</td></tr>
<tr><td><code id="plotEvents_+3A_colline">colline</code></td>
<td>
<p>Line colour</p>
</td></tr>
<tr><td><code id="plotEvents_+3A_colpnt">colpnt</code></td>
<td>
<p>Point colour</p>
</td></tr>
<tr><td><code id="plotEvents_+3A_colbound">colbound</code></td>
<td>
<p>Background colour for plot type <code>"bound"</code></p>
</td></tr>
<tr><td><code id="plotEvents_+3A_ymin">ymin</code></td>
<td>
<p>Minimum plot extend in vertical direction</p>
</td></tr>
<tr><td><code id="plotEvents_+3A_ymax">ymax</code></td>
<td>
<p>Maximum plot extent in vertical direction</p>
</td></tr>
<tr><td><code id="plotEvents_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="plotEvents_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label</p>
</td></tr>
<tr><td><code id="plotEvents_+3A_main">main</code></td>
<td>
<p>Plot title</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three plot types are implemented: <code>"lineover"</code>, <code>"bound"</code>, <code>"hyet"</code>. See examples.
If events contains a column titled &quot;which.max&quot; the maxima are also plotted.
</p>


<h3>Value</h3>

<p>No return value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eventBaseflow">eventBaseflow</a></code> <code><a href="#topic+eventMaxima">eventMaxima</a></code> <code><a href="#topic+eventMinima">eventMinima</a></code> <code><a href="#topic+eventPOT">eventPOT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot events
library(hydroEvents)
BFI_res = eventBaseflow(dataBassRiver)

oldpar &lt;- par(mfrow = c(3, 1), mar = c(3, 2.7, 2, 1))
d = as.Date("1974-06-30") + 0:(length(dataBassRiver)-1)
plotEvents(data = dataBassRiver, dates = d, events = BFI_res,
   type = "lineover", xlab = "Date", ylab = "Flow (ML/day)", main = "lineover")
plotEvents(data = dataBassRiver, dates = d, events = BFI_res, type = "bound",
   xlab = "Date", ylab = "Flow (ML/day)", main = "bound")
plotEvents(data = dataBassRiver, dates = d, events = BFI_res, type = "hyet",
   xlab = "Date", ylab = "Flow (ML/day)", main = "hyet")
par(oldpar)
</code></pre>

<hr>
<h2 id='plotPairs'>Plot Paired Events</h2><span id='topic+plotPairs'></span>

<h3>Description</h3>

<p>Wrapper function for plotting paired events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPairs(
  data.1,
  data.2,
  events,
  dates = NULL,
  type = "hyet",
  color.list = rainbow(nrow(events)),
  xlab = "",
  ylab.1 = "",
  ylab.2 = "",
  cex.2 = 1,
  main = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPairs_+3A_data.1">data.1</code></td>
<td>
<p>The first data vector</p>
</td></tr>
<tr><td><code id="plotPairs_+3A_data.2">data.2</code></td>
<td>
<p>The second data vector</p>
</td></tr>
<tr><td><code id="plotPairs_+3A_events">events</code></td>
<td>
<p>The pairedeEvents data frame from <a href="#topic+pairEvents">pairEvents</a></p>
</td></tr>
<tr><td><code id="plotPairs_+3A_dates">dates</code></td>
<td>
<p>Optional date vector</p>
</td></tr>
<tr><td><code id="plotPairs_+3A_type">type</code></td>
<td>
<p>The type of plot (see details)</p>
</td></tr>
<tr><td><code id="plotPairs_+3A_color.list">color.list</code></td>
<td>
<p>Vector of colours used for plotting</p>
</td></tr>
<tr><td><code id="plotPairs_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="plotPairs_+3A_ylab.1">ylab.1</code></td>
<td>
<p>primary y-axis label</p>
</td></tr>
<tr><td><code id="plotPairs_+3A_ylab.2">ylab.2</code></td>
<td>
<p>secondary y-axis label</p>
</td></tr>
<tr><td><code id="plotPairs_+3A_cex.2">cex.2</code></td>
<td>
<p>cex for secondary y-axis label</p>
</td></tr>
<tr><td><code id="plotPairs_+3A_main">main</code></td>
<td>
<p>Plot title</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the type is <code>"hyet"</code> then <code>data.1</code> is plotted as a vertical lines and <code>data.2</code> as a line.
If the type is <code>"lineover"</code> then all data is plotted as lines.
</p>


<h3>Value</h3>

<p>No return value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairEvents">pairEvents</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(hydroEvents)
BFI_res = eventBaseflow(dataBassRiver)
POT_res = eventPOT(dataLoch)
pairs.1 = pairEvents(POT_res, BFI_res, type = 1, lag = 5)
pairs.3 = pairEvents(POT_res, BFI_res, type = 3, lag = 3)
d = as.Date("1974-06-30") + 0:(length(dataBassRiver)-1)
oldpar &lt;- par(mar = c(3, 3.5, 2, 3.5), mfrow = c(2, 1))
plotPairs(dataLoch, dataBassRiver, pairs.1, dates = d, type = "hyet", xlab = "Date",
    ylab.1 = "Rain (mm)", ylab.2 = "Flow (ML/day)", main = "Matching Forward")
plotPairs(dataLoch, dataBassRiver, pairs.3, dates = d, type = "hyet", xlab = "Date",
    ylab.1 = "Flow (ML/day)", ylab.2 = "Rain (mm)", main = "Matching Backward")
par(oldpar)
</code></pre>

<hr>
<h2 id='WQ_Q'>Example water quality and streamflow data</h2><span id='topic+WQ_Q'></span>

<h3>Description</h3>

<p>Data from 4 HRS (Hydrologic Reference Stations, Australian Bureau of Meteorology) catchments are included:
catchment IDs: 410073, 424002, G8150018, A5020502.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WQ_Q
</code></pre>


<h3>Format</h3>

<p>Water quality (WQ) and streamflow (Q) data at matching time steps from 4 HRS catchments.
Each dataset (qdata and wqdata) is a list of length 4, corresponding to the 4 catchments.
</p>


<h3>Source</h3>

<p>HRS streamflow data:
<a href="http://www.bom.gov.au/water/hrs/">http://www.bom.gov.au/water/hrs/</a>
water quality data:
WaterNSW: <a href="https://realtimedata.waternsw.com.au/">https://realtimedata.waternsw.com.au/</a>
Northern Territory Department of Environment, Parks and Water Security <a href="https://ntg.aquaticinformatics.net/AQWebportal/">https://ntg.aquaticinformatics.net/AQWebportal/</a>
South Australia Department for Environment and Water <a href="https://www.waterconnect.sa.gov.au/">https://www.waterconnect.sa.gov.au/</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
