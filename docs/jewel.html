<!DOCTYPE html><html lang="en"><head><title>Help for package jewel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jewel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addZeroDiagonal'><p>Adding zero diagonal to a matrix</p></a></li>
<li><a href='#constructWeights'><p>Construct weights for _jewel_ minimization problem from prior information on vertices degrees.</p></a></li>
<li><a href='#evaluatePerformance'><p>Evaluation of graph estimation method's performance if the true graph is known.</p></a></li>
<li><a href='#generateData_rewire'><p>Generate a set of scale-free graphs and corresponding datasets (using the graphs as their Gaussian graphical models)</p></a></li>
<li><a href='#jewel'><p>Estimate Gaussian graphical models from multiple datasets</p></a></li>
<li><a href='#jewel_inner'><p>Estimate Gaussian graphical models from multiple datasets</p></a></li>
<li><a href='#removeDiagonal'><p>Removing diagonal from a matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Graphical Models Estimation from Multiple Sources</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates networks of conditional dependencies (Gaussian graphical models) from multiple classes of data (similar but not exactly, i.e. measurements on different equipment, in different locations or for various sub-types). Package also allows to generate simulation data and evaluate the performance. Implementation of the method described in Angelini, De Canditiis and Plaksienko (2022) &lt;<a href="https://doi.org/10.3390%2Fmath10213983">doi:10.3390/math10213983</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, matrixcalc, MASS, SMUT, igraph, parallel, purrr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/annaplaksienko/jewel">https://github.com/annaplaksienko/jewel</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-21 21:48:46 UTC; annapla</td>
</tr>
<tr>
<td>Author:</td>
<td>Anna Plaksienko <a href="https://orcid.org/0000-0001-9607-057X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Claudia Angelini <a href="https://orcid.org/0000-0001-8350-8464"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Daniela De Canditiis
    <a href="https://orcid.org/0000-0002-3022-3411"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anna Plaksienko &lt;anna@plaxienko.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-22 21:20:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='addZeroDiagonal'>Adding zero diagonal to a matrix</h2><span id='topic+addZeroDiagonal'></span>

<h3>Description</h3>

<p>Function adds zero diagonal to <code>(p-1)</code> by <code>p</code> matrix and returns <code>p</code> by <code>p</code> matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addZeroDiagonal(M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addZeroDiagonal_+3A_m">M</code></td>
<td>
<p>a matrix to which you need to add zero diagonal</p>
</td></tr>
</table>

<hr>
<h2 id='constructWeights'>Construct weights for _jewel_ minimization problem from prior information on vertices degrees.</h2><span id='topic+constructWeights'></span>

<h3>Description</h3>

<p>Function takes a numerical vector of vertices degrees and constructs weights with the rule <code>W_ij = 1 / sqrt(d_i * d_j)</code> and then the whole matrix is normilized by the maximum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constructWeights(d, K = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="constructWeights_+3A_d">d</code></td>
<td>
<p>either one numerical vector or a list of <code>K</code> numerical vectors 
of length <code>p</code> with user-provided degrees of vertices for each class. 
If there is only one vector, we assume degrees are the same for all <code>K</code> classes. 
In that case parameter <code>K</code> (number of classes) must be provided.
Note that for successful _jewel_ estimation true degrees are not necessary: 
for example, user can provide a vector where known hubs have degree 10 
and the rest of the vertices have degree 1.</p>
</td></tr>
<tr><td><code id="constructWeights_+3A_k">K</code></td>
<td>
<p>number of classes (i.e. datasets, i.e. desired graphs). By default it is length(d).
In length(d) = 1, <code>K</code> must be provided by the user.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>W - a list of <code>K</code> numeric matrices of the size <code>p</code> by <code>p</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
K &lt;- 3
p &lt;- 50
n &lt;- 20
data &lt;- generateData_rewire(K = K, p = p, n = n, ncores = 1, verbose = FALSE)
G_list_true &lt;- data$Graphs
true_degrees &lt;- rowSums(G_list_true[[1]])
cut &lt;- sort(true_degrees, decreasing = TRUE)[ceiling(p * 0.03)]
apriori_hubs &lt;- ifelse(true_degrees &gt;= cut, 10, 1)
W &lt;- constructWeights(apriori_hubs, K = K)
}
</code></pre>

<hr>
<h2 id='evaluatePerformance'>Evaluation of graph estimation method's performance if the true graph is known.</h2><span id='topic+evaluatePerformance'></span>

<h3>Description</h3>

<p>Function compares adjacency matrices of the true and estimated simple graphs and calculates the number of true positives (correctly estimated edges), true negatives (correctly estimated absence of edges), false positives (edges present in the estimator but not in the true graph) and false negatives (failure to identify an edge).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluatePerformance(G, G_hat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluatePerformance_+3A_g">G</code></td>
<td>
<p>true graph's adjacency matrix.</p>
</td></tr>
<tr><td><code id="evaluatePerformance_+3A_g_hat">G_hat</code></td>
<td>
<p>estimated graph's adjacency matrix. Must have the same dimensions as <code>G</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>performance - a numeric vector of length 4 with TP, TN, FP, FN.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
K &lt;- 3
p &lt;- 50
n &lt;- 20
data &lt;- generateData_rewire(K = K, p = p, n = n, ncores = 1, verbose = FALSE)
G_common_true &lt;- data$CommonGraph
X &lt;- data$Data
res &lt;- jewel(X, lambda1 = 0.25)
G_common_est &lt;- res$CommonG
evaluatePerformance(G = G_common_true, G_hat = G_common_est)
}
</code></pre>

<hr>
<h2 id='generateData_rewire'>Generate a set of scale-free graphs and corresponding datasets (using the graphs as their Gaussian graphical models)</h2><span id='topic+generateData_rewire'></span>

<h3>Description</h3>

<p>Function first generates <code>K</code> scale-free graphs with <code>p</code> vertices. They have the same order and degree distribution and share most of the edges, but some edges may vary (user can control how many).
Function then generates corresponding precision and covariance matrices, all of the size <code>p</code> by <code>p</code> (see the paper for the details of the procedure).
Then for each <code>l</code>-th element of vector <code>n</code> it generates <code>K</code> data matrices, each of the size <code>n_l</code> by <code>p</code>, 
i.e., for the same underlying graphs we can generate several sets of <code>K</code> datasets with different sample sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateData_rewire(
  K,
  p,
  n,
  power = 1,
  m = 1,
  perc = 0.05,
  int = NULL,
  ncores = NULL,
  makePlot = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateData_rewire_+3A_k">K</code></td>
<td>
<p>number of graphs/data matrices.</p>
</td></tr>
<tr><td><code id="generateData_rewire_+3A_p">p</code></td>
<td>
<p>number of nodes in the true graphs.</p>
</td></tr>
<tr><td><code id="generateData_rewire_+3A_n">n</code></td>
<td>
<p>a numerical vector of the sample sizes for each desired set of 
<code>K</code> data matrices. Can be a vector of one element if the user wishes to 
obtain only one dataset of <code>K</code> matrices.</p>
</td></tr>
<tr><td><code id="generateData_rewire_+3A_power">power</code></td>
<td>
<p>a number, power of preferential attachment for the Barabasi-Albert 
algorithm for the generation of the scale-free graph. Bigger number means 
more connected hubs. The default value is 1.</p>
</td></tr>
<tr><td><code id="generateData_rewire_+3A_m">m</code></td>
<td>
<p>number of edges to add at each step of Barabasi-Albert algorithm 
for generation of the scale-free graph. The default value is 1.</p>
</td></tr>
<tr><td><code id="generateData_rewire_+3A_perc">perc</code></td>
<td>
<p>a number, tuning parameter for the difference between graphs. 
Number of trials to perform in the rewiring procedure of the first graph is 
<code>p * perc</code>. Bigger the number, more different are the graphs.</p>
</td></tr>
<tr><td><code id="generateData_rewire_+3A_int">int</code></td>
<td>
<p>a vector of two numbers, <code>a</code> and <code>b</code>. Entries of 
precision matrices are sampled from the uniform distribution on the interval 
<code>[-b, -a] + [a, b]</code>. The default values are <code>a = 0.2, b = 0.8</code>.</p>
</td></tr>
<tr><td><code id="generateData_rewire_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to use in parallel data generation. 
If <code>NULL</code>, set to <code class="reqn">\#physical cores - 1</code>.</p>
</td></tr>
<tr><td><code id="generateData_rewire_+3A_makeplot">makePlot</code></td>
<td>
<p>If makePlot = FALSE, plotting of the generated graphs is 
disabled. The default value is TRUE.</p>
</td></tr>
<tr><td><code id="generateData_rewire_+3A_verbose">verbose</code></td>
<td>
<p>If verbose = FALSE, tracing information printing is disabled. 
The default value is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The following list is returned
</p>

<ul>
<li> <p><code>Graphs</code> – a list of adjacency matrices of the <code>K</code> generated graphs.
</p>
</li>
<li> <p><code>CommomGraph</code> - a matrix, common part (intersection) of the <code>K</code> generated graphs.
</p>
</li>
<li> <p><code>Data</code> - a list of lists, for each sample size of the input vector <code>n</code> one obtains <code>K</code> data matrices, each of the size <code>n_l</code> by <code>p</code>.
</p>
</li>
<li> <p><code>Sigma</code> - a list of <code>K</code> covariance matrices of the size <code>p</code> by <code>p</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- generateData_rewire(K = 3, p = 50, n = 20, ncores = 1, verbose = FALSE)
</code></pre>

<hr>
<h2 id='jewel'>Estimate Gaussian graphical models from multiple datasets</h2><span id='topic+jewel'></span>

<h3>Description</h3>

<p>This function estimates Gaussian graphical models (i.e. networks of conditional dependencies, direct connections between variables) given multiple datasets. 
We assume that datasets contain measurements of the same variables collected under different conditions (different equipment, locations, even sub-types of disease).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jewel(
  X,
  lambda1,
  lambda2 = NULL,
  Theta = NULL,
  W = NULL,
  tol = 0.01,
  maxIter = 10000,
  stability = FALSE,
  stability_nsubsets = 25,
  stability_frac = 0.8,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jewel_+3A_x">X</code></td>
<td>
<p>a list of <code>K</code> numeric data matrices of <code>n_k</code> samples and 
<code>p</code> variables (<code>n_k</code> can be different for each matrix).</p>
</td></tr>
<tr><td><code id="jewel_+3A_lambda1">lambda1</code></td>
<td>
<p>a number, first regularization parameter (of the common penalty).</p>
</td></tr>
<tr><td><code id="jewel_+3A_lambda2">lambda2</code></td>
<td>
<p>an optional number, second regularization parameter 
(of the class-specific penalty). If NULL, set to <code>lambda_2 = lambda_1 * 1.4</code></p>
</td></tr>
<tr><td><code id="jewel_+3A_theta">Theta</code></td>
<td>
<p>an optional list of <code>K</code> regression coefficient matrices 
of the size <code>p</code> by <code>p</code>. User-provided initialization can be used 
for warm-start procedures. If NULL, initialized as all zeros.</p>
</td></tr>
<tr><td><code id="jewel_+3A_w">W</code></td>
<td>
<p>an optional list of <code>K</code> weights matrices of the size 
<code>p</code> by <code>p</code>. User-provided initialization can be used when some 
vertices are believed to be hubs. If NULL, initialized as all ones.</p>
</td></tr>
<tr><td><code id="jewel_+3A_tol">tol</code></td>
<td>
<p>an optional number, convergence threshold controlling the relative 
error between iterations. The default value is 0.01.</p>
</td></tr>
<tr><td><code id="jewel_+3A_maxiter">maxIter</code></td>
<td>
<p>an optional number, maximum allowed number of iterations. 
The default value is 10 000.</p>
</td></tr>
<tr><td><code id="jewel_+3A_stability">stability</code></td>
<td>
<p>if stability = TRUE, stability selection procedure to reduce 
the number of false positives will be applied. <code>n_k / 2</code> samples are 
randomly chosen in each dataset <code>stability_nsubsets</code> times and then 
__jewel__ method is applied to each subset. In the final estimate, we include 
only the edges that appear in at least <code>stability_frac</code> proportion of the subsets. 
By default this procedure is disabled since it increases the running time.</p>
</td></tr>
<tr><td><code id="jewel_+3A_stability_nsubsets">stability_nsubsets</code></td>
<td>
<p>an optional number, how many times to subsample 
datasets and apply __jewel__ for stability selection procedure. The default value is 25.</p>
</td></tr>
<tr><td><code id="jewel_+3A_stability_frac">stability_frac</code></td>
<td>
<p>an optional number, in what proportion of the stability 
results on subsampled data an edge has to be present to be included into the 
final estimate. The default value is 0.8.</p>
</td></tr>
<tr><td><code id="jewel_+3A_verbose">verbose</code></td>
<td>
<p>if verbose = FALSE, tracing information printing is disabled. 
The default value is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The following list is returned
</p>

<ul>
<li> <p><code>CommonG</code> - an adjacency matrix of the common estimated graph (intersection of <code>K</code> estimated graphs).
</p>
</li>
<li> <p><code>G_list</code> - a list of <code>K</code> adjacency matrices for each estimated graph.
</p>
</li>
<li> <p><code>Theta</code> - a list of <code>K</code> estimated covariance matrices (when stability selection is disabled).
</p>
</li>
<li> <p><code>BIC</code> – a number, value of Bayesian information criterion for resulting graphs (when stability selection is disabled).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>{
K &lt;- 3
p &lt;- 50
n &lt;- 20
data &lt;- generateData_rewire(K = K, p = p, n = n, ncores = 1, verbose = FALSE)
G_list_true &lt;- data$Graphs
X &lt;- data$Data
true_degrees &lt;- rowSums(G_list_true[[1]])
cut &lt;- sort(true_degrees, decreasing = TRUE)[ceiling(p * 0.03)]
apriori_hubs &lt;- ifelse(true_degrees &gt;= cut, 10, 1)
W &lt;- constructWeights(apriori_hubs, K = K)
res &lt;- jewel(X, lambda1 = 0.25, W = W, verbose = FALSE)
}
</code></pre>

<hr>
<h2 id='jewel_inner'>Estimate Gaussian graphical models from multiple datasets</h2><span id='topic+jewel_inner'></span>

<h3>Description</h3>

<p>This function estimates Gaussian graphical models (i.e. networks of conditional dependencies, direct connections between variables) given several datasets. 
We assume that datasets contain measurements of the same variables collected under different conditions (different equipment, locations, even sub-types of disease).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jewel_inner(
  X,
  lambda1,
  lambda2 = NULL,
  Theta = NULL,
  W = NULL,
  tol = 0.01,
  maxIter = 10000,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jewel_inner_+3A_x">X</code></td>
<td>
<p>a list of <code>K</code> numeric data matrices of <code>n_k</code> samples and <code>p</code> variables (<code>n_k</code> can be different for each matrix).</p>
</td></tr>
<tr><td><code id="jewel_inner_+3A_lambda1">lambda1</code></td>
<td>
<p>a number, first regularization parameter (of the common penalty).</p>
</td></tr>
<tr><td><code id="jewel_inner_+3A_lambda2">lambda2</code></td>
<td>
<p>an optional number, second regularization parameter (of the class-specific penalty). If NULL, set to <code>lambda_2 = lambda_1 * 1.4</code></p>
</td></tr>
<tr><td><code id="jewel_inner_+3A_theta">Theta</code></td>
<td>
<p>an optional list of <code>K</code> regression coefficient matrices of the size <code>p</code> by <code>p</code>. User-provided initialization can be used for warm-start procedures. If NULL, initialized as all zeros.</p>
</td></tr>
<tr><td><code id="jewel_inner_+3A_w">W</code></td>
<td>
<p>an optional list of <code>K</code> weights matrices of the size <code>p</code> by <code>p</code>. User-provided initialization can be used when some vertices are believed to be hubs. If NULL, initialized as all ones.</p>
</td></tr>
<tr><td><code id="jewel_inner_+3A_tol">tol</code></td>
<td>
<p>an optional number, convergence threshold controlling the relative error between iterations. The default value is 0.01.</p>
</td></tr>
<tr><td><code id="jewel_inner_+3A_maxiter">maxIter</code></td>
<td>
<p>an optional number, maximum allowed number of iterations. The default value is 10 000.</p>
</td></tr>
<tr><td><code id="jewel_inner_+3A_verbose">verbose</code></td>
<td>
<p>if verbose = FALSE, tracing information printing is disabled. The default value is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The following list is returned
</p>

<ul>
<li> <p><code>CommonG</code> - an adjacency matrix of the common estimated graph (intersection of <code>K</code> estimated graphs).
</p>
</li>
<li> <p><code>G_list</code> - a list of <code>K</code> adjacency matrices for each estimated graph.
</p>
</li>
<li> <p><code>Theta</code> - a list of <code>K</code> estimated covariance matrices.
</p>
</li>
<li> <p><code>BIC</code> – a number, value of Bayesian information criterion for resulting graphs.
</p>
</li></ul>


<hr>
<h2 id='removeDiagonal'>Removing diagonal from a matrix</h2><span id='topic+removeDiagonal'></span>

<h3>Description</h3>

<p>Function removes a diagonal from a square <code>p</code> by <code>p</code> matrix
and returns <code>(p-1)</code> by <code>p</code> matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeDiagonal(M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="removeDiagonal_+3A_m">M</code></td>
<td>
<p>a matrix in which you need to remove a diagonal</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
