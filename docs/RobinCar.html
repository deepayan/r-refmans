<!DOCTYPE html><html><head><title>Help for package RobinCar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RobinCar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#car_pb'><p>Generate permuted block treatment assignments</p></a></li>
<li><a href='#car_ps'><p>Generate Pocock-Simon minimization treatment assignments</p></a></li>
<li><a href='#car_sr'><p>Generate simple randomization treatment assignments</p></a></li>
<li><a href='#data_gen'><p>Data generation function from JRSS-B paper</p></a></li>
<li><a href='#data_gen2'><p>Data generation function from covariate adjusted log-rank paper</p></a></li>
<li><a href='#print.CalibrationResult'><p>Print calibration result</p></a></li>
<li><a href='#print.ContrastResult'><p>Print contrast result</p></a></li>
<li><a href='#print.GLMModelResult'><p>Print glm model result</p></a></li>
<li><a href='#print.LinModelResult'><p>Print linear model result</p></a></li>
<li><a href='#print.TTEResult'><p>Print TTE result</p></a></li>
<li><a href='#robincar_calibrate'><p>Perform linear or joint calibration</p></a></li>
<li><a href='#robincar_contrast'><p>Estimate a treatment contrast</p></a></li>
<li><a href='#robincar_covhr'><p>Covariate-adjusted estimators for time to event data</p></a></li>
<li><a href='#robincar_coxscore'><p>Robust cox score adjustment</p></a></li>
<li><a href='#robincar_glm'><p>Covariate adjustment using generalized linear working model</p></a></li>
<li><a href='#robincar_linear'><p>Covariate adjustment using linear working model</p></a></li>
<li><a href='#robincar_logrank'><p>Robust (potentially stratified) logrank adjustment</p></a></li>
<li><a href='#robincar_SL'><p>BETA: Covariate adjustment using working models from the super learner libraries</p>
through the AIPW package with cross-fitting.</a></li>
<li><a href='#robincar_SL_median'><p>BETA: Covariate adjustment using working models from the super learner libraries</p>
through the AIPW package with cross-fitting, with median adjustment.</a></li>
<li><a href='#robincar_tte'><p>Covariate adjustment for time to event data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Robust Estimation and Inference in Covariate-Adaptive
Randomization</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs robust estimation and inference when using covariate adjustment and/or covariate-adaptive randomization in randomized controlled trials.
    Ting Ye, Jun Shao, Yanyao Yi, Qinyuan Zhao (2023) &lt;<a href="https://doi.org/10.1080%2F01621459.2022.2049278">doi:10.1080/01621459.2022.2049278</a>&gt;.
    Ting Ye, Marlena Bannick, Yanyao Yi, Jun Shao (2023) &lt;<a href="https://doi.org/10.1080%2F24754269.2023.2205802">doi:10.1080/24754269.2023.2205802</a>&gt;.
    Ting Ye, Jun Shao, Yanyao Yi (2023) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasad045">doi:10.1093/biomet/asad045</a>&gt;.
    Marlena Bannick, Jun Shao, Jingyi Liu, Yu Du, Yanyao Yi, Ting Ye (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2306.10213">doi:10.48550/arXiv.2306.10213</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, magrittr, tidyr, emulator, numDeriv, tidyverse, stats,
rlang, survival, fastDummies, data.table, broom, SuperLearner,
AIPW, MASS</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, ranger, forcats, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-20 20:03:54 UTC; marlena</td>
</tr>
<tr>
<td>Author:</td>
<td>Marlena Bannick <a href="https://orcid.org/0000-0001-6279-5978"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Ting Ye [aut],
  Yanyao Yi [aut],
  Faith Bian [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marlena Bannick &lt;mnorwood@uw.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-20 20:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='car_pb'>Generate permuted block treatment assignments</h2><span id='topic+car_pb'></span>

<h3>Description</h3>

<p>Generate permuted block treatment assignments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>car_pb(z, trt_label, trt_alc, blocksize = 4L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="car_pb_+3A_z">z</code></td>
<td>
<p>The car_strata design matrix, as a data frame with factor variables</p>
</td></tr>
<tr><td><code id="car_pb_+3A_trt_label">trt_label</code></td>
<td>
<p>Treatment label</p>
</td></tr>
<tr><td><code id="car_pb_+3A_trt_alc">trt_alc</code></td>
<td>
<p>Treatment allocation vector</p>
</td></tr>
<tr><td><code id="car_pb_+3A_blocksize">blocksize</code></td>
<td>
<p>Permuted block blocksize</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of treatment assignments with labels from the 'trt_label' argument, based on stratified permuted block randomization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create car_strata variables
library(fastDummies)
library(dplyr)

x &lt;- runif(100)
z &lt;- cut(x, breaks=c(0, 0.25, 0.5, 0.75, 1.0))
z &lt;- dummy_cols(z) %&gt;%
     mutate(across(where(is.numeric), as.factor))

car_pb(z[, 2:5], c(0, 1, 2), trt_alc=c(1/4, 1/2, 1/4), blocksize=4L)

</code></pre>

<hr>
<h2 id='car_ps'>Generate Pocock-Simon minimization treatment assignments</h2><span id='topic+car_ps'></span>

<h3>Description</h3>

<p>Generate Pocock-Simon minimization treatment assignments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>car_ps(z, treat, ratio, imb_measure, p_bc = 0.8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="car_ps_+3A_z">z</code></td>
<td>
<p>The car_strata design matrix</p>
</td></tr>
<tr><td><code id="car_ps_+3A_treat">treat</code></td>
<td>
<p>A vector of length k (the number of treatment arms), which labels the treatment arms being compared.</p>
</td></tr>
<tr><td><code id="car_ps_+3A_ratio">ratio</code></td>
<td>
<p>A vector of length k (the number of treatment arms), which indicates the allocation ratio, e.g., c(1,1,1) for equal allocation with three treatment arms.</p>
</td></tr>
<tr><td><code id="car_ps_+3A_imb_measure">imb_measure</code></td>
<td>
<p>What measure of imbalance should be minimzed during randomization &ndash; either &quot;Range&quot; or &quot;SD&quot;</p>
</td></tr>
<tr><td><code id="car_ps_+3A_p_bc">p_bc</code></td>
<td>
<p>The biased probability, i.e., the probability of assigning each patient to the arm that minimizes the imbalance. Default is 0.8</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>res</dt><dd><p>treatment assignment vector</p>
</dd>
</dl>

<p>A vector of treatment assignments with labels from the &lsquo;treat' argument, based on Pocock-Simon&rsquo;s minimization.
</p>


<h3>Author(s)</h3>

<p>Ting Ye Yanyao Yi
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create car_strata variables
library(fastDummies)
library(dplyr)

x &lt;- runif(100)
z &lt;- cut(x, breaks=c(0, 0.25, 0.5, 0.75, 1.0))
z &lt;- dummy_cols(z)
A &lt;- car_ps(
  z=z[, 2:5],
  treat=c(0, 1, 2),
  ratio=c(1, 1, 1),
  imb_measure="Range"
)

</code></pre>

<hr>
<h2 id='car_sr'>Generate simple randomization treatment assignments</h2><span id='topic+car_sr'></span>

<h3>Description</h3>

<p>Generate simple randomization treatment assignments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>car_sr(n, p_trt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="car_sr_+3A_n">n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code id="car_sr_+3A_p_trt">p_trt</code></td>
<td>
<p>Proportion allotted to treatment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of treatment assignments as 0's and 1's based on simple randomization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>car_sr(10, p_trt=0.4)

</code></pre>

<hr>
<h2 id='data_gen'>Data generation function from JRSS-B paper</h2><span id='topic+data_gen'></span>

<h3>Description</h3>

<p>Data generation function from JRSS-B paper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_gen(
  n,
  theta,
  randomization,
  p_trt,
  case = c("case1", "case2", "case3", "case4", "case5")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_gen_+3A_n">n</code></td>
<td>
<p>total number of subjects to be generated</p>
</td></tr>
<tr><td><code id="data_gen_+3A_theta">theta</code></td>
<td>
<p>true treatment effect</p>
</td></tr>
<tr><td><code id="data_gen_+3A_randomization">randomization</code></td>
<td>
<p>randomization method in c(&quot;SR&quot;,&quot;CABC&quot;,&quot;permuted_block&quot;,&quot;minimization&quot;,&quot;urn&quot;)</p>
</td></tr>
<tr><td><code id="data_gen_+3A_p_trt">p_trt</code></td>
<td>
<p>proportion of treatment arm</p>
</td></tr>
<tr><td><code id="data_gen_+3A_case">case</code></td>
<td>
<p>simulation case in the paper</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the following columns:
</p>
<table>
<tr><td><code>t</code></td>
<td>
<p>event time</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>event indicator</p>
</td></tr>
<tr><td><code>I1</code></td>
<td>
<p>assignment to treatment group 1</p>
</td></tr>
<tr><td><code>I0</code></td>
<td>
<p>assignment to treatment group 0</p>
</td></tr>
<tr><td><code>model_z1</code>, <code>model_z2</code></td>
<td>
<p>covariates</p>
</td></tr>
<tr><td><code>car_strata1</code>, <code>...</code></td>
<td>
<p>strata variables</p>
</td></tr>
</table>

<hr>
<h2 id='data_gen2'>Data generation function from covariate adjusted log-rank paper</h2><span id='topic+data_gen2'></span>

<h3>Description</h3>

<p>Data generation function from covariate adjusted log-rank paper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_gen2(
  n,
  theta,
  randomization,
  p_trt,
  case = c("case1", "case2", "case3", "case4"),
  blocksize = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_gen2_+3A_n">n</code></td>
<td>
<p>total number of subjects to be generated</p>
</td></tr>
<tr><td><code id="data_gen2_+3A_theta">theta</code></td>
<td>
<p>true treatment effect</p>
</td></tr>
<tr><td><code id="data_gen2_+3A_randomization">randomization</code></td>
<td>
<p>randomization method in c(&quot;SR&quot;,&quot;CABC&quot;,&quot;permuted_block&quot;,&quot;minimization&quot;,&quot;urn&quot;)</p>
</td></tr>
<tr><td><code id="data_gen2_+3A_p_trt">p_trt</code></td>
<td>
<p>proportion of treatment arm</p>
</td></tr>
<tr><td><code id="data_gen2_+3A_case">case</code></td>
<td>
<p>simulation case in the paper</p>
</td></tr>
<tr><td><code id="data_gen2_+3A_blocksize">blocksize</code></td>
<td>
<p>block size for permuted block design</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the following columns:
</p>
<table>
<tr><td><code>t</code></td>
<td>
<p>event time</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>event indicator</p>
</td></tr>
<tr><td><code>I1</code></td>
<td>
<p>assignment to treatment group 1</p>
</td></tr>
<tr><td><code>I0</code></td>
<td>
<p>assignment to treatment group 0</p>
</td></tr>
<tr><td><code>model_w3</code></td>
<td>
<p>covariates</p>
</td></tr>
<tr><td><code>car_strata1</code>, <code>...</code></td>
<td>
<p>strata variables</p>
</td></tr>
</table>

<hr>
<h2 id='print.CalibrationResult'>Print calibration result</h2><span id='topic+print.CalibrationResult'></span>

<h3>Description</h3>

<p>Print calibration result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CalibrationResult'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.CalibrationResult_+3A_x">x</code></td>
<td>
<p>A GLMModel result. If you'd like to calibrate a linear
adjustment, use 'robincar_glm' instead of 'robincar_linear'.</p>
</td></tr>
<tr><td><code id="print.CalibrationResult_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints the treatment mean estimates (and variances) based on a calibration on top of a
GLM working model, along with the settings used. See <a href="#topic+robincar_calibrate">RobinCar::robincar_calibrate()</a>.
</p>

<hr>
<h2 id='print.ContrastResult'>Print contrast result</h2><span id='topic+print.ContrastResult'></span>

<h3>Description</h3>

<p>Print contrast result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ContrastResult'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ContrastResult_+3A_x">x</code></td>
<td>
<p>A ContrastResult object</p>
</td></tr>
<tr><td><code id="print.ContrastResult_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints estimates (and variances) of treatment contrasts based on a linear or GLM working model,
along with the settings used. See <a href="#topic+robincar_contrast">RobinCar::robincar_contrast()</a>
</p>

<hr>
<h2 id='print.GLMModelResult'>Print glm model result</h2><span id='topic+print.GLMModelResult'></span>

<h3>Description</h3>

<p>Print glm model result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GLMModelResult'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.GLMModelResult_+3A_x">x</code></td>
<td>
<p>A GLMModelResult object</p>
</td></tr>
<tr><td><code id="print.GLMModelResult_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints the treatment mean estimates (and variances) based on a GLM working model,
along with the settings used. See <a href="#topic+robincar_glm">RobinCar::robincar_glm()</a>.
</p>

<hr>
<h2 id='print.LinModelResult'>Print linear model result</h2><span id='topic+print.LinModelResult'></span>

<h3>Description</h3>

<p>Print linear model result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LinModelResult'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.LinModelResult_+3A_x">x</code></td>
<td>
<p>A LinModelResult object</p>
</td></tr>
<tr><td><code id="print.LinModelResult_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints the treatment mean estimates (and variances) based on a linear working model,
along with the settings used. See <a href="#topic+robincar_linear">RobinCar::robincar_linear()</a>.
</p>

<hr>
<h2 id='print.TTEResult'>Print TTE result</h2><span id='topic+print.TTEResult'></span>

<h3>Description</h3>

<p>Print TTE result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TTEResult'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.TTEResult_+3A_x">x</code></td>
<td>
<p>A TTEResult object</p>
</td></tr>
<tr><td><code id="print.TTEResult_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints results of time-to-event covariate adjusted analyses including covariate-adjusted (stratified) logrank,
robust Cox score, and covariate-adjusted hazard ratio. Prints summary statistics about number of observations and events, possibly by strata,
and the test statistics and/or estimates, and p-values. See <a href="#topic+robincar_tte">RobinCar::robincar_tte()</a> and <a href="#topic+robincar_covhr">RobinCar::robincar_covhr()</a>.
</p>

<hr>
<h2 id='robincar_calibrate'>Perform linear or joint calibration</h2><span id='topic+robincar_calibrate'></span>

<h3>Description</h3>

<p>Uses linear or joint calibration to &quot;calibrate&quot; the estimates from a linear or GLM-type adjustment.
Linear calibration fits a linear model with treatment (and treatment-by-covariate interactions) and with the predicted <code class="reqn">\hat{\bm \mu}(X_i) = (\hat{\mu}_1(X_i), \dots, \hat{\mu}_K(X_i))</code> as constructed covariates where <code class="reqn">K</code> is the number of treatment groups;
joint calibration also includes <code class="reqn">Z_i</code> the strata variables as covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robincar_calibrate(result, joint = FALSE, add_x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robincar_calibrate_+3A_result">result</code></td>
<td>
<p>A GLMModelResult</p>
</td></tr>
<tr><td><code id="robincar_calibrate_+3A_joint">joint</code></td>
<td>
<p>If true, then performs joint calibration
with the <code class="reqn">\hat{\bm \mu}(X_i)</code> and strata <code class="reqn">Z_i</code>
to achieve universality and efficiency gain
rather than just linear calibration that uses <code class="reqn">\hat{\bm \mu}(X_i)</code>.</p>
</td></tr>
<tr><td><code id="robincar_calibrate_+3A_add_x">add_x</code></td>
<td>
<p>Additional x to use in the calibration. Must have been in
the original dataset that robincar_glm was called on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A result object that has the same structure as <a href="#topic+robincar_glm">RobinCar::robincar_glm()</a>, with the argument 'result' included as &quot;original&quot; in the list.
</p>

<hr>
<h2 id='robincar_contrast'>Estimate a treatment contrast</h2><span id='topic+robincar_contrast'></span>

<h3>Description</h3>

<p>Estimate a treatment contrast using the result of <a href="#topic+robincar_linear">RobinCar::robincar_linear()</a>, <a href="#topic+robincar_glm">RobinCar::robincar_glm()</a>, or <a href="#topic+robincar_SL">RobinCar::robincar_SL()</a> using
the delta method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robincar_contrast(result, contrast_h, contrast_dh = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robincar_contrast_+3A_result">result</code></td>
<td>
<p>A LinModelResult or GLMModelResult</p>
</td></tr>
<tr><td><code id="robincar_contrast_+3A_contrast_h">contrast_h</code></td>
<td>
<p>An optional function to specify a desired contrast</p>
</td></tr>
<tr><td><code id="robincar_contrast_+3A_contrast_dh">contrast_dh</code></td>
<td>
<p>An optional jacobian function for the contrast</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A contrast object which has the following attributes:
</p>
<table>
<tr><td><code>result</code></td>
<td>
<p>A <a href="dplyr.html#topic+tibble">dplyr::tibble()</a> with the label of the treatment contrast (e.g., 1 vs. 0), the estimate of the treatment contrast, estimated SE, and p-value based on a z-test with estimate and SE.</p>
</td></tr>
<tr><td><code>varcov</code></td>
<td>
<p>The variance-covariance matrix for the treatment contrast estimates.</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>List of model settings used for the contrast.</p>
</td></tr>
</table>

<hr>
<h2 id='robincar_covhr'>Covariate-adjusted estimators for time to event data</h2><span id='topic+robincar_covhr'></span>

<h3>Description</h3>

<p>Estimate a covariate-adjusted hazard ratio ('adj_method=&quot;CL&quot;'),
or a covariate-adjusted stratified hazard ratio ('adj_method=&quot;CSL&quot;').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robincar_covhr(
  df,
  treat_col,
  response_col,
  event_col,
  car_strata_cols = NULL,
  covariate_cols = NULL,
  p_trt = 0.5,
  ref_arm = NULL,
  car_scheme = "simple",
  adj_method = "CL",
  interval = c(-10, 10)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robincar_covhr_+3A_df">df</code></td>
<td>
<p>A data.frame with the required columns</p>
</td></tr>
<tr><td><code id="robincar_covhr_+3A_treat_col">treat_col</code></td>
<td>
<p>Name of column in df with treatment variable</p>
</td></tr>
<tr><td><code id="robincar_covhr_+3A_response_col">response_col</code></td>
<td>
<p>Name of the column in df with response variable</p>
</td></tr>
<tr><td><code id="robincar_covhr_+3A_event_col">event_col</code></td>
<td>
<p>Name of column in df with event indicator
(0/FALSE=no event, 1/TRUE=event)</p>
</td></tr>
<tr><td><code id="robincar_covhr_+3A_car_strata_cols">car_strata_cols</code></td>
<td>
<p>Names of columns in df with car_strata variables</p>
</td></tr>
<tr><td><code id="robincar_covhr_+3A_covariate_cols">covariate_cols</code></td>
<td>
<p>Names of columns in df with covariate variables</p>
</td></tr>
<tr><td><code id="robincar_covhr_+3A_p_trt">p_trt</code></td>
<td>
<p>Treatment allocation ratio for the reference arm.</p>
</td></tr>
<tr><td><code id="robincar_covhr_+3A_ref_arm">ref_arm</code></td>
<td>
<p>Reference arm of the treatment group, defaults to NULL,
which results in using the first element of 'unique(data[, treat_col])'.</p>
</td></tr>
<tr><td><code id="robincar_covhr_+3A_car_scheme">car_scheme</code></td>
<td>
<p>Name of the type of covariate-adaptive randomization scheme. One of: &quot;simple&quot;, &quot;pocock-simon&quot;, &quot;biased-coin&quot;, &quot;permuted-block&quot;.</p>
</td></tr>
<tr><td><code id="robincar_covhr_+3A_adj_method">adj_method</code></td>
<td>
<p>Adjustment method (one of &quot;CL&quot;, &quot;CSL&quot;)</p>
</td></tr>
<tr><td><code id="robincar_covhr_+3A_interval">interval</code></td>
<td>
<p>Interval for uniroot function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with attribute named &quot;result&quot;, which lists:
</p>
<table>
<tr><td><code>theta_L</code></td>
<td>
<p>estimate of the hazard ratio</p>
</td></tr>
<tr><td><code>se_theta_L</code></td>
<td>
<p>SE estimate of the hazard ratio</p>
</td></tr>
<tr><td><code>theta_CL</code></td>
<td>
<p>estimate of the covariate-adjusted hazard ratio</p>
</td></tr>
<tr><td><code>se_theta_CL</code></td>
<td>
<p>SE estimate of the covariate-adjusted hazard ratio</p>
</td></tr>
</table>
<p>Other attributes are the settings used, data attributes, and the original data frame supplied by the user.
</p>

<hr>
<h2 id='robincar_coxscore'>Robust cox score adjustment</h2><span id='topic+robincar_coxscore'></span>

<h3>Description</h3>

<p>Robust cox score adjustment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robincar_coxscore(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robincar_coxscore_+3A_...">...</code></td>
<td>
<p>Arguments to robincar_tte, other than 'adj_method'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A result object with the following attributes:
</p>
<table>
<tr><td><code>result</code></td>
<td>
<p>A list: &quot;statistic&quot; is the robust Cox score test statistic which can be used to obtain p-values; &quot;U&quot; and &quot;se&quot; are the numerator and denominator of the test statistic, respectively.</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>The covariate adjustment settings used.</p>
</td></tr>
<tr><td><code>original_df</code></td>
<td>
<p>The dataset supplied by the user.</p>
</td></tr>
</table>

<hr>
<h2 id='robincar_glm'>Covariate adjustment using generalized linear working model</h2><span id='topic+robincar_glm'></span>

<h3>Description</h3>

<p>Estimate treatment-group-specific response means and (optionally)
treatment group contrasts using a generalized linear working model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robincar_glm(
  df,
  treat_col,
  response_col,
  formula = NULL,
  car_strata_cols = NULL,
  car_scheme = "simple",
  g_family = stats::gaussian,
  g_accuracy = 7,
  contrast_h = NULL,
  contrast_dh = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robincar_glm_+3A_df">df</code></td>
<td>
<p>A data.frame with the required columns</p>
</td></tr>
<tr><td><code id="robincar_glm_+3A_treat_col">treat_col</code></td>
<td>
<p>Name of column in df with treatment variable</p>
</td></tr>
<tr><td><code id="robincar_glm_+3A_response_col">response_col</code></td>
<td>
<p>Name of the column in df with response variable</p>
</td></tr>
<tr><td><code id="robincar_glm_+3A_formula">formula</code></td>
<td>
<p>The formula to use for adjustment specified using as.formula(&quot;...&quot;). This overrides car_strata_cols and covariate_cols.</p>
</td></tr>
<tr><td><code id="robincar_glm_+3A_car_strata_cols">car_strata_cols</code></td>
<td>
<p>Names of columns in df with car_strata variables</p>
</td></tr>
<tr><td><code id="robincar_glm_+3A_car_scheme">car_scheme</code></td>
<td>
<p>Name of the type of covariate-adaptive randomization scheme. One of: &quot;simple&quot;, &quot;pocock-simon&quot;, &quot;biased-coin&quot;, &quot;permuted-block&quot;.</p>
</td></tr>
<tr><td><code id="robincar_glm_+3A_g_family">g_family</code></td>
<td>
<p>Family that would be supplied to glm(...), e.g., binomial. If no link specified, will use default link, like behavior in glm.
If you wish to use a negative binomial working model with an unknown dispersion parameter, then use 'g_family=&quot;nb&quot;'.</p>
</td></tr>
<tr><td><code id="robincar_glm_+3A_g_accuracy">g_accuracy</code></td>
<td>
<p>Level of accuracy to check prediction un-biasedness.</p>
</td></tr>
<tr><td><code id="robincar_glm_+3A_contrast_h">contrast_h</code></td>
<td>
<p>An optional function to specify a desired contrast</p>
</td></tr>
<tr><td><code id="robincar_glm_+3A_contrast_dh">contrast_dh</code></td>
<td>
<p>An optional jacobian function for the contrast (otherwise use numerical derivative)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output is the AIPW estimator given by (for each treatment group <code class="reqn">a</code>):
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{n} \sum_{i=1}^{n} \hat{\mu}_a(X_i) + \frac{1}{n_a} \sum_{i:A_i=a} \{Y_i - \hat{\mu}(X_i)\}</code>
</p>

<p>where <code class="reqn">Y_i</code> is the outcome, <code class="reqn">A_i</code> is the treatment assignment, <code class="reqn">X_i</code> are the covariates, <code class="reqn">n_a = \sum_{i=1}^{n} A_i=a</code>,
and <code class="reqn">\hat{\mu}_a</code> is the estimated conditional mean function based on the GLM working model.
This working model has treatment <code class="reqn">a</code>-specific coefficients if 'adj_method' is &quot;heterogeneous&quot;. Otherwise, they are shared across the treatment arms.
Alternatively, if 'formula' is used, the working model can be specified according to the user.
</p>
<p>Importantly, the estimated variance accounts for misspecification of the working model, and for covariate-adaptive randomization.
</p>


<h3>Value</h3>

<p>If 'contrast_h' argument is used, outputs a 'main' and a 'contrast' object. The 'main' object has the following structure:
</p>
<table>
<tr><td><code>result</code></td>
<td>
<p>A <a href="dplyr.html#topic+tibble">dplyr::tibble()</a> with the treatment label, treatment mean estimate using AIPW, estimated SE, and p-value based on a z-test with estimate and SE.</p>
</td></tr>
<tr><td><code>varcov</code></td>
<td>
<p>The variance-covariance matrix for the treatment mean estimates.</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>List of model settings used in covariate adjustment.</p>
</td></tr>
<tr><td><code>original_df</code></td>
<td>
<p>The original dataset provided by the user.</p>
</td></tr>
<tr><td><code>mod</code></td>
<td>
<p>The fit from the <a href="stats.html#topic+glm">glm()</a> working model used for covariate adjustment.</p>
</td></tr>
<tr><td><code>mu_a</code></td>
<td>
<p>Predicted potential outcomes for each treatment category (columns) and individual (rows). These are the <code class="reqn">\hat{\mu}_a</code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code>g.estimate</code></td>
<td>
<p>The G-computation estimate based only on <code class="reqn">\frac{1}{n} \sum_{i=1}^{n} \hat{\mu}_a(X_i)</code>. This is equivalent to the AIPW estimate when a canonical link function is used.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Attributes about the dataset.</p>
</td></tr>
</table>
<p>The 'contrast' object has a structure that is documented in <a href="#topic+robincar_contrast">RobinCar::robincar_contrast()</a>.
</p>

<hr>
<h2 id='robincar_linear'>Covariate adjustment using linear working model</h2><span id='topic+robincar_linear'></span>

<h3>Description</h3>

<p>Estimate treatment-group-specific response means and (optionally)
treatment group contrasts using a linear working model for continuous outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robincar_linear(
  df,
  treat_col,
  response_col,
  car_strata_cols = NULL,
  covariate_cols = NULL,
  car_scheme = "simple",
  adj_method = "ANOVA",
  contrast_h = NULL,
  contrast_dh = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robincar_linear_+3A_df">df</code></td>
<td>
<p>A data.frame with the required columns</p>
</td></tr>
<tr><td><code id="robincar_linear_+3A_treat_col">treat_col</code></td>
<td>
<p>Name of column in df with treatment variable</p>
</td></tr>
<tr><td><code id="robincar_linear_+3A_response_col">response_col</code></td>
<td>
<p>Name of the column in df with response variable</p>
</td></tr>
<tr><td><code id="robincar_linear_+3A_car_strata_cols">car_strata_cols</code></td>
<td>
<p>Names of columns in df with car_strata variables</p>
</td></tr>
<tr><td><code id="robincar_linear_+3A_covariate_cols">covariate_cols</code></td>
<td>
<p>Names of columns in df with covariate variables. **If you want to include the strata variables as covariates also, add them here.**</p>
</td></tr>
<tr><td><code id="robincar_linear_+3A_car_scheme">car_scheme</code></td>
<td>
<p>Name of the type of covariate-adaptive randomization scheme. One of: &quot;simple&quot;, &quot;pocock-simon&quot;, &quot;biased-coin&quot;, &quot;permuted-block&quot;.</p>
</td></tr>
<tr><td><code id="robincar_linear_+3A_adj_method">adj_method</code></td>
<td>
<p>Name of linear adjustment method to use. One of: &quot;ANOVA&quot;, &quot;ANCOVA&quot;, &quot;ANHECOVA&quot;.</p>
</td></tr>
<tr><td><code id="robincar_linear_+3A_contrast_h">contrast_h</code></td>
<td>
<p>An optional function to specify a desired contrast</p>
</td></tr>
<tr><td><code id="robincar_linear_+3A_contrast_dh">contrast_dh</code></td>
<td>
<p>An optional jacobian function for the contrast (otherwise use numerical derivative)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>* Adjustment method &quot;ANOVA&quot; fits a linear model with formula 'Y ~ A' where
'A' is the treatment group indicator and 'Y' is the response.
* &quot;ANCOVA&quot; fits a linear model with 'Y ~ A + X' where 'X' are the variables
specified in the 'covariate_cols' argument.
* &quot;ANHECOVA&quot; fits a linear model with 'Y ~ A*X', the main effects and treatment-by-covariate
interactions.
</p>


<h3>Value</h3>

<p>See value of <a href="#topic+robincar_glm">RobinCar::robincar_glm()</a>, this function is a wrapper
using a linear link function.
</p>

<hr>
<h2 id='robincar_logrank'>Robust (potentially stratified) logrank adjustment</h2><span id='topic+robincar_logrank'></span>

<h3>Description</h3>

<p>Perform a robust covariate-adjusted logrank test (&quot;CL&quot;) that can be stratified (&quot;CSL&quot;) if desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robincar_logrank(adj_method, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robincar_logrank_+3A_adj_method">adj_method</code></td>
<td>
<p>Adjustment method, one of &quot;CL&quot;, &quot;CSL&quot;</p>
</td></tr>
<tr><td><code id="robincar_logrank_+3A_...">...</code></td>
<td>
<p>Additional arguments to 'robincar_tte'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A result object with the following attributes:
</p>
<table>
<tr><td><code>result</code></td>
<td>
<p>A list: &quot;statistic&quot; is the adjusted logrank test statistic which can be used to obtain p-values; &quot;U&quot; and &quot;se&quot; are the numerator and denominator of the test statistic, respectively.</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>The covariate adjustment settings used.</p>
</td></tr>
<tr><td><code>original_df</code></td>
<td>
<p>The dataset supplied by the user.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
library(dplyr)
library(forcats)
set.seed(0)
n=100
data.simu0=data_gen(n=n,
                    theta=0,
                    randomization="permuted_block",
                    p_trt=0.5,
                    case="case2") %&gt;% mutate(strata1=sample(letters[1:3],n,replace=TRUE),
                                             strata2=sample(LETTERS[4:5],n,replace=TRUE))

out &lt;- robincar_logrank(df=data.simu0,
                        treat_col="I1",
                        p_trt=0.5,
                        ref_arm=0,
                        response_col="t",
                        event_col="delta",
                        covariate_cols=c("model_z1", "model_z2"),
                        car_scheme="simple",
                        adj_method=c("CL"))

set.seed(0)
n=100
data.simu0=data_gen(n=n,
                    theta=0,
                    randomization="permuted_block",
                    p_trt=0.5,
                    case="case1")

data.simu &lt;- data.simu0 %&gt;%
  tidyr::pivot_longer(cols=starts_with("car_strata"),
                      names_prefix="car_strata",
                      names_to="strt") %&gt;%
  filter(value==1) %&gt;% select(-value) %&gt;%
  mutate(strt=forcats::as_factor(strt)) %&gt;%
  select(t,strt) %&gt;%
  left_join(data.simu0, .)

out1 &lt;- robincar_logrank(df=data.simu,
                         treat_col="I1",
                         p_trt=0.5,
                         ref_arm=0,
                         response_col="t",
                         event_col="delta",
                         car_strata_cols="strt",
                         covariate_cols=NULL,
                         car_scheme=c("permuted-block"),
                         adj_method=c("CSL")
)

</code></pre>

<hr>
<h2 id='robincar_SL'>BETA: Covariate adjustment using working models from the super learner libraries
through the AIPW package with cross-fitting.</h2><span id='topic+robincar_SL'></span>

<h3>Description</h3>

<p>Estimate treatment-group-specific response means and (optionally)
treatment group contrasts using a generalized linear working model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robincar_SL(
  df,
  treat_col,
  response_col,
  car_strata_cols = NULL,
  covariate_cols = NULL,
  car_scheme = "simple",
  covariate_to_include_strata = NULL,
  SL_libraries = c(),
  SL_learners = c(),
  k_split = 2,
  g_accuracy = 7,
  contrast_h = NULL,
  contrast_dh = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robincar_SL_+3A_df">df</code></td>
<td>
<p>A data.frame with the required columns</p>
</td></tr>
<tr><td><code id="robincar_SL_+3A_treat_col">treat_col</code></td>
<td>
<p>Name of column in df with treatment variable</p>
</td></tr>
<tr><td><code id="robincar_SL_+3A_response_col">response_col</code></td>
<td>
<p>Name of the column in df with response variable</p>
</td></tr>
<tr><td><code id="robincar_SL_+3A_car_strata_cols">car_strata_cols</code></td>
<td>
<p>Names of columns in df with car_strata variables</p>
</td></tr>
<tr><td><code id="robincar_SL_+3A_covariate_cols">covariate_cols</code></td>
<td>
<p>Names of columns in df with covariate variables</p>
</td></tr>
<tr><td><code id="robincar_SL_+3A_car_scheme">car_scheme</code></td>
<td>
<p>Name of the type of covariate-adaptive randomization scheme. One of: &quot;simple&quot;, &quot;pocock-simon&quot;, &quot;biased-coin&quot;, &quot;permuted-block&quot;.</p>
</td></tr>
<tr><td><code id="robincar_SL_+3A_covariate_to_include_strata">covariate_to_include_strata</code></td>
<td>
<p>Whether to include car_strata variables in covariate adjustment. Defaults to F for ANOVA and ANCOVA; defaults to T for ANHECOVA. User may override by passing in this argument.</p>
</td></tr>
<tr><td><code id="robincar_SL_+3A_sl_libraries">SL_libraries</code></td>
<td>
<p>Vector of super-learner libraries to use for the covariate adjustment (see <a href="SuperLearner.html#topic+listWrappers">SuperLearner::listWrappers</a>)</p>
</td></tr>
<tr><td><code id="robincar_SL_+3A_sl_learners">SL_learners</code></td>
<td>
<p>Optional list of super-learner &quot;learners&quot; to use for the covariate adjustment (see <a href="SuperLearner.html#topic+create.Learner">SuperLearner::create.Learner())</a></p>
</td></tr>
<tr><td><code id="robincar_SL_+3A_k_split">k_split</code></td>
<td>
<p>Number of splits to use in cross-fitting</p>
</td></tr>
<tr><td><code id="robincar_SL_+3A_g_accuracy">g_accuracy</code></td>
<td>
<p>Level of accuracy to check prediction un-biasedness (in digits).</p>
</td></tr>
<tr><td><code id="robincar_SL_+3A_contrast_h">contrast_h</code></td>
<td>
<p>An optional function to specify a desired contrast</p>
</td></tr>
<tr><td><code id="robincar_SL_+3A_contrast_dh">contrast_dh</code></td>
<td>
<p>An optional jacobian function for the contrast (otherwise use numerical derivative)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>*WARNING: This function is still under development and has not been extensively tested.*
This function currently only works for two treatment groups.
Before using this function, you must load the <a href="SuperLearner.html#topic+SuperLearner">SuperLearner</a> library with
'library(SuperLearner)', otherwise the function call will fail.
</p>


<h3>Value</h3>

<p>See value of <a href="#topic+robincar_glm">RobinCar::robincar_glm</a>, but the working model for <code class="reqn">\hat{\mu}(X_i)</code> is based on the <a href="AIPW.html#topic+AIPW">AIPW</a> package that uses specified SuperLearner libraries and cross-fitting.
Also, 'mod' attribute is an object of class <a href="AIPW.html#topic+AIPW">AIPW::AIPW</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(SuperLearner)
library(ranger)
n &lt;- 1000
set.seed(10)
DATA2 &lt;- data.frame(A=rbinom(n, size=1, prob=0.5),
                    y=rbinom(n, size=1, prob=0.2),
                    x1=rnorm(n),
                    x2=rnorm(n),
                    x3=as.factor(rbinom(n, size=1, prob=0.5)),
                    z1=rbinom(n, size=1, prob=0.5),
                    z2=rbinom(n, size=1, prob=0.5))
DATA2[, "y"] &lt;- NA
As &lt;- DATA2$A == 1
DATA2[DATA2$A == 1, "y"] &lt;- rbinom(
  sum(As),
  size=1,
  prob=exp(DATA2[As,]$x1)/(1+exp(DATA2[As,]$x1)))
DATA2[DATA2$A == 0, "y"] &lt;- rbinom(
  n-sum(As),
  size=1,
  prob=exp(1 +
    5*DATA2[!As,]$x1 + DATA2[!As,]$x2)/
    (1+exp(1 + 5*DATA2[!As,]$x1 + DATA2[!As,]$x2)))
DATA2$A &lt;- as.factor(DATA2$A)

sl.mod &lt;- robincar_SL(
  df=DATA2,
  response_col="y",
  treat_col="A",
  car_strata_cols=c("z1"),
  covariate_cols=c("x1"),
  SL_libraries=c("SL.ranger"),
  car_scheme="permuted-block",
  covariate_to_include_strata=TRUE
)

sl.mod$result

</code></pre>

<hr>
<h2 id='robincar_SL_median'>BETA: Covariate adjustment using working models from the super learner libraries
through the AIPW package with cross-fitting, with median adjustment.</h2><span id='topic+robincar_SL_median'></span>

<h3>Description</h3>

<p>Estimate treatment-group-specific response means and (optionally)
treatment group contrasts using a generalized linear working model.
Perform median adjustment to limit randomness induced from cross-fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robincar_SL_median(
  n_times,
  seed,
  df,
  treat_col,
  response_col,
  car_strata_cols = NULL,
  covariate_cols = NULL,
  car_scheme = "simple",
  covariate_to_include_strata = NULL,
  SL_libraries = c(),
  SL_learners = c(),
  k_split = 2,
  g_accuracy = 7,
  contrast_h = NULL,
  contrast_dh = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robincar_SL_median_+3A_n_times">n_times</code></td>
<td>
<p>Number of times to run the robincar_SL function</p>
</td></tr>
<tr><td><code id="robincar_SL_median_+3A_seed">seed</code></td>
<td>
<p>Seed to set before running the set of functions</p>
</td></tr>
<tr><td><code id="robincar_SL_median_+3A_df">df</code></td>
<td>
<p>A data.frame with the required columns</p>
</td></tr>
<tr><td><code id="robincar_SL_median_+3A_treat_col">treat_col</code></td>
<td>
<p>Name of column in df with treatment variable</p>
</td></tr>
<tr><td><code id="robincar_SL_median_+3A_response_col">response_col</code></td>
<td>
<p>Name of the column in df with response variable</p>
</td></tr>
<tr><td><code id="robincar_SL_median_+3A_car_strata_cols">car_strata_cols</code></td>
<td>
<p>Names of columns in df with car_strata variables</p>
</td></tr>
<tr><td><code id="robincar_SL_median_+3A_covariate_cols">covariate_cols</code></td>
<td>
<p>Names of columns in df with covariate variables</p>
</td></tr>
<tr><td><code id="robincar_SL_median_+3A_car_scheme">car_scheme</code></td>
<td>
<p>Name of the type of covariate-adaptive randomization scheme. One of: &quot;simple&quot;, &quot;pocock-simon&quot;, &quot;biased-coin&quot;, &quot;permuted-block&quot;.</p>
</td></tr>
<tr><td><code id="robincar_SL_median_+3A_covariate_to_include_strata">covariate_to_include_strata</code></td>
<td>
<p>Whether to include car_strata variables in covariate adjustment. Defaults to F for ANOVA and ANCOVA; defaults to T for ANHECOVA. User may override by passing in this argument.</p>
</td></tr>
<tr><td><code id="robincar_SL_median_+3A_sl_libraries">SL_libraries</code></td>
<td>
<p>Vector of super-learner libraries to use for the covariate adjustment (see <a href="SuperLearner.html#topic+listWrappers">SuperLearner::listWrappers</a>)</p>
</td></tr>
<tr><td><code id="robincar_SL_median_+3A_sl_learners">SL_learners</code></td>
<td>
<p>Optional list of super-learner &quot;learners&quot; to use for the covariate adjustment (see <a href="SuperLearner.html#topic+create.Learner">SuperLearner::create.Learner())</a></p>
</td></tr>
<tr><td><code id="robincar_SL_median_+3A_k_split">k_split</code></td>
<td>
<p>Number of splits to use in cross-fitting</p>
</td></tr>
<tr><td><code id="robincar_SL_median_+3A_g_accuracy">g_accuracy</code></td>
<td>
<p>Level of accuracy to check prediction un-biasedness (in digits).</p>
</td></tr>
<tr><td><code id="robincar_SL_median_+3A_contrast_h">contrast_h</code></td>
<td>
<p>An optional function to specify a desired contrast</p>
</td></tr>
<tr><td><code id="robincar_SL_median_+3A_contrast_dh">contrast_dh</code></td>
<td>
<p>An optional jacobian function for the contrast (otherwise use numerical derivative)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>*WARNING: This function is still under development and has not been extensively tested.*
This function currently only works for two treatment groups.
Before using this function, you must load the SuperLearner library with
'library(SuperLearner)', otherwise the function call will fail.
</p>


<h3>Value</h3>

<p>See value of <a href="#topic+robincar_SL">RobinCar::robincar_SL</a>.
Attributes 'mods' and 'mu_as' are lists of 'mod' and 'mu_a' attributes, respectively, for each replicate of 'robincar_SL' used in the median.
</p>

<hr>
<h2 id='robincar_tte'>Covariate adjustment for time to event data</h2><span id='topic+robincar_tte'></span>

<h3>Description</h3>

<p>Perform a covariate-adjusted logrank test ('adj_method=&quot;CL&quot;'),
covariate-adjusted stratified logrank test ('adj_method=&quot;CSL&quot;'),
or a covariate-adjusted robust Cox score test ('adj_method=&quot;coxscore&quot;').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robincar_tte(
  df,
  treat_col,
  response_col,
  event_col,
  adj_method,
  car_strata_cols = NULL,
  covariate_cols = NULL,
  p_trt = 0.5,
  ref_arm = NULL,
  sparse_remove = TRUE,
  car_scheme = "simple"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robincar_tte_+3A_df">df</code></td>
<td>
<p>A data.frame with the required columns</p>
</td></tr>
<tr><td><code id="robincar_tte_+3A_treat_col">treat_col</code></td>
<td>
<p>Name of column in df with treatment variable</p>
</td></tr>
<tr><td><code id="robincar_tte_+3A_response_col">response_col</code></td>
<td>
<p>Name of the column in df with response variable</p>
</td></tr>
<tr><td><code id="robincar_tte_+3A_event_col">event_col</code></td>
<td>
<p>Name of column in df with event indicator
(0/FALSE=no event, 1/TRUE=event)</p>
</td></tr>
<tr><td><code id="robincar_tte_+3A_adj_method">adj_method</code></td>
<td>
<p>Adjustment method (one of &quot;CL&quot;, &quot;CSL&quot;, or &quot;coxscore&quot;)</p>
</td></tr>
<tr><td><code id="robincar_tte_+3A_car_strata_cols">car_strata_cols</code></td>
<td>
<p>Names of columns in df with car_strata variables</p>
</td></tr>
<tr><td><code id="robincar_tte_+3A_covariate_cols">covariate_cols</code></td>
<td>
<p>Names of columns in df with covariate variables</p>
</td></tr>
<tr><td><code id="robincar_tte_+3A_p_trt">p_trt</code></td>
<td>
<p>Treatment allocation ratio for the reference arm.</p>
</td></tr>
<tr><td><code id="robincar_tte_+3A_ref_arm">ref_arm</code></td>
<td>
<p>Reference arm of the treatment group, defaults to NULL,
which results in using the first element of 'unique(data[, treat_col])'.</p>
</td></tr>
<tr><td><code id="robincar_tte_+3A_sparse_remove">sparse_remove</code></td>
<td>
<p>Remove sparse car_strata from calculation</p>
</td></tr>
<tr><td><code id="robincar_tte_+3A_car_scheme">car_scheme</code></td>
<td>
<p>Name of the type of covariate-adaptive randomization scheme. One of: &quot;simple&quot;, &quot;pocock-simon&quot;, &quot;biased-coin&quot;, &quot;permuted-block&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'robincar_coxscore' and 'robincar_logrank' are wrapper functions around
'robincar_tte'.
</p>


<h3>Value</h3>

<p>For adjustment method &quot;CL&quot; or &quot;CSL&quot;, see value of <a href="#topic+robincar_linear">RobinCar::robincar_logrank()</a>; for adjustment method &quot;coxscore&quot; see value of <a href="#topic+robincar_coxscore">RobinCar::robincar_coxscore()</a>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
