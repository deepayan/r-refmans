<!DOCTYPE html><html><head><title>Help for package lsr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lsr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aad'><p>Mean (average) absolute deviation from the mean</p></a></li>
<li><a href='#associationTest'><p>Chi-square test of association / independence</p></a></li>
<li><a href='#bars'><p>Grouped Bar Plots with Error Bars</p></a></li>
<li><a href='#ciMean'><p>Confidence interval around the mean</p></a></li>
<li><a href='#cohensD'><p>Cohen's d</p></a></li>
<li><a href='#copy'><p>Copies a vector into a matrix</p></a></li>
<li><a href='#correlate'><p>Correlation matrices</p></a></li>
<li><a href='#cramersV'><p>Cramer's V</p></a></li>
<li><a href='#etaSquared'><p>Effect size calculations for ANOVAs</p></a></li>
<li><a href='#expandFactors'><p>Expand factors to a set of contrasts</p></a></li>
<li><a href='#goodnessOfFitTest'><p>Chi-square test against specified probabilities</p></a></li>
<li><a href='#importList'><p>Import a list</p></a></li>
<li><a href='#independentSamplesTTest'><p>Independent samples t-test</p></a></li>
<li><a href='#longToWide'><p>Reshape from long to wide</p></a></li>
<li><a href='#maxFreq'><p>Sample mode</p></a></li>
<li><a href='#oneSampleTTest'><p>One sample t-test</p></a></li>
<li><a href='#pairedSamplesTTest'><p>Paired samples t-test</p></a></li>
<li><a href='#permuteLevels'><p>Permute the levels of a factor</p></a></li>
<li><a href='#posthocPairwiseT'><p>Post-hoc pairwise t-tests for ANOVA</p></a></li>
<li><a href='#print.assocTest'><p>Print method for lsr chi-square tests</p></a></li>
<li><a href='#print.correlate'><p>Print method for correlate objects</p></a></li>
<li><a href='#print.gofTest'><p>Print method for lsr goodness-of-fit tests</p></a></li>
<li><a href='#print.TTest'><p>Print method for lsr t-tests</p></a></li>
<li><a href='#print.whoList'><p>Print method for whoList objects</p></a></li>
<li><a href='#quantileCut'><p>Cut by quantiles</p></a></li>
<li><a href='#rmAll'><p>Remove all objects</p></a></li>
<li><a href='#sortFrame'><p>Sort a data frame</p></a></li>
<li><a href='#standardCoefs'><p>Standardised regression coefficients</p></a></li>
<li><a href='#tFrame'><p>Transpose a data frame</p></a></li>
<li><a href='#unlibrary'><p>Unload a package</p></a></li>
<li><a href='#who'><p>Contents of workspace</p></a></li>
<li><a href='#wideToLong'><p>Reshape from wide to long</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Companion to "Learning Statistics with R"</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.2</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of tools intended to make introductory 
    statistics easier to teach, including wrappers for common 
    hypothesis tests and basic data manipulation. It accompanies 
    Navarro, D. J. (2015). Learning Statistics with R: A Tutorial 
    for Psychology Students and Other Beginners, Version 0.6. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/djnavarro/lsr">https://github.com/djnavarro/lsr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/djnavarro/lsr/issues">https://github.com/djnavarro/lsr/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, methods, stats</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-01 05:22:49 UTC; danielle</td>
</tr>
<tr>
<td>Author:</td>
<td>Danielle Navarro <a href="https://orcid.org/0000-0001-7648-6578"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Danielle Navarro &lt;djnavarro@protonmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-01 08:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='aad'>Mean (average) absolute deviation from the mean</h2><span id='topic+aad'></span>

<h3>Description</h3>

<p>Calculates the mean absolute deviation from the sample mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aad(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aad_+3A_x">x</code></td>
<td>
<p>A vector containing the observations.</p>
</td></tr>
<tr><td><code id="aad_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical value indicating whether or not missing values should be removed. Defaults to <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>aad</code> function calculates the average (i.e. mean)
absolute deviation from the mean value of <code>x</code>, removing <code>NA</code>
values if requested by the user. It exists primarily to simplify the
discussion of descriptive statistics during an introductory stats class.
</p>


<h3>Value</h3>

<p>Numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'># basic usage
X &lt;- c(1, 3, 6)  # data
aad(X)           # returns a value of 1.777

# removing missing data
X &lt;- c(1, 3, NA, 6)   # data
aad(X)                # returns NA
aad(X, na.rm = TRUE)  # returns 1.777

</code></pre>

<hr>
<h2 id='associationTest'>Chi-square test of association / independence</h2><span id='topic+associationTest'></span>

<h3>Description</h3>

<p>Convenience function that runs a chi-square test of
association/independence. This is a wrapper function intended to
be used for pedagogical purposes only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>associationTest(formula, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="associationTest_+3A_formula">formula</code></td>
<td>
<p>One-sided formula specifying the two variables (required).</p>
</td></tr>
<tr><td><code id="associationTest_+3A_data">data</code></td>
<td>
<p>Optional data frame containing the variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>associationTest</code> function runs the chi-square test
of association on the variables specified in the <code>formula</code> argument.
The formula must be a one-sided formula of the form
<code>~variable1 + variable2</code>, and both variables must be factors.
</p>


<h3>Value</h3>

<p>An object of class 'assocTest'. When printed, the output is
organised into six short sections. The first section lists the name
of the test and the variables included. The second lists the null and
alternative hypotheses for the test. The third shows the observed
contingency table, and the fourth shows the expected contingency
table under the null. The fifth prints out the test results, and the
sixth reports an estimate of effect size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
gender=factor(c("male","male","male","male","female","female","female")),
answer=factor(c("heads","heads","heads","heads","tails","tails","heads"))
)

associationTest( ~ gender + answer, df )

</code></pre>

<hr>
<h2 id='bars'>Grouped Bar Plots with Error Bars</h2><span id='topic+bars'></span>

<h3>Description</h3>

<p>Grouped bar plots with error bars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bars(
  formula,
  data = NULL,
  heightFun = mean,
  errorFun = ciMean,
  yLabel = NULL,
  xLabels = NULL,
  main = "",
  ylim = NULL,
  barFillColour = NULL,
  barLineWidth = 2,
  barLineColour = "black",
  barSpaceSmall = 0.2,
  barSpaceBig = 1,
  legendLabels = NULL,
  legendDownShift = 0,
  legendLeftShift = 0,
  errorBarLineWidth = 1,
  errorBarLineColour = "grey40",
  errorBarWhiskerWidth = 0.2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bars_+3A_formula">formula</code></td>
<td>
<p>A two-sided formula specifying the response variable and the grouping factors</p>
</td></tr>
<tr><td><code id="bars_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the variables</p>
</td></tr>
<tr><td><code id="bars_+3A_heightfun">heightFun</code></td>
<td>
<p>The function used to calculate the bar height for a group (default=mean)</p>
</td></tr>
<tr><td><code id="bars_+3A_errorfun">errorFun</code></td>
<td>
<p>The function used to calculate the error bar for a group (default=ciMean). No bars drawn if <code>errorFun=FALSE</code></p>
</td></tr>
<tr><td><code id="bars_+3A_ylabel">yLabel</code></td>
<td>
<p>The y-axis label (defaults to the name of the response variable)</p>
</td></tr>
<tr><td><code id="bars_+3A_xlabels">xLabels</code></td>
<td>
<p>The x-axis bar labels (defaults to factor labels of the appropriate grouping variable)</p>
</td></tr>
<tr><td><code id="bars_+3A_main">main</code></td>
<td>
<p>The plot title</p>
</td></tr>
<tr><td><code id="bars_+3A_ylim">ylim</code></td>
<td>
<p>The y-axis limit: lower bound defaults to 0, default upper bound estimated</p>
</td></tr>
<tr><td><code id="bars_+3A_barfillcolour">barFillColour</code></td>
<td>
<p>The colours to fill the bars (defaults to a rainbow palette with saturation .3)</p>
</td></tr>
<tr><td><code id="bars_+3A_barlinewidth">barLineWidth</code></td>
<td>
<p>The width of the bar border lines (default=2)</p>
</td></tr>
<tr><td><code id="bars_+3A_barlinecolour">barLineColour</code></td>
<td>
<p>The colour of the bar border lines (default=&quot;black&quot;)</p>
</td></tr>
<tr><td><code id="bars_+3A_barspacesmall">barSpaceSmall</code></td>
<td>
<p>The size of the gap between bars within a cluster, as a proportion of bar width (default=.2)</p>
</td></tr>
<tr><td><code id="bars_+3A_barspacebig">barSpaceBig</code></td>
<td>
<p>The size of the gap separating clusters of bars, as a proportion of bar width (default=1)</p>
</td></tr>
<tr><td><code id="bars_+3A_legendlabels">legendLabels</code></td>
<td>
<p>The text for the legend (defaults to factor labels of the appropriate grouping variable). No legends drawn if <code>legendLabels=FALSE</code> or if only one grouping variable is specified</p>
</td></tr>
<tr><td><code id="bars_+3A_legenddownshift">legendDownShift</code></td>
<td>
<p>How far below the top is the legend, as proportion of plot height? (default=0)</p>
</td></tr>
<tr><td><code id="bars_+3A_legendleftshift">legendLeftShift</code></td>
<td>
<p>How far away from the right edge is the legend, as proportion of plot? (default=0)</p>
</td></tr>
<tr><td><code id="bars_+3A_errorbarlinewidth">errorBarLineWidth</code></td>
<td>
<p>The line width for the error bars (default=1)</p>
</td></tr>
<tr><td><code id="bars_+3A_errorbarlinecolour">errorBarLineColour</code></td>
<td>
<p>The colour of the error bars (default=&quot;grey40&quot;)</p>
</td></tr>
<tr><td><code id="bars_+3A_errorbarwhiskerwidth">errorBarWhiskerWidth</code></td>
<td>
<p>The width of error bar whiskers, as proportion of bar width (default=.2)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots group means (or other function, if specified) broken down by
one or two grouping factors. Confidence intervals (or other function) are
plotted. User specifies a two sided formula of the form
<code>response ~ group1 + group2</code>, where <code>response</code> must be numeric
and <code>group1</code> and <code>group2</code> are factors. The <code>group1</code> variable
defines the primary separation on the x-axis, and the x-axis labels by
default print out the levels of this factor. The <code>group2</code> variable
defines the finer grain separation, and the legend labels correspond to
the levels of this factor. Note that <code>group2</code> is optional.
</p>


<h3>Value</h3>

<p>Invisibly returns a data frame containing the factor levels, group
means and confidence intervals. Note that this function is usually called
for its side effects.
</p>

<hr>
<h2 id='ciMean'>Confidence interval around the mean</h2><span id='topic+ciMean'></span>

<h3>Description</h3>

<p>Calculates confidence intervals for the mean of a normally-distributed variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ciMean(x, conf = 0.95, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ciMean_+3A_x">x</code></td>
<td>
<p>A numeric vector, data frame or matrix containing the observations.</p>
</td></tr>
<tr><td><code id="ciMean_+3A_conf">conf</code></td>
<td>
<p>The level of confidence desired. Defaults to a 95% confidence interval</p>
</td></tr>
<tr><td><code id="ciMean_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical value indicating whether missing values are to be removed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the confidence interval for the mean of
a variable (or set of variables in a data frame or matrix), under the
standard assumption that the data are normally distributed. By default it
returns a 95% confidence interval (<code>conf = 0.95</code>) and does not
remove missing values (<code>na.rm = FALSE</code>).
</p>


<h3>Value</h3>

<p>The output is a matrix containing the lower and upper ends of the
confidence interval for each variable. If a data frame is specified as input
and contains non-numeric variables, the corresponding rows in the output
matrix have NA values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- c(1, 3, 6)          # data
ciMean(X)                # 95 percent confidence interval
ciMean(X, conf = .8)     # 80 percent confidence interval

confint( lm(X ~ 1) )     # for comparison purposes

X &lt;- c(1, 3, NA, 6)      # data with missing values
ciMean(X, na.rm = TRUE)  # remove missing values

</code></pre>

<hr>
<h2 id='cohensD'>Cohen's d</h2><span id='topic+cohensD'></span>

<h3>Description</h3>

<p>Calculates the Cohen's d measure of effect size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cohensD(
  x = NULL,
  y = NULL,
  data = NULL,
  method = "pooled",
  mu = 0,
  formula = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cohensD_+3A_x">x</code></td>
<td>
<p>A numeric variable containing the data for group 1, or possibly a formula of the form <code>outcome ~ group</code></p>
</td></tr>
<tr><td><code id="cohensD_+3A_y">y</code></td>
<td>
<p>If <code>x</code> is a numeric variable, the <code>y</code> argument should be a numeric variable containing the data for group 2. If a one-sample calculation is desired, then no value for <code>y</code> should be specified.</p>
</td></tr>
<tr><td><code id="cohensD_+3A_data">data</code></td>
<td>
<p>If <code>x</code> is a formula, then <code>data</code> is an optional argument specifying data frame containing the variables in the formula.</p>
</td></tr>
<tr><td><code id="cohensD_+3A_method">method</code></td>
<td>
<p>Which version of the d statistic should we calculate? Possible values are <code>"pooled"</code> (the default), <code>"x.sd"</code>, <code>"y.sd"</code>, <code>"corrected"</code>, <code>"raw"</code>, <code>"paired"</code> and <code>"unequal"</code>. See below for specifics.</p>
</td></tr>
<tr><td><code id="cohensD_+3A_mu">mu</code></td>
<td>
<p>The &quot;null&quot; value against which the effect size should be measured. This is almost always 0 (the default), so this argument is rarely specified.</p>
</td></tr>
<tr><td><code id="cohensD_+3A_formula">formula</code></td>
<td>
<p>An alias for <code>x</code> if a formula input is used. Included for the sake of consistency with the <code>t.test</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>cohensD</code> function calculates the Cohen's d measure of
effect size in one of several different formats. The function is intended
to be called in one of two different ways, mirroring the <code>t.test</code>
function. That is, the first input argument <code>x</code> is a formula, then a
command of the form <code>cohensD(x = outcome~group, data = data.frame)</code>
is expected, whereas if <code>x</code> is a numeric variable, then a command of
the form <code>cohensD(x = group1, y = group2)</code> is expected.
</p>
<p>The <code>method</code> argument allows the user to select one of several
different variants of Cohen's d. Assuming that the original t-test for
which an effect size is desired was an independent samples t-test (i.e.,
not one sample or paired samples t-test), then there are several
possibilities for how the normalising term (i.e., the standard deviation
estimate) in Cohen's d should be calculated. The most commonly used
method is to use the same pooled standard deviation estimate that is
used in a Student t-test (<code>method = "pooled"</code>, the default). If
<code>method = "raw"</code> is used, then the same pooled standard deviation
estimate is used, except that the sample standard deviation is used
(divide by N) rather than the unbiased estimate of the population
standard deviation (divide by N-2). Alternatively, there may be reasons
to use only one of the two groups to estimate the standard deviation. To
do so, use <code>method = "x.sd"</code> to select the <code>x</code> variable, or
the first group listed in the grouping factor; and <code>method = "y.sd"</code>
to normalise by <code>y</code>, or the second group listed in the grouping
factor. The last of the &quot;Student t-test&quot; based measures is the unbiased
estimator of d (<code>method = "corrected"</code>), which multiplies the &quot;pooled&quot;
version by (N-3)/(N-2.25).
</p>
<p>For other versions of the t-test, there are two possibilities implemented.
If the original t-test did not make a homogeneity of variance assumption,
as per the Welch test, the normalising term should mirror the Welch test
(<code>method = "unequal"</code>). Or, if the original t-test was a paired samples
t-test, and the effect size desired is intended to be based on the standard
deviation of the differences, then <code>method = "paired"</code> should be used.
</p>
<p>The last argument to <code>cohensD</code> is <code>mu</code>, which represents the mean
against which one sample Cohen's d calculation should be assessed. Note that
this is a slightly narrower usage of <code>mu</code> than the <code>t.test</code>
function allows. <code>cohensD</code> does not currently support the use of a
non-zero <code>mu</code> value for a paired-samples calculation.
</p>


<h3>Value</h3>

<p>Numeric variable containing the effect size, d. Note that it does
not show the direction of the effect, only the magnitude. That is, the value
of d returned by the function is always positive or zero.
</p>


<h3>References</h3>

<p>Cohen, J. (1988). Statistical power analysis for the behavioral sciences
(2nd ed.). Hillsdale, NJ: Lawrence Erlbaum Associates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># calculate Cohen's d for two independent samples:
gradesA &lt;- c(55, 65, 65, 68, 70) # 5 students with teacher A
gradesB &lt;- c(56, 60, 62, 66)     # 4 students with teacher B
cohensD(gradesA, gradesB)

# calculate Cohen's d for the same data, described differently:
grade &lt;- c(55, 65, 65, 68, 70, 56, 60, 62, 66) # grades for all students
teacher &lt;- c("A", "A", "A", "A", "A", "B", "B", "B", "B") # teacher for each student
cohensD(grade ~ teacher)

# calculate Cohen's d for two paired samples:
pre  &lt;- c(100, 122, 97, 25, 274) # a pre-treatment measure for 5 cases
post &lt;- c(104, 125, 99, 29, 277) # the post-treatment measure for the same 5 cases
cohensD(pre, post, method = "paired") # ... explicitly indicate that it's paired, or else
cohensD(post - pre)  # ... do a "single-sample" calculation on the difference

# support for data frames:
exams &lt;- data.frame(grade, teacher)
cohensD(exams$grade ~ exams$teacher)    # using $
cohensD(grade ~ teacher, data = exams)  # using the 'data' argument

</code></pre>

<hr>
<h2 id='copy'>Copies a vector into a matrix</h2><span id='topic+copy'></span><span id='topic+colCopy'></span><span id='topic+rowCopy'></span>

<h3>Description</h3>

<p>Copies a vector into a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colCopy(x, times, dimnames = NULL)

rowCopy(x, times, dimnames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_+3A_x">x</code></td>
<td>
<p>The vector to be copied</p>
</td></tr>
<tr><td><code id="copy_+3A_times">times</code></td>
<td>
<p>Number of copies of the vector to bind together</p>
</td></tr>
<tr><td><code id="copy_+3A_dimnames">dimnames</code></td>
<td>
<p>List specifying row and column names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenience function for binding together multiple copies
of the same vector. The intended usage is for situations where one might
ordinarily use <code>rbind</code> or <code>cbind</code>, but the work is done by the
<code>matrix</code> function. Instead of needing to input multiple copies of the
input vector <code>x</code> (as one would for <code>rbind</code>), one only needs to
specify the number of <code>times</code> that the vector should be copied.
</p>


<h3>Value</h3>

<p>For <code>rowCopy</code>, the output is a matrix with <code>times</code> rows
and <code>length(x)</code> columns, in which each row contains the vector <code>x</code>.
For <code>colCopy</code>, each column corresponds to the vector <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Example 1: basic usage
data &lt;- c(3,1,4,1,5)
rowCopy( data, 4 )
colCopy( data, 4 )

#Example 2: attach dimension names
dnames &lt;- list( rows = c("r1","r2","r3"), cols = c("c1","c2","c3","c4","c5") )
rowCopy( data,3,dnames )
</code></pre>

<hr>
<h2 id='correlate'>Correlation matrices</h2><span id='topic+correlate'></span>

<h3>Description</h3>

<p>Computes a correlation matrix and runs hypothesis tests with corrections for multiple comparisons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlate(
  x,
  y = NULL,
  test = FALSE,
  corr.method = "pearson",
  p.adjust.method = "holm"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlate_+3A_x">x</code></td>
<td>
<p>Matrix or data frame containing variables to be correlated</p>
</td></tr>
<tr><td><code id="correlate_+3A_y">y</code></td>
<td>
<p>Optionally, a second set of variables to be correlated with those in <code>x</code></p>
</td></tr>
<tr><td><code id="correlate_+3A_test">test</code></td>
<td>
<p>Should hypothesis tests be displayed? (Default=<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="correlate_+3A_corr.method">corr.method</code></td>
<td>
<p>What kind of correlations should be computed? Default is <code>"pearson"</code>, but <code>"spearman"</code> and <code>"kendall"</code> are also supported</p>
</td></tr>
<tr><td><code id="correlate_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>What method should be used to correct for multiple comparisons. Default value is <code>"holm"</code>, and the allowable values are the same as for <code><a href="stats.html#topic+p.adjust">p.adjust</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>correlate</code> function calculates a correlation matrix
between all pairs of variables. Much like the <code>cor</code> function, if the
user inputs only one set of variables (<code>x</code>) then it computes all
pairwise correlations between the variables in <code>x</code>. If the user
specifies both <code>x</code> and <code>y</code> it correlates the variables in
<code>x</code> with the variables in <code>y</code>.
</p>
<p>Unlike the <code>cor</code> function, <code>correlate</code> does not generate an
error if some of the variables are categorical (i.e., factors). Variables
that are not numeric (or integer) class are simply ignored. They appear in
the output, but no correlations are reported for those variables. The
decision to have the <code>correlate</code> function allow the user a little
leniency when the input contains non-numeric variables should be explained.
The motivation is pedagogical rather than statistical. It is sometimes the
case in psychology that students need to work with correlation matrices
before they are comfortable subsetting a data frame, so it is convenient
to allow them to type commands like <code>correlate(data)</code> even when
<code>data</code> contains variables for which Pearson/Spearman correlations
are not appropriate. (It is also useful to use the output of
<code>correlate</code> to illustrate the fact that Pearson correlations should
not be used for categorical variables).
</p>
<p>A second difference between <code>cor</code> and <code>correlate</code> is that
<code>correlate</code> runs hypothesis tests for all correlations in the
correlation matrix (using the <code>cor.test</code> function to do the work).
The results of the tests are only displayed to the user if
<code>test=TRUE</code>. This is a pragmatic choice, given the (perhaps
unfortunate) fact that psychologists often want to see the results
of these tests: it is probably not coincidental that the <code>corr.test</code>
function in the <span class="pkg">psych</span> package already provides this functionality
(though the output is difficult for novices to read).
</p>
<p>The concern with running hypothesis tests for all elements of a correlation
matrix is inflated Type I error rates. To minimise this risk, reported
p-values are adjusted using the Holm method. The user can change this
setting by specifying <code>p.adjust.method</code>. See <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>
for details.
</p>
<p>Missing data are handled using pairwise complete cases.
</p>


<h3>Value</h3>

<p>The printed output shows the correlation matrix, and if tests are
requested it also reports a matrix of p-values and sample sizes associated
with each correlation (these can vary if there are missing data). The
underlying data structure is an object of class <code>correlate</code> (an S3
class). It is effectively a list containing four elements:
<code>correlation</code> is the correlation matrix, <code>p.value</code> is the matrix
of p-values, <code>sample.size</code> is the matrix of sample sizes, and
<code>args</code> is a vector that stores information about what the user
requested.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data frame with factors and missing values
data &lt;- data.frame(
  anxiety = c(1.31,2.72,3.18,4.21,5.55,NA),
  stress = c(2.01,3.45,1.99,3.25,4.27,6.80),
  depression = c(2.51,1.77,3.34,5.83,9.01,7.74),
  happiness = c(4.02,3.66,5.23,6.37,7.83,1.18),
  gender = factor( c("male","female","female","male","female","female") ),
  ssri = factor( c("no","no","no",NA,"yes","yes") )
)

# default output is just the (Pearson) correlation matrix
correlate( data )

# other types of correlation:
correlate( data, corr.method="spearman" )

# two meaningful subsets to be correlated:
nervous &lt;- data[,c("anxiety","stress")]
happy &lt;- data[,c("happiness","depression","ssri")]

# default output for two matrix input
correlate( nervous, happy )

# the same examples, with Holm-corrected p-values
correlate( data, test=TRUE )
correlate( nervous, happy, test=TRUE )

</code></pre>

<hr>
<h2 id='cramersV'>Cramer's V</h2><span id='topic+cramersV'></span>

<h3>Description</h3>

<p>Calculate the Cramer's V measure of association
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cramersV(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cramersV_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to the <code>chisq.test</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the Cramer's V measure of effect size for chi-square
tests of association and goodness of fit. The arguments to the
<code>cramersV</code> function are all passed straight to the <code>chisq.test</code>
function, and should have the same format.
</p>


<h3>Value</h3>

<p>A numeric variable with a single element corresponding to the
value of V.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Consider an experiment with two conditions, each with 100
# participants. Each participant chooses between one of three
# options. Possible data for this experiment:

condition1 &lt;- c(30, 20, 50)
condition2 &lt;- c(35, 30, 35)
X &lt;- cbind( condition1, condition2 )
rownames(X) &lt;- c( 'choice1', 'choice2', 'choice3' )
print(X)

# To test the null hypothesis that the distribution of choices
# is identical in the two conditions, we would run a chi-square
# test:
chisq.test(X)

# To estimate the effect size we can use Cramer's V:
cramersV( X )  # returns a value of 0.159

</code></pre>

<hr>
<h2 id='etaSquared'>Effect size calculations for ANOVAs</h2><span id='topic+etaSquared'></span>

<h3>Description</h3>

<p>Calculates eta-squared and partial eta-squared
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etaSquared(x, type = 2, anova = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="etaSquared_+3A_x">x</code></td>
<td>
<p>An analysis of variance (aov) object.</p>
</td></tr>
<tr><td><code id="etaSquared_+3A_type">type</code></td>
<td>
<p>What type of sum of squares to calculate?</p>
</td></tr>
<tr><td><code id="etaSquared_+3A_anova">anova</code></td>
<td>
<p>Should the full ANOVA table be printed out in addition to the effect sizes?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the eta-squared and partial eta-squared measures of
effect size that are commonly used in analysis of variance. The input
<code>x</code> should be the analysis of variance object itself.
</p>
<p>For unbalanced designs, the default in <code>etaSquared</code> is to compute
Type II sums of squares (<code>type=2</code>), in keeping with the <code>Anova</code>
function in the <code>car</code> package. It is possible to revert to the
Type I SS values (<code>type=1</code>) to be consistent with <code>anova</code>, but
this rarely tests hypotheses of interest. Type III SS values (<code>type=3</code>)
can also be computed.
</p>


<h3>Value</h3>

<p>If <code>anova=FALSE</code>, the output is an M x 2 matrix. Each of the
M rows corresponds to one of the terms in the ANOVA (e.g., main effect 1,
main effect 2, interaction, etc), and each of the columns corresponds to
a different measure of effect size. Column 1 contains the eta-squared
values, and column 2 contains partial eta-squared values. If
<code>anova=TRUE</code>, the output contains additional columns containing the
sums of squares, mean squares, degrees of freedom, F-statistics and p-values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: one-way ANOVA

outcome &lt;- c( 1.4,2.1,3.0,2.1,3.2,4.7,3.5,4.5,5.4 )  # data
treatment1 &lt;- factor( c( 1,1,1,2,2,2,3,3,3 ))        # grouping variable
anova1 &lt;- aov( outcome ~ treatment1 )                # run the ANOVA
summary( anova1 )                                    # print the ANOVA table
etaSquared( anova1 )                                 # effect size

# Example 2: two-way ANOVA

treatment2 &lt;- factor( c( 1,2,3,1,2,3,1,2,3 ))      # second grouping variable
anova2 &lt;- aov( outcome ~ treatment1 + treatment2 ) # run the ANOVA
summary( anova2 )                                  # print the ANOVA table
etaSquared( anova2 )                               # effect size

</code></pre>

<hr>
<h2 id='expandFactors'>Expand factors to a set of contrasts</h2><span id='topic+expandFactors'></span>

<h3>Description</h3>

<p>Substitutes all factors in a data frame with the set of
contrasts with which that factor is associated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandFactors(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expandFactors_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="expandFactors_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to model.matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>expandFactors</code> function replaces all of the factors
in a data frame with the set of contrasts output by the <code>contrasts</code>
function or <code>model.matrix</code>. It may be useful for teaching purposes
when explaining relationship between ANOVA and regression.
</p>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grading &lt;- data.frame( teacher = factor( c("Amy","Amy","Ben","Ben","Cat") ),
                       gender = factor( c("male","female","female","male","male") ),
                       grade = c(75,80,45,50,65) )

# expand factors using the default contrasts (usually treatment contrasts)
expandFactors( grading )

# specify the contrasts using the contrasts.arg argument to model.matrix
my.contrasts &lt;- list( teacher = "contr.helmert", gender = "contr.treatment" )
expandFactors( grading, contrasts.arg = my.contrasts )

</code></pre>

<hr>
<h2 id='goodnessOfFitTest'>Chi-square test against specified probabilities</h2><span id='topic+goodnessOfFitTest'></span>

<h3>Description</h3>

<p>Convenience function that runs a chi-square goodness of fit
test against specified probabilities. This is a wrapper function intended
to be used for pedagogical purposes only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>goodnessOfFitTest(x, p = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="goodnessOfFitTest_+3A_x">x</code></td>
<td>
<p>Factor variable containing the raw outcomes.</p>
</td></tr>
<tr><td><code id="goodnessOfFitTest_+3A_p">p</code></td>
<td>
<p>Numeric variable containing the null-hypothesis probabilities (default = all outcomes equally likely)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>goodnessOfFitTest</code> function runs the chi-square
goodness of fit test of the hypothesis that the outcomes in the factor
<code>x</code> were generated according to the probabilities in the vector
<code>p</code>. The probability vector <code>p</code> must be a numeric variable
of length <code>nlevels(x)</code>. If no probabilities are specified, all
outcomes are assumed to be equally likely.
</p>


<h3>Value</h3>

<p>An object of class 'gofTest'. When printed, the output is
organised into four short sections. The first section lists the name
of the test and the variables included. The second lists the null and
alternative hypotheses for the test. The third shows the observed
frequency table, the expected frequency table under the null hypothesis,
and the probabilities specified by the null. The fourth prints out the
test results.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+chisq.test">chisq.test</a></code>,
<code><a href="#topic+associationTest">associationTest</a></code>,
<code><a href="#topic+cramersV">cramersV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># raw data
gender &lt;- factor(
  c( "male","male","male","male","female","female",
     "female","male","male","male" ))

# goodness of fit test against the hypothesis that males and
# females occur with equal frequency
goodnessOfFitTest( gender )

# goodness of fit test against the hypothesis that males appear
# with probability .6 and females with probability .4.
goodnessOfFitTest( gender, p=c(.4,.6) )
goodnessOfFitTest( gender, p=c(female=.4,male=.6) )
goodnessOfFitTest( gender, p=c(male=.6,female=.4) )

</code></pre>

<hr>
<h2 id='importList'>Import a list</h2><span id='topic+importList'></span>

<h3>Description</h3>

<p>Creates variables in the workspace corresponding to the elements of a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importList(x, ask = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="importList_+3A_x">x</code></td>
<td>
<p>List to be imported</p>
</td></tr>
<tr><td><code id="importList_+3A_ask">ask</code></td>
<td>
<p>Should R ask the user to confirm the new variables before creating them? (default is <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>importList</code> function creates variables in the parent
environment (generally the global workspace) corresponding to each of the
elements of the list object <code>x</code>. If the names of these elements do
not correspond to legitimate variables names they are converted using
the <code><a href="base.html#topic+make.names">make.names</a></code> functions to valid variables names.
</p>


<h3>Value</h3>

<p>Invisibly returns <code>0</code> if the user chooses not to import the
variables, otherwise invisibly returns <code>1</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+unlist">unlist</a></code>,
<code><a href="base.html#topic+attach">attach</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data set organised into two groups
data &lt;- c(1,2,3,4,5)
group &lt;- c("group A","group A","group B","group B","group B")

# the split function creates a list with two elements
# named "group A" and "group B", each containing the
# data for the respective groups
data.list &lt;- split( data, group )

# The data.list variable looks like this:

#   $`group A`
#   [1] 1 2
#
#   $`group B`
#   [1] 3 4 5

# importing the list with the default value of ask = TRUE will
# cause R to wait on the user's approval. Typing this:

#   importList( data.list )

# would produce the following output:

#   Names of variables to be created:
#   [1] "group.A" "group.B"
#   Create these variables? [y/n]

# If the user then types y, the new variables are created.

# this version will silently import the variables.
importList( x = data.list, ask = FALSE )

</code></pre>

<hr>
<h2 id='independentSamplesTTest'>Independent samples t-test</h2><span id='topic+independentSamplesTTest'></span>

<h3>Description</h3>

<p>Convenience function that runs an independent samples t-test.
This is a wrapper function intended to be used for pedagogical purposes only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>independentSamplesTTest(
  formula,
  data = NULL,
  var.equal = FALSE,
  one.sided = FALSE,
  conf.level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="independentSamplesTTest_+3A_formula">formula</code></td>
<td>
<p>Formula specifying the outcome and the groups (required).</p>
</td></tr>
<tr><td><code id="independentSamplesTTest_+3A_data">data</code></td>
<td>
<p>Optional data frame containing the variables.</p>
</td></tr>
<tr><td><code id="independentSamplesTTest_+3A_var.equal">var.equal</code></td>
<td>
<p>Should the test assume equal variances (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="independentSamplesTTest_+3A_one.sided">one.sided</code></td>
<td>
<p>One sided or two sided hypothesis test (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="independentSamplesTTest_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level for the confidence interval (default = .95).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>independentSamplesTTest</code> function runs an
independent-samples t-test and prints the results in a format that is
easier for novices to handle than the output of <code>t.test</code>. All the
actual calculations are done by the <code>t.test</code> and <code>cohensD</code>
functions. The <code>formula</code> argument must be a two-sided formula of
the form <code>outcome ~ group</code>. When <code>var.equal=TRUE</code>, a Student's
t-test is run and the estimate of Cohen's d uses a pooled estimate of
standard deviation. When <code>var.equal=FALSE</code>, the Welch test is used,
and the estimate of Cohen's d uses the &quot;unequal&quot; method.
</p>
<p>As with the <code>t.test</code> function, the default test is two sided,
corresponding to a default value of <code>one.sided = FALSE</code>. To specify
a one sided test, the <code>one.sided</code> argument must specify the name of
the factor level that is hypothesised (under the alternative) to have
the larger mean. For instance, if the outcome for &quot;group2&quot; is expected
to be higher than for &quot;group1&quot;, then the corresponding one sided test
is specified by <code>one.sided = "group2"</code>.
</p>


<h3>Value</h3>

<p>An object of class 'TTest'. When printed, the output is organised
into five short sections. The first section lists the name of the test and
the variables included. The second provides means and standard deviations.
The third states explicitly what the null and alternative hypotheses were.
The fourth contains the test results: t-statistic, degrees of freedom and
p-value. The final section includes the relevant confidence interval and
an estimate of the effect size (i.e., Cohen's d)
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+t.test">t.test</a></code>,
<code><a href="#topic+oneSampleTTest">oneSampleTTest</a></code>,
<code><a href="#topic+pairedSamplesTTest">pairedSamplesTTest</a></code>,
<code><a href="#topic+cohensD">cohensD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(
  rt = c(451, 562, 704, 324, 505, 600, 829),
  cond = factor( x=c(1,1,1,2,2,2,2), labels=c("group1","group2")))

# Welch t-test
independentSamplesTTest( rt ~ cond, df )

# Student t-test
independentSamplesTTest( rt ~ cond, df, var.equal=TRUE )

# one sided test
independentSamplesTTest( rt ~ cond, df, one.sided="group1" )

# missing data
df$rt[1] &lt;- NA
df$cond[7] &lt;- NA
independentSamplesTTest( rt ~ cond, df )

</code></pre>

<hr>
<h2 id='longToWide'>Reshape from long to wide</h2><span id='topic+longToWide'></span>

<h3>Description</h3>

<p>Reshape a data frame from long form to wide form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>longToWide(data, formula, sep = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="longToWide_+3A_data">data</code></td>
<td>
<p>The data frame.</p>
</td></tr>
<tr><td><code id="longToWide_+3A_formula">formula</code></td>
<td>
<p>A two-sided formula specifying measure variables and within-subject variables</p>
</td></tr>
<tr><td><code id="longToWide_+3A_sep">sep</code></td>
<td>
<p>Separator string used in wide-form variable names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>longToWide</code> function is the companion function to
<code>wideToLong</code>. The <code>data</code> argument is a &quot;long form&quot; data frame,
in which each row corresponds to a single observation. The output is a
&quot;wide form&quot; data frame, in which each row corresponds to a single
experimental unit (e.g., a single subject).
</p>
<p>The reshaping formula should list all of the measure variables on the
left hand side, and all of the within-subject variables on the right
hand side. All other variables are assumed to be between-subject variables.
For example, if the <code>accuracy</code> of a participant's performance is
measured at multiple <code>time</code> points, then the formula would be
<code>accuracy ~ time</code>.
</p>
<p>Multiple variables are supported on both sides of the formula. For example,
suppose we measured the response time <code>rt</code> and <code>accuracy</code> of
participants, across three separate <code>days</code>, and across three separate
<code>sessions</code> within each day. In this case the formula would be
<code>rt + accuracy ~ days + sessions</code>.
</p>


<h3>Value</h3>

<p>The output is a &quot;wide form&quot; data frame in containing one row per
subject (or experimental unit, more generally), with each observation of
that subject corresponding to a separate variable. The naming scheme for
these variables places the name of the measured variable first, followed
by the levels of within-subjects variable(s), separated by the separator
string <code>sep</code>. In the example above where the reshaping formula was
<code>accuracy ~ time</code>, if the default separator of <code>sep="_"</code> was
used, and the levels of the <code>time</code> variable are <code>t1</code>, <code>t2</code>
and <code>t3</code>, then the output would include the variables
<code>accuracy_t1</code>, <code>accuracy_t2</code> and <code>accuracy_t3</code>.
</p>
<p>In the second example listed above, where the reshaping formula was
<code>rt + accuracy ~ days + sessions</code>, the output variables would refer
to levels of both within-subjects variables. For instance,
<code>rt_day1_session1</code>, and <code>accuracy_day2_session1</code> might be the
names of two of the variables in the wide form data frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wideToLong">wideToLong</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>long &lt;- data.frame(
  id = c(1, 2, 3, 1, 2, 3, 1, 2, 3),
  time = c("t1", "t1", "t1", "t2", "t2", "t2", "t3", "t3", "t3"),
  accuracy = c(.50, .03, .72, .94, .63, .49, .78, .71, .16)
)

longToWide(long, accuracy ~ time)

</code></pre>

<hr>
<h2 id='maxFreq'>Sample mode</h2><span id='topic+maxFreq'></span><span id='topic+mode'></span><span id='topic+modeOf'></span>

<h3>Description</h3>

<p>Calculate the mode of a sample: both modal value(s) and
the corresponding frequency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxFreq(x, na.rm = TRUE)

modeOf(x, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxFreq_+3A_x">x</code></td>
<td>
<p>A vector containing the observations.</p>
</td></tr>
<tr><td><code id="maxFreq_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical value indicating whether NA values should be removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These two functions can be used to calculate the mode (most
frequently observed value) of a sample, and the actual frequency of the
modal value. The only complication is in respect to missing data. If
<code>na.rm = FALSE</code>, then there are multiple possibilities for how to
calculate the mode. One possibility is to treat <code>NA</code> as another
possible value for the elements of <code>x</code>, and therefore if <code>NA</code>
is more frequent than any other value, then <code>NA</code> is the mode; and
the modal frequency is equal to the number of missing values. This is
the version that is currently implemented.
</p>
<p>Another possibility is to treat <code>NA</code> as meaning &quot;true value unknown&quot;,
and to the mode of <code>x</code> is itself known only if the number of missing
values is small enough that &ndash; regardless of what value they have &ndash; they
cannot alter the sample mode. For instance, if <code>x</code> were
<code>c(1,1,1,1,2,2,NA)</code>, we know that the mode of <code>x</code> is <code>1</code>
regardless of what the true value is for the one missing datum; and we
know that the modal frequency is between 4 and 5. This is also a valid
interpretation, depending on what precisely it is the user wants, but
is not currently implemented.
</p>
<p>Because of the ambiguity of how <code>na.rm = FALSE</code> should be interpreted,
the default value has been set to <code>na.rm = TRUE</code>, which differs from
the default value used elsewhere in the package.
</p>


<h3>Value</h3>

<p>The <code>modeOf</code> function returns the mode of <code>x</code>. If there
are ties, it returns a vector containing all values of <code>x</code> that have
the modal frequency. The <code>maxFreq</code> function returns the modal
frequency as a numeric value.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+mean">mean</a></code>,
<code><a href="stats.html#topic+median">median</a></code>,
<code><a href="base.html#topic+table">table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple example
eyes &lt;- c("green","green","brown","brown","blue")
modeOf(eyes)
maxFreq(eyes)

# vector with missing data
eyes &lt;- c("green","green","brown","brown","blue",NA,NA,NA)

# returns NA as the modal value.
modeOf(eyes, na.rm = FALSE)
maxFreq(eyes, na.rm = FALSE)

# returns c("green", "brown") as the modes, as before
modeOf(eyes, na.rm = TRUE)
maxFreq(eyes, na.rm = TRUE)
</code></pre>

<hr>
<h2 id='oneSampleTTest'>One sample t-test</h2><span id='topic+oneSampleTTest'></span>

<h3>Description</h3>

<p>Convenience function that runs a one sample t-test. This is
a wrapper function intended to be used for pedagogical purposes only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneSampleTTest(x, mu, one.sided = FALSE, conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oneSampleTTest_+3A_x">x</code></td>
<td>
<p>The variable to be tested (required).</p>
</td></tr>
<tr><td><code id="oneSampleTTest_+3A_mu">mu</code></td>
<td>
<p>The value against which the mean should be tested (required).</p>
</td></tr>
<tr><td><code id="oneSampleTTest_+3A_one.sided">one.sided</code></td>
<td>
<p>One sided or two sided hypothesis test (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="oneSampleTTest_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level for the confidence interval (default = .95).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>oneSampleTTest</code> function runs a one-sample t-test on
the data in <code>x</code>, and prints the results in a format that is easier
for novices to handle than the output of <code>t.test</code>. All the actual
calculations are done by the <code>t.test</code> and <code>cohensD</code> functions.
</p>
<p>As with the <code>t.test</code> function, the default test is two sided,
corresponding to a default value of <code>one.sided = FALSE</code>. To specify
a one sided test in which the alternative hypothesis is that <code>x</code> is
larger than <code>mu</code>, the input must be <code>one.sided = "greater"</code>.
Similarly, if <code>one.sided="less"</code>, then the alternative hypothesis
is that the mean of <code>x</code> is smaller than <code>mu</code>.
</p>


<h3>Value</h3>

<p>An object of class 'TTest'. When printed, the output is organised
into five short sections. The first section lists the name of the test and
the variables included. The second provides means and standard deviations.
The third states explicitly what the null and alternative hypotheses were.
The fourth contains the test results: t-statistic, degrees of freedom and
p-value. The final section includes the relevant confidence interval and an
estimate of the effect size (i.e., Cohen's d).
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+t.test">t.test</a></code>,
<code><a href="#topic+pairedSamplesTTest">pairedSamplesTTest</a></code>,
<code><a href="#topic+independentSamplesTTest">independentSamplesTTest</a></code>,
<code><a href="#topic+cohensD">cohensD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
likert &lt;- c(3,1,4,1,4,6,7,2,6,6,7)

oneSampleTTest( x = likert, mu = 4 )
oneSampleTTest( x = likert, mu = 4, one.sided = "greater" )
oneSampleTTest( x = likert, mu = 4, conf.level=.99 )

likert &lt;- c(3,NA,4,NA,4,6,7,NA,6,6,7)
oneSampleTTest( x = likert, mu = 4 )

</code></pre>

<hr>
<h2 id='pairedSamplesTTest'>Paired samples t-test</h2><span id='topic+pairedSamplesTTest'></span>

<h3>Description</h3>

<p>Convenience function that runs a paired samples t-test. This
is a wrapper function intended to be used for pedagogical purposes only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairedSamplesTTest(
  formula,
  data = NULL,
  id = NULL,
  one.sided = FALSE,
  conf.level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairedSamplesTTest_+3A_formula">formula</code></td>
<td>
<p>Formula specifying the outcome and the groups (required).</p>
</td></tr>
<tr><td><code id="pairedSamplesTTest_+3A_data">data</code></td>
<td>
<p>Optional data frame containing the variables.</p>
</td></tr>
<tr><td><code id="pairedSamplesTTest_+3A_id">id</code></td>
<td>
<p>The name of the id variable (must be a character string).</p>
</td></tr>
<tr><td><code id="pairedSamplesTTest_+3A_one.sided">one.sided</code></td>
<td>
<p>One sided or two sided hypothesis test (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="pairedSamplesTTest_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level for the confidence interval (default = .95).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>pairedSamplesTTest</code> function runs a paired-sample t-test,
and prints the results in a format that is easier for novices to handle than
the output of <code>t.test</code>. All the actual calculations are done by the
<code>t.test</code> and <code>cohensD</code> functions.
</p>
<p>There are two different ways of specifying the formula, depending on whether
the data are in wide form or long form. If the data are in wide form, then
the input should be a one-sided formula of the form
<code>~ variable1 + variable2</code>. The <code>id</code> variable is not required: the
first element of <code>variable1</code> is paired with the first element of
<code>variable2</code> and so on. Both <code>variable1</code> and <code>variable2</code> must
be numeric.
</p>
<p>If the data are in long form, a two sided formula is required. The simplest
way to specify the test is to input a formula of the form
<code>outcome ~ group + (id)</code>. The term in parentheses is assumed to be
the <code>id</code> variable, and must be a factor. The <code>group</code> variable
must be a factor with two levels (if there are more than two levels but
only two are used in the data, a warning is given). The <code>outcome</code>
variable must be numeric.
</p>
<p>The reason for using the <code>outcome ~ group + (id)</code> format is that it is
broadly consistent with the way repeated measures analyses are specified
in the <code>lme4</code> package. However, this format may not appeal to some
people for teaching purposes. Given this, the <code>pairedSamplesTTest</code>
also supports a simpler formula of the form <code>outcome ~ group</code>, so
long as the user specifies the <code>id</code> argument: this must be a
character vector specifying the name of the id variable
</p>
<p>As with the <code>t.test</code> function, the default test is two sided,
corresponding to a default value of <code>one.sided = FALSE</code>. To specify
a one sided test, the <code>one.sided</code> argument must specify the name of
the factor level (long form data) or variable (wide form data) that is
hypothesised (under the alternative) to have the larger mean. For instance,
if the outcome at &quot;time2&quot; is expected to be higher than at &quot;time1&quot;, then
the corresponding one sided test is specified by <code>one.sided = "time2"</code>.
</p>


<h3>Value</h3>

<p>An object of class 'TTest'. When printed, the output is organised
into five short sections. The first section lists the name of the test
and the variables included. The second provides means and standard
deviations. The third states explicitly what the null and alternative
hypotheses were. The fourth contains the test results: t-statistic,
degrees of freedom and p-value. The final section includes the relevant
confidence interval and an estimate of the effect size (i.e., Cohen's d)
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+t.test">t.test</a></code>,
<code><a href="#topic+oneSampleTTest">oneSampleTTest</a></code>,
<code><a href="#topic+independentSamplesTTest">independentSamplesTTest</a></code>,
<code><a href="#topic+cohensD">cohensD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># long form data frame
df &lt;- data.frame(
  id = factor( x=c(1, 1, 2, 2, 3, 3, 4, 4),
               labels=c("alice","bob","chris","diana") ),
  time = factor( x=c(1,2,1,2,1,2,1,2),
                 labels=c("time1","time2")),
  wm = c(3, 4, 6, 6, 9, 12,7,9)
)

# wide form
df2 &lt;- longToWide( df, wm ~ time )

# basic test, run from long form or wide form data
pairedSamplesTTest( formula= wm ~ time, data=df, id="id" )
pairedSamplesTTest( formula= wm ~ time + (id), data=df )
pairedSamplesTTest( formula= ~wm_time1 + wm_time2, data=df2 )

# one sided test
pairedSamplesTTest( formula= wm~time, data=df, id="id", one.sided="time2" )

# missing data because of NA values
df$wm[1] &lt;- NA
pairedSamplesTTest( formula= wm~time, data=df, id="id" )

# missing data because of missing cases from the long form data frame
df &lt;- df[-1,]
pairedSamplesTTest( formula= wm~time, data=df, id="id" )

</code></pre>

<hr>
<h2 id='permuteLevels'>Permute the levels of a factor</h2><span id='topic+permuteLevels'></span>

<h3>Description</h3>

<p>Apply an arbitrary permutation to the ordering of levels
within a factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permuteLevels(x, perm, ordered = is.ordered(x), invert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permuteLevels_+3A_x">x</code></td>
<td>
<p>The factor to be permuted</p>
</td></tr>
<tr><td><code id="permuteLevels_+3A_perm">perm</code></td>
<td>
<p>A vector specifying the permutation</p>
</td></tr>
<tr><td><code id="permuteLevels_+3A_ordered">ordered</code></td>
<td>
<p>Should the output be an ordered factor?</p>
</td></tr>
<tr><td><code id="permuteLevels_+3A_invert">invert</code></td>
<td>
<p>Use the inverse of <code>perm</code> to specify the permutation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenience function used to shuffle the order in
which the levels of a factor are specified. It is similar in spirit to
the <code>relevel</code> function, but more general. The <code>relevel</code>
function only changes the first level of the factor, whereas
<code>permuteLevels</code> can apply an arbitrary permutation. This can be
useful for plotting data, because some plotting functions will display
the factor levels in the same order that they appear within the factor.
</p>
<p>The <code>perm</code> argument is a vector of the same length as <code>levels(x)</code>,
such that <code>perm[k]</code> is an integer that indicates which of the old
levels should be moved to position k. However, if <code>invert=TRUE</code>, the
inverse permutation is applied: that is, <code>perm[k]</code> is an integer
specifying where to move the k-th level of the original factor. See the
examples for more details.
</p>


<h3>Value</h3>

<p>Returns a factor with identical values, but with the ordering
of the factor levels shuffled.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+factor">factor</a></code>,
<code><a href="base.html#topic+order">order</a></code>,
<code><a href="stats.html#topic+relevel">relevel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# original factor specifies the levels in order: a,b,c,d,e,f
x &lt;- factor( c(1,4,2,2,3,3,5,5,6,6), labels=letters[1:6] )
print(x)

# apply permutation (5 3 2 1 4 6)... i.e., move 5th factor level (e)
# into position 1, move 3rd factor level (c) into position 2, etc
permuteLevels(x,perm = c(5,3,2,1,4,6))

# apply the inverse of permutation (5 3 2 1 4 6)... i.e., move 1st
# level (a) into position 5, move 2nd level (b) into position 3, etc
permuteLevels(x,perm = c(5,3,2,1,4,6),invert=TRUE)

</code></pre>

<hr>
<h2 id='posthocPairwiseT'>Post-hoc pairwise t-tests for ANOVA</h2><span id='topic+posthocPairwiseT'></span>

<h3>Description</h3>

<p>Performs pairwise t-tests for an analysis of variance,
making corrections for multiple comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posthocPairwiseT(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posthocPairwiseT_+3A_x">x</code></td>
<td>
<p>An <code>aov</code> object</p>
</td></tr>
<tr><td><code id="posthocPairwiseT_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>pairwise.t.test</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The intention behind this function is to allow users to use simple
tools for multiple corrections (e.g., Bonferroni, Holm) as post hoc
corrections in an ANOVA context, using the fitted model object (i.e., an
<code>aov</code> object) as the input. The reason for including this function is
that Tukey / Scheffe methods for constructing simultaneous confidence
intervals (as per <code><a href="stats.html#topic+TukeyHSD">TukeyHSD</a></code>) are not often discussed in the
context of an introductory class, and the more powerful tools provided by
the <code>multcomp</code> package are not appropriate for students just beginning
to learn statistics.
</p>
<p>This function is currently just a wrapper function for
<code><a href="stats.html#topic+pairwise.t.test">pairwise.t.test</a></code>, and it only works for one-way ANOVA, but
this may change in future versions.
</p>


<h3>Value</h3>

<p>As per <code>pairwise.t.test</code>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+pairwise.t.test">pairwise.t.test</a></code>,
<code><a href="stats.html#topic+TukeyHSD">TukeyHSD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the data set to analyse:
dataset &lt;- data.frame(
  outcome = c( 1,2,3, 2,3,4, 5,6,7 ),
  group = factor(c( "a","a","a", "b","b","b","c","c","c"))
)

# run the ANOVA and print out the ANOVA table:
anova1 &lt;- aov( outcome ~ group, data = dataset )
summary(anova1)

# Currently, the following two commands are equivalent:
posthocPairwiseT( anova1 )
pairwise.t.test( dataset$outcome, dataset$group )

</code></pre>

<hr>
<h2 id='print.assocTest'>Print method for lsr chi-square tests</h2><span id='topic+print.assocTest'></span>

<h3>Description</h3>

<p>Print method for lsr chi-square tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'assocTest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.assocTest_+3A_x">x</code></td>
<td>
<p>An object of class 'assocTest'</p>
</td></tr>
<tr><td><code id="print.assocTest_+3A_...">...</code></td>
<td>
<p>For consistency with the generic (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the original object
</p>

<hr>
<h2 id='print.correlate'>Print method for correlate objects</h2><span id='topic+print.correlate'></span>

<h3>Description</h3>

<p>Print method for correlate objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'correlate'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.correlate_+3A_x">x</code></td>
<td>
<p>An object of class 'correlate'</p>
</td></tr>
<tr><td><code id="print.correlate_+3A_...">...</code></td>
<td>
<p>For consistency with the generic (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the original object
</p>

<hr>
<h2 id='print.gofTest'>Print method for lsr goodness-of-fit tests</h2><span id='topic+print.gofTest'></span>

<h3>Description</h3>

<p>Print method for lsr goodness-of-fit tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gofTest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gofTest_+3A_x">x</code></td>
<td>
<p>An object of class 'gofTest'</p>
</td></tr>
<tr><td><code id="print.gofTest_+3A_...">...</code></td>
<td>
<p>For consistency with the generic (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the original object
</p>

<hr>
<h2 id='print.TTest'>Print method for lsr t-tests</h2><span id='topic+print.TTest'></span>

<h3>Description</h3>

<p>Print method for lsr t-tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TTest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.TTest_+3A_x">x</code></td>
<td>
<p>An object of class 'TTest'</p>
</td></tr>
<tr><td><code id="print.TTest_+3A_...">...</code></td>
<td>
<p>For consistency with the generic (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the original object
</p>

<hr>
<h2 id='print.whoList'>Print method for whoList objects</h2><span id='topic+print.whoList'></span>

<h3>Description</h3>

<p>Print method for whoList objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'whoList'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.whoList_+3A_x">x</code></td>
<td>
<p>An object of class 'whoList'</p>
</td></tr>
<tr><td><code id="print.whoList_+3A_...">...</code></td>
<td>
<p>For consistency with the generic (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the original object
</p>

<hr>
<h2 id='quantileCut'>Cut by quantiles</h2><span id='topic+quantileCut'></span>

<h3>Description</h3>

<p>Cuts a variable into equal sized categories
</p>
<p>It is sometimes convenient (though not always wise) to split a
continuous numeric variable <code>x</code> into a set of <code>n</code> discrete
categories that contain an approximately equal number of cases. The
<code>quantileCut</code> function does exactly this. The actual categorisation
is done by the <code><a href="base.html#topic+cut">cut</a></code> function. However, instead of selecting
ranges of equal sizes (the default behaviour in <code>cut</code>), the
<code>quantileCut</code> function uses the <code><a href="stats.html#topic+quantile">quantile</a></code> function to
select  unequal sized ranges so as to ensure that each of the categories
contains the same number of observations. The intended purpose of the
function is to assist in exploratory data analysis; it is not generally
a good idea to use the output of <code>quantileCut</code> function as a factor
in an analysis of variance, for instance, since the factor levels are not
interpretable and will almost certainly violate homogeneity of variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantileCut(x, n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantileCut_+3A_x">x</code></td>
<td>
<p>A vector containing the observations.</p>
</td></tr>
<tr><td><code id="quantileCut_+3A_n">n</code></td>
<td>
<p>Number of categories</p>
</td></tr>
<tr><td><code id="quantileCut_+3A_...">...</code></td>
<td>
<p>Additional arguments to cut</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor containing <code>n</code> levels. The factor levels are
determined in the same way as for the <code>cut</code> function, and can be
specified manually using the <code>labels</code> argument, which is passed to
the <code>cut</code> function.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cut">cut</a></code>, <code><a href="stats.html#topic+quantile">quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># An example illustrating why care is needed

dataset &lt;- c( 0,1,2, 3,4,5, 7,10,15 )       # note the uneven spread of data
x &lt;- quantileCut( dataset, 3 )              # cut into 3 equally frequent bins
table(x)                                    # tabulate

# For comparison purposes, here is the behaviour of the more standard cut
# function when applied to the same data:
y &lt;- cut( dataset, 3 )
table(y)

</code></pre>

<hr>
<h2 id='rmAll'>Remove all objects</h2><span id='topic+rmAll'></span>

<h3>Description</h3>

<p>Removes all objects from the workspace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmAll(ask = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmAll_+3A_ask">ask</code></td>
<td>
<p>Logical value indicating whether to ask user to confirm deletions. Default is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rmAll</code> function provides a simple way of deleting all
objects from the workspace. It is almost equivalent to the usual
<code>rm(list = objects())</code> command. The only difference that it requires
the user to confirm the deletions first if <code>ask = TRUE</code>, after
displaying a list of the current objects in the worspace. This can
occasionally be useful for teaching purposes.
</p>


<h3>Value</h3>

<p>Invisibly returns 0 if no deletions are made, 1 if at least one deletion is made.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rm">rm</a></code>
</p>

<hr>
<h2 id='sortFrame'>Sort a data frame</h2><span id='topic+sortFrame'></span>

<h3>Description</h3>

<p>Sorts a data frame using one or more variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortFrame(x, ..., alphabetical = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortFrame_+3A_x">x</code></td>
<td>
<p>Data frame to be sorted</p>
</td></tr>
<tr><td><code id="sortFrame_+3A_...">...</code></td>
<td>
<p>A list of sort terms (see below)</p>
</td></tr>
<tr><td><code id="sortFrame_+3A_alphabetical">alphabetical</code></td>
<td>
<p>Should character vectors be sorted alphabetically?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simplest use of this function is to sort a data frame <code>x</code>
in terms of one or more of the variables it contains. If for instance,
the data frame <code>x</code> contains two variables <code>a</code> and <code>b</code>, then
the command <code>sortFrame(x,a,b)</code> sorts by variable <code>a</code>, breaking
ties using variable <code>b</code>. Numeric variables are sorted in ascending
order: to sort in descending order of <code>a</code> and then ascending order
of <code>b</code>, use the command <code>sortFrame(x,-a,b)</code>. Factors are treated
as numeric variables, and are sorted by the internal codes (i.e., the first
factor level equals 1, the second factor levels equals 2 and so on).
Character vectors are sorted in alphabetical order, which differs from the
ordering used by the <code><a href="base.html#topic+sort">sort</a></code> function; to use the default 'ascii'
ordering, specify <code>alphabetical=FALSE</code>. Minus signs can be used in
conjunction with character vectors in order to sort in reverse alphabetical
order. If <code>c</code> represents a character variable, then <code>sortFrame(x,c)</code>
sorts in alphabetical order, whereas <code>sortFrame(x,-c)</code> sorts in reverse
alphabetical order.
</p>
<p>It is also possible to specify more complicated sort terms by including
expressions using multiple variables within a single term, but care is
required. For instance, it is possible to sort the data frame by the sum of
two variables, using the command <code>sortFrame(x, a+b)</code>. For numeric
variables expressions of this kind should work in the expected manner, but
this is not always the case for non-numeric variables: <code>sortFrame</code> uses
the <code><a href="base.html#topic+xtfrm">xtfrm</a></code> function to provide, for every variable referred to
in the list of sort terms (<code>...</code>) a numeric vector that sorts in the
same order as the original variable. This reliance is what makes reverse
alphabetical order (e.g., <code>sortFrame(x,-c)</code>) work. However, it also
means that it is possible to specify somewhat nonsensical sort terms for
character vectors by abusing the numerical coding (e.g.
<code>sortFrame(x,(c-3)^2)</code>; see the examples section). It also means
that sorting in terms of string operation functions (e.g., <code>nchar</code>)
do not work as expected. See examples section. Future versions of
<code>sortFrame</code> will (hopefully) address this, possibly by allowing the
user to &quot;switch off&quot; the internal use of <code>xtfrm</code>, or else by allowing
<code><a href="base.html#topic+AsIs">AsIs</a></code> expressions to be used in sort terms.
</p>


<h3>Value</h3>

<p>The sorted data frame
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sort">sort</a></code>, <code><a href="base.html#topic+order">order</a></code>, <code><a href="base.html#topic+xtfrm">xtfrm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>txt &lt;- c("bob","Clare","clare","bob","eve","eve")
num1 &lt;- c(3,1,2,0,0,2)
num2 &lt;- c(1,1,3,0,3,2)
etc &lt;- c("not","used","as","a","sort","term")
dataset &lt;- data.frame( txt, num1, num2, etc, stringsAsFactors=FALSE )

sortFrame( dataset, num1 )
sortFrame( dataset, num1, num2 )
sortFrame( dataset, txt )

</code></pre>

<hr>
<h2 id='standardCoefs'>Standardised regression coefficients</h2><span id='topic+standardCoefs'></span>

<h3>Description</h3>

<p>Calculates the standardised regression coefficients for a linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardCoefs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardCoefs_+3A_x">x</code></td>
<td>
<p>A linear model object (i.e. class <code>lm</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the standardised regression coefficients (beta-weights),
namely the values of the regression coefficients that would have been observed
has all regressors and the outcome variable been scaled to have mean 0 and
variance 1 before fitting the regression model. Standardised coefficients are
sometimes useful in some applied contexts since there is a sense in which all
beta values are &quot;on the same scale&quot;, though this is not entirely unproblematic.
</p>


<h3>Value</h3>

<p>A matrix with the regressors as rows, and the two different
regression coefficients (unstandardised and standardised) as the two
columns. The columns are labeled b (unstandardised) and beta (standardised).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1: simple linear regression

# data
X1 &lt;- c(0.69, 0.77, 0.92, 1.72, 1.79, 2.37, 2.64, 2.69, 2.84, 3.41)
Y  &lt;- c(3.28, 4.23, 3.34, 3.73, 5.33, 6.02, 5.16, 6.49, 6.49, 6.05)

model1 &lt;- lm( Y ~ X1 )  # run a simple linear regression
coefficients( model1 )  # extract the raw regression coefficients
standardCoefs( model1 ) # extract standardised coefficients


# Example 2: multiple linear regression

X2 &lt;- c(0.19, 0.22, 0.95, 0.43, 0.51, 0.04, 0.12, 0.44, 0.38, 0.33)
model2 &lt;- lm( Y ~ X1 + X2 )   # new model
standardCoefs( model2 )       # standardised coefficients

#Example 3: interaction terms

model3 &lt;- lm( Y ~ X1 * X2 )
coefficients( model3 )
standardCoefs( model3 )

# Note that these beta values are equivalent to standardising all
# three regressors including the interaction term X1:X2, not merely
# standardising the two predictors X1 and X2.

</code></pre>

<hr>
<h2 id='tFrame'>Transpose a data frame</h2><span id='topic+tFrame'></span>

<h3>Description</h3>

<p>Transposes a data frame, converting variables to cases and vice versa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tFrame(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tFrame_+3A_x">x</code></td>
<td>
<p>The data frame to be transposed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>tFrame</code> function is a convenience function that simply
transposes the input data frame and coerces the result back to a data frame.
Apart from a very small amount of exception handling, it is equivalent to
<code>as.data.frame(t(x))</code>. It exists simply because I sometimes find it
convenient when teaching statistics to discuss simple data handling before
going into details regarding coercion; similarly, since I generally have
students work with data frames before exposing them to matrices, it is
convenient to have a transpose function that returns a data frame as output.
</p>
<p>Naturally, the <code>tFrame</code> function should only be used when it is
actually sensible to think of the cases of <code>x</code> as variables in their
own right. In real life I expect that this maps almost perfectly onto those
cases where <code>x</code> could be a matrix just as easily as a data frame, so
I don't believe that <code>tFrame</code> is useful in real world data analysis. It
is intended as a teaching tool.
</p>


<h3>Value</h3>

<p>The transposed data frame
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+t">t</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a data frame that could sensibly be transposed...
Gf &lt;- c(105, 119, 121, 98)   # fluid intelligence for 4 people
Gc &lt;- c(110, 115, 119, 103)  # crystallised intelligence
Gs &lt;- c(112, 102, 108, 99)   # speed of processing
dataset &lt;- data.frame( Gf, Gc, Gs )
rownames(dataset) &lt;- paste( "person", 1:4, sep="" )
print(dataset)

# Now transpose it...
tFrame( dataset )

</code></pre>

<hr>
<h2 id='unlibrary'>Unload a package</h2><span id='topic+unlibrary'></span>

<h3>Description</h3>

<p>A wrapper function to <code><a href="base.html#topic+detach">detach</a></code> that removes a package
from the search path, but takes a package name as input similar to <code><a href="base.html#topic+library">library</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unlibrary(package)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unlibrary_+3A_package">package</code></td>
<td>
<p>A package name, which may be specified with or without quotes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unloads a package. This is just a wrapper for the <code>detach</code>
function. However, the <code>package</code> argument is just the name of the
package (rather than the longer string that is required by the <code>detach</code>
function), and &ndash; like the <code>library</code> function &ndash; can be specified
without quote marks. The <code>unlibrary</code> function does not unload dependencies,
only the named package.
</p>
<p>The name &quot;unlibrary&quot; is a bit of an abuse of both R terminology (in which
one has a library of packages) and the English language, but I think it
helps convey that the goal of the <code>unlibrary</code> function is to do the
opposite of what the <code>library</code> function does.
</p>


<h3>Value</h3>

<p>Identical to <code>detach</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+library">library</a></code>, <code><a href="base.html#topic+require">require</a></code>, <code><a href="base.html#topic+detach">detach</a></code>
</p>

<hr>
<h2 id='who'>Contents of workspace</h2><span id='topic+who'></span>

<h3>Description</h3>

<p>Prints out a simple summary of all the objects in the workspace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>who(expand = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="who_+3A_expand">expand</code></td>
<td>
<p>Should R &quot;expand&quot; data frames when listing variables? If
<code>expand = TRUE</code>, variables inside a data frame are included in the
output. The default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>who</code> function prints out some basic information about
all variables in the workspace. Specifically, it lists the names of all
variables, what class they are, and how big they are (see below for
specifics). If the <code>expand</code> argument is <code>TRUE</code> it will also
print out the same information about variables within data frames. See
the examples below to see what the output looks like.
</p>
<p>The purpose for the function is to show more information than the
<code>objects</code> function (especially as regards the names of variables
inside data frames), but not to show as much detail as the <code>ls.str</code>
function, which is generally too verbose for novice users.
</p>
<p>The &quot;size&quot; of an object is only reported for some kinds of object:
specifically, only those objects whose <code><a href="#topic+mode">mode</a></code> is either
<code>numeric</code>, <code>character</code>, <code>logical</code>, <code>complex</code> or
<code>list</code>. Nothing is printed for any other kind of object. If the
object has explicit dimensions (e.g., data frames or matrices) then
<code>who</code> prints out the dimension sizes (e.g., &quot;2 x 3&quot; ). Otherwise
the length of the object is printed.
</p>


<h3>Value</h3>

<p><code>who</code> returns an object of class <code>whoList</code> which is
just a data frame with a dedicated print method.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+objects">objects</a></code>, <code><a href="utils.html#topic+ls.str">ls.str</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cats &lt;- 4
mood &lt;- "happy"
who()

dataset &lt;- data.frame(
  hi = c( "hello","cruel","world" ),
  pi = c( 3,1,4 )
)

who()
who(expand = TRUE)

</code></pre>

<hr>
<h2 id='wideToLong'>Reshape from wide to long</h2><span id='topic+wideToLong'></span>

<h3>Description</h3>

<p>Reshape a data frame from wide form to long form using the variable names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wideToLong(data, within = "within", sep = "_", split = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wideToLong_+3A_data">data</code></td>
<td>
<p>The data frame.</p>
</td></tr>
<tr><td><code id="wideToLong_+3A_within">within</code></td>
<td>
<p>Name to give to the long-form within-subject factor(s)</p>
</td></tr>
<tr><td><code id="wideToLong_+3A_sep">sep</code></td>
<td>
<p>Separator string used in wide-form variable names</p>
</td></tr>
<tr><td><code id="wideToLong_+3A_split">split</code></td>
<td>
<p>Should multiple within-subject factors be split into multiple variables?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>wideToLong</code> function is the companion function to <code>longToWide</code>.
The <code>data</code> argument is a &quot;wide form&quot; data frame, in which each row corresponds to
a single experimental unit (e.g., a single subject).  The output is a &quot;long form&quot; data
frame, in which each row corresponds to a single observation.
</p>
<p>The <code>wideToLong</code> function relies on the variable names to determine how the data
should be reshaped. The naming scheme for these variables places the name of the
measured variable first, followed by the levels of the within-subjects variable(s),
separated by the separator string <code>sep</code> (default is <code>_</code>) The separator
string cannot appear anywhere else in the variable names: variables without
the separator string are assumed to be between-subject variables.
</p>
<p>If the experiment measured the <code>accuracy</code> of participants at some task
at two different points in time, then the wide form data frame would contain
variables of the form <code>accuracy_t1</code> and <code>accuracy_t2</code>. After
reshaping, the long form data frame would contain one measured variable
called <code>accuracy</code>, and a within-subjects factor with levels <code>t1</code>
and <code>t2</code>. The name of the within-subjects factor is the <code>within</code>
argument.
</p>
<p>The function supports experimental designs with multiple within-subjects
factors and multi-variable observations. For example, suppose each
experimental subject is tested in two <code>conditions</code> (<code>cond1</code> and
<code>cond2</code>), on each of two <code>days</code> (<code>day1</code> and <code>day2</code>),
yielding an experimental design in which four observations are made for
each subject. For each such observation, we record the mean response time
<code>MRT</code> for and proportion of correct responses <code>PC</code> for the
participant.  The variable names needed for a design such as this one would
be <code>MRT_cond1_day1</code>, <code>MRT_cond1_day2</code>, <code>PC_cond1_day1</code>, etc.
The <code>within</code> argument should be a vector of names for the
within-subject factors: in this case, <code>within = c("condition","day")</code>.
</p>
<p>By default, if there are multiple within-subject factors implied by the
existence of multiple separators, the output will keep these as distinct
variables in the long form data frame (<code>split=FALSE</code>). If
<code>split=TRUE</code>, the within-subject factors will be collapsed into a
single variable.
</p>


<h3>Value</h3>

<p>A data frame containing the reshaped data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+longToWide">longToWide</a></code>, <code><a href="stats.html#topic+reshape">reshape</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Outcome measure is mean response time (MRT), measured in two conditions
# with 4 participants. All participants participate in both conditions.

wide &lt;- data.frame( accuracy_t1 = c( .15,.50,.78,.55 ),  # accuracy at time point 1
                    accuracy_t2 = c( .55,.32,.99,.60 ),  # accuracy at time point 2
                    id = 1:4 )                           # id variable

# convert to long form
wideToLong( wide, "time" )


# A more complex design with multiple within-subject factors. Again, we have only
# four participants, but now we have two different outcome measures, mean response
# time (MRT) and the proportion of correct responses (PC). Additionally, we have two
# different repeated measures variables. As before, we have the experimental condition
# (cond1, cond2), but this time each participant does both conditions on two different
# days (day1, day2). Finally, we have multiple between-subject variables too, namely
# id and gender.

wide2 &lt;- data.frame( id = 1:4,
                     gender = factor( c("male","male","female","female") ),
                     MRT_cond1_day1 = c( 415,500,478,550 ),
                     MRT_cond2_day1 = c( 455,532,499,602 ),
                     MRT_cond1_day2 = c( 400,490,468,502 ),
                     MRT_cond2_day2 = c( 450,518,474,588 ),
                     PC_cond1_day1 = c( 79,83,91,75 ),
                     PC_cond2_day1 = c( 82,86,90,78 ),
                     PC_cond1_day2 = c( 88,92,98,89 ),
                     PC_cond2_day2 = c( 93,97,100,95 ) )

# conversion to long form:
wideToLong( wide2 )
wideToLong( wide2, within = c("condition","day") )

# treat "condition x day" as a single repeated measures variable:
wideToLong( wide2, split = FALSE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
