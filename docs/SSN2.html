<!DOCTYPE html><html><head><title>Help for package SSN2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SSN2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SSN2-package'><p>SSN2: Spatial Modeling on Stream Networks</p></a></li>
<li><a href='#AIC.SSN2'><p>Compute AIC and AICc of fitted model objects</p></a></li>
<li><a href='#anova.SSN2'><p>Compute analysis of variance and likelihood ratio tests of fitted model objects</p></a></li>
<li><a href='#augment.SSN2'><p>Augment data with information from fitted model objects</p></a></li>
<li><a href='#coef.SSN2'><p>Extract fitted model coefficients</p></a></li>
<li><a href='#confint.SSN2'><p>Confidence intervals for fitted model parameters</p></a></li>
<li><a href='#cooks.distance.SSN2'><p>Compute Cook's distance</p></a></li>
<li><a href='#copy_lsn_to_temp'><p>Copy LSN to temporary directory</p></a></li>
<li><a href='#covmatrix.SSN2'><p>Create a covariance matrix</p></a></li>
<li><a href='#deviance.SSN2'><p>Fitted model deviance</p></a></li>
<li><a href='#fitted.SSN2'><p>Extract model fitted values</p></a></li>
<li><a href='#formula.SSN2'><p>Model formulae</p></a></li>
<li><a href='#glance.SSN2'><p>Glance at a fitted model object</p></a></li>
<li><a href='#glances.SSN2'><p>Glance at many fitted model objects</p></a></li>
<li><a href='#hatvalues.SSN2'><p>Compute leverage (hat) values</p></a></li>
<li><a href='#influence.SSN2'><p>Regression diagnostics</p></a></li>
<li><a href='#labels.SSN2'><p>Find labels from object</p></a></li>
<li><a href='#logLik.SSN2'><p>Extract log-likelihood</p></a></li>
<li><a href='#loocv.SSN2'><p>Perform leave-one-out cross validation</p></a></li>
<li><a href='#mf04p'><p>Imported SSN object from the MiddleFork04.ssn data folder</p></a></li>
<li><a href='#MiddleFork04.ssn'><p>MiddleFork04.ssn: Middle Fork 2004 stream temperature dataset</p></a></li>
<li><a href='#model.frame.SSN2'><p>Extract the model frame from a fitted model object</p></a></li>
<li><a href='#model.matrix.SSN2'><p>Extract the model matrix from a fitted model object</p></a></li>
<li><a href='#names.SSN'><p>names SSN object</p></a></li>
<li><a href='#plot.SSN2'><p>Plot fitted model diagnostics</p></a></li>
<li><a href='#plot.Torgegram'><p>Plot Torgegram</p></a></li>
<li><a href='#predict.SSN2'><p>Model predictions (Kriging)</p></a></li>
<li><a href='#print.SSN'><p>Print SSN object</p></a></li>
<li><a href='#print.SSN2'><p>Print values</p></a></li>
<li><a href='#pseudoR2.SSN2'><p>Compute a pseudo r-squared</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#residuals.SSN2'><p>Extract fitted model residuals</p></a></li>
<li><a href='#ssn_create_distmat'><p>Calculate Hydrologic Distances for an <code>SSN</code> object</p></a></li>
<li><a href='#ssn_get_data'><p>Get a data.frame from an SSN, ssn_lm, or ssn_glm object</p></a></li>
<li><a href='#ssn_get_netgeom'><p>Extract netgeom column</p></a></li>
<li><a href='#ssn_get_stream_distmat'><p>Get stream distance matrices from an <code>SSN</code> object</p></a></li>
<li><a href='#ssn_glm'><p>Fitting Generalized Linear Models for Spatial Stream Networks</p></a></li>
<li><a href='#ssn_import'><p>Import <code>SSN</code> object</p></a></li>
<li><a href='#ssn_import_predpts'><p>Import prediction points into an SSN, ssn_lm, or ssn_glm object</p></a></li>
<li><a href='#ssn_initial'><p>Create a covariance parameter initial object</p></a></li>
<li><a href='#ssn_lm'><p>Fitting Linear Models for Spatial Stream Networks</p></a></li>
<li><a href='#ssn_params'><p>Create covariance parameter objects.</p></a></li>
<li><a href='#ssn_put_data'><p>Put an sf data.frame in an SSN object</p></a></li>
<li><a href='#ssn_simulate'><p>Simulate random variables on a stream network</p></a></li>
<li><a href='#ssn_split_predpts'><p>Split a prediction dataset in an <code>SSN</code> object</p></a></li>
<li><a href='#ssn_subset'><p>Subset an <code>SSN</code> object</p></a></li>
<li><a href='#SSN_to_SSN2'><p>Convert object from <code>SpatialStreamNetwork</code> class to <code>SSN</code> class</p></a></li>
<li><a href='#ssn_update_path'><p>Update path in an SSN object</p></a></li>
<li><a href='#ssn_write'><p>write an SSN object</p></a></li>
<li><a href='#summary.SSN'><p>Summarize an SSN object</p></a></li>
<li><a href='#summary.SSN2'><p>Summarize a fitted model object</p></a></li>
<li><a href='#tidy.SSN2'><p>Tidy a fitted model object</p></a></li>
<li><a href='#Torgegram'><p>Compute the empirical semivariogram</p></a></li>
<li><a href='#varcomp.SSN2'><p>Variability component comparison</p></a></li>
<li><a href='#vcov.SSN2'><p>Calculate variance-covariance matrix for a fitted model object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Spatial Modeling on Stream Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Spatial statistical modeling and prediction for data on stream networks, including models based on in-stream distance (Ver Hoef, J.M. and Peterson, E.E., (2010) &lt;<a href="https://doi.org/10.1198%2Fjasa.2009.ap08248">doi:10.1198/jasa.2009.ap08248</a>&gt;.) Models are created using moving average constructions. Spatial linear models, including explanatory variables, can be fit with (restricted) maximum likelihood.  Mapping and other graphical functions are included. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, sf, Matrix, generics, tibble, graphics, parallel,
spmodel, RSQLite, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0), ggplot2, sp, statmod</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://usepa.github.io/SSN2/">https://usepa.github.io/SSN2/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/USEPA/SSN2/issues">https://github.com/USEPA/SSN2/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-15 17:21:49 UTC; MDUMELLE</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Dumelle <a href="https://orcid.org/0000-0002-3393-5529"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jay M. Ver Hoef [aut],
  Erin Peterson [aut],
  Alan Pearse [ctb],
  Dan Isaak [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Dumelle &lt;Dumelle.Michael@epa.gov&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-15 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='SSN2-package'>SSN2: Spatial Modeling on Stream Networks</h2><span id='topic+SSN2'></span><span id='topic+SSN2-package'></span>

<h3>Description</h3>

<p>Spatial statistical modeling and prediction for data on stream networks, including models based on in-stream distance (Ver Hoef, J.M. and Peterson, E.E., (2010) <a href="https://doi.org/10.1198/jasa.2009.ap08248">doi:10.1198/jasa.2009.ap08248</a>.) Models are created using moving average constructions. Spatial linear models, including explanatory variables, can be fit with (restricted) maximum likelihood. Mapping and other graphical functions are included.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael Dumelle <a href="mailto:Dumelle.Michael@epa.gov">Dumelle.Michael@epa.gov</a> (<a href="https://orcid.org/0000-0002-3393-5529">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Jay M. Ver Hoef <a href="mailto:jay.verhoef@noaa.gov">jay.verhoef@noaa.gov</a>
</p>
</li>
<li><p> Erin Peterson
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Alan Pearse [contributor]
</p>
</li>
<li><p> Dan Isaak [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://usepa.github.io/SSN2/">https://usepa.github.io/SSN2/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/USEPA/SSN2/issues">https://github.com/USEPA/SSN2/issues</a>
</p>
</li></ul>


<hr>
<h2 id='AIC.SSN2'>Compute AIC and AICc of fitted model objects</h2><span id='topic+AIC.SSN2'></span><span id='topic+AIC.ssn_lm'></span><span id='topic+AIC.ssn_glm'></span><span id='topic+AICc.ssn_lm'></span><span id='topic+AICc.ssn_glm'></span>

<h3>Description</h3>

<p>Compute AIC and AICc for one or
several fitted model objects for which a log-likelihood
value can be obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
AIC(object, ..., k = 2)

## S3 method for class 'ssn_glm'
AIC(object, ..., k = 2)

## S3 method for class 'ssn_lm'
AICc(object, ..., k = 2)

## S3 method for class 'ssn_glm'
AICc(object, ..., k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.SSN2_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="AIC.SSN2_+3A_...">...</code></td>
<td>
<p>Optionally more fitted model objects.</p>
</td></tr>
<tr><td><code id="AIC.SSN2_+3A_k">k</code></td>
<td>
<p>The penalty parameter, taken to be 2. Currently not allowed to differ
from 2 (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When comparing models fit by maximum or restricted maximum
likelihood, the smaller the AIC or AICc, the better the fit. The AICc contains
a correction to AIC for small sample sizes. AIC and AICc comparisons between <code>"ml"</code>
and <code>"reml"</code> models are meaningless &ndash; comparisons should only be made
within a set of models estimated using <code>"ml"</code> or a set of models estimated
using <code>"reml"</code>. AIC and AICc comparisons for <code>"reml"</code> must
use the same fixed effects. To vary the covariance parameters and
fixed effects simultaneously, use <code>"ml"</code>.
</p>
<p>The AIC is defined as
<code class="reqn">-2loglik + 2(npar)</code> and the AICc is defined as
<code class="reqn">-2loglik + 2n(npar) / (n - npar - 1)</code>, where <code class="reqn">n</code> is the sample size
and <code class="reqn">npar</code> is the number of estimated parameters. For <code>"ml"</code>, <code class="reqn">npar</code> is
the number of estimated covariance parameters plus the number of estimated
fixed effects. For <code>"reml"</code>, <code class="reqn">npar</code> is the number of estimated covariance
parameters.
</p>


<h3>Value</h3>

<p>If just one object is provided, a numeric value with the corresponding
AIC or AICc.
</p>
<p>If multiple objects are provided, a <code>data.frame</code> with rows corresponding
to the objects and columns representing the number of parameters estimated
(<code>df</code>) and the AIC or AICc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
AIC(ssn_mod)
AICc(ssn_mod)
</code></pre>

<hr>
<h2 id='anova.SSN2'>Compute analysis of variance and likelihood ratio tests of fitted model objects</h2><span id='topic+anova.SSN2'></span><span id='topic+anova.ssn_lm'></span><span id='topic+anova.ssn_glm'></span><span id='topic+tidy.anova.ssn_lm'></span><span id='topic+tidy.anova.ssn_glm'></span>

<h3>Description</h3>

<p>Compute analysis of variance tables for a fitted model object or
a likelihood ratio test for two fitted model objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
anova(object, ..., test = TRUE, Terms, L)

## S3 method for class 'ssn_glm'
anova(object, ..., test = TRUE, Terms, L)

## S3 method for class 'anova.ssn_lm'
tidy(x, ...)

## S3 method for class 'anova.ssn_glm'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.SSN2_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="anova.SSN2_+3A_...">...</code></td>
<td>
<p>An additional fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>
(for <code>anova()</code>).</p>
</td></tr>
<tr><td><code id="anova.SSN2_+3A_test">test</code></td>
<td>
<p>A logical value indicating whether p-values from asymptotic Chi-squared
hypothesis tests should be returned. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="anova.SSN2_+3A_terms">Terms</code></td>
<td>
<p>An optional character or integer vector that specifies terms in the model
used to jointly compute test statistics and p-values (if <code>test = TRUE</code>)
against a null hypothesis of zero. <code>Terms</code> is only used when a single fitted model
object is passed to the function. If <code>Terms</code> is a character vector, it
should contain the names of the fixed effect terms. If <code>Terms</code> is an integer
vector, it should correspond to the order (starting at one) of the names
of the fixed effect terms. The easiest way to obtain the names of
all possible terms is to run <code>tidy(anova(object))$effects</code> (the
integer representation matches the positions of this vector).</p>
</td></tr>
<tr><td><code id="anova.SSN2_+3A_l">L</code></td>
<td>
<p>An optional numeric matrix or list specifying linear combinations
of the coefficients in the model used to compute test statistics
and p-values (if <code>test = TRUE</code>) for coefficient constraints corresponding to a null
hypothesis of zero. <code>L</code> is only used when a single fitted model
object is passed to the function. If <code>L</code> is a numeric matrix, its rows
indicate coefficient constraints and its columns
represent coefficients. Then a single hypothesis test is conducted
against a null hypothesis of zero.
If <code>L</code> is a list, each list element is a numeric matrix specified as above.
Then separate hypothesis tests are conducted. The easiest
way to obtain all possible coefficients is to run <code>tidy(object)$term</code>.</p>
</td></tr>
<tr><td><code id="anova.SSN2_+3A_x">x</code></td>
<td>
<p>An object from <code>anova(object)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When one fitted model object is present, <code>anova()</code>
performs a general linear hypothesis test corresponding to some hypothesis
specified by a matrix of constraints. If <code>Terms</code> and <code>L</code> are not specified,
each model term is tested against zero (which correspond to type III or marginal
hypothesis tests from classical ANOVA). If <code>Terms</code> is specified and <code>L</code>
is not specified, all terms are tested jointly against zero. When <code>L</code> is
specified, the linear combinations of terms specified by <code>L</code> are jointly
tested against zero.
</p>
<p>When two fitted model objects are present, one must be a &quot;reduced&quot;
model nested in a &quot;full&quot; model. Then <code>anova()</code> performs a likelihood ratio test.
</p>


<h3>Value</h3>

<p>When one fitted model object is present, <code>anova()</code>
returns a data frame with degrees of
freedom (<code>Df</code>), test statistics (<code>Chi2</code>), and p-values
(<code>Pr(&gt;Chi2)</code> if <code>test = TRUE</code>) corresponding
to asymptotic Chi-squared hypothesis tests for each model term.
</p>
<p>When two fitted model objects are present, <code>anova()</code> returns a data frame
with the difference in degrees of freedom between the full and reduced model (<code>Df</code>), a test
statistic (<code>Chi2</code>), and a p-value corresponding to the likelihood ratio test
(<code>Pr(&gt;Chi2)</code> if <code>test = TRUE</code>).
</p>
<p>Whether one or two fitted model objects are provided,
<code>tidy()</code> can be used
to obtain tidy tibbles of the <code>anova(object)</code> output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
anova(ssn_mod)
tidy(anova(ssn_mod))
</code></pre>

<hr>
<h2 id='augment.SSN2'>Augment data with information from fitted model objects</h2><span id='topic+augment.SSN2'></span><span id='topic+augment.ssn_lm'></span><span id='topic+augment.ssn_glm'></span>

<h3>Description</h3>

<p>Augment accepts a fitted model object and a data set and adds
information about each observation in the data set. New columns always
begin with a <code>.</code> prefix to avoid overwriting columns in the original
data set.
</p>
<p>Augment behaves differently depending on whether the original data or new data
requires augmenting. Typically, when augmenting the original data, only the fitted
model object is specified, and when augmenting new data, the fitted model object
and <code>newdata</code> are specified. When augmenting the original data, diagnostic
statistics are augmented to each row in the data set. When augmenting new data,
predictions and optional intervals (confidence or prediction) or standard errors are augmented to each
row in the new data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
augment(
  x,
  drop = TRUE,
  newdata = NULL,
  se_fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  level = 0.95,
  ...
)

## S3 method for class 'ssn_glm'
augment(
  x,
  drop = TRUE,
  newdata = NULL,
  type = c("link", "response"),
  se_fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  newdata_size,
  level = 0.95,
  var_correct = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.SSN2_+3A_x">x</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.SSN2_+3A_drop">drop</code></td>
<td>
<p>A logical indicating whether to drop extra variables in the
fitted model object <code>x</code> when augmenting. The default for <code>drop</code> is <code>TRUE</code>.
<code>drop</code> is ignored if augmenting <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="augment.SSN2_+3A_newdata">newdata</code></td>
<td>
<p>A vector that contains the names of the prediction <code>sf</code>
objects from the original <code>ssn.object</code> requiring prediction.
All of the original explanatory variables used to create the fitted model object <code>x</code>
must be present in each prediction <code>sf</code> object represented by <code>newdata</code>.
Defaults to <code>NULL</code>, which indicates
that nothing has been passed to <code>newdata</code> and augmenting occurs
for the original data. The value <code>"ssn"</code> is shorthand for specifying
all prediction <code>sf</code> objects.</p>
</td></tr>
<tr><td><code id="augment.SSN2_+3A_se_fit">se_fit</code></td>
<td>
<p>Logical indicating whether or not a <code>.se.fit</code> column should
be added to augmented output. Passed to <code>predict()</code> and
defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="augment.SSN2_+3A_interval">interval</code></td>
<td>
<p>Character indicating the type of confidence interval columns to
add to the augmented <code>newdata</code> output. Passed to <code>predict()</code> and defaults
to <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="augment.SSN2_+3A_level">level</code></td>
<td>
<p>Tolerance/confidence level. The default is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="augment.SSN2_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>predict()</code> when augmenting <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="augment.SSN2_+3A_type">type</code></td>
<td>
<p>The scale (<code>response</code> or <code>link</code>) of predictions obtained
using <code>ssn_glm</code> objects.</p>
</td></tr>
<tr><td><code id="augment.SSN2_+3A_newdata_size">newdata_size</code></td>
<td>
<p>The <code>size</code> value for each observation in <code>newdata</code>
used when predicting for the binomial family.</p>
</td></tr>
<tr><td><code id="augment.SSN2_+3A_var_correct">var_correct</code></td>
<td>
<p>A logical indicating whether to return the corrected prediction
variances when predicting via models fit using <code>ssn_glm</code>. The default is
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>augment()</code> returns a tibble as an <code>sf</code> object.
</p>
<p>Missing response values from the original data can be augmented as if
they were a <code>newdata</code> object by providing <code>".missing"</code> to the
<code>newdata</code> argument.
</p>


<h3>Value</h3>

<p>When augmenting the original data set, a tibble with additional columns
</p>

<ul>
<li> <p><code>.fitted</code>: Fitted value
</p>
</li>
<li> <p><code>.resid</code>: Response residual (the difference between observed and fitted values)
</p>
</li>
<li> <p><code>.hat</code>: Leverage (diagonal of the hat matrix)
</p>
</li>
<li> <p><code>.cooksd</code>: Cook's distance
</p>
</li>
<li> <p><code>.std.resid</code>: Standardized residuals
</p>
</li>
<li> <p><code>.se.fit</code>: Standard error of the fitted value.
</p>
</li></ul>

<p>When augmenting a new data set, a tibble with additional columns
</p>

<ul>
<li> <p><code>.fitted</code>: Predicted (or fitted) value
</p>
</li>
<li> <p><code>.lower</code>: Lower bound on interval
</p>
</li>
<li> <p><code>.upper</code>: Upper bound on interval
</p>
</li>
<li> <p><code>.se.fit</code>: Standard error of the predicted (or fitted) value
</p>
</li></ul>

<p>When predictions for all prediction objects are desired, the output is a list
where each element has a name that matches the prediction objects and values
that are the predictions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tidy.SSN2">tidy.SSN2()</a></code> <code><a href="#topic+glance.SSN2">glance.SSN2()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, predpts = "CapeHorn", overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
augment(ssn_mod)
augment(ssn_mod, newdata = "CapeHorn")
</code></pre>

<hr>
<h2 id='coef.SSN2'>Extract fitted model coefficients</h2><span id='topic+coef.SSN2'></span><span id='topic+coef.ssn_lm'></span><span id='topic+coefficients.ssn_lm'></span><span id='topic+coef.ssn_glm'></span><span id='topic+coefficients.ssn_glm'></span>

<h3>Description</h3>

<p><code>coef</code> extracts fitted model coefficients from fitted model objects.
<code>coefficients</code> is an alias for it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
coef(object, type = "fixed", ...)

## S3 method for class 'ssn_lm'
coefficients(object, type = "fixed", ...)

## S3 method for class 'ssn_glm'
coef(object, type = "fixed", ...)

## S3 method for class 'ssn_glm'
coefficients(object, type = "fixed", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.SSN2_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="coef.SSN2_+3A_type">type</code></td>
<td>
<p><code>"fixed"</code> for fixed effect coefficients, <code>"tailup"</code> for
tailup covariance parameter coefficients, <code>"taildown"</code> for
taildown covariance parameter coefficients, <code>"euclid"</code> for
Euclidean covariance parameter coefficients, <code>"nugget"</code> for
nugget covariance parameter coefficients, <code>"dispersion"</code> for
the dispersion parameter coefficient (<code>ssn_glm()</code> objects), <code>"randcov"</code> for random effect
variance coefficients, or <code>"ssn"</code> for all of the tailup, taildown,
Euclidean, nugget, and dispersion (<code>ssn_glm()</code> objects) parameter coefficients.
Defaults to <code>"fixed"</code>.</p>
</td></tr>
<tr><td><code id="coef.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
coef(ssn_mod)
coef(ssn_mod, type = "tailup")
coefficients(ssn_mod)
</code></pre>

<hr>
<h2 id='confint.SSN2'>Confidence intervals for fitted model parameters</h2><span id='topic+confint.SSN2'></span><span id='topic+confint.ssn_lm'></span><span id='topic+confint.ssn_glm'></span>

<h3>Description</h3>

<p>Computes confidence intervals for one or more parameters in a fitted
model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
confint(object, parm, level = 0.95, ...)

## S3 method for class 'ssn_glm'
confint(object, parm, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.SSN2_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="confint.SSN2_+3A_parm">parm</code></td>
<td>
<p>A specification of which parameters are to be given confidence
intervals (a character vector of names). If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.SSN2_+3A_level">level</code></td>
<td>
<p>The confidence level required. The default is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="confint.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Gaussian-based confidence intervals (two-sided and equal-tailed) for the
fixed effect coefficients based on the confidence level specified by <code>level</code>.
For <code>ssn_glm()</code> objects, confidence intervals are on the link scale.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
confint(ssn_mod)
confint(ssn_mod, level = 0.9)
</code></pre>

<hr>
<h2 id='cooks.distance.SSN2'>Compute Cook's distance</h2><span id='topic+cooks.distance.SSN2'></span><span id='topic+cooks.distance.ssn_lm'></span><span id='topic+cooks.distance.ssn_glm'></span>

<h3>Description</h3>

<p>Compute the Cook's distance for each observation from a fitted
model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
cooks.distance(model, ...)

## S3 method for class 'ssn_glm'
cooks.distance(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cooks.distance.SSN2_+3A_model">model</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="cooks.distance.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cook's distance measures the influence of an observation on a fitted
model object. If an observation is influential, its omission from the data
noticeably impacts parameter estimates. The larger the Cook's distance, the
larger the influence.
</p>


<h3>Value</h3>

<p>A vector of Cook's distance values for each observation from the
fitted model object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+augment.SSN2">augment.SSN2()</a></code> <code><a href="#topic+hatvalues.SSN2">hatvalues.SSN2()</a></code> <code><a href="#topic+influence.SSN2">influence.SSN2()</a></code> <code><a href="#topic+residuals.SSN2">residuals.SSN2()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
cooks.distance(ssn_mod)
</code></pre>

<hr>
<h2 id='copy_lsn_to_temp'>Copy LSN to temporary directory</h2><span id='topic+copy_lsn_to_temp'></span>

<h3>Description</h3>

<p>Copies the LSN directory MiddleFork04.ssn to R's temporary
directory so the examples in SSN2 do not write to the local
library or any other places.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy_lsn_to_temp()
</code></pre>


<h3>Details</h3>

<p>Copies the LSN directory MiddleFork04.ssn to R's temporary directory
</p>


<h3>Value</h3>

<p>A copy of MiddleFork04.ssn residing in R's temporary directory
</p>


<h3>Examples</h3>

<pre><code class='language-R'>copy_lsn_to_temp()
# getwd()
# setwd(tempdir())
# getwd()
# if unix-alike, list temporary directory contents using: system('ls')
# if windows, list temporary directory contents using: shell('dir')
</code></pre>

<hr>
<h2 id='covmatrix.SSN2'>Create a covariance matrix</h2><span id='topic+covmatrix.SSN2'></span><span id='topic+covmatrix.ssn_lm'></span><span id='topic+covmatrix.ssn_glm'></span>

<h3>Description</h3>

<p>Create a covariance matrix from a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
covmatrix(object, newdata, cov_type, ...)

## S3 method for class 'ssn_glm'
covmatrix(object, newdata, cov_type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covmatrix.SSN2_+3A_object">object</code></td>
<td>
<p>A fitted model object (e.g., <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>).</p>
</td></tr>
<tr><td><code id="covmatrix.SSN2_+3A_newdata">newdata</code></td>
<td>
<p>If omitted, the covariance matrix of
the observed data is returned. If provided, <code>newdata</code> is
a data frame or <code>sf</code> object that contains coordinate information
required to construct the covariance between <code>newdata</code> and
the observed data. If a data frame, <code>newdata</code>
must contain variables that represent coordinates having the same name as
the coordinates from the observed data used to fit <code>object</code>. If an
<code>sf</code> object, coordinates are obtained from the geometry of <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="covmatrix.SSN2_+3A_cov_type">cov_type</code></td>
<td>
<p>The type of covariance matrix returned. If <code>newdata</code>
is omitted, the <code class="reqn">n \times n</code> covariance matrix of the observed
data is returned, where <code class="reqn">n</code> is the sample size used to fit <code>object</code>.
If <code>newdata</code> is provided and <code>cov_type</code> is <code>"pred.obs"</code> (the default),
the <code class="reqn">m \times n</code> covariance matrix of the predicted and observed data is returned,
where <code class="reqn">m</code> is the number of observations in the prediction data.
If <code>newdata</code> is provided and <code>cov_type</code> is <code>"obs.pred"</code>,
the <code class="reqn">n \times m</code> covariance matrix of the observed and prediction data is returned.
If <code>newdata</code> is provided and <code>cov_type</code> is <code>"pred.pred"</code>,
the <code class="reqn">m \times m</code> covariance matrix of the prediction data is returned.</p>
</td></tr>
<tr><td><code id="covmatrix.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A covariance matrix (see <code>cov_type</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, predpts = "CapeHorn", overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
covmatrix(ssn_mod)
covmatrix(ssn_mod, "CapeHorn")
</code></pre>

<hr>
<h2 id='deviance.SSN2'>Fitted model deviance</h2><span id='topic+deviance.SSN2'></span><span id='topic+deviance.ssn_lm'></span><span id='topic+deviance.ssn_glm'></span>

<h3>Description</h3>

<p>Returns the deviance of a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
deviance(object, ...)

## S3 method for class 'ssn_glm'
deviance(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deviance.SSN2_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="deviance.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The deviance is twice the difference in log-likelihoods between the
saturated (perfect-fit) model and the fitted model.
</p>


<h3>Value</h3>

<p>The deviance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_glm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  family = "Gamma",
  tailup_type = "exponential",
  additive = "afvArea"
)
deviance(ssn_mod)
</code></pre>

<hr>
<h2 id='fitted.SSN2'>Extract model fitted values</h2><span id='topic+fitted.SSN2'></span><span id='topic+fitted.ssn_lm'></span><span id='topic+fitted.values.ssn_lm'></span><span id='topic+fitted.ssn_glm'></span><span id='topic+fitted.values.ssn_glm'></span>

<h3>Description</h3>

<p>Extract fitted values from fitted model objects. <code>fitted.values</code>
is an alias.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
fitted(object, type = "response", ...)

## S3 method for class 'ssn_lm'
fitted.values(object, type = "response", ...)

## S3 method for class 'ssn_glm'
fitted(object, type = "response", ...)

## S3 method for class 'ssn_glm'
fitted.values(object, type = "response", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.SSN2_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="fitted.SSN2_+3A_type">type</code></td>
<td>
<p><code>"response"</code> for fitted values of the response,
<code>"tailup"</code> for fitted values of the tailup random errors,
<code>"taildown"</code> for fitted values of the taildown random errors,
<code>"euclid"</code> for fitted values of the Euclidean random errors,
<code>"nugget"</code> for fitted values of the nugget random errors,
or <code>"randcov"</code> for fitted values of the random effects. If from
<code><a href="#topic+ssn_glm">ssn_glm()</a></code>, <code>"link"</code> for fitted values on the link scale.
The default is <code>"response"</code>.</p>
</td></tr>
<tr><td><code id="fitted.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>type</code> is <code>"response"</code>, the fitted values
for each observation are the standard fitted values <code class="reqn">X \hat{\beta}</code>.
When <code>type</code> is <code>"tailup"</code>, <code>"taildown"</code>, <code>"euclid"</code>,
or <code>"nugget"</code> the fitted values for each observation
are (generally) the best linear unbiased predictors of the respective random error.
When <code>type</code> is <code>"randcov"</code>, the fitted
values for each level of each random effect are (generally) the best linear unbiased
predictors of the corresponding random effect. The fitted values for <code>type</code>
<code>"tailup"</code>, <code>"taildown"</code>, <code>"euclid"</code>,
<code>"nugget"</code>, and <code>"randcov"</code> can generally be used to check assumptions
for each component of the fitted model object (e.g., check a Gaussian assumption).
</p>
<p>If from <code><a href="#topic+ssn_glm">ssn_glm()</a></code>, when <code>type</code> is <code>"response"</code>, the fitted values
for each observation are the standard fitted values on the inverse link
scale: <code class="reqn">g^{-1}</code>(<code class="reqn">X \hat{\beta} + \nu</code>), where <code class="reqn">g(.)</code> is a link function,
<code class="reqn">\beta</code> are the fixed effects, and <code class="reqn">\nu</code> are the spatial and random effects.
</p>


<h3>Value</h3>

<p>The fitted values according to <code>type</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
fitted(ssn_mod)
fitted.values(ssn_mod)
</code></pre>

<hr>
<h2 id='formula.SSN2'>Model formulae</h2><span id='topic+formula.SSN2'></span><span id='topic+formula.ssn_lm'></span><span id='topic+formula.ssn_glm'></span>

<h3>Description</h3>

<p>Return formula used by a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
formula(x, ...)

## S3 method for class 'ssn_glm'
formula(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.SSN2_+3A_x">x</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="formula.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The formula used by a fitted model object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
formula(ssn_mod)
</code></pre>

<hr>
<h2 id='glance.SSN2'>Glance at a fitted model object</h2><span id='topic+glance.SSN2'></span><span id='topic+glance.ssn_lm'></span><span id='topic+glance.ssn_glm'></span>

<h3>Description</h3>

<p>Returns a row of model
summaries from a fitted model object. Glance returns the same number of columns for all models
and estimation methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
glance(x, ...)

## S3 method for class 'ssn_glm'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.SSN2_+3A_x">x</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single-row tibble with columns
</p>

<ul>
<li> <p><code>n</code> The sample size.
</p>
</li>
<li> <p><code>p</code> The number of fixed effects.
</p>
</li>
<li> <p><code>npar</code> The number of estimated covariance parameters.
</p>
</li>
<li> <p><code>value</code> The optimized value of the fitting function
</p>
</li>
<li> <p><code>AIC</code> The AIC.
</p>
</li>
<li> <p><code>AICc</code> The AICc.
</p>
</li>
<li> <p><code>logLik</code> The log-likelihood
</p>
</li>
<li> <p><code>deviance</code> The deviance.
</p>
</li>
<li> <p><code>pseudo.r.squared</code> The pseudo r-squared
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
glance(ssn_mod)
</code></pre>

<hr>
<h2 id='glances.SSN2'>Glance at many fitted model objects</h2><span id='topic+glances.SSN2'></span><span id='topic+glances.ssn_lm'></span><span id='topic+glances.ssn_glm'></span>

<h3>Description</h3>

<p><code>glances()</code> repeatedly calls <code>glance()</code> on several
fitted model objects and binds the output together, sorted by a column of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
glances(object, ..., sort_by = "AICc", decreasing = FALSE)

## S3 method for class 'ssn_glm'
glances(object, ..., sort_by = "AICc", decreasing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glances.SSN2_+3A_object">object</code></td>
<td>
<p>Fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="glances.SSN2_+3A_...">...</code></td>
<td>
<p>Additional fitted model objects from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="glances.SSN2_+3A_sort_by">sort_by</code></td>
<td>
<p>Sort by a <code>glance</code> statistic (i.e., the name of a column
output from <code>glance()</code> or the order of model input (<code>sort_by = "order"</code>).
The default is <code>"AICc"</code>.</p>
</td></tr>
<tr><td><code id="glances.SSN2_+3A_decreasing">decreasing</code></td>
<td>
<p>Should <code>sort_by</code> be decreasing or not? The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble where each row represents the output of <code>glance()</code> for
each fitted model object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

# tailup only
ssn_mod1 &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
# taildown only
ssn_mod2 &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  taildown_type = "exponential"
)
glances(ssn_mod1, ssn_mod2)
</code></pre>

<hr>
<h2 id='hatvalues.SSN2'>Compute leverage (hat) values</h2><span id='topic+hatvalues.SSN2'></span><span id='topic+hatvalues.ssn_lm'></span><span id='topic+hatvalues.ssn_glm'></span>

<h3>Description</h3>

<p>Compute the leverage (hat) value for each observation from a fitted
model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
hatvalues(model, ...)

## S3 method for class 'ssn_glm'
hatvalues(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hatvalues.SSN2_+3A_model">model</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="hatvalues.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Leverage values measure how far an observation's explanatory variables
are relative to the average of the explanatory variables. In other words, observations with high
leverage are typically considered to have an extreme or unusual combination of explanatory
variables. Leverage values are the diagonal of the hat (projection) matrix.
The larger the hat value, the larger the leverage.
</p>


<h3>Value</h3>

<p>A vector of leverage (hat) values for each observation from the
fitted model object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+augment.SSN2">augment.SSN2()</a></code> <code><a href="#topic+cooks.distance.SSN2">cooks.distance.SSN2()</a></code> <code><a href="#topic+influence.SSN2">influence.SSN2()</a></code> <code><a href="#topic+residuals.SSN2">residuals.SSN2()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
hatvalues(ssn_mod)
</code></pre>

<hr>
<h2 id='influence.SSN2'>Regression diagnostics</h2><span id='topic+influence.SSN2'></span><span id='topic+influence.ssn_lm'></span><span id='topic+influence.ssn_glm'></span>

<h3>Description</h3>

<p>Provides basic quantities which are used in forming
a wide variety of diagnostics for checking the quality of fitted model objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
influence(model, ...)

## S3 method for class 'ssn_glm'
influence(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="influence.SSN2_+3A_model">model</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="influence.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code><a href="#topic+residuals.SSN2">residuals.SSN2()</a></code>, <code><a href="#topic+hatvalues.SSN2">hatvalues.SSN2()</a></code>,
and <code><a href="#topic+cooks.distance.SSN2">cooks.distance.SSN2()</a></code> and puts the results into a tibble. It is
primarily used when calling <code><a href="#topic+augment.SSN2">augment.SSN2()</a></code>.
</p>


<h3>Value</h3>

<p>A tibble with residuals (<code>.resid</code>), leverage values (<code>.hat</code>),
cook's distance (<code>.cooksd</code>), and standardized residuals (<code>.std.resid</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+augment.SSN2">augment.SSN2()</a></code> <code><a href="#topic+cooks.distance.SSN2">cooks.distance.SSN2()</a></code> <code><a href="#topic+hatvalues.SSN2">hatvalues.SSN2()</a></code> <code><a href="#topic+residuals.SSN2">residuals.SSN2()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
influence(ssn_mod)
</code></pre>

<hr>
<h2 id='labels.SSN2'>Find labels from object</h2><span id='topic+labels.SSN2'></span><span id='topic+labels.ssn_lm'></span><span id='topic+labels.ssn_glm'></span>

<h3>Description</h3>

<p>Find a suitable set of labels from a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
labels(object, ...)

## S3 method for class 'ssn_glm'
labels(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labels.SSN2_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="labels.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the terms used for the fixed effects
from a fitted model object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
labels(ssn_mod)
</code></pre>

<hr>
<h2 id='logLik.SSN2'>Extract log-likelihood</h2><span id='topic+logLik.SSN2'></span><span id='topic+logLik.ssn_lm'></span><span id='topic+logLik.ssn_glm'></span>

<h3>Description</h3>

<p>Find the log-likelihood of a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
logLik(object, ...)

## S3 method for class 'ssn_glm'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.SSN2_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="logLik.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
logLik(ssn_mod)
</code></pre>

<hr>
<h2 id='loocv.SSN2'>Perform leave-one-out cross validation</h2><span id='topic+loocv.SSN2'></span><span id='topic+loocv.ssn_lm'></span><span id='topic+loocv.ssn_glm'></span>

<h3>Description</h3>

<p>Perform leave-one-out cross validation with options for computationally
efficient approximations for big data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
loocv(object, cv_predict = FALSE, se.fit = FALSE, ...)

## S3 method for class 'ssn_glm'
loocv(object, cv_predict = FALSE, se.fit = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loocv.SSN2_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="loocv.SSN2_+3A_cv_predict">cv_predict</code></td>
<td>
<p>A logical indicating whether the leave-one-out fitted values
should be returned. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="loocv.SSN2_+3A_se.fit">se.fit</code></td>
<td>
<p>A logical indicating whether the leave-one-out
prediction standard errors should be returned. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="loocv.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each observation is held-out from the data set and the remaining data
are used to make a prediction for the held-out observation. This is compared
to the true value of the observation and several model-fit statistics are computed
across all observations.
</p>


<h3>Value</h3>

<p>If <code>cv_predict = FALSE</code> and <code>se.fit = FALSE</code>,
a tibble indicating several
leave-one-out cross validation error metrics. If <code>cv_predict = TRUE</code> or <code>se.fit = TRUE</code>,
a list with elements: <code>stats</code>, a tibble indicating several
leave-one-out cross validation metrics; <code>cv_predict</code>, a numeric vector
with leave-one-out predictions for each observation (if <code>cv_predict = TRUE</code>);
and <code>se.fit</code>, a numeric vector with leave-one-out prediction standard
errors for each observation (if <code>se.fit = TRUE</code>).
</p>
<p>If an <code>ssn_lm</code> object, the cross validation error metrics are:
</p>

<ul>
<li><p> bias: The average difference between the predicted value and true value
</p>
</li>
<li><p> std.bias: The average standardized difference between the predicted value and true value
</p>
</li>
<li><p> MSPE: The average squared difference between the predicted value and true value
</p>
</li>
<li><p> RMSPE: The root average squared difference between the predicted value and true value
</p>
</li>
<li><p> std.MSPE: The average standardized squared difference between the predicted value and true value
</p>
</li>
<li><p> RAV: The root of the average estimated variance of the predicted value
</p>
</li>
<li><p> cor2: The squared correlation between the predicted and true values
</p>
</li>
<li><p> cover.80: Coverage rates of 80% prediction intervals built for the true values
</p>
</li>
<li><p> cover.90: Coverage rates of 90% prediction intervals built for the true values
</p>
</li>
<li><p> cover.95: Coverage rates of 95% prediction intervals built for the true values
</p>
</li></ul>

<p>If an <code>ssn_glm</code> object, the cross validation error metrics are:
</p>

<ul>
<li><p> bias: The average difference between the predicted value and true value
</p>
</li>
<li><p> MSPE: The average squared difference between the predicted value and true value
</p>
</li>
<li><p> RMSPE: The root average squared difference between the predicted value and true value
</p>
</li>
<li><p> RAV: The root of the average estimated variance of the predicted value (on the link scale)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
loocv(ssn_mod)
</code></pre>

<hr>
<h2 id='mf04p'>Imported SSN object from the MiddleFork04.ssn data folder</h2><span id='topic+mf04p'></span>

<h3>Description</h3>

<p>The MiddleFork04.ssn data folder contains the spatial, attribute,
and topological information needed to construct a spatial stream
network object using the SSN2 package. <code>mf04p</code> was created
using <code><a href="#topic+ssn_import">ssn_import()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mf04p
</code></pre>


<h3>Format</h3>

<p>An object of class <code>SSN</code> of length 4.
</p>


<h3>See Also</h3>

<p><a href="#topic+MiddleFork04.ssn">MiddleFork04.ssn</a> for details about the contents of <code>mf04p</code>.
<code><a href="#topic+ssn_import">ssn_import()</a></code> to convert a .ssn object to an <code>SSN</code> object in R.
<a href="#topic+ssn_create_distmat">ssn_create_distmat</a> for details about the distance matrix file structure.
</p>

<hr>
<h2 id='MiddleFork04.ssn'>MiddleFork04.ssn: Middle Fork 2004 stream temperature dataset</h2><span id='topic+MiddleFork04.ssn'></span>

<h3>Description</h3>

<p>The <code>MiddleFork04.ssn</code> data folder contains the spatial, attribute,
and topological information needed to construct an SSN object using
the <code>SSN2</code> package.
</p>


<h3>Details</h3>

<p>The <code>MiddleFork04.ssn</code> folder contains five shapefiles:
</p>

<ul>
<li><p> edges: polyline shapefile representing the stream network
</p>
</li>
<li><p> sites: point shapefile representing the observed site locations
</p>
</li>
<li><p> pred1km: point shapefile representing prediction site locations at
approximately 1km intervals throughout the stream network
</p>
</li>
<li><p> Knapp: point shapefile representing prediction site locations on the Knapp River
</p>
</li>
<li><p> CapeHorn: point shapefile representing prediction site locations on the Cape Horn River
</p>
</li></ul>

<p>The <code>MiddleFork04.ssn</code> includes one text file, <code>netID1.txt</code>, which contains the
topological information for the stream network in the Middle Fork 2004
dataset.
</p>
<p>The distance folder contains four folders that store the hydrologic
distance matrices for each of the point shapefiles (<code>obs</code>, <code>CapeHorn</code>,
<code>Knapp</code>, and <code>pred1km</code>). See <code><a href="#topic+ssn_create_distmat">ssn_create_distmat()</a></code> for a
detailed description of the distance matrix file structure.
</p>
<p>Attribute data is also stored within each of the spatial
datasets. The column names are defined as follows:
</p>
<p><code>edges</code>:
</p>

<ul>
<li><p> COMID: Common identifier of an NHD feature or relationship
</p>
</li>
<li><p> GNIS_Name: Feature name as found in the Geographic Names Information System
</p>
</li>
<li><p> REACHCODE: Unique identifier for a reach. The first 8 digits contain the identfier for the HUC8 and the last 6 digits are a unique within-HUC8 identifier for the reach
</p>
</li>
<li><p> FTYPE: three-digit integer used to classify hydrography features in the NHD and define subtypes
</p>
</li>
<li><p> FCODE: Numeric code that contains the feature type and its attributes as found in the NHDFCode lookup table
</p>
</li>
<li><p> CDRAINAG: Cumulative drainage area (km2) for the lowermost location on the edge
</p>
</li>
<li><p> AREAWTMAP: Area weighted mean annual precipitation (mm) at the lowermost location on the edge
</p>
</li>
<li><p> SLOPE: Slope of the edge (cm/cm)
</p>
</li>
<li><p> h2oAreaKm2: Watershed area (km2) for the lowermost location on the line segment
</p>
</li>
<li><p> rid: Reach identifier
</p>
</li>
<li><p> areaPI: Segment proportional influence value, calculated using watershed area (h2oAreaKm2)
</p>
</li>
<li><p> afvArea: Additive function value, calculated using areaPI
</p>
</li>
<li><p> upDist: Distance from the stream outlet (most downstream location in the the stream network) to the uppermost location on the line segment
</p>
</li>
<li><p> Length: Length of line segment (m)
</p>
</li>
<li><p> netID: Network identifier
</p>
</li></ul>

<p><code>sites</code>:
</p>

<ul>
<li><p> STREAMNAME: Stream name
</p>
</li>
<li><p> COMID: Common identifier of an NHD feature or relationship
</p>
</li>
<li><p> CDRAINAG: Cumulative drainage area (km2)
</p>
</li>
<li><p> AREAWTMAP: Area weighted mean annual precipitation (mm) at lowermost
location on the line segment where the site resides
</p>
</li>
<li><p> SLOPE: Slope of the line segment (cm/cm) where the site resides
</p>
</li>
<li><p> ELEV_DEM: Elevation at the site based on a 30m DEM
</p>
</li>
<li><p> Source: Source of the data - relates to the ID field of the source table
</p>
</li>
<li><p> Summer_mn: Overall summer mean termperature (C) of the deployment
</p>
</li>
<li><p> MaxOver20: Binary variable: 1 represents the maximum summer temperature
was greater than 20C and 0 indicates that it was less than 20C
</p>
</li>
<li><p> C16: Number of times daily stream temperature exceeded 16C
</p>
</li>
<li><p> C20: Number of times daily stream temperature exceeded 20C
</p>
</li>
<li><p> C24: Number of times daily stream temperature exceeded 24C
</p>
</li>
<li><p> FlowCMS: Average stream flow (cubic meters per sec) for August,
by year, from 1950-2010 across 9 USGS gauges in the region
</p>
</li>
<li><p> AirMEANc: Average mean air temperature (C) from July 15 - August 31,
from 1980-2009 across 10 COOP air stations within the domain
</p>
</li>
<li><p> AirMWMTc: Average maximum air temperature (C) from July 15 - August 31,
from 1980-2009 across 10 COOP air stations within the domain.
MWMT = maximum 7-day moving average of the maximum daily temperature
(i.e. maximum of all the 7-day maximums)
</p>
</li>
<li><p> NEAR_X: x coordinate
</p>
</li>
<li><p> NEAR_Y: y coordinate
</p>
</li>
<li><p> rid: Reach identifier of the edge the site resides on
</p>
</li>
<li><p> ratio: Site ratio value; provides the proportional distance along the edge to the site location
</p>
</li>
<li><p> upDist: Distance upstream from the stream outlet (m)
</p>
</li>
<li><p> afvArea: Additive function value calculated using waterhsed area (h2oAreaKm2)
</p>
</li>
<li><p> locID: Location identifier
</p>
</li>
<li><p> netID: Stream network identifier
</p>
</li>
<li><p> pid: Point identifier
</p>
</li></ul>

<p><code>pred1km</code>, <code>CapeHorn</code>, and <code>Knapp</code>:
</p>

<ul>
<li><p> COMID: Common identifier of an NHD feature or relationship
</p>
</li>
<li><p> GNIS_Name: Feature name of the edge the site resides on, as found in the Geographic Names Information System
</p>
</li>
<li><p> CDRAINAG: Cumulative drainage area (km2)
</p>
</li>
<li><p> AREAWTMAP: Area weighted mean annual precipitation (mm) at lowermost location on the line segment where the site resides
</p>
</li>
<li><p> SLOPE: Slope of the line segment (cm/cm) where the site resides
</p>
</li>
<li><p> ELEV_DEM: Elevation at the site based on a 30m DEM
</p>
</li>
<li><p> NEAR_X: x coordinate
</p>
</li>
<li><p> NEAR_Y: y coordinate
</p>
</li>
<li><p> rid: Reach identifier of the edge the site resides on
</p>
</li>
<li><p> ratio: Site ratio value; provides the proportional distance along the edge to the site location
</p>
</li>
<li><p> upDist: Distance upstream from the stream outlet (m)
</p>
</li>
<li><p> afvArea: Additive function value calculated using watershed area (h2oAreaKm2)
</p>
</li>
<li><p> locID: Location identifier
</p>
</li>
<li><p> netID: Stream network identifier
</p>
</li>
<li><p> pid: Point identifier
</p>
</li>
<li><p> FlowCMS: Average stream flow (cubic meters per sec) for August, by year, from 1950-2010 across 9 USGS gauges in the region
</p>
</li>
<li><p> AirMEANc: Average mean air temperature (C) from July 15 - August 31, from 1980-2009 across 10 COOP air stations within the domain
</p>
</li>
<li><p> AirMWMTc: Average maximum air temperature (C) from July 15 - August 31, from 1980-2009 across 10 COOP air stations within the domain. MWMT = maximum 7-day moving average of the maximum daily temperature(i.e. maximum of all the 7-day maximums)
</p>
</li></ul>



<h3>Source</h3>

<p><code>edges</code> are a modified version of the United States
National Hydrography Dataset
(http://nhd.usgs.gov/). <code>sites</code>, <code>pred1km</code>, <code>CapeHorn</code>
and <code>Knapp</code> are unpublished United States Forest Service data.
</p>


<h3>See Also</h3>

<p><a href="#topic+mf04p">mf04p</a> for the Middle For 04 data as an <code>SSN</code> object.
</p>

<hr>
<h2 id='model.frame.SSN2'>Extract the model frame from a fitted model object</h2><span id='topic+model.frame.SSN2'></span><span id='topic+model.frame.ssn_lm'></span><span id='topic+model.frame.ssn_glm'></span>

<h3>Description</h3>

<p>Extract the model frame from a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
model.frame(formula, ...)

## S3 method for class 'ssn_glm'
model.frame(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.SSN2_+3A_formula">formula</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="model.frame.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A model frame that contains the variables used by the formula
for the fitted model object.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.frame">stats::model.frame()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
model.frame(ssn_mod)
</code></pre>

<hr>
<h2 id='model.matrix.SSN2'>Extract the model matrix from a fitted model object</h2><span id='topic+model.matrix.SSN2'></span><span id='topic+model.matrix.ssn_lm'></span><span id='topic+model.matrix.ssn_glm'></span>

<h3>Description</h3>

<p>Extract the model matrix (X) from a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
model.matrix(object, ...)

## S3 method for class 'ssn_glm'
model.matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.SSN2_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="model.matrix.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The model matrix (of the fixed effects), whose rows represent
observations and whose columns represent explanatory variables corresponding
to each fixed effect.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
model.matrix(ssn_mod)
</code></pre>

<hr>
<h2 id='names.SSN'>names SSN object</h2><span id='topic+names.SSN'></span>

<h3>Description</h3>

<p>Extract and print names from the SSN object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SSN'
names(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names.SSN_+3A_x">x</code></td>
<td>
<p>An SSN object.</p>
</td></tr>
<tr><td><code id="names.SSN_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print variable names to console
</p>

<hr>
<h2 id='plot.SSN2'>Plot fitted model diagnostics</h2><span id='topic+plot.SSN2'></span><span id='topic+plot.ssn_lm'></span><span id='topic+plot.ssn_glm'></span>

<h3>Description</h3>

<p>Plot fitted model diagnostics such as residuals vs fitted values,
quantile-quantile, scale-location, Cook's distance, residuals vs leverage,
and Cook's distance vs leverage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
plot(x, which, ...)

## S3 method for class 'ssn_glm'
plot(x, which, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SSN2_+3A_x">x</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.SSN2_+3A_which">which</code></td>
<td>
<p>An integer vector taking on values between 1 and 6, which indicates
the plots to return. Available plots are described in Details. If <code>which</code>
has length greater than one, additional plots are stepped through in order
using <code>&lt;Return&gt;</code>. The default is <code>which = c(1, 2)</code></p>
</td></tr>
<tr><td><code id="plot.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all fitted model objects,, the values of <code>which</code> make the
corresponding plot:
</p>

<ul>
<li><p> 1: Standardized residuals vs fitted values (of the response)
</p>
</li>
<li><p> 2: Normal quantile-quantile plot of standardized residuals
</p>
</li>
<li><p> 3: Scale-location plot of standardized residuals
</p>
</li>
<li><p> 4: Cook's distance
</p>
</li>
<li><p> 5: Standardized residuals vs leverage
</p>
</li>
<li><p> 6: Cook's distance vs leverage
</p>
</li></ul>



<h3>Value</h3>

<p>No return value. Function called for plotting side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.Torgegram">plot.Torgegram()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
plot(ssn_mod, which = 1)
</code></pre>

<hr>
<h2 id='plot.Torgegram'>Plot Torgegram</h2><span id='topic+plot.Torgegram'></span>

<h3>Description</h3>

<p>Plot Torgegram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Torgegram'
plot(x, type, separate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Torgegram_+3A_x">x</code></td>
<td>
<p>A Torgegram object from <code><a href="#topic+Torgegram">Torgegram()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Torgegram_+3A_type">type</code></td>
<td>
<p>The type of semivariogram. Can take character values that are a subset
of objects in <code>x</code>. The default is <code>names(x)</code>.</p>
</td></tr>
<tr><td><code id="plot.Torgegram_+3A_separate">separate</code></td>
<td>
<p>When <code>type</code> is length greater than one, whether each
<code>type</code> be placed in a separate plot. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.Torgegram_+3A_...">...</code></td>
<td>
<p>Other arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Function called for plotting side effects.
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.SSN2">plot.SSN2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

tg &lt;- Torgegram(Summer_mn ~ 1, mf04p)
plot(tg)
</code></pre>

<hr>
<h2 id='predict.SSN2'>Model predictions (Kriging)</h2><span id='topic+predict.SSN2'></span><span id='topic+predict.ssn_lm'></span><span id='topic+predict.ssn_glm'></span>

<h3>Description</h3>

<p>Predicted values and intervals based on a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
predict(
  object,
  newdata,
  se.fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  level = 0.95,
  block = FALSE,
  ...
)

## S3 method for class 'ssn_glm'
predict(
  object,
  newdata,
  type = c("link", "response"),
  se.fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  newdata_size,
  level = 0.95,
  var_correct = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.SSN2_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="predict.SSN2_+3A_newdata">newdata</code></td>
<td>
<p>A character vector that indicates the name of the prediction data set
in the SSN object for which predictions are desired. If omitted, predictions
for all prediction data sets are returned. Note that the name <code>".missing"</code>
indicates the prediction data set that contains the missing observations in the data used
to fit the model.</p>
</td></tr>
<tr><td><code id="predict.SSN2_+3A_se.fit">se.fit</code></td>
<td>
<p>A logical indicating if standard errors are returned.
The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict.SSN2_+3A_interval">interval</code></td>
<td>
<p>Type of interval calculation. The default is <code>"none"</code>.
Other options are <code>"confidence"</code> (for confidence intervals) and
<code>"prediction"</code> (for prediction intervals).</p>
</td></tr>
<tr><td><code id="predict.SSN2_+3A_level">level</code></td>
<td>
<p>Tolerance/confidence level. The default is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="predict.SSN2_+3A_block">block</code></td>
<td>
<p>A logical indicating whether a block prediction over the entire
region in <code>newdata</code> should be returned. The default is <code>FALSE</code>, which returns point
predictions for each location in <code>newdata</code>. Currently only available for
model fit using <code>ssn_lm()</code> or models fit using <code>ssn_glm()</code> where
<code>family</code> is <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="predict.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
<tr><td><code id="predict.SSN2_+3A_type">type</code></td>
<td>
<p>The scale (<code>response</code> or <code>link</code>) of predictions obtained
using <code>ssn_glm</code> objects.</p>
</td></tr>
<tr><td><code id="predict.SSN2_+3A_newdata_size">newdata_size</code></td>
<td>
<p>The <code>size</code> value for each observation in <code>newdata</code>
used when predicting for the binomial family.</p>
</td></tr>
<tr><td><code id="predict.SSN2_+3A_var_correct">var_correct</code></td>
<td>
<p>A logical indicating whether to return the corrected prediction
variances when predicting via models fit using <code>ssn_glm</code>. The default is
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The (empirical) best linear unbiased predictions (i.e., Kriging
predictions) at each site are returned when <code>interval</code> is <code>"none"</code>
or <code>"prediction"</code> alongside standard errors. Prediction intervals
are also returned if <code>interval</code> is <code>"prediction"</code>. When
<code>interval</code> is <code>"confidence"</code>, the estimated mean is returned
alongside standard errors and confidence intervals for the mean.
</p>


<h3>Value</h3>

<p>If <code>se.fit</code> is <code>FALSE</code>, <code>predict.ssn()</code> returns
a vector of predictions or a matrix of predictions with column names
<code>fit</code>, <code>lwr</code>, and <code>upr</code> if <code>interval</code> is <code>"confidence"</code>
or <code>"prediction"</code>. If <code>se.fit</code> is <code>TRUE</code>, a list with the following components is returned:
</p>

<ul>
<li> <p><code>fit</code>: vector or matrix as above
</p>
</li>
<li> <p><code>se.fit:</code> standard error of each fit
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, predpts = "pred1km", overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
predict(ssn_mod, "pred1km")
</code></pre>

<hr>
<h2 id='print.SSN'>Print SSN object</h2><span id='topic+print.SSN'></span>

<h3>Description</h3>

<p>Print information about the data found in an SSN object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SSN'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.SSN_+3A_x">x</code></td>
<td>
<p>An SSN object.</p>
</td></tr>
<tr><td><code id="print.SSN_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print summary to console
</p>

<hr>
<h2 id='print.SSN2'>Print values</h2><span id='topic+print.SSN2'></span><span id='topic+print.ssn_lm'></span><span id='topic+print.ssn_glm'></span><span id='topic+print.summary.ssn_lm'></span><span id='topic+print.summary.ssn_glm'></span><span id='topic+print.anova.ssn_lm'></span><span id='topic+print.anova.ssn_glm'></span>

<h3>Description</h3>

<p>Print fitted model objects and summaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
print(x, digits = max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'ssn_glm'
print(x, digits = max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'summary.ssn_lm'
print(
  x,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)

## S3 method for class 'summary.ssn_glm'
print(
  x,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)

## S3 method for class 'anova.ssn_lm'
print(
  x,
  digits = max(getOption("digits") - 2L, 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)

## S3 method for class 'anova.ssn_glm'
print(
  x,
  digits = max(getOption("digits") - 2L, 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.SSN2_+3A_x">x</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code>, a fitted model object from <code><a href="#topic+ssn_glm">ssn_glm()</a></code>,
or output from <code>summary(x)</code> or or <code>anova(x)</code>.</p>
</td></tr>
<tr><td><code id="print.SSN2_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="print.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="print.SSN2_+3A_signif.stars">signif.stars</code></td>
<td>
<p>Logical. If <code>TRUE</code>, significance stars are printed for each coefficient</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Printed fitted model objects and summaries with formatting.
</p>

<hr>
<h2 id='pseudoR2.SSN2'>Compute a pseudo r-squared</h2><span id='topic+pseudoR2.SSN2'></span><span id='topic+pseudoR2.ssn_lm'></span><span id='topic+pseudoR2.ssn_glm'></span>

<h3>Description</h3>

<p>Compute a pseudo r-squared for a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
pseudoR2(object, adjust = FALSE, ...)

## S3 method for class 'ssn_glm'
pseudoR2(object, adjust = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudoR2.SSN2_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="pseudoR2.SSN2_+3A_adjust">adjust</code></td>
<td>
<p>A logical indicating whether the pseudo r-squared
should be adjusted to account for the number of explanatory variables. The
default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pseudoR2.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several pseudo r-squared statistics exist for in the literature.
We define this pseudo r-squared as one minus the ratio of the deviance of a full model
relative to the deviance of a null (intercept only) model. This pseudo r-squared
can be viewed as a generalization of the classical r-squared definition
seen as one minus the ratio of error sums of squares from the full model relative
to the error sums of squares from the null model. If adjusted, the adjustment
is analogous to the the classical r-squared adjustment.
</p>


<h3>Value</h3>

<p>The pseudo r-squared as a numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
pseudoR2(ssn_mod)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+tidy'></span><span id='topic+glance'></span><span id='topic+augment'></span><span id='topic+AICc'></span><span id='topic+covmatrix'></span><span id='topic+dispersion_initial'></span><span id='topic+dispersion_params'></span><span id='topic+glances'></span><span id='topic+loocv'></span><span id='topic+pseudoR2'></span><span id='topic+randcov_initial'></span><span id='topic+randcov_params'></span><span id='topic+varcomp'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+augment">augment</a></code>, <code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
<dt>spmodel</dt><dd><p><code><a href="spmodel.html#topic+AIC.spmodel">AICc</a></code>, <code><a href="spmodel.html#topic+covmatrix">covmatrix</a></code>, <code><a href="spmodel.html#topic+dispersion_initial">dispersion_initial</a></code>, <code><a href="spmodel.html#topic+dispersion_params">dispersion_params</a></code>, <code><a href="spmodel.html#topic+glances">glances</a></code>, <code><a href="spmodel.html#topic+loocv">loocv</a></code>, <code><a href="spmodel.html#topic+pseudoR2">pseudoR2</a></code>, <code><a href="spmodel.html#topic+randcov_initial">randcov_initial</a></code>, <code><a href="spmodel.html#topic+randcov_params">randcov_params</a></code>, <code><a href="spmodel.html#topic+varcomp">varcomp</a></code></p>
</dd>
</dl>

<hr>
<h2 id='residuals.SSN2'>Extract fitted model residuals</h2><span id='topic+residuals.SSN2'></span><span id='topic+residuals.ssn_lm'></span><span id='topic+resid.ssn_lm'></span><span id='topic+rstandard.ssn_lm'></span><span id='topic+residuals.ssn_glm'></span><span id='topic+resid.ssn_glm'></span><span id='topic+rstandard.ssn_glm'></span>

<h3>Description</h3>

<p>Extract residuals from a fitted model object.
<code>resid</code> is an alias.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
residuals(object, type = "response", ...)

## S3 method for class 'ssn_lm'
resid(object, type = "response", ...)

## S3 method for class 'ssn_lm'
rstandard(model, ...)

## S3 method for class 'ssn_glm'
residuals(object, type = "deviance", ...)

## S3 method for class 'ssn_glm'
resid(object, type = "deviance", ...)

## S3 method for class 'ssn_glm'
rstandard(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.SSN2_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="residuals.SSN2_+3A_type">type</code></td>
<td>
<p><code>"response"</code> for response residuals, <code>"pearson"</code>
for Pearson residuals, or <code>"standardized"</code> for standardized residuals.
For <code>ssn_lm()</code> fitted model objects, the default is <code>"response"</code>.
For <code>ssn_glm()</code> fitted model objects, deviance residuals are also
available (<code>"deviance"</code>) and are the default residual type.</p>
</td></tr>
<tr><td><code id="residuals.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
<tr><td><code id="residuals.SSN2_+3A_model">model</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The response residuals are taken as the response minus the fitted values
for the response: <code class="reqn">y - X \hat{\beta}</code>. The Pearson residuals are the
response residuals pre-multiplied by their inverse square root.
The standardized residuals are Pearson residuals divided by the square
root of one minus the leverage (hat) value. The standardized residuals are often used to
check model assumptions, as they have mean zero and variance approximately one.
</p>
<p><code>rstandard()</code> is an alias for <code>residuals(model, type = "standardized")</code>.
</p>


<h3>Value</h3>

<p>The residuals as a numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
residuals(ssn_mod)
resid(ssn_mod)
rstandard(ssn_mod)
</code></pre>

<hr>
<h2 id='ssn_create_distmat'>Calculate Hydrologic Distances for an <code>SSN</code> object</h2><span id='topic+ssn_create_distmat'></span>

<h3>Description</h3>

<p>Creates a collection of (non-symmetric) matrices
containing pairwise downstream hydrologic distances between sites
in an <code>SSN</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssn_create_distmat(
  ssn.object,
  predpts = NULL,
  overwrite = FALSE,
  among_predpts = FALSE,
  only_predpts = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssn_create_distmat_+3A_ssn.object">ssn.object</code></td>
<td>
<p>An <code>SSN</code> object</p>
</td></tr>
<tr><td><code id="ssn_create_distmat_+3A_predpts">predpts</code></td>
<td>
<p>name of prediction points in an <code>SSN</code> object.
When a vector with length greater than one, each name is iterated upon.
Default is NULL.</p>
</td></tr>
<tr><td><code id="ssn_create_distmat_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. If <code>TRUE</code>, overwrite existing distance
matrices. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ssn_create_distmat_+3A_among_predpts">among_predpts</code></td>
<td>
<p>Logical. If <code>TRUE</code>, compute the pairwise distances
between the prediction sites. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ssn_create_distmat_+3A_only_predpts">only_predpts</code></td>
<td>
<p>Logical. If <code>TRUE</code>, only compute distances for
prediction sites. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A distance matrix that contains the hydrologic distance
between any two sites in <code>SSN</code> object is needed to fit a spatial
statistical model using the tail-up and tail-down autocovariance
functions described in Ver Hoef and Peterson (2010). These models
are implemented in R via <code>ssn_lm</code> and <code>ssn_glm</code> in
the<code>SSN2</code> package. The hydrologic distance information needed to
model the covariance between flow-connected (i.e. water flows
from one location to the other) and flow-unconnected (i.e. water
does not flow from one location to the other, but they reside on
the same network) locations differs. The total hydrologic
distance is a directionless measure; it represents the hydrologic
distance between two sites, ignoring flow direction. The
hydrologic distance from each site to a common downstream stream
junction is used when creating models for flow-unconnected pairs,
which we term downstream hydrologic distance. In contrast, the
total hydrologic distance is used for modeling flow-connected
pairs, which we term total hydrologic distance.
</p>
<p>A downstream hydrologic distance matrix provides enough
information to meet the data requirements for both the tail-up and
tail-down models. When two locations are flow-connected, the
downstream hydrologic distance from the upstream location to the
downstream location is greater than zero, but it is zero in the
other direction. When two locations are flow-unconnected the
downstream hydrologic distance will be greater than zero in both
directions. A site's downstream hydrologic distance to itself is
equal to zero. The format of the downstream hydrologic distance
matrix is efficient because distance information needed to fit
both the tail-up and tail-down models is only stored once. As an
example, a matrix containing the total hydrologic distance between
sites is easily calculated by adding the downstream distance
matrix to its transpose.
</p>
<p>The downstream hydrologic distances are calculated based on the
binaryIDs and stored as matrices. The matrices are stored in a
directory named &lsquo;distance&rsquo;, which is created by the
<code>ssn_create_distmat</code> function within the .ssn directory. The distance
directory will always contain at least one directory named
&lsquo;obs&rsquo;, which contains a number of .RData files, one for each
network that has observed sites residing on it. The naming
convention for the files is based on the netID number
(e.g. dist.net1.RData). Each matrix in the &lsquo;obs&rsquo; folder
contains the information to form a square matrix, which contains
the downstream hydrologic distance between each pair of observed
sites on the network. Direction is preserved, with columns
representing the FROM site and rows representing the TO site. Row
and column names correspond to the pid attribute for each site.
</p>
<p>If the argument <code>predpts</code> is specified in the call to the
function, the downstream hydrologic distances between the observed
and prediction sites will also be computed. A new directory is
created within the distance directory, with the name corresponding
to the names attribute for the preds
(e.g. <code>attributes(ssn.object$preds)$names</code>). A sequence of
.RData files is created within this directory, similar to the
structure for the observed sites, except that two objects are
stored for each network that contains <em>both</em> observed and
prediction sites. The letters <code>a</code> and <code>b</code> are used in
the naming convention to distinguish between the two objects
(e.g. dist.net1.a and dist.net1.b). The matrices that these
objects represent are not necessarily square. In matrices of type
<code>a</code>, rows correspond to observed locations and columns to
prediction locations. In contrast, rows correspond to prediction
locations and columns to observed locations in matrices of type
<code>b</code>. Direction is also preserved, with columns representing
the FROM site and rows representing the TO site in both object
types. Again, row and column names correspond to the pid attribute
for each site.
</p>
<p>If <code>among_predpts = TRUE</code>, the downstream
hydrologic distances will also be computed between prediction
sites, for each network. Again these are stored within the distance
directory with the name corresponding to the prediction points
dataset. The naming convention for these prediction to prediction
site distance matrices is the same as the distance matrices stored
in the &lsquo;obs&rsquo; directory (e.g. dist.net1.RData). These extra
distance matrices are needed to perform block Kriging using
<code><a href="#topic+predict.ssn_lm">predict.ssn_lm</a></code>.
</p>
<p>If <code>only_predpts = TRUE</code>, the downstream
hydrologic distances will not be calculated between observed sites
themselves. Pairwise distances will only be calculated for observed
and prediction locations and. Pairwise distances between prediction
locations will also be calculated if <code>among_predpts = TRUE</code>.
</p>


<h3>Value</h3>

<p>The <code>ssn_create_distmat</code> function creates a collection
of hierarchical directories in the <code>ssn$path</code> directory,
which store the pairwise distances between sites associated with
the <code>SSN</code> object. See details section for additional information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Copy the MiddleForke04.ssn data to a local temporary directory.
## Only needed for this example.
copy_lsn_to_temp()
## Import SSN data
mf04p &lt;- ssn_import(paste0(tempdir(), "/MiddleFork04.ssn"),
  predpts = c("pred1km.shp", "Knapp"),
  overwrite = TRUE
)

## Create distance matrices for observations and one set of prediction sites
## Include hydrologic distance matrices among prediction sites.
ssn_create_distmat(mf04p,
  predpts = "pred1km", overwrite = TRUE,
  among_predpts = TRUE
)

## Create distance matrices for an additional set of prediction points.
## Distance matrices for observations and pred1km prediction sites are
## not recalculated.
ssn_create_distmat(mf04p,
  predpts = "Knapp", overwrite = TRUE,
  among_predpts = TRUE, only_predpts = TRUE
)
</code></pre>

<hr>
<h2 id='ssn_get_data'>Get a data.frame from an SSN, ssn_lm, or ssn_glm object</h2><span id='topic+ssn_get_data'></span>

<h3>Description</h3>

<p>The <code>ssn_get_data</code> function extracts an
sf data.frame for the observation or prediction data from
an <code>SSN</code>, <code>ssn_lm</code>, or <code>ssn_glm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssn_get_data(x, name = "obs")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssn_get_data_+3A_x">x</code></td>
<td>
<p>An object of class <code>SSN</code>, <code>ssn_lm</code>, or <code>ssn_glm</code>.</p>
</td></tr>
<tr><td><code id="ssn_get_data_+3A_name">name</code></td>
<td>
<p>the internal name of the dataset in the object
<code>x</code>. For observed values, this will always be &quot;obs&quot;, the
default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The internal <code>name</code> for observed data in objects of
class <code>SSN</code> is &quot;obs&quot; and it is the
default. If another <code>name</code> is specified, it must represent a
prediction data set in the <code>SSN</code>,
<code>ssn_lm</code>, or <code>ssn_glm</code> object. For <code>SSN</code> objects,
these names are obtained using the call <code>names(x$preds)</code>. For
all other object classes, the names are obtained using the call
<code>names(x$ssn.object$preds)</code>.
</p>


<h3>Value</h3>

<p>An sf data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssn_put_data">ssn_put_data()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Extract observed data from an SSN object
# Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, predpts = "pred1km", overwrite = TRUE)

obs.df &lt;- ssn_get_data(mf04p)
dim(obs.df)

## Extract prediction data from an SSN object
names(mf04p$preds)
pred1km.df &lt;- ssn_get_data(mf04p, name = "pred1km")
names(pred1km.df)

## extract observed data from an ssn_lm object
ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
obs.mod.df &lt;- ssn_get_data(ssn_mod)
summary(obs.mod.df)
</code></pre>

<hr>
<h2 id='ssn_get_netgeom'>Extract netgeom column</h2><span id='topic+ssn_get_netgeom'></span>

<h3>Description</h3>

<p>Extract topological information from netgeom column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssn_get_netgeom(x, netvars = "all", reformat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssn_get_netgeom_+3A_x">x</code></td>
<td>
<p>An sf data.frame found in an <code>SSN</code> object or the
netgeom column as a vector</p>
</td></tr>
<tr><td><code id="ssn_get_netgeom_+3A_netvars">netvars</code></td>
<td>
<p>Network coordinate variables to return. Default is
&quot;all&quot;. For edges, valid column names include: &quot;NetworkID&quot;,
&quot;SegmentID&quot;, and &quot;DistanceUpstream&quot;. For point datasets, valid column
names include &quot;NetworkID&quot;, &quot;SegmentID&quot;, &quot;DistanceUpstream&quot;, &quot;ratio&quot;, &quot;pid&quot;,
and &quot;locID&quot;.</p>
</td></tr>
<tr><td><code id="ssn_get_netgeom_+3A_reformat">reformat</code></td>
<td>
<p>Convert network coordinate variables from character to numeric.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When an <code>SSN</code> object is generated using the
<code>importSSN</code> function, a text column named &quot;netgeom&quot; is added
to the edges, observed sites, and prediction sites (if they
exist) data.frames. The netgeom column contains data used to
describe how edge and site features relate to one another in
topological space. For edges, netgeom values contain the
&quot;ENETWORK&quot; prefix, with 3 space delimited values in parentheses:
&quot;ENETWORK (NetworkID SegmentID DistanceUpstream)&quot;. For point
datasets (observed and prediction sites), the values contain the
&quot;SNETWORK&quot; prefix, followed by 6 space delimited values in parentheses:
&quot;SNETWORK (NetworkID SegmentID DistanceUpstream ratio pid locID)&quot;. The
<code>ssn_get_netgeom</code> function extracts and converts these
values from text to numeric, returning either a data.frame
(default) or vector containing the variables requested via
<code>netvars</code>.
</p>


<h3>Value</h3>

<p>If more than one column is requested using netvars, the
function returns a data.frame (default). If only one column is
requested, the result is a vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_get_netgeom(mf04p$obs)
ssn_get_netgeom(mf04p$edges, "DistanceUpstream")
</code></pre>

<hr>
<h2 id='ssn_get_stream_distmat'>Get stream distance matrices from an <code>SSN</code> object</h2><span id='topic+ssn_get_stream_distmat'></span>

<h3>Description</h3>

<p>Extracts the stream network distance matrices for the
observation or prediction data from an <code>SSN</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssn_get_stream_distmat(x, name = "obs")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssn_get_stream_distmat_+3A_x">x</code></td>
<td>
<p>An <code>SSN</code> object</p>
</td></tr>
<tr><td><code id="ssn_get_stream_distmat_+3A_name">name</code></td>
<td>
<p>Internal name of the dataset in the object
<code>x</code>. For observed values, this will always be &quot;obs&quot;, the
default.  To get a stream network distance matrix for a
prediction data set, the name of the dataset must be given, in
quotes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The internal <code>name</code> for observed data in objects of class
<code>SSN</code> is &quot;obs&quot; and it is the default. If another <code>name</code>
is specified, it must represent a prediction data set in the
<code>SSN</code> object. For <code>SSN</code>
objects, these names are obtained using the call <code>names(x$preds)</code>.
</p>
<p>Note that these are not traditional symmetric distance
matrices. First, distances in an <code>SSN</code> object represent stream
distance, or hydrologic distance, which is the distance between two
locations when movement is restricted to the branching stream
network. Another important difference is the distance matrices for
<code>SSN</code> objects contain the <em>downstream only</em> stream
distance between two locations, making them asymmetric. This
asymmetry provides a way to store two types of spatial
relationships based on stream distance:
</p>

<ul>
<li><p>Flow-connected: Water flows from an upstream site to a
downstream site.
</p>
</li>
<li><p>Flow-unconnected: Two sites reside on the
same stream network, but do not share flow.
</p>
</li></ul>

<p>For example, if two sites are flow-connected the downstream
distance from the upstream site to the downstream site is &gt; 0,
while the downstream distance between the downstream site and the
upstream site = 0. For flow-unconnected sites, the downstream
distance represents the distance from each site to the closest
downstream junction and will be &gt; 0 in both directions. Direction
is preserved, with columns representing the FROM site and rows
representing the TO site. Row and column names correspond to the
unique point identifier &quot;pid&quot; for each site. From this matrix, it
is also possible to get total stream distance (downstream +
upstream) between any two sites on the same network (see examples
for additional details).
</p>
<p>Stream distances are only calculated within a network and so the
asymmetric matrices are also stored by network.  For observation
data, a single square matrix of distances is returned for each
network, with the names based on the netID value (e.g. &quot;dist.net1&quot;,
&quot;dist.net2&quot;, etc.). However, two distance matrices (&quot;a&quot; and &quot;b&quot;)
are required to store the downstream only distance between observed
and prediction sites. The label &quot;a&quot; represents the downstream
stream distance <em>from</em> prediction sites <em>to</em> observation
sites, and the label &quot;b&quot; represents the distance <em>from</em>
observation sites <em>to</em> predictions sites.  Thus, the list of
prediction matrices are labeled &quot;dist.net1.a&quot; for the downstream
only distance from prediction sites in the columns, to observation
sites in the rows, for the first network. A prediction matrix
labeled &quot;dist.net1.b&quot; contains downstream distances <em>from</em>
observation sites in the columns <em>to</em> prediction sites in the
rows, for the first network. The downstream only distance matrices
for observations and predictions will be rectangular, unless the
number of observation and prediction locations are equal.  If the
argument <code>amongPreds = TRUE</code> was used in the function
<code>ssn_create_distmat</code>, then the distance between prediction sites
themselves is also returned, using the same labelling convention as
for among observation sites. That is, the matrices for each network
will be labeled &quot;dist.net1&quot;, &quot;dist.net2&quot;, etc., for the first and
second network, etc.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> of asymmetric downstream only
stream distance matrices, by network.
</p>


<h3>References</h3>

<p>Ver Hoef, J.M. and Peterson, E.E. (2010) A moving
average approach to spatial statistical models of stream
networks. The Journal of the American Statistical Association,
<b>105(489)</b>, 22&ndash;24
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssn_create_distmat">ssn_create_distmat()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For this example only, copy MiddleFork04.ssn directory to R's
## temporary directory
copy_lsn_to_temp()
## Create an SSN object with prediction sites
mf04p &lt;- ssn_import(paste0(tempdir(), "/MiddleFork04.ssn"),
  predpts = "pred1km", overwrite = TRUE
)

## Create distance matrices for obs x obs, obs x preds, and preds x
## preds
## Not run: 
ssn_create_distmat(mf04p,
  predpts = "pred1km", among_predpts = TRUE,
  overwrite = TRUE
)

## End(Not run)

## Check names of prediction datasets
names(mf04p$preds)

## Get list of stream distance matrices for observations
dist_obs &lt;- ssn_get_stream_distmat(mf04p)
## Display structure of list and names of the matrices
str(dist_obs)
names(dist_obs)
## Look at first 5 rows and columns in asymmetric
## downstream only distance matrix for netID == 1
dist_obs$dist.net1[1:5, 1:5]

## Create symmetric total stream distance matrix between
## observations
strdist_2 &lt;- dist_obs$dist.net2 + t(dist_obs$dist.net2)
strdist_2[5:10, 5:10]

## Get maximum downstream only distance between
## observations on netID == 2
a.mat &lt;- pmax(dist_obs$dist.net2, t(dist_obs$dist.net2))
a.mat[5:10, 5:10]

## Get minimum downstream only distance between observations. If
## minimum distance == 0, sites are flow-connected
b.mat &lt;- pmin(dist_obs$dist.net2, t(dist_obs$dist.net2))
b.mat[5:10, 5:10]

## Get distance matrices for pred1km
dist_pred1km &lt;- ssn_get_stream_distmat(mf04p, name = "pred1km")
str(dist_pred1km)
names(dist_pred1km)
## Look at first 5 rows and columns of downstream only distances
## FROM prediction sites TO observed sites on netID == 1
dist_pred1km$dist.net1.a[1:5, 1:5]

## Look at downstream only stream distances among prediction
## sites in pred1km on netID == 1. This is useful for block
## prediction
dist_pred1km$dist.net1[1:5, 1:5]
</code></pre>

<hr>
<h2 id='ssn_glm'>Fitting Generalized Linear Models for Spatial Stream Networks</h2><span id='topic+ssn_glm'></span>

<h3>Description</h3>

<p>This function works on spatial stream network objects to fit
generalized linear models with spatially autocorrelated errors using likelihood methods, allowing for
non-spatial random effects, anisotropy, partition factors, big data methods, and more.
The spatial formulation is described in Ver Hoef and Peterson (2010)
and Peterson and Ver Hoef (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssn_glm(
  formula,
  ssn.object,
  family,
  tailup_type = "none",
  taildown_type = "none",
  euclid_type = "none",
  nugget_type = "nugget",
  tailup_initial,
  taildown_initial,
  euclid_initial,
  nugget_initial,
  dispersion_initial,
  additive,
  estmethod = "reml",
  anisotropy = FALSE,
  random,
  randcov_initial,
  partition_factor,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssn_glm_+3A_formula">formula</code></td>
<td>
<p>A two-sided linear formula describing the fixed effect structure
of the model, with the response to the left of the <code>~</code> operator and
the terms on the right, separated by <code>+</code> operators.</p>
</td></tr>
<tr><td><code id="ssn_glm_+3A_ssn.object">ssn.object</code></td>
<td>
<p>A spatial stream network object with class <code>SSN</code>.</p>
</td></tr>
<tr><td><code id="ssn_glm_+3A_family">family</code></td>
<td>
<p>The generalized linear model family for use with <code>ssn_glm()</code>.
Available options include <code>"Gaussian"</code>, <code>"poisson"</code>,
<code>"nbinomial"</code> (negative binomial), <code>"binomial"</code>, <code>"beta"</code>,
<code>"Gamma"</code>, and <code>"invgauss"</code>. When <code>family</code>
is <code>"Gaussian"</code>, arguments are passed to and evaluated by <code><a href="#topic+ssn_lm">ssn_lm()</a></code>.
Can be quoted or unquoted. Note that the <code>family</code> argument
only takes a single value, rather than the list structure used by <a href="stats.html#topic+glm">stats::glm</a>.
See Details for more.</p>
</td></tr>
<tr><td><code id="ssn_glm_+3A_tailup_type">tailup_type</code></td>
<td>
<p>The tailup covariance function type. Available options
include <code>"linear"</code>, <code>"spherical"</code>, <code>"exponential"</code>,
<code>"mariah"</code>, <code>"epa"</code>, and <code>"none"</code>. Parameterizations are
described in Details.</p>
</td></tr>
<tr><td><code id="ssn_glm_+3A_taildown_type">taildown_type</code></td>
<td>
<p>The taildown covariance function type. Available options
include <code>"linear"</code>, <code>"spherical"</code>, <code>"exponential"</code>,
<code>"mariah"</code>, <code>"epa"</code>, and <code>"none"</code>. Parameterizations are
described in Details.</p>
</td></tr>
<tr><td><code id="ssn_glm_+3A_euclid_type">euclid_type</code></td>
<td>
<p>The euclidean covariance function type. Available options
include <code>"spherical"</code>, <code>"exponential"</code>, <code>"gaussian"</code>,
<code>"cosine"</code>, <code>"cubic"</code>, <code>"pentaspherical"</code>, <code>"wave"</code>,
<code>"jbessel"</code>, <code>"gravity"</code>, <code>"rquad"</code>, <code>"magnetic"</code>, and
<code>"none"</code>. Parameterizations are
described in Details.</p>
</td></tr>
<tr><td><code id="ssn_glm_+3A_nugget_type">nugget_type</code></td>
<td>
<p>The nugget covariance function type. Available options
include <code>"nugget"</code> or <code>"none"</code>. Parameterizations are
described in Details.</p>
</td></tr>
<tr><td><code id="ssn_glm_+3A_tailup_initial">tailup_initial</code></td>
<td>
<p>An object from <code><a href="#topic+tailup_initial">tailup_initial()</a></code> specifying initial and/or
known values for the tailup covariance parameters.</p>
</td></tr>
<tr><td><code id="ssn_glm_+3A_taildown_initial">taildown_initial</code></td>
<td>
<p>An object from <code><a href="#topic+taildown_initial">taildown_initial()</a></code> specifying initial and/or
known values for the taildown covariance parameters.</p>
</td></tr>
<tr><td><code id="ssn_glm_+3A_euclid_initial">euclid_initial</code></td>
<td>
<p>An object from <code><a href="#topic+euclid_initial">euclid_initial()</a></code> specifying initial and/or
known values for the euclidean covariance parameters.</p>
</td></tr>
<tr><td><code id="ssn_glm_+3A_nugget_initial">nugget_initial</code></td>
<td>
<p>An object from <code><a href="#topic+nugget_initial">nugget_initial()</a></code> specifying initial and/or
known values for the nugget covariance parameters.</p>
</td></tr>
<tr><td><code id="ssn_glm_+3A_dispersion_initial">dispersion_initial</code></td>
<td>
<p>An object from <code><a href="#topic+dispersion_initial">dispersion_initial()</a></code> specifying initial and/or
known values for the tailup covariance parameters.</p>
</td></tr>
<tr><td><code id="ssn_glm_+3A_additive">additive</code></td>
<td>
<p>The name of the variable in <code>ssn.object</code> that is used
to define spatial weights. Can be quoted or unquoted. For the tailup covariance functions, these additive
weights are used for branching. Technical details that describe the role
of the additive variable in the tailup covariance function are available
in Ver Hoef and Peterson (2010).</p>
</td></tr>
<tr><td><code id="ssn_glm_+3A_estmethod">estmethod</code></td>
<td>
<p>The estimation method. Available options include
<code>"reml"</code> for restricted maximum likelihood and <code>"ml"</code> for maximum
likelihood. The default is <code>"reml"</code>.</p>
</td></tr>
<tr><td><code id="ssn_glm_+3A_anisotropy">anisotropy</code></td>
<td>
<p>A logical indicating whether (geometric) anisotropy should
be modeled. Not required if <code>spcov_initial</code> is provided with 1) <code>rotate</code>
assumed unknown or assumed known and non-zero or 2) <code>scale</code> assumed unknown
or assumed known and less than one. When <code>anisotropy</code> is <code>TRUE</code>,
computational times can significantly increase. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ssn_glm_+3A_random">random</code></td>
<td>
<p>A one-sided linear formula describing the random effect structure
of the model. Terms are specified to the right of the <code>~ operator</code>.
Each term has the structure <code>x1 + ... + xn | g1/.../gm</code>, where <code>x1 + ... + xn</code>
specifies the model for the random effects and <code>g1/.../gm</code> is the grouping
structure. Separate terms are separated by <code>+</code> and must generally
be wrapped in parentheses. Random intercepts are added to each model
implicitly when at least  one other variable is defined.
If a random intercept is not desired, this must be explicitly
defined (e.g., <code>x1 + ... + xn - 1 | g1/.../gm</code>). If only a random intercept
is desired for a grouping structure, the random intercept must be specified
as <code>1 | g1/.../gm</code>. Note that <code>g1/.../gm</code> is shorthand for <code>(1 | g1/.../gm)</code>.
If only random intercepts are desired and the shorthand notation is used,
parentheses can be omitted.</p>
</td></tr>
<tr><td><code id="ssn_glm_+3A_randcov_initial">randcov_initial</code></td>
<td>
<p>An optional object specifying initial and/or
known values for the random effect variances. See <code><a href="spmodel.html#topic+randcov_initial">spmodel::randcov_initial()</a></code>.</p>
</td></tr>
<tr><td><code id="ssn_glm_+3A_partition_factor">partition_factor</code></td>
<td>
<p>A one-sided linear formula with a single term
specifying the partition factor.  The partition factor assumes observations
from different levels of the partition factor are uncorrelated.</p>
</td></tr>
<tr><td><code id="ssn_glm_+3A_...">...</code></td>
<td>
<p>Other arguments to <code>stats::optim()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generalized linear model for spatial stream networks can be written as
<code class="reqn">g(\mu) = \eta = X \beta + zu + zd + ze + n</code>, where <code class="reqn">\mu</code> is the expectation
of the response given the random errors, <code class="reqn">y</code>, <code class="reqn">g()</code> is a function that links the mean
and <code class="reqn">\eta</code> (and is called a link function), <code>X</code> is the fixed effects design
matrix, <code class="reqn">\beta</code> are the fixed effects, <code class="reqn">zu</code> is tailup random error,
<code class="reqn">zd</code> is taildown random error, and <code class="reqn">ze</code> is Euclidean random error,
and <code class="reqn">n</code> is nugget random error.
</p>
<p>There are six generalized linear model
families available: <code>poisson</code> assumes <code class="reqn">y</code> is a Poisson random variable
<code>nbinomial</code> assumes <code class="reqn">y</code> is a negative binomial random
variable, <code>binomial</code> assumes <code class="reqn">y</code> is a binomial random variable,
<code>beta</code> assumes <code class="reqn">y</code> is a beta random variable,
<code>Gamma</code> assumes <code class="reqn">y</code> is a gamma random
variable, and <code>inverse.gaussian</code> assumes <code class="reqn">y</code> is an inverse Gaussian
random variable.
</p>
<p>The supports for <code class="reqn">y</code> for each family are given below:
</p>

<ul>
<li><p> family: support of <code class="reqn">y</code>
</p>
</li>
<li><p> Gaussian: <code class="reqn">-\infty &lt; y &lt; \infty</code>
</p>
</li>
<li><p> poisson: <code class="reqn">0 \le y</code>; <code class="reqn">y</code> an integer
</p>
</li>
<li><p> nbinomial: <code class="reqn">0 \le y</code>; <code class="reqn">y</code> an integer
</p>
</li>
<li><p> binomial: <code class="reqn">0 \le y</code>; <code class="reqn">y</code> an integer
</p>
</li>
<li><p> beta: <code class="reqn">0 &lt; y &lt; 1</code>
</p>
</li>
<li><p> Gamma: <code class="reqn">0 &lt; y</code>
</p>
</li>
<li><p> inverse.gaussian: <code class="reqn">0 &lt; y</code>
</p>
</li></ul>

<p>The generalized linear model families
and the parameterizations of their link functions are given
below:
</p>

<ul>
<li><p> family: link function
</p>
</li>
<li><p> Gaussian: <code class="reqn">g(\mu) = \eta</code> (identity link)
</p>
</li>
<li><p> poisson: <code class="reqn">g(\mu) = log(\eta)</code> (log link)
</p>
</li>
<li><p> nbinomial: <code class="reqn">g(\mu) = log(\eta)</code> (log link)
</p>
</li>
<li><p> binomial: <code class="reqn">g(\mu) = log(\eta / (1 - \eta))</code> (logit link)
</p>
</li>
<li><p> beta: <code class="reqn">g(\mu) = log(\eta / (1 - \eta))</code> (logit link)
</p>
</li>
<li><p> Gamma: <code class="reqn">g(\mu) = log(\eta)</code> (log link)
</p>
</li>
<li><p> inverse.gaussian: <code class="reqn">g(\mu) = log(\eta)</code> (log link)
</p>
</li></ul>

<p>The variance function of an individual <code class="reqn">y</code> (given <code class="reqn">\mu</code>)
for each generalized linear model family is given below:
</p>

<ul>
<li><p> family: <code class="reqn">Var(y)</code>
</p>
</li>
<li><p> Gaussian: <code class="reqn">\sigma^2</code>
</p>
</li>
<li><p> poisson: <code class="reqn">\mu \phi</code>
</p>
</li>
<li><p> nbinomial: <code class="reqn">\mu + \mu^2 / \phi</code>
</p>
</li>
<li><p> binomial: <code class="reqn">n \mu (1 - \mu) \phi</code>
</p>
</li>
<li><p> beta: <code class="reqn">\mu (1 - \mu) / (1 + \phi)</code>
</p>
</li>
<li><p> Gamma: <code class="reqn">\mu^2 / \phi</code>
</p>
</li>
<li><p> inverse.gaussian: <code class="reqn">\mu^2 / \phi</code>
</p>
</li></ul>

<p>The parameter <code class="reqn">\phi</code> is a dispersion parameter that influences <code class="reqn">Var(y)</code>.
For the <code>poisson</code> and <code>binomial</code> families, <code class="reqn">\phi</code> is always
one. Note that this inverse Gaussian parameterization is different than a
standard inverse Gaussian parameterization, which has variance <code class="reqn">\mu^3 / \lambda</code>.
Setting <code class="reqn">\phi = \lambda / \mu</code> yields our parameterization, which is
preferred for computational stability. Also note that the dispersion parameter
is often defined in the literature as <code class="reqn">V(\mu) \phi</code>, where <code class="reqn">V(\mu)</code> is the variance
function of the mean. We do not use this parameterization, which is important
to recognize while interpreting dispersion estimates.
For more on generalized linear model constructions, see McCullagh and
Nelder (1989).
</p>
<p>In the generalized linear model context, the tailup, taildown, Euclidean, and
nugget covariance affect the modeled mean of an observation (conditional on
these effects). On the link scale, the tailup random errors capture spatial
covariance moving downstream (and depend on downstream distance), the taildown
random errors capture spatial covariance moving upstream (and depend on upstream)
distance, the Euclidean random errors capture spatial covariance that depends on
Euclidean distance, and the nugget random errors captures variability
independent of spatial locations. <code class="reqn">\eta</code> is modeled using a
spatial covariance function expressed as
<code class="reqn">de(zu) * R(zu) + de(zd) * R(zd) + de(ze) * R(ze) + nugget * I</code>.
<code class="reqn">de(zu)</code>, <code class="reqn">de(zu)</code>, and <code class="reqn">de(zd)</code> represent the tailup, taildown, and Euclidean
variances, respectively. <code class="reqn">R(zu)</code>, <code class="reqn">R(zd)</code>, and <code class="reqn">R(ze)</code> represent the tailup,
taildown, and Euclidean correlation matrices, respectively. Each correlation
matrix depends on a range parameter that controls the distance-decay behavior
of the correlation. <code class="reqn">nugget</code> represents the nugget variance and
<code class="reqn">I</code> represents an identity matrix.
</p>
<p><code>tailup_type</code> Details: Let <code class="reqn">D</code> be a matrix of hydrologic distances,
<code class="reqn">W</code> be a diagonal matrix of weights from <code>additive</code>, <code class="reqn">r = D / range</code>,
and <code class="reqn">I</code> be
an identity matrix. Then parametric forms for flow-connected
elements of <code class="reqn">R(zu)</code> are given below:
</p>

<ul>
<li><p> linear: <code class="reqn">(1 - r) * (r &lt;= 1) * W</code>
</p>
</li>
<li><p> spherical: <code class="reqn">(1 - 1.5r + 0.5r^3) * (r &lt;= 1) * W</code>
</p>
</li>
<li><p> exponential: <code class="reqn">exp(-r) * W</code>
</p>
</li>
<li><p> mariah: <code class="reqn">log(90r + 1) / 90r * (D &gt; 0) + 1 * (D = 0) * W</code>
</p>
</li>
<li><p> epa: <code class="reqn">(D - range)^2 * F * (r &lt;= 1) * W / 16range^5</code>
</p>
</li>
<li><p> none: <code class="reqn">I</code> * W
</p>
</li></ul>

<p>Details describing the <code>F</code> matrix in the <code>epa</code> covariance are given in Garreta et al. (2010).
Flow-unconnected elements of <code class="reqn">R(zu)</code> are assumed uncorrelated.
Observations on different networks are also assumed uncorrelated.
</p>
<p><code>taildown_type</code> Details: Let <code class="reqn">D</code> be a matrix of hydrologic distances,
<code class="reqn">r = D / range</code>,
and <code class="reqn">I</code> be an identity matrix. Then parametric forms for flow-connected
elements of <code class="reqn">R(zd)</code> are given below:
</p>

<ul>
<li><p> linear: <code class="reqn">(1 - r) * (r &lt;= 1)</code>
</p>
</li>
<li><p> spherical: <code class="reqn">(1 - 1.5r + 0.5r^3) * (r &lt;= 1)</code>
</p>
</li>
<li><p> exponential: <code class="reqn">exp(-r)</code>
</p>
</li>
<li><p> mariah: <code class="reqn">log(90r + 1) / 90r * (D &gt; 0) + 1 * (D = 0)</code>
</p>
</li>
<li><p> epa: <code class="reqn">(D - range)^2 * F1 * (r &lt;= 1) / 16range^5</code>
</p>
</li>
<li><p> none: <code class="reqn">I</code>
</p>
</li></ul>

<p>Now let <code class="reqn">A</code> be a matrix that contains the shorter of the two distances
between two sites and the common downstream junction, <code class="reqn">r1 = A / range</code>,
<code class="reqn">B</code> be a matrix that contains the longer of the two distances between two sites and the
common downstream junction, <code class="reqn">r2 = B / range</code>,  and <code class="reqn">I</code> be an identity matrix.
Then parametric forms for flow-unconnected elements of <code class="reqn">R(zd)</code> are given below:
</p>

<ul>
<li><p> linear: <code class="reqn">(1 - r2) * (r2 &lt;= 1)</code>
</p>
</li>
<li><p> spherical: <code class="reqn">(1 - 1.5r1 + 0.5r2) * (1 - r2)^2 * (r2 &lt;= 1)</code>
</p>
</li>
<li><p> exponential: <code class="reqn">exp(-(r1 + r2))</code>
</p>
</li>
<li><p> mariah: <code class="reqn">(log(90r1 + 1) - log(90r2 + 1)) / (90r1 - 90r2) * (A =/ B) + (1 / (90r1 + 1)) * (A = B)</code>
</p>
</li>
<li><p> epa: <code class="reqn">(B - range)^2 * F2 * (r2 &lt;= 1) / 16range^5</code>
</p>
</li>
<li><p> none: <code class="reqn">I</code>
</p>
</li></ul>

<p>Details describing the <code>F1</code> and <code>F2</code> matrices in the <code>epa</code>
covariance are given in Garreta et al. (2010).
Observations on different networks are assumed uncorrelated.
</p>
<p><code>euclid_type</code> Details: Let <code class="reqn">D</code> be a matrix of Euclidean distances,
<code class="reqn">r = D / range</code>, and <code class="reqn">I</code> be an identity matrix. Then parametric
forms for elements of <code class="reqn">R(ze)</code> are given below:
</p>

<ul>
<li><p> exponential: <code class="reqn">exp(- r )</code>
</p>
</li>
<li><p> spherical: <code class="reqn">(1 - 1.5r + 0.5r^3) * (r &lt;= 1)</code>
</p>
</li>
<li><p> gaussian: <code class="reqn">exp(- r^2 )</code>
</p>
</li>
<li><p> cubic: <code class="reqn">(1 - 7r^2 + 8.75r^3 - 3.5r^5 + 0.75r^7) * (r &lt;= 1)</code>
</p>
</li>
<li><p> pentaspherical: <code class="reqn">(1 - 1.875r + 1.25r^3 - 0.375r^5) * (r &lt;= 1)</code>
</p>
</li>
<li><p> cosine: <code class="reqn">cos(r)</code>
</p>
</li>
<li><p> wave: <code class="reqn">sin(r) * (h &gt; 0) / r + (h = 0)</code>
</p>
</li>
<li><p> jbessel: <code class="reqn">Bj(h * range)</code>, Bj is Bessel-J function
</p>
</li>
<li><p> gravity: <code class="reqn">(1 + r^2)^{-0.5}</code>
</p>
</li>
<li><p> rquad: <code class="reqn">(1 + r^2)^{-1}</code>
</p>
</li>
<li><p> magnetic: <code class="reqn">(1 + r^2)^{-1.5}</code>
</p>
</li>
<li><p> none: <code class="reqn">I</code>
</p>
</li></ul>

<p><code>nugget_type</code> Details: Let <code class="reqn">I</code> be an identity matrix and <code class="reqn">0</code>
be the zero matrix. Then parametric
forms for elements the nugget variance are given below:
</p>

<ul>
<li><p> nugget: <code class="reqn">I</code>
</p>
</li>
<li><p> none: <code class="reqn">0</code>
</p>
</li></ul>

<p>In short, the nugget effect is modeled when <code>nugget_type</code> is <code>"nugget"</code>
and omitted when <code>nugget_type</code> is <code>"none"</code>.
</p>
<p><code>estmethod</code> Details: The various estimation methods are
</p>

<ul>
<li> <p><code>reml</code>: Maximize the restricted log-likelihood.
</p>
</li>
<li> <p><code>ml</code>: Maximize the log-likelihood.
</p>
</li></ul>

<p><code>anisotropy</code> Details: By default, all Euclidean covariance parameters except <code>rotate</code>
and <code>scale</code> are assumed unknown, requiring estimation. If either <code>rotate</code> or <code>scale</code>
are given initial values other than 0 and 1 (respectively) or are assumed unknown
in <code><a href="#topic+euclid_initial">euclid_initial()</a></code>, <code>anisotropy</code> is implicitly set to <code>TRUE</code>.
(Geometric) Anisotropy is modeled by transforming a Euclidean covariance function that
decays differently in different directions to one that decays equally in all
directions via rotation and scaling of the original Euclidean coordinates. The rotation is
controlled by the <code>rotate</code> parameter in <code class="reqn">[0, \pi]</code> radians. The scaling
is controlled by the <code>scale</code> parameter in <code class="reqn">[0, 1]</code>. The anisotropy
correction involves first a rotation of the coordinates clockwise by <code>rotate</code> and then a
scaling of the coordinates' minor axis by the reciprocal of <code>scale</code>. The Euclidean
covariance is then computed using these transformed coordinates.
</p>
<p><code>random</code> Details: If random effects are used (the estimation method must be <code>"reml"</code> or
<code>"ml"</code>), the model
can be written as <code class="reqn">g(\mu) = \eta = X \beta + W1\gamma 1 + ... Wj\gamma j + zu + zd + ze + n</code>,
where each Z is a random effects design matrix and each u is a random effect.
</p>
<p><code>partition_factor</code> Details: The partition factor can be represented in matrix form as <code class="reqn">P</code>, where
elements of <code class="reqn">P</code> equal one for observations in the same level of the partition
factor and zero otherwise. The covariance matrix involving only the
spatial and random effects components is then multiplied element-wise
(Hadmard product) by <code class="reqn">P</code>, yielding the final covariance matrix.
</p>
<p>Other Details: Observations with <code>NA</code> response values are removed for model
fitting, but their values can be predicted afterwards by running
<code>predict(object)</code>.
</p>


<h3>Value</h3>

<p>A list with many elements that store information about
the fitted model object and has class <code>ssn_glm</code>. Many generic functions that
summarize model fit are available for <code>ssn_glm</code> objects, including
<code>AIC</code>, <code>AICc</code>, <code>anova</code>, <code>augment</code>, <code>coef</code>,
<code>cooks.distance</code>, <code>covmatrix</code>, <code>deviance</code>, <code>fitted</code>, <code>formula</code>,
<code>glance</code>, <code>glances</code>, <code>hatvalues</code>, <code>influence</code>,
<code>labels</code>, <code>logLik</code>, <code>loocv</code>, <code>model.frame</code>, <code>model.matrix</code>,
<code>plot</code>, <code>predict</code>, <code>print</code>, <code>pseudoR2</code>, <code>summary</code>,
<code>terms</code>, <code>tidy</code>, <code>update</code>, <code>varcomp</code>, and <code>vcov</code>.
</p>
<p>This fitted model list contains the following elements:
</p>

<ul>
<li> <p><code>additive</code>: The name of the additive function value column.
</p>
</li>
<li> <p><code>anisotropy</code>: Whether euclidean anisotropy was modeled.
</p>
</li>
<li> <p><code>call</code>: The function call.
</p>
</li>
<li> <p><code>coefficients</code>: Model coefficients.
</p>
</li>
<li> <p><code>contrasts</code>: Any user-supplied contrasts.
</p>
</li>
<li> <p><code>cooks_distance</code>: Cook's distance values.
</p>
</li>
<li> <p><code>crs</code>: The geographic coordinate reference system.
</p>
</li>
<li> <p><code>deviance</code>: The model deviance.
</p>
</li>
<li> <p><code>diagtol</code>: A tolerance value that may be added to the diagonal
of  ovariance matrices to encourage decomposition stability.
</p>
</li>
<li> <p><code>estmethod</code>: The estimation method.
</p>
</li>
<li> <p><code>euclid_max</code>: The maximum euclidean distance.
</p>
</li>
<li> <p><code>family</code>: The generalized linear model family
</p>
</li>
<li> <p><code>fitted</code>: Fitted values.
</p>
</li>
<li> <p><code>formula</code>: The model formula.
</p>
</li>
<li> <p><code>hatvalues</code>: The hat (leverage) values.
</p>
</li>
<li> <p><code>is_known</code>: An object that identifies which parameters are known.
</p>
</li>
<li> <p><code>local_index</code>: An index identifier used internally for sorting.
</p>
</li>
<li> <p><code>missing_index</code>: Which rows in the &quot;obs&quot; object had missing responses.
</p>
</li>
<li> <p><code>n</code>: The sample size.
</p>
</li>
<li> <p><code>npar</code>: The number of estimated covariance parameters.
</p>
</li>
<li> <p><code>observed_index</code>: Which rows in the &quot;obs&quot; object had observed responses.
</p>
</li>
<li> <p><code>optim</code>: The optimization output.
</p>
</li>
<li> <p><code>p</code>: The number of fixed effects.
</p>
</li>
<li> <p><code>partition_factor</code>: The partition factor formula.
</p>
</li>
<li> <p><code>pseudoR2</code>: The pseudo R-squared.
</p>
</li>
<li> <p><code>random</code>: The random effect formula.
</p>
</li>
<li> <p><code>residuals</code>: The residuals.
</p>
</li>
<li> <p><code>sf_column_name</code>: The name of the geometry columns <code>ssn.object</code>
</p>
</li>
<li> <p><code>size</code>: The size of the binomial trials if relevant.
</p>
</li>
<li> <p><code>ssn.object</code>: An updated <code>ssn.object</code>.
</p>
</li>
<li> <p><code>tail_max</code>: The maximum stream distance.
</p>
</li>
<li> <p><code>terms</code>: The model terms.
</p>
</li>
<li> <p><code>vcov</code>: Variance-covariance matrices
</p>
</li>
<li> <p><code>xlevels</code>: The levels of factors in the model matrix.
</p>
</li>
<li> <p><code>y</code>: The response.
</p>
</li></ul>

<p>These list elements are meant to be used with various generic functions
(<code>e.g., residuals()</code> that operate on the model object.
While possible to access elements of the fitted model list directly, we strongly
advise against doing so when there is a generic available to return the element
of interest. For example, we strongly recommend using <code>residuals()</code> to
obtain model residuals instead of accessing the fitted model list directly via
<code>object$residuals</code>.
</p>


<h3>Note</h3>

<p>This function does not perform any internal scaling. If optimization is not
stable due to large extremely large variances, scale relevant variables
so they have variance 1 before optimization.
</p>


<h3>References</h3>

<p>Garreta, V., Monestiez, P. and Ver Hoef, J.M. (2010) Spatial modelling and
prediction on river networks: up model, down model, or hybrid?
<em>Environmetrics</em> <b>21(5)</b>, 439&ndash;456.
</p>
<p>McCullagh P. and Nelder, J. A. (1989) <em>Generalized Linear Models</em>. London: Chapman and Hall.
</p>
<p>Peterson, E.E. and Ver Hoef, J.M. (2010) A mixed-model moving-average approach
to geostatistical modeling in stream networks. <em>Ecology</em> <b>91(3)</b>,
644&ndash;651.
</p>
<p>Ver Hoef, J.M. and Peterson, E.E. (2010) A moving average approach for spatial
statistical models of stream networks (with discussion).
<em>Journal of the American Statistical Association</em> <b>105</b>, 6&ndash;18.
DOI: 10.1198/jasa.2009.ap08248.  Rejoinder pgs. 22&ndash;24.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_gmod &lt;- ssn_glm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  family = "Gamma",
  tailup_type = "exponential",
  additive = "afvArea"
)
summary(ssn_gmod)

</code></pre>

<hr>
<h2 id='ssn_import'>Import <code>SSN</code> object</h2><span id='topic+ssn_import'></span>

<h3>Description</h3>

<p>This function reads spatial data from a .ssn folder
and creates an <code>SSN</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssn_import(
  path,
  include_obs = TRUE,
  predpts,
  format_additive = FALSE,
  names_additive = NULL,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssn_import_+3A_path">path</code></td>
<td>
<p>Filepath to the .ssn directory. See details.</p>
</td></tr>
<tr><td><code id="ssn_import_+3A_include_obs">include_obs</code></td>
<td>
<p>default = <code>TRUE</code>. Logical indicating
whether observed sites should be included in the SSN object.</p>
</td></tr>
<tr><td><code id="ssn_import_+3A_predpts">predpts</code></td>
<td>
<p>Vector of shapefile basenames for prediction sites
found within the .ssn folder.</p>
</td></tr>
<tr><td><code id="ssn_import_+3A_format_additive">format_additive</code></td>
<td>
<p>Logical indicating whether the columns containing
the addtive function values should be formated for
<code>SSN2</code>. Default = <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ssn_import_+3A_names_additive">names_additive</code></td>
<td>
<p>Character vector of column names in observed and
prediction site datasets containing additive function values.
Must be defined if <code>format_additive = TRUE</code>. Default =
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ssn_import_+3A_overwrite">overwrite</code></td>
<td>
<p>default = <code>FALSE</code>. If <code>TRUE</code>, overwrite
existing binaryID.db files.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>importSSN</code> function imports spatial data from a .ssn
folder to create an <code>SSN</code> object. The information contained in the
.ssn folder can be generated using a number of proprietary and
open source software tools:
</p>

<ul>
<li><p>The Spatial Tools for the Analysis of River Systems
(STARS) tools for ArcGIS Desktop versions 9.3x-10.8x (Peterson
and Ver Hoef 2014). This custom ArcGIS toolset is designed to
work with existing streams data in vector format.
</p>
</li>
<li><p>The openSTARS package (Kattwinkel et al. 2020) extends
the functionality of the STARS toolset, which makes use of R
and GRASS GIS. It is open source and designed to derive streams
in raster format from a digital elevation model (DEM).
</p>
</li>
<li><p>The SSNbler package (currently in development as of
September 2023) is an open source version of the STARS toolset,
which makes use of the functionality found in the sf package to
process streams data in vector format.
</p>
</li></ul>

<p>When spatial data are processed using one of these software
tools, a .ssn directory is output which contains all of the
spatial, topological and attribute data needed to fit a spatial
statistical stream network model to streams data.  This includes:
</p>

<ul>
<li><p>An edges shapefile of lines that represent the stream
network.
</p>
</li>
<li><p>A sites shapefile of points where observed data were
collected on the stream network.
</p>
</li>
<li><p>Prediction sites shapefile(s) of locations where
predictions will be made.
</p>
</li>
<li><p>netID.dat files for each distinct network, which store
the topological relationships of the line segments in edges.
</p>
</li></ul>

<p>A more detailed description of the .ssn directory and its
contents is provided in Peterson and Ver Hoef (2014).
</p>
<p>The <code>ssn_import</code> imports the edges, observed sites, and
prediction sites as <code>sf data.frame</code> objects. A new column named 'netgeom'
is created to store important data that represents
topological relationships in a spatial stream network
model. These data are stored in character format, which is less
likely to be inadvertantly changed by users. See
<code><a href="#topic+ssn_get_netgeom">ssn_get_netgeom</a></code> for a more detailed description of
the format and contents of 'netgeom'.
</p>
<p>The information contained in the netID text files is imported
into an SQLite database, binaryID.db, which is stored in the .ssn
directory. This information is used internally by
<code><a href="#topic+ssn_create_distmat">ssn_create_distmat</a></code>,
<code><a href="#topic+ssn_lm">ssn_lm</a></code> and
<code><a href="#topic+ssn_glm">ssn_glm</a></code> to calculate the data necessary
to fit a spatial statistical model to stream network data. If
<code>overwrite = TRUE</code> (<code>overwrite = FALSE</code> is the default) and a binaryID.db
file already exists within the .ssn directory, it will be
overwriten when the <code>SSN</code> object is created.
</p>
<p>At a minimum, an <code>SSN</code> object must always contain streams, which
are referred to as edges. The <code>SSN</code> object would also typically
contain a set of observed sites, where measurements have been
collected and only one observed dataset is permitted. When
<code>include_obs=FALSE</code>, an <code>SSN</code> object is created without
observations. This option provides flexibility for users who
would like to simulate data on a set of artifical sites on an
existing stream network. Note that observation sites must be
included in the <code>SSN</code> object in order to fit models using
<code>ssn_lm</code> or <code>ssn_glm</code>. The <code>SSN</code> object may contain
multiple sets of prediction points (or none), which are stored as
separate shapefiles in the .ssn directory. The
<code><a href="#topic+ssn_import_predpts">ssn_import_predpts</a></code> function allows users to import additional
sets of prediction sites to a an existing <code>SSN</code> object.
</p>


<h3>Value</h3>

<p><code>ssn_import</code> returns an object of class SSN, which is a list
with four elements containing:
</p>

<ul>
<li><p><code>edges</code>: An <code>sf data.frame</code> containing the stream network,
with an additional 'netgeom' column.
</p>
</li>
<li><p><code>obs</code>: An sf data.frame containing observed site locations,
with an additional 'netgeom' column. NA if <code>include_obs =
    FALSE</code>.
</p>
</li>
<li><p><code>preds</code>: A list of sf data.frames containing prediction
site locations. The names of the preds list correspond to the
basenames of the prediction site shapefiles (without the .shp
extension) specified in <code>predpts</code>. Empty list if <code>predpts</code> is not provided.
</p>
</li>
<li><p>path: The local file to the .ssn directory associated with the <code>SSN</code>
object.
</p>
</li></ul>



<h3>References</h3>

<p>Kattwinkel, M., Szocs, E., Peterson, E., and Schafer,
R.B. (2020) Preparing GIS data for analysis of stream monitoring
data: The R package openSTARS. <em>PLOS One</em> <b>15(9)</b>,
e0239237.
Peterson, E., and Ver Hoef, J.M. (2014) STARS: An
ArcGIS toolset used to calculate the spatial information needed
to fit spatial statistical stream network models to stream
network data. <em>Journal of Statistical Software</em>
<b>56(2)</b>, 1&ndash;17.
</p>


<h3>See Also</h3>

<p><a href="#topic+ssn_get_netgeom">ssn_get_netgeom</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create local temporary copy of MiddleFork04.ssn found in
# SSN2/lsndata folder. Only necessary for this example.
copy_lsn_to_temp()

## Import SSN object with no prediction sites
mf04 &lt;- ssn_import(paste0(tempdir(), "/MiddleFork04.ssn"),
  overwrite = TRUE
)

## Import SSN object with 3 sets of prediction sites
mf04p &lt;- ssn_import(paste0(tempdir(), "/MiddleFork04.ssn"),
  predpts = c(
    "pred1km.shp",
    "CapeHorn.shp",
    "Knapp.shp"
  ),
  overwrite = TRUE
)

</code></pre>

<hr>
<h2 id='ssn_import_predpts'>Import prediction points into an SSN, ssn_lm, or ssn_glm object</h2><span id='topic+ssn_import_predpts'></span>

<h3>Description</h3>

<p>A shapefile of prediction points found in the .ssn
directory are imported into an existing object of class
<code>SSN</code>, <code>ssn_lm</code>, or <code>ssn_glm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssn_import_predpts(x, predpts, format_additive = FALSE, names_additive = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssn_import_predpts_+3A_x">x</code></td>
<td>
<p>An object of class<code>SSN</code>, <code>ssn_lm</code>, or
<code>ssn_glm</code>.</p>
</td></tr>
<tr><td><code id="ssn_import_predpts_+3A_predpts">predpts</code></td>
<td>
<p>Name of the prediction point shapefile to import in
character format, without the .shp extension.</p>
</td></tr>
<tr><td><code id="ssn_import_predpts_+3A_format_additive">format_additive</code></td>
<td>
<p>Logical indicating whether the columns containing
the addtive function values should be formated for
<code>SSN2</code>. Default = <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ssn_import_predpts_+3A_names_additive">names_additive</code></td>
<td>
<p>Character vector of column names in observed and
prediction site datasets containing additive function
values. Must be defined if <code>format_additive = TRUE</code>. Default =
<code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ssn_import_predpts</code> imports a shapefile of
prediction points residing in the .ssn directory into an existing
<code>SSN</code>, <code>ssn_lm</code>, or <code>ssn_glm</code> object. The
prediction dataset must reside in the ssn.object$path
directory. The path for an <code>SSN</code> object can be updated using
<code>ssn_update_path()</code> prior to importing prediction
datasets. Note that, the prediction dataset must contain the
spatial, topological and attribute information needed to make
predictions using an ssn_lm or ssn_glm object.  This information
can be generated using a number of proprietary and open source
software tools: </p>
 <ul>
<li><p>The Spatial Tools for the
Analysis of River Systems (STARS) tools for ArcGIS Desktop
versions 9.3x-10.8x (Peterson and Ver Hoef 2014). This custom
ArcGIS toolset is designed to work with existing streams data in
vector format.  </p>
</li>
<li><p>The openSTARS package (Kattwinkel et
al. 2020) extends the functionality of the STARS toolset, which
makes use of R and GRASS GIS. It is open source and designed to
derive streams in raster format from a digital elevation model
(DEM).  </p>
</li>
<li><p>The SSNbler package (currently in development as
of September 2023) is an open source version of the STARS
toolset, which makes use of the functionality found in the sf
package to process streams data in vector format.  </p>
</li></ul>



<h3>Value</h3>

<p>an object of class <code>SSN</code>, <code>ssn_lm</code>, or
<code>ssn_glm</code> which contains the new prediction dataset. The
name of the prediction dataset in the preds list corresponds to
the basenames of the prediction site shapefiles (without the .shp
extension) specified in <code>predpts</code>. See
<code><a href="#topic+ssn_import">ssn_import</a></code> for a detailed description of
the prediction dataset format within the <code>SSN</code> class object.
</p>


<h3>References</h3>

<p>Kattwinkel, M., Szocs, E., Peterson, E., and Schafer,
R.B. (2020) Preparing GIS data for analysis of stream monitoring
data: The R package openSTARS. <em>PLOS One</em> <b>15(9)</b>,
e0239237.
Peterson, E., and Ver Hoef, J.M. (2014) STARS: An
ArcGIS toolset used to calculate the spatial information needed
to fit spatial statistical stream network models to stream
network data. <em>Journal of Statistical Software</em>
<b>56(2)</b>, 1&ndash;17.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create local temporary copy of MiddleFork04.ssn found in
# SSN2/lsndata folder. Only necessary for this example.
copy_lsn_to_temp()

## Import SSN object with no prediction sites
mf04p &lt;- ssn_import(paste0(tempdir(), "/MiddleFork04.ssn"),
  overwrite = TRUE
)

## Import pred1km prediction dataset into SSN object
mf04p &lt;- ssn_import(paste0(tempdir(), "/MiddleFork04.ssn"))
mf04p &lt;- ssn_import_predpts(mf04p, predpts = "pred1km")
names(mf04p$preds)

## Import pred1km prediction dataset into a ssn_glm object
ssn_gmod &lt;- ssn_glm(Summer_mn ~ netID, mf04p,
  family = "Gamma",
  tailup_type = "exponential", additive = "afvArea"
)
ssn_gmod &lt;- ssn_import_predpts(ssn_gmod, predpts = "CapeHorn")
names(ssn_gmod$ssn.object$preds)
</code></pre>

<hr>
<h2 id='ssn_initial'>Create a covariance parameter initial object</h2><span id='topic+ssn_initial'></span><span id='topic+tailup_initial'></span><span id='topic+taildown_initial'></span><span id='topic+euclid_initial'></span><span id='topic+nugget_initial'></span>

<h3>Description</h3>

<p>Create a covariance parameter initial object that specifies
initial and/or known values to use while estimating specific covariance parameters
with <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.  See <code><a href="spmodel.html#topic+randcov_initial">spmodel::randcov_initial()</a></code> for documentation regarding
random effect covariance parameter initial objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tailup_initial(tailup_type, de, range, known)

taildown_initial(taildown_type, de, range, known)

euclid_initial(euclid_type, de, range, rotate, scale, known)

nugget_initial(nugget_type, nugget, known)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssn_initial_+3A_tailup_type">tailup_type</code></td>
<td>
<p>The tailup covariance function type. Available options
include <code>"linear"</code>, <code>"spherical"</code>, <code>"exponential"</code>,
<code>"mariah"</code>, <code>"epa"</code>, and <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="ssn_initial_+3A_de">de</code></td>
<td>
<p>The spatially dependent (correlated) random error variance. Commonly referred to as
a partial sill.</p>
</td></tr>
<tr><td><code id="ssn_initial_+3A_range">range</code></td>
<td>
<p>The correlation parameter.</p>
</td></tr>
<tr><td><code id="ssn_initial_+3A_known">known</code></td>
<td>
<p>A character vector indicating which covariance parameters are to be
assumed known. The value <code>"given"</code> is shorthand for assuming all
covariance parameters given to <code>*_initial()</code> are assumed known.</p>
</td></tr>
<tr><td><code id="ssn_initial_+3A_taildown_type">taildown_type</code></td>
<td>
<p>The taildown covariance function type. Available options
include <code>"linear"</code>, <code>"spherical"</code>, <code>"exponential"</code>,
<code>"mariah"</code>, <code>"epa"</code>, and <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="ssn_initial_+3A_euclid_type">euclid_type</code></td>
<td>
<p>The euclidean covariance function type. Available options
include <code>"spherical"</code>, <code>"exponential"</code>, <code>"gaussian"</code>,
<code>"cosine"</code>, <code>"cubic"</code>, <code>"pentaspherical"</code>, <code>"wave"</code>,
<code>"jbessel"</code>, <code>"gravity"</code>, <code>"rquad"</code>, <code>"magnetic"</code>, and
<code>"none"</code>.</p>
</td></tr>
<tr><td><code id="ssn_initial_+3A_rotate">rotate</code></td>
<td>
<p>Anisotropy rotation parameter (from 0 to <code class="reqn">\pi</code> radians) for
the euclidean portion of the covariance. A value of 0 (the default) implies no rotation.</p>
</td></tr>
<tr><td><code id="ssn_initial_+3A_scale">scale</code></td>
<td>
<p>Anisotropy scale parameter (from 0 to 1) for
the euclidean portion of the covariance. A value of 1 (the default) implies no scaling.</p>
</td></tr>
<tr><td><code id="ssn_initial_+3A_nugget_type">nugget_type</code></td>
<td>
<p>The nugget covariance function type. Available options
include <code>"nugget"</code> or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="ssn_initial_+3A_nugget">nugget</code></td>
<td>
<p>The spatially independent (not correlated) random error variance. Commonly referred to as
a nugget.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create an initial object for use with <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.
<code>NA</code> values can be given for <code>ie</code>, <code>rotate</code>, and <code>scale</code>, which lets
these functions find initial values for parameters that are sometimes
otherwise assumed known (e.g., <code>rotate</code> and <code>scale</code> with <code><a href="#topic+ssn_lm">ssn_lm()</a></code> and <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.
Parametric forms for each spatial covariance type are presented below.
</p>
<p><code>tailup_type</code> Details: Let <code class="reqn">D</code> be a matrix of hydrologic distances,
<code class="reqn">W</code> be a diagonal matrix of weights from <code>additive</code>, <code class="reqn">r = D / range</code>,
and <code class="reqn">I</code> be
an identity matrix. Then parametric forms for flow-connected
elements of <code class="reqn">R(zu)</code> are given below:
</p>

<ul>
<li><p> linear: <code class="reqn">(1 - r) * (r &lt;= 1) * W</code>
</p>
</li>
<li><p> spherical: <code class="reqn">(1 - 1.5r + 0.5r^3) * (r &lt;= 1) * W</code>
</p>
</li>
<li><p> exponential: <code class="reqn">exp(-r) * W</code>
</p>
</li>
<li><p> mariah: <code class="reqn">log(90r + 1) / 90r * (D &gt; 0) + 1 * (D = 0) * W</code>
</p>
</li>
<li><p> epa: <code class="reqn">(D - range)^2 * F * (r &lt;= 1) * W / 16range^5</code>
</p>
</li>
<li><p> none: <code class="reqn">I</code> * W
</p>
</li></ul>

<p>Details describing the <code>F</code> matrix in the <code>epa</code> covariance are given in Garreta et al. (2010).
Flow-unconnected elements of <code class="reqn">R(zu)</code> are assumed uncorrelated.
Observations on different networks are also assumed uncorrelated.
</p>
<p><code>taildown_type</code> Details: Let <code class="reqn">D</code> be a matrix of hydrologic distances,
<code class="reqn">r = D / range</code>,
and <code class="reqn">I</code> be an identity matrix. Then parametric forms for flow-connected
elements of <code class="reqn">R(zd)</code> are given below:
</p>

<ul>
<li><p> linear: <code class="reqn">(1 - r) * (r &lt;= 1)</code>
</p>
</li>
<li><p> spherical: <code class="reqn">(1 - 1.5r + 0.5r^3) * (r &lt;= 1)</code>
</p>
</li>
<li><p> exponential: <code class="reqn">exp(-r)</code>
</p>
</li>
<li><p> mariah: <code class="reqn">log(90r + 1) / 90r * (D &gt; 0) + 1 * (D = 0)</code>
</p>
</li>
<li><p> epa: <code class="reqn">(D - range)^2 * F1 * (r &lt;= 1) / 16range^5</code>
</p>
</li>
<li><p> none: <code class="reqn">I</code>
</p>
</li></ul>

<p>Now let <code class="reqn">A</code> be a matrix that contains the shorter of the two distances
between two sites and the common downstream junction, <code class="reqn">r1 = A / range</code>,
<code class="reqn">B</code> be a matrix that contains the longer of the two distances between two sites and the
common downstream junction, <code class="reqn">r2 = B / range</code>,  and <code class="reqn">I</code> be an identity matrix.
Then parametric forms for flow-unconnected elements of <code class="reqn">R(zd)</code> are given below:
</p>

<ul>
<li><p> linear: <code class="reqn">(1 - r2) * (r2 &lt;= 1)</code>
</p>
</li>
<li><p> spherical: <code class="reqn">(1 - 1.5r1 + 0.5r2) * (1 - r2)^2 * (r2 &lt;= 1)</code>
</p>
</li>
<li><p> exponential: <code class="reqn">exp(-(r1 + r2))</code>
</p>
</li>
<li><p> mariah: <code class="reqn">(log(90r1 + 1) - log(90r2 + 1)) / (90r1 - 90r2) * (A =/ B) + (1 / (90r1 + 1)) * (A = B)</code>
</p>
</li>
<li><p> epa: <code class="reqn">(B - range)^2 * F2 * (r2 &lt;= 1) / 16range^5</code>
</p>
</li>
<li><p> none: <code class="reqn">I</code>
</p>
</li></ul>

<p>Details describing the <code>F1</code> and <code>F2</code> matrices in the <code>epa</code>
covariance are given in Garreta et al. (2010).
Observations on different networks are assumed uncorrelated.
</p>
<p><code>euclid_type</code> Details: Let <code class="reqn">D</code> be a matrix of Euclidean distances,
<code class="reqn">r = D / range</code>, and <code class="reqn">I</code> be an identity matrix. Then parametric
forms for elements of <code class="reqn">R(ze)</code> are given below:
</p>

<ul>
<li><p> exponential: <code class="reqn">exp(- r )</code>
</p>
</li>
<li><p> spherical: <code class="reqn">(1 - 1.5r + 0.5r^3) * (r &lt;= 1)</code>
</p>
</li>
<li><p> gaussian: <code class="reqn">exp(- r^2 )</code>
</p>
</li>
<li><p> cubic: <code class="reqn">(1 - 7r^2 + 8.75r^3 - 3.5r^5 + 0.75r^7) * (r &lt;= 1)</code>
</p>
</li>
<li><p> pentaspherical: <code class="reqn">(1 - 1.875r + 1.25r^3 - 0.375r^5) * (r &lt;= 1)</code>
</p>
</li>
<li><p> cosine: <code class="reqn">cos(r)</code>
</p>
</li>
<li><p> wave: <code class="reqn">sin(r) * (h &gt; 0) / r + (h = 0)</code>
</p>
</li>
<li><p> jbessel: <code class="reqn">Bj(h * range)</code>, Bj is Bessel-J function
</p>
</li>
<li><p> gravity: <code class="reqn">(1 + r^2)^{-0.5}</code>
</p>
</li>
<li><p> rquad: <code class="reqn">(1 + r^2)^{-1}</code>
</p>
</li>
<li><p> magnetic: <code class="reqn">(1 + r^2)^{-1.5}</code>
</p>
</li>
<li><p> none: <code class="reqn">I</code>
</p>
</li></ul>

<p><code>nugget_type</code> Details: Let <code class="reqn">I</code> be an identity matrix and <code class="reqn">0</code>
be the zero matrix. Then parametric
forms for elements the nugget variance are given below:
</p>

<ul>
<li><p> nugget: <code class="reqn">I</code>
</p>
</li>
<li><p> none: <code class="reqn">0</code>
</p>
</li></ul>

<p>In short, the nugget effect is modeled when <code>nugget_type</code> is <code>"nugget"</code>
and omitted when <code>nugget_type</code> is <code>"none"</code>.
</p>
<p>Dispersion and random effect initial objects are specified via
<code><a href="spmodel.html#topic+dispersion_initial">spmodel::dispersion_initial()</a></code> and <code><a href="spmodel.html#topic+randcov_initial">spmodel::randcov_initial()</a></code>, respectively.
</p>


<h3>Value</h3>

<p>A list with two elements: <code>initial</code> and <code>is_known</code>.
<code>initial</code> is a named numeric vector indicating the spatial covariance parameters
with specified initial and/or known values. <code>is_known</code> is a named
numeric vector indicating whether the spatial covariance parameters in
<code>initial</code> are known or not. The class of the list
matches the the relevant spatial covariance type.
</p>


<h3>References</h3>

<p>Peterson, E.E. and Ver Hoef, J.M. (2010) A mixed-model moving-average approach
to geostatistical modeling in stream networks. <em>Ecology</em> <b>91(3)</b>,
644&ndash;651.
</p>
<p>Ver Hoef, J.M. and Peterson, E.E. (2010) A moving average approach for spatial
statistical models of stream networks (with discussion).
<em>Journal of the American Statistical Association</em> <b>105</b>, 6&ndash;18.
DOI: 10.1198/jasa.2009.ap08248.  Rejoinder pgs. 22&ndash;24.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tailup_initial("exponential", de = 1, range = 20, known = "range")
tailup_initial("exponential", de = 1, range = 20, known = "given")
euclid_initial("spherical", de = 2, range = 4, scale = 0.8, known = c("range", "scale"))
dispersion_initial("nbinomial", dispersion = 5)

</code></pre>

<hr>
<h2 id='ssn_lm'>Fitting Linear Models for Spatial Stream Networks</h2><span id='topic+ssn_lm'></span>

<h3>Description</h3>

<p>This function works on spatial stream network objects to fit
linear models with spatially autocorrelated errors using likelihood methods, allowing for
non-spatial random effects, anisotropy, partition factors, big data methods, and more.
The spatial formulation is described in Ver Hoef and Peterson (2010)
and Peterson and Ver Hoef (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssn_lm(
  formula,
  ssn.object,
  tailup_type = "none",
  taildown_type = "none",
  euclid_type = "none",
  nugget_type = "nugget",
  tailup_initial,
  taildown_initial,
  euclid_initial,
  nugget_initial,
  additive,
  estmethod = "reml",
  anisotropy = FALSE,
  random,
  randcov_initial,
  partition_factor,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssn_lm_+3A_formula">formula</code></td>
<td>
<p>A two-sided linear formula describing the fixed effect structure
of the model, with the response to the left of the <code>~</code> operator and
the terms on the right, separated by <code>+</code> operators.</p>
</td></tr>
<tr><td><code id="ssn_lm_+3A_ssn.object">ssn.object</code></td>
<td>
<p>A spatial stream network object with class <code>SSN</code>.</p>
</td></tr>
<tr><td><code id="ssn_lm_+3A_tailup_type">tailup_type</code></td>
<td>
<p>The tailup covariance function type. Available options
include <code>"linear"</code>, <code>"spherical"</code>, <code>"exponential"</code>,
<code>"mariah"</code>, <code>"epa"</code>, and <code>"none"</code>. Parameterizations are
described in Details.</p>
</td></tr>
<tr><td><code id="ssn_lm_+3A_taildown_type">taildown_type</code></td>
<td>
<p>The taildown covariance function type. Available options
include <code>"linear"</code>, <code>"spherical"</code>, <code>"exponential"</code>,
<code>"mariah"</code>, <code>"epa"</code>, and <code>"none"</code>. Parameterizations are
described in Details.</p>
</td></tr>
<tr><td><code id="ssn_lm_+3A_euclid_type">euclid_type</code></td>
<td>
<p>The euclidean covariance function type. Available options
include <code>"spherical"</code>, <code>"exponential"</code>, <code>"gaussian"</code>,
<code>"cosine"</code>, <code>"cubic"</code>, <code>"pentaspherical"</code>, <code>"wave"</code>,
<code>"jbessel"</code>, <code>"gravity"</code>, <code>"rquad"</code>, <code>"magnetic"</code>, and
<code>"none"</code>. Parameterizations are
described in Details.</p>
</td></tr>
<tr><td><code id="ssn_lm_+3A_nugget_type">nugget_type</code></td>
<td>
<p>The nugget covariance function type. Available options
include <code>"nugget"</code> or <code>"none"</code>. Parameterizations are
described in Details.</p>
</td></tr>
<tr><td><code id="ssn_lm_+3A_tailup_initial">tailup_initial</code></td>
<td>
<p>An object from <code><a href="#topic+tailup_initial">tailup_initial()</a></code> specifying initial and/or
known values for the tailup covariance parameters.</p>
</td></tr>
<tr><td><code id="ssn_lm_+3A_taildown_initial">taildown_initial</code></td>
<td>
<p>An object from <code><a href="#topic+taildown_initial">taildown_initial()</a></code> specifying initial and/or
known values for the taildown covariance parameters.</p>
</td></tr>
<tr><td><code id="ssn_lm_+3A_euclid_initial">euclid_initial</code></td>
<td>
<p>An object from <code><a href="#topic+euclid_initial">euclid_initial()</a></code> specifying initial and/or
known values for the euclidean covariance parameters.</p>
</td></tr>
<tr><td><code id="ssn_lm_+3A_nugget_initial">nugget_initial</code></td>
<td>
<p>An object from <code><a href="#topic+nugget_initial">nugget_initial()</a></code> specifying initial and/or
known values for the nugget covariance parameters.</p>
</td></tr>
<tr><td><code id="ssn_lm_+3A_additive">additive</code></td>
<td>
<p>The name of the variable in <code>ssn.object</code> that is used
to define spatial weights. Can be quoted or unquoted. For the tailup covariance functions, these additive
weights are used for branching. Technical details that describe the role
of the additive variable in the tailup covariance function are available
in Ver Hoef and Peterson (2010).</p>
</td></tr>
<tr><td><code id="ssn_lm_+3A_estmethod">estmethod</code></td>
<td>
<p>The estimation method. Available options include
<code>"reml"</code> for restricted maximum likelihood and <code>"ml"</code> for maximum
likelihood. The default is <code>"reml"</code>.</p>
</td></tr>
<tr><td><code id="ssn_lm_+3A_anisotropy">anisotropy</code></td>
<td>
<p>A logical indicating whether (geometric) anisotropy should
be modeled. Not required if <code>spcov_initial</code> is provided with 1) <code>rotate</code>
assumed unknown or assumed known and non-zero or 2) <code>scale</code> assumed unknown
or assumed known and less than one. When <code>anisotropy</code> is <code>TRUE</code>,
computational times can significantly increase. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ssn_lm_+3A_random">random</code></td>
<td>
<p>A one-sided linear formula describing the random effect structure
of the model. Terms are specified to the right of the <code>~ operator</code>.
Each term has the structure <code>x1 + ... + xn | g1/.../gm</code>, where <code>x1 + ... + xn</code>
specifies the model for the random effects and <code>g1/.../gm</code> is the grouping
structure. Separate terms are separated by <code>+</code> and must generally
be wrapped in parentheses. Random intercepts are added to each model
implicitly when at least  one other variable is defined.
If a random intercept is not desired, this must be explicitly
defined (e.g., <code>x1 + ... + xn - 1 | g1/.../gm</code>). If only a random intercept
is desired for a grouping structure, the random intercept must be specified
as <code>1 | g1/.../gm</code>. Note that <code>g1/.../gm</code> is shorthand for <code>(1 | g1/.../gm)</code>.
If only random intercepts are desired and the shorthand notation is used,
parentheses can be omitted.</p>
</td></tr>
<tr><td><code id="ssn_lm_+3A_randcov_initial">randcov_initial</code></td>
<td>
<p>An optional object specifying initial and/or
known values for the random effect variances. See <code><a href="spmodel.html#topic+randcov_initial">spmodel::randcov_initial()</a></code>.</p>
</td></tr>
<tr><td><code id="ssn_lm_+3A_partition_factor">partition_factor</code></td>
<td>
<p>A one-sided linear formula with a single term
specifying the partition factor.  The partition factor assumes observations
from different levels of the partition factor are uncorrelated.</p>
</td></tr>
<tr><td><code id="ssn_lm_+3A_...">...</code></td>
<td>
<p>Other arguments to <code>stats::optim()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The linear model for spatial stream networks can be written as
<code class="reqn">y = X \beta + zu + zd + ze + n</code>, where <code class="reqn">X</code> is the fixed effects design
matrix, <code class="reqn">\beta</code> are the fixed effects, <code class="reqn">zu</code> is tailup random error,
<code class="reqn">zd</code> is taildown random error, and <code class="reqn">ze</code> is Euclidean random error,
and <code class="reqn">n</code> is nugget random error. The tailup random errors capture spatial
covariance moving downstream (and depend on downstream distance), the taildown
random errors capture spatial covariance moving upstream (and depend on upstream)
distance, the Euclidean random errors capture spatial covariance that depends on
Euclidean distance, and the nugget random errors captures variability
independent of spatial locations. The response <code class="reqn">y</code> is modeled using a
spatial covariance function expressed as
<code class="reqn">de(zu) * R(zu) + de(zd) * R(zd) + de(ze) * R(ze) + nugget * I</code>.
<code class="reqn">de(zu)</code>, <code class="reqn">de(zu)</code>, and <code class="reqn">de(zd)</code> represent the tailup, taildown, and Euclidean
variances, respectively. <code class="reqn">R(zu)</code>, <code class="reqn">R(zd)</code>, and <code class="reqn">R(ze)</code> represent the tailup,
taildown, and Euclidean correlation matrices, respectively. Each correlation
matrix depends on a range parameter that controls the distance-decay behavior
of the correlation. <code class="reqn">nugget</code> represents the nugget variance and
<code class="reqn">I</code> represents an identity matrix.
</p>
<p><code>tailup_type</code> Details: Let <code class="reqn">D</code> be a matrix of hydrologic distances,
<code class="reqn">W</code> be a diagonal matrix of weights from <code>additive</code>, <code class="reqn">r = D / range</code>,
and <code class="reqn">I</code> be
an identity matrix. Then parametric forms for flow-connected
elements of <code class="reqn">R(zu)</code> are given below:
</p>

<ul>
<li><p> linear: <code class="reqn">(1 - r) * (r &lt;= 1) * W</code>
</p>
</li>
<li><p> spherical: <code class="reqn">(1 - 1.5r + 0.5r^3) * (r &lt;= 1) * W</code>
</p>
</li>
<li><p> exponential: <code class="reqn">exp(-r) * W</code>
</p>
</li>
<li><p> mariah: <code class="reqn">log(90r + 1) / 90r * (D &gt; 0) + 1 * (D = 0) * W</code>
</p>
</li>
<li><p> epa: <code class="reqn">(D - range)^2 * F * (r &lt;= 1) * W / 16range^5</code>
</p>
</li>
<li><p> none: <code class="reqn">I</code> * W
</p>
</li></ul>

<p>Details describing the <code>F</code> matrix in the <code>epa</code> covariance are given in Garreta et al. (2010).
Flow-unconnected elements of <code class="reqn">R(zu)</code> are assumed uncorrelated.
Observations on different networks are also assumed uncorrelated.
</p>
<p><code>taildown_type</code> Details: Let <code class="reqn">D</code> be a matrix of hydrologic distances,
<code class="reqn">r = D / range</code>,
and <code class="reqn">I</code> be an identity matrix. Then parametric forms for flow-connected
elements of <code class="reqn">R(zd)</code> are given below:
</p>

<ul>
<li><p> linear: <code class="reqn">(1 - r) * (r &lt;= 1)</code>
</p>
</li>
<li><p> spherical: <code class="reqn">(1 - 1.5r + 0.5r^3) * (r &lt;= 1)</code>
</p>
</li>
<li><p> exponential: <code class="reqn">exp(-r)</code>
</p>
</li>
<li><p> mariah: <code class="reqn">log(90r + 1) / 90r * (D &gt; 0) + 1 * (D = 0)</code>
</p>
</li>
<li><p> epa: <code class="reqn">(D - range)^2 * F1 * (r &lt;= 1) / 16range^5</code>
</p>
</li>
<li><p> none: <code class="reqn">I</code>
</p>
</li></ul>

<p>Now let <code class="reqn">A</code> be a matrix that contains the shorter of the two distances
between two sites and the common downstream junction, <code class="reqn">r1 = A / range</code>,
<code class="reqn">B</code> be a matrix that contains the longer of the two distances between two sites and the
common downstream junction, <code class="reqn">r2 = B / range</code>,  and <code class="reqn">I</code> be an identity matrix.
Then parametric forms for flow-unconnected elements of <code class="reqn">R(zd)</code> are given below:
</p>

<ul>
<li><p> linear: <code class="reqn">(1 - r2) * (r2 &lt;= 1)</code>
</p>
</li>
<li><p> spherical: <code class="reqn">(1 - 1.5r1 + 0.5r2) * (1 - r2)^2 * (r2 &lt;= 1)</code>
</p>
</li>
<li><p> exponential: <code class="reqn">exp(-(r1 + r2))</code>
</p>
</li>
<li><p> mariah: <code class="reqn">(log(90r1 + 1) - log(90r2 + 1)) / (90r1 - 90r2) * (A =/ B) + (1 / (90r1 + 1)) * (A = B)</code>
</p>
</li>
<li><p> epa: <code class="reqn">(B - range)^2 * F2 * (r2 &lt;= 1) / 16range^5</code>
</p>
</li>
<li><p> none: <code class="reqn">I</code>
</p>
</li></ul>

<p>Details describing the <code>F1</code> and <code>F2</code> matrices in the <code>epa</code>
covariance are given in Garreta et al. (2010).
Observations on different networks are assumed uncorrelated.
</p>
<p><code>euclid_type</code> Details: Let <code class="reqn">D</code> be a matrix of Euclidean distances,
<code class="reqn">r = D / range</code>, and <code class="reqn">I</code> be an identity matrix. Then parametric
forms for elements of <code class="reqn">R(ze)</code> are given below:
</p>

<ul>
<li><p> exponential: <code class="reqn">exp(- r )</code>
</p>
</li>
<li><p> spherical: <code class="reqn">(1 - 1.5r + 0.5r^3) * (r &lt;= 1)</code>
</p>
</li>
<li><p> gaussian: <code class="reqn">exp(- r^2 )</code>
</p>
</li>
<li><p> cubic: <code class="reqn">(1 - 7r^2 + 8.75r^3 - 3.5r^5 + 0.75r^7) * (r &lt;= 1)</code>
</p>
</li>
<li><p> pentaspherical: <code class="reqn">(1 - 1.875r + 1.25r^3 - 0.375r^5) * (r &lt;= 1)</code>
</p>
</li>
<li><p> cosine: <code class="reqn">cos(r)</code>
</p>
</li>
<li><p> wave: <code class="reqn">sin(r) * (h &gt; 0) / r + (h = 0)</code>
</p>
</li>
<li><p> jbessel: <code class="reqn">Bj(h * range)</code>, Bj is Bessel-J function
</p>
</li>
<li><p> gravity: <code class="reqn">(1 + r^2)^{-0.5}</code>
</p>
</li>
<li><p> rquad: <code class="reqn">(1 + r^2)^{-1}</code>
</p>
</li>
<li><p> magnetic: <code class="reqn">(1 + r^2)^{-1.5}</code>
</p>
</li>
<li><p> none: <code class="reqn">I</code>
</p>
</li></ul>

<p><code>nugget_type</code> Details: Let <code class="reqn">I</code> be an identity matrix and <code class="reqn">0</code>
be the zero matrix. Then parametric
forms for elements the nugget variance are given below:
</p>

<ul>
<li><p> nugget: <code class="reqn">I</code>
</p>
</li>
<li><p> none: <code class="reqn">0</code>
</p>
</li></ul>

<p>In short, the nugget effect is modeled when <code>nugget_type</code> is <code>"nugget"</code>
and omitted when <code>nugget_type</code> is <code>"none"</code>.
</p>
<p><code>estmethod</code> Details: The various estimation methods are
</p>

<ul>
<li> <p><code>reml</code>: Maximize the restricted log-likelihood.
</p>
</li>
<li> <p><code>ml</code>: Maximize the log-likelihood.
</p>
</li></ul>

<p><code>anisotropy</code> Details: By default, all Euclidean covariance parameters except <code>rotate</code>
and <code>scale</code> are assumed unknown, requiring estimation. If either <code>rotate</code> or <code>scale</code>
are given initial values other than 0 and 1 (respectively) or are assumed unknown
in <code><a href="#topic+euclid_initial">euclid_initial()</a></code>, <code>anisotropy</code> is implicitly set to <code>TRUE</code>.
(Geometric) Anisotropy is modeled by transforming a Euclidean covariance function that
decays differently in different directions to one that decays equally in all
directions via rotation and scaling of the original Euclidean coordinates. The rotation is
controlled by the <code>rotate</code> parameter in <code class="reqn">[0, \pi]</code> radians. The scaling
is controlled by the <code>scale</code> parameter in <code class="reqn">[0, 1]</code>. The anisotropy
correction involves first a rotation of the coordinates clockwise by <code>rotate</code> and then a
scaling of the coordinates' minor axis by the reciprocal of <code>scale</code>. The Euclidean
covariance is then computed using these transformed coordinates.
</p>
<p><code>random</code> Details: If random effects are used, the model
can be written as <code class="reqn">y = X \beta + W1\gamma 1 + ... Wj\gamma j + zu + zd + ze + n</code>,
where each Z is a random effects design matrix and each u is a random effect.
</p>
<p><code>partition_factor</code> Details: The partition factor can be represented in matrix form as <code class="reqn">P</code>, where
elements of <code class="reqn">P</code> equal one for observations in the same level of the partition
factor and zero otherwise. The covariance matrix involving only the
spatial and random effects components is then multiplied element-wise
(Hadmard product) by <code class="reqn">P</code>, yielding the final covariance matrix.
</p>
<p>Other Details: Observations with <code>NA</code> response values are removed for model
fitting, but their values can be predicted afterwards by running
<code>predict(object)</code>.
</p>


<h3>Value</h3>

<p>A list with many elements that store information about
the fitted model object and has class <code>ssn_lm</code>. Many generic functions that
summarize model fit are available for <code>ssn_lm</code> objects, including
<code>AIC</code>, <code>AICc</code>, <code>anova</code>, <code>augment</code>, <code>coef</code>,
<code>cooks.distance</code>, <code>covmatrix</code>, <code>deviance</code>, <code>fitted</code>, <code>formula</code>,
<code>glance</code>, <code>glances</code>, <code>hatvalues</code>, <code>influence</code>,
<code>labels</code>, <code>logLik</code>, <code>loocv</code>, <code>model.frame</code>, <code>model.matrix</code>,
<code>plot</code>, <code>predict</code>, <code>print</code>, <code>pseudoR2</code>, <code>summary</code>,
<code>terms</code>, <code>tidy</code>, <code>update</code>, <code>varcomp</code>, and <code>vcov</code>.
</p>
<p>This fitted model list contains the following elements:
</p>

<ul>
<li> <p><code>additive</code>: The name of the additive function value column.
</p>
</li>
<li> <p><code>anisotropy</code>: Whether euclidean anisotropy was modeled.
</p>
</li>
<li> <p><code>call</code>: The function call.
</p>
</li>
<li> <p><code>coefficients</code>: Model coefficients.
</p>
</li>
<li> <p><code>contrasts</code>: Any user-supplied contrasts.
</p>
</li>
<li> <p><code>cooks_distance</code>: Cook's distance values.
</p>
</li>
<li> <p><code>crs</code>: The geographic coordinate reference system.
</p>
</li>
<li> <p><code>deviance</code>: The model deviance.
</p>
</li>
<li> <p><code>diagtol</code>: A tolerance value that may be added to the diagonal
of  ovariance matrices to encourage decomposition stability.
</p>
</li>
<li> <p><code>estmethod</code>: The estimation method.
</p>
</li>
<li> <p><code>euclid_max</code>: The maximum euclidean distance.
</p>
</li>
<li> <p><code>fitted</code>: Fitted values.
</p>
</li>
<li> <p><code>formula</code>: The model formula.
</p>
</li>
<li> <p><code>hatvalues</code>: The hat (leverage) values.
</p>
</li>
<li> <p><code>is_known</code>: An object that identifies which parameters are known.
</p>
</li>
<li> <p><code>local_index</code>: An index identifier used internally for sorting.
</p>
</li>
<li> <p><code>missing_index</code>: Which rows in the &quot;obs&quot; object had missing responses.
</p>
</li>
<li> <p><code>n</code>: The sample size.
</p>
</li>
<li> <p><code>npar</code>: The number of estimated covariance parameters.
</p>
</li>
<li> <p><code>observed_index</code>: Which rows in the &quot;obs&quot; object had observed responses.
</p>
</li>
<li> <p><code>optim</code>: The optimization output.
</p>
</li>
<li> <p><code>p</code>: The number of fixed effects.
</p>
</li>
<li> <p><code>partition_factor</code>: The partition factor formula.
</p>
</li>
<li> <p><code>pseudoR2</code>: The pseudo R-squared.
</p>
</li>
<li> <p><code>random</code>: The random effect formula.
</p>
</li>
<li> <p><code>residuals</code>: The residuals.
</p>
</li>
<li> <p><code>sf_column_name</code>: The name of the geometry columns <code>ssn.object</code>
</p>
</li>
<li> <p><code>ssn.object</code>: An updated <code>ssn.object</code>.
</p>
</li>
<li> <p><code>tail_max</code>: The maximum stream distance.
</p>
</li>
<li> <p><code>terms</code>: The model terms.
</p>
</li>
<li> <p><code>vcov</code>: Variance-covariance matrices
</p>
</li>
<li> <p><code>xlevels</code>: The levels of factors in the model matrix.
</p>
</li></ul>

<p>These list elements are meant to be used with various generic functions
(<code>e.g., residuals()</code> that operate on the model object.
While possible to access elements of the fitted model list directly, we strongly
advise against doing so when there is a generic available to return the element
of interest. For example, we strongly recommend using <code>residuals()</code> to
obtain model residuals instead of accessing the fitted model list directly via
<code>object$residuals</code>.
</p>


<h3>Note</h3>

<p>This function does not perform any internal scaling. If optimization is not
stable due to large extremely large variances, scale relevant variables
so they have variance 1 before optimization.
</p>


<h3>References</h3>

<p>Garreta, V., Monestiez, P. and Ver Hoef, J.M. (2010) Spatial modelling and
prediction on river networks: up model, down model, or hybrid?
<em>Environmetrics</em> <b>21(5)</b>, 439&ndash;456.
</p>
<p>Peterson, E.E. and Ver Hoef, J.M. (2010) A mixed-model moving-average approach
to geostatistical modeling in stream networks. <em>Ecology</em> <b>91(3)</b>,
644&ndash;651.
</p>
<p>Ver Hoef, J.M. and Peterson, E.E. (2010) A moving average approach for spatial
statistical models of stream networks (with discussion).
<em>Journal of the American Statistical Association</em> <b>105</b>, 6&ndash;18.
DOI: 10.1198/jasa.2009.ap08248.  Rejoinder pgs. 22&ndash;24.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
summary(ssn_mod)

</code></pre>

<hr>
<h2 id='ssn_params'>Create covariance parameter objects.</h2><span id='topic+ssn_params'></span><span id='topic+tailup_params'></span><span id='topic+taildown_params'></span><span id='topic+euclid_params'></span><span id='topic+nugget_params'></span>

<h3>Description</h3>

<p>Create a covariance parameter object for us with other functions.
See <code><a href="spmodel.html#topic+randcov_params">spmodel::randcov_params()</a></code> for documentation regarding
random effect covariance parameter objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tailup_params(tailup_type, de, range)

taildown_params(taildown_type, de, range)

euclid_params(euclid_type, de, range, rotate, scale)

nugget_params(nugget_type, nugget)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssn_params_+3A_tailup_type">tailup_type</code></td>
<td>
<p>The tailup covariance function type. Available options
include <code>"linear"</code>, <code>"spherical"</code>, <code>"exponential"</code>,
<code>"mariah"</code>, <code>"epa"</code>, and <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="ssn_params_+3A_de">de</code></td>
<td>
<p>The spatially dependent (correlated) random error variance. Commonly referred to as
a partial sill.</p>
</td></tr>
<tr><td><code id="ssn_params_+3A_range">range</code></td>
<td>
<p>The correlation parameter.</p>
</td></tr>
<tr><td><code id="ssn_params_+3A_taildown_type">taildown_type</code></td>
<td>
<p>The taildown covariance function type. Available options
include <code>"linear"</code>, <code>"spherical"</code>, <code>"exponential"</code>,
<code>"mariah"</code>, <code>"epa"</code>, and <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="ssn_params_+3A_euclid_type">euclid_type</code></td>
<td>
<p>The euclidean covariance function type. Available options
include <code>"spherical"</code>, <code>"exponential"</code>, <code>"gaussian"</code>,
<code>"cosine"</code>, <code>"cubic"</code>, <code>"pentaspherical"</code>, <code>"wave"</code>,
<code>"jbessel"</code>, <code>"gravity"</code>, <code>"rquad"</code>, <code>"magnetic"</code>, and
<code>"none"</code>.</p>
</td></tr>
<tr><td><code id="ssn_params_+3A_rotate">rotate</code></td>
<td>
<p>Anisotropy rotation parameter (from 0 to <code class="reqn">\pi</code> radians) for
the euclidean portion of the covariance. A value of 0 (the default) implies no rotation.</p>
</td></tr>
<tr><td><code id="ssn_params_+3A_scale">scale</code></td>
<td>
<p>Anisotropy scale parameter (from 0 to 1) for
the euclidean portion of the covariance. A value of 1 (the default) implies no scaling.</p>
</td></tr>
<tr><td><code id="ssn_params_+3A_nugget_type">nugget_type</code></td>
<td>
<p>The nugget covariance function type. Available options
include <code>"nugget"</code> or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="ssn_params_+3A_nugget">nugget</code></td>
<td>
<p>The spatially independent (not correlated) random error variance. Commonly referred to as
a nugget.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A parameter object with class that matches the relevant <code>type</code> argument.
</p>


<h3>References</h3>

<p>Peterson, E.E. and Ver Hoef, J.M. (2010) A mixed-model moving-average approach
to geostatistical modeling in stream networks. <em>Ecology</em> <b>91(3)</b>,
644&ndash;651.
</p>
<p>Ver Hoef, J.M. and Peterson, E.E. (2010) A moving average approach for spatial
statistical models of stream networks (with discussion).
<em>Journal of the American Statistical Association</em> <b>105</b>, 6&ndash;18.
DOI: 10.1198/jasa.2009.ap08248.  Rejoinder pgs. 22&ndash;24.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tailup_params("exponential", de = 1, range = 20)
taildown_params("exponential", de = 1, range = 20)
euclid_params("exponential", de = 1, range = 20, rotate = 0, scale = 1)
nugget_params("nugget", nugget = 1)
</code></pre>

<hr>
<h2 id='ssn_put_data'>Put an sf data.frame in an SSN object</h2><span id='topic+ssn_put_data'></span>

<h3>Description</h3>

<p>The <code>ssn_put_data</code> function puts an sf
data.frame representing observation or prediction
data into an SSN, ssn_lm, or ssn_glm object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssn_put_data(data, x, name = "obs", resize_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssn_put_data_+3A_data">data</code></td>
<td>
<p>sf data.frame with point geometry.</p>
</td></tr>
<tr><td><code id="ssn_put_data_+3A_x">x</code></td>
<td>
<p>An object of class SSN, ssn_lm, or ssn_glm.</p>
</td></tr>
<tr><td><code id="ssn_put_data_+3A_name">name</code></td>
<td>
<p>the internal name of the data set in the object
<code>x</code>. For observed data, this will always be &quot;obs&quot;, the
default.</p>
</td></tr>
<tr><td><code id="ssn_put_data_+3A_resize_data">resize_data</code></td>
<td>
<p>Logical. Indicates whether sf_df can have a
different number of features than the current data.frame in the
object. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The internal <code>name</code> for observed data in objects of
class <code>SSN</code>, <code>ssn_lm</code>, and <code>ssn_glm</code> is &quot;obs&quot; and it is the
default. If another <code>name</code> is specified, it must represent a
prediction dataset in the object. For <code>SSN</code> objects,
these names are obtained using the call <code>names(x$preds)</code>. For
all other object classes, the names are obtained using the call
names(x$ssn.object$preds).
</p>
<p>The <code>resize_sf_data</code> argument specifies whether sf_data can have a
different number of features (i.e., rows) than the sf data.frame
it is replacing. Care should be taken when resize_df is set to
TRUE, especially if the new sf_data has more features than the
existing sf data.frame. In these cases, the user is responsible
for ensuring that the additional features have the correct
spatial, topological, and attribute data to accurately represent
spatial relationships in the SSN object.
</p>


<h3>Value</h3>

<p>Returns an object of the same class as x, which contains
the sf data.frame sf_data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssn_get_data">ssn_get_data()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mf04p)
## Extract observation data.frame from SSN object
obs.df &lt;- ssn_get_data(mf04p)
## Create a new column for summer mean temperature and set Value in
obs.df$Value &lt;- obs.df$Summer_mn
obs.df$Value[1] &lt;- NA

## Put the modified sf data.frame into the SSN object
mf04p &lt;- ssn_put_data(obs.df, mf04p)
head(ssn_get_data(mf04p)[, c("Summer_mn", "Value")])
</code></pre>

<hr>
<h2 id='ssn_simulate'>Simulate random variables on a stream network</h2><span id='topic+ssn_simulate'></span><span id='topic+ssn_rbeta'></span><span id='topic+ssn_rbinom'></span><span id='topic+ssn_rgamma'></span><span id='topic+ssn_rinvgauss'></span><span id='topic+ssn_rnbinom'></span><span id='topic+ssn_rnorm'></span><span id='topic+ssn_rpois'></span>

<h3>Description</h3>

<p>Simulate random variables on a stream
network with a specific mean and covariance structure. Designed to use
<code>ssn_simulate()</code>, but individual simulation functions for each
resposne distribution also exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssn_simulate(
  family = "Gaussian",
  ssn.object,
  network = "obs",
  tailup_params,
  taildown_params,
  euclid_params,
  nugget_params,
  additive,
  mean = 0,
  samples = 1,
  dispersion = 1,
  size = 1,
  randcov_params,
  partition_factor,
  ...
)

ssn_rbeta(
  ssn.object,
  network = "obs",
  tailup_params,
  taildown_params,
  euclid_params,
  nugget_params,
  dispersion = 1,
  mean = 0,
  samples = 1,
  additive,
  randcov_params,
  partition_factor,
  ...
)

ssn_rbinom(
  ssn.object,
  network = "obs",
  tailup_params,
  taildown_params,
  euclid_params,
  nugget_params,
  mean = 0,
  size = 1,
  samples = 1,
  additive,
  randcov_params,
  partition_factor,
  ...
)

ssn_rgamma(
  ssn.object,
  network = "obs",
  tailup_params,
  taildown_params,
  euclid_params,
  nugget_params,
  dispersion = 1,
  mean = 0,
  samples = 1,
  additive,
  randcov_params,
  partition_factor,
  ...
)

ssn_rinvgauss(
  ssn.object,
  network = "obs",
  tailup_params,
  taildown_params,
  euclid_params,
  nugget_params,
  dispersion = 1,
  mean = 0,
  samples = 1,
  additive,
  randcov_params,
  partition_factor,
  ...
)

ssn_rnbinom(
  ssn.object,
  network = "obs",
  tailup_params,
  taildown_params,
  euclid_params,
  nugget_params,
  dispersion = 1,
  mean = 0,
  samples = 1,
  additive,
  randcov_params,
  partition_factor,
  ...
)

ssn_rnorm(
  ssn.object,
  network = "obs",
  tailup_params,
  taildown_params,
  euclid_params,
  nugget_params,
  mean = 0,
  samples = 1,
  additive,
  randcov_params,
  partition_factor,
  ...
)

ssn_rpois(
  ssn.object,
  network = "obs",
  tailup_params,
  taildown_params,
  euclid_params,
  nugget_params,
  mean = 0,
  samples = 1,
  additive,
  randcov_params,
  partition_factor,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssn_simulate_+3A_family">family</code></td>
<td>
<p>The response distribution family. The default is <code>"Gaussian"</code>.</p>
</td></tr>
<tr><td><code id="ssn_simulate_+3A_ssn.object">ssn.object</code></td>
<td>
<p>A spatial stream network object with class <code>SSN</code>. Random
variables are simulated for each row of <code>ssn.object$obs</code>.</p>
</td></tr>
<tr><td><code id="ssn_simulate_+3A_network">network</code></td>
<td>
<p>The spatial stream network to simulate on. Currently only
allowed to be <code>"obs"</code> for the <code>ssn.object$obs</code> object.</p>
</td></tr>
<tr><td><code id="ssn_simulate_+3A_tailup_params">tailup_params</code></td>
<td>
<p>An object from <code><a href="#topic+tailup_params">tailup_params()</a></code> specifying
the tailup covariance parameters.</p>
</td></tr>
<tr><td><code id="ssn_simulate_+3A_taildown_params">taildown_params</code></td>
<td>
<p>An object from <code><a href="#topic+taildown_params">taildown_params()</a></code> specifying
the taildown covariance parameters.</p>
</td></tr>
<tr><td><code id="ssn_simulate_+3A_euclid_params">euclid_params</code></td>
<td>
<p>An object from <code><a href="#topic+euclid_params">euclid_params()</a></code> specifying
the Euclidean covariance parameters.</p>
</td></tr>
<tr><td><code id="ssn_simulate_+3A_nugget_params">nugget_params</code></td>
<td>
<p>An object from <code><a href="#topic+nugget_params">nugget_params()</a></code> specifying
the nugget covariance parameters.</p>
</td></tr>
<tr><td><code id="ssn_simulate_+3A_additive">additive</code></td>
<td>
<p>The name of the variable in <code>ssn.object</code> that is used
to define spatial weights. Can be quoted or unquoted. For the tailup covariance functions, these additive
weights are used for branching. Technical details that describe the role
of the additive variable in the tailup covariance function are available
in Ver Hoef and Peterson (2010).</p>
</td></tr>
<tr><td><code id="ssn_simulate_+3A_mean">mean</code></td>
<td>
<p>A numeric vector representing the mean. <code>mean</code> must have length 1
(in which case it is recycled) or length equal
to the number of rows in <code>data</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="ssn_simulate_+3A_samples">samples</code></td>
<td>
<p>The number of independent samples to generate. The default
is <code>1</code>.</p>
</td></tr>
<tr><td><code id="ssn_simulate_+3A_dispersion">dispersion</code></td>
<td>
<p>The dispersion value (if relevant).</p>
</td></tr>
<tr><td><code id="ssn_simulate_+3A_size">size</code></td>
<td>
<p>A numeric vector representing the sample size for each binomial trial.
The default is <code>1</code>, which corresponds to a Bernoulli trial for each observation.</p>
</td></tr>
<tr><td><code id="ssn_simulate_+3A_randcov_params">randcov_params</code></td>
<td>
<p>A <code><a href="spmodel.html#topic+randcov_params">spmodel::randcov_params()</a></code> object.</p>
</td></tr>
<tr><td><code id="ssn_simulate_+3A_partition_factor">partition_factor</code></td>
<td>
<p>A formula indicating the partition factor.</p>
</td></tr>
<tr><td><code id="ssn_simulate_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Random variables are simulated via the product of the covariance matrix's
square (Cholesky) root and independent standard normal random variables
on the link scale, which are then used to simulate a relevant variable on the response scale
according to <code>family</code>.
Computing the square root is a significant
computational burden and likely unfeasible for sample sizes much past 10,000.
Because this square root only needs to be computed once, however, it is
nearly the sample computational cost to call <code>ssn_rnorm()</code> for any value
of <code>samples</code>.
</p>
<p>If not using <code>ssn_simulate()</code>, individual simulation functions for
each response distribution do exist:
</p>

<ul>
<li> <p><code>ssn_rnorm()</code>: Simulate from a Gaussian distribution
</p>
</li>
<li> <p><code>ssn_rpois()</code>: Simulate from a Poisson distribution
</p>
</li>
<li> <p><code>ssn_rnbinom()</code>: Simulate from a negative binomial distribution
</p>
</li>
<li> <p><code>ssn_rbinom()</code>: Simulate from a binomial distribution
</p>
</li>
<li> <p><code>ssn_rbeta()</code>: Simulate from a beta distribution
</p>
</li>
<li> <p><code>ssn_rgamma()</code>: Simulate from a gamma distribution
</p>
</li>
<li> <p><code>ssn_rinvgauss()</code>: Simulate from an inverse Gaussian distribution
</p>
</li></ul>



<h3>Value</h3>

<p>If <code>samples</code> is 1, a vector of random variables for each row of <code>ssn.object$obs</code>
is returned. If <code>samples</code> is greater than one, a matrix of random variables
is returned, where the rows correspond to each row of <code>ssn.object$obs</code> and the columns
correspond to independent samples.
</p>


<h3>References</h3>

<p>Ver Hoef, J.M. and Peterson, E.E. (2010) A moving average approach for spatial
statistical models of stream networks (with discussion).
<em>Journal of the American Statistical Association</em> <b>105</b>, 6&ndash;18.
DOI: 10.1198/jasa.2009.ap08248.  Rejoinder pgs. 22&ndash;24.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

tailup &lt;- tailup_params("exponential", de = 0.1, range = 200)
taildown &lt;- taildown_params("exponential", de = 0.4, range = 300)
euclid &lt;- euclid_params("spherical", de = 0.2, range = 1000, rotate = 0, scale = 1)
nugget &lt;- nugget_params("nugget", nugget = 0.1)
ssn_simulate("gaussian", mf04p, "obs", tailup, taildown, euclid, nugget, additive = "afvArea")

</code></pre>

<hr>
<h2 id='ssn_split_predpts'>Split a prediction dataset in an <code>SSN</code> object</h2><span id='topic+ssn_split_predpts'></span>

<h3>Description</h3>

<p>The <code>splitPrediction</code> function is used to
split prediction sets in an <code>SSN</code> object into smaller
prediction sets. It returns a <code>SSN</code> object with additional
prediction sets based on equal interval splits, a factor,
integer, character or logical column stored within the prediction
set, or a logical expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssn_split_predpts(
  ssn,
  predpts,
  size_predpts,
  by,
  subset,
  id_predpts,
  keep = TRUE,
  drop_levels = FALSE,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssn_split_predpts_+3A_ssn">ssn</code></td>
<td>
<p>An <code>SSN</code> object.</p>
</td></tr>
<tr><td><code id="ssn_split_predpts_+3A_predpts">predpts</code></td>
<td>
<p>A character string representing the name of the
prediction dataset</p>
</td></tr>
<tr><td><code id="ssn_split_predpts_+3A_size_predpts">size_predpts</code></td>
<td>
<p>numeric value representing the size of the new
prediction sets. The existing prediction set is split equally to
produce multiple prediction sets of this size</p>
</td></tr>
<tr><td><code id="ssn_split_predpts_+3A_by">by</code></td>
<td>
<p>character string representing the column name of type
factor, integer, character or logical that the split will be
based on</p>
</td></tr>
<tr><td><code id="ssn_split_predpts_+3A_subset">subset</code></td>
<td>
<p>logical expression indicating which elements or rows
to keep; missing values are taken as <code>FALSE</code></p>
</td></tr>
<tr><td><code id="ssn_split_predpts_+3A_id_predpts">id_predpts</code></td>
<td>
<p>character string representing the new prediction
dataset name. This value is only specified when the subset method is
used</p>
</td></tr>
<tr><td><code id="ssn_split_predpts_+3A_keep">keep</code></td>
<td>
<p>logical value indicating whether the original
prediction dataset should be retained in the <code>SSN</code>
object. Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="ssn_split_predpts_+3A_drop_levels">drop_levels</code></td>
<td>
<p>logical value indicating whether empty factor
levels should be dropped in the <code>by</code> column when the new
prediction dataset(s) are created. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="ssn_split_predpts_+3A_overwrite">overwrite</code></td>
<td>
<p>logical indicating whether the new prediction
dataset shapefile should be deleted in the .ssn directory if it
already exists. Default = <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three methods have been provided to split prediction sets:
<code>size_predpts</code>, <code>by</code>, and <code>subset</code>. The
<code>size_predpts</code> method is used to split the existing prediction
set into multiple equally-sized prediction sets. Note that the
final prediction set may be smaller in size than the others if
the total number of predictions is not evenly divisible by
<code>size_predpts</code>. The <code>by</code> method is used if the prediction
set is to be split into multiple new prediction sets based on an
existing column of type factor, integer, character, or
logical. The <code>subset</code> method is used to create one new
prediction set based on a logical expression.
</p>
<p>When more than one prediction dataset is created the prediction
dataset names will be appended with a hyphen and prediction
dataset number if more than one prediction dataset is
created. For example, when &quot;preds&quot; is split using
<code>size_predpts</code>, the new names will be &quot;preds-1&quot;, &quot;preds-2&quot;, and
so forth.
</p>
<p>When <code>keep=FALSE</code>, the prediction dataset is removed from
the <code>SSN</code> object stored in memory, but is not deleted from
the .ssn directory specified in <code>ssn$path</code>.
</p>
<p>Note that, only one
method may be specified when the <code>ssn_split_predpts</code>
function is called. The distance matrices for the new prediction
datasets must be created using the <code>ssn_create_distmat</code> before
predictions can be made.
</p>


<h3>Value</h3>

<p>returns the <code>SSN</code> specified in <code>ssn</code>, with one or more new prediction
sets. Shapefiles of the new prediction sets are written to the
.ssn directory designated in ssn$path.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Import SSN object
copy_lsn_to_temp() ## Only needed for this example
ssn &lt;- ssn_import(paste0(tempdir(), "/MiddleFork04.ssn"),
  predpts = c("pred1km.shp", "Knapp", "CapeHorn"),
  overwrite = TRUE
)

## Split predictions into size_predpts 200
ssn1 &lt;- ssn_split_predpts(ssn, "CapeHorn",
  size_predpts = 200,
  keep = FALSE, overwrite = TRUE
)
names(ssn1$preds)
nrow(ssn1$preds[["CapeHorn-1"]])

## Split predictions using by method
ssn$preds$pred1km$net.fac &lt;- as.factor(ssn$preds$pred1km$netID)
ssn2 &lt;- ssn_split_predpts(ssn, "pred1km",
  by = "net.fac",
  overwrite = TRUE
)
names(ssn2$preds)

## Split predictions using subset method
ssn3 &lt;- ssn_split_predpts(ssn, "pred1km",
  subset = ratio &gt; 0.5,
  id_predpts = "RATIO_05", overwrite = TRUE
)
names(ssn3$preds)
</code></pre>

<hr>
<h2 id='ssn_subset'>Subset an <code>SSN</code> object</h2><span id='topic+ssn_subset'></span>

<h3>Description</h3>

<p>Returns an <code>SSN</code> object that has been subset based on a
logical expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssn_subset(ssn, path, subset, clip = FALSE, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssn_subset_+3A_ssn">ssn</code></td>
<td>
<p>An <code>SSN</code> object.</p>
</td></tr>
<tr><td><code id="ssn_subset_+3A_path">path</code></td>
<td>
<p>The filepath to the .ssn folder, in string format,
where the subset <code>SSN</code> will be saved.</p>
</td></tr>
<tr><td><code id="ssn_subset_+3A_subset">subset</code></td>
<td>
<p>A logical expression indicating which features to keep.</p>
</td></tr>
<tr><td><code id="ssn_subset_+3A_clip">clip</code></td>
<td>
<p>If <code>TRUE</code>, create a subset of the edges and
prediction sites, based on the same logical expression used to
subset the observed sites.  Default = <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ssn_subset_+3A_overwrite">overwrite</code></td>
<td>
<p>If <code>TRUE</code>, overwrite the folder specified in
<code>path</code> if it exists. Default = FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a subset of the original <code>SSN</code>
object based on a logical expression defined in the <code>subset</code>
argument. The <code>subset</code> argument is treated as an expression
within <code>ssn_subset()</code> and so the full argument is not a
string; although values in factor or character format will still
require quotes (see examples). If <code>clip = TRUE</code>, then the
columns referred to in <code>subset</code> must be present in the edges
and all of the prediction datasets (if present in the <code>SSN</code>
object). Note that features with missing values in the <code>subset</code>
expression are treated as false and are not included in the
subset <code>SSN</code> object.
</p>
<p>Once the subset <code>SSN</code> object has been written to the local
directory, it is re-imported using
<code><a href="#topic+ssn_import">ssn_import</a></code>. During this process, the
binaryID.db is recreated. If distance matrices exist in the
original <code>SSN</code> object, they are not copied or recalculated
for the new <code>SSN</code> object. Users will need to run the
<code><a href="#topic+ssn_create_distmat">ssn_create_distmat</a></code> to create the distance
matrices before fitting models to the data in the subset
<code>SSN</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>SSN</code>, which is stored locally in the .ssn
directory specified in <code>path</code>. It also creates and
stores an SQLite database, binaryID.db, within the .ssn
directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Import SSN object
copy_lsn_to_temp() ## Only needed for this example
mf04p &lt;- ssn_import(paste0(tempdir(), "/MiddleFork04.ssn"),
  predpts = c("pred1km.shp", "Knapp"),
  overwrite = TRUE
)

## Subset SSN observations, edges, and prediction sites on network 1
ssn.sub1 &lt;- ssn_subset(mf04p,
  path = paste0(tempdir(), "/subset1.ssn"),
  subset = netID == 1, clip = TRUE,
  overwrite = TRUE
)

## Subset SSN observations, removing two sites
ssn.sub2 &lt;- ssn_subset(mf04p,
  path = paste0(tempdir(), "/subset2.ssn"),
  subset = !COMID %in% c("23519461", "23519365"),
  overwrite = TRUE
)
</code></pre>

<hr>
<h2 id='SSN_to_SSN2'>Convert object from <code>SpatialStreamNetwork</code> class to <code>SSN</code> class</h2><span id='topic+SSN_to_SSN2'></span>

<h3>Description</h3>

<p>Convert an S4 <code>SpatialStreamNetwork</code> object
created in the SSN package to an S3 <code>SSN</code> object used in the
SSN2 package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSN_to_SSN2(object, edge_additive = NULL, site_additive = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSN_to_SSN2_+3A_object">object</code></td>
<td>
<p>A SpatialStreamNetwork object</p>
</td></tr>
<tr><td><code id="SSN_to_SSN2_+3A_edge_additive">edge_additive</code></td>
<td>
<p>A character vector of additive function value
column names found in edges. Default is NULL. See Details for
more information.</p>
</td></tr>
<tr><td><code id="SSN_to_SSN2_+3A_site_additive">site_additive</code></td>
<td>
<p>A character vector of additive function value
column names found in the observed sites and prediction
sites. See Details for more information. Default is NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>SSN_to_SSN2()</code> has been made available to help users
migrate from the <code>SSN</code> package to the updated <code>SSN2</code>
package. It is used to convert existing S4 <code>SpatialStreamNetwork</code>
objects <em>stored in saved workspaces</em> to the S3 <code>SSN</code> class object
used in the <code>SSN2</code> package. Note that <code><a href="#topic+ssn_import">ssn_import</a></code> is
used to create an S3 <code>SSN</code> object from data stored locally in a .ssn
directory.
</p>
<p>Additive function values are used to generate spatial weights for
the tail-up covariance function used in <code>ssn_glm</code>. The range
of additive function values are restricted to <code class="reqn">0 \le AFV \le
  1</code>. In the <code>SSN2</code> package, columns containing additive
function values are stored as text, rather than numeric
format. This prevents values less than 1 with more than 10 digits
from being truncated when writing/reading shapefiles (and their
.dbf tables). The columns containing additive function values are
specified using the <code>edge_additive</code> and <code>site_additive</code> arguments
and converted to character format in the <code>SSN</code> class object
returned. The arguments <code>edge_additive</code> and <code>site_additive</code>
accept a single column name in character format, or a vector
containing multiple column names. Note that, column names for
additive function values on the edges, sites, and prediction
sites may differ. If a column specified in <code>edge_additive</code> or
<code>site_additive</code> is not present, the function will return a
warning, rather than an error. Columns containing additive
function values can also be converted to text manually using the
<code><a href="base.html#topic+formatC">formatC</a></code> function, which provides the
flexibility needed to store the values with their full precision.
</p>


<h3>Value</h3>

<p>An S3 <code>SSN</code> class object, with additive function value
columns converted to text format.
</p>

<hr>
<h2 id='ssn_update_path'>Update path in an SSN object</h2><span id='topic+ssn_update_path'></span>

<h3>Description</h3>

<p>Update the local path in an existing SSN object based
on an user defined file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssn_update_path(x, path, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssn_update_path_+3A_x">x</code></td>
<td>
<p>An SSN, ssn_lm or ssn_glm object.</p>
</td></tr>
<tr><td><code id="ssn_update_path_+3A_path">path</code></td>
<td>
<p>Filepath to the .ssn folder associated with the SSN
object.</p>
</td></tr>
<tr><td><code id="ssn_update_path_+3A_verbose">verbose</code></td>
<td>
<p>A logical that indicates if the new path should be printed
to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At times, it may be necessary to move a .ssn directory,
which is linked to an SSN object in an R workspace. If the .ssn
directory is moved, the path must be updated before using the
<code>ssn_glmssn</code> function and other functions that read/write
to the .ssn directory. The <code>ssn_update_path</code> is a helper
function that serves this purpose.
</p>


<h3>Value</h3>

<p>An SSN object with a new path list element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use mf04p SSN object provided in SSN2
data(mf04p)

## For examples only, make sure mf04p has the correct path
## If you use ssn_import(), the path will be correct
newpath &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_update_path(mf04p, newpath)
</code></pre>

<hr>
<h2 id='ssn_write'>write an SSN object</h2><span id='topic+ssn_write'></span>

<h3>Description</h3>

<p>This function writes an <code>SSN</code> object to a local
.ssn directory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssn_write(ssn, path, overwrite = FALSE, copy_dist = FALSE, import = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssn_write_+3A_ssn">ssn</code></td>
<td>
<p>An <code>SSN</code> object.</p>
</td></tr>
<tr><td><code id="ssn_write_+3A_path">path</code></td>
<td>
<p>filepath to the local .ssn directory to write to.</p>
</td></tr>
<tr><td><code id="ssn_write_+3A_overwrite">overwrite</code></td>
<td>
<p>If <code>TRUE</code>, overwrite existing files in <code>file</code>
(if it exists). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ssn_write_+3A_copy_dist">copy_dist</code></td>
<td>
<p>If <code>TRUE</code>, copy distance matrices to <code>file</code>
(if they exist). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ssn_write_+3A_import">import</code></td>
<td>
<p>If <code>TRUE</code>, import and return the <code>SSN</code> object
after writing to file. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ssn_write creates an .ssn directory that contains the
spatial, topological, and attribute information stored in the
original <code>SSN</code> object. When <code>import = TRUE</code>, the
<code>SSN</code> object is imported and returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For examples only, copy MiddleFork04.ssn directory to R's
# temporary directory
copy_lsn_to_temp()
## Import SSN object with prediction sites
mf04p &lt;- ssn_import(paste0(tempdir(), "/MiddleFork04.ssn"),
  predpts = c("pred1km.shp"),
  overwrite = TRUE
)

## Write SSN to new .ssn directory
ssn_write(mf04p, path = paste0(tempdir(), "/tempSSN.ssn"))

## Write SSN to .ssn directory and return SSN object
tempSSN &lt;- ssn_write(mf04p, path = paste0(
  tempdir(),
  "/tempSSN.ssn"
), overwrite = TRUE, import = TRUE)
</code></pre>

<hr>
<h2 id='summary.SSN'>Summarize an SSN object</h2><span id='topic+summary.SSN'></span>

<h3>Description</h3>

<p>Summarize data found in an SSN object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SSN'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.SSN_+3A_object">object</code></td>
<td>
<p>An SSN object.</p>
</td></tr>
<tr><td><code id="summary.SSN_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.SSN()</code> creates a summary of a SSN object
intended to be printed using <code>print()</code>. This summary
contains information about the number of observed and prediction
locations, as well as the column names found in their respective
sf data.frames.
</p>


<h3>Value</h3>

<p>A list with several fitted model quantities used to create
informative summaries when printing.
</p>

<hr>
<h2 id='summary.SSN2'>Summarize a fitted model object</h2><span id='topic+summary.SSN2'></span><span id='topic+summary.ssn_lm'></span><span id='topic+summary.ssn_glm'></span>

<h3>Description</h3>

<p>Summarize a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
summary(object, ...)

## S3 method for class 'ssn_glm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.SSN2_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.ssn()</code> creates a summary of a fitted model object
intended to be printed using <code>print()</code>. This summary contains
useful information like the original function call, residuals,
a coefficients table, a pseudo r-squared, and estimated covariance
parameters.
</p>


<h3>Value</h3>

<p>A list with several fitted model quantities used to create
informative summaries when printing.
</p>


<h3>See Also</h3>

<p><a href="#topic+print.SSN2">print.SSN2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
summary(ssn_mod)
</code></pre>

<hr>
<h2 id='tidy.SSN2'>Tidy a fitted model object</h2><span id='topic+tidy.SSN2'></span><span id='topic+tidy.ssn_lm'></span><span id='topic+tidy.ssn_glm'></span>

<h3>Description</h3>

<p>Tidy a fitted model object into a summarized tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
tidy(x, conf.int = FALSE, conf.level = 0.95, effects = "fixed", ...)

## S3 method for class 'ssn_glm'
tidy(x, conf.int = FALSE, conf.level = 0.95, effects = "fixed", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.SSN2_+3A_x">x</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.SSN2_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence interval
in the tidied output. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.SSN2_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval if
<code>conf.int</code> is <code>TRUE</code>. Must be strictly greater than 0 and less than 1.
The default is 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.SSN2_+3A_effects">effects</code></td>
<td>
<p>The type of effects to tidy. Available options are <code>"fixed"</code>
(fixed effects), <code>"tailup"</code> (tailup covariance parameters),
<code>"taildown"</code> (taildown covariance parameters), <code>"euclid"</code> (Euclidean
covariance parameters), <code>"nugget"</code> (nugget covariance parameter),
<code>"dispersion"</code> (dispersion parameter if relevant), <code>"ssn"</code> for all
of <code>"tailup"</code>, <code>"taildown"</code>, <code>"euclid"</code>, <code>"nugget"</code>, and
<code>"dispersion"</code>, and <code>"randcov"</code> (random effect variances). The default is <code>"fixed"</code>.</p>
</td></tr>
<tr><td><code id="tidy.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy tibble of summary information <code>effects</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glance.SSN2">glance.SSN2()</a></code> <code><a href="#topic+augment.SSN2">augment.SSN2()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
tidy(ssn_mod)
</code></pre>

<hr>
<h2 id='Torgegram'>Compute the empirical semivariogram</h2><span id='topic+Torgegram'></span>

<h3>Description</h3>

<p>Compute the empirical semivariogram for varying bin sizes and
cutoff values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Torgegram(
  formula,
  ssn.object,
  type = c("flowcon", "flowuncon"),
  bins = 15,
  cutoff,
  partition_factor
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Torgegram_+3A_formula">formula</code></td>
<td>
<p>A formula describing the fixed effect structure.</p>
</td></tr>
<tr><td><code id="Torgegram_+3A_ssn.object">ssn.object</code></td>
<td>
<p>A spatial stream network object with class <code>SSN</code>.</p>
</td></tr>
<tr><td><code id="Torgegram_+3A_type">type</code></td>
<td>
<p>The Torgegram type. A vector with possible values <code>"flowcon"</code>
for flow-connected distances, <code>"flowuncon"</code> for flow-unconnected distances,
and <code>"euclid"</code> for Euclidean distances. The default is to show both
flow-connected and flow-unconnected distances.</p>
</td></tr>
<tr><td><code id="Torgegram_+3A_bins">bins</code></td>
<td>
<p>The number of equally spaced bins. The default is 15.</p>
</td></tr>
<tr><td><code id="Torgegram_+3A_cutoff">cutoff</code></td>
<td>
<p>The maximum distance considered.
The default is half the diagonal of the bounding box from the coordinates.</p>
</td></tr>
<tr><td><code id="Torgegram_+3A_partition_factor">partition_factor</code></td>
<td>
<p>An optional formula specifying the partition factor.
If specified, semivariances are only computed for observations sharing the
same level of the partition factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Torgegram is an empirical semivariogram is a tool used to visualize and model
spatial dependence by estimating the semivariance of a process at varying distances
separately for flow-connected, flow-unconnected, and Euclidean distances.
For a constant-mean process, the
semivariance at distance <code class="reqn">h</code> is denoted <code class="reqn">\gamma(h)</code> and defined as
<code class="reqn">0.5 * Var(z1  - z2)</code>. Under second-order stationarity,
<code class="reqn">\gamma(h) = Cov(0) - Cov(h)</code>, where <code class="reqn">Cov(h)</code> is the covariance function
at distance <code>h</code>. Typically the residuals from an ordinary
least squares fit defined by <code>formula</code> are second-order stationary with
mean zero. These residuals are used to compute the empirical semivariogram.
At a distance <code>h</code>, the empirical semivariance is
<code class="reqn">1/N(h) \sum (r1 - r2)^2</code>, where <code class="reqn">N(h)</code> is the number of (unique)
pairs in the set of observations whose distance separation is <code>h</code> and
<code>r1</code> and <code>r2</code> are residuals corresponding to observations whose
distance separation is <code>h</code>. In spmodel, these distance bins actually
contain observations whose distance separation is <code>h +- c</code>,
where <code>c</code> is a constant determined implicitly by <code>bins</code>. Typically,
only observations whose distance separation is below some cutoff are used
to compute the empirical semivariogram (this cutoff is determined by <code>cutoff</code>).
</p>


<h3>Value</h3>

<p>A list with elements correspond to <code>type</code>. Each element
is data frame with distance bins (<code>bins</code>), the  average distance
(<code>dist</code>), the semivariance (<code>gamma</code>), and the
number of (unique) pairs (<code>np</code>) for the respective <code>type</code>.
</p>


<h3>References</h3>

<p>Zimmerman, D. L., &amp; Ver Hoef, J. M. (2017). The Torgegram for fluvial
variography: characterizing spatial dependence on stream networks.
<em>Journal of Computational and Graphical Statistics</em>,
<b>26(2)</b>, 253&ndash;264.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.Torgegram">plot.Torgegram()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

tg &lt;- Torgegram(Summer_mn ~ 1, mf04p)
plot(tg)
</code></pre>

<hr>
<h2 id='varcomp.SSN2'>Variability component comparison</h2><span id='topic+varcomp.SSN2'></span><span id='topic+varcomp.ssn_lm'></span><span id='topic+varcomp.ssn_glm'></span>

<h3>Description</h3>

<p>Compare the proportion of total variability explained by the fixed effects
and each variance parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
varcomp(object, ...)

## S3 method for class 'ssn_glm'
varcomp(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varcomp.SSN2_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="varcomp.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble that partitions the the total variability by the fixed effects
and each variance parameter. The proportion of variability explained by the
fixed effects is the pseudo R-squared obtained by <code>psuedoR2()</code>. The
remaining proportion is spread accordingly among each variance parameter:
<code>"tailup_de"</code>, <code>"taildown_de"</code>, <code>"euclid_de"</code>, <code>"nugget"</code>,
and if random effects are used, each named random effect. For <code>ssn_glm()</code>,
models, only the variances on the link scale are considered (i.e., the variance
function of the response is omitted).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
varcomp(ssn_mod)
</code></pre>

<hr>
<h2 id='vcov.SSN2'>Calculate variance-covariance matrix for a fitted model object</h2><span id='topic+vcov.SSN2'></span><span id='topic+vcov.ssn_lm'></span><span id='topic+vcov.ssn_glm'></span>

<h3>Description</h3>

<p>Calculate variance-covariance matrix for a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssn_lm'
vcov(object, ...)

## S3 method for class 'ssn_glm'
vcov(object, var_correct = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.SSN2_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+ssn_lm">ssn_lm()</a></code> or <code><a href="#topic+ssn_glm">ssn_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="vcov.SSN2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
<tr><td><code id="vcov.SSN2_+3A_var_correct">var_correct</code></td>
<td>
<p>A logical indicating whether to return the corrected variance-covariance
matrix for models fit using <code><a href="#topic+ssn_glm">ssn_glm()</a></code> (when <code>family</code> is different
from <code>"Gaussian"</code>). The default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The variance-covariance matrix of coefficients obtained via <code>coef()</code>.
Currently, only the variance-covariance matrix of the fixed effects is supported.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
vcov(ssn_mod)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
