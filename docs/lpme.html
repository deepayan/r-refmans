<!DOCTYPE html><html><head><title>Help for package lpme</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lpme}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#densityreg'><p>Conditional Density Estimation with Covariate Measurement Error</p></a></li>
<li><a href='#densityregbw'><p>Bandwidth Selector for Conditional Density Estimation with Covariate Measurement Error</p></a></li>
<li><a href='#meanreg'><p>Local Polynomial Estimators for Nonparametric Mean Regression</p></a></li>
<li><a href='#meanregbwSIMEX'><p>Cross-Validation Bandwidth Selector Using SIMEX for Nonparametric Mean Regression</p></a></li>
<li><a href='#modereg'><p>Nonparametric Estimators for Nonparametric Mode Regression</p></a></li>
<li><a href='#moderegbw'><p>Cross-Validation Bandwidth Selector for Nonparametric Mode Regression</p></a></li>
<li><a href='#moderegbwSIMEX'><p>Cross-Validation Bandwidth Selector Using SIMEX for Nonparametric Mode Regression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonparametric Estimation of Measurement Error Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-09</td>
</tr>
<tr>
<td>Description:</td>
<td>Provide nonparametric methods for mean regression model, modal regression and conditional density estimation in the presence/absence of measurement error. Bandwidth selection is also provided for each method. See Huang and Zhou (2017) &lt;<a href="https://doi.org/10.1080%2F10485252.2017.1303060">doi:10.1080/10485252.2017.1303060</a>&gt;, Zhou and Huang (2016) &lt;<a href="https://doi.org/10.1214%2F16-EJS1210">doi:10.1214/16-EJS1210</a>&gt;, Huang and Zhou (2020) &lt;<a href="https://doi.org/10.1214%2F20-EJS1688">doi:10.1214/20-EJS1688</a>&gt;, and Zhou and Huang (2019) &lt;<a href="https://doi.org/10.1080%2F03610918.2017.1402044">doi:10.1080/03610918.2017.1402044</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.1), decon, flexmix, splines, locpol</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.4.300.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-09 18:07:56 UTC; Haiming</td>
</tr>
<tr>
<td>Author:</td>
<td>Haiming Zhou [aut, cre, cph],
  Xianzheng Huang [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Haiming Zhou &lt;haiming2019@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-09 22:00:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='densityreg'>Conditional Density Estimation with Covariate Measurement Error</h2><span id='topic+densityreg'></span>

<h3>Description</h3>

<p>This function provides nonparametric estimators (Huang and Zhou, 2020) for the density of a response conditioning on an error-prone covariate. The corresponding estimators in the absence of measurement error are also provided. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densityreg(Y, W, bw, xgrid=NULL, ygrid = NULL, sig=NULL, K1 = "Gauss", 
           K2 = "Gauss", mean.estimate = NULL, spline.df = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityreg_+3A_y">Y</code></td>
<td>
<p>         an n by 1 response vector. </p>
</td></tr>
<tr><td><code id="densityreg_+3A_w">W</code></td>
<td>
<p>         an n by 1 predictor vector.</p>
</td></tr> 
<tr><td><code id="densityreg_+3A_bw">bw</code></td>
<td>
<p>        bandwidth.</p>
</td></tr> 
<tr><td><code id="densityreg_+3A_xgrid">xgrid</code></td>
<td>
<p>     the grid values in x-axis to estimate the conditional density.</p>
</td></tr>
<tr><td><code id="densityreg_+3A_ygrid">ygrid</code></td>
<td>
<p>     the grid values in y-axis to estimate the conditional density.</p>
</td></tr>
<tr><td><code id="densityreg_+3A_sig">sig</code></td>
<td>
<p>      standard deviation of the measurement error; <code>sig=NULL</code> returns the naive estimators ignoring measurement error.</p>
</td></tr> 
<tr><td><code id="densityreg_+3A_k1">K1</code></td>
<td>
<p>      kernel function for X; choices include <code>"Gauss"</code> and <code>SecOrder</code>.</p>
</td></tr> 
<tr><td><code id="densityreg_+3A_k2">K2</code></td>
<td>
<p>      kernel function for Y; choices include <code>"Gauss"</code> and <code>SecOrder</code>.</p>
</td></tr> 
<tr><td><code id="densityreg_+3A_mean.estimate">mean.estimate</code></td>
<td>
<p>    method to estimate the naive mean function of Y given X; choices include <code>"spline"</code> and <code>"kernel"</code>. If <code>NULL</code>, the methods 1 and 3 in the reference below are considered.</p>
</td></tr>
<tr><td><code id="densityreg_+3A_spline.df">spline.df</code></td>
<td>
<p>   the degrees of freedom for B-splines when <code>mean.estimate="spline"</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The results include the grid points <code>xgrid</code> for X and <code>ygrid</code> for Y, the fitted density values <code>fitxy</code>.
</p>


<h3>Author(s)</h3>

<p>Haiming Zhou and Xianzheng Huang
</p>


<h3>References</h3>

<p>Huang, X. and Zhou, H. (2020). Conditional density estimation with covariate measurement error. <em>Electronic Journal of Statistics</em>, 14(1): 970-1023.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+densityregbw">densityregbw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################
## X - True covariates
## W - Observed covariates
## Y - individual response
library(lpme)
## generate laplace
rlap=function (use.n, location = 0, scale = 1) 
{
  location &lt;- rep(location, length.out = use.n)
  scale &lt;- rep(scale, length.out = use.n)
  rrrr &lt;- runif(use.n)
  location - sign(rrrr - 0.5) * scale * (log(2) + ifelse(rrrr &lt; 0.5, log(rrrr), log1p(-rrrr)))
}
## sample size:
n =100;
## Function f(y|x) to estimate#
mofx = function(x){ x }
sofx = function(x){ 0.5 } 
fy_x=function(y,x) dnorm(y, mofx(x), sofx(x));
## Generate data
sigma_x = 1; X = rnorm(n, 0, sigma_x); 
## Sample Y
Y = rep(0, n);
for(i in 1:n){
  Y[i] = mofx(X[i]) + rnorm(1, 0, sofx(X[i]));
}

## reliability ratio
lambda=0.7;
sigma_u  = sqrt(1/lambda-1)*sigma_x;
#W=X+rnorm(n,0,sigma_u);
W=X+rlap(n,0,sigma_u/sqrt(2));

##----- naive kernel density estimate  ---- 
fitbw = densityregbw(Y, W, K1 = "Gauss", K2 = "Gauss")
fhat1 = densityreg(Y, W, bw=fitbw$bw, K1 = "Gauss", K2 = "Gauss");

###----- naive kernel density estimate with mean adjustment  ---- 
#fitbw = densityregbw(Y, W, K1 = "Gauss", K2 = "Gauss", 
#                     mean.estimate = "kernel")
#fhat2 = densityreg(Y, W, bw=fitbw$bw, K1 = "Gauss", K2 = "Gauss", 
#                   mean.estimate = "kernel");

##----- proposed method without mean adjustment  ---- 
fitbw = densityregbw(Y, W, sig=sigma_u, K1="SecOrder", K2="Gauss")
fhat3 = densityreg(Y, W, bw=fitbw$bw, sig=sigma_u, K1="SecOrder", K2="Gauss");

##----- proposed method wit mean adjustment  ---- 
#fitbw = densityregbw(Y, W, sig=sigma_u, K1="SecOrder", K2="SecOrder", 
#                     mean.estimate = "kernel")
#fhat4 = densityreg(Y, W, bw=fitbw$bw, sig=sigma_u, K1="SecOrder", K2="SecOrder", 
#                   mean.estimate = "kernel");

par(mfrow=c(2,2))
plot(W,Y, col=2)
points(X,Y)
x0 = seq(0, 1, length.out = 3)
for(i in 1:length(x0)){
  plot(fhat1$ygrid, fy_x(fhat1$ygrid, x0[i]), "l", lwd="2", xlab = "y", ylab = "density",
       main = paste("Conditional density at x=", x0[i], sep=""), ylim=c(0,1.5));
  indx = which.min(abs(fhat1$xgrid-x0[i])) ## the index of xgrid that is closest to x0[i].
  lines(fhat1$ygrid, fhat1$fitxy[indx,], lwd=3, lty=2, col=1)
  #lines(fhat2$ygrid, fhat2$fitxy[indx,], lwd=3, lty=2, col=2)
  lines(fhat3$ygrid, fhat3$fitxy[indx,], lwd=3, lty=2, col=3)
  #lines(fhat4$ygrid, fhat4$fitxy[indx,], lwd=3, lty=2, col=4)
}

</code></pre>

<hr>
<h2 id='densityregbw'>Bandwidth Selector for Conditional Density Estimation with Covariate Measurement Error</h2><span id='topic+densityregbw'></span>

<h3>Description</h3>

<p>This function selects the bandwidth for the nonparametric estimators (Huang and Zhou, 2020) for the density of a response conditioning on an error-prone covariate. The corresponding methods in the absence of measurement error are also provided. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densityregbw(Y, W, h1=NULL, h2=NULL, sig = NULL,
             xinterval = quantile(W, probs=c(0.025, 0.975), names = FALSE),
             K1 = "Gauss", K2 = "Gauss", mean.estimate = NULL, spline.df = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityregbw_+3A_y">Y</code></td>
<td>
<p>         an n by 1 response vector. </p>
</td></tr>
<tr><td><code id="densityregbw_+3A_w">W</code></td>
<td>
<p>         an n by 1 predictor vector.</p>
</td></tr> 
<tr><td><code id="densityregbw_+3A_h1">h1</code></td>
<td>
<p>       bandwidth vector for h1; default is <code>NULL</code>, and h1 is chosen automatically. See the reference below for details. It is recommended to carefully specify a fine grid for h1. </p>
</td></tr>
<tr><td><code id="densityregbw_+3A_h2">h2</code></td>
<td>
<p>      bandwidth vector for h2; default is <code>NULL</code>, and h2 is chosen automatically. See the reference below for details. It is recommended to carefully specify a fine grid for h2.</p>
</td></tr>
<tr><td><code id="densityregbw_+3A_sig">sig</code></td>
<td>
<p>      standard deviation of the measurement error; <code>sig=NULL</code> returns the naive estimators ignoring measurement error.</p>
</td></tr> 
<tr><td><code id="densityregbw_+3A_xinterval">xinterval</code></td>
<td>
<p> the interval within which the modes will be estimated.</p>
</td></tr>
<tr><td><code id="densityregbw_+3A_k1">K1</code></td>
<td>
<p>      kernel function for X; choices include <code>"Gauss"</code> and <code>SecOrder</code>.</p>
</td></tr> 
<tr><td><code id="densityregbw_+3A_k2">K2</code></td>
<td>
<p>      kernel function for Y; choices include <code>"Gauss"</code> and <code>SecOrder</code>.</p>
</td></tr> 
<tr><td><code id="densityregbw_+3A_mean.estimate">mean.estimate</code></td>
<td>
<p>    method to estimate the naive mean function of Y given X; choices include <code>"spline"</code> and <code>"kernel"</code>. If <code>NULL</code>, the methods 1 and 3 in the reference below are considered.</p>
</td></tr>
<tr><td><code id="densityregbw_+3A_spline.df">spline.df</code></td>
<td>
<p>   the degrees of freedom for B-splines when <code>mean.estimate="spline"</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The results include the bandwidth <code>bw</code>, grid values for h1 and grid values for h2.
</p>


<h3>Author(s)</h3>

<p>Haiming Zhou and Xianzheng Huang
</p>


<h3>References</h3>

<p>Huang, X. and Zhou, H. (2020). Conditional density estimation with covariate measurement error. <em>Electronic Journal of Statistics</em>, 14(1): 970-1023.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+densityreg">densityreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################
## X - True covariates
## W - Observed covariates
## Y - individual response
library(lpme)
## generate laplace
rlap=function (use.n, location = 0, scale = 1) 
{
  location &lt;- rep(location, length.out = use.n)
  scale &lt;- rep(scale, length.out = use.n)
  rrrr &lt;- runif(use.n)
  location - sign(rrrr - 0.5) * scale * (log(2) + ifelse(rrrr &lt; 0.5, log(rrrr), log1p(-rrrr)))
}
## sample size:
n =100;
## Function f(y|x) to estimate#
mofx = function(x){ x }
sofx = function(x){ 0.5 } 
fy_x=function(y,x) dnorm(y, mofx(x), sofx(x));
## Generate data
sigma_x = 1; X = rnorm(n, 0, sigma_x); 
## Sample Y
Y = rep(0, n);
for(i in 1:n){
  Y[i] = mofx(X[i]) + rnorm(1, 0, sofx(X[i]));
}

## reliability ratio
lambda=0.7;
sigma_u  = sqrt(1/lambda-1)*sigma_x;
#W=X+rnorm(n,0,sigma_u);
W=X+rlap(n,0,sigma_u/sqrt(2));

##----- naive kernel density estimate  ---- 
fitbw = densityregbw(Y, W, K1 = "Gauss", K2 = "Gauss")
fhat1 = densityreg(Y, W, bw=fitbw$bw, K1 = "Gauss", K2 = "Gauss");

###----- naive kernel density estimate with mean adjustment  ---- 
#fitbw = densityregbw(Y, W, K1 = "Gauss", K2 = "Gauss", 
#                     mean.estimate = "kernel")
#fhat2 = densityreg(Y, W, bw=fitbw$bw, K1 = "Gauss", K2 = "Gauss", 
#                   mean.estimate = "kernel");

##----- proposed method without mean adjustment  ---- 
fitbw = densityregbw(Y, W, sig=sigma_u, K1="SecOrder", K2="Gauss")
fhat3 = densityreg(Y, W, bw=fitbw$bw, sig=sigma_u, K1="SecOrder", K2="Gauss");

##----- proposed method wit mean adjustment  ---- 
#fitbw = densityregbw(Y, W, sig=sigma_u, K1="SecOrder", K2="SecOrder", 
#                     mean.estimate = "kernel")
#fhat4 = densityreg(Y, W, bw=fitbw$bw, sig=sigma_u, K1="SecOrder", K2="SecOrder", 
#                   mean.estimate = "kernel");

par(mfrow=c(2,2))
plot(W,Y, col=2)
points(X,Y)
x0 = seq(0, 1, length.out = 3)
for(i in 1:length(x0)){
  plot(fhat1$ygrid, fy_x(fhat1$ygrid, x0[i]), "l", lwd="2", xlab = "y", ylab = "density",
       main = paste("Conditional density at x=", x0[i], sep=""), ylim=c(0,1.5));
  indx = which.min(abs(fhat1$xgrid-x0[i])) ## the index of xgrid that is closest to x0[i].
  lines(fhat1$ygrid, fhat1$fitxy[indx,], lwd=3, lty=2, col=1)
  #lines(fhat2$ygrid, fhat2$fitxy[indx,], lwd=3, lty=2, col=2)
  lines(fhat3$ygrid, fhat3$fitxy[indx,], lwd=3, lty=2, col=3)
  #lines(fhat4$ygrid, fhat4$fitxy[indx,], lwd=3, lty=2, col=4)
}

</code></pre>

<hr>
<h2 id='meanreg'>Local Polynomial Estimators for Nonparametric Mean Regression</h2><span id='topic+meanreg'></span>

<h3>Description</h3>

<p>This function provides both the DFC (Delaigle, Fan, and Carroll, 2009) and HZ (Huang and Zhou, 2017) local linear estimators for solving the errors-in-variables problem. The local linear estimator in the absence of measurement error is also provided. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanreg(Y, W, bw, xgrid=NULL, method="HZ", sig=NULL, error="laplace", FT_fu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanreg_+3A_y">Y</code></td>
<td>
<p>         an n by 1 response vector. </p>
</td></tr>
<tr><td><code id="meanreg_+3A_w">W</code></td>
<td>
<p>         an n by 1 predictor vector.</p>
</td></tr> 
<tr><td><code id="meanreg_+3A_bw">bw</code></td>
<td>
<p>         bandwidth.</p>
</td></tr> 
<tr><td><code id="meanreg_+3A_xgrid">xgrid</code></td>
<td>
<p> the grid values to estimate the responses.</p>
</td></tr>
<tr><td><code id="meanreg_+3A_method">method</code></td>
<td>
<p>   the method to be used; <code>method="HZ"</code> returns the estimator proposed by Huang and Zhou (2017); <code>method="DFC"</code> returns the estimator proposed by Delaigle, Fan, and Carroll (2009); <code>method="naive"</code> returns the local linear estimator ignoring measurement error.</p>
</td></tr>
<tr><td><code id="meanreg_+3A_sig">sig</code></td>
<td>
<p>      standard deviation of the measurement error; <code>sig=NULL</code> returns the naive estimators ignoring measurement error.</p>
</td></tr>   
<tr><td><code id="meanreg_+3A_error">error</code></td>
<td>
<p>    the distribution assumed for the measurement error; <code>error="laplace"</code> is for Laplace distribution; <code>error="normal"</code> is for Gaussian distribution; <code>error="user"</code> is for user-assumed distribution.</p>
</td></tr> 
<tr><td><code id="meanreg_+3A_ft_fu">FT_fu</code></td>
<td>
<p>    a function for the Fourier transform of density of error, which is required only when <code>error="user"</code>.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>The results include the grid points <code>xgrid</code> for predictor and corresponding fitted responses <code>yhat</code>.
</p>


<h3>Author(s)</h3>

<p>Haiming Zhou and Xianzheng Huang
</p>


<h3>References</h3>

<p>Huang, X. and Zhou, H. (2017). An alternative local polynomial estimator for the error-in-variables problem. <em>Journal of Nonparametric Statistics</em>, 29: 301-325.
</p>
<p>Delaigle, A., Fan, J., and Carroll, R. (2009). A design-adaptive local polynomial estimator for the errors-in-variables problem. <em>Journal of the American Statistical Association</em>, 104: 348-359.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meanregbwSIMEX">meanregbwSIMEX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################
## X - True covariates
## W - Observed covariates
## Y - individual response
library(lpme)

## sample size:
n =100;
## Function gofx(x) to estimate
gofx  = function(x){ 1/4*x + x^2/4 }
xgrid = seq(-2, 2, 0.02)

## Generate data
sigma_e  = 0.5;
sigma_x = 1; X = rnorm(n, 0, sigma_x); 
## Sample Y
Y  = gofx(X) + rnorm(n, 0, sigma_e);
##------------------  method Based on X ---------------------------
ghat_X= meanreg(Y, X, 0.1, method="naive", xgrid=xgrid);

## reliability ratio
lambda=0.85;
sigma_u  = sqrt(1/lambda-1)*sigma_x;
print( sigma_x^2/(sigma_x^2 + sigma_u^2) );
W=X+rnorm(n,0,sigma_u);
#W=X+rlaplace(n,0,sigma_u/sqrt(2));
  
##------------------  method Based on W ---------------------------
ghat_W=meanreg(Y, W, 0.1, method="naive", xgrid=xgrid);

##------------------ JASA method -------------------------------------
h = 0.13; 
ghat_JASA=meanreg(Y, W, h, method="DFC", sig=sigma_u, 
                  error="laplace", xgrid=xgrid);

##------------------ Our method -------------------------
ghat_NEW=meanreg(Y, W, h, method="HZ", sig=sigma_u, 
                 error="laplace", xgrid=xgrid);

## plots
plot(xgrid, gofx(xgrid), "l", main="Individual", lwd="2")
lines(xgrid, ghat_NEW$yhat, lty="dashed", col="2",lwd="3")
lines(xgrid, ghat_JASA$yhat, lty="dotted", col="3",lwd="3")
lines(xgrid, ghat_X$yhat, lty="dashed", col="4",lwd="2")
lines(xgrid, ghat_W$yhat, lty="dashed", col="5",lwd="3")
</code></pre>

<hr>
<h2 id='meanregbwSIMEX'>Cross-Validation Bandwidth Selector Using SIMEX for Nonparametric Mean Regression</h2><span id='topic+meanregbwSIMEX'></span>

<h3>Description</h3>

<p>This function selects the bandwidth for both the DFC (Delaigle, Fan, and Carroll, 2009) and HZ (Huang and Zhou, 2017) estimators. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanregbwSIMEX(Y, W, method="HZ", sig, error="laplace", k_fold=5, B=10,
               h1=NULL, h2=NULL, length.h=10, lconst=0.5, rconst=2, Wdiff=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanregbwSIMEX_+3A_y">Y</code></td>
<td>
<p>         an n by 1 response vector. </p>
</td></tr>
<tr><td><code id="meanregbwSIMEX_+3A_w">W</code></td>
<td>
<p>         an n by 1 predictor vector.</p>
</td></tr> 
<tr><td><code id="meanregbwSIMEX_+3A_method">method</code></td>
<td>
<p>   the method to be used; <code>method="HZ"</code> uses the estimator proposed by Huang and Zhou (2017); <code>method="DFC"</code> uses the estimator proposed by Delaigle, Fan, and Carroll (2009). It currently does not support bandwidth selection for naive estimators.</p>
</td></tr>
<tr><td><code id="meanregbwSIMEX_+3A_sig">sig</code></td>
<td>
<p>      standard deviation of the measurement error.</p>
</td></tr>   
<tr><td><code id="meanregbwSIMEX_+3A_error">error</code></td>
<td>
<p>    the distribution assumed for the measurement error; <code>error="laplace"</code> is for Laplace distribution; <code>error="normal"</code> is for Gaussian distribution. It currently does not support user-assumed distribution.</p>
</td></tr> 
<tr><td><code id="meanregbwSIMEX_+3A_k_fold">k_fold</code></td>
<td>
<p>   gives fold of cross-validation to be used; default is 2.</p>
</td></tr>
<tr><td><code id="meanregbwSIMEX_+3A_b">B</code></td>
<td>
<p>        total number of cross-validation criteria to average over; defualt is 10.</p>
</td></tr>
<tr><td><code id="meanregbwSIMEX_+3A_h1">h1</code></td>
<td>
<p>       bandwidth vector for the first level error contamination; default is <code>NULL</code>, and h1 is chosen automatically. See Huang and Zhou (2017) for details. </p>
</td></tr>
<tr><td><code id="meanregbwSIMEX_+3A_h2">h2</code></td>
<td>
<p>      bandwidth vector for the second level error contamination; defualt is <code>NULL</code>, and h2 is chosen automatically. See Huang and Zhou (2017) for details.</p>
</td></tr>
<tr><td><code id="meanregbwSIMEX_+3A_length.h">length.h</code></td>
<td>
<p> number of grid points for each of h1 and h2; default is 10.</p>
</td></tr>
<tr><td><code id="meanregbwSIMEX_+3A_lconst">lconst</code>, <code id="meanregbwSIMEX_+3A_rconst">rconst</code></td>
<td>
<p> used to control the searching windows for bandwidths h1 and h2. For example, <code>seq(bw1*lconst,bw1*rconst,length.out=length.h)</code> is used to obtain bandwidth grid points for h1, where bw1 is an initial bandwidth; see Huang and Zhou (2017) for details of finding the initial bandwith.</p>
</td></tr>
<tr><td><code id="meanregbwSIMEX_+3A_wdiff">Wdiff</code></td>
<td>
<p>    an n by 1 vector of <code>(W1-W2)/2</code>, where W1, W2 are two replicated measurements; default is <code>NULL</code>, which indicates that the errors are generated from the assumed error distribution, otherwise, the errors are generated from Wdiff with replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The results include the bandwidth <code>bw</code>.
</p>


<h3>Author(s)</h3>

<p>Haiming Zhou and Xianzheng Huang
</p>


<h3>References</h3>

<p>Huang, X. and Zhou, H. (2017). An alternative local polynomial estimator for the error-in-variables problem. <em>Journal of Nonparametric Statistics</em>, 29: 301-325.
</p>
<p>Delaigle, A. and Hall, P. (2008). Using SIMEX for smoothing-parameter choice in errors-in-variables problems. <em>Journal of the American Statistical Association</em>, 103: 280-287.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meanreg">meanreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################
## X - True covariates
## W - Observed covariates
## Y - individual response
library(lpme)
## generate laplace
rlap=function (use.n, location = 0, scale = 1) 
{
location &lt;- rep(location, length.out = use.n)
scale &lt;- rep(scale, length.out = use.n)
rrrr &lt;- runif(use.n)
location-sign(rrrr-0.5)*scale*(log(2)+ifelse(rrrr&lt;0.5, log(rrrr), log1p(-rrrr)))
}

## sample size:
n =100;
## Function gofx(x) to estimate
gofx  = function(x){ 2*x*exp(-10*x^4/81) }

## Generate data
sigma_e  = 0.2;
sigma_x = 1; X = rnorm(n, 0, sigma_x); 
## Sample Y
Y  = gofx(X) + rnorm(n, 0, sigma_e);
## reliability ratio
lambda=0.85;
sigma_u  = sqrt(1/lambda-1)*sigma_x;
print( sigma_x^2/(sigma_x^2 + sigma_u^2) );
#W=X+rnorm(n,0,sigma_u);
W=X+rlap(n,0,sigma_u/sqrt(2));
  
#### SIMEX
#**Note: larger values for B and length.h are needed for accurate estimates.
#**e.g., k_fold=5, B=10, length.h=10 will be generally good. 
hwNEW = meanregbwSIMEX(Y, W, method="HZ", sig=sigma_u, error="laplace", k_fold=2, 
                        B=1, length.h=1)$bw
ghat_NEW = meanreg(Y, W, hwNEW , method="HZ", sig=sigma_u, error="laplace");

## plots
x = ghat_NEW$xgrid;
plot(x, gofx(x), "l", main="Individual", lwd="2")
lines(ghat_NEW$xgrid, ghat_NEW$yhat, lty="dashed", col="2",lwd="3")
</code></pre>

<hr>
<h2 id='modereg'>Nonparametric Estimators for Nonparametric Mode Regression</h2><span id='topic+modereg'></span>

<h3>Description</h3>

<p>This function provides the nonparametric estimators (Zhou and Huang, 2016; Zhou and Huang, 2019) for nonparametric modal regression. The corresponding estimators in the absence of measurement error are also provided. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modereg(Y, W, bw, xgrid=NULL, sig=NULL, nstart=4, p.order=0, maxiter = 500, 
        tol=.Machine$double.eps^0.25, mesh=NULL, PLOT=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modereg_+3A_y">Y</code></td>
<td>
<p>         an n by 1 response vector. </p>
</td></tr>
<tr><td><code id="modereg_+3A_w">W</code></td>
<td>
<p>         an n by 1 predictor vector.</p>
</td></tr> 
<tr><td><code id="modereg_+3A_bw">bw</code></td>
<td>
<p>        bandwidth.</p>
</td></tr> 
<tr><td><code id="modereg_+3A_xgrid">xgrid</code></td>
<td>
<p>     the grid values to estimate the responses.</p>
</td></tr>
<tr><td><code id="modereg_+3A_sig">sig</code></td>
<td>
<p>      standard deviation of the measurement error; <code>sig=NULL</code> returns the naive estimators ignoring measurement error.</p>
</td></tr> 
<tr><td><code id="modereg_+3A_nstart">nstart</code></td>
<td>
<p>    the starting number of modes for each grid value.</p>
</td></tr>
<tr><td><code id="modereg_+3A_p.order">p.order</code></td>
<td>
<p>   the order of polynomial, up to 1; <code>p.order=0</code> returns local constant estimators and <code>p.order=1</code> returns local linear estimators. </p>
</td></tr>
<tr><td><code id="modereg_+3A_maxiter">maxiter</code></td>
<td>
<p>  the maximum number of iterations performed for the mean shift algorithm if not converage.</p>
</td></tr> 
<tr><td><code id="modereg_+3A_tol">tol</code></td>
<td>
<p>      the deisered accurary (convergence tolerrance).</p>
</td></tr>
<tr><td><code id="modereg_+3A_mesh">mesh</code></td>
<td>
<p>     a matrix of initial mode points, where each row corresponds a mode in <code>(x,y)</code> coordinate; if <code>mesh=NULL</code>, it will be chosen automatically according to <code>xgrid</code> and <code>nstart</code>.</p>
</td></tr>
<tr><td><code id="modereg_+3A_plot">PLOT</code></td>
<td>
<p>     a logical value indicating whether the estimated modes will be plotted.</p>
</td></tr>
<tr><td><code id="modereg_+3A_...">...</code></td>
<td>
<p>       further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The results include the grid points <code>xgrid</code> for predictor, the number of modes for each grid <code>x.num</code>, the initial mesh points <code>mesh</code>, and corresponding fitted modes <code>mode</code>.
</p>


<h3>Author(s)</h3>

<p>Haiming Zhou and Xianzheng Huang
</p>


<h3>References</h3>

<p>Zhou. H. and Huang, X. (2016). Nonparametric modal regression in the presence of measurement error. <em>Electronic Journal of Statistics</em>, 10: 3579-3620.
</p>
<p>Zhou, H. and Huang, X. (2019). Bandwidth selection for nonparametric modal regression. <em>Communications in Statistics - Simulation and Computation</em>, 48(4): 968-984.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+moderegbwSIMEX">moderegbwSIMEX</a>,<a href="#topic+moderegbw">moderegbw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lpme)

rlaplace=function (use.n, location = 0, scale = 1) 
{
  location &lt;- rep(location, length.out = use.n)
  scale &lt;- rep(scale, length.out = use.n)
  rrrr &lt;- runif(use.n)
  location - sign(rrrr - 0.5) * scale * 
    (log(2) + ifelse(rrrr &lt; 0.5, log(rrrr), log1p(-rrrr)))
}

## sample size:
n =100;
## Function m(x) to estimate#
gofx1  = function(x){ (x+x^2) }
gofx2  = function(x){ (x+x^2)-6 }
xgrid	= seq(-2, 2, length.out=100); 
ngrid	= length(xgrid)

## Sample X
X = rnorm(n, 0, 1); sigma_x=1;
## Sample Y
Y = rep(0, n);
U = runif(n);
for(i in 1:n){
  if(U[i]&lt;0.5){
    Y[i] = rnorm(1, gofx1(X[i]), 1);
  }else{
    Y[i] = rnorm(1, gofx2(X[i]), 1);
  }
}
## reliability ratio
lambda=0.9;
sigma_u  = sqrt(1/lambda-1)*sigma_x;
W=X+rlaplace(n,0,sigma_u/sqrt(2));

## mode estimates
hhxy = c(0.15, 1)
## Note you needs to use the following code to calculate bandwidth
## It is not run here due to the time constrain of runing examples. 
#hhxy = moderegbwSIMEX(Y, W, method="CV-density", p.order=0, 
#                       sig=sigma_u, B=5, length.h=10)$bw;
fit = modereg(Y, W, xgrid=xgrid, bw=hhxy, sig=sigma_u, p.order=0,
              PLOT=TRUE);

## Plot
plot(xgrid, gofx1(xgrid), "l", lwd="2", ylim=c(-9,7), xlim=c(-2,2));
lines(xgrid, gofx2(xgrid), "l", lwd="2");
points(rep(fit$xgrid,fit$x.num), fit$mode, col="3",lwd="2")
</code></pre>

<hr>
<h2 id='moderegbw'>Cross-Validation Bandwidth Selector for Nonparametric Mode Regression</h2><span id='topic+moderegbw'></span>

<h3>Description</h3>

<p>This function selects the bandwidth (Zhou and Huang, 2019) for the local polynomial estimators for nonparametric modal regression in the absence of measurement error.</p>


<h3>Usage</h3>

<pre><code class='language-R'>moderegbw(Y, X, method="CV-density", p.order=0, h1=NULL, h2=NULL, nstart = 4,
          xinterval = quantile(X, probs=c(0.025, 0.975), names = FALSE),
          df=5, ncomp=5, nboot=5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moderegbw_+3A_y">Y</code></td>
<td>
<p>         an n by 1 response vector. </p>
</td></tr>
<tr><td><code id="moderegbw_+3A_x">X</code></td>
<td>
<p>         an n by 1 predictor vector.</p>
</td></tr> 
<tr><td><code id="moderegbw_+3A_method">method</code></td>
<td>
    <p><code>method="CV-density"</code> is for density-based CV; <code>method="CV-mode"</code> is for mode-based CV; <code>metohd="bootstrap"</code> is for a bootstap method; see Zhou and Huang (2019) for details. For non-measurement error models, <code>method="CV-mode"</code> is recommended.</p>
</td></tr>
<tr><td><code id="moderegbw_+3A_p.order">p.order</code></td>
<td>
<p>   the order of polynomial, up to 1; <code>p.order=0</code> returns local constant estimators and <code>p.order=1</code> returns local linear estimators. </p>
</td></tr>
<tr><td><code id="moderegbw_+3A_h1">h1</code></td>
<td>
<p>       bandwidth vector for h1; default is <code>NULL</code>, and h1 is chosen automatically. See Zhou and Huang (2019) for details. It is recommended to carefully specify a fine grid for h1. </p>
</td></tr>
<tr><td><code id="moderegbw_+3A_h2">h2</code></td>
<td>
<p>      bandwidth vector for h2; default is <code>NULL</code>, and h2 is chosen automatically. See Zhou and Huang (2019) for details. It is recommended to carefully specify a fine grid for h2.</p>
</td></tr>
<tr><td><code id="moderegbw_+3A_nstart">nstart</code></td>
<td>
<p>    the starting number of modes for each grid value.</p>
</td></tr>
<tr><td><code id="moderegbw_+3A_xinterval">xinterval</code></td>
<td>
<p> the interval within which the modes will be estimated.</p>
</td></tr>
<tr><td><code id="moderegbw_+3A_df">df</code></td>
<td>
<p>        the degrees of freedom of splines used in the mixture normal regression for bootstrap method.</p>
</td></tr> 
<tr><td><code id="moderegbw_+3A_ncomp">ncomp</code></td>
<td>
<p>     the number of components used in the mixture normal regression for bootstrap method.</p>
</td></tr> 
<tr><td><code id="moderegbw_+3A_nboot">nboot</code></td>
<td>
<p>     the number of bootstrap samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The results include the bandwidth <code>bw</code>.
</p>


<h3>Author(s)</h3>

<p>Haiming Zhou and Xianzheng Huang
</p>


<h3>References</h3>

<p>Zhou, H. and Huang, X. (2019). Bandwidth selection for nonparametric modal regression. <em>Communications in Statistics - Simulation and Computation</em>, 48(4): 968-984.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+moderegbwSIMEX">moderegbwSIMEX</a>,<a href="#topic+modereg">modereg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lpme)
## sample size:
n =100;
## Function m(x) to estimate#
gofx1  = function(x){ (x+x^2) }
gofx2  = function(x){ (x+x^2)-6 }
xgrid	= seq(-2, 2, length.out=100); 
ngrid	= length(xgrid)

## Sample X
X = rnorm(n, 0, 1); sigma_x=1;
## Sample Y
Y = rep(0, n);
U = runif(n);
for(i in 1:n){
  if(U[i]&lt;0.5){
    Y[i] = rnorm(1, gofx1(X[i]), 1);
  }else{
    Y[i] = rnorm(1, gofx2(X[i]), 1);
  }
}

## mode estimates
h1ref = c(1.06*sd(X)*n^(-0.2));
h2ref = c(1.06*sd(Y)*n^(-0.2));
## In practice moer fine grids are desired. 
hx = seq(h1ref*0.2, h1ref*1.5, length.out = 10); 
hy = seq(h2ref*0.8, h2ref, length.out = 2); 
hhxy = moderegbw(Y, X, method="CV-mode", p.order=0,
                 h1=hx, h2=hy)$bw;
fit = modereg(Y, X, xgrid=xgrid, bw=hhxy, p.order=0, PLOT=TRUE);

## Plot
plot(xgrid, gofx1(xgrid), "l", lwd="2", ylim=c(-9,7), xlim=c(-2,2));
lines(xgrid, gofx2(xgrid), "l", lwd="2");
points(rep(fit$xgrid,fit$x.num), fit$mode, col="3",lwd="2")
</code></pre>

<hr>
<h2 id='moderegbwSIMEX'>Cross-Validation Bandwidth Selector Using SIMEX for Nonparametric Mode Regression</h2><span id='topic+moderegbwSIMEX'></span>

<h3>Description</h3>

<p>This function selects the bandwidth (Zhou and Huang, 2016) for the local polynomial estimators for nonparametric modal regression in the presence of measurement error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moderegbwSIMEX(Y, W, method="CV-density", p.order=0, sig, B=5, 
               h1=NULL, h2=NULL, length.h=10, CIregion=0.95, nstart=4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moderegbwSIMEX_+3A_y">Y</code></td>
<td>
<p>         an n by 1 response vector. </p>
</td></tr>
<tr><td><code id="moderegbwSIMEX_+3A_w">W</code></td>
<td>
<p>         an n by 1 predictor vector.</p>
</td></tr> 
<tr><td><code id="moderegbwSIMEX_+3A_method">method</code></td>
<td>
   <p><code>method="CV-density"</code> is for density-based CV; <code>method="CV-mode"</code> is for mode-based CV; see Zhou and Huang (2016) for details. For measurement error models, <code>method="CV-density"</code> is recommended.</p>
</td></tr>
<tr><td><code id="moderegbwSIMEX_+3A_p.order">p.order</code></td>
<td>
<p>   the order of polynomial, up to 1; <code>p.order=0</code> returns local constant estimators and <code>p.order=1</code> returns local linear estimators. </p>
</td></tr>
<tr><td><code id="moderegbwSIMEX_+3A_sig">sig</code></td>
<td>
<p>      standard deviation of the measurement error.</p>
</td></tr>   
<tr><td><code id="moderegbwSIMEX_+3A_b">B</code></td>
<td>
<p>        total number of cross-validation criteria to average over; defualt is 5.</p>
</td></tr>
<tr><td><code id="moderegbwSIMEX_+3A_h1">h1</code></td>
<td>
<p>       bandwidth vector for h1; default is <code>NULL</code>, and h1 is chosen automatically. See Zhou and Huang (2016) for details. It is recommended to carefully specify a fine grid for h1. </p>
</td></tr>
<tr><td><code id="moderegbwSIMEX_+3A_h2">h2</code></td>
<td>
<p>      bandwidth vector for h2; default is <code>NULL</code>, and h2 is chosen automatically. See Zhou and Huang (2016) for details. It is recommended to carefully specify a fine grid for h2.</p>
</td></tr>
<tr><td><code id="moderegbwSIMEX_+3A_length.h">length.h</code></td>
<td>
<p> number of grid points for each of h1 and h2; default is 10.</p>
</td></tr>
<tr><td><code id="moderegbwSIMEX_+3A_ciregion">CIregion</code></td>
<td>
<p> used to determine the interval on which the mode is estimated.</p>
</td></tr>
<tr><td><code id="moderegbwSIMEX_+3A_nstart">nstart</code></td>
<td>
<p>    the starting number of modes for each grid value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The results include the bandwidth <code>bw</code>.
</p>


<h3>Author(s)</h3>

<p>Haiming Zhou and Xianzheng Huang
</p>


<h3>References</h3>

<p>Zhou. H. and Huang, X. (2016). Nonparametric modal regression in the presence of measurement error. <em>Electronic Journal of Statistics</em>, 10: 3579-3620.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modereg">modereg</a>, <a href="#topic+moderegbw">moderegbw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lpme)

rlaplace=function (use.n, location = 0, scale = 1) 
{
  location &lt;- rep(location, length.out = use.n)
  scale &lt;- rep(scale, length.out = use.n)
  rrrr &lt;- runif(use.n)
  location - sign(rrrr - 0.5) * scale * 
    (log(2) + ifelse(rrrr &lt; 0.5, log(rrrr), log1p(-rrrr)))
}

## sample size:
n =100;
## Function m(x) to estimate#
gofx1  = function(x){ (x+x^2) }
gofx2  = function(x){ (x+x^2)-6 }
xgrid	= seq(-2, 2, length.out=100); 
ngrid	= length(xgrid)

## Sample X
X = rnorm(n, 0, 1); sigma_x=1;
## Sample Y
Y = rep(0, n);
U = runif(n);
for(i in 1:n){
  if(U[i]&lt;0.5){
    Y[i] = rnorm(1, gofx1(X[i]), 1);
  }else{
    Y[i] = rnorm(1, gofx2(X[i]), 1);
  }
}
## reliability ratio
lambda=0.9;
sigma_u  = sqrt(1/lambda-1)*sigma_x;
W=X+rlaplace(n,0,sigma_u/sqrt(2));

## mode estimates
hhxy = c(0.15, 1)
## Note you needs to use the following code to calculate bandwidth
## It is not run here due to the time constrain of runing examples. 
#hhxy = moderegbwSIMEX(Y, W, method="CV-density", p.order=0, 
#                      sig=sigma_u, B=5, length.h=10)$bw;
fit = modereg(Y, W, xgrid=xgrid, bw=hhxy, sig=sigma_u, p.order=0,
              PLOT=TRUE);

## Plot
plot(xgrid, gofx1(xgrid), "l", lwd="2", ylim=c(-9,7), xlim=c(-2,2));
lines(xgrid, gofx2(xgrid), "l", lwd="2");
points(rep(fit$xgrid,fit$x.num), fit$mode, col="3",lwd="2")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
