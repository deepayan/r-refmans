<!DOCTYPE html><html><head><title>Help for package LearnGeom</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LearnGeom}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AddPointPoly'><p>Adds a point to a previously defined polygon</p></a></li>
<li><a href='#Angle'><p>Computes the angle between three points</p></a></li>
<li><a href='#CenterPolygon'><p>Computes the center of a given polygon. The center is obtained by averaging the x and y coordinates of the polygon</p></a></li>
<li><a href='#Circumcenter'><p>Computes the circumcenter of a given triangle, that is, the intersection of its three medians</p></a></li>
<li><a href='#CoordinatePlane'><p>Plots an empty coordinate (cartesian) plane with customizable limits for the X and Y axis</p></a></li>
<li><a href='#CreateArcAngles'><p>Creates an arc of a circumference</p></a></li>
<li><a href='#CreateArcPointsDist'><p>Creates an arc of a circumference to connect two points</p></a></li>
<li><a href='#CreateLineAngle'><p>Creates a vector to represent a line that passes through a point and forms certain angle with X axis</p></a></li>
<li><a href='#CreateLinePoints'><p>Creates a vector that represents the line that connects two points</p></a></li>
<li><a href='#CreatePolygon'><p>Creates a matrix to represent the polygon that connects several points</p></a></li>
<li><a href='#CreateRegularPolygon'><p>Creates a matrix to represent a regular polygon</p></a></li>
<li><a href='#CreateSegmentAngle'><p>Creates a matrix that represents the segment that starts from a point with certain length and angle</p></a></li>
<li><a href='#CreateSegmentPoints'><p>Creates a matrix that represents the segment that connects two points</p></a></li>
<li><a href='#DistanceLines'><p>Computes the distance between two lines</p></a></li>
<li><a href='#DistancePointLine'><p>Computes the distance between a point and a line</p></a></li>
<li><a href='#DistancePoints'><p>Computes the distance between two points</p></a></li>
<li><a href='#Draw'><p>Plots a geometric object</p></a></li>
<li><a href='#Duopoly'><p>Plots a fractal curve from the trochoids family. Any curve from this family can be defined by some parametrical equations, but they can also be produced (approximated) through a simple iterative process based on segment drawing for certain angles and lengths</p></a></li>
<li><a href='#FractalSegment'><p>Plots a fractal curve starting from a segment</p></a></li>
<li><a href='#Homothety'><p>Creates an homothety from a given polygon</p></a></li>
<li><a href='#Incenter'><p>Computes the incenter of a given triangle</p></a></li>
<li><a href='#IntersectLineCircle'><p>Finds the intersection between a line and a circumference</p></a></li>
<li><a href='#IntersectLines'><p>Finds the intersection of two lines</p></a></li>
<li><a href='#Koch'><p>Plots the Koch curve</p></a></li>
<li><a href='#LinesAngles'><p>Computes the angle that form two lines</p></a></li>
<li><a href='#MidPoint'><p>Computes the middle point of the segment that connects two points</p></a></li>
<li><a href='#PolygonAngles'><p>Computes each of the existing angles in a given polygon</p></a></li>
<li><a href='#ProjectPoint'><p>Computes the orthogonal projection of a point onto a line</p></a></li>
<li><a href='#ReflectedPoint'><p>Computes the reflected point about a line of a given point</p></a></li>
<li><a href='#ReflectedPolygon'><p>Creates the reflection about a line of a given polygon</p></a></li>
<li><a href='#RemovePointPoly'><p>Removes a point from a previously defined polygon</p></a></li>
<li><a href='#Rotate'><p>Rotates a geometric object</p></a></li>
<li><a href='#SelectPoints'><p>Selection of points from the coordinate plane</p></a></li>
<li><a href='#ShearedPolygon'><p>Creates a sheared polygon from a given one</p></a></li>
<li><a href='#Sierpinski'><p>Plots the Sierpinski triangle</p></a></li>
<li><a href='#SimilarPolygon'><p>Creates a similar polygon to a given one</p></a></li>
<li><a href='#Soddy'><p>Finds the inner and outer Soddy circles of three given mutually tangent circles</p></a></li>
<li><a href='#Star'><p>Creates a closed curve with the shape of a star. Each of the stars produced by this function is built through a simple iterative process based on segment drawing for certain angles and lengths. It can also produce regular polygons for some combinations of the parameters</p></a></li>
<li><a href='#Tessellation'><p>Creates a tessellation from a starting set of geometric objects</p></a></li>
<li><a href='#Translate'><p>Translates a geometric object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Learning Plane Geometry</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Alvaro Briz-Redon, Angel Serrano-Aroca</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alvaro Briz-Redon &lt;albrizre@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains some functions to learn and teach basic plane Geometry at undergraduate level with the aim of being helpful to young students with little programming skills.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-07-14 15:33:57 UTC; Usuario</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-07-14 16:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='AddPointPoly'>Adds a point to a previously defined polygon</h2><span id='topic+AddPointPoly'></span>

<h3>Description</h3>

<p><code>AddPointPoly</code> creates a matrix to represent the polygon that connects several points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddPointPoly(Poly, point, position)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddPointPoly_+3A_poly">Poly</code></td>
<td>
<p>Polygon object, previously created with function <code>CreatePolygon</code> or <code>CreateRegularPolygon</code></p>
</td></tr>
<tr><td><code id="AddPointPoly_+3A_point">point</code></td>
<td>
<p>Vector containing the xy-coordinates of the point to be added to the polygon</p>
</td></tr>
<tr><td><code id="AddPointPoly_+3A_position">position</code></td>
<td>
<p>Integer indicating the position of the point in the original polygon, after which the new point is being added (considering that every polygon is an ordered list of points). It is convenient to visualize the polygon with <code>label = T</code> in order to avoid mistakes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix which contains the points of the polygon. Each row represents one of the points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
n &lt;- 5
C &lt;- c(0,0)
l &lt;- 2
Penta &lt;- CreateRegularPolygon(n, C, l)
Penta &lt;- AddPointPoly(Penta, CenterPolygon(Penta), 1)
Draw(Penta, "blue", label = TRUE)
</code></pre>

<hr>
<h2 id='Angle'>Computes the angle between three points</h2><span id='topic+Angle'></span>

<h3>Description</h3>

<p><code>Angle</code> computes the angle between three points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Angle(A, B, C, label = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Angle_+3A_a">A</code></td>
<td>
<p>Vector containing the xy-cooydinates of point A</p>
</td></tr>
<tr><td><code id="Angle_+3A_b">B</code></td>
<td>
<p>Vector containing the xy-cooydinates of point B. This point acts as the vertex of angle ABC</p>
</td></tr>
<tr><td><code id="Angle_+3A_c">C</code></td>
<td>
<p>Vector containing the xy-cooydinates of point C</p>
</td></tr>
<tr><td><code id="Angle_+3A_label">label</code></td>
<td>
<p>Boolean. When <code>label</code> = <code>TRUE</code>, the plot displays the angle in the point that acts as the vertex. If missing, it works as with <code>label</code> = <code>FALSE</code>, so the angle is not displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Angle between the three points in degrees
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
A &lt;- c(-1,0)
B &lt;- c(0,0)
C &lt;- c(0,1)
Draw(CreatePolygon(A, B, C), "transparent")
angle &lt;- Angle(A, B, C, label = TRUE)
angle &lt;- Angle(A, C, B, label = TRUE)
angle &lt;- Angle(B, A, C, label = TRUE)
</code></pre>

<hr>
<h2 id='CenterPolygon'>Computes the center of a given polygon. The center is obtained by averaging the x and y coordinates of the polygon</h2><span id='topic+CenterPolygon'></span>

<h3>Description</h3>

<p><code>CenterPolygon</code> computes the center of a polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CenterPolygon(Poly)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CenterPolygon_+3A_poly">Poly</code></td>
<td>
<p>Polygon object, previously created with either of the functions <code>CreatePolygon</code> or <code>CreateRegularPolygon</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector which contains the xy-coordinates of the center of the polygon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
P3 &lt;- c(2,0) 
Poly &lt;- CreatePolygon(P1, P2, P3)
C &lt;- CenterPolygon(Poly)
x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
Draw(Poly, "blue")
Draw(C, "red")
</code></pre>

<hr>
<h2 id='Circumcenter'>Computes the circumcenter of a given triangle, that is, the intersection of its three medians</h2><span id='topic+Circumcenter'></span>

<h3>Description</h3>

<p><code>Circumcenter</code> computes the center of a triangle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Circumcenter(Tri, lines = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Circumcenter_+3A_tri">Tri</code></td>
<td>
<p>Triangle object, previously created with function <code>CreatePolygon</code></p>
</td></tr>
<tr><td><code id="Circumcenter_+3A_lines">lines</code></td>
<td>
<p>Boolean. When <code>lines</code> = <code>TRUE</code>, the plot displays the lines that represent the medians of each of the sides of the triangle. If missing, it works as with <code>lines</code> = <code>FALSE</code>, so the lines are not displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector which contains the xy-coordinates of the circumcenter of the triangle
</p>


<h3>References</h3>

<p>http://mathworld.wolfram.com/Circumcenter.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
P3 &lt;- c(2,0) 
Tri &lt;- CreatePolygon(P1, P2, P3)
x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
Draw(Tri, "transparent")
I &lt;- Circumcenter(Tri, lines = TRUE)
Draw(I, "red")
</code></pre>

<hr>
<h2 id='CoordinatePlane'>Plots an empty coordinate (cartesian) plane with customizable limits for the X and Y axis</h2><span id='topic+CoordinatePlane'></span>

<h3>Description</h3>

<p><code>CoordinatePlane</code> plots an empty coordinate (cartesian) plane with customizable limits for the X and Y axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CoordinatePlane(x_min, x_max, y_min, y_max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CoordinatePlane_+3A_x_min">x_min</code></td>
<td>
<p>Lowest value for the X axis</p>
</td></tr>
<tr><td><code id="CoordinatePlane_+3A_x_max">x_max</code></td>
<td>
<p>Highest value for the X axis</p>
</td></tr>
<tr><td><code id="CoordinatePlane_+3A_y_min">y_min</code></td>
<td>
<p>Lowest value for the Y axis</p>
</td></tr>
<tr><td><code id="CoordinatePlane_+3A_y_max">y_max</code></td>
<td>
<p>Highest value for the Y axis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. It produces a plot of a coordinate plane with axes and grid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
</code></pre>

<hr>
<h2 id='CreateArcAngles'>Creates an arc of a circumference</h2><span id='topic+CreateArcAngles'></span>

<h3>Description</h3>

<p><code>CreateArcAngles</code> creates an arc of a circumference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateArcAngles(C, r, angle1, angle2, direction = "anticlock")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateArcAngles_+3A_c">C</code></td>
<td>
<p>Vector containing the xy-coordinates of the center of the circumference</p>
</td></tr>
<tr><td><code id="CreateArcAngles_+3A_r">r</code></td>
<td>
<p>Radius for the circumference (or arc)</p>
</td></tr>
<tr><td><code id="CreateArcAngles_+3A_angle1">angle1</code></td>
<td>
<p>- Angle in degrees (0-360) at which the arc starts</p>
</td></tr>
<tr><td><code id="CreateArcAngles_+3A_angle2">angle2</code></td>
<td>
<p>- Angle in degrees (0-360) at which the arc finishes</p>
</td></tr>
<tr><td><code id="CreateArcAngles_+3A_direction">direction</code></td>
<td>
<p>- String indicating the direction which is considered to create the arc, from the smaller to the higher angle. It has two possible values: &quot;clock&quot; (clockwise direction) and &quot;anticlock&quot; (anti-clockwise direction)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector which contains the center, radius, angles (0-360) and direction (1 - &quot;clock&quot;, 2 - &quot;anticlock&quot;) that define the created arc
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
C &lt;- c(0,0)
r &lt;- 3
angle1 &lt;- 90
angle2 &lt;- 180
direction &lt;- "anticlock"
Arc1 &lt;- CreateArcAngles(C, r, angle1, angle2, direction)
Draw(Arc1, "black")
direction &lt;- "clock"
Arc2 &lt;- CreateArcAngles(C, r, angle1, angle2, direction)
Draw(Arc2, "red")
</code></pre>

<hr>
<h2 id='CreateArcPointsDist'>Creates an arc of a circumference to connect two points</h2><span id='topic+CreateArcPointsDist'></span>

<h3>Description</h3>

<p><code>CreateArcPointsDist</code> creates an arc of a circumference to connect two points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateArcPointsDist(P1, P2, r, choice, direction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateArcPointsDist_+3A_p1">P1</code></td>
<td>
<p>Vector containing the xy-coordinates of point 1</p>
</td></tr>
<tr><td><code id="CreateArcPointsDist_+3A_p2">P2</code></td>
<td>
<p>Vector containing the xy-coordinates of point 2</p>
</td></tr>
<tr><td><code id="CreateArcPointsDist_+3A_r">r</code></td>
<td>
<p>Radius for the circumference which is used to generate the arc. This parameter is necessary because there are infinite possible arcs that connect two points. In the case the radius is smaller than half the distance between <code>P1</code> and <code>P2</code>, there is no possible arc, so the function tells the user</p>
</td></tr>
<tr><td><code id="CreateArcPointsDist_+3A_choice">choice</code></td>
<td>
<p>- Integer indicating which of the two possible centers is chosen to create the arcs. A value of 1 means the center of the circle that contains the arc is chosen in the direction of M + v, being M the middle point between P1 and P2 and v the orthogonal vector of P2 - P1 normalized to the appropriate length for creating the desired arc. A value of 2 means the center of the resulting circle is chosen in the direction of M - V. Remark: There are as well two options for vector v. If P1 = (a,b) and P2 = (c,d), v is written in the internal function as (b-d,c-a)</p>
</td></tr>
<tr><td><code id="CreateArcPointsDist_+3A_direction">direction</code></td>
<td>
<p>- String indicating the direction which is considered to create the arc, from the smaller to the higher angle. It has two possible values: &quot;clock&quot; (clockwise direction) and &quot;anticlock&quot; (anti-clockwise direction)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector which contains the center, radius and angles (0-360) that define the created arc
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
P1 &lt;- c(-3,2)
P2 &lt;- c(0,0)
r &lt;- sqrt(18)/2
choice=1
direction="anticlock"
Arc &lt;- CreateArcPointsDist(P1, P2, r, choice, direction)
Draw(Arc, "red")
choice=2
direction="anticlock"
Arc &lt;- CreateArcPointsDist(P1, P2, r, choice, direction)
Draw(Arc, "blue")
choice=1
direction="clock"
Arc &lt;- CreateArcPointsDist(P1, P2, r, choice, direction)
Draw(Arc, "pink")
choice=2
direction="clock"
Arc &lt;- CreateArcPointsDist(P1, P2, r, choice, direction)
Draw(Arc, "green")
</code></pre>

<hr>
<h2 id='CreateLineAngle'>Creates a vector to represent a line that passes through a point and forms certain angle with X axis</h2><span id='topic+CreateLineAngle'></span>

<h3>Description</h3>

<p><code>CreateLineAngle</code> creates a vector to represent a line that passes through a point and forms certain angle with X axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateLineAngle(P, angle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateLineAngle_+3A_p">P</code></td>
<td>
<p>Vector containing the xy-coordinates of a point</p>
</td></tr>
<tr><td><code id="CreateLineAngle_+3A_angle">angle</code></td>
<td>
<p>Angle in degrees (0-360) for the line</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector which contains the slope and intercept of the defined line. If the angle is defined as 90, the slope is set to <code>Inf</code> and the intercept is replaced by the x-value for the line (which is a vertical line in this situation)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- c(0,0)
angle &lt;- 45
Line &lt;- CreateLineAngle(P, angle)
</code></pre>

<hr>
<h2 id='CreateLinePoints'>Creates a vector that represents the line that connects two points</h2><span id='topic+CreateLinePoints'></span>

<h3>Description</h3>

<p><code>CreateLinePoints</code> creates a vector that represents the line that connects two points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateLinePoints(P1, P2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateLinePoints_+3A_p1">P1</code></td>
<td>
<p>Vector containing the xy-coordinates of point 1</p>
</td></tr>
<tr><td><code id="CreateLinePoints_+3A_p2">P2</code></td>
<td>
<p>Vector containing the xy-coordinates of point 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector which contains the slope and intercept of the defined line. If the points have the same x-coordinate, the slope is set to <code>Inf</code> and the intercept is replaced by the x-value for the line (which is a vertical line in this situation)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
Line &lt;- CreateLinePoints(P1, P2)
</code></pre>

<hr>
<h2 id='CreatePolygon'>Creates a matrix to represent the polygon that connects several points</h2><span id='topic+CreatePolygon'></span>

<h3>Description</h3>

<p><code>CreatePolygon</code> creates a matrix to represent the polygon that connects several points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreatePolygon(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreatePolygon_+3A_...">...</code></td>
<td>
<p>An undetermined number of points introduced by the user in the form of vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix which contains the points of the polygon. Each row represents one of the points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
P3 &lt;- c(2,0) 
Poly &lt;- CreatePolygon(P1, P2, P3)
</code></pre>

<hr>
<h2 id='CreateRegularPolygon'>Creates a matrix to represent a regular polygon</h2><span id='topic+CreateRegularPolygon'></span>

<h3>Description</h3>

<p><code>CreateRegularPolygon</code> creates a matrix to represent the polygon that connects several points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateRegularPolygon(n, C, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateRegularPolygon_+3A_n">n</code></td>
<td>
<p>Number of sides for the polygon</p>
</td></tr>
<tr><td><code id="CreateRegularPolygon_+3A_c">C</code></td>
<td>
<p>Vector containing the xy-coordinates for the center of the regular polygon</p>
</td></tr>
<tr><td><code id="CreateRegularPolygon_+3A_l">l</code></td>
<td>
<p>Length of the sides for the polygon</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix which contains the points of a regular polygon given its number of points and the length of its sides. Each row represents one of the points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
n &lt;- 5
C &lt;- c(0,0) 
l &lt;- 1
Penta &lt;- CreateRegularPolygon(n, C, l)
Draw(Penta, "blue", label = TRUE)
</code></pre>

<hr>
<h2 id='CreateSegmentAngle'>Creates a matrix that represents the segment that starts from a point with certain length and angle</h2><span id='topic+CreateSegmentAngle'></span>

<h3>Description</h3>

<p><code>DrawSegment</code> plots the segment that connects two points in a previously generated coordinate plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateSegmentAngle(P, angle, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateSegmentAngle_+3A_p">P</code></td>
<td>
<p>Vector containing the xy-coordinates of the point</p>
</td></tr>
<tr><td><code id="CreateSegmentAngle_+3A_angle">angle</code></td>
<td>
<p>Angle in degrees (0-360) for the segment</p>
</td></tr>
<tr><td><code id="CreateSegmentAngle_+3A_l">l</code></td>
<td>
<p>Positive number that indicates the length for the segment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix which contains the points that determine the extremes of the segment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
P &lt;- c(0,0)
angle &lt;- 30
l &lt;- 1
Segment &lt;- CreateSegmentAngle(P, angle, l)
Draw(Segment, "black")
</code></pre>

<hr>
<h2 id='CreateSegmentPoints'>Creates a matrix that represents the segment that connects two points</h2><span id='topic+CreateSegmentPoints'></span>

<h3>Description</h3>

<p><code>DrawSegment</code> plots the segment that connects two points in a previously generated coordinate plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateSegmentPoints(P1, P2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateSegmentPoints_+3A_p1">P1</code></td>
<td>
<p>Vector containing the xy-coordinates of point 1</p>
</td></tr>
<tr><td><code id="CreateSegmentPoints_+3A_p2">P2</code></td>
<td>
<p>Vector containing the xy-coordinates of point 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix which contains the points that determine the extremes of the segment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
Segment &lt;- CreateSegmentPoints(P1, P2)
Draw(Segment, "black")
</code></pre>

<hr>
<h2 id='DistanceLines'>Computes the distance between two lines</h2><span id='topic+DistanceLines'></span>

<h3>Description</h3>

<p><code>DistanceLines</code> computes the distance between two lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DistanceLines(Line1, Line2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DistanceLines_+3A_line1">Line1</code></td>
<td>
<p>Line object previously created with <code>CreateLinePoints</code> or <code>CreateLineAngle</code></p>
</td></tr>
<tr><td><code id="DistanceLines_+3A_line2">Line2</code></td>
<td>
<p>Line object previously created with <code>CreateLinePoints</code> or <code>CreateLineAngle</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the distance between two points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
Line1 &lt;- CreateLinePoints(P1, P2)
P3 &lt;- c(1,-1)
P4 &lt;- c(2,0)
Line2 &lt;- CreateLinePoints(P3, P4)
d &lt;- DistanceLines(Line1, Line2)
</code></pre>

<hr>
<h2 id='DistancePointLine'>Computes the distance between a point and a line</h2><span id='topic+DistancePointLine'></span>

<h3>Description</h3>

<p><code>DistancePointLine</code> computes the distance between a point and a line
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DistancePointLine(P, Line)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DistancePointLine_+3A_p">P</code></td>
<td>
<p>Vector containing the xy-coordinates of a point</p>
</td></tr>
<tr><td><code id="DistancePointLine_+3A_line">Line</code></td>
<td>
<p>Vector object previously created with <code>CreateLinePoints</code> or <code>CreateLineAngle</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the distance between a point and a line. This distance corresponds to the distance between the point and its orthogonal projection into the line
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- c(2,1)
P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
Line &lt;- CreateLinePoints(P1, P2)
d &lt;- DistancePointLine(P, Line)
</code></pre>

<hr>
<h2 id='DistancePoints'>Computes the distance between two points</h2><span id='topic+DistancePoints'></span>

<h3>Description</h3>

<p><code>DistancePoints</code> computes the distance between two points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DistancePoints(P1, P2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DistancePoints_+3A_p1">P1</code></td>
<td>
<p>Vector containing the xy-coordinates of point 1</p>
</td></tr>
<tr><td><code id="DistancePoints_+3A_p2">P2</code></td>
<td>
<p>Vector containing the xy-coordinates of point 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the euclidean distance between two points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
d &lt;- DistancePoints(P1, P2)
</code></pre>

<hr>
<h2 id='Draw'>Plots a geometric object</h2><span id='topic+Draw'></span>

<h3>Description</h3>

<p><code>Draw</code> plots geometric objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Draw(object, colors = c("black", "black"), label = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Draw_+3A_object">object</code></td>
<td>
<p>geometric object of any of these five types: point, segment, arc, line or polygon. A point is simply a vector of length 2, which contains the xy-coordinates for the point. For the other four types, there can be created with any of the following functions: <br /> 
- <code>CreateArcAngles</code> <br /> 
- <code>CreateArcPointsDist</code> <br /> 
- <code>CreateLineAngle</code> <br /> 
- <code>CreateLinePoints</code> <br /> 
- <code>CreatePolygon</code> <br /> 
- <code>CreateRegularPolygon</code> <br /> 
- <code>CreateSegmentAngle</code> <br /> 
- <code>CreateSegmentPoints</code> <br /></p>
</td></tr>
<tr><td><code id="Draw_+3A_colors">colors</code></td>
<td>
<p>Vector containing information about the color for the object to be plotted. In the case of polygons, the vector should have length 2 to define the background color and the border color (in this order). Moreover, it can be used <code>"transparent"</code> in the case no background color is needed for the polygon. For the other four types of objects, <code>color</code> should be a vector of length 1 (or a simple string) to indicate the color for the object. If this parameter is not specified the default color is black (for polygons, it is black for the background and the border)</p>
</td></tr>
<tr><td><code id="Draw_+3A_label">label</code></td>
<td>
<p>Boolean, only used for polygons. When <code>label</code> = <code>TRUE</code> and the object is a polygon, the plot displays the numbers that correspond to the order of the points of the polygon. If missing, it works as with <code>label</code> = <code>FALSE</code>, so the numbers are not displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. It produces the plot of a geometric object (point, segment, arc, line or polygon) in the current coordinate plane
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
P3 &lt;- c(2,0) 
Poly &lt;- CreatePolygon(P1, P2, P3)
Draw(Poly, c("blue"))
</code></pre>

<hr>
<h2 id='Duopoly'>Plots a fractal curve from the trochoids family. Any curve from this family can be defined by some parametrical equations, but they can also be produced (approximated) through a simple iterative process based on segment drawing for certain angles and lengths</h2><span id='topic+Duopoly'></span>

<h3>Description</h3>

<p><code>Duopoly</code> plots a closed curve from the trochoids family
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Duopoly(P, l1, angle1, l2, angle2, time = 0, color = "transparent")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Duopoly_+3A_p">P</code></td>
<td>
<p>Vector containing the xy-coordinates of the starting point for the curve</p>
</td></tr>
<tr><td><code id="Duopoly_+3A_l1">l1</code></td>
<td>
<p>Number that indicates the length side of the segment drawn the first in each of the steps of the process</p>
</td></tr>
<tr><td><code id="Duopoly_+3A_angle1">angle1</code></td>
<td>
<p>Angle (0-360) that indicates the direction of the segment which is drawn the first in each of the steps of the process</p>
</td></tr>
<tr><td><code id="Duopoly_+3A_l2">l2</code></td>
<td>
<p>Number that indicates the length side of the segment drawn the second in each of the steps of the process</p>
</td></tr>
<tr><td><code id="Duopoly_+3A_angle2">angle2</code></td>
<td>
<p>Angle (0-360) that indicates the direction of the segment which is drawn the second in each of the steps of the process</p>
</td></tr>
<tr><td><code id="Duopoly_+3A_time">time</code></td>
<td>
<p>Number of seconds to wait for the program before drawing each of the segments that make the trochoid curve. If no <code>time</code> is specified, default value is 0 (no waiting time). If the chosen time is very small (<code>time</code> &lt; 0.05) it is possible that the program shows the plot directly. In this case, it should be increased the <code>time</code> parameter.</p>
</td></tr>
<tr><td><code id="Duopoly_+3A_color">color</code></td>
<td>
<p>Color to indicate the points that are obtained during the process to approximate the trochoid. If missing, the points are not indicated and only the segments are drawn in the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. It produces the plot of a curve from the trochoids family
</p>


<h3>References</h3>

<p>Abelson, H., &amp; DiSessa, A. A. (1986). Turtle geometry: The computer as a medium for exploring mathematics. MIT press
</p>
<p>Armon, U. (1996). Representing trochoid curves by DUOPOLY procedure. International Journal of Mathematical Education in Science and Technology, 27(2), 177-187
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -100
x_max &lt;- 100
y_min &lt;- -50
y_max &lt;- 150
CoordinatePlane(x_min, x_max, y_min, y_max)
P &lt;- c(0,0)
l1 &lt;- 2
angle1 &lt;- 3
l2 &lt;- 2
angle2 &lt;- 10 
Duopoly(P, l1, angle1, l2, angle2)
</code></pre>

<hr>
<h2 id='FractalSegment'>Plots a fractal curve starting from a segment</h2><span id='topic+FractalSegment'></span>

<h3>Description</h3>

<p><code>FractalSegment</code> plots the first iterations of a fractal curve, starting from a segment in the plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FractalSegment(P1, P2, angle, cut1, cut2, f, it)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FractalSegment_+3A_p1">P1</code></td>
<td>
<p>Vector containing the xy-coordinates of point 1. This point is the left extreme of the segment that corresponds to the first iteration (<code>it</code> = 1)</p>
</td></tr>
<tr><td><code id="FractalSegment_+3A_p2">P2</code></td>
<td>
<p>Vector containing the xy-coordinates of point 2. This point is the right extreme of the segment that corresponds to the first iteration (<code>it</code> = 1)</p>
</td></tr>
<tr><td><code id="FractalSegment_+3A_angle">angle</code></td>
<td>
<p>Angle (0-360) that determines the angle with which the new segments are drawn at the cut points</p>
</td></tr>
<tr><td><code id="FractalSegment_+3A_cut1">cut1</code></td>
<td>
<p>Number bigger than 0 and smaller than 1 that indicates the proportional part of the segment at which the first cut occurs. This parameter determines the position of the first cut point</p>
</td></tr>
<tr><td><code id="FractalSegment_+3A_cut2">cut2</code></td>
<td>
<p>Number bigger than 0 and smaller than 1 that indicates the proportional part of the segment at which the second cut occurs. This parameter determines the position of the second cut point</p>
</td></tr>
<tr><td><code id="FractalSegment_+3A_f">f</code></td>
<td>
<p>Positive number that produces an enlargement or a reduction for the new drawn segment in each iteration</p>
</td></tr>
<tr><td><code id="FractalSegment_+3A_it">it</code></td>
<td>
<p>Number of iterations to be performed for the construction of the fractal curve. It is not recommended to choose a number higher than 7 in order to avoid an excess of computation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. It produces the plot of the first <code>n</code> iterations of a fractal curve in the current coordinate plane. The choice of parameters <code>cut1 = 1/3</code>, <code>cut2 = 2/3</code>, <code>angle = 60</code> and <code>f = 1</code> produces the Koch curve
</p>


<h3>References</h3>

<p>http://mathworld.wolfram.com/Fractal.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -6
x_max &lt;- 6
y_min &lt;- -4
y_max &lt;- 8
CoordinatePlane(x_min, x_max, y_min, y_max)
P1 &lt;- c(-5,0)
P2 &lt;- c(5,0)
angle &lt;- 90
cut1 &lt;- 1/3
cut2 &lt;- 2/3
f &lt;- 1
it &lt;- 4
FractalSegment(P1, P2, angle, cut1, cut2, f, it)
</code></pre>

<hr>
<h2 id='Homothety'>Creates an homothety from a given polygon</h2><span id='topic+Homothety'></span>

<h3>Description</h3>

<p><code>Homothety</code> creates an homothety from a given polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Homothety(Poly, C, k, lines = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Homothety_+3A_poly">Poly</code></td>
<td>
<p>Polygon object, previously created with function <code>CreatePolygon</code></p>
</td></tr>
<tr><td><code id="Homothety_+3A_c">C</code></td>
<td>
<p>Vector containing the xy-coordinates of the center of the homothety</p>
</td></tr>
<tr><td><code id="Homothety_+3A_k">k</code></td>
<td>
<p>Number which represents the expansion or contraction factor for the homothety</p>
</td></tr>
<tr><td><code id="Homothety_+3A_lines">lines</code></td>
<td>
<p>Boolean. When <code>lines</code> = <code>TRUE</code>, the plot displays the lines that connect the center of the homothety with the points of the polygons (the original and the transformed one). If missing, it works as with <code>lines</code> = <code>FALSE</code>, so the lines are not displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the coordinates of a polygon that has been transformed according to the homothethy with center at <code>C</code> and factor <code>k</code>
</p>


<h3>References</h3>

<p>https://www.encyclopediaofmath.org/index.php/Homothety
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -2
x_max &lt;- 6
y_min &lt;- -3
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
P3 &lt;- c(2,0) 
Poly &lt;- CreatePolygon(P1, P2, P3)
Draw(Poly, "blue")
C &lt;- c(-1,-2)
k1 &lt;- 0.5
Poly_homothety1 &lt;- Homothety(Poly, C, k1, lines = TRUE)
Draw(Poly_homothety1, "orange")
k2 &lt;- 2
Poly_homothety2 &lt;- Homothety(Poly, C, k2, lines = TRUE)
Draw(Poly_homothety2, "orange")
</code></pre>

<hr>
<h2 id='Incenter'>Computes the incenter of a given triangle</h2><span id='topic+Incenter'></span>

<h3>Description</h3>

<p><code>Incenter</code> computes the center of a triangle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Incenter(Tri, lines = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Incenter_+3A_tri">Tri</code></td>
<td>
<p>Triangle object, previously created with function <code>CreatePolygon</code></p>
</td></tr>
<tr><td><code id="Incenter_+3A_lines">lines</code></td>
<td>
<p>Boolean. When <code>lines</code> = <code>TRUE</code>, the plot displays the lines that bisect each of the angles of the triangle. If missing, it works as with <code>lines</code> = <code>FALSE</code>, so the lines are not displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector which contains the xy-coordinates of the incenter of the triangle
</p>


<h3>References</h3>

<p>http://mathworld.wolfram.com/Incenter.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
P3 &lt;- c(2,0) 
Tri &lt;- CreatePolygon(P1, P2, P3)
x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
Draw(Tri, "transparent")
I &lt;- Incenter(Tri, lines = TRUE)
Draw(I, "red")
</code></pre>

<hr>
<h2 id='IntersectLineCircle'>Finds the intersection between a line and a circumference</h2><span id='topic+IntersectLineCircle'></span>

<h3>Description</h3>

<p><code>IntersectLineCircle</code> finds the intesection between a line and a circumference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IntersectLineCircle(Line, C, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IntersectLineCircle_+3A_line">Line</code></td>
<td>
<p>Line object previously created with <code>CreateLinePoints</code> or <code>CreateLineAngle</code></p>
</td></tr>
<tr><td><code id="IntersectLineCircle_+3A_c">C</code></td>
<td>
<p>Vector containing the xy-coordinates of the center of the circumference</p>
</td></tr>
<tr><td><code id="IntersectLineCircle_+3A_r">r</code></td>
<td>
<p>Radius for the circumference</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector containing the xy-coordinates of the intersection points. In case of no intersection, the function tells the user
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
Line &lt;- CreateLinePoints(P1, P2)
C &lt;- c(0,0)
r &lt;- 2
intersection &lt;- IntersectLineCircle(Line, C, r)
x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
Draw(Line, "black")
Draw(CreateArcAngles(C, r, 0, 360), "black")
Draw(intersection[1,], "red")
Draw(intersection[2,], "red")
</code></pre>

<hr>
<h2 id='IntersectLines'>Finds the intersection of two lines</h2><span id='topic+IntersectLines'></span>

<h3>Description</h3>

<p><code>IntersectLines</code> finds the intesection of two lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IntersectLines(Line1, Line2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IntersectLines_+3A_line1">Line1</code></td>
<td>
<p>Line object previously created with <code>CreateLinePoints</code> or <code>CreateLineAngle</code></p>
</td></tr>
<tr><td><code id="IntersectLines_+3A_line2">Line2</code></td>
<td>
<p>Line object previously created with <code>CreateLinePoints</code> or <code>CreateLineAngle</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector containing the xy-coordinates of the intersection point. In case of no intersection, the function tells the user
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
Line1 &lt;- CreateLinePoints(P1, P2)
P3 &lt;- c(1,-1)
P4 &lt;- c(2,0)
Line2 &lt;- CreateLinePoints(P3, P4)
intersection &lt;- IntersectLines(Line1, Line2)
</code></pre>

<hr>
<h2 id='Koch'>Plots the Koch curve</h2><span id='topic+Koch'></span>

<h3>Description</h3>

<p><code>Koch</code> plots the first iterations of Koch curve, a well-known fractal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Koch(P1, P2, it)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Koch_+3A_p1">P1</code></td>
<td>
<p>Vector containing the xy-coordinates of point 1. This point is the left extreme of the segment that corresponds to the first iteration (<code>it</code> = 1)</p>
</td></tr>
<tr><td><code id="Koch_+3A_p2">P2</code></td>
<td>
<p>Vector containing the xy-coordinates of point 2. This point is the right extreme of the segment that corresponds to the first iteration (<code>it</code> = 1)</p>
</td></tr>
<tr><td><code id="Koch_+3A_it">it</code></td>
<td>
<p>Number of iterations to be performed for the construction of Koch curve. It is not recommended to choose a number higher than 7 in order to avoid an excess of computation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. It produces the plot of the first <code>n</code> iterations of Koch curve in the current coordinate plane
</p>


<h3>References</h3>

<p>http://mathworld.wolfram.com/KochSnowflake.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -6
x_max &lt;- 6
y_min &lt;- -4
y_max &lt;- 8
CoordinatePlane(x_min, x_max, y_min, y_max)
P1 &lt;- c(-5,0)
P2 &lt;- c(5,0)
it &lt;- 4 
Koch(P1, P2, it)
</code></pre>

<hr>
<h2 id='LinesAngles'>Computes the angle that form two lines</h2><span id='topic+LinesAngles'></span>

<h3>Description</h3>

<p><code>LinesAngles</code> computes the angle that form two lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LinesAngles(Line1, Line2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LinesAngles_+3A_line1">Line1</code></td>
<td>
<p>Line object previously created with <code>CreateLinePoints</code> or <code>CreateLineAngle</code></p>
</td></tr>
<tr><td><code id="LinesAngles_+3A_line2">Line2</code></td>
<td>
<p>Line object previously created with <code>CreateLinePoints</code> or <code>CreateLineAngle</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the angle that form the two lines
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
Line1 &lt;- CreateLinePoints(P1, P2)
P3 &lt;- c(1,-1)
P4 &lt;- c(2,3)
Line2 &lt;- CreateLinePoints(P3, P4)
angle &lt;- LinesAngles(Line1, Line2)
</code></pre>

<hr>
<h2 id='MidPoint'>Computes the middle point of the segment that connects two points</h2><span id='topic+MidPoint'></span>

<h3>Description</h3>

<p><code>MidPoint</code> computes the middle point of the segment that connects two points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MidPoint(P1, P2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MidPoint_+3A_p1">P1</code></td>
<td>
<p>Vector containing the xy-coordinates of point 1</p>
</td></tr>
<tr><td><code id="MidPoint_+3A_p2">P2</code></td>
<td>
<p>Vector containing the xy-coordinates of point 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector containing the xy-coordinates of the middle point of the segment that connects <code>P1</code> and <code>P2</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
mid &lt;- MidPoint(P1, P2)
</code></pre>

<hr>
<h2 id='PolygonAngles'>Computes each of the existing angles in a given polygon</h2><span id='topic+PolygonAngles'></span>

<h3>Description</h3>

<p><code>PolygonAngles</code> computes each of the existing angles in a given polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PolygonAngles(Poly)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PolygonAngles_+3A_poly">Poly</code></td>
<td>
<p>Polygon object, previously created with function <code>CreatePolygon</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector containing the angles for each of the points of a polygon. The resulting vector follows the order of the points in the defined polygon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
P3 &lt;- c(2,0) 
Poly &lt;- CreatePolygon(P1, P2, P3)
angles &lt;- PolygonAngles(Poly)
</code></pre>

<hr>
<h2 id='ProjectPoint'>Computes the orthogonal projection of a point onto a line</h2><span id='topic+ProjectPoint'></span>

<h3>Description</h3>

<p><code>ProjectPoint</code> computes the orthogonal projection of a point onto a line
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProjectPoint(P, Line)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ProjectPoint_+3A_p">P</code></td>
<td>
<p>Vector containing the xy-coordinates of a point</p>
</td></tr>
<tr><td><code id="ProjectPoint_+3A_line">Line</code></td>
<td>
<p>Line object previously created with <code>CreateLinePoints</code> or <code>CreateLineAngle</code>, to be used as the axis of symmetry</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector which contains the xy-coordinates of the projection point
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
xx &lt;- c(0,1,2)
yy &lt;- c(0,1,0)
P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
Line &lt;- CreateLinePoints(P1, P2)
Draw(Line, "black")
P &lt;- c(-2,2)
Draw(P, "black")
projection &lt;- ProjectPoint(P, Line)
Draw(projection, "red")
</code></pre>

<hr>
<h2 id='ReflectedPoint'>Computes the reflected point about a line of a given point</h2><span id='topic+ReflectedPoint'></span>

<h3>Description</h3>

<p><code>ReflectedPoint</code> computes the reflected point about a line of a given point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReflectedPoint(P, Line)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReflectedPoint_+3A_p">P</code></td>
<td>
<p>Vector containing the xy-coordinates of a point</p>
</td></tr>
<tr><td><code id="ReflectedPoint_+3A_line">Line</code></td>
<td>
<p>Line object previously created with <code>CreateLinePoints</code> or <code>CreateLineAngle</code>, to be used as the axis of symmetry</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector which contains the xy-coordinates of the reflected point
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
xx &lt;- c(0,1,2)
yy &lt;- c(0,1,0)
P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
Line &lt;- CreateLinePoints(P1, P2)
Draw(Line, "black")
P &lt;- c(-2,2)
Draw(P, "black")
reflected &lt;- ReflectedPoint(P, Line)
Draw(reflected, "red")
</code></pre>

<hr>
<h2 id='ReflectedPolygon'>Creates the reflection about a line of a given polygon</h2><span id='topic+ReflectedPolygon'></span>

<h3>Description</h3>

<p><code>ReflectedPolygon</code> creates the reflection about a line of a given polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReflectedPolygon(Poly, Line)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReflectedPolygon_+3A_poly">Poly</code></td>
<td>
<p>Polygon object, previously created with function <code>CreatePolygon</code> or <code>CreateRegularPolygon</code></p>
</td></tr>
<tr><td><code id="ReflectedPolygon_+3A_line">Line</code></td>
<td>
<p>Line object previously created with <code>CreateLinePoints</code> or <code>CreateLineAngle</code>, to be used as the axis of symmetry</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the reflection of a polygon about a line
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
P3 &lt;- c(2,0) 
Poly &lt;- CreatePolygon(P1, P2, P3)
Draw(Poly, "blue")
P1 &lt;- c(-3,2)
P2 &lt;- c(1,-4)
Line &lt;- CreateLinePoints(P1, P2)
Draw(Line, "black")
Poly_reflected &lt;- ReflectedPolygon(Poly, Line)
Draw(Poly_reflected, "orange")
</code></pre>

<hr>
<h2 id='RemovePointPoly'>Removes a point from a previously defined polygon</h2><span id='topic+RemovePointPoly'></span>

<h3>Description</h3>

<p><code>RemovePointPoly</code> creates a matrix to represent the polygon that connects several points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RemovePointPoly(Poly, position)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RemovePointPoly_+3A_poly">Poly</code></td>
<td>
<p>Polygon object, previously created with function <code>CreatePolygon</code> or <code>CreateRegularPolygon</code></p>
</td></tr>
<tr><td><code id="RemovePointPoly_+3A_position">position</code></td>
<td>
<p>Integer indicating the position of the point in the original polygon that is being removed. It is convenient to visualize the polygon with <code>label = T</code> in order to avoid mistakes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix which contains the points of the polygon. Each row represents one of the points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
n &lt;- 5
C &lt;- c(0,0)
l &lt;- 2
Penta &lt;- CreateRegularPolygon(n, C, l)
Penta &lt;- RemovePointPoly(Penta, 4)
Draw(Penta, "blue", label = TRUE)
</code></pre>

<hr>
<h2 id='Rotate'>Rotates a geometric object</h2><span id='topic+Rotate'></span>

<h3>Description</h3>

<p><code>Rotate</code> rotates a geometric object of any of the following types: line, polygon or segment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rotate(object, fixed, angle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rotate_+3A_object">object</code></td>
<td>
<p>geometric object of type line, polygon or segment, previously created with any of the functions in the package</p>
</td></tr>
<tr><td><code id="Rotate_+3A_fixed">fixed</code></td>
<td>
<p>Vector containing the xy-coordinates of the only point of the plane which remains fixed during rotation</p>
</td></tr>
<tr><td><code id="Rotate_+3A_angle">angle</code></td>
<td>
<p>Angle of rotation in degrees (0-360), considering the clockwise direction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a geometric object which is the rotation of the original one, following the clockwise direction
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
P3 &lt;- c(2,0) 
Poly &lt;- CreatePolygon(P1, P2, P3)
Draw(Poly, "blue")
fixed &lt;- c(-1,-1)
angle &lt;- 30
Poly_rotated &lt;- Rotate(Poly, fixed, angle)
Draw(Poly_rotated, "orange")
fixed &lt;- c(2,0)
Poly_rotated &lt;- Rotate(Poly, fixed, angle)
Draw(Poly_rotated, "transparent")
</code></pre>

<hr>
<h2 id='SelectPoints'>Selection of points from the coordinate plane</h2><span id='topic+SelectPoints'></span>

<h3>Description</h3>

<p><code>SelectPoints</code> allows the selection of points from the coordinate plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectPoints(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectPoints_+3A_n">n</code></td>
<td>
<p>Number of points to select from the current coordinate plane</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector or matrix which contains the xy-coordinates of the selected points. Each row represents one of the points. If <code>n = 1</code> the output is a numeric vector, if <code>n = 2</code> then it is a <code>Segment</code>, and for <code>n &gt; 2</code> the object is a polygon.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 3
points &lt;- SelectPoints(n)
</code></pre>

<hr>
<h2 id='ShearedPolygon'>Creates a sheared polygon from a given one</h2><span id='topic+ShearedPolygon'></span>

<h3>Description</h3>

<p><code>ShearedPolygon</code> creates a sheared polygon from a given one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ShearedPolygon(Poly, k, direction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ShearedPolygon_+3A_poly">Poly</code></td>
<td>
<p>Polygon object, previously created with function <code>CreatePolygon</code> or <code>CreateRegularPolygon</code></p>
</td></tr>
<tr><td><code id="ShearedPolygon_+3A_k">k</code></td>
<td>
<p>Number that represents the shear factor which is applied to the original polygon</p>
</td></tr>
<tr><td><code id="ShearedPolygon_+3A_direction">direction</code></td>
<td>
<p>String with value &quot;horizontal&quot; or &quot;vertical&quot; which indicates the direction in which shearing is applied. Horizontal means the shearing is parallel to the X axis, while vertical means parallel to the Y axis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a sheared polygon, in any of the two axis, to the original one
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
Square &lt;- CreateRegularPolygon(4, c(-2, 0), 1)
Draw(Square, "blue")
k &lt;- 1
Square_shearX &lt;- Translate(ShearedPolygon(Square, k, "horizontal"), c(3,0))
Draw(Square_shearX, "orange")
Square_shearY &lt;- Translate(ShearedPolygon(Square, k, "vertical"), c(3,0))
Draw(Square_shearY, "orange")
</code></pre>

<hr>
<h2 id='Sierpinski'>Plots the Sierpinski triangle</h2><span id='topic+Sierpinski'></span>

<h3>Description</h3>

<p><code>Sierpinski</code> plots the first iterations of Sierpinski triangle, a well-known fractal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sierpinski(Tri, it)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sierpinski_+3A_tri">Tri</code></td>
<td>
<p>Regular triangle, previously created with function <code>CreateRegularPolygon</code></p>
</td></tr>
<tr><td><code id="Sierpinski_+3A_it">it</code></td>
<td>
<p>Number of iterations to be performed for the construction of Sierpinski triangle. It is not recommended to choose a number higher than 10 in order to avoid an excess of computation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. It produces the plot of the first <code>n</code> iterations of Sierpinski triangle in the current coordinate plane
</p>


<h3>References</h3>

<p>http://mathworld.wolfram.com/SierpinskiSieve.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -6
x_max &lt;- 6
y_min &lt;- -6
y_max &lt;- 6
CoordinatePlane(x_min, x_max, y_min, y_max)
n &lt;- 3
C &lt;- c(0,0)
l &lt;- 5
Tri &lt;- CreateRegularPolygon(n, C, l)
it &lt;- 6
Sierpinski(Tri, it)
</code></pre>

<hr>
<h2 id='SimilarPolygon'>Creates a similar polygon to a given one</h2><span id='topic+SimilarPolygon'></span>

<h3>Description</h3>

<p><code>SimilarPolygon</code> creates a sheared polygon from a given one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimilarPolygon(Poly, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimilarPolygon_+3A_poly">Poly</code></td>
<td>
<p>Polygon object, previously created with function <code>CreatePolygon</code> or <code>CreateRegularPolygon</code></p>
</td></tr>
<tr><td><code id="SimilarPolygon_+3A_k">k</code></td>
<td>
<p>Positive number that represents the expansion (k &gt; 1) or contraction (k &lt; 1) factor which is applied to the original polygon</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a similar polygon, exapended or contracted, to the original polygon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
P3 &lt;- c(2,0) 
Poly &lt;- CreatePolygon(P1, P2, P3)
Draw(Poly, "blue")
k &lt;- 2
Poly_similar &lt;- SimilarPolygon(Poly, k)
Draw(Translate(Poly_similar, c(-1,2)), "orange")
</code></pre>

<hr>
<h2 id='Soddy'>Finds the inner and outer Soddy circles of three given mutually tangent circles</h2><span id='topic+Soddy'></span>

<h3>Description</h3>

<p><code>Soddy</code> finds inner and outer Soddy circles of three given mutually tangent circles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Soddy(A, r1, B, r2, C, r3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Soddy_+3A_a">A</code></td>
<td>
<p>Vector containing the xy-coordinates of the center of circumference 1</p>
</td></tr>
<tr><td><code id="Soddy_+3A_r1">r1</code></td>
<td>
<p>Radius for circumference 1</p>
</td></tr>
<tr><td><code id="Soddy_+3A_b">B</code></td>
<td>
<p>Vector containing the xy-coordinates of the center of circumference 2</p>
</td></tr>
<tr><td><code id="Soddy_+3A_r2">r2</code></td>
<td>
<p>Radius for circumference 2</p>
</td></tr>
<tr><td><code id="Soddy_+3A_c">C</code></td>
<td>
<p>Vector containing the xy-coordinates of the center of circumference 3</p>
</td></tr>
<tr><td><code id="Soddy_+3A_r3">r3</code></td>
<td>
<p>Radius for circumference 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list which contains the Soddy center and the radiuses of Soddy inner and outer circle of three mutually tangent circles
</p>


<h3>References</h3>

<p>http://mathworld.wolfram.com/SoddyCircles.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -3
x_max &lt;- 3
y_min &lt;- -2.5
y_max &lt;- 3.5
CoordinatePlane(x_min, x_max, y_min, y_max)
A &lt;- c(-1,0)
B &lt;- c(1,0)
C &lt;- c(0,sqrt(3))
r1 &lt;- 1
r2 &lt;- 1
r3 &lt;- 1
Draw(CreateArcAngles(A, r1, 0, 360), "black")
Draw(CreateArcAngles(B, r2, 0, 360), "black")
Draw(CreateArcAngles(C, r3, 0, 360), "black")
result &lt;- Soddy(A, r1, B, r2, C, r3)
soddy_point &lt;- result[[1]]
inner_radius &lt;- result[[2]]
outer_radius &lt;- result[[3]]
Draw(soddy_point,"red")
Draw(CreateArcAngles(soddy_point,inner_radius,0,360),"red")
Draw(CreateArcAngles(soddy_point,outer_radius,0,360),"red")
</code></pre>

<hr>
<h2 id='Star'>Creates a closed curve with the shape of a star. Each of the stars produced by this function is built through a simple iterative process based on segment drawing for certain angles and lengths. It can also produce regular polygons for some combinations of the parameters</h2><span id='topic+Star'></span>

<h3>Description</h3>

<p><code>Star</code> creates a star with multiple building possibilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Star(P, angle, l, time = 0, color = "transparent")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Star_+3A_p">P</code></td>
<td>
<p>Vector containing the xy-coordinates of the starting point for the star</p>
</td></tr>
<tr><td><code id="Star_+3A_angle">angle</code></td>
<td>
<p>Angle (0-360) that is related to the direction of the two segments which are drawn in each of the steps of the process. This parameter really represents the angle (in clockwise and anti-clockwise direction) for the two first drawn segments, but it is modified according to rotations of 144 degrees in all the following steps, including the last one, which closes the curve.</p>
</td></tr>
<tr><td><code id="Star_+3A_l">l</code></td>
<td>
<p>Number that indicates the length side of the segments that are drawn. This parameter will determine the size of the star</p>
</td></tr>
<tr><td><code id="Star_+3A_time">time</code></td>
<td>
<p>Number of seconds to wait for the program before drawing each of the segments that make star. If no <code>time</code> is specified, default value is 0 (no waiting time). If the chosen time is very small (<code>time</code> &lt; 0.05) it is possible that the program shows the plot directly. In this case, it should be increased the <code>time</code> parameter.</p>
</td></tr>
<tr><td><code id="Star_+3A_color">color</code></td>
<td>
<p>Color to indicate the points that are obtained during the process to draw the star. If missing, the points are not indicated and only the segments are drawn in the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. It produces the plot of a closed curve with the shape of a star, if the parameters are chosen properly
</p>


<h3>References</h3>

<p>Abelson, H., &amp; DiSessa, A. A. (1986). Turtle geometry: The computer as a medium for exploring mathematics. MIT press
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
P &lt;- c(0,0)
angle &lt;- 0
l &lt;- 1
Star(P, angle, l)
</code></pre>

<hr>
<h2 id='Tessellation'>Creates a tessellation from a starting set of geometric objects</h2><span id='topic+Tessellation'></span>

<h3>Description</h3>

<p><code>Tessellation</code> creates a geometric pattern by the repetitive translation of an initial geometric object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tessellation(objects_list, colors, direction, separation, it)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tessellation_+3A_objects_list">objects_list</code></td>
<td>
<p>A list composed by several geometric objects (mainly polygons created with <code>CreatePolygon</code> or <code>CreateRegularPolygon</code>)</p>
</td></tr>
<tr><td><code id="Tessellation_+3A_colors">colors</code></td>
<td>
<p>Vector containing the colors for each of the objects of the initial geometric object</p>
</td></tr>
<tr><td><code id="Tessellation_+3A_direction">direction</code></td>
<td>
<p>Vector containing the xy-coordinates of the direction in which tessellation is being generated</p>
</td></tr>
<tr><td><code id="Tessellation_+3A_separation">separation</code></td>
<td>
<p>Number indicating the distance that separates any of the geometric objects in the repetitive pattern. This distance must be understood in the sense of a translation of the initial object. Indeed, this distance is only preserved in the direction of the chosen vector <code>direction</code> when generating the pattern. Moreover, the choice of <code>separation = 0</code> implies no pattern is generated</p>
</td></tr>
<tr><td><code id="Tessellation_+3A_it">it</code></td>
<td>
<p>Number of iterations to be performed for the construction of the tessellation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. It produces the plot of a repetitive pattern, usually known as a tessellation
</p>


<h3>References</h3>

<p>http://mathworld.wolfram.com/Tessellation.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -6
x_max &lt;- 6
y_min &lt;- -2
y_max &lt;- 10
CoordinatePlane(x_min, x_max, y_min, y_max)
Hexa &lt;- CreateRegularPolygon(6, c(-3,0), 1)
Draw(Hexa, "purple")
Tri &lt;- CreatePolygon(c(-3,-1), c(Hexa[4,1],-2), c(Hexa[1,1],-2))
Draw(Tri,"pink")
objects_list &lt;- list(Tri, Hexa)
cols &lt;- c("pink", "purple")
direction &lt;- c(1,0)
separation &lt;- 1.732051 
it &lt;- 3
Tessellation(objects_list, cols, direction, separation, it)
direction &lt;- c(0,1)
separation &lt;- 3
it &lt;- 4
Tessellation(objects_list, cols, direction, separation, it)
</code></pre>

<hr>
<h2 id='Translate'>Translates a geometric object</h2><span id='topic+Translate'></span>

<h3>Description</h3>

<p><code>Translate</code> translates a geometric object of any of the following types: line, polygon or segment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Translate(object, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Translate_+3A_object">object</code></td>
<td>
<p>geometric object, previously created with function <code>CreatePolygon</code></p>
</td></tr>
<tr><td><code id="Translate_+3A_v">v</code></td>
<td>
<p>Vector containing the xy-coordinates of the translation vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a polygon whose coordinates are translated according to vector <code>v</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_min &lt;- -5
x_max &lt;- 5
y_min &lt;- -5
y_max &lt;- 5
CoordinatePlane(x_min, x_max, y_min, y_max)
P1 &lt;- c(0,0)
P2 &lt;- c(1,1)
P3 &lt;- c(2,0) 
Poly &lt;- CreatePolygon(P1, P2, P3)
Draw(Poly, "blue")
v &lt;- c(1,2)
Poly_translated &lt;- Translate(Poly, v)
Draw(Poly_translated, "orange")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
