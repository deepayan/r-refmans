<!DOCTYPE html><html><head><title>Help for package bayesSurv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bayesSurv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bayesBisurvreg'><p>Population-averaged accelerated failure time model for bivariate,</p>
possibly doubly-interval-censored data. The error distribution is
expressed as a penalized bivariate normal mixture with high number
of components (bivariate G-spline).</a></li>
<li><a href='#bayesBisurvreg.help'>
<p>Helping function for Bayesian regression with smoothed bivariate</p>
densities as the error term,
based on possibly censored data</a></li>
<li><a href='#bayesDensity'>
<p>Summary for the density estimate based on the mixture Bayesian AFT model.</p></a></li>
<li><a href='#bayesGspline'>
<p>Summary for the density estimate based on the model with Bayesian</p>
G-splines.</a></li>
<li><a href='#bayesHistogram'><p>Smoothing of a uni- or bivariate histogram using Bayesian</p>
G-splines</a></li>
<li><a href='#bayesHistogram.help'>
<p>Helping function for Bayesian smoothing of (bi)-variate densities</p>
based on possibly censored data</a></li>
<li><a href='#bayessurvreg.help'>
<p>Helping function for Bayesian survival regression models.</p></a></li>
<li><a href='#bayessurvreg1'>
<p>A Bayesian survival regression with an error distribution</p>
expressed as a~normal mixture with unknown number of components</a></li>
<li><a href='#bayessurvreg1.files2init'>
<p>Read the initial values for the Bayesian survival regression model to the list.</p></a></li>
<li><a href='#bayessurvreg1.help'>
<p>Helping function for Bayesian survival regression models, version 1.</p></a></li>
<li><a href='#bayessurvreg2'>
<p>Cluster-specific accelerated failure time model for multivariate,</p>
possibly doubly-interval-censored data. The error distribution is
expressed as a penalized univariate normal mixture with high number of
components (G-spline). The distribution of the vector of random
effects is multivariate normal.</a></li>
<li><a href='#bayessurvreg2.help'>
<p>Helping functions for Bayesian regression with an error distribution</p>
smoothed using G-splines</a></li>
<li><a href='#bayessurvreg3'>
<p>Cluster-specific accelerated failure time model for multivariate,</p>
possibly doubly-interval-censored data with flexibly specified random effects
and/or error distribution.</a></li>
<li><a href='#bayessurvreg3.help'>
<p>Helping functions for Bayesian regression with an error distribution</p>
smoothed using G-splines</a></li>
<li><a href='#cgd'><p>Chronic Granulomatous Disease data</p></a></li>
<li><a href='#credible.region'>
<p>Compute a simultaneous credible region (rectangle) from a sample for a vector valued parameter.</p></a></li>
<li><a href='#densplot2'>
<p>Probability density function estimate from MCMC output</p></a></li>
<li><a href='#files.Gspline'>
<p>Write headers to or clean files with sampled G-spline</p></a></li>
<li><a href='#files2coda'>
<p>Read the sampled values from the Bayesian survival regression model</p>
to a coda mcmc object.</a></li>
<li><a href='#give.init'>
<p>Check and possibly fill in initial values for the G-spline, augmented</p>
observations and allocations for Bayesian models with G-splines</a></li>
<li><a href='#give.summary'>
<p>Brief summary for the chain(s) obtained using the MCMC.</p></a></li>
<li><a href='#marginal.bayesGspline'>
<p>Summary for the marginal density estimates based on the bivariate model with Bayesian</p>
G-splines.</a></li>
<li><a href='#plot.bayesDensity'>
<p>Plot an object of class bayesDensity</p></a></li>
<li><a href='#plot.bayesGspline'>
<p>Plot an object of class bayesGspline</p></a></li>
<li><a href='#plot.marginal.bayesGspline'>
<p>Plot an object of class marginal.bayesGspline</p></a></li>
<li><a href='#predictive'>
<p>Compute predictive quantities based on a Bayesian survival regression</p>
model fitted using bayessurvreg1 function.</a></li>
<li><a href='#predictive2'>
<p>Compute predictive quantities based on a Bayesian survival regression</p>
model fitted using bayesBisurvreg or bayessurvreg2 or bayessurvreg3 functions.</a></li>
<li><a href='#print.bayesDensity'>
<p>Print a summary for the density estimate based on the Bayesian model.</p></a></li>
<li><a href='#rMVNorm'>
<p>Sample from the multivariate normal distribution</p></a></li>
<li><a href='#rWishart'>
<p>Sample from the Wishart distribution</p></a></li>
<li><a href='#sampleCovMat'>
<p>Compute a sample covariance matrix.</p></a></li>
<li><a href='#sampled.kendall.tau'>
<p>Estimate of the Kendall's tau from the bivariate model</p></a></li>
<li><a href='#scanFN'><p>Read Data Values</p></a></li>
<li><a href='#simult.pvalue'>
<p>Compute a simultaneous p-value from a sample for a vector valued parameter.</p></a></li>
<li><a href='#tandmob2'><p>Signal Tandmobiel data, version 2</p></a></li>
<li><a href='#tandmobRoos'><p>Signal Tandmobiel data, version Roos</p></a></li>
<li><a href='#traceplot2'>
<p>Trace plot of MCMC output.</p></a></li>
<li><a href='#vecr2matr'>
<p>Transform single component indeces to double component indeces</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-16</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Survival Regression with Flexible Error and Random
Effects Distributions</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), survival, coda, smoothSurv</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, utils</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains Bayesian implementations of the Mixed-Effects Accelerated Failure Time (MEAFT) models
             for censored data. Those can be not only right-censored but also interval-censored,
	     doubly-interval-censored or misclassified interval-censored. The methods implemented in the package
	     have been published in Komárek and Lesaffre (2006, Stat. Modelling) &lt;<a href="https://doi.org/10.1191%2F1471082X06st107oa">doi:10.1191/1471082X06st107oa</a>&gt;,
	     Komárek, Lesaffre and Legrand (2007, Stat. in Medicine) &lt;<a href="https://doi.org/10.1002%2Fsim.3083">doi:10.1002/sim.3083</a>&gt;, Komárek and Lesaffre (2007, Stat. Sinica) <a href="https://www3.stat.sinica.edu.tw/statistica/oldpdf/A17n27.pdf">https://www3.stat.sinica.edu.tw/statistica/oldpdf/A17n27.pdf</a>, Komárek and Lesaffre (2008, JASA) &lt;<a href="https://doi.org/10.1198%2F016214507000000563">doi:10.1198/016214507000000563</a>&gt;,
	     García-Zattera, Jara and Komárek (2016, Biometrics) &lt;<a href="https://doi.org/10.1111%2Fbiom.12424">doi:10.1111/biom.12424</a>&gt;.	     </td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://msekce.karlin.mff.cuni.cz/~komarek/">https://msekce.karlin.mff.cuni.cz/~komarek/</a></td>
</tr>
<tr>
<td>ZipData:</td>
<td>no</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-16 19:13:11 UTC; komarek</td>
</tr>
<tr>
<td>Author:</td>
<td>Arnošt Komárek <a href="https://orcid.org/0000-0001-8778-3762"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arnošt Komárek &lt;arnost.komarek@mff.cuni.cz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-18 18:00:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='bayesBisurvreg'>Population-averaged accelerated failure time model for bivariate,
possibly doubly-interval-censored data. The error distribution is
expressed as a penalized bivariate normal mixture with high number
of components (bivariate G-spline).
</h2><span id='topic+bayesBisurvreg'></span><span id='topic+C_bayesBisurvreg'></span>

<h3>Description</h3>

<p>A function to estimate a regression model with bivariate
(possibly right-, left-, interval- or doubly-interval-censored) data.
In the case of doubly interval censoring, different regression models
can be specified for the onset and event times.
</p>
<p>The error density of the regression model is specified as a mixture of Bayesian G-splines
(normal densities with equidistant means and constant variance matrices). This function performs an
MCMC sampling from the posterior distribution of unknown quantities.
</p>
<p>For details, see Komárek (2006) and
Komárek and Lesaffre (2006).
</p>
<p>We explain first in more detail a model without doubly censoring.
Let <code class="reqn">T_{i,l},\; i=1,\dots, N,\; l=1, 2</code>
be event times for <code class="reqn">i</code>th cluster and the first and the second
unit. The following regression model is assumed:
</p>
<p style="text-align: center;"><code class="reqn">\log(T_{i,l}) = \beta'x_{i,l} + \varepsilon_{i,l},\quad i=1,\dots,N,\;l=1,2</code>
</p>

<p>where <code class="reqn">\beta</code> is unknown regression parameter vector and
<code class="reqn">x_{i,l}</code> is a vector of covariates. The bivariate error terms
<code class="reqn">\varepsilon_i=(\varepsilon_{i,1},\,\varepsilon_{i,2})',\;i=1,\dots,N</code>
are assumed to be i.i.d. with a bivariate density
<code class="reqn">g_{\varepsilon}(e_1,\,e_2)</code>. This density is expressed as
a mixture of Bayesian G-splines (normal densities with equidistant
means and constant variance matrices). We distinguish two,
theoretically equivalent, specifications.
</p>

<dl>
<dt>Specification 1</dt><dd>
<p style="text-align: center;"><code class="reqn">(\varepsilon_1,\,\varepsilon_2)' \sim
	\sum_{j_1=-K_1}^{K_1}\sum_{j_2=-K_2}^{K_2} w_{j_1,j_2} N_2(\mu_{(j_1,j_2)},\,\mbox{diag}(\sigma_1^2,\,\sigma_2^2))</code>
</p>

<p>where <code class="reqn">\sigma_1^2,\,\sigma_2^2</code> are
<b>unknown</b> basis variances and
<code class="reqn">\mu_{(j_1,j_2)} = (\mu_{1,j_1},\,\mu_{2,j_2})'</code>
is an equidistant grid of knots symmetric around the
<b>unknown</b> point <code class="reqn">(\gamma_1,\,\gamma_2)'</code> 
and related to the unknown basis variances through the
relationship
</p>
<p style="text-align: center;"><code class="reqn">\mu_{1,j_1} = \gamma_1 + j_1\delta_1\sigma_1,\quad j_1=-K_1,\dots,K_1,</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu_{2,j_2} = \gamma_2 + j_2\delta_2\sigma_2,\quad j_2=-K_2,\dots,K_2,</code>
</p>

<p>where <code class="reqn">\delta_1,\,\delta_2</code> are fixed
constants, e.g. <code class="reqn">\delta_1=\delta_2=2/3</code>
(which has a justification of being close to cubic B-splines).

</p>
</dd>
<dt>Specification 2</dt><dd>
<p style="text-align: center;"><code class="reqn">(\varepsilon_1,\,\varepsilon_2)' \sim (\alpha_1,\,\alpha_2)'+ \bold{S}\,(V_1,\,V_2)'</code>
</p>

<p>where <code class="reqn">(\alpha_1,\,\alpha_2)'</code> is an
<b>unknown</b> intercept term and
<code class="reqn">\bold{S} \mbox{ is a diagonal matrix with } \tau_1 \mbox{ and }\tau_2 \mbox{ on a diagonal,}</code>
i.e. <code class="reqn">\tau_1,\,\tau_2</code> are <b>unknown</b> scale
parameters. <code class="reqn">(V_1,\,V_2)')</code> is then
standardized bivariate error term which is distributed according
to the bivariate normal mixture, i.e.
</p>
<p style="text-align: center;"><code class="reqn">(V_1,\,V_2)'\sim \sum_{j_1=-K_1}^{K_1}\sum_{j_2=-K_2}^{K_2}
	w_{j_1,j_2} N_2(\mu_{(j_1,j_2)},\,\mbox{diag}(\sigma_1^2, \sigma_2^2))</code>
</p>

<p>where <code class="reqn">\mu_{(j_1,j_2)} =
	(\mu_{1,j_1},\,\mu_{2,j_2})'</code> is an equidistant grid of <b>fixed</b> knots (means), usually
symmetric about the <b>fixed</b> point <code class="reqn">(\gamma_1,\,\gamma_2)'=(0,
	0)'</code> and
<code class="reqn">\sigma_1^2,\,\sigma_2^2</code> are
<b>fixed</b> basis variances. Reasonable values for the numbers of grid
points <code class="reqn">K_1</code> and <code class="reqn">K_2</code> are
<code class="reqn">K_1=K_2=15</code> with the distance between the two
knots equal to <code class="reqn">\delta=0.3</code> and for the basis
variances
<code class="reqn">\sigma_1^2\sigma_2^2=0.2^2.</code>
</p>
</dd>  
</dl>

<p>Personally, I found Specification 2 performing better. In the paper
Komárek and Lesaffre (2006) only
Specification 2 is described.
</p>
<p>The mixture weights
<code class="reqn">w_{j_1,j_2},\;j_1=-K_1,\dots, K_1,\;j_2=-K_2,\dots,
    K_2</code> are
not estimated directly. To avoid the constraints
<code class="reqn">0 &lt; w_{j_1,j_2} &lt; 1</code> and
<code class="reqn">\sum_{j_1=-K_1}^{K_1}\sum_{j_2=-K_2}^{K_2}w_{j_1,j_2} =
    1</code>
transformed weights  <code class="reqn">a_{j_1,j_2},\;j_1=-K_1,\dots, K_1,\;j_2=-K_2,\dots,
    K_2</code>
related to the original weights by the logistic transformation:
</p>
<p style="text-align: center;"><code class="reqn">a_{j_1,j_2} =
    \frac{\exp(w_{j_1,j_2})}{\sum_{m_1}\sum_{m_2}\exp(w_{m_1,m_2})}</code>
</p>

<p>are estimated instead.
</p>
<p>A Bayesian model is set up for all unknown parameters. For more
details I refer to Komárek and Lesaffre (2006)
and to Komárek (2006).
</p>
<p>If there are doubly-censored data the model of the same type as above
can be specified for both the onset time and the time-to-event. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesBisurvreg(formula, formula2, data = parent.frame(),
   na.action = na.fail, onlyX = FALSE,
   nsimul = list(niter = 10, nthin = 1, nburn = 0, nwrite = 10),
   prior, prior.beta, init = list(iter = 0),
   mcmc.par = list(type.update.a = "slice", k.overrelax.a = 1,
                   k.overrelax.sigma = 1, k.overrelax.scale = 1),
   prior2, prior.beta2, init2,
   mcmc.par2 = list(type.update.a = "slice", k.overrelax.a = 1,
                    k.overrelax.sigma = 1, k.overrelax.scale = 1),
   store = list(a = FALSE, a2 = FALSE, y = FALSE, y2 = FALSE,
                r = FALSE, r2 = FALSE),
   dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesBisurvreg_+3A_formula">formula</code></td>
<td>
<p>model formula for the regression. In the case of
doubly-censored data, this is the model formula for the onset
time. Data are assumed to be sorted according to subjects and within
subjects according to the types of the events that determine the
bivariate survival distribution, i.e. the response vector must be
<code class="reqn">t_{1,1}, t_{1,2}, t_{2,1}, t_{2,2}, t_{3,1}, t_{3,2}, \dots,
      t_{n,1},
      t_{n,2}</code>.
The rows of the design matrix with covariates must be sorted
analogically.
</p>
<p>The left-hand side of the formula must be an object created using
<code><a href="survival.html#topic+Surv">Surv</a></code>.
</p>
</td></tr>
<tr><td><code id="bayesBisurvreg_+3A_formula2">formula2</code></td>
<td>
<p>model formula for the regression of the time-to-event in
the case of doubly-censored data. Ignored otherwise. The same remark as
for <code>formula</code> concerning the sort order applies here.
</p>
</td></tr>
<tr><td><code id="bayesBisurvreg_+3A_data">data</code></td>
<td>
<p>optional data frame in which to interpret the variables
occuring in the formulas.
</p>
</td></tr>
<tr><td><code id="bayesBisurvreg_+3A_na.action">na.action</code></td>
<td>
<p>the user is discouraged from changing the default
value <code>na.fail</code>.</p>
</td></tr>
<tr><td><code id="bayesBisurvreg_+3A_onlyx">onlyX</code></td>
<td>
<p>if <code>TRUE</code> no MCMC sampling is performed and only the
design matrix (matrices) are returned. This can be useful to set up
correctly priors for regression parameters in the presence of
<code>factor</code> covariates.</p>
</td></tr>
<tr><td><code id="bayesBisurvreg_+3A_nsimul">nsimul</code></td>
<td>
<p>a list giving the number of iterations of the MCMC and
other parameters of the simulation.
</p>

<dl>
<dt>niter</dt><dd><p>total number of sampled values after discarding
thinned ones, burn-up included;</p>
</dd>
<dt>nthin</dt><dd><p>thinning interval;</p>
</dd>
<dt>nburn</dt><dd><p>number of sampled values in a burn-up period after
discarding thinned values. This value should be smaller than
<code>niter</code>. If not, <code>nburn</code> is set to <code>niter - 1</code>. It can be set to zero;</p>
</dd>
<dt>nwrite</dt><dd><p>an interval at which information about the number of
performed iterations is print on the screen and during the
burn-up period an interval with which the sampled values are
writen to files;</p>
</dd>
</dl>
    
</td></tr>    
<tr><td><code id="bayesBisurvreg_+3A_prior">prior</code></td>
<td>
<p>a list specifying the prior distribution of the G-spline
defining the distribution of the error term in the regression model
given by <code>formula</code>. See <code>prior</code> argument of
<code><a href="#topic+bayesHistogram">bayesHistogram</a></code> function for more detail. In this list
also &lsquo;Specification&rsquo; as described above is specified.
</p>
</td></tr>
<tr><td><code id="bayesBisurvreg_+3A_prior.beta">prior.beta</code></td>
<td>
<p>prior specification for the regression parameters,
in the case of doubly censored data for the regression parameters of
the onset time. I.e. it is related to <code>formula</code>.
</p>
<p>This should be a list with the following components:
</p>

<dl>
<dt>mean.prior</dt><dd><p>a vector specifying a prior mean for each
<code>beta</code> parameter in the model.</p>
</dd>
<dt>var.prior</dt><dd><p>a vector specifying a prior variance for each
<code>beta</code> parameter.</p>
</dd>
</dl>

<p>It is recommended to run the function
bayesBisurvreg first with its argument <code>onlyX</code> set to <code>TRUE</code>
to find out how the betas are sorted. They must correspond to a
design matrix X taken from <code>formula</code>.
</p>
</td></tr>  
<tr><td><code id="bayesBisurvreg_+3A_init">init</code></td>
<td>
<p>an optional list with initial values for the MCMC related
to the model given by <code>formula</code>. The list can have the following components:
</p>

<dl>
<dt>iter</dt><dd><p>the number of the iteration to which the initial values
correspond, usually zero.</p>
</dd>
<dt>beta</dt><dd><p>a vector of initial values for the regression
parameters. It must be sorted in the same way as are the columns
in the design matrix. Use <code>onlyX=TRUE</code> if you do not know how
the columns in the design matrix are created.</p>
</dd>
<dt>a</dt><dd><p>a matrix of size <code class="reqn">(2K_1+1)\times(2K_2+1)</code> with the initial values of transformed mixture weights.</p>
</dd>
<dt>lambda</dt><dd><p>initial values for the Markov random fields precision
parameters. According to the chosen prior for the transformed
mixture weights, this is either a number or a vector of length 2.
</p>
</dd>
<dt>gamma</dt><dd><p>a vector of length 2 of initial values for the middle
knots <code class="reqn">\gamma_1, \gamma_2</code> in each
dimension.
</p>
<p>If &lsquo;Specification&rsquo; is 2, this value will not be changed
by the MCMC and it is recommended (for easier
interpretation of the results) to set <code>init$gamma</code> to zero
for all dimensions (default behavior).
</p>
<p>If &lsquo;Specification&rsquo; is 1 <code>init$gamma</code> should be
approximately equal to the mean value of the residuals in each
margin.
</p>
</dd>
<dt>sigma</dt><dd><p>a vector of length 2 of initial values of the basis
standard deviations <code class="reqn">\sigma_1, \sigma_2</code>.
</p>
<p>If &lsquo;Specification&rsquo; is 2 this value will not be changed
by the MCMC and it is recommended to set it
approximately equal to the range of standardized data (let say 4
+ 4) divided by the number of knots in each margin and
multiplied by something like 2/3.
</p>
<p>If &lsquo;Specification&rsquo; is 1
this should be approximately equal to the range of the residuals
divided by the number of knots in each margin and
multiplied again by something like 2/3.
</p>
</dd>  
<dt>intercept</dt><dd><p>a vector of length 2 of initial values of the
intercept terms <code class="reqn">\alpha_1, \alpha_2</code>.
</p>
<p>If &lsquo;Specification&rsquo; is 1 this value is not changed by the
MCMC and the initial value is always changed to zero for both dimensions.</p>
</dd>
<dt>scale</dt><dd><p>a vector of length 2 of initial values of the scale
parameters <code class="reqn">\tau_1, \tau_2</code>.
</p>
<p>If &lsquo;Specification&rsquo; is 1 this value is not changed by the MCMC
and the initial value is always changed to one for both dimensions.</p>
</dd>
<dt>y</dt><dd><p>a matrix with 2 columns and <code class="reqn">N</code> rows with initial
values of log-event-times for each cluster in rows.</p>
</dd>
<dt>r</dt><dd><p>a matrix with 2 columns and <code class="reqn">N</code> rows with initial
component labels for each bivariate residual in rows. All values
in the first column must be between <code class="reqn">-K_1</code></p>
</dd></dl>
<p> and
<code class="reqn">K_1</code> and all values in the second column must be between
<code class="reqn">-K_2</code> and <code class="reqn">K_2</code>. See argument <code>init</code> of
the function <code><a href="#topic+bayesHistogram">bayesHistogram</a></code> for more details.
</p>
</td></tr>  
<tr><td><code id="bayesBisurvreg_+3A_mcmc.par">mcmc.par</code></td>
<td>
<p>a list specifying how some of the G-spline parameters
related to <code>formula</code> are to be updated. The list can have the following components (all
of them have their default values):
</p>

<dl>
<dt>type.update.a</dt><dd><p>G-spline transformed weights <code class="reqn">a</code> can
be updated using one of the following algorithms:
</p>

<dl>
<dt>slice</dt><dd><p>slice sampler of Neal (2003)</p>
</dd>
<dt>ars.quantile</dt><dd><p>adaptive rejection sampling of Gilks and
Wild (1992) with starting abscissae being quantiles of the
envelop at the previous iteration</p>
</dd>
<dt>ars.mode</dt><dd><p>adaptive rejection sampling of Gilks and Wild
(1992) with starting abscissae being the mode plus/minus 3
times estimated standard deviation of the full conditional
distribution</p>
</dd>
</dl>

<p>Default is <code>slice</code>.
</p>
</dd>
<dt>k.overrelax.a</dt><dd><p>if <code>type.update.a == "slice"</code> some
updates are overrelaxed. Then every <code>k.overrelax.a</code>th
iteration is not overrelaxed. Default is <code>k.overrelax.a =
	  1</code>, i.e. no overrelaxation</p>
</dd>
<dt>k.overrelax.sigma</dt><dd><p>G-spline basis standard deviations are
updated using the slice sampler of Neal (2003). At the same
time, overrelaxation can be used. Then every
k.overrelax.sigma th update is not overrelaxed. Default is
<code>k.overrelax.sigma = 1</code>, i.e. no overrelaxation</p>
</dd>
<dt>k.overrelax.scale</dt><dd><p>G-spline scales are
updated using the slice sampler of Neal (2003). At the same
time, overrelaxation can be used. Then every
k.overrelax.scale th update is not overrelaxed. Default is
<code>k.overrelax.scale = 1</code>, i.e. no overrelaxation</p>
</dd>
</dl>
  
</td></tr>  
<tr><td><code id="bayesBisurvreg_+3A_prior2">prior2</code></td>
<td>
<p>a list specifying the prior distribution of the G-spline
defining the distribution of the error term in the regression model
given by <code>formula2</code>. See <code>prior</code> argument of
<code><a href="#topic+bayesHistogram">bayesHistogram</a></code> function for more detail.  </p>
</td></tr>
<tr><td><code id="bayesBisurvreg_+3A_prior.beta2">prior.beta2</code></td>
<td>
<p>prior specification for the regression parameters
of time-to-event in the case of doubly censored data (related to
<code>formula2</code>).
This should be a list with the same structure as <code>prior.beta</code>.
</p>
</td></tr>  
<tr><td><code id="bayesBisurvreg_+3A_init2">init2</code></td>
<td>
<p>an optional list with initial values for the MCMC related
to the model given by <code>formula2</code>. The list has the same
structure as <code>init</code>.
</p>
</td></tr>
<tr><td><code id="bayesBisurvreg_+3A_mcmc.par2">mcmc.par2</code></td>
<td>
<p>a list specifying how some of the G-spline parameters
related to <code>formula2</code> are to be updated. The list has the same
structure as <code>mcmc.par</code>.
</p>
</td></tr>
<tr><td><code id="bayesBisurvreg_+3A_store">store</code></td>
<td>
<p>a list of logical values specifying which chains that are
not stored by default are to be stored. The list can have the
following components.
</p>

<dl>
<dt>a</dt><dd><p>if <code>TRUE</code> then all the transformed mixture weights
<code class="reqn">a_{k_1,\,k_2},</code>
<code class="reqn">k_1=-K_1,\dots,K_1,</code>
<code class="reqn">k_2=-K_2,\dots,K_2,</code>
related to the G-spline of <code>formula</code> are stored.</p>
</dd>
<dt>a2</dt><dd><p>if <code>TRUE</code> and there are doubly-censored data then all the transformed mixture weights
<code class="reqn">a_{k_1,\,k_2},</code>
<code class="reqn">k_1=-K_1,\dots,K_1,</code>
<code class="reqn">k_2=-K_2,\dots,K_2,</code>
related to the G-spline of <code>formula2</code> are stored.</p>
</dd>
<dt>y</dt><dd><p>if <code>TRUE</code> then augmented log-event times for all
observations related to the <code>formula</code> are stored.</p>
</dd>
<dt>y2</dt><dd><p>if <code>TRUE</code> then augmented log-event times for all
observations related to <code>formula2</code> are stored.</p>
</dd>
<dt>r</dt><dd><p>if <code>TRUE</code> then labels of mixture components for
residuals related to <code>formula</code> are stored.</p>
</dd>
<dt>r2</dt><dd><p>if <code>TRUE</code> then labels of mixture components for
residuals related to <code>formula2</code> are stored.</p>
</dd>
</dl>
  
</td></tr>  
<tr><td><code id="bayesBisurvreg_+3A_dir">dir</code></td>
<td>
<p>a string that specifies a directory where all sampled
values are to be stored.
</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A list of class <code>bayesBisurvreg</code> containing an information
concerning the initial values and prior choices.
</p>


<h3>Files created</h3>

  
<p>Additionally, the following files with sampled values
are stored in a directory specified by <code>dir</code> argument of this
function (some of them are created only on request, see <code>store</code>
parameter of this function).
</p>
<p>Headers are written to all files created by default and to files asked
by the user via the argument <code>store</code>. During the burn-in, only
every <code>nsimul$nwrite</code> value is written. After the burn-in, all
sampled values are written in files created by default and to files
asked by the user via the argument <code>store</code>. In the files for
which the corresponding <code>store</code> component is <code>FALSE</code>, every
<code>nsimul$nwrite</code> value is written during the whole MCMC (this
might be useful to restart the MCMC from some specific point).
</p>
<p>The following files are created:
</p>

<dl>
<dt>iteration.sim</dt><dd><p>one column labeled <code>iteration</code> with
indeces of MCMC iterations to which the stored sampled values
correspond.
</p>
</dd>
<dt>mixmoment.sim</dt><dd><p>columns labeled <code>k</code>, <code>Mean.1</code>, <code>Mean.2</code>,
<code>D.1.1</code>, <code>D.2.1</code>, <code>D.2.2</code>, where
</p>
<p><b>k</b> = number of mixture components that had probability
numerically higher than zero;
</p>
<p><b>Mean.1</b> =
<code class="reqn">\mbox{E}(\varepsilon_{i,1})</code>;
</p>
<p><b>Mean.2</b> =
<code class="reqn">\mbox{E}(\varepsilon_{i,2})</code>;
</p>
<p><b>D.1.1</b> =
<code class="reqn">\mbox{var}(\varepsilon_{i,1})</code>;
</p>
<p><b>D.2.1</b> =
<code class="reqn">\mbox{cov}(\varepsilon_{i,1},\,\varepsilon_{i,2})</code>;
</p>
<p><b>D.2.2</b> =
<code class="reqn">\mbox{var}(\varepsilon_{i,2})</code>;
</p>
<p>all related to the distribution of the error term from the model given by <code>formula</code>.
</p>
</dd>
<dt>mixmoment_2.sim</dt><dd><p>in the case of doubly-censored data, the same
structure as <code>mixmoment.sim</code>, however related to the model
given by <code>formula2</code>.      
</p>
</dd>
<dt>mweight.sim</dt><dd><p>sampled mixture weights
<code class="reqn">w_{k_1,\,k_2}</code> of mixture components that had
probabilities numerically higher than zero. Related to the model
given by <code>formula</code>.
</p>
</dd>
<dt>mweight_2.sim</dt><dd><p>in the case of doubly-censored data, the same
structure as <code>mweight.sim</code>, however related to the model
given by <code>formula2</code>. 
</p>
</dd>
<dt>mmean.sim</dt><dd><p>indeces <code class="reqn">k_1,\;k_2,</code>
<code class="reqn">k_1 \in\{-K_1, \dots, K_1\},</code>
<code class="reqn">k_2 \in\{-K_2, \dots, K_2\}</code>
of mixture components that had probabilities numerically higher
than zero. It corresponds to the weights in
<code>mweight.sim</code>. Related to the model given by <code>formula</code>.
</p>
</dd>
<dt>mmean_2.sim</dt><dd><p>in the case of doubly-censored data, the same
structure as <code>mmean.sim</code>, however related to the model
given by <code>formula2</code>. 
</p>
</dd>
<dt>gspline.sim</dt><dd><p>characteristics of the sampled G-spline
(distribution of
<code class="reqn">(\varepsilon_{i,1},\,\varepsilon_{i,2})'</code>) related to the model given by
<code>formula</code>. This file together with <code>mixmoment.sim</code>,
<code>mweight.sim</code> and <code>mmean.sim</code> can be used to reconstruct
the G-spline in each MCMC iteration.
</p>
<p>The file has columns labeled <code>gamma1</code>,
<code>gamma2</code>, <code>sigma1</code>, <code>sigma2</code>, <code>delta1</code>,
<code>delta2</code>, <code>intercept1</code>, <code>intercept2</code>,
<code>scale1</code>, <code>scale2</code>. The meaning of the values in these
columns is the following:
</p>
<p><b>gamma1</b> = the middle knot <code class="reqn">\gamma_1</code> in the
first dimension. If &lsquo;Specification&rsquo; is 2, this column
usually contains zeros;
</p>
<p><b>gamma2</b> = the middle knot <code class="reqn">\gamma_2</code> in the
second dimension. If &lsquo;Specification&rsquo; is 2, this column
usually contains zeros;
</p>
<p><b>sigma1</b> = basis standard deviation <code class="reqn">\sigma_1</code>
of the G-spline in the first dimension. This column contains
a fixed value if &lsquo;Specification&rsquo; is 2;
</p>
<p><b>sigma2</b> = basis standard deviation <code class="reqn">\sigma_2</code>
of the G-spline in the second dimension. This column contains
a fixed value if &lsquo;Specification&rsquo; is 2;
</p>
<p><b>delta1</b> = distance <code class="reqn">delta_1</code> between the two knots of the G-spline in
the first dimension. This column contains
a fixed value if &lsquo;Specification&rsquo; is 2;
</p>
<p><b>delta2</b> = distance <code class="reqn">\delta_2</code> between the two knots of the G-spline in
the second dimension. This column contains a fixed value if
&lsquo;Specification&rsquo; is 2;
</p>
<p><b>intercept1</b> = the intercept term <code class="reqn">\alpha_1</code> of
the G-spline in the first dimension. If &lsquo;Specification&rsquo; is 1, this column
usually contains zeros;
</p>
<p><b>intercept2</b> = the intercept term <code class="reqn">\alpha_2</code> of
the G-spline in the second dimension. If &lsquo;Specification&rsquo; is 1, this column
usually contains zeros;
</p>
<p><b>scale1</b> = the scale parameter <code class="reqn">\tau_1</code> of the
G-spline in the first dimension. If &lsquo;Specification&rsquo; is 1, this column
usually contains ones;
</p>
<p><b>scale2</b> = the scale parameter <code class="reqn">\tau_2</code> of the
G-spline in the second dimension. &lsquo;Specification&rsquo; is 1, this column
usually contains ones.      
</p>
</dd>
<dt>gspline_2.sim</dt><dd><p>in the case of doubly-censored data, the same
structure as <code>gspline.sim</code>, however related to the model
given by <code>formula2</code>. 
</p>
</dd>
<dt>mlogweight.sim</dt><dd><p>fully created only if <code>store$a = TRUE</code>. The
file contains the transformed weights
<code class="reqn">a_{k_1,\,k_2},</code>
<code class="reqn">k_1=-K_1,\dots,K_1,</code>
<code class="reqn">k_2=-K_2,\dots,K_2</code> of all mixture
components, i.e. also of components that had numerically zero
probabilities.
This file is related to the model given by <code>formula</code>.
</p>
</dd>
<dt>mlogweight_2.sim</dt><dd><p>fully created only if <code>store$a2 =
      TRUE</code> and in the case of doubly-censored data, the same
structure as <code>mlogweight.sim</code>, however related to the model
given by <code>formula2</code>. 
</p>
</dd>
<dt>r.sim</dt><dd><p>fully created only if <code>store$r = TRUE</code>. The file
contains the labels of the mixture components into which the
residuals are intrinsically assigned. Instead of double indeces
<code class="reqn">(k_1,\,k_2)</code>, values from 1 to <code class="reqn">(2\,K_1+1)\times
	(2\,K_2+1)</code> are stored here. Function
<code><a href="#topic+vecr2matr">vecr2matr</a></code> can be used to transform it back to double
indeces.
</p>
</dd>
<dt>r_2.sim</dt><dd><p>fully created only if <code>store$r2 =
      TRUE</code> and in the case of doubly-censored data, the same
structure as <code>r.sim</code>, however related to the model
given by <code>formula2</code>. 
</p>
</dd>
<dt>lambda.sim</dt><dd><p>either one column labeled <code>lambda</code> or two
columns labeled <code>lambda1</code> and <code>lambda2</code>. These are the
values of the smoothing parameter(s) <code class="reqn">\lambda</code>
(hyperparameters of the prior distribution of the transformed
mixture weights <code class="reqn">a_{k_1,\,k_2}</code>). This file is
related to the model given by <code>formula</code>.
</p>
</dd>
<dt>lambda_2.sim</dt><dd><p>in the case of doubly-censored data, the same
structure as <code>lambda.sim</code>, however related to the model
given by <code>formula2</code>. 
</p>
</dd>
<dt>beta.sim</dt><dd><p>sampled values of the regression parameters
<code class="reqn">\beta</code> related to the model given by
<code>formula</code>. The columns are labeled according to the
<code>colnames</code> of the design matrix.
</p>
</dd>
<dt>beta_2.sim</dt><dd><p>in the case of doubly-censored data, the same
structure as <code>beta.sim</code>, however related to the model
given by <code>formula2</code>. 
</p>
</dd>
<dt>Y.sim</dt><dd><p>fully created only if <code>store$y = TRUE</code>. It
contains sampled (augmented) log-event times for all observations
in the data set.
</p>
</dd>
<dt>Y_2.sim</dt><dd><p>fully created only if <code>store$y2 =
      TRUE</code> and in the case of doubly-censored data, the same
structure as <code>Y.sim</code>, however related to the model
given by <code>formula2</code>. 
</p>
</dd>
<dt>logposter.sim</dt><dd><p>columns labeled <code>loglik</code>, <code>penalty</code>
or <code>penalty1</code> and
<code>penalty2</code>, <code>logprw</code>. This file is related to the model
given by <code>formula</code>. The columns have the following meaning.
</p>
<p><b>loglik</b>
<code class="reqn">=</code> <code class="reqn">%
	-N\Bigl\{\log(2\pi) + \log(\sigma_1) + \log(\sigma_2)\Bigr\}-
          0.5\sum_{i=1}^N\Bigl\{
	  (\sigma_1^2\,\tau_1^2)^{-1}\; (y_{i,1} - x_{i,1}'\beta - \alpha_1 - \tau_1\mu_{1,\,r_{i,1}})^2 +
	  (\sigma_2^2\,\tau_2^2)^{-1}\; (y_{i,2} - x_{i,2}'\beta - \alpha_2 - \tau_2\mu_{2,\,r_{i,2}})^2
          \Bigr\}
      </code>
</p>
<p>where <code class="reqn">y_{i,l}</code> denotes (augmented) <em>(i,l)</em>th
true log-event time. In other words, <code>loglik</code> is equal to the
conditional log-density
<code class="reqn">\sum_{i=1}^N\,\log\Bigl\{p\bigl((y_{i,1},\,y_{i,2})\;\big|\;r_{i},\,\beta,\,\mbox{G-spline}\bigr)\Bigr\};</code>
</p>
<p><b>penalty1:</b> If <code>prior$neighbor.system</code> = <code>"uniCAR"</code>:
the penalty term for the first dimension not multiplied by
<code>lambda1</code>;
</p>
<p><b>penalty2:</b> If <code>prior$neighbor.system</code> = <code>"uniCAR"</code>:
the penalty term for the second dimension not multiplied by
<code>lambda2</code>;
</p>
<p><b>penalty:</b> If <code>prior$neighbor.system</code> is different from <code>"uniCAR"</code>:
the penalty term not multiplied by <code>lambda</code>;
</p>
<p><b>logprw</b> <code class="reqn">=</code>
<code class="reqn">-2\,N\,\log\bigl\{\sum_{k_1}\sum_{k_2}a_{k_1,\,k_2}\bigr\} +
	\sum_{k_1}\sum_{k_2}N_{k_1,\,k_2}\,a_{k_1,\,k_2},</code>
where <code class="reqn">N_{k_1,\,k_2}</code> is the number of residuals
assigned intrinsincally to the <code class="reqn">(k_1,\,k_2)</code>th
mixture component.
</p>
<p>In other words, <code>logprw</code> is equal to the conditional
log-density
<code class="reqn">\sum_{i=1}^N \log\bigl\{p(r_i\;|\;\mbox{G-spline
	  weights})\bigr\}.</code>
</p>
</dd>
<dt>logposter_2.sim</dt><dd><p>in the case of doubly-censored data, the same
structure as <code>lambda.sim</code>, however related to the model
given by <code>formula2</code>. 
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Gilks, W. R. and Wild, P. (1992).
Adaptive rejection sampling for Gibbs sampling.
<em>Applied Statistics,</em> <b>41</b>, 337 - 348.
</p>
<p>Komárek, A. (2006).
<em>Accelerated Failure Time Models for Multivariate
Interval-Censored Data with Flexible Distributional Assumptions</em>.
PhD. Thesis, Katholieke Universiteit Leuven, Faculteit Wetenschappen.
</p>
<p>Komárek, A. and Lesaffre, E. (2006).
Bayesian semi-parametric accelerated failure time model for paired
doubly interval-censored data.
<em>Statistical Modelling</em>, <b>6</b>, 3 - 22.
</p>
<p>Neal, R. M. (2003).
Slice sampling (with Discussion).
<em>The Annals of Statistics,</em> <b>31</b>, 705 - 767.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the description of R commands for
## the population averaged AFT model
## with the Signal Tandmobiel data,
## analysis described in Komarek and Lesaffre (2006),
##
## R commands available in the documentation
## directory of this package as
## - see ex-tandmobPA.R and
##   https://www2.karlin.mff.cuni.cz/ komarek/software/bayesSurv/ex-tandmobPA.pdf
##
</code></pre>

<hr>
<h2 id='bayesBisurvreg.help'>
Helping function for Bayesian regression with smoothed bivariate
densities as the error term,
based on possibly censored data
</h2><span id='topic+bayesBisurvreg.help'></span><span id='topic+bayesBisurvreg.checkStore'></span><span id='topic+bayesBisurvreg.priorInit'></span><span id='topic+bayesBisurvreg.priorBeta'></span><span id='topic+bayesBisurvreg.writeHeaders'></span>

<h3>Description</h3>

<p>These functions are not to be called by ordinary users.
</p>
<p>These are just sub-parts of &lsquo;bayesBisurvreg&rsquo; function to make it more
readable for the programmer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesBisurvreg.checkStore(store)

bayesBisurvreg.priorInit(dim, prior, init, design, mcmc.par,
                              prior2, init2, design2, mcmc.par2,
                         doubly)

bayesBisurvreg.priorBeta(prior.beta, init, design)

bayesBisurvreg.writeHeaders(dir, dim, nP, doubly, prior.init, store,
                            design, design2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesBisurvreg.help_+3A_store">store</code></td>
<td>
<p>a list as required by the argument <code>store</code> of the
function <code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code> or <code><a href="#topic+bayesBisurvreg.checkStore">bayesBisurvreg.checkStore</a></code></p>
</td></tr>
<tr><td><code id="bayesBisurvreg.help_+3A_dim">dim</code></td>
<td>
<p>dimension of the response, 1 or 2</p>
</td></tr>    
<tr><td><code id="bayesBisurvreg.help_+3A_prior">prior</code></td>
<td>
<p>a list as required by the argument <code>prior</code> of the
function <code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code></p>
</td></tr>
<tr><td><code id="bayesBisurvreg.help_+3A_prior2">prior2</code></td>
<td>
<p>a list as required by the argument <code>prior2</code> of the
function <code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code></p>
</td></tr>
<tr><td><code id="bayesBisurvreg.help_+3A_init">init</code></td>
<td>
<p>a list as required by the argument <code>init</code> of the
function <code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code></p>
</td></tr>
<tr><td><code id="bayesBisurvreg.help_+3A_init2">init2</code></td>
<td>
<p>a list as required by the argument <code>init2</code> of the
function <code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code></p>
</td></tr>
<tr><td><code id="bayesBisurvreg.help_+3A_mcmc.par">mcmc.par</code></td>
<td>
<p>a list as required by the argument <code>mcmc.par</code> of the
function <code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code></p>
</td></tr>
<tr><td><code id="bayesBisurvreg.help_+3A_mcmc.par2">mcmc.par2</code></td>
<td>
<p>a list as required by the argument <code>mcmc.par2</code> of the
function <code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code></p>
</td></tr>
<tr><td><code id="bayesBisurvreg.help_+3A_design">design</code></td>
<td>
<p>an object as returned by the function
<code><a href="#topic+bayessurvreg.design">bayessurvreg.design</a></code> related to either the onset time
if doubly censored observations or to the event time. Remark:
<code>design$Y</code> contains original times and NOT their logarithmic transformations.</p>
</td></tr>
<tr><td><code id="bayesBisurvreg.help_+3A_design2">design2</code></td>
<td>
<p>an object as returned by the function
<code><a href="#topic+bayessurvreg.design">bayessurvreg.design</a></code> related to time-to-event
if doubly censored observations. Remark:
<code>design2$Y</code> contains original times and NOT their logarithmic transformations.</p>
</td></tr>    
<tr><td><code id="bayesBisurvreg.help_+3A_doubly">doubly</code></td>
<td>
<p>logical indicating whether the response is doubly
censored or not</p>
</td></tr>  
<tr><td><code id="bayesBisurvreg.help_+3A_prior.beta">prior.beta</code></td>
<td>
<p>a list as required by the argument <code>prior.beta</code> or
<code>prior.beta2</code> of the function <code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code></p>
</td></tr>
<tr><td><code id="bayesBisurvreg.help_+3A_dir">dir</code></td>
<td>
<p>path to the directory where the sampled values are to be stored</p>
</td></tr>
<tr><td><code id="bayesBisurvreg.help_+3A_np">nP</code></td>
<td>
<p>sample size - number of observations if the univariate model
is fitted, number of bivariate observational vectors if the
bivariate model is fitted</p>
</td></tr>
<tr><td><code id="bayesBisurvreg.help_+3A_prior.init">prior.init</code></td>
<td>
<p>a list as returned by the function
<code><a href="#topic+bayesBisurvreg.priorInit">bayesBisurvreg.priorInit</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Some lists.
</p>


<h3>Value for bayesBisurvreg.priorInit</h3>

<p>A~list with the following components:
</p>

<dl>
<dt>Gparmi</dt><dd><p>integer arguments for the G-spline constructor in the
C++ code related to the onset/event time</p>
</dd>
<dt>Gparmd</dt><dd><p>double arguments for the G-spline constructor in the
C++ code related to the onset/event time</p>
</dd>
<dt>y</dt><dd><p>vector of initial values for the log(onset time)/log(event
time), sorted as
<code class="reqn">y_1[1], y_1[2], \dots, y_n[1], y_n[2]</code> in the case of bivariate response with sample size
equal to <code class="reqn">n</code></p>
</dd>
<dt>r</dt><dd><p>initial component labels (vector of size <code class="reqn">n</code>) taking
values from 1 to the total length of the G-spline related to the
onset/event time</p>
</dd>
<dt>Gparmi2</dt><dd><p>integer arguments for the G-spline constructor in the
C++ code related to time-to-event in the case of doubly censoring</p>
</dd>
<dt>Gparmd2</dt><dd><p>double arguments for the G-spline constructor in the
C++ code related to time-to-event in the case of doubly censoring</p>
</dd>
<dt>y2</dt><dd><p>vector of initial values for the time-to-event in the case of doubly censoring
sorted as
</p>
<p style="text-align: center;"><code class="reqn">y_1[1], y_1[2], \dots, y_n[1], y_n[2]</code>
</p>
<p> in the case of bivariate response with sample size
equal to <code class="reqn">n</code></p>
</dd>
<dt>r2</dt><dd><p>initial component labels (vector of size <code class="reqn">n</code>) taking
values from 1 to the total length of the G-spline related to
time-to-event in the case of doubly censoring</p>
</dd>
<dt>iter</dt><dd><p>index of the nullth iteration</p>
</dd>
<dt>specification</dt><dd><p>2 component vector (one component for onset, one
for time-to-event), specification of the G-spline model (1 or 2), see
<code><a href="#topic+bayesHistogram">bayesHistogram</a></code> for more detail</p>
</dd>
<dt>y.left</dt><dd><p>lower limit of the log-response (or exact/right/left
censored observation) as required by the C++ function
<code>bayesBisurvreg</code>, related to the onset time in the case of
doubly censoring and to the event time otherwise</p>
</dd>
<dt>y.right</dt><dd><p>upper limit of the log-response as required by the C++ function
<code>bayesBisurvreg</code>, related to the onset time in the case of
doubly censoring and to the event time otherwise</p>
</dd>
<dt>status</dt><dd><p>status vector as required by the C++ function
<code>bayesBisurvreg</code> related to the onset time in the case of
doubly censoring and to the event time otherwise</p>
</dd>
<dt>t2.left</dt><dd><p>lower limit of the response as required by the C++
function <code>bayesBisurvreg</code>, related to time-to-event in the
case of doubly censoring, equal to 0 if there is no doubly-censoring</p>
</dd>
<dt>t2.right</dt><dd><p>upper limit of the response as required by the C++
function <code>bayesBisurvreg</code>, related to time-to-event in the
case of doubly censoring, equal to 0 if there is no doubly-censoring</p>
</dd>
<dt>status2</dt><dd><p>status vector related to time-to-event in the case of
doubly censoring, equal to 0 otherwise.</p>
</dd>
</dl>

<p>and the following attributes:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>init</b>        </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>prior</b>       </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>mcmc.par</b>    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>init2</b>       </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>prior2</b>      </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>mcmc.par2</b>   </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>
    


<h3>Value for bayesBisurvreg.priorBeta</h3>

<p>A list with the following components:
</p>

<dl>
<dt>parmI</dt><dd><p>integer arguments for C++ <code>classBetaGamma</code> constructor</p>
</dd>
<dt>parmD</dt><dd><p>double arguments for C++ <code>classBetaGamma</code> constructor</p>
</dd>
</dl>

<p>and the following attributes:
</p>

<dl>
<dt>init</dt><dd><p>a~vector with initial values of the beta parameter,
equal to <code>numeric(0)</code> if there are no regressors</p>
</dd>
<dt>prior.beta</dt><dd><p>a~list with components <code>mean.prior</code> and
<code>var.prior</code> containing vectors with the prior mean and prior
variance of the <code>beta</code> parameters</p>
</dd>
</dl>
    


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>

<hr>
<h2 id='bayesDensity'>
Summary for the density estimate based on the mixture Bayesian AFT model.
</h2><span id='topic+bayesDensity'></span><span id='topic+C_bayesDensity'></span>

<h3>Description</h3>

<p>Function to summarize the results obtained using
<code><a href="#topic+bayessurvreg1">bayessurvreg1</a></code> function.
</p>
<p>Compute the conditional (given the number of mixture components) and
unconditional estimate of the density function based on the values
sampled using the reversible jumps MCMC (MCMC average evaluated in a
grid of values).
</p>
<p>Give also the values of each sampled density
evaluated at that grid (returned as the attribute of the resulting
object). Methods for printing and plotting are also provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesDensity(dir, stgrid, centgrid, grid, n.grid = 100,
    skip = 0, by = 1, last.iter,
    standard = TRUE, center = TRUE, unstandard = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesDensity_+3A_dir">dir</code></td>
<td>
<p>directory where to search for files &lsquo;mixmoment.sim&rsquo;,
&lsquo;mweight.sim&rsquo;, mmean.sim', &lsquo;mvariance.sim&rsquo; with the McMC sample.</p>
</td></tr>
<tr><td><code id="bayesDensity_+3A_stgrid">stgrid</code></td>
<td>
<p>grid of values at which the sampled standardized
densities are to be evaluated. If <code>missing</code>, the grid is
automatically computed.</p>
</td></tr>
<tr><td><code id="bayesDensity_+3A_centgrid">centgrid</code></td>
<td>
<p>grid of values at which the sampled centered (but not
scaled) densities are to be evaluated. If <code>missing</code>. the grid
is automatically computed.</p>
</td></tr>
<tr><td><code id="bayesDensity_+3A_grid">grid</code></td>
<td>
<p>grid of values at which the sampled densities are to be
evaluated. If <code>missing</code>,
the grid is guessed from the first 20 sampled mixtures as the sequence starting with the minimal
sampled mixture mean minus 3 standard deviations of the appropriate mixture
component, ending with the maximal sampled mixture mean plus 3
standard deviations of the appropriate mixture
component, of the length given by <code>n.grid</code>.</p>
</td></tr>
<tr><td><code id="bayesDensity_+3A_n.grid">n.grid</code></td>
<td>
<p>the length of the grid if <code>grid = NULL</code>.</p>
</td></tr>
<tr><td><code id="bayesDensity_+3A_skip">skip</code></td>
<td>
<p>number of rows that should be skipped at the beginning of
each *.sim file with the stored sample.</p>
</td></tr>
<tr><td><code id="bayesDensity_+3A_by">by</code></td>
<td>
<p>additional thinning of the sample.</p>
</td></tr>
<tr><td><code id="bayesDensity_+3A_last.iter">last.iter</code></td>
<td>
<p>index of the last row from *.sim files that should be
used. If not specified than it is set to the maximum available
determined according to the file <code>mixmoment.sim</code>.</p>
</td></tr>
<tr><td><code id="bayesDensity_+3A_standard">standard</code></td>
<td>
<p>if <code>TRUE</code> then also standardized (zero mean,
unit variance) sampled densities are evaluated.</p>
</td></tr>
<tr><td><code id="bayesDensity_+3A_center">center</code></td>
<td>
<p>if <code>TRUE</code> then also centered (zero mean) sampled
densities are evaluated.</p>
</td></tr>
<tr><td><code id="bayesDensity_+3A_unstandard">unstandard</code></td>
<td>
<p>of <code>TRUE</code> then also original (unstandardized)
sampled densities are evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>bayesDensity</code> is returned. This object is a
list and has potentially three components: <code>standard</code>,
<code>center</code>  and
<code>unstandard</code>. Each of these three components is a <code>data.frame</code>
with as many rows as number of grid points at which the density was
evaluated and with columns called &lsquo;grid&rsquo;, &lsquo;unconditional&rsquo; and &lsquo;k = 1&rsquo;,
..., &lsquo;k = k.max&rsquo; giving a predictive errr density, either averaged
over all sampled <code class="reqn">k</code>s (unconditional) or averaged over a
psecific number of mixture components.
</p>
<p>Additionally, the object of class <code>bayesDensity</code> has three
attributes:
</p>
<table>
<tr><td><code>sample.size</code></td>
<td>
<p>a vector of length <code>1 + kmax</code> giving the
frequency of each <code class="reqn">k</code> in the sample.</p>
</td></tr>
<tr><td><code>moments</code></td>
<td>
<p>a <code>data.frame</code> with columns called &lsquo;intercept&rsquo;
and &lsquo;scale&rsquo; giving the mean and variance of the sampled mixture at
each iteration of the McMC.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>a <code>data.frame</code> with one column called &lsquo;k&rsquo; giving
number of mixture components at each iteration.</p>
</td></tr>
</table>
<p>There exist methods to print and plot objects of the class <code>bayesDensity</code>.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Komárek, A. (2006).
<em>Accelerated Failure Time Models for Multivariate
Interval-Censored Data with Flexible Distributional Assumptions</em>.
PhD. Thesis, Katholieke Universiteit Leuven, Faculteit Wetenschappen.
</p>
<p>Komárek, A. and Lesaffre, E. (2007).
Bayesian accelerated failure time model for correlated interval-censored data
with a normal mixture as an error distribution.
<em>Statistica Sinica</em>, <b>17</b>, 549&ndash;569.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the description of R commands for
## the models described in
## Komarek (2006),
## Komarek and Lesaffre (2007),
## 
## R commands available
## in the documentation
## directory of this package
## - ex-cgd.R and
##   https://www2.karlin.mff.cuni.cz/~komarek/software/bayesSurv/ex-cgd.pdf
##
## - ex-tandmobMixture.R and
##   https://www2.karlin.mff.cuni.cz/~komarek/software/bayesSurv/ex-tandmobMixture.pdf
## 
</code></pre>

<hr>
<h2 id='bayesGspline'>
Summary for the density estimate based on the model with Bayesian
G-splines.
</h2><span id='topic+bayesGspline'></span><span id='topic+C_bayesGspline'></span>

<h3>Description</h3>

<p>Compute the estimate of the density function based on the values
sampled using the MCMC (MCMC average evaluated in a
grid of values) in a model where density is specified as
a Bayesian G-spline.
</p>
<p>This function serves to summarize the MCMC chains related to the distributional parts 
of the considered models obtained using the functions:
<code><a href="#topic+bayesHistogram">bayesHistogram</a></code>,
<code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code>, <code><a href="#topic+bayessurvreg2">bayessurvreg2</a></code>, <code><a href="#topic+bayessurvreg3">bayessurvreg3</a></code>.
</p>
<p>If asked, this function returns also the values of the G-spline
evaluated in a grid at each iteration of MCMC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesGspline(dir, extens="", extens.adjust="_b",
   grid1, grid2, skip = 0, by = 1, last.iter, nwrite,
   only.aver = TRUE, standard = FALSE, version = 0)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="bayesGspline_+3A_dir">dir</code></td>
<td>
<p>directory where to search for files (&lsquo;mixmoment.sim&rsquo;,
&lsquo;mweight.sim&rsquo;, &lsquo;mmean.sim&rsquo;, &lsquo;gspline.sim&rsquo;) with the MCMC
sample.</p>
</td></tr>
<tr><td><code id="bayesGspline_+3A_extens">extens</code></td>
<td>
<p>an extension used to distinguish different sampled
G-splines if more G-splines were used in one simulation (e.g. with
doubly-censored data or in the model where both the error term and the
random intercept were defined as the G-splines). According to which
<code>bayes*survreg*</code> function was used, specify the argument
<code>extens</code> in the following way.
</p>

<dl>
<dt>bayesHistogram:</dt><dd>
<p>always <code>extens = ""</code>
</p>
</dd>
<dt>bayesBisurvreg:</dt><dd>

<ul>
<li><p> to compute the bivariate distribution of the <em>error</em> term for
the <em>onset</em> time: <code>extens = ""</code>;
</p>
</li>
<li><p> to compute the bivariate distribution of the <em>error</em> term for
the <em>event</em> time if there was doubly-censoring:
<code>extens = "_2"</code>;
</p>
</li></ul>
	 
</dd>
<dt>bayessurvreg2:</dt><dd>

<ul>
<li><p> to compute the distribution of the <em>error</em> term for
the <em>onset</em> time: <code>extens = ""</code>;
</p>
</li>
<li><p> to compute the distribution of the <em>error</em> term for
the <em>event</em> time if there was doubly-censoring:
<code>extens = "_2"</code>;
</p>
</li></ul>
	   
</dd>
<dt>bayessurvreg3:</dt><dd>

<ul>
<li><p> to compute the distribution of the <em>error</em> term for
the <em>onset</em> time: <code>extens = ""</code>;
</p>
</li>
<li><p> to compute the distribution of the <em>error</em> term for
the <em>event</em> time if there was doubly-censoring:
<code>extens = "_2"</code>;
</p>
</li>
<li><p> to compute the distribution of the <em>random intercept</em> for the
<em>onset</em> time: <code>extens = "_b"</code>;
</p>
</li>
<li><p> to compute the distribution of the <em>random intercept</em> term for
the <em>event</em> time if there was doubly-censoring:
<code>extens = "_b2"</code>;      
</p>
</li></ul>

</dd>  
</dl>

</td></tr>
<tr><td><code id="bayesGspline_+3A_extens.adjust">extens.adjust</code></td>
<td>
<p>this argument is applicable for the situation when
the MCMC chains were created using the function
<code><a href="#topic+bayessurvreg3">bayessurvreg3</a></code>, and when both the distribution of the
error term and the random intercept was specified as the G-spline.
</p>
<p>In that case the location of the error term and the random intercept
are separately not identifiable. Only the location of the sum
<code class="reqn">\varepsilon + b</code> can be estimated. For this reason,
the function <code>bayesGspline</code> always centers the distribution of
the random intercept to have a zero mean and adds its original mean to
the mean of the distribution of the error term.
</p>
<p>Argument <code>extens.adjust</code> is used to match correctly the files
containing the G-spline of the random intercept corresponding to the
particular error term. 
</p>
<p>The following values of <code>extens.adjust</code> should be used in the
following situations:
</p>

<ul>
<li><p> if there are no doubly-censored data or if we are computing
the distribution of the error term/random intercept from the model
for the <em>onset</em> time then
</p>

<table>
<tr>
 <td style="text-align: center;">
      <code>extens.adjust = "_b"</code>
    </td>
</tr>

</table>

</li>
<li><p> if there are doubly-censored data and we are computing the
distribution of the error term/random intercept from the model for
the <em>event</em> time then
</p>

<table>
<tr>
 <td style="text-align: center;">
      <code>extens.adjust = "_b2"</code>
    </td>
</tr>

</table>

</li></ul>
  
</td></tr>  
<tr><td><code id="bayesGspline_+3A_grid1">grid1</code></td>
<td>
<p>grid of values from the first dimension at which the sampled 
densities are to be evaluated.</p>
</td></tr>
<tr><td><code id="bayesGspline_+3A_grid2">grid2</code></td>
<td>
<p>grid of values from the second dimension (if the G-spline
was bivariate) at which the sampled densities are to be
evaluated. This item is <code>missing</code> if the G-spline is univariate.</p>
</td></tr>
<tr><td><code id="bayesGspline_+3A_skip">skip</code></td>
<td>
<p>number of rows that should be skipped at the beginning of
each *.sim file with the stored sample.</p>
</td></tr>
<tr><td><code id="bayesGspline_+3A_by">by</code></td>
<td>
<p>additional thinning of the sample.</p>
</td></tr>
<tr><td><code id="bayesGspline_+3A_last.iter">last.iter</code></td>
<td>
<p>index of the last row from *.sim files that should be
used. If not specified than it is set to the maximum available
determined according to the file <code>mixmoment.sim</code>.</p>
</td></tr>
<tr><td><code id="bayesGspline_+3A_nwrite">nwrite</code></td>
<td>
<p>frequency with which is the user informed about the
progress of computation (every <code>nwrite</code>th iteration count of
iterations change).</p>
</td></tr>
<tr><td><code id="bayesGspline_+3A_only.aver">only.aver</code></td>
<td>
<p><code>TRUE/FALSE</code>, if <code>TRUE</code> only MCMC average is
returned otherwise also values of the G-spline at each iteration are
returned (which might ask for quite lots of memory).</p>
</td></tr>
<tr><td><code id="bayesGspline_+3A_standard">standard</code></td>
<td>
<p><code>TRUE/FALSE</code>, if <code>TRUE</code>, each G-spline is
standardized to have zero mean and unit variance. Only applicable if
<code>version</code> = 30 or 31, otherwise <code>standard</code> is always set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bayesGspline_+3A_version">version</code></td>
<td>

<p>this argument indicates by which <code>bayes*survreg*</code> function the
chains used by <code>bayesGspline</code> were created. Use the following:
</p>

<dl>
<dt>bayesHistogram:</dt><dd><p><code>version = 0</code>;</p>
</dd>
<dt>bayesBisurvreg:</dt><dd><p><code>version = 0</code>;</p>
</dd>
<dt>bayessurvreg2:</dt><dd><p><code>version = 0</code>;</p>
</dd>
<dt>bayessurvreg3:</dt><dd>
<p><code>version = 30 </code> or <code> 31</code>.
</p>
<p>Use
<code>version = 30</code> if you want to compute the density of the
<em>error</em> term.
</p>
<p>Use
<code>version = 31</code> if you want to compute the density of the
<em>random intercept</em>.
</p>
<p>Use
<code>version = 32</code> if you want to compute the density of the
<em>error</em> term in the model with doubly-interval-censored data
and bivariate normal distribution for random intercepts in the
onset and time-to-event parts of the model OR if you have just
interval-censored data and a simple AFT model without random
effects and you want to compute the density of the <em>error</em>
term of the model.
</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>bayesGspline</code> is returned. This object is a
list with components
<code>grid</code>, <code>average</code> for the univariate G-spline and
components <code>grid1</code>, <code>grid2</code>, <code>average</code> for the bivariate G-spline.
</p>
<table>
<tr><td><code>grid</code></td>
<td>
<p>this is a grid of values (vector) at which the McMC average of the
G-spline was computed.</p>
</td></tr>
<tr><td><code>average</code></td>
<td>
<p>these are McMC averages of the G-spline (vector) evaluated in
<code>grid</code>.</p>
</td></tr>
<tr><td><code>grid1</code></td>
<td>
<p>this is a grid of values (vector) for the first dimension
at which the McMC average of the G-spline was computed.</p>
</td></tr>
<tr><td><code>grid2</code></td>
<td>
<p>this is a grid of values (vector) for the second dimension
at which the McMC average of the G-spline was computed.</p>
</td></tr>
<tr><td><code>average</code></td>
<td>
<p>this is a matrix <code>length(grid1)</code> times
<code>length(grid2)</code> with McMC averages of the G-spline evaluated in
</p>

<table>
<tr>
 <td style="text-align: left;">
      x1 = </td><td style="text-align: center;"> ( grid1 </td><td style="text-align: center;"> ... </td><td style="text-align: center;"> grid1 ) </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

<p>and
</p>

<table>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: right;"> (</td><td style="text-align: center;"> grid2  </td><td style="text-align: left;"> ) </td>
</tr>
<tr>
 <td style="text-align: left;">
      x2 = </td><td style="text-align: right;"> (</td><td style="text-align: center;"> ...    </td><td style="text-align: left;"> )  </td>
</tr>
<tr>
 <td style="text-align: left;">
	   </td><td style="text-align: right;"> (</td><td style="text-align: center;"> grid2  </td><td style="text-align: left;"> ) </td>
</tr>
<tr>
 <td style="text-align: left;">   
    </td>
</tr>

</table>

</td></tr>
</table>
<p>There exists a method to plot objects of the class <code>bayesGspline</code>.
</p>


<h3>Attributes</h3>

<p>Additionally, the object of class <code>bayesGspline</code> has the following
attributes:
</p>

<dl>
<dt><code>sample.size</code></dt><dd><p>a length of the McMC sample used to compute the McMC average.
</p>
</dd>
<dt><code>sample</code></dt><dd><p>G-spline evaluated in a grid of values. This attribute
is present only if <code>only.aver = FALSE</code>.
</p>
<p>For a univariate G-spline this is a matrix with <code>sample.size</code> columns and
length(grid1) rows.
</p>
<p>For a bivariate G-spline this is a matrix
with <code>sample.size</code> columns and
length(grid1)*length(grid2) rows.
</p>
</dd>
</dl>
    


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Komárek, A. (2006).
<em>Accelerated Failure Time Models for Multivariate
Interval-Censored Data with Flexible Distributional Assumptions</em>.
PhD. Thesis, Katholieke Universiteit Leuven, Faculteit Wetenschappen.
</p>
<p>Komárek, A. and Lesaffre, E. (2006).
Bayesian semi-parametric accelerated failurew time model for paired
doubly interval-censored data.
<em>Statistical Modelling</em>, <b>6</b>, 3&ndash;22.
</p>
<p>Komárek, A. and Lesaffre, E. (2008).
Bayesian accelerated failure time model with multivariate doubly-interval-censored data
and flexible distributional assumptions.
<em>Journal of the American Statistical Association</em>, <b>103</b>, 523&ndash;533.
</p>
<p>Komárek, A., Lesaffre, E., and Legrand, C. (2007).
Baseline and treatment effect heterogeneity for survival
times between centers using a random effects accelerated failure time
model with flexible error distribution.
<em>Statistics in Medicine,</em> <b>26</b>, 5457&ndash;5472.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the description of R commands for
## the models described in
## Komarek (2006),
## Komarek and Lesaffre (2006),
## Komarek and Lesaffre (2008),
## Komarek, Lesaffre, and Legrand (2007).
## 
## R commands available
## in the documentation
## directory of this package
##  - ex-tandmobPA.R and
##    https://www2.karlin.mff.cuni.cz/~komarek/software/bayesSurv/ex-tandmobPA.pdf
##  - ex-tandmobCS.R and
##    https://www2.karlin.mff.cuni.cz/~komarek/software/bayesSurv/ex-tandmobCS.pdf
##  - ex-eortc.R and
##    https://www2.karlin.mff.cuni.cz/~komarek/software/bayesSurv/ex-eortc.pdf
##
</code></pre>

<hr>
<h2 id='bayesHistogram'>Smoothing of a uni- or bivariate histogram using Bayesian
G-splines</h2><span id='topic+bayesHistogram'></span><span id='topic+C_bayesHistogram'></span>

<h3>Description</h3>

<p>A function to estimate a density of a uni- or bivariate
(possibly censored) sample. The density is specified as a mixture of Bayesian G-splines
(normal densities with equidistant means and equal variances). This function performs an
MCMC sampling from the posterior distribution of unknown quantities in
the density specification. Other method functions are available to
visualize resulting density estimate.
</p>
<p>This function served as a basis for further developed
<code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code>, <code><a href="#topic+bayessurvreg2">bayessurvreg2</a></code> and
<code><a href="#topic+bayessurvreg3">bayessurvreg3</a></code> functions. However, in contrast to these
functions, <code>bayesHistogram</code> does not allow for doubly censoring.
</p>
<p><b>Bivariate case:</b>
</p>
<p>Let <code class="reqn">Y_{i,l},\; i=1,\dots,N,\; l=1,2</code> be
observations for the <code class="reqn">i</code>th cluster and the first and the second
unit (dimension). The bivariate observations
<code class="reqn">Y_i=(Y_{i,1},\,Y_{i,2})',\;i=1,\dots,N</code>
are assumed to be i.i.d. with a~bivariate density
<code class="reqn">g_{y}(y_1,\,y_2)</code>. This density is expressed as
a~mixture of Bayesian G-splines (normal densities with equidistant
means and constant variance matrices). We distinguish two,
theoretically equivalent, specifications.
</p>

<dl>
<dt>Specification 1</dt><dd>
<p style="text-align: center;"><code class="reqn">(Y_1,\,Y_2)' \sim
	\sum_{j_1=-K_1}^{K_1}\sum_{j_2=-K_2}^{K_2} w_{j_1,j_2} N_2(\mu_{(j_1,j_2)},\,\mbox{diag}(\sigma_1^2,\,\sigma_2^2))</code>
</p>

<p>where <code class="reqn">\sigma_1^2,\,\sigma_2^2</code> are
<b>unknown</b> basis variances and
<code class="reqn">\mu_{(j_1,j_2)} = (\mu_{1,j_1},\,\mu_{2,j_2})'</code>
is an~equidistant grid of knots symmetric around the
<b>unknown</b> point <code class="reqn">(\gamma_1,\,\gamma_2)'</code> 
and related to the unknown basis variances through the
relationship
</p>
<p style="text-align: center;"><code class="reqn">\mu_{1,j_1} = \gamma_1 + j_1\delta_1\sigma_1,\quad j_1=-K_1,\dots,K_1,</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu_{2,j_2} = \gamma_2 + j_2\delta_2\sigma_2,\quad j_2=-K_2,\dots,K_2,</code>
</p>

<p>where <code class="reqn">\delta_1,\,\delta_2</code> are fixed
constants, e.g. <code class="reqn">\delta_1=\delta_2=2/3</code>
(which has a~justification of being close to cubic B-splines).      
</p>
</dd>
<dt>Specification 2</dt><dd>
<p style="text-align: center;"><code class="reqn">(Y_1,\,Y_2)' \sim (\alpha_1,\,\alpha_2)'+ \bold{S}\,(Y_1,\,Y_2)'</code>
</p>

<p>where <code class="reqn">(\alpha_1,\,\alpha_2)'</code> is an
<b>unknown</b> intercept term and
<code class="reqn">\bold{S} \mbox{ is a diagonal matrix with } \tau_1 \mbox{ and }\tau_2 \mbox{ on a diagonal,}</code>
i.e. <code class="reqn">\tau_1,\,\tau_2</code> are <b>unknown</b> scale
parameters. <code class="reqn">(V_1,\,V_2)'</code> is then
standardized observational vector which is distributed according
to the bivariate normal mixture, i.e.
</p>
<p style="text-align: center;"><code class="reqn">(V_1,\,V_2)'\sim \sum_{j_1=-K_1}^{K_1}\sum_{j_2=-K_2}^{K_2}
	w_{j_1,j_2} N_2(\mu_{(j_1,j_2)},\,\mbox{diag}(\sigma_1^2, \sigma_2^2))</code>
</p>

<p>where <code class="reqn">\mu_{(j_1,j_2)} =
	(\mu_{1,j_1},\,\mu_{2,j_2})'</code> is an~equidistant grid of <b>fixed</b> knots (means), usually
symmetric about the <b>fixed</b> point <code class="reqn">(\gamma_1,\,\gamma_2)'=(0,
	0)'</code> and
<code class="reqn">\sigma_1^2,\,\sigma_2^2</code> are
<b>fixed</b> basis variances. Reasonable values for the numbers of grid
points <code class="reqn">K_1</code> and <code class="reqn">K_2</code> are
<code class="reqn">K_1=K_2=15</code> with the distance between the two
knots equal to <code class="reqn">\delta=0.3</code> and for the basis
variances
<code class="reqn">\sigma_1^2\sigma_2^2=0.2^2.</code>
</p>
</dd>
</dl>
  
<p><b>Univariate case:</b>
</p>
<p>It is a~direct simplification of the bivariate case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesHistogram(y1, y2,
   nsimul = list(niter = 10, nthin = 1, nburn = 0, nwrite = 10),
   prior, init = list(iter = 0),
   mcmc.par = list(type.update.a = "slice", k.overrelax.a = 1,
                   k.overrelax.sigma = 1, k.overrelax.scale = 1),
   store = list(a = FALSE, y = FALSE, r = FALSE),
   dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesHistogram_+3A_y1">y1</code></td>
<td>
<p>response for the first dimension in the form of a survival
object created using <code><a href="survival.html#topic+Surv">Surv</a></code>.</p>
</td></tr>
<tr><td><code id="bayesHistogram_+3A_y2">y2</code></td>
<td>
<p>response for the second dimension in the form of a survival
object created using <code><a href="survival.html#topic+Surv">Surv</a></code>. If the response
is one-dimensional this item is missing.</p>
</td></tr>
<tr><td><code id="bayesHistogram_+3A_nsimul">nsimul</code></td>
<td>
<p>a list giving the number of iterations of the MCMC and
other parameters of the simulation.
</p>

<dl>
<dt>niter</dt><dd><p>total number of sampled values after discarding
thinned ones, burn-up included;</p>
</dd>
<dt>nthin</dt><dd><p>thinning interval;</p>
</dd>
<dt>nburn</dt><dd><p>number of sampled values in a burn-up period after
discarding thinned values. This value should be smaller than
<code>niter</code>. If not, <code>nburn</code> is set to <code>niter - 1</code>. It can be set to zero;</p>
</dd>
<dt>nwrite</dt><dd><p>an interval at which information about the number of
performed iterations is print on the screen and during the
burn-up period an interval with which the sampled values are
writen to files;</p>
</dd>
</dl>
    
</td></tr>    
<tr><td><code id="bayesHistogram_+3A_prior">prior</code></td>
<td>
<p>a list that identifies prior hyperparameters and prior
choices. See the paper Komárek and Lesaffre (2008) and the PhD. thesis
Komárek (2006) for more details.
</p>
<p>Some prior parameters can be guessed by the function itself. If you
want to do so, set such parameters to <code>NULL</code>. Set to
<code>NULL</code> also the parameters that are not needed in your model.
</p>

<dl>
<dt>specification</dt><dd><p>a~number giving which specification of the
model is used. It can be one of the following numbers:
</p>

<dl>
<dt>1</dt><dd><p>with this specification positions of the middle knots
<code class="reqn">\gamma_1,\dots,\gamma_q,</code>
where <code class="reqn">q</code> is dimension of the G-spline and basis
standard deviations
<code class="reqn">\sigma_{0,1},\dots,\sigma_{0,q}</code>
are estimated. At the same time the G-spline intercepts
<code class="reqn">\alpha_1,\dots,\alpha_q</code> and the
G-spline scale parameters
<code class="reqn">s_{1},\dots,s_{q}</code>
are assumed to be fixed (usually, intercepts to zero and
scales to 1). The user can specified the fixed quantities in
the <code>init</code> parameter of this function
</p>
</dd>  
<dt>2</dt><dd><p>with this specification, G-spline intercepts
<code class="reqn">\alpha_1,\dots,\alpha_q</code> and the
G-spline scale parameters
<code class="reqn">s_{1},\dots,s_{q}</code> are estimated
at the same time positions of the middle knots
<code class="reqn">\gamma_1,\dots,\gamma_q</code>
and basis standard deviations
<code class="reqn">\sigma_{0,1},\dots,\sigma_{0,q}</code>
are assumed to be fixed (usually, middle knots to zero ans
basis standard deviations to some smaller number like 0.2)
The user can specified the fixed quantities in the
<code>init</code> parameter of this function	    
</p>
</dd>	  
</dl>
  
</dd>  
<dt>K</dt><dd><p>specification of the number of knots in each dimension, i.e. <code>K</code> 
is a vector of length equal to the dimension of the data <code class="reqn">q</code>
and <code class="reqn">K_j,</code> <code class="reqn">j=1,\dots,q</code> determines that 
the subscript <code class="reqn">k_j</code> of the knots runs over
<code class="reqn">-K_j,\dots,0,\dots,K_j</code>. A value
<code class="reqn">K_j=0</code> is valid as well. There are only some restriction
on the minimal value of <code class="reqn">K_j</code> with respect to the choice
of the neighbor system and possibly the order of the conditional
autoregression in the prior of transformed weights (see below).
</p>
</dd>
<dt>izero</dt><dd><p>subscript <code class="reqn">k_1\dots k_q</code> 
of the knot whose transformed weight 
<code class="reqn">a_{k_1\dots k_q}</code> will constantly be equal to zero.
This is here for identifiability. To avoid numerical problems
it is highly recommended to set <code>izero=rep(0, q)</code>.
<code>izero[j]</code> should be taken from the set
<code class="reqn">-K_j, \dots, K_j</code>.
</p>
</dd>
<dt>neighbor.system</dt><dd><p>identification of the neighboring system
for the Markov random field prior of transformed mixture weights
<code class="reqn">a_{k_1\,k_2}</code>. This can be substring of one of
the following strings:
</p>

<dl>
<dt><code>uniCAR</code></dt><dd><p> &ldquo;univariate conditional
autoregression&rdquo;: a~prior based on squared differences of
given order <code class="reqn">m</code> (see argument <code>order</code>) in each row and
column. 
</p>
<p>For univariate smoothing:
</p>
<p style="text-align: center;"><code class="reqn">
	      p(a) \propto \exp\Bigl\{-\frac{\lambda}{2}\sum_{k=-K+m}^K\bigl(\Delta^m a_{k}\bigr)^2\Bigr\},</code>
</p>

<p>where <code class="reqn">\Delta^m</code> denotes the difference
operator of order <code class="reqn">m</code>, i.e.
<code class="reqn">\Delta^1 a_k = a_k - a_{k-1}</code> and
<code class="reqn">\Delta^m a_k = \Delta^{m-1}a_k - \Delta^{m-1}a_{k-1},</code>
<code class="reqn">m \geq 2.</code>
</p>
<p>For bivariate smoothing:
</p>
<p style="text-align: center;"><code class="reqn">
	      p(a) \propto
	      \exp\Bigl\{
	      -\frac{\lambda_1}{2}\sum_{k_1=-K_1}^{K_1}\sum_{k_2=-K_2+m}^{K_2}
	      \bigl(\Delta_1^m a_{k_1,k_2}\bigr)^2
	      -\frac{\lambda_2}{2}\sum_{k_2=-K_2}^{K_2}\sum_{k_1=-K_1+m}^{K_1}
	      \bigl(\Delta_2^m a_{k_1,k_2}\bigr)^2
	      \Bigr\},</code>
</p>

<p>where <code class="reqn">\Delta_l^m</code> denotes the difference
operator of order <code class="reqn">m</code> acting in the <code class="reqn">l</code>th
margin, e.g.
</p>
<p style="text-align: center;"><code class="reqn">\Delta_1^2 = a_{k_1,k_2} - 2a_{k_1,k_2-1} + a_{k_1,k_2-2}.</code>
</p>

<p>The precision parameters <code class="reqn">\lambda_1</code> and
<code class="reqn">\lambda_2</code> might be forced to be equal (see
argument <code>equal.lambda</code>.)
</p>
</dd>
<dt><code>eight.neighbors</code></dt><dd><p>this prior is based on eight
nearest neighbors (i.e. except on edges, each full
conditional depends only on eight nearest neighbors) and
local quadratic smoothing.
It applies only in the case of bivariate smoothing. The prior is then
defined as
</p>
<p style="text-align: center;"><code class="reqn">
              p(a) \propto \exp
	      \Bigl\{-\frac{\lambda}{2}\sum_{k_1=-K_1}^{K_1-1}\sum_{k_2=-K_2}^{K_2-1}
	      \bigl(\Delta a_{k_1,k_2} \bigr)^2\Bigr\},
	    </code>
</p>
  
<p>where
</p>
<p style="text-align: center;"><code class="reqn">\Delta a_{k_1,k_2} = a_{k_1,k_2} - a_{k_1+1,k_2} -
	      a_{k_1, k_2+1} + a_{k_1+1,k_2+1}.</code>
</p>
	    
</dd>
<dt><code>twelve.neighbors</code></dt><dd><p>!!! THIS FEATURE HAS NOT BEEN
IMPLEMENTED YET. !!!</p>
</dd>
</dl>

</dd>	
<dt>order</dt><dd><p>order of the conditional autoregression if
<code>neighbor.system = uniCAR</code>. Implemented are 1, 2, 3. If
<code>order = 0</code> and  <code>neighbor.system = uniCAR</code>
then mixture weights are assumed to be fixed
and equal to their initial values specified by the <code>init</code>
parameter (see below). Note that the numbers <code class="reqn">K_j,</code>
<code class="reqn">j=1,\dots,q</code> must be all equal to or higher than
<code>order</code>.
</p>
</dd>
<dt>equal.lambda</dt><dd><p><code>TRUE/FALSE</code> applicable in the case when
a density of bivariate observations is estimated and
<code>neighbor.system = uniCAR</code>. It specifies whether there is
only one common Markov random field precision parameter
<code class="reqn">\lambda</code> for all margins (dimensions) or whether
each margin (dimension) has its own precision parameter
<code class="reqn">\lambda</code>.
For all other neighbor systems is <code>equal.lambda</code>
automatically <code>TRUE</code>.
</p>
</dd>
<dt>prior.lambda</dt><dd><p>specification of the prior distributions for
the Markov random field precision parameter(s)
<code class="reqn">\lambda</code> (when <code>equal.lambda = TRUE</code>) or
<code class="reqn">\lambda_1,\dots,\lambda_q</code>
(when <code>equal.lambda = TRUE</code>).
This is a vector of substring of one of the following strings
(one substring for each margin if <code>equal.lambda = FALSE</code>,
otherwise just one substring):
</p>

<dl>
<dt><code>fixed</code></dt><dd><p>the <code class="reqn">\lambda</code> parameter is then
assumed to be fixed and equal to its initial values given
by <code>init</code> (see below).</p>
</dd>
<dt><code>gamma</code></dt><dd><p>a particular <code class="reqn">\lambda</code> parameter has
a priori gamma distribution with shape <code class="reqn">g_j</code> and rate
(inverse scale) <code class="reqn">h_j</code> where
<code class="reqn">j=1</code> if <code>equal.lambda=TRUE</code> and
<code class="reqn">j=1,\dots,q</code> if <code>equal.lambda=TRUE</code>.
Shape and rate parameters are specified by
<code>shape.lambda</code>, <code>rate.lambda</code> (see below).</p>
</dd>
<dt><code>sduniform</code></dt><dd><p>a particular
<code class="reqn">1/\sqrt{\lambda}</code> parameter
(i.e.a standard deviation of the Markov random field)
has a priori a uniform distribution on the interval
<code class="reqn">(0, S_j)</code> where
<code class="reqn">j=1</code> if <code>equal.lambda=TRUE</code> and
<code class="reqn">j=1,\dots,q</code> if <code>equal.lambda=TRUE</code>.
Upper limit of intervals is specified by <code>rate.lambda</code>
(see below).</p>
</dd>
</dl>

</dd>
<dt>prior.gamma</dt><dd><p>specification of the prior distribution for a
reference knot (intercept) <code class="reqn">\gamma</code> in each
dimension. This is a vector of substrings of one of the following strings
(one substring for each margin):
</p>

<dl>
<dt><code>fixed</code></dt><dd><p>the <code class="reqn">\gamma</code> parameter is then
assumed to be fixed and equal to its initial values given
by <code>init</code> (see below).</p>
</dd>
<dt><code>normal</code></dt><dd><p>the <code class="reqn">\gamma</code> parameter has a
priori a normal distribution with mean and variance given by
<code>mean.gamma</code> and <code>var.gamma</code>.</p>
</dd>
</dl>
	  
</dd>	
<dt>prior.sigma</dt><dd><p>specification of the prior distribution for
basis standard deviations of the G-spline in each dimension.
This is a vector of substrings of one of the following strings
(one substring for each margin):
</p>

<dl>
<dt><code>fixed</code></dt><dd><p>the <code class="reqn">\sigma</code> parameter is then
assumed to be fixed and equal to its initial values given
by <code>init</code> (see below).</p>
</dd>
<dt><code>gamma</code></dt><dd><p>a particular <code class="reqn">\sigma^{-2}</code> parameter has
a priori gamma distribution with shape <code class="reqn">\zeta_j</code> and rate
(inverse scale) <code class="reqn">\eta_j</code> where
<code class="reqn">j=1,\dots,q</code>.
Shape and rate parameters are specified by
<code>shape.sigma</code>, <code>rate.sigma</code> (see below).</p>
</dd>
<dt><code>sduniform</code></dt><dd><p>a particular
<code class="reqn">\sigma</code> parameter
has a priori a uniform distribution on the interval
<code class="reqn">(0, S_j)</code>.
Upper limit of intervals is specified by <code>rate.sigma</code>
(see below).</p>
</dd>
</dl>

</dd>
<dt>prior.intercept</dt><dd><p>specification of the prior distribution for
the intercept terms
<code class="reqn">\alpha_1,\dots,\alpha_q</code>
(2nd specification) in each dimension.
This is a vector of substrings of one of the following strings
(one substring for each margin):
</p>

<dl>
<dt><code>fixed</code></dt><dd><p>the intercept parameter is then
assumed to be fixed and equal to its initial values given
by <code>init</code> (see below).</p>
</dd>
<dt><code>normal</code></dt><dd><p>the intercept parameter has a
priori a normal distribution with mean and variance given by
<code>mean.intercept</code> and <code>var.intercept</code>.</p>
</dd>
</dl>
	  	
</dd>
<dt>prior.scale</dt><dd><p>specification of the prior distribution for
the scale parameter (2nd specification) of the G-spline in each dimension
This is a vector of substrings of one of the following strings
(one substring for each margin):
</p>

<dl>
<dt><code>fixed</code></dt><dd><p>the <code>scale</code> parameter is then
assumed to be fixed and equal to its initial values given
by <code>init</code> (see below).</p>
</dd>
<dt><code>gamma</code></dt><dd><p>a particular <code class="reqn">scale^{-2}</code> parameter has
a priori gamma distribution with shape <code class="reqn">\zeta_j</code> and rate
(inverse scale) <code class="reqn">\eta_j</code> where
<code class="reqn">j=1,\dots,q</code>.
Shape and rate parameters are specified by
<code>shape.scale</code>, <code>rate.scale</code> (see below).</p>
</dd>
<dt><code>sduniform</code></dt><dd><p>a particular
<code class="reqn">scale</code> parameter
has a priori a uniform distribution on the interval
<code class="reqn">(0, S_j)</code>.
Upper limit of intervals is specified by <code>rate.scale</code>
(see below).</p>
</dd>
</dl>

</dd>      
<dt>c4delta</dt><dd><p>values of <code class="reqn">c_1,\dots,c_q</code> which serve
to compute the distance <code class="reqn">\delta_j</code>
between two consecutive knots in each dimension.
The knot <code class="reqn">\mu_{j\,k},</code>
<code class="reqn">j=1,\dots,q,</code> 
<code class="reqn">k=-K_j,\dots,K_j</code> is defined
as <code class="reqn">\mu_{j\,k} = \gamma_j + k\,\delta_j</code>
with <code class="reqn">\delta_j = c_j\,\sigma_j</code>.
</p>
</dd>
<dt>mean.gamma</dt><dd><p>these are means for the normal prior
distribution of middle knots
<code class="reqn">\gamma_1,\dots,\gamma_q</code>
in each dimension if this prior is normal. For fixed
<code class="reqn">\gamma</code> an appropriate element of the vector
<code>mean.gamma</code> may be whatever.
</p>
</dd>
<dt>var.gamma</dt><dd><p>these are variances for the normal prior
distribution of middle knots
<code class="reqn">\gamma_1,\dots,\gamma_q</code>
in each dimension if this prior is normal. For fixed
<code class="reqn">\gamma</code> an appropriate element of the vector
<code>var.gamma</code> may be whatever.
</p>
</dd>
<dt>shape.lambda</dt><dd><p>these are shape parameters for the gamma prior
(if used) of Markov random field precision parameters
<code class="reqn">\lambda_1,\dots,\lambda_q</code> (if
<code>equal.lambda = FALSE</code>) or <code class="reqn">\lambda_1</code> (if
<code>equal.lambda = TRUE</code>).
</p>
</dd>
<dt>rate.lambda</dt><dd><p>these are rate parameters for the gamma prior
(if <code>prior.lambda = gamma</code>) of Markov random field precision parameters
<code class="reqn">\lambda_1,\dots,\lambda_q</code> (if
<code>equal.lambda = FALSE</code>) or <code class="reqn">\lambda_1</code> (if
<code>equal.lambda = TRUE</code>) or upper limits of the uniform prior
(if <code>prior.lambda = sduniform</code>) of Markov random field
standard deviation  parameters
<code class="reqn">\lambda_1^{-1/2},\dots,\lambda_q^{-1/2}</code> (if
<code>equal.lambda = FALSE</code>) or <code class="reqn">\lambda_1^{-1/2}</code> (if
<code>equal.lambda = TRUE</code>).
</p>
</dd>
<dt>shape.sigma</dt><dd><p>these are shape parameters for the gamma prior
(if used) of basis inverse variances
<code class="reqn">\sigma_1^{-2},\dots,\sigma_q^{-2}</code>.
</p>
</dd>
<dt>rate.sigma</dt><dd><p>these are rate parameters for the gamma prior
(if <code>prior.sigma = gamma</code>) of basis inverse variances
<code class="reqn">\sigma_1^{-2},\dots,\sigma_q^{-2}</code> 
or upper limits of the uniform prior
(if <code>prior.sigma = sduniform</code>) of basis standard deviations
<code class="reqn">\sigma_1,\dots,\sigma_q</code>.
</p>
</dd>
<dt>mean.intercept</dt><dd><p>these are means for the normal prior
distribution of the G-spline intercepts (2nd specification)
<code class="reqn">\alpha_1,\dots,\alpha_q</code>
in each dimension if this prior is normal. For fixed
<code class="reqn">\alpha</code> an appropriate element of the vector
<code>mean.intercept</code> may be whatever.
</p>
</dd>
<dt>var.intercept</dt><dd><p>these are variances for the normal prior
distribution of the G-spline intercepts
<code class="reqn">\alpha_1,\dots,\alpha_q</code>
in each dimension if this prior is normal. For fixed
<code class="reqn">\alpha</code> an appropriate element of the vector
<code>var.alpha</code> may be whatever.
</p>
</dd>      
<dt>shape.scale</dt><dd><p>these are shape parameters for the gamma prior
(if used) of the G-spline scale parameter (2nd specification)
<code class="reqn">scale_1^{-2},\dots,scale_q^{-2}</code>.
</p>
</dd>
<dt>rate.scale</dt><dd><p>these are rate parameters for the gamma prior
(if <code>prior.scale = gamma</code>) of the G-spline inverse variances
<code class="reqn">scale_1^{-2},\dots,scale_q^{-2}</code> 
or upper limits of the uniform prior
(if <code>prior.scale = sduniform</code>) of the G-spline scale
<code class="reqn">scale_1,\dots,scale_q</code>.
</p>
</dd>      
</dl>

</td></tr>
<tr><td><code id="bayesHistogram_+3A_init">init</code></td>
<td>
<p>a list of the initial values to start the McMC. Set to
<code>NULL</code> such parameters that you want the program should itself sample
for you or parameters that are not needed in your model.
</p>

<dl>
<dt>iter</dt><dd><p>the number of the iteration to which the initial values
correspond, usually zero.</p>
</dd>      
<dt>a</dt><dd><p>vector/matrix of initial transformed mixture weights
<code class="reqn">a_{k_1},</code> <code class="reqn">k_1=-K_1,\dots,K_1</code>
if univariate density is estimated;
<code class="reqn">a_{k_1\,k_2},</code>
<code class="reqn">k_1=-K_1,\dots,K_1,</code>
<code class="reqn">k_2=-K_2,\dots,K_2,</code>
if bivariate density is estimated. This initial value can be
guessed by the function itself.
</p>
</dd>
<dt>lambda</dt><dd><p>initial values for Markov random field precision
parameter(s) <code class="reqn">\lambda</code> (if <code>equal.lambda = TRUE</code>),
<code class="reqn">\lambda_1,\dots,\lambda_q</code> 
(if <code>equal.lambda = FALSE</code>.)
</p>
</dd>
<dt>gamma</dt><dd><p>initial values for the middle knots in each
dimension.
</p>
<p>If <code>prior$specification = 2</code> it is recommended
(for easier interpretation of the results) to set
<code>init$gamma</code> to zero for all dimensions.
</p>
<p>If <code>prior$specification = 1</code> <code>init$gamma</code> should be
approximately equal to the mean value of the data in each margin.
</p>
</dd>
<dt>sigma</dt><dd><p>initial values for basis standard deviations in each
dimension.
</p>
<p>If <code>prior$specification = 2</code> this should be
approximately equal to the range of standardized data (let say 4
+ 4) divided by the number of knots in each margin and
multiplied by something like 2/3.
</p>
<p>If <code>prior$specification = 1</code> this should be approximately equal to the range of your
data divided by the number of knots in each margin and
multiplied again by something like 2/3.
</p>
</dd>
<dt>intercept</dt><dd><p>initial values for the intercept term in each
dimension.
</p>
<p>Note that if <code>prior$specification = 1</code> this
initial value is always changed to zero for all dimensions.	
</p>
</dd>
<dt>scale</dt><dd><p>initial values for the G-spline scale parameter in each
dimension.
</p>
<p>Note that if <code>prior$specification = 1</code> this
initial value is always changed to one for all dimensions.
</p>
</dd>      
<dt>y</dt><dd><p>initial values for (possibly unobserved censored) observations. This
should be either a vector of length equal to the sample size if
the response is univariate or a matrix with as many rows as is
the sample size and two columns if the response is
bivariate. Be aware that <code>init$y</code> must be consistent with
data supplied. This initial can be guessed by the function
itself. Possible missing values in <code>init$y</code> tells the
function to guess the initial value.
</p>
</dd>
<dt>r</dt><dd><p>initial values for labels of components to which the
(augmented) observations belong. This initial can be guessed by
the function itself. This
should be either a vector of length equal to the sample size if
the response is univariate or a matrix with as many rows as is
the sample size and two columns if the response is
bivariate. Values in the first column of this matrix should be
between <code>-prior$K[1]</code> and <code>prior$K[1]</code>, values in the
second column of this matrix between <code>-prior$K[2]</code> and
<code>prior$K[2]</code>, e.g. when <code>init$r[i,1:2] = c(-3, 6)</code> it
means that the <code class="reqn">i</code>th observation is initially assigned to
the component with the mean
<code class="reqn">\boldsymbol{\mu}=(\mu_1, \mu_2)'</code> where
</p>
<p style="text-align: center;"><code class="reqn">\mu_1 = \mu_{1,\,-3} = \gamma_1 -3\,c_1\sigma_1</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\mu_2 = \mu_{2,\,6} = \gamma_2 +6\,c_2\sigma_2.</code>
</p>

</dd>
</dl>

</td></tr>
<tr><td><code id="bayesHistogram_+3A_mcmc.par">mcmc.par</code></td>
<td>
<p>a list specifying further details of the McMC
simulation. There are default values implemented for all components
of this list.
</p>

<dl>
<dt>type.update.a</dt><dd><p>it specifies the McMC method to update
transformed mixture weights <code class="reqn">a</code>. It is a~substring of one
of the following strings:
</p>

<dl>
<dt>slice</dt><dd><p>slice sampler of Neal (2003) is used (default choice);</p>
</dd>
<dt>ars.quantile</dt><dd><p>adaptive rejection sampling of Gilks and
Wild (1992) is used with starting abscissae equal to 15%,
50% and 85% quantiles of a~piecewise exponential
approximation to the full conditional from the previous
iteration;</p>
</dd>
<dt>ars.mode</dt><dd><p>adaptive rejection sampling of Gilks and Wild
(1992) is used with starting abscissae equal to the mode and
plus/minus twice approximate standard deviation of the full
conditional distribution</p>
</dd>
</dl>

</dd>
<dt>k.overrelax.a</dt><dd><p>this specifies a frequency of overrelaxed
updates of transformed mixture weights <code class="reqn">a</code> when slice
sampler is used. Every <code class="reqn">k</code>th value is sampled in a usual
way (without overrelaxation). If you do not want overrelaxation
at all, set <code>k.overrelax.a</code> to 1 (default choice). Note
that overrelaxation can be only done with the slice sampler (and
not with adaptive rejection sampling).</p>
</dd>
<dt>k.overrelax.sigma</dt><dd><p>a vector of length equal to the dimension
of the G-spline specifying a frequency of overrelaxed updates of
basis G-spline variances. If you do not want overrelaxation at
all, set all components of <code>k.overrelax.sigma</code> to 1
(default choice).</p>
</dd>
<dt>k.overrelax.scale</dt><dd><p>a vector of length equal to the dimension
of the G-spline specifying a frequency of overrelaxed updates of
the G-spline scale parameters (2nd specification).
If you do not want overrelaxation at
all, set all components of <code>k.overrelax.scale</code> to 1
(default choice).</p>
</dd>      
</dl>
       
</td></tr>
<tr><td><code id="bayesHistogram_+3A_store">store</code></td>
<td>
<p>a~list of logical values specifying which chains that are
not stored by default are to be stored. The list can have the
following components.
</p>

<dl>
<dt>a</dt><dd><p>if <code>TRUE</code> then all the transformed mixture weights
<code class="reqn">a_{k_1,\,k_2},</code>
<code class="reqn">k_1=-K_1,\dots,K_1,</code>
<code class="reqn">k_2=-K_2,\dots,K_2,</code>
related to the G-spline are stored.</p>
</dd>
<dt>y</dt><dd><p>if <code>TRUE</code> then augmented log-event times for all
observations are stored.</p>
</dd>
<dt>r</dt><dd><p>if <code>TRUE</code> then labels of mixture components for
residuals are stored.</p>
</dd>
</dl>
  
</td></tr>  
<tr><td><code id="bayesHistogram_+3A_dir">dir</code></td>
<td>
<p>a string that specifies a directory where all sampled
values are to be stored.
</p>
</td></tr>   
</table>


<h3>Value</h3>

<p>A list of class <code>bayesHistogram</code> containing an information
concerning the initial values and prior choices.
</p>


<h3>Files created</h3>

  
<p>Additionally, the following files with sampled values
are stored in a directory specified by <code>dir</code> argument of this
function (some of them are created only on request, see <code>store</code>
parameter of this function).
</p>
<p>Headers are written to all files created by default and to files asked
by the user via the argument <code>store</code>.  All
sampled values are written in files created by default and to files
asked by the user via the argument <code>store</code>. In the files for
which the corresponding <code>store</code> component is <code>FALSE</code>, every
<code>nsimul$nwrite</code> value is written during the whole MCMC (this
might be useful to restart the MCMC from some specific point).
</p>
<p>The following files are created:
</p>

<dl>
<dt>iteration.sim</dt><dd><p>one column labeled <code>iteration</code> with
indeces of MCMC iterations to which the stored sampled values
correspond.
</p>
</dd>
<dt>mixmoment.sim</dt><dd><p>columns labeled <code>k</code>, <code>Mean.1</code>, <code>Mean.2</code>,
<code>D.1.1</code>, <code>D.2.1</code>, <code>D.2.2</code> in the bivariate case and
columns labeled <code>k</code>, <code>Mean.1</code>, <code>D.1.1</code> in the
univariate case, where
</p>
<p><b>k</b> = number of mixture components that had probability
numerically higher than zero;
</p>
<p><b>Mean.1</b> =
<code class="reqn">\mbox{E}(Y_{i,1})</code>;
</p>
<p><b>Mean.2</b> =
<code class="reqn">\mbox{E}(Y_{i,2})</code>;
</p>
<p><b>D.1.1</b> =
<code class="reqn">\mbox{var}(Y_{i,1})</code>;
</p>
<p><b>D.2.1</b> =
<code class="reqn">\mbox{cov}(Y_{i,1},\,Y_{i,2})</code>;
</p>
<p><b>D.2.2</b> =
<code class="reqn">\mbox{var}(Y_{i,2})</code>.
</p>
</dd>
<dt>mweight.sim</dt><dd><p>sampled mixture weights
<code class="reqn">w_{k_1,\,k_2}</code> of mixture components that had
probabilities numerically higher than zero. 
</p>
</dd>
<dt>mmean.sim</dt><dd><p>indeces <code class="reqn">k_1,\;k_2,</code>
<code class="reqn">k_1 \in\{-K_1, \dots, K_1\},</code>
<code class="reqn">k_2 \in\{-K_2, \dots, K_2\}</code>
of mixture components that had probabilities numerically higher
than zero. It corresponds to the weights in
<code>mweight.sim</code>. 
</p>
</dd>
<dt>gspline.sim</dt><dd><p>characteristics of the sampled G-spline
(distribution of
<code class="reqn">(Y_{i,1},\,Y_{i,2})'</code>).
This file together with <code>mixmoment.sim</code>,
<code>mweight.sim</code> and <code>mmean.sim</code> can be used to reconstruct
the G-spline in each MCMC iteration.
</p>
<p>The file has columns labeled <code>gamma1</code>,
<code>gamma2</code>, <code>sigma1</code>, <code>sigma2</code>, <code>delta1</code>,
<code>delta2</code>, <code>intercept1</code>, <code>intercept2</code>,
<code>scale1</code>, <code>scale2</code>. The meaning of the values in these
columns is the following:
</p>
<p><b>gamma1</b> = the middle knot <code class="reqn">\gamma_1</code> in the
first dimension. If &lsquo;Specification&rsquo; is 2, this column
usually contains zeros;
</p>
<p><b>gamma2</b> = the middle knot <code class="reqn">\gamma_2</code> in the
second dimension. If &lsquo;Specification&rsquo; is 2, this column
usually contains zeros;
</p>
<p><b>sigma1</b> = basis standard deviation <code class="reqn">\sigma_1</code>
of the G-spline in the first dimension. This column contains
a~fixed value if &lsquo;Specification&rsquo; is 2;
</p>
<p><b>sigma2</b> = basis standard deviation <code class="reqn">\sigma_2</code>
of the G-spline in the second dimension. This column contains
a~fixed value if &lsquo;Specification&rsquo; is 2;
</p>
<p><b>delta1</b> = distance <code class="reqn">delta_1</code> between the two knots of the G-spline in
the first dimension. This column contains
a~fixed value if &lsquo;Specification&rsquo; is 2;
</p>
<p><b>delta2</b> = distance <code class="reqn">\delta_2</code> between the two knots of the G-spline in
the second dimension. This column contains a~fixed value if
&lsquo;Specification&rsquo; is 2;
</p>
<p><b>intercept1</b> = the intercept term <code class="reqn">\alpha_1</code> of
the G-spline in the first dimension. If &lsquo;Specification&rsquo; is 1, this column
usually contains zeros;
</p>
<p><b>intercept2</b> = the intercept term <code class="reqn">\alpha_2</code> of
the G-spline in the second dimension. If &lsquo;Specification&rsquo; is 1, this column
usually contains zeros;
</p>
<p><b>scale1</b> = the scale parameter <code class="reqn">\tau_1</code> of the
G-spline in the first dimension. If &lsquo;Specification&rsquo; is 1, this column
usually contains ones;
</p>
<p><b>scale2</b> = the scale parameter <code class="reqn">\tau_2</code> of the
G-spline in the second dimension. &lsquo;Specification&rsquo; is 1, this column
usually contains ones.      
</p>
</dd>
<dt>mlogweight.sim</dt><dd><p>fully created only if <code>store$a = TRUE</code>. The
file contains the transformed weights
<code class="reqn">a_{k_1,\,k_2},</code>
<code class="reqn">k_1=-K_1,\dots,K_1,</code>
<code class="reqn">k_2=-K_2,\dots,K_2</code> of all mixture
components, i.e. also of components that had numerically zero
probabilities.
</p>
</dd>
<dt>r.sim</dt><dd><p>fully created only if <code>store$r = TRUE</code>. The file
contains the labels of the mixture components into which the
observations are intrinsically assigned. Instead of double indeces
<code class="reqn">(k_1,\,k_2)</code>, values from 1 to <code class="reqn">(2\,K_1+1)\times
	(2\,K_2+1)</code> are stored here. Function
<code><a href="#topic+vecr2matr">vecr2matr</a></code> can be used to transform it back to double
indeces.
</p>
</dd>
<dt>lambda.sim</dt><dd><p>either one column labeled <code>lambda</code> or two
columns labeled <code>lambda1</code> and <code>lambda2</code>. These are the
values of the smoothing parameter(s) <code class="reqn">\lambda</code>
(hyperparameters of the prior distribution of the transformed
mixture weights <code class="reqn">a_{k_1,\,k_2}</code>). 
</p>
</dd>
<dt>Y.sim</dt><dd><p>fully created only if <code>store$y = TRUE</code>. It
contains sampled (augmented) log-event times for all observations
in the data set.
</p>
</dd>
<dt>logposter.sim</dt><dd><p>columns labeled <code>loglik</code>, <code>penalty</code>
or <code>penalty1</code> and
<code>penalty2</code>, <code>logprw</code>. The columns have the following
meaning (the formulas apply for the bivariate case).
</p>
<p><b>loglik</b>
<code class="reqn">=</code> <code class="reqn">%
	-N\Bigl\{\log(2\pi) + \log(\sigma_1) + \log(\sigma_2)\Bigr\}-
          0.5\sum_{i=1}^N\Bigl\{
	  (\sigma_1^2\,\tau_1^2)^{-1}\; (y_{i,1} - \alpha_1 - \tau_1\mu_{1,\,r_{i,1}})^2 +
	  (\sigma_2^2\,\tau_2^2)^{-1}\; (y_{i,2} - \alpha_2 - \tau_2\mu_{2,\,r_{i,2}})^2
          \Bigr\}
      </code>
</p>
<p>where <code class="reqn">y_{i,l}</code> denotes (augmented) <em>(i,l)</em>th
true log-event time. In other words, <code>loglik</code> is equal to the
conditional log-density
<code class="reqn">\sum_{i=1}^N\,\log\Bigl\{p\bigl((y_{i,1},\,y_{i,2})\;\big|\;r_{i},\,\mbox{G-spline}\bigr)\Bigr\};</code>
</p>
<p><b>penalty1:</b> If <code>prior$neighbor.system</code> = <code>"uniCAR"</code>:
the penalty term for the first dimension not multiplied by
<code>lambda1</code>;
</p>
<p><b>penalty2:</b> If <code>prior$neighbor.system</code> = <code>"uniCAR"</code>:
the penalty term for the second dimension not multiplied by
<code>lambda2</code>;
</p>
<p><b>penalty:</b> If <code>prior$neighbor.system</code> is different from <code>"uniCAR"</code>:
the penalty term not multiplied by <code>lambda</code>;
</p>
<p><b>logprw</b> <code class="reqn">=</code>
<code class="reqn">-2\,N\,\log\bigl\{\sum_{k_1}\sum_{k_2}a_{k_1,\,k_2}\bigr\} +
	\sum_{k_1}\sum_{k_2}N_{k_1,\,k_2}\,a_{k_1,\,k_2},</code>
where <code class="reqn">N_{k_1,\,k_2}</code> is the number of observations
assigned intrinsincally to the <code class="reqn">(k_1,\,k_2)</code>th
mixture component.
</p>
<p>In other words, <code>logprw</code> is equal to the conditional
log-density
<code class="reqn">\sum_{i=1}^N \log\bigl\{p(r_i\;|\;\mbox{G-spline
	  weights})\bigr\}.</code>
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Gilks, W. R. and Wild, P. (1992).
Adaptive rejection sampling for Gibbs sampling.
<em>Applied Statistics,</em> <b>41</b>, 337 - 348.
</p>
<p>Komárek, A. (2006).
<em>Accelerated Failure Time Models for Multivariate
Interval-Censored Data with Flexible Distributional Assumptions</em>.
PhD. Thesis, Katholieke Universiteit Leuven, Faculteit Wetenschappen.
</p>
<p>Komárek, A. and Lesaffre, E. (2008).
Bayesian accelerated failure time model with multivariate doubly-interval-censored data
and flexible distributional assumptions.
<em>Journal of the American Statistical Association</em>, <b>103</b>,
523 - 533.
</p>
<p>Komárek, A. and Lesaffre, E. (2006b).
Bayesian semi-parametric accelerated failurew time model for paired
doubly interval-censored data.
<em>Statistical Modelling</em>, <b>6</b>, 3 - 22.
</p>
<p>Neal, R. M. (2003).
Slice sampling (with Discussion).
<em>The Annals of Statistics,</em> <b>31</b>, 705 - 767.
</p>

<hr>
<h2 id='bayesHistogram.help'>
Helping function for Bayesian smoothing of (bi)-variate densities
based on possibly censored data
</h2><span id='topic+bayesHistogram.help'></span><span id='topic+bayesHistogram.design'></span><span id='topic+bayesHistogram.checkStore'></span><span id='topic+bayesHistogram.priorInit'></span><span id='topic+bayesHistogram.writeHeaders'></span>

<h3>Description</h3>

<p>These functions are not to be called by ordinary users.
</p>
<p>These are just sub-parts of &lsquo;bayesHistogram&rsquo; function to make it more
readable for the programmer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesHistogram.design(y1, y2)

bayesHistogram.checkStore(store)

bayesHistogram.priorInit(prior, init, mcmc.par, design)

bayesHistogram.writeHeaders(dir, design, prior.init, store)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesHistogram.help_+3A_y1">y1</code></td>
<td>
<p>response for the first dimension. This should be a~survival object
created by <code><a href="survival.html#topic+Surv">Surv</a></code></p>
</td></tr>
<tr><td><code id="bayesHistogram.help_+3A_y2">y2</code></td>
<td>
<p>response object for the second dimension (if bivariate
density is to be smoothed). This should be a~survival object created
by <code><a href="survival.html#topic+Surv">Surv</a></code>. Further, it must be consistent with
<code>y1</code>, i.e. it has to have the same number of rows.</p>
</td></tr>
<tr><td><code id="bayesHistogram.help_+3A_store">store</code></td>
<td>
<p>a~list with appropriate components</p>
</td></tr>
<tr><td><code id="bayesHistogram.help_+3A_prior">prior</code></td>
<td>
<p>a~list as required by <code>prior</code> argument of function <code><a href="#topic+bayesHistogram">bayesHistogram</a></code></p>
</td></tr>
<tr><td><code id="bayesHistogram.help_+3A_init">init</code></td>
<td>
<p>a~list as required by <code>init</code> argument of function <code><a href="#topic+bayesHistogram">bayesHistogram</a></code></p>
</td></tr>
<tr><td><code id="bayesHistogram.help_+3A_mcmc.par">mcmc.par</code></td>
<td>
<p>a~list as required by <code>mcmc.par</code> argument of
function <code><a href="#topic+bayesHistogram">bayesHistogram</a></code></p>
</td></tr>
<tr><td><code id="bayesHistogram.help_+3A_design">design</code></td>
<td>
<p>a~list with the design information as returned by the
function <code>bayesHistogram.design</code>. The list is assumed
to have the following components:
</p>

<dl>
<dt>y.left</dt><dd><p>...</p>
</dd>
<dt>y.right</dt><dd><p>...</p>
</dd>
<dt>status</dt><dd><p>...</p>
</dd>
<dt>dim</dt><dd><p>...</p>
</dd>
</dl>

</td></tr>  
<tr><td><code id="bayesHistogram.help_+3A_dir">dir</code></td>
<td>
<p>string giving a~directory where to store sampled files</p>
</td></tr>  
<tr><td><code id="bayesHistogram.help_+3A_prior.init">prior.init</code></td>
<td>
<p>an~object as returned by <code><a href="#topic+bayesHistogram.priorInit">bayesHistogram.priorInit</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Some lists.
</p>


<h3>Value for bayesHistogram.design</h3>

<p>A~list with the following components:
</p>

<dl>
<dt>y.left</dt><dd><p>vector or matrix with either observed, right or left
censored observations or with the lower limits of interval censored
observations. It is a vector if <code>dim == 1</code> and it is a matrix with
2 rows and <code class="reqn">n</code> columns if <code>dim == 2</code>, where <code class="reqn">n</code>
is a~sample size. In that case, the first row of the matrix are
responses for the first dimension and the second row of the matrix
are responses for the second dimension.</p>
</dd>
<dt>y.right</dt><dd><p>vector or matrix with entries equal to 1 for observed,
right or left censored observations and entries equal to the upper
limits of interval censored observations. The structure is the same
as that of <code>y.left</code>.</p>
</dd>
<dt>status</dt><dd><p>a~vector or matrix with censoring indicators (1 =
exactly observed, 0 = right censored, 2 = left censored, 3 =
interval censored). The structure is the same as that of <code>y.left</code>.</p>
</dd>
<dt>dim</dt><dd><p>dimension of the response, i.e. 1 (univariate smoothing) or
2 (bivariate smoothing)</p>
</dd>
</dl>



<h3>Value for bayesHistogram.priorInit</h3>

<p>A~list with the following components:
</p>

<dl>
<dt>Gparmi</dt><dd><p>integer parameters for the G-spline constructor in the
C++ code</p>
</dd>
<dt>Gparmd</dt><dd><p>double parameters for the G-spline constructor in the
C++ code</p>
</dd>
<dt>iter</dt><dd><p>index of the nullth iteration</p>
</dd>
<dt>y</dt><dd><p>vector of initial values for the response, sorted as
<code class="reqn">y_1[1], y_1[2], \dots, y_n[1], y_n[2]</code> in the case of bivariate response with sample size
equal to <code class="reqn">n</code></p>
</dd>
<dt>r</dt><dd><p>initial component labels (vector of size <code class="reqn">n</code>) taking
values from 1 to the total length of the G-spline</p>
</dd>
<dt>specification</dt><dd><p>specification of the G-spline model (1 or 2), see
<code><a href="#topic+bayesHistogram">bayesHistogram</a></code> for more detail</p>
</dd>
</dl>

<p>and the following attributes:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <b>init</b>      </td>
</tr>
<tr>
 <td style="text-align: left;">
  <b>prior</b>     </td>
</tr>
<tr>
 <td style="text-align: left;">
  <b>mcmc.par</b>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>

<hr>
<h2 id='bayessurvreg.help'>
Helping function for Bayesian survival regression models.
</h2><span id='topic+bayessurvreg.help'></span><span id='topic+bayessurvreg.design'></span><span id='topic+bayessurvreg.checknsimul'></span>

<h3>Description</h3>

<p>These functions are not to be called by ordinary users.
</p>
<p>These are just sub-parts of &lsquo;bayessurvreg&rsquo; functions to make them more
readable for the programmer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayessurvreg.design(m, formula, random, data, transform, dtransform)

bayessurvreg.checknsimul(nsimul)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayessurvreg.help_+3A_m">m</code>, <code id="bayessurvreg.help_+3A_formula">formula</code>, <code id="bayessurvreg.help_+3A_random">random</code>, <code id="bayessurvreg.help_+3A_data">data</code>, <code id="bayessurvreg.help_+3A_transform">transform</code>, <code id="bayessurvreg.help_+3A_dtransform">dtransform</code></td>
<td>
</td></tr>
<tr><td><code id="bayessurvreg.help_+3A_nsimul">nsimul</code></td>
<td>
<p>a list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Some lists.
</p>


<h3>Value for bayessurvreg.design</h3>

<p>A~list with the following components:
</p>

<dl>
<dt>n</dt><dd><p>number of observations (in the case of bivariate data, this
is a~number of single observations, i.e. <code class="reqn">2\times \mbox{sample
	size}</code>) included in the dataset</p>
</dd>
<dt>ncluster</dt><dd><p>number of clusters included in the dataset. In the
case of bivariate data this is equal to the number of bivariate
observations. If there are no random effects included in the model
and if the observations are not bivariate then <code>ncluster = n</code></p>
</dd>
<dt>nwithin</dt><dd><p>a~vector of length equal to <code>ncluster</code> with
numbers of observations within each cluster. In the case of
bivariate observations this is a~vector filled with 2's, if there are
no random effects and if the observations are not bivariate then
this is a~vector filled with 1's</p>
</dd>
<dt>nY</dt><dd><p>number of columns in the response matrix <code class="reqn">Y</code>. This is
equal to 2 if there are no interval-censored observations and equal
to 3 if there is at least one interval censored observation in the
dataset</p>
</dd>
<dt>nX</dt><dd><p>number of columns in the design matrix <code class="reqn">X</code>. Note that
the matrix <code class="reqn">X</code> contains covariates for both fixed and random
effects</p>
</dd>
<dt>nfixed</dt><dd><p>number of fixed effects involved in the model. Note that
possible intercept is always removed from the model</p>
</dd>
<dt>nrandom</dt><dd><p>number of random effects in the model, possible random
intercept included</p>
</dd>
<dt>randomInt</dt><dd><p><code>TRUE</code>/<code>FALSE</code> indicating whether the
random intercept is included in the model</p>
</dd>
<dt>Y</dt><dd><p>response matrix. Its last column is always equal to the
status indicator (1 for exactly observed event times, 0 for
right-censored observations, 2 for left-censored observations, 3 for
interval-censored observations).</p>
</dd>
<dt>X</dt><dd><p>design matrix containing covariates</p>
</dd>
<dt>Yinit</dt><dd><p>response matrix extracted from <code>formula</code> using <code><a href="stats.html#topic+model.extract">model.extract</a></code></p>
</dd>
<dt>Xinit</dt><dd><p>design matrix extracted from <code>formula</code> using
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code> function</p>
</dd>
<dt>cluster</dt><dd><p>a~vector of length <code>n</code> with identifications of
clusters (as given by <code>cluster</code> in <code>formula</code>)</p>
</dd>
<dt>indb</dt><dd><p>a~vector of length <code>nX</code> identifying fixed and random
effects. <code>indb[j] = -1</code> if the <code class="reqn">j</code>th column of matrix
<code class="reqn">X</code> is a fixed effects. it is equal to <code class="reqn">l</code> if the
<code class="reqn">j</code>th column of matrix <code class="reqn">X</code> corresponds to the
<code class="reqn">l</code>th random effect (in C++ indexing)</p>
</dd>
<dt>rnames.X</dt><dd><p>row names of <code>Xinit</code></p>
</dd>
<dt>names.random</dt><dd><p>column names of the <code class="reqn">X</code> matrix corespning
to the random effects. If there is the random intercept in the
model, the first component of this vector is equal to &quot;(Intercept)&quot;</p>
</dd>
<dt>factors</dt><dd><p>???</p>
</dd>
<dt>n.factors</dt><dd><p>number of factor covariates in the model formula</p>
</dd>
<dt>n.in.factors</dt><dd><p>???</p>
</dd>
</dl>
  


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>

<hr>
<h2 id='bayessurvreg1'>
A Bayesian survival regression with an error distribution
expressed as a~normal mixture with unknown number of components
</h2><span id='topic+bayessurvreg1'></span><span id='topic+C_bayessurvreg1'></span><span id='topic+C_cholesky'></span>

<h3>Description</h3>

<p>A function to sample from the posterior distribution for a survival
regression  model
</p>
<p style="text-align: center;"><code class="reqn">\log(T_{i,l}) = \beta^T x_{i,l} + b_i^T z_{i,l} +
    \varepsilon_{i,l},\quad i=1,\dots,N,\ l=1,\dots,n_i,</code>
</p>

<p>where distribution of <code class="reqn">\varepsilon_{i,l}</code> is specified
as a normal mixture with unknown number of components as in Richardson
and Green (1997) and random effect <code class="reqn">b_i</code> is normally distributed.
</p>
<p>See Komárek (2006) or
Komárek and Lesaffre (2007)
for more detailed description of prior assumptions.
</p>
<p>Sampled values are stored on a disk to be further worked out by e.g.
<code>coda</code> or <code>boa</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayessurvreg1(formula, random,
   data = parent.frame(), subset,
   na.action = na.fail,
   x = FALSE, y = FALSE, onlyX = FALSE,
   nsimul = list(niter = 10, nthin = 1, nburn = 0,
                 nnoadapt = 0, nwrite = 10),
   prior = list(kmax = 5, k.prior = "poisson", poisson.k = 3,
                dirichlet.w = 1,
                mean.mu = NULL, var.mu = NULL,
                shape.invsig2 = 1.5,
                shape.hyper.invsig2 = 0.8, rate.hyper.invsig2 = NULL,
                pi.split = NULL, pi.birth = NULL,
                Eb0.depend.mix = FALSE),
   prior.beta, prior.b, prop.revjump,
   init = list(iter = 0, mixture = NULL, beta = NULL,
               b = NULL, D = NULL,
               y = NULL, r = NULL, otherp = NULL, u = NULL),
   store = list(y = TRUE, r = TRUE, b = TRUE, u = TRUE,
                MHb = FALSE, regresres = FALSE),
   dir,
   toler.chol = 1e-10, toler.qr = 1e-10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayessurvreg1_+3A_formula">formula</code></td>
<td>
<p>model formula for the &lsquo;fixed&rsquo; part of the model, i.e. the
part that specifies <code class="reqn">\beta^T x_{i,l}</code>. See
<code><a href="survival.html#topic+survreg">survreg</a></code> for further details. Intercept is implicitely
included in the model by estimation of the error distribution. As a
consequence <code>-1</code> in the model formula does not have any effect
on the model.
</p>
<p>The left-hand side of the <code>formula</code> must be an~objecy created
using <code><a href="survival.html#topic+Surv">Surv</a></code>.
</p>
<p>If <code>random</code> is used then the formula must contain
an identification of clusters in the form <code>cluster(id)</code>, where
<code>id</code> is a name of the variable that determines clusters, e.g.
</p>

<table>
<tr>
 <td style="text-align: center;">
      <code>Surv(time, event)~gender + cluster(id)</code>.
    </td>
</tr>

</table>
  
</td></tr>
<tr><td><code id="bayessurvreg1_+3A_random">random</code></td>
<td>
<p>formula for the &lsquo;random&rsquo; part of the model, i.e. the
part that specifies <code class="reqn">b_i^T z_{i,l}</code>. If omitted,
no random part is included in the model. E.g. to specify the model with a
random intercept, say <code>random=~1</code>. All effects mentioned in
<code>random</code> should also be mentioned on the right-hand side of
<code>formula</code>.
</p>
<p>When some random effects are included the random intercept is added
by default. It can be removed using e.g. <code>random=~-1 + gender</code>.
</p>
</td></tr>
<tr><td><code id="bayessurvreg1_+3A_data">data</code></td>
<td>
<p>optional data frame in which to interpret the variables
occuring in the formulas.</p>
</td></tr>
<tr><td><code id="bayessurvreg1_+3A_subset">subset</code></td>
<td>
<p>subset of the observations to be used in the fit.</p>
</td></tr>
<tr><td><code id="bayessurvreg1_+3A_na.action">na.action</code></td>
<td>
<p>function to be used to handle any <code>NA</code>s in the
data. The user is discouraged to change a default value
<code>na.fail</code>.</p>
</td></tr>
<tr><td><code id="bayessurvreg1_+3A_x">x</code></td>
<td>
<p>if <code>TRUE</code> then the <code>X</code> matrix is returned. This
matrix contain all columns appearing in both <code>formula</code> and
<code>random</code> parameters.</p>
</td></tr>  
<tr><td><code id="bayessurvreg1_+3A_y">y</code></td>
<td>
<p>if <code>TRUE</code> then the <code>y</code> matrix (of log-survival
times) is returned.</p>
</td></tr>
<tr><td><code id="bayessurvreg1_+3A_onlyx">onlyX</code></td>
<td>
<p>if TRUE, no McMC is performed. The function returns only
a design matrix of your model (intercept excluded). It might be
useful to set up correctly a parameter for a block update of
<code class="reqn">\beta</code> (regression parameters related to the fixed
effects) and <code class="reqn">\gamma</code> (means of the random effects,
random intercept excluded) parameters in the model if
Metropolis-Hastings is to be used instead of default Gibbs.</p>
</td></tr>
<tr><td><code id="bayessurvreg1_+3A_nsimul">nsimul</code></td>
<td>
<p>a list giving the number of iterations of the McMC and
other parameters of the simulation.
</p>

<dl>
<dt>niter</dt><dd><p>total number of sampled values after discarding
thinned ones, burn-up included.</p>
</dd>
<dt>nthin</dt><dd><p>thinning interval.</p>
</dd>
<dt>nburn</dt><dd><p>number of sampled values in a burn-up period after
discarding thinned values. This value should be smaller than
<code>niter</code>. If not, <code>nburn</code> is set to <code>niter - 1</code>. It can be set to zero.</p>
</dd>
<dt>nnoadapt</dt><dd><p>applicable if some blocks of parameters are
updated using an adaptive Metropolis algorithm. This is a number
of sampled values that are generated using an initial and fixed
proposal covariance matrix. It should be smaller or equal to
<code>nburn</code>. If not, <code>nnoadapt</code> is set to <code>nburn</code>.</p>
</dd>
<dt>nwrite</dt><dd><p>an interval at which sampled values are written to
files. </p>
</dd>
</dl>

</td></tr>    
<tr><td><code id="bayessurvreg1_+3A_prior">prior</code></td>
<td>
<p>a list that identifies prior hyperparameters and prior
choices. See accompanying paper for more details.
Some prior parameters can be guessed by the function itself. If you
want to do so, set such parameters to <code>NULL</code>. Set to
<code>NULL</code> also the parameters that are not needed in your model.
</p>

<dl>
<dt>kmax</dt><dd><p>value of <code class="reqn">k_{max}</code>, upper limit for the
number of mixture components. Its high values like 100 will
usually correspond to <code class="reqn">\infty</code>.</p>
</dd>
<dt>k.prior</dt><dd><p>a string specifying the prior distribution of
<code class="reqn">k</code>, number of mixture components. Valid are either
&ldquo;poisson&rdquo;, &ldquo;uniform&rdquo;, or &ldquo;fixed&rdquo;. When &ldquo;fixed&rdquo; is given
then the number of mixture components is not sampled.</p>
</dd>
<dt>poisson.k</dt><dd><p>prior hyperparameter <code class="reqn">\lambda</code> for
the number of mixture components $k$ if Poisson prior for this
parameter is used.</p>
</dd>
<dt>dirichlet.w</dt><dd><p>prior hyperparameter <code class="reqn">\delta</code> for
the Dirichlet distribution of mixture weights
<code class="reqn">w_1,\dots,w_k</code>.</p>
</dd>
<dt>mean.mu</dt><dd><p>prior hyperparameter <code class="reqn">\xi</code> for the mean of
the normal prior for mixture means
<code class="reqn">\mu_1,\dots,\mu_k</code>.</p>
</dd>
<dt>var.mu</dt><dd><p>prior hyperparameter <code class="reqn">\kappa</code> for the
variance of the normal prior for mixture means <code class="reqn">\mu_1,\dots,\mu_k</code>.</p>
</dd>
<dt>shape.invsig2</dt><dd><p>prior hyperparameter <code class="reqn">\zeta</code> for
the shape of the inverse-gamma distribution for the mixture
variances
<code class="reqn">\sigma_1^2,\dots,\sigma_k^2</code>.</p>
</dd>
<dt>shape.hyper.invsig2</dt><dd><p>prior hyperparameter (shape) <code class="reqn">g</code> for the
gamma distribution of the parameter <code class="reqn">\eta</code>. Remember,
<code class="reqn">\eta</code> is a scale parameter of the inverse-gamma distribution for the mixture
variances
<code class="reqn">\sigma_1^2,\dots,\sigma_k^2</code>.</p>
</dd>
<dt>rate.hyper.invsig2</dt><dd><p>prior hyperparameter (rate) <code class="reqn">h</code> for the
gamma distribution of the parameter <code class="reqn">\eta</code>. Remember,
<code class="reqn">\eta</code> is a scale parameter of the inverse-gamma distribution for the mixture
variances
<code class="reqn">\sigma_1^2,\dots,\sigma_k^2</code>.</p>
</dd>
<dt>pi.split</dt><dd><p>probabilities of a split move within the
reversible jump McMC. It must be a vector of length equal to
<code>kmax</code> with the first component equal to 1 and the last
component equal to 0. If <code>NULL</code> 2nd to (k-1)th components
are set to 0.5.</p>
</dd>
<dt>pi.birth</dt><dd><p>probabilities of a birth move within the
reversible jump McMC. It must be a vector of length equal to
<code>kmax</code> with the first component equal to 1 and the last
component equal to 0. If <code>NULL</code> 2nd to (k-1)th components
are set to 0.5.</p>
</dd>
<dt>Eb0.depend.mix</dt><dd><p>this will normally be <code>FALSE</code>. Setting
this option to <code>TRUE</code> served for some experiments during
the development of this function. In principle, when this is set
to <code>TRUE</code> and the random intercept is included in the model
then it is assumed that the mean of the random intercept is not
zero but <code class="reqn">\sum_{j=1}^k w_j\mu_j</code>,
i.e. the mean of the random intercept depends on
mixture. However, this did not werk too well.	
</p>
</dd>	
</dl>

</td></tr>
<tr><td><code id="bayessurvreg1_+3A_prior.beta">prior.beta</code></td>
<td>
<p>a list defining the blocks of <code class="reqn">\beta</code>
parameters (both fixed effects and means of random effects, except
the random intercept) that are to be updated together (in a block),
a description of how they are updated and a specification of priors.
The list is assumed to have the following components.
</p>

<dl>
<dt>mean.prior</dt><dd><p>a vector specifying a prior mean for each
<code class="reqn">\beta</code> parameter in the model.</p>
</dd>
<dt>var.prior</dt><dd><p>a vector specifying a prior variance for each
<code class="reqn">\beta</code> parameter. It is recommended to run the function
<code>bayessurvreg1</code> first with its argument <code>onlyX</code> set to
<code>TRUE</code> to find out how the <code class="reqn">\beta</code>s are
sorted. They must correspond to a design matrix X.</p>
</dd>
<dt>blocks</dt><dd><p>a list with the following components.
</p>

<dl>
<dt>ind.block</dt><dd><p>a list with vectors with indeces of columns of
the design matrix X defining the effect of <code class="reqn">\beta</code>s in the
block. If not specified, all <code class="reqn">\beta</code> parameters
corresponding to fixed effects are updated in one block and
remaining <code class="reqn">\beta</code> parameters (means of random
effects) in the second block using the Gibbs move.</p>
</dd>
<dt>cov.prop</dt><dd><p>a list with vectors with a lower triangle of the covariance
matrix which is used in the normal proposal (use a command
<code><a href="base.html#topic+lower.tri">lower.tri</a></code> with <code>diag = TRUE</code> to get a lower
triangle from a matrix) when one of the Metopolis-like
algorithms is used for
a given block. This matrix is used at each iteration if the given
block is updated using a standard random-walk Metropolis-Hastings step. If the
block is updated using an adaptive Metropolis step this matrix is
used only at start. If not specified and Metropolis-like
algorith is required a diagonal matrix with prior
variances for corresponding <code class="reqn">\beta</code> on a diagonal is
used. It is set to a vector of zeros of appropriate length when the Gibbs move is required
for a given block.</p>
</dd>
</dl>

</dd>
<dt>type.upd</dt><dd><p>a character vector specifying the type of the update
that will be used for each block. Valid are substrings of
either &quot;gibbs&quot; or &quot;adaptive.metropolis&quot; or &quot;random.walk.metropolis&quot;.
Default is &quot;gibbs&quot; for all blocks.</p>
</dd>
<dt>mean.sampled</dt><dd><p>a vector of means of up to now sampled
values. This component is useful when the adaptive Metropolis
algorithm is used and we do not start from the beginning
(e.g. already several iterations of McMC have already been
performed). Otherwise, this component does not have to be filled.</p>
</dd>
<dt>eps.AM</dt><dd><p>a vector with <code class="reqn">\epsilon</code> from the
adaptive Metropolis algorithm for each block.</p>
</dd>
<dt>sd.AM</dt><dd><p>a vector specifying <code class="reqn">s_d, d = 1,\dots, D</code> numbers from the
adaptive Metropolis algorithm for each dimension. This vector must
be of length equal at least to the length of the longest
block. Defaults values are <code class="reqn">\frac{1}{d}2.4^2</code>
where <code class="reqn">d</code> denotes a length of the block.</p>
</dd>
<dt>weight.unif</dt><dd><p>a vector specifying the weight of the uniform
component in the proposal for each block. If not specified, it is
equal to 0.5 for all parameters.</p>
</dd>
<dt>half.range.unif</dt><dd><p>a vector of same length as the number of
columns in the design matrix X specifying the half range of the
uniform component of the proposal.</p>
</dd>     
</dl>

</td></tr>
<tr><td><code id="bayessurvreg1_+3A_prior.b">prior.b</code></td>
<td>
<p>a list defining the way in which the random effects are
to be updated and the specification of priors for random effects
related parameters. The list is assumed to have following components.
</p>

<dl>
<dt>prior.D</dt><dd><p>a string defining the prior distribution for the
covariance matrix of random effects <code class="reqn">D</code>. It can be either
&ldquo;inv.wishart&rdquo; or &ldquo;sduniform&rdquo;.
</p>

<dl>
<dt>inv.wishart</dt><dd><p>in that case is assumed that the prior distribution
of the matrix <code class="reqn">D</code> is Inverse-Wishart with degrees of freedom
equal to <code class="reqn">\tau</code> and a scale matrix equal to
<code class="reqn">S</code>. When <code class="reqn">D</code> is a matrix <code class="reqn">q\times q</code> a
prior expectation of <code class="reqn">D</code> is equal to
<code class="reqn">(\tau - q - 1)^{-1}S</code> if
<code class="reqn">\tau &gt; q + 1</code>. For
<code class="reqn">q - 1 &lt; \tau \leq q + 1</code> a prior
expectation is not finite.	
Degrees of freedom parameter <code class="reqn">\tau</code> does not have to be an
integer. It has to only satisfy a condition
<code class="reqn">\tau &gt; q - 1</code>. <code>prior.b$df.D</code> gives a prior
degrees of freedom parameter <code class="reqn">\tau</code> and
<code>prior.b$scale.D</code> determines the scale matrix <code class="reqn">D</code>.
This is also the default choice.
</p>
</dd>
<dt>sduniform</dt><dd><p>this can be used only when the random effect is
univariate. Then the matrix <code class="reqn">D</code> is just a scalar and the
prior of <code class="reqn">\sqrt{D}</code> (standard deviation of the
univariate random effect) is assumed to be uniform on interval
<code class="reqn">(0, S)</code>. The upper limit <code class="reqn">S</code> is given by <code>prior.b$scale.D</code>.
</p>
</dd>	
</dl>

</dd>
<dt>df.D</dt><dd><p>degrees of freedom parameter <code class="reqn">\tau</code> in the case
that the prior of the matrix <code class="reqn">D</code> is inverse-Wishart.
</p>
</dd>
<dt>scale.D</dt><dd><p>a lower triangle of the scale matrix <code class="reqn">S</code> in
the case that the prior of the matrix <code class="reqn">D</code> is
inverse-Wishart or the upper limit <code class="reqn">S</code> of the uniform distribution in
the case that <code class="reqn">\sqrt{D} \sim \mbox{Unif}(0, S)</code>.</p>
</dd>
<dt>type.upd</dt><dd><p>a character vector specifying the type of the
update. Valid are substrings of either &quot;random.walk.metropolis&quot; or
&quot;gibbs&quot;. Default is &quot;gibbs&quot;. In contrast to <code class="reqn">\beta</code>
parameters, all random effects are updated using the same type of
the move. If &quot;random.walk.metropolis&quot; is used, random effects may
be divided into blocks in which they are updated. With &quot;gibbs&quot;,
there is only one block defined for all random effects.
which are updated in one step using its full conditional distribution.</p>
</dd>
<dt>blocks</dt><dd><p>a list with the following components. This is set to
NULL if <code>type.upd = "gibbs"</code>.      
</p>

<dl>
<dt>ind.block</dt><dd><p>a list with vectors with indeces of random
effects defining the block. Random intercept has always an
index 1, remaining random effects have subsequent indeces
according to their appearance in the design matrix X.</p>
</dd>
<dt>cov.prop</dt><dd><p>a list with vectors with a lower triangle of the covariance
matrix which is used in the normal proposal (use a command
<code><a href="base.html#topic+lower.tri">lower.tri</a></code> with <code>diag = TRUE</code> to get a lower triangle from a matrix) for
a given block when
</p>

<table>
<tr>
 <td style="text-align: center;">
	     <code>type.upd = "random.walk.metropolis"</code>. 
	   </td>
</tr>

</table>
  
</dd>      	
</dl>

</dd>	 
<dt>weight.unif</dt><dd><p>a vector specifying the weight of the uniform
component in the proposal for each block when
</p>

<table>
<tr>
 <td style="text-align: center;">
	<code>type.upd = "random.walk.metropolis"</code>. 
      </td>
</tr>

</table>

<p>If not specified, it is
equal to 0.5 for all parameters. It is set to NULL if <code>type.upd = "gibbs"</code>.</p>
</dd> 
<dt>half.range.unif</dt><dd><p>a vector of same length as the number of
random effects specifying the half range of the uniform component
of the proposal when <code>type.upd = "random.walk.metropolis"</code>.
It is set to NULL if <code>type.upd = "gibbs"</code>.</p>
</dd>       
</dl>

</td></tr>
<tr><td><code id="bayessurvreg1_+3A_prop.revjump">prop.revjump</code></td>
<td>
<p>a list of values defining in which way the
reversible jumps will be performed. 
</p>

<dl>
<dt>algorithm</dt><dd><p>a string defining the algorithm used to generate
canonical proposal vectors
<code class="reqn">u = (u_{3k+1},\dots, u_{3k_{max}})'</code>
where <code class="reqn">u_{3k+1}, u_{3k+2}, u_{3k+3}</code>
are directly used when a jump to a space of higher dimension is
proposed. These canonical proposal vectors are further
transformed to give desired parameters (mixture component's weight, mean and
variance). 
Valid values of <code>prop.revjump$algorithm</code> are substrings of
&quot;basic&quot;, &quot;independent.av&quot;, &quot;correlated.av&quot;. <code>"basic"</code> means
that both components of vectors <code class="reqn">u</code> and vectors
<code class="reqn">u</code> in time are generated independently from a standard
uniform distribution. This corresponds to a basic reversible
jumps McMC algorithm of Green (1995). Other two methods
implement an auxiliary variable method of Brooks et
al. (2003). The first one an independent auxiliary variable
method where vectors <code class="reqn">u</code> may be correlated in time
however their components are independent and the second one the
correlated auxiliary method where vectors <code class="reqn">u</code> are
correlated in time and also their components may be
correlated. In both cases components of vectors <code class="reqn">u</code>
follow marginally a standard uniform distribution. A moody ring
method of Brooks et al. (2003) is used to generate <code class="reqn">u</code> vectors.
</p>
</dd>
<dt>moody.ring</dt><dd><p>parameters for the moody ring when
<code>algorithm</code> is either &quot;independent.av&quot; or
&quot;correlated.av&quot;. This is a two component vector with both
components taking values between 0 and 0.5 defining the strength
of a correlation in time and between the components of
<code class="reqn">u</code> vectors. This vector is ignored when <code>algorithm
	  = "basic"</code>. The first component of this vector determines
dependence between <code class="reqn">u</code> vectors in time
(<code class="reqn">\varepsilon</code> in Brooks et al. (2003)), the second
component determines dependence between components of <code class="reqn">u</code>
vectors (<code class="reqn">\delta</code> in Brooks et al. (2003)). The
second compoenent is ignored when <code>algorithm = "independent.av"</code>.
Note that both <code class="reqn">\varepsilon</code> and
<code class="reqn">\delta</code> do not have a meaning of correlation. They
determine a range of additional uniform distributions. So that
their values equal to <code class="reqn">0</code> mean perfect correlation and
their values equal to <code class="reqn">0.5</code> mean
independence. I.e. &quot;correlated.av&quot; with <code class="reqn">\delta = 0.5</code> is same as &quot;independent.av&quot; and &quot;correlated.av&quot; with
<code class="reqn">\delta = 0.5, \varepsilon = 0.5</code> is same as &quot;basic&quot;.</p>
</dd>
<dt>transform.split.combine</dt><dd><p>a description of how the canonical
variables <code class="reqn">u</code> are to be transformed to give new values of
mixture component's weight, mean and variance when a split move
is proposed. Possible values are substrings of
&quot;richardson.green&quot;, &quot;brooks&quot; and &quot;identity&quot;. In all cases, the
<code class="reqn">(0, 1)</code> canonical variables <code class="reqn">u</code> are transformed 
to <code class="reqn">(0, 1)</code> variates <code class="reqn">v</code> that are than used
to compute new values of mixture component's weight, mean and
variance using a method of moments matching described in
Richardson and Green (1997). When &quot;identity&quot;, no further
transformation is performed, when &quot;richardson.green&quot;, <code class="reqn">u</code>
vectors are transformed such that the components of resulting <code class="reqn">v</code>
vectors follow independently beta distributions with parameters
given further by <code>p = prop.revjump$transform.split.combine.parms</code>
such that in the triplet of v's used in a particular split move,
<code class="reqn">v_1 \sim beta(p_1, p_2), v_2 \sim beta(p_3, p_4), v_3 \sim beta(p_5, p_6)</code>.
When &quot;brooks&quot; <code class="reqn">v_2</code> is further transformed by
<code class="reqn">|2v_2 - 1|</code>. Default values of
</p>

<table>
<tr>
 <td style="text-align: center;">
	<code>prop.revjump$transform.split.combine$parms</code> 
	</td>
</tr>

</table>

<p>is <code>c(2, 2, 2, 2, 1, 1)</code>.</p>
</dd>
<dt>transform.split.combine.parms</dt><dd><p>see above.</p>
</dd>
<dt>transform.birth.death</dt><dd><p>a description of how the canonical
variables <code class="reqn">u</code> are to be transformed to give new values of
mixture component's weight, mean and variance when a birth move
is proposed. At this moment only one value is possible:
&quot;richardson.green&quot; implementing the proposal as in Richardson
and Green (1997).</p>
</dd>
</dl>

</td></tr>      
<tr><td><code id="bayessurvreg1_+3A_init">init</code></td>
<td>
<p>a list of the initial values to start the McMC. Set to
<code>NULL</code> such parameters that you want the program should itself sample
for you or parameters that are not needed in your model.
</p>

<dl>
<dt>iter</dt><dd><p>index of the iteration to which initial values
correspond, usually zero.</p>
</dd>
<dt>mixture</dt><dd><p>initial mixture for the error random variable
<code class="reqn">\varepsilon</code>. It must a vector of length <code>1 +
        3*kmax</code>, where <code>mixture[1]</code> gives initial number of mixture
of components <code class="reqn">k</code>,
<code>mixture[2:(k+1)]</code> gives initial mixture weights,
<code>mixture[(2+kmax):(2+kmax+k-1)]</code> gives initial mixture means, 
<code>mixture[(2+2*kmax):(2+2*kmax+k-1)]</code> gives initial mixture
variances. Remaining components of this vector are ignored.</p>
</dd>
<dt>beta</dt><dd><p>initial values of regression parameters in the same
order as columns of the design matrix <code>X</code>. Call the
function <code>bayessurvreg1</code> with <code>onlyX = TRUE</code> to see
how the columns are sorted. Remember, <code>beta</code> in this
function contains both fixed effects <code class="reqn">\beta</code> and
means of random effect <code class="reqn">\gamma</code> in the notation of
the accompanying paper except the mean of
the random intercept which is always zero.</p>
</dd>
<dt>b</dt><dd><p>initial values of random effects <code class="reqn">b_i</code> for each
cluster. This must a matrix of size <code class="reqn">q \times N</code> or a
vector of length <code class="reqn">q*N</code>,
where <code class="reqn">q</code> is a number of random effects and <code class="reqn">N</code>
number of clusters, one column per cluster.</p>
</dd>
<dt>D</dt><dd><p>initial value for the covariance matrix of random effects
<code class="reqn">D</code>. Only its lower triangle must be given in a
vector, e.g. <code>c(d[1,1], d[2,1], d[3,1], d[2,2], d[3,2],
          d[3,3])</code> for a matrix <code class="reqn">3 \times 3</code>.</p>
</dd>
<dt>y</dt><dd><p>initial values of true log-event times. This must be a
vector of length <code class="reqn">\sum_{i=1}^N n_i</code>.</p>
</dd>
<dt>r</dt><dd><p>initial values of component labels
<code class="reqn">r_{i,l}</code>. This must be a vector of length
<code class="reqn">\sum_{i=1}^N n_i</code>.</p>
</dd>
<dt>otherp</dt><dd><p>initial values for other parameters. At this moment,
only a value of the parameter <code class="reqn">\eta</code> is given here.</p>
</dd>
<dt>u</dt><dd><p>initial canonical proposal vector of length
<code class="reqn">3k_{max}</code>. When initial number of compoents
given by <code>init$mixture[1]</code> is <code class="reqn">k</code>, effectively only
last <code class="reqn">3k_{max} - 3*k</code> components of the
initial <code class="reqn">u</code> vector are used. Further, when
<code>prop.revjump$algorithm = "correlated.av"</code>, the first
component of <code>init$u</code> (<code>init$u[1]</code>) contains an
initial mood parameter (<code class="reqn">C_0</code> in Brooks et al. (2003))
for the moody ring.</p>
</dd>
</dl>
      
</td></tr>
<tr><td><code id="bayessurvreg1_+3A_store">store</code></td>
<td>
<p>a list that defines which sampled values besides
regression parameters <code class="reqn">\beta</code>, means of random effects
<code class="reqn">\gamma</code> (both stored in a file called <code>beta.sim</code>),
a covariance matrix of random effects <code class="reqn">D</code> (stored
in a file <code>D.sim</code>),
the mixture (stored in file <code>mixmoment.sim, mweight.sim,
      mmean.sim, mvariance.sim</code>),
values of other parameters - <code class="reqn">\eta</code> (stored in a file <code>otherp.sim</code>),
values of log-likelihoods (stored in a file <code>loglik.sim</code>),
information concerning the performance of the reversible jump McMC
and acceptance of regression parameters (stored in a file <code>MHinfo.sim</code>),
iteration indeces (stored in a file <code>iteration.sim</code>)
are to be stored. The list <code>store</code> has the following
components.
</p>

<dl>
<dt>y</dt><dd><p>if <code>TRUE</code> sampled true log-event times are  stored.</p>
</dd>
<dt>r</dt><dd><p>if <code>TRUE</code> sampled component labels are stored.</p>
</dd>
<dt>b</dt><dd><p>if <code>TRUE</code> sampled values of random effects
<code class="reqn">b_i</code> are stored.</p>
</dd>
<dt>u</dt><dd><p>if <code>TRUE</code> sampled values of canonical proposal
vectors for the reversible jump McMC are stored.</p>
</dd>
<dt>MHb</dt><dd><p>if <code>TRUE</code> information concerning the performance
of the Metropolis-Hastings algorithm for the update of random
effects (if used instead of a dafault Gibbs) is stored.</p>
</dd>
<dt>regresres</dt><dd><p>if <code>TRUE</code> sampled values of regression
residuals at each iteration are stored. The regression residual
is defined as <code class="reqn">res_{i,l} = \log(t_{i,l}) - \beta^T x_{i,l} -
	b_i^T z_{i,l}</code>.</p>
</dd>
</dl>

<p>In the case that either <code>store$y</code>, or <code>store$r</code>, or
<code>store$b</code>, or <code>store$u</code> are <code>FALSE</code>, only the last
values of either <code>y</code>, or <code>r</code>, or <code>b</code>, or <code>u</code>
at the time of writting of remaining quantities are stored in
appropriate files (without headers) to be possibly used by
<code><a href="#topic+bayessurvreg1.files2init">bayessurvreg1.files2init</a></code> function.  
</p>
</td></tr>
<tr><td><code id="bayessurvreg1_+3A_dir">dir</code></td>
<td>
<p>a string that specifies a directory where all sampled
values are to be stored.</p>
</td></tr>
<tr><td><code id="bayessurvreg1_+3A_toler.chol">toler.chol</code></td>
<td>
<p>tolerance for the Cholesky decomposition.</p>
</td></tr>
<tr><td><code id="bayessurvreg1_+3A_toler.qr">toler.qr</code></td>
<td>
<p>tolerance for the QR decomposition.</p>
</td></tr>
<tr><td><code id="bayessurvreg1_+3A_...">...</code></td>
<td>
<p>who knows?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>bayessurvreg</code> containing an information
concerning the initial values and prior choices.
</p>


<h3>Files created</h3>

  
<p>Additionally, the following files with sampled values
are stored in a directory specified by <code>dir</code> parameter of this
function (some of them are created only on request, see <code>store</code>
parameter of this function).
</p>

<dl>
<dt>iteration.sim</dt><dd><p>one column labeled <code>iteration</code> with
indeces of McMC iterations to which the stored sampled values correspond.</p>
</dd>
<dt>loglik.sim</dt><dd><p>two columns labeled <code>loglik</code> and
<code>randomloglik</code>.
</p>
<p style="text-align: center;"><code class="reqn">\mbox{\code{loglik}} = \sum_{i=1}^{N}\sum_{l=1}^{n_i}\Biggl[
	\biggl\{
        \log\Bigl(\frac{1}{\sqrt{2\pi\sigma_{r_{i,l}}^2}}\Bigr)
	-\frac{(y_{i,l} - \beta^T x_{i,l} - b_i^T z_{i,l} - \mu_{r_{i,l}})^2}{2\sigma_{r_{i,l}}^2}
	\biggr\}
	\Biggr],</code>
</p>

<p>where
<code class="reqn">y_{i,l}</code> denotes (sampled) <em>(i,l)</em>th true
log-event time,
<code class="reqn">b_i</code> sampled value of the random effect vector for the
<em>i</em>th cluster,
<code class="reqn">\beta</code> sampled value of the regression parameter
<code class="reqn">\beta</code> and
<code class="reqn">k, w_j, \mu_j, \sigma_j^2, j = 1,\dots,k</code> sampled mixture at each iteration.
</p>
<p style="text-align: center;"><code class="reqn">\mbox{\code{randomloglik}} =
	\sum_{i=1}^{N}\log\Bigl(g(b_i)\Bigr),</code>
</p>

<p>where <code class="reqn">g</code> denotes a density of
(multivariate) normal distribution
<code class="reqn">N(\gamma, D),</code> where
<code class="reqn">\gamma</code> is a sampled value of the mean of random
effect vector and <code class="reqn">D</code> is a sampled value of the covariance
matrix of the random effects at each iteration.      
</p>
</dd>
<dt>mixmoment.sim</dt><dd><p>three columns labeled <code>k</code>, <code>Intercept</code> and
<code>Scale</code>. These are the number of mixture components, mean and
standard deviation of the sampled error distribution (mixture) at
each iteration.</p>
</dd>
<dt>mweight.sim</dt><dd><p>each row contains mixture weights
<code class="reqn">w_1,\dots,w_k</code>
at each iteration. From the header of this file, maximal number of mixture
components specified in the prior can be derived.</p>
</dd>
<dt>mmean.sim</dt><dd><p>each row contains mixture means
<code class="reqn">\mu_1,\dots,\mu_k</code>
at each iteration. From the header of this file, maximal number of mixture
components specified in the prior can be derived.</p>
</dd>
<dt>mvariance.sim</dt><dd><p>each row contains mixture variances
<code class="reqn">\sigma^2_1,\dots,\sigma^2_k</code> at each
iteration. From the header of this file, maximal number of mixture
components specified in the prior can be derived.</p>
</dd>    
<dt>beta.sim</dt><dd><p>columns labeled according to name of the design
matrix. These are sampled values of regression parameters
<code class="reqn">\beta</code> and means of random effects <code class="reqn">\gamma</code>
(except the mean of the random intercept which is zero).</p>
</dd>
<dt>b.sim</dt><dd><p>columns labeled <code>nameb[1].id[1], ...,
	nameb[q].id[1], ..., nameb[1].id[N], ..., nameb[q].id[N]</code>,
where <code>q</code> is a dimension of the random effect vector
<code class="reqn">b_i</code> and <code>N</code> number of clusters. <code>nameb</code>
is replaced by appropriate column name from the design matrix and
<code>id</code> is replaced by identificator of the clusters. This gives
sampled values of the random effects for each cluster.</p>
</dd>
<dt>D.sim</dt><dd><p>columns labeled <code>det, D.s.t, s = 1,..., q, t =
	s,...,q</code>, where <code>q</code> is dimension of the random effect
vector <code class="reqn">b_i</code>. Column <code>det</code> gives a determinant of
the covariance matrix <code class="reqn">D</code> of the random effects at each
iteration, remaining columns give a lower triangle of this matrix
at each iteration.</p>
</dd>
<dt>Y.sim</dt><dd><p>columns labeled <code>Y[m]</code> where <code>m</code> goes from 1
to <code class="reqn">\sum_{i=1}^{N}n_i</code>. This gives sampled
log-event times for each observation in the dataset at each
iteration.</p>
</dd>
<dt>r.sim</dt><dd><p>columns labeled <code>r[m]</code> where <code>m</code> goes from 1
to <code class="reqn">\sum_{i=1}^{N}n_i</code>. This gives sampled
mixture labels for each observation in the dataset at each iteration.</p>
</dd>
<dt>otherp.sim</dt><dd><p>Currently only one column labeled <code>eta</code> that
gives sampled values of the hyperparameter <code class="reqn">\eta</code>.</p>
</dd>
<dt>MHinfo.sim</dt><dd><p>this gives the information concerning the
performance of reversible jump algorithm and a sampler of
regression parameters <code class="reqn">\beta</code> and means of random
effects <code class="reqn">\gamma</code>. It has columns
</p>

<dl>
<dt><code>accept.spl.comb</code></dt><dd><p>relative frequency of accepted
split-combine moves up to that iteration.</p>
</dd>
<dt><code>split</code></dt><dd><p>relative frequency of proposed split moves
up to that iteration.</p>
</dd>
<dt><code>accept.birth.death</code></dt><dd><p>relative frequency of accepted
birth-death moves up to that iteration.</p>
</dd>
<dt><code>birth</code></dt><dd><p>relative frequency of proposed birth moves
up to that iteration.</p>
</dd>
<dt><code>beta.block.m</code></dt><dd><p>with <code>m</code> going from 1 to number
of defined blocks of beta parameters. This gives a relative
frequency of accepted proposals for each block up to that
iteration. When Gibbs move is used, these should be columns of
ones.</p>
</dd>
</dl>
	
</dd>
<dt>MHbinfo.sim</dt><dd><p>this gives the information concerning the
performance of a sampler for random effects (relative frequency of
accepted values for each cluster and each block of random effects
updated together). When Gibbs move is used only ones are seen in
this file.</p>
</dd>
<dt>u.sim</dt><dd><p>Sampled values of canonical proposal variables for
reversible jump algorithm are stored here. This file is useful
only when trying to restart the simulation from some specific point.</p>
</dd>
<dt>regresres.sim</dt><dd><p>columns labeled <code>res[m]</code> where <code>m</code> goes from 1
to <code class="reqn">\sum_{i=1}^{N}n_i</code> This stores so called
regression residuals for each observation at each iteration. This
residual is defined as
</p>
<p style="text-align: center;"><code class="reqn">res_{i,l} = y_{i,l} - \beta^T x_{i,l} - b_i z_{i,l},\qquad
	i=1\dots,N,\quad l=1,\dots,n_i,</code>
</p>
<p> where <code class="reqn">y_{i,l}</code> is a (sampled)
log-event time at each iteration.
</p>
</dd>
</dl>
        


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Komárek, A. (2006).
<em>Accelerated Failure Time Models for Multivariate
Interval-Censored Data with Flexible Distributional Assumptions</em>.
PhD. Thesis, Katholieke Universiteit Leuven, Faculteit Wetenschappen.
</p>
<p>Komárek, A. and Lesaffre, E. (2007).
Bayesian accelerated failure time model for correlated interval-censored data
with a normal mixture as an error distribution.
<em>Statistica Sinica</em>, <b>17</b>, 549 - 569.
</p>
<p>Brooks, S. P., Giudici, P., and Roberts, G. O. (2003).
Efficient construction of reversible jump Markov chain Monte Carlo
proposal distribution (with Discussion).
<em>Journal of the Royal Statistical Society B,</em> <b>65,</b> 3 - 55.
</p>
<p>Green, P. J. (1995).
Reversible jump MCMC computation and Bayesian model determination.
<em>Biometrika,</em> <b>82,</b> 711 - 732.
</p>
<p>Richardson, S., and Green, P. J. (1997).
On Bayesian analysis of mixtures with unknown number of components (with
Discussion).
<em>Journal of the Royal Statistical Society B,</em> <b>59,</b> 731 - 792.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the description of R commands for
## the models described in
## Komarek (2006),
## Komarek and Lesaffre (2007).
## 
## R commands available
## in the documentation
## directory of this package as
## - ex-cgd.R and
##   https://www2.karlin.mff.cuni.cz/~komarek/software/bayesSurv/ex-cgd.pdf
##
## - ex-tandmobMixture.R and
##   https://www2.karlin.mff.cuni.cz/~komarek/software/bayesSurv/ex-tandmobMixture.pdf
##
</code></pre>

<hr>
<h2 id='bayessurvreg1.files2init'>
Read the initial values for the Bayesian survival regression model to the list.
</h2><span id='topic+bayessurvreg1.files2init'></span>

<h3>Description</h3>

<p>This function creates the list of initial values as required by the <code>init</code>
argument of the function <code><a href="#topic+bayessurvreg1">bayessurvreg1</a></code>. The initials are taken from
the files that are of the form of the files where the simulated values from
the McMC run performed by the function <code><a href="#topic+bayessurvreg1">bayessurvreg1</a></code> are stored.
The files are assumed to have the following names: &quot;iteration.sim&quot;,
&quot;mixmoment.sim&quot;, &quot;mweight.sim&quot;, &quot;mmean.sim&quot;, &quot;mvariance.sim&quot;,   
&quot;beta.sim&quot;, &quot;b.sim&quot;, &quot;Y.sim&quot;, &quot;r.sim&quot;, &quot;D.sim&quot;, &quot;otherp.sim&quot;, &quot;u.sim&quot;. Some of these files
may be missing. In that case, the corresponding initial is filled by <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayessurvreg1.files2init(dir = getwd(), row, kmax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayessurvreg1.files2init_+3A_dir">dir</code></td>
<td>
<p>string giving the directory where it will be searched for the files with 
initial values.</p>
</td></tr>
<tr><td><code id="bayessurvreg1.files2init_+3A_row">row</code></td>
<td>
<p>the row (possible header does not count) from the files with the
values that will be considered to give the initial values. By default,
it is the last row from the files.</p>
</td></tr>
<tr><td><code id="bayessurvreg1.files2init_+3A_kmax">kmax</code></td>
<td>
<p>maximal number of mixture components. This must be given
only if <code>header == FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components called &quot;iter&quot;, &quot;mixture&quot;, &quot;beta&quot;, &quot;b&quot;, &quot;D&quot;, &quot;y&quot;,
&quot;r&quot;, &quot;otherp&quot;, &quot;u&quot;
in the form as required by the argument <code>init</code> of the function <code><a href="#topic+bayessurvreg1">bayessurvreg1</a></code>.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>

<hr>
<h2 id='bayessurvreg1.help'>
Helping function for Bayesian survival regression models, version 1.
</h2><span id='topic+bayessurvreg1.help'></span><span id='topic+bayessurvreg1.checkStore'></span><span id='topic+bayessurvreg1.priorInit'></span><span id='topic+bayessurvreg1.priorBeta'></span><span id='topic+bayessurvreg1.priorb'></span><span id='topic+bayessurvreg1.writeHeaders'></span><span id='topic+bayessurvreg1.revjump'></span>

<h3>Description</h3>

<p>These functions are not to be called by ordinary users.
</p>
<p>These are just sub-parts of &lsquo;bayessurvreg1&rsquo; function to make it more
readable for the programmer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayessurvreg1.checkStore(store)

bayessurvreg1.priorInit(prior, init, Yinit, Xinit, n, nX, nrandom,
   ncluster, indb, randomInt, toler.chol)

bayessurvreg1.priorBeta(prior.beta, nX, indb, factors,
   n.factors, n.in.factors)

bayessurvreg1.priorb(prior.b, nrandom, ncluster, toler.chol)

bayessurvreg1.writeHeaders(dir, prior, store, nX, X, names.random,
   ncluster, nrandom, rnamesX, unique.cluster, nBetaBlocks, nbBlocks)

bayessurvreg1.revjump(prop.revjump)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayessurvreg1.help_+3A_store">store</code></td>
<td>
<p>a~list as required by the <code>store</code> argument of the
function <code><a href="#topic+bayessurvreg1">bayessurvreg1</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg1.help_+3A_prior">prior</code>, <code id="bayessurvreg1.help_+3A_init">init</code>, <code id="bayessurvreg1.help_+3A_yinit">Yinit</code>, <code id="bayessurvreg1.help_+3A_xinit">Xinit</code>, <code id="bayessurvreg1.help_+3A_n">n</code>, <code id="bayessurvreg1.help_+3A_nx">nX</code>, <code id="bayessurvreg1.help_+3A_nrandom">nrandom</code>, <code id="bayessurvreg1.help_+3A_ncluster">ncluster</code></td>
<td>
<p>???</p>
</td></tr>
<tr><td><code id="bayessurvreg1.help_+3A_indb">indb</code>, <code id="bayessurvreg1.help_+3A_randomint">randomInt</code>, <code id="bayessurvreg1.help_+3A_toler.chol">toler.chol</code></td>
<td>
<p>???</p>
</td></tr>
<tr><td><code id="bayessurvreg1.help_+3A_prior.beta">prior.beta</code>, <code id="bayessurvreg1.help_+3A_factors">factors</code>, <code id="bayessurvreg1.help_+3A_n.factors">n.factors</code>, <code id="bayessurvreg1.help_+3A_n.in.factors">n.in.factors</code></td>
<td>
<p>???</p>
</td></tr>
<tr><td><code id="bayessurvreg1.help_+3A_prior.b">prior.b</code></td>
<td>
<p>???</p>
</td></tr>  
<tr><td><code id="bayessurvreg1.help_+3A_prop.revjump">prop.revjump</code></td>
<td>
<p>???</p>
</td></tr>
<tr><td><code id="bayessurvreg1.help_+3A_dir">dir</code>, <code id="bayessurvreg1.help_+3A_x">X</code>, <code id="bayessurvreg1.help_+3A_names.random">names.random</code></td>
<td>
<p>???</p>
</td></tr>
<tr><td><code id="bayessurvreg1.help_+3A_rnamesx">rnamesX</code>, <code id="bayessurvreg1.help_+3A_unique.cluster">unique.cluster</code>, <code id="bayessurvreg1.help_+3A_nbetablocks">nBetaBlocks</code>, <code id="bayessurvreg1.help_+3A_nbblocks">nbBlocks</code></td>
<td>
<p>???</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Some lists.
</p>


<h3>Value for bayessurvreg1.priorb</h3>

<p>A~list with the following components:
</p>

<dl>
<dt>double</dt><dd><p>double vector for C++ constructor of class
<code>bblocks</code>. It has the following parts:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <b>priordD</b>       </td>
</tr>
<tr>
 <td style="text-align: left;">
      <b>covparLV</b>      </td>
</tr>
<tr>
 <td style="text-align: left;">
      <b>halfRangeUnif</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
      <b>weightUnif</b>    </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>
      
</dd>
<dt>integer</dt><dd><p>integer vector for C++ constructor of class
<code>bblocks</code>. It has the following parts:
</p>

<table>
<tr>
 <td style="text-align: left;">
        <b>nrandom</b>    </td>
</tr>
<tr>
 <td style="text-align: left;">
        <b>ncluster</b>   </td>
</tr>
<tr>
 <td style="text-align: left;">
        <b>priorD</b>     </td>
</tr>
<tr>
 <td style="text-align: left;">
        <b>typeUpd</b>    </td>
</tr>
<tr>
 <td style="text-align: left;">
        <b>nBlocks</b>    </td>
</tr>
<tr>
 <td style="text-align: left;">
        <b>nInBlock</b>   </td>
</tr>
<tr>
 <td style="text-align: left;">
        <b>lcovparLV</b>  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<b>indBlockLV</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>
    
</dd>
</dl>

<p>and the following attributes:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>prior.b</b>        </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>

<hr>
<h2 id='bayessurvreg2'>
Cluster-specific accelerated failure time model for multivariate,
possibly doubly-interval-censored data. The error distribution is
expressed as a penalized univariate normal mixture with high number of
components (G-spline). The distribution of the vector of random
effects is multivariate normal.  
</h2><span id='topic+bayessurvreg2'></span><span id='topic+C_bayessurvreg2'></span>

<h3>Description</h3>

<p>A function to estimate a regression model with possibly clustered
(possibly right, left, interval or doubly-interval censored) data.
In the case of doubly-interval censoring, different regression models
can be specified for the onset and event times.
</p>
<p>(Multivariate) random effects, normally distributed and  acting as
in the linear mixed model, normally distributed, can be included to
adjust for clusters.
</p>
<p>The error density of the regression model is specified as a mixture of
Bayesian G-splines (normal densities with equidistant means and
constant variances). This function performs an MCMC sampling from the
posterior distribution of unknown quantities.
</p>
<p>For details, see Komárek (2006),
and Komárek, Lesaffre and Legrand (2007).
</p>
<p>We explain first in more detail a model without doubly censoring.
Let <code class="reqn">T_{i,l},\; i=1,\dots, N,\; l=1,\dots, n_i</code>
be event times for <code class="reqn">i</code>th cluster and the units within that cluster
The following regression model is assumed:
</p>
<p style="text-align: center;"><code class="reqn">\log(T_{i,l}) = \beta'x_{i,l} + b_i'z_{i,l} + \varepsilon_{i,l},\quad i=1,\dots, N,\;l=1,\dots, n_i</code>
</p>

<p>where <code class="reqn">\beta</code> is unknown regression parameter vector,
<code class="reqn">x_{i,l}</code> is a vector of covariates.
<code class="reqn">b_i</code> is a (multivariate) cluster-specific random effect
vector and <code class="reqn">z_{i,l}</code> is a vector of covariates for random
effects.
</p>
<p>The random effect vectors <code class="reqn">b_i,\;i=1,\dots, N</code>
are assumed to be i.i.d. with a (multivariate) normal distribution
with the mean <code class="reqn">\beta_b</code> and a covariance matrix
<code class="reqn">D</code>. Hierarchical centring (see Gelfand, Sahu, Carlin, 1995) is
used. I.e. <code class="reqn">\beta_b</code> expresses the average effect of the
covariates included in <code class="reqn">z_{i,l}</code>. Note that covariates
included in <code class="reqn">z_{i,l}</code> may not be included in the covariate
vector <code class="reqn">x_{i,l}</code>. The covariance matrix <code class="reqn">D</code> is
assigned an inverse Wishart prior distribution in the next level of hierarchy.
</p>
<p>The error terms
<code class="reqn">\varepsilon_{i,l},\;i=1,\dots, N, l=1,\dots, n_i</code>
are assumed to be i.i.d. with a univariate density
<code class="reqn">g_{\varepsilon}(e)</code>. This density is expressed as
a mixture of Bayesian G-splines (normal densities with equidistant
means and constant variances). We distinguish two,
theoretically equivalent, specifications.
</p>

<dl>
<dt>Specification 1</dt><dd>
<p style="text-align: center;"><code class="reqn">\varepsilon \sim
	\sum_{j=-K}^{K} w_{j} N(\mu_{j},\,\sigma^2)</code>
</p>

<p>where <code class="reqn">\sigma^2</code> is the
<b>unknown</b> basis variance and
<code class="reqn">\mu_{j},\;j=-K,\dots, K</code>
is an equidistant grid of knots symmetric around the
<b>unknown</b> point <code class="reqn">\gamma</code> 
and related to the unknown basis variance through the
relationship
</p>
<p style="text-align: center;"><code class="reqn">\mu_{j} = \gamma + j\delta\sigma,\quad j=-K,\dots,K,</code>
</p>

<p>where <code class="reqn">\delta</code> is fixed
constants, e.g. <code class="reqn">\delta=2/3</code>
(which has a justification of being close to cubic B-splines).

</p>
</dd>
<dt>Specification 2</dt><dd>
<p style="text-align: center;"><code class="reqn">\varepsilon \sim \alpha + \tau\,V</code>
</p>

<p>where <code class="reqn">\alpha</code> is an
<b>unknown</b> intercept term and
<code class="reqn">\tau</code> is an <b>unknown</b> scale parameter.
<code class="reqn">V</code> is then
standardized error term which is distributed according
to the univariate normal mixture, i.e.
</p>
<p style="text-align: center;"><code class="reqn">V\sim \sum_{j=-K}^{K}
	w_{j} N(\mu_{j},\,\sigma^2)</code>
</p>

<p>where <code class="reqn">\mu_{j},\;j=-K,\dots, K</code>
is an equidistant grid of <b>fixed</b> knots (means), usually
symmetric about the <b>fixed</b> point <code class="reqn">\gamma=0</code> and
<code class="reqn">\sigma^2</code> is <b>fixed</b> basis variance.
Reasonable values for the numbers of grid
points <code class="reqn">K</code> is
<code class="reqn">K=15</code> with the distance between the two
knots equal to <code class="reqn">\delta=0.3</code> and for the basis
variance
<code class="reqn">\sigma^2=0.2^2.</code>
</p>
</dd>  
</dl>

<p>Personally, I found Specification 2 performing better. In the paper
Komárek, Lesaffre and Legrand (2007) only
Specification 2 is described.
</p>
<p>The mixture weights
<code class="reqn">w_{j},\;j=-K,\dots, K</code> are
not estimated directly. To avoid the constraints
<code class="reqn">0 &lt; w_{j} &lt; 1</code> and
<code class="reqn">\sum_{j=-K}^{K}\,w_j = 1</code>
transformed weights <code class="reqn">a_{j},\;j=-K,\dots, K</code>
related to the original weights by the logistic transformation:
</p>
<p style="text-align: center;"><code class="reqn">a_{j} = \frac{\exp(w_{j})}{\sum_{m}\exp(w_{m})}</code>
</p>

<p>are estimated instead.
</p>
<p>A Bayesian model is set up for all unknown parameters. For more
details I refer to Komárek (2006)
and to Komárek, Lesafre, and Legrand (2007).
</p>
<p>If there are doubly-censored data the model of the same type as above
can be specified for both the onset time and the time-to-event. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayessurvreg2(formula, random, formula2, random2,
   data = parent.frame(),
   na.action = na.fail, onlyX = FALSE,
   nsimul = list(niter = 10, nthin = 1, nburn = 0, nwrite = 10),
   prior, prior.beta, prior.b, init = list(iter = 0),
   mcmc.par = list(type.update.a = "slice", k.overrelax.a = 1,
                   k.overrelax.sigma = 1, k.overrelax.scale = 1),
   prior2, prior.beta2, prior.b2, init2,
   mcmc.par2 = list(type.update.a = "slice", k.overrelax.a = 1,
                    k.overrelax.sigma = 1, k.overrelax.scale = 1),
   store = list(a = FALSE, a2 = FALSE, y = FALSE, y2 = FALSE,
                r = FALSE, r2 = FALSE, b = FALSE, b2 = FALSE), 
   dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayessurvreg2_+3A_formula">formula</code></td>
<td>
<p>model formula for the regression. In the case of
doubly-censored data, this is the model formula for the onset
time.
</p>
<p>The left-hand side of the <code>formula</code> must be an object created
using <code><a href="survival.html#topic+Surv">Surv</a></code>.
</p>
<p>In the formula all covariates appearing both in the vector
<code class="reqn">x_{i,l}</code> and <code class="reqn">z_{i,l}</code> must be
mentioned. Intercept is implicitely included in the model by the
estimation of the error distribution. As a consequence <code>-1</code> in
the model formula does not have any effect on the model
specification.
</p>
<p>If <code>random</code> is used then the formula must contain
an identification of clusters in the form <code>cluster(id)</code>, where
<code>id</code> is a name of the variable that determines clusters, e.g.
</p>

<table>
<tr>
 <td style="text-align: center;">
      <code>Surv(time, event) gender + cluster(id)</code>.
    </td>
</tr>

</table>
     
</td></tr>  
<tr><td><code id="bayessurvreg2_+3A_random">random</code></td>
<td>
<p>formula for the &lsquo;random&rsquo; part of the model, i.e. the
part that specifies the covariates <code class="reqn">z_{i,l}</code>. In the
case of doubly-censored data, this is the <code>random</code> formula for
the onset time.
</p>
<p>If omitted, no random part is included in the model. E.g. to specify the model with a
random intercept, say <code>random= 1</code>. All effects mentioned in
<code>random</code> should also be mentioned on the right-hand side of
<code>formula</code>.
</p>
<p>When some random effects are included the random intercept is added
by default. It can be removed using e.g. <code>random= -1 + gender</code>.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg2_+3A_formula2">formula2</code></td>
<td>
<p>model formula for the regression of the time-to-event in
the case of doubly-censored data. Ignored otherwise. The same structure as
for <code>formula</code> applies here.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg2_+3A_random2">random2</code></td>
<td>
<p>specification of the &lsquo;random&rsquo; part of the model for
time-to-event in the case of doubly-censored data. Ignored
otherwise. The same structure as for <code>random</code> applies here.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg2_+3A_data">data</code></td>
<td>
<p>optional data frame in which to interpret the variables
occuring in the <code>formula</code>, <code>formula2</code>, <code>random</code>,
<code>random2</code> statements.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg2_+3A_na.action">na.action</code></td>
<td>
<p>the user is discouraged from changing the default
value <code>na.fail</code>.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg2_+3A_onlyx">onlyX</code></td>
<td>
<p>if <code>TRUE</code> no MCMC sampling is performed and only the
design matrix (matrices) are returned. This can be useful to set up
correctly priors for regression parameters in the presence of
<code>factor</code> covariates.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg2_+3A_nsimul">nsimul</code></td>
<td>
<p>a list giving the number of iterations of the MCMC and
other parameters of the simulation.
</p>

<dl>
<dt>niter</dt><dd><p>total number of sampled values after discarding
thinned ones, burn-up included;</p>
</dd>
<dt>nthin</dt><dd><p>thinning interval;</p>
</dd>
<dt>nburn</dt><dd><p>number of sampled values in a burn-up period after
discarding thinned values. This value should be smaller than
<code>niter</code>. If not, <code>nburn</code> is set to <code>niter - 1</code>. It can be set to zero;</p>
</dd>
<dt>nwrite</dt><dd><p>an interval at which information about the number of
performed iterations is print on the screen and during the
burn-up period an interval with which the sampled values are
writen to files;</p>
</dd>
</dl>
    
</td></tr>  
<tr><td><code id="bayessurvreg2_+3A_prior">prior</code></td>
<td>
<p>a list specifying the prior distribution of the G-spline
defining the distribution of the error term in the regression model
given by <code>formula</code> and <code>random</code>. See <code>prior</code> argument of
<code><a href="#topic+bayesHistogram">bayesHistogram</a></code> function for more detail. In this list
also &lsquo;Specification&rsquo; as described above is specified.
</p>
<p>The item <code>prior$neighbor.system</code> can only be equal to
<code>uniCAR</code> here.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg2_+3A_prior.b">prior.b</code></td>
<td>
<p>a list defining the way in which the random effects
involved in <code>formula</code> and <code>random</code>
are to be updated and the specification
of priors for parameters related to these random effects. The list
is assumed to have the following components.
</p>

<dl>
<dt>prior.D</dt><dd><p>a string defining the prior distribution for the
covariance matrix of random effects <code class="reqn">D</code>. It can be either
&ldquo;inv.wishart&rdquo; or &ldquo;sduniform&rdquo;.
</p>

<dl>
<dt>inv.wishart</dt><dd><p>in that case is assumed that the prior distribution
of the matrix <code class="reqn">D</code> is Inverse-Wishart with degrees of freedom
equal to <code class="reqn">\tau</code> and a scale matrix equal to
<code class="reqn">S</code>. When <code class="reqn">D</code> is a matrix <code class="reqn">q\times q</code> a
prior expectation of <code class="reqn">D</code> is equal to
<code class="reqn">(\tau - q - 1)^{-1}S</code> if
<code class="reqn">\tau &gt; q + 1</code>. For
<code class="reqn">q - 1 &lt; \tau \leq q + 1</code> a prior
expectation is not finite.	
Degrees of freedom parameter <code class="reqn">\tau</code> does not have to be an
integer. It has to only satisfy a condition
<code class="reqn">\tau &gt; q - 1</code>. <code>prior.b$df.D</code> gives a prior
degrees of freedom parameter <code class="reqn">\tau</code> and
<code>prior.b$scale.D</code> determines the scale matrix <code class="reqn">D</code>.
Inverse-Wishart is also the default choice.
</p>
</dd>
<dt>sduniform</dt><dd><p>this can be used only when the random effect is
univariate (e.g. only random intercept in the model).
Then the matrix <code class="reqn">D</code> is just a scalar and the
prior of <code class="reqn">\sqrt{D}</code> (standard deviation of the
univariate random effect) is assumed to be uniform on interval
<code class="reqn">(0, S)</code>. The upper limit <code class="reqn">S</code> is given by <code>prior.b$scale.D</code>.
</p>
</dd>	
</dl>
  
</dd>  
<dt>df.D</dt><dd><p>degrees of freedom parameter <code class="reqn">\tau</code> in the case
that the prior of the matrix <code class="reqn">D</code> is inverse-Wishart.
</p>
</dd>
<dt>scale.D</dt><dd><p>a lower triangle of the scale matrix <code class="reqn">S</code> in
the case that the prior of the matrix <code class="reqn">D</code> is
inverse-Wishart or the upper limit <code class="reqn">S</code> of the uniform distribution in
the case that <code class="reqn">\sqrt{D} \sim \mbox{Unif}(0, S)</code>.
</p>
</dd>    
</dl>
  
</td></tr>  
<tr><td><code id="bayessurvreg2_+3A_prior.beta">prior.beta</code></td>
<td>
<p>prior specification for the regression parameters,
in the case of doubly-censored data for the regression parameters of
the onset time, i.e. it is related to <code>formula</code> and
<code>random</code>.
Note that the <code>beta</code> vector contains both the fixed effects
<code class="reqn">\beta</code> and the means of the random effects (except the
random intercept) <code class="reqn">\beta_b</code>.
</p>
<p>This should be a list with the following components:
</p>

<dl>
<dt>mean.prior</dt><dd><p>a vector specifying a prior mean for each
<code>beta</code> parameter in the model.</p>
</dd>
<dt>var.prior</dt><dd><p>a vector specifying a prior variance for each
<code>beta</code> parameter.</p>
</dd>
</dl>

<p>It is recommended to run the function
bayessurvreg2 first with its argument <code>onlyX</code> set to <code>TRUE</code>
to find out how the betas are sorted. They must correspond to a
design matrix X taken from <code>formula</code>.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg2_+3A_init">init</code></td>
<td>
<p>an optional list with initial values for the MCMC related
to the model given by <code>formula</code> and <code>random</code>. The list can have the following components:
</p>

<dl>
<dt>iter</dt><dd><p>the number of the iteration to which the initial values
correspond, usually zero.</p>
</dd>
<dt>beta</dt><dd><p>a vector of initial values for the regression
parameters (both the fixed effects and means of the random
effects).
It must be sorted in the same way as are the columns
in the design matrix. Use <code>onlyX=TRUE</code> if you do not know how
the columns in the design matrix are created.</p>
</dd>
<dt>a</dt><dd><p>a vector of length <code class="reqn">2K+1</code> with the initial values of transformed mixture weights.</p>
</dd>
<dt>lambda</dt><dd><p>initial values for the Markov random fields precision parameter. 
</p>
</dd>
<dt>gamma</dt><dd><p>an initial values for the middle
knot <code class="reqn">\gamma.</code>
</p>
<p>If &lsquo;Specification&rsquo; is 2, this value will not be changed
by the MCMC and it is recommended (for easier
interpretation of the results) to set <code>init$gamma</code> to zero
(default behavior).
</p>
<p>If &lsquo;Specification&rsquo; is 1 <code>init$gamma</code> should be
approximately equal to the mean value of the residuals.
</p>
</dd>
<dt>sigma</dt><dd><p>an initial values of the basis
standard deviation <code class="reqn">\sigma</code>.
</p>
<p>If &lsquo;Specification&rsquo; is 2, this value will not be changed
by the MCMC and it is recommended to set it
approximately equal to the range of standardized data
(let say 4 + 4)
divided by the number of knots and
multiplied by something like 2/3.
</p>
<p>If &lsquo;Specification&rsquo; is 1
this should be approximately equal to the range of the residuals
divided by the number of knots <code class="reqn">(2K+1)</code> and
multiplied again by something like 2/3.
</p>
</dd>  
<dt>intercept</dt><dd><p>an initial values of the
intercept term <code class="reqn">\alpha</code>.
</p>
<p>If &lsquo;Specification&rsquo; is 1 this value is not changed by the
MCMC and the initial value is always changed to zero.</p>
</dd>
<dt>scale</dt><dd><p>an initial value of the scale
parameter <code class="reqn">\tau</code>.
</p>
<p>If &lsquo;Specification&rsquo; is 1 this value is not changed by the MCMC
and the initial value is always changed to one.</p>
</dd>
<dt>D</dt><dd><p>initial value for the covariance matrix of random effects
<code class="reqn">D</code>. Only its lower triangle must be given in a vector,
e.g. <code>c(d[1,1], d[2,1], d[3,1], d[2,2], d[3,2], d[3,3])</code>
for a matrix <code class="reqn">3 \times 3</code>.</p>
</dd>
<dt>b</dt><dd><p>a vector or matrix of the initial values of random effects
<code class="reqn">b_i,\;i=1,\dots,N</code>
for each cluster. The matrix should be of size
<code class="reqn">q\times N</code>, where <code class="reqn">q</code> is the number of random
effects. I.e. each column of the matrix contains the initial
values for one cluster.</p>
</dd>
<dt>y</dt><dd><p>a vector of length <code class="reqn">\sum_{i=1}^N\,n_i</code>
with initial values of log-event-times.</p>
</dd>
<dt>r</dt><dd><p>a vector of length <code class="reqn">\sum_{i=1}^N\,n_i</code>
with initial
component labels for each residual. All values must be between
<code class="reqn">-K</code> and <code class="reqn">K.</code> See argument <code>init</code> of
the function <code><a href="#topic+bayesHistogram">bayesHistogram</a></code> for more details.</p>
</dd>
</dl>

</td></tr>  
<tr><td><code id="bayessurvreg2_+3A_mcmc.par">mcmc.par</code></td>
<td>
<p>a list specifying how some of the G-spline parameters
related to the distribution of the error term from <code>formula</code>
are to be updated. See <code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code> for more
details.
</p>
<p>In contrast to <code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code> function argument
<code>mcmc.par$type.update.a</code> can also be equal to
<code>"block"</code> in which case all <code class="reqn">a</code> coefficients are updated
in 1 block using the Metropolis-Hastings algorithm. 
</p>
</td></tr>  
<tr><td><code id="bayessurvreg2_+3A_prior2">prior2</code></td>
<td>
<p>a list specifying the prior distribution of the G-spline
defining the distribution of the error term in the regression model
given by <code>formula2</code> and <code>random2</code>. See <code>prior</code> argument of
<code><a href="#topic+bayesHistogram">bayesHistogram</a></code> function for more detail.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg2_+3A_prior.b2">prior.b2</code></td>
<td>
<p>prior specification for the parameters related to the
random effects from <code>formula2</code> and <code>random2</code>. This should
be a list with the same structure as <code>prior.b</code>.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg2_+3A_prior.beta2">prior.beta2</code></td>
<td>
<p>prior specification for the regression parameters
of time-to-event in the case of doubly censored data (related to
<code>formula2</code> and <code>random2</code>).
This should be a list with the same structure as <code>prior.beta</code>.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg2_+3A_init2">init2</code></td>
<td>
<p>an optional list with initial values for the MCMC related
to the model given by <code>formula2</code> and <code>random2</code>.
The list has the same structure as <code>init</code>.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg2_+3A_mcmc.par2">mcmc.par2</code></td>
<td>
<p>a list specifying how some of the G-spline parameters
related to <code>formula2</code> are to be updated. The list has the same
structure as <code>mcmc.par</code>.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg2_+3A_store">store</code></td>
<td>
<p>a list of logical values specifying which chains that are
not stored by default are to be stored. The list can have the
following components.
</p>

<dl>
<dt>a</dt><dd><p>if <code>TRUE</code> then all the transformed mixture weights
<code class="reqn">a_{k},</code>
<code class="reqn">k=-K,\dots,K,</code>
related to the G-spline (error distribution) of <code>formula</code> are stored.</p>
</dd>
<dt>a2</dt><dd><p>if <code>TRUE</code> and there are doubly-censored data then
all the transformed mixture weights
<code class="reqn">a_{k},</code>
<code class="reqn">k=-K,\dots,K,</code>
related to the G-spline (error distribution) of <code>formula2</code> are stored.</p>
</dd>
<dt>y</dt><dd><p>if <code>TRUE</code> then augmented log-event times for all
observations related to the <code>formula</code> are stored.</p>
</dd>
<dt>y2</dt><dd><p>if <code>TRUE</code> then augmented log-event times for all
observations related to <code>formula2</code> are stored.</p>
</dd>
<dt>r</dt><dd><p>if <code>TRUE</code> then labels of mixture components for
residuals related to <code>formula</code> are stored.</p>
</dd>
<dt>r2</dt><dd><p>if <code>TRUE</code> then labels of mixture components for
residuals related to <code>formula2</code> are stored.</p>
</dd>
<dt>b</dt><dd><p>if <code>TRUE</code> then the sampled values of the random
effects related to <code>formula</code> and <code>random</code> are stored.</p>
</dd>
<dt>b2</dt><dd><p>if <code>TRUE</code> then the sampled values of the random
effects related to <code>formula2</code> and <code>random2</code> are stored.</p>
</dd>
</dl>
  
</td></tr>  
<tr><td><code id="bayessurvreg2_+3A_dir">dir</code></td>
<td>
<p>a string that specifies a directory where all sampled
values are to be stored.
</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A list of class <code>bayessurvreg2</code> containing an information
concerning the initial values and prior choices.
</p>


<h3>Files created</h3>

  
<p>Additionally, the following files with sampled values
are stored in a directory specified by <code>dir</code> argument of this
function (some of them are created only on request, see <code>store</code>
parameter of this function).
</p>
<p>Headers are written to all files created by default and to files asked
by the user via the argument <code>store</code>. During the burn-in, only
every <code>nsimul$nwrite</code> value is written. After the burn-in, all
sampled values are written in files created by default and to files
asked by the user via the argument <code>store</code>. In the files for
which the corresponding <code>store</code> component is <code>FALSE</code>, every
<code>nsimul$nwrite</code> value is written during the whole MCMC (this
might be useful to restart the MCMC from some specific point).
</p>
<p>The following files are created:
</p>

<dl>
<dt>iteration.sim</dt><dd><p>one column labeled <code>iteration</code> with
indeces of MCMC iterations to which the stored sampled values
correspond.
</p>
</dd>
<dt>mixmoment.sim</dt><dd><p>columns labeled <code>k</code>, <code>Mean.1</code>, 
<code>D.1.1</code>, where
</p>
<p><b>k</b> = number of mixture components that had probability
numerically higher than zero;
</p>
<p><b>Mean.1</b> =
<code class="reqn">\mbox{E}(\varepsilon_{i,l})</code>;
</p>
<p><b>D.1.1</b> =
<code class="reqn">\mbox{var}(\varepsilon_{i,l})</code>;
</p>
<p>all related to the distribution of the error term from the
model given by <code>formula</code>.
</p>
</dd>
<dt>mixmoment_2.sim</dt><dd><p>in the case of doubly-censored data, the same
structure as <code>mixmoment.sim</code>, however related to the model
given by <code>formula2</code>.      
</p>
</dd>
<dt>mweight.sim</dt><dd><p>sampled mixture weights
<code class="reqn">w_{k}</code> of mixture components that had
probabilities numerically higher than zero. Related to the model
given by <code>formula</code>.
</p>
</dd>
<dt>mweight_2.sim</dt><dd><p>in the case of doubly-censored data, the same
structure as <code>mweight.sim</code>, however related to the model
given by <code>formula2</code>. 
</p>
</dd>
<dt>mmean.sim</dt><dd><p>indeces <code class="reqn">k,</code>
<code class="reqn">k \in\{-K, \dots, K\}</code>
of mixture components that had probabilities numerically higher
than zero. It corresponds to the weights in
<code>mweight.sim</code>. Related to the model given by <code>formula</code>.
</p>
</dd>
<dt>mmean_2.sim</dt><dd><p>in the case of doubly-censored data, the same
structure as <code>mmean.sim</code>, however related to the model
given by <code>formula2</code>. 
</p>
</dd>
<dt>gspline.sim</dt><dd><p>characteristics of the sampled G-spline
(distribution of
<code class="reqn">\varepsilon_{i,l}</code>)
related to the model given by
<code>formula</code>. This file together with <code>mixmoment.sim</code>,
<code>mweight.sim</code> and <code>mmean.sim</code> can be used to reconstruct
the G-spline in each MCMC iteration.
</p>
<p>The file has columns labeled
<code>gamma1</code>,
<code>sigma1</code>,
<code>delta1</code>,
<code>intercept1</code>, 
<code>scale1</code>,
The meaning of the values in these columns is the following:
</p>
<p><b>gamma1</b> = the middle knot <code class="reqn">\gamma</code> 
If &lsquo;Specification&rsquo; is 2, this column usually contains zeros;
</p>
<p><b>sigma1</b> = basis standard deviation <code class="reqn">\sigma</code>
of the G-spline. This column contains a fixed value
if &lsquo;Specification&rsquo; is 2;
</p>
<p><b>delta1</b> = distance <code class="reqn">delta</code> between the two knots of the G-spline.
This column contains a fixed value if &lsquo;Specification&rsquo; is 2;
</p>
<p><b>intercept1</b> = the intercept term <code class="reqn">\alpha</code> of the G-spline.
If &lsquo;Specification&rsquo; is 1, this column usually contains zeros;
</p>
<p><b>scale1</b> = the scale parameter <code class="reqn">\tau</code> of the G-spline.
If &lsquo;Specification&rsquo; is 1, this column usually contains ones;
</p>
</dd>
<dt>gspline_2.sim</dt><dd><p>in the case of doubly-censored data, the same
structure as <code>gspline.sim</code>, however related to the model
given by <code>formula2</code>. 
</p>
</dd>
<dt>mlogweight.sim</dt><dd><p>fully created only if <code>store$a = TRUE</code>. The
file contains the transformed weights
<code class="reqn">a_{k},</code>
<code class="reqn">k=-K,\dots,K</code>
of all mixture components, i.e. also of components that had numerically zero
probabilities. This file is related to the error distribution of
the model given by <code>formula</code>.
</p>
</dd>
<dt>mlogweight_2.sim</dt><dd><p>fully created only if <code>store$a2 =
      TRUE</code> and in the case of doubly-censored data, the same
structure as <code>mlogweight.sim</code>, however related to the error
distribution of the model given by <code>formula2</code>. 
</p>
</dd>
<dt>r.sim</dt><dd><p>fully created only if <code>store$r = TRUE</code>. The file
contains the labels of the mixture components into which the
residuals are intrinsically assigned. Instead of indeces on the
scale <code class="reqn">\{-K,\dots, K\}</code>
values from 1 to <code class="reqn">(2\,K+1)</code> are stored here. Function
<code><a href="#topic+vecr2matr">vecr2matr</a></code> can be used to transform it back to
indices from <code class="reqn">-K</code> to <code class="reqn">K</code>.
</p>
</dd>
<dt>r_2.sim</dt><dd><p>fully created only if <code>store$r2 =
      TRUE</code> and in the case of doubly-censored data, the same
structure as <code>r.sim</code>, however related to the model
given by <code>formula2</code>. 
</p>
</dd>
<dt>lambda.sim</dt><dd><p>one column labeled <code>lambda</code>. These are the
values of the smoothing parameter<code class="reqn">\lambda</code>
(hyperparameters of the prior distribution of the transformed
mixture weights <code class="reqn">a_{k}</code>). This file is
related to the model given by <code>formula</code>.
</p>
</dd>
<dt>lambda_2.sim</dt><dd><p>in the case of doubly-censored data, the same
structure as <code>lambda.sim</code>, however related to the model
given by <code>formula2</code>. 
</p>
</dd>
<dt>beta.sim</dt><dd><p>sampled values of the regression parameters, both
the fixed effects <code class="reqn">\beta</code> and means of the random
effects <code class="reqn">\beta_b</code> (except the random intercept which
has always the mean equal to zero).
This file is related to the model given by <code>formula</code>.
The columns are labeled according to the
<code>colnames</code> of the design matrix.
</p>
</dd>
<dt>beta_2.sim</dt><dd><p>in the case of doubly-censored data, the same
structure as <code>beta.sim</code>, however related to the model
given by <code>formula2</code>. 
</p>
</dd>
<dt>D.sim</dt><dd><p>sampled values of the covariance matrix <code class="reqn">D</code> of
the random effects. The file has <code class="reqn">1 + 0.5\,q\,(q+1)</code> columns (<code class="reqn">q</code> is the dimension of the random
effect vector <code class="reqn">b_i</code>). The first column labeled <code>det</code>
contains the determinant of the sampled matrix, additional columns
labeled <code>D.1.1</code>, <code>D.2.1</code>, ..., <code>D.q.1</code>, ...
<code>D.q.q</code> contain the lower triangle of the sampled
matrix. This file is related to the model specified by
<code>formula</code> and <code>random</code>.
</p>
</dd>
<dt>D_2.sim</dt><dd><p>in the case of doubly-censored data, the same
structure as <code>D.sim</code>, however related to the model given by
<code>formula2</code> and <code>random2</code>.
</p>
</dd>
<dt>b.sim</dt><dd><p>fully created only if <code>store$b = TRUE</code>. It
contains sampled values of random effects for all clusters in
the data set. The file has <code class="reqn">q\times N</code> columns sorted as
<code class="reqn">b_{1,1},\dots,b_{1,q},\dots, b_{N,1},\dots,b_{N,q}</code>. This file is
related to the model given by <code>formula</code> and <code>random</code>.
</p>
</dd>
<dt>b_2.sim</dt><dd><p>fully created only if <code>store$b2 =
      TRUE</code> and in the case of doubly-censored data, the same
structure as <code>b.sim</code>, however related to the model
given by <code>formula2</code> and <code>random2</code>. 
</p>
</dd>  
<dt>Y.sim</dt><dd><p>fully created only if <code>store$y = TRUE</code>. It
contains sampled (augmented) log-event times for all observations
in the data set.
</p>
</dd>
<dt>Y_2.sim</dt><dd><p>fully created only if <code>store$y2 =
      TRUE</code> and in the case of doubly-censored data, the same
structure as <code>Y.sim</code>, however related to the model
given by <code>formula2</code>. 
</p>
</dd>
<dt>logposter.sim</dt><dd><p>columns labeled <code>loglik</code>, <code>penalty</code>,
and <code>logprw</code>. This file is related to the model
given by <code>formula</code>. The columns have the following meaning.
</p>
<p><b>loglik</b>
<code class="reqn">=</code> <code class="reqn">%
	- (\sum_{i=1}^N\,n_i)\,\Bigl\{\log(\sqrt{2\pi}) + \log(\sigma) \Bigr\}-
          0.5\sum_{i=1}^N\sum_{l=1}^{n_i}
	  \Bigl\{
	  (\sigma^2\,\tau^2)^{-1}\; (y_{i,l} - x_{i,l}'\beta - z_{i,l}'b_i -
	  \alpha - \tau\mu_{r_{i,l}})^2
          \Bigr\}
      </code>
</p>
<p>where <code class="reqn">y_{i,l}</code> denotes (augmented) <em>(i,l)</em>th
true log-event time.
</p>
<p>In other words, <code>loglik</code> is equal to the
conditional log-density
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i=1}^N \sum_{l=1}^{n_i}\,\log\Bigl\{p\bigl(y_{i,l}\;\big|\;r_{i,l},\,\beta,\,b_i,\,\mbox{G-spline}\bigr)\Bigr\};</code>
</p>

<p><b>penalty:</b>
the penalty term
</p>
<p style="text-align: center;"><code class="reqn">-\frac{1}{2}\sum_{k}\Bigl(\Delta\, a_k\Bigr)^2</code>
</p>

<p>(not multiplied by <code class="reqn">\lambda</code>);
</p>
<p><b>logprw</b> <code class="reqn">=</code>
<code class="reqn">-2\,(\sum_i n_i)\,\log\bigl\{\sum_{k}a_{k}\bigr\} +
	\sum_{k}N_{k}\,a_{k},</code>
where <code class="reqn">N_{k}</code> is the number of residuals
assigned intrinsincally to the <code class="reqn">k</code>th
mixture component.
</p>
<p>In other words, <code>logprw</code> is equal to the conditional
log-density
<code class="reqn">\sum_{i=1}^N\sum_{l=1}^{n_i} \log\bigl\{p(r_{i,l}\;|\;\mbox{G-spline
	  weights})\bigr\}.</code>
</p>
</dd>
<dt>logposter_2.sim</dt><dd><p>in the case of doubly-censored data, the same
structure as <code>logposter.sim</code>, however related to the model
given by <code>formula2</code>. 
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Gelfand, A. E., Sahu, S. K., and Carlin, B. P. (1995).
Efficient parametrisations for normal linear mixed models.
<em>Biometrika,</em> <b>82,</b> 479-488.
</p>
<p>Komárek, A. (2006).
<em>Accelerated Failure Time Models for Multivariate
Interval-Censored Data with Flexible Distributional Assumptions</em>.
PhD. Thesis, Katholieke Universiteit Leuven, Faculteit Wetenschappen.
</p>
<p>Komárek, A., Lesaffre, E., and Legrand, C. (2007).
Baseline and treatment effect heterogeneity for survival
times between centers using a random effects accelerated failure time
model with flexible error distribution.
<em>Statistics in Medicine,</em> <b>26</b>, 5457-5472.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the description of R commands for
## the model with EORTC data,
## analysis described in Komarek, Lesaffre and Legrand (2007).
##
## R commands available in the documentation
## directory of this package
## as ex-eortc.R and
## https://www2.karlin.mff.cuni.cz/ komarek/software/bayesSurv/ex-eortc.pdf
##
</code></pre>

<hr>
<h2 id='bayessurvreg2.help'>
Helping functions for Bayesian regression with an error distribution
smoothed using G-splines
</h2><span id='topic+bayessurvreg2.help'></span><span id='topic+bayessurvreg2.checkStore'></span><span id='topic+bayessurvreg2.priorInit'></span><span id='topic+bayessurvreg2.priorBeta'></span><span id='topic+bayessurvreg2.priorb'></span><span id='topic+bayessurvreg2.writeHeaders'></span>

<h3>Description</h3>

<p>These functions are not to be called by ordinary users.
</p>
<p>These are just sub-parts of &lsquo;bayessurvreg2&rsquo; function to make it more
readable for the programmer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayessurvreg2.checkStore(store)

bayessurvreg2.priorInit(prior, init, design, mcmc.par,
                        prior2, init2, design2, mcmc.par2, doubly)

bayessurvreg2.priorBeta(prior.beta, init, design)

bayessurvreg2.priorb(prior.b, init, design)

bayessurvreg2.writeHeaders(dir, doubly, prior.init, store, design, design2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayessurvreg2.help_+3A_store">store</code></td>
<td>
<p>a~list as required by the argument <code>store</code> of the
function <code><a href="#topic+bayessurvreg2">bayessurvreg2</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg2.help_+3A_prior">prior</code></td>
<td>
<p>a~list as required by the argument <code>prior</code> of the
function <code><a href="#topic+bayessurvreg2">bayessurvreg2</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg2.help_+3A_prior2">prior2</code></td>
<td>
<p>a~list as required by the argument <code>prior2</code> of the
function <code><a href="#topic+bayessurvreg2">bayessurvreg2</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg2.help_+3A_init">init</code></td>
<td>
<p>a~list as required by the argument <code>init</code> of the
function <code><a href="#topic+bayessurvreg2">bayessurvreg2</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg2.help_+3A_init2">init2</code></td>
<td>
<p>a~list as required by the argument <code>init2</code> of the
function <code><a href="#topic+bayessurvreg2">bayessurvreg2</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg2.help_+3A_mcmc.par">mcmc.par</code></td>
<td>
<p>a~list as required by the argument <code>mcmc.par</code> of the
function <code><a href="#topic+bayessurvreg2">bayessurvreg2</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg2.help_+3A_mcmc.par2">mcmc.par2</code></td>
<td>
<p>a~list as required by the argument <code>mcmc.par2</code> of the
function <code><a href="#topic+bayessurvreg2">bayessurvreg2</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg2.help_+3A_design">design</code></td>
<td>
<p>an~object as returned by the function
<code><a href="#topic+bayessurvreg.design">bayessurvreg.design</a></code> related to either the onset time
if doubly censored observations or to the event time. Remark:
<code>design$Y</code> contains original times and NOT their logarithmic transformations.</p>
</td></tr>
<tr><td><code id="bayessurvreg2.help_+3A_design2">design2</code></td>
<td>
<p>an~object as returned by the function
<code><a href="#topic+bayessurvreg.design">bayessurvreg.design</a></code> related to time-to-event
if doubly censored observations. Remark:
<code>design2$Y</code> contains original times and NOT their logarithmic transformations.</p>
</td></tr>    
<tr><td><code id="bayessurvreg2.help_+3A_doubly">doubly</code></td>
<td>
<p>logical indicating whether the response is doubly
censored or not</p>
</td></tr>  
<tr><td><code id="bayessurvreg2.help_+3A_prior.beta">prior.beta</code></td>
<td>
<p>a~list as required by the argument <code>prior.beta</code> or
<code>prior.beta2</code> of the function <code><a href="#topic+bayessurvreg2">bayessurvreg2</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg2.help_+3A_prior.b">prior.b</code></td>
<td>
<p>a~list as required by the argument <code>prior.b</code> or
<code>prior.b2</code> of the function <code><a href="#topic+bayessurvreg2">bayessurvreg2</a></code></p>
</td></tr>  
<tr><td><code id="bayessurvreg2.help_+3A_dir">dir</code></td>
<td>
<p>path to the directory where the sampled values are to be
stored</p>
</td></tr>
<tr><td><code id="bayessurvreg2.help_+3A_prior.init">prior.init</code></td>
<td>
<p>a~list as returned by the function
<code><a href="#topic+bayessurvreg2.priorInit">bayessurvreg2.priorInit</a></code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Some lists.
</p>


<h3>Value for bayessurvreg2.priorBeta</h3>

<p>A list with the following components:
</p>

<dl>
<dt>parmI</dt><dd><p>integer arguments for C++ <code>BetaGamma</code>
constructor</p>
</dd>
<dt>parmD</dt><dd><p>double arguments for C++ <code>BetaGamma</code>
constructor</p>
</dd>
</dl>

<p>and the following attributes:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>init</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>prior.beta</b> </td>
</tr>
<tr>
 <td style="text-align: left;">    
  </td>
</tr>

</table>
      


<h3>Value for bayessurvreg2.priorInit</h3>

<p>The same object as that returned by <code><a href="#topic+bayesBisurvreg.priorInit">bayesBisurvreg.priorInit</a></code>.
</p>


<h3>Value for bayessurvreg2.priorb</h3>

<p>A list with the following components:
</p>

<dl>
<dt>bparmI</dt><dd><p>integer arguments for C++ <code>RandomEff</code>
constructor</p>
</dd>
<dt>bparmD</dt><dd><p>double arguments for C++ <code>RandomEff</code>
constructor</p>
</dd>
<dt>DparmI</dt><dd><p>integer arguments for C++ <code>CovMatrix</code>
constructor</p>
</dd>
<dt>DparmD</dt><dd><p>double arguments for C++ <code>CovMatrix</code>
constructor</p>
</dd>    
</dl>

<p>and the following attributes:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>init.b</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>init.D</b> </td>
</tr>
<tr>
 <td style="text-align: left;">    
    <b>prior.b</b> </td>
</tr>
<tr>
 <td style="text-align: left;">    
  </td>
</tr>

</table>
      


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>

<hr>
<h2 id='bayessurvreg3'>
Cluster-specific accelerated failure time model for multivariate,
possibly doubly-interval-censored data with flexibly specified random effects
and/or error distribution.
</h2><span id='topic+bayessurvreg3'></span><span id='topic+bayessurvreg3Para'></span><span id='topic+C_iPML_misclass_GJK'></span>

<h3>Description</h3>

<p>A function to estimate a regression model with possibly clustered
(possibly right, left, interval or doubly-interval censored) data.
In the case of doubly-interval censoring, different regression models
can be specified for the onset and event times.
</p>
<p>A univariate random effect (random intercept)
with the distribution expressed as a penalized normal
mixture can be included in the model to adjust for clusters.
</p>
<p>The error density of the regression model is specified as a mixture of
Bayesian G-splines (normal densities with equidistant means and
constant variances). This function performs an MCMC sampling from the
posterior distribution of unknown quantities.
</p>
<p>For details, see Komárek (2006)
and Komárek and Lesaffre (2008).
</p>
<p>SUPPLEMENTED IN 06/2013:  Interval-censored times might be subject to
misclassification. In case of doubly-interval-censored data, the event
time might be subject to misclassification. For details, see
García-Zattera, Jara and Komárek (2016).  
</p>
<p>We explain first in more detail a model without doubly censoring.
Let <code class="reqn">T_{i,l},\; i=1,\dots, N,\; l=1,\dots, n_i</code>
be event times for <code class="reqn">i</code>th cluster and the units within that cluster
The following regression model is assumed:
</p>
<p style="text-align: center;"><code class="reqn">\log(T_{i,l}) = \beta'x_{i,l} + b_i + \varepsilon_{i,l},\quad i=1,\dots, N,\;l=1,\dots, n_i</code>
</p>

<p>where <code class="reqn">\beta</code> is unknown regression parameter vector,
<code class="reqn">x_{i,l}</code> is a vector of covariates.
<code class="reqn">b_i</code> is a cluster-specific random effect (random intercept).
</p>
<p>The random effects <code class="reqn">b_i,\;i=1,\dots, N</code>
are assumed to be i.i.d. with a univariate density <code class="reqn">g_{b}(b)</code>.
The error terms
<code class="reqn">\varepsilon_{i,l},\;i=1,\dots, N, l=1,\dots, n_i</code>
are assumed to be i.i.d. with a univariate density
<code class="reqn">g_{\varepsilon}(e)</code>.
</p>
<p>Densities <code class="reqn">g_{b}</code> and <code class="reqn">g_{\varepsilon}</code> are
both expressed as
a mixture of Bayesian G-splines (normal densities with equidistant
means and constant variances). We distinguish two,
theoretically equivalent, specifications.
</p>
<p>In the following, the density for <code class="reqn">\varepsilon</code>
is explicitely described. The density for <code class="reqn">b</code> is obtained in
an analogous manner.  
</p>

<dl>
<dt>Specification 1</dt><dd>
<p style="text-align: center;"><code class="reqn">\varepsilon \sim
	\sum_{j=-K}^{K} w_{j} N(\mu_{j},\,\sigma^2)</code>
</p>

<p>where <code class="reqn">\sigma^2</code> is the
<b>unknown</b> basis variance and
<code class="reqn">\mu_{j},\;j=-K,\dots, K</code>
is an equidistant grid of knots symmetric around the
<b>unknown</b> point <code class="reqn">\gamma</code> 
and related to the unknown basis variance through the
relationship
</p>
<p style="text-align: center;"><code class="reqn">\mu_{j} = \gamma + j\delta\sigma,\quad j=-K,\dots,K,</code>
</p>

<p>where <code class="reqn">\delta</code> is fixed
constants, e.g. <code class="reqn">\delta=2/3</code>
(which has a justification of being close to cubic B-splines).

</p>
</dd>
<dt>Specification 2</dt><dd>
<p style="text-align: center;"><code class="reqn">\varepsilon \sim \alpha + \tau\,V</code>
</p>

<p>where <code class="reqn">\alpha</code> is an
<b>unknown</b> intercept term and
<code class="reqn">\tau</code> is an <b>unknown</b> scale parameter.
<code class="reqn">V</code> is then
standardized error term which is distributed according
to the univariate normal mixture, i.e.
</p>
<p style="text-align: center;"><code class="reqn">V\sim \sum_{j=-K}^{K}
	w_{j} N(\mu_{j},\,\sigma^2)</code>
</p>

<p>where <code class="reqn">\mu_{j},\;j=-K,\dots, K</code>
is an equidistant grid of <b>fixed</b> knots (means), usually
symmetric about the <b>fixed</b> point <code class="reqn">\gamma=0</code> and
<code class="reqn">\sigma^2</code> is <b>fixed</b> basis variance.
Reasonable values for the numbers of grid
points <code class="reqn">K</code> is
<code class="reqn">K=15</code> with the distance between the two
knots equal to <code class="reqn">\delta=0.3</code> and for the basis
variance
<code class="reqn">\sigma^2=0.2^2.</code>
</p>
</dd>  
</dl>

<p>Personally, I found Specification 2 performing better. In the paper
Komárek and Lesaffre (2008) only Specification 2 is described.
</p>
<p>The mixture weights
<code class="reqn">w_{j},\;j=-K,\dots, K</code> are
not estimated directly. To avoid the constraints
<code class="reqn">0 &lt; w_{j} &lt; 1</code> and
<code class="reqn">\sum_{j=-K}^{K}\,w_j = 1</code>
transformed weights <code class="reqn">a_{j},\;j=-K,\dots, K</code>
related to the original weights by the logistic transformation:
</p>
<p style="text-align: center;"><code class="reqn">a_{j} = \frac{\exp(w_{j})}{\sum_{m}\exp(w_{m})}</code>
</p>

<p>are estimated instead.
</p>
<p>A Bayesian model is set up for all unknown parameters. For more
details I refer to Komárek and Lesaffre (2008).
</p>
<p>If there are doubly-censored data the model of the same type as above
can be specified for both the onset time and the time-to-event.
</p>
<p>In the case one wishes to link the random intercept of the onset model
and the random intercept of the time-to-event model, there are the
following possibilities.
</p>
<p><b>Bivariate normal distribution</b> <br />
It is assumed that the pair of random intercepts from the onset and
time-to-event part of the model are normally distributed with zero
mean and an unknown covariance matrix <code class="reqn">D</code>.
</p>
<p>A priori, the inverse covariance matrix <code class="reqn">D^{-1}</code> is
addumed to follow a Wishart distribution.
</p>
<p><b>Unknown correlation between the basis G-splines</b> <br />
Each pair of basis G-splines describing the distribution of the random
intercept in the onset part and the time-to-event part of the model is
assumed to be correlated with an unknown correlation coefficient
<code class="reqn">\varrho</code>. Note that this is just an experiment and is no
more further supported.
</p>
<p>Prior distribution on <code class="reqn">\varrho</code> is assumed to be
uniform. In the MCMC, the Fisher Z transform of the <code class="reqn">\varrho</code>
given by
</p>
<p style="text-align: center;"><code class="reqn">Z =
    -\frac{1}{2}\log\Bigl(\frac{1-\varrho}{1+\varrho}\Bigr)=\mbox{atanh}(\varrho)</code>
</p>

<p>is sampled. Its prior is derived from the uniform prior
<code class="reqn">\mbox{Unif}(-1,\;1)</code> put on <code class="reqn">\varrho.</code>
</p>
<p>The Fisher Z transform is updated using the Metropolis-Hastings
alhorithm. The proposal distribution is given either by a normal
approximation obtained using the Taylor expansion of the full
conditional distribution or by a Langevin proposal (see Robert and
Casella, 2004, p. 318).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayessurvreg3(formula, random, formula2, random2,
   data = parent.frame(),
   classification,
   classParam = list(Model = c("Examiner", "Factor:Examiner"),
                     a.sens = 1, b.sens = 1, a.spec = 1, b.spec = 1,
                     init.sens = NULL, init.spec = NULL),
   na.action = na.fail, onlyX = FALSE,
   nsimul = list(niter = 10, nthin = 1, nburn = 0, nwrite = 10),   
   prior, prior.beta, prior.b, init = list(iter = 0),
   mcmc.par = list(type.update.a = "slice", k.overrelax.a = 1,
                   k.overrelax.sigma = 1, k.overrelax.scale = 1,
                   type.update.a.b = "slice", k.overrelax.a.b = 1,
                   k.overrelax.sigma.b = 1, k.overrelax.scale.b = 1),
   prior2, prior.beta2, prior.b2, init2,
   mcmc.par2 = list(type.update.a = "slice", k.overrelax.a = 1,
                    k.overrelax.sigma = 1, k.overrelax.scale = 1,
                    type.update.a.b = "slice", k.overrelax.a.b = 1,
                    k.overrelax.sigma.b = 1, k.overrelax.scale.b = 1),
   priorinit.Nb,
   rho = list(type.update = "fixed.zero", init=0, sigmaL=0.1),
   store = list(a = FALSE, a2 = FALSE, y = FALSE, y2 = FALSE,
                r = FALSE, r2 = FALSE, b = FALSE, b2 = FALSE,
                a.b = FALSE, a.b2 = FALSE, r.b = FALSE, r.b2 = FALSE), 
   dir)

bayessurvreg3Para(formula, random, formula2, random2,
   data = parent.frame(),
   classification,
   classParam = list(Model = c("Examiner", "Factor:Examiner"),
                     a.sens = 1, b.sens = 1, a.spec = 1, b.spec = 1,
                     init.sens = NULL, init.spec = NULL),
   na.action = na.fail, onlyX = FALSE,
   nsimul = list(niter = 10, nthin = 1, nburn = 0, nwrite = 10),   
   prior, prior.beta, prior.b, init = list(iter = 0),
   mcmc.par = list(type.update.a = "slice", k.overrelax.a = 1,
                   k.overrelax.sigma = 1, k.overrelax.scale = 1,
                   type.update.a.b = "slice", k.overrelax.a.b = 1,
                   k.overrelax.sigma.b = 1, k.overrelax.scale.b = 1),
   prior2, prior.beta2, prior.b2, init2,
   mcmc.par2 = list(type.update.a = "slice", k.overrelax.a = 1,
                    k.overrelax.sigma = 1, k.overrelax.scale = 1,
                    type.update.a.b = "slice", k.overrelax.a.b = 1,
                    k.overrelax.sigma.b = 1, k.overrelax.scale.b = 1),
   priorinit.Nb,
   rho = list(type.update = "fixed.zero", init=0, sigmaL=0.1),
   store = list(a = FALSE, a2 = FALSE, y = FALSE, y2 = FALSE,
                r = FALSE, r2 = FALSE, b = FALSE, b2 = FALSE,
                a.b = FALSE, a.b2 = FALSE, r.b = FALSE, r.b2 = FALSE), 
   dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayessurvreg3_+3A_formula">formula</code></td>
<td>
<p>model formula for the regression. In the case of
doubly-censored data, this is the model formula for the onset
time.
</p>
<p>The left-hand side of the <code>formula</code> must be an object created
using <code><a href="survival.html#topic+Surv">Surv</a></code>.
</p>
<p>Intercept is implicitely included in the model by the
estimation of the error distribution. As a consequence <code>-1</code> in
the model formula does not have any effect on the model
specification.
</p>
<p>If <code>random</code> is used then the formula must contain
an identification of clusters in the form <code>cluster(id)</code>, where
<code>id</code> is a name of the variable that determines clusters, e.g.
</p>

<table>
<tr>
 <td style="text-align: center;">
      <code>Surv(time, event) gender + cluster(id)</code>.
    </td>
</tr>

</table>
     
</td></tr>  
<tr><td><code id="bayessurvreg3_+3A_random">random</code></td>
<td>
<p>formula for the &lsquo;random&rsquo; part of the model.
In the case of doubly-censored data, this is the <code>random</code> formula for
the onset time. With this version of the function only
</p>

<table>
<tr>
 <td style="text-align: center;">
      <code>random =  1</code>
    </td>
</tr>

</table>
     
<p>is allowed. If omitted, no random part is included in the model. 
</p>
</td></tr>  
<tr><td><code id="bayessurvreg3_+3A_formula2">formula2</code></td>
<td>
<p>model formula for the regression of the time-to-event in
the case of doubly-censored data. Ignored otherwise. The same structure as
for <code>formula</code> applies here.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg3_+3A_random2">random2</code></td>
<td>
<p>specification of the &lsquo;random&rsquo; part of the model for
time-to-event in the case of doubly-censored data. Ignored
otherwise. The same structure as for <code>random</code> applies here.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg3_+3A_data">data</code></td>
<td>
<p>optional data frame in which to interpret the variables
occuring in the <code>formula</code>, <code>formula2</code>, <code>random</code>,
<code>random2</code> statements.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg3_+3A_classification">classification</code></td>
<td>
<p><code>data.frame</code> with the
information for a model which considers misclassification of the
event times. It is assumed to have the following columns where the
position of columns is important, not their names:
</p>

<ol>
<li><p><b>idUnit</b>: variable which determines the rows of
<code>classification</code> matrix pertaining to one unit in
<code>formula/formula2</code> <code>data</code>. Number of unique <code>idUnit</code> values must be the
same as in <code>formula/formula2</code> <code>data</code>,
<code>classification</code> matrix must be sorted in the same order as
<code>formula/formula2</code> <code>data</code> and having all rows
pertaining to one unit in its consecutive rows.
</p>
</li>
<li><p><b>Time</b>: variable with the examination times. It is
assumed that the <code>Time</code>s are sorted in an increasing order
for each <code>idUnit</code>.      
</p>
</li>
<li><p><b>Examiner</b>: variable which determines the examiner who
performed evaluation at a specific visit. Number of unique
<code>Examiner</code> values determines the number of examiners.
</p>
</li>
<li><p><b>Status</b>: 0/1 variable giving the event status
according to examiner, 0 = no event, 1 = event.
</p>
</li>
<li><p><b>Factor</b>: possible factor (e.g., tooth in our dental
application which may influence the misclassification). Numeric
or character variables are converted to a <code>factor</code>. This
column is obligatory only if <code>classModel</code> is &ldquo;Factor:Examiner&rdquo;.
</p>
</li></ol>

<p>Possible additional columns are ignored.
</p>
<p>If missing, no misclassification is considered.
</p>
</td></tr>
<tr><td><code id="bayessurvreg3_+3A_classparam">classParam</code></td>
<td>
<p>a <code>list</code> with additional parameters for the
misclassification model. It is ignored if there is no
<code>classification</code> argument specified.
</p>
<p>The following components of the <code>list</code> <code>classParam</code> are expected.
</p>

<dl>
<dt>Model</dt><dd><p>a character string which specifies the model
considered. It can be 1. &ldquo;Examiner&rdquo;:
sensitivity and specificity depend only on <code>Examiner</code>,
2. &ldquo;Factor:Examiner&rdquo;: sensitivity and specificity is for each
examiner generally different for different levels of a factor <code>Factor</code>.
</p>
</dd>
<dt>a.sens</dt><dd><p>parameter &lsquo;a&rsquo; (<code>shape1</code>) of the beta prior distributions
for sensitivities.</p>
</dd>
<dt>b.sens</dt><dd><p>parameter &lsquo;b&rsquo; (<code>shape2</code>) of the beta prior distributions
for sensitivities.</p>
</dd>
<dt>a.spec</dt><dd><p>parameter &lsquo;a&rsquo; (<code>shape1</code>) of the beta prior distributions
for specificities.</p>
</dd>
<dt>b.spec</dt><dd><p>parameter &lsquo;b&rsquo; (<code>shape2</code>) of the beta prior distributions
for specificities.</p>
</dd>
<dt>init.sens</dt><dd><p>a vector or matrix with initial values of
sensitivities. A vector is expected if <code>Model</code> is
&ldquo;Examiner&rdquo; in which case each component of the vector
corresponds to each examiner. A matrix is expected if
<code>Model</code> is &ldquo;Factor:Examiner&rdquo; in which case rows of
the matrix correspond to the values of <code>Factor</code> and columns
to examiners.
</p>
<p>If not given then the initial sensitivities are sampled from a
uniform distribution on (0.8, 0.9).
</p>
</dd>
<dt>init.spec</dt><dd><p>a vector or matrix with initial values of
specificities. The structure is the same as for <code>init.sens</code>.</p>
</dd>      
</dl>
  
</td></tr>
<tr><td><code id="bayessurvreg3_+3A_na.action">na.action</code></td>
<td>
<p>the user is discouraged from changing the default
value <code>na.fail</code>.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg3_+3A_onlyx">onlyX</code></td>
<td>
<p>if <code>TRUE</code> no MCMC sampling is performed and only the
design matrix (matrices) are returned. This can be useful to set up
correctly priors for regression parameters in the presence of
<code>factor</code> covariates.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg3_+3A_nsimul">nsimul</code></td>
<td>
<p>a list giving the number of iterations of the MCMC and
other parameters of the simulation.
</p>

<dl>
<dt>niter</dt><dd><p>total number of sampled values after discarding
thinned ones, burn-up included;</p>
</dd>
<dt>nthin</dt><dd><p>thinning interval;</p>
</dd>
<dt>nburn</dt><dd><p>number of sampled values in a burn-up period after
discarding thinned values. This value should be smaller than
<code>niter</code>. If not, <code>nburn</code> is set to <code>niter - 1</code>. It can be set to zero;</p>
</dd>
<dt>nwrite</dt><dd><p>an interval at which information about the number of
performed iterations is print on the screen and during the
burn-up period an interval with which the sampled values are
writen to files;</p>
</dd>
</dl>
    
</td></tr>  
<tr><td><code id="bayessurvreg3_+3A_prior">prior</code></td>
<td>
<p>a list specifying the prior distribution of the G-spline
defining the distribution of the error term in the regression model
given by <code>formula</code> and <code>random</code>. See <code>prior</code> argument of
<code><a href="#topic+bayesHistogram">bayesHistogram</a></code> function for more detail. In this list
also &lsquo;Specification&rsquo; as described above is specified.
</p>
<p>The item <code>prior$neighbor.system</code> can only be equal to
<code>uniCAR</code> here.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg3_+3A_prior.b">prior.b</code></td>
<td>
<p>a list specifying the prior distribution of the
G-spline defining the distribution of the random intercept in the
regression model given by <code>formula</code> and <code>random</code>. See
<code>prior</code> argument of <code><a href="#topic+bayesHistogram">bayesHistogram</a></code> function for
more detail. In this list
also &lsquo;Specification&rsquo; as described above is specified.
</p>
<p>It is ignored if the argument <code>priorinit.Nb</code> is given.
</p>
<p>The item <code>prior.b$neighbor.system</code> can only be equal to
<code>uniCAR</code> here.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg3_+3A_prior.beta">prior.beta</code></td>
<td>
<p>prior specification for the regression parameters,
in the case of doubly-censored data for the regression parameters of
the onset time, i.e. it is related to <code>formula</code> and
<code>random</code>.
</p>
<p>This should be a list with the following components:
</p>

<dl>
<dt>mean.prior</dt><dd><p>a vector specifying a prior mean for each
<code>beta</code> parameter in the model.</p>
</dd>
<dt>var.prior</dt><dd><p>a vector specifying a prior variance for each
<code>beta</code> parameter.</p>
</dd>
</dl>

<p>It is recommended to run the function
bayessurvreg3 first with its argument <code>onlyX</code> set to <code>TRUE</code>
to find out how the betas are sorted. They must correspond to a
design matrix X taken from <code>formula</code>.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg3_+3A_init">init</code></td>
<td>
<p>an optional list with initial values for the MCMC related
to the model given by <code>formula</code> and <code>random</code>. The list can have the following components:
</p>

<dl>
<dt>iter</dt><dd><p>the number of the iteration to which the initial values
correspond, usually zero.</p>
</dd>
<dt>beta</dt><dd><p>a vector of initial values for the regression
parameters.
It must be sorted in the same way as are the columns
in the design matrix. Use <code>onlyX=TRUE</code> if you do not know how
the columns in the design matrix are created.</p>
</dd>
<dt>a</dt><dd><p>a vector of length <code class="reqn">2K+1</code> with the initial
values of transformed mixture weights for the G-spline defining
the distribution of the error term <code class="reqn">\varepsilon</code>.</p>
</dd>
<dt>lambda</dt><dd><p>initial values for the Markov random fields precision
parameter for the G-spline defining
the distribution of the error term <code class="reqn">\varepsilon</code>. 
</p>
</dd>
<dt>gamma</dt><dd><p>an initial values for the middle
knot <code class="reqn">\gamma</code> for the G-spline defining
the distribution of the error term <code class="reqn">\varepsilon</code>.
</p>
<p>If &lsquo;Specification&rsquo; is 2, this value will not be changed
by the MCMC and it is recommended (for easier
interpretation of the results) to set <code>init$gamma</code> to zero
(default behavior).
</p>
<p>If &lsquo;Specification&rsquo; is 1 <code>init$gamma</code> should be
approximately equal to the mean value of the residuals.
</p>
</dd>
<dt>sigma</dt><dd><p>an initial values of the basis
standard deviation <code class="reqn">\sigma</code> for the G-spline defining
the distribution of the error term <code class="reqn">\varepsilon</code>.
</p>
<p>If &lsquo;Specification&rsquo; is 2, this value will not be changed
by the MCMC and it is recommended to set it
approximately equal to the range of standardized data
(let say 4 + 4)
divided by the number of knots and
multiplied by something like 2/3.
</p>
<p>If &lsquo;Specification&rsquo; is 1
this should be approximately equal to the range of the residuals
divided by the number of knots <code class="reqn">(2K+1)</code> and
multiplied again by something like 2/3.
</p>
</dd>  
<dt>intercept</dt><dd><p>an initial values of the
intercept term <code class="reqn">\alpha</code> for the G-spline defining
the distribution of the error term <code class="reqn">\varepsilon</code>.
</p>
<p>If &lsquo;Specification&rsquo; is 1 this value is not changed by the
MCMC and the initial value is always changed to zero.</p>
</dd>
<dt>scale</dt><dd><p>an initial value of the scale
parameter <code class="reqn">\tau</code> for the G-spline defining
the distribution of the error term <code class="reqn">\varepsilon</code>.
</p>
<p>If &lsquo;Specification&rsquo; is 1 this value is not changed by the MCMC
and the initial value is always changed to one.</p>
</dd>
<dt>a.b</dt><dd><p>a vector of length <code class="reqn">2K+1</code> with the initial
values of transformed mixture weights for the G-spline defining
the distribution of the random intercept <code class="reqn">b</code>.</p>
</dd>
<dt>lambda.b</dt><dd><p>initial values for the Markov random fields precision
parameter for the G-spline defining
the distribution of the random intercept <code class="reqn">b</code>. 
</p>
</dd>
<dt>gamma.b</dt><dd><p>an initial values for the middle
knot <code class="reqn">\gamma</code> for the G-spline defining
the distribution of the random intercept <code class="reqn">b</code>.
</p>
<p>Due to identifiability reasons, this value is always changed to
zero and is for neither &lsquo;Specification&rsquo; updated by the
MCMC.
</p>
</dd>
<dt>sigma.b</dt><dd><p>an initial values of the basis
standard deviation <code class="reqn">\sigma</code> for the G-spline defining
the distribution of the random intercept <code class="reqn">b</code>.
</p>
<p>If &lsquo;Specification&rsquo; is 2, this value will not be changed
by the MCMC and it is recommended to set it
approximately equal to the range of standardized data
(let say 4 + 4)
divided by the number of knots and
multiplied by something like 2/3.
</p>
<p>If &lsquo;Specification&rsquo; is 1
this should be approximately equal to the range of the residuals
divided by the number of knots <code class="reqn">(2K+1)</code> and
multiplied again by something like 2/3.
</p>
</dd>  
<dt>intercept.b</dt><dd><p>an initial values of the
intercept term <code class="reqn">\alpha</code> for the G-spline defining
the distribution of the random intercept <code class="reqn">b</code>.
</p>
<p>Due to identifiability reasons, this value is always changed to
zero and is for neither &lsquo;Specification&rsquo; updated by the
MCMC.
</p>
</dd>
<dt>scale.b</dt><dd><p>an initial value of the scale
parameter <code class="reqn">\tau</code> for the G-spline defining
the distribution of the random intercept <code class="reqn">b</code>.
</p>
<p>If &lsquo;Specification&rsquo; is 1 this value is not changed by the MCMC
and the initial value is always changed to one.</p>
</dd>
<dt>b</dt><dd><p>a vector of length <code class="reqn">N</code> of the initial values of random effects
<code class="reqn">b_i,\;i=1,\dots,N</code>
for each cluster.</p>
</dd>
<dt>y</dt><dd><p>a vector of length <code class="reqn">\sum_{i=1}^N\,n_i</code>
with initial values of log-event-times.</p>
</dd>
<dt>r</dt><dd><p>a vector of length <code class="reqn">\sum_{i=1}^N\,n_i</code>
with initial
component labels for each residual. All values must be between
<code class="reqn">-K</code> and <code class="reqn">K.</code> See argument <code>init</code> of
the function <code><a href="#topic+bayesHistogram">bayesHistogram</a></code> for more details.</p>
</dd>
<dt>r.b</dt><dd><p>a vector of length <code class="reqn">N</code>
with initial
component labels for each random intercept. All values must be between
<code class="reqn">-K</code> and <code class="reqn">K.</code> See argument <code>init</code> of
the function <code><a href="#topic+bayesHistogram">bayesHistogram</a></code> for more details.</p>
</dd>    
</dl>
 
</td></tr>  
<tr><td><code id="bayessurvreg3_+3A_mcmc.par">mcmc.par</code></td>
<td>
<p>a list specifying how some of the G-spline parameters
related to the distribution of the error term and of the random
intercept from <code>formula</code> and <code>random</code>
are to be updated. See <code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code> for more
details.
</p>
<p>Compared to the mcmc.par argument of the function
<code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code> additional components related to the
G-spline for the random intercept can be present, namely
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>type.update.a.b</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>k.overrelax.a.b</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>k.overrelax.sigma.b</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>k.overrelax.scale.b</code>
    </td>
</tr>

</table>

<p>In contrast to <code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code> function arguments
<code>mcmc.par$type.update.a</code> and <code>mcmc.par$type.update.a.b</code> can also be equal to
<code>"block"</code> in which case all <code class="reqn">a</code> coefficients are updated
in 1 block using the Metropolis-Hastings algorithm. 
</p>
</td></tr>  
<tr><td><code id="bayessurvreg3_+3A_prior2">prior2</code></td>
<td>
<p>a list specifying the prior distribution of the G-spline
defining the distribution of the error term in the regression model
given by <code>formula2</code> and <code>random2</code>. See <code>prior</code> argument of
<code><a href="#topic+bayesHistogram">bayesHistogram</a></code> function for more detail.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg3_+3A_prior.b2">prior.b2</code></td>
<td>
<p>prior specification for the parameters related to the
random effects from <code>formula2</code> and <code>random2</code>. This should
be a list with the same structure as <code>prior.b</code>.
</p>
<p>It is ignored if the argument <code>priorinit.Nb</code> is given.    
</p>
</td></tr>  
<tr><td><code id="bayessurvreg3_+3A_prior.beta2">prior.beta2</code></td>
<td>
<p>prior specification for the regression parameters
of time-to-event in the case of doubly censored data (related to
<code>formula2</code> and <code>random2</code>).
This should be a list with the same structure as <code>prior.beta</code>.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg3_+3A_init2">init2</code></td>
<td>
<p>an optional list with initial values for the MCMC related
to the model given by <code>formula2</code> and <code>random2</code>.
The list has the same structure as <code>init</code>.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg3_+3A_mcmc.par2">mcmc.par2</code></td>
<td>
<p>a list specifying how some of the G-spline parameters
related to <code>formula2</code> and <code>random2</code> are to be updated.
The list has the same structure as <code>mcmc.par</code>.
</p>
</td></tr>  
<tr><td><code id="bayessurvreg3_+3A_priorinit.nb">priorinit.Nb</code></td>
<td>
<p>a list specifying the prior of the random intercepts
in the case of the AFT model with doubly-interval-censored data and
onset, time-to-event random intercepts following bivariate normal
distribution.
</p>
<p>The list should have the following components.
</p>

<dl>
<dt>init.D</dt><dd><p>initial value for the covariance matrix of the onset
random intercept and time-to-event random intercept.
</p>
<p>It can be specified either as a vector of length 3 giving the
lower triangle of the matrix or as a matrix 2 x 2.
</p>
</dd>	
<dt>df.Di</dt><dd><p>degrees of freedom <code class="reqn">\nu</code> for the Wishart prior of the
matrix <code class="reqn">D^{-1}</code>.
</p>
<p>Note that it must be higher than 1.
</p>
</dd>
<dt>scale.Di</dt><dd><p>scale matrix <code class="reqn">S</code> for the Wishart prior of the
matrix <code class="reqn">D^{-1}</code>.
</p>
<p>It can be specified either as a vector of length 3 giving the
lower triangle of the matrix or as a matrix 2 x 2.
</p>
<p>Note that a priori
</p>
<p style="text-align: center;"><code class="reqn">\mbox{E}(D^{-1}.) = \nu S</code>
</p>

</dd>      
</dl>
  
</td></tr>    
<tr><td><code id="bayessurvreg3_+3A_rho">rho</code></td>
<td>
<p>a list specifying possible correlation between the onset
random intercept and the time-to-event random intercept in the
experimental version of the model. If not given correlation is fixed
to <code class="reqn">0</code>.
</p>
<p>It is ignored if the argument <code>priorinit.Nb</code> is given.
Ordinary users should not care about this argument.
</p>
<p>The list can have the following components.
</p>

<dl>
<dt>type.update</dt><dd><p>character specifying how the Fisher Z transform
of the correlation coefficient is updated. Possible values are:
</p>
<p><code>"fixed.zero"</code>:
correlation coefficient is fixed to <code class="reqn">0</code> and it is not updated.
</p>
<p><code>"normal.around.mode"</code>:
at each iteration of MCMC, 1 Newton-Raphson step from the
current point <code class="reqn">Z</code> of the full conditional distribution is
performed, normal approximation is formed by Taylor expansion
and new point <code class="reqn">Z</code> is sampled from that normal
approximation.
</p>
<p>Note that this proposal does not work too well if the current
point <code class="reqn">Z</code> lies in the area of low posterior mass. The
reason is that even 1 Newton-Raphson step usually leads to the
area of high posterior probability mass and the proposal is
&ldquo;too ambisious&rdquo;.
</p>
<p><code>"langevin"</code>.
at each iteration of MCMC, new point <code class="reqn">Z</code> is sampled
using the Langevin algorithm. A scale parameter (see below)
must cerefully be chosen for this algorithm to ensure that the
acceptance rate is about 50&ndash;60% (Robert, Casella, 2004, p. 319).
</p>
</dd>		
</dl>
  
</td></tr>  
<tr><td><code id="bayessurvreg3_+3A_store">store</code></td>
<td>
<p>a list of logical values specifying which chains that are
not stored by default are to be stored. The list can have the
following components.
</p>

<dl>
<dt>a</dt><dd><p>if <code>TRUE</code> then all the transformed mixture weights
<code class="reqn">a_{k},</code>
<code class="reqn">k=-K,\dots,K,</code>
related to the G-spline defining the error distribution of <code>formula</code>
are stored.</p>
</dd>
<dt>a.b</dt><dd><p>if <code>TRUE</code> then all the transformed mixture weights
<code class="reqn">a_{k},</code>
<code class="reqn">k=-K,\dots,K,</code>
related to the G-spline defining the distribution of the random
intercept from <code>formula</code> and <code>random</code> are stored.</p>
</dd>
<dt>a2</dt><dd><p>if <code>TRUE</code> and there are doubly-censored data then
all the transformed mixture weights
<code class="reqn">a_{k},</code>
<code class="reqn">k=-K,\dots,K,</code>
related to the G-spline defining the error distribution of
<code>formula2</code> are stored.</p>
</dd>
<dt>a.b2</dt><dd><p>if <code>TRUE</code> then all the transformed mixture weights
<code class="reqn">a_{k},</code>
<code class="reqn">k=-K,\dots,K,</code>
related to the G-spline defining the distribution of the random
intercept from <code>formula2</code> and <code>random2</code> are stored.</p>
</dd>      
<dt>y</dt><dd><p>if <code>TRUE</code> then augmented log-event times for all
observations related to the <code>formula</code> are stored.</p>
</dd>
<dt>y2</dt><dd><p>if <code>TRUE</code> then augmented log-event times for all
observations related to <code>formula2</code> are stored.</p>
</dd>
<dt>r</dt><dd><p>if <code>TRUE</code> then labels of mixture components for
residuals related to <code>formula</code> are stored.</p>
</dd>      
<dt>r.b</dt><dd><p>if <code>TRUE</code> then labels of mixture components for
random intercepts related to <code>formula</code> and <code>random</code>
are stored.</p>
</dd>      
<dt>r2</dt><dd><p>if <code>TRUE</code> then labels of mixture components for
residuals related to <code>formula2</code> are stored.</p>
</dd>
<dt>r.b2</dt><dd><p>if <code>TRUE</code> then labels of mixture components for
random intercepts related to <code>formula2</code> and <code>random2</code>
are stored.</p>
</dd>            
<dt>b</dt><dd><p>if <code>TRUE</code> then the sampled values of the random
interceptss related to <code>formula</code> and <code>random</code> are stored.</p>
</dd>
<dt>b2</dt><dd><p>if <code>TRUE</code> then the sampled values of the random
interceptss related to <code>formula2</code> and <code>random2</code> are stored.</p>
</dd>
</dl>
  
</td></tr>  
<tr><td><code id="bayessurvreg3_+3A_dir">dir</code></td>
<td>
<p>a string that specifies a directory where all sampled
values are to be stored.
</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A list of class <code>bayessurvreg3</code> containing an information
concerning the initial values and prior choices.
</p>


<h3>Files created</h3>


<p>Additionally, the following files with sampled values
are stored in a directory specified by <code>dir</code> argument of this
function (some of them are created only on request, see <code>store</code>
parameter of this function).
</p>
<p>Headers are written to all files created by default and to files asked
by the user via the argument <code>store</code>. During the burn-in, only
every <code>nsimul$nwrite</code> value is written. After the burn-in, all
sampled values are written in files created by default and to files
asked by the user via the argument <code>store</code>. In the files for
which the corresponding <code>store</code> component is <code>FALSE</code>, every
<code>nsimul$nwrite</code> value is written during the whole MCMC (this
might be useful to restart the MCMC from some specific point).
</p>
<p>The following files are created:
</p>

<dl>
<dt>iteration.sim</dt><dd><p>one column labeled <code>iteration</code> with
indeces of MCMC iterations to which the stored sampled values
correspond.
</p>
</dd>
<dt>mixmoment.sim</dt><dd><p>this file is related to the density of the
error term from the model given by <code>formula</code>.
</p>
<p>Columns labeled <code>k</code>, <code>Mean.1</code>, 
<code>D.1.1</code>, where
</p>
<p><b>k</b> = number of mixture components that had probability
numerically higher than zero;
</p>
<p><b>Mean.1</b> =
<code class="reqn">\mbox{E}(\varepsilon_{i,l})</code>;
</p>
<p><b>D.1.1</b> =
<code class="reqn">\mbox{var}(\varepsilon_{i,l})</code>.
</p>
</dd>
<dt>mixmoment_b.sim</dt><dd><p>this file is related to the density of the
random intercept from the model given by <code>formula</code> and
<code>random</code>.
</p>
<p>The same structure as <code>mixmoment.sim</code>.
</p>
</dd>
<dt>mixmoment_2.sim</dt><dd><p>in the case of doubly-censored data. This
file is related to the density of the error term from the model
given by <code>formula2</code>.
</p>
<p>The same structure as <code>mixmoment.sim</code>.
</p>
</dd>
<dt>mixmoment_b2.sim</dt><dd><p>in the case of doubly-censored data. This
file is related to the density of the random intercept from the model
given by <code>formula2</code> and <code>random2</code>.
</p>
<p>The same structure as <code>mixmoment.sim</code>.
</p>
</dd>    
<dt>mweight.sim</dt><dd><p>this file is related to the density of the
error term from the model given by <code>formula</code>.
</p>
<p>Sampled mixture weights <code class="reqn">w_{k}</code> of mixture components that had
probabilities numerically higher than zero. 
</p>
</dd>
<dt>mweight_b.sim</dt><dd><p>this file is related to the density of the
random intercept from the model given by <code>formula</code> and
<code>random</code>.
</p>
<p>The same structure as <code>mweight.sim</code>.
</p>
</dd>
<dt>mweight_2.sim</dt><dd><p>in the case of doubly-censored data. This
file is related to the density of the error term from the model
given by <code>formula2</code>.
</p>
<p>The same structure as <code>mweight.sim</code>.
</p>
</dd>
<dt>mweight_b2.sim</dt><dd><p>in the case of doubly-censored data. This
file is related to the density of the random intercept from the model
given by <code>formula2</code> and <code>random2</code>.
</p>
<p>The same structure as <code>mweight.sim</code>.
</p>
</dd>    
<dt>mmean.sim</dt><dd><p>this file is related to the density of the
error term from the model given by <code>formula</code>.
</p>
<p>Indeces <code class="reqn">k,</code>
<code class="reqn">k \in\{-K, \dots, K\}</code>
of mixture components that had probabilities numerically higher
than zero. It corresponds to the weights in
<code>mweight.sim</code>. 
</p>
</dd>
<dt>mmean_b.sim</dt><dd><p>this file is related to the density of the
random intercept from the model given by <code>formula</code> and
<code>random</code>.
</p>
<p>The same structure as <code>mmean.sim</code>.
</p>
</dd>
<dt>mmean_2.sim</dt><dd><p>in the case of doubly-censored data. This
file is related to the density of the error term from the model
given by <code>formula2</code>.
</p>
<p>The same structure as <code>mmean.sim</code>.
</p>
</dd>
<dt>mmean_b2.sim</dt><dd><p>in the case of doubly-censored data. This
file is related to the density of the random intercept from the model
given by <code>formula2</code> and <code>random2</code>.
</p>
<p>The same structure as <code>mmean.sim</code>.
</p>
</dd>    
<dt>gspline.sim</dt><dd><p>this file is related to the density of the
error term from the model given by <code>formula</code>.
</p>
<p>Characteristics of the sampled G-spline.
This file together with <code>mixmoment.sim</code>,
<code>mweight.sim</code> and <code>mmean.sim</code> can be used to reconstruct
the G-spline in each MCMC iteration.
</p>
<p>The file has columns labeled
<code>gamma1</code>,
<code>sigma1</code>,
<code>delta1</code>,
<code>intercept1</code>, 
<code>scale1</code>,
The meaning of the values in these columns is the following:
</p>
<p><b>gamma1</b> = the middle knot <code class="reqn">\gamma</code> 
If &lsquo;Specification&rsquo; is 2, this column usually contains zeros;
</p>
<p><b>sigma1</b> = basis standard deviation <code class="reqn">\sigma</code>
of the G-spline. This column contains a fixed value
if &lsquo;Specification&rsquo; is 2;
</p>
<p><b>delta1</b> = distance <code class="reqn">delta</code> between the two knots of the G-spline.
This column contains a fixed value if &lsquo;Specification&rsquo; is 2;
</p>
<p><b>intercept1</b> = the intercept term <code class="reqn">\alpha</code> of the G-spline.
If &lsquo;Specification&rsquo; is 1, this column usually contains zeros;
</p>
<p><b>scale1</b> = the scale parameter <code class="reqn">\tau</code> of the G-spline.
If &lsquo;Specification&rsquo; is 1, this column usually contains ones;
</p>
</dd>
<dt>gspline_b.sim</dt><dd><p>this file is related to the density of the
random intercept from the model given by <code>formula</code> and
<code>random</code>.
</p>
<p>The same structure as <code>gspline.sim</code>.
</p>
</dd>
<dt>gspline_2.sim</dt><dd><p>in the case of doubly-censored data. This
file is related to the density of the error term from the model
given by <code>formula2</code>.
</p>
<p>The same structure as <code>gspline.sim</code>.
</p>
</dd>
<dt>gspline_b2.sim</dt><dd><p>in the case of doubly-censored data. This
file is related to the density of the random intercept from the model
given by <code>formula2</code> and <code>random2</code>.
</p>
<p>The same structure as <code>gspline.sim</code>.
</p>
</dd>    
<dt>mlogweight.sim</dt><dd><p>this file is related to the density of the
error term from the model given by <code>formula</code>.
</p>
<p>Fully created only if <code>store$a = TRUE</code>. The
file contains the transformed weights
<code class="reqn">a_{k},</code>
<code class="reqn">k=-K,\dots,K</code>
of all mixture components, i.e. also of components that had numerically zero
probabilities. 
</p>
</dd>
<dt>mlogweight_b.sim</dt><dd><p>this file is related to the density of the
random intercept from the model given by <code>formula</code> and
<code>random</code>.
</p>
<p>Fully created only if <code>store$a.b = TRUE</code>.
</p>
<p>The same structure as <code>mlogweight.sim</code>.
</p>
</dd>
<dt>mlogweight_2.sim</dt><dd><p>in the case of doubly-censored data. This
file is related to the density of the error term from the model
given by <code>formula2</code>.
</p>
<p>Fully created only if <code>store$a2 = TRUE</code>.
</p>
<p>The same structure as <code>mlogweight.sim</code>.
</p>
</dd>
<dt>mlogweight_b2.sim</dt><dd><p>in the case of doubly-censored data. This
file is related to the density of the random intercept from the model
given by <code>formula2</code> and <code>random2</code>.
</p>
<p>Fully created only if <code>store$a.b2 = TRUE</code>.
</p>
<p>The same structure as <code>mlogweight.sim</code>.
</p>
</dd>    
<dt>r.sim</dt><dd><p>this file is related to the density of the
error term from the model given by <code>formula</code>.
</p>
<p>Fully created only if <code>store$r = TRUE</code>. The file
contains the labels of the mixture components into which the
residuals are intrinsically assigned. Instead of indeces on the
scale <code class="reqn">\{-K,\dots, K\}</code>
values from 1 to <code class="reqn">(2\,K+1)</code> are stored here. Function
<code><a href="#topic+vecr2matr">vecr2matr</a></code> can be used to transform it back to
indices from <code class="reqn">-K</code> to <code class="reqn">K</code>.
</p>
</dd>
<dt>r_b.sim</dt><dd><p>this file is related to the density of the
random intercept from the model given by <code>formula</code> and
<code>random</code>.
</p>
<p>Fully created only if <code>store$r.b = TRUE</code>.
</p>
<p>The same structure as <code>r.sim</code>.
</p>
</dd>
<dt>r_2.sim</dt><dd><p>in the case of doubly-censored data. This
file is related to the density of the error term from the model
given by <code>formula2</code>.
</p>
<p>Fully created only if <code>store$r2 = TRUE</code>.
</p>
<p>The same structure as <code>r.sim</code>.
</p>
</dd>
<dt>r_b2.sim</dt><dd><p>in the case of doubly-censored data. This
file is related to the density of the random intercept from the model
given by <code>formula2</code> and <code>random2</code>.
</p>
<p>Fully created only if <code>store$r.b2 = TRUE</code>.
</p>
<p>The same structure as <code>r.sim</code>.
</p>
</dd>    
<dt>lambda.sim</dt><dd><p>this file is related to the density of the
error term from the model given by <code>formula</code>.
</p>
<p>One column labeled <code>lambda</code>. These are the
values of the smoothing parameter<code class="reqn">\lambda</code>
(hyperparameters of the prior distribution of the transformed
mixture weights <code class="reqn">a_{k}</code>). 
</p>
</dd>
<dt>lambda_b.sim</dt><dd><p>this file is related to the density of the
random intercept from the model given by <code>formula</code> and
<code>random</code>.
</p>
<p>The same structure as <code>lambda.sim</code>.
</p>
</dd>
<dt>lambda_2.sim</dt><dd><p>in the case of doubly-censored data. This
file is related to the density of the error term from the model
given by <code>formula2</code>.
</p>
<p>The same structure as <code>lambda.sim</code>.
</p>
</dd>
<dt>lambda_b2.sim</dt><dd><p>in the case of doubly-censored data. This
file is related to the density of the random intercept from the model
given by <code>formula2</code> and <code>random2</code>.
</p>
<p>The same structure as <code>lambda.sim</code>.
</p>
</dd>    
<dt>beta.sim</dt><dd><p>this file is related to the model given by
<code>formula</code>.
</p>
<p>Sampled values of the regression parameters
<code class="reqn">\beta</code>.
</p>
<p>The columns are labeled according to the
<code>colnames</code> of the design matrix.
</p>
</dd>
<dt>beta_2.sim</dt><dd><p>in the case of doubly-censored data, the same
structure as <code>beta.sim</code>, however related to the model
given by <code>formula2</code>. 
</p>
</dd>
<dt>b.sim</dt><dd><p>this file is related to the model given by
<code>formula</code> and <code>random</code>.
</p>
<p>Fully created only if <code>store$b = TRUE</code>. It
contains sampled values of random intercepts for all clusters in
the data set. The file has <code class="reqn">N</code> columns.
</p>
</dd>
<dt>b_2.sim</dt><dd><p>fully created only if <code>store$b2 =
      TRUE</code> and in the case of doubly-censored data, the same
structure as <code>b.sim</code>, however related to the model
given by <code>formula2</code> and <code>random2</code>. 
</p>
</dd>  
<dt>Y.sim</dt><dd><p>this file is related to the model given by <code>formula</code>.
</p>
<p>Fully created only if <code>store$y = TRUE</code>. It
contains sampled (augmented) log-event times for all observations
in the data set.
</p>
</dd>
<dt>Y_2.sim</dt><dd><p>fully created only if <code>store$y2 =
      TRUE</code> and in the case of doubly-censored data, the same
structure as <code>Y.sim</code>, however related to the model
given by <code>formula2</code>. 
</p>
</dd>
<dt>logposter.sim</dt><dd>
<p>This file is related to the residuals of the model
given by <code>formula</code>. 
</p>
<p>Columns labeled <code>loglik</code>, <code>penalty</code>, and <code>logprw</code>. 
The columns have the following meaning.
</p>
<p><b>loglik</b>
<code class="reqn">=</code> <code class="reqn">%
	- (\sum_{i=1}^N\,n_i)\,\Bigl\{\log(\sqrt{2\pi}) + \log(\sigma) \Bigr\}-
          0.5\sum_{i=1}^N\sum_{l=1}^{n_i}
	  \Bigl\{
	  (\sigma^2\,\tau^2)^{-1}\; (y_{i,l} - x_{i,l}'\beta - b_i -
	  \alpha - \tau\mu_{r_{i,l}})^2
          \Bigr\}
      </code>
</p>
<p>where <code class="reqn">y_{i,l}</code> denotes (augmented) <em>(i,l)</em>th
true log-event time.
</p>
<p>In other words, <code>loglik</code> is equal to the
conditional log-density
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i=1}^N \sum_{l=1}^{n_i}\,\log\Bigl\{p\bigl(y_{i,l}\;\big|\;r_{i,l},\,\beta,\,b_i,\,\mbox{error-G-spline}\bigr)\Bigr\};</code>
</p>

<p><b>penalty:</b>
the penalty term
</p>
<p style="text-align: center;"><code class="reqn">-\frac{1}{2}\sum_{k}\Bigl(\Delta\, a_k\Bigr)^2</code>
</p>

<p>(not multiplied by <code class="reqn">\lambda</code>);
</p>
<p><b>logprw</b> <code class="reqn">=</code>
<code class="reqn">-2\,(\sum_i n_i)\,\log\bigl\{\sum_{k}a_{k}\bigr\} +
	\sum_{k}N_{k}\,a_{k},</code>
where <code class="reqn">N_{k}</code> is the number of residuals
assigned intrinsincally to the <code class="reqn">k</code>th
mixture component.
</p>
<p>In other words, <code>logprw</code> is equal to the conditional
log-density
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i=1}^N\sum_{l=1}^{n_i} \log\bigl\{p(r_{i,l}\;|\;\mbox{error-G-spline
	  weights})\bigr\}.</code>
</p>

</dd>
<dt>logposter_b.sim</dt><dd><p>This file is related to the random
intercepts from the model given by <code>formula</code> and
<code>random</code>. 
</p>
<p>Columns labeled <code>loglik</code>, <code>penalty</code>, and <code>logprw</code>. 
The columns have the following meaning.
</p>
<p><b>loglik</b>
<code class="reqn">=</code> <code class="reqn">%
	- N\,\Bigl\{\log(\sqrt{2\pi}) + \log(\sigma) \Bigr\}-
          0.5\sum_{i=1}^N
	  \Bigl\{
	  (\sigma^2\,\tau^2)^{-1}\; (b_i - \alpha - \tau\mu_{r_{i}})^2
          \Bigr\}
      </code>
</p>
<p>where <code class="reqn">b_{i}</code> denotes (augmented) <em>i</em>th
random intercept.
</p>
<p>In other words, <code>loglik</code> is equal to the
conditional log-density
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i=1}^N \,\log\Bigl\{p\bigl(b_{i}\;\big|\;r_{i},\,\mbox{b-G-spline}\bigr)\Bigr\};</code>
</p>

<p>The columns <code>penalty</code> and <code>logprw</code> have the analogous
meaning as in the case of logposter.sim file.
</p>
</dd>
<dt>logposter_2.sim</dt><dd><p>in the case of doubly-censored data, the same
structure as <code>logposter.sim</code>, however related to the model
given by <code>formula2</code>. 
</p>
</dd>
<dt>logposter_b2.sim</dt><dd><p>in the case of doubly-censored data, the same
structure as <code>logposter_b.sim</code>, however related to the model
given by <code>formula2</code> and <code>random2</code>.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>García-Zattera, M. J., Jara, A., and Komárek, A. (2016).
A flexible AFT model for misclassified clustered interval-censored
data.
<em>Biometrics</em>, <b>72</b>, 473 - 483.
</p>
<p>Komárek, A. (2006).
<em>Accelerated Failure Time Models for Multivariate
Interval-Censored Data with Flexible Distributional Assumptions</em>.
PhD. Thesis, Katholieke Universiteit Leuven, Faculteit Wetenschappen.
</p>
<p>Komárek, A. and Lesaffre, E. (2008).
Bayesian accelerated failure time model with multivariate doubly-interval-censored data
and flexible distributional assumptions.
<em>Journal of the American Statistical Association</em>, <b>103</b>,
523 - 533.
</p>
<p>Robert C. P. and Casella, G. (2004).
<em>Monte Carlo Statistical Methods, Second Edition.</em>
New York: Springer Science+Business Media.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the description of R commands for
## the cluster specific AFT model
## with the Signal Tandmobiel data,
## analysis described in Komarek and Lesaffre (2007).
##
## R commands available in the documentation
## directory of this package
## - see ex-tandmobCS.R and
##   https://www2.karlin.mff.cuni.cz/ komarek/software/bayesSurv/ex-tandmobCS.pdf
##
</code></pre>

<hr>
<h2 id='bayessurvreg3.help'>
Helping functions for Bayesian regression with an error distribution
smoothed using G-splines
</h2><span id='topic+bayessurvreg3.help'></span><span id='topic+bayessurvreg3.checkStore'></span><span id='topic+bayessurvreg3.priorInit'></span><span id='topic+bayessurvreg3.priorBeta'></span><span id='topic+bayessurvreg3.priorb'></span><span id='topic+bayessurvreg3.writeHeaders'></span><span id='topic+bayessurvreg3.priorinitNb'></span><span id='topic+bayessurvreg3.checkrho'></span>

<h3>Description</h3>

<p>These functions are not to be called by ordinary users.
</p>
<p>These are just sub-parts of &lsquo;bayessurvreg3&rsquo; function to make it more
readable for the programmer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayessurvreg3.checkStore(store)

bayessurvreg3.priorInit(prior, init, design, mcmc.par,
   prior2, init2, design2, mcmc.par2, doubly)

bayessurvreg3.priorBeta(prior.beta, init, design)

bayessurvreg3.priorb(prior.b, init, design, mcmc.par)

bayessurvreg3.writeHeaders(dir, doubly, prior.init,
   priorb.di, priorb2.di, store, design, design2,
   version, mclass)

bayessurvreg3.priorinitNb(priorinit.Nb, init, init2,
   design, design2, doubly)

bayessurvreg3.checkrho(rho, doubly)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayessurvreg3.help_+3A_store">store</code></td>
<td>
<p>a list as required by the argument <code>store</code> of the
function <code><a href="#topic+bayessurvreg2">bayessurvreg2</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg3.help_+3A_prior">prior</code></td>
<td>
<p>a list as required by the argument <code>prior</code> of the
function <code><a href="#topic+bayessurvreg3">bayessurvreg3</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg3.help_+3A_prior2">prior2</code></td>
<td>
<p>a list as required by the argument <code>prior2</code> of the
function <code><a href="#topic+bayessurvreg3">bayessurvreg3</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg3.help_+3A_init">init</code></td>
<td>
<p>a list as required by the argument <code>init</code> of the
function <code><a href="#topic+bayessurvreg3">bayessurvreg3</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg3.help_+3A_init2">init2</code></td>
<td>
<p>a list as required by the argument <code>init2</code> of the
function <code><a href="#topic+bayessurvreg3">bayessurvreg3</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg3.help_+3A_mcmc.par">mcmc.par</code></td>
<td>
<p>a list as required by the argument <code>mcmc.par</code> of the
function <code><a href="#topic+bayessurvreg3">bayessurvreg3</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg3.help_+3A_mcmc.par2">mcmc.par2</code></td>
<td>
<p>a list as required by the argument <code>mcmc.par2</code> of the
function <code><a href="#topic+bayessurvreg3">bayessurvreg3</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg3.help_+3A_design">design</code></td>
<td>
<p>an object as returned by the function
<code><a href="#topic+bayessurvreg.design">bayessurvreg.design</a></code> related to either the onset time
if doubly censored observations or to the event time. Remark:
<code>design$Y</code> contains original times and NOT their logarithmic transformations.</p>
</td></tr>
<tr><td><code id="bayessurvreg3.help_+3A_design2">design2</code></td>
<td>
<p>an object as returned by the function
<code><a href="#topic+bayessurvreg.design">bayessurvreg.design</a></code> related to time-to-event
if doubly censored observations. Remark:
<code>design2$Y</code> contains original times and NOT their logarithmic transformations.</p>
</td></tr>    
<tr><td><code id="bayessurvreg3.help_+3A_doubly">doubly</code></td>
<td>
<p>logical indicating whether the response is doubly
censored or not</p>
</td></tr>  
<tr><td><code id="bayessurvreg3.help_+3A_prior.beta">prior.beta</code></td>
<td>
<p>a list as required by the argument <code>prior.beta</code> or
<code>prior.beta2</code> of the function <code><a href="#topic+bayessurvreg3">bayessurvreg3</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg3.help_+3A_prior.b">prior.b</code></td>
<td>
<p>a list as required by the argument <code>prior.b</code> or
<code>prior.b2</code> of the function <code><a href="#topic+bayessurvreg3">bayessurvreg3</a></code></p>
</td></tr>  
<tr><td><code id="bayessurvreg3.help_+3A_dir">dir</code></td>
<td>
<p>path to the directory where the sampled values are to be
stored</p>
</td></tr>
<tr><td><code id="bayessurvreg3.help_+3A_prior.init">prior.init</code></td>
<td>
<p>a list as returned by the function
<code><a href="#topic+bayessurvreg3.priorInit">bayessurvreg3.priorInit</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg3.help_+3A_priorb.di">priorb.di</code></td>
<td>
<p>a list as returned by the function
<code><a href="#topic+bayessurvreg3.priorb">bayessurvreg3.priorb</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg3.help_+3A_priorb2.di">priorb2.di</code></td>
<td>
<p>a list as returned by the function
<code><a href="#topic+bayessurvreg3.priorb">bayessurvreg3.priorb</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg3.help_+3A_priorinit.nb">priorinit.Nb</code></td>
<td>
<p>a list as required by the argument
<code>priorinit.Nb</code> of the function <code><a href="#topic+bayessurvreg3">bayessurvreg3</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg3.help_+3A_rho">rho</code></td>
<td>
<p>a list as required by the argument <code>rho</code>
of the function <code><a href="#topic+bayessurvreg3">bayessurvreg3</a></code></p>
</td></tr>
<tr><td><code id="bayessurvreg3.help_+3A_version">version</code></td>
<td>
<p>it is equal to 3 if either there is no correlation
coefficient between the onset and time-to-event random intercepts or
this correlation coefficient is fixed to 0
</p>
<p>It is equal to 31 if we are estimating correlation coefficient
between the onset and time-to-event random intercepts.
</p>
</td></tr>
<tr><td><code id="bayessurvreg3.help_+3A_mclass">mclass</code></td>
<td>
<p>object created by <code><a href="#topic+bayessurvreg3">bayessurvreg3</a></code> function
related to a model which considers possible misclassification of the
event status.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Some lists (in most cases).
</p>


<h3>Value for bayessurvreg3.priorb</h3>

<p>A list with the following components:
</p>

<dl>
<dt>bparmI</dt><dd><p>integer arguments for C++ <code>RandomEff</code>
constructor</p>
</dd>
<dt>bparmD</dt><dd><p>double arguments for C++ <code>RandomEff</code>
constructor</p>
</dd>
<dt>GsplI</dt><dd><p>integer arguments for C++ <code>Gspline</code>
constructor related to the smothed density of the random intercept</p>
</dd>
<dt>GsplD</dt><dd><p>double arguments for C++ <code>Gspline</code> constructor
related to the smoothed density of the random intercept</p>
</dd>
<dt>specification</dt><dd><p>1 or 2, one of the G-spline specifications
related to the distribution of the random intercept</p>
</dd>
<dt>r</dt><dd><p>initial component labels (vector of size <code class="reqn">ncluster</code>) taking
values from 1 to the total length of the G-spline related to the
random intercept</p>
</dd>
</dl>

<p>and the following attributes:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>prior.b</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>init</b> </td>
</tr>
<tr>
 <td style="text-align: left;">    
    <b>mcmc.par</b> </td>
</tr>
<tr>
 <td style="text-align: left;">    
  </td>
</tr>

</table>
      


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>

<hr>
<h2 id='cgd'>Chronic Granulomatous Disease data</h2><span id='topic+cgd'></span>

<h3>Description</h3>

<p>Dataset from Fleming and Harrington (1991).
</p>
<p>Data from a multicenter placebo-controlled randomized trial of gamma
inferon in patients with chronic granulomatous disease (CGD). 128
patients were randomized to either gamma inferon (<code class="reqn">n=63</code>) or
placebo (<code class="reqn">n=65</code>). For each patient the times from study
entry to initial and any recurrent serious infections are
available. There is a minimum of one and a maximum of eight
(recurrent) infection times per patient, with a total of 203 records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cgd)</code></pre>


<h3>Format</h3>

<p>a~data frame with 203 rows and 17 columns. There are the
following variables contained in the data frame.
</p>

<dl>
<dt>hospit</dt><dd><p>code of the hospital</p>
</dd>
<dt>ID</dt><dd><p>case identification number</p>
</dd>
<dt>RDT</dt><dd><p>date randomization onto study (mmddyy)</p>
</dd>
<dt>IDT</dt><dd><p>date of onset of serious infection, or date the patient was taken off the study (mmddyy)</p>
</dd>
<dt>trtmt</dt><dd><p>treatment code, 1 = rIFN-gamma, 2 = placebo</p>
</dd>
<dt>inherit</dt><dd><p>pattern of inheritance, 1 = X-linked, 2 = autosomal recessive</p>
</dd>
<dt>age</dt><dd><p>age in years</p>
</dd>
<dt>height</dt><dd><p>height of the patient in cm</p>
</dd>
<dt>weight</dt><dd><p>weight of the patient in kg</p>
</dd>
<dt>cortico</dt><dd><p>using corticosteroids at time of study entry, 1 =
yes, 2 = no</p>
</dd>
<dt>prophy</dt><dd><p>using prophylatic antibiotics at time of study entry,
1 = yes, 2 = no</p>
</dd>
<dt>gender</dt><dd><p>1 = male, 2 = female</p>
</dd>
<dt>hcat</dt><dd><p>hospital category, 1 = US-NIH,  2 = US-other, 2 = Europe
- Amsterdam, 4 = Europe - other</p>
</dd>
<dt>T1</dt><dd><p>elapsed time (in days) from randomization (from sequence = 1 record) to diagnosis of a serious infection
or, if a censored observation, elapsed time from randomization to censoring date;
computed as IDT - RDT (from sequence = 1 record)</p>
</dd>
<dt>T2</dt><dd><p>0, for sequence = 1 record, if sequence &gt; 1, T2 = T1(from previous record) + 1</p>
</dd>
<dt>event</dt><dd><p>censoring indicator, 1 = non-censored observation, 2 = censored observation</p>
</dd>
<dt>sequence</dt><dd><p>sequence number, for each patient, the infection recods are in sequence number order</p>
</dd>
</dl>
  


<h3>Source</h3>

<p>Appendix D.2 of Fleming and Harrington (1991).
</p>


<h3>References</h3>

<p>Fleming, T. R. and Harrington, D. P. (1991).
<em>Counting Processes and Survival Analysis</em>.
New York: John Wiley and Sons.
</p>

<hr>
<h2 id='credible.region'>
Compute a simultaneous credible region (rectangle) from a sample for a vector valued parameter.
</h2><span id='topic+credible.region'></span>

<h3>Description</h3>

<p>See references below for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>credible.region(sample, probs=c(0.90, 0.975))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="credible.region_+3A_sample">sample</code></td>
<td>
<p>a data frame or matrix with sampled values (one column = one parameter)</p>
</td></tr>
<tr><td><code id="credible.region_+3A_probs">probs</code></td>
<td>
<p>probabilities for which the credible regions are to be computed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list (one component for each confidence region) of length equal to
<code>length(probs)</code>. Each component of the list is a matrix with two
rows (lower and upper limit) and as many columns as the number of
parameters giving the confidence region.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Besag, J., Green, P., Higdon, D. and Mengersen, K. (1995).
Bayesian computation and stochastic systems (with Discussion).
<em>Statistical Science,</em> <b>10</b>, 3 - 66, page 30
</p>
<p>Held, L. (2004).  
Simultaneous inference in risk assessment; a Bayesian perspective
<em>In: COMPSTAT 2004, Proceedings in Computational Statistics (J. Antoch, Ed.),</em>
213 - 222, page 214
</p>
<p>Held, L. (2004b).
Simultaneous posterior probability statements from Monte Carlo output.
<em>Journal of Computational and Graphical Statistics,</em> <b>13</b>,
20 - 35.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  m &lt;- 10000
  sample &lt;- data.frame(x1=rnorm(m), x2=rnorm(m), x3=rnorm(m))
  probs &lt;- c(0.70, 0.90, 0.95)
  CR &lt;- credible.region(sample, probs=probs)

  for (kk in 1:length(CR)){
    suma &lt;- sum(sample$x1 &gt;= CR[[kk]]["Lower", "x1"] &amp; sample$x1 &lt;= CR[[kk]]["Upper", "x1"] &amp;
            sample$x2 &gt;= CR[[kk]]["Lower", "x2"] &amp; sample$x2 &lt;= CR[[kk]]["Upper", "x2"] &amp;
            sample$x3 &gt;= CR[[kk]]["Lower", "x3"] &amp; sample$x3 &lt;= CR[[kk]]["Upper", "x3"])
    show &lt;- c(suma/m, probs[kk])
    names(show) &lt;- c("Empirical", "Desired")
    print(show)
  }
</code></pre>

<hr>
<h2 id='densplot2'>
Probability density function estimate from MCMC output
</h2><span id='topic+densplot2'></span>

<h3>Description</h3>

<p>Displays a plot of the density estimate for each variable in x, calculated by the density function. 
</p>
<p>This is slightly modified version of <code><a href="coda.html#topic+densplot">densplot</a></code> function
of a <code>coda</code> package to conform to my personal preferences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densplot2(x, plot = TRUE, show.obs = FALSE, bwf, bty = "n", main = "",
          xlim, ylim, xlab, ylab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densplot2_+3A_x">x</code></td>
<td>
<p>an <code><a href="coda.html#topic+mcmc">mcmc</a></code> or <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.</p>
</td></tr>
<tr><td><code id="densplot2_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code> this function works more or less in the
same way as <code>coda</code> function <code><a href="coda.html#topic+densplot">densplot</a></code> function.
If <code>FALSE</code> this function returns one data frame for each chain
with computed density which can be used for future plotting.</p>
</td></tr>
<tr><td><code id="densplot2_+3A_show.obs">show.obs</code></td>
<td>
<p>show observations along the x-axis?</p>
</td></tr>
<tr><td><code id="densplot2_+3A_bwf">bwf</code></td>
<td>
<p>function for calculating the bandwidth. If omitted, the
bandwidth is calculate by 1.06 times the minimum of the standard
deviation and the interquartile range divided by 1.34 times the
sample size to the negative one fifth power.</p>
</td></tr>
<tr><td><code id="densplot2_+3A_xlim">xlim</code>, <code id="densplot2_+3A_ylim">ylim</code>, <code id="densplot2_+3A_xlab">xlab</code>, <code id="densplot2_+3A_ylab">ylab</code></td>
<td>
<p>further arguments passed to the
<code><a href="graphics.html#topic+plot.default">plot.default</a></code> function.</p>
</td></tr>  
<tr><td><code id="densplot2_+3A_bty">bty</code>, <code id="densplot2_+3A_main">main</code>, <code id="densplot2_+3A_...">...</code></td>
<td>
<p>further arguments passed to the
<code><a href="graphics.html#topic+plot.default">plot.default</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>

<hr>
<h2 id='files.Gspline'>
Write headers to or clean files with sampled G-spline
</h2><span id='topic+clean.Gspline'></span><span id='topic+write.headers.Gspline'></span>

<h3>Description</h3>

<p>These functions are not to be called by ordinary users.
</p>
<p>These are just sub-parts of some <code>*.writeHeaders</code> functions to make them more
readable for the programmer.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean.Gspline(dir, label, care.of.y=TRUE)

write.headers.Gspline(dir, dim, nP, label, gparmi,
    store.a, store.y, store.r, care.of.y=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="files.Gspline_+3A_dir">dir</code></td>
<td>
<p>a~string giving the path to the directory where to search or
store G-spline files</p>
</td></tr>
<tr><td><code id="files.Gspline_+3A_label">label</code></td>
<td>
<p>a~string with extension of the G-spline files</p>
</td></tr>
<tr><td><code id="files.Gspline_+3A_dim">dim</code></td>
<td>
<p>dimension of the G-spline</p>
</td></tr>
<tr><td><code id="files.Gspline_+3A_np">nP</code></td>
<td>
<p>number of (bivariate) observations</p>
</td></tr>
<tr><td><code id="files.Gspline_+3A_gparmi">gparmi</code></td>
<td>
<p>a~vector with integer arguments required by the
constructor of C++ class <code>Gspline</code></p>
</td></tr>
<tr><td><code id="files.Gspline_+3A_store.a">store.a</code></td>
<td>
<p>logical, store transformed weights?</p>
</td></tr>
<tr><td><code id="files.Gspline_+3A_store.y">store.y</code></td>
<td>
<p>logical, store augmented observations?</p>
</td></tr>
<tr><td><code id="files.Gspline_+3A_store.r">store.r</code></td>
<td>
<p>logical, store allocations?</p>
</td></tr>
<tr><td><code id="files.Gspline_+3A_care.of.y">care.of.y</code></td>
<td>
<p>logical, do we wish to take care of the <code>Y.sim</code> file?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>

<hr>
<h2 id='files2coda'>
Read the sampled values from the Bayesian survival regression model
to a coda mcmc object.
</h2><span id='topic+files2coda'></span>

<h3>Description</h3>

<p>This function creates a <code>coda</code> <code>mcmc</code> object from values found
in files where sampled values from <code>bayessurvreg1</code> function are stored
or from data.frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>files2coda(files, data.frames, variant = 1, dir = getwd(),
   start = 1, end, thin = 1, header = TRUE, chain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="files2coda_+3A_files">files</code></td>
<td>
<p>a vector of strings giving the names of files that are to
be converted to <code>coda</code> objects. If missing and <code>data.frames</code>
is also missing, all appropriate files
found in a directory <code>dir</code> are converted to coda objects. File
&quot;iteration.sim&quot; is always used (if found) to index the sampled
values. If this file is not found the sampled values are indexed from
1 to the sample size. If &quot;mixture.sim&quot; appeares here, only the column
with number of mixture components is converted to the coda object.</p>
</td></tr>
<tr><td><code id="files2coda_+3A_data.frames">data.frames</code></td>
<td>
<p>a vector of strings giving the names of data.frames
that are to be converted to <code>coda</code> objects.
</p>
</td></tr>
<tr><td><code id="files2coda_+3A_variant">variant</code></td>
<td>
<p>a variant of <code>bayessurvreg</code> function used to
generate sampled values. This argument is only used to identify
appropriate files when <code>files</code> argument is missing.
</p>
<p>Currently only 1 is supported to cooperate with <code><a href="#topic+bayessurvreg1">bayessurvreg1</a></code>.
</p>
</td></tr>
<tr><td><code id="files2coda_+3A_dir">dir</code></td>
<td>
<p>string giving the directory where it will be searched for the files with 
sampled values.</p>
</td></tr>
<tr><td><code id="files2coda_+3A_start">start</code></td>
<td>
<p>the first row (possible header does not count) from the files with the
sampled values that will be converted to coda objects.</p>
</td></tr>
<tr><td><code id="files2coda_+3A_end">end</code></td>
<td>
<p>the last row from the files with the sampled values that
will be converted to coda objects. If missing, it is the last row in
files.</p>
</td></tr>
<tr><td><code id="files2coda_+3A_thin">thin</code></td>
<td>
<p>additional thinning of sampled values (i.e. only every
<code>thin</code> value from <code>files</code> and <code>data.frames</code> is considered).</p>
</td></tr>
<tr><td><code id="files2coda_+3A_header">header</code></td>
<td>
<p>TRUE or FALSE indicating whether the files with the sampled values
contain also the header on the first line or not.</p>
</td></tr>
<tr><td><code id="files2coda_+3A_chain">chain</code></td>
<td>
<p>parameter giving the number of the chain if parallel
chains were created and sampled values stored in data.frames further
stored in lists(). If <code>missing</code>, data.frames are not assumed to
be stored in lists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code>mcmc</code> objects. One object per file or data.frame.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## *** illustration of usage of parameters 'data.frames' and 'chain' ***
## *********************************************************************
## Two parallel chains with four variables, stored in data.frames
## data.frames are further stored in lists
library("coda")

group1 &lt;- list();  group2 &lt;- list();  group3 &lt;- list()
    ## first chain of first two variables:
  group1[[1]] &lt;- data.frame(var1 = rnorm(100, 0, 1), var2 = rnorm(100, 5, 4))
    ## second chain of first two variables:   
  group1[[2]] &lt;- data.frame(var1 = rnorm(100, 0, 1), var2 = rnorm(100, 5, 4))
    ## first chain of the third variable:
  group2[[1]] &lt;- data.frame(var3 = rgamma(100, 1, 1))
    ## second chain of the third variable:
  group2[[2]] &lt;- data.frame(var3 = rgamma(100, 1, 1))
    ## first chain of the fourth variable:
  group3[[1]] &lt;- data.frame(var4 = rbinom(100, 1, 0.4))
    ## second chain of the fourth variable:
  group3[[2]] &lt;- data.frame(var4 = rbinom(100, 1, 0.4))  

  ## Create mcmc objects for each chain separately
mc.chain1 &lt;- files2coda(data.frames = c("group1", "group2", "group3"), chain = 1)
mc.chain2 &lt;- files2coda(data.frames = c("group1", "group2", "group3"), chain = 2)

  ## Create mcmc.list to represent two parallel chains
mc &lt;- mcmc.list(mc.chain1, mc.chain2)
rm(mc.chain1, mc.chain2)


## *** illustration of usage of parameter 'data.frames' without 'chain' ***
## ************************************************************************
## Only one chain for four variables was sampled and stored in three data.frames
    ## chain of first two variables:
  group1 &lt;- data.frame(var1 = rnorm(100, 0, 1), var2 = rnorm(100, 5, 4))
    ## chain of the third variable:  
  group2 &lt;- data.frame(var3 = rgamma(100, 1, 1))
    ## chain of the fourth variable:
  group3 &lt;- data.frame(var4 = rbinom(100, 1, 0.4))                        

  ## Create an mcmc object
mc &lt;- files2coda(data.frames = c("group1", "group2", "group3"))
</code></pre>

<hr>
<h2 id='give.init'>
Check and possibly fill in initial values for the G-spline, augmented
observations and allocations for Bayesian models with G-splines
</h2><span id='topic+give.init.Gspline'></span><span id='topic+give.init.y'></span><span id='topic+give.init.y2'></span><span id='topic+give.init.r'></span><span id='topic+C_findClosestKnot'></span><span id='topic+C_midimputeData'></span><span id='topic+C_midimputeDataDoubly'></span>

<h3>Description</h3>

<p>These functions are not to be called by ordinary users.
</p>
<p>These are just sub-parts of <code><a href="#topic+bayesBisurvreg.priorInit">bayesBisurvreg.priorInit</a></code> and
related functions to make them more readable for the programmer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>give.init.Gspline(prior, init, mcmc.par, dim)

give.init.y(init.y, dim, y.left, y.right, status)

give.init.y2(init.y, init2.y, dim, design, design2, doubly)

give.init.r(init.r, init.y, dim, KK,
   gamma, sigma, c4delta, intcpt, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="give.init_+3A_prior">prior</code></td>
<td>
<p>a~list as required by <code>prior</code> argument of the function
<code><a href="#topic+bayesHistogram">bayesHistogram</a></code> or <code>prior</code> and <code>prior2</code>
arguments of the function <code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code>
</p>
</td></tr>  
<tr><td><code id="give.init_+3A_init">init</code></td>
<td>
<p>a~list as required by <code>init</code> argument of the function
<code><a href="#topic+bayesHistogram">bayesHistogram</a></code> or by <code>init</code> and <code>init2</code>
arguments of the function <code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code>
</p>
</td></tr>  
<tr><td><code id="give.init_+3A_mcmc.par">mcmc.par</code></td>
<td>
<p>a~list as required by <code>mcmc.par</code> argument of
function <code><a href="#topic+bayesHistogram">bayesHistogram</a></code> or by <code>mcmc.par</code> and
<code>mcmc.par2</code> arguments of the function
<code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code>
</p>
</td></tr>  
<tr><td><code id="give.init_+3A_dim">dim</code></td>
<td>
<p>dimension of the G-spline/response, 1 or 2.
</p>
</td></tr>  
<tr><td><code id="give.init_+3A_init.y">init.y</code></td>
<td>
<p>initial (augmented) observations possibly given by the user.                        
They are partially checked for consistency and these supplied by the user                   
used in the resulting object. This should be either vector of length <code class="reqn">n</code>             
where <code class="reqn">n</code> is a~sample size if the dimension is one or a~matrix with                  
2 columns and <code class="reqn">n</code> rows if the dimension is two.
</p>
</td></tr>  
<tr><td><code id="give.init_+3A_init2.y">init2.y</code></td>
<td>
<p>initial (augmented) times-to-event (if doubly censoring) possibly given by the user.  
They are partially checked for consistency and these supplied by the user                   
used in the resulting object. This should be either vector of length <code class="reqn">n</code>             
where <code class="reqn">n</code> is a~sample size if the dimension is one or a~matrix with                  
2 columns and <code class="reqn">n</code> rows if the dimension is two.
</p>
</td></tr>  
<tr><td><code id="give.init_+3A_design">design</code></td>
<td>
<p>an~object as returned by the function
<code><a href="#topic+bayessurvreg.design">bayessurvreg.design</a></code> related to either the onset time
if doubly censored observations or to the event time. Remark:
<code>design$Y</code> contains original times and NOT their logarithmic
transformations.
</p>
</td></tr>  
<tr><td><code id="give.init_+3A_design2">design2</code></td>
<td>
<p>an~object as returned by the function
<code><a href="#topic+bayessurvreg.design">bayessurvreg.design</a></code> related to time-to-event
if doubly censored observations. Remark:
<code>design2$Y</code> contains original times and NOT their logarithmic
transformations.
</p>
</td></tr>  
<tr><td><code id="give.init_+3A_doubly">doubly</code></td>
<td>
<p>logical indicating whether the response is doubly
censored or not
</p>
</td></tr>  
<tr><td><code id="give.init_+3A_y.left">y.left</code></td>
<td>
<p>observed, left or right censored log(event time) or the lower limit                 
of the interval censored observation. Sorted in a~transposed order compared                 
to <code>init.y</code>.
</p>
</td></tr>  
<tr><td><code id="give.init_+3A_y.right">y.right</code></td>
<td>
<p>upper limit of the interval censored observation, whatever if the observation      
is not interval-censored sorted in a~transposed order compared to <code>init.y</code>.
</p>
</td></tr>  
<tr><td><code id="give.init_+3A_status">status</code></td>
<td>
<p>status indicator vector/matrix. 1 for observed times, 0 for right censored times,   
2 for left censored times, 3 for interval censored times.
</p>
</td></tr>  
<tr><td><code id="give.init_+3A_init.r">init.r</code></td>
<td>
<p>initial allocations possibly given by the user. This should be a~vector of length
<code class="reqn">n</code> where n is a~sample size if <code>dim</code> is equal to 1 and
a~matrix with <code class="reqn">n</code> rows and 2 columns if <code>dim</code> is equal to
2. Values should be on the scale
<code class="reqn">-K_j,\dots,K_j,</code>
<code class="reqn">j=1,\dots,dim</code>
</p>
</td></tr>  
<tr><td><code id="give.init_+3A_kk">KK</code></td>
<td>
<p>vector of length <code>dim</code> with <code class="reqn">K</code> coefficients
defining the G-spline.
</p>
</td></tr>  
<tr><td><code id="give.init_+3A_gamma">gamma</code></td>
<td>
<p>vector of length <code>dim</code> with initial
<code class="reqn">\gamma</code> parameters of the G-spline.
</p>
</td></tr>  
<tr><td><code id="give.init_+3A_sigma">sigma</code></td>
<td>
<p>vector of length <code>dim</code> with initial
<code class="reqn">\sigma</code> parameters of the G-spline.
</p>
</td></tr>  
<tr><td><code id="give.init_+3A_c4delta">c4delta</code></td>
<td>
<p>vector of length <code>dim</code> with constants to compute the distance between two knots
defining the G-spline.
</p>
</td></tr>  
<tr><td><code id="give.init_+3A_intcpt">intcpt</code></td>
<td>
<p>vector of length <code>dim</code> with initial values of the
intercept term of the G-spline.
</p>
</td></tr>  
<tr><td><code id="give.init_+3A_scale">scale</code></td>
<td>
<p>vector of length <code>dim</code> with initial values of the
scale parameters of the G-spline.
</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Some lists.
</p>


<h3>Value for give.init.Gspline</h3>

<p>A~list with the following components:
</p>

<dl>
<dt>Gparmi</dt><dd><p>integer parameters for the G-spline constructor in the
C++ code</p>
</dd>
<dt>Gparmd</dt><dd><p>double parameters for the G-spline constructor in the
C++ code</p>
</dd>
<dt>specification</dt><dd><p>specification of the G-spline model (1 or 2), see
<code><a href="#topic+bayesHistogram">bayesHistogram</a></code> for more detail</p>
</dd>
</dl>

<p>and the following attributes:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <b>init</b>      </td>
</tr>
<tr>
 <td style="text-align: left;">
  <b>prior</b>     </td>
</tr>
<tr>
 <td style="text-align: left;">
  <b>mcmc.par</b>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Value for give.init.y</h3>

<p>A~vector or matrix with the same structure as <code>init.y</code>, i.e. with 2~columns and
<code class="reqn">n</code> rows in the case of the bivariate data.
</p>


<h3>Value for give.init.y2</h3>

<p>A~list with the following components:
</p>

<dl>
<dt>init.y</dt><dd><p>a~vector of length <code class="reqn">n</code> or a~matrix with 2
columns and <code class="reqn">n</code> rows with initial log(onset times)</p>
</dd>
<dt>init2.y</dt><dd><p>a~vector of length <code class="reqn">n</code> or a~matrix with 2
columns and <code class="reqn">n</code> rows with initial log(times-to-event). If
the data are not doubly cdensored, this object is equal to 0.</p>
</dd>
<dt>y1.left</dt><dd><p>lower limit of the log-response (or exact/right/left
censored observation) as required by the C++ function
<code>bayesBisurvreg</code>, related to the onset time in the case of
doubly censoring and to the event time otherwise</p>
</dd>
<dt>y1.right</dt><dd><p>upper limit of the log-response as required by the C++ function
<code>bayesBisurvreg</code>, related to the onset time in the case of
doubly censoring and to the event time otherwise</p>
</dd>
<dt>status1</dt><dd><p>status vector as required by the C++ function
<code>bayesBisurvreg</code> related to the onset time in the case of
doubly censoring and to the event time otherwise</p>
</dd>
<dt>t2.left</dt><dd><p>lower limit of the response as required by the C++
function <code>bayesBisurvreg</code>, related to time-to-event in the
case of doubly censoring, equal to 0 if there is no doubly-censoring</p>
</dd>
<dt>t2.right</dt><dd><p>upper limit of the response as required by the C++
function <code>bayesBisurvreg</code>, related to time-to-event in the
case of doubly censoring, equal to 0 if there is no doubly-censoring</p>
</dd>
<dt>status2</dt><dd><p>status vector related to time-to-event in the case of
doubly censoring, equal to 0 otherwise.</p>
</dd>
</dl>
    


<h3>Value for give.init.r</h3>

<p>To be added somewhen...
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>

<hr>
<h2 id='give.summary'>
Brief summary for the chain(s) obtained using the MCMC.
</h2><span id='topic+give.summary'></span>

<h3>Description</h3>

<p>This function computes a sample mean, quantiles and a Bayesian
<code class="reqn">p</code>-value which is defined as
</p>
<p style="text-align: center;"><code class="reqn">p = 2\times\min(n_{-},\,n_{+}),</code>
</p>

<p>where
<code class="reqn">n_{-}</code> is the number of the sampled values which are
negative and <code class="reqn">n_{+}</code> is the number of sampled values which
are positive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>give.summary(sample, probs=c(0.5, 0.025, 0.975))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="give.summary_+3A_sample">sample</code></td>
<td>
<p>a data frame or a vector with sampled values</p>
</td></tr>
<tr><td><code id="give.summary_+3A_probs">probs</code></td>
<td>
<p>probabilities of the quantiles that are to be computed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a vector with the sample mean, quantiles and a Bayesian <code class="reqn">p</code>-value.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example with a sample stored in a vector:
sample &lt;- rnorm(1000)
give.summary(sample)

## Example with a sample stored in a data.frame:
sample &lt;- data.frame(x=rnorm(1000), y=rgamma(1000, shape=1, rate=1))
give.summary(sample)
</code></pre>

<hr>
<h2 id='marginal.bayesGspline'>
Summary for the marginal density estimates based on the bivariate model with Bayesian
G-splines.
</h2><span id='topic+marginal.bayesGspline'></span><span id='topic+C_marginal_bayesGspline'></span>

<h3>Description</h3>

<p>Compute the estimate of the marginal density function based on the values
sampled using the MCMC (MCMC average evaluated in a
grid of values) in a model where density is specified as
a bivariate Bayesian G-spline.
</p>
<p>This function serves to summarize the MCMC chains related to the distributional parts 
of the considered models obtained using the functions:
<code><a href="#topic+bayesHistogram">bayesHistogram</a></code> and <code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code>.
</p>
<p>If asked, this function returns also the values of the marginal G-spline
evaluated in a grid at each iteration of MCMC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal.bayesGspline(dir, extens = "", K, grid1, grid2,
   skip = 0, by = 1, last.iter, nwrite, only.aver = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginal.bayesGspline_+3A_dir">dir</code></td>
<td>
<p>directory where to search for files (&lsquo;mixmoment.sim&rsquo;,
&lsquo;mweight.sim&rsquo;, &lsquo;mmean.sim&rsquo;, &lsquo;gspline.sim&rsquo;) with the MCMC
sample.</p>
</td></tr>
<tr><td><code id="marginal.bayesGspline_+3A_extens">extens</code></td>
<td>
<p>an extension used to distinguish different sampled
G-splines if more G-splines were used in one simulation (e.g. with
doubly-censored data). According to which
<code>bayes*survreg*</code> function was used, specify the argument
<code>extens</code> in the following way.
</p>

<dl>
<dt>bayesHistogram:</dt><dd>
<p>always <code>extens = ""</code>
</p>
</dd>
<dt>bayesBisurvreg:</dt><dd><p><code class="reqn">\quad</code>
</p>

<ul>
<li><p> to compute the marginals of the bivariate distribution of the <em>error</em> term for
the <em>onset</em> time: <code>extens = ""</code>;
</p>
</li>
<li><p> to compute the marginals of the bivariate distribution of the <em>error</em> term for
the <em>event</em> time if there was doubly-censoring:
<code>extens = "_2"</code>;
</p>
</li></ul>
	 
</dd>
</dl>

</td></tr>
<tr><td><code id="marginal.bayesGspline_+3A_k">K</code></td>
<td>
<p>a~vector of length 2 specifying the number of knots at each
side of the middle knot for each dimension of the G-spline.</p>
</td></tr>
<tr><td><code id="marginal.bayesGspline_+3A_grid1">grid1</code></td>
<td>
<p>grid of values from the first dimension at which the sampled 
marginal densities are to be evaluated.</p>
</td></tr>
<tr><td><code id="marginal.bayesGspline_+3A_grid2">grid2</code></td>
<td>
<p>grid of values from the second dimension
at which the sampled marginal densities are to be
evaluated.</p>
</td></tr>
<tr><td><code id="marginal.bayesGspline_+3A_skip">skip</code></td>
<td>
<p>number of rows that should be skipped at the beginning of
each *.sim file with the stored sample.</p>
</td></tr>
<tr><td><code id="marginal.bayesGspline_+3A_by">by</code></td>
<td>
<p>additional thinning of the sample.</p>
</td></tr>
<tr><td><code id="marginal.bayesGspline_+3A_last.iter">last.iter</code></td>
<td>
<p>index of the last row from *.sim files that should be
used. If not specified than it is set to the maximum available
determined according to the file <code>mixmoment.sim</code>.</p>
</td></tr>
<tr><td><code id="marginal.bayesGspline_+3A_nwrite">nwrite</code></td>
<td>
<p>frequency with which is the user informed about the
progress of computation (every <code>nwrite</code>th iteration count of
iterations change).</p>
</td></tr>
<tr><td><code id="marginal.bayesGspline_+3A_only.aver">only.aver</code></td>
<td>
<p><code>TRUE/FALSE</code>, if <code>TRUE</code> only MCMC average is
returned otherwise also values of the marginal G-spline at each iteration are
returned (which might ask for quite lots of memory).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>marginal.bayesGspline</code> is returned. This object is a
list with components <code>margin1</code> and <code>margin2</code> (for two margins).
</p>
<p>Both <code>margin1</code> and <code>margin2</code> components are data.frames with
columns named <code>grid</code> and <code>average</code> where
</p>
<table>
<tr><td><code>grid</code></td>
<td>
<p>is a grid of values (vector) at which the McMC average of the
marginal G-spline was computed.</p>
</td></tr>
<tr><td><code>average</code></td>
<td>
<p>are McMC averages of the marginal G-spline (vector) evaluated in
<code>grid</code>.</p>
</td></tr>
</table>
<p>There exists a method to plot objects of the class <code>marginal.bayesGspline</code>.
</p>


<h3>Attributes</h3>

<p>Additionally, the object of class <code>marginal.bayesGspline</code> has the following
attributes:
</p>

<dl>
<dt><code>sample.size</code></dt><dd><p>a length of the McMC sample used to compute the McMC average.
</p>
</dd>
<dt><code>sample1</code></dt><dd><p>marginal (margin = 1) G-spline evaluated in a grid of values. This attribute
is present only if <code>only.aver = FALSE</code>.
</p>
<p>This a matrix with <code>sample.size</code> columns and length(grid1) rows.
</p>
</dd>
<dt><code>sample2</code></dt><dd><p>marginal (margin = 2) G-spline evaluated in a grid of values. This attribute
is present only if <code>only.aver = FALSE</code>.
</p>
<p>This a matrix with <code>sample.size</code> columns and length(grid2) rows.
</p>
</dd>    
</dl>
    


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Komárek, A. (2006).
<em>Accelerated Failure Time Models for Multivariate
Interval-Censored Data with Flexible Distributional Assumptions</em>.
PhD. Thesis, Katholieke Universiteit Leuven, Faculteit Wetenschappen.
</p>
<p>Komárek, A. and Lesaffre, E. (2006).
Bayesian semi-parametric accelerated failurew time model for paired
doubly interval-censored data.
<em>Statistical Modelling</em>, <b>6</b>, 3 - 22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the description of R commands for
## the models described in
## Komarek (2006),
## Komarek and Lesaffre (2006),
## 
## R commands available
## in the documentation
## directory of this package
## - see ex-tandmobPA.R and
##   https://www2.karlin.mff.cuni.cz/~komarek/software/bayesSurv/ex-tandmobPA.pdf
##
</code></pre>

<hr>
<h2 id='plot.bayesDensity'>
Plot an object of class bayesDensity
</h2><span id='topic+plot.bayesDensity'></span>

<h3>Description</h3>

<p>This function plots an object created by <code><a href="#topic+bayesDensity">bayesDensity</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesDensity'
plot(x, k.cond, dim.plot = TRUE, over = TRUE,
   alegend = TRUE, standard = TRUE, center = FALSE,
   type = "l", bty = "n",
   xlab = expression(epsilon), ylab = expression(f(epsilon)),
   lty, xlim, ylim, xleg, yleg, main, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bayesDensity_+3A_x">x</code></td>
<td>
<p>an object of class <code>bayesDensity</code>.</p>
</td></tr>
<tr><td><code id="plot.bayesDensity_+3A_k.cond">k.cond</code></td>
<td>
<p>a numerical vector giving the numbers of mixture components for which the conditional densities
are to be plotted. 0 states for the unconditional (overall) density, averaged over the mixture with all possible
numbers of components. If NULL, all conditional and the
unconditional density found in <code>x</code> will be plotted.</p>
</td></tr>
<tr><td><code id="plot.bayesDensity_+3A_dim.plot">dim.plot</code></td>
<td>
<p>an indicator whether the dimension of the plot used
in <code>par(mfrow)</code> should be computed automatically. If
<code>dim.plot = FALSE</code> and <code>over = FALSE</code> the user has to
determine himself using <code>par(mfrow)</code> how to put the plots on
the page.</p>
</td></tr>
<tr><td><code id="plot.bayesDensity_+3A_over">over</code></td>
<td>
<p>an indicator whether all densities should be drawn into
one plot using different types of lines. If <code>FALSE</code> a separate
plot for each density is created.</p>
</td></tr>
<tr><td><code id="plot.bayesDensity_+3A_alegend">alegend</code></td>
<td>
<p>an indicator whether an automatic legend should be
added to the plot.</p>
</td></tr>
<tr><td><code id="plot.bayesDensity_+3A_standard">standard</code></td>
<td>
<p>logical, do we want to plot standardized density?</p>
</td></tr>
<tr><td><code id="plot.bayesDensity_+3A_center">center</code></td>
<td>
<p>logical, do we want to plot centered density?, set both
<code>standard</code> and <code>center</code> to <code>FALSE</code> if you wish to
plot unstandardized density.</p>
</td></tr>
<tr><td><code id="plot.bayesDensity_+3A_xleg">xleg</code>, <code id="plot.bayesDensity_+3A_yleg">yleg</code></td>
<td>
<p>position of the legend if <code>over = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.bayesDensity_+3A_type">type</code>, <code id="plot.bayesDensity_+3A_bty">bty</code>, <code id="plot.bayesDensity_+3A_xlab">xlab</code>, <code id="plot.bayesDensity_+3A_ylab">ylab</code>, <code id="plot.bayesDensity_+3A_lty">lty</code>, <code id="plot.bayesDensity_+3A_xlim">xlim</code>, <code id="plot.bayesDensity_+3A_ylim">ylim</code>, <code id="plot.bayesDensity_+3A_main">main</code>, <code id="plot.bayesDensity_+3A_...">...</code></td>
<td>
<p>other
arguments passed to the <code>plot.default</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>

<hr>
<h2 id='plot.bayesGspline'>
Plot an object of class bayesGspline
</h2><span id='topic+plot.bayesGspline'></span>

<h3>Description</h3>

<p>This function plots an object created by <code><a href="#topic+bayesGspline">bayesGspline</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesGspline'
plot(x, add = FALSE, type = "l", lty=1, bty = "n",
     xlab, ylab, main, sub, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bayesGspline_+3A_x">x</code></td>
<td>
<p>an object of class <code>bayesGspline</code>.</p>
</td></tr>
<tr><td><code id="plot.bayesGspline_+3A_add">add</code></td>
<td>
<p>if <code>TRUE</code> a new plot is produced, otherwise it is
drawn to an existing plot.</p>
</td></tr>
<tr><td><code id="plot.bayesGspline_+3A_type">type</code>, <code id="plot.bayesGspline_+3A_lty">lty</code>, <code id="plot.bayesGspline_+3A_bty">bty</code>, <code id="plot.bayesGspline_+3A_xlab">xlab</code>, <code id="plot.bayesGspline_+3A_ylab">ylab</code>, <code id="plot.bayesGspline_+3A_main">main</code>, <code id="plot.bayesGspline_+3A_sub">sub</code>, <code id="plot.bayesGspline_+3A_...">...</code></td>
<td>
<p>other
arguments passed to the <code>plot.default</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>

<hr>
<h2 id='plot.marginal.bayesGspline'>
Plot an object of class marginal.bayesGspline
</h2><span id='topic+plot.marginal.bayesGspline'></span>

<h3>Description</h3>

<p>This function plots an object created by <code><a href="#topic+marginal.bayesGspline">marginal.bayesGspline</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marginal.bayesGspline'
plot(x, type = "l", lty=1, bty = "n",
   xlab1, ylab1, main1, xlab2, ylab2, main2, sub, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.marginal.bayesGspline_+3A_x">x</code></td>
<td>
<p>an object of class <code>marginal.bayesGspline</code>.</p>
</td></tr>
<tr><td><code id="plot.marginal.bayesGspline_+3A_type">type</code>, <code id="plot.marginal.bayesGspline_+3A_lty">lty</code>, <code id="plot.marginal.bayesGspline_+3A_bty">bty</code>, <code id="plot.marginal.bayesGspline_+3A_xlab1">xlab1</code>, <code id="plot.marginal.bayesGspline_+3A_ylab1">ylab1</code>, <code id="plot.marginal.bayesGspline_+3A_main1">main1</code>, <code id="plot.marginal.bayesGspline_+3A_xlab2">xlab2</code>, <code id="plot.marginal.bayesGspline_+3A_ylab2">ylab2</code>, <code id="plot.marginal.bayesGspline_+3A_main2">main2</code>, <code id="plot.marginal.bayesGspline_+3A_sub">sub</code>, <code id="plot.marginal.bayesGspline_+3A_...">...</code></td>
<td>
<p>other
arguments passed to the <code>plot.default</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>

<hr>
<h2 id='predictive'>
Compute predictive quantities based on a Bayesian survival regression
model fitted using bayessurvreg1 function.  
</h2><span id='topic+predictive'></span><span id='topic+predictive.control'></span><span id='topic+C_predictive'></span>

<h3>Description</h3>

<p>This function runs additional McMC to compute predictive survivor and
hazard curves and predictive event times for specified values of
covariates.
</p>
<p>Firstly, the function <code><a href="#topic+bayessurvreg1">bayessurvreg1</a></code> has to be used to
obtain a sample from the posterior distribution of unknown quantities.
</p>
<p>Directly, posterior predictive quantiles and means of asked quantities
are computed and stored in files.
</p>
<p>Function <code>predictive.control</code> serves only to perform some input
checks inside the main function <code>predictive</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictive(formula, random, time0 = 0, data = parent.frame(),
     grid, type = "mixture", subset, na.action = na.fail,
     quantile = c(0, 0.025, 0.5, 0.975, 1),                       
     skip = 0, by = 1, last.iter, nwrite, only.aver = FALSE,
     predict = list(Et=TRUE, t=FALSE, Surv=TRUE, hazard=FALSE, cum.hazard=FALSE),
     store = list(Et=TRUE, t = FALSE, Surv = FALSE, hazard = FALSE, cum.hazard=FALSE),
     Eb0.depend.mix = FALSE,
     dir, toler.chol = 1e-10, toler.qr = 1e-10)

predictive.control(predict, store, only.aver, quantile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictive_+3A_formula">formula</code></td>
<td>
<p>the same formula as that one used to sample from the
posterior distribution of unknown quantities by the function
<code><a href="#topic+bayessurvreg1">bayessurvreg1</a></code>.</p>
</td></tr>
<tr><td><code id="predictive_+3A_random">random</code></td>
<td>
<p>the same <code>random</code> statement as that one used to sample from the
posterior distribution of unknown quantities by the function
<code><a href="#topic+bayessurvreg1">bayessurvreg1</a></code>.</p>
</td></tr>
<tr><td><code id="predictive_+3A_time0">time0</code></td>
<td>
<p>starting time for the survival model. This option is used
to get correct hazard function in the case that the original model was
<code class="reqn">\log(T-time0) = \dots</code>.</p>
</td></tr>
<tr><td><code id="predictive_+3A_data">data</code></td>
<td>
<p>optional data frame in which to interpret the variables
occuring in the formulas. Usually, you create a new
<code>data.frame</code> similar to that one used to obtain a sample from
the posterior distribution. In this new <code>data.frame</code>, put
covariate values equal to these for which predictive quantities are
to be obtained. If <code>cluster</code> statement was used, assign a
unique cluster identification to each observation. Response variable
and a censoring indicator may be set to arbitrary values. They are
only used in <code>formula</code> but are ignored for computation.</p>
</td></tr>
<tr><td><code id="predictive_+3A_grid">grid</code></td>
<td>
<p>a list of length as number of observations in <code>data</code> or a vector
giving grids of values where predictive survivor functions, hazards, cumulative
hazards are to be evaluated. If it is a vector, same grid is used for all
observations from <code>data</code>. Not needed if only <code>predict$t</code>
or <code>predict$Et</code> are <code>TRUE</code>. If <code>time0</code> is different
from zero your grid should start at <code>time0</code> and not at zero.</p>
</td></tr>
<tr><td><code id="predictive_+3A_type">type</code></td>
<td>
<p>a character string giving the type of assumed error distribution. Currently, valid
are substrings of &quot;mixture&quot;. In the future, &quot;spline&quot;,
&quot;polya.tree&quot; might be also implemented.</p>
</td></tr>
<tr><td><code id="predictive_+3A_subset">subset</code></td>
<td>
<p>subset of the observations from the <code>data</code> to be
used. This option will normally not be needed.</p>
</td></tr>  
<tr><td><code id="predictive_+3A_na.action">na.action</code></td>
<td>
<p>function to be used to handle any <code>NA</code>s in the
data. The user is discouraged to change a default value
<code>na.fail</code>.</p>
</td></tr>
<tr><td><code id="predictive_+3A_quantile">quantile</code></td>
<td>
<p>a vector of quantiles that are to be computed for each
predictive quantity.</p>
</td></tr>
<tr><td><code id="predictive_+3A_skip">skip</code></td>
<td>
<p>number of rows that should be skipped at the beginning of
each *.sim file with the stored sample.</p>
</td></tr>
<tr><td><code id="predictive_+3A_by">by</code></td>
<td>
<p>additional thinning of the sample.</p>
</td></tr>
<tr><td><code id="predictive_+3A_last.iter">last.iter</code></td>
<td>
<p>index of the last row from *.sim files that should be
used. If not specified than it is set to the maximum available
determined according to the file <code>mixmoment.sim</code>.</p>
</td></tr>
<tr><td><code id="predictive_+3A_nwrite">nwrite</code></td>
<td>
<p>frequency with which is the user informed about the
progress of computation (every <code>nwrite</code>th iteration count of
iterations change).</p>
</td></tr>
<tr><td><code id="predictive_+3A_only.aver">only.aver</code></td>
<td>
<p>if <code>TRUE</code> only posterior predictive mean is
computed for all quantities and no quantiles.</p>
</td></tr>
<tr><td><code id="predictive_+3A_predict">predict</code></td>
<td>
<p>a list of logical values indicating which predictive quantities are to be sampled.
Components of the list:
</p>

<dl>
<dt>Et</dt><dd><p>predictive expectations of survivor times</p>
</dd>
<dt>t</dt><dd><p>predictive survivor times</p>
</dd>
<dt>Surv</dt><dd><p>predictive survivor functions</p>
</dd>
<dt>hazard</dt><dd><p>predictive hazard functions</p>
</dd>
<dt>cum.hazard</dt><dd><p>predictive cumulative hazard functions</p>
</dd>
</dl>

</td></tr>  
<tr><td><code id="predictive_+3A_store">store</code></td>
<td>
<p>a list of logical values indicating which predictive
quantities are to be stored in files as &lsquo;predET*.sim&rsquo;, &lsquo;predT*.sim&rsquo;,
&lsquo;predS*.sim&rsquo;, &lsquo;predhazard*.sim&rsquo;, &lsquo;predcumhazard*.sim&rsquo;. If you are
interested only in posterior means or quantiles of the predictive
quantities you do not have to store sampled values. Posterior means
and quantiles are stored in files &lsquo;quantET*.sim&rsquo;, &lsquo;quantT*.sim&rsquo;,
&lsquo;quantS*.sim&rsquo;, &lsquo;quanthazard*.sim&rsquo;, &lsquo;quantpredhazard*.sim&rsquo;.</p>
</td></tr>
<tr><td><code id="predictive_+3A_eb0.depend.mix">Eb0.depend.mix</code></td>
<td>
<p>a logical value indicating whether the mean of
the random intercept (if included in the model) was given in a
hierarchical model as an overall mean of the mixture in the error
term. With <code>FALSE</code> (default) you have the same model as that
one described in an accompanying paper. An ordinary user is
discouraged from setting this to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predictive_+3A_dir">dir</code></td>
<td>
<p>a string giving a directory where previously simulated
values were stored and where newly obtained quantities will be
stored. On Unix, do not use &lsquo;~/&rsquo; to specify your home directory.
A full path must be given, e.g. &lsquo;/home/arnost/&rsquo;.</p>
</td></tr>
<tr><td><code id="predictive_+3A_toler.chol">toler.chol</code></td>
<td>
<p>tolerance for the Cholesky decomposition.</p>
</td></tr>
<tr><td><code id="predictive_+3A_toler.qr">toler.qr</code></td>
<td>
<p>tolerance for the QR decomposition.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>An integer which should be equal to zero if everything ran fine.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Komárek, A. (2006).
<em>Accelerated Failure Time Models for Multivariate
Interval-Censored Data with Flexible Distributional Assumptions</em>.
PhD. Thesis, Katholieke Universiteit Leuven, Faculteit Wetenschappen.
</p>
<p>Komárek, A. and Lesaffre, E. (2007).
Bayesian accelerated failure time model for correlated interval-censored data
with a normal mixture as an error distribution.
<em>Statistica Sinica</em>, <b>17</b>, 549 - 569.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the description of R commands for
## the models described in
## Komarek (2006),
## Komarek and Lesaffre (2007).
##
## R commands available
## in the documentation
## directory of this package as
## - ex-cgd.R and
##   https://www2.karlin.mff.cuni.cz/~komarek/software/bayesSurv/ex-cgd.pdf
##
## - ex-tandmobMixture.R and
##   https://www2.karlin.mff.cuni.cz/~komarek/software/bayesSurv/ex-tandmobMixture.pdf
##
</code></pre>

<hr>
<h2 id='predictive2'>
Compute predictive quantities based on a Bayesian survival regression
model fitted using bayesBisurvreg or bayessurvreg2 or bayessurvreg3 functions.
</h2><span id='topic+predictive2'></span><span id='topic+predictive2Para'></span><span id='topic+predictive2.control'></span><span id='topic+C_predictive_GS'></span>

<h3>Description</h3>

<p>This function computes predictive densities, survivor and hazard
curves for specified combinations of covariates.
</p>
<p>Firstly, either the function <code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code> or the
function <code><a href="#topic+bayessurvreg2">bayessurvreg2</a></code> or the function <code><a href="#topic+bayessurvreg3">bayessurvreg3</a></code>
has to be used to obtain a sample from the posterior distribution of unknown quantities.
</p>
<p>Function <code>predictive2.control</code> serves only to perform some input
checks inside the main function <code>predictive2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictive2(formula, random, obs.dim, time0, data = parent.frame(),
     grid, na.action = na.fail, Gspline,
     quantile = c(0, 0.025, 0.5, 0.975, 1),
     skip = 0, by = 1, last.iter, nwrite,
     only.aver = TRUE,
     predict = list(density=FALSE, Surv=TRUE,
                    hazard=FALSE, cum.hazard=FALSE),
     dir, extens = "", extens.random="_b", version=0)

predictive2Para(formula, random, obs.dim, time0, data = parent.frame(),
     grid, na.action = na.fail, Gspline,
     quantile = c(0, 0.025, 0.5, 0.975, 1),
     skip = 0, by = 1, last.iter, nwrite,
     only.aver = TRUE,
     predict = list(density=FALSE, Surv=TRUE,
                    hazard=FALSE, cum.hazard=FALSE),
     dir, extens = "", extens.random="_b", version=0)

predictive2.control(predict, only.aver, quantile, obs.dim,
     time0, Gspline, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictive2_+3A_formula">formula</code></td>
<td>
<p>the same formula as that one used to sample from the
posterior distribution of unknown quantities by the function
<code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code> or <code><a href="#topic+bayessurvreg2">bayessurvreg2</a></code> or
<code><a href="#topic+bayessurvreg3">bayessurvreg3</a></code>. On the left hand side whichever
<code>Surv</code> object of a~proper length
can be used (it is ignored anyway).
</p>
<p>REMARK: the prediction must be asked for at least two combinations of
covariates. This is the restriction imposed by one of the internal
functions I use.
</p>
</td></tr>  
<tr><td><code id="predictive2_+3A_random">random</code></td>
<td>
<p>the same <code>random </code> statement as that one used to sample from the
posterior distribution of unknown quantities by the function
<code><a href="#topic+bayessurvreg2">bayessurvreg2</a></code> or <code><a href="#topic+bayessurvreg3">bayessurvreg3</a></code>, not applicable if
<code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code> was used to sample from the posterior
distribution.
</p>
</td></tr>  
<tr><td><code id="predictive2_+3A_obs.dim">obs.dim</code></td>
<td>
<p>a vector that has to be supplied if bivariate data were
used for estimation (using the function
<code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code>). This vector has to be of the same
length as the number of covariate combinations for which the
predictive quantities are to be computed. It determines to which
dimension (1 or 2) each observation belong.
</p>
</td></tr>  
<tr><td><code id="predictive2_+3A_time0">time0</code></td>
<td>
<p>a~vector of length <code>Gspline$dim</code> giving the starting
time for the survival model. It does not have to be supplied if equal
to zero (usually).
This option is used to get hazard and density functions on the
original time scale in the case that the model was
<code class="reqn">\log(T-time0) = \dots</code>. Note that
<code>time0</code> IS NOT the starting time of doubly censored observation
since there after subtracting the onset time, the starting time is
(usually) equal to zero.
</p>
</td></tr>  
<tr><td><code id="predictive2_+3A_data">data</code></td>
<td>
<p>optional data frame in which to interpret the variables
occuring in the formulas. Usually, you create a new
<code>data.frame</code> similar to that one used to obtain a sample from
the posterior distribution. In this new <code>data.frame</code>, put
covariate values equal to these for which predictive quantities are
to be obtained. If <code>cluster</code> statement was used, assign a
unique cluster identification to each observation. Response variable
and a censoring indicator may be set to arbitrary values. They are
only used in <code>formula</code> but are ignored for computation.
</p>
</td></tr>  
<tr><td><code id="predictive2_+3A_grid">grid</code></td>
<td>
<p>a~vector giving the grid of values where predictive
quantities are to be evaluated. The grid should normally start at some
value slightly higher than <code>time0</code>.
</p>
</td></tr>  
<tr><td><code id="predictive2_+3A_na.action">na.action</code></td>
<td>
<p>function to be used to handle any <code>NA</code>s in the
data. The user is discouraged to change a default value
<code>na.fail</code>.
</p>
</td></tr>  
<tr><td><code id="predictive2_+3A_gspline">Gspline</code></td>
<td>
<p>a~list specifying the G-spline used for the error
distribution in the model. It is a~list with the following components:
</p>

<dl>
<dt>dim</dt><dd><p>dimension of the G-spline, in the case when the function
<code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code> was used to fit the model this will
usually be equal to 2, in the case when the function
<code><a href="#topic+bayessurvreg2">bayessurvreg2</a></code> was used to fit the model this MUST be
equal to 1.</p>
</dd>
<dt>K</dt><dd><p>a~vector of length <code>Gspline$dim</code> specifying the number
of knots at each side of the middle knot for each dimension of the
G-spline.</p>
</dd>
</dl>

</td></tr>  
<tr><td><code id="predictive2_+3A_quantile">quantile</code></td>
<td>
<p>a vector of quantiles that are to be computed for each
predictive quantity.
</p>
</td></tr>  
<tr><td><code id="predictive2_+3A_skip">skip</code></td>
<td>
<p>number of rows that should be skipped at the beginning of
each *.sim file with the stored sample.
</p>
</td></tr>  
<tr><td><code id="predictive2_+3A_by">by</code></td>
<td>
<p>additional thinning of the sample.
</p>
</td></tr>  
<tr><td><code id="predictive2_+3A_last.iter">last.iter</code></td>
<td>
<p>index of the last row from *.sim files that should be
used. If not specified than it is set to the maximum available
determined according to the file <code>mixmoment.sim</code>.
</p>
</td></tr>  
<tr><td><code id="predictive2_+3A_nwrite">nwrite</code></td>
<td>
<p>frequency with which is the user informed about the
progress of computation (every <code>nwrite</code>th iteration count of
iterations change).
</p>
</td></tr>  
<tr><td><code id="predictive2_+3A_only.aver">only.aver</code></td>
<td>
<p>if <code>TRUE</code> only posterior predictive mean is
computed for all quantities and no quantiles.
</p>
<p>The word of warning: with <code>only.aver</code> set to <code>FALSE</code>, all
quantities must be stored for all iterations of the MCMC to be able to
compute the quantiles. This might require quite lots of memory.
</p>
</td></tr>  
<tr><td><code id="predictive2_+3A_predict">predict</code></td>
<td>
<p>a list of logical values indicating which predictive quantities are to be computed.
Components of the list:
</p>

<dl>
<dt>density</dt><dd><p>predictive density</p>
</dd>
<dt>Surv</dt><dd><p>predictive survivor functions</p>
</dd>
<dt>hazard</dt><dd><p>predictive hazard functions</p>
</dd>
<dt>cum.hazard</dt><dd><p>predictive cumulative hazard functions</p>
</dd>
</dl>

</td></tr>  
<tr><td><code id="predictive2_+3A_dir">dir</code></td>
<td>
<p>directory where to search for files (&lsquo;mixmoment.sim&rsquo;,
&lsquo;mweight.sim&rsquo;, mmean.sim', gspline.sim', 'beta.sim', 'D.sim', ...) with the McMC
sample.
</p>
</td></tr>  
<tr><td><code id="predictive2_+3A_extens">extens</code></td>
<td>
<p>an extension used to distinguish different sampled
G-splines if more formulas were used in one MCMC simulation (e.g. with
doubly-censored data).
</p>

<ul>
<li><p> if the data were not doubly-censored or if you wish to compute
predictive quantities for the <em>onset</em> time of the
doubly-censored data then
</p>

<table>
<tr>
 <td style="text-align: center;">
      <code>extens = ""</code>
    </td>
</tr>

</table>

</li>
<li><p> if the data were doubly-censored and you wish to compute
predictive quantities for the <em>event</em> time then
</p>

<table>
<tr>
 <td style="text-align: center;">
      <code>extens = "_2"</code>
    </td>
</tr>

</table>

</li></ul>
  
</td></tr>  
<tr><td><code id="predictive2_+3A_extens.random">extens.random</code></td>
<td>
<p>only applicable if the function
<code><a href="#topic+bayessurvreg3">bayessurvreg3</a></code> was used to generate the MCMC sample.
</p>
<p>This is an extension used to distinguish different sampled G-splines
determining the distribution of the random intercept (under the
presence of doubly-censored data).
</p>

<ul>
<li><p> if the data were not doubly-censored or if you wish to compute
predictive quantities for the <em>onset</em> time of the
doubly-censored data then
</p>

<table>
<tr>
 <td style="text-align: center;">
      <code>extens.random = "_b"</code>
    </td>
</tr>

</table>

</li>
<li><p> if the data were doubly-censored and you wish to compute
predictive quantities for the <em>event</em> time then
</p>

<table>
<tr>
 <td style="text-align: center;">
      <code>extens.random = "_b2"</code>
    </td>
</tr>

</table>

</li></ul>
  
</td></tr>  
<tr><td><code id="predictive2_+3A_version">version</code></td>
<td>
<p> this argument indicates by which <code>bayes*survreg*</code> function the
chains used by <code>bayesGspline</code> were created. Use the following:
</p>

<dl>
<dt>bayesBisurvreg:</dt><dd><p><code>version = 0</code>;</p>
</dd>
<dt>bayessurvreg2:</dt><dd><p><code>version = 0</code>;</p>
</dd>
<dt>bayessurvreg3:</dt><dd><p>with all distributions specified as G-splines:
<code>version = 3</code>;</p>
</dd>
<dt>bayessurvreg3:</dt><dd><p>with error distributions specified as
G-splines and bivariate normal random intercepts: <code>version = 32</code>.</p>
</dd>    
</dl>

</td></tr>  
<tr><td><code id="predictive2_+3A_n">n</code></td>
<td>
<p>number of covariate combinations for which the prediction will
be performed.
</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A list with possibly the following components (what is included depends
on the value of the arguments <code>predict</code> and <code>only.aver</code>):
</p>
<table>
<tr><td><code>grid</code></td>
<td>
<p>a~vector with the grid values at which the survivor
function, survivor density, hazard and cumulative hazard are computed.</p>
</td></tr>
<tr><td><code>Surv</code></td>
<td>
<p>predictive survivor functions.
</p>
<p>A~matrix with as many columns as length(grid) and as many
rows as the number of covariate combinations for which the
predictive quantities were asked. One row per covariate combination.
</p>
</td></tr> 
<tr><td><code>density</code></td>
<td>
<p>predictive survivor densities.
</p>
<p>The same structure as <code>Surv</code> component of the list.
</p>
</td></tr>
<tr><td><code>hazard</code></td>
<td>
<p>predictive hazard functions.
</p>
<p>The same structure as <code>Surv</code> component of the list.    
</p>
</td></tr>
<tr><td><code>cum.hazard</code></td>
<td>
<p>predictive cumulative hazard functions.
</p>
<p>The same structure as <code>Surv</code> component of the list.    
</p>
</td></tr>
<tr><td><code>quant.Surv</code></td>
<td>
<p>pointwise quantiles for the predictive survivor
functions.
</p>
<p>This is a list with as many components as the number of covariate
combinations. One component per covariate combination.
</p>
<p>Each component of this list is a~matrix with as many columns as
length(grid) and as many rows as the length of the argument
<code>quantile</code>. Each row of this matrix gives values of one
quantile. The rows are also labeled by the probabilities (in %) of
the quantiles.
</p>
</td></tr>
<tr><td><code>quant.density</code></td>
<td>
<p>pointwise quantiles for the predictive survivor
densities.
</p>
<p>The same structure as <code>quant.Surv</code> component of the list.
</p>
</td></tr>
<tr><td><code>quant.hazard</code></td>
<td>
<p>pointwise quantiles for the predictive hazard
functions.
</p>
<p>The same structure as <code>quant.Surv</code> component of the list.    
</p>
</td></tr>
<tr><td><code>quant.cum.hazard</code></td>
<td>
<p>pointwise quantiles for the predictive
cumulative hazard functions.
</p>
<p>The same structure as <code>quant.Surv</code> component of the list.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Komárek, A. (2006).
<em>Accelerated Failure Time Models for Multivariate
Interval-Censored Data with Flexible Distributional Assumptions</em>.
PhD. Thesis, Katholieke Universiteit Leuven, Faculteit Wetenschappen.
</p>
<p>Komárek, A. and Lesaffre, E. (2008).
Bayesian accelerated failure time model with multivariate doubly-interval-censored data
and flexible distributional assumptions.
<em>Journal of the American Statistical Association</em>, <b>103</b>,
523 - 533.
</p>
<p>Komárek, A. and Lesaffre, E. (2006).
Bayesian semi-parametric accelerated failurew time model for paired
doubly interval-censored data.
<em>Statistical Modelling</em>, <b>6</b>, 3 - 22.
</p>
<p>Komárek, A.,  Lesaffre, E., and Legrand, C. (2007).
Baseline and treatment effect heterogeneity for survival
times between centers using a random effects accelerated failure time
model with flexible error distribution.
<em>Statistics in Medicine</em>, <b>26</b>, 5457 - 5472.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the description of R commands for
## the models described in
## Komarek (2006),
## Komarek and Lesaffre (2006),
## Komarek and Lesaffre (2008),
## Komarek, Lesaffre, and Legrand (2007).
##
## R commands available in the documentation
## directory of this package
##  - ex-tandmobPA.R and
##    https://www2.karlin.mff.cuni.cz/~komarek/software/bayesSurv/ex-tandmobPA.pdf
##  - ex-tandmobCS.R and
##    https://www2.karlin.mff.cuni.cz/~komarek/software/bayesSurv/ex-tandmobCS.pdf
##  - ex-eortc.R and
##    https://www2.karlin.mff.cuni.cz/~komarek/software/bayesSurv/ex-eortc.pdf
</code></pre>

<hr>
<h2 id='print.bayesDensity'>
Print a summary for the density estimate based on the Bayesian model.
</h2><span id='topic+print.bayesDensity'></span>

<h3>Description</h3>

<p>This function prints a~object created by <code><a href="#topic+bayesDensity">bayesDensity</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesDensity'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bayesDensity_+3A_x">x</code></td>
<td>
<p>an object of class <code>bayesDensity</code>.</p>
</td></tr>
<tr><td><code id="print.bayesDensity_+3A_...">...</code></td>
<td>
<p>this is here for a consistency with a generic function.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>

<hr>
<h2 id='rMVNorm'>
Sample from the multivariate normal distribution
</h2><span id='topic+rMVNorm'></span><span id='topic+C_rmvnormR2006'></span>

<h3>Description</h3>

<p>According to the parametrization used, sample from the multivariate
normal distribution.
</p>
<p>The following parametrization can be specified
</p>

<dl>
<dt>standard</dt><dd>
<p>In this case we sample from either
<code class="reqn">\mathcal{N}(\mu, \Sigma)</code> or from
<code class="reqn">\mathcal{N}(\mu, Q^{-1}).</code>      
</p>
</dd>
<dt>canonical</dt><dd>
<p>In this case we sample from
<code class="reqn">\mathcal{N}(Q^{-1}b,\;Q^{-1}).</code>      
</p>
</dd>
</dl>

<p>Generation of random numbers is performed by Algorithms 2.3-2.5 in Rue and
Held (2005, pp. 34-35). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rMVNorm(n, mean=0, Sigma=1, Q, param=c("standard", "canonical"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rMVNorm_+3A_n">n</code></td>
<td>
<p>number of observations to be sampled.</p>
</td></tr>    
<tr><td><code id="rMVNorm_+3A_mean">mean</code></td>
<td>

<p>For <code>param="standard"</code>, it is 
a vector <code class="reqn">\mu</code> of means. If <code>length(mean)</code> is equal to 1, it
is recycled and all components have the same mean.
</p>
<p>For <code>param="canonical"</code>, it is 
a vector <code class="reqn">b</code> of canonical means. If <code>length(mean)</code> is equal to 1, it
is recycled and all components have the same mean.    
</p>
</td></tr>
<tr><td><code id="rMVNorm_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix of the multivariate normal
distribution. It is ignored if <code>Q</code> is given at the same time.
</p>
</td></tr>
<tr><td><code id="rMVNorm_+3A_q">Q</code></td>
<td>
<p>precision matrix of the multivariate normal distribution.
</p>
<p>It does not have to be supplied provided <code>Sigma</code> is given and
<code>param="standard"</code>.
</p>
<p>It must be supplied if <code>param="canonical"</code>.
</p>
</td></tr>
<tr><td><code id="rMVNorm_+3A_param">param</code></td>
<td>
<p>a character which specifies the parametrization.
</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Matrix with sampled points in rows.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Rue, H. and Held, L. (2005).
<em>Gaussian Markov Random Fields: Theory and Applications</em>.
Boca Raton: Chapman and Hall/CRC.  
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+rnorm">rnorm</a></code>, <code><a href="mvtnorm.html#topic+Mvnorm">Mvnorm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Mean, covariance matrix, its inverse
### and the canonical mean
mu &lt;- c(0, 2, 0.5)
L &lt;- matrix(c(1, 1, 1,  0, 0.5, 0.5,  0, 0, 0.3), ncol=3)
Sigma &lt;- L %*% t(L)
Q &lt;- chol2inv(t(L))
b &lt;- Q %*% mu

print(Sigma)
print(Q)
print(Sigma %*% Q)

### Sample using different parametrizations
set.seed(775988621)
n &lt;- 10000

### Sample from N(mu, Sigma)
xx1 &lt;- rMVNorm(n=n, mean=mu, Sigma=Sigma)
apply(xx1, 2, mean)
var(xx1)

### Sample from N(mu, Q^{-1})
xx2 &lt;- rMVNorm(n=n, mean=mu, Q=Q)
apply(xx2, 2, mean)
var(xx2)

### Sample from N(Q^{-1}*b, Q^{-1})
xx3 &lt;- rMVNorm(n=n, mean=b, Q=Q, param="canonical")
apply(xx3, 2, mean)
var(xx3)
</code></pre>

<hr>
<h2 id='rWishart'>
Sample from the Wishart distribution
</h2><span id='topic+rWishart'></span><span id='topic+C_rwishartR3'></span>

<h3>Description</h3>

<p>Sample from the Wishart distribution
</p>
<p style="text-align: center;"><code class="reqn">\mbox{Wishart}(\nu, S),</code>
</p>

<p>where <code class="reqn">\nu</code> are degrees of freedom of the Wishart distribution
and <code class="reqn">S</code> is its scale matrix. The same parametrization as in
Gelman (2004) is assumed, that is, if
<code class="reqn">W\sim\mbox{Wishart}(\nu,S)</code> then
</p>
<p style="text-align: center;"><code class="reqn">\mbox{E}(W) = \nu S</code>
</p>
<p>.
</p>
<p>In the univariate case, <code class="reqn">\mbox{Wishart}(\nu,S)</code> is the
same as <code class="reqn">\mbox{Gamma}(\nu/2, 1/(2S)).</code>  
</p>
<p>Generation of random numbers is performed by the algorithm described
in Ripley (1987, pp. 99).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rWishart(n, df, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rWishart_+3A_n">n</code></td>
<td>
<p>number of observations to be sampled.</p>
</td></tr>    
<tr><td><code id="rWishart_+3A_df">df</code></td>
<td>
<p>degrees of freedom of the Wishart distribution.
</p>
</td></tr>
<tr><td><code id="rWishart_+3A_s">S</code></td>
<td>
<p>scale matrix of the Wishart distribution.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with sampled points (lower triangles of <code class="reqn">W</code>) in rows.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Gelman, A., Carlin, J. B., Stern, H. S., and Rubin, D. B. (2004).
<em>Bayesian Data Analysis, Second edition</em>. 
Boca Raton: Chapman and Hall/CRC.
</p>
<p>Ripley, B. D. (1987).
<em>Stochastic Simulation</em>.
New York: John Wiley and Sons.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### The same as rgamma(n, shape=df/2, rate=1/(2*S))
n &lt;- 1000
df &lt;- 1
S  &lt;- 3
w &lt;- rWishart(n=n, df=df, S=S)
mean(w)    ## should be close to df*S
var(w)     ## should be close to 2*df*S^2

### Multivariate Wishart
n &lt;- 1000
df &lt;- 2
S &lt;- matrix(c(1,3,3,13), nrow=2)
w &lt;- rWishart(n=n, df=df, S=S)
apply(w, 2, mean)                ## should be close to df*S
df*S

df &lt;- 2.5
S &lt;- matrix(c(1,2,3,2,20,26,3,26,70), nrow=3)
w &lt;- rWishart(n=n, df=df, S=S)
apply(w, 2, mean)                ## should be close to df*S
df*S
</code></pre>

<hr>
<h2 id='sampleCovMat'>
Compute a sample covariance matrix.
</h2><span id='topic+sampleCovMat'></span>

<h3>Description</h3>

<p>This function computes a sample covariance matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleCovMat(sample)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleCovMat_+3A_sample">sample</code></td>
<td>
<p>a <code>matrix</code> or <code>data.frame</code> with sampled values
in rows. I.e. number of rows of <code>sample</code> determines a sample
size, number of columns of <code>sample</code> determines a dimension of
the distribution from which it was sampled.
</p>
</td></tr>     
</table>


<h3>Details</h3>

<p>When <code class="reqn">y_1, \dots, y_n</code> is a sequence of
<code class="reqn">p</code>-dimensional vectors <code class="reqn">y_i</code> the sample covariance
matrix <code class="reqn">S</code> is equal to
</p>
<p style="text-align: center;"><code class="reqn">S = \frac{1}{n-1} \sum_{i=1}^n (y_i - m)(y_i - m)^T</code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">m = \frac{1}{n}\sum_{i=1}^n y_i.</code>
</p>

<p>When <code class="reqn">n=1</code> the function returns just sum of squares.      
</p>


<h3>Value</h3>

<p>This function returns a matrix.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Sample some values
  z1 &lt;- rnorm(100, 0, 1)           ## first components of y
  z2 &lt;- rnorm(100, 5, 2)           ## second components of y
  z3 &lt;- rnorm(100, 10, 0.5)        ## third components of y

  ## Put them into a data.frame
  sample &lt;- data.frame(z1, z2, z3)

  ## Compute a sample covariance matrix
  sampleCovMat(sample)
</code></pre>

<hr>
<h2 id='sampled.kendall.tau'>
Estimate of the Kendall's tau from the bivariate model
</h2><span id='topic+sampled.kendall.tau'></span><span id='topic+C_sampledKendallTau'></span>

<h3>Description</h3>

<p>This function computes an estimate of the residual (after adjustment
for covariates) Kendall's tau for the bivariate survival model fitted
using the functions <code><a href="#topic+bayesHistogram">bayesHistogram</a></code> or
<code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code>.
</p>
<p>For both these function their argument <code>prior$specification</code> must
be equal to 2!
</p>
<p>When <code class="reqn">G</code> is a bivariate distribution function, the population
version of the Kendall's tau is defined as
</p>
<p style="text-align: center;"><code class="reqn">\tau = 4\int G dG - 1</code>
</p>
<p>.
</p>
<p>For the model estimated using one of the above mentioned functions the
value of Kendall's tau at each iteration of MCMC is equal to
</p>
<p style="text-align: center;"><code class="reqn">\tau =
    4\sum_{i=-K_1}^{K_1}\sum_{j=-K_2}^{K_2}\sum_{k=-K_1}^{K_1}\sum_{l=-K_2}^{K_2}w_{i,j} w_{k,l}
    \Phi\left(\frac{\mu_{1,i} - \mu_{1,k}}{\sqrt{2}\sigma_1}\right)
    \Phi\left(\frac{\mu_{2,j} - \mu_{2,l}}{\sqrt{2}\sigma_2}\right)
    - 1,</code>
</p>

<p>where <code class="reqn">\mu_{1,-K_1},\dots,\mu_{1,K_1}</code>
are knots in the first margin, 
<code class="reqn">\mu_{2,-K_2},\dots,\mu_{2,K_2}</code>
are knots in the second margin,
<code class="reqn">\sigma_1</code> is the basis standard deviation in the first margin,
<code class="reqn">\sigma_2</code> is the basis standard deviation in the second margin,
and <code class="reqn">w_{i,j},\;i=-K_1,\dots,K_1,\;j=-K_2,\dots,K_2</code> are the G-spline weights.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampled.kendall.tau(dir = getwd(), extens = "", K,
  skip = 0, by = 1, last.iter, nwrite)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="sampled.kendall.tau_+3A_dir">dir</code></td>
<td>
<p>directory where to search for files (&lsquo;mixmoment.sim&rsquo;,
&lsquo;mweight.sim&rsquo;, &lsquo;mmean.sim&rsquo;, &lsquo;gspline.sim&rsquo;) with the MCMC
sample.</p>
</td></tr>
<tr><td><code id="sampled.kendall.tau_+3A_extens">extens</code></td>
<td>
<p>an extension used to distinguish different sampled
G-splines if more G-splines were used in one simulation (with
doubly-censored data) According to which
<code>bayes*survreg*</code> function was used, specify the argument
<code>extens</code> in the following way.
</p>

<dl>
<dt>bayesHistogram:</dt><dd>
<p>always <code>extens = ""</code>
</p>
</dd>
<dt>bayesBisurvreg:</dt><dd><p><code class="reqn">\quad</code>
</p>

<ul>
<li><p> to compute the bivariate distribution of the <em>error</em> term for
the <em>onset</em> time: <code>extens = ""</code>;
</p>
</li>
<li><p> to compute the bivariate distribution of the <em>error</em> term for
the <em>event</em> time if there was doubly-censoring:
<code>extens = "_2"</code>;
</p>
</li></ul>
	 
</dd>
</dl>

</td></tr>
<tr><td><code id="sampled.kendall.tau_+3A_k">K</code></td>
<td>
<p>a~vector of length 2 specifying the number of knots at each side of the middle knot for each dimension of the
G-spline.</p>
</td></tr>
<tr><td><code id="sampled.kendall.tau_+3A_skip">skip</code></td>
<td>
<p>number of rows that should be skipped at the beginning of
each *.sim file with the stored sample.</p>
</td></tr>
<tr><td><code id="sampled.kendall.tau_+3A_by">by</code></td>
<td>
<p>additional thinning of the sample.</p>
</td></tr>
<tr><td><code id="sampled.kendall.tau_+3A_last.iter">last.iter</code></td>
<td>
<p>index of the last row from *.sim files that should be
used. If not specified than it is set to the maximum available
determined according to the file <code>mixmoment.sim</code>.</p>
</td></tr>
<tr><td><code id="sampled.kendall.tau_+3A_nwrite">nwrite</code></td>
<td>
<p>frequency with which is the user informed about the
progress of computation (every <code>nwrite</code>th iteration count of
iterations change).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with sampled values of the Kendall's tau.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Komárek, A. (2006).
<em>Accelerated Failure Time Models for Multivariate
Interval-Censored Data with Flexible Distributional Assumptions</em>.
PhD. Thesis, Katholieke Universiteit Leuven, Faculteit Wetenschappen.
</p>
<p>Komárek, A. and Lesaffre, E. (2006).
Bayesian semi-parametric accelerated failurew time model for paired
doubly interval-censored data.
<em>Statistical Modelling</em>, <b>6</b>, 3 - 22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the description of R commands for
## the models described in
## Komarek (2006),
## Komarek and Lesaffre (2006),
## 
## R commands available
## in the documentation
## directory of this package
## - see ex-tandmobPA.R and
##   https://www2.karlin.mff.cuni.cz/~komarek/software/bayesSurv/ex-tandmobPA.pdf
##
</code></pre>

<hr>
<h2 id='scanFN'>Read Data Values</h2><span id='topic+scanFN'></span>

<h3>Description</h3>

<p>Read numeric data into a data frame from a file. Header is assumed to
be present in the file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scanFN(file, quiet=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scanFN_+3A_file">file</code></td>
<td>
<p>the name of a file to read data values from.  If the
specified file is <code>""</code>, then input is taken from the keyboard
(or <code>stdin</code> if input is redirected).
(In this case input can be terminated by a blank line or an EOF
signal, <code>Ctrl-D</code> on Unix and <code>Ctrl-Z</code> on Windows.)
</p>
<p>Otherwise, the file name is interpreted <em>relative</em> to the
current working directory (given by <code><a href="base.html#topic+getwd">getwd</a>()</code>),
unless it specifies an <em>absolute</em> path.
Tilde-expansion is performed where supported.
</p>
<p>Alternatively, <code>file</code> can be a <code><a href="base.html#topic+connection">connection</a></code>,
which will be opened if necessary, and if so closed at the end of
the function call.  Whatever mode the connection is opened in,
any of LF, CRLF or CR will be accepted as the EOL marker for a line
and so will match <code>sep = "\n"</code>.
</p>
<p><code>file</code> can also be a complete URL.
</p>
<p>To read a data file not in the current encoding (for example a
Latin-1 file in a UTF-8 locale or conversely) use a
<code><a href="base.html#topic+file">file</a></code> connection setting the <code>encoding</code> argument.
</p>
</td></tr>
<tr><td><code id="scanFN_+3A_quiet">quiet</code></td>
<td>
<p>logical: if <code>FALSE</code> (default), scan() will print a
line, saying how many items have been read.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="base.html#topic+scan">scan</a></code>.
</p>


<h3>Value</h3>

<p><code>data.frame</code> with read data values.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
<em>The New S Language</em>.
Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scan">scan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cat("x y z", "1 2 3", "1 4 6", "10 20 30", file="ex.data", sep="\n")
pp &lt;- scanFN("ex.data", quiet=FALSE)
pp &lt;- scanFN("ex.data", quiet= TRUE)
print(pp)
unlink("ex.data") # tidy up
</code></pre>

<hr>
<h2 id='simult.pvalue'>
Compute a simultaneous p-value from a sample for a vector valued parameter.
</h2><span id='topic+simult.pvalue'></span><span id='topic+print.simult.pvalue'></span>

<h3>Description</h3>

<p>The p-value is computed as 1 - the credible level of the credible
region which just cover the point (0, 0, ..., 0)'.
</p>
<p>The function returns also the simultaneous credible region (rectangle)
with a specified credible level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simult.pvalue(sample, precision=0.001, prob=0.95)
## S3 method for class 'simult.pvalue'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simult.pvalue_+3A_sample">sample</code></td>
<td>
<p>a data frame or matrix with sampled values (one column =
one parameter)</p>
</td></tr>
<tr><td><code id="simult.pvalue_+3A_precision">precision</code></td>
<td>
<p>precision with which the p-value is to be computed</p>
</td></tr>
<tr><td><code id="simult.pvalue_+3A_prob">prob</code></td>
<td>
<p>probability for which the credible region is to be
computed</p>
</td></tr>
<tr><td><code id="simult.pvalue_+3A_x">x</code></td>
<td>
<p>an object of class simult.pvalue</p>
</td></tr>
<tr><td><code id="simult.pvalue_+3A_...">...</code></td>
<td>
<p>who knows</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'simult.pvalue'.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Besag, J., Green, P., Higdon, D. and Mengersen, K. (1995).
Bayesian computation and stochastic systems (with Discussion).
<em>Statistical Science,</em> <b>10</b>, 3 - 66. page 30
</p>
<p>Held, L. (2004).
Simultaneous posterior probability statements from Monte Carlo output.
<em>Journal of Computational and Graphical Statistics,</em> <b>13</b>, 20 - 35. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- 1000
sample &lt;- data.frame(x1=rnorm(m), x2=rnorm(m), x3=rnorm(m))
simult.pvalue(sample)

sample &lt;- data.frame(x1=rnorm(m), x2=rnorm(m), x3=rnorm(m, mean=2))
simult.pvalue(sample)

sample &lt;- data.frame(x1=rnorm(m), x2=rnorm(m), x3=rnorm(m, mean=5))
simult.pvalue(sample, prob=0.99, precision=0.0001)
</code></pre>

<hr>
<h2 id='tandmob2'>Signal Tandmobiel data, version 2</h2><span id='topic+tandmob2'></span>

<h3>Description</h3>

<p>This is the dataset resulting from a longitudinal prospective dental
study performed in Flanders (North of Belgium) in 1996 &ndash; 2001. The
cohort of 4\,468 randomly sampled children who attended the first year
of the basic school at the beginning of the study was annualy dental
examined by one of 16 trained dentists.
The original dataset consists thus of at most 6 dental observations
for each child.
</p>
<p>The dataset presented here contains mainly the
information on the emergence and caries times summarized in the
interval-censored observations. Some baseline covariates are also
included here.
</p>
<p>For more detail on the design of the study see Vanobbergen et
al. (2000).
</p>
<p>This data set was used in the analyses presented in
Komárek et al. (2005), in
Lesaffre, Komárek, and Declerck (2005) and in
Komárek and Lesaffre (2007).
</p>
<p><b>IMPORTANT NOTICE:</b> It is possible to use these data for your
research work under the condition that each manuscript is first
approved by <br />
Prof. Emmanuel Lesaffre <br />
Leuven Biostatistics and statistical Bioinformatics Centre (L-BioStat) <br />
Katholieke Universiteit Leuven <br />
Kapucijnenvoer 35 <br />
B-3000 Leuven <br />
Belgium <br />
&lt;<code>emmanuel.lesaffre@kuleuven.be</code>&gt;  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tandmob2)</code></pre>


<h3>Format</h3>

<p>a~data frame with 4\,430 rows (38 sampled children did not come
to any of the designed dental examinations) and the following
variables
</p>

<dl>
<dt>IDNR</dt><dd><p>identification number of a child</p>
</dd>
<dt>GENDER</dt><dd><p>character <em>boy</em> or <em>girl</em></p>
</dd>
<dt>GENDERNum</dt><dd><p>numeric, 0 = <em>boy</em>, 1 = <em>girl</em></p>
</dd>
<dt>DOB</dt><dd><p>character, date of birth in the format DDmmmYY</p>
</dd>
<dt>PROVINCE</dt><dd><p>factor, code of the province with
</p>

<dl>
<dt>0 = </dt><dd><p>Antwerpen</p>
</dd>
<dt>1 = </dt><dd><p>Vlaams Brabant</p>
</dd>
<dt>2 = </dt><dd><p>Limburg</p>
</dd>
<dt>3 = </dt><dd><p>Oost Vlaanderen</p>
</dd>
<dt>4 = </dt><dd><p>West Vlaanderen</p>
</dd>
</dl>
  
</dd>
<dt>EDUC</dt><dd><p>factor, code of the educational system with
</p>

<dl>
<dt>0 = </dt><dd><p>Free</p>
</dd>
<dt>1 = </dt><dd><p>Community school</p>
</dd>
<dt>2 = </dt><dd><p>Province/council school</p>
</dd>
</dl>
  
</dd>
<dt>STARTBR</dt><dd><p>factor, code indicating the starting age of brushing
the teeth (as reported by parents) with
</p>

<dl>
<dt>1 = </dt><dd><p>[0, 1] years</p>
</dd>
<dt>2 = </dt><dd><p>(1, 2] years</p>
</dd>
<dt>3 = </dt><dd><p>(2, 3] years</p>
</dd>
<dt>4 = </dt><dd><p>(3, 4] years</p>
</dd>
<dt>5 = </dt><dd><p>(4, 5] years</p>
</dd>      
<dt>6 = </dt><dd><p>later than at the age of 5</p>
</dd>      
</dl>
  
</dd>
<dt>FLUOR</dt><dd><p>binary covariate, 0 = no, 1 = yes. This is the covariate
<em>fluorosis</em> used in the paper Komárek et al. (2005).
</p>
</dd>
<dt>BAD.xx</dt><dd><p>binary, indicator whether a deciduous tooth xx was
removed becaues of orthodontical reasons or not.
</p>
<p>xx takes values 53, 63, 73, 83 (deciduous lateral canines),
54, 64, 74, 84 (deciduous first molars),
55, 65, 75, 85 (deciduous second molars).
</p>
</dd>
<dt>EBEG.xx</dt><dd><p>lower limit of the emergence (in years of age) of the
permanent tooth xx. <code>NA</code> if the emergence was left-censored.
</p>
<p>xx takes values 11, 21, 31, 41 (permanent incisors),
12, 22, 32, 42 (permanent central canines),
13, 23, 33, 43 (permanent lateral canines),
14, 24, 34, 44 (permanent first premolars),
15, 25, 35, 45 (permanent second premolars),
16, 26, 36, 46 (permanent first molars),
17, 27, 37, 47 (permanent second molars).
</p>
</dd>
<dt>EEND.xx</dt><dd><p>upper limit of the emergence (in years of age) of the
permanent tooth xx. <code>NA</code> if the emergence was right-censored.
</p>
<p>xx takes values as for the variable <code>EBEG.xx</code>.
</p>
</dd>
<dt>FBEG.xx</dt><dd><p>lower limit for the caries time (in years of age, &lsquo;F&rsquo;
stands for &lsquo;failure&rsquo;) of the permanent tooth xx. <code>NA</code> if the
caries time was left-censored.
</p>
<p>xx takes values as for the variable <code>EBEG.xx</code>.    
</p>
</dd>
<dt>FEND.xx</dt><dd><p>upper limit for the caries time (in years of age, &lsquo;F&rsquo;
stands for &lsquo;failure&rsquo;) of the permanent tooth xx. <code>NA</code> if the
caries time was right-censored.
</p>
<p>xx takes values as for the variable <code>EBEG.xx</code>.
</p>
<p>Unfortunately, for all teeth except 16, 26, 36 and 46 almost all
the caries times are right-censored. For teeth 16, 26, 36, 46, the
amount of right-censoring is only about 25%.
</p>
</dd>
<dt>Txx.DMF</dt><dd><p>indicator whether a deciduous tooth xx was
<em><b>d</b>ecayed</em> or <em><b>m</b>issing due to caries</em>
or <em><b>f</b>illed</em> on at most the last examination
before the first examination when the emergence of the permanent
successor was recorded.
</p>
<p>xx takes values 53, 63, 73, 83 (deciduous lateral incisors),
54, 64, 74, 84 (deciduous first molars),
55, 65, 75, 85 (deciduous second molars).
</p>
</dd>
<dt>Txx.CAR</dt><dd><p>indicator whether a~deciduous tooth xx was
removed due to the orthodontical reasons or decayed
on at most the last examination before the first examination when  
the emergence of the permanent successor was recorded.
</p>
</dd>  
</dl>
  


<h3>Source</h3>

<p>Leuven Biostatistics and statistical Bioinformatics Centre (L-BioStat), Katholieke Universiteit Leuven,
Kapucijnenvoer 35, 3000 Leuven, Belgium
</p>
<p><code>URL:</code> <code>https://gbiomed.kuleuven.be/english/research/50000687/50000696/</code>
</p>
<p>Data collection was supported by Unilever, Belgium.
The Signal Tandmobiel project comprises the following partners:
D. Declerck (Dental School, Catholic University Leuven),
L. Martens (Dental School, University Ghent),
J. Vanobbergen (Oral Health Promotion and Prevention, Flemish Dental Association),
P. Bottenberg (Dental School, University Brussels),
E. Lesaffre (Biostatistical Centre, Catholic University Leuven),
K. Hoppenbrouwers (Youth Health Department, Catholic University Leuven; Flemish Association for Youth Health Care).  
</p>


<h3>References</h3>

<p>Komárek, A., Lesaffre, E.,
<code class="reqn">\mbox{H\"{a}rk\"{a}nen,}</code> T., Declerck, D., and
Virtanen, J. I. (2005).
A Bayesian analysis of multivariate doubly-interval-censored dental data.
<em>Biostatistics,</em> <b>6</b>, 145&ndash;155.
</p>
<p>Komárek, A. and Lesaffre, E. (2007).
Bayesian accelerated failure time model for correlated interval-censored data
with a normal mixture as an error distribution.
<em>Statistica Sinica,</em> <b>17</b>, 549&ndash;569. 
</p>
<p>Lesaffre, E., Komárek, A., and Declerck, D. (2005).
An overview of methods for interval-censored data with an emphasis on
applications in dentistry.
<em>Statistical Methods in Medical Research</em>, <b>14</b>, 539&ndash;552.
</p>
<p>Vanobbergen, J., Martens, L., Lesaffre, E., and Declerck, D. (2000).
The Signal-Tandmobiel project &ndash; a longitudinal intervention health promotion
study in Flanders (Belgium): baseline and first year results.
<em>European Journal of Paediatric Dentistry</em>, <b>2</b>, 87&ndash;96.
</p>

<hr>
<h2 id='tandmobRoos'>Signal Tandmobiel data, version Roos</h2><span id='topic+tandmobRoos'></span>

<h3>Description</h3>

<p>This is the dataset resulting from a longitudinal prospective dental
study performed in Flanders (North of Belgium) in 1996 &ndash; 2001. The
cohort of 4\,468 randomly sampled children who attended the first year
of the basic school at the beginning of the study was annualy dental
examined by one of 16 trained dentists.
The original dataset consists thus of at most 6 dental observations
for each child.
</p>
<p>The dataset presented here contains mainly the
information on the emergence and caries times summarized in the
interval-censored observations. Some baseline covariates are also
included here.
</p>
<p>For more detail on the design of the study see Vanobbergen et
al. (2000).
</p>
<p>This is the version of the dataset used first by Leroy et al. (2005)
and contains a subset of the <code><a href="#topic+tandmob2">tandmob2</a></code>. Some children
were removed to satisfy inclusion criteria given in Leroy et
al. (2005). Additionally, left-censored emergence times of the
permanent first molars are adjusted according to the eruption stage
(see Leroy et al., 2005).
</p>
<p>This data set was then used in the analyses presented in
Komárek and Lesaffre (2006, 2008).
</p>
<p><b>IMPORTANT NOTICE:</b> It is possible to use these data for your
research work under the condition that each manuscript is first
approved by <br />
Prof. Emmanuel Lesaffre <br />
Leuven Biostatistics and statistical Bioinformatics Centre (L-BioStat) <br />
Katholieke Universiteit Leuven <br />
Kapucijnenvoer 35 <br />
B-3000 Leuven <br />
Belgium <br />
&lt;<code>emmanuel.lesaffre@kuleuven.be</code>&gt;  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tandmobRoos)</code></pre>


<h3>Format</h3>

<p>a~data frame with 4\,394 rows and the following
variables
</p>

<dl>
<dt>IDNR</dt><dd><p>identification number of a child</p>
</dd>
<dt>GENDER</dt><dd><p>character <em>boy</em> or <em>girl</em></p>
</dd>
<dt>DOB</dt><dd><p>character, date of birth in the format DDmmmYY</p>
</dd>
<dt>PROVINCE</dt><dd><p>factor, code of the province with
</p>

<dl>
<dt>0 = </dt><dd><p>Antwerpen</p>
</dd>
<dt>1 = </dt><dd><p>Vlaams Brabant</p>
</dd>
<dt>2 = </dt><dd><p>Limburg</p>
</dd>
<dt>3 = </dt><dd><p>Oost Vlaanderen</p>
</dd>
<dt>4 = </dt><dd><p>West Vlaanderen</p>
</dd>
</dl>
  
</dd>
<dt>EDUC</dt><dd><p>factor, code of the educational system with
</p>

<dl>
<dt>0 = </dt><dd><p>Free</p>
</dd>
<dt>1 = </dt><dd><p>Community school</p>
</dd>
<dt>2 = </dt><dd><p>Province/council school</p>
</dd>
</dl>
  
</dd>
<dt>GIRL</dt><dd><p>numeric, 0 = <em>boy</em>, 1 = <em>girl</em></p>
</dd>
<dt>EBEG.xx</dt><dd><p>lower limit of the emergence (in years of age) of the
permanent tooth xx. In contrast to <code><a href="#topic+tandmob2">tandmob2</a></code>, the lower
emergence limit for the permanent first molars that were originally
left-censored, are adjusted according to the eruption stage (see
Leroy, 2005 for more details).
</p>
<p>xx takes values 16, 26, 36, 46 (permanent first molars).
</p>
</dd>
<dt>EEND.xx</dt><dd><p>upper limit of the emergence (in years of age) of the
permanent tooth xx. <code>NA</code> if the emergence was right-censored.
</p>
<p>xx takes values as for the variable <code>EBEG.xx</code>.
</p>
</dd>
<dt>FBEG.xx</dt><dd><p>lower limit for the caries time (in years of age, &lsquo;F&rsquo;
stands for &lsquo;failure&rsquo;) of the permanent tooth xx. <code>NA</code> if the
caries time was left-censored.
</p>
<p>xx takes values as for the variable <code>EBEG.xx</code>.    
</p>
</dd>
<dt>FEND.xx</dt><dd><p>upper limit for the caries time (in years of age, &lsquo;F&rsquo;
stands for &lsquo;failure&rsquo;) of the permanent tooth xx. <code>NA</code> if the
caries time was right-censored.
</p>
<p>xx takes values as for the variable <code>EBEG.xx</code>.
</p>
<p>Unfortunately, for all teeth except 16, 26, 36 and 46 almost all
the caries times are right-censored. For teeth 16, 26, 36, 46, the
amount of right-censoring is only about 25%.
</p>
</dd>
<dt>TOOTH.xx</dt><dd><p>numeric, 0 or 1. Equal to 1 if the information
concerning the permanent tooth was available, 0 if the permanent
tooth xx was removed from the dataset by Kris.
</p>
<p>xx takes values 16, 26, 36, 46.
</p>
<p>These variables are almost useless for ordinary users.
</p>
</dd>
<dt>Txxd</dt><dd><p>numeric, 0 or 1. It is equal to 1 if the deciduous tooth
xx was decayed, 0 otherwise.
</p>
<p>xx takes values 54, 64, 74, 84 (deciduous first molars),
55, 65, 75, 85 (deciduous second molars).
</p>
</dd>
<dt>Txxm</dt><dd><p>numeric, 0 or 1. It is equal to 1 if the deciduous tooth
xx was missing due to caries, 0 otherwise.
</p>
<p>xx takes values 54, 64, 74, 84 (deciduous first molars),
55, 65, 75, 85 (deciduous second molars).
</p>
</dd>
<dt>Txxf</dt><dd><p>numeric, 0 or 1. It is equal to 1 if the deciduous tooth
xx was filled, 0 otherwise.
</p>
<p>xx takes values 54, 64, 74, 84 (deciduous first molars),
55, 65, 75, 85 (deciduous second molars).
</p>
</dd>
<dt>Txxs</dt><dd><p>numeric, 0 or 1. It is equal to 1 if the deciduous tooth
xx was sound, 0 otherwise.
</p>
<p>xx takes values 54, 64, 74, 84 (deciduous first molars),
55, 65, 75, 85 (deciduous second molars).
</p>
</dd>
<dt>SEAL.xx</dt><dd><p>numeric, 0 or 1. It is equal to 1 if the permanent
first molar xx was sealed in pits and fissures (a form of
protection), 0 otherwise.
</p>
<p>xx takes values 16, 26, 36, 46 (permanent first molars).    
</p>
</dd>
<dt>FREQ.BR</dt><dd><p>numeric, 0 or 1. It is equal to 1 if the child brushes
daily the teeth, equal to 0 if he/she brushes less than once a day.
</p>
</dd>
<dt>PLAQUE.xx.1</dt><dd><p>numeric, 0 or 1. It is equal to 1 if there was
occlusal plaque in pits and fissures of the permanent tooth xx. It
is equal to 0 if there was either no plaque present or the plaque
was present on the total occlusal surface.
</p>
<p>xx takes values 16, 26, 36, 46 (permanent first molars).    
</p>
</dd>  
<dt>PLAQUE.xx.2</dt><dd><p>numeric, 0 or 1. It is equal to 1 if there was
occlusal plaque on the total occlusal surface of the permanent tooth xx. It
is equal to 0 if there was either no plaque present or the plaque
was present only in pits and fissures.
</p>
<p>xx takes values 16, 26, 36, 46 (permanent first molars).    
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Leuven Biostatistics and statistical Bioinformatics Centre (L-BioStat), Katholieke Universiteit Leuven,
Kapucijnenvoer 35, 3000 Leuven, Belgium
</p>
<p><code>URL:</code> <code>https://gbiomed.kuleuven.be/english/research/50000687/50000696/</code>
</p>
<p>Data collection was supported by Unilever, Belgium.
The Signal Tandmobiel project comprises the following partners:
D. Declerck (Dental School, Catholic University Leuven),
L. Martens (Dental School, University Ghent),
J. Vanobbergen (Oral Health Promotion and Prevention, Flemish Dental Association),
P. Bottenberg (Dental School, University Brussels),
E. Lesaffre (Biostatistical Centre, Catholic University Leuven),
K. Hoppenbrouwers (Youth Health Department, Catholic University Leuven; Flemish Association for Youth Health Care).
</p>


<h3>References</h3>

<p>Komárek, A. and Lesaffre, E. (2008).
Bayesian accelerated failure time model with multivariate doubly-interval-censored data
and flexible distributional assumptions.
<em>Journal of the American Statistical Association</em>, <b>103</b>, 523&ndash;533.
</p>
<p>Komárek, A. and Lesaffre, E. (2006).
Bayesian semi-parametric accelerated failurew time model for paired
doubly interval-censored data.
<em>Statistical Modelling</em>, <b>6</b>, 3&ndash;22.
</p>
<p>Leroy, R., Bogaerts, K., Lesaffre, E., and Declerck, D. (2005).
Effect of caries experience in primary molars on cavity formation
in the adjacent permanent first molar.
<em>Caries Research</em>, <b>39</b>, 342&ndash;349.
</p>
<p>Vanobbergen, J., Martens, L., Lesaffre, E., and Declerck, D. (2000).
The Signal-Tandmobiel project &ndash; a longitudinal intervention health promotion
study in Flanders (Belgium): baseline and first year results.
<em>European Journal of Paediatric Dentistry</em>, <b>2</b>, 87&ndash;96.
</p>

<hr>
<h2 id='traceplot2'>
Trace plot of MCMC output.
</h2><span id='topic+traceplot2'></span>

<h3>Description</h3>

  
<p>Displays a plot of iterations vs. sampled values for each variable in
the chain, with a separate plot per variable.
</p>
<p>This is slightly modified version of <code><a href="coda.html#topic+traceplot">traceplot</a></code> function
of a <code>coda</code> package to conform to my personal preferences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traceplot2(x, chains, bty = "n", main, xlab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traceplot2_+3A_x">x</code></td>
<td>
<p>an <code><a href="coda.html#topic+mcmc">mcmc</a></code> or <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.</p>
</td></tr>
<tr><td><code id="traceplot2_+3A_chains">chains</code></td>
<td>
<p>indeces of chains from the object that are to be plotted.</p>
</td></tr>
<tr><td><code id="traceplot2_+3A_bty">bty</code>, <code id="traceplot2_+3A_main">main</code>, <code id="traceplot2_+3A_xlab">xlab</code>, <code id="traceplot2_+3A_...">...</code></td>
<td>
<p>further arguments passed to the
<code><a href="graphics.html#topic+plot.default">plot.default</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>

<hr>
<h2 id='vecr2matr'>
Transform single component indeces to double component indeces
</h2><span id='topic+vecr2matr'></span>

<h3>Description</h3>

<p>Components of a bivariate G-spline can be indexed in several
ways. Suppose that the knots in the first dimension are
<code class="reqn">\mu_{1,-K_1},\dots,\mu_{1,K_1}</code>
and the knots in the second dimension
<code class="reqn">\mu_{2,-K_2},\dots,\mu_{2,K_2}.</code>
I.e. we have <code class="reqn">2K_1+1</code> knots in the first dimension and
<code class="reqn">2K_2+1</code> knots in the second dimension. Each G-spline
component can have a double index <code class="reqn">(k_1,k_2)</code>
assigned which means that it corresponds to the knot
<code class="reqn">(\mu_{1,k_1},\mu_{2,k_2})</code>
or alternatively the same G-spline component can have a~single index
</p>
<p style="text-align: center;"><code class="reqn">r=(k_2 + K_2)\times(2K_1+1) + k_1 + K_1 + 1</code>
</p>

<p>assigned where <code class="reqn">r</code> takes values from
<code class="reqn">1,\dots,K_1\times K_2</code>. Single indexing is used
for example by files <code>r.sim</code> and <code>r_2.sim</code> generated by
functions <code><a href="#topic+bayesHistogram">bayesHistogram</a></code>, <code><a href="#topic+bayesBisurvreg">bayesBisurvreg</a></code>,
<code><a href="#topic+bayessurvreg2">bayessurvreg2</a></code> to save some space.
</p>
<p>This function serves to translate single indeces to double indeces
using the relationship
</p>
<p style="text-align: center;"><code class="reqn">k_1 = (r - 1) \mbox{ mod } (2K_1+1) - K_1</code>
</p>

<p style="text-align: center;"><code class="reqn">k_2 = (r - 1) \mbox{ div } (2K_1+1) - K_2</code>
</p>

<p>The function can be used also in one dimensional case when a~simple
relationship holds
</p>
<p style="text-align: center;"><code class="reqn">r = k + K + 1</code>
</p>
  
<p style="text-align: center;"><code class="reqn">k = r - 1 - K</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>vecr2matr(vec.r, KK)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vecr2matr_+3A_vec.r">vec.r</code></td>
<td>
<p>a~vector of single indeces</p>
</td></tr>
<tr><td><code id="vecr2matr_+3A_kk">KK</code></td>
<td>
<p>a~vector with numbers of knots on each side of the central
knot for each dimension of the G-spline. The length of <code>KK</code>
determines dimension of the G-spline</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In bivariate case: a~matrix with two columns and as many rows as the
length of <code>vec.r</code>.
</p>
<p>In univariate case: a~vector with as ,amy components as the length of <code>vec.r</code>.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Bivariate G-spline
### with 31 knots in each dimension
KK &lt;- c(15, 15)

### First observation in component (-15, -15),
### second observation in component (15, 15),
### third observation in component (0, 0)
vec.r &lt;- c(1, 961, 481)
vecr2matr(vec.r, KK)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
