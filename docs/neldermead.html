<!DOCTYPE html><html><head><title>Help for package neldermead</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {neldermead}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#neldermead-package'>
<p>R port of the Scilab neldermead module</p></a></li>
<li><a href='#costf.transposex'>
<p>Cost Function Call</p></a></li>
<li><a href='#fmin.gridsearch'>
<p>Grid evaluation of an unconstrained cost function</p></a></li>
<li><a href='#fminbnd'>
<p>Computation of the constrained minimimum of given function with the</p>
Nelder-Mead algorithm.</a></li>
<li><a href='#fminbnd.function'>
<p>fminbnd Cost Function Call</p></a></li>
<li><a href='#fminbnd.outputfun'>
<p>fminbnd Output Function Call</p></a></li>
<li><a href='#fminsearch'>
<p>Computation of the unconstrained minimum of given function with the</p>
Nelder-Mead algorithm.</a></li>
<li><a href='#fminsearch.function'>
<p>fminsearch Cost Function Call</p></a></li>
<li><a href='#fminsearch.outputfun'>
<p>fminsearch Output Function Call</p></a></li>
<li><a href='#neldermead'>
<p>S3 neldermead object</p></a></li>
<li><a href='#neldermead.algo'>
<p>Nelder-Mead Algorithm</p></a></li>
<li><a href='#neldermead.destroy'>
<p>Erase a neldermead object.</p></a></li>
<li><a href='#neldermead.function'>
<p>Call Cost Function.</p></a></li>
<li><a href='#neldermead.get'>
<p>Get the value for the given element</p></a></li>
<li><a href='#neldermead.restart'>
<p>Restart neldermead search.</p></a></li>
<li><a href='#neldermead.search'>
<p>Starts the optimization</p></a></li>
<li><a href='#neldermead.set'>
<p>Neldermead Object Configuration</p></a></li>
<li><a href='#optimget'>
<p>Queries an optimization option list</p></a></li>
<li><a href='#optimset'>
<p>Configures and returns an optimization data structure.</p></a></li>
<li><a href='#optimset.method'>
<p>Default set of optimization options</p></a></li>
<li><a href='#Secondary search functions'>
<p>Secondary functions for neldermead.search</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>R Port of the 'Scilab' Neldermead Module</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-12</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-01-30</td>
</tr>
<tr>
<td>Depends:</td>
<td>optimbase (&ge; 1.0-9), optimsimplex (&ge; 1.0-7), methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.28),rmarkdown (&ge; 2.2)</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides several direct search optimization algorithms based on the
  simplex method. The provided algorithms are direct search algorithms, i.e.
  algorithms which do not use the derivative of the cost function. They are
  based on the update of a simplex. The following algorithms are available: the
  fixed shape simplex method of Spendley, Hext and Himsworth (unconstrained
  optimization with a fixed shape simplex, 1962) &lt;<a href="https://doi.org/10.1080%2F00401706.1962.10490033">doi:10.1080/00401706.1962.10490033</a>&gt;, 
  the variable shape simplex method of Nelder and Mead (unconstrained optimization
  with a variable shape simplex made, 1965) &lt;<a href="https://doi.org/10.1093%2Fcomjnl%2F7.4.308">doi:10.1093/comjnl/7.4.308</a>&gt;, and 
  Box's complex method (constrained optimization with a variable shape simplex,
  1965) &lt;<a href="https://doi.org/10.1093%2Fcomjnl%2F8.1.42">doi:10.1093/comjnl/8.1.42</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.cecill.info/licences/Licence_CeCILL_V2-en.txt">CeCILL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-31 01:54:03 UTC; sebastien</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastien Bihorel [aut, cre],
  Michael Baudin [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastien Bihorel &lt;sb.pmlab@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-01 08:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='neldermead-package'>
R port of the Scilab neldermead module
</h2><span id='topic+neldermead-package'></span>

<h3>Description</h3>

<p>The goal of this package is to provide a Nelder-Mead direct search
optimization method. That Nelder-Mead algorithm may be used in the following
optimization context: </p>

<ul>
<li><p> there is no need to provide the derivatives of the objective
function,
</p>
</li>
<li><p> the number of parameters is small (up to 10-20),
</p>
</li>
<li><p> there are bounds and/or non linear constraints.
</p>
</li></ul>

<p><strong>Design</strong>
</p>
<p>This package provides the following components:</p>

<ul>
<li> <p><span class="pkg">neldermead</span> provides various Nelder-Mead variants and manages for
Nelder-Mead specific settings, such as the method to compute the initial
simplex, the specific termination criteria,
</p>
</li>
<li> <p><code>fminsearch</code> provides a simplified Nelder-Mead algorithm.
Specific termination criteria, initial simplex and auxiliary settings are 
automatically configured.
</p>
</li>
<li> <p><code>fminbnd</code> provides a simplified Box algorithm, ie the equivalent
of <code>fminsearch</code> for unconstrained search.
</p>
</li>
<li> <p><code>optimset</code>, <code>optimget</code> provide commands to emulate their
Scilab counterparts.
</p>
</li>
<li> <p><code>optimplotfunccount</code>, <code>optimplotx</code> and <code>optimplotfval</code>
provide plotting features for the fminsearch function (Not implemented
yet).
</p>
</li>
<li> <p><code>nmplot</code> provides a high-level component which provides directly
output pictures for Nelder-Mead algorithm. (Not implemented yet).
</p>
</li></ul>

<p>The current component is based on the following packages </p>

<ul>
<li> <p><span class="pkg">optimbase</span>: provides an abstract class for a general optimization
component, including the number of variables, the minimum and maximum
bounds, the number of non linear inequality constraints, the loggin
system, various termination criteria, the cost function, etc...
</p>
</li>
<li> <p><span class="pkg">optimsimplex</span>: provides a class to manage a simplex made of an
arbitrary number of vertices, including the computation of a simplex by
various methods (axes, regular, Pfeffer's, randomized bounds), the
computation of the size by various methods (diameter, sigma+, sigma-,
etc...),
</p>
</li></ul>

<p><strong>Features</strong>
</p>
<p>The following is a list of features the Nelder-Mead prototype algorithm
currently provides:</p>

<ul>
<li><p> Provides 3 algorithms, including </p>

<ul>
<li><p> the fixed shape algorithm of Spendley et al.,
</p>
</li>
<li><p> the variable shape algorithm of Nelder and Mead,
</p>
</li>
<li><p> Box's 'complex' algorithm managing bounds and nonlinear inequality
constraints based on arbitrary number of vertices in the simplex.
</p>
</li></ul>

</li>
<li><p> Manage various simplex initializations: </p>

<ul>
<li><p> initial simplex given by user,
</p>
</li>
<li><p> initial simplex computed with a length and along the coordinate
axes,
</p>
</li>
<li><p> initial regular simplex computed with formula of Spendley et al.,
</p>
</li>
<li><p> initial simplex computed by a small perturbation around the initial
guess point.
</p>
</li></ul>

</li>
<li><p> Manage cost function: </p>

<ul>
<li><p> optional additional argument,
</p>
</li>
<li><p> direct communication of the task to perform: cost function or
inequality constraints.
</p>
</li></ul>

</li>
<li><p> Manage various termination criteria, including maximum number of
iterations, tolerance on function value (relative or absolute):</p>

<ul>
<li><p> tolerance on x (relative or absolute),
</p>
</li>
<li><p> tolerance on standard deviation of function value (original
termination criteria in Box 1965),
</p>
</li>
<li><p> maximum number of evaluations of cost function,
</p>
</li>
<li><p> absolute or relative simplex size.
</p>
</li></ul>

</li>
<li><p> Manage the history of the convergence, including: </p>

<ul>
<li><p> history of function values,
</p>
</li>
<li><p> history of optimum point,
</p>
</li>
<li><p> history of simplices,
</p>
</li>
<li><p> history of termination criteria.
</p>
</li></ul>

</li>
<li><p> Provide a plot command which allows to graphically see the history
of the simplices toward the optimum (Not yet implemented).
</p>
</li>
<li><p> Provide query features for the status of the optimization process:
number of iterations, number of function evaluations, status of execution,
function value at initial point, function value at optimal point, etc...
</p>
</li>
<li><p> Kelley restart based on simplex gradient.
</p>
</li>
<li><p> O'Neill restart based on factorial search around optimum.
</p>
</li></ul>



<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
  Package: </td><td style="text-align: left;"> neldermead</td>
</tr>
<tr>
 <td style="text-align: left;">
  Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
  Version: </td><td style="text-align: left;"> 1.0-12</td>
</tr>
<tr>
 <td style="text-align: left;">
  Date: </td><td style="text-align: left;"> 2022-01-30</td>
</tr>
<tr>
 <td style="text-align: left;">
  License: </td><td style="text-align: left;"> CeCILL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
  LazyLoad: </td><td style="text-align: left;"> yes
  </td>
</tr>

</table>

<p>See <code>vignette('neldermead',package='neldermead')</code> for more information.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab neldermead module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>References</h3>

<p>'Sequential Application of Simplex Designs in Optimisation and Evolutionary
Operation', Spendley, W. and Hext, G. R. and Himsworth, F. R., American
Statistical Association and American Society for Quality, 1962
</p>
<p>'A Simplex Method for Function Minimization', Nelder, J. A. and Mead, R., The
Computer Journal, 1965
</p>
<p>'A New Method of Constrained Optimization and a Comparison With Other Methods',
M. J. Box, The Computer Journal 1965 8(1):42-52, 1965 by British Computer
Society
</p>
<p>'Discussion and correspondence: modification of the complex method of
constrained optimization', J. A. Guin, The Computer Journal, 1968
</p>
<p>'Detection and Remediation of Stagnation in the Nelder&ndash;Mead Algorithm Using a
Sufficient Decrease Condition', Kelley C. T., SIAM J. on Optimization, 1999
</p>
<p>'Iterative Methods for Optimization', C. T. Kelley, SIAM Frontiers in Applied
Mathematics, 1999
</p>
<p>'Algorithm AS47 - Function minimization using a simplex procedure', O'Neill, R.,
Applied Statistics, 1971
</p>


<h3>See Also</h3>

<p><code><a href="optimbase.html#topic+optimbase">optimbase</a></code>
<code><a href="optimsimplex.html#topic+optimsimplex">optimsimplex</a></code>
</p>

<hr>
<h2 id='costf.transposex'>
Cost Function Call
</h2><span id='topic+costf.transposex'></span>

<h3>Description</h3>

<p>Call the cost function after transposition of the value of the point
estimate x, so that the input row vector, given by optimsimplex, is
transposed into a  column vector as required by the cost function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  costf.transposex(x = NULL, this = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="costf.transposex_+3A_x">x</code></td>
<td>
<p>The point estimate provide as a row matrix.</p>
</td></tr>
<tr><td><code id="costf.transposex_+3A_this">this</code></td>
<td>
<p>A neldermead object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the value of the cost function (called by <code>neldermead.costf</code>.)
</p>


<h3>Author(s)</h3>

<p>Author of Scilab neldermead module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+neldermead.costf">neldermead.costf</a></code>
</p>

<hr>
<h2 id='fmin.gridsearch'>
Grid evaluation of an unconstrained cost function
</h2><span id='topic+fmin.gridsearch'></span>

<h3>Description</h3>

<p>Evaluate an unconstrained cost function on a grid of points around a given 
initial point estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fmin.gridsearch(fun = NULL, x0 = NULL, xmin = NULL, 
                  xmax = NULL, npts = 3, alpha = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmin.gridsearch_+3A_fun">fun</code></td>
<td>
<p>An unconstrained cost function returning a numeric scalar, similar 
to those used in the <code>fminsearch</code> function.</p>
</td></tr>
<tr><td><code id="fmin.gridsearch_+3A_x0">x0</code></td>
<td>
<p>The initial point estimate, provided as a numeric vector.</p>
</td></tr>
<tr><td><code id="fmin.gridsearch_+3A_xmin">xmin</code></td>
<td>
<p>Optional: a vector of lower bounds.</p>
</td></tr>
<tr><td><code id="fmin.gridsearch_+3A_xmax">xmax</code></td>
<td>
<p>Optional: a vector of upper bounds.</p>
</td></tr>
<tr><td><code id="fmin.gridsearch_+3A_npts">npts</code></td>
<td>
<p>An integer scalar greater than 2, indicating the number of 
evaluation points will be used on each dimension to build the search grid.</p>
</td></tr>
<tr><td><code id="fmin.gridsearch_+3A_alpha">alpha</code></td>
<td>
<p>A vector of numbers greater than 1, which give the factor(s) used
to calculate the evaluation range of each dimension of the search grid (see 
Details). If <code>alpha</code> length is lower than that of <code>x0</code>, elements 
of <code>alpha</code> are recycled. If its length is higher than that of 
<code>x0</code>, <code>alpha</code> is truncated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fmin.gridsearch</code> evaluates the cost function at each point 
of a grid of <code>npts^length(x0)</code> points. If lower (<code>xmin</code>) and upper 
(<code>xmax</code>) bounds are provided, the range of evaluation points is limited 
by those bounds and <code>alpha</code> is not used. Otherwise, the range of 
evaluation points is defined as <code>[x0/alpha,x0*alpha]</code>.
</p>
<p>The actual evaluation of the cost function is delegated to 
<code>optimbase.gridsearch</code>.
</p>


<h3>Value</h3>

<p>Return a data.frame with the coordinates of the evaluation point, the value of
the cost function and its feasibility. Because the cost function is 
unconstrained, it is always feasible. The data.frame is ordered by feasibility
and increasing value of the cost function.
</p>


<h3>Author(s)</h3>

<p>Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fminsearch">fminsearch</a></code>, 
<code><a href="optimbase.html#topic+optimbase.gridsearch">optimbase.gridsearch</a></code>
</p>

<hr>
<h2 id='fminbnd'>
Computation of the constrained minimimum of given function with the
Nelder-Mead algorithm.
</h2><span id='topic+fminbnd'></span>

<h3>Description</h3>

<p>EXPERIMENTAL.
</p>
<p>This function searches for the constrained minimum of a given cost function.
The provided algorithm is a direct search algorithm, i.e. an algorithm which
does not use the derivative of the cost function. It is based on the update of
a simplex, which is a set of k&gt;=n+1 vertices, where each vertex is associated
with one point, which coordinates are constrained within user-defined 
boundaries, and with one function value. This algorithm corresponds to a 
version of the Box algorithm, based on bounds and no non-linear constraints. 
This function is based on a specialized use of the more general
<code>neldermead</code> function bundle. Users who want to have a more flexible
solution based on direct search algorithms should consider using the
<code>neldermead</code> functions instead of the <code>fminbnd</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fminbnd(fun=NULL, x0=NULL, xmin=NULL, xmax=NULL, options=NULL, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fminbnd_+3A_fun">fun</code></td>
<td>
<p>A cost function return a numeric scalar.</p>
</td></tr>
<tr><td><code id="fminbnd_+3A_x0">x0</code></td>
<td>
<p>A numerical vector of initial guesses (length n).</p>
</td></tr>
<tr><td><code id="fminbnd_+3A_xmin">xmin</code></td>
<td>
<p>A numerical vector of lower bounds for <code>x0</code> (length n).</p>
</td></tr>
<tr><td><code id="fminbnd_+3A_xmax">xmax</code></td>
<td>
<p>A numerical vector of upper bounds for <code>x0</code> (length n).</p>
</td></tr>
<tr><td><code id="fminbnd_+3A_options">options</code></td>
<td>
<p>A list of optimization options, which drives the behaviour of
<code>fminbnd</code>. These options must be set with the <code>optimset</code>
function (see <code>?optimset</code>) which returns a list with the following
elements: </p>

<dl>
<dt>MaxIter</dt><dd><p>The maximum number of iterations. The default is 200 * n.</p>
</dd>
<dt>MaxFunEvals</dt><dd><p>The maximum number of evaluations of the cost function.
The default is 200 * n.</p>
</dd>
<dt>BoxTolFun</dt><dd><p>The absolute tolerance on function value. The default value
is 1.e-4.</p>
</dd>
<dt>TolFun</dt><dd><p>The absolute tolerance on function value. The default value
is 1.e-4.</p>
</dd>
<dt>TolX</dt><dd><p>The absolute tolerance on simplex size. The default value is
1.e-4.</p>
</dd>
<dt>Display</dt><dd><p>The verbose level.</p>
</dd>
<dt>OutputFcn</dt><dd><p>The output function, or a list of output functions
called at the end of each iteration. The default value is NULL.</p>
</dd>
<dt>PlotFcns</dt><dd><p>The plot function, or a list of plotput functions called
at the end of each iteration. The default value is empty.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="fminbnd_+3A_verbose">verbose</code></td>
<td>
<p>The verbose option, controlling the amount of messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Termination criteria</strong>
</p>
<p>In this section, we describe the termination criteria used by <code>fminbnd</code>.
The criteria is based on the following variables: </p>

<dl>
<dt>boxkount</dt><dd><p>the current number of time the tolerance on the cost 
function was met, and</p>
</dd>
<dt>shiftfv</dt><dd><p>the absolute value of the difference of function value
between the highest and lowest vertices.</p>
</dd>
</dl>

<p>If both <code>shiftfv &lt; options$TolFun</code> and <code>boxkount &lt; options$nbMatch</code> 
conditions are true, then the iterations stop.
</p>
<p><strong>The initial simplex</strong>
</p>
<p>The <code>fminbnd</code> algorithm uses a special initial simplex, which is an
heuristic depending on the initial guess. The strategy chosen by
<code>fminbnd</code> corresponds to the content of <code>simplex0method</code>
element of the neldermead object (set to 'randbounds'). It is applied using 
the content of the <code>boundsmin</code> and <code>boundsmin</code> elements to generate
a simplex with random vertices within the boundaries defined by the user (ie,
<code>xmin</code>, and <code>xmax</code>). This method is an heuristic which is presented 
in 'A New Method of Constrained Optimization and a Comparison With Other 
Methods' by M.J. Box. See in the help of <code>optimsimplex</code> for more details.
</p>
<p><strong>The number of iterations</strong>
</p>
<p>In this section, we present the default values for the number of iterations in
<code>fminbnd</code>.
</p>
<p>The <code>options</code> input argument is an optional list which can
contain the <code>MaxIter</code> field, which stores the maximum number of
iterations. The default value is 200n, where n is the number of variables.
The factor 200 has not been chosen by chance, but is the result of experiments
performed against quadratic functions with increasing space dimension.
This result is presented in 'Effect of dimensionality on the Nelder-Mead
simplex method' by Lixing Han and Michael Neumann. This paper is based on
Lixing Han's  PhD, 'Algorithms in Unconstrained Optimization'. The study is
based on numerical experiments with a quadratic function where the number of
terms depends on the dimension of the space (i.e. the number of variables).
Their study showed that the number of iterations required to reach the
tolerance criteria is roughly 100n. Most iterations are based on inside
contractions. Since each step of the Nelder-Mead algorithm only require one
or two function evaluations, the number of required function evaluations in
this experiment is also roughly 100n.
</p>
<p><strong>Output and plot functions</strong>
</p>
<p>The <code>optimset</code> function can be used to configure one or more output and
plot functions.
The output or plot function is expected to have the following definition:
</p>
<p><code>myfun &lt;- function(x , optimValues , state)</code>
</p>
<p>The input arguments <code>x</code>, <code>optimValues</code> and <code>state</code> are
described in detail in the <code>optimset</code> help page. The
<code>optimValues$procedure</code> field represents the type of step performed at
the current iteration and can be equal to one of the following strings:
</p>

<ul>
<li><p> &rdquo; (the empty string),
</p>
</li>
<li><p> 'initial simplex',
</p>
</li>
<li><p> 'reflect (Box)'.
</p>
</li></ul>



<h3>Value</h3>

<p>Return a object of class neldermead. Use the <code>neldermead.get</code> to extract
the following element from the returned object:</p>

<dl>
<dt>xopt</dt><dd><p>The vector of n numeric values, minimizing the cost function.</p>
</dd>
<dt>fopt</dt><dd><p>The minimum value of the cost function.</p>
</dd>
<dt>exitflag</dt><dd><p>The flag associated with exist status of the algorithm.
The following values are available:</p>

<dl>
<dt>-1</dt><dd><p>The maximum number of iterations has been reached.</p>
</dd>
<dt>0</dt><dd><p>The maximum number of function evaluations has been reached.</p>
</dd>
<dt>1</dt><dd><p>The tolerance on the simplex size and function value delta has
been reached. This signifies that the algorithm has converged,
probably to a solution of the problem.</p>
</dd>
</dl>

</dd>
<dt>output</dt><dd><p>A list which stores detailed information about the exit of the
algorithm. This list contains the following fields:</p>

<dl>
<dt>algorithm</dt><dd><p>A string containing the definition of the algorithm
used, i.e. 'Nelder-Mead simplex direct search'.</p>
</dd>
<dt>funcCount</dt><dd><p>The number of function evaluations.</p>
</dd>
<dt>iterations</dt><dd><p>The number of iterations.</p>
</dd>
<dt>message</dt><dd><p>A string containing a termination message.</p>
</dd>
</dl>

</dd>
</dl>



<h3>Author(s)</h3>

<p>Author: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimset">optimset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#In the following example, we use the fminbnd function to compute the minimum
#of a quadratic function. We first define the function 'quad', and then use
#the fminbnd function to search the minimum, starting with the initial guess
#(1.2, 1.9) and bounds of (1, 1) and (2, 2). In this particular case, 11 
#iterations are performed with 20 function evaluations
  quad &lt;- function(x){
    y &lt;- x[1]^2 + x[2]^2
  }
  sol &lt;- fminbnd(quad,c(1.2,1.9),c(1,1),c(2,2))
  summary(sol)
</code></pre>

<hr>
<h2 id='fminbnd.function'>
fminbnd Cost Function Call
</h2><span id='topic+fminbnd.function'></span>

<h3>Description</h3>

<p>This function calls the cost function and makes it match neldermead
requirements. It is used in the <code>fminbnd</code> function as the
<code>function</code> element of the neldermead object (see <code>?neldermead</code>
and <code>?neldermead.set</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fminbnd.function(x = NULL, index = NULL, fmsfundata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fminbnd.function_+3A_x">x</code></td>
<td>
<p>A single column vector of parameter estimates.</p>
</td></tr>
<tr><td><code id="fminbnd.function_+3A_index">index</code></td>
<td>
<p>An integer variable set to 2, indicating that only the cost
function is to be computed by the algorithm.</p>
</td></tr>
<tr><td><code id="fminbnd.function_+3A_fmsfundata">fmsfundata</code></td>
<td>
<p>An object of class 'optimbase.functionargs' and with 
(at least) a <code>fun</code> element, which contains the user-defined cost 
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following elements: </p>

<dl>
<dt>f</dt><dd><p>The value of the cost function at the current point estimate.</p>
</dd>
<dt>index</dt><dd><p>The same <code>index</code> variable.</p>
</dd>
<dt>this</dt><dd><p>A list with a single element <code>costargument</code> which
contains <code>fmsfundata</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Author of Scilab neldermead module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fminbnd">fminbnd</a></code>,
<code><a href="#topic+neldermead">neldermead</a></code>,
<code><a href="#topic+neldermead.set">neldermead.set</a></code>,
</p>

<hr>
<h2 id='fminbnd.outputfun'>
fminbnd Output Function Call
</h2><span id='topic+fminbnd.outputfun'></span>

<h3>Description</h3>

<p>This function calls the output function and make it match neldermead
requirements. It is used in the <code>fminbnd</code> function as the
<code>outputcommand</code> element of the neldermead object (see
<code>?neldermead</code> and <code>?neldermead.set</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fminbnd.outputfun(state = NULL, data = NULL, fmsdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fminbnd.outputfun_+3A_state">state</code></td>
<td>
<p>The current state of the algorithm either 'init', 'iter' or
'done'.</p>
</td></tr>
<tr><td><code id="fminbnd.outputfun_+3A_data">data</code></td>
<td>
<p>The data at the current state. This is an object of class 
'neldermead.data', i.e. a list with the following elements: </p>

<dl>
<dt>x</dt><dd><p>The current parameter estimates.</p>
</dd>
<dt>fval</dt><dd><p>The current value of the cost function.</p>
</dd>
<dt>simplex</dt><dd><p>The current simplex object.</p>
</dd>
<dt>iteration</dt><dd><p>The number of iterations performed.</p>
</dd>
<dt>funccount</dt><dd><p>The number of function evaluations.</p>
</dd>
<dt>step</dt><dd><p>The type of step in the previous iteration.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="fminbnd.outputfun_+3A_fmsdata">fmsdata</code></td>
<td>
<p>This is an object of class 'optimbase.functionargs' which 
contains specific data of the <code>fminbnd</code> algorithm: </p>

<dl>
<dt>Display</dt><dd><p>what to display</p>
</dd>
<dt>OutputFcn</dt><dd><p>the array of output functions</p>
</dd>
<dt>PlotFcns</dt><dd><p>the array of plot functions</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return any data, but execute the output function(s).
</p>


<h3>Author(s)</h3>

<p>Author of Scilab neldermead module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fminbnd">fminbnd</a></code>,
<code><a href="#topic+neldermead">neldermead</a></code>,
<code><a href="#topic+neldermead.set">neldermead.set</a></code>,
</p>

<hr>
<h2 id='fminsearch'>
Computation of the unconstrained minimum of given function with the
Nelder-Mead algorithm.
</h2><span id='topic+fminsearch'></span>

<h3>Description</h3>

<p>This function searches for the unconstrained minimum of a given cost function.
The provided algorithm is a direct search algorithm, i.e. an algorithm which
does not use the derivative of the cost function. It is based on the update of
a simplex, which is a set of k&gt;=n+1 vertices, where each vertex is associated
with one point and one function value. This algorithm is the Nelder-Mead
algorithm. This function is based on a specialized use of the more general
<code>neldermead</code> function bundle. Users who want to have a more flexible
solution based on direct search algorithms should consider using the
<code>neldermead</code> functions instead of the <code>fminsearch</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fminsearch(fun = NULL, x0 = NULL, options = NULL, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fminsearch_+3A_fun">fun</code></td>
<td>
<p>A cost function return a numeric scalar.</p>
</td></tr>
<tr><td><code id="fminsearch_+3A_x0">x0</code></td>
<td>
<p>A numerical vector of initial guesses (length n).</p>
</td></tr>
<tr><td><code id="fminsearch_+3A_options">options</code></td>
<td>
<p>A list of optimization options, which drives the behaviour of
<code>fminsearch</code>. These options must be set with the <code>optimset</code>
function (see <code>?optimset</code>) which returns a list with the following
elements: </p>

<dl>
<dt>MaxIter</dt><dd><p>The maximum number of iterations. The default is 200 * n.</p>
</dd>
<dt>MaxFunEvals</dt><dd><p>The maximum number of evaluations of the cost function.
The default is 200 * n.</p>
</dd>
<dt>TolFun</dt><dd><p>The absolute tolerance on function value. The default value
is 1.e-4.</p>
</dd>
<dt>TolX</dt><dd><p>The absolute tolerance on simplex size. The default value is
1.e-4.</p>
</dd>
<dt>Display</dt><dd><p>The verbose level.</p>
</dd>
<dt>OutputFcn</dt><dd><p>The output function, or a list of output functions
called at the end of each iteration. The default value is NULL.</p>
</dd>
<dt>PlotFcns</dt><dd><p>The plot function, or a list of plotput functions called
at the end of each iteration. The default value is empty.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="fminsearch_+3A_verbose">verbose</code></td>
<td>
<p>The verbose option, controlling the amount of messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Termination criteria</strong>
</p>
<p>In this section, we describe the termination criteria used by fminsearch.
The criteria is based on the following variables: </p>

<dl>
<dt>ssize</dt><dd><p>the current simplex size,</p>
</dd>
<dt>shiftfv</dt><dd><p>the absolute value of the difference of function value
between the highest and lowest vertices.</p>
</dd>
</dl>

<p>If both <code>ssize &lt; options$TolX</code> and <code>shiftfv &lt; options$TolFun</code>
conditions are true, then the iterations stop. The size of the simplex is
computed using the 'sigmaplus' method of the <span class="pkg">optimsimplex</span> package. The
'sigmamplus' size is the maximum length of the vector from each vertex to the
first vertex. It requires one loop over the vertices of the simplex.
</p>
<p><strong>The initial simplex</strong>
</p>
<p>The <code>fminsearch</code> algorithm uses a special initial simplex, which is an
heuristic depending on the initial guess. The strategy chosen by
<code>fminsearch</code> corresponds to the content of <code>simplex0method</code>
element of the neldermead object (set to 'pfeffer').  It is applied using 
the content of the <code>simplex0deltausual</code> (0.05) and
<code>simplex0deltazero</code> (0.0075) elements. Pfeffer's method is an heuristic
which is presented in 'Global Optimization Of Lennard-Jones Atomic Clusters'
by Ellen Fan. It is due to L. Pfeffer at Stanford. See in the help of
optimsimplex for more details.
</p>
<p><strong>The number of iterations</strong>
</p>
<p>In this section, we present the default values for the number of iterations in
<code>fminsearch</code>.
</p>
<p>The <code>options</code> input argument is an optional list which can
contain the <code>MaxIter</code> field, which stores the maximum number of
iterations. The default value is 200n, where n is the number of variables.
The factor 200 has not been chosen by chance, but is the result of experiments
performed against quadratic functions with increasing space dimension.
This result is presented in 'Effect of dimensionality on the Nelder-mead
simplex method' by Lixing Han and Michael Neumann. This paper is based on
Lixing Han's  PhD, 'Algorithms in Unconstrained Optimization'. The study is
based on numerical experiments with a quadratic function where the number of
terms depends on the dimension of the space (i.e. the number of variables).
Their study showed that the number of iterations required to reach the
tolerance criteria is roughly 100n. Most iterations are based on inside
contractions. Since each step of the Nelder-Mead algorithm only require one
or two function evaluations, the number of required function evaluations in
this experiment is also roughly 100n.
</p>
<p><strong>Output and plot functions</strong>
</p>
<p>The <code>optimset</code> function can be used to configure one or more output and
plot functions.
The output or plot function is expected to have the following definition:
</p>
<p><code>myfun &lt;- function(x , optimValues , state)</code>
</p>
<p>The input arguments <code>x</code>, <code>optimValues</code> and <code>state</code> are
described in detail in the <code>optimset</code> help page. The
<code>optimValues$procedure</code> field represents the type of step performed at
the current iteration and can be equal to one of the following strings:
</p>

<ul>
<li><p> &rdquo; (the empty string),
</p>
</li>
<li><p> 'initial simplex',
</p>
</li>
<li><p> 'expand',
</p>
</li>
<li><p> 'reflect',
</p>
</li>
<li><p> 'contract inside',
</p>
</li>
<li><p> 'contract outside'.
</p>
</li></ul>



<h3>Value</h3>

<p>Return a object of class neldermead. Use the <code>neldermead.get</code> to extract
the following element from the returned object:</p>

<dl>
<dt>xopt</dt><dd><p>The vector of n numeric values, minimizing the cost function.</p>
</dd>
<dt>fopt</dt><dd><p>The minimum value of the cost function.</p>
</dd>
<dt>exitflag</dt><dd><p>The flag associated with exist status of the algorithm.
The following values are available:</p>

<dl>
<dt>-1</dt><dd><p>The maximum number of iterations has been reached.</p>
</dd>
<dt>0</dt><dd><p>The maximum number of function evaluations has been reached.</p>
</dd>
<dt>1</dt><dd><p>The tolerance on the simplex size and function value delta has
been reached. This signifies that the algorithm has converged,
probably to a solution of the problem.</p>
</dd>
</dl>

</dd>
<dt>output</dt><dd><p>A list which stores detailed information about the exit of the
algorithm. This list contains the following fields:</p>

<dl>
<dt>algorithm</dt><dd><p>A string containing the definition of the algorithm
used, i.e. 'Nelder-Mead simplex direct search'.</p>
</dd>
<dt>funcCount</dt><dd><p>The number of function evaluations.</p>
</dd>
<dt>iterations</dt><dd><p>The number of iterations.</p>
</dd>
<dt>message</dt><dd><p>A string containing a termination message.</p>
</dd>
</dl>

</dd>
</dl>



<h3>Author(s)</h3>

<p>Author of Scilab neldermead module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>References</h3>

<p>'Sequential Application of Simplex Designs in Optimisation and Evolutionary
Operation', Spendley, W. and Hext, G. R. and Himsworth, F. R., American
Statistical Association and American Society for Quality, 1962
</p>
<p>'A Simplex Method for Function Minimization', Nelder, J. A. and Mead, R., The
Computer Journal, 1965
</p>
<p>'Iterative Methods for Optimization', C. T. Kelley, SIAM Frontiers in Applied
Mathematics, 1999
</p>
<p>'Algorithm AS47 - Function minimization using a simplex procedure', O'Neill, R.,
Applied Statistics, 1971
</p>
<p>'Effect of dimensionality on the nelder-mead simplex method', Lixing Han and
Michael Neumann, Optimization Methods and Software, 21, 1, 1&ndash;16, 2006.
</p>
<p>'Algorithms in Unconstrained Optimization', Lixing Han, Ph.D., The University of
Connecticut, 2000.
</p>
<p>'Global Optimization Of Lennard-Jones Atomic Clusters' Ellen Fan, Thesis,
February 26, 2002, McMaster University
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimset">optimset</a></code>
<code><a href="#topic+neldermead">neldermead</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#In the following example, we use the fminsearch function to compute the minimum
#of the Rosenbrock function. We first define the function 'banana', and then use
#the fminsearch function to search the minimum, starting with the initial guess
#(-1.2, 1.0). In this particular case, 85 iterations are performed with 159
#function evaluations
  banana &lt;- function(x){
    y &lt;- 100*(x[2]-x[1]^2)^2 + (1-x[1])^2
  }
  sol &lt;- fminsearch(banana, c(-1.2,1))
  sol

#In the following example, we configure the absolute tolerance on the size of
#the simplex to a larger value, so that the algorithm performs less iterations.
#Since the default value of 'TolX' for the fminsearch function is 1.e-4, we
#decide to use 1.e-2. The optimset function is used to create an optimization
#option list and the field 'TolX' is set to 1.e-2. The options list is then
#passed to the fminsearch function as the third input argument. In this
#particular case, the number of iterations is 70 with 130 function evaluations.

  opt &lt;- optimset(TolX=1.e-2)
  sol &lt;- fminsearch(banana, c(-1.2,1), opt)
  sol
  
#In the following example, we want to produce intermediate outputs of the
#algorithm. We define the outfun function, which takes the current point x as
#input argument. The function plots the current point into the current graphic
#window with the plot function. We use the 'OutputFcn' feature of the optimset
#function and set it to the output function. Then the option list is passed 
#to the fminsearch function. At each iteration, the output function is called 
#back, which creates and update a plot. While this example creates a 2D plot,
#the user may customized the output function so that it writes a message in 
#the console, write some data into a data file, etc... The user can distinguish 
#between the output function (associated with the 'OutputFcn' option) and the
#plot function (associated with the 'PlotFcns' option). See the optimset for
#more details on this feature.

  outfun &lt;- function(x, optimValues, state){
    plot(x[1],x[2],xlim=c(-1.5,1.5),ylim=c(-1.5,1.5))
    par(new=TRUE)
  }
  opt &lt;- optimset(OutputFcn=outfun)
  sol &lt;- fminsearch(banana, c(-1.2,1), opt)
  sol

#The 'Display' option allows to get some input about the intermediate steps of
#the algorithm as well as to be warned in case of a convergence problem.
#In the following example, we present what happens in case of a convergence
#problem. We set the number of iterations to 10, instead of the default 400
#iterations. We know that 85 iterations are required to reach the convergence
#criteria. Therefore, the convergence criteria is not met and the maximum number
#of iterations is reached.

  opt &lt;- optimset(MaxIter=10)
  sol &lt;- fminsearch(banana, c(-1.2,1), opt)

#Since the default value of the 'Display' option is 'notify', a message is
#generated, which warns the user about a possible convergence problem. The
#previous script produces the following output.
# Exiting: Maximum number of iterations has been exceeded
#          - increase MaxIter option.
#          Current function value: 4.1355598

#In the following example, we present how to display intermediate steps used by
#the algorithm. We simply set the 'Display' option to the 'iter' value. This 
#option allows to see the number of function evaluations, the minimum function
#value and which type of simplex step is used for the iteration.
  opt &lt;- optimset(Display='iter')
  sol &lt;- fminsearch(banana, c(-1.2,1), opt)
  sol
</code></pre>

<hr>
<h2 id='fminsearch.function'>
fminsearch Cost Function Call
</h2><span id='topic+fminsearch.function'></span>

<h3>Description</h3>

<p>This function calls the cost function and makes it match neldermead
requirements. It is used in the <code>fminsearch</code> function as the
<code>function</code> element of the neldermead object (see <code>?neldermead</code>
and <code>?neldermead.set</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fminsearch.function(x = NULL, index = NULL, fmsfundata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fminsearch.function_+3A_x">x</code></td>
<td>
<p>A single column vector of parameter estimates.</p>
</td></tr>
<tr><td><code id="fminsearch.function_+3A_index">index</code></td>
<td>
<p>An integer variable set to 2, indicating that only the cost
function is to be computed by the algorithm.</p>
</td></tr>
<tr><td><code id="fminsearch.function_+3A_fmsfundata">fmsfundata</code></td>
<td>
<p>An object of class 'optimbase.functionargs' and with 
(at least) a <code>fun</code> element, which contains the user-defined cost 
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following elements: </p>

<dl>
<dt>f</dt><dd><p>The value of the cost function at the current point estimate.</p>
</dd>
<dt>index</dt><dd><p>The same <code>index</code> variable.</p>
</dd>
<dt>this</dt><dd><p>A list with a single element <code>costargument</code> which
contains <code>fmsfundata</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Author of Scilab neldermead module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fminsearch">fminsearch</a></code>,
<code><a href="#topic+neldermead">neldermead</a></code>,
<code><a href="#topic+neldermead.set">neldermead.set</a></code>,
</p>

<hr>
<h2 id='fminsearch.outputfun'>
fminsearch Output Function Call
</h2><span id='topic+fminsearch.outputfun'></span>

<h3>Description</h3>

<p>This function calls the output function and make it match neldermead
requirements. It is used in the <code>fminsearch</code> function as the
<code>outputcommand</code> element of the neldermead object (see
<code>?neldermead</code> and <code>?neldermead.set</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fminsearch.outputfun(state = NULL, data = NULL, fmsdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fminsearch.outputfun_+3A_state">state</code></td>
<td>
<p>The current state of the algorithm either 'init', 'iter' or
'done'.</p>
</td></tr>
<tr><td><code id="fminsearch.outputfun_+3A_data">data</code></td>
<td>
<p>The data at the current state. This is an object of class 
'neldermead.data', i.e. a list with the following elements: </p>

<dl>
<dt>x</dt><dd><p>The current parameter estimates.</p>
</dd>
<dt>fval</dt><dd><p>The current value of the cost function.</p>
</dd>
<dt>simplex</dt><dd><p>The current simplex object.</p>
</dd>
<dt>iteration</dt><dd><p>The number of iterations performed.</p>
</dd>
<dt>funccount</dt><dd><p>The number of function evaluations.</p>
</dd>
<dt>step</dt><dd><p>The type of step in the previous iteration.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="fminsearch.outputfun_+3A_fmsdata">fmsdata</code></td>
<td>
<p>This is an object of class 'optimbase.functionargs' which 
contains specific data of the <code>fminsearch</code> algorithm: </p>

<dl>
<dt>Display</dt><dd><p>what to display</p>
</dd>
<dt>OutputFcn</dt><dd><p>the array of output functions</p>
</dd>
<dt>PlotFcns</dt><dd><p>the array of plot functions</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return any data, but execute the output function(s).
</p>


<h3>Author(s)</h3>

<p>Author of Scilab neldermead module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fminsearch">fminsearch</a></code>,
<code><a href="#topic+neldermead">neldermead</a></code>,
<code><a href="#topic+neldermead.set">neldermead.set</a></code>,
</p>

<hr>
<h2 id='neldermead'>
S3 neldermead object
</h2><span id='topic+neldermead'></span><span id='topic+print.neldermead'></span><span id='topic+summary.neldermead'></span><span id='topic+is.neldermead'></span>

<h3>Description</h3>

<p>These functions support the S3 class 'neldermead'and are intended to 
either create objects of this class or check if an object is of this class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  neldermead(optbase, method, simplex0, simplex0method, 
    simplex0length, simplexsize0, simplexopt, historysimplex, coords0, rho, chi, 
    gamma, sigma, tolfstdeviation, tolfstdeviationmethod, tolsimplexizeabsolute, 
    tolsimplexizerelative, tolsimplexizemethod, toldeltafv, tolssizedeltafvmethod,
    simplex0deltausual, simplex0deltazero, restartsimplexmethod, restartmax, 
    restarteps, restartstep, restartnb, restartflag, restartdetection, 
    kelleystagnationflag, kelleynormalizationflag, kelleystagnationalpha0, 
    kelleyalpha, startupflag, boxnbpoints, boxnbpointseff, boxineqscaling, 
    checkcostfunction, scalingsimplex0, guinalphamin, boxboundsalpha, 
    boxtermination, boxtolf, boxnbmatch, boxkount, boxreflect, tolvarianceflag, 
    tolabsolutevariance, tolrelativevariance, variancesimplex0, mymethod, 
    myterminate, myterminateflag, greedy, output, exitflag)
    
  ## S3 method for class 'neldermead'
print(x,verbose,...)
  
  ## S3 method for class 'neldermead'
summary(object,showhistory,...)
  
  ## S3 method for class 'neldermead'
is(x=NULL)
  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neldermead_+3A_optbase">optbase</code></td>
<td>
<p>An object of class 'optimbase', i.e. a list created by 
<code>optimbase()</code> and containing the following elements: </p>

<dl>
<dt>verbose</dt><dd><p>The verbose option, controlling the amount of messages.</p>
</dd>
<dt>x0</dt><dd><p>The initial guess.</p>
</dd>
<dt>fx0</dt><dd><p>The value of the function for the initial guess.</p>
</dd>
<dt>xopt</dt><dd><p>The optimum parameter.</p>
</dd>
<dt>fopt</dt><dd><p>The optimum function value.</p>
</dd>
<dt>tolfunabsolute</dt><dd><p>The absolute tolerance on function value.</p>
</dd>
<dt>tolfunrelative</dt><dd><p>The relative tolerance on function value.</p>
</dd>
<dt>tolfunmethod</dt><dd><p>Logical flag for the tolerance on function value in
the termination criteria. This criteria is suitable for functions which
minimum is associated with a function value equal to 0.</p>
</dd>
<dt>tolxabsolute</dt><dd><p>The absolute tolerance on x.</p>
</dd>
<dt>tolxrelative</dt><dd><p>The relative tolerance on x.</p>
</dd>
<dt>tolxmethod</dt><dd><p>Possible values: FALSE, TRUE.</p>
</dd>
<dt>funevals</dt><dd><p>The number of function evaluations.</p>
</dd>
<dt>maxfunevals</dt><dd><p>The maximum number of function evaluations.</p>
</dd>
<dt>maxiter</dt><dd><p>The maximum number of iterations.</p>
</dd>
<dt>iterations</dt><dd><p>The number of iterations.</p>
</dd>
<dt>fun</dt><dd><p>The cost function.</p>
</dd>
<dt>status</dt><dd><p>The status of the optimization.</p>
</dd>
<dt>historyfopt</dt><dd><p>The vector to store the history for fopt. The values of
the cost function will be stored at each iteration in a new element, so
the length of <code>historyfopt</code> at the end of the optimization should
be the number of iterations.</p>
</dd>
<dt>historyxopt</dt><dd><p>The list to store the history for xopt. The vectors of 
estimates will be stored on separated levels of the list, so the length
of <code>historyfopt</code> at the end of the optimization should be the
number of iterations.</p>
</dd>
<dt>verbosetermination</dt><dd><p>The verbose option for termination criteria.</p>
</dd>
<dt>outputcommand</dt><dd><p>The command called back for output.</p>
</dd>
<dt>outputcommandarg</dt><dd><p>The outputcommand argument is initialized as a
string. If the user configure this element, it is expected that a matrix
of values or a list is passed so that the argument is appended to the
name of the function.</p>
</dd>
<dt>numberofvariables</dt><dd><p>The number of variables to optimize.</p>
</dd>
<dt>storehistory</dt><dd><p>The flag which enables/disables the storing of the
history.</p>
</dd>
<dt>costfargument</dt><dd><p>The costf argument is initialized as a string. If
the user configure this element, it is expected that a matrix of values
or a list is passed so that the argument is appended to the name of the
function.</p>
</dd>
<dt>boundsmin</dt><dd><p>Minimum bounds for the parameters.</p>
</dd>
<dt>boundsmax</dt><dd><p>Maximum bounds for the parameters.</p>
</dd>
<dt>nbineqconst</dt><dd><p>The number of nonlinear inequality constraints.</p>
</dd>
<dt>logfile</dt><dd><p>The name of the log file.</p>
</dd>
<dt>logfilehandle</dt><dd><p>The handle for the log file.</p>
</dd>
<dt>logstartup</dt><dd><p>Set to TRUE when the logging is started up.</p>
</dd>
<dt>withderivatives</dt><dd><p>Set to TRUE when the method uses derivatives.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="neldermead_+3A_method">method</code></td>
<td>
<p>The name of the algorithm to use.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_simplex0">simplex0</code></td>
<td>
<p>An object of class 'simplex', i.e. a list created by
<code>optimsimplex()</code>, and containing the following elements:</p>

<dl>
<dt>verbose</dt><dd><p>The verbose option, controlling the amount of messages.</p>
</dd>
<dt>x</dt><dd><p>The coordinates of the vertices, with size nbve x n.</p>
</dd>
<dt>n</dt><dd><p>The dimension of the space.</p>
</dd>
<dt>fv</dt><dd><p>The function values, with size nbve x 1.</p>
</dd>
<dt>nbve</dt><dd><p>The number of vertices.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="neldermead_+3A_simplex0method">simplex0method</code></td>
<td>
<p>The method to use to compute the initial simplex.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_simplex0length">simplex0length</code></td>
<td>
<p>The length to use when the initial simplex is computed
with the 'axes' or 'spendley' methods.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_rho">rho</code></td>
<td>
<p>The reflection coefficient. This parameter is used when the
<code>method</code> element is set to 'fixed' or 'variable'.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_chi">chi</code></td>
<td>
<p>The expansion coefficient. This parameter is used when the
<code>method</code> element is set to 'variable'.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_gamma">gamma</code></td>
<td>
<p>The contraction coefficient. This parameter is used when the
<code>method</code> element is set to 'variable'.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_sigma">sigma</code></td>
<td>
<p>The shrinkage coefficient. This parameter is used when the
<code>method</code> element is set to 'fixed' or 'variable'.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_tolfstdeviation">tolfstdeviation</code></td>
<td>
<p>The tolerance for the standard deviation.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_tolfstdeviationmethod">tolfstdeviationmethod</code></td>
<td>
<p>Set to FALSE.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_tolsimplexizeabsolute">tolsimplexizeabsolute</code></td>
<td>
<p>The absolute tolerance on the simplex size.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_tolsimplexizerelative">tolsimplexizerelative</code></td>
<td>
<p>The relative tolerance on the simplex size.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_tolsimplexizemethod">tolsimplexizemethod</code></td>
<td>
<p>Logical flag to enable/disable the tolerance on
the simplex size. When this criteria is enabled, the values of the
<code>tolsimplexizeabsolute</code> and <code>tolsimplexizerelative</code> elements are
used in the termination criteria. The method to compute the size is the
'sigmaplus' method.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_simplexsize0">simplexsize0</code></td>
<td>
<p>Initial size of the simplex, for the tolerance on the
simplex size.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_toldeltafv">toldeltafv</code></td>
<td>
<p>The absolute tolerance on the difference between the
highest and the lowest function values.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_tolssizedeltafvmethod">tolssizedeltafvmethod</code></td>
<td>
<p>Logical flag to enable/disable the termination
criteria based on the size of the simplex and the difference of function
value in the simplex. If this criteria is triggered, the status of the
optimization is set to 'tolsizedeltafv'. This termination criteria uses
the values of the <code>tolsimplexizeabsolute</code> and <code>toldeltafv</code>
elements. This criteria is identical to Scilab's <code>fminsearch</code>.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_historysimplex">historysimplex</code></td>
<td>
<p>The list to store the history for simplex. The simplex
will be stored on a new level of the list at each iteration, so the length 
of <code>historyfopt</code> at the end of the optimization should be the number
of iterations.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_coords0">coords0</code></td>
<td>
<p>The coordinates of the vertices of the initial simplex. If
the <code>simplex0method</code> element is set to 'given', these coordinates are
used to compute the initial simplex. This matrix is expected to have
shape nbve x n where nbve is the number of vertices and n is the number of
variables.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_simplex0deltausual">simplex0deltausual</code></td>
<td>
<p>The relative delta for non-zero parameters in
'pfeffer' method.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_simplex0deltazero">simplex0deltazero</code></td>
<td>
<p>The absolute delta for non-zero parameters in
'pfeffer' method.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_simplexopt">simplexopt</code></td>
<td>
<p>The optimum simplex, after one optimization process.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_restartsimplexmethod">restartsimplexmethod</code></td>
<td>
<p>The method to compute the initial simplex after
a restart.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_restartmax">restartmax</code></td>
<td>
<p>The maximum number of restarts, when automatic restart is
enabled via the <code>restartflag</code> element.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_restarteps">restarteps</code></td>
<td>
<p>The absolute epsilon value used to check for optimality in
the factorial O'Neill restart detection.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_restartstep">restartstep</code></td>
<td>
<p>The absolute step length used to check for optimality in
the factorial O'Neill restart detection.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_kelleystagnationflag">kelleystagnationflag</code></td>
<td>
<p>Logical flag to enable/disable the termination
criteria using Kelley's stagnation detection, based on sufficient decrease
condition. If this criteria is triggered, the status of the optimization
is set to 'kelleystagnation'.</p>
</td></tr></table>
<p>,
</p>
<table>
<tr><td><code id="neldermead_+3A_kelleynormalizationflag">kelleynormalizationflag</code></td>
<td>
<p>Logical flag to enable/disable the
normalization of the alpha coefficient in Kelley's stagnation detection,
i.e. use the value of the <code>kelleystagnationalpha0</code> element as is.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_kelleystagnationalpha0">kelleystagnationalpha0</code></td>
<td>
<p>The parameter used in Kelley's stagnation
detection.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_kelleyalpha">kelleyalpha</code></td>
<td>
<p>The current value of Kelley's alpha, after normalization,
if required.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_restartnb">restartnb</code></td>
<td>
<p>Number of restarts performed.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_restartflag">restartflag</code></td>
<td>
<p>Logical flag to enable/disable the automatic restart of
the algorithm.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_restartdetection">restartdetection</code></td>
<td>
<p>The method to detect if the automatic restart must
be performed.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_startupflag">startupflag</code></td>
<td>
<p>Set to TRUE when the startup has been performed.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_boxnbpoints">boxnbpoints</code></td>
<td>
<p>The number of points in the initial simplex, when the
<code>simplex0method</code> is set to 'randbounds'. The value of this element is
also use to update the simplex when a restart is performed and the
<code>restartsimplexmethod</code> element is set to 'randbounds'. The default
value is so that the number of points is twice the number of variables of
the problem.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_boxnbpointseff">boxnbpointseff</code></td>
<td>
<p>The effective number of points required in the simplex
for Box's algorithm.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_boxineqscaling">boxineqscaling</code></td>
<td>
<p>The scaling coefficient used to scale the trial point
for function improvement or into the constraints of Box's algorithm.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_checkcostfunction">checkcostfunction</code></td>
<td>
<p>Logical flag to enable/disable the checking of the
connection of the cost function.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_scalingsimplex0">scalingsimplex0</code></td>
<td>
<p>The algorithm used to scale the initial simplex into
the nonlinear constraints. The following two algorithms are provided:
</p>

<dl>
<dt>'tox0'</dt><dd><p>scales the vertices toward the initial guess.</p>
</dd>
<dt>'tocentroid'</dt><dd><p>scales the vertices toward the centroid, as
recommended by Box.</p>
</dd>
</dl>

<p>If the centroid happens to be unfeasible, because the constraints are not
convex, the scaling of the initial simplex toward the centroid may fail.
Since the initial guess is always feasible, scaling toward the initial
guess cannot fail.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_guinalphamin">guinalphamin</code></td>
<td>
<p>The minimum value of alpha when scaling the vertices of
the simplex into nonlinear constraints in Box's algorithm.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_boxboundsalpha">boxboundsalpha</code></td>
<td>
<p>The parameter used to project the vertices into the
bounds in Box's algorithm.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_boxtermination">boxtermination</code></td>
<td>
<p>Logical flag to enable/disable Box's termination
criteria.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_boxtolf">boxtolf</code></td>
<td>
<p>The absolute tolerance on difference of function values in
the simplex, suggested by Box. This tolerance is used if the
<code>boxtermination</code> element is set to TRUE.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_boxnbmatch">boxnbmatch</code></td>
<td>
<p>The number of consecutive match of Box's termination
criteria.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_boxkount">boxkount</code></td>
<td>
<p>Current number of consecutive match.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_boxreflect">boxreflect</code></td>
<td>
<p>The reflection factor in Box's algorithm.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_tolvarianceflag">tolvarianceflag</code></td>
<td>
<p>Logical flag to enable/disable the termination
criteria based on the variance of the function value. If this criteria is
triggered, the status of the optimization is set to 'tolvariance'. This
criteria is suggested by Nelder and Mead.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_tolabsolutevariance">tolabsolutevariance</code></td>
<td>
<p>The absolute tolerance on the variance of the
function values of the simplex.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_tolrelativevariance">tolrelativevariance</code></td>
<td>
<p>The relative tolerance on the variance of the
function values of the simplex.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_variancesimplex0">variancesimplex0</code></td>
<td>
<p>Relative tolerance on variance.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_mymethod">mymethod</code></td>
<td>
<p>A user-derined simplex algorithm.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_myterminate">myterminate</code></td>
<td>
<p>A user-defined terminate function.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_myterminateflag">myterminateflag</code></td>
<td>
<p>Logical flag to enable/disable the user-defined
terminate function.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_greedy">greedy</code></td>
<td>
<p>Logical flag to enable/disable greedy Nelder-Mead.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_output">output</code></td>
<td>
<p>The command to call back for user-defined output of specialized 
function.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_exitflag">exitflag</code></td>
<td>
<p>Logical flag to enable/disable the user-defined output of
specialized function.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_x">x</code></td>
<td>
<p>An object of class 'neldermead'.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_verbose">verbose</code></td>
<td>
<p>A logical flag, controlling the amount of data printed.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_...">...</code></td>
<td>
<p>optional arguments to 'print' or 'plot' methods.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_object">object</code></td>
<td>
<p>An object of class 'neldermead'.</p>
</td></tr>
<tr><td><code id="neldermead_+3A_showhistory">showhistory</code></td>
<td>
<p>Optional logical flag, to define whether optimization 
history must be summarized or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>neldermead</code> function returns a new object of class 'neldermead', 
with the following default content:</p>

<dl>
<dt>optbase</dt><dd><p>An object of class 'optimbase' with the following default 
content: </p>

<dl>
<dt>verbose</dt><dd><p>Default is FALSE.</p>
</dd>
<dt>x0</dt><dd><p>Default is NULL.</p>
</dd>
<dt>fx0</dt><dd><p>Default is NULL.</p>
</dd>
<dt>xopt</dt><dd><p>Default is 0.</p>
</dd>
<dt>fopt</dt><dd><p>Default is 0.</p>
</dd>
<dt>tolfunabsolute</dt><dd><p>Default is 0.</p>
</dd>
<dt>tolfunrelative</dt><dd><p>Default is .Machine$double.eps.</p>
</dd>
<dt>tolfunmethod</dt><dd><p>Default is FALSE.</p>
</dd>
<dt>tolxabsolute</dt><dd><p>Default is 0.</p>
</dd>
<dt>tolxrelative</dt><dd><p>Default is .Machine$double.eps.</p>
</dd>
<dt>tolxmethod</dt><dd><p>Default is TRUE.</p>
</dd>
<dt>funevals</dt><dd><p>Default is 0.</p>
</dd>
<dt>maxfunevals</dt><dd><p>Default is 100.</p>
</dd>
<dt>maxiter</dt><dd><p>Default is 100.</p>
</dd>
<dt>iterations</dt><dd><p>Default is 0.</p>
</dd>
<dt>fun</dt><dd><p>Default is &rdquo;.</p>
</dd>
<dt>status</dt><dd><p>Default is &rdquo;.</p>
</dd>
<dt>historyfopt</dt><dd><p>Default is NULL.</p>
</dd>
<dt>historyxopt</dt><dd><p>Default is NULL.</p>
</dd>
<dt>verbosetermination</dt><dd><p>Default is FALSE.</p>
</dd>
<dt>outputcommand</dt><dd><p>Default is &rdquo;.</p>
</dd>
<dt>outputcommandarg</dt><dd><p>Default is &rdquo;. If the user configures this 
element, it is expected to be an object of class 'optimbase.outputargs' 
or will be coerced to an object of class 'optimbase.outputargs'.</p>
</dd>
<dt>numberofvariables</dt><dd><p>Default is 0.</p>
</dd>
<dt>storehistory</dt><dd><p>Default is FALSE.</p>
</dd>
<dt>costfargument</dt><dd><p>Default is &rdquo;. If the user configures this element, 
it is expected to be an object of class 'optimbase.functionargs' or 
will be coerced to an object of class 'optimbase.functionargs'.</p>
</dd>
<dt>boundsmin</dt><dd><p>Default is NULL.</p>
</dd>
<dt>boundsmax</dt><dd><p>Default is NULL.</p>
</dd>
<dt>nbineqconst</dt><dd><p>Default is 0.</p>
</dd>
<dt>logfile</dt><dd><p>Default is &rdquo;.</p>
</dd>
<dt>logfilehandle</dt><dd><p>Default is 0.</p>
</dd>
<dt>logstartup</dt><dd><p>Default is FALSE.</p>
</dd>
<dt>withderivatives</dt><dd><p>Default is FALSE.</p>
</dd>
</dl>

</dd>
<dt>method</dt><dd><p>Default is 'variable'.</p>
</dd>
<dt>simplex0</dt><dd><p>Default is an object of class 'simplex', with the following 
content:</p>

<dl>
<dt>verbose</dt><dd><p>Default is 0.</p>
</dd>
<dt>x</dt><dd><p>Default is NULL.</p>
</dd>
<dt>n</dt><dd><p>Default is 0.</p>
</dd>
<dt>fv</dt><dd><p>Default is NULL.</p>
</dd>
<dt>nbve</dt><dd><p>Default is 0.</p>
</dd>
</dl>

</dd>
<dt>simplex0method</dt><dd><p>Default is 'axes'.</p>
</dd>
<dt>simplex0length</dt><dd><p>Default is 1.</p>
</dd>
<dt>rho</dt><dd><p>Default is 1.</p>
</dd>
<dt>chi</dt><dd><p>Default is 2.</p>
</dd>
<dt>gamma</dt><dd><p>Default is 0.5.</p>
</dd>
<dt>sigma</dt><dd><p>Default is 0.5.</p>
</dd>
<dt>tolfstdeviation</dt><dd><p>Default is 0.</p>
</dd>
<dt>tolfstdeviationmethod</dt><dd><p>Default is FALSE.</p>
</dd>
<dt>tolsimplexizeabsolute</dt><dd><p>Default is 0.</p>
</dd>
<dt>tolsimplexizerelative</dt><dd><p>Default is .Machine$double.eps.</p>
</dd>
<dt>tolsimplexizemethod</dt><dd><p>Default is FALSE.</p>
</dd>
<dt>simplexsize0</dt><dd><p>Default is 0.</p>
</dd>
<dt>toldeltafv</dt><dd><p>Default is .Machine$double.eps.</p>
</dd>
<dt>tolssizedeltafvmethod</dt><dd><p>Default is FALSE.</p>
</dd>
<dt>historysimplex</dt><dd><p>Default is NULL.</p>
</dd>
<dt>coords0</dt><dd><p>Default is NULL.</p>
</dd>
<dt>simplex0deltausual</dt><dd><p>Default is 0.05.</p>
</dd>
<dt>simplex0deltazero</dt><dd><p>Default is 0.0075.</p>
</dd>
<dt>simplexopt</dt><dd><p>Default is NULL.</p>
</dd>
<dt>restartsimplexmethod</dt><dd><p>Default is 'oriented'.</p>
</dd>
<dt>restartmax</dt><dd><p>Default is 3.</p>
</dd>
<dt>restarteps</dt><dd><p>Default is .Machine$double.eps.</p>
</dd>
<dt>restartstep</dt><dd><p>Default is 1.</p>
</dd>
<dt>kelleystagnationflag</dt><dd><p>Default is FALSE.</p>
</dd></dl>
<p>,
</p>
<dl>
<dt>kelleynormalizationflag</dt><dd><p>Default is TRUE, i.e. the simplex gradient of 
the initial simplex is taken into account in the stagnation detection.</p>
</dd>
<dt>kelleystagnationalpha0</dt><dd><p>Default is 1.e-4.</p>
</dd>
<dt>kelleyalpha</dt><dd><p>Default is 1.e-4.</p>
</dd>
<dt>restartnb</dt><dd><p>Default is 0.</p>
</dd>
<dt>restartflag</dt><dd><p>Default is FALSE.</p>
</dd>
<dt>restartdetection</dt><dd><p>Default is 'oneill'.</p>
</dd>
<dt>startupflag</dt><dd><p>Default is FALSE.</p>
</dd>
<dt>boxnbpoints</dt><dd><p>Default is '2n'.</p>
</dd>
<dt>boxnbpointseff</dt><dd><p>Default is 0.</p>
</dd>
<dt>boxineqscaling</dt><dd><p>Default is 0.</p>
</dd>
<dt>checkcostfunction</dt><dd><p>Default is TRUE.</p>
</dd>
<dt>scalingsimplex0</dt><dd><p>Default is 'tox0'.</p>
</dd>
<dt>guinalphamin</dt><dd><p>Default is 1.e-6.</p>
</dd>
<dt>boxtermination</dt><dd><p>Default is FALSE.</p>
</dd>
<dt>boxtolf</dt><dd><p>Default is 1.e-5.</p>
</dd>
<dt>boxnbmatch</dt><dd><p>Default is 5.</p>
</dd>
<dt>boxkount</dt><dd><p>Default is 0.</p>
</dd>
<dt>boxreflect</dt><dd><p>Default is 1.3.</p>
</dd>
<dt>tolvarianceflag</dt><dd><p>Default is FALSE.</p>
</dd>
<dt>tolabsolutevariance</dt><dd><p>Default is 0.</p>
</dd>
<dt>tolrelativevariance</dt><dd><p>Default is .Machine$double.eps.</p>
</dd>
<dt>variancesimplex0</dt><dd><p>Default is .Machine$double.eps.</p>
</dd>
<dt>mymethod</dt><dd><p>Default is NULL.</p>
</dd>
<dt>myterminate</dt><dd><p>Default is NULL.</p>
</dd>
<dt>myterminateflag</dt><dd><p>Default is FALSE.</p>
</dd>
<dt>greedy</dt><dd><p>Default is FALSE.</p>
</dd>
<dt>output</dt><dd><p>Default is list().</p>
</dd>
<dt>exitflag</dt><dd><p>Default is FALSE.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Author of Scilab neldermead module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="optimbase.html#topic+optimbase">optimbase</a></code>,
<code><a href="optimsimplex.html#topic+optimsimplex">optimsimplex</a></code>
</p>

<hr>
<h2 id='neldermead.algo'>
Nelder-Mead Algorithm
</h2><span id='topic+neldermead.algo'></span><span id='topic+neldermead.fixed'></span><span id='topic+neldermead.variable'></span><span id='topic+neldermead.box'></span><span id='topic+neldermead.storehistory'></span><span id='topic+neldermead.termination'></span><span id='topic+neldermead.interpolate'></span><span id='topic+boxlinesearch'></span>

<h3>Description</h3>

<p><code>neldermead.algo</code> performs an optimization without restart using the
method associated with the <code>method</code> element of the neldermead object;
<code>neldermead.fixed</code>, <code>neldermead.variable</code>, <code>neldermead.box</code>,
<code>boxlinesearch</code>, <code>neldermead.storehistory</code>,
<code>neldermead.termination</code>, and <code>neldermead.interpolate</code> are utility
functions for <code>neldermead.algo</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  neldermead.algo(this = NULL)
  neldermead.fixed(this = NULL)
  neldermead.variable(this = NULL)
  neldermead.box(this = this)
  boxlinesearch(this = NULL, n = NULL, xbar = NULL, xhigh = NULL, fhigh = NULL,
                rho = NULL)
  neldermead.storehistory(this = NULL, n = NULL, fopt = NULL, xopt = NULL,
                          fv = NULL, xcoords = NULL)
  neldermead.termination(this = NULL, fvinitial = NULL, oldfvmean = NULL,
                         newfvmean = NULL, previousxopt = NULL,
                         currentxopt = NULL, simplex = NULL)
  neldermead.interpolate(x1 = NULL, x2 = NULL, fac = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neldermead.algo_+3A_this">this</code></td>
<td>
<p>A neldermead object.</p>
</td></tr>
<tr><td><code id="neldermead.algo_+3A_n">n</code></td>
<td>
<p>Number of variables.</p>
</td></tr>
<tr><td><code id="neldermead.algo_+3A_xbar">xbar</code></td>
<td>
<p>The centroid.</p>
</td></tr>
<tr><td><code id="neldermead.algo_+3A_xhigh">xhigh</code></td>
<td>
<p>The high point.</p>
</td></tr>
<tr><td><code id="neldermead.algo_+3A_fhigh">fhigh</code></td>
<td>
<p>The value of the cost function at <code>xhigh</code>.</p>
</td></tr>
<tr><td><code id="neldermead.algo_+3A_rho">rho</code></td>
<td>
<p>The reflection factor.</p>
</td></tr>
<tr><td><code id="neldermead.algo_+3A_fopt">fopt</code></td>
<td>
<p>The current value of the function at the current optimum point
estimate.</p>
</td></tr>
<tr><td><code id="neldermead.algo_+3A_xopt">xopt</code></td>
<td>
<p>The current optimum point estimate.</p>
</td></tr>
<tr><td><code id="neldermead.algo_+3A_fv">fv</code></td>
<td>
<p>The function values, with size nbve x 1.</p>
</td></tr>
<tr><td><code id="neldermead.algo_+3A_xcoords">xcoords</code></td>
<td>
<p>Matrix of size n x n+1, coordinates of the n+1 vertices</p>
</td></tr>
<tr><td><code id="neldermead.algo_+3A_fvinitial">fvinitial</code></td>
<td>
<p>The initial cost function value.</p>
</td></tr>
<tr><td><code id="neldermead.algo_+3A_oldfvmean">oldfvmean</code></td>
<td>
<p>The old cost function value average on the simplex.</p>
</td></tr>
<tr><td><code id="neldermead.algo_+3A_newfvmean">newfvmean</code></td>
<td>
<p>The new cost function value average on the simplex.</p>
</td></tr>
<tr><td><code id="neldermead.algo_+3A_previousxopt">previousxopt</code></td>
<td>
<p>The previous point estimate.</p>
</td></tr>
<tr><td><code id="neldermead.algo_+3A_currentxopt">currentxopt</code></td>
<td>
<p>The current point estimate.</p>
</td></tr>
<tr><td><code id="neldermead.algo_+3A_simplex">simplex</code></td>
<td>
<p>The simplex. The best point estimate in the simplex is expected
to be stored at 1, while the worst point estimate in the simplex is expected
to be stored at n+1.</p>
</td></tr>
<tr><td><code id="neldermead.algo_+3A_x1">x1</code></td>
<td>
<p>The first reference point estimate to perform the
interpolation.</p>
</td></tr>
<tr><td><code id="neldermead.algo_+3A_x2">x2</code></td>
<td>
<p>The second reference point estimate to perform the
interpolation.</p>
</td></tr>  
<tr><td><code id="neldermead.algo_+3A_fac">fac</code></td>
<td>
<p>A factor to perform the interpolation.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>neldermead.fixed</code></dt><dd><p>The simplex algorithm with fixed size simplex.
We implement the following 'rules' of the method of Spendley et al.
</p>

<ul>
<li><p> Rule 1 is strictly applied, but the reflection is done by reflection
of the high point, since we minimize a function instead of maximizing it,
like Spendley.
</p>
</li>
<li><p> Rule 2 is NOT implemented, as we expect that the function evaluation
is not subject to errors.
</p>
</li>
<li><p> Rule 3 is applied, i.e. reflection with respect to next to high point.
A shrink step is included, with shrinkage factor sigma.
</p>
</li></ul>

<p>Rule 1. Ascertain the lowest reading y, of yi ... Yk+1
Complete a new simplex Sp by excluding the point Vp corresponding to
y, and replacing it by V* defined as above.
</p>
<p>Rule 2. If a result has occurred in (k + 1) successive simplexes, and is not
then eliminated by application of Rule 1, do not move in the direction
indicated by Rule 1, or at all, but discard the result and replace it by a
new observation at the same point.
</p>
<p>Rule 3. If y is the lowest reading in So , and if the next observation made,
y* , is the lowest reading in the new simplex S , do not apply Rule 1 and
return to So from Sp . Move out of S, by rejecting the second lowest reading
(which is also the second lowest reading in So).
</p>
</dd>
<dt><code>neldermead.variable</code></dt><dd><p>The original Nelder-Mead algorithm, with
variable-size simplex.</p>
</dd>
<dt><code>neldermead.box</code></dt><dd><p>The Nelder-Mead algorithm, with variable-size
simplex and modifications by Box for bounds and inequality constraints.</p>
</dd>
<dt><code>boxlinesearch</code></dt><dd><p>Called by <code>neldermead.box</code>, i.e. Box's
method. Perform a line search from xbar, on the line (xhigh,xbar). The
reflected point estimate satisfies the following constraints: </p>

<ul>
<li><p> fr &lt; fhigh
</p>
</li>
<li><p> xr satisfies the bounds constraints
</p>
</li>
<li><p> xr satisfies the nonlinear positive inequality constraints
</p>
</li>
<li><p> xr satisfies the linear positive inequality constraints
</p>
</li></ul>

<p>The method is based on projection and scaling toward the centroid.</p>
</dd>
<dt><code>neldermead.storehistory</code></dt><dd><p>Store the optimization history into the
neldermead object.</p>
</dd>
<dt><code>neldermead.termination</code></dt><dd><p>Determine if the algorithm must continue
or terminate. The function uses the cost function average in the simplex
instead of the best cost function value. This is because the function
average changes at each iteration. Instead, the best function value has a
step-by-step evolution and may not change between two successive iterations,
leading to a stop of the algorithm.</p>
</dd>
<dt><code>neldermead.interpolate</code></dt><dd><p>Compute the point estimate xi as an
interpolation between x1 and x2, as follows:  xi = (1+fac)x1 - fac*x2</p>
</dd>
</dl>



<h3>Value</h3>


<dl>
<dt><code>neldermead.fixed</code>, <code>neldermead.variable</code>, and
<code>neldermead.box</code></dt><dd><p>Return the updated neldermead object, containing the
optimum point estimate.</p>
</dd>
<dt><code>boxlinesearch</code></dt><dd><p>Return a list with the following elements:
</p>

<dl>
<dt>this</dt><dd><p>The updated neldermead object.</p>
</dd>
<dt>status</dt><dd><p>TRUE if the search is successful, FALSE otherwise.</p>
</dd>
<dt>xr</dt><dd><p>The reflected point estimate.</p>
</dd>
<dt>fr</dt><dd><p>The value of the cost function at <code>xr</code>.</p>
</dd>
</dl>

</dd>
<dt><code>neldermead.storehistory</code></dt><dd><p>Return the updated neldermead object.</p>
</dd>
<dt><code>neldermead.termination</code></dt><dd><p>Return a list with the following
elements: </p>

<dl>
<dt>this</dt><dd><p>The updated neldermead object</p>
</dd>
<dt>terminate</dt><dd><p>TRUE if the algorithm terminates, FALSE if the algorithm
must continue.</p>
</dd>
<dt>status</dt><dd><p>The termination status: 'continue', 'maxiter', 'maxfuneval',
'tolf', 'tolx', 'tolsize', 'tolsizedeltafv', 'kelleystagnation',
'tolboxf', 'tolvariance' or the user-defined termination status.</p>
</dd>
</dl>

</dd>
<dt><code>neldermead.interpolate</code></dt><dd><p>Return a new point estimate, i.e. a
column vector.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Author of Scilab neldermead module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>

<hr>
<h2 id='neldermead.destroy'>
Erase a neldermead object.
</h2><span id='topic+neldermead.destroy'></span>

<h3>Description</h3>

<p><code>neldermead.destroy</code> calls <code>optimbase.destroy</code> and
<code>optimsimplex.destroy</code> to erase the content of <code>this$optbase</code> and
<code>this$simplex0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  neldermead.destroy(this = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neldermead.destroy_+3A_this">this</code></td>
<td>
<p>A neldermead object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return an updated neldermead object.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab neldermead module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="optimbase.html#topic+optimbase.destroy">optimbase.destroy</a></code>,
<code><a href="optimsimplex.html#topic+optimsimplex.destroy">optimsimplex.destroy</a></code>
</p>

<hr>
<h2 id='neldermead.function'>
Call Cost Function.
</h2><span id='topic+neldermead.function'></span>

<h3>Description</h3>

<p>Simple way to compute the value of the cost function specified in a neldermead
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  neldermead.function(this = NULL, x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neldermead.function_+3A_this">this</code></td>
<td>
<p>A neldermead object.</p>
</td></tr>
<tr><td><code id="neldermead.function_+3A_x">x</code></td>
<td>
<p>The point estimate where the cost function is to be evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the value of the cost function.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab neldermead module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>

<hr>
<h2 id='neldermead.get'>
Get the value for the given element
</h2><span id='topic+neldermead.get'></span>

<h3>Description</h3>

<p>Get the value for the given element in a neldermead object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  neldermead.get(this = NULL, key = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neldermead.get_+3A_this">this</code></td>
<td>
<p>A neldermead object.</p>
</td></tr>
<tr><td><code id="neldermead.get_+3A_key">key</code></td>
<td>
<p>The name of the key to query.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the value of the list element <code>key</code>, or an error message if
<code>key</code> does not exist in the neldermead object <code>this</code>.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab neldermead module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+neldermead.set">neldermead.set</a></code>,
<code><a href="optimbase.html#topic+optimbase.get">optimbase.get</a></code>
</p>

<hr>
<h2 id='neldermead.restart'>
Restart neldermead search.
</h2><span id='topic+neldermead.restart'></span>

<h3>Description</h3>

<p>Update the simplex with <code>neldermead.updatesimp</code> and restart the search
with <code>neldermead.search</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  neldermead.restart(this = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neldermead.restart_+3A_this">this</code></td>
<td>
<p>A neldermead object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an updated neldermead object.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab neldermead module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+neldermead.updatesimp">neldermead.updatesimp</a></code>,
<code><a href="#topic+neldermead.search">neldermead.search</a></code>,
</p>

<hr>
<h2 id='neldermead.search'>
Starts the optimization
</h2><span id='topic+neldermead.search'></span>

<h3>Description</h3>

<p>Performs the optimization associated with the method associated with the
<code>method</code> element of the neldermead object and find the optimum. If the
<code>restartflag</code> element is enabled, automatic restarts are performed, based
on the <code>restartdetection</code> element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  neldermead.search(this = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neldermead.search_+3A_this">this</code></td>
<td>
<p>A neldermead object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return an updated neldermead object.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab neldermead module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fminsearch">fminsearch</a></code>,
<code><a href="#topic+neldermead">neldermead</a></code>,
<code><a href="#topic+neldermead.set">neldermead.set</a></code>,
</p>

<hr>
<h2 id='neldermead.set'>
Neldermead Object Configuration
</h2><span id='topic+neldermead.set'></span>

<h3>Description</h3>

<p>Configure the current neldermead object with the given value for the given
key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  neldermead.set(this = NULL, key = NULL, value = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neldermead.set_+3A_this">this</code></td>
<td>
<p>The current neldermead object.</p>
</td></tr>
<tr><td><code id="neldermead.set_+3A_key">key</code></td>
<td>
<p>The key to configure. See details for the list of possible keys.</p>
</td></tr>
<tr><td><code id="neldermead.set_+3A_value">value</code></td>
<td>
<p>The value to assign to the key.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>neldermead.set</code> sets the content of the <code>key</code> element of
the neldermead object <code>this</code> to <code>value</code>. If <code>key</code> is a
sub-element of <code>this$optbase</code>, <code>value</code> is assigned by
<code>optimbase.set</code>.
</p>
<p>The main available keys are the following:</p>

<dl>
<dt>'-verbose'</dt><dd><p>Set to 1 to enable verbose logging.</p>
</dd>
<dt>'-verbosetermination'</dt><dd><p>Set to 1 to enable verbose termination
logging.</p>
</dd>
<dt>'-x0'</dt><dd><p>The initial guess, as a n x 1 column vector, where n is the
number of variables.</p>
</dd>
<dt>'-maxfunevals'</dt><dd><p>The maximum number of function evaluations. If this
criteria is triggered during optimization, the status of the optimization
is set to 'maxfuneval'.</p>
</dd>
<dt>'-maxiter'</dt><dd><p>The maximum number of iterations. If this criteria is
triggered during optimization, the status of the optimization is set to
'maxiter'.</p>
</dd></dl>
<p>option
</p>
<dl>
<dt>'-tolfunabsolute'</dt><dd><p>The absolute tolerance for the function value.</p>
</dd>
<dt>'-tolfunrelative'</dt><dd><p>The relative tolerance for the function value.</p>
</dd>
<dt>'-tolfunmethod'</dt><dd><p>The method used for the tolerance on function value
in the termination criteria. The following values are available: TRUE,
FALSE. If this criteria is triggered, the status of the optimization is
set to 'tolf'.</p>
</dd>
<dt>'-tolxabsolute'</dt><dd><p>The absolute tolerance on x.</p>
</dd>
<dt>'-tolxrelative'</dt><dd><p>The relative tolerance on x.</p>
</dd>
<dt>'-tolxmethod'</dt><dd><p>The method used for the tolerance on x in the
termination criteria. The following values are available: TRUE, FALSE. If
this criteria is triggered during optimization, the status of the
optimization is set to 'tolx'.</p>
</dd>
<dt>'-function'</dt><dd><p>The objective function, which computes the value of the
cost and the non linear constraints, if any. See
<code>vignette('neldermead',package='neldermead')</code> for the details of
the communication between the optimization system and the cost function.</p>
</dd>
<dt>'-costfargument'</dt><dd><p>An additionnal argument, passed to the cost
function.</p>
</dd>
<dt>'-outputcommand'</dt><dd><p>A command which is called back for output. See
<code>vignette('neldermead',package='neldermead')</code> for the details of
the communication between the optimization system and the output command
function.</p>
</dd>
<dt>'-outputcommandarg'</dt><dd><p>An additionnal argument, passed to the output
command.</p>
</dd></dl>
<p>option
</p>
<dl>
<dt>'-numberofvariables'</dt><dd><p>The number of variables to optimize.</p>
</dd>
<dt>'-storehistory'</dt><dd><p>Set to TRUE to enable the history storing.</p>
</dd>
<dt>'-boundsmin'</dt><dd><p>The minimum bounds for the parameters.</p>
</dd>
<dt>'-boundsmax'</dt><dd><p>The maximum bounds for the parameters.</p>
</dd>
<dt>'-nbineqconst'</dt><dd><p>The number of inequality constraints.</p>
</dd>
<dt>'-method'</dt><dd><p>The name of the algorithm to use. The following methods are
available:</p>

<dl>
<dt>'fixed'</dt><dd><p>the fixed simplex shape algorithm of Spendley et al. This
algorithm is for unconstrained problems (i.e. bounds and non linear
constraints are not taken into account)</p>
</dd>
<dt>'variable'</dt><dd><p>the variable simplex shape algorithm of Nelder and
Mead. This algorithm is for unconstrained problems (i.e. bounds and
non linear constraints are not taken into account)</p>
</dd>
<dt>'box'</dt><dd><p>Box's complex algorithm. This algorithm takes into
account bounds and nonlinear inequality constraints.</p>
</dd>
<dt>'mine'</dt><dd><p>the user-defined algorithm, associated with the
<code>mymethod</code> element. See
<code>vignette('neldermead',package='neldermead')</code> for details.</p>
</dd>
</dl>

</dd>
<dt>'-simplex0method'</dt><dd><p>The method to use to compute the initial simplex.
The first vertex in the simplex is always the initial guess associated
with the <code>x0</code> element. The following methods are available:
</p>

<dl>
<dt>'given'</dt><dd><p>The coordinates associated with the <code>coords0</code>
element are used to compute the initial simplex, with arbitrary number
of vertices. This allows the user to setup the initial simplex by a
specific method which is not provided by the current package (for
example with a simplex computed from a design of experiments). This
allows also to configure the initial simplex so that a specific
behaviour of the algorithm is to be reproduced (for example the Mac
Kinnon test case). The given matrix is expected to have nbve rows and
n columns, where n is the dimension of the problem and nbve is the
number of vertices.</p>
</dd>
<dt>'axes'</dt><dd><p>The simplex is computed from the coordinate axes and the
length associated with the <code>simplex0length</code> element.</p>
</dd>
<dt>'spendley'</dt><dd><p>The simplex is computed so that it is regular with
the length associated with the <code>simplex0length</code> element (i.e. all
the edges have the same length).</p>
</dd>
<dt>'pfeffer'</dt><dd><p>The simplex is computed from an heuristic, in the
neighborhood of the initial guess. This initial simplex depends on
the -simplex0deltausual and -simplex0deltazero.</p>
</dd>
<dt>'randbounds'</dt><dd><p>The simplex is computed from the bounds and a
random number. This option is available only if bounds are available:
if bounds are not available, an error is generated. This method is
usually associated with Box's algorithm. The number of vertices in
the simplex is taken from the <code>boxnbpoints</code> element.</p>
</dd>
</dl>

</dd>
<dt>'-coords0'</dt><dd><p>The coordinates of the vertices of the initial simplex. If
the <code>simplex0method</code> element is set to 'given', these coordinates are
used to compute the initial simplex. This matrix is expected to have shape
nbve x n, where nbve is the number of vertices and n is the number of
variables.</p>
</dd>
<dt>'-simplex0length'</dt><dd><p>The length to use when the initial simplex is
computed with the 'axes' or 'spendley' methods. If the initial simplex is
computed from 'spendley' method, the length is expected to be a
scalar value. If the initial simplex is computed from 'axes' method,
it may be either a scalar value or a vector of values, of length n,
where n is the number of variables.</p>
</dd>
<dt>'-simplex0deltausual'</dt><dd><p>The relative delta for non-zero parameters in
'pfeffer' method.</p>
</dd>
<dt>'-simplex0deltazero'</dt><dd><p>The absolute delta for non-zero parameters in
'pfeffer' method.</p>
</dd>
<dt>'-rho'</dt><dd><p>The reflection coefficient. This parameter is used when the
<code>method</code> element is set to 'fixed' or 'variable'.</p>
</dd>
<dt>'-chi'</dt><dd><p>The expansion coefficient. This parameter is used when the
<code>method</code> element is set to 'variable'.</p>
</dd>
<dt>'-gamma'</dt><dd><p>The contraction coefficient. This parameter is used when the
<code>method</code> element is set to 'variable'.</p>
</dd>
<dt>'-sigma'</dt><dd><p>The shrinkage coefficient. This parameter is used when the
<code>method</code> element is set to 'fixed' or 'variable'.</p>
</dd>
<dt>'-tolsimplexizemethod'</dt><dd><p>Set to FALSE to disable the tolerance on the
simplex size. If this criteria is triggered,
the status of the optimization is set to 'tolsize'. When this criteria is
enabled, the values of the <code>tolsimplexizeabsolute</code> and
<code>tolsimplexizerelative</code> elements are used in the termination
criteria. The method to compute the size is the 'sigmaplus' method.</p>
</dd>
<dt>'-tolsimplexizeabsolute'</dt><dd><p>The absolute tolerance on the simplex size.</p>
</dd>
<dt>'-tolsimplexizerelative'</dt><dd><p>The relative tolerance on the simplex size.</p>
</dd>
<dt>'-tolssizedeltafvmethod'</dt><dd><p>Set to TRUE to enable the termination
criteria based on the size of the simplex and the difference of function
value in the simplex. If this criteria is triggered, the status of the
optimization is set to 'tolsizedeltafv'. This termination criteria uses
the values of the <code>tolsimplexizeabsolute</code> and <code>toldeltafv</code>
elements.</p>
</dd></dl>
<p>option
</p>
<dl>
<dt>'-toldeltafv'</dt><dd><p>The absolute tolerance on the difference between the
highest and the lowest function values.</p>
</dd>
<dt>'-tolvarianceflag'</dt><dd><p>Set to TRUE to enable the termination criteria
based on the variance of the function value. If this criteria is
triggered, the status of the optimization is set to 'tolvariance'.
This criteria is suggested by Nelder and Mead.</p>
</dd>
<dt>'-tolabsolutevariance'</dt><dd><p>The absolute tolerance on the variance of the
function values of the simplex.</p>
</dd>
<dt>'-tolrelativevariance'</dt><dd><p>The relative tolerance on the variance of the
function values of the simplex.</p>
</dd>
<dt>'-kelleystagnationflag'</dt><dd><p>Set to TRUE to enable the termination
criteria using Kelley's stagnation detection, based on sufficient decrease
condition. If this criteria is triggered, the status of the optimization
is set to 'kelleystagnation'.</p>
</dd>
<dt>'-kelleynormalizationflag'</dt><dd><p>Set to FALSE to disable the normalization
of the alpha coefficient in Kelley's stagnation detection, i.e. use the
value of the <code>kelleystagnationalpha0</code> element as is. Default value is
TRUE, i.e. the simplex gradient of the initial simplex is takeoptionn into
account in the stagnation detection.</p>
</dd>
<dt>'-kelleystagnationalpha0'</dt><dd><p>The parameter used in Kelley's stagnation
detection.</p>
</dd>
<dt>'-restartflag'</dt><dd><p>Set to TRUE to enable the automatic restart of the
algorithm.</p>
</dd>
<dt>'-restartdetection'</dt><dd><p>The method to detect if the automatic restart
must be performed. The following methods are available:</p>

<dl>
<dt>'oneill'</dt><dd><p>The factorial local optimality test by O'Neill is used. If
the test finds a local point which is better than the computed optimum,
a restart is performed.</p>
</dd>
<dt>'kelley'</dt><dd><p>The sufficient decrease condition by O'Neill is used. If
the test finds that the status of the optimization is
'kelleystagnation', a restart is performed. This status may be generated
if the -kelleystagnationflag option is set to TRUE.</p>
</dd>
</dl>

</dd>
<dt>'-restartmax'</dt><dd><p>The maximum number of restarts, when automatic restart
is enabled via the -restartflag option.</p>
</dd>
<dt>'-restarteps'</dt><dd><p>The absolute epsilon value used to check for optimality
in the factorial O'Neill restart detection.</p>
</dd>
<dt>'-restartstep'</dt><dd><p>The absolute step length used to check for optimality
in the factorial O'Neill restart detection.</p>
</dd>
<dt>'-restartsimplexmethod'</dt><dd><p>The method to compute the initial simplex
after a restart. The following methods are available.</p>

<dl>
<dt>'given'</dt><dd><p>The coordinates associated with the <code>coords0</code> element
are used to compute the initial simplex, with arbitrary number of
vertices. This allow the user to setup the initial simplex by a specific
method which is not provided by the current package (for example with
a simplex computed from a design of experiments). This allows also to
configure the initial simplex so that a specific behaviour of the
algorithm is to be reproduced (for example the Mc Kinnon test case).
The given matrix is expected to have nbve rows and n columns, where n
is the dimension of the problem and nbve is the number of vertices.</p>
</dd>
<dt>'axes'</dt><dd><p>The simplex is computed from the coordinate axes and the
length associated with the -simplex0length option.</p>
</dd>
<dt>'spendley'</dt><dd><p>The simplex is computed so that it is regular with the
length associated with the -simplex0length option (i.e. all the edges
have the same length).</p>
</dd>
<dt>'pfeffer'</dt><dd><p>The simplex is computed from an heuristic, in the
neighborhood of the initial guess. This initial simplex depends on the
-simplex0deltausual and -simplex0deltazero.</p>
</dd>
<dt>'randbounds'</dt><dd><p>The simplex is computed from the bounds and a random
number. This option is available only if bounds are available: if
bounds are not available, an error is generated. This method is usually
associated with Box's algorithm. The number of vertices in the simplex
is taken from the -boxnbpoints option.</p>
</dd>
<dt>'oriented'</dt><dd><p>The simplex is computed so that it is oriented, as
suggested by Kelley.</p>
</dd>
</dl>

</dd>
<dt>'-scalingsimplex0'</dt><dd><p>The algorithm used to scale the initial simplex
into the nonlinear constraints. The following two algorithms are provided:
</p>

<dl>
<dt>'tox0'</dt><dd><p>scales the vertices toward the initial guess.</p>
</dd>
<dt>'tocentroid'</dt><dd><p>scales the vertices toward the centroid, as
recommended by Box.</p>
</dd>
</dl>

<p>If the centroid happens to be unfeasible, because the constraints are not
convex, the scaling of the initial simplex toward the centroid may fail.
Since the initial guess is always feasible, scaling toward the initial
guess cannot fail.</p>
</dd>
<dt>'-boxnbpoints'</dt><dd><p>The number of points in the initial simplex, when the
-simplex0method is set to 'randbounds'. The value of this option is also
use to update the simplex when a restart is performed and the
-restartsimplexmethod option is set to 'randbounds'. The default value is
so that the number of points is twice the number of variables of the
problem.</p>
</dd>
<dt>'-boxineqscaling'</dt><dd><p>The scaling coefficient used to scale the trial
point for function improvement or into the constraints of Box's
algorithm.</p>
</dd>
<dt>'-guinalphamin'</dt><dd><p>The minimum value of alpha when scaling the vertices
of the simplex into nonlinear constraints in Box's algorithm.</p>
</dd>
<dt>'-boxreflect'</dt><dd><p>The reflection factor in Box's algorithm.</p>
</dd>
<dt>'-boxtermination'</dt><dd><p>Set to TRUE to enable Box's termination criteria.</p>
</dd>
<dt>'-boxtolf'</dt><dd><p>The absolute tolerance on difference of function values in
the simplex, suggested by Box. This tolerance is used if the
-<code>boxtermination</code> element is set to TRUE.</p>
</dd>
<dt>'-boxnbmatch'</dt><dd><p>The number of consecutive match of Box's termination
criteria.</p>
</dd>
<dt>'-boxboundsalpha'</dt><dd><p>The parameter used to project the vertices into the
bounds in Box's algorithm.</p>
</dd>
<dt>'-mymethod'</dt><dd><p>A user-derined simplex algorithm. See
<code>vignette('neldermead',package='neldermead')</code> for details.</p>
</dd>
<dt>'-myterminate'</dt><dd><p>A user-defined terminate function. See
<code>vignette('neldermead',package='neldermead')</code> for details.</p>
</dd>
<dt>'-myterminateflag'</dt><dd><p>Set to TRUE to enable the user-defined terminate
function.</p>
</dd>
</dl>



<h3>Value</h3>

<p>An updated neldermead object.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab neldermead module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+neldermead">neldermead</a></code>
</p>

<hr>
<h2 id='optimget'>
Queries an optimization option list
</h2><span id='topic+optimget'></span>

<h3>Description</h3>

<p>This function allows to make queries on an existing optimization option list.
This list must have been created and updated by the <code>optimset</code> function.
The <code>optimget</code> allows to retrieve the value associated with a given key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimget(options = NULL, key = NULL, value = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimget_+3A_options">options</code></td>
<td>
<p>A list created or modifies by <code>optimset</code>.</p>
</td></tr>
<tr><td><code id="optimget_+3A_key">key</code></td>
<td>
<p>A single character string, which should be the name of the field in
<code>options</code> to query (case insensitive).</p>
</td></tr>
<tr><td><code id="optimget_+3A_value">value</code></td>
<td>
<p>A default value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>key</code> is matched against the field names of <code>options</code> using
<code>grep</code> and a case-insensitive regular expression. If <code>key</code> is not
found in <code>options</code>, the function returns NULL. If several matches are
found, <code>optimget</code> is stopped.
</p>


<h3>Value</h3>

<p>Return <code>options$key</code> if <code>key</code> is found in <code>options</code>. Return
<code>value</code>, otherwise.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab neldermead module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimset">optimset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  opt &lt;- optimset(method='fminsearch')
  optimget(opt,'Display')
  optimget(opt,'abc','!@')
</code></pre>

<hr>
<h2 id='optimset'>
Configures and returns an optimization data structure.
</h2><span id='topic+optimset'></span>

<h3>Description</h3>

<p>This function creates or updates a list which can be used to modify
the behaviour of optimization methods. The goal of this function is to manage
the <code>options</code> list with a set of fields (for example, 'MaxFunEvals',
'MaxIter', etc...). The user can create a new list with empty fields or
create a new structure with default fields which correspond to a particular
algorithm. The user can also configure each field and set it to a particular
value. Finally, the user passes the list to an optimization function so
that the algorithm uses the options configured by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimset(method = NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimset_+3A_method">method</code></td>
<td>
<p>If provided, the <code>method</code> calls the <code>optimset.method</code> 
function. If the content of <code>method</code> is recognized, a default set of 
options are returned. The only current recognized character strings are 
'fminsearch' and 'fminbnd'.</p>
</td></tr>
<tr><td><code id="optimset_+3A_...">...</code></td>
<td>
<p>Additional arguments which would be included in the options output
if the <code>method</code> argument is not used. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most optimization algorithms require many algorithmic parameters such as the
number of iterations or the number of function evaluations. If these
parameters are given to the optimization function as input parameters, this
forces both the user and the developer to manage many input parameters. The
goal of the <code>optimset</code> function is to simplify the management of input
arguments, by gathering all the parameters into a single list.
</p>
<p>While the current implementation of the <code>optimset</code> function only supports
the <code>fminsearch</code> and <code>fminbnd</code> function, it is designed to be 
extended to as many optimization function as required. Because all 
optimization algorithms do not require the same parameters, the data structure 
aims at remaining flexible. But, most of the time, most parameters are the 
same from algorithm to algorithm, for example, the tolerance parameters which 
drive the termination criteria are often the same, even if the termination 
criteria itself is not the same.
</p>
<p>Optimization parameters that are returned by the <code>optimset</code> function and
that can be defined in <code>...</code> are the following: </p>

<dl>
<dt>Display</dt><dd><p>The verbose level. The default value is 'notify'. The following
is a list of available verbose levels.</p>

<dl>
<dt>'off'</dt><dd><p>The algorithm displays no message at all.</p>
</dd>
<dt>'notify'</dt><dd><p>The algorithm displays message if the termination criteria
is not reached at the end of the optimization. This may happen if the
maximum number or iterations of the maximum number of function
evaluations is reached and warns the user of a convergence problem.</p>
</dd>
<dt>'final'</dt><dd><p>The algorithm displays a message at the end of the
optimization, showing the number of iterations, the number of function
evaluations and the status of the optimization. This option includes the
messages generated by the 'notify' option i.e. warns in case of a
convergence problem.</p>
</dd>
<dt>'iter'</dt><dd><p>The algorithm displays a one-line message at each iteration.
This option includes the messages generated by the 'notify' option i.e.
warns in case of a convergence problem. It also includes the message
generated by the 'final' option.</p>
</dd>
</dl>

</dd>
<dt>FunValCheck</dt><dd><p>A logical flag to enable the checking of function values.</p>
</dd>
<dt>MaxFunEvals</dt><dd><p>The maximum number of evaluations of the cost function.</p>
</dd>
<dt>MaxIter</dt><dd><p>The maximum number of iterations.</p>
</dd>
<dt>OutputFcn</dt><dd><p>A function which is called at each iteration to print out
intermediate state of the optimization algorithm (for example into a log
file).</p>
</dd>
<dt>PlotFcns</dt><dd><p>A function which is called at each iteration to plot the
intermediate state of the optimization algorithm (for example into a 2D
graphic).</p>
</dd>
<dt>TolFun</dt><dd><p>The absolute tolerance on function value.</p>
</dd>
<dt>TolX</dt><dd><p>The absolute tolerance on the variable x.</p>
</dd>
<dt>nbMatch</dt><dd><p>Specific to Box method: the number of consecutive times the 
<code>TolFun</code> criteria must be met to terminate the optimization.</p>
</dd>
<dt>boundsAlpha</dt><dd><p>Specific to Box method: the parameter used to project the 
vertices into the bounds in Box's algorithm</p>
</dd>
<dt>boxScaling</dt><dd><p>Specific to Box method: the scaling coefficient used to 
scale the trial point for function improvement or into the constraints of 
Box's algorithm</p>
</dd>
<dt>alphaMin</dt><dd><p>Specific to Box method: the minimum value of alpha when 
scaling the vertices of the simplex into nonlinear constraints in Box's 
algorithm</p>
</dd>
</dl>

<p><strong>Output and plot functions</strong>
The 'OutputFcn' and 'PlotFcns' options accept as argument a function (or a
list of functions). In the client optimization algorithm, this output or plot
function is called back once per iteration. It can be used by the user to
display a message in the console, write into a file, etc...
The output or plot function is expected to have the following definition:
</p>
<p>myfun &lt;- function(x, optimValues, state)
</p>
<p>where the input parameters are:</p>

<dl>
<dt>x</dt><dd><p>The current point estimate.</p>
</dd>
<dt>optimValues</dt><dd><p>A list which contains the following fields:</p>

<dl>
<dt>funccount</dt><dd><p>The number of function evaluations.</p>
</dd>
<dt>fval</dt><dd><p>The best function value.</p>
</dd>
<dt>iteration</dt><dd><p>The current iteration number.</p>
</dd>
<dt>procedure</dt><dd><p>The type of step performed. This string depends on the
specific algorithm (see <code>fminsearch</code> for details).</p>
</dd>
</dl>

</dd>
<dt>state</dt><dd><p>the state of the algorithm. The following states are
available:</p>

<dl>
<dt>'init'</dt><dd><p>when the algorithm is initializing,</p>
</dd>
<dt>'iter'</dt><dd><p>when the algorithm is performing iterations,</p>
</dd>
<dt>'done'</dt><dd><p>when the algorithm is terminated.</p>
</dd>
</dl>

</dd>
</dl>



<h3>Value</h3>

<p>Return a list with the following fields: Display, FunValCheck, MaxFunEvals,
MaxIter, OutputFcn, PlotFcns, TolFun, TolX, nbMatch, boundsAlpha, boxScaling, 
and alphaMin.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab neldermead module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimset.method">optimset.method</a></code>,<code><a href="#topic+fminsearch">fminsearch</a></code>, <code><a href="#topic+fminbnd">fminbnd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  optimset()
  optimset(Display='iter')
  optimset(method='fminbnd')
</code></pre>

<hr>
<h2 id='optimset.method'>
Default set of optimization options
</h2><span id='topic+optimset.method'></span>

<h3>Description</h3>

<p>This function returns a default set of optimization options for defined
'methods'; <code>optimset.method</code> is called by <code>optimset</code> when a
<code>method</code> was provided as input. Currently, the only valid <code>method</code>
is 'fminsearch'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimset.method(method = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimset.method_+3A_method">method</code></td>
<td>
<p>A character string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following fields: Display, FunValCheck, MaxFunEvals,
MaxIter, OutputFcn, PlotFcns, TolFun, and TolX.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab neldermead module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimset">optimset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  optimset.method('fminsearch')
  # Will fail
  try(optimset.method('abc'))
</code></pre>

<hr>
<h2 id='Secondary+20search+20functions'>
Secondary functions for neldermead.search
</h2><span id='topic+neldermead.startup'></span><span id='topic+neldermead.log'></span><span id='topic+neldermead.scaletox0'></span><span id='topic+neldermead.scaletocenter'></span><span id='topic+neldermead.termstartup'></span><span id='topic+neldermead.outputcmd'></span><span id='topic+neldermead.autorestart'></span><span id='topic+neldermead.istorestart'></span><span id='topic+neldermead.isroneill'></span><span id='topic+neldermead.isrkelley'></span><span id='topic+neldermead.updatesimp'></span><span id='topic+scaleinconstraints'></span><span id='topic+neldermead.costf'></span>

<h3>Description</h3>

<p>Utility functions for <code>neldermead.serch</code> and dependent functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  neldermead.startup(this = NULL)
  neldermead.log(this = NULL, msg = NULL)
  neldermead.scaletox0(this = NULL, simplex0 = NULL)
  neldermead.scaletocenter(this = NULL, simplex0 = NULL, x0 = NULL)
  neldermead.termstartup(this = NULL)
  neldermead.outputcmd(this = NULL, state = NULL, simplex = NULL, step = NULL)
  neldermead.autorestart(this = NULL)
  neldermead.istorestart(this = NULL)
  neldermead.isroneill(this = NULL)
  neldermead.isrkelley(this = this)
  neldermead.updatesimp(this = NULL)
  scaleinconstraints(this = NULL, x = NULL, xref = NULL)
  neldermead.costf(x = NULL, this = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Secondary+2B20search+2B20functions_+3A_this">this</code></td>
<td>
<p>A neldermead object.</p>
</td></tr>
<tr><td><code id="Secondary+2B20search+2B20functions_+3A_msg">msg</code></td>
<td>
<p>A character string.</p>
</td></tr>
<tr><td><code id="Secondary+2B20search+2B20functions_+3A_simplex0">simplex0</code></td>
<td>
<p>The initial simplex object.</p>
</td></tr>
<tr><td><code id="Secondary+2B20search+2B20functions_+3A_x0">x0</code></td>
<td>
<p>A column matrix of initial parameters.</p>
</td></tr>
<tr><td><code id="Secondary+2B20search+2B20functions_+3A_state">state</code></td>
<td>
<p>The state of the algorithm, either 'init', 'done' or 'iter'.</p>
</td></tr>
<tr><td><code id="Secondary+2B20search+2B20functions_+3A_simplex">simplex</code></td>
<td>
<p>The current simplex object.</p>
</td></tr>
<tr><td><code id="Secondary+2B20search+2B20functions_+3A_step">step</code></td>
<td>
<p>The type of step performed during the iteration: 'init', 'done',
'reflection', 'expansion', 'insidecontraction', 'outsidecontraction',
'reflectionnext' or 'shrink'.</p>
</td></tr>
<tr><td><code id="Secondary+2B20search+2B20functions_+3A_x">x</code></td>
<td>
<p>The point estimate to scale.</p>
</td></tr>
<tr><td><code id="Secondary+2B20search+2B20functions_+3A_xref">xref</code></td>
<td>
<p>The reference point estimate.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>neldermead.startup</code></dt><dd><p>Startup the algorithm. Compute the
initial simplex, depending on the content of the <code>simplex0method</code>
element of the neldermead object ('given', 'axes', 'spendley', 'pfeffer' or
'randbounds').</p>
</dd>
<dt><code>neldermead.log</code></dt><dd><p>Print a message to the log file using
<code>optimbase.log</code>.</p>
</dd>
<dt><code>neldermead.scaletox0</code></dt><dd><p>Scale the simplex into the nonlinear
inequality constraints, if any. Scale toward x0, which is feasible.</p>
</dd>
<dt><code>neldermead.scaletocenter</code></dt><dd><p>Scale the simplex into the nonlinear
inequality constraints, if any. Scale to the centroid of the points which
satisfy the constraints. This is Box's method for scaling. It is unsure,
since the centroid of the points which satisfy the constraints may not
be feasible.</p>
</dd>
<dt><code>neldermead.termstartup</code></dt><dd><p>Initialize Kelley's stagnation detection
system when normalization is required, by computing kelleyalpha. If the
simplex gradient is zero, then use alpha0 as alpha.</p>
</dd>
<dt><code>neldermead.outputcmd</code></dt><dd><p>Call the array of user-defined output
functions</p>
</dd>
<dt><code>neldermead.autorestart</code></dt><dd><p>Perform an optimization with automatic
restart. The loop processes for i = 1 to <code>restartmax</code> + 1. This is
because a RE-start is performed after one simulation has been performed,
hence the 'RE'.</p>
</dd>
<dt><code>neldermead.istorestart</code></dt><dd><p>Determine if the optimization is to
restart using <code>neldermead.isroneill</code> or <code>neldermead.isrkelley</code>
depending on the content of the <code>restartdetection</code> element.</p>
</dd>
<dt><code>neldermead.isroneill</code></dt><dd><p>Determine if the optimization is to
restart. Use O'Neill method as a criteria for restart. It is an axis-by-axis
search for optimality.</p>
</dd>
<dt><code>neldermead.isrkelley</code></dt><dd><p>Determine if the optimization is to
restart. Use <code>kelleystagnation</code> as a criteria for restart.</p>
</dd>
<dt><code>neldermead.updatesimp</code></dt><dd><p>Update the initial simplex simplex0 for a
restart.</p>
</dd>
<dt><code>scaleinconstraints</code></dt><dd><p>Given a point reference to scale and a
reference point which satisfies the constraints, scale the point
towards the reference point estimate until it satisfies all the
constraints.</p>
</dd>
<dt><code>neldermead.costf</code></dt><dd><p>Call the cost function and return the value.
This function is given to the simplex function class as a callback.
Input/Output arguments are swapped w.r.t. <code>optimbase.function</code>, so that
it matches the requirements of simplex methods.</p>
</dd>
</dl>



<h3>Value</h3>


<dl>
<dt><code>neldermead.startup</code></dt><dd><p>Return an updated neldermead object
<code>this</code>.</p>
</dd>
<dt><code>neldermead.log</code></dt><dd><p>Return the neldermead object <code>this</code>.</p>
</dd>
<dt><code>neldermead.scaletox0</code></dt><dd><p>Return an updated simplex.</p>
</dd>
<dt><code>neldermead.scaletocenter</code></dt><dd><p>Return an updated simplex.</p>
</dd>
<dt><code>neldermead.termstartup</code></dt><dd><p>Return an updated neldermead object
<code>this</code>.</p>
</dd>
<dt><code>neldermead.outputcmd</code></dt><dd><p>Do not return any data, but execute the
output function(s).</p>
</dd>
<dt><code>neldermead.autorestart</code></dt><dd><p>Return an updated neldermead object
<code>this</code>.</p>
</dd>
<dt><code>neldermead.istorestart</code></dt><dd><p>Return a list with the following
elements:</p>

<dl>
<dt>this</dt><dd><p>The input neldermead object.</p>
</dd>
<dt>istorestart</dt><dd><p>Set to TRUE if the optimization is to restart, to FALSE
otherwise.</p>
</dd>
</dl>

</dd>
<dt><code>neldermead.isroneill</code></dt><dd><p>Return a list with the following elements:
</p>

<dl>
<dt>this</dt><dd><p>The input neldermead object.</p>
</dd>
<dt>istorestart</dt><dd><p>Set to TRUE if the optimization is to restart, to FALSE
otherwise.</p>
</dd>
</dl>

</dd>
<dt><code>neldermead.isrkelley</code></dt><dd><p>Return a list with the following elements:
</p>

<dl>
<dt>this</dt><dd><p>The input neldermead object.</p>
</dd>
<dt>istorestart</dt><dd><p>Set to TRUE if the optimization is to restart, to FALSE
otherwise.</p>
</dd>
</dl>

</dd>
<dt><code>neldermead.updatesimp</code></dt><dd><p>Return an updated neldermead object
<code>this</code>.</p>
</dd>
<dt><code>scaleinconstraints</code></dt><dd><p>Return a list with the following elements:
</p>

<dl>
<dt>this</dt><dd><p>The updated neldermead object.</p>
</dd>
<dt>isscaled</dt><dd><p>TRUE if the procedure has succeeded before
<code>boxnbnlloops</code>, FALSE if it has failed.</p>
</dd>
<dt>p</dt><dd><p>The scaled parameters.</p>
</dd>
</dl>

</dd>
<dt><code>neldermead.costf</code></dt><dd><p>Return a list with the following elements:
</p>

<dl>
<dt>f</dt><dd><p>The value of the cost function.</p>
</dd>
<dt>this</dt><dd><p>The updated neldermead object.</p>
</dd>
</dl>

</dd>
</dl>



<h3>Author(s)</h3>

<p>Author of Scilab neldermead module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
