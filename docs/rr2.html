<!DOCTYPE html><html lang="en"><head><title>Help for package rr2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rr2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rr2'><p>rr2: An R package to calculate R2s for regression models</p></a></li>
<li><a href='#binaryPGLMM'><p>Phylogenetic GLM for binary data</p></a></li>
<li><a href='#inv.logit'><p>Invert logit function</p></a></li>
<li><a href='#partialR2'><p>Partial R2</p></a></li>
<li><a href='#partialR2adj'><p>Adjusted partial R2</p></a></li>
<li><a href='#R2'><p>Calculate R2_lik, R2_resid, and R2_pred</p></a></li>
<li><a href='#R2_lik'><p>Calculate R2_lik</p></a></li>
<li><a href='#R2_pred'><p>Calculate R2_pred</p></a></li>
<li><a href='#R2_resid'><p>Calculate R2_resid</p></a></li>
<li><a href='#transf_phy'><p>Transform a phylogeny based on a phylolm model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>R2s for Regression Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Three methods to calculate R2 for models with correlated errors, 
    including Phylogenetic GLS, Phylogenetic Logistic Regression, Linear Mixed 
    Models (LMMs), and Generalized Linear Mixed Models (GLMMs). See details in 
    Ives 2018 &lt;<a href="https://doi.org/10.1093%2Fsysbio%2Fsyy060">doi:10.1093/sysbio/syy060</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0), stats</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>lme4, phylolm (&ge; 2.6.2), ape, utils, Matrix, nlme, phyr (&ge;
1.0.3)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, mvtnorm</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/arives/rr2">https://github.com/arives/rr2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/arives/rr2/issues">https://github.com/arives/rr2/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 13:34:14 UTC; arives</td>
</tr>
<tr>
<td>Author:</td>
<td>Anthony Ives [aut, cre],
  Daijiang Li [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anthony Ives &lt;arives@wisc.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 14:20:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='rr2'>rr2: An R package to calculate R2s for regression models</h2><span id='topic+rr2'></span><span id='topic+rr2-package'></span>

<h3>Description</h3>

<p>The rr2 package provides methods to calculate R2 for models with correlated errors, 
including Phylogenetic GLS, Phylogenetic Logistic Regression, LMMs, GLMM, and PGLMM.
</p>

<hr>
<h2 id='binaryPGLMM'>Phylogenetic GLM for binary data</h2><span id='topic+binaryPGLMM'></span>

<h3>Description</h3>

<p>Fitting phylogenetic generalized linear models for binary data (0 and 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binaryPGLMM(
  formula,
  data = list(),
  phy,
  s2.init = 0.1,
  B.init = NULL,
  tol.pql = 10^-6,
  maxit.pql = 200,
  maxit.reml = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binaryPGLMM_+3A_formula">formula</code></td>
<td>
<p>Regression formula.</p>
</td></tr>
<tr><td><code id="binaryPGLMM_+3A_data">data</code></td>
<td>
<p>Data frame to fit the model with.</p>
</td></tr>
<tr><td><code id="binaryPGLMM_+3A_phy">phy</code></td>
<td>
<p>Phylogenetic tree of type phylo with branch lengths.</p>
</td></tr>
<tr><td><code id="binaryPGLMM_+3A_s2.init">s2.init</code></td>
<td>
<p>Initial variance values for random terms, default is 0.1.</p>
</td></tr>
<tr><td><code id="binaryPGLMM_+3A_b.init">B.init</code></td>
<td>
<p>Initial coefficient values for fixed terms, if not provided, will use those from <code>lm</code>.</p>
</td></tr>
<tr><td><code id="binaryPGLMM_+3A_tol.pql">tol.pql</code></td>
<td>
<p>Tolerance value, default is 10^-6.</p>
</td></tr>
<tr><td><code id="binaryPGLMM_+3A_maxit.pql">maxit.pql</code></td>
<td>
<p>The number of iterations, default is 200.</p>
</td></tr>
<tr><td><code id="binaryPGLMM_+3A_maxit.reml">maxit.reml</code></td>
<td>
<p>The number of iterations for optim, default is 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A large list with class as <code>binaryPGLMM</code>.
</p>

<hr>
<h2 id='inv.logit'>Invert logit function</h2><span id='topic+inv.logit'></span>

<h3>Description</h3>

<p>Convert numeric values between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv.logit(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inv.logit_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>

<hr>
<h2 id='partialR2'>Partial R2</h2><span id='topic+partialR2'></span>

<h3>Description</h3>

<p>Get partial R2 by comparing a model and its reduced model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partialR2(mod, mod.r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partialR2_+3A_mod">mod</code></td>
<td>
<p>A linear regression model.</p>
</td></tr>
<tr><td><code id="partialR2_+3A_mod.r">mod.r</code></td>
<td>
<p>A reduced model based on <code>mod</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>R2 value between 0 and 1.
</p>

<hr>
<h2 id='partialR2adj'>Adjusted partial R2</h2><span id='topic+partialR2adj'></span>

<h3>Description</h3>

<p>Get adjusted partial R2 by comparing a model and its reduced model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partialR2adj(
  mod,
  df.f = summary(mod)$df[1],
  mod.r,
  df.r = summary(mod.r)$df[1]
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partialR2adj_+3A_mod">mod</code></td>
<td>
<p>A linear regression model.</p>
</td></tr>
<tr><td><code id="partialR2adj_+3A_df.f">df.f</code></td>
<td>
<p>Degree of freedom of the <code>mod</code>.</p>
</td></tr>
<tr><td><code id="partialR2adj_+3A_mod.r">mod.r</code></td>
<td>
<p>A reduced model based on <code>mod</code>.</p>
</td></tr>
<tr><td><code id="partialR2adj_+3A_df.r">df.r</code></td>
<td>
<p>Degree of freedom of the reduced <code>mod.r</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of both R2 and adjusted R2 , the latter is not necessary to be between 0 and 1.
</p>

<hr>
<h2 id='R2'>Calculate R2_lik, R2_resid, and R2_pred</h2><span id='topic+R2'></span>

<h3>Description</h3>

<p>This is a wrapper for calculating three R2s &ndash; R2_lik, R2_resid, and R2_pred &ndash; for LMMs and GLMMs, and phylogenetic LMMs (PLMMs) and GLMMs (PGLMMs). Note that the individual functions <code>R2_lik()</code>, <code>R2_resid()</code>, and <code>R2_pred()</code> can be called separately. This is preferrable if you are only interested in one R2; for example, for <code>phylolm()</code> called from &lsquo;R2' you need to specify &rsquo;phy' (phylo object for the phylogeny), while <code>R2_lik()</code> does not require this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R2(
  mod = NULL,
  mod.r = NULL,
  phy = NULL,
  sigma2_d = c("s2w", "NS", "rNS"),
  lik = TRUE,
  resid = TRUE,
  pred = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R2_+3A_mod">mod</code></td>
<td>
<p>A regression model with one of the following classes: 'lm', 'glm', lmerMod', glmerMod', 'phylolm', 'gls', 'pglmm', 'pglmm_compare', binaryPGLMM', or 'communityPGLMM'.</p>
</td></tr>
<tr><td><code id="R2_+3A_mod.r">mod.r</code></td>
<td>
<p>A reduced model; if not provided, the total R2 will be given by setting 'mod.r' to the model corresponding to 'mod' with the intercept as the only predictor.</p>
</td></tr>
<tr><td><code id="R2_+3A_phy">phy</code></td>
<td>
<p>The phylogeny for phylogenetic models (as a 'phylo' object), which is not required to be specified for <code>R2_lik()</code> or non-phylogenetic models.</p>
</td></tr>
<tr><td><code id="R2_+3A_sigma2_d">sigma2_d</code></td>
<td>
<p>Distribution-specific variance <code class="reqn">\sigma^2_d</code> (see Details) used in <code>R2_resid()</code>. For binomial GLMs, GLMMs and PGLMMs with logit link functions, options are c('s2w', 'NS', 'rNS'). For binomial GLMs, GLMMs and PGLMMs with probit link functions, options are c('s2w', 'NS'). Other families use 's2w'.</p>
</td></tr>
<tr><td><code id="R2_+3A_lik">lik</code></td>
<td>
<p>Whether to calculate R2_lik; default is TRUE.</p>
</td></tr>
<tr><td><code id="R2_+3A_resid">resid</code></td>
<td>
<p>Whether to calculate R2_resid; default is TRUE.</p>
</td></tr>
<tr><td><code id="R2_+3A_pred">pred</code></td>
<td>
<p>Whether to calculate R2_pred; default is TRUE.</p>
</td></tr>
<tr><td><code id="R2_+3A_...">...</code></td>
<td>
<p>Additional arguments for 'R2_pred()'. 'gaussian.pred = &quot;tip_rm&quot;' or 'gaussian.pred = &quot;nearest_node&quot;'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details about the methods are provided under the separate functions for <code>R2_lik()</code>, <code>R2_resid()</code>, and <code>R2_pred()</code>. There are also many worked examples.
</p>


<h3>Value</h3>

<p>A vector, with all three R2s by default.
</p>


<h3>Author(s)</h3>

<p>Daijiang Li and Anthony R. Ives
</p>


<h3>References</h3>

<p>Ives A.R. and Li D. 2018. rr2: An R package to calculate R2s for regression models. Journal of Open Source Software. DOI:10.21105/joss.01028
</p>
<p>Ives A.R. 2018. R2s for Correlated Data: Phylogenetic Models, LMMs, and GLMMs. Systematic Biology, Volume 68, Issue 2, March 2019, Pages 234-251. DOI:10.1093/sysbio/syy060
</p>


<h3>See Also</h3>

<p>MuMIn, lme4, ape, phylolm, phyr, pez
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
library(phylolm)
library(lme4)
library(nlme)
library(phyr)

set.seed(12345)
p1 &lt;- 10
nsample &lt;- 10
n &lt;- p1 * nsample

d &lt;- data.frame(x1 = 0, x2 = 0, u1 = rep(1:p1, each = nsample),
                u2 = rep(1:p1, times = nsample))
d$u1 &lt;- as.factor(d$u1)
d$u2 &lt;- as.factor(d$u2)

b1 &lt;- 1
b2 &lt;- -1
sd1 &lt;- 1.5

d$x1 &lt;- rnorm(n = n)
d$x2 &lt;- rnorm(n = n)
d$y.lmm &lt;- b1 * d$x1 + b2 * d$x2 + 
  rep(rnorm(n = p1, sd = sd1), each = nsample) +
  rep(rnorm(n = p1, sd = sd1), times = nsample) + 
  rnorm(n = n)

prob &lt;- inv.logit(b1 * d$x1 + rep(rnorm(n = p1, sd = sd1), each = nsample))
d$y.glmm &lt;- rbinom(n = n, size = 1, prob = prob)

# LMM with two fixed and two random effects ----
z.f &lt;- lmer(y.lmm ~ x1 + x2 + (1 | u1) + (1 | u2), data = d, REML = FALSE)
z.x &lt;- lmer(y.lmm ~ x1 + (1 | u1) + (1 | u2), data = d, REML = FALSE)
z.v &lt;- lmer(y.lmm ~ 1 + (1 | u2), data = d, REML = FALSE)
z.0 &lt;- lm(y.lmm ~ 1, data = d)

R2(z.f, z.x)
R2(z.f, z.v)
R2(z.f)

# GLMM with one fixed and one random effect ----
z.f &lt;- glmer(y.glmm ~ x1 + (1 | u1), data = d, family = 'binomial')
z.x &lt;- glmer(y.glmm ~ 1 + (1 | u1), data = d, family = 'binomial')
z.v &lt;- glm(y.glmm ~ x1, data = d, family = 'binomial')

R2(z.f, z.x)
R2(z.f, z.v)
R2(z.f)

# These give different results for R2_resid.
R2(z.f, sigma2_d = 's2w')
R2(z.f, sigma2_d = 'NS')
R2(z.f, sigma2_d = 'rNS')

# GLS {nlme} with one fixed effect and autocorrelated errors among 6 groups ----
nT &lt;- 10
nseries &lt;- 6
n &lt;- nT * nseries

d &lt;- data.frame(x = 0, y = 0, u = rep(1:nseries, each = nT), e = rnorm(1))
d$u &lt;- as.factor(d$u)
d$x &lt;- rnorm(n = n)
ar1 &lt;- .5
for(t in 2:n) d$e[t] &lt;- ar1*d$e[t-1] + rnorm(1)

b1 &lt;- 1
d$y &lt;- b1 * d$x + d$e

z.f &lt;- gls(y ~ x + u, correlation = corAR1(form = ~1 | u), data = d)
z.x &lt;- gls(y ~ 1, correlation = corAR1(form = ~1 | u), data = d)
z.ar &lt;- lm(y ~ x + u, data = d)

R2(z.f, z.x)
R2(z.f, z.ar)
R2(z.f)

# PGLS with a single fixed effect ----
n &lt;- 100
d &lt;- data.frame(x = rep(0, n), y = 0)

b1 &lt;- 1.5
signal &lt;- 0.7

phy &lt;- compute.brlen(rtree(n = n), method = 'Grafen', power = 1)
phy.x &lt;- compute.brlen(phy, method = 'Grafen', power = .0001)

# Generate random data
x &lt;- rTraitCont(phy.x, model = 'BM', sigma = 1)
e &lt;- signal ^ 0.5 * rTraitCont(phy, model = 'BM', sigma = 1) +
  (1 - signal) ^ 0.5 * rnorm(n = n)
d$x &lt;- x[match(names(e), names(x))]
d$y &lt;- b1 * x + e
rownames(d) &lt;- phy$tip.label
d$sp &lt;- phy$tip.label

# Fit with phylolm() in {phylolm}
z.f &lt;- phylolm(y ~ x, phy = phy, data = d, model = 'lambda')
z.x &lt;- phylolm(y ~ 1, phy = phy, data = d, model = 'lambda')
z.v &lt;- lm(y ~ x, data = d)

R2(z.f, z.x, phy = phy)
R2(z.f, z.v, phy = phy)
R2(z.f, phy = phy)

# These data can also be fit with pglmm_compare in {phyr}
# Note that pglmm_compare will be renamed to pglmm_compare in the next version
z.f &lt;- pglmm_compare(y ~ x, data = d, phy = phy, REML=FALSE)
z.x &lt;- pglmm_compare(y ~ 1, data = d, phy = phy, REML=FALSE)
z.v &lt;- glm(y ~ x, data = d)

R2(z.f, z.x)
R2(z.f, z.v)
R2(z.f)

# This also works for models fit with gls() in {nlme}
z.f &lt;- gls(y ~ x, data = d, correlation = corPagel(1, phy, form = ~sp), method = "ML")
z.x &lt;- gls(y ~ 1, data = d, correlation = corPagel(1, phy, form = ~sp), method = "ML")
z.v &lt;- lm(y ~ x, data = d)

R2(z.f, z.x)
R2(z.f, z.v)
R2(z.f)

# But note that you need to define weights for gls() with non-ultrametric trees;
# if not, you will get a error from R2_resid,  "Matrix is not block-diagonal"

phy.nu &lt;- rtree(n = n)
# Generate random data
e &lt;- signal ^ 0.5 * rTraitCont(phy.nu, model = 'BM', sigma = 1) +
  (1 - signal) ^ 0.5 * rnorm(n = n)
d$x &lt;- x[match(names(e), names(x))]
d$y &lt;- b1 * x + e
rownames(d) &lt;- phy.nu$tip.label
d$sp &lt;- phy.nu$tip.label

weights &lt;- diag(vcv.phylo(phy.nu))
z.f &lt;- gls(y ~ x, data = d,
           correlation = corPagel(1, phy.nu, form = ~sp),
           weights = varFixed(~weights), method = "ML")
z.x &lt;- gls(y ~ 1, data = d,
           correlation = corPagel(1, phy.nu, form = ~sp),
           weights = varFixed(~weights), method = "ML")
z.v &lt;- lm(y ~ x, weights = 1/weights, data = d)

R2(z.f, z.x)
R2(z.f, z.v)
R2(z.f)

# PGLMM with one fixed effect ----
n &lt;- 100
b1 &lt;- 1.5
signal &lt;- 2

phy &lt;- compute.brlen(rtree(n = n), method = 'Grafen', power = 1)
phy.x &lt;- compute.brlen(phy, method = 'Grafen', power = .0001)

# Generate random data
x &lt;- rnorm(n)
d &lt;- data.frame(x = x, y = 0)

e &lt;- signal * rTraitCont(phy, model = 'BM', sigma = 1)
e &lt;- e[match(phy$tip.label, names(e))]

d$y &lt;- rbinom(n = n, size = 1, prob = inv.logit(b1 * d$x + e))
rownames(d) &lt;- phy$tip.label
# Use the function phyloglm() from the phylolm package.
z.f &lt;- phyloglm(y ~ x, data = d, start.alpha = 1, phy = phy)
z.x &lt;- phyloglm(y ~ 1, data = d, phy = phy, start.alpha = min(20, z.f$alpha))
z.v &lt;- glm(y ~ x, data = d, family = 'binomial')

R2(z.f, z.x)
R2(z.f, z.v)
R2(z.f)

# Use the function pglmm_compare() from the phyr package. Note that this is a 
# different model from phyloglm()
z.f &lt;- pglmm_compare(y ~ x, data = d, family = 'binomial', phy = phy, REML = FALSE)
z.x &lt;- pglmm_compare(y ~ 1, data = d, family = 'binomial', phy = phy, REML = FALSE)
z.v &lt;- glm(y ~ x, data = d, family = 'binomial')

R2(z.f, z.x)
R2(z.f, z.v)
R2(z.f)

# A community example of pglmm {phyr} ----
library(mvtnorm)
nspp &lt;- 6
nsite &lt;- 4

# Simulate a phylogeny that has a lot of phylogenetic signal (power = 1.3)
phy &lt;- compute.brlen(rtree(n = nspp), method = "Grafen", power = 1.3)

# Simulate species means
sd.sp &lt;- 1
mean.sp &lt;- rTraitCont(phy, model = "BM", sigma=sd.sp ^ 2)

# Replicate values of mean.sp over sites
Y.sp &lt;- rep(mean.sp, times = nsite)

# Simulate site means
sd.site &lt;- 1
mean.site &lt;- rnorm(nsite, sd = sd.site)

# Replicate values of mean.site over sp
Y.site &lt;- rep(mean.site, each = nspp)

# Compute a covariance matrix for phylogenetic attraction
sd.attract &lt;- 1
Vphy &lt;- vcv(phy)

# Standardize the phylogenetic covariance matrix to have determinant = 1.
# (For an explanation of this standardization, see subsection 4.3.1 in Ives (2018))
Vphy &lt;- Vphy/(det(Vphy)^(1/nspp))

# Construct the overall covariance matrix for phylogenetic attraction.
# (For an explanation of Kronecker products, see subsection 4.3.1 in the book)
V &lt;- kronecker(diag(nrow = nsite, ncol = nsite), Vphy)
Y.attract &lt;- array(t(rmvnorm(n = 1, sigma = sd.attract^2*V)))

# Simulate residual errors
sd.e &lt;- 1
Y.e &lt;- rnorm(nspp * nsite, sd = sd.e)

# Construct the dataset
d &lt;- data.frame(sp = rep(phy$tip.label, times = nsite), site = rep(1:nsite, each = nspp))

# Simulate abundance data
d$Y &lt;- Y.sp + Y.site + Y.attract + Y.e

# Full and reduced models
z.f &lt;- pglmm(Y ~ 1 + (1|sp__) + (1|site) + (1|sp__@site),
             data = d, cov_ranef = list(sp = phy), REML = FALSE)
z.nested &lt;- pglmm(Y ~ 1 + (1|sp__) + (1|site),
                  data = d, cov_ranef = list(sp = phy), REML = FALSE)
z.sp &lt;- pglmm(Y ~ 1 + (1|sp) + (1|site),
              data = d, cov_ranef = list(sp = phy), REML = FALSE)

R2(z.f, z.nested)
R2(z.nested, z.sp)
R2(z.f)
</code></pre>

<hr>
<h2 id='R2_lik'>Calculate R2_lik</h2><span id='topic+R2_lik'></span>

<h3>Description</h3>

<p>Calculate partial and total R2s for LMM, GLMM, PGLS, and PGLMM using R2_lik, 
an R2 based on the likelihood of the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R2_lik(mod = NULL, mod.r = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R2_lik_+3A_mod">mod</code></td>
<td>
<p>A regression model with one of the following classes: 'lm', 'glm', 
'lmerMod', 'glmerMod', 'phylolm', 'phyloglm', 'gls', 'pglmm', pglmm_compare' 
or 'communityPGLMM'.</p>
</td></tr>
<tr><td><code id="R2_lik_+3A_mod.r">mod.r</code></td>
<td>
<p>A reduced model; if not provided, the total R2 will be given by 
setting 'mod.r' to the model corresponding to 'mod' with the intercept as 
the only predictor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>R2_lik()</code> is implemented as
</p>
<p style="text-align: center;"><code class="reqn">partial R2 = 1 - exp(-2/n * (logLik(mod.f) - logLik(mod.r)))</code>
</p>

<p>where 'mod.f' and 'mod.r' are the full and reduced models, respectively. The total 
R2 is given when 'mod.r' is the model corresponding to mod.f that contains only 
the intercept. For GLMMs and PGLMMs, <code>R2_lik()</code> is standardized to have a 
maximum of one following Nagelkerke (1991). Although you can use R2_lik with 
models fit with REML, you really shouldn't, because this makes it impossible 
to compare values when reduced models differ in independent variables (fixed effects).
</p>
<p><code>R2_lik()</code> is also computed for LMMs and GLMMs in the MuMIn package.
</p>


<h3>Value</h3>

<p>R2_lik value.
</p>


<h3>Author(s)</h3>

<p>Anthony R. Ives
</p>


<h3>References</h3>

<p>Ives A.R. and Li D. 2018. rr2: An R package to calculate R2s for regression models. Journal of Open Source Software. DOI:10.21105/joss.01028
</p>
<p>Ives A.R. 2018. R2s for Correlated Data: Phylogenetic Models, LMMs, and GLMMs. Systematic Biology, Volume 68, Issue 2, March 2019, Pages 234-251. DOI:10.1093/sysbio/syy060
</p>
<p>Nagelkerke 1991. A note on a general definition of the coefficient of determination. Biometrika 78:691–692.
</p>


<h3>See Also</h3>

<p>MuMIn, lme4, ape, phylolm, phyr, pez
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
library(phylolm)
library(lme4)
library(nlme)
library(phyr)

set.seed(12345)
p1 &lt;- 10
nsample &lt;- 10
n &lt;- p1 * nsample

d &lt;- data.frame(x1 = 0, x2 = 0, u1 = rep(1:p1, each = nsample),
                u2 = rep(1:p1, times = nsample))
d$u1 &lt;- as.factor(d$u1)
d$u2 &lt;- as.factor(d$u2)

b1 &lt;- 1
b2 &lt;- -1
sd1 &lt;- 1.5

d$x1 &lt;- rnorm(n = n)
d$x2 &lt;- rnorm(n = n)
d$y.lmm &lt;- b1 * d$x1 + b2 * d$x2 + 
  rep(rnorm(n = p1, sd = sd1), each = nsample) +
  rep(rnorm(n = p1, sd = sd1), times = nsample) + 
  rnorm(n = n)

prob &lt;- inv.logit(b1 * d$x1 + rep(rnorm(n = p1, sd = sd1), each = nsample))
d$y.glmm &lt;- rbinom(n = n, size = 1, prob = prob)

# LMM with two fixed and two random effects ----
z.f &lt;- lmer(y.lmm ~ x1 + x2 + (1 | u1) + (1 | u2), data = d, REML = FALSE)
z.x &lt;- lmer(y.lmm ~ x1 + (1 | u1) + (1 | u2), data = d, REML = FALSE)
z.v &lt;- lmer(y.lmm ~ 1 + (1 | u2), data = d, REML = FALSE)
z.0 &lt;- lm(y.lmm ~ 1, data = d)

R2_lik(z.f, z.x)
R2_lik(z.f, z.v)
R2_lik(z.f)

# GLMM with one fixed and one random effect ----
z.f &lt;- glmer(y.glmm ~ x1 + (1 | u1), data = d, family = 'binomial')
z.x &lt;- glmer(y.glmm ~ 1 + (1 | u1), data = d, family = 'binomial')
z.v &lt;- glm(y.glmm ~ x1, data = d, family = 'binomial')

R2_lik(z.f, z.x)
R2_lik(z.f, z.v)
R2_lik(z.f)

# PGLS with a single fixed effect ----
n &lt;- 100
d &lt;- data.frame(x = array(0, dim = n), y = 0)

b1 &lt;- 1.5
signal &lt;- 0.5

phy &lt;- compute.brlen(rtree(n = n), method = 'Grafen', power = 1)
phy.x &lt;- compute.brlen(phy, method = 'Grafen', power = .0001)

# Generate random data
x &lt;- rTraitCont(phy.x, model = 'BM', sigma = 1)
e &lt;- signal^0.5 * rTraitCont(phy, model = 'BM', sigma = 1) + (1-signal)^0.5 * rnorm(n = n)
d$x &lt;- x[match(names(e), names(x))]
d$y &lt;- b1 * x + e
rownames(d) &lt;- phy$tip.label
d$sp &lt;- phy$tip.label

z.f &lt;- pglmm_compare(y ~ x, data = d, phy = phy, REML=FALSE)
z.x &lt;- pglmm_compare(y ~ 1, data = d, phy = phy, REML=FALSE)
z.v &lt;- glm(y ~ x, data = d)

R2_lik(z.f, z.x)
R2_lik(z.f, z.v)
R2_lik(z.f)

# These data can also be fit with phylolm() in {phylolm}
z.f &lt;- phylolm(y ~ x, phy = phy, data = d, model = 'lambda')
z.x &lt;- phylolm(y ~ 1, phy = phy, data = d, model = 'lambda')
z.v &lt;- lm(y ~ x, data = d)

R2_lik(z.f, z.x)
R2_lik(z.f, z.v)
R2_lik(z.f)

# This also works for models fit with gls() in {nlme}
z.f &lt;- gls(y ~ x, data = d, correlation = corPagel(1, phy, form = ~sp), method = "ML")
z.x &lt;- gls(y ~ 1, data = d, correlation = corPagel(1, phy, form = ~sp), method = "ML")
z.v &lt;- lm(y ~ x, data = d)

R2_lik(z.f, z.x)
R2_lik(z.f, z.v)
R2_lik(z.f)

# PGLMM with one fixed effect ----
n &lt;- 100
b1 &lt;- 1.5
signal &lt;- 2

phy &lt;- compute.brlen(rtree(n = n), method = 'Grafen', power = 1)
phy.x &lt;- compute.brlen(phy, method = 'Grafen', power = .0001)

# Generate random data
x &lt;- rnorm(n)
d &lt;- data.frame(x = x, y = 0)

e &lt;- signal * rTraitCont(phy, model = 'BM', sigma = 1)
e &lt;- e[match(phy$tip.label, names(e))]

d$y &lt;- rbinom(n = n, size = 1, prob = inv.logit(b1 * d$x + e))
rownames(d) &lt;- phy$tip.label

z.f &lt;- phyloglm(y ~ x, data = d, start.alpha = 1, phy = phy)
z.x &lt;- phyloglm(y ~ 1, data = d, phy = phy, start.alpha = min(20, z.f$alpha))
z.v &lt;- glm(y ~ x, data = d, family = 'binomial')

R2_lik(z.f, z.x)
R2_lik(z.f, z.v)
R2_lik(z.f)

# These data can also be fit with pglmm_compare(), although note that 
# this is a different model from phyloglm()

z.f &lt;- pglmm_compare(y ~ x, data = d, family = "binomial", phy = phy, REML=FALSE)
z.x &lt;- pglmm_compare(y ~ 1, data = d, family = "binomial", phy = phy, REML=FALSE)
z.v &lt;- glm(y ~ x, data = d, family = "binomial")

R2_lik(z.f, z.x)
R2_lik(z.f, z.v)
R2_lik(z.f)
</code></pre>

<hr>
<h2 id='R2_pred'>Calculate R2_pred</h2><span id='topic+R2_pred'></span>

<h3>Description</h3>

<p>Calculate partial and total R2s for LMM, GLMM, PGLS, and PGLMM using R2_pred, an R2 based on the variance of the difference between the observed and predicted values of a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R2_pred(mod = NULL, mod.r = NULL, gaussian.pred = "tip_rm", phy = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R2_pred_+3A_mod">mod</code></td>
<td>
<p>A regression model with one of the following classes: 'lm', 'glm', 'lmerMod', 'glmerMod', 'phylolm', 'gls', 'pglmm', pglmm_compare', 'binaryPGLMM', or 'communityPGLMM'.</p>
</td></tr>
<tr><td><code id="R2_pred_+3A_mod.r">mod.r</code></td>
<td>
<p>A reduced model; if not provided, the total R2 will be given by setting 'mod.r' to the model corresponding to 'mod' with the intercept as the only predictor.</p>
</td></tr>
<tr><td><code id="R2_pred_+3A_gaussian.pred">gaussian.pred</code></td>
<td>
<p>For models of classes 'pglmm' and 'pglmm_compare' when family = gaussian, which type of prediction to calculate.</p>
</td></tr>
<tr><td><code id="R2_pred_+3A_phy">phy</code></td>
<td>
<p>The phylogeny for phylogenetic models (as a 'phylo' object), which must be specified for models of class 'phylolm'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>R2_pred works with classes 'lm', 'glm', 'lmerMod', 'glmerMod', 'phylolm', 'phyloglm', 'gls', 'pglmm', 'pglmm_compare', binaryPGLMM', and 'communityPGLMM' (family = gaussian and binomial).
</p>
<p><strong>LMM (lmerMod), GLMM (glmerMod), PGLMM (pglmm, pglmm_compare, binaryPGLMM and communityPGLMM):</strong>
</p>
<p style="text-align: center;"><code class="reqn">partial R2 = 1 - var(y - y.fitted.f)/var(y - y.fitted.r)</code>
</p>

<p>where y are the observed data, and y.fitted.f and y.fitted.r are the fitted (predicted) values from the full and reduced models. For GLMMs and PGLMMs, the values of y.fitted are in the space of the raw data (as opposed to the 'Normal' or 'latent' space). When the reduced model 'mod.r' is not specified, the total R2 is computing using the reduced model with only the intercept.
</p>
<p>For pglmm and pglmm_compare with gaussian models, the default method for computing predicted values is &quot;nearest_node&quot; to correspond to predicted values in lmer, although the method &quot;tip_rm&quot; can be specified to correspond to the analyses in Ives (2018).
</p>
<p>Note that the version of <code>binaryPGLMM()</code> in the package ape is replaced by a version contained within rr2 that outputs all of the required information for the calculation of R2_resid.
</p>
<p><strong>PGLS (phylolm and gls):</strong>
</p>
<p>For PGLS, the total R2_pred is computed by removing each datum one at a time, predicting its value from the fitted model, repeating this for all data points, and then calculating the variance of the difference between observed and fitted values. The predictions are calculated as
</p>
<p style="text-align: center;"><code class="reqn">res.predicted[j] = V[j, -j] solve(V[-j, -j]) res[-j]</code>
</p>

<p>where res[-j] is a vector of residuals with datum j removed, V[-j,-j] is the phylogenetic covariance matrix with row and column j removed, and V[j, -j] is row j of covariance matrix V with element j removed. The partial R2_pred is calculated from the total R2_pred from full and reduced models as
</p>
<p style="text-align: center;"><code class="reqn">partial R2 = 1 - (1 - R2_pred.f)/(1 - R2_pred.r)</code>
</p>

<p>Note that <code>phylolm()</code> can have difficulties in finding solutions when there is no phylogenetic signal; when the estimate indicates no phylogenetic signal, you should refit the model with the corresponding LM.
</p>
<p><strong>LM (lm) and GLM (glm):</strong> 
</p>
<p>For compatibility and generating reduced models, rr2 will compute R2_pred for LM and GLM that correspond to LMM/PGLS and GLMM/PGLMM.
</p>


<h3>Author(s)</h3>

<p>Anthony R. Ives
</p>


<h3>References</h3>

<p>Ives A.R. and Li D. 2018. rr2: An R package to calculate R2s for regression models. Journal of Open Source Software. DOI:10.21105/joss.01028
</p>
<p>Ives A.R. 2018. R2s for Correlated Data: Phylogenetic Models, LMMs, and GLMMs. Systematic Biology, Volume 68, Issue 2, March 2019, Pages 234-251. DOI:10.1093/sysbio/syy060
</p>


<h3>See Also</h3>

<p>MuMIn, lme4, ape, phylolm, pez
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
library(phylolm)
library(lme4)
library(nlme)
library(phyr)

set.seed(12345)
p1 &lt;- 10
nsample &lt;- 10
n &lt;- p1 * nsample

d &lt;- data.frame(x1 = 0, x2 = 0, u1 = rep(1:p1, each = nsample),
                u2 = rep(1:p1, times = nsample))
d$u1 &lt;- as.factor(d$u1)
d$u2 &lt;- as.factor(d$u2)

b1 &lt;- 1
b2 &lt;- -1
sd1 &lt;- 1.5

d$x1 &lt;- rnorm(n = n)
d$x2 &lt;- rnorm(n = n)
d$y.lmm &lt;- b1 * d$x1 + b2 * d$x2 + 
  rep(rnorm(n = p1, sd = sd1), each = nsample) +
  rep(rnorm(n = p1, sd = sd1), times = nsample) + 
  rnorm(n = n)

prob &lt;- inv.logit(b1 * d$x1 + rep(rnorm(n = p1, sd = sd1), each = nsample))
d$y.glmm &lt;- rbinom(n = n, size = 1, prob = prob)

# LMM with two fixed and two random effects ----
z.f &lt;- lmer(y.lmm ~ x1 + x2 + (1 | u1) + (1 | u2), data = d, REML = FALSE)
z.x &lt;- lmer(y.lmm ~ x1 + (1 | u1) + (1 | u2), data = d, REML = FALSE)
z.v &lt;- lmer(y.lmm ~ 1 + (1 | u2), data = d, REML = FALSE)
z.0 &lt;- lm(y.lmm ~ 1, data = d)

R2_pred(z.f, z.x)
R2_pred(z.f, z.v)
R2_pred(z.f)

# GLMM with one fixed and one random effect ----
z.f &lt;- glmer(y.glmm ~ x1 + (1 | u1), data = d, family = 'binomial')
z.x &lt;- glmer(y.glmm ~ 1 + (1 | u1), data = d, family = 'binomial')
z.v &lt;- glm(y.glmm ~ x1, data = d, family = 'binomial')

R2_pred(z.f, z.x)
R2_pred(z.f, z.v)
R2_pred(z.f)

# PGLS with a single fixed effect ----
n &lt;- 100
d &lt;- data.frame(x = array(0, dim = n), y = 0)

b1 &lt;- 1.5
signal &lt;- 0.7

phy &lt;- compute.brlen(rtree(n = n), method = 'Grafen', power = 1)
phy.x &lt;- compute.brlen(phy, method = 'Grafen', power = .0001)

# Generate random data
x &lt;- rTraitCont(phy.x, model = 'BM', sigma = 1)
e &lt;- signal ^ 0.5 * rTraitCont(phy, model = 'BM', sigma = 1) +
  (1 - signal) ^ 0.5 * rnorm(n = n)
d$x &lt;- x[match(names(e), names(x))]
d$y &lt;- b1 * x + e
rownames(d) &lt;- phy$tip.label
d$sp &lt;- phy$tip.label

z.x &lt;- gls(y ~ 1, data = d, correlation = corPagel(1, phy, form = ~sp), method = "ML")
z.f &lt;- gls(y ~ x, data = d, correlation = corPagel(1, phy, form = ~sp), method = "ML")
z.v &lt;- lm(y ~ x, data = d)

R2_pred(z.f, z.x)
R2_pred(z.f, z.v)
R2_pred(z.f)

# PGLMM with one fixed effect ----
n &lt;- 100
b1 &lt;- 1.5
signal &lt;- 2

phy &lt;- compute.brlen(rtree(n = n), method = 'Grafen', power = 1)
phy.x &lt;- compute.brlen(phy, method = 'Grafen', power = .0001)

# Generate random data
x &lt;- rnorm(n)
d &lt;- data.frame(x = x, y = 0)

e &lt;- signal * rTraitCont(phy, model = 'BM', sigma = 1)
e &lt;- e[match(phy$tip.label, names(e))]

d$y &lt;- rbinom(n = n, size = 1, prob = inv.logit(b1 * d$x + e))
rownames(d) &lt;- phy$tip.label

z.f &lt;- pglmm_compare(y ~ x, data = d, family = "binomial", phy = phy)
z.x &lt;- pglmm_compare(y ~ 1, data = d, family = "binomial", phy = phy)
z.v &lt;- glm(y ~ x, data = d, family = "binomial")

R2_pred(z.f, z.x)
R2_pred(z.f, z.v)
R2_pred(z.f)

#' #################
# A community example of pglmm {phyr} contrasting R2_pred when bayes = TRUE and bayes = F

library(mvtnorm)
nspp &lt;- 6
nsite &lt;- 4

# Simulate a phylogeny that has a lot of phylogenetic signal (power = 1.3)
phy &lt;- compute.brlen(rtree(n = nspp), method = "Grafen", power = 1.3)

# Simulate species means
sd.sp &lt;- 1
mean.sp &lt;- rTraitCont(phy, model = "BM", sigma=sd.sp^2)

# Replicate values of mean.sp over sites
Y.sp &lt;- rep(mean.sp, times=nsite)

# Simulate site means
sd.site &lt;- 1
mean.site &lt;- rnorm(nsite, sd=sd.site)

# Replicate values of mean.site over sp
Y.site &lt;- rep(mean.site, each=nspp)

# Compute a covariance matrix for phylogenetic attraction
sd.attract &lt;- 1
Vphy &lt;- vcv(phy)

# Standardize the phylogenetic covariance matrix to have determinant = 1.
# (For an explanation of this standardization, see subsection 4.3.1 in Ives (2018))
Vphy &lt;- Vphy/(det(Vphy)^(1/nspp))

# Construct the overall covariance matrix for phylogenetic attraction.
# (For an explanation of Kronecker products, see subsection 4.3.1 in the book)
V &lt;- kronecker(diag(nrow = nsite, ncol = nsite), Vphy)
Y.attract &lt;- array(t(rmvnorm(n = 1, sigma = sd.attract^2*V)))

# Simulate residual errors
sd.e &lt;- 1
Y.e &lt;- rnorm(nspp*nsite, sd = sd.e)

# Construct the dataset
d &lt;- data.frame(sp = rep(phy$tip.label, times = nsite), site = rep(1:nsite, each = nspp))

# Simulate abundance data
d$Y &lt;- Y.sp + Y.site + Y.attract + Y.e

# Full and reduced models
z.f &lt;- pglmm(Y ~ 1 + (1|sp__) + (1|site) + (1|sp__@site),
        data = d, cov_ranef = list(sp = phy), REML = FALSE)
z.nested &lt;- pglmm(Y ~ 1 + (1|sp__) + (1|site),
        data = d, cov_ranef = list(sp = phy), REML = FALSE)
z.sp &lt;- pglmm(Y ~ 1 + (1|sp) + (1|site),
        data = d, cov_ranef = list(sp = phy), REML = FALSE)

R2_pred(z.f, z.nested)
R2_pred(z.nested, z.sp)
R2_pred(z.f)

# vector - matrix
# These are generally larger when gaussian.pred = "nearest_node"
R2_pred(z.f, z.nested, gaussian.pred = "nearest_node")
R2_pred(z.nested, z.sp, gaussian.pred = "nearest_node")
R2_pred(z.f, gaussian.pred = "nearest_node")

# # When bayes = TRUE, gaussian.pred does not work.
# # Commented out because INLA is not on CRAN
# z.f.bayes &lt;- pglmm(Y ~ 1 + (1|sp__) + (1|site) + (1|sp__@site),
#                data = d, cov_ranef = list(sp = phy), bayes = TRUE)
# z.nested.bayes &lt;- pglmm(Y ~ 1 + (1|sp__) + (1|site),
#                data = d, cov_ranef = list(sp = phy), bayes = TRUE)
# z.sp.bayes &lt;- pglmm(Y ~ 1 + (1|sp) + (1|site),
#                data = d, cov_ranef = list(sp = phy), bayes = TRUE)
# 
# R2_pred(z.f.bayes, z.nested.bayes)
# R2_pred(z.nested.bayes, z.sp.bayes)
# R2_pred(z.f.bayes)
</code></pre>

<hr>
<h2 id='R2_resid'>Calculate R2_resid</h2><span id='topic+R2_resid'></span>

<h3>Description</h3>

<p>Calculate partial and total R2s for LMM, GLMM, PGLS, and PGLMM using R2_resid, an extension of ordinary least-squares (OLS) R2s. For LMMs and GLMMs, R2_resid is related to the method proposed by Nakagawa and Schielzeth (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R2_resid(
  mod = NULL,
  mod.r = NULL,
  sigma2_d = c("s2w", "NS", "rNS"),
  phy = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R2_resid_+3A_mod">mod</code></td>
<td>
<p>A regression model with one of the following classes: 'lm', 'glm', 'lmerMod', 'glmerMod', 'phylolm', 'gls', 'pglmm_compare' or 'binaryPGLMM'. For 'glmerMod', only family = c('binomial', 'poisson') are supported.</p>
</td></tr>
<tr><td><code id="R2_resid_+3A_mod.r">mod.r</code></td>
<td>
<p>A reduced model; if not provided, the total R2 will be given by setting 'mod.r' to the model corresponding to 'mod' with the intercept as the only predictor.</p>
</td></tr>
<tr><td><code id="R2_resid_+3A_sigma2_d">sigma2_d</code></td>
<td>
<p>Distribution-specific variance <code class="reqn">\sigma^2_d</code> (see Details). For binomial GLMs, GLMMs and PGLMMs with logit link functions, options are c('s2w', 'NS', 'rNS'). For binomial GLMs, GLMMs and PGLMMs with probit link functions, options are c('s2w', 'NS'). Other families use 's2w'.</p>
</td></tr>
<tr><td><code id="R2_resid_+3A_phy">phy</code></td>
<td>
<p>The phylogeny for phylogenetic models (as a 'phylo' object), which must be specified for models of class 'phylolm'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>R2_resid works with classes 'lm', 'glm', 'lmerMod', 'glmerMod', 'phylolm', 'pglmm_compare', and 'binaryPGLMM'.
</p>
<p><strong>LMM (lmerMod):</strong>
</p>
<p style="text-align: center;"><code class="reqn">partial R^2 = 1 - \sigma^2_{e.f}/\sigma^2_{e.r}</code>
</p>

<p style="text-align: center;"><code class="reqn">total R^2 = 1 - \sigma^2_{e.f}/var(y)</code>
</p>

<p>where <code class="reqn">\sigma^2_{e.f}</code> and <code class="reqn">\sigma^2_{e.r}</code> are the estimated residual variances from the full and reduced LMM, and var(y) is the total variance of the response (dependent) variable.
</p>
<p><strong>GLMM (glmerMod):</strong> 
</p>
<p style="text-align: center;"><code class="reqn">total R^2 = 1 - \sigma^2_d/(\sigma^2_x + \sigma^2_b + \sigma^2_d)</code>
</p>

<p>where <code class="reqn">\sigma^2_x</code> and <code class="reqn">\sigma^2_b</code> are the estimated variances associated with the fixed and random effects. <code class="reqn">\sigma^2_d</code> is a term that scales the implied 'residual variance' of the GLMM (see Ives 2018, Appendix 1). The default used for <code class="reqn">\sigma^2_d</code> is <code class="reqn">\sigma^2_w</code> which is computed from the iterative weights of the GLMM. Specifically,
</p>
<p style="text-align: center;"><code class="reqn">\sigma_{w}^{2}=var(g'(\mu)*(y-\mu))</code>
</p>

<p>where g'() is the derivative of the link function, and <code class="reqn">(y-\mu)</code> is the difference between the data y and their predicted values <code class="reqn">\mu</code>. This is the default option specified by sigma2_d = 's2w'. For binomial models with a logit link function, sigma2_d = 'NS' gives the scaling <code class="reqn">\sigma^2_d =  \pi^2/3</code> from Nakagawa and Schielzeth (2013), and sigma2_d = 'rNS' gives <code class="reqn">\sigma^2_d = 0.8768809 * \pi^2/3</code> which is a &quot;corrected&quot; version of 'NS' (see Ives 2018, Appendix 1). For binomial models with a probit link function, sigma2_d = 'NS' gives the scaling <code class="reqn">\sigma^2_d = 1</code>. In general, option sigma2_d = 's2w' will give values lower than sigma2_d = 'NS' and 'rNS', but the values will be closer to <code>R2_lik()</code> and <code>R2_pred()</code>. For other forms of sigma2_d from Nakagawa and Schielzeth (2013) and Nakagawa et al. (2017), see the MuMIn package.
</p>
<p>Partial R2s are given by the standard formula
</p>
<p style="text-align: center;"><code class="reqn">partial R^2 = 1 - (1 - R^2_{.f})/(1 - R^2_{.r})</code>
</p>

<p>where R2.f and R2.r are the total R2s for full and reduced models, respectively.
</p>
<p><strong>PGLS (phylolm, pglmm_compare):</strong> 
</p>
<p style="text-align: center;"><code class="reqn">partial R^2 = 1 - c.f * \sigma^2_{.f}/(c.r * \sigma^2_{.r})</code>
</p>

<p>where <code class="reqn">\sigma^2_{.f}</code> and <code class="reqn">\sigma^2_{.r}</code> are the variances estimated for the PGLS full and reduced models, and c.f and c.r are the scaling values for full and reduce models that equal the total sum of phylogenetic branch length estimates. Note that the phylogeny needs to be specified in R2_resid.
</p>
<p><code>phylolm()</code> can have difficulties in finding solutions when there is no phylogenetic signal;
when the estimate indicates no phylogenetic signal, you should refit the model with the corresponding LM.
</p>
<p><strong>PGLMM (pglmm_compare, binaryPGLMM):</strong> 
</p>
<p>The R2_resid for PGLMMs is computed in the same way as the GLMM (glmer), with options sigma_d = c('s2w', 'NS', 'rNS'). The estimated variance of the random effect associated with the phylogeny, <code class="reqn">\sigma^2_b</code>, is multiplied by the diagonal elements of the phylogenetic covariance matrix. For binary models, this covariance matrix should be standardized so that all diagonal elements are the same (a contemporaneous or ultrametric phylogenetic tree) (Ives and Garland 2014). In case this is not done, however, the code takes the geometric average of the diagonal elements.
</p>
<p>Note that the version of <code>binaryPGLMM()</code> in the package ape is replaced by a version contained within rr2 that outputs all of the required information for the calculation of <code>R2_resid()</code>
</p>
<p><strong>LM (lm) and GLM (glm):</strong> 
</p>
<p>For compatibility and generating reduced models, rr2 will compute <code>R2_resid()</code> for LM and GLM that correspond to LMM/PGLS and GLMM/PGLMM.
</p>


<h3>Value</h3>

<p>R2_resid value.
</p>


<h3>Author(s)</h3>

<p>Anthony R. Ives
</p>


<h3>References</h3>

<p>Ives A.R. and Li D. 2018. rr2: An R package to calculate R2s for regression models. Journal of Open Source Software. DOI:10.21105/joss.01028
</p>
<p>Ives A.R. 2018. R2s for Correlated Data: Phylogenetic Models, LMMs, and GLMMs. Systematic Biology, Volume 68, Issue 2, March 2019, Pages 234-251. DOI:10.1093/sysbio/syy060
</p>
<p>Ives A. R., Garland T., Jr. 2014. Phylogenetic regression for binary dependent variables. In: Garamszegi LZ editor. Modern Phylogenetic Comparative Methods and Their Application in Evolutionary Biology. Berlin Heidelberg, Springer-Verlag, p. 231-261.
</p>
<p>Nakagawa S., Schielzeth H. 2013. A general and simple method for obtaining R2 from generalized linear mixed-effects models. Methods in Ecology and Evolution, 4:133-142.
</p>
<p>Nakagawa S., Johnson P. C. D., Schielzeth H. 2017. The coefficient of determination R2 and intra-class correlation coefficient from generalized linear mixed-effects models revisited and expanded. Journal of the Royal Society Interface, 14.
</p>


<h3>See Also</h3>

<p>MuMIn, lme4, ape, phylolm, pez
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
library(phylolm)
library(lme4)
library(nlme)
library(phyr)

set.seed(12345)
p1 &lt;- 10
nsample &lt;- 10
n &lt;- p1 * nsample

d &lt;- data.frame(x1 = 0, x2 = 0, u1 = rep(1:p1, each = nsample),
                u2 = rep(1:p1, times = nsample))
d$u1 &lt;- as.factor(d$u1)
d$u2 &lt;- as.factor(d$u2)

b1 &lt;- 1
b2 &lt;- -1
sd1 &lt;- 1.5

d$x1 &lt;- rnorm(n = n)
d$x2 &lt;- rnorm(n = n)
d$y.lmm &lt;- b1 * d$x1 + b2 * d$x2 + 
  rep(rnorm(n = p1, sd = sd1), each = nsample) +
  rep(rnorm(n = p1, sd = sd1), times = nsample) + 
  rnorm(n = n)

prob &lt;- inv.logit(b1 * d$x1 + rep(rnorm(n = p1, sd = sd1), each = nsample))
d$y.glmm &lt;- rbinom(n = n, size = 1, prob = prob)

# LMM with two fixed and two random effects ----
z.f &lt;- lmer(y.lmm ~ x1 + x2 + (1 | u1) + (1 | u2), data = d, REML = FALSE)
z.x &lt;- lmer(y.lmm ~ x1 + (1 | u1) + (1 | u2), data = d, REML = FALSE)
z.v &lt;- lmer(y.lmm ~ 1 + (1 | u2), data = d, REML = FALSE)
z.0 &lt;- lm(y.lmm ~ 1, data = d)

R2_resid(z.f, z.x)
R2_resid(z.f, z.v)
R2_resid(z.f)

# GLMM with one fixed and one random effect ----
z.f &lt;- glmer(y.glmm ~ x1 + (1 | u1), data = d, family = 'binomial')
z.x &lt;- glmer(y.glmm ~ 1 + (1 | u1), data = d, family = 'binomial')
z.v &lt;- glm(y.glmm ~ x1, data = d, family = 'binomial')

R2_resid(z.f, z.x)
R2_resid(z.f, z.v)
R2_resid(z.f)

# PGLS with a single fixed effect ----
n &lt;- 100
d &lt;- data.frame(x = array(0, dim = n), y = 0)

b1 &lt;- 1.5
signal &lt;- 0.7

phy &lt;- compute.brlen(rtree(n = n), method = 'Grafen', power = 1)
phy.x &lt;- compute.brlen(phy, method = 'Grafen', power = .0001)

# Generate random data
x &lt;- rTraitCont(phy.x, model = 'BM', sigma = 1)
e &lt;- signal ^ 0.5 * rTraitCont(phy, model = 'BM', sigma = 1) +
  (1 - signal) ^ 0.5 * rnorm(n = n)
d$x &lt;- x[match(names(e), names(x))]
d$y &lt;- b1 * x + e
rownames(d) &lt;- phy$tip.label
d$sp &lt;- phy$tip.label

z.x &lt;- pglmm_compare(y ~ 1, phy = phy, data = d, REML=FALSE)
z.f &lt;- pglmm_compare(y ~ x, phy = phy, data = d, REML=FALSE)
z.v &lt;- lm(y ~ x, data = d)

R2_resid(z.f, z.x)
R2_resid(z.f, z.v)
R2_resid(z.f)

z.x &lt;- phylolm(y ~ 1, phy = phy, data = d, model = 'lambda')
z.f &lt;- phylolm(y ~ x, phy = phy, data = d, model = 'lambda')
z.v &lt;- lm(y ~ x, data = d)

R2_resid(z.f, z.x, phy = phy)
R2_resid(z.f, z.v, phy = phy)
R2_resid(z.f, phy = phy)

# This also works for models fit with gls() in {nlme}
z.f &lt;- gls(y ~ x, data = d, correlation = corPagel(1, phy, form = ~sp), method = "ML")
z.x &lt;- gls(y ~ 1, data = d, correlation = corPagel(1, phy, form = ~sp), method = "ML")
z.v &lt;- lm(y ~ x, data = d)

R2_resid(z.f, z.x)
R2_resid(z.f, z.v)
R2_resid(z.f)

# But note that you need to define weights for gls() with non-ultrametric trees;
# if not, you will get a error "Matrix is not block-diagonal"

phy.nu &lt;- rtree(n = n)

# Generate random data
e &lt;- signal ^ 0.5 * rTraitCont(phy.nu, model = 'BM', sigma = 1) +
  (1 - signal) ^ 0.5 * rnorm(n = n)
d$x &lt;- x[match(names(e), names(x))]
d$y &lt;- b1 * x + e
rownames(d) &lt;- phy.nu$tip.label
d$sp &lt;- phy.nu$tip.label

weights &lt;- diag(vcv.phylo(phy.nu))
z.x &lt;- gls(y ~ 1,data = d,
         correlation = corPagel(1, phy.nu, form = ~sp),
         weights=varFixed(~weights), method = "ML")
z.f &lt;- gls(y ~ x,data = d,
         correlation = corPagel(1, phy.nu, form = ~sp),
         weights=varFixed(~weights), method = "ML")
z.v &lt;- lm(y ~ x, weights = 1/weights, data = d)

R2_resid(z.f, z.x)
R2_resid(z.f, z.v)
R2_resid(z.f)

# PGLMM with one fixed effect ----

n &lt;- 100
b1 &lt;- 1.5
signal &lt;- 2

phy &lt;- compute.brlen(rtree(n = n), method = 'Grafen', power = 1)
phy.x &lt;- compute.brlen(phy, method = 'Grafen', power = .0001)

# Generate random data
x &lt;- rnorm(n)
d &lt;- data.frame(x = x, y = 0)

e &lt;- signal * rTraitCont(phy, model = 'BM', sigma = 1)
e &lt;- e[match(phy$tip.label, names(e))]

d$y &lt;- rbinom(n = n, size = 1, prob = inv.logit(b1 * d$x + e))
rownames(d) &lt;- phy$tip.label

# Use the function pglmm_compare in {phyr}.
z.f &lt;- pglmm_compare(y ~ x, data = d, family = "binomial", phy = phy)
z.x &lt;- pglmm_compare(y ~ 1, data = d, family = "binomial", phy = phy)
z.v &lt;- glm(y ~ x, data = d, family = 'binomial')

R2_resid(z.f, z.x)
R2_resid(z.f, z.v)
R2_resid(z.f)

</code></pre>

<hr>
<h2 id='transf_phy'>Transform a phylogeny based on a phylolm model</h2><span id='topic+transf_phy'></span>

<h3>Description</h3>

<p>Using a fitted phylolm model to transform branch lengths of a phylogeny
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transf_phy(phylolmMod, phy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transf_phy_+3A_phylolmmod">phylolmMod</code></td>
<td>
<p>A fitted phylolm model.</p>
</td></tr>
<tr><td><code id="transf_phy_+3A_phy">phy</code></td>
<td>
<p>A phylogeny with class 'phylo'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A transformed phylogeny.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
