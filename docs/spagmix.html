<!DOCTYPE html><html lang="en"><head><title>Help for package spagmix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spagmix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spagmix-package'>
<p>The spagmix Package: Artificial Spatial and Spatio-Temporal Densities on Bounded Windows</p></a></li>
<li><a href='#lgcpmix'>
<p>Generate a spatial log-Gaussian Cox process intensity</p></a></li>
<li><a href='#plot.stim'><p>Plotting 'stim' objects</p></a></li>
<li><a href='#rgmix'><p>Random bivariate Gaussian mixture density generation</p></a></li>
<li><a href='#rpoispoly'>
<p>Generate a Poisson point pattern in a polygonal window</p></a></li>
<li><a href='#rrmix'><p>Spatial relative risk surface generation</p></a></li>
<li><a href='#rrpoint'>
<p>Generate random case/control points in space or space-time</p></a></li>
<li><a href='#rrstmix'>
<p>Spatiotemporal relative risk surface generation</p></a></li>
<li><a href='#rstpoint'>
<p>Generate random points in space-time</p></a></li>
<li><a href='#sgmix'><p>Bivariate Gaussian mixture density generation</p></a></li>
<li><a href='#spagmix-internal'>
<p>Internal <code>spagmix</code> functions</p></a></li>
<li><a href='#stgmix'><p>Trivariate Gaussian mixture density generation</p></a></li>
<li><a href='#stintegral'>
<p>Evaluate integral of a spatiotemporal object</p></a></li>
<li><a href='#stkey'>
<p>Spatiotemporal density generation via keyframe interpolation</p></a></li>
<li><a href='#toywin'>
<p>Toy Windows</p></a></li>
<li><a href='#unify.owin'><p>Spatial window unit rescaler</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Artificial Spatial and Spatio-Temporal Densities on Bounded
Windows</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-25</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tilman M. Davies &lt;tilman.davies@otago.ac.nz&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Simple utilities to design and generate density functions on bounded regions in space and space-time, and simulate independent, identically distributed data therefrom. See Davies &amp; Lawson (2019) &lt;<a href="https://doi.org/10.1080%2F00949655.2019.1575066">doi:10.1080/00949655.2019.1575066</a>&gt; for example.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), spatstat (&ge; 3.0-0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, sparr, mvtnorm, spatstat.geom, spatstat.random</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgl</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-25 02:02:02 UTC; davti75p</td>
</tr>
<tr>
<td>Author:</td>
<td>Anna K. Redmond [aut],
  Tilman M. Davies [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-25 02:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='spagmix-package'>
The spagmix Package: Artificial Spatial and Spatio-Temporal Densities on Bounded Windows
</h2><span id='topic+spagmix-package'></span><span id='topic+spagmix'></span>

<h3>Description</h3>

<p>Provides functions to design synthetic spatial and spatiotemporal densities and relative risk functions based mainly on Gaussian mixture distributions, and simulate independent and identically distributed data therefrom.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> spagmix</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.4-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-06-25</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Appraisal of existing, refined, and new statistical methods for the analysis of spatial and spatiotemporal point pattern data usually involves numeric experimentation. Motivated by relevant problems in nonparametric density estimation (see e.g. Wand &amp; Jones, 1995), <code>spagmix</code> (&ldquo;spatial Gaussian mixtures&rdquo;) provides some simple utilities for designing heterogeneous density and density-ratio or <em>relative risk</em> (Bithell 1990, 1991; Kelsall &amp; Diggle, 1995) functions in space and space-time (see Fernando &amp; Hazelton, 2014 for the latter). The package is also capable of producing realisations of (possibly inhomogeneous) spatial log-Gaussian Cox process intensities (Møller et al., 1998; see also Davies &amp; Hazelton, 2013).
</p>
<p>Additionally, functions for simulating datasets given these scenarios are included. For examples of how these kinds of synthetic functions have been used in simulation studies in various publications, see for example Clark &amp; Lawson, 2004; Davies &amp; Hazelton, 2010; Davies, 2013a,b; Davies &amp; Hazelton, 2013; Fernando et al., 2014; Davies et al., 2016; Davies et al., 2018a; and Davies &amp; Lawson, 2019.
</p>
<p>We have designed the objects of <code>spagmix</code> to use and be compatible with standard object classes of the <code><a href="spatstat.html#topic+spatstat-package">spatstat</a></code> (Baddeley &amp; Turner, 2005; Baddeley et al., 2015) and <code><a href="sparr.html#topic+sparr-package">sparr</a></code> (Davies et al., 2018b) packages. The content of <code>spagmix</code> can be broken up as follows:<br />
</p>
<p><em>Artificial polygonal windows</em><br />
Some pre-made synthetic spatial windows; these are all single closed polygons as objects of class <code><a href="spatstat.geom.html#topic+owin">owin</a></code> and are lazy-loaded:<br />
<code><a href="#topic+bx">bx</a></code>, <code><a href="#topic+heart">heart</a></code>, <code><a href="#topic+shp1">shp1</a></code>, <code><a href="#topic+shp2">shp2</a></code>, <code><a href="#topic+star">star</a></code>, <code><a href="#topic+toywin">toywin</a></code><br />
</p>
<p><em>Spatial scenarios</em><br />
<code><a href="#topic+sgmix">sgmix</a></code> is used to create spatial (2D) Gaussian mixture distributions on a bounded subset of the plane.<br />
<code><a href="#topic+rgmix">rgmix</a></code> also creates 2D Gaussian mixture densities, but does so by stochastic generation of the contributing bumps.<br />
<code><a href="#topic+rrmix">rrmix</a></code> creates Gaussian mixture relative risk scenarios based on a supplied control density (see e.g. Davies &amp; Hazelton, 2010).
<code><a href="#topic+lgcpmix">lgcpmix</a></code> generates a spatial log-Gaussian Cox process intensity in space, given a deterministic intensity function and residual correlation governed by a stochastic realisation of a Gaussian field with a specified covariance structure.
</p>
<p><em>Spatiotemporal scenarios</em><br />
<code><a href="#topic+stgmix">stgmix</a></code> is used to create spatiotemporal (3D) Gaussian mixture densities on a bounded subset of the plane and a single closed interval in time.<br />
<code><a href="#topic+stkey">stkey</a></code> is used to create spatiotemporal densities by pixel-wise interpolation of multiple spatial image &lsquo;keyframes&rsquo;.
<code><a href="#topic+rrstmix">rrstmix</a></code> is a spatiotemporal version of <code><a href="#topic+rrmix">rrmix</a></code>, used to create artificial spatiotemporal relative risk functions. Note the control density may be purely spatial, representing a distribution &lsquo;at-risk&rsquo; points that does not change over time (Fernando &amp; Hazelton, 2014).<br />
</p>
<p><em>Data generation</em><br />
To generate purely spatial data for a single spatial density, the user is directed to <code><a href="spatstat.random.html#topic+rpoint">rpoint</a></code> of the <code><a href="spatstat.html#topic+spatstat-package">spatstat</a></code> package or <code><a href="sparr.html#topic+rimpoly">rimpoly</a></code> of the <code><a href="sparr.html#topic+sparr-package">sparr</a></code> package.<br />
<code><a href="#topic+rpoispoly">rpoispoly</a></code> is a wrapper of <code><a href="sparr.html#topic+rimpoly">rimpoly</a></code>, and is used to generate realisations of Poisson point processes in space, given an intensity function.
<code><a href="#topic+rrpoint">rrpoint</a></code> is a wrapper of <code><a href="sparr.html#topic+rimpoly">rimpoly</a></code>, and is used to generate iid datasets based on a synthetic spatial relative risk surface object.<br />
<code><a href="#topic+rstpoint">rstpoint</a></code> is a 3D rejection algorithm for sampling iid data from a supplied spatiotemporal density.<br />
<code><a href="#topic+rrstpoint">rrstpoint</a></code> is a wrapper of <code><a href="#topic+rstpoint">rstpoint</a></code> to generate iid datasets from a synthetic spatiotemporal relative risk surface object.<br />
</p>
<p><em>Miscellaneous</em><br />
<code><a href="#topic+plot.stim">plot.stim</a></code> is an <code>S3</code> plotting method for spatiotemporal density objects.<br />
<code><a href="#topic+stintegral">stintegral</a></code> computes the 3D integral of a spatiotemporal density object.<br />
<code><a href="#topic+unify.owin">unify.owin</a></code> is a wrapper for <code><a href="spatstat.geom.html#topic+affine">affine</a></code> that transforms any spatial <code><a href="spatstat.geom.html#topic+owin">owin</a></code> to fall inside the unit square.
</p>


<h3>Dependencies/Imports</h3>

<p>Depends on <code><a href="spatstat.html#topic+spatstat-package">spatstat</a></code> functionality (Baddeley &amp; Turner, 2005; Baddeley et al., 2015) and imports from <code>abind</code> (Plate &amp; Heiberger, 2016), <code>sparr</code> (Davies et al., 2018b), and mvtnorm (Genz et al., 2018). We also highly recommend the <code>rgl</code> package (Adler et al., 2018) which can be used to create interactive plots of spatiotemporal data.
</p>


<h3>Author(s)</h3>

<p>A.K. Redmond and T.M. Davies<br />
<em>Dept. of Mathematics &amp; Statistics, University of Otago, Dunedin, New Zealand</em><br />
</p>
<p>Maintainer: T.M.D. <a href="mailto:tilman.davies@otago.ac.nz">tilman.davies@otago.ac.nz</a><br />
</p>


<h3>References</h3>

<p>Adler, D., Murdoch, D. and others (2018), rgl: 3D Visualization Using OpenGL, R package version 0.99.16 https://CRAN.R-project.org/package=rgl<br /><br />
Baddeley, A., Rubak, E. and Turner, R. (2015), <em>Spatial Point Patterns: Methodology and Applications with R</em>, Chapman and Hall/CRC Press, London.<br /><br />
Baddeley, A. and Turner, R. (2005), Spatstat: an R package for analyzing spatial point patterns, <em>Journal of Statistical Software</em>, <b>12</b>(6), 1-42.<br /><br />
Bithell, J.F. (1990), An application of density estimation to geographical epidemiology, <em>Statistics in Medicine</em>, <b>9</b>, 691-701.<br /><br />
Bithell, J.F. (1991), Estimation of relative risk function,. <em>Statistics in Medicine</em>, <b>10</b>, 1745-1751.<br /><br />
Clark, A.B. and Lawson, A.B. (2004), An evaluation of non-parametric relative risk estimators for disease maps, <em>Computational Statistics &amp; Data Analysis</em>, <b>47</b>, 63-78.<br /><br />
Davies, T.M. (2013a), Jointly optimal bandwidth selection for the planar kernel-smoothed density-ratio, <em>Spatial and Spatio-temporal Epidemiology</em>, <b>5</b>, 51-65.<br /><br />
Davies, T.M. (2013b), Scaling oversmoothing factors for kernel estimation of spatial relative risk, <em>Epidemiological Methods</em>, <b>2</b>(1), 67-83.<br /><br />
Davies, T.M. and Hazelton, M.L. (2010), Adaptive kernel estimation of spatial relative risk, <em>Statistics in Medicine</em>, <b>29</b>(23), 2423-2437.<br /><br />
Davies, T.M. and Hazelton, M.L. (2013), Assessing minimum contrast parameter estimation for spatial and spatiotemporal log-Gaussian Cox processes, <em>Statistica Neerlandica</em>, <b>67</b>(4), 355-389.<br /><br />
Davies, T.M., Jones, K. and Hazelton, M.L. (2016), Symmetric adaptive smoothing regimens for estimation of the spatial relative risk function, <em>Computational Statistics &amp; Data Analysis</em>, <b>101</b>, 12-28.<br /><br />
Davies, T.M. and Lawson, A.B. (2019), An evaluation of likelihood-based bandwidth selectors for spatial and spatiotemporal kernel estimates, <em>Journal of Statistical Computation and Simulation</em>, <b>89</b> 1131-1152.<br /><br />
Davies, T.M., Flynn, C.R. and Hazelton, M.L. (2018a), On the utility of asymptotic bandwidth selectors for spatially adaptive kernel density estimation, <em>Statistics &amp; Probability Letters</em>, <b>138</b>, 75-81.<br /><br />
Davies, T.M., Marshall, J.C. and Hazelton, M.L. (2018b), Tutorial on kernel estimation of continuous spatial and spatiotemporal relative risk, <em>Statistics in Medicine</em>, <b>37</b>(7), 1191-1221.<br /><br />
Fernando, W.T.P.S., Ganesalingam, S. and Hazelton, M.L. (2014), A comparison of estimators of the geographical relative risk function, <em>Journal of Statistical Computation and Simulation</em>, <b>84</b>(7), 1471-1485.<br /><br />
Fernando, W.T.P.S. and Hazelton, M.L. (2014), Generalizing the spatial relative risk function, <em>Spatial and Spatio-temporal Epidemiology</em>, <b>8</b>, 1-10.<br /><br />
Genz, A., Bretz, F., Miwa, T., Mi, X., Leisch, F., Scheipl, F. and Hothorn, T. (2018), mvtnorm: Multivariate Normal and t Distributions, R package version 1.0-8. URL http://CRAN.R-project.org/package=mvtnorm <br /><br />
Kelsall, J.E. and Diggle, P.J. (1995), Kernel estimation of relative risk, <em>Bernoulli</em>, <b>1</b>, 3-16.<br /><br />
Møller, J., Syversveen, A.R. and Waagepetersen, R.P. (1998), Log-Gaussian Cox processes, <em>Scandinavian Journal of Statistics</em>, <b>25</b>(3) 451&ndash;482.<br /><br />
Plate, T. and Heiberger, R. (2016), abind: Combine Multidimensional Arrays, R package version 1.4-5. https://CRAN.R-project.org/package=abind <br /><br />
</p>

<hr>
<h2 id='lgcpmix'>
Generate a spatial log-Gaussian Cox process intensity
</h2><span id='topic+lgcpmix'></span>

<h3>Description</h3>

<p>Generate a realisation of a (possibly inhomogeneous) log-Gaussian Cox process (LGCP) spatial intensity function with an identifiable mean structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcpmix(lambda, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lgcpmix_+3A_lambda">lambda</code></td>
<td>

<p>A pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age giving the deterministic spatial intensity as the mean structure of the process. The generated Gaussian field will match the dimensions, resolution and domain of this object.
</p>
</td></tr>
<tr><td><code id="lgcpmix_+3A_...">...</code></td>
<td>

<p>Additional arguments controlling the Gaussian random field to be passed to <code><a href="spatstat.random.html#topic+rLGCP">rLGCP</a></code>. Minimally, the user will need to supply <code>param</code> and <code>model</code>. See &lsquo;Details&rsquo;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows the user to generate a spatial intensity function <code class="reqn">\Gamma</code> of the form 
</p>
<p><code class="reqn">\Gamma(x) = \lambda(x)\exp[Y(x)]</code> 
</p>
<p>for <code class="reqn">x \in W</code>, where <code class="reqn">\lambda(x)</code> (passed to <code>lambda</code>) is the deterministic spatial intensity over the spatial domain <code class="reqn">W</code>, and <code class="reqn">Y(x)</code> is a Gaussian random field on <code class="reqn">W</code>. This Gaussian field, implemented through <code><a href="spatstat.random.html#topic+rLGCP">rLGCP</a></code>, is defined with a particular spatial covariance function (specified via the <code>model</code> argument given to <code>...</code>) with variance and scale parameters <code class="reqn">\sigma^2</code> and <code class="reqn">\phi</code> respectively, as well as any additionally required parameter values (all specified in the <code>param</code> argument, also given to <code>...</code>). For example, requesting <code>model = "exponential"</code> with <code>param = list(var=</code><code class="reqn">\sigma^2</code><code>,scale=</code><code class="reqn">\phi</code><code>))</code> imposes an exponential covariance structure on the generated field whereby <code class="reqn">Cov(u) = \sigma^2\exp(-u/\phi)</code> for the Euclidean distance between any two spatial locations <code class="reqn">u</code>.
</p>
<p>The mean parameter <code class="reqn">\mu</code> of the Gaussian field <code class="reqn">Y</code> is internally fixed at <code class="reqn">-\sigma^2/2</code>; negative half the variance. This is for identifiability of the mean structure, forcing <code class="reqn">E[Y(x)] = 1</code> for all <code class="reqn">x \in W</code> (see theoretical properties in Møller et al., 1998). In turn, this means the deterministic intensity function <code class="reqn">\lambda(x)</code> is solely responsible for describing fixed heterogeneity in spatial intensity over <code class="reqn">W</code> (as such, the pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age supplied to <code>lambda</code> as <code class="reqn">\lambda(x)</code> must be non-negatively-valued and yield a finite integral), with the randomly generated Gaussian field left to describe residual stochastic spatial correlation. This presents a highly flexible class of model, even with stationarity and isotropy of the Gaussian field itself, and is intuitively sensible in a variety of applications. See Diggle et al. (2005) and Davies &amp; Hazelton (2013) for example. Given this, any user-supplied value of <code>mu</code> in <code style="white-space: pre;">&#8288;...&#8288;</code> (intended for <code><a href="spatstat.random.html#topic+rLGCP">rLGCP</a></code>) is irrelevant and will be ignored/overwritten.
</p>
<p>To generate a subsequent dataset, use e.g. <code><a href="spatstat.random.html#topic+rpoispp">rpoispp</a></code> or <code><a href="#topic+rpoispoly">rpoispoly</a></code>.
</p>


<h3>Value</h3>

<p>A pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age giving the generated intensity function, comprised of the product of <code>lambda</code> (fixed, and unchanging in repeated calls to this function) and the exponentiated Gaussian field (with expected value 1, this is stochastic and varies in repeated calls).
</p>


<h3>Author(s)</h3>

<p>T.M. Davies.
</p>


<h3>References</h3>

<p>Davies, T.M. and Hazelton, M.L. (2013), Assessing minimum contrast parameter estimation for spatial and spatiotemporal log-Gaussian Cox processes, <em>Statistica Neerlandica</em>, <b>67</b>(4) 355&ndash;389.
</p>
<p>Diggle, P.J., Rowlingson, B. and Su, T. (2005), Point process methodology for on-line spatio-temporal disease surveillance, <em>Environmetrics</em>, <b>16</b> 423&ndash;434.
</p>
<p>Møller, J., Syversveen, A.R. and Waagepetersen, R.P. (1998), Log-Gaussian Cox processes, <em>Scandinavian Journal of Statistics</em>, <b>25</b>(3) 451&ndash;482.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.random.html#topic+rLGCP">rLGCP</a></code>, <code><a href="spatstat.random.html#topic+rpoispp">rpoispp</a></code>, <code><a href="#topic+rpoispoly">rpoispoly</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Homogeneous example ##

# Create constant intensity image integrating to 500

homog &lt;- as.im(as.mask(toywin))
homog &lt;- homog/integral(homog)*500


# Corresponding LGCP realisations using exponential covariance structure
oldpar &lt;- par(mfrow=c(2,2),mar=rep(1.5,4))
for(i in 1:4){
  temp &lt;- lgcpmix(homog,model="exponential",param=list(var=1,scale=0.2))
  plot(temp,main=paste("Realisation",i),log=TRUE)
}
par(oldpar)


## Inhomogeneous examples ##

# Create deterministic trend

mn &lt;- cbind(c(0.25,0.8),c(0.31,0.82),c(0.43,0.64),c(0.63,0.62),c(0.21,0.26))
v1 &lt;- matrix(c(0.0023,-0.0009,-0.0009,0.002),2)
v2 &lt;- matrix(c(0.0016,0.0015,0.0015,0.004),2)
v3 &lt;- matrix(c(0.0007,0.0004,0.0004,0.0011),2)
v4 &lt;- matrix(c(0.0023,-0.0041,-0.0041,0.0099),2)
v5 &lt;- matrix(c(0.0013,0.0011,0.0011,0.0014),2)
vr &lt;- array(NA,dim=c(2,2,5))
for(i in 1:5) vr[,,i] &lt;- get(paste("v",i,sep=""))
intens &lt;- sgmix(mean=mn,vcv=vr,window=toywin,p0=0.1,int=500)


# Two realisations (identical calls to function), exponential covariance structure

r1exp &lt;- lgcpmix(lambda=intens,model="exponential",param=list(var=2,scale=0.05))
r2exp &lt;- lgcpmix(lambda=intens,model="exponential",param=list(var=2,scale=0.05))


# Two more realisations, Matern covariance with smoothness 1

r1mat &lt;- lgcpmix(lambda=intens,model="matern",param=list(var=2,scale=0.05,nu=1))
r2mat &lt;- lgcpmix(lambda=intens,model="matern",param=list(var=2,scale=0.05,nu=1))

# Plot everything, including 'intens' alone (no correlation)

oldpar &lt;- par(mar=rep(2,4))
layout(matrix(c(1,2,4,1,3,5),3))
plot(intens,main="intens alone",log=TRUE)
plot(r1exp,main="realisation 1\nexponential covar",log=TRUE)
plot(r2exp,main="realisation 2\nexponential covar",log=TRUE)
plot(r1mat,main="realisation 1\nMatern covar",log=TRUE)
plot(r2mat,main="realisation 2\nMatern covar",log=TRUE)
par(oldpar)

# Plot example datasets
dint &lt;- rpoispoly(intens,w=toywin)
d1exp &lt;- rpoispoly(r1exp,w=toywin)
d2exp &lt;- rpoispoly(r2exp,w=toywin)
d1mat &lt;- rpoispoly(r1mat,w=toywin)
d2mat &lt;- rpoispoly(r2mat,w=toywin)

oldpar &lt;- par(mar=rep(2,4))
layout(matrix(c(1,2,4,1,3,5),3))
plot(dint,main="intens alone",log=TRUE)
plot(d1exp,main="realisation 1\nexponential covar",log=TRUE)
plot(d2exp,main="realisation 2\nexponential covar",log=TRUE)
plot(d1mat,main="realisation 1\nMatern covar",log=TRUE)
plot(d2mat,main="realisation 2\nMatern covar",log=TRUE)
par(oldpar)
</code></pre>

<hr>
<h2 id='plot.stim'>Plotting 'stim' objects</h2><span id='topic+plot.stim'></span>

<h3>Description</h3>

<p><code>plot</code> method for class <code><a href="#topic+stim">stim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stim'
plot(x, fix.range = FALSE, sleep = 0.2, override.par = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.stim_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+stim">stim</a></code>.</p>
</td></tr>
<tr><td><code id="plot.stim_+3A_fix.range">fix.range</code></td>
<td>
<p>Logical value indicating whether use the same color scale limits for each plot in the sequence. Ignored if the user supplies a pre-defined <code><a href="spatstat.geom.html#topic+colourmap">colourmap</a></code> to the <code>col</code> argument, which is matched to <code>...</code> and passed to <code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>.</p>
</td></tr>
<tr><td><code id="plot.stim_+3A_sleep">sleep</code></td>
<td>
<p>Single positive numeric value giving the amount of time (in
seconds) to <code><a href="base.html#topic+Sys.sleep">Sys.sleep</a></code> before drawing the next image in
the animation.</p>
</td></tr>
<tr><td><code id="plot.stim_+3A_override.par">override.par</code></td>
<td>
<p>Logical value indicating whether to override the
existing graphics device parameters prior to plotting, resetting
<code>mfrow</code> and <code>mar</code>. See &lsquo;Details&rsquo; for when you might want to
disable this.</p>
</td></tr>
<tr><td><code id="plot.stim_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters to be passed to
<code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code> (see &lsquo;Details&rsquo;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Actual visualisation is deferred to
<code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>, for which there are a variety of
customisations available the user can access via <code>...</code>.
</p>
<p>The <code><a href="#topic+stim">stim</a></code> object is plotted as an animation, one pixel image
after another, separated by <code>sleep</code> seconds. If instead you intend the
individual images to be plotted in an array of images, you should first set
up your plot device layout, and ensure <code>override.par = FALSE</code> so that
the function does not reset these device parameters itself. In such an
instance, one might also want to set <code>sleep = 0</code>.
</p>


<h3>Value</h3>

<p>Plots to the active graphics device.
</p>


<h3>Author(s)</h3>

<p>T.M. Davies
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See help(stgmix) and help(stkey) for examples
</code></pre>

<hr>
<h2 id='rgmix'>Random bivariate Gaussian mixture density generation</h2><span id='topic+rgmix'></span>

<h3>Description</h3>

<p>Generates a pixel image of a bivariate normal mixture density observed on a bounded window using a specified number of contributing densities with randomly selected means and variance-covariance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgmix(N, window, v = 4, S = NULL, extras = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgmix_+3A_n">N</code></td>
<td>

<p>The number of Gaussian components to generate for the mixture.
</p>
</td></tr>
<tr><td><code id="rgmix_+3A_window">window</code></td>
<td>

<p>An object of class <code><a href="spatstat.geom.html#topic+owin">owin</a></code> giving the observational window on which the mixture density is defined.
</p>
</td></tr>
<tr><td><code id="rgmix_+3A_v">v</code></td>
<td>

<p>The degrees of freedom for the inverse-Wishart distribution of the variance-covariance matrices (must be at least 4). The default value of 4 ensures the generated covariance matrices are centered on <code>S</code>.
</p>
</td></tr>
<tr><td><code id="rgmix_+3A_s">S</code></td>
<td>

<p>A symmetric, positive-definite <code class="reqn">2 \times 2</code> scale matrix for the inverse-Wishart distribution of the variance-covariance matrices.
</p>
</td></tr>
<tr><td><code id="rgmix_+3A_extras">extras</code></td>
<td>

<p>A logical value indicating whether, in addition to returning the pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age of the final mixture density, to also return the randomly realised mean locations and corresponding variance-covariance matrices. See &lsquo;Value&rsquo;.
</p>
</td></tr>
<tr><td><code id="rgmix_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to <code><a href="#topic+sgmix">sgmix</a></code>. See &lsquo;Details&rsquo;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates and returns a bivariate Gaussian mixture density on a bounded <code>window</code> based on <code>N</code> randomly generated mean locations and corresponding randomly generated variance-covariance matrices. First, the <code>N</code> mean locations are generated based on a uniform distribution over the spatial <code>window</code>. Each location is then associated with a covariance matrix generated from an inverse-Wishart distribution with <code>v</code> degrees of freedom and scale matrix <code>S</code>.
</p>
<p>Once the above steps are completed, the function calls <code><a href="#topic+sgmix">sgmix</a></code> with the chosen mean and covariance matrices, thereby creating the Gaussian mixture. Resolution and other aspects of this call can be controlled by using <code>...</code>, passing the contents internally to <code><a href="#topic+sgmix">sgmix</a></code>. By default, all generated Gaussian components have equal weight in contributing to the final mixture density. The user can alter this by passing <code>p0</code> and <code>p</code> to the <code>...</code>, though should take care that the length of <code>p</code> is <code>N</code>, and that <code>p0</code> and <code>p</code> sum to 1, as outlined in the documentation for <code><a href="#topic+sgmix">sgmix</a></code>.
</p>


<h3>Value</h3>

<p>If <code>extras = FALSE</code> (default), then a pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age of the final mixture density. If <code>extras = TRUE</code>, a list is returned with members <code>f</code> (the pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age of the final mixture density); <code>mn</code> (a <code class="reqn">2 \times</code> <code>N</code> matrix with each column giving the mean location of each of the <code>N</code> Gaussian bumps); and <code>vcv</code> (a <code class="reqn">2 \times 2 \times</code> <code>N</code> array with layers giving the covariance matrices associated with the means in the columns of <code>mn</code>).
</p>


<h3>Author(s)</h3>

<p>A.K. Redmond and T.M. Davies</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(321)
dens1 &lt;- rgmix(7,window=toywin)
plot(dens1)

set.seed(456)
dens2 &lt;- rgmix(7,window=toywin)
plot(dens2)

# Explicitly return details of generated means and covariances
set.seed(321)
dens1.detailed &lt;- rgmix(7,window=toywin,extras=TRUE)
dens1.detailed$f
dens1.detailed$mn
dens1.detailed$vcv

# Set underlying uniform proportion and compare with dens2 from above
set.seed(456)
dens2.wunif &lt;- rgmix(7,window=toywin,p0=0.3)
plot(rpoint(500,dens2))
plot(rpoint(500,dens2.wunif))

# Explicitly setting scale matrix for inverse-wishart generation of covariances
dens3 &lt;- rgmix(3,window=toywin,S=matrix(c(0.025,-0.004,-0.004,0.02),2))
plot(dens3)
</code></pre>

<hr>
<h2 id='rpoispoly'>
Generate a Poisson point pattern in a polygonal window
</h2><span id='topic+rpoispoly'></span>

<h3>Description</h3>

<p>Generates a single realisation of a spatial Poisson point process based on a pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age and a polygonal <code><a href="spatstat.geom.html#topic+owin">owin</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpoispoly(z, w = NULL, correction = 1.1, maxpass = 50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rpoispoly_+3A_z">z</code></td>
<td>
<p>A pixel image of class <code><a href="spatstat.geom.html#topic+im">im</a></code> defining the spatial intensity function of the points. The number of points generated, <code class="reqn">n</code>, will be found as a randomly generated Poisson variate with mean parameter equal to the integral of <code>z</code>.</p>
</td></tr>
<tr><td><code id="rpoispoly_+3A_w">w</code></td>
<td>
<p>A polygonal window of class <code><a href="spatstat.geom.html#topic+owin">owin</a></code>. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="rpoispoly_+3A_correction">correction</code></td>
<td>
<p>An adjustment to the number of points generated at the initial pass of the internal loop in an effort to minimise the total number of passes required to reach <code class="reqn">n</code> points. See &lsquo;Details&rsquo; and &lsquo;Warning&rsquo;.</p>
</td></tr>
<tr><td><code id="rpoispoly_+3A_maxpass">maxpass</code></td>
<td>
<p>The maximum number of passes allowed before the function exits. If this is reached before <code class="reqn">n</code> points are found that fall within <code>w</code>, a warning is issued.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper function for <code><a href="sparr.html#topic+rimpoly">rimpoly</a></code> that operates much like <code><a href="spatstat.random.html#topic+rpoispp">rpoispp</a></code>, but with artificial corrections at the edges of boundary pixels. This allows the user to generate a realisation of a 2D Poisson point process using a supplied pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age as the spatial intensity function, but return the result with a polygonal <code><a href="spatstat.geom.html#topic+owin">owin</a></code> instead of a binary image mask.
</p>
<p>Let <code class="reqn">n</code> be a randomly generated integer from a Poisson distribution with mean given by the integral of the intensity function <code>z</code>. When the user specifies their own polygonal window in <code>w</code>, a <code>while</code> loop is called and repeated as many
times as necessary (up to <code>maxpass</code> times) to find <code class="reqn">n</code> points inside <code>w</code> (when <code>w = NULL</code>, then the union of the pixels of <code>z</code>
is used, obtained via <code>as.polygonal(Window(z))</code>). The loop is necessary because the standard behaviour of <code><a href="spatstat.random.html#topic+rpoispp">rpoispp</a></code> can (and often does)
yield points that sit in corners of pixels which lie outside a corresponding irregular polygon <code>w</code>.
</p>
<p>The <code>correction</code> argument is used to determine how many points are generated initially,
which will be <code>ceiling(correction*n)</code>; to minimise the number of required passes over the loop this is by default set to give a number slightly higher than the requested <code class="reqn">n</code>.
</p>
<p>An error is thrown if <code>Window(z)</code> and <code>w</code> do not overlap.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> containing the Poisson-generated points, defined with the polygonal <code><a href="spatstat.geom.html#topic+owin">owin</a></code>, <code>w</code>.
</p>


<h3>Warning</h3>

<p>Note that this is an artificial correction that forces the Poisson-generated number of <code class="reqn">n</code> points to be found inside <em>any</em> supplied polygon <code>w</code> (even if <code>w</code> only partially covers the domain of <code>z</code>). As such, this function only makes sense in terms of the theory of a Poisson point process if the polygon <code>w</code> corresponds exactly to the pixellised intensity. For practical intents and purposes, it therefore must be assumed in using this function that a supplied polygon <code>w</code> is/was the original basis for the discretisation into the pixel image for the purposes of producing the intensity <code>z</code>, and hence that any adverse effects arising from imposing <code>w</code> as the window of the final result are negligible. See &lsquo;Examples&rsquo;.
</p>


<h3>Author(s)</h3>

<p>T.M. Davies
</p>


<h3>References</h3>

<p>Diggle, P.J. (2014) <em>Statistical Analysis of Spatial and Spatiotemporal Point Patterns</em>, 3rd Ed, Chapman &amp; Hall, Boca Raton, USA.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.random.html#topic+rpoint">rpoint</a></code>, <code><a href="sparr.html#topic+rimpoly">rimpoly</a></code>, <code><a href="spatstat.random.html#topic+rpoispp">rpoispp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mn &lt;- cbind(c(0.25,0.8),c(0.31,0.82),c(0.43,0.64),c(0.63,0.62),c(0.21,0.26))
v1 &lt;- matrix(c(0.0023,-0.0009,-0.0009,0.002),2)
v2 &lt;- matrix(c(0.0016,0.0015,0.0015,0.004),2)
v3 &lt;- matrix(c(0.0007,0.0004,0.0004,0.0011),2)
v4 &lt;- matrix(c(0.0023,-0.0041,-0.0041,0.0099),2)
v5 &lt;- matrix(c(0.0013,0.0011,0.0011,0.0014),2)
vr &lt;- array(NA,dim=c(2,2,5))
for(i in 1:5) vr[,,i] &lt;- get(paste("v",i,sep=""))
intens &lt;- sgmix(mean=mn,vcv=vr,window=toywin,p0=0.1,int=500)

aa &lt;- rpoispp(intens) # Default spatstat function
bb &lt;- rpoispoly(intens) # No polygon supplied; just uses pixel union
cc &lt;- rpoispoly(intens,w=toywin) # Original irregular polygon

plot(intens,log=TRUE)
plot(aa,main=paste("aa\nn =",npoints(aa)))
plot(bb,main=paste("bb\nn =",npoints(bb)))
plot(cc,main=paste("cc\nn =",npoints(cc)))
</code></pre>

<hr>
<h2 id='rrmix'>Spatial relative risk surface generation</h2><span id='topic+rrmix'></span><span id='topic+rrim'></span>

<h3>Description</h3>

<p>Generates an appropriately scaled spatial (bivariate) relative risk surface using a supplied control density and <code class="reqn">N</code> isotropic Gaussian-style hotspots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrmix(g, rhotspots, rsds, rweights, rbase = 1, log = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rrmix_+3A_g">g</code></td>
<td>

<p>A pixel <code><a href="spatstat.geom.html#topic+im">im</a>age</code> representing the control density; this will be internally rescaled to integrate to 1 if it does not already do so.
</p>
</td></tr>
<tr><td><code id="rrmix_+3A_rhotspots">rhotspots</code></td>
<td>

<p>A <code class="reqn">2 \times N</code> matrix giving the centers of the <code class="reqn">N</code> peaks and troughs in the relative risk density.
</p>
</td></tr>
<tr><td><code id="rrmix_+3A_rsds">rsds</code></td>
<td>

<p>A positive numeric vector of length <code class="reqn">N</code> giving the isotropic standard deviations for each relative Gaussian peak or trough.
</p>
</td></tr>
<tr><td><code id="rrmix_+3A_rweights">rweights</code></td>
<td>

<p>A vector of length <code class="reqn">N</code> giving relative weightings for each peak (positive weights) or trough (negative).
</p>
</td></tr>
<tr><td><code id="rrmix_+3A_rbase">rbase</code></td>
<td>

<p>The base level of the relative risk surface (default is 1). The peaks and troughs will be added or subtracted from this base level prior to normalisation.
</p>
</td></tr>
<tr><td><code id="rrmix_+3A_log">log</code></td>
<td>

<p>A logical value. If <code>TRUE</code> (default), the relative risk surface is returned logged.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A useful tool for the comparison of two estimated density functions on the same spatial region <code class="reqn">W \subset R^2</code> is the <em>relative risk function</em>, <code class="reqn">r</code>, (Bithell, 1990; 1991; Kelsall and Diggle, 1995), defined simply as a density-ratio: 
</p>
<p><code class="reqn">r(x) = f(x) / g(x); x \in W.</code>
</p>
<p>Various methods have been developed to improve estimation of <code class="reqn">r</code>, most commonly with a motivation in geographical epidemiology, where the &lsquo;numerator&rsquo; density <code class="reqn">f</code> pertains to the observed disease cases and the &lsquo;denominator&rsquo; density <code class="reqn">g</code> reflects the distribution of the at-risk controls (Kelsall and Diggle, 1995; Hazelton and Davies, 2009; Davies and Hazelton, 2010). To test newly developed methodology, simulations based on known relative risk scenarios are usually necessary. This function allows the user to design such scenarios, as used in Hazelton and Davies (2009), Davies and Hazelton (2010), and Davies (2013) for example.
</p>
<p>This function calculates a relative risk surface based on <code class="reqn">N</code> Gaussian-style &lsquo;bumps&rsquo; added and subtracted from a base level of <code>rbase</code>, with the peaks and troughs centered at the coordinates given by <code>rhotspots</code> with relative weights of <code>rweights</code> and isotropic standard deviations of <code>rsds</code>. The risk surface <code class="reqn">r</code> is computed as
</p>
<p><code class="reqn">r(x) \propto </code> <code>rbase</code> <code class="reqn">+ \sum_{i=1}^{N}</code> <code>rweights[</code><code class="reqn">i</code><code>]</code><code class="reqn">*exp(-0.5*</code><code>rsds[</code><code class="reqn">i</code><code>]</code><code class="reqn">^(-2)*</code>||<code class="reqn">x-</code><code>rhotspots[,</code><code class="reqn">i</code><code>]</code>||<code class="reqn">^2)</code>
</p>
<p>where || . || denotes Euclidean norm. Because <code class="reqn">f</code> and <code class="reqn">g</code> are both densities, the risk surface as defined above must then be rescaled with respect to the supplied control density <code class="reqn">g</code> (argument <code>g</code>) to ensure that
</p>
<p><code class="reqn">\int_W r(x)g(x) dx = 1</code>
</p>
<p>This is automatically performed inside the function. The case density that gives rise to the designed <code class="reqn">r</code> is then easily recovered because <code class="reqn">f = r * g</code>. By default, the function returns the log-relative risk surface <code class="reqn">\log r = \log f - \log g</code> alongside the case and control densities.
</p>


<h3>Value</h3>

<p>An object of class <code>rrim</code>. This is a <code><a href="spatstat.geom.html#topic+solist">solist</a></code> of three pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>ages: <code>f</code> as the case density, <code>g</code> the control density (a copy of the argument of the same name, integrating to 1), and <code>r</code> as the (log) relative risk surface.
</p>


<h3>Author(s)</h3>

<p>A.K. Redmond and T.M. Davies</p>


<h3>References</h3>

<p>Bithell, J.F. (1990), An application of density estimation to geographical epidemiology, <em>Statistics in Medicine</em>, <b>9</b>, 691-701.<br /><br />
Bithell, J.F. (1991), Estimation of relative risk functions, <em>Statistics in Medicine</em>, <b>10</b>, 1745-1751.<br /><br />
Davies, T.M. (2013), Jointly optimal bandwidth selection
for the planar kernel-smoothed density-ratio, <em>Spatial and
Spatio-temporal Epidemiology</em>, <b>5</b>, 51-65.<br /><br />
Davies, T.M. and Hazelton, M.L. (2010), Adaptive kernel estimation of spatial relative risk, <em>Statistics in Medicine</em>, <b>29</b>(23) 2423-2437.<br /><br />
Kelsall, J.E. and Diggle, P.J. (1995a), Kernel estimation of relative risk, <em>Bernoulli</em>, <b>1</b>, 3-16.<br /><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
gg &lt;- rgmix(3,window=toywin,S=matrix(c(0.08^2,0,0,0.1^2),nrow=2),p0=0.2)

rho &lt;- rrmix(g=gg,
             rhotspots=cbind(c(0.8,0.3),c(0.4,0.4),c(0.6,0.5),c(0.3,0.5)),
             rsds=c(0.005,0.025,0.01,0.025),
             rweights=c(3,2,10,5)*10)

rho.sample &lt;- rrpoint(c(400,800),rho,toywin)


oldpar &lt;- par(mfrow=c(2,2))
plot(rho$g,main="control density")
plot(rho$f,main="case density")
plot(rho$r,main="log relative risk surface")
plot(rho.sample$controls,main="sample data")
points(rho.sample$cases,col=2)
legend("topright",col=2:1,legend=c("cases","controls"),pch=1)
par(oldpar)
</code></pre>

<hr>
<h2 id='rrpoint'>
Generate random case/control points in space or space-time
</h2><span id='topic+rrpoint'></span><span id='topic+rrstpoint'></span>

<h3>Description</h3>

<p>Generates a pair of random, independent point patterns corresponding to a case density and a control density, for relative risk analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrpoint(n, r, W = NULL, correction = 1.1, maxpass = 50)
rrstpoint(n, r, W = NULL, correction = 1.5, maxpass = 50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rrpoint_+3A_n">n</code></td>
<td>

<p>The number of points to be generated. This must be a numeric vector of length 2 giving the number of points to generate for the case and control densities respectively. Alternatively a single number can be supplied; then the same number of points is generated for both densities.
</p>
</td></tr>
<tr><td><code id="rrpoint_+3A_r">r</code></td>
<td>

<p>The relative risk surface object containing the definitions of the case and control probability densities: an object of class <code><a href="#topic+rrim">rrim</a></code> or <code><a href="sparr.html#topic+risk">rrs</a></code> for <code>rrpoint</code>, or an object of class <code><a href="#topic+rrstim">rrstim</a></code> or <code><a href="sparr.html#topic+spattemp.risk">rrst</a></code> for <code>rrstpoint</code>.
</p>
</td></tr>
<tr><td><code id="rrpoint_+3A_w">W</code></td>
<td>

<p>The polygonal <code><a href="spatstat.geom.html#topic+owin">owin</a></code> defining the spatial window on which the density is defined. If <code>NULL</code>, this will be set to the <code><a href="spatstat.geom.html#topic+as.polygonal">as.polygonal</a></code> version of the pixel images stored in <code>r</code>. See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="rrpoint_+3A_correction">correction</code></td>
<td>

<p>An adjustment to the number of points generated at the initial pass of the internal loop in an effort to minimise the total number of passes required to reach <code>n</code> points.
</p>
</td></tr>
<tr><td><code id="rrpoint_+3A_maxpass">maxpass</code></td>
<td>

<p>The maximum number of passes allowed before the function exits. If this is reached before <code>n</code> points are found with respect to the spatial or spatiotemporal domains of <code>r</code>, a warning is issued.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions randomly generate a pair of independent spatial or spatiotemporal point patterns of <code>n</code> points based on the case and control density functions stored in <code>r</code>. At any given pass for each density, <code>n</code> * <code>correction</code> points are generated and rejection sampling is used to accept some of the points; this is repeated until the required number of points is found.
</p>
<p>The argument <code>W</code> is optional, but is useful when the user wants the spatial window of the resulting point pattern to be a corresponding irregular polygon, as opposed to being based on the boundary of a binary image mask (which, when the pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>ages in <code>r</code> are converted to a polygon directly, gives jagged edges based on the union of the pixels).
</p>


<h3>Value</h3>

<p>A list with two components, <code>cases</code> and <code>controls</code>, each of which is an object of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> containing the <code>n</code> generated points. for spatiotemporal densities, the <code><a href="spatstat.geom.html#topic+marks">marks</a></code> of the object will contain the correspondingly generated observation times.
</p>


<h3>Author(s)</h3>

<p>T.M. Davies
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using 'rrim' object:
set.seed(1)
gg &lt;- rgmix(3,window=toywin,S=matrix(c(0.08^2,0,0,0.1^2),nrow=2),p0=0.2)
rho &lt;- rrmix(g=gg,
             rhotspots=cbind(c(0.8,0.3),c(0.4,0.4),c(0.6,0.5),c(0.3,0.5)),
             rsds=c(0.005,0.025,0.01,0.025),
             rweights=c(3,2,10,5)*10)

rho.sample &lt;- rrpoint(n=c(400,800),r=rho,W=toywin)

oldpar &lt;- par(mfrow=c(2,2))
plot(rho$g,main="control density")
plot(rho$f,main="case density")
plot(rho$r,main="log relative risk surface")
plot(rho.sample$controls,main="sample data")
points(rho.sample$cases,col=2)
legend("topright",col=2:1,legend=c("cases","controls"),pch=1)
par(oldpar)


# Using 'rrs' object:
require("sparr")
data(pbc)
pbccas &lt;- split(pbc)$case
pbccon &lt;- split(pbc)$control
h0 &lt;- OS(pbc,nstar="geometric")
f &lt;- bivariate.density(pbccas,h0=h0,hp=2,adapt=TRUE,pilot.density=pbccas,
                       edge="diggle",davies.baddeley=0.05,verbose=FALSE)
g &lt;- bivariate.density(pbccon,h0=h0,hp=2,adapt=TRUE,pilot.density=pbccas,
                       edge="diggle",davies.baddeley=0.05,verbose=FALSE)
pbcrr &lt;- risk(f,g,tolerate=TRUE,verbose=FALSE)

pbcrr.pt &lt;- rrpoint(n=1000,r=pbcrr)

par(mfrow=c(1,3))
plot(pbcrr)
plot(pbcrr.pt$cases)
plot(pbcrr.pt$controls)


# Using 'rrstim' object:
set.seed(321)
gg &lt;- rgmix(7,window=shp2)
rsk &lt;- rrstmix(g=gg,rhotspots=matrix(c(-1,-1,2,2.5,0,5),nrow=3),
               rsds=sqrt(cbind(rep(0.75,3),c(0.05,0.01,0.5))),
               rweights=c(-0.4,7),tlim=c(0,6),tres=64)
plot(rsk$r,fix.range=TRUE)

rsk.pt &lt;- rrstpoint(1000,r=rsk,W=shp2)

par(mfrow=c(1,2))
plot(rsk.pt$cases)
plot(rsk.pt$controls)


# Using 'rrst' object:
require("sparr")
data(fmd)
fmdcas &lt;- fmd$cases
fmdcon &lt;- fmd$controls

f &lt;- spattemp.density(fmdcas,h=6,lambda=8)
g &lt;- bivariate.density(fmdcon,h0=6)
rho &lt;- spattemp.risk(f,g)

rho.pt &lt;- rrstpoint(1000,r=rho)

par(mfrow=c(1,2))
plot(rho.pt$cases)
plot(rho.pt$controls)

</code></pre>

<hr>
<h2 id='rrstmix'>
Spatiotemporal relative risk surface generation
</h2><span id='topic+rrstmix'></span><span id='topic+rrstim'></span>

<h3>Description</h3>

<p>Generates an appropriately scaled spatiotemporal (trivariate) relative risk surface using a supplied control density and <code class="reqn">N</code> Gaussian-style hotspots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrstmix(g, rhotspots, rsds, rweights, rbase = 1, log = TRUE,
        tlim = NULL, tres = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rrstmix_+3A_g">g</code></td>
<td>

<p>The control density as a <code><a href="#topic+stim">stim</a></code>, <code><a href="sparr.html#topic+spattemp.density">stden</a></code>, or <code><a href="spatstat.geom.html#topic+im">im</a></code> object; this will be internally rescaled to integrate to 1 if it does not already do so. When a <code><a href="#topic+stim">stim</a></code> or <code><a href="sparr.html#topic+spattemp.density">stden</a></code> object, the resolution and domain of the final result will be the same as this. When this argument is passed an object of class <code><a href="spatstat.geom.html#topic+im">im</a></code>, the function assumes a static (unchanging) control density over time (see Fernando and Hazelton, 2014), and the user must additionally specify <code>tlim</code> and <code>tres</code>.
</p>
</td></tr>
<tr><td><code id="rrstmix_+3A_rhotspots">rhotspots</code></td>
<td>

<p>A <code class="reqn">3 \times N</code> matrix specifying the spatiotemporal coordinates of the <code class="reqn">N</code> peaks and troughs in the relative risk density. The three entries down each column will be respectively interpreted as <code class="reqn">x</code>-coord., <code class="reqn">y</code>-coord., and time-coordinate of each Gaussian bump.
</p>
</td></tr>
<tr><td><code id="rrstmix_+3A_rsds">rsds</code></td>
<td>

<p>A <code class="reqn">3 \times N</code> strictly positive numeric matrix specifying the standard deviations along each axis of each of the <code class="reqn">N</code> bumps, the ordering of the components in each column is the same as <code>rhotspots</code>.
</p>
</td></tr>
<tr><td><code id="rrstmix_+3A_rweights">rweights</code></td>
<td>

<p>A vector of length <code class="reqn">N</code> giving relative weightings for each peak (positive weight) or trough (negative).
</p>
</td></tr>
<tr><td><code id="rrstmix_+3A_rbase">rbase</code></td>
<td>

<p>The base level of the relative risk surface (default is 1). The peaks and troughs will be added or subtracted from this base level prior to normalisation.
</p>
</td></tr>
<tr><td><code id="rrstmix_+3A_log">log</code></td>
<td>

<p>A logical value. If <code>TRUE</code> (default), the relative risk surface is returned logged.
</p>
</td></tr>
<tr><td><code id="rrstmix_+3A_tlim">tlim</code></td>
<td>

<p>Only used if <code>g</code> is a pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age object. A vector of length 2 giving the boundaries of the time interval on which the relative risk surface will be defined.
</p>
</td></tr>
<tr><td><code id="rrstmix_+3A_tres">tres</code></td>
<td>

<p>Only used if <code>g</code> is a pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age object. The resolution along the temporal axis of the final result.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the spatiotemporal (trivariate) equivalent of <code><a href="#topic+rrmix">rrmix</a></code>. See &lsquo;Details&rsquo; in the documentation for that function for more information.
</p>


<h3>Value</h3>

<p>An oject of class <code>rrstim</code>. This is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>f</code></td>
<td>
<p>An object of class <code><a href="#topic+stim">stim</a></code> giving the case density.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>A copy of the object passed to the argument <code>g</code>, possibly renormalised to integrate to 1 if this was necessary. If <code>g</code> was originally an <code><a href="spatstat.geom.html#topic+im">im</a></code>, this will be converted to an object of class <code><a href="#topic+stim">stim</a></code>.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>An object of class <code><a href="#topic+stim">stim</a></code> giving the (log) relative risk surface.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A.K. Redmond and T.M. Davies</p>


<h3>References</h3>

<p>Fernando, W.T.P.S. and Hazelton, M.L. (2014), Generalizing the spatial relative risk function, <em>Spatial and Spatio-temporal Epidemiology</em>, <b>8</b>, 1-10.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# time-varying control density
gg1 &lt;- stgmix(mean=matrix(c(2,1,3,0,-1,5),nrow=3),
             vcv=array(c(1,0,0,0,1,0,0,0,1,2,0,0,0,1,0,0,0,2),dim=c(3,3,2)),
             window=shp2,tlim=c(0,6))
rsk1 &lt;- rrstmix(g=gg1,rhotspots=matrix(c(-2,0,2,1,2,5.5),nrow=3),
               rsds=sqrt(cbind(rep(1.5,3),rep(0.25,3))),rweights=c(-0.5,5))
plot(rsk1$g,sleep=0.1,fix.range=TRUE)
plot(rsk1$f,sleep=0.1,fix.range=TRUE)
plot(rsk1$r,sleep=0.1,fix.range=TRUE)

# time-constant control density
set.seed(321)
gg2 &lt;- rgmix(7,window=shp2)
rsk2 &lt;- rrstmix(g=gg2,rhotspots=matrix(c(-1,-1,2,2.5,0,5),nrow=3),
                rsds=sqrt(cbind(rep(0.75,3),c(0.05,0.01,0.5))),
                rweights=c(-0.4,7),tlim=c(0,6),tres=64)
plot(rsk2$g,sleep=0.1,fix.range=TRUE)
plot(rsk2$f,sleep=0.1,fix.range=TRUE)
plot(rsk2$r,sleep=0.1,fix.range=TRUE)

</code></pre>

<hr>
<h2 id='rstpoint'>
Generate random points in space-time
</h2><span id='topic+rstpoint'></span>

<h3>Description</h3>

<p>Generates a random spatiotemporal point pattern containing <code class="reqn">n</code> independent, identically distributed points with a specified distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstpoint(n, f, W = NULL, correction = 1.5, maxpass = 50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rstpoint_+3A_n">n</code></td>
<td>

<p>The number of points to be generated.
</p>
</td></tr>
<tr><td><code id="rstpoint_+3A_f">f</code></td>
<td>

<p>The probability density of the points, an object of class <code><a href="#topic+stim">stim</a></code> or <code><a href="sparr.html#topic+spattemp.density">stden</a></code>.
</p>
</td></tr>
<tr><td><code id="rstpoint_+3A_w">W</code></td>
<td>

<p>The polygonal <code><a href="spatstat.geom.html#topic+owin">owin</a></code> defining the spatial window on which the density is defined. If <code>NULL</code>, this will be set to the <code><a href="spatstat.geom.html#topic+as.polygonal">as.polygonal</a></code> version of the pixel images stored in <code>f</code>. See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="rstpoint_+3A_correction">correction</code></td>
<td>

<p>An adjustment to the number of points generated at the initial pass of the internal loop in an effort to minimise the total number of passes required to reach <code>n</code> points.
</p>
</td></tr>
<tr><td><code id="rstpoint_+3A_maxpass">maxpass</code></td>
<td>

<p>The maximum number of passes allowed before the function exits. If this is reached before <code>n</code> points are found with respect to the spatiotemporal domain of <code>f</code>, a warning is issued.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function randomly generates a spatiotemporal point pattern of exactly <code>n</code> points based on the density function <code>f</code>. At any given pass, <code>n</code> * <code>correction</code> points are generated and rejection sampling is used to accept some of the points; this is repeated until the required number of points is found.
</p>
<p>The argument <code>W</code> is optional, but is useful when the user wants the spatial window of the resulting point pattern to be a corresponding irregular polygon, as opposed to being based on the boundary of a binary image mask (which, when the pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>ages in <code>f</code> are converted to a polygon directly, gives jagged edges based on the union of the pixels).
</p>


<h3>Value</h3>

<p>An object of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> containing the <code>n</code> generated points. The <code><a href="spatstat.geom.html#topic+marks">marks</a></code> of the object contain the correspondingly generated observation times.
</p>


<h3>Author(s)</h3>

<p>A.K. Redmond and T.M. Davies
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r1a &lt;- sgmix(cbind(c(0.5,0.5)),vcv=0.01,window=toywin,p0=0.5,p=c(0.5),res=128)
r1b &lt;- sgmix(cbind(c(0.5,0.5),c(0.4,0.6)),vcv=c(0.06,0.015),window=toywin,
             p0=0.1,p=c(0.5,0.4),res=128)
r1c &lt;- sgmix(cbind(c(0.4,0.6)),vcv=c(0.1),window=toywin,p0=0.1,p=c(0.9),res=128)
sts1 &lt;- stkey(start=r1a,
              stop=r1c,
              tlim=c(1,10),
              tres=64,
              window=toywin,
              kf=solist(r1a,r1b),
              kftimes=c(2,6),
              fscale=0.1+0.9*dnorm(seq(-3,3,length=64),mean=0,sd=1))
plot(sts1,sleep=0.1)

Y &lt;- rstpoint(500,sts1,W=toywin,correction=10,maxpass=500)
plot(Y)

require("rgl")
plot3d(Y$x,Y$y,marks(Y))

</code></pre>

<hr>
<h2 id='sgmix'>Bivariate Gaussian mixture density generation</h2><span id='topic+sgmix'></span>

<h3>Description</h3>

<p>Generates a pixel image of a specified bivariate normal mixture density observed on a bounded window.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgmix(mean, vcv, window, p0 = 0, p = NULL, resolution = 128, int = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sgmix_+3A_mean">mean</code></td>
<td>

<p>A <code class="reqn">2 \times N</code> matrix specifying the means of each of <code class="reqn">N</code> contributing normal densities.
</p>
</td></tr>
<tr><td><code id="sgmix_+3A_vcv">vcv</code></td>
<td>

<p>Either a <code class="reqn">2 \times 2 \times N</code> array specifying the variance-covariance matrices of each contributing density, or a numeric vector of length <code class="reqn">N</code> giving the isotropic <b>standard deviations</b> of each contributing density. An error is thrown if the function encounters anything but a symmetric, positive-definite covariation specification for each component.
</p>
</td></tr>
<tr><td><code id="sgmix_+3A_window">window</code></td>
<td>

<p>An object of class <code><a href="spatstat.geom.html#topic+owin">owin</a></code> giving the observational window on which the mixture density is defined.
</p>
</td></tr>
<tr><td><code id="sgmix_+3A_p0">p0</code></td>
<td>

<p>The proportion of uniform density that contributes to the mixture (default is 0).
</p>
</td></tr>
<tr><td><code id="sgmix_+3A_p">p</code></td>
<td>

<p>A numeric vector of the <code class="reqn">N</code> proportions for each contributing density (default is equal proportions for each density, after subtracting <code>p0</code>). Together, <code>p0</code> and <code>p</code> must sum to exactly 1.
</p>
</td></tr>
<tr><td><code id="sgmix_+3A_resolution">resolution</code></td>
<td>

<p>The number of pixels along each side of the grid for the pixel image (default is 128).
</p>
</td></tr>
<tr><td><code id="sgmix_+3A_int">int</code></td>
<td>

<p>A positive numeric value for post-hoc rescaling of the density (useful if the user wishes to return an <em>intensity</em> function). Defaults to 1 for no change in scaling.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age of a 2D density function made of a mixture of <code class="reqn">N</code> bivariate normals; each component is restricted to conserve probability mass over a bounded subset of the plane. A warning will appear if less than 1% of the integral of each Gaussian bump is inside the observational window.</p>


<h3>Value</h3>

<p>An object of class <code><a href="spatstat.geom.html#topic+im">im</a></code> giving the mixture density.
</p>


<h3>Author(s)</h3>

<p>A.K. Redmond
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example using isotropic standard deviations
m1 &lt;- c(0.4,0.5)
m2 &lt;- c(0.2,0.7)
s1 &lt;- 0.1
s2 &lt;- 0.025
dens1 &lt;- sgmix(mean=cbind(m1,m2),vcv=c(s1,s2),window=toywin,p0=0.3,p=c(0.5,0.2))

plot(dens1,log=TRUE)
pts1 &lt;- rpoint(200,dens1) # generate random points via spatstat.core::rpoint
points(pts1)


# Example using full covariance matrices
mn &lt;- cbind(c(0.25,0.8),c(0.31,0.82),c(0.43,0.64),c(0.63,0.62),c(0.21,0.26))
v1 &lt;- matrix(c(0.0023,-0.0009,-0.0009,0.002),2)
v2 &lt;- matrix(c(0.0016,0.0015,0.0015,0.004),2)
v3 &lt;- matrix(c(0.0007,0.0004,0.0004,0.0011),2)
v4 &lt;- matrix(c(0.0023,-0.0041,-0.0041,0.0099),2)
v5 &lt;- matrix(c(0.0013,0.0011,0.0011,0.0014),2)
vr &lt;- array(NA,dim=c(2,2,5))
for(i in 1:5) vr[,,i] &lt;- get(paste("v",i,sep=""))
dens2 &lt;- sgmix(mean=mn,vcv=vr,window=toywin,p0=0.1)

plot(dens2,log=TRUE)
pts2 &lt;- rpoint(200,dens2)
points(pts2)
</code></pre>

<hr>
<h2 id='spagmix-internal'>
Internal <code>spagmix</code> functions
</h2><span id='topic+spagmix-internal'></span><span id='topic+rw'></span><span id='topic+riw'></span>

<h3>Description</h3>

<p>Internal <code><a href="#topic+spagmix">spagmix</a></code> functions, only meant to be accessed by the user directly in a life-threatening situation.
</p>


<h3>Value</h3>

<p>A numeric matrix for internal calculations in <code><a href="#topic+rgmix">rgmix</a></code>.
</p>


<h3>Usage</h3>

<p><code>rw(a,A)</code><br />
<code>riw(b,B)</code><br />
</p>


<h3>Author(s)</h3>

<p>T.M. Davies</p>

<hr>
<h2 id='stgmix'>Trivariate Gaussian mixture density generation</h2><span id='topic+stgmix'></span><span id='topic+stim'></span>

<h3>Description</h3>

<p>Generates a pixel image array of a specified trivariate normal mixture density observed on a bounded window in space and time.</p>


<h3>Usage</h3>

<pre><code class='language-R'>stgmix(mean, vcv, window, tlim, p0 = 0, p = NULL, sres = 128, tres = sres, int = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stgmix_+3A_mean">mean</code></td>
<td>

<p>A <code class="reqn">3 x N</code> matrix specifying the means of each of <code class="reqn">N</code> contributing normal densities; each component in the order of (x-coord, y-coord, time-coord).
</p>
</td></tr>
<tr><td><code id="stgmix_+3A_vcv">vcv</code></td>
<td>

<p>A <code class="reqn">3 x 3 x N</code> array specifying the variance-covariance matrices of each contributing density.
</p>
</td></tr>
<tr><td><code id="stgmix_+3A_window">window</code></td>
<td>

<p>An object of class <code><a href="spatstat.geom.html#topic+owin">owin</a></code> giving the spatial observational window on which the mixture density is defined.
</p>
</td></tr>
<tr><td><code id="stgmix_+3A_tlim">tlim</code></td>
<td>

<p>A vector of length 2 giving the boundaries of the time interval on which the mixture density is defined.
</p>
</td></tr>
<tr><td><code id="stgmix_+3A_p0">p0</code></td>
<td>

<p>The proportion of uniform density that contributes to the final mixture (default is 0).
</p>
</td></tr>
<tr><td><code id="stgmix_+3A_p">p</code></td>
<td>

<p>A numeric vector of the <code class="reqn">N</code> proportions for each contributing density (default is equal proportions for each density, after subtracting <code>p0</code>). Together, <code>p0</code> and <code>p</code> must sum to exactly 1.
</p>
</td></tr>
<tr><td><code id="stgmix_+3A_sres">sres</code></td>
<td>

<p>The spatial resolution (number of pixels) along each side of the spatial grid (default is 128).
</p>
</td></tr>
<tr><td><code id="stgmix_+3A_tres">tres</code></td>
<td>

<p>The temporal resolution (default is to equate with <code>sres</code>).
</p>
</td></tr>
<tr><td><code id="stgmix_+3A_int">int</code></td>
<td>

<p>A positive numeric value for post-hoc rescaling of the density (useful if the user wishes to return a spatiotemporal <em>intensity</em> function). Defaults to 1 for no change in scaling.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a 3D array of a density function made up of a mixture of <code class="reqn">N</code> trivariate normals with the interpretation of a continuous probability density function in space-time. As such, each component is restricted to conserve mass over a 3D region specified by a fixed polygonal <code>window</code> in space, stretched over defined temporal limits (<code>tlim</code>). A warning will appear if less than 1% of the integral of each Gaussian bump is inside this observational spatiotemporal polyhedron.
</p>


<h3>Value</h3>

<p>An object of class <code>stim</code> giving the trivariate density. This is a list with six components:
</p>
<table role = "presentation">
<tr><td><code>a</code></td>
<td>
<p>The <code>sres</code> <code class="reqn">x</code> <code>sres</code> <code class="reqn">x</code> <code>tres</code> array of the specified density.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>A pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age version of <code>a</code>, provided as a <code><a href="spatstat.geom.html#topic+solist">solist</a></code> of length <code>tres</code>, with each member being the spatial <code><a href="spatstat.geom.html#topic+im">im</a></code>age slice of the 3D density at each of the time-coordinate values.</p>
</td></tr>
<tr><td><code>xcol</code></td>
<td>
<p>Grid coordinates in the spatial x-axis (corresponds to each spatial <code><a href="spatstat.geom.html#topic+im">im</a></code>age in <code>v</code>).</p>
</td></tr>
<tr><td><code>yrow</code></td>
<td>
<p>Grid coordinates in the spatial y-axis (corresponds to each spatial <code><a href="spatstat.geom.html#topic+im">im</a></code>age in <code>v</code>).</p>
</td></tr>
<tr><td><code>tlay</code></td>
<td>
<p>Grid coordinates in the temporal axis (corresponds to the order of the spatial <code><a href="spatstat.geom.html#topic+im">im</a></code>ages in <code>v</code>).</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>A copy of <code>window</code>, the spatial <code><a href="spatstat.geom.html#topic+owin">owin</a></code> upon which the density is defined.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A.K. Redmond and T.M. Davies</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require("abind")
m1 &lt;- c(0.3,0.3,2)
m2 &lt;- c(0.5,0.8,8)
m3 &lt;- c(0.7,0.6,7)
v1 &lt;- diag(c(0.01^2,0.01^2,1))
v2 &lt;- diag(c(0.005,0.005,0.5))
v3 &lt;- diag(c(0.005,0.005,0.5))
stg1 &lt;- stgmix(mean=cbind(m1,m2,m3),
               vcv=abind(v1,v2,v3,along=3),
               window=toywin,tlim=c(1,10),
               p0=0.1,tres=64)
plot(stg1,log=TRUE)


mn &lt;- matrix(c(0,0,0,-2,1,4,1,-2,8),nrow=3)
vr &lt;- array(c(1,0,0,0,1,0,0,0,1,1,0,0.5,0,1,0,0.5,0,3,1,0,0,0,2,0,0,0,1),
            dim=c(3,3,3))
stg2 &lt;- stgmix(mean=mn,vcv=vr,window=shp1,
               tlim=c(0,10),tres=50)
plot(stg2,fix.range=TRUE,sleep=0.1)

</code></pre>

<hr>
<h2 id='stintegral'>
Evaluate integral of a spatiotemporal object
</h2><span id='topic+stintegral'></span>

<h3>Description</h3>

<p>Integrates an object of class <code><a href="#topic+stim">stim</a></code> or <code><a href="sparr.html#topic+spattemp.density">stden</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stintegral(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stintegral_+3A_x">x</code></td>
<td>

<p>The object of class <code><a href="#topic+stim">stim</a></code> or <code><a href="sparr.html#topic+spattemp.density">stden</a></code> to be integrated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The integral is evaluated arithmetically as the sum of the product of the value of each voxel and the voxel area, for those voxels inside the relevant space-time window (i.e. ignoring <code>NA</code>s).
</p>


<h3>Value</h3>

<p>A single numeric value giving the integral sought.
</p>


<h3>Author(s)</h3>

<p>T.M. Davies
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# 'stim' objects
require("abind")
m1 &lt;- c(0.3,0.3,2)
m2 &lt;- c(0.5,0.8,8)
m3 &lt;- c(0.7,0.6,7)
v1 &lt;- diag(c(0.01^2,0.01^2,1))
v2 &lt;- diag(c(0.005,0.005,0.5))
v3 &lt;- diag(c(0.005,0.005,0.5))
stg1 &lt;- stgmix(mean=cbind(m1,m2,m3),vcv=abind(v1,v2,v3,along=3),
               window=toywin,tlim=c(0,10),p0=0.1,tres=64)
stg2 &lt;- stgmix(mean=cbind(m1,m2,m3),vcv=abind(v1,v2,v3,along=3),
               window=toywin,tlim=c(0,10),p0=0.1,tres=64,int=200)
stintegral(stg1)
stintegral(stg2)

# 'sten' objects
require("sparr")
data(burk)
hlam &lt;- OS.spattemp(burk$cases)
bden &lt;- spattemp.density(burk$cases,h=hlam[1],lambda=hlam[2],sres=64,verbose=FALSE)
stintegral(bden)

</code></pre>

<hr>
<h2 id='stkey'>
Spatiotemporal density generation via keyframe interpolation
</h2><span id='topic+stkey'></span>

<h3>Description</h3>

<p>Uses the supplied spatial pixel images and scalings to linearly interpolate the behaviour of the function over time, creating a trivariate density function in space-time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stkey(start, stop, tlim, kf = NULL, tres = 64,
      kftimes = NULL, fscales = NULL, window = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stkey_+3A_start">start</code></td>
<td>

<p>The spatial pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age corresponding to the spatial density at start of the time interval. May be unnormalised, the function internally rescales all supplied spatial images to integrate to 1.
</p>
</td></tr>
<tr><td><code id="stkey_+3A_stop">stop</code></td>
<td>

<p>The pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age for the end of the time interval. Must be compatible with <code>start</code>, in that it is defined over the same spatial domain and is of identical resolution.
</p>
</td></tr>
<tr><td><code id="stkey_+3A_tlim">tlim</code></td>
<td>

<p>A numeric vector of length 2 representing the temporal window i.e. the time interval over which the interpolation takes place.
</p>
</td></tr>
<tr><td><code id="stkey_+3A_kf">kf</code></td>
<td>

<p>A <code><a href="spatstat.geom.html#topic+solist">solist</a></code> of the pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>ages of the keyframes between <code>start</code> and <code>stop</code>. If supplied, each image must be compatible with <code>start</code> and <code>stop</code>. If unsupplied, the resulting interpolation is performed only on <code>start</code> and <code>stop</code>
</p>
</td></tr>
<tr><td><code id="stkey_+3A_tres">tres</code></td>
<td>

<p>The resolution of the resulting array in the time dimension (default is 64).
</p>
</td></tr>
<tr><td><code id="stkey_+3A_kftimes">kftimes</code></td>
<td>

<p>A vector of times that position the interim keyframes in <code>kf</code> between <code>tlim[1]</code> and <code>tlim[2]</code>. Ignored if <code>kf = NULL</code>. If unsupplied (<code>NULL</code>), but <code>kf</code> is present, the function simply positions the images of <code>kf</code> at evenly spaced time points in the <code>tlim</code> interval.
</p>
</td></tr>
<tr><td><code id="stkey_+3A_fscales">fscales</code></td>
<td>

<p>A numeric vector of unnormalised, relative point-intensity scales. This may be provided either as of <code>length(kf)</code> + 2, so the point intensities assinged to each frame in the order <code>c(start,</code>&lt;entries of <code>kf</code>&gt;<code>,stop)</code>, or of length <code>tres</code>. If unsupplied, each spatial frame is simply given equal weight. See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="stkey_+3A_window">window</code></td>
<td>

<p>An object of class <code><a href="spatstat.geom.html#topic+owin">owin</a></code> giving the polygonal spatial observational window on which the density is defined. If <code>NULL</code>, the polygon is simply obtained from the union of pixel values in the supplied images.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function interpolates in a pixel-wise fashion between the <code><a href="spatstat.geom.html#topic+im">im</a></code> objects supplied as <code>start</code> and <code>stop</code> (and <code>kf</code> if supplied), placing them as keyframes at the times in <code>tlim</code> (for <code>start</code> and <code>stop</code>) and <code>kftimes</code> (for the members of <code>kf</code>). The final result is rescaled such that its total integrated volume over the defined spatiotemporal domain is 1, yeilding a trivariate density function.
</p>
<p>If <code>fscale</code> is a vector of length <code>tres</code>, each element will correspond to the <b>relative</b> overall scaling of one of the resulting interpolated pixel images. If it is of length <code>length(kf) + 2</code>, the scales will correspond to <code>start</code>, each keyframe in <code>kf</code> and <code>stop</code> in that order. The values in this argument are only interpretable in a relative sense: for example, with a single keyframe suppled to <code>kf</code> (in addition to the required <code>start</code> and <code>stop</code>), then <code>fscales = c(0.5,1,0.5)</code> has exactly the same effect on the final result as <code>fscales = c(1,2,1)</code>, and is interpreted as yielding a point density that reaches twice the concentration at the time of the supplied keyframe relative to the <code>start</code> and <code>stop</code> margins. Supplying <code>fscale</code> as a vector of length <code>tres</code> thus allows finer control over the relative point density over time, such as for the incorporation of harmonic seasonal variation.
</p>


<h3>Value</h3>

<p>Like <code><a href="#topic+stgmix">stgmix</a></code>, an object of class <code><a href="#topic+stim">stim</a></code> giving the trivariate density. This is a list with six components:
</p>
<table role = "presentation">
<tr><td><code>a</code></td>
<td>
<p>The <code>xr</code> <code class="reqn">x</code> <code>yr</code> <code class="reqn">x</code> <code>tres</code> array of the specified density (where <code>xr</code> and <code>yr</code> are used here to denote the spatial resolution along the x- and y-axes; this is governed in <code>stkey</code> by the images initally supplied to <code>start</code> and <code>stop</code>).</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>A pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age version of <code>a</code>, provided as a <code><a href="spatstat.geom.html#topic+solist">solist</a></code> of length <code>tres</code>, with each member being the spatial <code><a href="spatstat.geom.html#topic+im">im</a></code>age slice of the 3D density at each of the time-coordinate values.</p>
</td></tr>
<tr><td><code>xcol</code></td>
<td>
<p>Grid coordinates in the spatial x-axis (corresponds to each spatial <code><a href="spatstat.geom.html#topic+im">im</a></code>age in <code>v</code>).</p>
</td></tr>
<tr><td><code>yrow</code></td>
<td>
<p>Grid coordinates in the spatial y-axis (corresponds to each spatial <code><a href="spatstat.geom.html#topic+im">im</a></code>age in <code>v</code>).</p>
</td></tr>
<tr><td><code>tlay</code></td>
<td>
<p>Grid coordinates in the temporal axis (corresponds to the order of the spatial <code><a href="spatstat.geom.html#topic+im">im</a></code>ages in <code>v</code>).</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>A copy of <code>window</code>, the spatial <code><a href="spatstat.geom.html#topic+owin">owin</a></code> upon which the density is defined.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A.K. Redmond and T.M. Davies
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mn &lt;- matrix(c(0,0,1,2,0.5,-1),nrow=2)
vr &lt;- array(c(0.2,0,0,2,1,0,0,1,1,0.3,0.3,0.5),dim=c(2,2,3))
im1 &lt;- sgmix(mn,c(1,2,1),shp1,p=c(0.4,0.3,0.3))
im2 &lt;- sgmix(matrix(c(-3,0,0,-2,-1,2),nrow=2),c(3,1,1),shp1,p=c(0.4,0.3,0.3))
im3 &lt;- sgmix(mn,vr,shp1,p0=0.1)

kf1 &lt;- stkey(start=im1,stop=im2,tlim=c(5,20),window=shp1)
plot(kf1)

kf2 &lt;- stkey(start=im1,stop=im1,tlim=c(0,15),kf=solist(im1,im1),kftimes=c(2,8),
             fscale=c(1,2,1.5,1),window=shp1)
plot(kf2,fix.range=TRUE)

kf3 &lt;- stkey(start=im1,stop=im2,tlim=c(0,20),kf=solist(im1,im2),kftimes=c(8,12),
             fscale=c(1,2,2,1),window=shp1)
plot(kf3,fix.range=TRUE)

ff &lt;- c(sin((1:64)/3)+1.5)
plot(ff,type="l")
kf4 &lt;- stkey(start=im1,stop=im2,kf=solist(im3),kftimes=25,tlim=c(0,50),fscale=ff,window=shp1)
plot(kf4,fix.range=TRUE)

</code></pre>

<hr>
<h2 id='toywin'>
Toy Windows
</h2><span id='topic+toywin'></span><span id='topic+heart'></span><span id='topic+bx'></span><span id='topic+shp1'></span><span id='topic+shp2'></span><span id='topic+star'></span>

<h3>Description</h3>

<p>Synthetic spatial windows for use in testing, simulations and demonstrations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bx)
data(heart)
data(shp1)
data(shp2)
data(star)
data(toywin)
</code></pre>


<h3>Format</h3>

<p>Each of these is a single closed polygon of class <code><a href="spatstat.geom.html#topic+owin">owin</a></code>.
</p>

<ul>
<li><p><code>bx</code> is a box on [-5,5]^2.
</p>
</li>
<li><p><code>heart</code> is a heart, professing love for all things <code><a href="spatstat.html#topic+spatstat-package">spatstat</a></code>.
</p>
</li>
<li><p><code>shp1</code> is shape of mystery.
</p>
</li>
<li><p><code>shp2</code> is a slightly more symmetric shape of mystery.
</p>
</li>
<li><p><code>star</code> is a star that shines brightly in even non-spatial contexts.
</p>
</li>
<li><p><code>toywin</code> is the eponymous toy window used in publications e.g. Davies &amp; Lawson (2019).
</p>
</li></ul>



<h3>Details</h3>

<p>These are lazy-loaded so may be called directly by name upon loading of <code>spagmix</code>.
</p>


<h3>Author(s)</h3>

<p>A.K. Redmond and T.M. Davies</p>


<h3>References</h3>

<p>Davies, T.M. and Lawson, A.B. (2019), An evaluation of likelihood-based bandwidth selectors for spatial and spatiotemporal kernel estimates, <em>Journal of Statistical Computation and Simulation</em>, <b>89</b> 1131-1152.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(mfrow=c(2,3))
plot(bx);axis(1);axis(2)
plot(heart);axis(1);axis(2)
plot(shp1);axis(1);axis(2)
plot(shp2);axis(1);axis(2)
plot(star);axis(1);axis(2)
plot(toywin);axis(1);axis(2)
par(oldpar)
</code></pre>

<hr>
<h2 id='unify.owin'>Spatial window unit rescaler</h2><span id='topic+unify.owin'></span>

<h3>Description</h3>

<p>Rescales any <code><a href="spatstat.geom.html#topic+owin">owin</a></code> to fall inside the unit square.</p>


<h3>Usage</h3>

<pre><code class='language-R'>unify.owin(W)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unify.owin_+3A_w">W</code></td>
<td>

<p>An object of class <code><a href="spatstat.geom.html#topic+owin">owin</a></code> giving the spatial window to be transformed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a simple wrapper for <code><a href="spatstat.geom.html#topic+affine">affine</a></code> deployed to rescale a supplied <code><a href="spatstat.geom.html#topic+owin">owin</a></code> to fall inside the unit square.
</p>


<h3>Value</h3>

<p>The rescaled <code><a href="spatstat.geom.html#topic+owin">owin</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- Window(chorley)
U &lt;- unify.owin(W)

oldpar &lt;- par(mfrow=c(1,2))
plot(W,axes=TRUE)
plot(U,axes=TRUE)
par(oldpar)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
