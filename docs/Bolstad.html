<!DOCTYPE html><html lang="en"><head><title>Help for package Bolstad</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Bolstad}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Bolstad-package'><p>Bolstad Functions</p></a></li>
<li><a href='#as.data.frame.Bolstad'><p>as.data.frame.Bolstad</p></a></li>
<li><a href='#bayes.lin.reg'><p>Bayesian inference for simple linear regression</p></a></li>
<li><a href='#bayes.lm'><p>Bayesian inference for multiple linear regression</p></a></li>
<li><a href='#bayes.t.test'><p>Bayesian t-test</p></a></li>
<li><a href='#bears'><p>bears</p></a></li>
<li><a href='#binobp'><p>Binomial sampling with a beta prior</p></a></li>
<li><a href='#binodp'><p>Binomial sampling with a discrete prior</p></a></li>
<li><a href='#binogcp'><p>Binomial sampling with a general continuous prior</p></a></li>
<li><a href='#binomixp'><p>Binomial sampling with a beta mixture prior</p></a></li>
<li><a href='#Bolstad.control'><p>Control Bolstad functions</p></a></li>
<li><a href='#cdf'><p>Cumulative distribution function generic</p></a></li>
<li><a href='#createPrior'><p>Create prior generic</p></a></li>
<li><a href='#createPrior.default'><p>Create prior default method</p></a></li>
<li><a href='#decomp'><p>Plot the prior, likelihood, and posterior on the same plot.</p></a></li>
<li><a href='#IQR'><p>Interquartile Range generic</p></a></li>
<li><a href='#lines.Bolstad'><p>Lines method for Bolstad objects</p></a></li>
<li><a href='#mean.Bolstad'><p>Calculate the posterior mean</p></a></li>
<li><a href='#median.Bolstad'><p>Median generic</p></a></li>
<li><a href='#moisture.df'><p>Moisture data</p></a></li>
<li><a href='#mvnmvnp'><p>Bayesian inference on a mutlivariate normal (MVN) mean with a multivariate normal (MVN) prior</p></a></li>
<li><a href='#normdp'><p>Bayesian inference on a normal mean with a discrete prior</p></a></li>
<li><a href='#normgcp'><p>Bayesian inference on a normal mean with a general continuous prior</p></a></li>
<li><a href='#normmixp'><p>Bayesian inference on a normal mean with a mixture of normal priors</p></a></li>
<li><a href='#normnp'><p>Bayesian inference on a normal mean with a normal prior</p></a></li>
<li><a href='#nvaricp'><p>Bayesian inference for a normal standard deviation with a scaled inverse</p>
chi-squared distribution</a></li>
<li><a href='#plot.Bolstad'><p>Plot method for objects of type Bolstad</p></a></li>
<li><a href='#poisdp'><p>Poisson sampling with a discrete prior</p></a></li>
<li><a href='#poisgamp'><p>Poisson sampling with a gamma prior</p></a></li>
<li><a href='#poisgcp'><p>Poisson sampling with a general continuous prior</p></a></li>
<li><a href='#print.Bolstad'><p>Print method for objects of class <code>Bolstad</code></p></a></li>
<li><a href='#print.sintegral'><p>Generic print method</p></a></li>
<li><a href='#print.sscsamp'><p>Print method for objects of class <code>sscsample</code></p></a></li>
<li><a href='#quantile.Bolstad'><p>Posterior quantiles</p></a></li>
<li><a href='#sd'><p>Standard deviation generic</p></a></li>
<li><a href='#sd.Bolstad'><p>Posterior standard deviation</p></a></li>
<li><a href='#sintegral'><p>Numerical integration using Simpson's Rule</p></a></li>
<li><a href='#slug'><p>Slug data</p></a></li>
<li><a href='#sscsample'><p>Simple, Stratified and Cluster Sampling</p></a></li>
<li><a href='#sscsample.data'><p>Data for simple random sampling, stratified sampling, and clusting sampling</p>
experiments</a></li>
<li><a href='#summary.Bolstad'><p>Summarizing Bayesian Multiple Linear Regression</p></a></li>
<li><a href='#var'><p>Variance generic</p></a></li>
<li><a href='#xdesign'><p>Monte Carlo study of randomized and blocked designs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.2.42</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-12</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions for Elementary Bayesian Inference</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of R functions and data sets for the book Introduction to Bayesian Statistics, Bolstad, W.M. (2017), John Wiley &amp; Sons ISBN 978-1-118-09156-2.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm, methods</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-12 02:39:14 UTC; jcur002</td>
</tr>
<tr>
<td>Author:</td>
<td>James Curran [aut, cre] (Original author)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Curran &lt;j.curran@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-12 10:20:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='Bolstad-package'>Bolstad Functions</h2><span id='topic+Bolstad-package'></span><span id='topic+Bolstad'></span>

<h3>Description</h3>

<p>A set of R functions and data sets for the book Introduction to Bayesian
Statistics, Bolstad, W.M. (2007), John Wiley &amp; Sons ISBN 0-471-27020-2. Most
of the package functions replicate the Minitab macros that are provided with
the book. Some additional functions are provided to simplfy inference about
the posterior distribution of the parameters of interest.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> Bolstad</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;">
0.2-26</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2015-05-01</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL 2</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>James Curran Maintainer: James Curran &lt;j.curran@auckland.ac.nz&gt; ~~
The author and/or maintainer of the package ~~
</p>


<h3>References</h3>

<p>Bolstad, W.M. (2007), Introduction to Bayesian Statistics, John
Wiley &amp; Sons.
</p>

<hr>
<h2 id='as.data.frame.Bolstad'>as.data.frame.Bolstad</h2><span id='topic+as.data.frame.Bolstad'></span>

<h3>Description</h3>

<p>as.data.frame.Bolstad
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Bolstad'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.Bolstad_+3A_x">x</code></td>
<td>
<p>an object of class <code>Bolstad</code></p>
</td></tr>
<tr><td><code id="as.data.frame.Bolstad_+3A_...">...</code></td>
<td>
<p>any extra arguments needed.</p>
</td></tr>
</table>

<hr>
<h2 id='bayes.lin.reg'>Bayesian inference for simple linear regression</h2><span id='topic+bayes.lin.reg'></span>

<h3>Description</h3>

<p>This function is used to find the posterior distribution of the simple
linear regression slope variable <code class="reqn">\beta</code> when we have a random
sample of ordered pairs <code class="reqn">(x_{i}, y_{i})</code> from the simple linear
regression model: 
</p>
<p style="text-align: center;"><code class="reqn">y_{i} = \alpha_{\bar{x}} + \beta x_{i}+\epsilon_{i}</code>
</p>
<p> where the
observation errors are, <code class="reqn">\epsilon_i</code>, independent
<code class="reqn">normal(0,\sigma^{2})</code> with known variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayes.lin.reg(
  y,
  x,
  slope.prior = c("flat", "normal"),
  intcpt.prior = c("flat", "normal"),
  mb0 = 0,
  sb0 = 0,
  ma0 = 0,
  sa0 = 0,
  sigma = NULL,
  alpha = 0.05,
  plot.data = FALSE,
  pred.x = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayes.lin.reg_+3A_y">y</code></td>
<td>
<p>the vector of responses.</p>
</td></tr>
<tr><td><code id="bayes.lin.reg_+3A_x">x</code></td>
<td>
<p>the value of the explantory variable associated with each response.</p>
</td></tr>
<tr><td><code id="bayes.lin.reg_+3A_slope.prior">slope.prior</code></td>
<td>
<p>use a &ldquo;flat&rdquo; prior or a &ldquo;normal&rdquo; prior. for
<code class="reqn">\beta</code></p>
</td></tr>
<tr><td><code id="bayes.lin.reg_+3A_intcpt.prior">intcpt.prior</code></td>
<td>
<p>use a &ldquo;flat&rdquo; prior or a &ldquo;normal&rdquo; prior. for
<code class="reqn">\alpha_[\bar{x}]</code></p>
</td></tr>
<tr><td><code id="bayes.lin.reg_+3A_mb0">mb0</code></td>
<td>
<p>the prior mean of the simple linear regression slope variable
<code class="reqn">\beta</code>. This argument is ignored for a flat prior.</p>
</td></tr>
<tr><td><code id="bayes.lin.reg_+3A_sb0">sb0</code></td>
<td>
<p>the prior std. deviation of the simple linear regression slope
variable <code class="reqn">\beta</code> - must be greater than zero. This argument is
ignored for a flat prior.</p>
</td></tr>
<tr><td><code id="bayes.lin.reg_+3A_ma0">ma0</code></td>
<td>
<p>the prior mean of the simple linear regression intercept variable
<code class="reqn">\alpha_{\bar{x}}</code>. This argument is ignored for a flat
prior.</p>
</td></tr>
<tr><td><code id="bayes.lin.reg_+3A_sa0">sa0</code></td>
<td>
<p>the prior std. deviation of the simple linear regression variable
<code class="reqn">\alpha_{\bar{x}}</code> - must be greater than zero. This
argument is ignored for a flat prior.</p>
</td></tr>
<tr><td><code id="bayes.lin.reg_+3A_sigma">sigma</code></td>
<td>
<p>the value of the std. deviation of the residuals. By default,
this is assumed to be unknown and the sample value is used instead. This
affects the prediction intervals.</p>
</td></tr>
<tr><td><code id="bayes.lin.reg_+3A_alpha">alpha</code></td>
<td>
<p>controls the width of the credible interval.</p>
</td></tr>
<tr><td><code id="bayes.lin.reg_+3A_plot.data">plot.data</code></td>
<td>
<p>if true the data are plotted, and the posterior regression
line superimposed on the data.</p>
</td></tr>
<tr><td><code id="bayes.lin.reg_+3A_pred.x">pred.x</code></td>
<td>
<p>a vector of x values for which the predicted y values are
obtained and the std. errors of prediction</p>
</td></tr>
<tr><td><code id="bayes.lin.reg_+3A_...">...</code></td>
<td>
<p>additional arguments that are passed to <code>Bolstad.control</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list will be returned with the following components:
</p>
<table role = "presentation">
<tr><td><code>post.coef</code></td>
<td>
<p>the posterior mean of the intecept and the slope</p>
</td></tr>
<tr><td><code>post.coef</code></td>
<td>
<p>the posterior standard deviation of the intercept the
slope</p>
</td></tr> <tr><td><code>pred.x</code></td>
<td>
<p>the vector of values for which predictions have been
requested. If pred.x is NULL then this is not returned</p>
</td></tr> <tr><td><code>pred.y</code></td>
<td>
<p>the
vector predicted values corresponding to pred.x. If pred.x is NULL then this
is not returned</p>
</td></tr> <tr><td><code>pred.se</code></td>
<td>
<p>The standard errors of the predicted values
in pred.y. If pred.x is NULL then this is not returned</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate some data from a known model, where the true value of the
## intercept alpha is 2, the true value of the slope beta is 3, and the
## errors come from a normal(0,1) distribution
set.seed(123)
x = rnorm(50)
y = 2 + 3*x + rnorm(50)

## use the function with a flat prior for the slope beta and a
## flat prior for the intercept, alpha_xbar.

bayes.lin.reg(y,x)

## use the function with a normal(0,3) prior for the slope beta and a
## normal(30,10) prior for the intercept, alpha_xbar.

bayes.lin.reg(y,x,"n","n",0,3,30,10)

## use the same data but plot it and the credible interval

bayes.lin.reg(y,x,"n","n",0,3,30,10, plot.data = TRUE)

## The heart rate vs. O2 uptake example 14.1
O2 = c(0.47,0.75,0.83,0.98,1.18,1.29,1.40,1.60,1.75,1.90,2.23)
HR = c(94,96,94,95,104,106,108,113,115,121,131)
plot(HR,O2,xlab="Heart Rate",ylab="Oxygen uptake (Percent)")

bayes.lin.reg(O2,HR,"n","f",0,1,sigma=0.13)

## Repeat the example but obtain predictions for HR = 100 and 110

bayes.lin.reg(O2,HR,"n","f",0,1,sigma=0.13,pred.x=c(100,110))

</code></pre>

<hr>
<h2 id='bayes.lm'>Bayesian inference for multiple linear regression</h2><span id='topic+bayes.lm'></span>

<h3>Description</h3>

<p>bayes.lm is used to fit linear models in the Bayesian paradigm. It can be used to carry out regression, 
single stratum analysis of variance and analysis of covariance (although these are not tested). This
documentation is shamelessly adapated from the lm documentation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayes.lm(
  formula,
  data,
  subset,
  na.action,
  model = TRUE,
  x = FALSE,
  y = FALSE,
  center = TRUE,
  prior = NULL,
  sigma = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayes.lm_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): a symbolic 
description of the model to be fitted. The details of model specification are given under &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="bayes.lm_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a 
data frame) containing the variables in the model. If not found in data, the variables are taken 
from <code>environment(formula)</code>, typically the environment from which <code>bayes.lm</code> is called.</p>
</td></tr>
<tr><td><code id="bayes.lm_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="bayes.lm_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain <code>NA</code>s. The 
default is set by the <code><a href="stats.html#topic+na.action">na.action</a></code> setting of options, and is <code>link[stats]{na.fail}</code>
if that is unset. The &lsquo;factory-fresh&rsquo; default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>. Another possible value 
is <code>NULL</code>, no action. Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="bayes.lm_+3A_model">model</code>, <code id="bayes.lm_+3A_x">x</code>, <code id="bayes.lm_+3A_y">y</code></td>
<td>
<p>logicals. If <code>TRUE</code> the corresponding components of the fit (the model frame, the model matrix, the response)
are returned.
<code class="reqn">\beta</code>. This argument is ignored for a flat prior.</p>
</td></tr>
<tr><td><code id="bayes.lm_+3A_center">center</code></td>
<td>
<p>logical or numeric. If <code>TRUE</code> then the covariates will be centered on their means to make them
orthogonal to the intercept. This probably makes no sense for models with factors, and if the argument
is numeric then it contains a vector of covariate indices to be centered (not implemented yet).</p>
</td></tr>
<tr><td><code id="bayes.lm_+3A_prior">prior</code></td>
<td>
<p>A list containing b0 (A vector of prior coefficients) and V0 (A prior covariance matrix)</p>
</td></tr>
<tr><td><code id="bayes.lm_+3A_sigma">sigma</code></td>
<td>
<p>the population standard deviation of the errors. If <code>FALSE</code> then this is estimated from the residual sum of squares from the ML fit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models for <code>bayes.lm</code> are specified symbolically. A typical model has the form 
<code>response ~ terms</code> where <code>response</code> is the (numeric) response vector and <code>terms</code> is a
series of terms which specifies a linear predictor for <code>response</code>. A terms specification of the 
form <code>first + second</code> indicates all the terms in <code>first</code> together with all the terms in 
<code>second</code> with duplicates removed. A specification of the form <code>first:second</code> indicates the 
set of terms obtained by taking the interactions of all terms in <code>first</code> with all terms in 
<code>second</code>. The specification <code>first*second</code> indicates the cross of <code>first</code> and <code>second</code>.
This is the same as <code>first + second + first:second</code>.
</p>
<p>See <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> for some further details. The terms in the formula will be 
re-ordered so that main effects come first, followed by the interactions, all second-order, 
all third-order and so on: to avoid this pass a <code>terms</code> object as the formula 
(see <code><a href="stats.html#topic+aov">aov</a></code> and <code>demo(glm.vr)</code> for an example).
</p>
<p>A formula has an implied intercept term. To remove this use either <code>y ~ x - 1</code> or 
<code>y ~ 0 + x</code>. See <code><a href="stats.html#topic+formula">formula</a></code> for more details of allowed formulae.
</p>
<p><code>bayes.lm</code> calls the lower level function <code>lm.fit</code> to get the maximum likelihood estimates
see below, for the actual numerical computations. For programming only, you may consider doing 
likewise.
</p>
<p><code>subset</code> is evaluated in the same way as variables in formula, that is first in data and 
then in the environment of formula.
</p>


<h3>Value</h3>

<p><code>bayes.lm</code> returns an object of class <code>Bolstad</code>.
The <code>summary</code> function is used to obtain and print a summary of the results much like the usual 
summary from a linear regression using <code><a href="stats.html#topic+lm">lm</a></code>.
The generic accessor functions <code>coef, fitted.values and residuals</code>
extract various useful features of the value returned by <code>bayes.lm</code>. Note that the residuals
are computed at the posterior mean values of the coefficients.
</p>
<p>An object of class &quot;Bolstad&quot; from this function is a list containing at least the following components:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients which contains the posterior mean</p>
</td></tr>
<tr><td><code>post.var</code></td>
<td>
<p>a matrix containing the posterior variance-covariance matrix of the coefficients</p>
</td></tr>
<tr><td><code>post.sd</code></td>
<td>
<p>sigma</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals, that is response minus fitted values (computed at the posterior mean)</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted mean values (computed at the posterior mean)</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the residual degrees of freedom</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if requested, the response used</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>if requested, the model matrix used</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if requested (the default), the model frame used</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>(where relevant) information returned by <code>model.frame</code> on the special 
handling of <code>NA</code>s</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(bears)
bears = subset(bears, Obs.No==1)
bears = bears[,-c(1,2,3,11,12)]
bears = bears[ ,c(7, 1:6)]
bears$Sex = bears$Sex - 1
log.bears = data.frame(log.Weight = log(bears$Weight), bears[,2:7])

b0 = rep(0, 7)
V0 = diag(rep(1e6,7))

fit = bayes.lm(log(Weight)~Sex+Head.L+Head.W+Neck.G+Length+Chest.G, data = bears,
               prior = list(b0 = b0, V0 = V0))
summary(fit)
print(fit)


## Dobson (1990) Page 9: Plant Weight Data:
ctl &lt;- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt &lt;- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group &lt;- gl(2, 10, 20, labels = c("Ctl","Trt"))
weight &lt;- c(ctl, trt)

lm.D9 &lt;- lm(weight ~ group)
bayes.D9 &lt;- bayes.lm(weight ~ group)

summary(lm.D9)
summary(bayes.D9)

</code></pre>

<hr>
<h2 id='bayes.t.test'>Bayesian t-test</h2><span id='topic+bayes.t.test'></span><span id='topic+bayes.t.test.default'></span><span id='topic+bayes.t.test.formula'></span>

<h3>Description</h3>

<p>Performs one and two sample t-tests (in the Bayesian hypothesis testing framework) on vectors of data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayes.t.test(x, ...)

## Default S3 method:
bayes.t.test(
  x,
  y = NULL,
  alternative = c("two.sided", "less", "greater"),
  mu = 0,
  paired = FALSE,
  var.equal = TRUE,
  conf.level = 0.95,
  prior = c("jeffreys", "joint.conj"),
  m = NULL,
  n0 = NULL,
  sig.med = NULL,
  kappa = 1,
  sigmaPrior = "chisq",
  nIter = 10000,
  nBurn = 1000,
  ...
)

## S3 method for class 'formula'
bayes.t.test(formula, data, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayes.t.test_+3A_x">x</code></td>
<td>
<p>a (non-empty) numeric vector of data values.</p>
</td></tr>
<tr><td><code id="bayes.t.test_+3A_...">...</code></td>
<td>
<p>any additional arguments</p>
</td></tr>
<tr><td><code id="bayes.t.test_+3A_y">y</code></td>
<td>
<p>an optional (non-empty) numeric vector of data values.</p>
</td></tr>
<tr><td><code id="bayes.t.test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of 
<code>"two.sided"</code> (default), <code>"greater"</code> or <code>"less"</code>. You can specify just the initial 
letter.</p>
</td></tr>
<tr><td><code id="bayes.t.test_+3A_mu">mu</code></td>
<td>
<p>a number indicating the true value of the mean (or difference in means if you are performing a two sample test).</p>
</td></tr>
<tr><td><code id="bayes.t.test_+3A_paired">paired</code></td>
<td>
<p>a logical indicating whether you want a paired t-test.</p>
</td></tr>
<tr><td><code id="bayes.t.test_+3A_var.equal">var.equal</code></td>
<td>
<p>a logical variable indicating whether to treat the two variances as being equal. 
If <code>TRUE</code> (default) then the pooled variance is used to estimate the variance otherwise the 
Welch (or Satterthwaite) approximation to the degrees of freedom is used. The unequal variance case is
implented using Gibbs sampling.</p>
</td></tr>
<tr><td><code id="bayes.t.test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of interval.</p>
</td></tr>
<tr><td><code id="bayes.t.test_+3A_prior">prior</code></td>
<td>
<p>a character string indicating which prior should be used for the means, must be one of
<code>"jeffreys"</code> (default) for independent Jeffreys' priors on the unknown mean(s) and variance(s), 
or <code>"joint.conj"</code> for a joint conjugate prior.</p>
</td></tr>
<tr><td><code id="bayes.t.test_+3A_m">m</code></td>
<td>
<p>if the joint conjugate prior is used then the user must specify a prior mean in the one-sample
or paired case, or two prior means in the two-sample case. Note that if the hypothesis is that there is no difference
between the means in the two-sample case, then the values of the prior means should usually be equal, and if so, 
then their actual values are irrelvant.This parameter is not used if the user chooses a Jeffreys' prior.</p>
</td></tr>
<tr><td><code id="bayes.t.test_+3A_n0">n0</code></td>
<td>
<p>if the joint conjugate prior is used then the user must specify the prior precision 
or precisions in the two sample case that represent our level of uncertainty
about the true mean(s). This parameter is not used if the user chooses a Jeffreys' prior.</p>
</td></tr>
<tr><td><code id="bayes.t.test_+3A_sig.med">sig.med</code></td>
<td>
<p>if the joint conjugate prior is used then the user must specify the prior median
for the unknown standard deviation. This parameter is not used if the user chooses a Jeffreys' prior.</p>
</td></tr>
<tr><td><code id="bayes.t.test_+3A_kappa">kappa</code></td>
<td>
<p>if the joint conjugate prior is used then the user must specify the degrees of freedom
for the inverse chi-squared distribution used for the unknown standard deviation. Usually the default
of 1 will be sufficient. This parameter is not used if the user chooses a Jeffreys' prior.</p>
</td></tr>
<tr><td><code id="bayes.t.test_+3A_sigmaprior">sigmaPrior</code></td>
<td>
<p>If a two-sample t-test with unequal variances is desired then the user must choose between
using an chi-squared prior (&quot;chisq&quot;) or a gamma prior (&quot;gamma&quot;) for the unknown population standard deviations.
This parameter is only used if <code>var.equal</code> is set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bayes.t.test_+3A_niter">nIter</code></td>
<td>
<p>Gibbs sampling is used when a two-sample t-test with unequal variances is desired.
This parameter controls the sample size from the posterior distribution.</p>
</td></tr>
<tr><td><code id="bayes.t.test_+3A_nburn">nBurn</code></td>
<td>
<p>Gibbs sampling is used when a two-sample t-test with unequal variances is desired.
This parameter controls the number of iterations used to burn in the chains before the procedure 
starts sampling in order to reduce correlation with the starting values.</p>
</td></tr>
<tr><td><code id="bayes.t.test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>lhs ~ rhs</code> where lhs is a numeric variable giving the data values and rhs a factor with two 
levels giving the corresponding groups.</p>
</td></tr>
<tr><td><code id="bayes.t.test_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see <code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing 
the variables in the formula formula. By default the variables are taken from <code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="bayes.t.test_+3A_subset">subset</code></td>
<td>
<p>currently ingored.</p>
</td></tr>
<tr><td><code id="bayes.t.test_+3A_na.action">na.action</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class &quot;htest&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the t-statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the t-statistic.</p>
</td></tr>                                                                                        
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr></table>
<p>&quot;                                                                                                              
</p>
<table role = "presentation">
<tr><td><code>conf.int</code></td>
<td>
<p>a confidence interval for the mean appropriate to the specified alternative hypothesis.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated mean or difference in means depending on whether it was a one-sample test or a two-sample test.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified hypothesized value of the mean or mean difference depending on whether it was a one-sample test or a two-sample test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of t-test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
<tr><td><code>result</code></td>
<td>
<p>an object of class <code>Bolstad</code></p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>bayes.t.test(default)</code>: Bayesian t-test
</p>
</li>
<li> <p><code>bayes.t.test(formula)</code>: Bayesian t-test
</p>
</li></ul>


<h3>Author(s)</h3>

<p>R Core with Bayesian internals added by James Curran
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bayes.t.test(1:10, y = c(7:20))      # P = .3.691e-01

## Same example but with using the joint conjugate prior
## We set the prior means equal (and it doesn't matter what the value is)
## the prior precision is 0.01, which is a prior standard deviation of 10
## we're saying the true difference of the means is between [-25.7, 25.7]
## with probability equal to 0.99. The median value for the prior on sigma is 2
## and we're using a scaled inverse chi-squared prior with 1 degree of freedom
bayes.t.test(1:10, y = c(7:20), var.equal = TRUE, prior = "joint.conj", 
             m = c(0,0), n0 =  rep(0.01, 2), sig.med = 2)

##' Same example but with a large outlier. Note the assumption of equal variances isn't sensible
bayes.t.test(1:10, y = c(7:20, 200)) # P = .1979    -- NOT significant anymore

## Classical example: Student's sleep data
plot(extra ~ group, data = sleep)

## Traditional interface
with(sleep, bayes.t.test(extra[group == 1], extra[group == 2]))

## Formula interface
bayes.t.test(extra ~ group, data = sleep)
</code></pre>

<hr>
<h2 id='bears'>bears</h2><span id='topic+bears'></span>

<h3>Description</h3>

<p>Body measurements for 143 wild bears.
</p>


<h3>Format</h3>

<p>A data frame with 143 observations on the following 12 variables.
</p>
 <ul>
<li><p>ID. Indentification number
</p>
</li>
<li><p>Age. Bear's age, in months. Note, wild bears are always born
in January, so an expert can estimate the bear's age without directly asking
it how old it is.  </p>
</li>
<li><p>Month. Month when the measurement was
made. 1 = Jan., 12 = Dec. Since bears hibernate in the winter, their body
shape probably depends on the season.  </p>
</li>
<li><p>Sex. 1 = male 2 =
female  </p>
</li>
<li><p>Head.L. Length of the head, in inches 
</p>
</li>
<li><p>Head.W. Width of the head, in inches 
</p>
</li>
<li><p>Neck.G. Girth (distance around) the neck, in inches 
</p>
</li>
<li><p>Length. Body length, in inches  </p>
</li>
<li><p>Chest.G. Girth
(distance around) the chest, in inches  </p>
</li>
<li><p>Weight. Weight of the
bear, in pounds  </p>
</li>
<li><p>Obs.No. Observation number for this bear.
For example, the bear with ID = 41 (Bertha) was measured on four occasions,
in the months coded 7, 8, 11, and 5. The value of Obs.No goes from 1 to 4
for these observations.  </p>
</li>
<li><p>Name. The names of the bears given
to them by the researchers </p>
</li></ul>



<h3>Details</h3>

<p>Wild bears were anesthetized, and their bodies were measured and weighed.
One goal of the study was to make a table (or perhaps a set of tables) for
hunters, so they could estimate the weight of a bear based on other
measurements. This would be used because in the forest it is easier to
measure the length of a bear, for example, than it is to weigh it.
</p>


<h3>Source</h3>

<p>This data is in the example data set Bears.MTW distributed with
Minitab
</p>


<h3>References</h3>

<p>This data set was supplied by Gary Alt. Entertaining references
are in Reader's Digest April, 1979, and Sports Afield September, 1981.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bears)
boxplot(Weight~Sex, data = bears)

</code></pre>

<hr>
<h2 id='binobp'>Binomial sampling with a beta prior</h2><span id='topic+binobp'></span>

<h3>Description</h3>

<p>Evaluates and plots the posterior density for <code class="reqn">\pi</code>, the probability
of a success in a Bernoulli trial, with binomial sampling and a continous
<code class="reqn">beta(a,b)</code> prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binobp(x, n, a = 1, b = 1, pi = seq(0, 1, by = 0.001), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binobp_+3A_x">x</code></td>
<td>
<p>the number of observed successes in the binomial experiment.</p>
</td></tr>
<tr><td><code id="binobp_+3A_n">n</code></td>
<td>
<p>the number of trials in the binomial experiment.</p>
</td></tr>
<tr><td><code id="binobp_+3A_a">a</code></td>
<td>
<p>parameter for the beta prior - must be greater than zero</p>
</td></tr>
<tr><td><code id="binobp_+3A_b">b</code></td>
<td>
<p>parameter for the beta prior - must be greater than zero</p>
</td></tr>
<tr><td><code id="binobp_+3A_pi">pi</code></td>
<td>
<p>A range of values for the prior to be calculated over.</p>
</td></tr>
<tr><td><code id="binobp_+3A_...">...</code></td>
<td>
<p>additional arguments that are passed to <code>Bolstad.control</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'Bolstad' is returned. This is a list with the
following components: </p>
<table role = "presentation">
<tr><td><code>prior</code></td>
<td>
<p>the prior density of <code class="reqn">\pi</code>, i.e.
the <code class="reqn">beta(a,b)</code> density</p>
</td></tr> <tr><td><code>likelihood</code></td>
<td>
<p>the likelihood of <code class="reqn">x</code>
given <code class="reqn">\pi</code> and <code class="reqn">n</code>, i.e. the
<code class="reqn">binomial(n,\pi)</code> density</p>
</td></tr> <tr><td><code>posterior</code></td>
<td>
<p>the
posterior density of <code class="reqn">\pi</code> given <code class="reqn">x</code> and <code class="reqn">n</code> - i.e. the
<code class="reqn">beta(a+x,b+n-x)</code> density</p>
</td></tr> <tr><td><code>pi</code></td>
<td>
<p>the values of <code class="reqn">\pi</code> for
which the posterior density was evaluated</p>
</td></tr> <tr><td><code>mean</code></td>
<td>
<p>the posterior mean</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>the posterior variance</p>
</td></tr> <tr><td><code>sd</code></td>
<td>
<p>the posterior std. deviation</p>
</td></tr>
<tr><td><code>quantiles</code></td>
<td>
<p>a set of quantiles from the posterior</p>
</td></tr> <tr><td><code>cdf</code></td>
<td>
<p>a
cumulative distribution function for the posterior</p>
</td></tr> <tr><td><code>quantileFun</code></td>
<td>
<p>a
quantile function for the posterior</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+binodp">binodp</a></code> <code><a href="#topic+binogcp">binogcp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simplest call with 6 successes observed in 8 trials and a beta(1,1) uniform
## prior
binobp(6,8)

## 6 successes observed in 8 trials and a non-uniform beta(0.5,6) prior
binobp(6,8,0.5,6)

## 4 successes observed in 12 trials with a non uniform beta(3,3) prior
## plot the stored prior, likelihood and posterior
results = binobp(4, 12, 3, 3)
decomp(results)


</code></pre>

<hr>
<h2 id='binodp'>Binomial sampling with a discrete prior</h2><span id='topic+binodp'></span>

<h3>Description</h3>

<p>Evaluates and plots the posterior density for <code class="reqn">\pi</code>, the probability
of a success in a Bernoulli trial, with binomial sampling and a discrete
prior on <code class="reqn">\pi</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binodp(x, n, pi = NULL, pi.prior = NULL, n.pi = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binodp_+3A_x">x</code></td>
<td>
<p>the number of observed successes in the binomial experiment.</p>
</td></tr>
<tr><td><code id="binodp_+3A_n">n</code></td>
<td>
<p>the number of trials in the binomial experiment.</p>
</td></tr>
<tr><td><code id="binodp_+3A_pi">pi</code></td>
<td>
<p>a vector of possibilities for the probability of success in a
single trial. if <code>pi</code> is <code>NULL</code> then a discrete uniform prior for
<code class="reqn">\pi</code> will be used.</p>
</td></tr>
<tr><td><code id="binodp_+3A_pi.prior">pi.prior</code></td>
<td>
<p>the associated prior probability mass.</p>
</td></tr>
<tr><td><code id="binodp_+3A_n.pi">n.pi</code></td>
<td>
<p>the number of possible <code class="reqn">\pi</code> values in the prior</p>
</td></tr>
<tr><td><code id="binodp_+3A_...">...</code></td>
<td>
<p>additional arguments that are passed to <code>Bolstad.control</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list will be returned with the following components: </p>
<table role = "presentation">
<tr><td><code>pi</code></td>
<td>
<p>the
vector of possible <code class="reqn">\pi</code> values used in the prior</p>
</td></tr>
<tr><td><code>pi.prior</code></td>
<td>
<p>the associated probability mass for the values in
<code class="reqn">\pi</code></p>
</td></tr> <tr><td><code>likelihood</code></td>
<td>
<p>the scaled likelihood function for
<code class="reqn">\pi</code> given <code class="reqn">x</code> and <code class="reqn">n</code></p>
</td></tr> <tr><td><code>posterior</code></td>
<td>
<p>the posterior
probability of <code class="reqn">\pi</code> given <code class="reqn">x</code> and <code class="reqn">n</code></p>
</td></tr> <tr><td><code>f.cond</code></td>
<td>
<p>the
conditional distribution of <code class="reqn">x</code> given <code class="reqn">\pi</code> and <code class="reqn">n</code></p>
</td></tr>
<tr><td><code>f.joint</code></td>
<td>
<p>the joint distribution of <code class="reqn">x</code> and <code class="reqn">\pi</code> given
<code class="reqn">n</code></p>
</td></tr> <tr><td><code>f.marg</code></td>
<td>
<p>the marginal distribution of <code class="reqn">x</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+binobp">binobp</a></code> <code><a href="#topic+binogcp">binogcp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simplest call with 6 successes observed in 8 trials and a uniform prior
binodp(6,8)

## same as previous example but with more possibilities for pi
binodp(6, 8, n.pi = 100)

## 6 successes, 8 trials and a non-uniform discrete prior
pi = seq(0, 1, by = 0.01)
pi.prior = runif(101)
pi.prior = sort(pi.prior / sum(pi.prior))
binodp(6, 8, pi, pi.prior)

## 5 successes, 6 trials, non-uniform prior
pi = c(0.3, 0.4, 0.5)
pi.prior = c(0.2, 0.3, 0.5)
results = binodp(5, 6, pi, pi.prior)

## plot the results from the previous example using a side-by-side barplot
results.matrix = rbind(results$pi.prior,results$posterior)
colnames(results.matrix) = pi
barplot(results.matrix, col = c("red", "blue"), beside = TRUE,
	      xlab = expression(pi), ylab=expression(Probability(pi)))
box()
legend("topleft", bty = "n", cex = 0.7, 
       legend = c("Prior", "Posterior"), fill = c("red", "blue"))

</code></pre>

<hr>
<h2 id='binogcp'>Binomial sampling with a general continuous prior</h2><span id='topic+binogcp'></span>

<h3>Description</h3>

<p>Evaluates and plots the posterior density for <code class="reqn">\pi</code>, the probability
of a success in a Bernoulli trial, with binomial sampling and a general
continuous prior on <code class="reqn">\pi</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binogcp(
  x,
  n,
  density = c("uniform", "beta", "exp", "normal", "user"),
  params = c(0, 1),
  n.pi = 1000,
  pi = NULL,
  pi.prior = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binogcp_+3A_x">x</code></td>
<td>
<p>the number of observed successes in the binomial experiment.</p>
</td></tr>
<tr><td><code id="binogcp_+3A_n">n</code></td>
<td>
<p>the number of trials in the binomial experiment.</p>
</td></tr>
<tr><td><code id="binogcp_+3A_density">density</code></td>
<td>
<p>may be one of &quot;beta&quot;, &quot;exp&quot;, &quot;normal&quot;, &quot;student&quot;, &quot;uniform&quot;
or &quot;user&quot;</p>
</td></tr>
<tr><td><code id="binogcp_+3A_params">params</code></td>
<td>
<p>if density is one of the parameteric forms then then a vector
of parameters must be supplied.  beta: a, b exp: rate normal: mean, sd
uniform: min, max</p>
</td></tr>
<tr><td><code id="binogcp_+3A_n.pi">n.pi</code></td>
<td>
<p>the number of possible <code class="reqn">\pi</code> values in the prior</p>
</td></tr>
<tr><td><code id="binogcp_+3A_pi">pi</code></td>
<td>
<p>a vector of possibilities for the probability of success in a
single trial. This must be set if density = &quot;user&quot;.</p>
</td></tr>
<tr><td><code id="binogcp_+3A_pi.prior">pi.prior</code></td>
<td>
<p>the associated prior probability mass. This must be set if
density = &quot;user&quot;.</p>
</td></tr>
<tr><td><code id="binogcp_+3A_...">...</code></td>
<td>
<p>additional arguments that are passed to <code>Bolstad.control</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list will be returned with the following components:
</p>
<table role = "presentation">
<tr><td><code>likelihood</code></td>
<td>
<p>the scaled likelihood function for <code class="reqn">\pi</code> given
<code class="reqn">x</code> and <code class="reqn">n</code></p>
</td></tr> <tr><td><code>posterior</code></td>
<td>
<p>the posterior probability of
<code class="reqn">\pi</code> given <code class="reqn">x</code> and <code class="reqn">n</code></p>
</td></tr> <tr><td><code>pi</code></td>
<td>
<p>the vector of possible
<code class="reqn">\pi</code> values used in the prior</p>
</td></tr> <tr><td><code>pi.prior</code></td>
<td>
<p>the associated
probability mass for the values in <code class="reqn">\pi</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+binobp">binobp</a></code> <code><a href="#topic+binodp">binodp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simplest call with 6 successes observed in 8 trials and a continuous
## uniform prior
binogcp(6, 8)

## 6 successes, 8 trials and a Beta(2, 2) prior
binogcp(6, 8,density = "beta", params = c(2, 2))

## 5 successes, 10 trials and a N(0.5, 0.25) prior
binogcp(5, 10, density = "normal", params = c(0.5, 0.25))

## 4 successes, 12 trials with a user specified triangular continuous prior
pi = seq(0, 1,by = 0.001)
pi.prior = rep(0, length(pi))
priorFun = createPrior(x = c(0, 0.5, 1), wt = c(0, 2, 0))
pi.prior = priorFun(pi)
results = binogcp(4, 12, "user", pi = pi, pi.prior = pi.prior)

## find the posterior CDF using the previous example and Simpson's rule
myCdf = cdf(results)
plot(myCdf, type = "l", xlab = expression(pi[0]),
	   ylab = expression(Pr(pi &lt;= pi[0])))

## use the quantile function to find the 95% credible region.
qtls = quantile(results, probs = c(0.025, 0.975))
cat(paste("Approximate 95% credible interval : ["
	, round(qtls[1], 4), " ", round(qtls, 4), "]\n", sep = ""))

## find the posterior mean, variance and std. deviation
## using the output from the previous example
post.mean = mean(results)
post.var = var(results)
post.sd = sd(results)

# calculate an approximate 95% credible region using the posterior mean and
# std. deviation
lb = post.mean - qnorm(0.975) * post.sd
ub = post.mean + qnorm(0.975) * post.sd

cat(paste("Approximate 95% credible interval : ["
	, round(lb, 4), " ", round(ub, 4), "]\n", sep = ""))

</code></pre>

<hr>
<h2 id='binomixp'>Binomial sampling with a beta mixture prior</h2><span id='topic+binomixp'></span>

<h3>Description</h3>

<p>Evaluates and plots the posterior density for <code class="reqn">\pi</code>, the probability
of a success in a Bernoulli trial, with binomial sampling when the prior
density for <code class="reqn">\pi</code> is a mixture of two beta distributions,
<code class="reqn">beta(a_0,b_0)</code> and <code class="reqn">beta(a_1,b_1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binomixp(x, n, alpha0 = c(1, 1), alpha1 = c(1, 1), p = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binomixp_+3A_x">x</code></td>
<td>
<p>the number of observed successes in the binomial experiment.</p>
</td></tr>
<tr><td><code id="binomixp_+3A_n">n</code></td>
<td>
<p>the number of trials in the binomial experiment.</p>
</td></tr>
<tr><td><code id="binomixp_+3A_alpha0">alpha0</code></td>
<td>
<p>a vector of length two containing the parameters,
<code class="reqn">a_0</code> and <code class="reqn">b_0</code>, for the first component beta prior - must
be greater than zero. By default the elements of alpha0 are set to 1.</p>
</td></tr>
<tr><td><code id="binomixp_+3A_alpha1">alpha1</code></td>
<td>
<p>a vector of length two containing the parameters,
<code class="reqn">a_1</code> and <code class="reqn">b_1</code>, for the second component beta prior - must
be greater than zero. By default the elements of alpha1 are set to 1.</p>
</td></tr>
<tr><td><code id="binomixp_+3A_p">p</code></td>
<td>
<p>The prior mixing proportion for the two component beta priors. That
is the prior is <code class="reqn">pimes beta(a_0,b_0)+(1-p)imes
beta(a_1,b_1)</code>. <code class="reqn">p</code> is set to 0.5 by
default</p>
</td></tr>
<tr><td><code id="binomixp_+3A_...">...</code></td>
<td>
<p>additional arguments that are passed to <code>Bolstad.control</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list will be returned with the following components: </p>
<table role = "presentation">
<tr><td><code>pi</code></td>
<td>
<p>the
values of <code class="reqn">\pi</code> for which the posterior density was evaluated</p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>the posterior density of <code class="reqn">\pi</code> given <code class="reqn">n</code> and
<code class="reqn">x</code></p>
</td></tr> <tr><td><code>likelihood</code></td>
<td>
<p>the likelihood function for <code class="reqn">\pi</code> given
<code class="reqn">x</code> and <code class="reqn">n</code>, i.e. the <code class="reqn">binomial(n,\pi)</code> density</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>the prior density of <code class="reqn">\pi</code> density</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+binodp">binodp</a></code> <code><a href="#topic+binogcp">binogcp</a></code> <code><a href="#topic+normmixp">normmixp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simplest call with 6 successes observed in 8 trials and a 50:50 mix
## of two beta(1,1) uniform priors
binomixp(6,8)

## 6 successes observed in 8 trials and a 20:80 mix of a non-uniform
## beta(0.5,6) prior and a uniform beta(1,1) prior
binomixp(6,8,alpha0=c(0.5,6),alpha1=c(1,1),p=0.2)

## 4 successes observed in 12 trials with a 90:10 non uniform beta(3,3) prior
## and a non uniform beta(4,12).
## Plot the stored prior, likelihood and posterior
results = binomixp(4, 12, c(3, 3), c(4, 12), 0.9)$mix

par(mfrow = c(3,1))
y.lims = c(0, 1.1 * max(results$posterior, results$prior))

plot(results$pi,results$prior,ylim=y.lims,type='l'
,xlab=expression(pi),ylab='Density',main='Prior')
polygon(results$pi,results$prior,col='red')

plot(results$pi,results$likelihood,type='l',
     xlab = expression(pi), ylab = 'Density', main = 'Likelihood')
polygon(results$pi,results$likelihood,col='green')

plot(results$pi,results$posterior,ylim=y.lims,type='l'
,xlab=expression(pi),ylab='Density',main='Posterior')
polygon(results$pi,results$posterior,col='blue')




</code></pre>

<hr>
<h2 id='Bolstad.control'>Control Bolstad functions</h2><span id='topic+Bolstad.control'></span>

<h3>Description</h3>

<p>Control Bolstad functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bolstad.control(plot = TRUE, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Bolstad.control_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code> then draw a plot (for functions that actually have plots)</p>
</td></tr>
<tr><td><code id="Bolstad.control_+3A_quiet">quiet</code></td>
<td>
<p>if <code>TRUE</code> then suppress the function output</p>
</td></tr>
<tr><td><code id="Bolstad.control_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an invisible list of options and their values
</p>

<hr>
<h2 id='cdf'>Cumulative distribution function generic</h2><span id='topic+cdf'></span><span id='topic+cdf.Bolstad'></span>

<h3>Description</h3>

<p>This function returns the cumulative distribution function (cdf) of the 
posterior distribution of the parameter interest over the range of values for
which the posterior is specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdf(x, ...)

## S3 method for class 'Bolstad'
cdf(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdf_+3A_x">x</code></td>
<td>
<p>An object for which we want to compute the cdf</p>
</td></tr>
<tr><td><code id="cdf_+3A_...">...</code></td>
<td>
<p>Any other parameters. Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either the exact cdf of the posterior if a conjugate prior has been
used, or a a <code>stats::splinefun</code> which will compute the lower
tail probability of the parameter for any valid input.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>cdf(Bolstad)</code>: Cumulative distribution function for posterior density
</p>
</li></ul>


<h3>Author(s)</h3>

<p>James Curran
</p>

<hr>
<h2 id='createPrior'>Create prior generic</h2><span id='topic+createPrior'></span>

<h3>Description</h3>

<p>Create prior generic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createPrior(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createPrior_+3A_x">x</code></td>
<td>
<p>a vector of x values at which the prior is to be specified (the support of the prior).</p>
</td></tr>
<tr><td><code id="createPrior_+3A_...">...</code></td>
<td>
<p>optional exta arguments. Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a linear interpolation function where the weights have been scaled so
the function (numerically) integrates to 1.
</p>

<hr>
<h2 id='createPrior.default'>Create prior default method</h2><span id='topic+createPrior.default'></span>

<h3>Description</h3>

<p>Create prior default method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
createPrior(x, wt, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createPrior.default_+3A_x">x</code></td>
<td>
<p>a vector of x values at which the prior is to be specified (the support of the prior). This should contain
unique values in ascending order. The function will sort values if x is unsorted with a warning, and will halt if x contains any
duplicates or negative lag 1 differences.</p>
</td></tr>
<tr><td><code id="createPrior.default_+3A_wt">wt</code></td>
<td>
<p>a vector of weights corresponding to the weight of the prior at the
given x values.</p>
</td></tr>
<tr><td><code id="createPrior.default_+3A_...">...</code></td>
<td>
<p>optional exta arguments. Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a linear interpolation function where the weights have been scaled so
the function (numerically) integrates to 1.
</p>

<hr>
<h2 id='decomp'>Plot the prior, likelihood, and posterior on the same plot.</h2><span id='topic+decomp'></span>

<h3>Description</h3>

<p>This function takes any object of class <code>Bolstad</code> and plots the prior,
likelihood and posterior on the same plot. The aim is to show the influence
of the prior, and the likelihood on the posterior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomp(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decomp_+3A_x">x</code></td>
<td>
<p>an object of class <code>Bolstad</code>.</p>
</td></tr>
<tr><td><code id="decomp_+3A_...">...</code></td>
<td>
<p>any other arguments to be passed to the <code>plot</code> function.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that <code>xlab</code>, <code>ylab</code>, <code>main</code>, <code>axes</code>,
<code>xlim</code>, <code>ylim</code> and <code>type</code> are all used in the function so
specifying them is unlikely to have any effect.
</p>


<h3>Author(s)</h3>

<p>James Curran
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# an example with a binomial sampling situation
results = binobp(4, 12, 3, 3, plot = FALSE)
decomp(results)

# an example with normal data
y = c(2.99,5.56,2.83,3.47)
results = normnp(y, 3, 2, 1, plot = FALSE)
decomp(results)

</code></pre>

<hr>
<h2 id='IQR'>Interquartile Range generic</h2><span id='topic+IQR'></span>

<h3>Description</h3>

<p>Compute the interquartile range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IQR(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IQR_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="IQR_+3A_...">...</code></td>
<td>
<p>any additional arguments. These are primarily used in <code>IQR.default</code>
which calls <code>stats::IQR</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is an object of class <code>Bolstad</code> then the posterior 
IQR of the parameter of interest will be calculated.
</p>


<h3>Author(s)</h3>

<p>James Curran
</p>

<hr>
<h2 id='lines.Bolstad'>Lines method for Bolstad objects</h2><span id='topic+lines.Bolstad'></span>

<h3>Description</h3>

<p>Allows simple addition of posterior distributions from other results to an
existing plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Bolstad'
lines(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lines.Bolstad_+3A_x">x</code></td>
<td>
<p>an object of class <code>Bolstad</code>.</p>
</td></tr>
<tr><td><code id="lines.Bolstad_+3A_...">...</code></td>
<td>
<p>any additional parameters to be passed to <code>graphics::lines</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='mean.Bolstad'>Calculate the posterior mean</h2><span id='topic+mean.Bolstad'></span>

<h3>Description</h3>

<p>Calculate the posterior mean of an object of class <code>Bolstad</code>. If the 
object has a member <code>mean</code> then it will return this value otherwise it 
will calculate <code class="reqn">\int_{-\infty}^{+\infty}\theta f(\theta|x).d\theta</code> using 
linear interpolation to approximate the density function and numerical 
integration where <code class="reqn">\theta</code> is the variable for which we want to do 
Bayesian inference, and <code class="reqn">x</code> is the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Bolstad'
mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean.Bolstad_+3A_x">x</code></td>
<td>
<p>An object of class <code>Bolstad</code></p>
</td></tr>
<tr><td><code id="mean.Bolstad_+3A_...">...</code></td>
<td>
<p>Any other arguments. This parameter is currently ignored but it 
could be useful in the future to deal with problematic data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The posterior mean of the variable of inference given the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The useful of this method is really highlighted when we have a general 
# continuous prior. In this example we are interested in the posterior mean of 
# an normal mean. Our prior is triangular over [-3, 3]
set.seed(123)
x = rnorm(20, -0.5, 1)
mu = seq(-3, 3, by = 0.001)
mu.prior = rep(0, length(mu))
mu.prior[mu &lt;= 0] = 1 / 3 + mu[mu &lt;= 0] / 9
mu.prior[mu &gt; 0] = 1 / 3 - mu[mu &gt; 0] / 9
results = normgcp(x, 1, density = "user", mu = mu, mu.prior = mu.prior)
mean(results)
</code></pre>

<hr>
<h2 id='median.Bolstad'>Median generic</h2><span id='topic+median.Bolstad'></span>

<h3>Description</h3>

<p>Compute the posterior median of the posterior distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Bolstad'
median(x, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="median.Bolstad_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="median.Bolstad_+3A_na.rm">na.rm</code></td>
<td>
<p>Ideally if <code>TRUE</code> then missing values will be removed, but not currently used.</p>
</td></tr>
<tr><td><code id="median.Bolstad_+3A_...">...</code></td>
<td>
<p>[&gt;=R3.4.0 only] Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is an object of class <code>Bolstad</code> then the posterior 
median of the parameter of interest will be calculated.
</p>


<h3>Author(s)</h3>

<p>James Curran
</p>

<hr>
<h2 id='moisture.df'>Moisture data</h2><span id='topic+moisture.df'></span>

<h3>Description</h3>

<p>Moisture level at two stages in a food manufacturing process, in-process and final.
These data are given in Example 14.1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moisture.df
</code></pre>


<h3>Format</h3>

<p>A data frame with 25 observations on the following 6 variables.
</p>
 <ul>
<li><p>batch. the batch number of the measurement
</p>
</li>
<li><p>proc.level. the in-process moisture level </p>
</li>
<li><p>final.level. natural
the final moisture level of the batch </p>
</li>
<li><p>ls.fit the least squares fitted value
of final.level given proc.level </p>
</li>
<li><p>residiual. the least squares residual
</p>
</li>
<li><p>residiual.sq. the squaredvleast squares residual</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(moisture.df)
plot(final.level~proc.level, data = moisture.df)


</code></pre>

<hr>
<h2 id='mvnmvnp'>Bayesian inference on a mutlivariate normal (MVN) mean with a multivariate normal (MVN) prior</h2><span id='topic+mvnmvnp'></span>

<h3>Description</h3>

<p>Evaluates posterior density for <code class="reqn">\mu</code>, the mean of a
MVN distribution, with a MVN prior on <code class="reqn">\mu</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvnmvnp(y, m0 = 0, V0 = 1, Sigma = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvnmvnp_+3A_y">y</code></td>
<td>
<p>a vector of observations from a MVN distribution with unknown
mean and known variance-covariance.</p>
</td></tr>
<tr><td><code id="mvnmvnp_+3A_m0">m0</code></td>
<td>
<p>the mean vector of the MVN prior, or a scalar constant so that the prior
vector of length <code class="reqn">k</code> with the same element repeated k times, e.g. <code>m0 = 0</code></p>
</td></tr>
<tr><td><code id="mvnmvnp_+3A_v0">V0</code></td>
<td>
<p>the variance-covariance matrix of the MVN prior, or the diagonal 
of the variance-covariance matrix of the MVN prior, or a scalar constant, say <code class="reqn">n_0</code>,  
so the prior is <code class="reqn">n_0\times \mathbf{I}_k</code> where <code class="reqn">\mathbf{I}_k</code> is the <code class="reqn">k</code> by <code class="reqn">k</code> identity matrix.</p>
</td></tr>
<tr><td><code id="mvnmvnp_+3A_sigma">Sigma</code></td>
<td>
<p>the known variance covariance matrix of the data. If
this value is NULL, which it is by default, then the sample covariance is used. NOTE:
if this is the case then the cdf and quantile functions should really be multivariate
t, but they are not - in which case the results are only (approximately) valid for large samples.</p>
</td></tr>
<tr><td><code id="mvnmvnp_+3A_...">...</code></td>
<td>
<p>any other values to be passed to Bolstad.control</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list will be returned with the following components: 
</p>
<table role = "presentation">
<tr><td><code>mean</code></td>
<td>
<p>the posterior mean of the MVN posterior distribution</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>the posterior variance-covariance matrix of the MVN posterior distribution</p>
</td></tr>
<tr><td><code>cdf</code></td>
<td>
<p>a function that will evaluation the posterior cdf at a given point. This function calls <code>mvtnmorm::pmvnorm</code>.</p>
</td></tr>
<tr><td><code>quantile</code></td>
<td>
<p>a function that will find quantiles from the posterior given input probabilities. This function calls <code>mvtnorm::qmvnorm</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='normdp'>Bayesian inference on a normal mean with a discrete prior</h2><span id='topic+normdp'></span>

<h3>Description</h3>

<p>Evaluates and plots the posterior density for <code class="reqn">\mu</code>, the mean of a
normal distribution, with a discrete prior on <code class="reqn">\mu</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normdp(x, sigma.x = NULL, mu = NULL, mu.prior = NULL, n.mu = 50, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normdp_+3A_x">x</code></td>
<td>
<p>a vector of observations from a normal distribution with unknown
mean and known std. deviation.</p>
</td></tr>
<tr><td><code id="normdp_+3A_sigma.x">sigma.x</code></td>
<td>
<p>the population std. deviation of the normal distribution</p>
</td></tr>
<tr><td><code id="normdp_+3A_mu">mu</code></td>
<td>
<p>a vector of possibilities for the probability of success in a
single trial. If mu is NULL then a uniform prior is used.</p>
</td></tr>
<tr><td><code id="normdp_+3A_mu.prior">mu.prior</code></td>
<td>
<p>the associated prior probability mass.</p>
</td></tr>
<tr><td><code id="normdp_+3A_n.mu">n.mu</code></td>
<td>
<p>the number of possible <code class="reqn">\mu</code> values in the prior</p>
</td></tr>
<tr><td><code id="normdp_+3A_...">...</code></td>
<td>
<p>additional arguments that are passed to <code>Bolstad.control</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list will be returned with the following components: </p>
<table role = "presentation">
<tr><td><code>mu</code></td>
<td>
<p>the
vector of possible <code class="reqn">\mu</code> values used in the prior</p>
</td></tr>
<tr><td><code>mu.prior</code></td>
<td>
<p>the associated probability mass for the values in
<code class="reqn">\mu</code></p>
</td></tr> <tr><td><code>likelihood</code></td>
<td>
<p>the scaled likelihood function for
<code class="reqn">\mu</code> given <code class="reqn">x</code> and <code class="reqn">\sigma_x</code></p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>the posterior probability of <code class="reqn">\mu</code> given <code class="reqn">x</code>
and <code class="reqn">\sigma_x</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+normnp">normnp</a></code> <code><a href="#topic+normgcp">normgcp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate a sample of 20 observations from a N(-0.5,1) population
x = rnorm(20,-0.5,1)

## find the posterior density with a uniform prior on mu
normdp(x,1)

## find the posterior density with a non-uniform prior on mu
mu = seq(-3,3,by=0.1)
mu.prior = runif(length(mu))
mu.prior = sort(mu.prior/sum(mu.prior))
normdp(x,1,mu,mu.prior)

## Let mu have the discrete distribution with 5 possible
## values, 2, 2.5, 3, 3.5 and 4, and associated prior probability of
## 0.1, 0.2, 0.4, 0.2, 0.1 respectively. Find the posterior
## distribution after a drawing random sample of n = 5 observations
## from a N(mu,1) distribution y = [1.52, 0.02, 3.35, 3.49, 1.82]
mu = seq(2,4,by=0.5)
mu.prior = c(0.1,0.2,0.4,0.2,0.1)
y = c(1.52,0.02,3.35,3.49,1.82)
normdp(y,1,mu,mu.prior)

</code></pre>

<hr>
<h2 id='normgcp'>Bayesian inference on a normal mean with a general continuous prior</h2><span id='topic+normgcp'></span>

<h3>Description</h3>

<p>Evaluates and plots the posterior density for <code class="reqn">\mu</code>, the mean of a
normal distribution, with a general continuous prior on <code class="reqn">\mu</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normgcp(
  x,
  sigma.x = NULL,
  density = c("uniform", "normal", "flat", "user"),
  params = NULL,
  n.mu = 50,
  mu = NULL,
  mu.prior = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normgcp_+3A_x">x</code></td>
<td>
<p>a vector of observations from a normal distribution with unknown
mean and known std. deviation.</p>
</td></tr>
<tr><td><code id="normgcp_+3A_sigma.x">sigma.x</code></td>
<td>
<p>the population std. deviation of the normal distribution</p>
</td></tr>
<tr><td><code id="normgcp_+3A_density">density</code></td>
<td>
<p>distributional form of the prior density can be one of:
&quot;normal&quot;, &quot;unform&quot;, or &quot;user&quot;.</p>
</td></tr>
<tr><td><code id="normgcp_+3A_params">params</code></td>
<td>
<p>if density = &quot;normal&quot; then params must contain at least a mean
and possible a std. deviation. If a std. deviation is not specified then
sigma.x will be used as the std. deviation of the prior. If density =
&quot;uniform&quot; then params must contain a minimum and a maximum value for the
uniform prior. If a maximum and minimum are not specified then a
<code class="reqn">U[0,1]</code> prior is used</p>
</td></tr>
<tr><td><code id="normgcp_+3A_n.mu">n.mu</code></td>
<td>
<p>the number of possible <code class="reqn">\mu</code> values in the prior</p>
</td></tr>
<tr><td><code id="normgcp_+3A_mu">mu</code></td>
<td>
<p>a vector of possibilities for the probability of success in a
single trial. Must be set if density=&quot;user&quot;</p>
</td></tr>
<tr><td><code id="normgcp_+3A_mu.prior">mu.prior</code></td>
<td>
<p>the associated prior density. Must be set if density=&quot;user&quot;</p>
</td></tr>
<tr><td><code id="normgcp_+3A_...">...</code></td>
<td>
<p>additional arguments that are passed to <code>Bolstad.control</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list will be returned with the following components:
</p>
<table role = "presentation">
<tr><td><code>likelihood</code></td>
<td>
<p>the scaled likelihood function for <code class="reqn">\mu</code> given
<code class="reqn">x</code> and <code class="reqn">\sigma_x</code></p>
</td></tr> <tr><td><code>posterior</code></td>
<td>
<p>the posterior
probability of <code class="reqn">\mu</code> given <code class="reqn">x</code> and <code class="reqn">\sigma</code></p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the vector of possible <code class="reqn">\mu</code> values used in the prior</p>
</td></tr>
<tr><td><code>mu.prior</code></td>
<td>
<p>the associated probability mass for the values in
<code class="reqn">\mu</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+normdp">normdp</a></code> <code><a href="#topic+normnp">normnp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate a sample of 20 observations from a N(-0.5,1) population
x = rnorm(20,-0.5,1)

## find the posterior density with a uniform U[-3,3] prior on mu
normgcp(x, 1, params = c(-3, 3))

## find the posterior density with a non-uniform prior on mu
mu = seq(-3, 3, by = 0.1)
mu.prior = rep(0, length(mu))
mu.prior[mu &lt;= 0] = 1 / 3 + mu[mu &lt;= 0] /9
mu.prior[mu &gt; 0] = 1 / 3 - mu[mu &gt; 0] / 9
normgcp(x, 1, density = "user", mu = mu, mu.prior = mu.prior)

## find the CDF for the previous example and plot it
## Note the syntax for sintegral has changed
results = normgcp(x,1,density="user",mu=mu,mu.prior=mu.prior)
cdf = sintegral(mu,results$posterior,n.pts=length(mu))$cdf
plot(cdf,type="l",xlab=expression(mu[0])
             ,ylab=expression(Pr(mu&lt;=mu[0])))

## use the CDF for the previous example to find a 95%
## credible interval for mu. Thanks to John Wilkinson for this simplified code

lcb = cdf$x[with(cdf,which.max(x[y&lt;=0.025]))]
ucb = cdf$x[with(cdf,which.max(x[y&lt;=0.975]))]
cat(paste("Approximate 95% credible interval : ["
           ,round(lcb,4)," ",round(ucb,4),"]\n",sep=""))

## use the CDF from the previous example to find the posterior mean
## and std. deviation
dens = mu*results$posterior
post.mean = sintegral(mu,dens)$value

dens = (mu-post.mean)^2*results$posterior
post.var = sintegral(mu,dens)$value
post.sd = sqrt(post.var)

## use the mean and std. deviation from the previous example to find
## an approximate 95% credible interval
lb = post.mean-qnorm(0.975)*post.sd
ub = post.mean+qnorm(0.975)*post.sd


cat(paste("Approximate 95% credible interval : ["
   ,round(lb,4)," ",round(ub,4),"]\n",sep=""))

## repeat the last example but use the new summary functions for the posterior
results = normgcp(x, 1, density = "user", mu = mu, mu.prior = mu.prior)

## use the cdf function to get the cdf and plot it
postCDF = cdf(results) ## note this is a function
plot(results$mu, postCDF(results$mu), type="l", xlab = expression(mu[0]),
     ylab = expression(Pr(mu &lt;= mu[0])))

## use the quantile function to get a 95% credible interval
ci = quantile(results, c(0.025, 0.975))
ci

## use the mean and sd functions to get the posterior mean and standard deviation
postMean = mean(results)
postSD = sd(results)
postMean
postSD

## use the mean and std. deviation from the previous example to find
## an approximate 95% credible interval
ciApprox = postMean + c(-1,1) * qnorm(0.975) * postSD
ciApprox

</code></pre>

<hr>
<h2 id='normmixp'>Bayesian inference on a normal mean with a mixture of normal priors</h2><span id='topic+normmixp'></span>

<h3>Description</h3>

<p>Evaluates and plots the posterior density for <code class="reqn">\mu</code>, the mean of a
normal distribution, with a mixture of normal priors on <code class="reqn">\mu</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normmixp(
  x,
  sigma.x,
  prior0,
  prior1,
  p = 0.5,
  mu = NULL,
  n.mu = max(100, length(mu)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normmixp_+3A_x">x</code></td>
<td>
<p>a vector of observations from a normal distribution with unknown
mean and known std. deviation.</p>
</td></tr>
<tr><td><code id="normmixp_+3A_sigma.x">sigma.x</code></td>
<td>
<p>the population std. deviation of the observations.</p>
</td></tr>
<tr><td><code id="normmixp_+3A_prior0">prior0</code></td>
<td>
<p>the vector of length 2 which contains the means and standard
deviation of your precise prior.</p>
</td></tr>
<tr><td><code id="normmixp_+3A_prior1">prior1</code></td>
<td>
<p>the vector of length 2 which contains the means and standard
deviation of your vague prior.</p>
</td></tr>
<tr><td><code id="normmixp_+3A_p">p</code></td>
<td>
<p>the mixing proportion for the two component normal priors.</p>
</td></tr>
<tr><td><code id="normmixp_+3A_mu">mu</code></td>
<td>
<p>a vector of prior possibilities for the mean. If it is <code>NULL</code>,
then a vector centered on the sample mean is created.</p>
</td></tr>
<tr><td><code id="normmixp_+3A_n.mu">n.mu</code></td>
<td>
<p>the number of possible <code class="reqn">\mu</code> values in the prior.</p>
</td></tr>
<tr><td><code id="normmixp_+3A_...">...</code></td>
<td>
<p>additional arguments that are passed to <code>Bolstad.control</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list will be returned with the following components: </p>
<table role = "presentation">
<tr><td><code>mu</code></td>
<td>
<p>the
vector of possible <code class="reqn">\mu</code> values used in the prior</p>
</td></tr> <tr><td><code>prior</code></td>
<td>
<p>the
associated probability mass for the values in <code class="reqn">\mu</code></p>
</td></tr>
<tr><td><code>likelihood</code></td>
<td>
<p>the scaled likelihood function for <code class="reqn">\mu</code> given
<code class="reqn">x</code> and <code class="reqn">\sigma_x</code></p>
</td></tr> <tr><td><code>posterior</code></td>
<td>
<p>the posterior
probability of <code class="reqn">\mu</code> given <code class="reqn">x</code> and <code class="reqn">\sigma_x</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+binomixp">binomixp</a></code> <code><a href="#topic+normdp">normdp</a></code> <code><a href="#topic+normgcp">normgcp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate a sample of 20 observations from a N(-0.5, 1) population
x = rnorm(20, -0.5, 1)

## find the posterior density with a N(0, 1) prior on mu - a 50:50 mix of
## two N(0, 1) densities
normmixp(x, 1, c(0, 1), c(0, 1))

## find the posterior density with 50:50 mix of a N(0.5, 3) prior and a
## N(0, 1) prior on mu
normmixp(x, 1, c(0.5, 3), c(0, 1))

## Find the posterior density for mu, given a random sample of 4
## observations from N(mu, 1), y = [2.99, 5.56, 2.83, 3.47],
## and a 80:20 mix of a N(3, 2) prior and a N(0, 100) prior for mu
x = c(2.99, 5.56, 2.83, 3.47)
normmixp(x, 1, c(3, 2), c(0, 100), 0.8)

</code></pre>

<hr>
<h2 id='normnp'>Bayesian inference on a normal mean with a normal prior</h2><span id='topic+normnp'></span>

<h3>Description</h3>

<p>Evaluates and plots the posterior density for <code class="reqn">\mu</code>, the mean of a
normal distribution, with a normal prior on <code class="reqn">\mu</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normnp(
  x,
  m.x = 0,
  s.x = 1,
  sigma.x = NULL,
  mu = NULL,
  n.mu = max(100, length(mu)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normnp_+3A_x">x</code></td>
<td>
<p>a vector of observations from a normal distribution with unknown
mean and known std. deviation.</p>
</td></tr>
<tr><td><code id="normnp_+3A_m.x">m.x</code></td>
<td>
<p>the mean of the normal prior</p>
</td></tr>
<tr><td><code id="normnp_+3A_s.x">s.x</code></td>
<td>
<p>the standard deviation of the normal prior</p>
</td></tr>
<tr><td><code id="normnp_+3A_sigma.x">sigma.x</code></td>
<td>
<p>the population std. deviation of the normal distribution. If
this value is NULL, which it is by default, then a flat prior is used and
m.x and s.x are ignored</p>
</td></tr>
<tr><td><code id="normnp_+3A_mu">mu</code></td>
<td>
<p>a vector of prior possibilities for the true mean. If this is <code>null</code>,
then a set of values centered on the sample mean is used.</p>
</td></tr>
<tr><td><code id="normnp_+3A_n.mu">n.mu</code></td>
<td>
<p>the number of possible <code class="reqn">\mu</code> values in the prior</p>
</td></tr>
<tr><td><code id="normnp_+3A_...">...</code></td>
<td>
<p>optional control arguments. See <code><a href="#topic+Bolstad.control">Bolstad.control</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list will be returned with the following components: </p>
<table role = "presentation">
<tr><td><code>mu</code></td>
<td>
<p>the
vector of possible <code class="reqn">\mu</code> values used in the prior</p>
</td></tr>
<tr><td><code>mu.prior</code></td>
<td>
<p>the associated probability mass for the values in
<code class="reqn">\mu</code></p>
</td></tr> <tr><td><code>likelihood</code></td>
<td>
<p>the scaled likelihood function for
<code class="reqn">\mu</code> given <code class="reqn">x</code> and <code class="reqn">\sigma_x</code></p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>the posterior probability of <code class="reqn">\mu</code> given <code class="reqn">x</code>
and <code class="reqn">\sigma_x</code></p>
</td></tr> <tr><td><code>mean</code></td>
<td>
<p>the posterior mean</p>
</td></tr> <tr><td><code>sd</code></td>
<td>
<p>the
posterior standard deviation</p>
</td></tr> <tr><td><code>qtls</code></td>
<td>
<p>a selection of quantiles from the
posterior density</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+normdp">normdp</a></code> <code><a href="#topic+normgcp">normgcp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate a sample of 20 observations from a N(-0.5,1) population
x = rnorm(20,-0.5,1)

## find the posterior density with a N(0,1) prior on mu
normnp(x,sigma=1)

## find the posterior density with N(0.5,3) prior on mu
normnp(x,0.5,3,1)

## Find the posterior density for mu, given a random sample of 4
## observations from N(mu,sigma^2=1), y = [2.99, 5.56, 2.83, 3.47],
## and a N(3,sd=2)$ prior for mu
y = c(2.99,5.56,2.83,3.47)
normnp(y,3,2,1)

</code></pre>

<hr>
<h2 id='nvaricp'>Bayesian inference for a normal standard deviation with a scaled inverse
chi-squared distribution</h2><span id='topic+nvaricp'></span>

<h3>Description</h3>

<p>Evaluates and plots the posterior density for <code class="reqn">\sigma</code>, the
standard deviation of a Normal distribution where the mean <code class="reqn">\mu</code> is
known
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nvaricp(y, mu, S0, kappa, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nvaricp_+3A_y">y</code></td>
<td>
<p>a random sample from a
<code class="reqn">normal(\mu,\sigma^2)</code> distribution.</p>
</td></tr>
<tr><td><code id="nvaricp_+3A_mu">mu</code></td>
<td>
<p>the known population mean of the random sample.</p>
</td></tr>
<tr><td><code id="nvaricp_+3A_s0">S0</code></td>
<td>
<p>the prior scaling factor.</p>
</td></tr>
<tr><td><code id="nvaricp_+3A_kappa">kappa</code></td>
<td>
<p>the degrees of freedom of the prior.</p>
</td></tr>
<tr><td><code id="nvaricp_+3A_...">...</code></td>
<td>
<p>additional arguments that are passed to <code>Bolstad.control</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list will be returned with the following components:
</p>
<table role = "presentation">
<tr><td><code>sigma</code></td>
<td>
<p>the vaules of <code class="reqn">\sigma</code> for which the prior,
likelihood and posterior have been calculated</p>
</td></tr> <tr><td><code>prior</code></td>
<td>
<p>the prior
density for <code class="reqn">\sigma</code></p>
</td></tr> <tr><td><code>likelihood</code></td>
<td>
<p>the likelihood function
for <code class="reqn">\sigma</code> given <code class="reqn">y</code></p>
</td></tr> <tr><td><code>posterior</code></td>
<td>
<p>the posterior
density of <code class="reqn">\mu</code> given <code class="reqn">y</code></p>
</td></tr> <tr><td><code>S1</code></td>
<td>
<p>the posterior
scaling constant</p>
</td></tr> <tr><td><code>kappa1</code></td>
<td>
<p>the posterior degrees of freedom</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Suppose we have five observations from a normal(mu, sigma^2)
## distribution mu = 200 which are 206.4, 197.4, 212.7, 208.5.
y = c(206.4, 197.4, 212.7, 208.5, 203.4)

## We wish to choose a prior that has a median of 8. This happens when
## S0 = 29.11 and kappa = 1
nvaricp(y,200,29.11,1)

##  Same as the previous example but a calculate a 95% credible
## interval for sigma. NOTE this method has changed
results = nvaricp(y,200,29.11,1)
quantile(results, probs = c(0.025, 0.975))
</code></pre>

<hr>
<h2 id='plot.Bolstad'>Plot method for objects of type Bolstad</h2><span id='topic+plot.Bolstad'></span>

<h3>Description</h3>

<p>A unified plotting method for plotting the prior, likelihood and posterior 
from any of the analyses in the book
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Bolstad'
plot(
  x,
  overlay = TRUE,
  which = c(1, 3),
  densCols = c("red", "green", "blue")[which],
  legendLoc = "topleft",
  scaleLike = FALSE,
  xlab = eval(expression(x$name)),
  ylab = "",
  main = "Shape of prior and posterior",
  ylim = c(0, max(cbind(x$prior, x$likelihood, x$posterior)[, which]) * 1.1),
  cex = 0.7,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.Bolstad_+3A_x">x</code></td>
<td>
<p>A S3 object of class Bolstad</p>
</td></tr>
<tr><td><code id="plot.Bolstad_+3A_overlay">overlay</code></td>
<td>
<p>if <code>FALSE</code> then up to three plots will be drawn 
side-by-side</p>
</td></tr>
<tr><td><code id="plot.Bolstad_+3A_which">which</code></td>
<td>
<p>Control which of the prior = 1, likelihood = 2, and posterior = 
3, are plots. This is set to prior and posterior by default to retain 
compatibility with the book</p>
</td></tr>
<tr><td><code id="plot.Bolstad_+3A_denscols">densCols</code></td>
<td>
<p>The colors of the lines for each of the prior, likelihood and
posterior</p>
</td></tr>
<tr><td><code id="plot.Bolstad_+3A_legendloc">legendLoc</code></td>
<td>
<p>The location of the legend, usually either <code>"topright"</code>
or <code>"topleft"</code></p>
</td></tr>
<tr><td><code id="plot.Bolstad_+3A_scalelike">scaleLike</code></td>
<td>
<p>If <code>TRUE</code>, then the likelihood will be scaled to have
approximately the same maximum value as the posterior</p>
</td></tr>
<tr><td><code id="plot.Bolstad_+3A_xlab">xlab</code></td>
<td>
<p>Label for x axis</p>
</td></tr>
<tr><td><code id="plot.Bolstad_+3A_ylab">ylab</code></td>
<td>
<p>Label for y axis</p>
</td></tr>
<tr><td><code id="plot.Bolstad_+3A_main">main</code></td>
<td>
<p>Title of plot</p>
</td></tr>
<tr><td><code id="plot.Bolstad_+3A_ylim">ylim</code></td>
<td>
<p>Vector giving y coordinate range</p>
</td></tr>
<tr><td><code id="plot.Bolstad_+3A_cex">cex</code></td>
<td>
<p>Character expansion multiplier</p>
</td></tr>
<tr><td><code id="plot.Bolstad_+3A_...">...</code></td>
<td>
<p>Any remaining arguments are fed to the <code>plot</code> command</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function provides a unified way of plotting the prior, likelihood and 
posterior from any of the functions in the library that return these 
quantities. It will produce an overlay of the lines by default, or separate 
panels if <code>overlay = FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>James Curran
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = rnorm(20,-0.5,1)
## find the posterior density with a N(0,1) prior on mu
b = normnp(x,sigma=1)
plot(b)
plot(b, which = 1:3)
plot(b, overlay = FALSE, which = 1:3)
</code></pre>

<hr>
<h2 id='poisdp'>Poisson sampling with a discrete prior</h2><span id='topic+poisdp'></span>

<h3>Description</h3>

<p>Evaluates and plots the posterior density for <code class="reqn">\mu</code>, the mean rate
of occurance in a Poisson process and a discrete prior on <code class="reqn">\mu</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poisdp(y.obs, mu, mu.prior, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poisdp_+3A_y.obs">y.obs</code></td>
<td>
<p>a random sample from a Poisson distribution.</p>
</td></tr>
<tr><td><code id="poisdp_+3A_mu">mu</code></td>
<td>
<p>a vector of possibilities for the mean rate of occurance of an
event over a finite period of space or time.</p>
</td></tr>
<tr><td><code id="poisdp_+3A_mu.prior">mu.prior</code></td>
<td>
<p>the associated prior probability mass.</p>
</td></tr>
<tr><td><code id="poisdp_+3A_...">...</code></td>
<td>
<p>additional arguments that are passed to <code>Bolstad.control</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list will be returned with the following components:
</p>
<table role = "presentation">
<tr><td><code>likelihood</code></td>
<td>
<p>the scaled likelihood function for <code class="reqn">\mu</code> given
<code class="reqn">y_{obs}</code></p>
</td></tr> <tr><td><code>posterior</code></td>
<td>
<p>the posterior probability of
<code class="reqn">\mu</code> given <code class="reqn">y_{obs}</code></p>
</td></tr> <tr><td><code>mu</code></td>
<td>
<p>the vector of possible
<code class="reqn">\mu</code> values used in the prior</p>
</td></tr> <tr><td><code>mu.prior</code></td>
<td>
<p>the associated
probability mass for the values in <code class="reqn">\mu</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+poisgamp">poisgamp</a></code> <code><a href="#topic+poisgcp">poisgcp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simplest call with an observation of 4 and a uniform prior on the
## values mu = 1,2,3
poisdp(4,1:3,c(1,1,1)/3)

##  Same as the previous example but a non-uniform discrete prior
mu = 1:3
mu.prior = c(0.3,0.4,0.3)
poisdp(4,mu=mu,mu.prior=mu.prior)

##  Same as the previous example but a non-uniform discrete prior
mu = seq(0.5,9.5,by=0.05)
mu.prior = runif(length(mu))
mu.prior = sort(mu.prior/sum(mu.prior))
poisdp(4,mu=mu,mu.prior=mu.prior)

## A random sample of 50 observations from a Poisson distribution with
## parameter mu = 3 and  non-uniform prior
y.obs = rpois(50,3)
mu = c(1:5)
mu.prior = c(0.1,0.1,0.05,0.25,0.5)
results = poisdp(y.obs, mu, mu.prior)

##  Same as the previous example but a non-uniform discrete prior
mu = seq(0.5,5.5,by=0.05)
mu.prior = runif(length(mu))
mu.prior = sort(mu.prior/sum(mu.prior))
y.obs = rpois(50,3)
poisdp(y.obs,mu=mu,mu.prior=mu.prior)


</code></pre>

<hr>
<h2 id='poisgamp'>Poisson sampling with a gamma prior</h2><span id='topic+poisgamp'></span>

<h3>Description</h3>

<p>Evaluates and plots the posterior density for <code class="reqn">\mu</code>, the mean rate
of occurance in a Poisson process and a <code class="reqn">gamma</code> prior on <code class="reqn">\mu</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poisgamp(y, shape, rate = 1, scale = 1/rate, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poisgamp_+3A_y">y</code></td>
<td>
<p>a random sample from a Poisson distribution.</p>
</td></tr>
<tr><td><code id="poisgamp_+3A_shape">shape</code></td>
<td>
<p>the shape parameter of the <code class="reqn">gamma</code> prior.</p>
</td></tr>
<tr><td><code id="poisgamp_+3A_rate">rate</code></td>
<td>
<p>the rate parameter of the <code class="reqn">gamma</code> prior. Note that the scale
is <code class="reqn">1 / rate</code></p>
</td></tr>
<tr><td><code id="poisgamp_+3A_scale">scale</code></td>
<td>
<p>the scale parameter of the <code class="reqn">gamma</code> prior</p>
</td></tr>
<tr><td><code id="poisgamp_+3A_alpha">alpha</code></td>
<td>
<p>the width of the credible interval is controlled by the
parameter alpha.</p>
</td></tr>
<tr><td><code id="poisgamp_+3A_...">...</code></td>
<td>
<p>additional arguments that are passed to <code>Bolstad.control</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'Bolstad' is returned. This is a list with the
following components:
</p>
<table role = "presentation">
<tr><td><code>prior</code></td>
<td>
<p>the prior density assigned to <code class="reqn">\mu</code></p>
</td></tr>
<tr><td><code>likelihood</code></td>
<td>
<p>the scaled likelihood function for <code class="reqn">\mu</code> given
<code class="reqn">y</code></p>
</td></tr> <tr><td><code>posterior</code></td>
<td>
<p>the posterior probability of <code class="reqn">\mu</code> given
<code class="reqn">y</code></p>
</td></tr> <tr><td><code>shape</code></td>
<td>
<p>the shape parameter for the <code class="reqn">gamma</code> posterior</p>
</td></tr>
<tr><td><code>rate</code></td>
<td>
<p>the rate parameter for the <code class="reqn">gamma</code> posterior</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+poisdp">poisdp</a></code> <code><a href="#topic+poisgcp">poisgcp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simplest call with an observation of 4 and a gamma(1, 1), i.e. an exponential prior on the
## mu
poisgamp(4, 1, 1)

##  Same as the previous example but a gamma(10, ) prior
poisgamp(4, 10, 1)

##  Same as the previous example but an improper gamma(1, ) prior
poisgamp(4, 1, 0)

## A random sample of 50 observations from a Poisson distribution with
## parameter mu = 3 and  gamma(6,3) prior
set.seed(123)
y = rpois(50,3)
poisgamp(y,6,3)

## In this example we have a random sample from a Poisson distribution
## with an unknown mean. We will use a gamma(6,3) prior to obtain the
## posterior gamma distribution, and use the R function qgamma to get a
## 95% credible interval for mu
y = c(3,4,4,3,3,4,2,3,1,7)
results = poisgamp(y,6,3)
ci = qgamma(c(0.025,0.975),results$shape, results$rate)
cat(paste("95% credible interval for mu: [",round(ci[1],3), ",", round(ci[2],3)),"]\n")

## In this example we have a random sample from a Poisson distribution
## with an unknown mean. We will use a gamma(6,3) prior to obtain the
## posterior gamma distribution, and use the R function qgamma to get a
## 95% credible interval for mu
y = c(3,4,4,3,3,4,2,3,1,7)
results = poisgamp(y, 6, 3)
ci = quantile(results, c(0.025, 0.975))
cat(paste("95% credible interval for mu: [",round(ci[1],3), ",", round(ci[2],3)),"]\n")


</code></pre>

<hr>
<h2 id='poisgcp'>Poisson sampling with a general continuous prior</h2><span id='topic+poisgcp'></span>

<h3>Description</h3>

<p>Evaluates and plots the posterior density for <code class="reqn">\mu</code>, the mean rate
of occurance of an event or objects, with Poisson sampling and a general
continuous prior on <code class="reqn">\mu</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poisgcp(
  y,
  density = c("normal", "gamma", "user"),
  params = c(0, 1),
  n.mu = 100,
  mu = NULL,
  mu.prior = NULL,
  print.sum.stat = FALSE,
  alpha = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poisgcp_+3A_y">y</code></td>
<td>
<p>A random sample of one or more observations from a Poisson
distribution</p>
</td></tr>
<tr><td><code id="poisgcp_+3A_density">density</code></td>
<td>
<p>may be one of <code>"gamma"</code>, <code>"normal"</code>, or <code>"user"</code></p>
</td></tr>
<tr><td><code id="poisgcp_+3A_params">params</code></td>
<td>
<p>if density is one of the parameteric forms then then a vector
of parameters must be supplied.  gamma: a0,b0 normal: mean,sd</p>
</td></tr>
<tr><td><code id="poisgcp_+3A_n.mu">n.mu</code></td>
<td>
<p>the number of possible <code class="reqn">\mu</code> values in the prior. This
number must be greater than or equal to 100. It is ignored when
density=&quot;user&quot;.</p>
</td></tr>
<tr><td><code id="poisgcp_+3A_mu">mu</code></td>
<td>
<p>either a vector of possibilities for the mean of a Poisson distribution, or a range (a vector of length 2) of values.
This must be set if <code>density = "user"</code>. If <code>mu</code> is a range, then <code>n.mu</code> will be used to decide how many points to 
discretise this range over.</p>
</td></tr>
<tr><td><code id="poisgcp_+3A_mu.prior">mu.prior</code></td>
<td>
<p>either a vector containing y values correspoding to the values in <code>mu</code>, or a function. 
This is used to specifiy the prior <code class="reqn">f(\mu)</code>. So <code>mu.prior</code> can be a vector containing <code class="reqn">f(\mu_i)</code> 
for every <code class="reqn">\mu_i</code>, or a funtion. This must be set if <code>density == "user"</code>.</p>
</td></tr>
<tr><td><code id="poisgcp_+3A_print.sum.stat">print.sum.stat</code></td>
<td>
<p>if set to TRUE then the posterior mean, posterior
variance, and a credible interval for the mean are printed. The width of the
credible interval is controlled by the parameter alpha.</p>
</td></tr>
<tr><td><code id="poisgcp_+3A_alpha">alpha</code></td>
<td>
<p>The width of the credible interval is controlled by the
parameter alpha.</p>
</td></tr>
<tr><td><code id="poisgcp_+3A_...">...</code></td>
<td>
<p>additional arguments that are passed to <code>Bolstad.control</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list will be returned with the following components: </p>
<table role = "presentation">
<tr><td><code>mu</code></td>
<td>
<p>the
vector of possible <code class="reqn">\mu</code> values used in the prior</p>
</td></tr>
<tr><td><code>mu.prior</code></td>
<td>
<p>the associated probability mass for the values in
<code class="reqn">\mu</code></p>
</td></tr> <tr><td><code>likelihood</code></td>
<td>
<p>the scaled likelihood function for
<code class="reqn">\mu</code> given <code class="reqn">y</code></p>
</td></tr> <tr><td><code>posterior</code></td>
<td>
<p>the posterior probability of
<code class="reqn">\mu</code> given <code class="reqn">y</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+poisdp">poisdp</a></code> <code><a href="#topic+poisgamp">poisgamp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Our data is random sample is 3, 4, 3, 0, 1. We will try a normal
## prior with a mean of 2 and a standard deviation of 0.5.
y = c(3,4,3,0,1)
poisgcp(y, density = "normal", params = c(2,0.5))

## The same data as above, but with a gamma(6,8) prior
y = c(3,4,3,0,1)
poisgcp(y, density = "gamma", params = c(6,8))

## The same data as above, but a user specified continuous prior.
## We will use print.sum.stat to get a 99% credible interval for mu.
y = c(3,4,3,0,1)
mu = seq(0,8,by=0.001)
mu.prior = c(seq(0,2,by=0.001),rep(2,1999),seq(2,0,by=-0.0005))/10
poisgcp(y,"user",mu=mu,mu.prior=mu.prior,print.sum.stat=TRUE,alpha=0.01)

## find the posterior CDF using the results from the previous example
## and Simpson's rule. Note that the syntax of sintegral has changed.
results = poisgcp(y,"user",mu=mu,mu.prior=mu.prior)
cdf = sintegral(mu,results$posterior,n.pts=length(mu))$cdf
plot(cdf,type="l",xlab=expression(mu[0])
	,ylab=expression(Pr(mu&lt;=mu[0])))

## use the cdf to find the 95% credible region.
lcb = cdf$x[with(cdf,which.max(x[y&lt;=0.025]))]
ucb = cdf$x[with(cdf,which.max(x[y&lt;=0.975]))]
cat(paste("Approximate 95% credible interval : ["
	,round(lcb,4)," ",round(ucb,4),"]\n",sep=""))

## find the posterior mean, variance and std. deviation
## using Simpson's rule and the output from the previous example
dens = mu*results$posterior # calculate mu*f(mu | x, n)
post.mean = sintegral(mu,dens)$value

dens = (mu-post.mean)^2*results$posterior
post.var = sintegral(mu,dens)$value
post.sd = sqrt(post.var)

# calculate an approximate 95% credible region using the posterior mean and
# std. deviation
lb = post.mean-qnorm(0.975)*post.sd
ub = post.mean+qnorm(0.975)*post.sd

cat(paste("Approximate 95% credible interval : ["
	,round(lb,4)," ",round(ub,4),"]\n",sep=""))

# NOTE: All the examples given above can now be done trivially in this package

## find the posterior CDF using the results from the previous example
results = poisgcp(y,"user",mu=mu,mu.prior=mu.prior)
cdf = cdf(results)
curve(cdf,type="l",xlab=expression(mu[0])
	,ylab=expression(Pr(mu&lt;=mu[0])))

## use the quantile function to find the 95% credible region.
ci = quantile(results, c(0.025, 0.975))
cat(paste0("Approximate 95% credible interval : ["
	,round(ci[1],4)," ",round(ci[2],4),"]\n"))

## find the posterior mean, variance and std. deviation
## using the output from the previous example
post.mean = mean(results)

post.var = var(results)
post.sd = sd(results)

# calculate an approximate 95% credible region using the posterior mean and
# std. deviation
ci = post.mean + c(-1, 1) * qnorm(0.975) * post.sd

cat(paste("Approximate 95% credible interval : ["
	,round(ci[1],4)," ",round(ci[2],4),"]\n",sep=""))

## Example 10.1 Dianna's prior
# Firstly we need to write a function that replicates Diana's prior
f = function(mu){
   result = rep(0, length(mu))
   result[mu &gt;=0 &amp; mu &lt;=2] = mu[mu &gt;=0 &amp; mu &lt;=2]
   result[mu &gt;=2 &amp; mu &lt;=4] = 2
   result[mu &gt;=4 &amp; mu &lt;=8] = 4 - 0.5 * mu[mu &gt;=4 &amp; mu &lt;=8]
   
   ## we don't need to scale so the prior integrates to one, 
   ## but it makes the results nicer to see
   
   A = 2 + 4 + 4
   result = result / A
   
   return(result)
 }
 
 results = poisgcp(y, mu = c(0, 10), mu.prior = f)

</code></pre>

<hr>
<h2 id='print.Bolstad'>Print method for objects of class <code>Bolstad</code></h2><span id='topic+print.Bolstad'></span>

<h3>Description</h3>

<p>This function provides a print summary method for the output of
<code>bayes.lm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Bolstad'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.Bolstad_+3A_x">x</code></td>
<td>
<p>an object of class <code>Bolstad</code></p>
</td></tr>
<tr><td><code id="print.Bolstad_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="print.Bolstad_+3A_...">...</code></td>
<td>
<p>any other arguments that are to be passed to <code>print.default</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>if x has both class <code>Bolstad</code> and <code>lm</code> then a print method 
similar to <code>print.lm</code> is called, otherwise <code>print.default</code> is called
</p>


<h3>Author(s)</h3>

<p>James Curran
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayes.lm">bayes.lm</a></code>
</p>

<hr>
<h2 id='print.sintegral'>Generic print method</h2><span id='topic+print.sintegral'></span>

<h3>Description</h3>

<p>Print the value of an <code>sintegral</code> object, specifically the 
(approximate) value of the integral.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sintegral'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.sintegral_+3A_x">x</code></td>
<td>
<p>An object of type <code>sintegral</code>&ndash;see <code><a href="#topic+sintegral">sintegral</a></code>.</p>
</td></tr>
<tr><td><code id="print.sintegral_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code>paste0</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='print.sscsamp'>Print method for objects of class <code>sscsample</code></h2><span id='topic+print.sscsamp'></span>

<h3>Description</h3>

<p>This function provides a print summary method for the output of
<code>sscsample</code>. The <code>sscsample</code> produces a large number of samples
from a fixed population using either simple random, stratified, or cluster
sampling. This function provides the means of each sample plus the number of
observations from each ethnicity stratum in the sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sscsamp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.sscsamp_+3A_x">x</code></td>
<td>
<p>an object of class <code>sscsamp</code> produced by <code>sscsample</code></p>
</td></tr>
<tr><td><code id="print.sscsamp_+3A_...">...</code></td>
<td>
<p>any other arguments that are to be passed to <code>cat</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>James Curran
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sscsample">sscsample</a></code>
</p>

<hr>
<h2 id='quantile.Bolstad'>Posterior quantiles</h2><span id='topic+quantile.Bolstad'></span>

<h3>Description</h3>

<p>Posterior quantiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Bolstad'
quantile(x, probs = seq(0, 1, 0.25), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantile.Bolstad_+3A_x">x</code></td>
<td>
<p>an object of class <code>Bolstad</code></p>
</td></tr>
<tr><td><code id="quantile.Bolstad_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="quantile.Bolstad_+3A_...">...</code></td>
<td>
<p>any extra arguments needed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is of class <code>Bolstad</code> then this will find the
quantiles of the posterior distribution using numerical integration and
linear interpolation if necessary.
</p>

<hr>
<h2 id='sd'>Standard deviation generic</h2><span id='topic+sd'></span>

<h3>Description</h3>

<p>Standard deviation generic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sd_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="sd_+3A_...">...</code></td>
<td>
<p>Any additional arguments to be passed to <code>sd</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='sd.Bolstad'>Posterior standard deviation</h2><span id='topic+sd.Bolstad'></span>

<h3>Description</h3>

<p>Posterior standard deviation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Bolstad'
sd(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sd.Bolstad_+3A_x">x</code></td>
<td>
<p>an object of class <code>Bolstad</code> for which we want to compute the standard deviation.</p>
</td></tr>
<tr><td><code id="sd.Bolstad_+3A_...">...</code></td>
<td>
<p>Any additional arguments to be passed to <code>sd</code>.
</p>
<p>Calculate the posterior standard deviation of an object of class <code>Bolstad</code>. If the 
object has a member <code>sd</code> then it will return this value otherwise it 
will calculate the posterior standard deviation <code class="reqn">sd[\theta|x]</code> using 
linear interpolation to approximate the density function and numerical 
integration where <code class="reqn">\theta</code> is the variable for which we want to do 
Bayesian inference, and <code class="reqn">x</code> is the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The usefulness of this method is really highlighted when we have a general 
## continuous prior. In this example we are interested in the posterior
## standard deviation of an normal mean. Our prior is triangular over [-3, 3]
set.seed(123)
x = rnorm(20, -0.5, 1)

mu = seq(-3, 3, by = 0.001)

mu.prior = rep(0, length(mu))
mu.prior[mu &lt;= 0] = 1 / 3 + mu[mu &lt;= 0] / 9
mu.prior[mu &gt; 0] = 1 / 3 - mu[mu &gt; 0] / 9

results = normgcp(x, 1, density = "user", mu = mu, mu.prior = mu.prior, plot = FALSE)
sd(results)
</code></pre>

<hr>
<h2 id='sintegral'>Numerical integration using Simpson's Rule</h2><span id='topic+sintegral'></span>

<h3>Description</h3>

<p>Takes a vector of <code class="reqn">x</code> values and a corresponding set of postive
<code class="reqn">f(x)=y</code> values, or a function, and evaluates the area under the curve:
</p>
<p style="text-align: center;"><code class="reqn"> \int{f(x)dx} </code>
</p>
<p>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sintegral(x, fx, n.pts = max(256, length(x)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sintegral_+3A_x">x</code></td>
<td>
<p>a sequence of <code class="reqn">x</code> values.</p>
</td></tr>
<tr><td><code id="sintegral_+3A_fx">fx</code></td>
<td>
<p>the value of the function to be integrated at <code class="reqn">x</code> or a
function</p>
</td></tr>
<tr><td><code id="sintegral_+3A_n.pts">n.pts</code></td>
<td>
<p>the number of points to be used in the integration. If <code>x</code>
contains more than n.pts then n.pts will be set to <code>length(x)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two elements, <code>value</code> - the value of the
intergral, and <code>cdf</code> - a list containing elements x and y which give a
numeric specification of the cdf.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## integrate the normal density from -3 to 3
x = seq(-3, 3, length = 100)
fx = dnorm(x)
estimate = sintegral(x,fx)$value
true.val = diff(pnorm(c(-3,3)))
abs.error = abs(estimate-true.val)
rel.pct.error =  100*abs(estimate-true.val)/true.val
cat(paste("Absolute error :",round(abs.error,7),"\n"))
cat(paste("Relative percentage error :",round(rel.pct.error,6),"percent\n"))

## repeat the example above using dnorm as function
x = seq(-3, 3, length = 100)
estimate = sintegral(x,dnorm)$value
true.val = diff(pnorm(c(-3,3)))
abs.error = abs(estimate-true.val)
rel.pct.error =  100*abs(estimate-true.val)/true.val
cat(paste("Absolute error :",round(abs.error,7),"\n"))
cat(paste("Relative percentage error :",round(rel.pct.error,6)," percent\n"))

## use the cdf

cdf = sintegral(x,dnorm)$cdf
plot(cdf, type = 'l', col = "black")
lines(x, pnorm(x), col = "red", lty = 2)

## integrate the function x^2-1 over the range 1-2
x = seq(1,2,length = 100)
sintegral(x,function(x){x^2-1})$value

## compare to integrate
integrate(function(x){x^2-1},1,2)


</code></pre>

<hr>
<h2 id='slug'>Slug data</h2><span id='topic+slug'></span>

<h3>Description</h3>

<p>Lengths and weights of 100 slugs from the species Limax maximus collected
around Hamilton, New Zealand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slug
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on the following 4 variables.
</p>
 <ul>
<li><p>length. length (mm) of the slug
</p>
</li>
<li><p>weight. weight (g) of the slug </p>
</li>
<li><p>log.len. natural
logarithm of the <code>length</code> </p>
</li>
<li><p>log.wt. natural logarithm of
the <code>weight</code> </p>
</li></ul>



<h3>References</h3>

<p>Barker, G. and McGhie, R. (1984). The Biology of Introduced
Slugs (Pulmonata) in New Zealand: Introduction and Notes on Limax Maximus,
NZ Entomologist 8, 106&ndash;111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(slug)
plot(weight~length, data = slug)
plot(log.wt~log.len, data = slug)


</code></pre>

<hr>
<h2 id='sscsample'>Simple, Stratified and Cluster Sampling</h2><span id='topic+sscsample'></span>

<h3>Description</h3>

<p>Samples from a fixed population using either simple random sampling,
stratitified sampling or cluster sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sscsample(
  size,
  n.samples,
  sample.type = c("simple", "cluster", "stratified"),
  x = NULL,
  strata = NULL,
  cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sscsample_+3A_size">size</code></td>
<td>
<p>the desired size of the sample</p>
</td></tr>
<tr><td><code id="sscsample_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of repeat samples to take</p>
</td></tr>
<tr><td><code id="sscsample_+3A_sample.type">sample.type</code></td>
<td>
<p>the sampling method. Can be one of &quot;simple&quot;,
&quot;stratified&quot;, &quot;cluser&quot; or 1, 2, 3 where 1 corresponds to &quot;simple&quot;, 2 to
&quot;stratified&quot; and 3 to &quot;cluster&quot;</p>
</td></tr>
<tr><td><code id="sscsample_+3A_x">x</code></td>
<td>
<p>a vector of measurements for each unit in the population. By
default x is not used, and the builtin data set sscsample.data is used</p>
</td></tr>
<tr><td><code id="sscsample_+3A_strata">strata</code></td>
<td>
<p>a corresponding vector for each unit in the population
indicating membership to a stratum</p>
</td></tr>
<tr><td><code id="sscsample_+3A_cluster">cluster</code></td>
<td>
<p>a corresponding vector for each unit in the population
indicating membership to a cluster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list will be returned with the following components:
</p>
<table role = "presentation">
<tr><td><code>samples</code></td>
<td>
<p>a matrix with the number of rows equal to size and the number
of columns equal to n.samples. Each column corresponds to a sample drawn
from the population</p>
</td></tr> <tr><td><code>s.strata</code></td>
<td>
<p>a matrix showing how many units from
each stratum were included in the sample</p>
</td></tr> <tr><td><code>means</code></td>
<td>
<p>a vector containing
the mean of each sample drawn</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>James M. Curran, Dept. of Statistics, University of Auckland. Janko
Dietzsch, Proteomics Algorithm and Simulation,Zentrum f. Bioinformatik
Tuebingen Fakultaet f. Informations- und Kognitionswissenschaften,
Universitaet Tuebingen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Draw 200 samples of size 20 using simple random sampling
sscsample(20,200)

## Draw 200 samples of size 20 using simple random sampling and store the
## results. Extract the means of all 200 samples, and the 50th sample
res = sscsample(20,200)
res$means
res$samples[,50]

</code></pre>

<hr>
<h2 id='sscsample.data'>Data for simple random sampling, stratified sampling, and clusting sampling
experiments</h2><span id='topic+sscsample.data'></span>

<h3>Description</h3>

<p>A simulated population made up of 100 individuals. The individuals come from
three ethnic groups with population proportions of 40%, 40%, and 20%,
respectively. There are twenty neighborhoods, and five individuals live in
each one.  Now, the income distribution may be different for the three
ethnic groups.  Also, individuals in the same neighborhood tend to be more
similar than individuals in different neighborhoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sscsample.data
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on the following 3 variables.
</p>
 <ul>
<li><p>income. Simulated income in $10,000
</p>
</li>
<li><p>ethnicity. A numerical vector indicating the ethnic group of
the observation </p>
</li>
<li><p>neighborhood. A numeric vector indicating the
neighborhood of the observation </p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(sscsample.data)
plot(income~ethnicity, data = sscsample.data)

</code></pre>

<hr>
<h2 id='summary.Bolstad'>Summarizing Bayesian Multiple Linear Regression</h2><span id='topic+summary.Bolstad'></span>

<h3>Description</h3>

<p><code>summary</code> method for output of <code><a href="#topic+bayes.lm">bayes.lm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Bolstad'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.Bolstad_+3A_object">object</code></td>
<td>
<p>an object of &quot;<code>Bolstad</code>&quot; that is the result of a call to <code><a href="#topic+bayes.lm">bayes.lm</a></code></p>
</td></tr>
<tr><td><code id="summary.Bolstad_+3A_...">...</code></td>
<td>
<p>any further arguments to be passed to <code>print</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The function to fit the model <code><a href="#topic+bayes.lm">bayes.lm</a></code>
</p>
<p>The function <code><a href="stats.html#topic+coef">coef</a></code> to extract the matrix of posterior means along with standard errors and t-statistics.
</p>

<hr>
<h2 id='var'>Variance generic</h2><span id='topic+var'></span>

<h3>Description</h3>

<p>Variance generic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_+3A_x">x</code></td>
<td>
<p>an object for which we want to compute the variance</p>
</td></tr>
<tr><td><code id="var_+3A_...">...</code></td>
<td>
<p>Any additional arguments to be passed to <code>var</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='xdesign'>Monte Carlo study of randomized and blocked designs</h2><span id='topic+xdesign'></span>

<h3>Description</h3>

<p>Simulates completely randomized design and randomized block designs from a
population of experimental units with underlying response values <code class="reqn">y</code> and
underlying other variable values <code class="reqn">x</code> (possibly lurking)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xdesign(
  x = NULL,
  y = NULL,
  corr = 0.8,
  size = 20,
  n.treatments = 4,
  n.rep = 500,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xdesign_+3A_x">x</code></td>
<td>
<p>a set of lurking values which are correlated with the response</p>
</td></tr>
<tr><td><code id="xdesign_+3A_y">y</code></td>
<td>
<p>a set of response values</p>
</td></tr>
<tr><td><code id="xdesign_+3A_corr">corr</code></td>
<td>
<p>the correlation between the response and lurking variable</p>
</td></tr>
<tr><td><code id="xdesign_+3A_size">size</code></td>
<td>
<p>the size of the treatment groups</p>
</td></tr>
<tr><td><code id="xdesign_+3A_n.treatments">n.treatments</code></td>
<td>
<p>the number of treatments</p>
</td></tr>
<tr><td><code id="xdesign_+3A_n.rep">n.rep</code></td>
<td>
<p>the number of Monte Carlo replicates</p>
</td></tr>
<tr><td><code id="xdesign_+3A_...">...</code></td>
<td>
<p>additional parameters which are passed to <code>Bolstad.control</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the ouput of xdesign is assigned to a variable, then a list is
returned with the following components: </p>
<table role = "presentation">
<tr><td><code>block.means</code></td>
<td>
<p>a vector of the
means of the lurking variable from each replicate of the simulation stored
by treatment number within replicate number</p>
</td></tr> <tr><td><code>treat.means</code></td>
<td>
<p>a vector of
the means of the response variable from each replicate of the simulation
stored by treatment number within replicate number</p>
</td></tr> <tr><td><code>ind</code></td>
<td>
<p>a vector
containing the treatment group numbers. Note that there will be twice as
many group numbers as there are treatments corresponding to the simulations
done using a completely randomized design and the simulations done using a
randomized block design</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Carry out simulations using the default parameters 

xdesign()

# Carry out simulations using a simulated response with 5 treaments, 
# groups of size 25, and a correlation of -0.6 between the response 
# and lurking variable

xdesign(corr = -0.6, size = 25, n.treatments = 5)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
