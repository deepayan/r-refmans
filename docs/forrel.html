<!DOCTYPE html><html lang="en-GB"><head><title>Help for package forrel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {forrel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#forrel-package'><p>forrel: Forensic Pedigree Analysis and Relatedness Inference</p></a></li>
<li><a href='#checkPairwise'><p>Check pedigree data for relationship errors</p></a></li>
<li><a href='#exclusionPower'><p>Power of exclusion</p></a></li>
<li><a href='#expectedLR'><p>Expected likelihood ratio</p></a></li>
<li><a href='#familias'><p>Import/export from Familias</p></a></li>
<li><a href='#findExclusions'><p>Find markers excluding an identification</p></a></li>
<li><a href='#FORCE'><p>FORCE panel kinship SNPs</p></a></li>
<li><a href='#ibdBootstrap'><p>Bootstrap estimation of IBD coefficients</p></a></li>
<li><a href='#ibdEstimate'><p>Pairwise relatedness estimation</p></a></li>
<li><a href='#ibdLoglik'><p>Pairwise IBD likelihood</p></a></li>
<li><a href='#kinshipLR'><p>Likelihood ratios for kinship testing</p></a></li>
<li><a href='#LRpower'><p>Power simulation for kinship LR</p></a></li>
<li><a href='#markerSim'><p>Marker simulation</p></a></li>
<li><a href='#markerSimParametric'><p>Simulate marker data given IBD coefficients</p></a></li>
<li><a href='#missingPersonEP'><p>Exclusion power for missing person cases</p></a></li>
<li><a href='#missingPersonIP'><p>Inclusion power for missing person cases</p></a></li>
<li><a href='#missingPersonLR'><p>Likelihood ratio calculation for missing person identification</p></a></li>
<li><a href='#missingPersonPlot'><p>Missing person plot</p></a></li>
<li><a href='#MPPsims'><p>Missing person power simulations</p></a></li>
<li><a href='#NorwegianFrequencies'><p>Norwegian STR frequencies</p></a></li>
<li><a href='#powerPlot'><p>Exclusion/inclusion power plots</p></a></li>
<li><a href='#profileSim'><p>Simulation of complete DNA profiles</p></a></li>
<li><a href='#profileSimParametric'><p>Simulate complete DNA profiles given IBD coefficients</p></a></li>
<li><a href='#quickLR'><p>LR calculations for paternity and sibship</p></a></li>
<li><a href='#randomPersonEP'><p>Random person exclusion power</p></a></li>
<li><a href='#showInTriangle'><p>Add points to the IBD triangle</p></a></li>
<li><a href='#simpleSim'><p>Unconditional marker simulation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Forensic Pedigree Analysis and Relatedness Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Forensic applications of pedigree analysis, including
    likelihood ratios for relationship testing, general relatedness
    inference, marker simulation, and power analysis. 'forrel' is part of
    the 'pedsuite', a collection of packages for pedigree analysis,
    further described in the book 'Pedigree Analysis in R' (Vigeland,
    2021, ISBN:9780128244302). Several functions deal specifically with
    power analysis in missing person cases, implementing methods described
    in Vigeland et al. (2020) &lt;<a href="https://doi.org/10.1016%2Fj.fsigen.2020.102376">doi:10.1016/j.fsigen.2020.102376</a>&gt;. Data
    import from the 'Familias' software (Egeland et al. (2000)
    &lt;<a href="https://doi.org/10.1016%2FS0379-0738%2800%2900147-X">doi:10.1016/S0379-0738(00)00147-X</a>&gt;) is supported through the
    'pedFamilias' package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/magnusdv/forrel">https://github.com/magnusdv/forrel</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/magnusdv/forrel/issues">https://github.com/magnusdv/forrel/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>pedtools (&ge; 2.6.0), R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>glue, pbapply, pedprobr (&ge; 0.8), ribd (&ge; 1.7.1), verbalisr
(&ge; 0.7.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, ggrepel, ibdsim2, plotly, poibin, scales, testthat</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-11 14:31:29 UTC; magnu</td>
</tr>
<tr>
<td>Author:</td>
<td>Magnus Dehli Vigeland
    <a href="https://orcid.org/0000-0002-9134-4962"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Thore Egeland [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Magnus Dehli Vigeland &lt;m.d.vigeland@medisin.uio.no&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-11 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='forrel-package'>forrel: Forensic Pedigree Analysis and Relatedness Inference</h2><span id='topic+forrel'></span><span id='topic+forrel-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Forensic applications of pedigree analysis, including likelihood ratios for relationship testing, general relatedness inference, marker simulation, and power analysis. 'forrel' is part of the 'pedsuite', a collection of packages for pedigree analysis, further described in the book 'Pedigree Analysis in R' (Vigeland, 2021, ISBN:9780128244302). Several functions deal specifically with power analysis in missing person cases, implementing methods described in Vigeland et al. (2020) <a href="https://doi.org/10.1016/j.fsigen.2020.102376">doi:10.1016/j.fsigen.2020.102376</a>. Data import from the 'Familias' software (Egeland et al. (2000) <a href="https://doi.org/10.1016/S0379-0738%2800%2900147-X">doi:10.1016/S0379-0738(00)00147-X</a>) is supported through the 'pedFamilias' package.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Magnus Dehli Vigeland <a href="mailto:m.d.vigeland@medisin.uio.no">m.d.vigeland@medisin.uio.no</a> (<a href="https://orcid.org/0000-0002-9134-4962">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Thore Egeland <a href="mailto:thore.egeland@nmbu.no">thore.egeland@nmbu.no</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/magnusdv/forrel">https://github.com/magnusdv/forrel</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/magnusdv/forrel/issues">https://github.com/magnusdv/forrel/issues</a>
</p>
</li></ul>


<hr>
<h2 id='checkPairwise'>Check pedigree data for relationship errors</h2><span id='topic+checkPairwise'></span><span id='topic+plotCP'></span>

<h3>Description</h3>

<p>The <code>checkPairwise()</code> function provides a convenient way to check for
pedigree errors, given the available marker data. The function calls
<code><a href="#topic+ibdEstimate">ibdEstimate()</a></code> to estimate IBD coefficients for all pairs of typed pedigree
members, and uses the estimates to test for potential errors. By default, the
results are shown in a colour-coded plot (based on <code><a href="ribd.html#topic+ibdTriangle">ribd::ibdTriangle()</a></code>)
where unlikely relationships are easy to spot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkPairwise(
  x,
  ids = typedMembers(x),
  includeInbred = FALSE,
  acrossComps = TRUE,
  plotType = c("base", "ggplot2", "plotly", "none"),
  GLRthreshold = 1000,
  pvalThreshold = NULL,
  nsim = 0,
  seed = NULL,
  plot = TRUE,
  verbose = TRUE,
  excludeInbred = NULL,
  ...
)

plotCP(
  cpRes = NULL,
  plotType = c("base", "ggplot2", "plotly"),
  labels = FALSE,
  errtxt = "Potential error",
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkPairwise_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of such.</p>
</td></tr>
<tr><td><code id="checkPairwise_+3A_ids">ids</code></td>
<td>
<p>A vector of ID labels; the individuals to include in the check.
Default: All typed members of <code>x</code>.</p>
</td></tr>
<tr><td><code id="checkPairwise_+3A_includeinbred">includeInbred</code></td>
<td>
<p>A logical, by default FALSE, indicating if inbred
individuals should be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="checkPairwise_+3A_acrosscomps">acrossComps</code></td>
<td>
<p>A logical indicating if pairs of individuals in different
components should be considered. Default: TRUE.</p>
</td></tr>
<tr><td><code id="checkPairwise_+3A_plottype">plotType</code></td>
<td>
<p>Either &quot;base&quot; (default), &quot;ggplot2&quot;, &quot;plotly&quot; or &quot;none&quot;.
Abbreviations are allowed.</p>
</td></tr>
<tr><td><code id="checkPairwise_+3A_glrthreshold">GLRthreshold</code></td>
<td>
<p>A positive number, by default 1000. Threshold for the
generalised likelihood ratio (see Details). Scores exceeding this are
flagged as potential errors in the output table and encircled in the plot.</p>
</td></tr>
<tr><td><code id="checkPairwise_+3A_pvalthreshold">pvalThreshold</code></td>
<td>
<p>A positive number, or NULL (default). If given, this is
used instead of <code>GLRthreshold</code> to identify potential errors. Ignored if
<code>nsim = 0</code>.</p>
</td></tr>
<tr><td><code id="checkPairwise_+3A_nsim">nsim</code></td>
<td>
<p>A nonnegative number; the number of simulations used to estimate
p-values. If 0 (default), this step is skipped.</p>
</td></tr>
<tr><td><code id="checkPairwise_+3A_seed">seed</code></td>
<td>
<p>An integer seed for the random number generator (optional, and
only relevant if <code>nsim &gt; 0</code>).</p>
</td></tr>
<tr><td><code id="checkPairwise_+3A_plot">plot</code></td>
<td>
<p>Deprecated. To suppress the triangle plot, use <code>plotType = "none"</code>.</p>
</td></tr>
<tr><td><code id="checkPairwise_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="checkPairwise_+3A_excludeinbred">excludeInbred</code></td>
<td>
<p>Deprecated; renamed to ´includeInbred´.</p>
</td></tr>
<tr><td><code id="checkPairwise_+3A_...">...</code></td>
<td>
<p>Further parameters passed on to <code><a href="ribd.html#topic+ibdTriangle">ribd::ibdTriangle()</a></code>.</p>
</td></tr>
<tr><td><code id="checkPairwise_+3A_cpres">cpRes</code></td>
<td>
<p>A data frame: the output from <code>checkPairwise()</code>.</p>
</td></tr>
<tr><td><code id="checkPairwise_+3A_labels">labels</code></td>
<td>
<p>A logical (default: FALSE). If TRUE, labels are included in the
IBD triangle plot.</p>
</td></tr>
<tr><td><code id="checkPairwise_+3A_errtxt">errtxt</code></td>
<td>
<p>A character string to use for the error legend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To identify potential pedigree errors, the function calculates the
<em>generalised likelihood ratio</em> (GLR) of each pairwise relationship.
This compares the likelihood of the estimated coefficients with that of the
coefficients implied by the pedigree. By default, relationships whose GLR
exceed 1000 are flagged as errors and shown with a circle in the plot.
Alternatively, if arguments <code>nsim</code> and <code>pvalThreshold</code> are supplied, the
p-value of each score is estimated by simulation, and used as threshold for
calling errors.
</p>
<p>By default, inbred individuals are excluded from the analysis, since pairwise
relationships involving inbred individuals have undefined kappa coefficients
(and therefore no position in the triangle). In some cases it may still be
informative to include their estimates; set <code>includeInbred = TRUE</code> to
enforce this.
</p>


<h3>Value</h3>

<p>If <code>plotType</code> is &quot;none&quot; or &quot;base&quot;: A data frame containing both the
estimated and pedigree-based IBD coefficients for each pair of typed
individuals. The last columns (<code>GLR</code>, <code>pval</code> and <code>err</code>) contain test
results using the GLR scores to identify potential pedigree errors.
</p>
<p>If <code>plotType</code> is &quot;ggplot2&quot; or &quot;plotly&quot;, the plot objects are returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ibdEstimate">ibdEstimate()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Example with realistic data

x = avuncularPed() |&gt;
  profileSim(markers = NorwegianFrequencies, seed = 1729)

checkPairwise(x)

### Create an error: sample swap 1 &lt;-&gt; 3
als = getAlleles(x)
als[c(1,3), ] = als[c(3,1), ]
y = setAlleles(x, alleles = als)

checkPairwise(y)

# Using p-values instead of GLR
nsim = 10 # increase!
checkPairwise(y, nsim = nsim, pvalThreshold = 0.05)

# Plot can be done separately
res = checkPairwise(y, nsim = nsim, pvalThreshold = 0.05, plotType = "none")
plotCP(res, plotType = "base", errtxt = "Not good!")


# Combined plot of pedigree and check results
dev.new(height = 5, width = 8, noRStudioGD = TRUE)
layout(rbind(1:2), widths = 2:3)
plot(y, margins = 2, title = "Swapped 1 - 3")
plotCP(res, labels = TRUE)


</code></pre>

<hr>
<h2 id='exclusionPower'>Power of exclusion</h2><span id='topic+exclusionPower'></span>

<h3>Description</h3>

<p>Computes the power (of a single marker, or for a collection of markers) of
excluding a claimed relationship, given the true relationship.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exclusionPower(
  claimPed,
  truePed,
  ids,
  markers = NULL,
  source = "claim",
  disableMutations = NA,
  exactMaxL = Inf,
  nsim = 1000,
  seed = NULL,
  alleles = NULL,
  afreq = NULL,
  knownGenotypes = NULL,
  Xchrom = FALSE,
  plot = FALSE,
  plotMarkers = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exclusionPower_+3A_claimped">claimPed</code></td>
<td>
<p>A <code>ped</code> object (or a list of such), describing the claimed
relationship. If a list, the sets of ID labels must be disjoint, that is,
all ID labels must be unique.</p>
</td></tr>
<tr><td><code id="exclusionPower_+3A_trueped">truePed</code></td>
<td>
<p>A <code>ped</code> object (or a list of such), describing the true
relationship. ID labels must be consistent with <code>claimPed</code>.</p>
</td></tr>
<tr><td><code id="exclusionPower_+3A_ids">ids</code></td>
<td>
<p>Individuals available for genotyping.</p>
</td></tr>
<tr><td><code id="exclusionPower_+3A_markers">markers</code></td>
<td>
<p>A vector indicating the names or indices of markers attached
to the source pedigree. If NULL (default), then all markers attached to the
source pedigree are used. If <code>alleles</code> or <code>afreq</code> is non-NULL, then this
parameter is ignored.</p>
</td></tr>
<tr><td><code id="exclusionPower_+3A_source">source</code></td>
<td>
<p>Either &quot;claim&quot; (default) or &quot;true&quot;, deciding which pedigree is
used as source for marker data.</p>
</td></tr>
<tr><td><code id="exclusionPower_+3A_disablemutations">disableMutations</code></td>
<td>
<p>This parameter determines how mutation models are
treated. Possible values are as follows:
</p>

<ul>
<li> <p><code>NA</code> (the default): Mutations are disabled only for those markers whose
known genotypes are compatible with both <code>claimPed</code> and <code>truePed</code>. This is
determined by temporarily removing all mutation models and checking which
markers have nonzero likelihood in both alternatives.
</p>
</li>
<li> <p><code>TRUE</code>: Mutations are disabled for all markers.
</p>
</li>
<li> <p><code>FALSE</code>: No action is done to disable mutations.
</p>
</li>
<li><p> A vector containing the names or indices of those markers for which
mutations should be disabled.
</p>
</li></ul>
</td></tr>
<tr><td><code id="exclusionPower_+3A_exactmaxl">exactMaxL</code></td>
<td>
<p>A positive integer, or <code>Inf</code> (default). Exact EPs are
calculated for markers whose number of alleles is less or equal to
<code>exactMaxL</code>; remaining markers are handled by simulation.</p>
</td></tr>
<tr><td><code id="exclusionPower_+3A_nsim">nsim</code></td>
<td>
<p>A positive integer; the number of simulations used for markers
whose number of alleles exceeds <code>exactMaxL</code>.</p>
</td></tr>
<tr><td><code id="exclusionPower_+3A_seed">seed</code></td>
<td>
<p>An integer seed for the random number generator (optional).</p>
</td></tr>
<tr><td><code id="exclusionPower_+3A_alleles">alleles</code>, <code id="exclusionPower_+3A_afreq">afreq</code>, <code id="exclusionPower_+3A_xchrom">Xchrom</code></td>
<td>
<p>If these are given, they are used (together with
<code>knownGenotypes</code>) to create a marker object on the fly.</p>
</td></tr>
<tr><td><code id="exclusionPower_+3A_knowngenotypes">knownGenotypes</code></td>
<td>
<p>A list of triplets <code style="white-space: pre;">&#8288;(a, b, c)&#8288;</code>, indicating that
individual <code>a</code> has genotype <code>b/c</code>. Ignored unless <code>alleles</code> or <code>afreq</code> is
non-NULL.</p>
</td></tr>
<tr><td><code id="exclusionPower_+3A_plot">plot</code></td>
<td>
<p>Either a logical or the character &quot;plotOnly&quot;. If the latter, a
plot is drawn, but no further computations are done.</p>
</td></tr>
<tr><td><code id="exclusionPower_+3A_plotmarkers">plotMarkers</code></td>
<td>
<p>A vector of marker names or indices whose genotypes are to
be included in the plot.</p>
</td></tr>
<tr><td><code id="exclusionPower_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the formula for exclusion power as defined and
discussed in (Egeland et al., 2014).
</p>
<p>It should be noted that <code>claimPed</code> and <code>truePed</code> may be any (lists of)
pedigrees, as long as they both contain the individuals specified by <code>ids</code>.
In particular, either alternative may have inbred founders (with the same or
different coefficients), but this must be set individually for each.
</p>


<h3>Value</h3>

<p>If <code>plot = "plotOnly"</code>, the function returns NULL after producing the
plot.
</p>
<p>Otherwise, the function returns an <code>EPresult</code> object, which is essentially
a list with the following entries:
</p>

<ul>
<li> <p><code>EPperMarker</code>: A numeric vector containing the exclusion power of each
marker. If the known genotypes of a marker are incompatible with the true
pedigree, the corresponding entry is <code>NA</code>.
</p>
</li>
<li> <p><code>EPtotal</code>: The total exclusion power, computed as <code>1 - prod(1 -   EPperMarker, na.rm = TRUE)</code>.
</p>
</li>
<li> <p><code>expectedMismatch</code>: The expected number of markers giving exclusion,
computed as <code>sum(EPperMarker, na.rm = TRUE)</code>.
</p>
</li>
<li> <p><code>distribMismatch</code>: The probability distribution of the number of markers
giving exclusion. This is given as a numeric vector of length <code>n+1</code>, where
<code>n</code> is the number of nonzero elements of <code>EPperMarker</code>. The vector has
names <code>0:n</code>.
</p>
</li>
<li> <p><code>time</code>: The total computation time.
</p>
</li>
<li> <p><code>params</code>: A list containing the (processed) parameters <code>ids</code>, <code>markers</code>
and <code>disableMutations</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Magnus Dehli Vigeland
</p>


<h3>References</h3>

<p>T. Egeland, N. Pinto and M.D. Vigeland, <em>A general approach to
power calculation for relationship testing.</em> Forensic Science
International: Genetics 9 (2014): 186-190.
<a href="https://doi.org/10.1016/j.fsigen.2013.05.001">doi:10.1016/j.fsigen.2013.05.001</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
############################################
### A standard case paternity case:
### Compute the power of exclusion when the claimed father is in fact
### unrelated to the child.
############################################

# Claim: 'AF' is the father of 'CH'
claim = nuclearPed(father = "AF", children = "CH")

# Attach two (empty) markers
claim = claim |&gt;
  addMarker(alleles = 1:2) |&gt;
  addMarker(alleles = 1:3)

# Truth: 'AF' and 'CH' are unrelated
true = singletons(c("AF", "CH"))

# EP when both are available for genotyping
exclusionPower(claim, true, ids = c("AF", "CH"))

# EP when the child is typed; homozygous 1/1 at both markers
claim2 = claim |&gt;
  setGenotype(marker = 1:2, id = "CH", geno = "1/1")

exclusionPower(claim2, true, ids = "AF")


############################################
### Two females claim to be mother and daughter, but are in reality sisters.
### We compute the power of various markers to reject the claim.
############################################

ids = c("A", "B")
claim = nuclearPed(father = "NN", mother = "A", children = "B", sex = 2)
true = nuclearPed(children = ids, sex = 2)

# SNP with MAF = 0.1:
PE1 = exclusionPower(claimPed = claim, truePed = true, ids = ids,
                     alleles = 1:2, afreq = c(0.9, 0.1))

stopifnot(round(PE1$EPtotal, 5) == 0.00405)

# Tetra-allelic marker with one major allele:
PE2 = exclusionPower(claimPed = claim, truePed = true, ids = ids,
                     alleles = 1:4, afreq = c(0.7, 0.1, 0.1, 0.1))

stopifnot(round(PE2$EPtotal, 5) == 0.03090)


### How does the power change if the true pedigree is inbred?
trueLOOP = halfSibPed(sex2 = 2) |&gt; addChildren(4, 5, ids = ids)

# SNP with MAF = 0.1:
PE3 = exclusionPower(claimPed = claim, truePed = trueLOOP, ids = ids,
                     alleles = 1:2, afreq = c(0.9, 0.1))

# Power almost doubled compared with PE1
stopifnot(round(PE3$EPtotal, 5) == 0.00765)

</code></pre>

<hr>
<h2 id='expectedLR'>Expected likelihood ratio</h2><span id='topic+expectedLR'></span>

<h3>Description</h3>

<p>This function computes the expected LR for a single marker, in a kinship test
comparing two hypothesised relationships between a set of individuals. The
true relationship may differ from both hypotheses. Some individuals may
already be genotyped, while others are available for typing. The
implementation uses <code>oneMarkerDistribution()</code> to find the joint genotype
distribution for the available individuals, conditional on the known data, in
each pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectedLR(numeratorPed, denominatorPed, truePed = numeratorPed, ids, marker)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expectedLR_+3A_numeratorped">numeratorPed</code></td>
<td>
<p>A <code>ped</code> object.</p>
</td></tr>
<tr><td><code id="expectedLR_+3A_denominatorped">denominatorPed</code></td>
<td>
<p>A <code>ped</code> object.</p>
</td></tr>
<tr><td><code id="expectedLR_+3A_trueped">truePed</code></td>
<td>
<p>A <code>ped</code> object.</p>
</td></tr>
<tr><td><code id="expectedLR_+3A_ids">ids</code></td>
<td>
<p>A vector of ID labels corresponding to untyped pedigree members.
(These must be members of all three input pedigrees).</p>
</td></tr>
<tr><td><code id="expectedLR_+3A_marker">marker</code></td>
<td>
<p>either a marker object compatible with <code>numeratorPed</code>, or the
name or index of a marker attached to <code>numeratorPed</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A positive number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#---------
# Curious example showing that ELR may decrease
# by typing additional reference individuals
#---------

# Numerator ped
numPed = nuclearPed(father = "fa", mother = "mo", child = "ch")

# Denominator ped: fa, mo, ch are unrelated. (Hack!)
denomPed = halfSibPed() |&gt; relabel(old = 1:3, new = c("mo", "fa", "ch"))

# Scenario 1: Only mother is typed; genotype 1/2
p = 0.9
m1 = marker(numPed, mo = "1/2", afreq = c("1" = p, "2" = 1-p))
expectedLR(numPed, denomPed, ids = "ch", marker = m1)

1/(8*p*(1-p)) + 1/2 # exact formula

# Scenario 2: Include father, with genotype 1/1
m2 = m1
genotype(m2, id = "fa") = "1/1"
expectedLR(numPed, denomPed, ids = "ch", marker = m2)

1/(8*p*(1-p)) + 1/(4*p^2) # exact formula

</code></pre>

<hr>
<h2 id='familias'>Import/export from Familias</h2><span id='topic+familias'></span><span id='topic+readFam'></span>

<h3>Description</h3>

<p>Functions for reading .fam files associated with the Familias
software for forensic kinship computations.
</p>
<p><em><strong>Deprecated</strong></em> These functions have been moved to a separate package,
<code>pedFamilias</code>, and will be removed from <code>forrel</code> in a future version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFam(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="familias_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the respective <code>pedFamilias</code> function.</p>
</td></tr>
</table>

<hr>
<h2 id='findExclusions'>Find markers excluding an identification</h2><span id='topic+findExclusions'></span>

<h3>Description</h3>

<p>Find markers for which the genotypes of a candidate individual is incompatible with a pedigree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findExclusions(x, id, candidate, removeMut = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findExclusions_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of such.</p>
</td></tr>
<tr><td><code id="findExclusions_+3A_id">id</code></td>
<td>
<p>A character of length 1; the name of an untyped member of <code>x</code>.</p>
</td></tr>
<tr><td><code id="findExclusions_+3A_candidate">candidate</code></td>
<td>
<p>A singleton pedigree, with genotypes for the same markers as <code>x</code>.</p>
</td></tr>
<tr><td><code id="findExclusions_+3A_removemut">removeMut</code></td>
<td>
<p>A logical. If TRUE (default), all mutations models are stripped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the names of incompatible markers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
db = NorwegianFrequencies[1:5]

# Pedigree with 3 siblings; simulate data for first two
x = nuclearPed(3) |&gt;
  profileSim(ids = 3:4, markers = db, seed = 1)

# Simulate random person
poi = singleton("POI") |&gt;
  profileSim(markers = db, seed = 1)

# Identify incompatible markers
findExclusions(x, id = 5, candidate = poi)   # D21S11

# Inspect
plotPedList(list(x, poi), marker = "D21S11", hatched = typedMembers)

</code></pre>

<hr>
<h2 id='FORCE'>FORCE panel kinship SNPs</h2><span id='topic+FORCE'></span>

<h3>Description</h3>

<p>A data frame describing (a subset of) the FORCE panel of SNPs designed for
applications in forensic genetics (Tillmar et al., 2021). The subset included
here are the SNPs recommended for kinship analysis. As the original
publication did not include allele frequencies, these were downloaded from
Ensembl via the biomaRt package. 15 markers were removed as frequency
information could not be retrieved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FORCE
</code></pre>


<h3>Format</h3>

<p>A data frame with 3915 rows and 6 columns:
</p>

<ul>
<li> <p><code>CHROM</code>: Chromosome (1-22)
</p>
</li>
<li> <p><code>MARKER</code>: Marker name (rs number)
</p>
</li>
<li> <p><code>MB</code>: Physical position in megabases (build GRCh38)
</p>
</li>
<li> <p><code>A1</code>: First allele
</p>
</li>
<li> <p><code>A2</code>: Second allele
</p>
</li>
<li> <p><code>FREQ1</code>: Allele frequency of <code>A1</code>
</p>
</li></ul>



<h3>Details</h3>

<p>To attach the FORCE markers to a pedigree, use <code><a href="pedtools.html#topic+setSNPs">pedtools::setSNPs()</a></code> (see
Examples).
</p>


<h3>Source</h3>

<p>Tillmar et al. The FORCE Panel: An All-in-One SNP Marker Set for
Confirming Investigative Genetic Genealogy Leads and for General Forensic
Applications. Genes. (2021)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = setSNPs(nuclearPed(), snpData = FORCE)
summary(x)

getMap(x, markers = 1:5)
getFreqDatabase(x, markers = 1:5)

</code></pre>

<hr>
<h2 id='ibdBootstrap'>Bootstrap estimation of IBD coefficients</h2><span id='topic+ibdBootstrap'></span>

<h3>Description</h3>

<p>This function produces (parametric or nonparametric) bootstrap estimates of
the IBD coefficients between two individuals; either the three <code class="reqn">\kappa</code>
-coefficients or the nine condensed identity coefficients <code class="reqn">\Delta</code> (see
<code><a href="#topic+ibdEstimate">ibdEstimate()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibdBootstrap(
  x = NULL,
  ids = NULL,
  param = NULL,
  kappa = NULL,
  delta = NULL,
  N,
  method = "parametric",
  freqList = NULL,
  plot = TRUE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ibdBootstrap_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object, or a list of such. If <code>method = "parametric"</code>, this
is only used to extract the allele frequencies, and can be skipped if
<code>freqList</code> is provided.</p>
</td></tr>
<tr><td><code id="ibdBootstrap_+3A_ids">ids</code></td>
<td>
<p>A pair of ID labels.</p>
</td></tr>
<tr><td><code id="ibdBootstrap_+3A_param">param</code></td>
<td>
<p>Either NULL (default), &quot;kappa&quot; or &quot;delta&quot;. (See below.)</p>
</td></tr>
<tr><td><code id="ibdBootstrap_+3A_kappa">kappa</code>, <code id="ibdBootstrap_+3A_delta">delta</code></td>
<td>
<p>Probability vectors of length 3 (kappa) or 9 (delta).
Exactly one of <code>param</code>, <code>kappa</code> and <code>delta</code> must be non-NULL. If <code>kappa</code>
and <code>delta</code> are both NULL, the appropriate set of coefficients is computed
as <code>ibdEstimate(x, ids, param)</code>.</p>
</td></tr>
<tr><td><code id="ibdBootstrap_+3A_n">N</code></td>
<td>
<p>The number of simulations.</p>
</td></tr>
<tr><td><code id="ibdBootstrap_+3A_method">method</code></td>
<td>
<p>Either &quot;parametric&quot; (default) or &quot;nonparametric&quot;. Abbreviations
are allowed. see Details for more information about each method.</p>
</td></tr>
<tr><td><code id="ibdBootstrap_+3A_freqlist">freqList</code></td>
<td>
<p>A list of probability vectors: The allele frequencies for
each marker.</p>
</td></tr>
<tr><td><code id="ibdBootstrap_+3A_plot">plot</code></td>
<td>
<p>A logical, only relevant for bootstraps of kappa. If TRUE, the
bootstrap estimates are plotted in the IBD triangle.</p>
</td></tr>
<tr><td><code id="ibdBootstrap_+3A_seed">seed</code></td>
<td>
<p>An integer seed for the random number generator (optional).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>method</code> controls how bootstrap estimates are obtained in each
replication:
</p>

<ul>
<li><p> &quot;parametric&quot;: new profiles for two individuals are simulated
from the input coefficients, followed by a re-estimation of the coefficients.
</p>
</li>
<li><p> &quot;nonparametric&quot;: the original markers are sampled with replacement, before
the coefficients are re-estimated.
</p>
</li></ul>

<p>Note that the pedigree itself does not affect the output of this function;
the role of <code>x</code> is simply to carry the marker data.
</p>


<h3>Value</h3>

<p>A data frame with <code>N</code> rows containing the bootstrap estimates. The
last column, <code>dist</code>, gives the Euclidean distance to the original
coefficients (either specified by the user or estimated from the data),
viewed as a point in R^3 (kappa) or R^9 (delta).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ibdEstimate">ibdEstimate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Frequency list of 15 standard STR markers
freqList = NorwegianFrequencies[1:15]

# Number of bootstrap simulations (increase!)
N = 5

# Bootstrap estimates for kappa of full siblings
boot1 = ibdBootstrap(kappa = c(0.25, .5, .25), N = N, freqList = freqList)
boot1

# Mean deviation
mean(boot1$dist)

# Same, but with the 9 identity coefficients.
delta = c(0, 0, 0, 0, 0, 0, .25, .5, .25)
boot2 = ibdBootstrap(delta = delta, N = N, freqList = freqList)

# Mean deviation
mean(boot2$dist)

#### Non-parametric bootstrap.
# Requires `x` and `ids` to be provided

x = nuclearPed(2)
x = markerSim(x, ids = 3:4, N = 50, alleles = 1:10, seed = 123)

bootNP = ibdBootstrap(x, ids = 3:4, param = "kappa", method = "non", N = N)

# Parametric bootstrap can also be done with this syntax
bootP = ibdBootstrap(x, ids = 3:4, param = "kappa", method = "par", N = N)

</code></pre>

<hr>
<h2 id='ibdEstimate'>Pairwise relatedness estimation</h2><span id='topic+ibdEstimate'></span>

<h3>Description</h3>

<p>Estimate the IBD coefficients <code class="reqn">\kappa = (\kappa_0, \kappa_1,
\kappa_2)</code> or the condensed identity coefficients <code class="reqn">\Delta =
(\Delta_1, ..., \Delta_9)</code> between a pair (or several pairs)
of pedigree members, using maximum likelihood methods. Estimates of
<code class="reqn">\kappa</code> may be visualised with <code><a href="#topic+showInTriangle">showInTriangle()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibdEstimate(
  x,
  ids = typedMembers(x),
  param = c("kappa", "delta"),
  acrossComps = TRUE,
  markers = NULL,
  start = NULL,
  tol = sqrt(.Machine$double.eps),
  beta = 0.5,
  sigma = 0.5,
  contourPlot = FALSE,
  levels = NULL,
  maxval = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ibdEstimate_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of such.</p>
</td></tr>
<tr><td><code id="ibdEstimate_+3A_ids">ids</code></td>
<td>
<p>Either a vector with ID labels, or a data frame/matrix with two
columns, each row indicating a pair of individuals. The entries are coerced
to characters, and must match uniquely against the ID labels of <code>x</code>. By
default, all pairs of genotyped members of <code>x</code> are included.</p>
</td></tr>
<tr><td><code id="ibdEstimate_+3A_param">param</code></td>
<td>
<p>Either &quot;kappa&quot; (default) or &quot;delta&quot;; indicating which set of
coefficients should be estimated.</p>
</td></tr>
<tr><td><code id="ibdEstimate_+3A_acrosscomps">acrossComps</code></td>
<td>
<p>A logical indicating if pairs of individuals in different
components should be included. Default: TRUE.</p>
</td></tr>
<tr><td><code id="ibdEstimate_+3A_markers">markers</code></td>
<td>
<p>A vector with names or indices of markers attached to x,
indicating which markers to include. By default, all markers are used.</p>
</td></tr>
<tr><td><code id="ibdEstimate_+3A_start">start</code></td>
<td>
<p>A probability vector (i.e., with nonnegative entries and sum 1)
of length 3 (if <code>param = "kappa"</code>) or 9 (if <code>param = "delta"</code>), indicating
the initial value of for the optimisation. By default, <code>start</code> is set to
<code style="white-space: pre;">&#8288;(1/3, 1/3, 1/3)&#8288;</code> if <code>param = "kappa"</code> and <code style="white-space: pre;">&#8288;(1/9, ..., 1/9)&#8288;</code> if <code>param = "delta"</code>.</p>
</td></tr>
<tr><td><code id="ibdEstimate_+3A_tol">tol</code>, <code id="ibdEstimate_+3A_beta">beta</code>, <code id="ibdEstimate_+3A_sigma">sigma</code></td>
<td>
<p>Control parameters for the optimisation routine; can
usually be left untouched.</p>
</td></tr>
<tr><td><code id="ibdEstimate_+3A_contourplot">contourPlot</code></td>
<td>
<p>A logical. If TRUE, contours of the log-likelihood
function are plotted overlaying the IBD triangle.</p>
</td></tr>
<tr><td><code id="ibdEstimate_+3A_levels">levels</code></td>
<td>
<p>(Only relevant if <code>contourPlot = TRUE</code>.) A numeric vector of
levels at which to draw contour lines. If NULL (default), the levels are
chosen automatically.</p>
</td></tr>
<tr><td><code id="ibdEstimate_+3A_maxval">maxval</code></td>
<td>
<p>A logical. If TRUE, the maximum log-likelihood value is
included in the output. Default: FALSE</p>
</td></tr>
<tr><td><code id="ibdEstimate_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It should be noted that this procedure estimates the <em>realised</em> identity
coefficients of each pair, i.e., the actual fractions of the autosomes in
each IBD state. These may deviate substantially from the theoretical pedigree
coefficients.
</p>
<p>Maximum likelihood estimation of relatedness coefficients originates with
Thompson (1975). Optimisation of <code class="reqn">\kappa</code> is done in the <code class="reqn">(\kappa_0,
\kappa_2)</code>-plane and restricted to the triangle defined by
</p>
<p style="text-align: center;"><code class="reqn">\kappa_0 \ge 0, \kappa_2 \ge 0, \kappa_0 + \kappa_2 \le 1</code>
</p>

<p>Optimisation of <code class="reqn">\Delta</code> is done in unit simplex of <code class="reqn">R^8</code>, using the
first 8 coefficients.
</p>
<p>The implementation optimises the log-likelihood using a projected gradient
descent algorithm, combined with a version of Armijo line search.
</p>
<p>When <code>param = "kappa"</code>, the output may be fed directly to <code><a href="#topic+showInTriangle">showInTriangle()</a></code>
for visualisation.
</p>


<h3>Value</h3>

<p>An object of class <code>ibdEst</code>, which is basically a data frame with
either 6 columns (if <code>param = "kappa"</code>) or 12 columns (if <code>param = "delta"</code>). The first three columns are <code>id1</code> (label of first individual),
<code>id2</code> (label of second individual) and <code>N</code> (the number of markers with no
missing alleles). The remaining columns contain the coefficient estimates.
If <code>maxval = T</code>, a column named <code>maxloglik</code> is added at the end.
</p>


<h3>Author(s)</h3>

<p>Magnus Dehli Vigeland
</p>


<h3>References</h3>


<ul>
<li><p> E. A. Thompson (1975). <em>The estimation of pairwise relationships.</em> Annals
of Human Genetics 39.
</p>
</li>
<li><p> E. A. Thompson (2000). <em>Statistical Inference from Genetic Data on
Pedigrees.</em> NSF-CBMS Regional Conference Series in Probability and
Statistics. Volume 6.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ibdBootstrap">ibdBootstrap()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Example 1: Siblings

# Create pedigree and simulate 100 markers
x = nuclearPed(2) |&gt; markerSim(N = 100, alleles = 1:4, seed = 123)
x

# Estimate kappa (expectation: (0.25, 0.5, 0.25)
k = ibdEstimate(x, ids = 3:4)
k

# Visualise estimate
showInTriangle(k, labels = TRUE)

# Contour plot of the log-likelihood function
ibdEstimate(x, ids = 3:4, contourPlot = TRUE)


### Example 2: Full sib mating
y = fullSibMating(1) |&gt;
  markerSim(ids = 5:6, N = 1000, alleles = 1:10, seed = 123)

# Estimate the condensed identity coefficients
ibdEstimate(y, param = "delta")

# Exact coefficient by `ribd`:
ribd::condensedIdentity(y, 5:6, simplify = FALSE)

</code></pre>

<hr>
<h2 id='ibdLoglik'>Pairwise IBD likelihood</h2><span id='topic+ibdLoglik'></span><span id='topic+ibdLoglikFUN'></span>

<h3>Description</h3>

<p>Given genotype data from two individuals, computes the log-likelihood of a
single set of IBD coefficients, either  <code>kappa</code> = <code class="reqn">(\kappa_0, \kappa_1,
\kappa_2)</code> or the Jacquard coefficients <code>delta</code> = <code class="reqn">(\Delta_1, ..., \Delta_9)</code>.
The <code>ibdLoglikFUN</code> version returns an efficient <em>function</em> for computing such
likelihoods, suitable for optimisations such as in <code><a href="#topic+ibdEstimate">ibdEstimate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibdLoglik(x = NULL, ids = NULL, kappa = NULL, delta = NULL)

ibdLoglikFUN(x, ids, input = c("kappa", "kappa02", "delta"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ibdLoglik_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of such.</p>
</td></tr>
<tr><td><code id="ibdLoglik_+3A_ids">ids</code></td>
<td>
<p>A vector of ID labels.</p>
</td></tr>
<tr><td><code id="ibdLoglik_+3A_kappa">kappa</code></td>
<td>
<p>A probability vector of length 3.</p>
</td></tr>
<tr><td><code id="ibdLoglik_+3A_delta">delta</code></td>
<td>
<p>A probability vector of length 9.</p>
</td></tr>
<tr><td><code id="ibdLoglik_+3A_input">input</code></td>
<td>
<p>Either &quot;kappa&quot;, &quot;kappa02&quot; or &quot;delta&quot;. See Value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ibdLoglik()</code> returns a single number; the total log-likelihood over
all markers included.
</p>
<p><code>ibdLoglikFUN()</code> returns a function for computing such log-likelihoods. The
function takes a single input vector <code>p</code>, whose interpretation depends on
the <code>input</code> parameter:
</p>

<ul>
<li><p> &quot;kappa&quot;: <code>p</code> is expected to be a set of kappa coefficients
<code class="reqn">(\kappa_0, \kappa_1, \kappa_2)</code>.
</p>
</li>
<li><p> &quot;kappa02&quot;: <code>p</code> should be a vector of length 2 containing the coefficients
<code class="reqn">\kappa_0</code> and <code class="reqn">\kappa_2</code>. This is sometimes a convenient shortcut
when working in the IBD triangle.
</p>
</li>
<li><p> &quot;delta&quot;: Expects <code>p</code> to be a set of condensed Jacquard coefficients
<code class="reqn">(\Delta_1, ..., \Delta_9)</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Siblings typed with 10 markers
x = nuclearPed(2) |&gt; markerSim(N = 10, alleles = 1:4)

# Calculate log-likelihood at a single point
k = c(0.25, 0.5, 0.25)
ibdLoglik(x, ids = 3:4, kappa = k)

# Or first get a function, and then apply it
llFun = ibdLoglikFUN(x, ids = 3:4, input = "kappa")
llFun(k)


</code></pre>

<hr>
<h2 id='kinshipLR'>Likelihood ratios for kinship testing</h2><span id='topic+kinshipLR'></span>

<h3>Description</h3>

<p>This function computes likelihood ratios (LRs) for a list of pedigrees. One
of the pedigrees (the last one, by default) is designated as 'reference', to
be used in the denominator in all LR calculations. To ensure that all
pedigrees use the same data set, one of the pedigrees may be chosen as
'source', from which data is transferred to all the other pedigrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kinshipLR(
  ...,
  ref = NULL,
  source = NULL,
  markers = NULL,
  linkageMap = NULL,
  keepMerlin = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kinshipLR_+3A_...">...</code></td>
<td>
<p>Pedigree alternatives. Each argument should be either a single
<code>ped</code> object or a list of such. The pedigrees may be named; otherwise they
are assigned names &quot;H1&quot;, &quot;H2&quot;, ... automatically.
</p>
<p>It is also possible to pass a single <code>list</code> containing all the pedigrees.</p>
</td></tr>
<tr><td><code id="kinshipLR_+3A_ref">ref</code></td>
<td>
<p>An index or name indicating which of the input pedigrees should be
used as &quot;reference pedigree&quot;, i.e., used in the denominator of each LR. If
NULL (the default), the last pedigree is used as reference.</p>
</td></tr>
<tr><td><code id="kinshipLR_+3A_source">source</code></td>
<td>
<p>An index or name designating one of the input pedigrees as
source for marker data. If given, marker data is transferred from this to
all the other pedigrees (replacing any existing markers). The default
action (<code>source = NULL</code>) is as follows: If all pedigree have attached
markers, no transfers are done. If exactly one of the pedigrees have
attached markers, these are transferred to the others. all other cases give
an error.</p>
</td></tr>
<tr><td><code id="kinshipLR_+3A_markers">markers</code></td>
<td>
<p>A vector of marker names or indices indicating which markers
should be included. If NULL (the default) all markers are used.</p>
</td></tr>
<tr><td><code id="kinshipLR_+3A_linkagemap">linkageMap</code></td>
<td>
<p>If this is non-NULL, the markers are interpreted as being
linked, and likelihoods will be computed by an external call to MERLIN.
</p>
<p>The supplied object should be either:
</p>

<ul>
<li><p> a data frame, whose first three columns must be (i) chromosome (ii)
marker name (iii) centiMorgan position, or
</p>
</li>
<li><p> a map object created with <code>ibdsim2::uniformMap()</code> or
<code>ibdsim2::loadMap()</code>. This will internally be applied to the attached
markers to produce a suitable data frame as above.
</p>
</li></ul>
</td></tr>
<tr><td><code id="kinshipLR_+3A_keepmerlin">keepMerlin</code></td>
<td>
<p>Either NULL (default) or the path to an existing folder. If
given, MERLIN files are stored here, typically for debugging purposes.</p>
</td></tr>
<tr><td><code id="kinshipLR_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, all markers are assumed to be unlinked. To accommodate linkage, a
genetic map may be supplied with the argument <code>linkageMap</code>. This requires the
software MERLIN to be installed.
</p>


<h3>Value</h3>

<p>A <code>LRresult</code> object, which is essentially a list with entries
</p>

<ul>
<li> <p><code>LRtotal</code> : A vector of length <code>L</code>, where <code>L</code> is the number of input
pedigrees. The i'th entry is the total LR (i.e., the product over all
markers) comparing pedigree <code>i</code> to the reference pedigree. The entry
corresponding to the reference will always be 1.
</p>
</li>
<li> <p><code>LRperMarker</code> : A numerical matrix, where the i'th column contains the
marker-wise LR values comparing pedigree <code>i</code> to the reference. The product
of all entries in a column should equal the corresponding entry in
<code>LRtotal</code>.
</p>
</li>
<li> <p><code>likelihoodsPerMarker</code> : A numerical matrix of the same dimensions as
<code>LRperMarker</code>, but where the entries are likelihood of each pedigree for
each marker.
</p>
</li>
<li> <p><code>time</code> : Elapsed time
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Magnus Dehli Vigeland and Thore Egeland
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LRpower">LRpower()</a></code>, <code><a href="pedprobr.html#topic+merlin">pedprobr::likelihoodMerlin()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Example 1: Full vs half sibs

# Simulate 5 markers for a pair of full sibs
ids = c("A", "B")
sibs = nuclearPed(children = ids)
sibs = simpleSim(sibs, N = 5, alleles = 1:4, ids = ids, seed = 123)

# Create two alternative hypotheses
halfsibs = relabel(halfSibPed(), old = 4:5, new = ids)
unrel = singletons(c("A", "B"))

# Compute LRs. By default, the last ped is used as reference
kinshipLR(sibs, halfsibs, unrel)

# Input pedigrees can be named, reflected in the output
kinshipLR(S = sibs, H = halfsibs, U = unrel)

# Select non-default reference (by index or name)
kinshipLR(S = sibs, H = halfsibs, U = unrel, ref = "H")

# Alternative syntax: List input
peds = list(S = sibs, H = halfsibs, U = unrel)
kinshipLR(peds, ref = "H", source = "S", verbose = TRUE)

# Detailed results
res = kinshipLR(peds)
res$LRperMarker
res$likelihoodsPerMarker


### Example 2: Separating grandparent/halfsib/uncle-nephew

# Requires ibdsim2 and MERLIN
if(requireNamespace("ibdsim2", quietly = TRUE) &amp;&amp; pedprobr::checkMerlin()) {

  # Load recombination map
  map = ibdsim2::loadMap("decode19", uniform = TRUE)   # unif for speed

  # Define pedigrees
  ids = c("A", "B")
  H = relabel(halfSibPed(),   old = c(4,5), new = ids)
  U = relabel(avuncularPed(), old = c(3,6), new = ids)
  G = relabel(linearPed(2),   old = c(1,5), new = ids)

  # Attach FORCE panel of SNPs to G
  G = setSNPs(G, FORCE[1:10, ])  # use all for better results

  # Simulate recombination pattern in G
  ibd = ibdsim2::ibdsim(G, N = 1, ids = ids, map = map)

  # Simulate genotypes conditional on pattern
  G = ibdsim2::profileSimIBD(G, ibdpattern = ibd)

  # Compute LR (genotypes are automatically transferred to H and U)
  kinshipLR(H, U, G, linkageMap = map)
}

</code></pre>

<hr>
<h2 id='LRpower'>Power simulation for kinship LR</h2><span id='topic+LRpower'></span>

<h3>Description</h3>

<p>This function uses simulations to estimate the likelihood ratio (LR)
distribution in a given kinship testing scenario. In the most general
setting, three pedigrees are involved: the two pedigrees being compared, and
the true relationship (which may differ from the other two). A subset of
individuals are available for genotyping. Some individuals may already be
genotyped; all simulations are then conditional on these.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LRpower(
  numeratorPed,
  denominatorPed,
  truePed = numeratorPed,
  ids,
  markers = NULL,
  source = "true",
  nsim = 1,
  threshold = NULL,
  disableMutations = NA,
  alleles = NULL,
  afreq = NULL,
  Xchrom = FALSE,
  knownGenotypes = NULL,
  plot = FALSE,
  plotMarkers = NULL,
  seed = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LRpower_+3A_numeratorped">numeratorPed</code>, <code id="LRpower_+3A_denominatorped">denominatorPed</code></td>
<td>
<p><code>ped</code> objects (or lists of such),
describing the two relationships under comparison.</p>
</td></tr>
<tr><td><code id="LRpower_+3A_trueped">truePed</code></td>
<td>
<p>A <code>ped</code> object (or a list of such), describing the true
relationship. By default equal to <code>numeratorPed</code>.</p>
</td></tr>
<tr><td><code id="LRpower_+3A_ids">ids</code></td>
<td>
<p>Individuals available for genotyping.</p>
</td></tr>
<tr><td><code id="LRpower_+3A_markers">markers</code></td>
<td>
<p>A vector indicating the names or indices of markers attached
to the source pedigree. If NULL (default), then all markers attached to the
source pedigree are used. If <code>alleles</code> or <code>afreq</code> is non-NULL, then this
parameter is ignored.</p>
</td></tr>
<tr><td><code id="LRpower_+3A_source">source</code></td>
<td>
<p>Either &quot;true&quot; (default), &quot;numerator&quot; or &quot;denominator&quot;,
indicating which pedigree is used as source for marker data.</p>
</td></tr>
<tr><td><code id="LRpower_+3A_nsim">nsim</code></td>
<td>
<p>A positive integer: the number of simulations.</p>
</td></tr>
<tr><td><code id="LRpower_+3A_threshold">threshold</code></td>
<td>
<p>A numeric vector with one or more positive numbers used as
LR thresholds.</p>
</td></tr>
<tr><td><code id="LRpower_+3A_disablemutations">disableMutations</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="LRpower_+3A_alleles">alleles</code>, <code id="LRpower_+3A_afreq">afreq</code>, <code id="LRpower_+3A_xchrom">Xchrom</code></td>
<td>
<p>If these are given, they are used (together with
<code>knownGenotypes</code>) to create a marker object on the fly.</p>
</td></tr>
<tr><td><code id="LRpower_+3A_knowngenotypes">knownGenotypes</code></td>
<td>
<p>A list of triplets <code style="white-space: pre;">&#8288;(a, b, c)&#8288;</code>, indicating that
individual <code>a</code> has genotype <code>b/c</code>. Ignored unless <code>alleles</code> or <code>afreq</code> is
non-NULL.</p>
</td></tr>
<tr><td><code id="LRpower_+3A_plot">plot</code></td>
<td>
<p>Either a logical or the character &quot;plotOnly&quot;. If the latter, a
plot is drawn, but no further computations are done.</p>
</td></tr>
<tr><td><code id="LRpower_+3A_plotmarkers">plotMarkers</code></td>
<td>
<p>A vector of marker names or indices whose genotypes are to
be included in the plot.</p>
</td></tr>
<tr><td><code id="LRpower_+3A_seed">seed</code></td>
<td>
<p>An integer seed for the random number generator (optional).</p>
</td></tr>
<tr><td><code id="LRpower_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>LRpowerResult</code> object, which is essentially a list with the
following entries:
</p>

<ul>
<li> <p><code>LRperSim</code>: A numeric vector of length <code>nsim</code> containing the total LR for
each simulation.
</p>
</li>
<li> <p><code>meanLRperMarker</code>: The mean LR per marker, over all simulations.
</p>
</li>
<li> <p><code>meanLR</code>: The mean total LR over all simulations.
</p>
</li>
<li> <p><code>meanLogLR</code>: The mean total <code>log10(LR)</code> over all simulations.
</p>
</li>
<li> <p><code>IP</code>: A named numeric of the same length as <code>threshold</code>. For each element
of <code>threshold</code>, the fraction of simulations resulting in a LR exceeding the
given number.
</p>
</li>
<li> <p><code>time</code>: The total computation time.
</p>
</li>
<li> <p><code>params</code>: A list containing the input parameters <code>missing</code>, <code>markers</code>,
<code>nsim</code>, <code>threshold</code> and <code>disableMutations</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Paternity LR of siblings
ids = c("A", "B")
truth = nuclearPed(children = ids)
claim = nuclearPed(fa = "A", mo = "NN", children = "B")
unrel = singletons(ids)

# Simulation parameters
nsim = 10   # increase!
thresh = 1

# Simulation 1:
als = 1:5
afr = runif(5)
afr = afr/sum(afr)

pow1 = LRpower(claim, unrel, truth, ids = ids, nsim = nsim,
               threshold = thresh, alleles = als, afreq = afr,
               seed = 123)
pow1

# Simulation 2: Same, but using an attached marker
truth = addMarker(truth, alleles = als, afreq = afr)

pow2 = LRpower(claim, unrel, truth, ids = ids, nsim = nsim,
               threshold = thresh, markers = 1, seed = 123)

stopifnot(identical(pow1$LRperSim, pow2$LRperSim))


# True pedigree has inbred founders
truth2 = setFounderInbreeding(truth, value = 0.5)

pow3 = LRpower(claim, unrel, truth2, ids = ids, nsim = nsim,
               threshold = thresh, markers = 1, seed = 123) # plot = TRUE
pow3


</code></pre>

<hr>
<h2 id='markerSim'>Marker simulation</h2><span id='topic+markerSim'></span>

<h3>Description</h3>

<p>Simulates marker genotypes conditional on the pedigree structure and known
genotypes. Note: This function simulates independent realisations at a single
locus. Equivalently, it can be thought of as independent simulations of
identical, unlinked markers. For simulations of a <em>set</em> of markers, see
<code><a href="#topic+profileSim">profileSim()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markerSim(
  x,
  N = 1,
  ids = NULL,
  alleles = NULL,
  afreq = NULL,
  mutmod = NULL,
  rate = NULL,
  partialmarker = NULL,
  loopBreakers = NULL,
  seed = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="markerSim_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of such.</p>
</td></tr>
<tr><td><code id="markerSim_+3A_n">N</code></td>
<td>
<p>A positive integer: the number of (independent) markers to be
simulated.</p>
</td></tr>
<tr><td><code id="markerSim_+3A_ids">ids</code></td>
<td>
<p>A vector containing ID labels of those pedigree members whose
genotypes should be simulated. By default, all individuals are included.</p>
</td></tr>
<tr><td><code id="markerSim_+3A_alleles">alleles</code></td>
<td>
<p>(Only if <code>partialmarker</code> is NULL.) A vector with allele
labels. If NULL, the following are tried in order:
</p>

<ul>
<li> <p><code>names(afreq)</code>
</p>
</li>
<li><p> &lsquo;seq_along(afreq)&rsquo;
</p>
</li>
<li> <p><code>1:2</code> (Fallback if both <code>alleles</code> and <code>afreq</code> are NULL.)
</p>
</li></ul>
</td></tr>
<tr><td><code id="markerSim_+3A_afreq">afreq</code></td>
<td>
<p>(Only if <code>partialmarker</code> is NULL.) A numeric vector with allele
frequencies, possibly named with allele labels.</p>
</td></tr>
<tr><td><code id="markerSim_+3A_mutmod">mutmod</code>, <code id="markerSim_+3A_rate">rate</code></td>
<td>
<p>Arguments specifying a mutation model, passed on to
<code><a href="pedtools.html#topic+marker">pedtools::marker()</a></code> (see there for explanations).</p>
</td></tr>
<tr><td><code id="markerSim_+3A_partialmarker">partialmarker</code></td>
<td>
<p>Either NULL (resulting in unconditional simulation), a
marker object (on which the simulation should be conditioned) or the name
(or index) of a marker attached to <code>x</code>.</p>
</td></tr>
<tr><td><code id="markerSim_+3A_loopbreakers">loopBreakers</code></td>
<td>
<p>A numeric containing IDs of individuals to be used as
loop breakers. Relevant only if the pedigree has loops, and only if
<code>partialmarker</code> is non-NULL. See <code><a href="pedtools.html#topic+inbreedingLoops">pedtools::breakLoops()</a></code>.</p>
</td></tr>
<tr><td><code id="markerSim_+3A_seed">seed</code></td>
<td>
<p>An integer seed for the random number generator (optional).</p>
</td></tr>
<tr><td><code id="markerSim_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implements (with various time savers) the algorithm used in SLINK of the
LINKAGE/FASTLINK suite. If <code>partialmarker</code> is NULL, genotypes are simulated
by simple gene dropping, using <code><a href="#topic+simpleSim">simpleSim()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>ped</code> object equal to <code>x</code> except its <code>MARKERS</code> entry, which
consists of the <code>N</code> simulated markers.
</p>


<h3>Author(s)</h3>

<p>Magnus Dehli Vigeland
</p>


<h3>References</h3>

<p>G. M. Lathrop, J.-M. Lalouel, C. Julier, and J. Ott, <em>Strategies
for Multilocus Analysis in Humans</em>, PNAS 81(1984), pp. 3443-3446.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profileSim">profileSim()</a></code>, <code><a href="#topic+simpleSim">simpleSim()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = nuclearPed(2)

# Unconditional simulation
markerSim(x, N = 2, alleles = 1:3)

# Conditional on one child being homozygous 1/1
x = addMarker(x, "3" = "1/1", alleles = 1:3)
markerSim(x, N = 2, partialmarker = 1)
markerSim(x, N = 1, ids = 4, partialmarker = 1, verbose = FALSE)

</code></pre>

<hr>
<h2 id='markerSimParametric'>Simulate marker data given IBD coefficients</h2><span id='topic+markerSimParametric'></span>

<h3>Description</h3>

<p>This function simulates genotypes for two individuals given their IBD
distribution, for N identical markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markerSimParametric(
  kappa = NULL,
  delta = NULL,
  states = NULL,
  N = 1,
  alleles = NULL,
  afreq = NULL,
  seed = NULL,
  returnValue = c("singletons", "alleles", "genotypes", "internal")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="markerSimParametric_+3A_kappa">kappa</code></td>
<td>
<p>A probability vector of length 3, giving a set of realised kappa
coefficients (between two noninbred individuals).</p>
</td></tr>
<tr><td><code id="markerSimParametric_+3A_delta">delta</code></td>
<td>
<p>A probability vector of length 9, giving a set of condensed
identity coefficients (Jacquard coefficients).</p>
</td></tr>
<tr><td><code id="markerSimParametric_+3A_states">states</code></td>
<td>
<p>An integer vector of length <code>N</code>, with entries in 1-9. Each
entry gives the identity state of the corresponding marker. (See details.)</p>
</td></tr>
<tr><td><code id="markerSimParametric_+3A_n">N</code></td>
<td>
<p>A positive integer: the number of independent markers to be
simulated.</p>
</td></tr>
<tr><td><code id="markerSimParametric_+3A_alleles">alleles</code></td>
<td>
<p>A vector with allele labels. If NULL, the following are tried
in order:
</p>

<ul>
<li> <p><code>names(afreq)</code>
</p>
</li>
<li><p> &lsquo;seq_along(afreq)&rsquo;
</p>
</li>
<li> <p><code>1:2</code> (fallback if both <code>alleles</code> and <code>afreq</code> are NULL)
</p>
</li></ul>
</td></tr>
<tr><td><code id="markerSimParametric_+3A_afreq">afreq</code></td>
<td>
<p>A numeric vector with allele frequencies, possibly named with
allele labels.</p>
</td></tr>
<tr><td><code id="markerSimParametric_+3A_seed">seed</code></td>
<td>
<p>An integer seed for the random number generator (optional).</p>
</td></tr>
<tr><td><code id="markerSimParametric_+3A_returnvalue">returnValue</code></td>
<td>
<p>Either &quot;singleton&quot; (default) or &quot;alleles&quot;. (see Value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exactly one of <code>kappa</code>, <code>delta</code> and <code>states</code> must be given; the other two
should remain NULL.
</p>
<p>If <code>states</code> is given, it explicitly determines the condensed identity state
at each marker. The states are described by integers 1-9, using the tradition
order introduced by Jacquard.
</p>
<p>If <code>kappa</code> is given, the states are generated by the command <code>states = sample(9:7, size = N, replace = TRUE, prob = kappa)</code>. (Note that identity
states 9, 8, 7 correspond to IBD status 0, 1, 2, respectively.)
</p>
<p>If <code>delta</code> is given, the states are generated by the command <code>states = sample(1:9, size = N, replace = TRUE, prob = delta)</code>.
</p>


<h3>Value</h3>

<p>The output depends on the value of the <code>returnValue</code> parameter:
</p>

<ul>
<li><p> &quot;singletons&quot;: a list of two singletons with the simulated marker data
attached.
</p>
</li>
<li><p> &quot;alleles&quot;: a list of four vectors of length <code>N</code>, named <code>a</code>, <code>b</code>, <code>c</code> and
<code>d</code>. These contain the simulated alleles, where a/b and c/d are the
genotypes of the to individuals.
</p>
</li>
<li><p> &quot;genotypes&quot;: a list of two vectors of length <code>N</code>, containing the
simulated genotypes. Identical to <code>paste(a, b, sep = "/")</code> and <code>paste(c, d,   sep = "/")</code>, where <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> are the vectors returned when
<code>returnValue == "alleles"</code>.
</p>
</li>
<li><p> &quot;internal&quot;: similar to &quot;alleles&quot;, but using the index integer of each
allele. (This option is mostly for internal use.)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># MZ twins
markerSimParametric(kappa = c(0,0,1), N = 5, alleles = 1:10)

# Equal distribution of states 1 and 2
markerSimParametric(delta = c(.5,.5,0,0,0,0,0,0,0), N = 5, alleles = 1:10)

# Force a specific sequence of states
markerSimParametric(states = c(1,2,7,8,9), N = 5, alleles = 1:10)

</code></pre>

<hr>
<h2 id='missingPersonEP'>Exclusion power for missing person cases</h2><span id='topic+missingPersonEP'></span>

<h3>Description</h3>

<p>This is a special case of <code><a href="#topic+exclusionPower">exclusionPower()</a></code> for use in missing person cases.
The function computes the probability that a random person is genetically
incompatible with the typed relatives of the missing person.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missingPersonEP(
  reference,
  missing,
  markers = NULL,
  disableMutations = NA,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="missingPersonEP_+3A_reference">reference</code></td>
<td>
<p>A <code>ped</code> object with attached markers.</p>
</td></tr>
<tr><td><code id="missingPersonEP_+3A_missing">missing</code></td>
<td>
<p>The ID label of the missing pedigree member.</p>
</td></tr>
<tr><td><code id="missingPersonEP_+3A_markers">markers</code></td>
<td>
<p>A vector indicating the names or indices of markers attached
to the source pedigree. If NULL (default), then all markers attached to the
source pedigree are used. If <code>alleles</code> or <code>afreq</code> is non-NULL, then this
parameter is ignored.</p>
</td></tr>
<tr><td><code id="missingPersonEP_+3A_disablemutations">disableMutations</code></td>
<td>
<p>This parameter determines how mutation models are
treated. Possible values are as follows:
</p>

<ul>
<li> <p><code>NA</code> (the default): Mutations are disabled only for those markers whose
known genotypes are consistent with the pedigree. This is determined by
temporarily removing all mutation models and checking which markers have
nonzero likelihood.
</p>
</li>
<li> <p><code>TRUE</code>: Mutations are disabled for all markers. This will result in an
error if any markers are inconsistent.
</p>
</li>
<li> <p><code>FALSE</code>: No action is done to disable mutations.
</p>
</li>
<li><p> A vector containing the names or indices of those markers for which
mutations should be disabled.
</p>
</li></ul>
</td></tr>
<tr><td><code id="missingPersonEP_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is identical to <code><a href="#topic+randomPersonEP">randomPersonEP()</a></code>, but with different argument
names. This makes it consistent with <code><a href="#topic+missingPersonIP">missingPersonIP()</a></code> and the other
'missing person' functions.
</p>


<h3>Value</h3>

<p>The <code>EPresult</code> object returned by <code><a href="#topic+exclusionPower">exclusionPower()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+randomPersonEP">randomPersonEP()</a></code>, <code><a href="#topic+exclusionPower">exclusionPower()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Four siblings; the fourth is missing
x = nuclearPed(4)

# Remaining sibs typed with 4 triallelic markers
x = markerSim(x, N = 4, ids = 3:5, alleles = 1:3, seed = 577, verbose = FALSE)

# Add marker with inconsistency in reference genotypes
# (by default this is ignored by `missingPersonEP()`)
x = addMarker(x, "3" = "1/1", "4" = "2/2", "5" = "3/3")

# Compute exclusion power statistics
missingPersonEP(x, missing = 6)

</code></pre>

<hr>
<h2 id='missingPersonIP'>Inclusion power for missing person cases</h2><span id='topic+missingPersonIP'></span>

<h3>Description</h3>

<p>This function simulates the LR distribution for the true missing person in a
reference family. The output contains both the total and marker-wise LR of
each simulation, as well as various summary statistics. If a specific LR
threshold is given, the <em>inclusion power</em> is computed as the probability that
LR exceeds the threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missingPersonIP(
  reference,
  missing,
  markers,
  nsim = 1,
  threshold = NULL,
  disableMutations = NA,
  seed = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="missingPersonIP_+3A_reference">reference</code></td>
<td>
<p>A <code>ped</code> object with attached markers.</p>
</td></tr>
<tr><td><code id="missingPersonIP_+3A_missing">missing</code></td>
<td>
<p>The ID label of the missing pedigree member.</p>
</td></tr>
<tr><td><code id="missingPersonIP_+3A_markers">markers</code></td>
<td>
<p>A vector indicating the names or indices of markers attached
to the source pedigree. If NULL (default), then all markers attached to the
source pedigree are used. If <code>alleles</code> or <code>afreq</code> is non-NULL, then this
parameter is ignored.</p>
</td></tr>
<tr><td><code id="missingPersonIP_+3A_nsim">nsim</code></td>
<td>
<p>A positive integer: the number of simulations</p>
</td></tr>
<tr><td><code id="missingPersonIP_+3A_threshold">threshold</code></td>
<td>
<p>A numeric vector with one or more positive numbers used as
the likelihood ratio thresholds for inclusion</p>
</td></tr>
<tr><td><code id="missingPersonIP_+3A_disablemutations">disableMutations</code></td>
<td>
<p>This parameter determines how mutation models are
treated. Possible values are as follows:
</p>

<ul>
<li> <p><code>NA</code> (the default): Mutations are disabled only for those markers whose
known genotypes are consistent with the pedigree. This is determined by
temporarily removing all mutation models and checking which markers have
nonzero likelihood.
</p>
</li>
<li> <p><code>TRUE</code>: Mutations are disabled for all markers. This will result in an
error if any markers are inconsistent.
</p>
</li>
<li> <p><code>FALSE</code>: No action is done to disable mutations.
</p>
</li>
<li><p> A vector containing the names or indices of those markers for which
mutations should be disabled.
</p>
</li></ul>
</td></tr>
<tr><td><code id="missingPersonIP_+3A_seed">seed</code></td>
<td>
<p>An integer seed for the random number generator (optional).</p>
</td></tr>
<tr><td><code id="missingPersonIP_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mpIP</code> object, which is essentially a list with the following
entries:
</p>

<ul>
<li> <p><code>LRperSim</code>: A numeric vector of length <code>nsim</code> containing the total LR for
each simulation.
</p>
</li>
<li> <p><code>meanLRperMarker</code>: The mean LR per marker, over all simulations.
</p>
</li>
<li> <p><code>meanLR</code>: The mean total LR over all simulations.
</p>
</li>
<li> <p><code>meanLogLR</code>: The mean total <code>log10(LR)</code> over all simulations.
</p>
</li>
<li> <p><code>IP</code>: A named numeric of the same length as <code>threshold</code>. For each element
of <code>threshold</code>, the fraction of simulations resulting in a LR exceeding the
given number.
</p>
</li>
<li> <p><code>time</code>: The total computation time.
</p>
</li>
<li> <p><code>params</code>: A list containing the input parameters <code>missing</code>, <code>markers</code>,
<code>nsim</code>, <code>threshold</code> and <code>disableMutations</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Four siblings; the fourth is missing
x = nuclearPed(4)

# Remaining sibs typed with 5 triallelic markers
x = markerSim(x, N = 5, ids = 3:5, alleles = 1:3, seed = 123, verbose = FALSE)

# Compute inclusion power statistics
ip = missingPersonIP(x, missing = 6, nsim = 5, threshold = c(10, 100))
ip

# LRs from each simulation
ip$LRperSim

</code></pre>

<hr>
<h2 id='missingPersonLR'>Likelihood ratio calculation for missing person identification</h2><span id='topic+missingPersonLR'></span>

<h3>Description</h3>

<p>This is a wrapper function for <code><a href="#topic+kinshipLR">kinshipLR()</a></code> for the special case of missing
person identification. A person of interest (POI) is matched against a
reference dataset containing genotypes of relatives of the missing person.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missingPersonLR(reference, missing, poi = NULL, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="missingPersonLR_+3A_reference">reference</code></td>
<td>
<p>A <code>ped</code> object with attached markers.</p>
</td></tr>
<tr><td><code id="missingPersonLR_+3A_missing">missing</code></td>
<td>
<p>The ID label of the missing member of <code>reference</code>.</p>
</td></tr>
<tr><td><code id="missingPersonLR_+3A_poi">poi</code></td>
<td>
<p>A <code>singleton</code> object, or NULL. If NULL, and <code>missing</code> is
genotyped, this data is extracted and used as <code>poi</code>.</p>
</td></tr>
<tr><td><code id="missingPersonLR_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="missingPersonLR_+3A_...">...</code></td>
<td>
<p>Optional parameters to be passed on to <code><a href="#topic+kinshipLR">kinshipLR()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function accepts two forms of input:
</p>

<ol>
<li><p> With <code>poi</code> a typed singleton. This is the typical use case, when you want
to compute the LR for some person of interest.
</p>
</li>
<li><p> With <code>poi = NULL</code>, but <code>missing</code> being genotyped. The data for <code>missing</code>
is then extracted as a singleton POI. This is especially useful in simulation
procedures, e.g., for simulating the LR distribution of the true missing
person.
</p>
</li></ol>

<p>See Examples for illustrations of both cases.
</p>


<h3>Value</h3>

<p>The <code>LRresult</code> object returned by <code><a href="#topic+kinshipLR">kinshipLR()</a></code>, but without the
trivial <code>H2:H2</code> comparison.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#------------------------------------------------
# Example: Identification of a missing grandchild
#------------------------------------------------

# Database with 5 STR markers (increase to make more realistic)
db = NorwegianFrequencies[1:5]

# Pedigree with missing person (MP); grandmother is genotyped
x = linearPed(2) |&gt;
  relabel(old = 5, new = "MP") |&gt;
  profileSim(markers = db, ids = "2", seed = 123)


### Scenario 1: Unrelated POI --------------------

# Generate random unrelated profile
poi = singleton("POI") |&gt;
  profileSim(markers = db, seed = 1234)

# Compute LR
lr = missingPersonLR(x, missing = "MP", poi = poi)
lr
lr$LRperMarker


### Scenario 2: POI is the missing person --------
# A small simulation example

# Simulate profiles for MP conditional on the grandmother
N = 10
y = profileSim(x, N = N, ids = "MP", seed = 12345)

# Compute LRs for each sim
LRsims = lapply(y, missingPersonLR, missing = "MP", verbose = FALSE)

# Plot distribution
LRtotal = sapply(LRsims, function(a) a$LRtotal)
plot(density(LRtotal))

# LRs for each marker
LRperMarker = sapply(LRsims, function(a) a$LRperMarker)
LRperMarker

# Overlaying marker-wise density plots (requires tidyverse)
# library(tidyverse)
# t(LRperMarker) |&gt; as_tibble() |&gt; pivot_longer(everything()) |&gt;
#   ggplot() + geom_density(aes(value, fill = name), alpha = 0.6)

</code></pre>

<hr>
<h2 id='missingPersonPlot'>Missing person plot</h2><span id='topic+missingPersonPlot'></span>

<h3>Description</h3>

<p>Visualises the competing hypotheses of a family reunion case. A plot with two
panels is generated. The left panel shows a pedigree in which the <em>person of
interest</em> (POI) is identical to the <em>missing person</em> (MP). The right panel
shows the situation where these two are unrelated. See Details for further
explanations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missingPersonPlot(
  reference,
  missing,
  labs = labels(reference),
  marker = NULL,
  hatched = typedMembers(reference),
  MP.label = "MP",
  POI.label = "POI",
  MP.col = "#FF9999",
  POI.col = "lightgreen",
  POI.sex = getSex(reference, missing),
  POI.hatched = NULL,
  titles = c(expression(H[1] * ": POI = MP"), expression(H[2] * ": POI unrelated")),
  width = NULL,
  cex = 1.2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="missingPersonPlot_+3A_reference">reference</code></td>
<td>
<p>A <code><a href="pedtools.html#topic+ped">pedtools::ped()</a></code> object.</p>
</td></tr>
<tr><td><code id="missingPersonPlot_+3A_missing">missing</code></td>
<td>
<p>The ID label of the missing pedigree member.</p>
</td></tr>
<tr><td><code id="missingPersonPlot_+3A_labs">labs</code></td>
<td>
<p>A character vector with labels for the pedigree members. See
<code><a href="pedtools.html#topic+plot.ped">pedtools::plot.ped()</a></code>.</p>
</td></tr>
<tr><td><code id="missingPersonPlot_+3A_marker">marker</code></td>
<td>
<p>Optional vector of marker indices to be included in the plot.</p>
</td></tr>
<tr><td><code id="missingPersonPlot_+3A_hatched">hatched</code></td>
<td>
<p>A vector of ID labels indicating who should appear with
hatched symbols in the plot. By default, all typed members.</p>
</td></tr>
<tr><td><code id="missingPersonPlot_+3A_mp.label">MP.label</code>, <code id="missingPersonPlot_+3A_poi.label">POI.label</code></td>
<td>
<p>Custom labels of the missing person and the POI.
Default: &quot;MP&quot; and &quot;POI&quot;.</p>
</td></tr>
<tr><td><code id="missingPersonPlot_+3A_mp.col">MP.col</code>, <code id="missingPersonPlot_+3A_poi.col">POI.col</code></td>
<td>
<p>Fill colours for MP and POI.</p>
</td></tr>
<tr><td><code id="missingPersonPlot_+3A_poi.sex">POI.sex</code></td>
<td>
<p>The sex of POI. This defaults to that of the missing person,
but may be set explicitly. This is particularly useful when the missing
person has unknown sex.</p>
</td></tr>
<tr><td><code id="missingPersonPlot_+3A_poi.hatched">POI.hatched</code></td>
<td>
<p>Deprecated (ignored).</p>
</td></tr>
<tr><td><code id="missingPersonPlot_+3A_titles">titles</code></td>
<td>
<p>A character of length 2, with subtitles for the two frames.</p>
</td></tr>
<tr><td><code id="missingPersonPlot_+3A_width">width</code></td>
<td>
<p>A positive number controlling the width of the plot. More
specifically this number is the relative width of the reference pedigree,
compared to a singleton.</p>
</td></tr>
<tr><td><code id="missingPersonPlot_+3A_cex">cex</code></td>
<td>
<p>Expansion factor for pedigree symbols and font size.</p>
</td></tr>
<tr><td><code id="missingPersonPlot_+3A_...">...</code></td>
<td>
<p>Extra parameters passed on to <code><a href="pedtools.html#topic+plotPedList">pedtools::plotPedList()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A standard family reunification case involves the following ingredients:
</p>

<ul>
<li><p> A reference family with a single missing person (&quot;MP&quot;).
</p>
</li>
<li><p> Some of the family members have been genotyped
</p>
</li>
<li><p> A person of interest (&quot;POI&quot;) is to be matched against the reference family
</p>
</li></ul>

<p>After genotyping of POI, the genetic evidence is typically assessed by
computing the likelihood ratio of the following hypotheses:
</p>

<ul>
<li><p> H1: POI is MP
</p>
</li>
<li><p> H2: POI is unrelated to the family
</p>
</li></ul>

<p>The goal of this function is to illustrate the above hypotheses, using
labels, colours and shading to visualise the different aspects of the
situation.
</p>
<p>This function cannot handle cases with more complicated hypotheses (e.g.
multiple missing persons, or where H2 specifies a different relationship).
However, as it is basically a wrapper of <code><a href="pedtools.html#topic+plotPedList">pedtools::plotPedList()</a></code>, an
interested user should be able to extend the source code to such cases
without too much trouble.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = nuclearPed(father = "fa", mother = "mo", children = c("b1", "b2"))

# Default plot
missingPersonPlot(x, missing = "b2")

# Open in separate window; explore various options
missingPersonPlot(x,
                  missing = "b2",
                  hatched = "b1",
                  deceased = c("fa", "mo"),
                  cex = 1.5,      # larger symbols and labels (see ?par())
                  cex.main = 1.3, # larger frame titles (see ?par())
                  dev.width = 7,  # device width (see ?plotPedList())
                  dev.height = 3  # device height (see ?plotPedList())
                  )

</code></pre>

<hr>
<h2 id='MPPsims'>Missing person power simulations</h2><span id='topic+MPPsims'></span>

<h3>Description</h3>

<p>Estimate the exclusion/inclusion power for various selections of available
individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MPPsims(
  reference,
  missing = "MP",
  selections,
  ep = TRUE,
  ip = TRUE,
  addBaseline = TRUE,
  nProfiles = 1,
  lrSims = 1,
  thresholdIP = NULL,
  disableMutations = NA,
  numCores = 1,
  seed = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MPPsims_+3A_reference">reference</code></td>
<td>
<p>A connected <code>ped</code> object, or a list of pedigrees. In the
latter case, the list must have the same length as <code>selections</code>.</p>
</td></tr>
<tr><td><code id="MPPsims_+3A_missing">missing</code></td>
<td>
<p>The ID label of the missing pedigree member.</p>
</td></tr>
<tr><td><code id="MPPsims_+3A_selections">selections</code></td>
<td>
<p>A list of pedigree member subsets. In the special case that
all subsets consist of a single individual, <code>selections</code> can be given as a
simple vector.</p>
</td></tr>
<tr><td><code id="MPPsims_+3A_ep">ep</code></td>
<td>
<p>A logical: Estimate the exclusion power? (Default: TRUE)</p>
</td></tr>
<tr><td><code id="MPPsims_+3A_ip">ip</code></td>
<td>
<p>A logical: Estimate the inclusion power? (Default: TRUE)</p>
</td></tr>
<tr><td><code id="MPPsims_+3A_addbaseline">addBaseline</code></td>
<td>
<p>A logical. If TRUE (default) an <em>empty</em> selection, named
&quot;Baseline&quot;, is added as the first element of <code>selection</code>.</p>
</td></tr>
<tr><td><code id="MPPsims_+3A_nprofiles">nProfiles</code></td>
<td>
<p>The number of profile simulations for each selection.</p>
</td></tr>
<tr><td><code id="MPPsims_+3A_lrsims">lrSims</code>, <code id="MPPsims_+3A_thresholdip">thresholdIP</code></td>
<td>
<p>Parameters passed onto <code><a href="#topic+missingPersonIP">missingPersonIP()</a></code>.</p>
</td></tr>
<tr><td><code id="MPPsims_+3A_disablemutations">disableMutations</code></td>
<td>
<p>This parameter determines how mutation models are
treated. Possible values are as follows:
</p>

<ul>
<li> <p><code>NA</code> (the default): Mutations are disabled only for those markers whose
known genotypes are consistent with the pedigree. This is determined by
temporarily removing all mutation models and checking which markers have
nonzero likelihood.
</p>
</li>
<li> <p><code>TRUE</code>: Mutations are disabled for all markers. This will result in an
error if any markers are inconsistent.
</p>
</li>
<li> <p><code>FALSE</code>: No action is done to disable mutations.
</p>
</li>
<li><p> A vector containing the names or indices of those markers for which
mutations should be disabled.
</p>
</li></ul>
</td></tr>
<tr><td><code id="MPPsims_+3A_numcores">numCores</code></td>
<td>
<p>The number of cores used for parallelisation, by default 1.</p>
</td></tr>
<tr><td><code id="MPPsims_+3A_seed">seed</code></td>
<td>
<p>An integer seed for the random number generator (optional).</p>
</td></tr>
<tr><td><code id="MPPsims_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;MPPsim&quot;, which is basically a list with one entry
for each element of <code>selections</code>. Each entry has elements <code>ep</code> and <code>ip</code>,
each of which is a list of length <code>nProfiles</code>.
</p>
<p>The output object has various attributes reflecting the input. Note that
<code>reference</code> and <code>selection</code> may differ slightly from the original input,
since they may be modified during the function run. (For instance, a
&quot;Baseline&quot; entry is added to <code>selection</code> if <code>addBaseline</code> is TRUE.) The
crucial point is that the output attributes correspond exactly to the
output data.
</p>

<ul>
<li> <p><code>reference</code> (always a list, of the same length as the <code>selections</code>
attribute
</p>
</li>
<li> <p><code>selections</code>
</p>
</li>
<li> <p><code>nProfiles</code>,<code>lrSims</code>,<code>thresholdIP</code>,<code>seed</code> (as in the input)
</p>
</li>
<li> <p><code>totalTime</code> (the total time used)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x = nuclearPed(fa = "Gf", mo = "Gm", children = c("Uncle", "Mother"), sex = 1:2)
x = addChildren(x, fa = "Father", mo = "Mother", nch = 3, sex = c(1,2,1),
                id = c("S1", "S2", "MP"))
x = addSon(x, "Father", id = "HS")

# Brother S1 is already genotyped with a marker with 4 alleles
x = addMarker(x, S1 = "1/2", alleles = 1:4)

# Alternatives for additional genotyping
sel = list("Father", "S2", "HS", c("Gm", "Uncle"))

plot(x, marker = 1, hatched = sel)

# Simulate
simData = MPPsims(x, selections = sel, nProfiles = 2, lrSims = 2)

# Power plot
powerPlot(simData, type = 3)


### With  mutations
# Add inconsistent marker
x = addMarker(x, S1 = "1/2", Father = "3/3", alleles = 1:4)

# Set mutation models for both
mutmod(x, 1:2) = list("equal", rate = 0.1)

# By default mutations are disabled for consistent markers
MPPsims(x, selections = "Father", addBaseline = FALSE)

# Don't disable anything
MPPsims(x, selections = "Father", addBaseline = FALSE,
        disableMutations = FALSE)


# Disable all mutation models. SHOULD GIVE ERROR FOR SECOND MARKER
# MPPsims(x, selections = "Father", addBaseline = FALSE,
#         disableMutations = TRUE)



</code></pre>

<hr>
<h2 id='NorwegianFrequencies'>Norwegian STR frequencies</h2><span id='topic+NorwegianFrequencies'></span>

<h3>Description</h3>

<p>A database of Norwegian allele frequencies for 35 STR markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NorwegianFrequencies
</code></pre>


<h3>Format</h3>

<p>A list of length 35. Each entry is a numerical vector summing to 1,
named with allele labels.
</p>
<p>The following markers are included:
</p>

<ul>
<li> <p><code>D3S1358</code>: 12 alleles
</p>
</li>
<li> <p><code>TH01</code>: 10 alleles
</p>
</li>
<li> <p><code>D21S11</code>: 26 alleles
</p>
</li>
<li> <p><code>D18S51 </code>: 23 alleles
</p>
</li>
<li> <p><code>PENTA_E</code>: 21 alleles
</p>
</li>
<li> <p><code>D5S818</code>: 9 alleles
</p>
</li>
<li> <p><code>D13S317</code>: 9 alleles
</p>
</li>
<li> <p><code>D7S820</code>: 19 alleles
</p>
</li>
<li> <p><code>D16S539</code>: 9 alleles
</p>
</li>
<li> <p><code>CSF1PO</code>: 11 alleles
</p>
</li>
<li> <p><code>PENTA_D</code>: 24 alleles
</p>
</li>
<li> <p><code>VWA</code>: 12 alleles
</p>
</li>
<li> <p><code>D8S1179</code>: 12 alleles
</p>
</li>
<li> <p><code>TPOX</code>: 9 alleles
</p>
</li>
<li> <p><code>FGA</code>: 25 alleles
</p>
</li>
<li> <p><code>D19S433</code>: 17 alleles
</p>
</li>
<li> <p><code>D2S1338</code>: 13 alleles
</p>
</li>
<li> <p><code>D10S1248</code>: 9 alleles
</p>
</li>
<li> <p><code>D1S1656</code>: 17 alleles
</p>
</li>
<li> <p><code>D22S1045</code>: 9 alleles
</p>
</li>
<li> <p><code>D2S441</code>: 13 alleles
</p>
</li>
<li> <p><code>D12S391</code>: 23 alleles
</p>
</li>
<li> <p><code>SE33</code>: 55 alleles
</p>
</li>
<li> <p><code>D7S1517</code>: 11 alleles
</p>
</li>
<li> <p><code>D3S1744</code>: 8 alleles
</p>
</li>
<li> <p><code>D2S1360</code>: 10 alleles
</p>
</li>
<li> <p><code>D6S474</code>: 6 alleles
</p>
</li>
<li> <p><code>D4S2366</code>: 7 alleles
</p>
</li>
<li> <p><code>D8S1132</code>: 12 alleles
</p>
</li>
<li> <p><code>D5S2500</code>: 8 alleles
</p>
</li>
<li> <p><code>D21S2055</code>: 18 alleles
</p>
</li>
<li> <p><code>D10S2325</code>: 10 alleles
</p>
</li>
<li> <p><code>D17S906</code>: 78 alleles
</p>
</li>
<li> <p><code>APOAI1</code>: 41 alleles
</p>
</li>
<li> <p><code>D11S554</code>: 51 alleles
</p>
</li></ul>



<h3>Source</h3>

<p>Dupuy et al. (2013): <em>Frequency data for 35 autosomal STR markers in
a Norwegian, an East African, an East Asian and Middle Asian population and
simulation of adequate database size</em>. Forensic Science International:
Genetics Supplement Series, Volume 4 (1).
</p>

<hr>
<h2 id='powerPlot'>Exclusion/inclusion power plots</h2><span id='topic+powerPlot'></span>

<h3>Description</h3>

<p>This function offers four different visualisations of exclusion/inclusion
powers, particularly for missing person cases. Output from <code><a href="#topic+MPPsims">MPPsims()</a></code> may be
fed directly as input to this function. The actual plotting is done with
<code>ggplot2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerPlot(
  ep,
  ip = NULL,
  type = 1,
  majorpoints = TRUE,
  minorpoints = TRUE,
  ellipse = FALSE,
  col = NULL,
  labs = NULL,
  jitter = FALSE,
  alpha = 1,
  stroke = 1.5,
  shape = "circle",
  size = 1,
  hline = NULL,
  vline = NULL,
  xlim = NULL,
  ylim = NULL,
  xlab = NULL,
  ylab = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="powerPlot_+3A_ep">ep</code>, <code id="powerPlot_+3A_ip">ip</code></td>
<td>
<p>Lists of equal length, with outputs from one or more runs of
<code><a href="#topic+missingPersonEP">missingPersonEP()</a></code> and <code><a href="#topic+missingPersonIP">missingPersonIP()</a></code> respectively. Alternatively,
<code>ep</code> can be a single output from <code><a href="#topic+MPPsims">MPPsims()</a></code>, in which case <code>ip</code> should be
NULL. See Examples.</p>
</td></tr>
<tr><td><code id="powerPlot_+3A_type">type</code></td>
<td>
<p>Plot type; either 1, 2, 3 or 4.</p>
</td></tr>
<tr><td><code id="powerPlot_+3A_majorpoints">majorpoints</code></td>
<td>
<p>A logical indicating whether &quot;major&quot; points should be
drawn (see Details).</p>
</td></tr>
<tr><td><code id="powerPlot_+3A_minorpoints">minorpoints</code></td>
<td>
<p>A logical indicating whether &quot;minor&quot; points should be
drawn (see Details).</p>
</td></tr>
<tr><td><code id="powerPlot_+3A_ellipse">ellipse</code></td>
<td>
<p>A logical. If TRUE, data ellipsis are drawn for each group
containing more than 1 element. NB: This fails with a warning if all points
in a group fall on a line.</p>
</td></tr>
<tr><td><code id="powerPlot_+3A_col">col</code></td>
<td>
<p>A colour vector, recycle to match the top level length of <code>ep</code>.</p>
</td></tr>
<tr><td><code id="powerPlot_+3A_labs">labs</code></td>
<td>
<p>A character of the same length as <code>ep</code>. If NULL, the names of
<code>ep</code> are used, if present.</p>
</td></tr>
<tr><td><code id="powerPlot_+3A_jitter">jitter</code></td>
<td>
<p>A logical (default: FALSE). If TRUE, a small jitter is added to
the major points.</p>
</td></tr>
<tr><td><code id="powerPlot_+3A_alpha">alpha</code></td>
<td>
<p>Transparency for minor points (see Details).</p>
</td></tr>
<tr><td><code id="powerPlot_+3A_stroke">stroke</code></td>
<td>
<p>Border width for major points (see Details).</p>
</td></tr>
<tr><td><code id="powerPlot_+3A_shape">shape</code></td>
<td>
<p>Either &quot;circle&quot;, &quot;square&quot;, &quot;diamond&quot;, &quot;triangleUp&quot; or
&quot;triangleDown&quot;, determining the shapes of both minor and major points.</p>
</td></tr>
<tr><td><code id="powerPlot_+3A_size">size</code></td>
<td>
<p>Point size.</p>
</td></tr>
<tr><td><code id="powerPlot_+3A_hline">hline</code>, <code id="powerPlot_+3A_vline">vline</code></td>
<td>
<p>Single numbers indicating positions for
horizontal/vertical &quot;threshold&quot; lines. If NULL (default), no lines are
drawn.</p>
</td></tr>
<tr><td><code id="powerPlot_+3A_xlim">xlim</code>, <code id="powerPlot_+3A_ylim">ylim</code></td>
<td>
<p>Axis limits; automatically chosen if NULL.</p>
</td></tr>
<tr><td><code id="powerPlot_+3A_xlab">xlab</code>, <code id="powerPlot_+3A_ylab">ylab</code></td>
<td>
<p>Axis labels; automatically chosen if NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot types are as follows:
</p>
<p><code>type = 1</code>: x = Exclusion power; y = Inclusion power
</p>
<p><code>type = 2</code>: x = Exclusion odds ratio; y = Inclusion odds ratio
</p>
<p><code>type = 3</code>: x = Expected number of exclusions; y = average log(LR)
</p>
<p><code>type = 4</code>: x = Exclusion power; y = average LR
</p>
<p>In the most general case <code>ep</code> (and similarly for <code>ip</code>) can be a list of lists
of <code>EPresult</code> objects. We refer to the inner lists as &quot;groups&quot;. A group may
consist of a single output, or several (typically many simulations of the
same situation). Points within the same group are always drawn with the same
colour and shape.
</p>
<p>When plotting several groups, two sets of points are drawn by default:
</p>

<ul>
<li><p> Major points: Group means.
</p>
</li>
<li><p> Minor points: Individual points in groups with more than one element.
</p>
</li></ul>

<p>The parameters <code>majorpoints</code> and <code>minorpoints</code> control which of the above
points are included.
</p>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MPPsims">MPPsims()</a></code>, <code><a href="#topic+missingPersonEP">missingPersonEP()</a></code>, <code><a href="#topic+missingPersonEP">missingPersonEP()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Example 1: Comparing the power of 3 reference families ###

# Frequencies for 2 STR markers
db = NorwegianFrequencies[1:2]  # Increase!

# Define pedigrees and simulate data
PAR = nuclearPed(1, child = "MP") |&gt;
  profileSim(markers = db, ids = 1)
SIB = nuclearPed(2) |&gt; relabel(old = 4, new = "MP") |&gt;
  profileSim(markers = db, ids = 3)
GRA = linearPed(2) |&gt; relabel(old = 5, new = "MP") |&gt;
  profileSim(markers = db, ids = 1)

# Collect in list and plot
peds = list(PAR = PAR, SIB = SIB, GRA = GRA)
plotPedList(peds, marker = 1, hatched = typedMembers, frames = FALSE,
            col = list(red = "MP"))

# Compute exclusion/inclusion powers:
ep = lapply(peds, function(y)
  missingPersonEP(y, missing = "MP", verbose = FALSE))

ip = lapply(peds, function(y)    # increase nsim!
  missingPersonIP(y, missing = "MP", nsim = 5, threshold = 10, verbose = FALSE))

# Plot
powerPlot(ep, ip, size = 2)

# Different plot type, not dependent of `threshold`
powerPlot(ep, ip, size = 2, type = 3)



### Example 2: Exploring powers for different sets of available relatives

# Create trio pedigree
ref = nuclearPed(father = "fa", mother = "mo", child = "MP")

# Add empty marker with 5 alleles
ref = addMarker(ref, alleles = 1:5)

# Alternatives for genotyping
sel = list("fa", c("fa", "mo"))

# Simulate power for each selection
simData = MPPsims(ref, selections = sel, nProfiles = 3, lrSims = 5,
                  thresholdIP = 2, seed = 123, numCores = 1)

# Power plot 1: EP vs IP
powerPlot(simData, type = 1)
powerPlot(simData, type = 1, minorpoints = FALSE, hline = 0.8)




# Change shape, and modify legend order
powerPlot(simData[3:1], type = 1, shape = c("ci", "sq", "di"))

# Zoom in, and add threshold lines
powerPlot(simData, type = 1, xlim = c(0.2, 1), ylim = c(0.5, 1),
          hline = 0.8, vline = 0.8)

# Power plot 3: Expected number of exclusions vs E[log LR]
powerPlot(simData, type = 3)

# With horizontal/vertical lines
powerPlot(simData, type = 3, hline = log10(2), vline = 1)

# Plot 4: Illustrating the general inequality ELR &gt; 1/(1-EP)
powerPlot(simData, type = 4)



</code></pre>

<hr>
<h2 id='profileSim'>Simulation of complete DNA profiles</h2><span id='topic+profileSim'></span>

<h3>Description</h3>

<p>Simulation of DNA profiles for specified pedigree members. Some pedigree
members may already be genotyped; in that case the simulation is conditional
on these. The main work of this function is done by <code><a href="#topic+markerSim">markerSim()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profileSim(
  x,
  N = 1,
  ids = NULL,
  markers = NULL,
  seed = NULL,
  numCores = 1,
  simplify1 = TRUE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="profileSim_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of such.</p>
</td></tr>
<tr><td><code id="profileSim_+3A_n">N</code></td>
<td>
<p>The number of complete simulations to be performed.</p>
</td></tr>
<tr><td><code id="profileSim_+3A_ids">ids</code></td>
<td>
<p>A character (or coercible to character) with ID labels indicating
whose genotypes should be simulated.</p>
</td></tr>
<tr><td><code id="profileSim_+3A_markers">markers</code></td>
<td>
<p>Either a vector indicating a subset of markers attached to
<code>x</code>, or a named list of frequency vectors. By default (<code>NULL</code>), all
attached markers are used. If a frequency list is given, marker objects are
created and attached to <code>x</code>. Simulations are conditional on the locus
attributes (allele frequencies, mutation models, etc) and any existing
genotypes in the indicated markers.</p>
</td></tr>
<tr><td><code id="profileSim_+3A_seed">seed</code></td>
<td>
<p>An integer seed for the random number generator (optional).</p>
</td></tr>
<tr><td><code id="profileSim_+3A_numcores">numCores</code></td>
<td>
<p>The number of cores to be used. The default is 1, i.e., no
parallelisation.</p>
</td></tr>
<tr><td><code id="profileSim_+3A_simplify1">simplify1</code></td>
<td>
<p>A logical, by default TRUE, removing the outer list layer
when <code>N = 1</code>. See Value.</p>
</td></tr>
<tr><td><code id="profileSim_+3A_verbose">verbose</code></td>
<td>
<p>A logical, by default TRUE.</p>
</td></tr>
<tr><td><code id="profileSim_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code><a href="#topic+markerSim">markerSim()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>N</code> objects similar to <code>x</code>, but with simulated genotypes.
Any previously attached markers are replaced by the simulated profiles. If
the indicated markers contained genotypes for some pedigree members, these
are still present in the simulated profiles.
</p>
<p>If <code>N = 1</code> and <code>simplify1 = TRUE</code>, the outer list layer is removed, i.e.,
<code>profileSim(..., N = 1, simplify1 = T)</code> is equivalent to <code>profileSim(..., N = 1, simplify1 = F)[[1]]</code>. This is usually the desired object in
interactive use, and works well with piping.
</p>
<p>When using <code>profileSim()</code> in other functions, it is recommended to add
<code>simplify1 = FALSE</code> to safeguard against issues with <code>N = 1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example pedigree with two brothers
x = nuclearPed(children = c("B1", "B2"))

### Simulate profiles using built-in freq database
profileSim(x, markers = NorwegianFrequencies[1:3])

### Conditioning on known genotypes for one brother

# Attach two SNP markers with genotypes for B1
y = x |&gt;
  addMarker(B1 = "1/2", alleles = 1:2) |&gt;
  addMarker(B1 = "1",   alleles = 1:2, chrom = "X")

# Simulate 2 profiles of B2 conditional on the above
profileSim(y, N = 2, ids = "B2", seed = 123)



</code></pre>

<hr>
<h2 id='profileSimParametric'>Simulate complete DNA profiles given IBD coefficients</h2><span id='topic+profileSimParametric'></span>

<h3>Description</h3>

<p>This function generalises <code><a href="#topic+markerSimParametric">markerSimParametric()</a></code> in the same way that
<code><a href="#topic+profileSim">profileSim()</a></code> generalises <code><a href="#topic+markerSim">markerSim()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profileSimParametric(
  kappa = NULL,
  delta = NULL,
  states = NULL,
  N = 1,
  freqList = NULL,
  seed = NULL,
  returnValue = c("singletons", "alleles", "genotypes", "internal")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="profileSimParametric_+3A_kappa">kappa</code></td>
<td>
<p>A probability vector of length 3, giving a set of realised kappa
coefficients (between two noninbred individuals).</p>
</td></tr>
<tr><td><code id="profileSimParametric_+3A_delta">delta</code></td>
<td>
<p>A probability vector of length 9, giving a set of condensed
identity coefficients (Jacquard coefficients).</p>
</td></tr>
<tr><td><code id="profileSimParametric_+3A_states">states</code></td>
<td>
<p>An integer vector of length <code>N</code>, with entries in 1-9. Each
entry gives the identity state of the corresponding marker. (See details.)</p>
</td></tr>
<tr><td><code id="profileSimParametric_+3A_n">N</code></td>
<td>
<p>A positive integer: the number of complete profiles to be simulated</p>
</td></tr>
<tr><td><code id="profileSimParametric_+3A_freqlist">freqList</code></td>
<td>
<p>A list of numeric vectors. Each vector is the allele
frequencies of a marker.</p>
</td></tr>
<tr><td><code id="profileSimParametric_+3A_seed">seed</code></td>
<td>
<p>An integer seed for the random number generator (optional).</p>
</td></tr>
<tr><td><code id="profileSimParametric_+3A_returnvalue">returnValue</code></td>
<td>
<p>Either &quot;singleton&quot; (default) or &quot;alleles&quot;. (see Value).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length <code>N</code>, whose entries are determined by <code>returnValue</code>,
as explained in <code><a href="#topic+markerSimParametric">markerSimParametric()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A single profile with 9 markers, each with forced identity state
profileSimParametric(states = 1:9, freqList = NorwegianFrequencies[1:9])

</code></pre>

<hr>
<h2 id='quickLR'>LR calculations for paternity and sibship</h2><span id='topic+quickLR'></span>

<h3>Description</h3>

<p>A thin wrapper around <code><a href="#topic+kinshipLR">kinshipLR()</a></code> for the common scenario of testing a pair
of individuals for paternity and/or sibship, against being unrelated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quickLR(x, ids = typedMembers(x), test = c("pat", "sib", "half"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quickLR_+3A_x">x</code></td>
<td>
<p>A ped object or a list of such.</p>
</td></tr>
<tr><td><code id="quickLR_+3A_ids">ids</code></td>
<td>
<p>A vector of two typed members of <code>x</code>. If not given, the typed
members of <code>x</code> are selected by default, but note that this gives an error
if the number of such individuals is not 2.</p>
</td></tr>
<tr><td><code id="quickLR_+3A_test">test</code></td>
<td>
<p>The hypotheses to be tested (against 'unrelatedness'). Allowed
values are &quot;pat&quot; (=paternity), &quot;sib&quot; (=full siblings), and &quot;half&quot; (=half
siblings). By default, all three are included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (slightly simplified) <code>LRresult</code> object, as described in
<code><a href="#topic+kinshipLR">kinshipLR()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate 100 markers for half siblings
x = halfSibPed() |&gt; markerSim(N = 100, ids = 4:5, alleles = 1:3, seed = 1)

# Test paternity, full sib, half sib
quickLR(x)

</code></pre>

<hr>
<h2 id='randomPersonEP'>Random person exclusion power</h2><span id='topic+randomPersonEP'></span>

<h3>Description</h3>

<p>This is a special case of <code><a href="#topic+exclusionPower">exclusionPower()</a></code>, computing the power to exclude
a random person as a given pedigree member. More specifically, the function
computes the probability of observing, in an individual unrelated to the
family individual, a genotype incompatible with the typed family members.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomPersonEP(x, id, markers = NULL, disableMutations = NA, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomPersonEP_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object with attached markers.</p>
</td></tr>
<tr><td><code id="randomPersonEP_+3A_id">id</code></td>
<td>
<p>The ID label of a single pedigree member.</p>
</td></tr>
<tr><td><code id="randomPersonEP_+3A_markers">markers</code></td>
<td>
<p>A vector indicating the names or indices of markers attached
to the source pedigree. If NULL (default), then all markers attached to the
source pedigree are used. If <code>alleles</code> or <code>afreq</code> is non-NULL, then this
parameter is ignored.</p>
</td></tr>
<tr><td><code id="randomPersonEP_+3A_disablemutations">disableMutations</code></td>
<td>
<p>This parameter determines how mutation models are
treated. Possible values are as follows:
</p>

<ul>
<li> <p><code>NA</code> (the default): Mutations are disabled only for those markers whose
known genotypes are consistent with the pedigree. This is determined by
temporarily removing all mutation models and checking which markers have
nonzero likelihood.
</p>
</li>
<li> <p><code>TRUE</code>: Mutations are disabled for all markers. This will result in an
error if any markers are inconsistent.
</p>
</li>
<li> <p><code>FALSE</code>: No action is done to disable mutations.
</p>
</li>
<li><p> A vector containing the names or indices of those markers for which
mutations should be disabled.
</p>
</li></ul>
</td></tr>
<tr><td><code id="randomPersonEP_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>EPresult</code> object returned by <code><a href="#topic+exclusionPower">exclusionPower()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Four siblings:
x = nuclearPed(4)

# First 3 sibs typed with 4 triallelic markers
x = markerSim(x, N = 4, ids = 3:5, alleles = 1:3, seed = 577, verbose = FALSE)

# Probability that a random man is excluded as the fourth sibling
randomPersonEP(x, id = 6)

</code></pre>

<hr>
<h2 id='showInTriangle'>Add points to the IBD triangle</h2><span id='topic+showInTriangle'></span>

<h3>Description</h3>

<p>This function is re-exported from the <code>ribd</code> package. For documentation see
<code><a href="ribd.html#topic+showInTriangle">ribd::showInTriangle()</a></code>.
</p>

<hr>
<h2 id='simpleSim'>Unconditional marker simulation</h2><span id='topic+simpleSim'></span>

<h3>Description</h3>

<p>Unconditional simulation of unlinked markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpleSim(
  x,
  N,
  alleles,
  afreq,
  ids,
  Xchrom = FALSE,
  mutmod = NULL,
  seed = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simpleSim_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object.</p>
</td></tr>
<tr><td><code id="simpleSim_+3A_n">N</code></td>
<td>
<p>A positive integer: the number of markers to be simulated.</p>
</td></tr>
<tr><td><code id="simpleSim_+3A_alleles">alleles</code></td>
<td>
<p>A vector with allele labels.</p>
</td></tr>
<tr><td><code id="simpleSim_+3A_afreq">afreq</code></td>
<td>
<p>A numeric vector of allele frequencies. If missing, the alleles
are assumed to be equifrequent.</p>
</td></tr>
<tr><td><code id="simpleSim_+3A_ids">ids</code></td>
<td>
<p>A vector containing ID labels of those pedigree members whose
genotypes should be simulated.</p>
</td></tr>
<tr><td><code id="simpleSim_+3A_xchrom">Xchrom</code></td>
<td>
<p>A logical: X linked markers or not?</p>
</td></tr>
<tr><td><code id="simpleSim_+3A_mutmod">mutmod</code></td>
<td>
<p>A list of mutation matrices named 'female' and 'male'.</p>
</td></tr>
<tr><td><code id="simpleSim_+3A_seed">seed</code></td>
<td>
<p>An integer seed for the random number generator (optional).</p>
</td></tr>
<tr><td><code id="simpleSim_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple genotype simulation, performed by first distributing alleles randomly
to all founders, followed by Mendelian <em>gene dropping</em> down throughout the
pedigree (i.e., for each non-founder a random allele is selected from each of
the parents). Finally, genotypes of individuals not included in <code>ids</code> are
removed.
</p>


<h3>Value</h3>

<p>A <code>ped</code> object equal to <code>x</code> except its <code>MARKERS</code> entry, which
consists of the <code>N</code> simulated markers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markerSim">markerSim()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = nuclearPed(1)
simpleSim(x, N = 3, afreq = c(0.5, 0.5))

y = cousinPed(1, child = TRUE)
simpleSim(y, N = 3, alleles = LETTERS[1:10])

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
