<!DOCTYPE html><html><head><title>Help for package gdistance</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gdistance}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gdistance'><p>Distances and Routes on Geographical Grids</p></a></li>
<li><a href='#accCost'><p>Accumulated Cost Surface</p></a></li>
<li><a href='#adjacencyFromTransition'><p>Adjacent cells</p></a></li>
<li><a href='#ArithMath-methods'><p>Arithmetic and mathematical operations with objects of Transition* classes</p></a></li>
<li><a href='#commuteDistance'><p>Commute-time distance</p></a></li>
<li><a href='#Coords class'><p>Coords class</p></a></li>
<li><a href='#costDistance'><p>Cost distance</p></a></li>
<li><a href='#genDist'><p>Genetic distances and coordinates of haplogroup R1b1b2 populations in Europe</p></a></li>
<li><a href='#geoCorrection'><p>Geographic Correction</p></a></li>
<li><a href='#normalize'><p>Normalize</p></a></li>
<li><a href='#overlap'><p>Overlap and nonoverlap of trajectories</p></a></li>
<li><a href='#passage'><p>Probability of passage</p></a></li>
<li><a href='#pathInc'><p>Incidence of paths from a common origin: overlap and non-overlap</p></a></li>
<li><a href='#raster,TransitionLayer-method'><p>RasterLayer from TransitionLayer object</p></a></li>
<li><a href='#rSPDistance'><p>Randomized shortest path distance</p></a></li>
<li><a href='#shortestPath'><p>Shortest path</p></a></li>
<li><a href='#Summary-methods'><p>Summary methods</p></a></li>
<li><a href='#sumReciprocal'><p>Reciprocal of the sum of the reciprocals of conductance values in Transition* objects</p></a></li>
<li><a href='#transition'><p>Create an object of the class Transition</p></a></li>
<li><a href='#Transition-classes'><p>Transition classes</p></a></li>
<li><a href='#Transition-extract-replace'><p>Extracting and replacing: class Transition</p></a></li>
<li><a href='#Transition-slots'><p>Extract or change elements of Transition* objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Distances and Routes on Geographical Grids</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.4</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://AgrDataSci.github.io/gdistance/">https://AgrDataSci.github.io/gdistance/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/AgrDataSci/gdistance/issues">https://github.com/AgrDataSci/gdistance/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provides classes and functions to calculate various 
             distance measures and routes in heterogeneous geographic 
             spaces represented as grids. The package implements measures
             to model dispersal histories first presented by van Etten and
             Hijmans (2010) &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0012060">doi:10.1371/journal.pone.0012060</a>&gt;. Least-cost
             distances as well as more complex distances based on (constrained)
             random walks can be calculated. The distances implemented in 
             the package are used in geographical genetics, accessibility 
             indicators, and may also have applications in other fields of
             geospatial analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0), raster (&ge; 1.9-19), methods, igraph (&ge; 0.7.0),
Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>sp, stats, terra</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown, rmarkdown, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-19 20:47:27 UTC; andrewjmarx</td>
</tr>
<tr>
<td>Author:</td>
<td>Jacob van Etten <a href="https://orcid.org/0000-0001-7554-2558"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Kauê de Sousa <a href="https://orcid.org/0000-0002-7571-7845"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Andrew Marx <a href="https://orcid.org/0000-0002-7456-1631"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre,
    ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrew Marx &lt;ajm.rpackages@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-19 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='gdistance'>Distances and Routes on Geographical Grids</h2><span id='topic+gdistance'></span><span id='topic+gdistance-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Provides classes and functions to calculate various distance measures and routes in heterogeneous geographic spaces represented as grids. The package implements measures to model dispersal histories first presented by van Etten and Hijmans (2010) <a href="https://doi.org/10.1371/journal.pone.0012060">doi:10.1371/journal.pone.0012060</a>. Least-cost distances as well as more complex distances based on (constrained) random walks can be calculated. The distances implemented in the package are used in geographical genetics, accessibility indicators, and may also have applications in other fields of geospatial analysis.
</p>


<h3>Author(s)</h3>

<p>Jacob van Etten and Kauê de Sousa
</p>


<h3>See Also</h3>

<p><strong>Useful links:</strong>
</p>

<ul>
<li><p>Package's paper:
<a href="https://doi.org/10.18637/jss.v076.i13">doi:10.18637/jss.v076.i13</a>
</p>
</li>
<li><p>Development repository:
<a href="https://github.com/AgrDataSci/gdistance">https://github.com/AgrDataSci/gdistance</a>
</p>
</li>
<li><p>Static documentation:
<a href="https://github.com/AgrDataSci/gdistance">https://github.com/AgrDataSci/gdistance</a>
</p>
</li>
<li><p>Report bugs:
<a href="https://github.com/AgrDataSci/gdistance/issues">https://github.com/AgrDataSci/gdistance/issues</a>
</p>
</li></ul>


<hr>
<h2 id='accCost'>Accumulated Cost Surface</h2><span id='topic+accCost'></span><span id='topic+accCost+2CTransitionLayer+2CRasterLayer-method'></span><span id='topic+accCost+2CTransitionLayer+2CCoords-method'></span>

<h3>Description</h3>

<p>Calculates the accumulated cost surface from one or
more origins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accCost(x, fromCoords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accCost_+3A_x">x</code></td>
<td>
<p>object of class <code>TransitionLayer</code></p>
</td></tr>
<tr><td><code id="accCost_+3A_fromcoords">fromCoords</code></td>
<td>
<p>origin point locations (SpatialPoints, matrix
or numeric class)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If more than one coordinate is supplied in fromCoords,
the function calculates the minimum least-cost distance
from any origin point.
</p>
<p>The function uses Dijkstra's algorithm
(as implemented in the igraph package).
</p>


<h3>Value</h3>

<p>a RasterLayer object
</p>


<h3>Author(s)</h3>

<p>Jacob van Etten
</p>


<h3>References</h3>

<p>E.W. Dijkstra. 1959. A note on two problems
in connexion with graphs. <em>Numerische Mathematik</em> 1, 269 - 271.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geoCorrection">geoCorrection</a></code>,
<code><a href="#topic+costDistance">costDistance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("raster")
# example equivalent to that in the documentation on r.cost in GRASS
r &lt;- raster(nrows=6, ncols=7,
            xmn=0, xmx=7,
            ymn=0, ymx=6,
            crs="+proj=utm +units=m")

r[] &lt;- c(2, 2, 1, 1, 5, 5, 5,
         2, 2, 8, 8, 5, 2, 1,
         7, 1, 1, 8, 2, 2, 2,
         8, 7, 8, 8, 8, 8, 5,
         8, 8, 1, 1, 5, 3, 9,
         8, 1, 1, 2, 5, 3, 9)

# 1/mean: reciprocal to get permeability
tr &lt;- transition(r, function(x) 1/mean(x), 8)
tr &lt;- geoCorrection(tr)

c1 &lt;- c(5.5,1.5)
c2 &lt;- c(1.5,5.5)

A &lt;- accCost(tr, c1)
plot(A)
text(A)
</code></pre>

<hr>
<h2 id='adjacencyFromTransition'>Adjacent cells</h2><span id='topic+adjacencyFromTransition'></span>

<h3>Description</h3>

<p>Identify pairs of cells that are adjacent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjacencyFromTransition(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacencyFromTransition_+3A_x">x</code></td>
<td>
<p>TransitionLayer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extracts the indices of those cells that are connected
(e.g. cells i,j that have a non-zero value in the transition
matrix).
</p>
<p>Cell numbers are unique indices of cells in the original grid.
By convention, cell numbers start with 1 in the upper-left
corner of the grid and increase from left to right and from top
to bottom.
</p>


<h3>Value</h3>

<p>A two column matrix with each row containing
a pair of adjacent cells.
</p>


<h3>Author(s)</h3>

<p>Jacob van Etten
</p>


<h3>See Also</h3>

<p><code><a href="raster.html#topic+adjacent">adjacent</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("raster")
r &lt;- raster(nrows = 6, ncols = 7,
            xmn = 0, xmx = 7,
            ymn = 0, ymx = 6,
            crs = "+proj=utm +units=m")
r[] &lt;- runif(6 * 7)
tr &lt;- transition(r, function(x) 1 / mean(x), 8)

aft &lt;- adjacencyFromTransition(tr)

head(aft)

</code></pre>

<hr>
<h2 id='ArithMath-methods'>Arithmetic and mathematical operations with objects of Transition* classes</h2><span id='topic+ArithMath-methods'></span><span id='topic+Arith-methods'></span><span id='topic+Arith+2CANY+2CTransitionLayer-method'></span><span id='topic+Arith+2CTransitionLayer+2CANY-method'></span><span id='topic+Arith+2CTransitionLayer+2CTransitionLayer-method'></span><span id='topic+Arith+2CTransitionLayer+2CTransitionStack-method'></span><span id='topic+Arith+2CTransitionStack+2CTransitionLayer-method'></span><span id='topic+Arith+2CTransitionStack+2CANY-method'></span><span id='topic+Arith+2CANY+2CTransitionStack-method'></span><span id='topic+Math-methods'></span><span id='topic+Math+2CTransitionLayer-method'></span><span id='topic+Math+2CTransitionStack-method'></span>

<h3>Description</h3>

<p>Standard arithmetic operators for computations with <code>Transition*</code>
objects and numeric values. Transition objects must have the same extent
and resolution. All arithmetic and mathematical operations that work on
the sparse matrices are available for <code>Transition*</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TransitionLayer,TransitionLayer'
Arith(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ArithMath-methods_+3A_e1">e1</code></td>
<td>
<p>objects</p>
</td></tr>
<tr><td><code id="ArithMath-methods_+3A_e2">e2</code></td>
<td>
<p>objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>Transition*</code> object or numeric.
</p>


<h3>Author(s)</h3>

<p>Jacob van Etten
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create a new raster and set all its values to unity.
raster &lt;- raster(nrows=18, ncols=36)
raster &lt;- setValues(raster,rep(1,ncell(raster)))

#create TransitionLayer objects
tr1 &lt;- transition(raster,mean,4)
tr2 &lt;- tr1

#arithmetic operations
tr3 &lt;- tr1 * tr2
tr4 &lt;- tr3 * 4

#mathematical operations
tr5 &lt;- sqrt(tr4)
</code></pre>

<hr>
<h2 id='commuteDistance'>Commute-time distance</h2><span id='topic+commuteDistance'></span><span id='topic+commuteDistance+2CTransitionLayer+2CCoords-method'></span>

<h3>Description</h3>

<p>Calculates the resistance distance between points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>commuteDistance(x, coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="commuteDistance_+3A_x">x</code></td>
<td>
<p>object of class <code>TransitionLayer</code></p>
</td></tr>
<tr><td><code id="commuteDistance_+3A_coords">coords</code></td>
<td>
<p>point locations coordinates
(of SpatialPoints, matrix or numeric class)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the expected random-walk commute
time between nodes in a graph. It is defined as the effective
distance (resistance distance) between the selected nodes multiplied
by the volume of the graph, which is the sum of the conductance
weights of all the edges in the graph (Chandra et al. 1997). The
result represents the average number of steps that is needed to
commute between the nodes during a random walk.
</p>
<p>The function implements the algorithm given by Fouss et al. (2007).
</p>
<p>Before calculating commute-time distances from a <code>TransitionLayer</code>
object, see if you need to apply the function
<code><a href="#topic+geoCorrection">geoCorrection</a></code>
</p>


<h3>Value</h3>

<p>distance matrix (S3 class dist or matrix)
</p>


<h3>Author(s)</h3>

<p>Jacob van Etten
</p>


<h3>References</h3>

<p>Chandra, A.K., Raghavan, P., Ruzzo, W.L., Smolensy, R. &amp; Tiwari, P. 1996.
The electrical resistance of a graph captures its commute and cover times.
Computational Complexity, 6(4), 312-340.
</p>
<p>Fouss, F., Pirotte, A., Renders, J.-M. &amp; Saerens, M. 2007.
Random-walk computation of similarities between nodes of a
graph with application to collaborative recommendation. IEEE
Transactions on Knowledge and Data Engineering, 19(3), 355-369.
</p>
<p>McRae, B.H. 2006. Isolation by resistance. Evolution 60(8), 1551-1561.
<a href="https://circuitscape.org/">https://circuitscape.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geoCorrection">geoCorrection</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("raster")
# Create a new raster and set all its values to unity.
r &lt;- raster(nrows=18, ncols=36)
r &lt;- setValues(r,rep(1,ncell(raster)))

#Create a Transition object from the raster
tr &lt;- transition(r, function(x) 1/mean(x),4)

# Create two sets of coordinates
library("sp")
sP1 &lt;- SpatialPoints(cbind(c(65,5,-65),c(55,35,-35)))
sP2 &lt;- SpatialPoints(cbind(c(50,15,-40),c(80,20,-5)))

#Calculate the resistance distance between the points
commuteDistance(tr, sP1)

</code></pre>

<hr>
<h2 id='Coords+20class'>Coords class</h2><span id='topic+Coords+20class'></span><span id='topic+Coords-class'></span>

<h3>Description</h3>

<p>This is a class union, providing a convenient class for
coordinates in several formats.
</p>


<h3>Details</h3>

<p>The class accepts coordinates in any of the following formats:
1. SpatialPoints
2. two-columned matrix
3. vector of length 2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Coords")
</code></pre>

<hr>
<h2 id='costDistance'>Cost distance</h2><span id='topic+costDistance'></span><span id='topic+costDistance+2CTransitionLayer+2CCoords+2Cmissing-method'></span><span id='topic+costDistance+2CTransitionLayer+2CCoords+2CCoords-method'></span>

<h3>Description</h3>

<p>Calculate the least-cost distance between points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>costDistance(x, fromCoords, toCoords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="costDistance_+3A_x">x</code></td>
<td>
<p>object of class <code>TransitionLayer</code></p>
</td></tr>
<tr><td><code id="costDistance_+3A_fromcoords">fromCoords</code></td>
<td>
<p>first set of point locations
(of <code>SpatialPoints</code>, matrix or numeric class)</p>
</td></tr>
<tr><td><code id="costDistance_+3A_tocoords">toCoords</code></td>
<td>
<p>optional, second set of point
locations (of <code>SpatialPoints</code>, matrix or numeric class)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cost units between cells are defined as the reciprocal
of the values in the transition matrix.
</p>
<p>The function uses Dijkstra's algorithm, as implemented in
the igraph package.
</p>
<p>A projection correction is needed for accuracy in the case
of grid data for a longlat raster (see function geoCorrection).
</p>


<h3>Value</h3>

<p>distance matrix (S3 class dist or matrix)
</p>


<h3>Author(s)</h3>

<p>Jacob van Etten
</p>


<h3>References</h3>

<p>E.W. Dijkstra. 1959. A note on two problems
in connexion with graphs. Numerische Mathematik 1, 269 - 271.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geoCorrection">geoCorrection</a></code>,
<code><a href="#topic+accCost">accCost</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("raster")
# create a new raster and set all its values to unity.
r &lt;- raster(nrows=18, ncols=36)
r &lt;- setValues(r,runif(ncell(r),0,1))

# create a Transition object from the raster
tr &lt;- transition(r,function(x) 1/mean(x),8)

# asymmetric
ncf &lt;- function(x) max(x) - x[1] + x[2]
tr2 &lt;- transition(r,ncf,8, symm=FALSE)

# create two sets of coordinates
sP1 &lt;- cbind(c(65,5,-65),c(55,35,-35))
sP2 &lt;- cbind(c(50,15,-40),c(80,20,-5))

# from and to identical
costDistance(tr,sP1)
costDistance(tr2,sP1)

# from and to different
costDistance(tr,sP1,sP2)
costDistance(tr2,sP1,sP2)

</code></pre>

<hr>
<h2 id='genDist'>Genetic distances and coordinates of haplogroup R1b1b2 populations in Europe</h2><span id='topic+genDist'></span><span id='topic+popCoord'></span>

<h3>Description</h3>

<p>genDist: Genetic distances between 23 populations of Y-chromosome
haplogroup R1b1b2 in Europe, calculated from haplotype microsatellite
data (see source).
</p>


<h3>Format</h3>

<p>dist object (genDist) and data.frame (popCoord)
</p>


<h3>Details</h3>

<p>The distance measure used is the negative logarithm of the shared
proportion of alleles.
</p>
<p>popCoord: Geographic coordinates of the same populations.
</p>


<h3>Source</h3>

<p>Distances calculated from Table S1 in
Balaresque et al. (2010).
Coordinates from Table 1.
</p>


<h3>References</h3>

<p>Balaresque P., et al. 2010. A predominantly Neolithic
origin for European paternal lineages.
<em>PLoS Biology</em> 8(1): e1000285.
</p>

<hr>
<h2 id='geoCorrection'>Geographic Correction</h2><span id='topic+geoCorrection'></span><span id='topic+geoCorrection+2CTransitionLayer+2Ccharacter-method'></span><span id='topic+geoCorrection+2CTransitionLayer+2Cmissing-method'></span>

<h3>Description</h3>

<p>Correct 'TransitionLayer' objects taking into account
local distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geoCorrection(x, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geoCorrection_+3A_x">x</code></td>
<td>
<p>object of class <code>Transition*</code></p>
</td></tr>
<tr><td><code id="geoCorrection_+3A_type">type</code></td>
<td>
<p>type of correction: &quot;c&quot;, &quot;r&quot;, or missing
(only required for lonlat, see Details)</p>
</td></tr>
<tr><td><code id="geoCorrection_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods. <code>multpl</code> with
correction factor (<code>TRUE</code>) or corrected values (<code>FALSE</code>, the default).
<code>scl</code> scale the correction values (default is <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Geographic correction is necessary for all objects of the
class Transition that are either:
(1) based on a grid in a geographic (lonlat) projection
and covering a large area;
(2) made with directions &gt; 4.
</p>
<p>The function will correct for map distortion, as well as for diagonal
connections between grid cells (which cover a longer distance than vertical
or horizontal connections).
</p>
<p>When working with lonlat grids, users should also anticipate whether they
will use methods based on either least-cost or random walks, and set the
type argument accordingly. In the case of least-cost distances, the
correction is only done in East-West direction. In the case of random walks
there should be an additional correction which reduces the conductance in
North-South direction (<code>type="r"</code>).
</p>
<p>The correction is done by dividing conductance values by the inter-cell
distance. Distances are calculated as great-circle distances for lonlat
grids (see function <code>[raster]{isLonLat}</code>) and Euclidean distances for all other grids.
</p>
<p>In the case of randomised shortest paths, the need for correction is
somewhat in between these two correction methods. We have not developed
an analytical solution for this problem yet. With very low values for theta,
you may choose the correction for random walks, and for high values the one for
least-cost paths. Users who want to work with intermediate values of theta are
encouraged to experiment with different solutions.
</p>
<p>The values are scaled to get values near 1 if the argument <code>scl</code> is set to
TRUE. This is desirable for subsequent calculations involving random walk
calculations. Values are divided by the W-E inter-cell distance (at the
centre of the grid).
</p>


<h3>Value</h3>

<p>a 'Transition*' object
</p>


<h3>Author(s)</h3>

<p>Jacob van Etten
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("raster")
r &lt;- raster(ncol=36,nrow=18)
r &lt;- setValues(r,rep(1,times=ncell(r)))
tr &lt;- transition(r, mean, directions=8)

# directly
tr1 &lt;- geoCorrection(tr, type="c", multpl=FALSE)
tr1

# the same, but with a separate correction matrix
trCorr &lt;- geoCorrection(tr, type="c", multpl=TRUE)
tr2 &lt;- tr * trCorr
tr2
</code></pre>

<hr>
<h2 id='normalize'>Normalize</h2><span id='topic+normalize'></span><span id='topic+normalize+2CTransitionLayer-method'></span>

<h3>Description</h3>

<p>Normalize the transition matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_+3A_x">x</code></td>
<td>
<p>object of class <code>Transition*</code></p>
</td></tr>
<tr><td><code id="normalize_+3A_...">...</code></td>
<td>
<p>optional argument <code>method</code> (see Details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>argument <code>method</code> passed through <code>...</code>
a character for the normalization method
the default is 'row' users can set the optional method argument
to either &quot;col&quot; or &quot;symm&quot;
</p>
<p>Normalization of the weighted adjacency matrix in the Transition* object.
Matrix values are divided by their respective row-sums, column-sums,
or the product of the square-roots of both (symmetric normalization).
</p>
<p>The default  <code>method</code> is row-normalization. To use the other normalization
methods, users can set the optional <code>method</code> argument
to either &quot;col&quot; or &quot;symm&quot;.
</p>
<p>For random walk calculations a symmetric matrix is needed (method = &quot;symm&quot;).
</p>


<h3>Value</h3>

<p>an object of class <code>TransitionLayer</code>
</p>


<h3>Author(s)</h3>

<p>Jacob van Etten
</p>


<h3>References</h3>

<p>von Luxburg, U. 2007. A tutorial on spectral clustering.
Statistics and Computing 17(4), 395-416.
<a href="https://doi.org/10.1007/s11222-007-9033-z">doi:10.1007/s11222-007-9033-z</a>
</p>
<p>Chung, F. 1997. Spectral Graph Theory. Conference Board of
the Mathematical Sciences, Washington.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("raster")
r &lt;- raster(ncol=36,nrow=18)
r &lt;- setValues(r,rep(1,times=ncell(r)))
tr &lt;- transition(r, mean, directions=8)

normalize(tr)

normalize(tr, method="symm")

</code></pre>

<hr>
<h2 id='overlap'>Overlap and nonoverlap of trajectories</h2><span id='topic+overlap'></span><span id='topic+nonoverlap'></span>

<h3>Description</h3>

<p>Special functions to calculate the degree of overlap and
nonoverlap between trajectories
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlap(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlap_+3A_a">a</code></td>
<td>
<p><code>matrix</code> object</p>
</td></tr>
<tr><td><code id="overlap_+3A_b">b</code></td>
<td>
<p><code>matrix</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are used by the <code>pathInc()</code> as defaults.
</p>


<h3>Value</h3>

<p>A matrix object
</p>


<h3>Note</h3>

<p>The functions are provided here to assist the user in defining
alternative measures of overlap / nonoverlap.
</p>


<h3>Author(s)</h3>

<p>Jacob van Etten
</p>

<hr>
<h2 id='passage'>Probability of passage</h2><span id='topic+passage'></span><span id='topic+passage+2CTransitionLayer+2CCoords+2CCoords+2Cmissing-method'></span><span id='topic+passage+2CTransitionLayer+2CCoords+2CCoords+2Cnumeric-method'></span><span id='topic+passage+2CTransitionLayer+2CRasterLayer+2CRasterLayer+2Cmissing-method'></span><span id='topic+passage+2CTransitionLayer+2CRasterLayer+2CRasterLayer+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Calculates for each cell the number of passages of a random-walk
or randomised shortest paths with given origin(s) and destination(s).
Either the total or the net number of passages can be calculated.
In the case of multiple origins or destinations, each receives equal
weight.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>passage(x, origin, goal, theta, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="passage_+3A_x">x</code></td>
<td>
<p>Object of class <code>Transition*</code></p>
</td></tr>
<tr><td><code id="passage_+3A_origin">origin</code></td>
<td>
<p><code>SpatialPoints</code>, matrix or numeric
object with coordinates or RasterLayer object with origin
cells set to TRUE</p>
</td></tr>
<tr><td><code id="passage_+3A_goal">goal</code></td>
<td>
<p><code>SpatialPoints</code>, matrix or numeric object
with coordinates or RasterLayer object with origin
cells set to TRUE</p>
</td></tr>
<tr><td><code id="passage_+3A_theta">theta</code></td>
<td>
<p>If zero or missing, a random walk results.
If a numeric value 0 &lt; theta &lt; 20 is given, randomised
shortest paths are calculated; theta is the degree
from which the path randomly deviates from the shortest path</p>
</td></tr>
<tr><td><code id="passage_+3A_...">...</code></td>
<td>
<p>Additional arguments:
totalNet (&quot;total&quot; or &quot;net&quot;), and output (&quot;RasterLayer&quot; or &quot;Transition&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The net number of passages between i and j is defined as:
abs( passages from i to j - passages from j to i ).
</p>
<p>Defaults for additional argument <code>totalNet</code> is &quot;net&quot;
and for <code>output</code> it is &quot;RasterLayer&quot;.
</p>
<p>Random walk requires a symmetric transition matrix.
</p>


<h3>Value</h3>

<p>RasterLayer or Transition object, depending on the output argument
</p>


<h3>Author(s)</h3>

<p>Jacob van Etten. Implementation of randomised shortest
paths based on Matlab code by Marco Saerens
</p>


<h3>References</h3>

<p>McRae B.H., B.G. Dickson, and T. Keitt. 2008.
Using circuit theory to model connectivity in ecology,
evolution, and conservation.
<em>Ecology</em> 89:2712-2724.
</p>
<p>Saerens M., L. Yen, F. Fouss, and Y. Achbany. 2009.
Randomized shortest-path problems: two related models.
<em>Neural Computation</em>, 21(8):2363-2404.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+commuteDistance">commuteDistance</a></code>,
<code><a href="#topic+pathInc">pathInc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create a new raster and set all its values to unity.
raster &lt;- raster(nrows=18, ncols=36)
raster &lt;- setValues(raster,rep(1,ncell(raster)))

#create a Transition object from the raster
tr &lt;- transition(raster,mean,4)
trC &lt;- geoCorrection(tr, type="c", scl=TRUE)
trR &lt;- geoCorrection(tr, type="r", scl=TRUE)

#create two coordinates
sP1 &lt;- SpatialPoints(cbind(-105,55))
sP2 &lt;- SpatialPoints(cbind(105,-55))

#randomised shortest paths with theta = 2
rSPraster &lt;- passage(trC, sP1, sP2, 2)
plot(rSPraster)
points(sP1)
points(sP2)

#randomised shortest paths with theta = 0.05
rSPraster &lt;- passage(trC, sP1, sP2, 0.05)
plot(rSPraster)
points(sP1)
points(sP2)

#randomised shortest paths with theta = 0.05
#and total
rSPraster &lt;- passage(trC, sP1, sP2, 0.05, totalNet = "total")
plot(rSPraster)
points(sP1)
points(sP2)

#random walk
rwraster &lt;- passage(trR, sP1, sP2)
plot(rwraster)
points(sP1)
points(sP2)

</code></pre>

<hr>
<h2 id='pathInc'>Incidence of paths from a common origin: overlap and non-overlap</h2><span id='topic+pathInc'></span><span id='topic+pathInc+2CTransitionLayer+2CCoords+2CCoords+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+pathInc+2CTransitionLayer+2CCoords+2CCoords+2Cmissing+2Cnumeric+2Cmissing-method'></span><span id='topic+pathInc+2CTransitionLayer+2CCoords+2CCoords+2Cmissing+2Cmissing+2CTransition-method'></span><span id='topic+pathInc+2CTransitionLayer+2CCoords+2CCoords+2Cmissing+2Cnumeric+2CTransition-method'></span><span id='topic+pathInc+2CTransitionLayer+2CCoords+2CCoords+2CCoords+2Cmissing+2Cmissing-method'></span><span id='topic+pathInc+2CTransitionLayer+2CCoords+2CCoords+2CCoords+2Cnumeric+2Cmissing-method'></span><span id='topic+pathInc+2CTransitionLayer+2CCoords+2CCoords+2CCoords+2Cmissing+2CTransition-method'></span><span id='topic+pathInc+2CTransitionLayer+2CCoords+2CCoords+2CCoords+2Cnumeric+2CTransition-method'></span>

<h3>Description</h3>

<p>Calculate the overlap and non-overlap of paths departing from a common origin.
Two algorithms are available: random walk and randomised shortest paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pathInc(x, origin, from, to, theta, weight, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pathInc_+3A_x">x</code></td>
<td>
<p>transition matrix of class <code>Transition*</code></p>
</td></tr>
<tr><td><code id="pathInc_+3A_origin">origin</code></td>
<td>
<p>coordinates of the origin (one point location,
SpatialPoints, matrix or numeric class)</p>
</td></tr>
<tr><td><code id="pathInc_+3A_from">from</code></td>
<td>
<p>coordinates of the destinations
(SpatialPoints, matrix or numeric class)</p>
</td></tr>
<tr><td><code id="pathInc_+3A_to">to</code></td>
<td>
<p>second set of coordinates of the destinations (can be missing)</p>
</td></tr>
<tr><td><code id="pathInc_+3A_theta">theta</code></td>
<td>
<p>value &gt; 0 and &lt; 20 (randomised shortest paths) or
missing (random walk)</p>
</td></tr>
<tr><td><code id="pathInc_+3A_weight">weight</code></td>
<td>
<p>matrix – Reciprocals of the non-zero values are used as weights.
If missing, reciprocals of the transition matrix are used.</p>
</td></tr>
<tr><td><code id="pathInc_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a complex wrapper function that calculates to what extent dispersal
routes overlap or do not overlap.
</p>
<p>First, the function calculates the trajectories for all &quot;from&quot; and &quot;to&quot;
locations, starting from a single &quot;origin&quot; location. These trajectories can
either be based on random walks or randomised shortest paths (giving a value
to theta).
</p>
<p>Then, for all unique pairs of trajectories, it calculates the extent to
which these trajectories overlap or diverge. These values are given back
to the user as a list of (distance) matrices.
</p>
<p>If only &quot;from&quot; coordinates are given, the function calculates symmetric
distance matrices for all combinations of points in &quot;from&quot;. If both &quot;from&quot;
and &quot;to&quot; coordinates are given, the function calculates a matrix of values
with rows for all locations in &quot;from&quot; and columns for all locations in &quot;to&quot;.
</p>
<p>Overlap is currently calculated as the minimum values of each pair of
trajectories compared. Non-overlap uses the following formula:
Nonoverlap = max(0,max(a,b)*(1-min(a,b))-min(a,b))
(see van Etten and Hijmans 2010). See the last example to learn
how to use an alternative function.
</p>


<h3>Value</h3>

<p>list of dist objects or list of matrices
</p>


<h3>Author(s)</h3>

<p>Jacob van Etten. Implementation of randomised shortest paths
based on Matlab code by Marco Saerens.
</p>


<h3>References</h3>

<p>McRae B.H., B.G. Dickson, and T. Keitt. 2008.
Using circuit theory to model connectivity in ecology,
evolution, and conservation. Ecology 89:2712-2724.
</p>
<p>Saerens M., L. Yen, F. Fouss, and Y. Achbany. 2009.
Randomized shortest-path problems: two related models.
Neural Computation, 21(8):2363-2404.
</p>
<p>van Etten, J., and R.J. Hijmans. 2010. A geospatial modelling
approach integrating archaeobotany and genetics to trace the
origin and dispersal of domesticated plants. PLoS ONE 5(8): e12060.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("raster")
library("sp")

# Create TransitionLayer
r &lt;- raster(ncol=36,nrow=18)
r &lt;- setValues(r,rep(1,times=ncell(r)))
tr &lt;- transition(r,mean,directions=4)

# Two different types of correction are required
trR &lt;- geoCorrection(tr, type="r", multpl=FALSE)
trC &lt;- geoCorrection(tr, type="c", multpl=FALSE)

# Create TransitionStack
ts &lt;- stack(trR, trR)

# Points for origin and coordinates between which to calculate path (non)overlaps
sP0 &lt;- SpatialPoints(cbind(0,0))
sP1 &lt;- SpatialPoints(cbind(c(65,5,-65),c(-55,35,-35)))

# Randomised shortest paths
# rescaling is needed: exp(-theta * trC) should give reasonable values
# divide by median of the non-zero values
trC &lt;- trC / median(transitionMatrix(trC)@x)
pathInc(trC, origin=sP0, from=sP1, theta=2)

# Random walk
pathInc(trR, origin=sP0, from=sP1)

# TransitionStack as weights
pathInc(trR, origin=sP0, from=sP1, weight=ts)

# Demonstrate use of an alternative function
#The current default is to take the minimum of each pair of layers

altoverlap &lt;- function(a, b)
{
  aV &lt;- as.vector(a[,rep(1:ncol(a), each=ncol(b))])
  bV &lt;- as.vector(b[,rep(1:ncol(b), times=ncol(a))])
  result &lt;- matrix(aV * bV, nrow = nrow(a), ncol=ncol(a)*ncol(b))
  return(result)
}

pathInc(trR, origin=sP0, from=sP1, weight=ts, functions=list(altoverlap))

</code></pre>

<hr>
<h2 id='raster+2CTransitionLayer-method'>RasterLayer from TransitionLayer object</h2><span id='topic+raster+2CTransitionLayer-method'></span>

<h3>Description</h3>

<p>Create a RasterLayer from a TransitionLayer with a call to
the generic function <code>raster</code>. The n x n transition matrix of
the TransitionLayer is transformed to form the values n cells of a raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TransitionLayer'
raster(x, reduceMethod = "NZcolMeans")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster+2B2CTransitionLayer-method_+3A_x">x</code></td>
<td>
<p>an object of class <code>Transition*</code></p>
</td></tr>
<tr><td><code id="raster+2B2CTransitionLayer-method_+3A_reducemethod">reduceMethod</code></td>
<td>
<p>character for the method to reduce the transition matrix.
See details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following methods to &lsquo;reduce&rsquo; the transition matrix are
available with the optional argument <code>reduceMethod</code>):
</p>

<ul>
<li><p>colSums
</p>
</li>
<li><p>rowSums
</p>
</li>
<li><p>colMeans
</p>
</li>
<li><p>rowMeans
</p>
</li>
<li><p>NZcolMeans
</p>
</li>
<li><p>NZrowMeans
</p>
</li></ul>

<p>The latter two methods only take into account the non-zero entries
in the transition matrix.
The default is NZcolMeans.
</p>


<h3>Value</h3>

<p>a RasterLayer
</p>


<h3>Author(s)</h3>

<p>Jacob van Etten
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create a new raster and set all its values to unity.
r &lt;- raster(nrows=18, ncols=36)
r &lt;- setValues(r,runif(ncell(r),0,1))

#create a Transition object from the raster
tr1 &lt;- transition(r,mean,8)

#asymmetric
asf &lt;- function(x) max(x) - x[1] + x[2]
tr2 &lt;- transition(r,asf,8, symm=FALSE)

#create RasterLayer objects
r1 &lt;- raster(tr1)
r2 &lt;- raster(tr2)
r3 &lt;- raster(tr1, "colMeans")
</code></pre>

<hr>
<h2 id='rSPDistance'>Randomized shortest path distance</h2><span id='topic+rSPDistance'></span><span id='topic+rSPDistance+2CTransitionLayer+2CCoords-method'></span>

<h3>Description</h3>

<p>Calculates the randomized shortest path distance between points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSPDistance(x, from, to, theta, totalNet = "net", method = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rSPDistance_+3A_x">x</code></td>
<td>
<p><code>TransitionLayer</code> object</p>
</td></tr>
<tr><td><code id="rSPDistance_+3A_from">from</code></td>
<td>
<p>point locations coordinates (of SpatialPoints,
matrix or numeric class)</p>
</td></tr>
<tr><td><code id="rSPDistance_+3A_to">to</code></td>
<td>
<p>point locations coordinates (of SpatialPoints,
matrix or numeric class)</p>
</td></tr>
<tr><td><code id="rSPDistance_+3A_theta">theta</code></td>
<td>
<p>theta is the degree from which the path randomly
deviates from the shortest path, 0 &lt; theta &lt; 20</p>
</td></tr>
<tr><td><code id="rSPDistance_+3A_totalnet">totalNet</code></td>
<td>
<p>total or net movements between cells</p>
</td></tr>
<tr><td><code id="rSPDistance_+3A_method">method</code></td>
<td>
<p>method 1 (as defined in Saerens et al.) or
method 2 (a modified version, see below in Details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the algorithm given by Saerens et al. (2009).
</p>
<p>Method 1 implements the method as it is.
Method 2 uses W = exp(-theta * ln(P)).
</p>


<h3>Value</h3>

<p>distance matrix (S3 class dist or matrix)
</p>


<h3>Author(s)</h3>

<p>Jacob van Etten
</p>


<h3>References</h3>

<p>Saerens M., L. Yen, F. Fouss, and Y. Achbany. 2009.
Randomized shortest-path problems: two related models.
<em>Neural Computation</em>, 21(8):2363-2404.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geoCorrection">geoCorrection</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create a new raster and set all its values to unity.
r &lt;- raster(nrows=18, ncols=36)
r &lt;- setValues(r,rep(1,ncell(raster)))

#Create a Transition object from the raster
tr &lt;- transition(r,mean,4)

#Create two sets of coordinates
sP1 &lt;- SpatialPoints(cbind(c(65,5,-65),c(55,35,-35)))
sP2 &lt;- SpatialPoints(cbind(c(50,15,-40),c(80,20,-5)))

#Calculate the RSP distance between the points
rSPDistance(tr, sP1, sP2, 1)

</code></pre>

<hr>
<h2 id='shortestPath'>Shortest path</h2><span id='topic+shortestPath'></span><span id='topic+shortestPath+2CTransitionLayer+2CCoords+2CCoords-method'></span>

<h3>Description</h3>

<p>Calculates the shortest path from an origin to a goal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shortestPath(x, origin, goal, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shortestPath_+3A_x">x</code></td>
<td>
<p><code>TransitionLayer</code> object</p>
</td></tr>
<tr><td><code id="shortestPath_+3A_origin">origin</code></td>
<td>
<p>SpatialPoints, vector or matrix with coordinates,
at the moment only the first cell is taken into account</p>
</td></tr>
<tr><td><code id="shortestPath_+3A_goal">goal</code></td>
<td>
<p>SpatialPoints, vector or matrix with coordinates</p>
</td></tr>
<tr><td><code id="shortestPath_+3A_...">...</code></td>
<td>
<p>Additional argument: output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As an additional argument output, the desired output object can be specified:
either &ldquo;TransitionLayer&rdquo; (default),
&ldquo;TransitionStack&rdquo; or &ldquo;SpatialLines&rdquo;.
</p>
<p>If there is more than one path either (1) transition values in the
TransitionLayer get values of 1 / number of paths or (2) the SpatialLines
object will contain more than one line.
</p>


<h3>Value</h3>

<p>Transition object
</p>


<h3>Author(s)</h3>

<p>Jacob van Etten
</p>


<h3>See Also</h3>

<p><code><a href="#topic+costDistance">costDistance</a></code>, <code><a href="#topic+accCost">accCost</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example equivalent to that in the documentation on r.cost/r.drain in GRASS
r &lt;- raster(nrows=6, ncols=7, xmn=0, xmx=7, ymn=0, ymx=6, crs="+proj=utm +units=m")

r[] &lt;- c(2, 2, 1, 1, 5, 5, 5,
         2, 2, 8, 8, 5, 2, 1,
         7, 1, 1, 8, 2, 2, 2,
         8, 7, 8, 8, 8, 8, 5,
         8, 8, 1, 1, 5, 3, 9,
         8, 1, 1, 2, 5, 3, 9)

tr &lt;- transition(r, function(x) 1/mean(x), 8)
# 1/mean: reciprocal to get permeability
tr &lt;- geoCorrection(tr)

c1 &lt;- c(5.5,1.5)
c2 &lt;- c(1.5,5.5)

#make a SpatialLines object for visualization
sPath1 &lt;- shortestPath(tr, c1, c2, output="SpatialLines")
plot(r)
lines(sPath1)

#make a TransitionLayer for further calculations
sPath2 &lt;- shortestPath(tr, c1, c2)

plot(raster(sPath2))

</code></pre>

<hr>
<h2 id='Summary-methods'>Summary methods</h2><span id='topic+Summary-methods'></span><span id='topic+Summary+2CTransitionLayer-method'></span><span id='topic+Summary+2CTransitionStack-method'></span><span id='topic+sum+2CTransitionStack-method'></span><span id='topic+mean+2CTransitionStack-method'></span><span id='topic+summary+2CTransitionLayer-method'></span><span id='topic+summary+2CTransitionStack-method'></span>

<h3>Description</h3>

<p>The following summary methods are available: mean,
Median, max, min, range, prod, sum, any, all
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TransitionStack'
Summary(x, ..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Summary-methods_+3A_x">x</code></td>
<td>
<p>objects</p>
</td></tr>
<tr><td><code id="Summary-methods_+3A_...">...</code></td>
<td>
<p>further arguments passes to or from methods</p>
</td></tr>
<tr><td><code id="Summary-methods_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, should missing values be removed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a TransitionLayer
</p>


<h3>Note</h3>

<p>These methods compute a summary statistic based on cell values of
layers in a TransitionStack. The result of these methods is always a
single TransitionLayer.
</p>


<h3>Author(s)</h3>

<p>Jacob van Etten
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create a new raster and set all its values to unity.
raster &lt;- raster(nrows=18, ncols=36)
raster &lt;- setValues(raster,rep(1,ncell(raster)))

#Create a Transition object from the raster
tr &lt;- transition(raster,mean,4)

trS &lt;- stack(tr, tr*2)

#Apply a Summary method
trSum &lt;- sum(trS)

#plot(raster(trMean))
</code></pre>

<hr>
<h2 id='sumReciprocal'>Reciprocal of the sum of the reciprocals of conductance values in Transition* objects</h2><span id='topic+sumReciprocal'></span>

<h3>Description</h3>

<p>Reciprocal of the sum of the reciprocals of conductance Transition* objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumReciprocal(x1, x2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumReciprocal_+3A_x1">x1</code></td>
<td>
<p><code>TransitionLayer</code> object</p>
</td></tr>
<tr><td><code id="sumReciprocal_+3A_x2">x2</code></td>
<td>
<p><code>TransitionLayer</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To calculate the total resistance of two resistors that are serially
connected, we should add their resistance values. However, if we work
with conductance values, we need to take the reciprocal of the summed
reciprocals of the conductance values. This function does that when
adding two TransitionLayers with conductance values
(<code>matrixValues(tr) == "conductance"</code>).
</p>
<p>For a TransitionLayer with resistance values
(<code>matrixValues(tr) == "resistance"</code>), the function will not take
reciprocals for that object, but will still take a reciprocal for the
final product (which will consequently have conductance values).
</p>


<h3>Value</h3>

<p><code>TransitionLayer</code> object containing conductance values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create a new raster and set all its values to unity.
raster &lt;- raster(nrows=18, ncols=36)
raster &lt;- setValues(raster,rep(1,ncell(raster)))

#Create TransitionLayer objects
tr1 &lt;- transition(raster,mean,4)
tr2 &lt;- tr1
matrixValues(tr1)

#Set one to resistance
matrixValues(tr2) &lt;- "resistance"

#Sum the two objects
sumReciprocal(tr1,tr2)
</code></pre>

<hr>
<h2 id='transition'>Create an object of the class Transition</h2><span id='topic+transition'></span><span id='topic+transition+2CRasterLayer-method'></span><span id='topic+transition+2CRasterBrick-method'></span>

<h3>Description</h3>

<p>Create a Transition object from a RasterLayer or RasterBrick object.
Transition values are calculated with a user-defined function from
the grid values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transition(x, transitionFunction, directions, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transition_+3A_x">x</code></td>
<td>
<p><code>RasterLayer</code> or <code>RasterBrick</code> (raster package)</p>
</td></tr>
<tr><td><code id="transition_+3A_transitionfunction">transitionFunction</code></td>
<td>
<p>Function to calculate transition values
from grid values</p>
</td></tr>
<tr><td><code id="transition_+3A_directions">directions</code></td>
<td>
<p>Directions in which cells are connected
(4, 8, 16, or other), see <code><a href="raster.html#topic+adjacent">adjacent</a></code></p>
</td></tr>
<tr><td><code id="transition_+3A_...">...</code></td>
<td>
<p>additional arguments, passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users may use one of three methods to construct a Transition*
object with this function.
</p>
<p>1) <code>TransitionLayer</code> from <code>RasterLayer</code>
</p>
<p><code>transition(x, transisitonFunction, directions, symm)</code>
</p>
<p>When a symmetric transition matrix is required, the user should
supply a transitionFunction f that obeys f(i,j) = f(j,i)
(a commutative function).
</p>
<p>The function <code>transition</code> does no commutativity check.
</p>
<p>To obtain an asymmetric transition matrix, a non-commutative
function should be supplied and an additional argument &lsquo;symm&rsquo;
should be set to FALSE.
</p>
<p>2) <code>TransitionLayer</code> from <code>RasterBrick</code>
</p>
<p><code>transition(x, transitionFunction = "mahal", directions)</code>
</p>
<p>This method serves to summarize several layers of data in a single
distance measure. The distance between adjacent cells is the normalized
reciprocal of the Mahalanobis distance
(mean distance / (mean distance + distance ij).
</p>
<p>3) <code>TransitionStack</code> from <code>RasterLayer</code>
</p>
<p>In contrast with the above methods, this method produces resistance
matrices by default.
</p>
<p>a) Continuous variables - barriers
</p>
<p><code>transition(x, transitionFunction = "barriers",
directions, symm, intervalBreaks)</code>
</p>
<p>This method creates a <code>TransitionStack</code> with each layer
containing a discrete boundary between areas in <code>x</code>.
Areas are defined by intervals in <code>x</code>.
The argument <code>intervalBreaks</code> is a vector of interval
breaks corresponding to the values in <code>x</code>.
If between a pair of cells i and j, min(i,j) &lt; break AND max(i,j) &gt; break,
then the value ij in the transition matrix becomes 1.
</p>
<p>All other values in the transition matrix remain 0.
The package classInt offers several methods to define intervals.
If symm is changed from the default (TRUE) to &quot;up&quot; or &quot;down&quot;,
it will give either only the upslope (symm = &quot;up&quot;) or
downslope (symm = &quot;down&quot;) barriers.
</p>
<p>b) Categorical variables - barriers
</p>
<p><code>transition(x, transitionFunction = "barriers", directions)</code>
</p>
<p>In this case, areas are defined as categories in the input raster.
A raster with a categorical variable can be created with
<code>asFactor()</code>.
The layers of the resulting TransitionStack contain
all possible combinations of categories.
Which layer contains the combination of categories i and j
out of n categories, can be determined with these formulae:
</p>
<p>if <code>symm</code> is <code>TRUE</code>: layer(i,j) = n*(j-1) - j*(j-1)/2 + i-j.
if <code>symm</code> is <code>FALSE</code> and i&gt;j: layer(i,j) = ((n*(j-1) - j*(j-1)/2 + i-j) * 2) - 1.
if <code>symm</code> is <code>FALSE</code> and i&lt;j: layer(i,j) = (n*(j-1) - j*(j-1)/2 + i-j) * 2.
</p>
<p>c) Categorical variables - areas
</p>
<p><code>transition(x, transitionFunction = "areas", directions)</code>
</p>
<p>Here, areas are also a categorical variable (see under 3b).
The layers in the resulting TransitionStack represent each one area.
Connections between two cells which are each inside the area are set to 1.
Connections between a cell inside and a cell outside the area are set to 0.5.
Connections between two cells outside the area are set to 0.
</p>

<hr>
<h2 id='Transition-classes'>Transition classes</h2><span id='topic+Transition-classes'></span><span id='topic+TransitionLayer-class'></span><span id='topic+TransitionStack-class'></span><span id='topic+TransitionData-class'></span><span id='topic+Transition-class'></span><span id='topic+coerce+2CTransitionLayer+2CsparseMatrix-method'></span><span id='topic+coerce+2CTransitionLayer+2CRasterLayer-method'></span><span id='topic+coerce+2CTransitionLayer+2CTransitionStack-method'></span><span id='topic+coerce+2CTransitionLayer+2CTransitionData-method'></span><span id='topic+coerce+2CRasterLayer+2CTransitionLayer-method'></span><span id='topic+coerce+2CTransitionData+2CsparseMatrix-method'></span><span id='topic+show+2CTransitionLayer-method'></span><span id='topic+show+2CTransitionStack-method'></span><span id='topic++3D+3D+2CTransitionLayer+2CTransitionLayer-method'></span><span id='topic++3D+3D+2CTransitionStack+2CTransitionStack-method'></span>

<h3>Description</h3>

<p>TransitionLayer and TransitionStack (or <code>Transition*</code>) are the core
classes of the package gdistance. They are the main input into the
functions to calculate distances and routes. An object of the class
TransitionLayer contains two main elements:
</p>


<h3>Details</h3>

<p>a. a transition matrix with transition values between connected
cells in a raster - an object of class sparseMatrix (package Matrix);
b. information on the extent, resolution and projection of the underlying
raster - an object of class Raster (package raster).
</p>
<p>All slots belong to these two elements from other package,
except two additional slots:
1. slot transitionCells, which is only used internally in the package;
2. slot matrixValues indicates if the nonzero values of the transition
matrix contains conductance or resistance values.
</p>
<p>Class TransitionStack contains one or more transition matrices.
</p>
<p>Class Transition is the union of TransitionLayer and TransitionStack.
</p>


<h3>Slots</h3>


<dl>
<dt><code>transitionMatrix</code></dt><dd><p>Object of class <code>"sparseMatrix"</code></p>
</dd>
<dt><code>transitionCells</code></dt><dd><p>Object of class <code>"integer"</code></p>
</dd>
<dt><code>matrixValues</code></dt><dd><p>Object of class <code>"character"</code></p>
</dd>
<dt><code>ncols</code></dt><dd><p>Object of class <code>"integer"</code></p>
</dd>
<dt><code>nrows</code></dt><dd><p>Object of class <code>"integer"</code></p>
</dd>
<dt><code>crs</code></dt><dd><p>Object of class <code>"CRS"</code> from <code>sp</code> package</p>
</dd>
<dt><code>extent</code></dt><dd><p>Object of class <code>"Extent"</code></p>
</dd>
<dt><code>layername</code></dt><dd><p>Object of class <code>"vector"</code></p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
new(&quot;Transition&quot;, nrows, ncols, xmin, xmax, ymin, ymax, projection).
</p>


<h3>Extends</h3>

<p>Class <code><a href="raster.html#topic+Raster-class">Raster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("TransitionLayer")

tr &lt;- new("TransitionLayer", nrows=as.integer(36), ncols=as.integer(18),
          extent=extent(c(xmin=-180,xmax=180, ymin=-90,ymax=90)),
          crs=CRS("+proj=longlat +datum=WGS84"))

tr &lt;- new("TransitionLayer",nrows=as.integer(36),ncols=as.integer(18),
          extent=extent(c(xmin=-180, xmax=180, ymin=-90,ymax=90)),
          crs=CRS(""))

</code></pre>

<hr>
<h2 id='Transition-extract-replace'>Extracting and replacing: class Transition</h2><span id='topic+Transition-extract-replace'></span><span id='topic++5B+2CTransitionLayer+2Cnumeric+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CTransitionLayer+2Cmatrix+2Cmissing+2Cmissing-method'></span><span id='topic++5B+3C-+2CTransitionLayer+2Cmatrix+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2CTransitionLayer+2Cnumeric+2Cnumeric+2CANY-method'></span><span id='topic++5B+5B+2CTransitionStack+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+5B+3C-+2CTransitionStack+2Cnumeric+2Cmissing+2CTransitionData-method'></span><span id='topic+TransitionStack+3C-'></span><span id='topic+transitionMatrix+3C-'></span><span id='topic+transitionMatrix+3C-+2CTransitionLayer+2CsparseMatrix-method'></span>

<h3>Description</h3>

<p>Methods for functions <code>[</code> and <code>[&lt;-</code> for object of
the class TransitionLayer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitionMatrix(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Transition-extract-replace_+3A_x">x</code></td>
<td>
<p>an object of class <code>Transition*</code></p>
</td></tr>
<tr><td><code id="Transition-extract-replace_+3A_value">value</code></td>
<td>
<p>the value to assign</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods for functions <code>[[</code> and <code>[[&lt;-</code> for object of
the class TransitionStack.
</p>
<p>Also see <code><a href="#topic+adjacencyFromTransition">adjacencyFromTransition</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create a new raster and set all its values to unity.
r &lt;- raster(nrows=18, ncols=36)
r &lt;- setValues(r,rep(1,ncell(r)))

#Create TransitionLayer objects
tr1 &lt;- transition(r,mean,4)
tr2 &lt;- tr1

#Extracting and replacing
tr1[cbind(1:9,1:9)] &lt;- tr2[cbind(1:9,1:9)]
tr1[1:9,1:9] &lt;- tr2[1:9,1:9]
tr1[1:5,1:5]
</code></pre>

<hr>
<h2 id='Transition-slots'>Extract or change elements of Transition* objects</h2><span id='topic+Transition-slots'></span><span id='topic+transitionMatrix'></span><span id='topic+nlayers+2CTransitionLayer-method'></span><span id='topic+nlayers+2CTransitionStack-method'></span><span id='topic+transitionMatrix+2CTransitionLayer+2Clogical-method'></span><span id='topic+transitionMatrix+2CTransitionLayer+2Cmissing-method'></span><span id='topic+transitionMatrix+2CTransitionData+2Cmissing-method'></span><span id='topic+matrixValues'></span><span id='topic+matrixValues+3C-'></span><span id='topic+transitionCells'></span><span id='topic+transitionData'></span><span id='topic+transitionCells+2CTransitionLayer-method'></span><span id='topic+transitionCells+2CTransitionData-method'></span><span id='topic+matrixValues+2CTransitionLayer-method'></span><span id='topic+matrixValues+3C-+2CTransitionLayer+2Ccharacter-method'></span><span id='topic+matrixValues+2CTransitionStack-method'></span><span id='topic+matrixValues+3C-+2CTransitionStack+2Ccharacter-method'></span><span id='topic+transitionData+2CTransitionLayer-method'></span><span id='topic+transitionData+2CTransitionStack-method'></span>

<h3>Description</h3>

<p>These functions are to be used to access slots of Transition* objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitionMatrix(x, inflate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Transition-slots_+3A_x">x</code></td>
<td>
<p>object of class <code>Transition*</code></p>
</td></tr>
<tr><td><code id="Transition-slots_+3A_inflate">inflate</code></td>
<td>
<p>logical (default is <code>TRUE</code>)</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
