<!DOCTYPE html><html><head><title>Help for package NetPreProc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NetPreProc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#NetPreProc-package'><p> NetPreProc</p></a></li>
<li><a href='#Binary.matrix.by.thresh-methods'><p> Transforming a real-valued network matrix into a binary matrix</p></a></li>
<li><a href='#check.network-methods'><p> Graph checking</p></a></li>
<li><a href='#Chua.norm-methods'><p> Chua normalization</p></a></li>
<li><a href='#Do.sim.matrix.Pearson'><p> Construction of the Pearson correlation matrix</p></a></li>
<li><a href='#Laplacian.norm-methods'><p> Laplacian graph normalization</p></a></li>
<li><a href='#Magnify.binary.features.norm-methods'><p> Normalization of binary matrices</p></a></li>
<li><a href='#Max.Min.norm-methods'><p> Max-min graph normalization</p></a></li>
<li><a href='#Prob.norm-methods'><p> Probabilistic normalization of a graph</p></a></li>
<li><a href='#Sparsify.matrix-methods'><p>Sparsifying the graph</p></a></li>
<li><a href='#Sparsify.matrix.fixed.neighbours-methods'><p>Sparsifying the graph by a fixed number of edges per node</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Network Pre-Processing and Normalization</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-14</td>
</tr>
<tr>
<td>Author:</td>
<td>Giorgio Valentini [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Giorgio Valentini &lt;valentini@di.unimi.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Network Pre-Processing and normalization. Methods for normalizing graphs, including Chua normalization, Laplacian normalization, Binary magnification, min-max normalization and others. Methods to sparsify adjacency matrices. Methods for graph pre-processing and for filtering edges of the graph.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>graph</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bionetdata</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-16 16:36:46 UTC; valenti</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-19 11:06:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='NetPreProc-package'> NetPreProc </h2><span id='topic+NetPreProc-package'></span>

<h3>Description</h3>

<p>Network Pre-Processing and normalization. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> NetPreProc</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-09-14</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> methods</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;">  graph</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;">  bionedata</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Network Pre-Processing and normalization. Methods for normalizing graphs, including Chua normalization, Laplacian normalization, Binary magnification, min-max normalization and oters. Methods to sparsify adjacency matrices. Methods for graph pre-processing and for filtering edges of the graph.
</p>


<h3>Author(s)</h3>

<p>Giorgio Valentini &ndash; Universita' degli Studi di Milano
</p>
<p>Maintainer: Giorgio Valentini&lt;valentini@di.unimi.it&gt;
</p>

<hr>
<h2 id='Binary.matrix.by.thresh-methods'> Transforming a real-valued network matrix into a binary matrix </h2><span id='topic+Binary.matrix.by.thresh+2Cgraph-method'></span><span id='topic+Binary.matrix.by.thresh+2Cmatrix-method'></span><span id='topic+Binary.matrix.by.thresh'></span>

<h3>Description</h3>

<p>Methods to transform a a real-valued network matrix into a binary matrix.
The binary matrix is obtained by thresholding: values above the given threshold are set to 1, otherwise to 0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Binary.matrix.by.thresh(W, thresh=0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Binary.matrix.by.thresh-methods_+3A_w">W</code></td>
<td>

<p>an object representing the graph to be normalized
</p>
</td></tr>
<tr><td><code id="Binary.matrix.by.thresh-methods_+3A_thresh">thresh</code></td>
<td>

<p>the threshold (def.=0.5)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The normalized binary adjacency matrix of the network
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(W = "graph")</code></dt><dd>
<p>an object of the virtual class graph (hence including objects of class <code><a href="graph.html#topic+graphAM-class">graphAM</a></code>  and <code><a href="graph.html#topic+graphNEL-class">graphNEL</a></code> from the package <span class="pkg">graph</span>)
</p>
</dd>
<dt><code>signature(W = "matrix")</code></dt><dd>
<p>a matrix representing the adjacency matrix of the graph
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>library(bionetdata);
data(DD.chem.data);
W &lt;- Binary.matrix.by.thresh(DD.chem.data);

# Using both methods with both signatures "matrix" and "graph"
# reducing dimension of the graph
library(graph);
DD.chem.data.red &lt;- DD.chem.data[1:100,1:100];
W.red &lt;- Binary.matrix.by.thresh(DD.chem.data.red);
g &lt;- new("graphAM", adjMat=DD.chem.data.red, values=list(weight=DD.chem.data.red));
Wg &lt;- Binary.matrix.by.thresh(g);
any(W.red!=Wg);
</code></pre>

<hr>
<h2 id='check.network-methods'> Graph checking </h2><span id='topic+check.network+2Cgraph-method'></span><span id='topic+check.network+2Cmatrix-method'></span><span id='topic+check.network'></span>

<h3>Description</h3>

<p>Method to check the characteristics of a graph.
Check if its adjacency matrix is symmetric, if it has NA, NaN o Inf values, and some minimals 
statistics about nodes and edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.network(W, name="Network matrix")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.network-methods_+3A_w">W</code></td>
<td>

<p>an object representing the graph to be checked
</p>
</td></tr>
<tr><td><code id="check.network-methods_+3A_name">name</code></td>
<td>

<p>a character vector that will be printed as heading
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It return a list of strings about the characteristics of the graph
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(W = "graph")</code></dt><dd>
<p>an object of the virtual class graph (hence including objects of class <code><a href="graph.html#topic+graphAM-class">graphAM</a></code>  and <code><a href="graph.html#topic+graphNEL-class">graphNEL</a></code> from the package <span class="pkg">graph</span>)
</p>
</dd>
<dt><code>signature(W = "matrix")</code></dt><dd>
<p>a matrix representing the adjacency matrix of the graph
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>library(bionetdata);
data(DD.chem.data);
check.network(DD.chem.data);
W &lt;- Prob.norm(DD.chem.data);
check.network(W, "prob. transition matrix");
WL &lt;- Laplacian.norm(DD.chem.data);
check.network(WL, "Laplacian norm. matrix");

library(graph)
g1 = randomEGraph(LETTERS[1:15], edges = 40);
check.network(g1, "random graph");
</code></pre>

<hr>
<h2 id='Chua.norm-methods'> Chua normalization </h2><span id='topic+Chua.norm+2Cgraph-method'></span><span id='topic+Chua.norm+2Cmatrix-method'></span><span id='topic+Chua.norm'></span>

<h3>Description</h3>

<p>Normalization of graphs according to Chua et al., 2007. 
The normalized weigths  between nodes are computed by taking into account their neighborhoods.
This normalization is meaningful in particular with interaction data.
More precisely, the normalized weigth <code class="reqn">W_{ij}</code> between nodes <code class="reqn">i</code> and <code class="reqn">j</code> is computed by taking into account their neighborhods <code class="reqn">N_i</code> and <code class="reqn">N_j</code> :
</p>
<p style="text-align: center;"><code class="reqn">W_{ij} = \frac{2|N_i \cap N_j|}{|N_i \setminus N_j| + 2|N_i \cap N_j| + 1}\times \frac{2|N_i \cap N_j|}{|N_j \setminus N_i| + 2|N_i \cap N_j| + 1}</code>
</p>

<p>where <code class="reqn">N_k</code> is the set of the neighbors of gene <code class="reqn">k</code> (<code class="reqn">k</code> is included).   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Chua.norm(W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Chua.norm-methods_+3A_w">W</code></td>
<td>

<p>an object representing the graph to be normalized
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The normalized adjacency matrix of the network
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(W = "graph")</code></dt><dd>
<p>an object of the virtual class graph (hence including objects of class <code><a href="graph.html#topic+graphAM-class">graphAM</a></code>  and <code><a href="graph.html#topic+graphNEL-class">graphNEL</a></code> from the package <span class="pkg">graph</span>)
</p>
</dd>
<dt><code>signature(W = "matrix")</code></dt><dd>
<p>a matrix representing the adjacency matrix of the graph
</p>
</dd>
</dl>


<h3>References</h3>

<p>Chua, H., Sung, W., &amp; Wong, L. An efficient strategy for extensive
integration of diverse biological data for protein function prediction. Bioinformatics, 23 , 3364&ndash;3373, 2007.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(bionetdata);
data(Yeast.Biogrid.data);
W &lt;- Chua.norm(Yeast.Biogrid.data);
</code></pre>

<hr>
<h2 id='Do.sim.matrix.Pearson'> Construction of the Pearson correlation matrix </h2><span id='topic+Do.sim.matrix.Pearson'></span>

<h3>Description</h3>

<p>Function to obtain the Pearson correlation matrix between rows of a given matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Do.sim.matrix.Pearson(M, cut = TRUE, remove.negatives = TRUE, min.thresh = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Do.sim.matrix.Pearson_+3A_m">M</code></td>
<td>

<p>input matrix
</p>
</td></tr>
<tr><td><code id="Do.sim.matrix.Pearson_+3A_cut">cut</code></td>
<td>

<p>if TRUE (def.) at least one edge is maintained for each node, all the other edges are set to 0. If false
no edgeis set to 0.
</p>
</td></tr>
<tr><td><code id="Do.sim.matrix.Pearson_+3A_remove.negatives">remove.negatives</code></td>
<td>

<p>if TRUE (def) negative values are replaced with 0 in the correlation matrix
</p>
</td></tr>
<tr><td><code id="Do.sim.matrix.Pearson_+3A_min.thresh">min.thresh</code></td>
<td>

<p>minimum allowed threshold (def. 0).
If a threshold lower than min.thresh is selected, thanit is substituted by min.thresh. 
Warning: setting min.thresh to large values may lead to highly disconneted network
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>You can also &quot;sparsify&quot; the matrix, by putting to 0 all the weights, by setting a threshold
such that at least one edge is maintained for each node.
The diagonal values are set to 0.
</p>


<h3>Value</h3>

<p>a square symmetric matrix of the Pearson correlation coefficients 
computed between the rows of M
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a gaussian random matrix
D &lt;- matrix(rnorm(20000),nrow=200);
W &lt;- Do.sim.matrix.Pearson (D);
# the same without default parameters
W2 &lt;- Do.sim.matrix.Pearson (D, cut=FALSE, remove.negatives=FALSE, min.thresh=-20);
</code></pre>

<hr>
<h2 id='Laplacian.norm-methods'> Laplacian graph normalization </h2><span id='topic+Laplacian.norm+2Cgraph-method'></span><span id='topic+Laplacian.norm+2Cmatrix-method'></span><span id='topic+Laplacian.norm'></span>

<h3>Description</h3>

<p>Methods to normalize weights of square symmetric adjacency matrices.
A network matrix is normalized by dividing each entry <code class="reqn">W_{ij}</code> by the square root of the product of the sum of elements of row <code class="reqn">i</code> and the sum of the elemnts in column <code class="reqn">j</code>.
In other words if <code class="reqn">D</code> is a diagonal matrix such that <code class="reqn">D_{ii} = \sum_j W_{ij}</code>, then the normalize matrix is: 
</p>
<p style="text-align: center;"><code class="reqn">
W_{norm} = D^{-1/2}  W  D^{-1/2}
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>Laplacian.norm(W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Laplacian.norm-methods_+3A_w">W</code></td>
<td>

<p>an object representing the graph to be normalized
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The normalized adjacency matrix of the network
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(W = "graph")</code></dt><dd>
<p>an object of the virtual class graph (hence including objects of class <code><a href="graph.html#topic+graphAM-class">graphAM</a></code>  and <code><a href="graph.html#topic+graphNEL-class">graphNEL</a></code> from the package <span class="pkg">graph</span>)
</p>
</dd>
<dt><code>signature(W = "matrix")</code></dt><dd>
<p>a matrix representing the adjacency matrix of the graph
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>library(bionetdata);
# normalization of drug-drug similarity networks
data(DD.chem.data);
W &lt;- Laplacian.norm(DD.chem.data);
# the same using an object of class graphAM
g &lt;- new("graphAM", adjMat=DD.chem.data, values=list(weight=DD.chem.data));
Wg &lt;- Laplacian.norm(g);
</code></pre>

<hr>
<h2 id='Magnify.binary.features.norm-methods'> Normalization of binary matrices </h2><span id='topic+Magnify.binary.features.norm+2Cmatrix-method'></span><span id='topic+Magnify.binary.features.norm'></span>

<h3>Description</h3>

<p>Normalization of binary matrices according to the procedure described in Mostafavi et al. 2008.
Having a binary matrix M, for each feature, if b is the proportion of 1, then ones are replaced with -log(b) and zeros with log(1-b).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Magnify.binary.features.norm(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Magnify.binary.features.norm-methods_+3A_m">M</code></td>
<td>

<p>an object representing the matrix to be normalized
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The normalized  matrix 
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(M = "matrix")</code></dt><dd>
<p>Input binary matrix. Rows are examples, columns features
</p>
</dd>
</dl>


<h3>References</h3>

<p>Mostafavi, S., Ray, D., Warde-Farley, D., Grouios, C., &amp; Morris, Q.
GeneMANIA: a real-time multiple association network integration algorithm
for predicting gene function. Genome Biology, 9, 2008.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D &lt;- matrix(ifelse(runif(40000)&gt;0.9,1,0),nrow=100);
M &lt;- Magnify.binary.features.norm(D);
</code></pre>

<hr>
<h2 id='Max.Min.norm-methods'> Max-min graph normalization </h2><span id='topic+Max.Min.norm+2Cgraph-method'></span><span id='topic+Max.Min.norm+2Cmatrix-method'></span><span id='topic+Max.Min.norm'></span>

<h3>Description</h3>

<p>Graph normalization with respect to the minimum and maximum value of its weights.
Each entry of the normalized matrix is in the range <code class="reqn">[0..1]</code>:
</p>
<p style="text-align: center;"><code class="reqn">W_{norm} = \frac{(W - \min(W))}{(\max(W)-\min(W))}</code>
</p>
 


<h3>Usage</h3>

<pre><code class='language-R'>Max.Min.norm(W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Max.Min.norm-methods_+3A_w">W</code></td>
<td>

<p>an object representing the graph to be normalized
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The normalized adjacency matrix of the network
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(W = "graph")</code></dt><dd>
<p>an object of the virtual class graph (hence including objects of class <code><a href="graph.html#topic+graphAM-class">graphAM</a></code>  and <code><a href="graph.html#topic+graphNEL-class">graphNEL</a></code> from the package <span class="pkg">graph</span>)
</p>
</dd>
<dt><code>signature(W = "matrix")</code></dt><dd>
<p>a matrix representing the adjacency matrix of the graph
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>library(bionetdata);
# max-min normalization for a drug-drug similarity network
data(DD.chem.data);
W &lt;- Max.Min.norm(DD.chem.data);
# the same using an object of class graphAM 

g &lt;- new("graphAM", adjMat=DD.chem.data, values=list(weight=DD.chem.data));
Wg &lt;- Max.Min.norm(g);
</code></pre>

<hr>
<h2 id='Prob.norm-methods'> Probabilistic normalization of a graph </h2><span id='topic+Prob.norm+2Cgraph-method'></span><span id='topic+Prob.norm+2Cmatrix-method'></span><span id='topic+Prob.norm'></span>

<h3>Description</h3>

<p>Method to compute the transition probability matrix of network.
A network matrix is normalized by dividing each entry <code class="reqn">W_{ij}</code> by the the sum of elements of row <code class="reqn">i</code> 
In other words if <code class="reqn">D</code> is a diagonal matrix such that <code class="reqn">D_{ii} = \sum_j W_{ij}</code> then the normalize matrix is: 
</p>
<p style="text-align: center;"><code class="reqn">
W_{norm} = D^{-1}  W 
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>Prob.norm(W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Prob.norm-methods_+3A_w">W</code></td>
<td>

<p>an object representing the graph to be normalized
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The normalized transition probability matrix of network
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(W = "graph")</code></dt><dd>
<p>an object of the virtual class graph (hence including objects of class <code><a href="graph.html#topic+graphAM-class">graphAM</a></code>  and <code><a href="graph.html#topic+graphNEL-class">graphNEL</a></code> from the package <span class="pkg">graph</span>)
</p>
</dd>
<dt><code>signature(W = "matrix")</code></dt><dd>
<p>a matrix representing the adjacency matrix of the graph
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>library(bionetdata);
# making transition prob matrix for a drug-drug similarity network
data(DD.chem.data);
W &lt;- Prob.norm(DD.chem.data);
# the same using an object of class graphAM and of class graphNEL

g &lt;- new("graphAM", adjMat=DD.chem.data, values=list(weight=DD.chem.data));
Wg &lt;- Prob.norm(g);
g2 &lt;- as(g, "graphNEL");
Wg2 &lt;- Prob.norm(g2);
</code></pre>

<hr>
<h2 id='Sparsify.matrix-methods'>Sparsifying the graph</h2><span id='topic+Sparsify.matrix+2Cgraph-method'></span><span id='topic+Sparsify.matrix+2Cmatrix-method'></span><span id='topic+Sparsify.matrix'></span>

<h3>Description</h3>

<p>Methods to sparsify a network matrix.
By this method a general threshold is et such that you  a minimum of k edges is guranteed for each node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sparsify.matrix(W, k=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sparsify.matrix-methods_+3A_w">W</code></td>
<td>

<p>an object representing the graph to be sparsified
</p>
</td></tr>
<tr><td><code id="Sparsify.matrix-methods_+3A_k">k</code></td>
<td>

<p>the number of guaranteed edges for each node (def.=1)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sparsified adjacency matrix of the network
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(W = "graph")</code></dt><dd>
<p>an object of the virtual class graph (hence including objects of class <code><a href="graph.html#topic+graphAM-class">graphAM</a></code>  and <code><a href="graph.html#topic+graphNEL-class">graphNEL</a></code> from the package <span class="pkg">graph</span>)
</p>
</dd>
<dt><code>signature(W = "matrix")</code></dt><dd>
<p>a matrix representing the adjacency matrix of the graph
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>library(bionetdata);
data(FIN.data);
W &lt;- Laplacian.norm(as.matrix(FIN.data));
# sparsification by maintaining at least one neighbour per node 
W1 &lt;- Sparsify.matrix(W);
# sparsification by maintaining at least 20 neighbours per node (if any)
W20 &lt;- Sparsify.matrix(W, k=20);

</code></pre>

<hr>
<h2 id='Sparsify.matrix.fixed.neighbours-methods'>Sparsifying the graph by a fixed number of edges per node</h2><span id='topic+Sparsify.matrix.fixed.neighbours+2Cgraph-method'></span><span id='topic+Sparsify.matrix.fixed.neighbours+2Cmatrix-method'></span><span id='topic+Sparsify.matrix.fixed.neighbours'></span>

<h3>Description</h3>

<p>Methods to sparsify a network matrix by fixing the number of edges for each node.
It selects the first k neighbours for each node (by row) according to the weight of the edge
By this function you select exactly k edges for each node (if there are at least k edges in the adjacency matrix).
The resulting matrix is not symmetric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sparsify.matrix.fixed.neighbours(W, k=10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sparsify.matrix.fixed.neighbours-methods_+3A_w">W</code></td>
<td>

<p>an object representing the graph to be normalized
</p>
</td></tr>
<tr><td><code id="Sparsify.matrix.fixed.neighbours-methods_+3A_k">k</code></td>
<td>

<p>the number of  edges for each node (def.=10)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sparsified matrix (Warning: the matrix is not symmetric)
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(W = "graph")</code></dt><dd>
<p>an object of the virtual class graph (hence including objects of class <code><a href="graph.html#topic+graphAM-class">graphAM</a></code>  and <code><a href="graph.html#topic+graphNEL-class">graphNEL</a></code> from the package <span class="pkg">graph</span>)
</p>
</dd>
<dt><code>signature(W = "matrix")</code></dt><dd>
<p>a matrix representing the adjacency matrix of the graph
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>library(bionetdata);
data(FIN.data);
W &lt;- Laplacian.norm(as.matrix(FIN.data));
# sparsification with 10 neighbours per node 
W10 &lt;- Sparsify.matrix.fixed.neighbours(W);
# sparsification with 20 neighbours per node 
W20 &lt;- Sparsify.matrix.fixed.neighbours(W, k=20);
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
