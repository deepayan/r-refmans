<!DOCTYPE html><html><head><title>Help for package eha</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eha}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#eha-package'><p>eha: Event History Analysis</p></a></li>
<li><a href='#aftreg'><p>Accelerated Failure Time Regression</p></a></li>
<li><a href='#aftreg.fit'><p>Parametric proportional hazards regression</p></a></li>
<li><a href='#age.window'><p>Age cut of survival data</p></a></li>
<li><a href='#cal.window'><p>Calendar time cut of survival data</p></a></li>
<li><a href='#check.dist'><p>Graphical goodness-of-fit test</p></a></li>
<li><a href='#check.surv'><p>Check the integrity of survival data.</p></a></li>
<li><a href='#child'><p>Child mortality, Skellefteå, Sweeden 1850&ndash;1900.</p></a></li>
<li><a href='#compHaz'><p>Graphical comparison of cumulative hazards</p></a></li>
<li><a href='#coxfunk'><p>Loglihood function (partial likelihood) of a Cox regression</p></a></li>
<li><a href='#coxreg'><p>Cox regression</p></a></li>
<li><a href='#coxreg.fit'><p>Cox regression</p></a></li>
<li><a href='#coxreg2'><p>Cox regression</p></a></li>
<li><a href='#cro'><p>Creates a minimal representation of a data frame.</p></a></li>
<li><a href='#EV'><p>The EV Distribution</p></a></li>
<li><a href='#fert'><p>Marital fertility nineteenth century</p></a></li>
<li><a href='#frail.fit'><p>Frailty experiment</p></a></li>
<li><a href='#geome.fit'><p>Constant intensity discrete time proportional hazards</p></a></li>
<li><a href='#Gompertz'><p>The Gompertz Distribution</p></a></li>
<li><a href='#hazards'><p>Get baseline hazards atoms from fits from</p></a></li>
<li><a href='#HiscoHisclass'><p>HISCO to HISCLASS transformation</p></a></li>
<li><a href='#import_strata'><p><code>strata</code> function imported from <code>survival</code></p></a></li>
<li><a href='#import_Surv'><p><code>Surv</code> function imported from <code>survival</code></p></a></li>
<li><a href='#infants'><p>Infant mortality and maternal death, Sweeden 1821&ndash;1894.</p></a></li>
<li><a href='#join.spells'><p>Straighten up a survival data frame</p></a></li>
<li><a href='#Loglogistic'><p>The Loglogistic Distribution</p></a></li>
<li><a href='#Lognormal'><p>The Lognormal Distribution</p></a></li>
<li><a href='#logrank'><p>The Log-rank test</p></a></li>
<li><a href='#logrye'>
<p>Rye prices, Scania, southern Sweden, 1801-1894.</p></a></li>
<li><a href='#ltx'><p>LaTeX printing of regression results.</p></a></li>
<li><a href='#ltx2'><p>LaTeX alternative printing of regression results.</p></a></li>
<li><a href='#make.communal'><p>Put communals in &quot;fixed&quot; data frame</p></a></li>
<li><a href='#makeham'><p>The Gompertz-Makeham Distribution</p></a></li>
<li><a href='#male.mortality'><p>Male mortality in ages 40-60, nineteenth century</p></a></li>
<li><a href='#mlreg'><p>ML proportional hazards regression</p></a></li>
<li><a href='#mort'><p>Male mortality in ages 40-60, nineteenth century</p></a></li>
<li><a href='#oe'><p>Create an oe object</p></a></li>
<li><a href='#oldmort'>
<p>Old age mortality, Sundsvall, Sweden, 1860-1880.</p></a></li>
<li><a href='#Pch'><p>The Piecewise Constant Hazards distribution.</p></a></li>
<li><a href='#pchreg'><p>Piecewise Constant Proportional Hazards Regression</p></a></li>
<li><a href='#perstat'><p>Period statistics</p></a></li>
<li><a href='#phfunc'><p>Loglihood function of a proportional hazards regression</p></a></li>
<li><a href='#phreg'><p>Parametric Proportional Hazards Regression</p></a></li>
<li><a href='#phreg.fit'><p>Parametric proportional hazards regression</p></a></li>
<li><a href='#piecewise'><p>Piecewise hazards</p></a></li>
<li><a href='#plot.aftreg'><p>Plots output from an AFT regression</p></a></li>
<li><a href='#plot.coxreg'><p>Plot method for <code>coxreg</code> objects</p></a></li>
<li><a href='#plot.hazdata'><p>Plots of hazdata objects.</p></a></li>
<li><a href='#plot.logrank'><p>Plots of hazdata objects.</p></a></li>
<li><a href='#plot.phreg'><p>Plots output from a phreg regression</p></a></li>
<li><a href='#plot.tpchreg'><p>Plots output from a tpchreg regression</p></a></li>
<li><a href='#plot.weibreg'><p>Plots output from a Weibull regression</p></a></li>
<li><a href='#plotHaz'><p>Graphical comparing of cumulative hazards</p></a></li>
<li><a href='#print.aftreg'><p>Prints aftreg objects</p></a></li>
<li><a href='#print.coxreg'><p>Prints coxreg objects</p></a></li>
<li><a href='#print.logrank'><p>Prints logrank objects</p></a></li>
<li><a href='#print.phreg'><p>Prints phreg objects</p></a></li>
<li><a href='#print.risksets'><p>Prints a summary of the content of a set of risk sets.</p></a></li>
<li><a href='#print.summary.aftreg'><p>Prints summary.aftreg objects</p></a></li>
<li><a href='#print.summary.coxreg'><p>Prints summary.coxreg objects</p></a></li>
<li><a href='#print.summary.phreg'><p>Prints summary.phreg objects</p></a></li>
<li><a href='#print.summary.tpchreg'><p>Prints summary.tpchreg objects</p></a></li>
<li><a href='#print.tpchreg'><p>Prints tpchreg objects</p></a></li>
<li><a href='#print.weibreg'><p>Prints weibreg objects</p></a></li>
<li><a href='#regtable'><p>Retrieves regression tables</p></a></li>
<li><a href='#risksets'><p>Finds the compositions and sizes of risk sets</p></a></li>
<li><a href='#scania'>
<p>Old age mortality, Scania, southern Sweden, 1813-1894.</p></a></li>
<li><a href='#summary.aftreg'><p>Prints aftreg objects</p></a></li>
<li><a href='#summary.coxreg'><p>A summary of coxreg objects.</p></a></li>
<li><a href='#summary.phreg'><p>A summary of phreg objects.</p></a></li>
<li><a href='#summary.tpchreg'><p>Summary for tpchreg objects</p></a></li>
<li><a href='#summary.weibreg'><p>Prints a weibreg object</p></a></li>
<li><a href='#SurvSplit'><p>Split a survival object at specified durations.</p></a></li>
<li><a href='#swedeaths'>
<p>Swedish death data, 1969-2020.</p></a></li>
<li><a href='#swepop'>
<p>Swedish population data, 1969-2020.</p></a></li>
<li><a href='#table.events'><p>Calculating failure times, risk set sizes and No. of events in each risk set</p></a></li>
<li><a href='#toBinary'><p>Transforms a &quot;survival&quot; data frame into a data frame suitable for binary</p>
(logistic) regression</a></li>
<li><a href='#toDate'><p>Convert time in years since &quot;0000-01-01&quot; to a date.</p></a></li>
<li><a href='#toTime'><p>Calculate duration in years from &quot;0000-01-01&quot; to a given date</p></a></li>
<li><a href='#toTpch'><p>Transform survival data to tabular form</p></a></li>
<li><a href='#tpchreg'><p>Proportional hazards regression with piecewise constant hazards and tabular</p>
data.</a></li>
<li><a href='#weibreg'><p>Weibull Regression</p></a></li>
<li><a href='#weibreg.fit'><p>Weibull regression</p></a></li>
<li><a href='#Weibull'><p>The (Cumulative) Hazard Function of a Weibull Distribution</p></a></li>
<li><a href='#wfunk'><p>Loglihood function of a Weibull regression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Version:</td>
<td>2.11.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Event History Analysis</td>
</tr>
<tr>
<td>Description:</td>
<td>Parametric proportional hazards fitting with left truncation and
        right censoring for common families of distributions, piecewise constant 
        hazards, and discrete models. Parametric accelerated failure time models
        for left truncated and right censored data. Proportional hazards
        models for tabular and register data. Sampling of risk sets in Cox 
        regression, selections in the Lexis diagram, bootstrapping. 
        Broström (2022) &lt;<a href="https://doi.org/10.1201%2F9780429503764">doi:10.1201/9780429503764</a>&gt;.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/goranbrostrom/eha/issues">https://github.com/goranbrostrom/eha/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ehar.se/r/eha/">https://ehar.se/r/eha/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, survival (&ge; 3.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Göran Broström &lt;goran.brostrom@umu.se&gt;</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, bookdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, utils</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-08 17:00:00 UTC; gobr0002</td>
</tr>
<tr>
<td>Author:</td>
<td>Göran Broström [aut, cre],
  Jianming Jin [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-08 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='eha-package'>eha: Event History Analysis</h2><span id='topic+eha'></span><span id='topic+eha-package'></span>

<h3>Description</h3>

<p>Parametric proportional hazards fitting with left truncation and right censoring for common families of distributions, piecewise constant hazards, and discrete models. Parametric accelerated failure time models for left truncated and right censored data. Proportional hazards models for tabular and register data. Sampling of risk sets in Cox regression, selections in the Lexis diagram, bootstrapping. Broström (2022) <a href="https://doi.org/10.1201/9780429503764">doi:10.1201/9780429503764</a>.
</p>


<h3>Details</h3>

<p>Eha enhances the recommended <span class="pkg">survival</span> package in several ways, 
see the description. The main applications in mind are demography and 
epidemiology. For standard Cox regression analysis the function 
<code><a href="survival.html#topic+coxph">coxph</a></code> in <span class="pkg">survival</span> is still recommended. The function 
<code><a href="#topic+coxreg">coxreg</a></code> in <span class="pkg">eha</span> in fact calls coxph for the standard kind 
of analyses.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Göran Broström <a href="mailto:goran.brostrom@umu.se">goran.brostrom@umu.se</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Jianming Jin [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Broström, G. (2012). <em>Event History Analysis with R</em>, Chapman and Hall/CRC 
Press, Boca Raton, FL.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://ehar.se/r/eha/">https://ehar.se/r/eha/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/goranbrostrom/eha/issues">https://github.com/goranbrostrom/eha/issues</a>
</p>
</li></ul>


<hr>
<h2 id='aftreg'>Accelerated Failure Time Regression</h2><span id='topic+aftreg'></span>

<h3>Description</h3>

<p>The accelerated failure time model with parametric baseline hazard(s).
Allows for stratification with different scale and shape in each stratum,
and left truncated and right censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aftreg(
  formula = formula(data),
  data = parent.frame(),
  na.action = getOption("na.action"),
  dist = "weibull",
  init,
  shape = 0,
  id,
  param = c("lifeAcc", "lifeExp"),
  control = list(eps = 1e-08, maxiter = 20, trace = FALSE),
  singular.ok = TRUE,
  model = FALSE,
  x = FALSE,
  y = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aftreg_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a ~
operator, and the terms on the right.  The response must be a survival
object as returned by the Surv function.</p>
</td></tr>
<tr><td><code id="aftreg_+3A_data">data</code></td>
<td>
<p>a data.frame in which to interpret the variables named in the
formula.</p>
</td></tr>
<tr><td><code id="aftreg_+3A_na.action">na.action</code></td>
<td>
<p>a missing-data filter function, applied to the model.frame,
after any subset argument has been used.  Default is
<code>options()$na.action</code>.</p>
</td></tr>
<tr><td><code id="aftreg_+3A_dist">dist</code></td>
<td>
<p>Which distribution? Default is &quot;weibull&quot;, with the alternatives
&quot;gompertz&quot;, &quot;ev&quot;, &quot;loglogistic&quot; and &quot;lognormal&quot;. A special case like the
<code>exponential</code> can be obtained by choosing &quot;weibull&quot; in combination with
<code>shape = 1</code>.</p>
</td></tr>
<tr><td><code id="aftreg_+3A_init">init</code></td>
<td>
<p>vector of initial values of the iteration.  Default initial
value is zero for all variables.</p>
</td></tr>
<tr><td><code id="aftreg_+3A_shape">shape</code></td>
<td>
<p>If positive, the shape parameter is fixed at that value.  If
zero or negative, the shape parameter is estimated. Stratification is now
regarded as a meaningful option even if <code>shape</code> is fixed.</p>
</td></tr>
<tr><td><code id="aftreg_+3A_id">id</code></td>
<td>
<p>If there are more than one spell per individual, it is essential
to keep spells together by the id argument. This allows for time-varying
covariates.</p>
</td></tr>
<tr><td><code id="aftreg_+3A_param">param</code></td>
<td>
<p>Which parametrization should be used? The <code>lifeAcc</code> uses
the parametrization given in the vignette, while the <code>lifeExp</code> uses the
same as in the <code><a href="survival.html#topic+survreg">survreg</a></code> function.</p>
</td></tr>
<tr><td><code id="aftreg_+3A_control">control</code></td>
<td>
<p>a list with components <code>eps</code> (convergence criterion),
<code>maxiter</code> (maximum number of iterations), and <code>trace</code> (logical,
debug output if <code>TRUE</code>).  You can change any component without mention
the other(s).</p>
</td></tr>
<tr><td><code id="aftreg_+3A_singular.ok">singular.ok</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="aftreg_+3A_model">model</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="aftreg_+3A_x">x</code></td>
<td>
<p>Return the design matrix in the model object?</p>
</td></tr>
<tr><td><code id="aftreg_+3A_y">y</code></td>
<td>
<p>Return the response in the model object?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameterization is different from the one used by
<code><a href="survival.html#topic+survreg">survreg</a></code>, when <code>param = "lifeAcc"</code>. The result
is then true acceleration of time. Then the model is 
</p>
<p style="text-align: center;"><code class="reqn">S(t; a, b, \beta, z) = S_0((t / \exp(b - z\beta))^{\exp(a)})</code>
</p>

<p>where <code class="reqn">S_0</code> is some standardized
survivor function. The baseline parameters <code class="reqn">a</code> and <code class="reqn">b</code> are log shape
and log scale, respectively. This is for the <code>default</code> parametrization.
With the <code>lifeExp</code> parametrization, some signs are changed: </p>
<p style="text-align: center;"><code class="reqn">b - z
beta</code>
</p>
<p> is changed to </p>
<p style="text-align: center;"><code class="reqn">b + z beta</code>
</p>
<p>. For the Gompertz distribution, the
base parametrization is <code>canonical</code>, a necessity for consistency with
the shape/scale paradigm (this is new in 2.3).
</p>


<h3>Value</h3>

<p>A list of class <code>"aftreg"</code> with components
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>Fitted parameter estimates.</p>
</td></tr> <tr><td><code>var</code></td>
<td>
<p>Covariance
matrix of the estimates.</p>
</td></tr> <tr><td><code>loglik</code></td>
<td>
<p>Vector of length two; first
component is the value at the initial parameter values, the second componet
is the maximized value.</p>
</td></tr> <tr><td><code>score</code></td>
<td>
<p>The score test statistic (at the
initial value).</p>
</td></tr> <tr><td><code>linear.predictors</code></td>
<td>
<p>The estimated linear predictors.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>Means of the columns of the design matrix.</p>
</td></tr>
<tr><td><code>w.means</code></td>
<td>
<p>Weighted (against exposure time) means of covariates;
weighted relative frequencies of levels of factors.</p>
</td></tr> <tr><td><code>n</code></td>
<td>
<p>Number of
spells in indata (possibly after removal of cases with NA's).</p>
</td></tr>
<tr><td><code>n.events</code></td>
<td>
<p>Number of events in data.</p>
</td></tr> <tr><td><code>terms</code></td>
<td>
<p>Used by extractor
functions.</p>
</td></tr> <tr><td><code>assign</code></td>
<td>
<p>Used by extractor functions.</p>
</td></tr> 
<tr><td><code>wald.test</code></td>
<td>
<p>The Wald test statistic (at the initial value).</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The Surv vector.</p>
</td></tr> <tr><td><code>isF</code></td>
<td>
<p>Logical vector indicating the
covariates that are factors.</p>
</td></tr> <tr><td><code>covars</code></td>
<td>
<p>The covariates.</p>
</td></tr>
<tr><td><code>ttr</code></td>
<td>
<p>Total Time at Risk.</p>
</td></tr> <tr><td><code>levels</code></td>
<td>
<p>List of levels of factors.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The calling formula.</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>The call.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method.</p>
</td></tr> <tr><td><code>convergence</code></td>
<td>
<p>Did the optimization
converge?</p>
</td></tr> <tr><td><code>fail</code></td>
<td>
<p>Did the optimization fail? (Is <code>NULL</code> if not).</p>
</td></tr>
<tr><td><code>pfixed</code></td>
<td>
<p>TRUE if shape was fixed in the estimation.</p>
</td></tr> <tr><td><code>param</code></td>
<td>
<p>The
parametrization.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxreg">coxreg</a></code>, <code><a href="#topic+phreg">phreg</a></code>,
<code><a href="survival.html#topic+survreg">survreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mort)
aftreg(Surv(enter, exit, event) ~ ses, param = "lifeExp", data = mort)

</code></pre>

<hr>
<h2 id='aftreg.fit'>Parametric proportional hazards regression</h2><span id='topic+aftreg.fit'></span>

<h3>Description</h3>

<p>This function is called by <code><a href="#topic+aftreg">aftreg</a></code>, but it can also be directly
called by a user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aftreg.fit(X, Y, dist, param, strata, offset, init, shape, id, control, pfixed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aftreg.fit_+3A_x">X</code></td>
<td>
<p>The design (covariate) matrix.</p>
</td></tr>
<tr><td><code id="aftreg.fit_+3A_y">Y</code></td>
<td>
<p>A survival object, the response.</p>
</td></tr>
<tr><td><code id="aftreg.fit_+3A_dist">dist</code></td>
<td>
<p>Which baseline distribution?</p>
</td></tr>
<tr><td><code id="aftreg.fit_+3A_param">param</code></td>
<td>
<p>Which parametrization?</p>
</td></tr>
<tr><td><code id="aftreg.fit_+3A_strata">strata</code></td>
<td>
<p>A stratum variable.</p>
</td></tr>
<tr><td><code id="aftreg.fit_+3A_offset">offset</code></td>
<td>
<p>Offset.</p>
</td></tr>
<tr><td><code id="aftreg.fit_+3A_init">init</code></td>
<td>
<p>Initial regression parameter values.</p>
</td></tr>
<tr><td><code id="aftreg.fit_+3A_shape">shape</code></td>
<td>
<p>If positive, a fixed value of the shape parameter in the
distribution. Otherwise, the shape is estimated.</p>
</td></tr>
<tr><td><code id="aftreg.fit_+3A_id">id</code></td>
<td>
<p>See corresponding argument to <code><a href="#topic+aftreg">aftreg</a></code>.</p>
</td></tr>
<tr><td><code id="aftreg.fit_+3A_control">control</code></td>
<td>
<p>Controls convergence and output.</p>
</td></tr>
<tr><td><code id="aftreg.fit_+3A_pfixed">pfixed</code></td>
<td>
<p>A logical indicating fixed shape parameter(s).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+aftreg">aftreg</a></code> for more detail.
</p>


<h3>Value</h3>

<table>
<tr><td><code>coefficients</code></td>
<td>
<p>Estimated regression coefficients plus estimated
scale and shape coefficients, sorted by strata, if present.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom; No. of regression parameters.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>Variance-covariance matrix</p>
</td></tr> 
<tr><td><code>loglik</code></td>
<td>
<p>Vector of length 2. The
first component is the maximized loglihood with only scale and shape in the
model, the second the final maximum.</p>
</td></tr> 
<tr><td><code>conver</code></td>
<td>
<p>TRUE if convergence</p>
</td></tr> 
<tr><td><code>fail</code></td>
<td>
<p>TRUE if failure</p>
</td></tr> 
<tr><td><code>iter</code></td>
<td>
<p>Number of Newton-Raphson iterates.</p>
</td></tr> 
<tr><td><code>n.strata</code></td>
<td>
<p>The number of strata in the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aftreg">aftreg</a></code>
</p>

<hr>
<h2 id='age.window'>Age cut of survival data</h2><span id='topic+age.window'></span>

<h3>Description</h3>

<p>For a given age interval, each spell is cut to fit into the given age
interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age.window(dat, window, surv = c("enter", "exit", "event"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="age.window_+3A_dat">dat</code></td>
<td>
<p>Input data frame. Must contain survival data.</p>
</td></tr>
<tr><td><code id="age.window_+3A_window">window</code></td>
<td>
<p>Vector of length two; the age interval.</p>
</td></tr>
<tr><td><code id="age.window_+3A_surv">surv</code></td>
<td>
<p>Vector of length three giving the names of the central variables
in 'dat'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>window</code> must be in the order <code>(begin, end)</code>
</p>


<h3>Value</h3>

<p>A data frame of the same form as the input data frame, but 'cut' as
desired. Intervals exceeding <code>window[2]</code> will be given <code>event = 0</code>.
If the selection gives an empty result, <code>NULL</code> is returned, with no warning.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cal.window">cal.window</a></code>, <code><a href="#topic+coxreg">coxreg</a></code>,
<code><a href="#topic+aftreg">aftreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- data.frame(enter = 0, exit = 5.731, event = 1, x = 2)
window &lt;- c(2, 5.3)
dat.trim &lt;- age.window(dat, window)  

</code></pre>

<hr>
<h2 id='cal.window'>Calendar time cut of survival data</h2><span id='topic+cal.window'></span>

<h3>Description</h3>

<p>For a given time interval, each spell is cut so that it fully lies in the
given time interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal.window(dat, window, surv = c("enter", "exit", "event", "birthdate"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cal.window_+3A_dat">dat</code></td>
<td>
<p>Input data frame. Must contain survival data and a birth date.</p>
</td></tr>
<tr><td><code id="cal.window_+3A_window">window</code></td>
<td>
<p>Vector of length two; the time interval</p>
</td></tr>
<tr><td><code id="cal.window_+3A_surv">surv</code></td>
<td>
<p>Vector of length four giving the names of the central variables
in 'dat'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>window</code> must be in the order <code>(begin, end)</code>
</p>


<h3>Value</h3>

<p>A data frame of the same form as the input data frame, but 'cut' as
desired. Intervals exceeding <code>window[2]</code> will be given <code>event = 0</code>
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+age.window">age.window</a></code>, <code><a href="#topic+coxreg">coxreg</a></code>,
<code><a href="#topic+aftreg">aftreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- data.frame(enter = 0, exit = 5.731, event = 1,
birthdate = 1962.505, x = 2)
window &lt;- c(1963, 1965)
dat.trim &lt;- cal.window(dat, window)  

</code></pre>

<hr>
<h2 id='check.dist'>Graphical goodness-of-fit test</h2><span id='topic+check.dist'></span>

<h3>Description</h3>

<p>Comparison of the cumulative hazards functions for a semi-parametric and a
parametric model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.dist(sp, pp, main = NULL, col = 1:2, lty = 1:2, printLegend = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.dist_+3A_sp">sp</code></td>
<td>
<p>An object of type &quot;coxreg&quot;, typically output from
<code><a href="#topic+coxreg">coxreg</a></code></p>
</td></tr>
<tr><td><code id="check.dist_+3A_pp">pp</code></td>
<td>
<p>An object of type &quot;phreg&quot;, typically output from
<code><a href="#topic+phreg">phreg</a></code></p>
</td></tr>
<tr><td><code id="check.dist_+3A_main">main</code></td>
<td>
<p>Header for the plot. Default is distribution and &quot;cumulative
hazard function&quot;</p>
</td></tr>
<tr><td><code id="check.dist_+3A_col">col</code></td>
<td>
<p>Line colors. should be <code>NULL</code> (black lines) or of length 2</p>
</td></tr>
<tr><td><code id="check.dist_+3A_lty">lty</code></td>
<td>
<p>line types.</p>
</td></tr>
<tr><td><code id="check.dist_+3A_printlegend">printLegend</code></td>
<td>
<p>Should a legend be printed? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the moment only a graphical comparison. The arguments <code>sp</code> and
<code>pp</code> may be swapped.
</p>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxreg">coxreg</a></code> and <code><a href="#topic+phreg">phreg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mort)
oldpar &lt;- par(mfrow = c(2, 2))
fit.cr &lt;- coxreg(Surv(enter, exit, event) ~ ses, data = mort)
fit.w &lt;- phreg(Surv(enter, exit, event) ~ ses, data = mort)
fit.g &lt;- phreg(Surv(enter, exit, event) ~ ses, data = mort,
dist = "gompertz")
fit.ev &lt;- phreg(Surv(enter, exit, event) ~ ses, data = mort,
dist = "ev")
check.dist(fit.cr, fit.w)
check.dist(fit.cr, fit.g)
check.dist(fit.cr, fit.ev)
par(oldpar)

</code></pre>

<hr>
<h2 id='check.surv'>Check the integrity of survival data.</h2><span id='topic+check.surv'></span>

<h3>Description</h3>

<p>Check that exit occurs after enter, that spells from an individual do not
overlap, and that each individual experiences at most one event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.surv(enter, exit, event, id = NULL, eps = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.surv_+3A_enter">enter</code></td>
<td>
<p>Left truncation time.</p>
</td></tr>
<tr><td><code id="check.surv_+3A_exit">exit</code></td>
<td>
<p>Time of exit.</p>
</td></tr>
<tr><td><code id="check.surv_+3A_event">event</code></td>
<td>
<p>Indicator of event. Zero means 'no event'.</p>
</td></tr>
<tr><td><code id="check.surv_+3A_id">id</code></td>
<td>
<p>Identification of individuals.</p>
</td></tr>
<tr><td><code id="check.surv_+3A_eps">eps</code></td>
<td>
<p>The smallest allowed spell length or overlap.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Interval lengths must be strictly positive.
</p>


<h3>Value</h3>

<p>A vector of id's for the insane individuals. Of zero length if no
errors.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+join.spells">join.spells</a></code>, <code><a href="#topic+coxreg">coxreg</a></code>,
<code><a href="#topic+aftreg">aftreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
xx &lt;- data.frame(enter = c(0, 1), exit = c(1.5, 3), event = c(0, 1), id =
c(1,1))
check.surv(xx$enter, xx$exit, xx$event, xx$id)

</code></pre>

<hr>
<h2 id='child'>Child mortality, Skellefteå, Sweeden 1850&ndash;1900.</h2><span id='topic+child'></span>

<h3>Description</h3>

<p>Children born in Skellefteå, Sweden, 1850-1884, are followed 
fifteen years or until death or out-migration.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(child)</code></pre>


<h3>Format</h3>

<p>A data frame with 26855 children born 1850-1884.
</p>

<dl>
<dt><code>id</code></dt><dd><p>An identification number.</p>
</dd>
<dt><code>m.id</code></dt><dd><p>Mother's id.</p>
</dd>
<dt><code>sex</code></dt><dd><p>Sex.</p>
</dd>
<dt><code>socBranch</code></dt><dd><p>Working branch of family (father).</p>
</dd>
<dt><code>birthdate</code></dt><dd><p>Birthdate.</p>
</dd>
<dt><code>enter</code></dt><dd><p>Start age of follow-up, always zero.</p>
</dd>
<dt><code>exit</code></dt><dd><p>Age of departure, either by death or emigration.</p>
</dd>
<dt><code>event</code></dt><dd><p>Type of departure, death = 1, right censoring = 0.</p>
</dd>
<dt><code>illeg</code></dt><dd><p>Born out of marriage (&quot;illegitimate&quot;)?</p>
</dd>
<dt><code>m.age</code></dt><dd><p>Mother's age.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The Skellefteå region is a large region in the northern part of Sweden.
</p>


<h3>Source</h3>

<p>Data originate from the Centre for Demographic and Ageing Research, 
Umeå University, Umeå, Sweden,
<a href="https://www.umu.se/en/centre-for-demographic-and-ageing-research/">https://www.umu.se/en/centre-for-demographic-and-ageing-research/</a>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- coxreg(Surv(enter, exit, event) ~ sex + socBranch, data = child, coxph = TRUE)
summary(fit)
</code></pre>

<hr>
<h2 id='compHaz'>Graphical comparison of cumulative hazards</h2><span id='topic+compHaz'></span>

<h3>Description</h3>

<p>Comparison of the estimated baseline cumulative hazards functions for two survival models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compHaz(
  fit1,
  fit2,
  main = NULL,
  lty = 1:2,
  col = c("red", "blue"),
  printLegend = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compHaz_+3A_fit1">fit1</code></td>
<td>
<p>An object of type &quot;coxreg&quot;, &quot;phreg&quot;, or other output from
from survival fitters.</p>
</td></tr>
<tr><td><code id="compHaz_+3A_fit2">fit2</code></td>
<td>
<p>An object of type &quot;coxreg&quot;, &quot;phreg&quot;, or other output from
survival fitters.</p>
</td></tr>
<tr><td><code id="compHaz_+3A_main">main</code></td>
<td>
<p>Header for the plot. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="compHaz_+3A_lty">lty</code></td>
<td>
<p>line types.</p>
</td></tr>
<tr><td><code id="compHaz_+3A_col">col</code></td>
<td>
<p>Line colors. should be <code>NULL</code> (black lines) or of length 2.</p>
</td></tr>
<tr><td><code id="compHaz_+3A_printlegend">printLegend</code></td>
<td>
<p>Should a legend be printed? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hazards">hazards</a></code>, <code><a href="#topic+coxreg">coxreg</a></code>, and <code><a href="#topic+phreg">phreg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fit.cr &lt;- coxreg(Surv(enter, exit, event) ~ sex, data = oldmort)
fit.w &lt;- phreg(Surv(enter, exit, event) ~ sex, data = oldmort)
compHaz(fit.cr, fit.w)
</code></pre>

<hr>
<h2 id='coxfunk'>Loglihood function (partial likelihood) of a Cox regression</h2><span id='topic+coxfunk'></span>

<h3>Description</h3>

<p>Calculates minus the log likelihood function and its first and second order
derivatives for data from a Cox regression model. It is used by <code>coxreg</code>
if the argument <code>coxph = FALSE</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxfunk(beta, X, offset, rs, what = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxfunk_+3A_beta">beta</code></td>
<td>
<p>Regression parameters</p>
</td></tr>
<tr><td><code id="coxfunk_+3A_x">X</code></td>
<td>
<p>The design (covariate) matrix.</p>
</td></tr>
<tr><td><code id="coxfunk_+3A_offset">offset</code></td>
<td>
<p>Offset.</p>
</td></tr>
<tr><td><code id="coxfunk_+3A_rs">rs</code></td>
<td>
<p>Risk set created by <code>risksets(..., collate_sets = TRUE)</code></p>
</td></tr>
<tr><td><code id="coxfunk_+3A_what">what</code></td>
<td>
<p>what = 0 means only loglihood, 1 means score vector as well, 2
loglihood, score and hessian.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the function returns log likelihood, score vector and minus
hessian, i.e. the observed information. The model is
</p>


<h3>Value</h3>

<p>A list with components 
</p>
<table>
<tr><td><code>loglik</code></td>
<td>
<p>The log likelihood.</p>
</td></tr>
<tr><td><code>dloglik</code></td>
<td>
<p>The score vector. Nonzero if <code>what &gt;= 1</code></p>
</td></tr>
<tr><td><code>d2loglik</code></td>
<td>
<p>The hessian. Nonzero if <code>ord &gt;= 2</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxreg">coxreg</a></code>
</p>

<hr>
<h2 id='coxreg'>Cox regression</h2><span id='topic+coxreg'></span>

<h3>Description</h3>

<p>Performs Cox regression with some special attractions, especially
<em>sampling of risksets</em> and <em>the weird bootstrap</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxreg(formula = formula(data), data = parent.frame(), weights,
subset, t.offset, na.action = getOption("na.action"), init = NULL, method =
c("efron", "breslow", "mppl", "ml"), control = list(eps = 1e-08, maxiter =
25, trace = FALSE), singular.ok = TRUE, model = FALSE, center = NULL, x =
FALSE, y = TRUE, hazards = NULL, boot = FALSE, efrac = 0, geometric = FALSE,
rs = NULL, frailty = NULL, max.survs = NULL, coxph = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxreg_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a ~
operator, and the terms on the right. The response must be a survival object
as returned by the Surv function.</p>
</td></tr>
<tr><td><code id="coxreg_+3A_data">data</code></td>
<td>
<p>a data.frame in which to interpret the variables named in the
formula.</p>
</td></tr>
<tr><td><code id="coxreg_+3A_weights">weights</code></td>
<td>
<p>Case weights; time-fixed or time-varying.</p>
</td></tr>
<tr><td><code id="coxreg_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="coxreg_+3A_t.offset">t.offset</code></td>
<td>
<p>Case offsets; time-varying.</p>
</td></tr>
<tr><td><code id="coxreg_+3A_na.action">na.action</code></td>
<td>
<p>a missing-data filter function, applied to the model.frame,
after any subset argument has been used.  Default is
<code>options()$na.action</code>.</p>
</td></tr>
<tr><td><code id="coxreg_+3A_init">init</code></td>
<td>
<p>vector of initial values of the iteration.  Default initial
value is zero for all variables.</p>
</td></tr>
<tr><td><code id="coxreg_+3A_method">method</code></td>
<td>
<p>Method of treating ties, &quot;efron&quot; (default), &quot;breslow&quot;, &quot;mppl&quot;
(maximum partial partial likelihood), or &quot;ml&quot; (maximum likelihood).</p>
</td></tr>
<tr><td><code id="coxreg_+3A_control">control</code></td>
<td>
<p>a list with components <code>eps</code> (convergence criterion),
<code>maxiter</code> (maximum number of iterations), and <code>silent</code> (logical,
controlling amount of output). You can change any component without mention
the other(s).</p>
</td></tr>
<tr><td><code id="coxreg_+3A_singular.ok">singular.ok</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="coxreg_+3A_model">model</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="coxreg_+3A_center">center</code></td>
<td>
<p>deprecated. See Details.</p>
</td></tr>
<tr><td><code id="coxreg_+3A_x">x</code></td>
<td>
<p>Return the design matrix in the model object?</p>
</td></tr>
<tr><td><code id="coxreg_+3A_y">y</code></td>
<td>
<p>return the response in the model object?</p>
</td></tr>
<tr><td><code id="coxreg_+3A_hazards">hazards</code></td>
<td>
<p>deprecated. Was: Calculate baseline hazards? Default is TRUE.
Calculating hazards is better done separately, after fitting. In most cases.</p>
</td></tr>
<tr><td><code id="coxreg_+3A_boot">boot</code></td>
<td>
<p>Number of boot replicates. Defaults to FALSE, no boot samples.</p>
</td></tr>
<tr><td><code id="coxreg_+3A_efrac">efrac</code></td>
<td>
<p>Upper limit of fraction failures in 'mppl'.</p>
</td></tr>
<tr><td><code id="coxreg_+3A_geometric">geometric</code></td>
<td>
<p>If TRUE, forces an 'ml' model with constant riskset
probability. Default is FALSE.</p>
</td></tr>
<tr><td><code id="coxreg_+3A_rs">rs</code></td>
<td>
<p>Risk set?</p>
</td></tr>
<tr><td><code id="coxreg_+3A_frailty">frailty</code></td>
<td>
<p>Grouping variable for frailty analysis. Not in use (yet).</p>
</td></tr>
<tr><td><code id="coxreg_+3A_max.survs">max.survs</code></td>
<td>
<p>Sampling of risk sets? If given, it should be (the upper
limit of) the number of survivors in each risk set.</p>
</td></tr>
<tr><td><code id="coxreg_+3A_coxph">coxph</code></td>
<td>
<p>Logical, defaults to <code>TRUE</code>. Determines if standard work
should be passed to <code><a href="survival.html#topic+coxph">coxph</a></code> via entry points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default method, <code>efron</code>, and the alternative, <code>breslow</code>, are
both the same as in <code><a href="survival.html#topic+coxph">coxph</a></code> in package
<code>survival</code>. The methods <code>mppl</code> and <code>ml</code> are maximum
likelihood, discrete-model, based.
</p>


<h3>Value</h3>

<p>A list of class <code>c("coxreg", "coxph")</code> with components
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>Fitted parameter estimates.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>Covariance matrix of the estimates.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Vector of length two; first component is the value at
the initial parameter values, the second component
is the maximized value.</p>
</td></tr>
<tr><td><code>score</code></td>
<td>
<p>The score test statistic (at the initial value).</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>The estimated linear predictors.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The martingale residuals.</p>
</td></tr>
<tr><td><code>hazards</code></td>
<td>
<p>The estimated baseline hazards, calculated at the value zero of
the covariates (rather, columns of the design matrix). Is a list,
with one component per stratum. Each
component is a matrix with two columns, the first contains risk times, the
second the corresponding hazard atom.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>Means of the columns of
the design matrix corresponding to covariates, if <code>center = TRUE</code>.
Columns corresponding to factor levels gice a zero in the corresponding
position in <code>means</code>. If <code>center = FALSE</code>, <code>means</code> are all
zero.</p>
</td></tr>
<tr><td><code>w.means</code></td>
<td>
<p>Weighted (against exposure time) means of covariates;
weighted relative frequencies of levels of factors.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of spells in indata (possibly after removal of cases
with NA's).</p>
</td></tr>
<tr><td><code>n.events</code></td>
<td>
<p>Number of events in data.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>Used by extractor functions.</p>
</td></tr>
<tr><td><code>assign</code></td>
<td>
<p>Used by extractor functions.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The Surv vector.</p>
</td></tr>
<tr><td><code>isF</code></td>
<td>
<p>Logical vector indicating the covariates that are factors.</p>
</td></tr>
<tr><td><code>covars</code></td>
<td>
<p>The covariates.</p>
</td></tr>
<tr><td><code>ttr</code></td>
<td>
<p>Total Time at Risk.</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>List of levels of factors.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The calling formula.</p>
</td></tr>
<tr><td><code>bootstrap</code></td>
<td>
<p>The (matrix of) bootstrap replicates, if requested on
input. It is up to the user to do
whatever desirable with this sample.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method.</p>
</td></tr>
<tr><td><code>n.strata</code></td>
<td>
<p>Number of strata.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>Did the optimization converge?</p>
</td></tr>
<tr><td><code>fail</code></td>
<td>
<p>Did the optimization fail? (Is <code>NULL</code> if not).</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The use of <code>rs</code> is dangerous, see note. It can
however speed up computing time considerably for huge data sets.
</p>


<h3>Note</h3>

<p>This function starts by creating risksets, if no riskset is supplied
via <code>rs</code>, with the aid of <code><a href="#topic+risksets">risksets</a></code>. Supplying output from
<code>risksets</code> via <code>rs</code> fails if there are any NA's in the data! Note
also that it depends on stratification, so <code>rs</code> contains information
about stratification. Giving another strata variable in the formula is an
error. The same is ok, for instance to supply stratum interactions.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>References</h3>

<p>Broström, G. and Lindkvist, M. (2008). Partial partial
likelihood. Communications in Statistics: Simulation and Computation 37:4,
679-686.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+coxph">coxph</a></code>, <code><a href="#topic+risksets">risksets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 dat &lt;- data.frame(time=  c(4, 3,1,1,2,2,3),
                status=c(1,1,1,0,1,1,0),
                x=     c(0, 2,1,1,1,0,0),
                sex=   c(0, 0,0,0,1,1,1))
 coxreg( Surv(time, status) ~ x + strata(sex), data = dat) #stratified model
 # Same as:
 rs &lt;- risksets(Surv(dat$time, dat$status), strata = dat$sex)
 coxreg( Surv(time, status) ~ x, data = dat, rs = rs) #stratified model
 
</code></pre>

<hr>
<h2 id='coxreg.fit'>Cox regression</h2><span id='topic+coxreg.fit'></span>

<h3>Description</h3>

<p>Called by <code><a href="#topic+coxreg">coxreg</a></code>, but a user can call it directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxreg.fit(
  X,
  Y,
  rs,
  weights,
  t.offset = NULL,
  strats,
  offset,
  init,
  max.survs,
  method = "efron",
  boot = FALSE,
  efrac = 0,
  calc.martres = TRUE,
  control,
  verbose = TRUE,
  calc.hazards = NULL,
  center = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxreg.fit_+3A_x">X</code></td>
<td>
<p>The design matrix.</p>
</td></tr>
<tr><td><code id="coxreg.fit_+3A_y">Y</code></td>
<td>
<p>The survival object.</p>
</td></tr>
<tr><td><code id="coxreg.fit_+3A_rs">rs</code></td>
<td>
<p>The risk set composition. If absent, calculated.</p>
</td></tr>
<tr><td><code id="coxreg.fit_+3A_weights">weights</code></td>
<td>
<p>Case weights; time-fixed or time-varying.</p>
</td></tr>
<tr><td><code id="coxreg.fit_+3A_t.offset">t.offset</code></td>
<td>
<p>Case offset; time-varying.</p>
</td></tr>
<tr><td><code id="coxreg.fit_+3A_strats">strats</code></td>
<td>
<p>The stratum variable. Can be absent.</p>
</td></tr>
<tr><td><code id="coxreg.fit_+3A_offset">offset</code></td>
<td>
<p>Offset. Can be absent.</p>
</td></tr>
<tr><td><code id="coxreg.fit_+3A_init">init</code></td>
<td>
<p>Start values. If absent, equal to zero.</p>
</td></tr>
<tr><td><code id="coxreg.fit_+3A_max.survs">max.survs</code></td>
<td>
<p>Sampling of risk sets? If so, gives the maximum number of
survivors in each risk set.</p>
</td></tr>
<tr><td><code id="coxreg.fit_+3A_method">method</code></td>
<td>
<p>Either &quot;efron&quot; (default) or &quot;breslow&quot;.</p>
</td></tr>
<tr><td><code id="coxreg.fit_+3A_boot">boot</code></td>
<td>
<p>Number of bootstrap replicates. Defaults to FALSE, no
bootstrapping.</p>
</td></tr>
<tr><td><code id="coxreg.fit_+3A_efrac">efrac</code></td>
<td>
<p>Upper limit of fraction failures in 'mppl'.</p>
</td></tr>
<tr><td><code id="coxreg.fit_+3A_calc.martres">calc.martres</code></td>
<td>
<p>Should martingale residuals be calculated?</p>
</td></tr>
<tr><td><code id="coxreg.fit_+3A_control">control</code></td>
<td>
<p>See <code><a href="#topic+coxreg">coxreg</a></code></p>
</td></tr>
<tr><td><code id="coxreg.fit_+3A_verbose">verbose</code></td>
<td>
<p>Should Warnings about convergence be printed?</p>
</td></tr>
<tr><td><code id="coxreg.fit_+3A_calc.hazards">calc.hazards</code></td>
<td>
<p>Deprecated. See <code><a href="#topic+coxreg">coxreg</a></code>.</p>
</td></tr>
<tr><td><code id="coxreg.fit_+3A_center">center</code></td>
<td>
<p>Deprecated. See <code><a href="#topic+coxreg">coxreg</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rs</code> is dangerous to use when NA's are present.
</p>


<h3>Value</h3>

<p>A list with components 
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>Estimated regression parameters.</p>
</td></tr> 
<tr><td><code>var</code></td>
<td>
<p>Covariance matrix of estimated coefficients.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>First component is value at <code>init</code>, second at maximum.</p>
</td></tr>
<tr><td><code>score</code></td>
<td>
<p>Score test statistic, at initial value.</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>Linear predictors.</p>
</td></tr> 
<tr><td><code>residuals</code></td>
<td>
<p>Martingale residuals.</p>
</td></tr> 
<tr><td><code>hazard</code></td>
<td>
<p>Estimated baseline hazard. At value zero of design variables.</p>
</td></tr> 
<tr><td><code>means</code></td>
<td>
<p>Means of the columns of the design matrix.</p>
</td></tr> 
<tr><td><code>bootstrap</code></td>
<td>
<p>The bootstrap replicates, if requested on input.</p>
</td></tr>
<tr><td><code>conver</code></td>
<td>
<p><code>TRUE</code> if convergence.</p>
</td></tr> 
<tr><td><code>f.conver</code></td>
<td>
<p>TRUE if variables converged.</p>
</td></tr> 
<tr><td><code>fail</code></td>
<td>
<p><code>TRUE</code> if failure.</p>
</td></tr> 
<tr><td><code>iter</code></td>
<td>
<p>Number of performed iterations.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It is the user's responsibility to check that indata is sane.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxreg">coxreg</a></code>, <code><a href="#topic+risksets">risksets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 X &lt;- as.matrix(data.frame(
                x=     c(0, 2,1,4,1,0,3),
                sex=   c(1, 0,0,0,1,1,1)))
 time &lt;- c(1,2,3,4,5,6,7)
 status &lt;- c(1,1,1,0,1,1,0)
 stratum &lt;- rep(1, length(time))

 coxreg.fit(X, Surv(time, status), strats = stratum, max.survs = 6,
     control = list(eps=1.e-4, maxiter = 10, trace = FALSE))

</code></pre>

<hr>
<h2 id='coxreg2'>Cox regression</h2><span id='topic+coxreg2'></span>

<h3>Description</h3>

<p>Performs Cox regression with some special attractions, especially
<em>sampling of risksets</em> and <em>the weird bootstrap</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxreg2(formula = formula(data), data = parent.frame(), weights,
subset, t.offset, na.action = getOption("na.action"), init = NULL, method =
c("efron", "breslow", "mppl", "ml"), control = list(eps = 1e-08, maxiter =
25, trace = FALSE), singular.ok = TRUE, model = FALSE, center = NULL, x =
FALSE, y = TRUE, hazards = NULL, boot = FALSE, efrac = 0, geometric = FALSE,
rs = NULL, frailty = NULL, max.survs = NULL, coxph = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxreg2_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a ~
operator, and the terms on the right. The response must be a survival object
as returned by the Surv function.</p>
</td></tr>
<tr><td><code id="coxreg2_+3A_data">data</code></td>
<td>
<p>a data.frame in which to interpret the variables named in the
formula.</p>
</td></tr>
<tr><td><code id="coxreg2_+3A_weights">weights</code></td>
<td>
<p>Case weights; time-fixed or time-varying.</p>
</td></tr>
<tr><td><code id="coxreg2_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="coxreg2_+3A_t.offset">t.offset</code></td>
<td>
<p>Case offsets; time-varying.</p>
</td></tr>
<tr><td><code id="coxreg2_+3A_na.action">na.action</code></td>
<td>
<p>a missing-data filter function, applied to the model.frame,
after any subset argument has been used.  Default is
<code>options()$na.action</code>.</p>
</td></tr>
<tr><td><code id="coxreg2_+3A_init">init</code></td>
<td>
<p>vector of initial values of the iteration.  Default initial
value is zero for all variables.</p>
</td></tr>
<tr><td><code id="coxreg2_+3A_method">method</code></td>
<td>
<p>Method of treating ties, &quot;efron&quot; (default), &quot;breslow&quot;, &quot;mppl&quot;
(maximum partial partial likelihood), or &quot;ml&quot; (maximum likelihood).</p>
</td></tr>
<tr><td><code id="coxreg2_+3A_control">control</code></td>
<td>
<p>a list with components <code>eps</code> (convergence criterion),
<code>maxiter</code> (maximum number of iterations), and <code>silent</code> (logical,
controlling amount of output). You can change any component without mention
the other(s).</p>
</td></tr>
<tr><td><code id="coxreg2_+3A_singular.ok">singular.ok</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="coxreg2_+3A_model">model</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="coxreg2_+3A_center">center</code></td>
<td>
<p>deprecated. See Details.</p>
</td></tr>
<tr><td><code id="coxreg2_+3A_x">x</code></td>
<td>
<p>Return the design matrix in the model object?</p>
</td></tr>
<tr><td><code id="coxreg2_+3A_y">y</code></td>
<td>
<p>return the response in the model object?</p>
</td></tr>
<tr><td><code id="coxreg2_+3A_hazards">hazards</code></td>
<td>
<p>deprecated. Was: Calculate baseline hazards? Default is TRUE.
Calculating hazards is better done separately, after fitting. In most cases.</p>
</td></tr>
<tr><td><code id="coxreg2_+3A_boot">boot</code></td>
<td>
<p>Number of boot replicates. Defaults to FALSE, no boot samples.</p>
</td></tr>
<tr><td><code id="coxreg2_+3A_efrac">efrac</code></td>
<td>
<p>Upper limit of fraction failures in 'mppl'.</p>
</td></tr>
<tr><td><code id="coxreg2_+3A_geometric">geometric</code></td>
<td>
<p>If TRUE, forces an 'ml' model with constant riskset
probability. Default is FALSE.</p>
</td></tr>
<tr><td><code id="coxreg2_+3A_rs">rs</code></td>
<td>
<p>Risk set?</p>
</td></tr>
<tr><td><code id="coxreg2_+3A_frailty">frailty</code></td>
<td>
<p>Grouping variable for frailty analysis. Not in use (yet).</p>
</td></tr>
<tr><td><code id="coxreg2_+3A_max.survs">max.survs</code></td>
<td>
<p>Sampling of risk sets? If given, it should be (the upper
limit of) the number of survivors in each risk set.</p>
</td></tr>
<tr><td><code id="coxreg2_+3A_coxph">coxph</code></td>
<td>
<p>Logical, defaults to <code>TRUE</code>. Determines if standard work
should be passed to <code><a href="survival.html#topic+coxph">coxph</a></code> via entry points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default method, <code>efron</code>, and the alternative, <code>breslow</code>, are
both the same as in <code><a href="survival.html#topic+coxph">coxph</a></code> in package
<code>survival</code>. The methods <code>mppl</code> and <code>ml</code> are maximum
likelihood, discrete-model, based.
</p>


<h3>Value</h3>

<p>A list of class <code>c("coxreg", "coxph")</code> with components
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>Fitted parameter estimates.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>Covariance matrix of the estimates.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Vector of length two; first component is the value at
the initial parameter values, the second component
is the maximized value.</p>
</td></tr>
<tr><td><code>score</code></td>
<td>
<p>The score test statistic (at the initial value).</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>The estimated linear predictors.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The martingale residuals.</p>
</td></tr>
<tr><td><code>hazards</code></td>
<td>
<p>The estimated baseline hazards, calculated at the value zero of
the covariates (rather, columns of the design matrix). Is a list,
with one component per stratum. Each
component is a matrix with two columns, the first contains risk times, the
second the corresponding hazard atom.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>Means of the columns of
the design matrix corresponding to covariates, if <code>center = TRUE</code>.
Columns corresponding to factor levels gice a zero in the corresponding
position in <code>means</code>. If <code>center = FALSE</code>, <code>means</code> are all
zero.</p>
</td></tr>
<tr><td><code>w.means</code></td>
<td>
<p>Weighted (against exposure time) means of covariates;
weighted relative frequencies of levels of factors.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of spells in indata (possibly after removal of cases
with NA's).</p>
</td></tr>
<tr><td><code>n.events</code></td>
<td>
<p>Number of events in data.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>Used by extractor functions.</p>
</td></tr>
<tr><td><code>assign</code></td>
<td>
<p>Used by extractor functions.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The Surv vector.</p>
</td></tr>
<tr><td><code>isF</code></td>
<td>
<p>Logical vector indicating the covariates that are factors.</p>
</td></tr>
<tr><td><code>covars</code></td>
<td>
<p>The covariates.</p>
</td></tr>
<tr><td><code>ttr</code></td>
<td>
<p>Total Time at Risk.</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>List of levels of factors.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The calling formula.</p>
</td></tr>
<tr><td><code>bootstrap</code></td>
<td>
<p>The (matrix of) bootstrap replicates, if requested on
input. It is up to the user to do
whatever desirable with this sample.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method.</p>
</td></tr>
<tr><td><code>n.strata</code></td>
<td>
<p>Number of strata.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>Did the optimization converge?</p>
</td></tr>
<tr><td><code>fail</code></td>
<td>
<p>Did the optimization fail? (Is <code>NULL</code> if not).</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The use of <code>rs</code> is dangerous, see note. It can
however speed up computing time considerably for huge data sets.
</p>


<h3>Note</h3>

<p>This function starts by creating risksets, if no riskset is supplied
via <code>rs</code>, with the aid of <code><a href="#topic+risksets">risksets</a></code>. Supplying output from
<code>risksets</code> via <code>rs</code> fails if there are any NA's in the data! Note
also that it depends on stratification, so <code>rs</code> contains information
about stratification. Giving another strata variable in the formula is an
error. The same is ok, for instance to supply stratum interactions.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>References</h3>

<p>Broström, G. and Lindkvist, M. (2008). Partial partial
likelihood. Communications in Statistics: Simulation and Computation 37:4,
679-686.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+coxph">coxph</a></code>, <code><a href="#topic+risksets">risksets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 dat &lt;- data.frame(time=  c(4, 3,1,1,2,2,3),
                status=c(1,1,1,0,1,1,0),
                x=     c(0, 2,1,1,1,0,0),
                sex=   c(0, 0,0,0,1,1,1))
 coxreg( Surv(time, status) ~ x + strata(sex), data = dat) #stratified model
 # Same as:
 rs &lt;- risksets(Surv(dat$time, dat$status), strata = dat$sex)
 coxreg( Surv(time, status) ~ x, data = dat, rs = rs) #stratified model
 
</code></pre>

<hr>
<h2 id='cro'>Creates a minimal representation of a data frame.</h2><span id='topic+cro'></span>

<h3>Description</h3>

<p>Given a data frame with a defined response variable, this function creates a
unique representation of the covariates in the data frame, vector (matrix)
of responses, and a pointer vector, connecting the responses with the
corresponding covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cro(dat, response = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cro_+3A_dat">dat</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="cro_+3A_response">response</code></td>
<td>
<p>The column(s) where the response resides.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rows in the data frame are converted to text strings with <code>paste</code>
and compared with <code>match</code>.
</p>


<h3>Value</h3>

<p>A list with components </p>
<table>
<tr><td><code>y</code></td>
<td>
<p>The response.</p>
</td></tr> <tr><td><code>covar</code></td>
<td>
<p>A data
frame with unique rows of covariates.</p>
</td></tr> <tr><td><code>keys</code></td>
<td>
<p>Pointers from <code>y</code> to
<code>covar</code>, connecting each response with its covariate vector.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is based on suggestions by Anne York and Brian Ripley.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+match">match</a></code>, <code><a href="base.html#topic+paste">paste</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- data.frame(y = c(1.1, 2.3, 0.7), x1 = c(1, 0, 1), x2 = c(0, 1, 0))
cro(dat)

</code></pre>

<hr>
<h2 id='EV'>The EV Distribution</h2><span id='topic+EV'></span><span id='topic+pEV'></span><span id='topic+dEV'></span><span id='topic+qEV'></span><span id='topic+hEV'></span><span id='topic+HEV'></span><span id='topic+rEV'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, hazard function,
cumulative hazard function, and random generation for the EV distribution
with parameters <code>shape</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dEV(x, shape = 1, scale = 1, log = FALSE) 
pEV(q, shape = 1, scale = 1, lower.tail = TRUE, log.p = FALSE) 
qEV(p, shape = 1, scale = 1, lower.tail = TRUE, log.p = FALSE) 
hEV(x, shape = 1, scale = 1, log = FALSE) 
HEV(x, shape = 1, scale = 1, log.p = FALSE) 
rEV(n, shape = 1, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EV_+3A_shape">shape</code>, <code id="EV_+3A_scale">scale</code></td>
<td>
<p>shape and scale parameters, both defaulting to 1.</p>
</td></tr>
<tr><td><code id="EV_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P(X \le
x)</code>, otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="EV_+3A_x">x</code>, <code id="EV_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="EV_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="EV_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="EV_+3A_log">log</code>, <code id="EV_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The EV distribution with <code>scale</code> parameter <code class="reqn">a</code> and <code>shape</code>
parameter <code class="reqn">\sigma</code> has hazard function given by </p>
<p style="text-align: center;"><code class="reqn">h(x) =
(b/\sigma)(x/\sigma)^(b-1)\exp((x / \sigma)^b)</code>
</p>
<p> for <code class="reqn">x \ge 0</code>.
</p>


<h3>Value</h3>

<p><code>dEV</code> gives the density, <code>pEV</code> gives the distribution
function, <code>qEV</code> gives the quantile function, <code>hEV</code> gives the
hazard function, <code>HEV</code> gives the cumulative hazard function, and
<code>rEV</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>

<hr>
<h2 id='fert'>Marital fertility nineteenth century</h2><span id='topic+fert'></span>

<h3>Description</h3>

<p>Birth intervals for married women with at least one birth, 19th northern
Sweden 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fert)</code></pre>


<h3>Format</h3>

<p>A data frame with 12169 observations the lengths (in years) of birth
intervals for 1859 married women with at least one birth. The first
interval (<code>parity = 0</code>) is the interval from marriage to first birth.
</p>

<dl>
<dt><code>id</code></dt><dd><p>Personal identification number for mother.</p>
</dd> 
<dt><code>parity</code></dt><dd><p>Time order of birth interval for the present
mother. The interval with <code>parity = 0</code> is the first, from
marriage to first birth.</p>
</dd>
<dt><code>age</code></dt><dd><p>The age of mother at start of interval.</p>
</dd>
<dt><code>year</code></dt><dd><p>The calendar year at start of interval.</p>
</dd>
<dt><code>next.ivl</code></dt><dd><p>The length of the coming time interval.</p>
</dd>
<dt><code>event</code></dt><dd><p>An indicator for whether the <code>next.ivl</code>
ends in a new birth (<code>event = 1</code>) or is right censored
(<code>event = 0</code>). Censoring occurs when the woman ends her
fertility period within her first marriage (marriage dissolution
or reaching the age of 48).</p>
</dd>
<dt><code>prev.ivl</code></dt><dd><p>The length of the previous time interval. May
be used as explanatory variable in a Cox regression of birth intervals.</p>
</dd>
<dt><code>ses</code></dt><dd><p>Socio-economic status, a factor with levels
<code>lower</code>, <code>upper</code>, <code>farmer</code>, and <code>unknown</code>.</p>
</dd>
<dt><code>parish</code></dt><dd><p>The Skelleftea region consists of three
parishes, Jorn, Norsjo, and Skelleftea.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data set contain clusters of dependent observations defined by
mother's id. 
</p>


<h3>Source</h3>

<p>Data is coming from The Demographic Data Base, Umea University, Umea, Sweden.
</p>


<h3>References</h3>

<p><a href="https://www.umu.se/enheten-for-demografi-och-aldrandeforskning/">https://www.umu.se/enheten-for-demografi-och-aldrandeforskning/</a>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fert)
fit &lt;- coxreg(Surv(next.ivl, event) ~ ses + prev.ivl, data = fert, subset =
(parity == 1))
summary(fit)
</code></pre>

<hr>
<h2 id='frail.fit'>Frailty experiment</h2><span id='topic+frail.fit'></span>

<h3>Description</h3>

<p>Utilizing GLMM models: Experimental, not exported (yet).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frail.fit(X, Y, rs, strats, offset, init, max.survs, frailty, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frail.fit_+3A_x">X</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="frail.fit_+3A_y">Y</code></td>
<td>
<p>survival object</p>
</td></tr>
<tr><td><code id="frail.fit_+3A_rs">rs</code></td>
<td>
<p>output from <code><a href="#topic+risksets">risksets</a></code></p>
</td></tr>
<tr><td><code id="frail.fit_+3A_strats">strats</code></td>
<td>
<p>strata</p>
</td></tr>
<tr><td><code id="frail.fit_+3A_offset">offset</code></td>
<td>
<p>offset</p>
</td></tr>
<tr><td><code id="frail.fit_+3A_init">init</code></td>
<td>
<p>start values</p>
</td></tr>
<tr><td><code id="frail.fit_+3A_max.survs">max.survs</code></td>
<td>
<p>for sampling of riskset survivors</p>
</td></tr>
<tr><td><code id="frail.fit_+3A_frailty">frailty</code></td>
<td>
<p>grouping variable</p>
</td></tr>
<tr><td><code id="frail.fit_+3A_control">control</code></td>
<td>
<p>control of optimization</p>
</td></tr>
</table>

<hr>
<h2 id='geome.fit'>Constant intensity discrete time proportional hazards</h2><span id='topic+geome.fit'></span>

<h3>Description</h3>

<p>This function is called from <code>coxreg</code>. A user may call it directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geome.fit(X, Y, rs, strats, offset, init, max.survs, method = "ml", control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geome.fit_+3A_x">X</code></td>
<td>
<p>The design matrix</p>
</td></tr>
<tr><td><code id="geome.fit_+3A_y">Y</code></td>
<td>
<p>Survival object</p>
</td></tr>
<tr><td><code id="geome.fit_+3A_rs">rs</code></td>
<td>
<p>risk set produced by <code><a href="#topic+risksets">risksets</a></code></p>
</td></tr>
<tr><td><code id="geome.fit_+3A_strats">strats</code></td>
<td>
<p>Stratum indicator</p>
</td></tr>
<tr><td><code id="geome.fit_+3A_offset">offset</code></td>
<td>
<p>Offset</p>
</td></tr>
<tr><td><code id="geome.fit_+3A_init">init</code></td>
<td>
<p>Initial values</p>
</td></tr>
<tr><td><code id="geome.fit_+3A_max.survs">max.survs</code></td>
<td>
<p>Maximal survivors</p>
</td></tr>
<tr><td><code id="geome.fit_+3A_method">method</code></td>
<td>
<p>&quot;ml&quot;, always, i.e., this argument is ignored.</p>
</td></tr>
<tr><td><code id="geome.fit_+3A_control">control</code></td>
<td>
<p>See <code>coxreg</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See the code.
</p>


<h3>Note</h3>

<p>Nothing special
</p>
<p><code>coxreg</code> is a defunct function
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>References</h3>

<p>See <code><a href="#topic+coxreg">coxreg</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxreg">coxreg</a></code>
</p>

<hr>
<h2 id='Gompertz'>The Gompertz Distribution</h2><span id='topic+Gompertz'></span><span id='topic+pgompertz'></span><span id='topic+gompertz'></span><span id='topic+dgompertz'></span><span id='topic+qgompertz'></span><span id='topic+hgompertz'></span><span id='topic+Hgompertz'></span><span id='topic+rgompertz'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, hazard function,
cumulative hazard function, and random generation for the Gompertz 
distribution with parameters <code>shape</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgompertz(x, shape = 1, scale = 1, rate, log = FALSE, 
param = c("default", "canonical", "rate")) 
pgompertz(q, shape = 1, scale = 1, rate, lower.tail = TRUE, log.p = FALSE, 
param = c("default", "canonical", "rate")) 
qgompertz(p, shape = 1, scale = 1, rate, lower.tail = TRUE, log.p = FALSE, 
param = c("default", "canonical", "rate")) 
hgompertz(x, shape = 1, scale = 1, rate, log = FALSE, 
param = c("default", "canonical", "rate")) 
Hgompertz(x, shape = 1, scale = 1, rate, log.p = FALSE, 
param = c("default", "canonical", "rate")) 
rgompertz(n, shape = 1, scale = 1, rate, 
param = c("default", "canonical", "rate"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gompertz_+3A_shape">shape</code>, <code id="Gompertz_+3A_scale">scale</code></td>
<td>
<p>shape and scale parameters, both defaulting to 1.</p>
</td></tr>
<tr><td><code id="Gompertz_+3A_rate">rate</code></td>
<td>
<p>the rate parameter for that parametrization, replaces scale.</p>
</td></tr>
<tr><td><code id="Gompertz_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P(X \le
x)</code>, otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="Gompertz_+3A_param">param</code></td>
<td>
<p>default or canonical or rate.</p>
</td></tr>
<tr><td><code id="Gompertz_+3A_x">x</code>, <code id="Gompertz_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Gompertz_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Gompertz_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="Gompertz_+3A_log">log</code>, <code id="Gompertz_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gompertz distribution with <code>scale</code> parameter <code class="reqn">a</code> and <code>shape</code>
parameter <code class="reqn">\sigma</code> has hazard function given by 
</p>
<p style="text-align: center;"><code class="reqn">h(x) = a \exp(x/\sigma)</code>
</p>

<p>for <code class="reqn">x \ge 0</code>.
If <code>param = "canonical"</code>, then then a &ndash;&gt; a/b, so that b is a
true scale parameter (for any fixed a), and b is an 'AFT parameter'.
If <code>param = "rate"</code>, then b &ndash;&gt; 1/b.
</p>


<h3>Value</h3>

<p><code>dgompertz</code> gives the density, <code>pgompertz</code> gives the distribution
function, <code>qgompertz</code> gives the quantile function, <code>hgompertz</code> gives the
hazard function, <code>Hgompertz</code> gives the cumulative hazard function, and
<code>rgompertz</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>

<hr>
<h2 id='hazards'>Get baseline hazards atoms from fits from</h2><span id='topic+hazards'></span>

<h3>Description</h3>

<p>Get baseline hazards atoms from fits from
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hazards(x, cum = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hazards_+3A_x">x</code></td>
<td>
<p>A <code>reg</code> object.</p>
</td></tr>
<tr><td><code id="hazards_+3A_cum">cum</code></td>
<td>
<p>Logical: Should the cumulative hazards be returned?</p>
</td></tr>
<tr><td><code id="hazards_+3A_...">...</code></td>
<td>
<p>Additional arguments for various methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list where each component is a two-column matrix representing
hazard atoms from one stratum. The first column is event time, and the 
second column is the corresponding hazard atom.
</p>

<hr>
<h2 id='HiscoHisclass'>HISCO to HISCLASS transformation</h2><span id='topic+HiscoHisclass'></span>

<h3>Description</h3>

<p>HISCO to HISCLASS transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HiscoHisclass(hisco, status = NULL, relation = NULL, urban = NULL,
debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HiscoHisclass_+3A_hisco">hisco</code></td>
<td>
<p>Hisco codes to be transformed to hisclass.</p>
</td></tr>
<tr><td><code id="HiscoHisclass_+3A_status">status</code></td>
<td>
<p>Optional standard description of status.</p>
</td></tr>
<tr><td><code id="HiscoHisclass_+3A_relation">relation</code></td>
<td>
<p>Relation between owner of occupation and self.</p>
</td></tr>
<tr><td><code id="HiscoHisclass_+3A_urban">urban</code></td>
<td>
<p>Logical, &quot;Is residence in an urban area?&quot;</p>
</td></tr>
<tr><td><code id="HiscoHisclass_+3A_debug">debug</code></td>
<td>
<p>Logical, prints intermediate values if TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of hisclass codes, same length as input hisco.
</p>


<h3>Author(s)</h3>

<p>Göran Broström with translation and modification of a Stata do.
</p>


<h3>References</h3>

<p>Van Leeuwen, M. and Maas, I. (2011). HISCLASS. A Historical
International Social Class Scheme. Leuwen University Press.
</p>

<hr>
<h2 id='import_strata'><code>strata</code> function imported from <code>survival</code></h2><span id='topic+import_strata'></span><span id='topic+strata'></span>

<h3>Description</h3>

<p>This function is imported from the <code>survival</code> package. See
<code><a href="survival.html#topic+strata">strata</a></code>.
</p>

<hr>
<h2 id='import_Surv'><code>Surv</code> function imported from <code>survival</code></h2><span id='topic+import_Surv'></span><span id='topic+Surv'></span>

<h3>Description</h3>

<p>This function is imported from the <code>survival</code> package. See
<code><a href="survival.html#topic+Surv">Surv</a></code>.
</p>

<hr>
<h2 id='infants'>Infant mortality and maternal death, Sweeden 1821&ndash;1894.</h2><span id='topic+infants'></span>

<h3>Description</h3>

<p>Matched data on infant mortality, from seven parishes in
Sweden, 1821&ndash;1894.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(infants)</code></pre>


<h3>Format</h3>

<p>A data frame with 80 rows and five variables.
</p>

<dl>
<dt><code>stratum</code></dt><dd><p>Triplet No. Each triplet consist of one infant
whose mother died (a case), and two controls, i.e, infants whose
mother did 
not die. Matched on covariates below.</p>
</dd> 
<dt><code>enter</code></dt><dd><p>Age (in days) of case when its mother died.</p>
</dd>
<dt><code>exit</code></dt><dd><p>Age (in days) at death or right censoring (at age
365 days).</p>
</dd>
<dt><code>event</code></dt><dd><p>Follow-up ends with death (1) or right censoring
(0).</p>
</dd>
<dt><code>mother</code></dt><dd><p><code>dead</code> for cases, <code>alive</code> for controls.</p>
</dd>
<dt><code>age</code></dt><dd><p>Mother's age at infant's birth.</p>
</dd>
<dt><code>sex</code></dt><dd><p>The infant's sex.</p>
</dd>
<dt><code>parish</code></dt><dd><p>Birth parish, either Nedertornea or not
Nedertornea.</p>
</dd>
<dt><code>civst</code></dt><dd><p>Civil status of mother, <code>married</code> or
<code>unmarried</code>.</p>
</dd>
<dt><code>ses</code></dt><dd><p>Socio-economic status of mother, either farmer or
not farmer.</p>
</dd>
<dt><code>year</code></dt><dd><p>Year of birth of the infant.</p>
</dd>
</dl>



<h3>Details</h3>

<p>From 5641 first-born in seven Swedish parishes 1820-1895, from Fleninge in the
very south to Nedertorneå in the very north, those whose mother died
during their first year of life were selected, in all 35 infants. To
each of them, two controls were selected by matching on the given covariates.
</p>


<h3>Source</h3>

<p>Data originate from The Demographic Data Base, Umeå University, Umeå, Sweden,
<a href="https://www.umu.se/enheten-for-demografi-och-aldrandeforskning/">https://www.umu.se/enheten-for-demografi-och-aldrandeforskning/</a>.</p>


<h3>References</h3>

<p>Broström, G. (1987). The influence of mother's death on infant
mortality: A case study in matched data survival analysis. Scandinavian
Journal of Statistics 14, 113-123.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(infants)
fit &lt;- coxreg(Surv(enter, exit, event) ~ strata(stratum) + mother, data
= infants)
fit
fit.w &lt;- phreg(Surv(enter, exit, event) ~ mother + parish + ses, data =
infants)
summary(fit.w) ## Weibull proportional hazards model.
</code></pre>

<hr>
<h2 id='join.spells'>Straighten up a survival data frame</h2><span id='topic+join.spells'></span>

<h3>Description</h3>

<p>Unnecessary cut spells are glued together, overlapping spells are
&quot;polished&quot;, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join.spells(dat, strict = FALSE, eps = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join.spells_+3A_dat">dat</code></td>
<td>
<p>A data frame with names enter, exit, event, id.</p>
</td></tr>
<tr><td><code id="join.spells_+3A_strict">strict</code></td>
<td>
<p>If TRUE, nothing is changed if errors in spells (non-positive
length, overlapping intervals, etc.) are detected. Otherwise (the default),
bad spells are removed, with &quot;earlier life&quot; having higher priority.</p>
</td></tr>
<tr><td><code id="join.spells_+3A_eps">eps</code></td>
<td>
<p>Tolerance for equality of two event times. Should be kept small.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of overlapping intervals (i.e., a data error), the appropriate id's
are returned if <code>strict</code> is <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A data frame with the same variables as the input, but individual
spells are joined, if possible (identical covariate values, and adjacent
time intervals).
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>References</h3>

<p>Therneau, T.M. and Grambsch, P.M. (2000). <em>Modeling
Survival Data: Extending the Cox model.</em> Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxreg">coxreg</a></code>, <code><a href="#topic+aftreg">aftreg</a></code>,
<code><a href="#topic+check.surv">check.surv</a></code>
</p>

<hr>
<h2 id='Loglogistic'>The Loglogistic Distribution</h2><span id='topic+Loglogistic'></span><span id='topic+pllogis'></span><span id='topic+Llogis'></span><span id='topic+dllogis'></span><span id='topic+qllogis'></span><span id='topic+hllogis'></span><span id='topic+Hllogis'></span><span id='topic+rllogis'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, hazard function,
cumulative hazard function, and random generation for the Loglogistic distribution
with parameters <code>shape</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dllogis(x, shape = 1, scale = 1, log = FALSE) 
pllogis(q, shape = 1, scale = 1, lower.tail = TRUE, log.p = FALSE) 
qllogis(p, shape = 1, scale = 1, lower.tail = TRUE, log.p = FALSE) 
hllogis(x, shape = 1, scale = 1, prop = 1, log = FALSE) 
Hllogis(x, shape = 1, scale = 1, prop = 1, log.p = FALSE) 
rllogis(n, shape = 1, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Loglogistic_+3A_shape">shape</code>, <code id="Loglogistic_+3A_scale">scale</code></td>
<td>
<p>shape and scale parameters, both defaulting to 1.</p>
</td></tr>
<tr><td><code id="Loglogistic_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P(X \le
x)</code>, otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="Loglogistic_+3A_x">x</code>, <code id="Loglogistic_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Loglogistic_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Loglogistic_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="Loglogistic_+3A_log">log</code>, <code id="Loglogistic_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Loglogistic_+3A_prop">prop</code></td>
<td>
<p>proportionality constant in the extended Loglogistic distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Loglogistic distribution with <code>scale</code> parameter <code class="reqn">a</code> and <code>shape</code>
parameter <code class="reqn">\sigma</code> has hazard function given by </p>
<p style="text-align: center;"><code class="reqn">h(x) =
(b/\sigma)(x/\sigma)^(b-1)\exp((x / \sigma)^b)</code>
</p>
<p> for <code class="reqn">x \ge 0</code>.
</p>


<h3>Value</h3>

<p><code>dllogis</code> gives the density, <code>pllogis</code> gives the distribution
function, <code>qllogis</code> gives the quantile function, <code>hllogis</code> gives the
hazard function, <code>Hllogis</code> gives the cumulative hazard function, and
<code>rllogis</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>

<hr>
<h2 id='Lognormal'>The Lognormal Distribution</h2><span id='topic+Lognormal'></span><span id='topic+hlnorm'></span><span id='topic+Lnorm'></span><span id='topic+dlnorm'></span><span id='topic+plnorm'></span><span id='topic+qlnorm'></span><span id='topic+Hlnorm'></span><span id='topic+rlnorm'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, hazard function,
cumulative hazard function, and random generation for the Lognormal distribution
with parameters <code>shape</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hlnorm(x, meanlog = 0, sdlog = 1, shape = 1 / sdlog, scale = exp(meanlog),
prop = 1, log = FALSE) 
Hlnorm(x, meanlog = 0, sdlog = 1, shape = 1 / sdlog, scale = exp(meanlog), 
prop = 1, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lognormal_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Lognormal_+3A_meanlog">meanlog</code></td>
<td>
<p>mean in the Normal distribution.</p>
</td></tr>
<tr><td><code id="Lognormal_+3A_sdlog">sdlog</code>, <code id="Lognormal_+3A_shape">shape</code></td>
<td>
<p>sdlog is standard deviation in the Normal distrimution, 
shape = 1/sdlog.</p>
</td></tr>
<tr><td><code id="Lognormal_+3A_scale">scale</code></td>
<td>
<p>is exp(meanlog).</p>
</td></tr>
<tr><td><code id="Lognormal_+3A_prop">prop</code></td>
<td>
<p>proportionality constant in the extended Lognormal distribution.</p>
</td></tr>
<tr><td><code id="Lognormal_+3A_log">log</code>, <code id="Lognormal_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Lognormal distribution with <code>scale</code> parameter <code class="reqn">a</code> and <code>shape</code>
parameter <code class="reqn">\sigma</code> has hazard function given by </p>
<p style="text-align: center;"><code class="reqn">h(x) =
(b/\sigma)(x/\sigma)^(b-1)\exp((x / \sigma)^b)</code>
</p>
<p> for <code class="reqn">x \ge 0</code>.
</p>


<h3>Value</h3>

<p><code>dlnorm</code> gives the density, <code>plnorm</code> gives the distribution
function, <code>qlnorm</code> gives the quantile function, <code>hlnorm</code> gives the
hazard function, <code>Hlnorm</code> gives the cumulative hazard function, and
<code>rlnorm</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>

<hr>
<h2 id='logrank'>The Log-rank test</h2><span id='topic+logrank'></span>

<h3>Description</h3>

<p>Performs the log-rank test on survival data, possibly stratified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logrank(Y, group, data = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logrank_+3A_y">Y</code></td>
<td>
<p>a survival object as returned by the <code><a href="#topic+Surv">Surv</a></code> function.</p>
</td></tr>
<tr><td><code id="logrank_+3A_group">group</code></td>
<td>
<p>defines the groups to be compared. Coerced to a factor.</p>
</td></tr>
<tr><td><code id="logrank_+3A_data">data</code></td>
<td>
<p>a data.frame in which to interpret the variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>logrank</code> with components
</p>
<table>
<tr><td><code>test.statistic</code></td>
<td>
<p>The logrank (score) test statistic.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The degrees of freedom of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The p value of the test.</p>
</td></tr>
<tr><td><code>hazards</code></td>
<td>
<p>A list of two-column matrices, describing event times and 
corresponding hazard atoms in each stratum (class 'hazdata').</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The test is performed by fitting a Cox regression model and reporting
its <code>score test</code>. With tied data, this might be slightly different from
the true logrank test, but the difference is unimportant in practice.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxreg">coxreg</a></code>, <code><a href="#topic+print.logrank">print.logrank</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- logrank(Y = Surv(enter, exit, event), group = civ, 
data = oldmort[oldmort$region == "town", ])
fit
</code></pre>

<hr>
<h2 id='logrye'>
Rye prices, Scania, southern Sweden, 1801-1894.
</h2><span id='topic+logrye'></span>

<h3>Description</h3>

<p>The data consists of yearly rye prices from 1801 to
1894. Logged and detrended, so the time series is supposed to measure
short term fluctuations in rye prices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(scania)</code></pre>


<h3>Format</h3>

<p>A data frame with 94 observations in two columns on the following 2 variables.
</p>

<dl>
<dt><code>year</code></dt><dd><p>The year the price is recorded.</p>
</dd>
<dt><code>foodprices</code></dt><dd><p>Detrended log rye prices.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The Scanian area in southern Sweden was during the 19th century a mainly
rural area. 
</p>


<h3>Source</h3>

<p>The Scanian Economic Demographic Database.
</p>


<h3>References</h3>

<p>Jörberg, L. (1972). A History of Prices in Sweden 1732-1914,
CWK Gleerup, Lund.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(logrye)
summary(logrye)
</code></pre>

<hr>
<h2 id='ltx'>LaTeX printing of regression results.</h2><span id='topic+ltx'></span>

<h3>Description</h3>

<p>This (generic) function prints the LaTeX code of the results of a fit from
<code><a href="#topic+coxreg">coxreg</a></code>, <code><a href="#topic+phreg">phreg</a></code>, <code><a href="#topic+tpchreg">tpchreg</a></code>, 
or <code><a href="#topic+aftreg">aftreg</a></code>, similar
to what <code>xtable</code> does for fits from other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltx(
  x,
  caption = NULL,
  label = NULL,
  dr = NULL,
  digits = max(options()$digits - 4, 3),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ltx_+3A_x">x</code></td>
<td>
<p>The output from a call to <code>coxreg</code>, <code>tpchreg</code>, or
<code>aftreg</code></p>
</td></tr>
<tr><td><code id="ltx_+3A_caption">caption</code></td>
<td>
<p>A suitable caption for the table.</p>
</td></tr>
<tr><td><code id="ltx_+3A_label">label</code></td>
<td>
<p>A label used in the LaTeX code.</p>
</td></tr>
<tr><td><code id="ltx_+3A_dr">dr</code></td>
<td>
<p>Output from a <code>drop1</code> call.</p>
</td></tr>
<tr><td><code id="ltx_+3A_digits">digits</code></td>
<td>
<p>Number of digits to be printed.</p>
</td></tr>
<tr><td><code id="ltx_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result is a printout which is (much) nicer than the standard printed
output from <code>glm</code> and friends,
</p>


<h3>Value</h3>

<p>LaTeX code version of the results from a run with
<code><a href="#topic+coxreg">coxreg</a></code>, <code><a href="#topic+phreg">phreg</a></code>, <code><a href="#topic+phreg">phreg</a></code>, 
or <code><a href="#topic+aftreg">aftreg</a></code>.
</p>


<h3>Note</h3>

<p>For printing confidence limits, use <code><a href="#topic+ltx2">ltx2</a></code>.
</p>


<h3>Author(s)</h3>

<p>Göran Broström.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ltx2">ltx2</a></code>, <code><a href="#topic+coxreg">coxreg</a></code>, <code><a href="#topic+phreg">phreg</a></code>, 
<code><a href="#topic+phreg">phreg</a></code>, and <code><a href="#topic+aftreg">aftreg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(oldmort)
fit &lt;- coxreg(Surv(enter, exit, event) ~ civ + sex, data = oldmort)
dr &lt;- drop1(fit, test = "Chisq")
ltx(fit, dr = dr, caption = "A test example.", label = "tab:test1") 

</code></pre>

<hr>
<h2 id='ltx2'>LaTeX alternative printing of regression results.</h2><span id='topic+ltx2'></span>

<h3>Description</h3>

<p>This (generic) function prints the LaTeX code of the results of a fit from
<code><a href="#topic+coxreg">coxreg</a></code>, <code><a href="#topic+phreg">phreg</a></code>, <code><a href="#topic+tpchreg">tpchreg</a></code>, 
or <code><a href="#topic+aftreg">aftreg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltx2(
  x,
  caption = NULL,
  label = NULL,
  dr = NULL,
  digits = max(options()$digits - 4, 4),
  conf = 0.95,
  keep = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ltx2_+3A_x">x</code></td>
<td>
<p>The output from a call to <code>coxreg</code>, <code>tpchreg</code>, or
<code>aftreg</code></p>
</td></tr>
<tr><td><code id="ltx2_+3A_caption">caption</code></td>
<td>
<p>A suitable caption for the table.</p>
</td></tr>
<tr><td><code id="ltx2_+3A_label">label</code></td>
<td>
<p>A label used in the LaTeX code.</p>
</td></tr>
<tr><td><code id="ltx2_+3A_dr">dr</code></td>
<td>
<p>Output from a <code>drop1</code> call.</p>
</td></tr>
<tr><td><code id="ltx2_+3A_digits">digits</code></td>
<td>
<p>Number of digits to be printed.</p>
</td></tr>
<tr><td><code id="ltx2_+3A_conf">conf</code></td>
<td>
<p>Confidence intervals level.</p>
</td></tr>
<tr><td><code id="ltx2_+3A_keep">keep</code></td>
<td>
<p>Number of covariates to present.</p>
</td></tr>
<tr><td><code id="ltx2_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>LaTeX code version of the results from a run with
<code><a href="#topic+coxreg">coxreg</a></code>, <code><a href="#topic+phreg">phreg</a></code>, <code><a href="#topic+phreg">phreg</a></code>, 
<code><a href="#topic+aftreg">aftreg</a></code>.
</p>


<h3>Note</h3>

<p>Resulting tables contain estimated hazard ratios and confidence limits
instead of regression coefficients and standard errors as in <code><a href="#topic+ltx">ltx</a></code>.
</p>


<h3>Author(s)</h3>

<p>Göran Broström.
</p>


<h3>See Also</h3>

<p><code>xtable</code>, <code><a href="#topic+coxreg">coxreg</a></code>, <code><a href="#topic+phreg">phreg</a></code>, 
<code><a href="#topic+phreg">phreg</a></code>, <code><a href="#topic+aftreg">aftreg</a></code>, and <code><a href="#topic+ltx">ltx</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(oldmort)
fit &lt;- coxreg(Surv(enter, exit, event) ~ sex, data = oldmort)
ltx2(fit, caption = "A test example.", label = "tab:test1") 

</code></pre>

<hr>
<h2 id='make.communal'>Put communals in &quot;fixed&quot; data frame</h2><span id='topic+make.communal'></span>

<h3>Description</h3>

<p>Given an ordinary data frame suitable for survival analysis, and a data
frame with &quot;communal&quot; time series, this function includes the communal
covariates as fixed, by the &quot;cutting spells&quot; method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.communal(
  dat,
  com.dat,
  communal = TRUE,
  start,
  period = 1,
  lag = 0,
  surv = c("enter", "exit", "event", "birthdate"),
  tol = 1e-04,
  fortran = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.communal_+3A_dat">dat</code></td>
<td>
<p>A data frame containing interval specified survival data and
covariates, of which one must give a &quot;birth date&quot;, the connection between
duration and calendar time</p>
</td></tr>
<tr><td><code id="make.communal_+3A_com.dat">com.dat</code></td>
<td>
<p>Data frame with communal covariates. They must have the same
start year and periodicity, given by <code>start</code> and <code>lag</code>.</p>
</td></tr>
<tr><td><code id="make.communal_+3A_communal">communal</code></td>
<td>
<p>Boolean; if TRUE, then it is a true communal (default),
otherwise a fixed. The first component is the first year (start date in
decimal form), and the second component is the period length. The third is
<code>lag</code> and the fourth is <code>scale</code>.</p>
</td></tr>
<tr><td><code id="make.communal_+3A_start">start</code></td>
<td>
<p>Start date in decimal form.</p>
</td></tr>
<tr><td><code id="make.communal_+3A_period">period</code></td>
<td>
<p>Period length. Defaults to one.</p>
</td></tr>
<tr><td><code id="make.communal_+3A_lag">lag</code></td>
<td>
<p>The lag of the effect. Defaults to zero.</p>
</td></tr>
<tr><td><code id="make.communal_+3A_surv">surv</code></td>
<td>
<p>Character vector of length 4 giving the names of interval start,
interval end, event indicator, birth date, in that order. These names must
correspond to names in <code>dat</code></p>
</td></tr>
<tr><td><code id="make.communal_+3A_tol">tol</code></td>
<td>
<p>Largest length of an interval considered to be of zero length.
The cutting sometimes produces zero length intervals, which we want to
discard.</p>
</td></tr>
<tr><td><code id="make.communal_+3A_fortran">fortran</code></td>
<td>
<p>If <code>TRUE</code>, then a Fortran implementation of the function
is used. This is the default. This possibility is only for debugging
purposes. You should of course get identical results with the two methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main purpose of this function is to prepare a data file for use with
<code><a href="#topic+coxreg">coxreg</a></code>, <code><a href="#topic+aftreg">aftreg</a></code>, and
<code><a href="survival.html#topic+coxph">coxph</a></code>.
</p>


<h3>Value</h3>

<p>The return value is a data frame with the same variables as in the
combination of <code>dat</code> and <code>com.dat</code>. Therefore it is an error to
have common name(s) in the two data frames.
</p>


<h3>Note</h3>

<p>Not very vigorously tested.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxreg">coxreg</a></code>, <code><a href="#topic+aftreg">aftreg</a></code>,
<code><a href="survival.html#topic+coxph">coxph</a></code>, <code><a href="#topic+cal.window">cal.window</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- data.frame(enter = 0, exit = 5.731, event = 1,
birthdate = 1962.505, x = 2)
## Birth date: July 2, 1962 (approximately).
com.dat &lt;- data.frame(price = c(12, 3, -5, 6, -8, -9, 1, 7))
dat.com &lt;- make.communal(dat, com.dat, start = 1962.000) 

</code></pre>

<hr>
<h2 id='makeham'>The Gompertz-Makeham Distribution</h2><span id='topic+makeham'></span><span id='topic+pmakeham'></span><span id='topic+dmakeham'></span><span id='topic+qmakeham'></span><span id='topic+hmakeham'></span><span id='topic+Hmakeham'></span><span id='topic+rmakeham'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, hazard function,
cumulative hazard function, and random generation for the Gompertz-Makeham 
distribution with parameters <code>shape</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmakeham(x, shape = c(1, 1), scale = 1, log = FALSE)
pmakeham(q, shape = c(1, 1), scale = 1, lower.tail = TRUE, log.p = FALSE)
qmakeham(p, shape = c(1, 1), scale = 1, lower.tail = TRUE, log.p = FALSE)
hmakeham(x, shape = c(1, 1), scale = 1, log = FALSE)
Hmakeham(x, shape = c(1, 1), scale = 1, log.p = FALSE)
rmakeham(n, shape = c(1, 1), scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeham_+3A_shape">shape</code></td>
<td>
<p>A vector, default value c(1, 1).</p>
</td></tr>
<tr><td><code id="makeham_+3A_scale">scale</code></td>
<td>
<p>defaulting to 1.</p>
</td></tr>
<tr><td><code id="makeham_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P(X \le
x)</code>, otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="makeham_+3A_x">x</code>, <code id="makeham_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="makeham_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="makeham_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="makeham_+3A_log">log</code>, <code id="makeham_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gompertz-Makeham distribution with <code>scale</code> parameter <code class="reqn">a</code> and <code>shape</code>
parameter <code class="reqn">\sigma</code> has hazard function given by 
</p>
<p style="text-align: center;"><code class="reqn">h(x) = a[1] + a[2] \exp(x/\sigma)</code>
</p>

<p>for <code class="reqn">x \ge 0</code>.
</p>


<h3>Value</h3>

<p><code>dmakeham</code> gives the density, <code>pmakeham</code> gives the distribution
function, <code>qmakeham</code> gives the quantile function, <code>hmakeham</code> gives the
hazard function, <code>Hmakeham</code> gives the cumulative hazard function, and
<code>rmakeham</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>

<hr>
<h2 id='male.mortality'>Male mortality in ages 40-60, nineteenth century</h2><span id='topic+male.mortality'></span>

<h3>Description</h3>

<p>Males born in the years 1800-1820 and surving at least 40 years  in
the parish Skellefteå in northern 
Sweden are followed from their fortieth birthday until death or the
sixtieth birthday, whichever comes first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(male.mortality)</code></pre>


<h3>Format</h3>

<p>A data frame with 2058 observations on the following 6 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>Personal identification number.</p>
</dd> 
<dt><code>enter</code></dt><dd><p>Start of duration. Measured in years since the
fortieth birthday.</p>
</dd>
<dt><code>exit</code></dt><dd><p>End of duration. Measured in years since the
fortieth birthday.</p>
</dd>
<dt><code>event</code></dt><dd><p>a logical vector indicating death at end of interval.</p>
</dd>
<dt><code>birthdate</code></dt><dd><p>The birthdate in decimal form.</p>
</dd>
<dt><code>ses</code></dt><dd><p>Socio-economic status, a factor with levels
<code>lower</code>, <code>upper</code></p>
</dd> 
</dl>



<h3>Details</h3>

<p>The interesting explanatory
covariate is <code>ses</code> (socioeconomic status), which is a
time-varying covariate. This explains why several individuals are
representated by more than one record each. Left trucation and right
censoring are introduced this way.
</p>


<h3>Note</h3>

<p>This data set is also known, and accessible,  as <code>mort</code>.</p>


<h3>Source</h3>

<p>Data is coming from The Demographic Data Base, Umea University, Umeå, Sweden.
</p>


<h3>References</h3>

<p><a href="https://www.umu.se/enheten-for-demografi-och-aldrandeforskning/">https://www.umu.se/enheten-for-demografi-och-aldrandeforskning/</a>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(male.mortality)
fit &lt;- coxreg(Surv(enter, exit, event) ~ ses, data = male.mortality)
summary(fit)
</code></pre>

<hr>
<h2 id='mlreg'>ML proportional hazards regression</h2><span id='topic+mlreg'></span>

<h3>Description</h3>

<p>Maximum Likelihood estimation of proportional hazards models. Is deprecated,
use <code>coxreg</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlreg(
  formula = formula(data),
  data = parent.frame(),
  na.action = getOption("na.action"),
  init = NULL,
  method = c("ML", "MPPL"),
  control = list(eps = 1e-08, maxiter = 10, n.points = 12, trace = FALSE),
  singular.ok = TRUE,
  model = FALSE,
  center = TRUE,
  x = FALSE,
  y = TRUE,
  boot = FALSE,
  geometric = FALSE,
  rs = NULL,
  frailty = NULL,
  max.survs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlreg_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a ~
operator, and the terms on the right. The response must be a survival object
as returned by the Surv function.</p>
</td></tr>
<tr><td><code id="mlreg_+3A_data">data</code></td>
<td>
<p>a data.frame in which to interpret the variables named in the
formula.</p>
</td></tr>
<tr><td><code id="mlreg_+3A_na.action">na.action</code></td>
<td>
<p>a missing-data filter function, applied to the model.frame,
after any subset argument has been used.  Default is
<code>options()$na.action</code>.</p>
</td></tr>
<tr><td><code id="mlreg_+3A_init">init</code></td>
<td>
<p>vector of initial values of the iteration.  Default initial
value is zero for all variables.</p>
</td></tr>
<tr><td><code id="mlreg_+3A_method">method</code></td>
<td>
<p>Method of treating ties, &quot;ML&quot;, the default, means pure maximum
likelihood, i.e, data are treated as discrete. The choice &quot;MPPL&quot; implies
that risk sets with no tied events are treated as in ordinary Cox
regression. This is a cameleont that adapts to data, part discrete and part
continuous.</p>
</td></tr>
<tr><td><code id="mlreg_+3A_control">control</code></td>
<td>
<p>a list with components <code>eps</code> (convergence criterion),
<code>maxiter</code> (maximum number of iterations), and <code>silent</code> (logical,
controlling amount of output). You can change any component without mention
the other(s).</p>
</td></tr>
<tr><td><code id="mlreg_+3A_singular.ok">singular.ok</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="mlreg_+3A_model">model</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="mlreg_+3A_center">center</code></td>
<td>
<p>Should covariates be centered? Default is TRUE</p>
</td></tr>
<tr><td><code id="mlreg_+3A_x">x</code></td>
<td>
<p>Return the design matrix in the model object?</p>
</td></tr>
<tr><td><code id="mlreg_+3A_y">y</code></td>
<td>
<p>return the response in the model object?</p>
</td></tr>
<tr><td><code id="mlreg_+3A_boot">boot</code></td>
<td>
<p>No. of bootstrap replicates. Defaults to FALSE, i.e., no
bootstrapping.</p>
</td></tr>
<tr><td><code id="mlreg_+3A_geometric">geometric</code></td>
<td>
<p>If <code>TRUE</code>, the intensity is assumed constant within
strata.</p>
</td></tr>
<tr><td><code id="mlreg_+3A_rs">rs</code></td>
<td>
<p>Risk set? If present, speeds up calculations considerably.</p>
</td></tr>
<tr><td><code id="mlreg_+3A_frailty">frailty</code></td>
<td>
<p>A grouping variable for frailty analysis. Full name is
needed.</p>
</td></tr>
<tr><td><code id="mlreg_+3A_max.survs">max.survs</code></td>
<td>
<p>Sampling of risk sets?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method <code>ML</code> performs a true discrete analysis, i.e., one parameter per
observed event time. Method <code>MPPL</code> is a compromize between the discrete
and continuous time approaches; one parameter per observed event time with
multiple events. With no ties in data, an ordinary Cox regression (as with
<code><a href="#topic+coxreg">coxreg</a></code>) is performed.
</p>


<h3>Value</h3>

<p>A list of class <code>c("mlreg", "coxreg", "coxph")</code> with components
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>Fitted parameter estimates.</p>
</td></tr> <tr><td><code>var</code></td>
<td>
<p>Covariance
matrix of the estimates.</p>
</td></tr> <tr><td><code>loglik</code></td>
<td>
<p>Vector of length two; first
component is the value at the initial parameter values, the second componet
is the maximized value.</p>
</td></tr> <tr><td><code>score</code></td>
<td>
<p>The score test statistic (at the
initial value).</p>
</td></tr> <tr><td><code>linear.predictors</code></td>
<td>
<p>The estimated linear predictors.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The martingale residuals.</p>
</td></tr> <tr><td><code>hazard</code></td>
<td>
<p>The estimated
baseline hazard.</p>
</td></tr> <tr><td><code>means</code></td>
<td>
<p>Means of the columns of the design matrix.</p>
</td></tr>
<tr><td><code>w.means</code></td>
<td>
<p>Weighted (against exposure time) means of covariates;
weighted relative frequencies of levels of factors.</p>
</td></tr> <tr><td><code>n</code></td>
<td>
<p>Number of
spells in indata (possibly after removal of cases with NA's).</p>
</td></tr>
<tr><td><code>events</code></td>
<td>
<p>Number of events in data.</p>
</td></tr> <tr><td><code>terms</code></td>
<td>
<p>Used by extractor
functions.</p>
</td></tr> <tr><td><code>assign</code></td>
<td>
<p>Used by extractor functions.</p>
</td></tr> <tr><td><code>wald.test</code></td>
<td>
<p>The
Walt test statistic (at the initial value).</p>
</td></tr> <tr><td><code>y</code></td>
<td>
<p>The Surv vector.</p>
</td></tr>
<tr><td><code>isF</code></td>
<td>
<p>Logical vector indicating the covariates that are factors.</p>
</td></tr>
<tr><td><code>covars</code></td>
<td>
<p>The covariates.</p>
</td></tr> <tr><td><code>ttr</code></td>
<td>
<p>Total Time at Risk.</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>List of levels of factors.</p>
</td></tr> <tr><td><code>formula</code></td>
<td>
<p>The calling
formula.</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>The call.</p>
</td></tr> <tr><td><code>bootstrap</code></td>
<td>
<p>The bootstrap sample, if
requested on input.</p>
</td></tr> <tr><td><code>sigma</code></td>
<td>
<p>Present if a frailty model is fitted.
Equals the estimated frailty standard deviation.</p>
</td></tr> <tr><td><code>sigma.sd</code></td>
<td>
<p>The
standard error of the estimated frailty standard deviation.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method.</p>
</td></tr> <tr><td><code>convergence</code></td>
<td>
<p>Did the optimization
converge?</p>
</td></tr> <tr><td><code>fail</code></td>
<td>
<p>Did the optimization fail? (Is <code>NULL</code> if not).</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The use of <code>rs</code> is dangerous, see note above. It can
however speed up computing time.
</p>


<h3>Note</h3>

<p>This function starts by creating risksets, if no riskset is supplied
via <code>rs</code>, with the aid of <code><a href="#topic+risksets">risksets</a></code>. This latter mechanism
fails if there are any NA's in the data! Note also that it depends on
stratification, so <code>rs</code> contains information about stratification.
Giving another strata variable in the formula is an error. The same is ok,
for instance to supply stratum interactions.
</p>
<p>Note futher that <code>mlreg</code> is deprecated. <code><a href="#topic+coxreg">coxreg</a></code> should be
used instead.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>References</h3>

<p>Broström, G. (2002). Cox regression; Ties without
tears. <em>Communications in Statistics: Theory and Methods</em> <b>31</b>,
285&ndash;297.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxreg">coxreg</a></code>, <code><a href="#topic+risksets">risksets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 dat &lt;- data.frame(time=  c(4, 3,1,1,2,2,3),
                status=c(1,1,1,0,1,1,0),
                x=     c(0, 2,1,1,1,0,0),
                sex=   c(0, 0,0,0,1,1,1))
 mlreg( Surv(time, status) ~ x + strata(sex), data = dat) #stratified model
 # Same as:
 rs &lt;- risksets(Surv(dat$time, dat$status), strata = dat$sex)
 mlreg( Surv(time, status) ~ x, data = dat, rs = rs) #stratified model
 
</code></pre>

<hr>
<h2 id='mort'>Male mortality in ages 40-60, nineteenth century</h2><span id='topic+mort'></span>

<h3>Description</h3>

<p>Males born in the years 1800-1820 and surving at least 40 years  in
the parish Skellefteå in northern 
Sweden are followed from their fortieth birthday until death or the
sixtieth birthday, whichever comes first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mort)</code></pre>


<h3>Format</h3>

<p>A data frame with 2058 observations on the following 6 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>Personal identification number.</p>
</dd> 
<dt><code>enter</code></dt><dd><p>Start of duration. Measured in years since the
fortieth birthday.</p>
</dd>
<dt><code>exit</code></dt><dd><p>End of duration. Measured in years since the
fortieth birthday.</p>
</dd>
<dt><code>event</code></dt><dd><p>a logical vector indicating death at end of interval.</p>
</dd>
<dt><code>birthdate</code></dt><dd><p>The birthdate in decimal form.</p>
</dd>
<dt><code>ses</code></dt><dd><p>Socio-economic status, a factor with levels
<code>lower</code>, <code>upper</code></p>
</dd> 
</dl>



<h3>Details</h3>

<p>The interesting explanatory
covariate is <code>ses</code> (socioeconomic status), which is a
time-varying covariate. This explains why several individuals are
representated by more than one record each. Left trucation and right
censoring are introduced this way.
</p>


<h3>Note</h3>

<p>This data set is also known, and accessible,  as <code>male.mortality</code></p>


<h3>Source</h3>

<p>Data is coming from The Demographic Data Base, Umea University, Umeå, Sweden.
</p>


<h3>References</h3>

<p><a href="https://www.umu.se/enheten-for-demografi-och-aldrandeforskning/">https://www.umu.se/enheten-for-demografi-och-aldrandeforskning/</a>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mort)
fit &lt;- coxreg(Surv(enter, exit, event) ~ ses, data = mort)
summary(fit)
</code></pre>

<hr>
<h2 id='oe'>Create an oe object</h2><span id='topic+oe'></span>

<h3>Description</h3>

<p>Create an <em>oe</em> (&quot;occurrence/exposure&quot;) object, used as a response 
variable in a model formula specifically in <code><a href="#topic+tpchreg">tpchreg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oe(count, exposure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oe_+3A_count">count</code></td>
<td>
<p>Number of events, a non-negative integer-valued vector.</p>
</td></tr>
<tr><td><code id="oe_+3A_exposure">exposure</code></td>
<td>
<p>exposure time corresponding to count. 
A positive numeric vector.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tpchreg">tpchreg</a></code>.
</p>

<hr>
<h2 id='oldmort'>
Old age mortality, Sundsvall, Sweden, 1860-1880.
</h2><span id='topic+oldmort'></span>

<h3>Description</h3>

<p>The data consists of old age life histories from 1 January 1860 to 31 december
1880, 21 years. Only (parts of) life histories above age 60 is
considered. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(oldmort)</code></pre>


<h3>Format</h3>

<p>A data frame with 6508 observations from 4603 persons on the following 13 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>Identification number.</p>
</dd>
<dt><code>enter</code></dt><dd><p>Start age for the interval.</p>
</dd>
<dt><code>exit</code></dt><dd><p>Stop age for the interval.</p>
</dd>
<dt><code>event</code></dt><dd><p>Indicator of death; equals <code>TRUE</code> if the person died
at the end of the interval, <code>FALSE</code> otherwise.</p>
</dd>
<dt><code>birthdate</code></dt><dd><p>Birthdate as a real number (i.e.,
&quot;1765-06-27&quot; is 1765.490).</p>
</dd>
<dt><code>m.id</code></dt><dd><p>Mother's identification number.</p>
</dd>
<dt><code>f.id</code></dt><dd><p>Father's identification number.</p>
</dd>
<dt><code>sex</code></dt><dd><p>Gender, a factor with levels <code>male</code> <code>female</code></p>
</dd>
<dt><code>civ</code></dt><dd><p>Civil status, a factor with levels <code>unmarried</code> <code>married</code> <code>widow</code></p>
</dd>
<dt><code>ses.50</code></dt><dd><p>Socio-economic status at age 50, a factor with levels <code>middle</code> <code>unknown</code> <code>upper</code> <code>farmer</code> <code>lower</code></p>
</dd>
<dt><code>birthplace</code></dt><dd><p>a factor with levels <code>parish</code> <code>region</code> <code>remote</code></p>
</dd>
<dt><code>imr.birth</code></dt><dd><p>Infant mortality rate at birth in the region
of birth</p>
</dd>
<dt><code>region</code></dt><dd><p>Subregion of Sundsvall, a factor with levels <code>town</code> <code>industry</code> <code>rural</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>The Sundsvall area in mid-Sweden was during the 19th century a fast
growing forest industry. At the end of the century, it was one of the
largest sawmill area in Europe. The town Sundsvall is fast growing part
of the region and center for the commerse.
</p>


<h3>Source</h3>

<p>The Demographic Data Base, Umeå University, Sweden.
</p>


<h3>References</h3>

<p>Edvinsson, S. (2000). The Demographic Data Base at Umeå University: A
resource for historical studies. In Hall, McKaa, and Thorvaldsen (eds),
&quot;Handbook of International Historical Microdata for Population
Research&quot;, Minnesota Population Center, Minneapolis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oldmort)
summary(oldmort)
## maybe str(oldmort) ; plot(oldmort) ...
</code></pre>

<hr>
<h2 id='Pch'>The Piecewise Constant Hazards distribution.</h2><span id='topic+Pch'></span><span id='topic+ppch'></span><span id='topic+pch'></span><span id='topic+dpch'></span><span id='topic+hpch'></span><span id='topic+Hpch'></span><span id='topic+qpch'></span><span id='topic+mpch'></span><span id='topic+rpch'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, hazard function,
cumulative hazard function, mean, and random generation for the Piecewice
Constant Hazards (pch) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppch(q, cuts, levels, lower.tail = TRUE, log.p = FALSE)
dpch(x, cuts, levels, log = FALSE)
hpch(x, cuts, levels, log = FALSE)
Hpch(x, cuts, levels, log.p = FALSE)
qpch(p, cuts, levels, lower.tail = TRUE, log.p = FALSE)
mpch(cuts, levels)
rpch(n, cuts, levels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pch_+3A_cuts">cuts</code></td>
<td>
<p>Vector of cut points defining the intervals where the hazard function
is constant.</p>
</td></tr>
<tr><td><code id="Pch_+3A_levels">levels</code></td>
<td>
<p>Vector of levels (values of the hazard function).</p>
</td></tr>
<tr><td><code id="Pch_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P(X \le x)</code>, otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="Pch_+3A_x">x</code>, <code id="Pch_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Pch_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Pch_+3A_log">log</code>, <code id="Pch_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Pch_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken 
to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pch distribution has a hazard function that is piecewise constant
on intervals defined by cutpoints 
</p>
<p style="text-align: center;"><code class="reqn">0 &lt; c_1 &lt; \cdots &lt; c_n &lt; \infty, n \ge 0</code>
</p>

<p>If <code>n = 0</code>, this reduces to an exponential distribution.
</p>


<h3>Value</h3>

<p><code>dpch</code> gives the density, 
<code>ppch</code> gives the distribution function, 
<code>qpch</code> gives the quantile function, 
<code>hpch</code> gives the hazard function, 
<code>Hpch</code> gives the cumulative hazard function, 
<code>mpch</code> gives the mean, and
<code>rpch</code> generates random deviates.
</p>


<h3>Note</h3>

<p>the parameter <code>levels</code> must have length at least 1, and the 
number of cut points must be one less than the number of levels.
</p>

<hr>
<h2 id='pchreg'>Piecewise Constant Proportional Hazards Regression</h2><span id='topic+pchreg'></span>

<h3>Description</h3>

<p>Proportional hazards model with piecewise constant baseline hazard(s).  Allows for
stratification and left truncated and right censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pchreg(
  formula = formula(data),
  data = parent.frame(),
  na.action = getOption("na.action"),
  cuts = NULL,
  init,
  control = list(eps = 1e-08, maxiter = 20, trace = FALSE),
  singular.ok = TRUE,
  model = FALSE,
  x = FALSE,
  y = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pchreg_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a ~
operator, and the terms on the right.  The response must be a survival
object as returned by the Surv function.</p>
</td></tr>
<tr><td><code id="pchreg_+3A_data">data</code></td>
<td>
<p>a data.frame in which to interpret the variables named in the
formula.</p>
</td></tr>
<tr><td><code id="pchreg_+3A_na.action">na.action</code></td>
<td>
<p>a missing-data filter function, applied to the model.frame,
after any subset argument has been used.  Default is
<code>options()$na.action</code>.</p>
</td></tr>
<tr><td><code id="pchreg_+3A_cuts">cuts</code></td>
<td>
<p>Specifies the points in time
where the hazard function jumps. If omitted, an exponential model is fitted.</p>
</td></tr>
<tr><td><code id="pchreg_+3A_init">init</code></td>
<td>
<p>vector of initial values of the iteration.  Default initial
value is zero for all variables.</p>
</td></tr>
<tr><td><code id="pchreg_+3A_control">control</code></td>
<td>
<p>a list with components <code>eps</code> (convergence criterion),
<code>maxiter</code> (maximum number of iterations), and <code>silent</code> (logical,
controlling amount of output).  You can change any component without mention
the other(s).</p>
</td></tr>
<tr><td><code id="pchreg_+3A_singular.ok">singular.ok</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="pchreg_+3A_model">model</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="pchreg_+3A_x">x</code></td>
<td>
<p>Return the design matrix in the model object?</p>
</td></tr>
<tr><td><code id="pchreg_+3A_y">y</code></td>
<td>
<p>Return the response in the model object?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>"pchreg"</code> with components
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>Fitted parameter estimates.</p>
</td></tr> 
<tr><td><code>cuts</code></td>
<td>
<p>Cut points (<code>NULL</code> if no cut points).</p>
</td></tr> 
<tr><td><code>hazards</code></td>
<td>
<p>The estimated constant levels.</p>
</td></tr> 
<tr><td><code>var</code></td>
<td>
<p>Covariance matrix of the estimates.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Vector of length two; first component is the value at the
initial parameter values, the second component is the maximized value.</p>
</td></tr>
<tr><td><code>score</code></td>
<td>
<p>The score test statistic (at the initial value).</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>The estimated linear predictors.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>Means of the columns of the design matrix, except those columns
corresponding to a factor level. Otherwise all
zero.</p>
</td></tr> 
<tr><td><code>w.means</code></td>
<td>
<p>Weighted (against exposure time) means of covariates;
weighted relative frequencies of levels of factors.</p>
</td></tr> 
<tr><td><code>n</code></td>
<td>
<p>Number of
spells in indata (possibly after removal of cases with NA's).</p>
</td></tr>
<tr><td><code>n.events</code></td>
<td>
<p>Number of events in data.</p>
</td></tr> 
<tr><td><code>terms</code></td>
<td>
<p>Used by extractor functions.</p>
</td></tr> 
<tr><td><code>assign</code></td>
<td>
<p>Used by extractor functions.</p>
</td></tr> 
<tr><td><code>wald.test</code></td>
<td>
<p>The Wald test statistic (at the initial value).</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The Surv vector.</p>
</td></tr> 
<tr><td><code>isF</code></td>
<td>
<p>Logical vector indicating the
covariates that are factors.</p>
</td></tr> 
<tr><td><code>covars</code></td>
<td>
<p>The covariates.</p>
</td></tr>
<tr><td><code>ttr</code></td>
<td>
<p>Total Time at Risk.</p>
</td></tr> 
<tr><td><code>levels</code></td>
<td>
<p>List of levels of factors.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The calling formula.</p>
</td></tr> 
<tr><td><code>call</code></td>
<td>
<p>The call.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method.</p>
</td></tr> 
<tr><td><code>convergence</code></td>
<td>
<p>Did the optimization
converge?</p>
</td></tr> 
<tr><td><code>fail</code></td>
<td>
<p>Did the optimization fail? (Is <code>NULL</code> if not).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phreg">phreg</a></code>, <code><a href="#topic+coxreg">coxreg</a></code>, <code>link{aftreg}</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
dat &lt;- age.window(oldmort, c(60, 80))
fit &lt;- pchreg(Surv(enter, exit, event) ~ ses.50 + sex, 
data = dat, cuts = seq(60, 80, by = 4))
summary(fit)

fit.cr &lt;- coxreg(Surv(enter, exit, event) ~ ses.50 + sex, data = dat)
check.dist(fit.cr, fit, main = "Cumulative hazards")

## End(Not run)

</code></pre>

<hr>
<h2 id='perstat'>Period statistics</h2><span id='topic+perstat'></span>

<h3>Description</h3>

<p>Calculates occurrence / exposure rates for time periods given by
<code>period</code> and for ages given by <code>age</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perstat(surv, period, age = c(0, 200))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perstat_+3A_surv">surv</code></td>
<td>
<p>An (extended) <code>surv</code> object (4 columns with <code>enter</code>,
<code>exit</code>, <code>event</code>, <code>birthdate</code>)</p>
</td></tr>
<tr><td><code id="perstat_+3A_period">period</code></td>
<td>
<p>A vector of dates (in decimal form)</p>
</td></tr>
<tr><td><code id="perstat_+3A_age">age</code></td>
<td>
<p>A vector of length 2; lowest and highest age</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components </p>
<table>
<tr><td><code>events</code></td>
<td>
<p>No. of events in eavh time
period.</p>
</td></tr> <tr><td><code>exposure</code></td>
<td>
<p>Exposure times in each period.</p>
</td></tr>
<tr><td><code>intensity</code></td>
<td>
<p><code>events / exposure</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+piecewise">piecewise</a></code>
</p>

<hr>
<h2 id='phfunc'>Loglihood function of a proportional hazards regression</h2><span id='topic+phfunc'></span>

<h3>Description</h3>

<p>Calculates minus the log likelihood function and its first and second order
derivatives for data from a Weibull regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phfunc(
  beta = NULL,
  lambda,
  p,
  X = NULL,
  Y,
  offset = rep(0, length(Y)),
  ord = 2,
  pfixed = FALSE,
  dist = "weibull"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phfunc_+3A_beta">beta</code></td>
<td>
<p>Regression parameters</p>
</td></tr>
<tr><td><code id="phfunc_+3A_lambda">lambda</code></td>
<td>
<p>The scale paramater</p>
</td></tr>
<tr><td><code id="phfunc_+3A_p">p</code></td>
<td>
<p>The shape parameter</p>
</td></tr>
<tr><td><code id="phfunc_+3A_x">X</code></td>
<td>
<p>The design (covariate) matrix.</p>
</td></tr>
<tr><td><code id="phfunc_+3A_y">Y</code></td>
<td>
<p>The response, a survival object.</p>
</td></tr>
<tr><td><code id="phfunc_+3A_offset">offset</code></td>
<td>
<p>Offset.</p>
</td></tr>
<tr><td><code id="phfunc_+3A_ord">ord</code></td>
<td>
<p>ord = 0 means only loglihood, 1 means score vector as well, 2
loglihood, score and hessian.</p>
</td></tr>
<tr><td><code id="phfunc_+3A_pfixed">pfixed</code></td>
<td>
<p>Logical, if TRUE the shape parameter is regarded as a known
constant in the calculations, meaning that it is not cosidered in the
partial derivatives.</p>
</td></tr>
<tr><td><code id="phfunc_+3A_dist">dist</code></td>
<td>
<p>Which distribtion? The default is &quot;weibull&quot;, with the
alternatives &quot;loglogistic&quot; and &quot;lognormal&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the function returns log likelihood, score vector and minus
hessian, i.e. the observed information. The model is 
</p>
<p style="text-align: center;"><code class="reqn">S(t; p, \lambda, \beta, z) = S_0((t / \lambda)^p)^{e^(z \beta)}</code>
</p>



<h3>Value</h3>

<p>A list with components </p>
<table>
<tr><td><code>f</code></td>
<td>
<p>The log likelihood. Present if
<code>ord &gt;= 0</code></p>
</td></tr> <tr><td><code>fp</code></td>
<td>
<p>The score vector. Present if <code>ord &gt;= 1</code></p>
</td></tr>
<tr><td><code>fpp</code></td>
<td>
<p>The negative of the hessian. Present if <code>ord &gt;= 2</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phreg">phreg</a></code>
</p>

<hr>
<h2 id='phreg'>Parametric Proportional Hazards Regression</h2><span id='topic+phreg'></span>

<h3>Description</h3>

<p>Proportional hazards model with parametric baseline hazard(s).  Allows for
stratification with different scale and shape in each stratum, and left
truncated and right censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phreg(
  formula = formula(data),
  data = parent.frame(),
  na.action = getOption("na.action"),
  dist = "weibull",
  cuts = NULL,
  init,
  shape = 0,
  param = c("canonical", "rate"),
  control = list(eps = 1e-08, maxiter = 20, trace = FALSE),
  singular.ok = TRUE,
  model = FALSE,
  x = FALSE,
  y = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phreg_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a ~
operator, and the terms on the right.  The response must be a survival
object as returned by the Surv function.</p>
</td></tr>
<tr><td><code id="phreg_+3A_data">data</code></td>
<td>
<p>a data.frame in which to interpret the variables named in the
formula.</p>
</td></tr>
<tr><td><code id="phreg_+3A_na.action">na.action</code></td>
<td>
<p>a missing-data filter function, applied to the model.frame,
after any subset argument has been used.  Default is
<code>options()$na.action</code>.</p>
</td></tr>
<tr><td><code id="phreg_+3A_dist">dist</code></td>
<td>
<p>Which distribution? Default is &quot;weibull&quot;, with the alternatives
&quot;ev&quot; (Extreme value), &quot;gompertz&quot;, &quot;pch&quot; (piecewise constant hazards
function), &quot;loglogistic&quot; and &quot;lognormal&quot;. A special case like the
<code>exponential</code> can be obtained by choosing &quot;weibull&quot; in combination with
<code>shape = 1</code>, or &quot;pch&quot; without <code>cuts</code>.</p>
</td></tr>
<tr><td><code id="phreg_+3A_cuts">cuts</code></td>
<td>
<p>Only used with <code>dist = "pch"</code>. Specifies the points in time
where the hazard function jumps. If omitted, an exponential model is fitted.</p>
</td></tr>
<tr><td><code id="phreg_+3A_init">init</code></td>
<td>
<p>vector of initial values of the iteration.  Default initial
value is zero for all variables.</p>
</td></tr>
<tr><td><code id="phreg_+3A_shape">shape</code></td>
<td>
<p>If positive, the shape parameter is fixed at that value (in
each stratum).  If zero or negative, the shape parameter is estimated.  If
more than one stratum is present in data, each stratum gets its own
estimate. Only relevant for the Weibull and Extreme Value distributions.</p>
</td></tr>
<tr><td><code id="phreg_+3A_param">param</code></td>
<td>
<p>Applies only to the Gompertz distribution: &quot;canonical&quot; is
defined in the description of the <code><a href="#topic+Gompertz">Gompertz</a></code> distribution;
&quot;rate&quot; transforms <code>scale</code> to 1/log(scale), giving the same
parametrization as in Stata and SAS. The latter thus allows for a negative
rate, or a &quot;cure&quot; (Gompertz) model. The default is &quot;canonical&quot;; if this
results in extremely large scale and/or shape estimates, consider trying
&quot;rate&quot;.</p>
</td></tr>
<tr><td><code id="phreg_+3A_control">control</code></td>
<td>
<p>a list with components <code>eps</code> (convergence criterion),
<code>maxiter</code> (maximum number of iterations), and <code>silent</code> (logical,
controlling amount of output).  You can change any component without mention
the other(s).</p>
</td></tr>
<tr><td><code id="phreg_+3A_singular.ok">singular.ok</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="phreg_+3A_model">model</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="phreg_+3A_x">x</code></td>
<td>
<p>Return the design matrix in the model object?</p>
</td></tr>
<tr><td><code id="phreg_+3A_y">y</code></td>
<td>
<p>Return the response in the model object?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameterization is the same as in <code><a href="#topic+coxreg">coxreg</a></code> and
<code><a href="survival.html#topic+coxph">coxph</a></code>, but different from the one used by
<code><a href="survival.html#topic+survreg">survreg</a></code> (which is not a proportional hazards
modelling function). The model is </p>
<p style="text-align: center;"><code class="reqn">S(t; a, b, \beta, z) =
S_0((t/b)^a)^{\exp((z-mean(z))\beta)}</code>
</p>
<p> where S0 is some standardized survivor
function.
</p>


<h3>Value</h3>

<p>A list of class <code>c("phreg", "coxreg")</code> with components
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>Fitted parameter estimates.</p>
</td></tr> 
<tr><td><code>cuts</code></td>
<td>
<p>Cut points for
the &quot;pch&quot; distribution. <code>NULL</code> otherwise.</p>
</td></tr> 
<tr><td><code>hazards</code></td>
<td>
<p>The estimated
constant levels in the case of the &quot;pch&quot; distribution. <code>NULL</code>
otherwise.</p>
</td></tr> 
<tr><td><code>var</code></td>
<td>
<p>Covariance matrix of the estimates.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Vector of length two; first component is the value at the
initial parameter values, the second componet is the maximized value.</p>
</td></tr>
<tr><td><code>score</code></td>
<td>
<p>The score test statistic (at the initial value).</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>The estimated linear predictors.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>Means of the columns of the design matrix, except those columns
corresponding to a factor level. Otherwise all
zero.</p>
</td></tr> 
<tr><td><code>w.means</code></td>
<td>
<p>Weighted (against exposure time) means of covariates;
weighted relative frequencies of levels of factors.</p>
</td></tr> 
<tr><td><code>n</code></td>
<td>
<p>Number of
spells in indata (possibly after removal of cases with NA's).</p>
</td></tr>
<tr><td><code>n.events</code></td>
<td>
<p>Number of events in data.</p>
</td></tr> 
<tr><td><code>terms</code></td>
<td>
<p>Used by extractor functions.</p>
</td></tr> 
<tr><td><code>assign</code></td>
<td>
<p>Used by extractor functions.</p>
</td></tr> 
<tr><td><code>wald.test</code></td>
<td>
<p>The Wald test statistic (at the initial value).</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The Surv vector.</p>
</td></tr> 
<tr><td><code>isF</code></td>
<td>
<p>Logical vector indicating the
covariates that are factors.</p>
</td></tr> 
<tr><td><code>covars</code></td>
<td>
<p>The covariates.</p>
</td></tr>
<tr><td><code>ttr</code></td>
<td>
<p>Total Time at Risk.</p>
</td></tr> 
<tr><td><code>levels</code></td>
<td>
<p>List of levels of factors.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The calling formula.</p>
</td></tr> 
<tr><td><code>call</code></td>
<td>
<p>The call.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method.</p>
</td></tr> 
<tr><td><code>convergence</code></td>
<td>
<p>Did the optimization
converge?</p>
</td></tr> 
<tr><td><code>fail</code></td>
<td>
<p>Did the optimization fail? (Is <code>NULL</code> if not).</p>
</td></tr>
<tr><td><code>pfixed</code></td>
<td>
<p>TRUE if shape was fixed in the estimation.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The lognormal and loglogistic distributions are included
on an experimental basis for the moment. Use with care, results may be
unreliable!
</p>
<p>The gompertz distribution has an exponentially increasing hazard function
under the canonical parametrization. This may cause instability in the
convergence of the fitting algorithm in the case of near-exponential data.
It may be resolved by using <code>param = "rate"</code>.
</p>


<h3>Note</h3>

<p>The lognormal and loglogistic baseline distributions are extended to a
three-parameter family by adding a &quot;proportionality&quot; parameter (multiplying
the baseline hazard function). The log of the estimated parameter turns up
as '(Intercept)' in the printed output. The reason for this extension is
that the standard lognormal and loglogistic distributions are not closed
under proportional hazards.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxreg">coxreg</a></code>, <code><a href="#topic+check.dist">check.dist</a></code>,
<code>link{aftreg}</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mort)
fit &lt;- phreg(Surv(enter, exit, event) ~ ses, data = mort)
fit
plot(fit)
fit.cr &lt;- coxreg(Surv(enter, exit, event) ~ ses, data = mort)
check.dist(fit.cr, fit)

</code></pre>

<hr>
<h2 id='phreg.fit'>Parametric proportional hazards regression</h2><span id='topic+phreg.fit'></span>

<h3>Description</h3>

<p>This function is called by <code><a href="#topic+phreg">phreg</a></code>, but it can also be directly
called by a user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phreg.fit(X, Y, dist, strata, offset, init, shape, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phreg.fit_+3A_x">X</code></td>
<td>
<p>The design (covariate) matrix.</p>
</td></tr>
<tr><td><code id="phreg.fit_+3A_y">Y</code></td>
<td>
<p>A survival object, the response.</p>
</td></tr>
<tr><td><code id="phreg.fit_+3A_dist">dist</code></td>
<td>
<p>Which baseline distribution?</p>
</td></tr>
<tr><td><code id="phreg.fit_+3A_strata">strata</code></td>
<td>
<p>A stratum variable.</p>
</td></tr>
<tr><td><code id="phreg.fit_+3A_offset">offset</code></td>
<td>
<p>Offset.</p>
</td></tr>
<tr><td><code id="phreg.fit_+3A_init">init</code></td>
<td>
<p>Initial regression parameter values.</p>
</td></tr>
<tr><td><code id="phreg.fit_+3A_shape">shape</code></td>
<td>
<p>If positive, a fixed value of the shape parameter in the
distribution. Otherwise, the shape is estimated.</p>
</td></tr>
<tr><td><code id="phreg.fit_+3A_control">control</code></td>
<td>
<p>Controls convergence and output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+phreg">phreg</a></code> for more detail.
</p>


<h3>Value</h3>

<table>
<tr><td><code>coefficients</code></td>
<td>
<p>Estimated regression coefficients plus estimated
scale and shape coefficients, sorted by strata, if present.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>Variance-covariance matrix</p>
</td></tr> <tr><td><code>loglik</code></td>
<td>
<p>Vector of length 2. The
first component is the maximized loglihood with only scale and shape in the
model, the second the final maximum.</p>
</td></tr> <tr><td><code>score</code></td>
<td>
<p>Score test statistic at
initial values</p>
</td></tr> <tr><td><code>linear.predictors</code></td>
<td>
<p>Linear predictors for each
interval.</p>
</td></tr> <tr><td><code>means</code></td>
<td>
<p>Means of the covariates</p>
</td></tr> <tr><td><code>conver</code></td>
<td>
<p>TRUE if
convergence</p>
</td></tr> <tr><td><code>fail</code></td>
<td>
<p>TRUE if failure</p>
</td></tr> <tr><td><code>iter</code></td>
<td>
<p>Number of
Newton-Raphson iterates.</p>
</td></tr> <tr><td><code>n.strata</code></td>
<td>
<p>The number of strata in the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phreg">phreg</a></code>
</p>

<hr>
<h2 id='piecewise'>Piecewise hazards</h2><span id='topic+piecewise'></span>

<h3>Description</h3>

<p>Calculate piecewise hazards, no. of events, and exposure times in each
interval indicated by cutpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piecewise(enter, exit, event, cutpoints)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piecewise_+3A_enter">enter</code></td>
<td>
<p>Left interval endpoint</p>
</td></tr>
<tr><td><code id="piecewise_+3A_exit">exit</code></td>
<td>
<p>Right interval endpoint</p>
</td></tr>
<tr><td><code id="piecewise_+3A_event">event</code></td>
<td>
<p>Indicator of event</p>
</td></tr>
<tr><td><code id="piecewise_+3A_cutpoints">cutpoints</code></td>
<td>
<p>Vector of cutpoints</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exact calculation.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>events</code></td>
<td>
<p>Vector of number of events</p>
</td></tr> <tr><td><code>exposure</code></td>
<td>
<p>Vector of total
exposure time</p>
</td></tr> <tr><td><code>intensity</code></td>
<td>
<p>Vector of hazards, <code>intensity</code> ==
<code>events</code> / <code>exposure</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+perstat">perstat</a></code>
</p>

<hr>
<h2 id='plot.aftreg'>Plots output from an AFT regression</h2><span id='topic+plot.aftreg'></span>

<h3>Description</h3>

<p>Just a simple plot of the hazard (cumulative hazard, density, survival)
functions for each stratum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aftreg'
plot(
  x,
  fn = c("haz", "cum", "den", "sur"),
  main = NULL,
  xlim = NULL,
  ylim = NULL,
  xlab = "Duration",
  ylab = "",
  col,
  lty,
  printLegend = TRUE,
  new.data = x$means,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.aftreg_+3A_x">x</code></td>
<td>
<p>A <code>aftreg</code> object</p>
</td></tr>
<tr><td><code id="plot.aftreg_+3A_fn">fn</code></td>
<td>
<p>Which functions shoud be plotted! Default is all. They will scroll
by, so you have to take care of explicitly what you want to be produced.
See, eg, <code>par(mfrow = ...)</code></p>
</td></tr>
<tr><td><code id="plot.aftreg_+3A_main">main</code></td>
<td>
<p>Header for the plot</p>
</td></tr>
<tr><td><code id="plot.aftreg_+3A_xlim">xlim</code></td>
<td>
<p>x limits</p>
</td></tr>
<tr><td><code id="plot.aftreg_+3A_ylim">ylim</code></td>
<td>
<p>y limits</p>
</td></tr>
<tr><td><code id="plot.aftreg_+3A_xlab">xlab</code></td>
<td>
<p>x label</p>
</td></tr>
<tr><td><code id="plot.aftreg_+3A_ylab">ylab</code></td>
<td>
<p>y label</p>
</td></tr>
<tr><td><code id="plot.aftreg_+3A_col">col</code></td>
<td>
<p>Colors?</p>
</td></tr>
<tr><td><code id="plot.aftreg_+3A_lty">lty</code></td>
<td>
<p>Line types?</p>
</td></tr>
<tr><td><code id="plot.aftreg_+3A_printlegend">printLegend</code></td>
<td>
<p>Should legend be printed? Default is yes.</p>
</td></tr>
<tr><td><code id="plot.aftreg_+3A_new.data">new.data</code></td>
<td>
<p>At which covariate values?</p>
</td></tr>
<tr><td><code id="plot.aftreg_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to 'plot'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot is drawn at the mean values of the covariates, by default.
</p>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aftreg">aftreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- rllogis(40, shape = 1, scale = 1)
x &lt;- rep(c(1,1,2,2), 10)
fit &lt;- aftreg(Surv(y, rep(1, 40)) ~ x, dist = "loglogistic")
plot(fit)

</code></pre>

<hr>
<h2 id='plot.coxreg'>Plot method for <code>coxreg</code> objects</h2><span id='topic+plot.coxreg'></span>

<h3>Description</h3>

<p>A plot of a baseline function of a <code>coxreg</code> fit is produced, one curve
for each stratum. A wrapper for <code>plot.survfit</code> in <code>survival</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxreg'
plot(
  x,
  fn = c("cum", "surv", "log", "loglog"),
  conf.int = FALSE,
  fig = TRUE,
  xlim = NULL,
  ylim = NULL,
  main = NULL,
  xlab = "Duration",
  ylab = "",
  col = 1,
  lty = 1,
  printLegend = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.coxreg_+3A_x">x</code></td>
<td>
<p>A <code>coxreg</code> object</p>
</td></tr>
<tr><td><code id="plot.coxreg_+3A_fn">fn</code></td>
<td>
<p>What should be plotted? Default is &quot;cumhaz&quot;, and the other choices
are &quot;surv&quot;, &quot;log&quot;, and &quot;loglog&quot;.</p>
</td></tr>
<tr><td><code id="plot.coxreg_+3A_conf.int">conf.int</code></td>
<td>
<p>logical or a value like 0.95 (default for one curve).</p>
</td></tr>
<tr><td><code id="plot.coxreg_+3A_fig">fig</code></td>
<td>
<p>logical. If <code>TRUE</code> the plot is actually drawn, otherwise
only the coordinates of the curve(s) are returned.</p>
</td></tr>
<tr><td><code id="plot.coxreg_+3A_xlim">xlim</code></td>
<td>
<p>Start and end of the x axis.</p>
</td></tr>
<tr><td><code id="plot.coxreg_+3A_ylim">ylim</code></td>
<td>
<p>Start and end of the y axis.</p>
</td></tr>
<tr><td><code id="plot.coxreg_+3A_main">main</code></td>
<td>
<p>A headline for the plot</p>
</td></tr>
<tr><td><code id="plot.coxreg_+3A_xlab">xlab</code></td>
<td>
<p>Label on the x axis.</p>
</td></tr>
<tr><td><code id="plot.coxreg_+3A_ylab">ylab</code></td>
<td>
<p>Label on the y axis.</p>
</td></tr>
<tr><td><code id="plot.coxreg_+3A_col">col</code></td>
<td>
<p>Color of the curves. Defaults to 'black'.</p>
</td></tr>
<tr><td><code id="plot.coxreg_+3A_lty">lty</code></td>
<td>
<p>Line type(s).</p>
</td></tr>
<tr><td><code id="plot.coxreg_+3A_printlegend">printLegend</code></td>
<td>
<p>Either a logical or a text string; if <code>TRUE</code>, a
legend is printed at a default place, if <code>FALSE</code>, no legend is printed.
Otherwise, if a text string, it should be one of &quot;bottomleft&quot;,
&quot;bottomright&quot;, &quot;topleft&quot;, etc., see <code><a href="graphics.html#topic+legend">legend</a></code> for all possible
choices.</p>
</td></tr>
<tr><td><code id="plot.coxreg_+3A_...">...</code></td>
<td>
<p>Other parameters to pass to the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>hazdata</code> containing the coordinates of the
curve(s).
</p>

<hr>
<h2 id='plot.hazdata'>Plots of hazdata objects.</h2><span id='topic+plot.hazdata'></span>

<h3>Description</h3>

<p>Baseline hazards estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hazdata'
plot(
  x,
  strata = NULL,
  fn = c("cum", "surv", "log", "loglog"),
  fig = TRUE,
  xlim = NULL,
  ylim = NULL,
  main = NULL,
  xlab = "",
  ylab = "",
  col = "black",
  lty = 1,
  printLegend = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hazdata_+3A_x">x</code></td>
<td>
<p>A <code>hazdata</code> object, typically the 'hazards' element in the
output from <code>link{coxreg}</code> with <code>method = "ml"</code> or 
<code>method = "mppl"</code> or <code>coxph = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.hazdata_+3A_strata">strata</code></td>
<td>
<p>Stratum names if there are strata present.</p>
</td></tr>
<tr><td><code id="plot.hazdata_+3A_fn">fn</code></td>
<td>
<p>Which type of plot? Allowed values are &quot;cum&quot; (or &quot;cumhaz&quot;),
&quot;surv&quot; (or &quot;sur&quot;), &quot;log&quot;, or &quot;loglog&quot;. The last two plots the cumulative 
hazards on a log (y) scale or a log-log (xy) scale, respectively.</p>
</td></tr>
<tr><td><code id="plot.hazdata_+3A_fig">fig</code></td>
<td>
<p>Should a plot actually be produced? Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.hazdata_+3A_xlim">xlim</code></td>
<td>
<p>Horizontal plot limits. If NULL, calculated by the function.</p>
</td></tr>
<tr><td><code id="plot.hazdata_+3A_ylim">ylim</code></td>
<td>
<p>Vertical plot limits. If NULL, set to <code>c(0, 1)</code> for a 
plot of the survival function.</p>
</td></tr>
<tr><td><code id="plot.hazdata_+3A_main">main</code></td>
<td>
<p>A heading for the plot.</p>
</td></tr>
<tr><td><code id="plot.hazdata_+3A_xlab">xlab</code></td>
<td>
<p>Label on the x axis.</p>
</td></tr>
<tr><td><code id="plot.hazdata_+3A_ylab">ylab</code></td>
<td>
<p>Label on the y-axis.</p>
</td></tr>
<tr><td><code id="plot.hazdata_+3A_col">col</code></td>
<td>
<p>Color of the lines. May be a vector of length equal to No. of
strata.</p>
</td></tr>
<tr><td><code id="plot.hazdata_+3A_lty">lty</code></td>
<td>
<p>Line type(s). May be a vector of length equal to No. of strata.</p>
</td></tr>
<tr><td><code id="plot.hazdata_+3A_printlegend">printLegend</code></td>
<td>
<p>Logical or character; should a legend be produced?
Defaults to TRUE. If character, it should be one of <code>bottomleft</code>, 
<code>bottomright</code>, etc, see <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="plot.hazdata_+3A_...">...</code></td>
<td>
<p>Anything that <code><a href="graphics.html#topic+plot.default">plot.default</a></code> likes...</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is also possible to have as first argument an object of type &quot;coxreg&quot;,
given that it contains a component of type &quot;hazdata&quot;.
</p>


<h3>Value</h3>

<p>A list where the elements are two-column matrices, one for each
stratum in the model. The first column contains risktimes, and the second
the y coordinates for the requested curve(s).
</p>


<h3>Note</h3>

<p><code>x</code> is a list where each element is a two-column matrix. The first
column contains failure times, and the second column contains the 
corresponding 'hazard atoms'.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
time0 &lt;- numeric(50)
group &lt;- c(rep(0, 25), rep(1, 25))
x &lt;- runif(50, -0.5, 0.5)
time1 &lt;- rexp( 50, exp(group) )
event &lt;- rep(1, 50)
fit &lt;- coxreg(Surv(time0, time1, event) ~ x + strata(group), method = "ml")
plot(fit$hazards, col = 1:2, fn = "surv", xlab = "Duration")
## Same result as:
## plot(fit, col = 1:2, fn = "sur", xlab = "Duration")

</code></pre>

<hr>
<h2 id='plot.logrank'>Plots of hazdata objects.</h2><span id='topic+plot.logrank'></span>

<h3>Description</h3>

<p>Baseline hazards estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'logrank'
plot(
  x,
  fn = c("cum", "surv", "log", "loglog"),
  xlim = NULL,
  ylim = NULL,
  main = NULL,
  xlab = "",
  ylab = "",
  col = "black",
  lty = 1,
  printLegend = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.logrank_+3A_x">x</code></td>
<td>
<p>A <code>logrank</code> object, typically the 'hazards' element in the
output from <code>link{logrank}</code>.</p>
</td></tr>
<tr><td><code id="plot.logrank_+3A_fn">fn</code></td>
<td>
<p>Which type of plot? Allowed values are &quot;cum&quot; (or &quot;cumhaz&quot;),
&quot;surv&quot; (or &quot;sur&quot;), &quot;log&quot;, or &quot;loglog&quot;. The last two plots the cumulative 
hazards on a log (y) scale or a log-log (xy) scale, respectively.</p>
</td></tr>
<tr><td><code id="plot.logrank_+3A_xlim">xlim</code></td>
<td>
<p>Horizontal plot limits. If NULL, calculated by the function.</p>
</td></tr>
<tr><td><code id="plot.logrank_+3A_ylim">ylim</code></td>
<td>
<p>Vertical plot limits. If NULL, set to <code>c(0, 1)</code> for a 
plot of the survival function.</p>
</td></tr>
<tr><td><code id="plot.logrank_+3A_main">main</code></td>
<td>
<p>A heading for the plot.</p>
</td></tr>
<tr><td><code id="plot.logrank_+3A_xlab">xlab</code></td>
<td>
<p>Label on the x axis.</p>
</td></tr>
<tr><td><code id="plot.logrank_+3A_ylab">ylab</code></td>
<td>
<p>Label on the y-axis.</p>
</td></tr>
<tr><td><code id="plot.logrank_+3A_col">col</code></td>
<td>
<p>Color of the lines. May be a vector of length equal to No. of
strata.</p>
</td></tr>
<tr><td><code id="plot.logrank_+3A_lty">lty</code></td>
<td>
<p>Line type(s). May be a vector of length equal to No. of strata.</p>
</td></tr>
<tr><td><code id="plot.logrank_+3A_printlegend">printLegend</code></td>
<td>
<p>Logical or character; should a legend be produced?
Defaults to TRUE. If character, it should be one of <code>bottomleft</code>, 
<code>bottomright</code>, etc, see <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="plot.logrank_+3A_...">...</code></td>
<td>
<p>Anything that <code><a href="graphics.html#topic+plot.default">plot.default</a></code> likes...</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is also possible to have as first argument an object of type &quot;coxreg&quot;,
given that it contains a component of type &quot;hazdata&quot;.
</p>


<h3>Value</h3>

<p>A list where the elements are two-column matrices, one for each
stratum in the model. The first column contains risktimes, and the second
the y coordinates for the requested curve(s).
</p>


<h3>Note</h3>

<p><code>x</code> is a list where each element is a two-column matrix. The first
column contains failure times, and the second column contains the 
corresponding 'hazard atoms'.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fit &lt;- logrank(Surv(enter, exit, event), group = civ, data = oldmort[oldmort$region == "town", ])
plot(fit)

</code></pre>

<hr>
<h2 id='plot.phreg'>Plots output from a phreg regression</h2><span id='topic+plot.phreg'></span>

<h3>Description</h3>

<p>Plot(s) of the hazard, density, cumulative hazards, and/or the survivor
function(s) for each stratum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phreg'
plot(
  x,
  fn = c("haz", "cum", "den", "sur"),
  main = NULL,
  xlim = NULL,
  ylim = NULL,
  xlab = "Duration",
  ylab = "",
  col,
  lty,
  printLegend = TRUE,
  score = 1,
  fig = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.phreg_+3A_x">x</code></td>
<td>
<p>A <code>phreg</code> object</p>
</td></tr>
<tr><td><code id="plot.phreg_+3A_fn">fn</code></td>
<td>
<p>Which function should be plotted? Default is the hazard function(s).</p>
</td></tr>
<tr><td><code id="plot.phreg_+3A_main">main</code></td>
<td>
<p>Header for the plot</p>
</td></tr>
<tr><td><code id="plot.phreg_+3A_xlim">xlim</code></td>
<td>
<p>x limits</p>
</td></tr>
<tr><td><code id="plot.phreg_+3A_ylim">ylim</code></td>
<td>
<p>y limits</p>
</td></tr>
<tr><td><code id="plot.phreg_+3A_xlab">xlab</code></td>
<td>
<p>x label</p>
</td></tr>
<tr><td><code id="plot.phreg_+3A_ylab">ylab</code></td>
<td>
<p>y label</p>
</td></tr>
<tr><td><code id="plot.phreg_+3A_col">col</code></td>
<td>
<p>Color(s) for the curves. Defaults to black.</p>
</td></tr>
<tr><td><code id="plot.phreg_+3A_lty">lty</code></td>
<td>
<p>Line type for the curve(s). Defaults to 1:(No. of strata).</p>
</td></tr>
<tr><td><code id="plot.phreg_+3A_printlegend">printLegend</code></td>
<td>
<p>Logical, or character (&quot;topleft&quot;, &quot;bottomleft&quot;,
&quot;topright&quot; or &quot;bottomright&quot;); if <code>TRUE</code> or character, a legend is added
to the plot if the number of strata is two or more.</p>
</td></tr>
<tr><td><code id="plot.phreg_+3A_score">score</code></td>
<td>
<p>Multiplication factor for the hazard function.</p>
</td></tr>
<tr><td><code id="plot.phreg_+3A_fig">fig</code></td>
<td>
<p>logical, should the graph be drawn? If FALSE, data is returned.</p>
</td></tr>
<tr><td><code id="plot.phreg_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to 'plot' and 'lines'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value if fig = TRUE, otherwise the cumulative 
hazards function (coordinates), given <code>fn = "cum"</code>.
</p>


<h3>Note</h3>

<p>Reference hazard is given by the fit; 
zero for all covariates, and  the reference category for factors.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phreg">phreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- rllogis(40, shape = 1, scale = 1)
x &lt;- rep(c(1,1,2,2), 10)
fit &lt;- phreg(Surv(y, rep(1, 40)) ~ x, dist = "loglogistic")
plot(fit)

</code></pre>

<hr>
<h2 id='plot.tpchreg'>Plots output from a tpchreg regression</h2><span id='topic+plot.tpchreg'></span>

<h3>Description</h3>

<p>Plot(s) of the hazard, cumulative hazards, and/or the survivor
function(s) for each stratum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tpchreg'
plot(
  x,
  fn = c("haz", "cum", "sur"),
  log = "",
  main = NULL,
  xlim = NULL,
  ylim = NULL,
  xlab = "Duration",
  ylab = "",
  col,
  lty,
  printLegend = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.tpchreg_+3A_x">x</code></td>
<td>
<p>A <code>tpchreg</code> object</p>
</td></tr>
<tr><td><code id="plot.tpchreg_+3A_fn">fn</code></td>
<td>
<p>Which functions should be plotted? Default is the hazard function.</p>
</td></tr>
<tr><td><code id="plot.tpchreg_+3A_log">log</code></td>
<td>
<p>character, &quot;&quot; (default), &quot;y&quot;, or &quot;xy&quot;.</p>
</td></tr>
<tr><td><code id="plot.tpchreg_+3A_main">main</code></td>
<td>
<p>Header for the plot</p>
</td></tr>
<tr><td><code id="plot.tpchreg_+3A_xlim">xlim</code></td>
<td>
<p>x limits</p>
</td></tr>
<tr><td><code id="plot.tpchreg_+3A_ylim">ylim</code></td>
<td>
<p>y limits</p>
</td></tr>
<tr><td><code id="plot.tpchreg_+3A_xlab">xlab</code></td>
<td>
<p>x label</p>
</td></tr>
<tr><td><code id="plot.tpchreg_+3A_ylab">ylab</code></td>
<td>
<p>y label</p>
</td></tr>
<tr><td><code id="plot.tpchreg_+3A_col">col</code></td>
<td>
<p>Color(s) for the curves. Defaults to black.</p>
</td></tr>
<tr><td><code id="plot.tpchreg_+3A_lty">lty</code></td>
<td>
<p>Line type for the curve(s). Defaults to 1:(No. of strata).</p>
</td></tr>
<tr><td><code id="plot.tpchreg_+3A_printlegend">printLegend</code></td>
<td>
<p>Logical, or character (&quot;topleft&quot;, &quot;bottomleft&quot;,
&quot;topright&quot; or &quot;bottomright&quot;); if <code>TRUE</code> or character, a legend is added
to the plot if the number of strata is two or more.</p>
</td></tr>
<tr><td><code id="plot.tpchreg_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to 'plot' and 'lines'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tpchreg">tpchreg</a></code>
</p>

<hr>
<h2 id='plot.weibreg'>Plots output from a Weibull regression</h2><span id='topic+plot.weibreg'></span>

<h3>Description</h3>

<p>Plot(s) of the hazard, density, cumulative hazards, and/or the survivor
function(s) for each stratum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'weibreg'
plot(
  x,
  fn = c("haz", "cum", "den", "sur"),
  main = NULL,
  xlim = NULL,
  ylim = NULL,
  xlab = NULL,
  ylab = NULL,
  new.data = x$means,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.weibreg_+3A_x">x</code></td>
<td>
<p>A <code>weibreg</code> object</p>
</td></tr>
<tr><td><code id="plot.weibreg_+3A_fn">fn</code></td>
<td>
<p>Which functions shoud be plotted! Default is all. They will scroll
by, so you have to take care explicitely what you want to be produced. See,
eg, <code>par(mfrow = ...)</code></p>
</td></tr>
<tr><td><code id="plot.weibreg_+3A_main">main</code></td>
<td>
<p>Header for the plot</p>
</td></tr>
<tr><td><code id="plot.weibreg_+3A_xlim">xlim</code></td>
<td>
<p>x limits</p>
</td></tr>
<tr><td><code id="plot.weibreg_+3A_ylim">ylim</code></td>
<td>
<p>y limits</p>
</td></tr>
<tr><td><code id="plot.weibreg_+3A_xlab">xlab</code></td>
<td>
<p>x label</p>
</td></tr>
<tr><td><code id="plot.weibreg_+3A_ylab">ylab</code></td>
<td>
<p>y label</p>
</td></tr>
<tr><td><code id="plot.weibreg_+3A_new.data">new.data</code></td>
<td>
<p>At which covariate values?</p>
</td></tr>
<tr><td><code id="plot.weibreg_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to 'plot'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot is drawn at the mean values of the covariates.
</p>


<h3>Value</h3>

<p>No return value
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phreg">phreg</a></code>, <code><a href="#topic+weibreg">weibreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- rweibull(4, shape = 1, scale = 1)
x &lt;- c(1,1,2,2)
fit &lt;- weibreg(Surv(y, c(1,1,1,1)) ~ x)
plot(fit)

</code></pre>

<hr>
<h2 id='plotHaz'>Graphical comparing of cumulative hazards</h2><span id='topic+plotHaz'></span>

<h3>Description</h3>

<p>Comparison of the cumulative hazards functions for a semi-parametric and
parametric models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHaz(
  sp,
  pp,
  interval,
  main = NULL,
  xlab = "Time",
  ylab = "Cum. hazards",
  leglab,
  col = c("blue", "red"),
  lty = 1:2,
  ylim,
  log = "",
  printLegend = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotHaz_+3A_sp">sp</code></td>
<td>
<p>An object of type &quot;coxreg&quot; or &quot;phreg&quot;, typically output from
<code><a href="#topic+coxreg">coxreg</a></code> or <code><a href="#topic+phreg">phreg</a></code>.</p>
</td></tr>
<tr><td><code id="plotHaz_+3A_pp">pp</code></td>
<td>
<p>An object of type &quot;coxreg&quot; or &quot;phreg&quot;, typically output from
<code><a href="#topic+coxreg">coxreg</a></code> or <code><a href="#topic+phreg">phreg</a></code>.</p>
</td></tr>
<tr><td><code id="plotHaz_+3A_interval">interval</code></td>
<td>
<p>Time interval for the plot, if missing, calculated from <code>sp</code>.</p>
</td></tr>
<tr><td><code id="plotHaz_+3A_main">main</code></td>
<td>
<p>Header for the plot. Default is distribution and &quot;cumulative
hazard function&quot;</p>
</td></tr>
<tr><td><code id="plotHaz_+3A_xlab">xlab</code></td>
<td>
<p>Label on x axis (default &quot;Time&quot;)</p>
</td></tr>
<tr><td><code id="plotHaz_+3A_ylab">ylab</code></td>
<td>
<p>Label on y axis (default &quot;Cum. Hazards&quot;)</p>
</td></tr>
<tr><td><code id="plotHaz_+3A_leglab">leglab</code></td>
<td>
<p>Labels in legend.</p>
</td></tr>
<tr><td><code id="plotHaz_+3A_col">col</code></td>
<td>
<p>Line colors. should be <code>NULL</code> (black lines) or of length 2</p>
</td></tr>
<tr><td><code id="plotHaz_+3A_lty">lty</code></td>
<td>
<p>line types.</p>
</td></tr>
<tr><td><code id="plotHaz_+3A_ylim">ylim</code></td>
<td>
<p>Y limits for the plot.</p>
</td></tr>
<tr><td><code id="plotHaz_+3A_log">log</code></td>
<td>
<p>Argument sent to <code>plot</code>, defaults to &quot;&quot;.</p>
</td></tr>
<tr><td><code id="plotHaz_+3A_printlegend">printLegend</code></td>
<td>
<p>Should a legend be printed? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the moment only a graphical comparison. The arguments <code>sp</code> and
<code>pp</code> may be swapped.
</p>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check.dist">check.dist</a></code>, <code><a href="#topic+coxreg">coxreg</a></code> and <code><a href="#topic+phreg">phreg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mort)
op &lt;- par(mfrow = c(1, 2))
fit.cr &lt;- coxreg(Surv(enter, exit, event) ~ ses, data = mort)
fit.w &lt;- phreg(Surv(enter, exit, event) ~ ses, data = mort)
fit.g &lt;- phreg(Surv(enter, exit, event) ~ ses, data = mort,
dist = "gompertz")
plotHaz(fit.cr, fit.w, interval = c(0, 20), main = "Weibull")
plotHaz(fit.cr, fit.g, main = "Gompertz")
par(op)

</code></pre>

<hr>
<h2 id='print.aftreg'>Prints aftreg objects</h2><span id='topic+print.aftreg'></span>

<h3>Description</h3>

<p>The hazard, the cumulative hazard, the density, and the survivor baseline
functions are plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aftreg'
print(x, digits = max(options()$digits - 4, 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.aftreg_+3A_x">x</code></td>
<td>
<p>A <code>aftreg</code> object</p>
</td></tr>
<tr><td><code id="print.aftreg_+3A_digits">digits</code></td>
<td>
<p>Precision in printing</p>
</td></tr>
<tr><td><code id="print.aftreg_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Note</h3>

<p>Doesn't work for threeway or higher order interactions. Use
<code><a href="survival.html#topic+print.coxph">print.coxph</a></code> in that case.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phreg">phreg</a></code>, <code><a href="survival.html#topic+print.coxph">print.coxph</a></code>
</p>

<hr>
<h2 id='print.coxreg'>Prints coxreg objects</h2><span id='topic+print.coxreg'></span>

<h3>Description</h3>

<p>More &quot;pretty-printing&quot; than <code>print.coxph</code>, which is a fall-back for
'difficult' objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxreg'
print(x, digits = max(options()$digits - 4, 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.coxreg_+3A_x">x</code></td>
<td>
<p>A <code>coxreg</code> object, typically the result of running
<code>coxreg</code></p>
</td></tr>
<tr><td><code id="print.coxreg_+3A_digits">digits</code></td>
<td>
<p>Output format.</p>
</td></tr>
<tr><td><code id="print.coxreg_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Doesn't work with three-way and higher interactions, in which case
<code>print.coxph</code> is used.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxreg">coxreg</a></code>, <code><a href="survival.html#topic+print.coxph">print.coxph</a></code>
</p>

<hr>
<h2 id='print.logrank'>Prints logrank objects</h2><span id='topic+print.logrank'></span>

<h3>Description</h3>

<p>The result of <code>logrank</code> is printed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'logrank'
print(x, digits = max(options()$digits - 4, 6), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.logrank_+3A_x">x</code></td>
<td>
<p>A <code>logrank</code> object</p>
</td></tr>
<tr><td><code id="print.logrank_+3A_digits">digits</code></td>
<td>
<p>Precision in printing</p>
</td></tr>
<tr><td><code id="print.logrank_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logrank">logrank</a></code>, <code><a href="#topic+coxreg">coxreg</a></code>
</p>

<hr>
<h2 id='print.phreg'>Prints phreg objects</h2><span id='topic+print.phreg'></span>

<h3>Description</h3>

<p>The hazard, the cumulative hazard, the density, and the survivor baseline
functions are plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phreg'
print(x, digits = max(options()$digits - 4, 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.phreg_+3A_x">x</code></td>
<td>
<p>A <code>phreg</code> object</p>
</td></tr>
<tr><td><code id="print.phreg_+3A_digits">digits</code></td>
<td>
<p>Precision in printing</p>
</td></tr>
<tr><td><code id="print.phreg_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Note</h3>

<p>Doesn't work for threeway or higher order interactions. Use
<code><a href="survival.html#topic+print.coxph">print.coxph</a></code> in that case.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phreg">phreg</a></code>, <code><a href="survival.html#topic+print.coxph">print.coxph</a></code>
</p>

<hr>
<h2 id='print.risksets'>Prints a summary of the content of a set of risk sets.</h2><span id='topic+print.risksets'></span>

<h3>Description</h3>

<p>Given the output from <code>risksets</code>, summary statistics are given for it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'risksets'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.risksets_+3A_x">x</code></td>
<td>
<p>An object of class 'risksets'.</p>
</td></tr>
<tr><td><code id="print.risksets_+3A_...">...</code></td>
<td>
<p>Not used for the moment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned; the function prints summary statistics of risk
sets.
</p>


<h3>Note</h3>

<p>There is no <code>summary.risksets</code> yet. On the TODO list.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code>risksets</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rs &lt;- with(mort, risksets(Surv(enter, exit, event)))
print(rs)

</code></pre>

<hr>
<h2 id='print.summary.aftreg'>Prints summary.aftreg objects</h2><span id='topic+print.summary.aftreg'></span>

<h3>Description</h3>

<p>Prints summary.aftreg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.aftreg'
print(x, digits = max(getOption("digits") - 3, 3), short = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.aftreg_+3A_x">x</code></td>
<td>
<p>A <code>summary.aftreg</code> object, typically the result of running
<code>summary.aftreg</code>, summary on a phreg object.</p>
</td></tr>
<tr><td><code id="print.summary.aftreg_+3A_digits">digits</code></td>
<td>
<p>Output format.</p>
</td></tr>
<tr><td><code id="print.summary.aftreg_+3A_short">short</code></td>
<td>
<p>Logical: If TRUE, short output, only regression.</p>
</td></tr>
<tr><td><code id="print.summary.aftreg_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aftreg">aftreg</a></code>, <code><a href="#topic+summary.aftreg">summary.aftreg</a></code>
</p>

<hr>
<h2 id='print.summary.coxreg'>Prints summary.coxreg objects</h2><span id='topic+print.summary.coxreg'></span>

<h3>Description</h3>

<p>Prints summary.coxreg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.coxreg'
print(x, digits = 3, short = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.coxreg_+3A_x">x</code></td>
<td>
<p>A <code>summary.coxreg</code> object, typically the result of running
<code>summary.coxreg</code>, summary on a coxreg object.</p>
</td></tr>
<tr><td><code id="print.summary.coxreg_+3A_digits">digits</code></td>
<td>
<p>Output format.</p>
</td></tr>
<tr><td><code id="print.summary.coxreg_+3A_short">short</code></td>
<td>
<p>Logical, short or long (default) output?</p>
</td></tr>
<tr><td><code id="print.summary.coxreg_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxreg">coxreg</a></code>, <code><a href="#topic+summary.coxreg">summary.coxreg</a></code>
</p>

<hr>
<h2 id='print.summary.phreg'>Prints summary.phreg objects</h2><span id='topic+print.summary.phreg'></span>

<h3>Description</h3>

<p>Prints summary.phreg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.phreg'
print(x, digits = max(getOption("digits") - 3, 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.phreg_+3A_x">x</code></td>
<td>
<p>A <code>summary.phreg</code> object, typically the result of running
<code>summary.phreg</code>, summary on a phreg object.</p>
</td></tr>
<tr><td><code id="print.summary.phreg_+3A_digits">digits</code></td>
<td>
<p>Output format.</p>
</td></tr>
<tr><td><code id="print.summary.phreg_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phreg">phreg</a></code>, <code><a href="#topic+summary.phreg">summary.phreg</a></code>
</p>

<hr>
<h2 id='print.summary.tpchreg'>Prints summary.tpchreg objects</h2><span id='topic+print.summary.tpchreg'></span>

<h3>Description</h3>

<p>Prints summary.tpchreg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.tpchreg'
print(x, digits = max(getOption("digits") - 3, 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.tpchreg_+3A_x">x</code></td>
<td>
<p>A <code>summary.tpchreg</code> object, typically the result of running
<code>summary.tpchreg</code>, summary on a tpchreg object.</p>
</td></tr>
<tr><td><code id="print.summary.tpchreg_+3A_digits">digits</code></td>
<td>
<p>Output format.</p>
</td></tr>
<tr><td><code id="print.summary.tpchreg_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tpchreg">tpchreg</a></code>, <code><a href="#topic+summary.tpchreg">summary.tpchreg</a></code>
</p>

<hr>
<h2 id='print.tpchreg'>Prints tpchreg objects</h2><span id='topic+print.tpchreg'></span>

<h3>Description</h3>

<p>More &quot;pretty-printing&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tpchreg'
print(x, digits = max(options()$digits - 4, 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.tpchreg_+3A_x">x</code></td>
<td>
<p>A <code>tpchreg</code> object, typically the result of running
<code>tpchreg</code></p>
</td></tr>
<tr><td><code id="print.tpchreg_+3A_digits">digits</code></td>
<td>
<p>Output format.</p>
</td></tr>
<tr><td><code id="print.tpchreg_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Doesn't work with three-way or higher interactions.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tpchreg">tpchreg</a></code>, <code><a href="#topic+print.coxreg">print.coxreg</a></code>
</p>

<hr>
<h2 id='print.weibreg'>Prints weibreg objects</h2><span id='topic+print.weibreg'></span>

<h3>Description</h3>

<p>The hazard, the cumulative hazard, the density, and the survivor baseline
functions are plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'weibreg'
print(x, digits = max(options()$digits - 4, 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.weibreg_+3A_x">x</code></td>
<td>
<p>A <code>weibreg</code> object</p>
</td></tr>
<tr><td><code id="print.weibreg_+3A_digits">digits</code></td>
<td>
<p>Precision in printing</p>
</td></tr>
<tr><td><code id="print.weibreg_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Note</h3>

<p>Doesn't work for threeway or higher order interactions. Use
<code><a href="survival.html#topic+print.coxph">print.coxph</a></code> in that case.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+weibreg">weibreg</a></code>, <code><a href="survival.html#topic+print.coxph">print.coxph</a></code>
</p>

<hr>
<h2 id='regtable'>Retrieves regression tables</h2><span id='topic+regtable'></span>

<h3>Description</h3>

<p>Retrieves regression tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regtable(x, digits = 3, short = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regtable_+3A_x">x</code></td>
<td>
<p>A <code>summary.XXreg</code> object, typically the result of running
<code>summary.XXreg</code>, summary on a XXreg object.</p>
</td></tr>
<tr><td><code id="regtable_+3A_digits">digits</code></td>
<td>
<p>Output format.</p>
</td></tr>
<tr><td><code id="regtable_+3A_short">short</code></td>
<td>
<p>If TRUE, return only coefficients table.</p>
</td></tr>
<tr><td><code id="regtable_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character data frame, ready to print in various formats.
</p>


<h3>Note</h3>

<p>Should not be used if interactions present.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxreg">coxreg</a></code>, <code><a href="#topic+summary.coxreg">summary.coxreg</a></code>
</p>

<hr>
<h2 id='risksets'>Finds the compositions and sizes of risk sets</h2><span id='topic+risksets'></span>

<h3>Description</h3>

<p>Focus is on the risk set composition just prior to a failure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>risksets(
  x,
  strata = NULL,
  max.survs = NULL,
  members = TRUE,
  collate_sets = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="risksets_+3A_x">x</code></td>
<td>
<p>A <code>Surv</code> object.</p>
</td></tr>
<tr><td><code id="risksets_+3A_strata">strata</code></td>
<td>
<p>Stratum indicator.</p>
</td></tr>
<tr><td><code id="risksets_+3A_max.survs">max.survs</code></td>
<td>
<p>Maximum number of survivors in each risk set. If smaller
than the 'natural number', survivors are sampled from the present ones. No
sampling if missing.</p>
</td></tr>
<tr><td><code id="risksets_+3A_members">members</code></td>
<td>
<p>If TRUE, all members of all risk sets are listed in the
resulting list, see below.</p>
</td></tr>
<tr><td><code id="risksets_+3A_collate_sets">collate_sets</code></td>
<td>
<p>logical. If TRUE, group information by
risk sets in a list. Only if <code>members = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input argument max.survs is left alone, all survivors are accounted
for in all risk sets.
</p>


<h3>Value</h3>

<p>A list with components (if <code>collate_sets = FALSE</code>)
</p>
<table>
<tr><td><code>antrs</code></td>
<td>
<p>No. of risk sets in each
stratum. The number of strata is given by <code>length(antrs)</code>.</p>
</td></tr>
<tr><td><code>risktimes</code></td>
<td>
<p>Ordered distinct failure time points.</p>
</td></tr>
<tr><td><code>eventset</code></td>
<td>
<p>If
'members' is TRUE, a vector of pointers to events in each risk set, else
NULL.</p>
</td></tr>
<tr><td><code>riskset</code></td>
<td>
<p>If 'members' is TRUE, a vector of pointers to the
members of the risk sets, in order. The 'n.events' first are the events. If
'members' is FALSE, 'riskset' is NULL.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>The sizes of the risk
sets.</p>
</td></tr>
<tr><td><code>n.events</code></td>
<td>
<p>The number of events in each risk set.</p>
</td></tr>
<tr><td><code>sample_fraction</code></td>
<td>
<p>If 'members' is TRUE, the sampling fraction of
survivors in each risk set.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Can be used to &quot;sample the risk sets&quot;.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+table.events">table.events</a></code>, <code><a href="#topic+coxreg">coxreg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 enter &lt;- c(0, 1, 0, 0)
 exit &lt;- c(1, 2, 3, 4)
 event &lt;- c(1, 1, 1, 0)
 risksets(Surv(enter, exit, event))

</code></pre>

<hr>
<h2 id='scania'>
Old age mortality, Scania, southern Sweden, 1813-1894.
</h2><span id='topic+scania'></span>

<h3>Description</h3>

<p>The data consists of old age life histories from 1 January 1813 to 31 december
1894. Only (parts of) life histories above age 50 is
considered. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(scania)</code></pre>


<h3>Format</h3>

<p>A data frame with 1931 observations from 1931 persons on the following 9 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>Identification number (enumeration).</p>
</dd>
<dt><code>enter</code></dt><dd><p>Start age for the interval.</p>
</dd>
<dt><code>exit</code></dt><dd><p>Stop age for the interval.</p>
</dd>
<dt><code>event</code></dt><dd><p>Indicator of death;
equals <code>TRUE</code> if the person died
at the end of the interval, <code>FALSE</code> otherwise.</p>
</dd>
<dt><code>birthdate</code></dt><dd><p>Birthdate as a real number (i.e.,
&quot;1765-06-27&quot; is 1765.490).</p>
</dd>
<dt><code>sex</code></dt><dd><p>Gender, a factor with levels <code>male</code>
<code>female</code>.</p>
</dd>
<dt><code>parish</code></dt><dd><p>One of five parishes in Scania, coded 1, 2, 3,
4, 5. Factor.</p>
</dd>
<dt><code>ses</code></dt><dd><p>Socio-economic status at age 50, a factor with
levels <code>upper</code> and <code>lower</code>.</p>
</dd>
<dt><code>immigrant</code></dt><dd><p>a factor with levels <code>no</code> <code>region</code>
and <code>yes</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The Scanian area in southern Sweden was during the 19th century a mainly
rural area. 
</p>


<h3>Source</h3>

<p>The Scanian Economic Demographic Database, Lund University, Sweden.
</p>


<h3>References</h3>

<p><a href="https://www.lusem.lu.se/organisation/research-centres/centre-economic-demography/centre-economic-demography-databases">https://www.lusem.lu.se/organisation/research-centres/centre-economic-demography/centre-economic-demography-databases</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(scania)
summary(scania)
</code></pre>

<hr>
<h2 id='summary.aftreg'>Prints aftreg objects</h2><span id='topic+summary.aftreg'></span>

<h3>Description</h3>

<p>Prints aftreg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aftreg'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.aftreg_+3A_object">object</code></td>
<td>
<p>A <code>aftreg</code> object</p>
</td></tr>
<tr><td><code id="summary.aftreg_+3A_...">...</code></td>
<td>
<p>Additional ...</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.coxreg">print.coxreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function (object, ...) 
print(object)

</code></pre>

<hr>
<h2 id='summary.coxreg'>A summary of coxreg objects.</h2><span id='topic+summary.coxreg'></span>

<h3>Description</h3>

<p>A summary of coxreg objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxreg'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.coxreg_+3A_object">object</code></td>
<td>
<p>A <code>coxreg</code> object</p>
</td></tr>
<tr><td><code id="summary.coxreg_+3A_...">...</code></td>
<td>
<p>Additional ...</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.coxreg">print.coxreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fit &lt;- coxreg(Surv(enter, exit, event) ~ sex + civ, data = oldmort)
summary(fit)
 
</code></pre>

<hr>
<h2 id='summary.phreg'>A summary of phreg objects.</h2><span id='topic+summary.phreg'></span>

<h3>Description</h3>

<p>A summary of phreg objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phreg'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.phreg_+3A_object">object</code></td>
<td>
<p>A <code>phreg</code> object</p>
</td></tr>
<tr><td><code id="summary.phreg_+3A_...">...</code></td>
<td>
<p>Additional ...</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.phreg">print.phreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fit &lt;- phreg(Surv(enter, exit, event) ~ sex + civ, 
data = oldmort[oldmort$region == "town", ])
summary(fit)
 
</code></pre>

<hr>
<h2 id='summary.tpchreg'>Summary for tpchreg objects</h2><span id='topic+summary.tpchreg'></span>

<h3>Description</h3>

<p>Summary for tpchreg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tpchreg'
summary(object, ci = FALSE, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.tpchreg_+3A_object">object</code></td>
<td>
<p>A <code>tpchreg</code> object.</p>
</td></tr>
<tr><td><code id="summary.tpchreg_+3A_ci">ci</code></td>
<td>
<p>Logical. If TRUE, confidence limits are given instead of se's.</p>
</td></tr>
<tr><td><code id="summary.tpchreg_+3A_level">level</code></td>
<td>
<p>Confidence level, used if ci.</p>
</td></tr>
<tr><td><code id="summary.tpchreg_+3A_...">...</code></td>
<td>
<p>Additional ...</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tpchreg">tpchreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
## function (object, ...) 

</code></pre>

<hr>
<h2 id='summary.weibreg'>Prints a weibreg object</h2><span id='topic+summary.weibreg'></span>

<h3>Description</h3>

<p>This is the same as <code><a href="#topic+print.weibreg">print.weibreg</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'weibreg'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.weibreg_+3A_object">object</code></td>
<td>
<p>A <code>weibreg</code> object</p>
</td></tr>
<tr><td><code id="summary.weibreg_+3A_...">...</code></td>
<td>
<p>Additional ...</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.weibreg">print.weibreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function (object, ...) 
print(object)

</code></pre>

<hr>
<h2 id='SurvSplit'>Split a survival object at specified durations.</h2><span id='topic+SurvSplit'></span>

<h3>Description</h3>

<p>Given a survival object, (a matrix with two or three columns) and a set of
specified cut times, split each record into multiple subrecords at each cut
time.  The new survival object will be in &lsquo;counting process&rsquo; format, with an
enter time, exit time, and event status for each record.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SurvSplit(Y, cuts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SurvSplit_+3A_y">Y</code></td>
<td>
<p>A survival object, a matrix with two or three columns.</p>
</td></tr>
<tr><td><code id="SurvSplit_+3A_cuts">cuts</code></td>
<td>
<p>The cut points, must be strictly positive and distinct.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components 
</p>
<table>
<tr><td><code>Y</code></td>
<td>
<p>The new survival object with three
columns, i.e., in 'counting process' form.</p>
</td></tr> 
<tr><td><code>ivl</code></td>
<td>
<p>Interval No., starting from leftmost, (0, cuts[1]) or similar.</p>
</td></tr> 
<tr><td><code>idx</code></td>
<td>
<p>Row number for original Y row.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is used in <code><a href="#topic+phreg">phreg</a></code> for the piecewise
constant hazards model. It uses <code><a href="#topic+age.window">age.window</a></code> for each interval.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+survSplit">survSplit</a></code>, <code><a href="#topic+age.window">age.window</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function(Y, cuts){
    if (NCOL(Y) == 2) Y &lt;- cbind(rep(0, NROW(Y)), Y)
    indat &lt;- cbind(Y, 1:NROW(Y), rep(-1, NROW(Y)))
    colnames(indat) &lt;- c("enter", "exit", "event", "idx", "ivl")
    n &lt;- length(cuts)
    cuts &lt;- sort(cuts)
    if ((cuts[1] &lt;= 0) || (cuts[n] == Inf))
        stop("'cuts' must be positive and finite.")
    cuts &lt;- c(0, cuts, Inf)
    n &lt;- n + 1
    out &lt;- list()
    indat &lt;- as.data.frame(indat)
    for (i in 1:n){
        out[[i]] &lt;- age.window(indat, cuts[i:(i+1)])
        out[[i]]$ivl &lt;- i
        out[[i]] &lt;- t(out[[i]])
    }
    Y &lt;- matrix(unlist(out), ncol = 5, byrow = TRUE)
    colnames(Y) &lt;- colnames(indat)
    list(Y = Y[, 1:3],
         ivl = Y[, 5],
         idx = Y[, 4]
         )
  }

</code></pre>

<hr>
<h2 id='swedeaths'>
Swedish death data, 1969-2020.
</h2><span id='topic+swedeaths'></span>

<h3>Description</h3>

<p>A data frame containing data on the number of deaths by sex, age and
year, Sweden 1969-2020.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(swedeaths)</code></pre>


<h3>Format</h3>

<p>A data frame with 5 variables and 10504 observations.
</p>

<dl>
<dt><code>age</code></dt><dd><p>Numerical with integer values 0-100, representing achieved
age in years during the actual calendar year. The highest value, 100, 
represents ages 100 and above.</p>
</dd>
<dt><code>sex</code></dt><dd><p>A factor with two levels, &quot;women&quot; and &quot;men&quot;.</p>
</dd>
<dt><code>year</code></dt><dd><p>Calendar year.</p>
</dd>
<dt><code>deaths</code></dt><dd><p>Number of deaths by age, sex, and year.</p>
</dd>
<dt><code>id</code></dt><dd><p> Created by the <code>reshape</code> procedure, see Details.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data are downloaded from Statistics Sweden in the form of a csv file and
and in that process converted to a data frame. Variable names are
translated from Swedish, 
and some of them are coverted to factors. Each numeric column contains
the number of deaths by sex and age. The original data set is in wide
form and then converted to long format.
</p>


<h3>Source</h3>

<p>Statistics Sweden, <a href="https://www.scb.se">https://www.scb.se</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+swepop">swepop</a></code>, <code><a href="#topic+tpchreg">tpchreg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(swedeaths)
## maybe str(swedeaths) ...
</code></pre>

<hr>
<h2 id='swepop'>
Swedish population data, 1969-2020.
</h2><span id='topic+swepop'></span>

<h3>Description</h3>

<p>A data frame containing data on the population size by sex, age and
year, Sweden 1969-2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(swepop)</code></pre>


<h3>Format</h3>

<p>A data frame with 5 variables and 10504 observations.
</p>

<dl>
<dt><code>age</code></dt><dd><p>Numerical with integer values 0-100, representing achieved
age in years during the actual calendar year.The highest value, 100, 
represents ages 100 and above.</p>
</dd>
<dt><code>sex</code></dt><dd><p>A factor with two levels, &quot;women&quot; and &quot;men&quot;.</p>
</dd>
<dt><code>year</code></dt><dd><p>Calendar year.</p>
</dd>
<dt><code>pop</code></dt><dd><p>Average population by age, sex, and year.</p>
</dd>
<dt>id</dt><dd><p>Created by the <code>reshape</code> procedure, see Details.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data are downloaded from Statistics Sweden in the form of a csv file and
converted to a data frame. Variable names are translated from Swedish,
and some of them are coverted to factors. The variable <code>pop</code> contains
the average population by sex and age, calculated by taking the mean
value of the population size at December 31 the previous year and
December 31 the current year. The original data contain the sizes at the
end of each year. The original data set is in wide format and converted to 
long format by <code>reshape</code>.
</p>


<h3>Source</h3>

<p>Statistics Sweden, <a href="https://www.scb.se">https://www.scb.se</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+swedeaths">swedeaths</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(swepop)
## maybe str(swepop) ...
</code></pre>

<hr>
<h2 id='table.events'>Calculating failure times, risk set sizes and No. of events in each risk set</h2><span id='topic+table.events'></span>

<h3>Description</h3>

<p>From input data of the 'interval' type, with an event indicator, summary
statistics for each risk set (at an event time point) are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table.events(enter = rep(0, length(exit)), exit, event, strict = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table.events_+3A_enter">enter</code></td>
<td>
<p>Left truncation time point.</p>
</td></tr>
<tr><td><code id="table.events_+3A_exit">exit</code></td>
<td>
<p>End time point, an event or a right censoring.</p>
</td></tr>
<tr><td><code id="table.events_+3A_event">event</code></td>
<td>
<p>Event indicator.</p>
</td></tr>
<tr><td><code id="table.events_+3A_strict">strict</code></td>
<td>
<p>If TRUE, then tabulating is not done after a time point where
all individuals in a riskset failed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components </p>
<table>
<tr><td><code>times</code></td>
<td>
<p>Ordered distinct event time
points.</p>
</td></tr> <tr><td><code>events</code></td>
<td>
<p>Number of events at each event time point.</p>
</td></tr>
<tr><td><code>riskset.sizes</code></td>
<td>
<p>Number at risk at each event time point.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+risksets">risksets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
exit = c(1,2,3,4,5)
event = c(1,1,0,1,1)
table.events(exit = exit, event = event)

</code></pre>

<hr>
<h2 id='toBinary'>Transforms a &quot;survival&quot; data frame into a data frame suitable for binary
(logistic) regression</h2><span id='topic+toBinary'></span>

<h3>Description</h3>

<p>The result of the transformation can be used to do survival analysis via
logistic regression. If the <code>cloglog</code> link is used, this corresponds to
a discrete time analogue to Cox's proportional hazards model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toBinary(
  dat,
  surv = c("enter", "exit", "event"),
  strats,
  max.survs = NROW(dat)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toBinary_+3A_dat">dat</code></td>
<td>
<p>A data frame with three variables representing the survival
response. The default is that they are named <code>enter</code>, <code>exit</code>, and
<code>event</code></p>
</td></tr>
<tr><td><code id="toBinary_+3A_surv">surv</code></td>
<td>
<p>A character vector with the names of the three variables
representing survival.</p>
</td></tr>
<tr><td><code id="toBinary_+3A_strats">strats</code></td>
<td>
<p>An eventual stratification variable.</p>
</td></tr>
<tr><td><code id="toBinary_+3A_max.survs">max.survs</code></td>
<td>
<p>Maximal number of survivors per risk set. If set to a
(small) number, survivors are sampled from the risk sets.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>toBinary calls <code>risksets</code> in the <code>eha</code> package.
</p>


<h3>Value</h3>

<p>Returns a data frame expanded risk set by risk set. The three
&quot;survival variables&quot; are replaced by a variable named <code>event</code> (which
overwrites an eventual variable by that name in the input). Two more
variables are created, <code>riskset</code> and <code>orig.row</code>.
</p>
<table>
<tr><td><code>event</code></td>
<td>
<p>Indicates an event in the corresponding risk set.</p>
</td></tr>
<tr><td><code>riskset</code></td>
<td>
<p>Factor (with levels 1, 2, ...) indicating risk set.</p>
</td></tr>
<tr><td><code>risktime</code></td>
<td>
<p>The 'risktime' (age) in the corresponding riskset.</p>
</td></tr>
<tr><td><code>orig.row</code></td>
<td>
<p>The row number for this item in the original data frame.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The survival variables must be three. If you only have <em>exit</em> and
<em>event</em>, create a third containing all zeros.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxreg">coxreg</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
enter &lt;- rep(0, 4)
exit &lt;- 1:4
event &lt;- rep(1, 4)
z &lt;- rep(c(-1, 1), 2)
dat &lt;- data.frame(enter, exit, event, z)
binDat &lt;- toBinary(dat)
dat
binDat
coxreg(Surv(enter, exit, event) ~ z, method = "ml", data = dat)
## Same as:
summary(glm(event ~ z + riskset, data = binDat, family = binomial(link = cloglog)))

</code></pre>

<hr>
<h2 id='toDate'>Convert time in years since &quot;0000-01-01&quot; to a date.</h2><span id='topic+toDate'></span>

<h3>Description</h3>

<p>This function uses <code>as.Date</code> and a simple linear transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toDate(times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toDate_+3A_times">times</code></td>
<td>
<p>a vector of durations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of dates as character strings of the type &quot;1897-05-21&quot;.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+toTime">toTime</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.
toDate(1897.357)

</code></pre>

<hr>
<h2 id='toTime'>Calculate duration in years from &quot;0000-01-01&quot; to a given date</h2><span id='topic+toTime'></span>

<h3>Description</h3>

<p>Given a vector of dates, the output is a vector of durations in years since
&quot;0000-01-01&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toTime(dates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toTime_+3A_dates">dates</code></td>
<td>
<p>A vector of dates in character form or of class <code>Date</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of durations, as decribed above.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+toDate">toDate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.


toTime(c("1897-05-16", "1901-11-21"))

</code></pre>

<hr>
<h2 id='toTpch'>Transform survival data to tabular form</h2><span id='topic+toTpch'></span>

<h3>Description</h3>

<p>Transform a &quot;survival data frame&quot; to tabular form aggregating number of events 
and exposure time by time intervals and covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toTpch(formula, data, cuts, enter = "enter", exit = "exit",
event = "event", episode = "age")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toTpch_+3A_formula">formula</code></td>
<td>
<p>A model formula.</p>
</td></tr>
<tr><td><code id="toTpch_+3A_data">data</code></td>
<td>
<p>A data frame with survival data.</p>
</td></tr>
<tr><td><code id="toTpch_+3A_cuts">cuts</code></td>
<td>
<p>An ordered, non-negative vector of time points at which a hazard function changes value.
Note that data are left truncated at cuts[1] (the smallest value) and right censored at c[n], where 
n  is the length of cuts and cuts[n] == max(cuts).</p>
</td></tr>
<tr><td><code id="toTpch_+3A_enter">enter</code></td>
<td>
<p>Character string with the name of the variable representing left truncation values.</p>
</td></tr>
<tr><td><code id="toTpch_+3A_exit">exit</code></td>
<td>
<p>Character string with the name of the event/censoring time variable.</p>
</td></tr>
<tr><td><code id="toTpch_+3A_event">event</code></td>
<td>
<p>Character string with the name of the event indicator variable.</p>
</td></tr>
<tr><td><code id="toTpch_+3A_episode">episode</code></td>
<td>
<p>Character string with the name of the output variable of the grouped time (a factor variable).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>cuts</code> is missing, nothing is done. Internally, this function first calls 
<code>survival::survSplit</code> and then <code>stats::aggregate</code>.
</p>


<h3>Value</h3>

<p>A data frame with exposure time and number of events aggregated by time intervals and covariates.
If all covariates are factors,this usually results in a huge reduction of the size of thedata frame, 
but otherwise the size of the output may be larger than the size of the input data frame
</p>


<h3>Note</h3>

<p>Episodes, or parts of episodes, outside <code>min(cuts), max(cuts)</code> are cut off. 
With continuous covariates, consider rounding them so that the number of distinct oberved values is not too large.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>

<hr>
<h2 id='tpchreg'>Proportional hazards regression with piecewise constant hazards and tabular 
data.</h2><span id='topic+tpchreg'></span>

<h3>Description</h3>

<p>Proportional hazards regression with piecewise constant hazards and tabular 
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpchreg(formula, data, time, weights, last, subset, na.action, 
contrasts = NULL, start.coef = NULL, 
control = list(epsilon = 1.e-8, maxit = 200, trace = FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tpchreg_+3A_formula">formula</code></td>
<td>
<p>a formula with 'oe(count, exposure) ~ x1 + ...'</p>
</td></tr>
<tr><td><code id="tpchreg_+3A_data">data</code></td>
<td>
<p>a data frame with occurrence/exposure data plus covariates.</p>
</td></tr>
<tr><td><code id="tpchreg_+3A_time">time</code></td>
<td>
<p>the time variable, a factor character vector indicating time 
intervals, or numeric, indicating the start of intervals.</p>
</td></tr>
<tr><td><code id="tpchreg_+3A_weights">weights</code></td>
<td>
<p>Case weights.</p>
</td></tr>
<tr><td><code id="tpchreg_+3A_last">last</code></td>
<td>
<p>If <code>time</code> is numeric, the closing of the last interval.</p>
</td></tr>
<tr><td><code id="tpchreg_+3A_subset">subset</code></td>
<td>
<p>subset of data, not implemented yet.</p>
</td></tr>
<tr><td><code id="tpchreg_+3A_na.action">na.action</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="tpchreg_+3A_contrasts">contrasts</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="tpchreg_+3A_start.coef">start.coef</code></td>
<td>
<p>For the moment equal to zero, not used.</p>
</td></tr>
<tr><td><code id="tpchreg_+3A_control">control</code></td>
<td>
<p>list of control parameters for the optimization.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The interpretation of cuts is different from that in <code><a href="#topic+hpch">hpch</a></code>.
This is intentional.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+oe">oe</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sw &lt;- swepop
sw$deaths &lt;- swedeaths$deaths
fit &lt;- tpchreg(oe(deaths, pop) ~ strata(sex) + I(year - 2000), 
time = age, last = 101, data = sw[sw$year &gt;= 2000, ])
summary(fit)

</code></pre>

<hr>
<h2 id='weibreg'>Weibull Regression</h2><span id='topic+weibreg'></span>

<h3>Description</h3>

<p>Proportional hazards model with baseline hazard(s) from the Weibull family
of distributions.  Allows for stratification with different scale and shape
in each stratum, and left truncated and right censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weibreg(
  formula = formula(data),
  data = parent.frame(),
  na.action = getOption("na.action"),
  init,
  shape = 0,
  control = list(eps = 1e-04, maxiter = 10, trace = FALSE),
  singular.ok = TRUE,
  model = FALSE,
  x = FALSE,
  y = TRUE,
  center = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weibreg_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a ~
operator, and the terms on the right.  The response must be a survival
object as returned by the Surv function.</p>
</td></tr>
<tr><td><code id="weibreg_+3A_data">data</code></td>
<td>
<p>a data.frame in which to interpret the variables named in the
formula.</p>
</td></tr>
<tr><td><code id="weibreg_+3A_na.action">na.action</code></td>
<td>
<p>a missing-data filter function, applied to the model.frame,
after any subset argument has been used.  Default is
<code>options()$na.action</code>.</p>
</td></tr>
<tr><td><code id="weibreg_+3A_init">init</code></td>
<td>
<p>vector of initial values of the iteration.  Default initial
value is zero for all variables.</p>
</td></tr>
<tr><td><code id="weibreg_+3A_shape">shape</code></td>
<td>
<p>If positive, the shape parameter is fixed at that value (in
each stratum).  If zero or negative, the shape parameter is estimated.  If
more than one stratum is present in data, each stratum gets its own
estimate.</p>
</td></tr>
<tr><td><code id="weibreg_+3A_control">control</code></td>
<td>
<p>a list with components <code>eps</code> (convergence criterion),
<code>maxiter</code> (maximum number of iterations), and <code>silent</code> (logical,
controlling amount of output).  You can change any component without mention
the other(s).</p>
</td></tr>
<tr><td><code id="weibreg_+3A_singular.ok">singular.ok</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="weibreg_+3A_model">model</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="weibreg_+3A_x">x</code></td>
<td>
<p>Return the design matrix in the model object?</p>
</td></tr>
<tr><td><code id="weibreg_+3A_y">y</code></td>
<td>
<p>Return the response in the model object?</p>
</td></tr>
<tr><td><code id="weibreg_+3A_center">center</code></td>
<td>
<p>Deprecated, and not used.  Will be removed in the future.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameterization is the same as in <code><a href="#topic+coxreg">coxreg</a></code> and
<code><a href="survival.html#topic+coxph">coxph</a></code>, but different from the one used by
<code><a href="survival.html#topic+survreg">survreg</a></code>. The model is </p>
<p style="text-align: center;"><code class="reqn">h(t; a, b, \beta, z) =
(a/b) (t/b)^{a-1} exp(z\beta)</code>
</p>
<p> This is in correspondence with <code><a href="#topic+Weibull">Weibull</a></code>. To
compare regression coefficients with those from <code>survreg</code> you need to
divide by estimated shape (<code class="reqn">\hat{a}</code>) and change sign. The p-values
and test statistics are however the same, with one exception; the score test
is done at maximized scale and shape in <code>weibreg</code>.
</p>
<p>This model is a Weibull distribution with shape parameter <code class="reqn">a</code> and scale
parameter <code class="reqn">b \exp(-z\beta / a)</code>
</p>


<h3>Value</h3>

<p>A list of class <code>c("weibreg", "coxreg")</code> with components
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>Fitted parameter estimates.</p>
</td></tr> <tr><td><code>var</code></td>
<td>
<p>Covariance
matrix of the estimates.</p>
</td></tr> <tr><td><code>loglik</code></td>
<td>
<p>Vector of length two; first
component is the value at the initial parameter values, the second componet
is the maximized value.</p>
</td></tr> <tr><td><code>score</code></td>
<td>
<p>The score test statistic (at the
initial value).</p>
</td></tr> <tr><td><code>linear.predictors</code></td>
<td>
<p>The estimated linear predictors.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>Means of the columns of the design matrix.</p>
</td></tr>
<tr><td><code>w.means</code></td>
<td>
<p>Weighted (against exposure time) means of covariates;
weighted relative frequencies of levels of factors.</p>
</td></tr> <tr><td><code>n</code></td>
<td>
<p>Number of
spells in indata (possibly after removal of cases with NA's).</p>
</td></tr>
<tr><td><code>events</code></td>
<td>
<p>Number of events in data.</p>
</td></tr> <tr><td><code>terms</code></td>
<td>
<p>Used by extractor
functions.</p>
</td></tr> <tr><td><code>assign</code></td>
<td>
<p>Used by extractor functions.</p>
</td></tr> 
<tr><td><code>wald.test</code></td>
<td>
<p>The Wald test statistic (at the initial value).</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The Surv vector.</p>
</td></tr> <tr><td><code>isF</code></td>
<td>
<p>Logical vector indicating the
covariates that are factors.</p>
</td></tr> <tr><td><code>covars</code></td>
<td>
<p>The covariates.</p>
</td></tr>
<tr><td><code>ttr</code></td>
<td>
<p>Total Time at Risk.</p>
</td></tr> <tr><td><code>levels</code></td>
<td>
<p>List of levels of factors.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The calling formula.</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>The call.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method.</p>
</td></tr> <tr><td><code>convergence</code></td>
<td>
<p>Did the optimization
converge?</p>
</td></tr> <tr><td><code>fail</code></td>
<td>
<p>Did the optimization fail? (Is <code>NULL</code> if not).</p>
</td></tr>
<tr><td><code>pfixed</code></td>
<td>
<p>TRUE if shape was fixed in the estimation.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The print method <code><a href="#topic+print.weibreg">print.weibreg</a></code> doesn't work
if threeway or higher order interactions are present.
</p>
<p>Note further that covariates are internally centered, if <code>center =
TRUE</code>, by this function, and this is not corrected for in the output. This
affects the estimate of <code class="reqn">\log(scale)</code>, but nothing else. If
you don't like this, set <code>center = FALSE</code>.
</p>


<h3>Note</h3>

<p>This function is not maintained, and may behave in unpredictable ways.
Use <code><a href="#topic+phreg">phreg</a></code> with <code>dist = "weibull"</code> (the default) instead!
Will soon be declared deprecated.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phreg">phreg</a></code>, <code><a href="#topic+coxreg">coxreg</a></code>,
<code><a href="#topic+print.weibreg">print.weibreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 dat &lt;- data.frame(time = c(4, 3, 1, 1, 2, 2, 3),
                status = c(1, 1, 1, 0, 1, 1, 0),
                x = c(0, 2, 1, 1, 1, 0, 0),
                sex = c(0, 0, 0, 0, 1, 1, 1))
 weibreg( Surv(time, status) ~ x + strata(sex), data = dat) #stratified model

</code></pre>

<hr>
<h2 id='weibreg.fit'>Weibull regression</h2><span id='topic+weibreg.fit'></span>

<h3>Description</h3>

<p>This function is called by <code><a href="#topic+weibreg">weibreg</a></code>, but it can also be
directly called by a user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weibreg.fit(X, Y, strata, offset, init, shape, control, center = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weibreg.fit_+3A_x">X</code></td>
<td>
<p>The design (covariate) matrix.</p>
</td></tr>
<tr><td><code id="weibreg.fit_+3A_y">Y</code></td>
<td>
<p>A survival object, the response.</p>
</td></tr>
<tr><td><code id="weibreg.fit_+3A_strata">strata</code></td>
<td>
<p>A stratum variable.</p>
</td></tr>
<tr><td><code id="weibreg.fit_+3A_offset">offset</code></td>
<td>
<p>Offset.</p>
</td></tr>
<tr><td><code id="weibreg.fit_+3A_init">init</code></td>
<td>
<p>Initial regression parameter values.</p>
</td></tr>
<tr><td><code id="weibreg.fit_+3A_shape">shape</code></td>
<td>
<p>If positive, a fixed value of the shape parameter in the
Weibull distribution. Otherwise, the shape is estimated.</p>
</td></tr>
<tr><td><code id="weibreg.fit_+3A_control">control</code></td>
<td>
<p>Controls convergence and output.</p>
</td></tr>
<tr><td><code id="weibreg.fit_+3A_center">center</code></td>
<td>
<p>Should covariates be centered?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+weibreg">weibreg</a></code> for more detail.
</p>


<h3>Value</h3>

<table>
<tr><td><code>coefficients</code></td>
<td>
<p>Estimated regression coefficients plus estimated
scale and shape coefficients, sorted by strata, if present.</p>
</td></tr> <tr><td><code>var</code></td>
<td>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Vector of length 2. The first component is the maximized
loglihood with only scale and shape in the model, the second the final
maximum.</p>
</td></tr> <tr><td><code>score</code></td>
<td>
<p>Score test statistic at initial values</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>Linear predictors for each interval.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>Means of the covariates</p>
</td></tr> <tr><td><code>conver</code></td>
<td>
<p>TRUE if convergence</p>
</td></tr>
<tr><td><code>fail</code></td>
<td>
<p>TRUE if failure</p>
</td></tr> <tr><td><code>iter</code></td>
<td>
<p>Number of Newton-Raphson iterates.</p>
</td></tr>
<tr><td><code>n.strata</code></td>
<td>
<p>The number of strata in the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+weibreg">weibreg</a></code>
</p>

<hr>
<h2 id='Weibull'>The (Cumulative) Hazard Function of a Weibull Distribution</h2><span id='topic+Weibull'></span><span id='topic+hweibull'></span><span id='topic+Hweibull'></span>

<h3>Description</h3>

<p><code>hweibull</code> calculates the hazard function of a Weibull distribution,
and <code>Hweibull</code> calculates the corresponding cumulative hazard function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hweibull(x, shape, scale = 1, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Weibull_+3A_x">x</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="Weibull_+3A_shape">shape</code></td>
<td>
<p>The shape parameter.</p>
</td></tr>
<tr><td><code id="Weibull_+3A_scale">scale</code></td>
<td>
<p>The scale parameter, defaults to 1.</p>
</td></tr>
<tr><td><code id="Weibull_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, the log of the hazard function is given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="stats.html#topic+dweibull">dweibull</a>.
</p>


<h3>Value</h3>

<p>The (cumulative) hazard function, evaluated at x.
</p>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+pweibull">pweibull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hweibull(3, 2, 1)
dweibull(3, 2, 1) / pweibull(3, 2, 1, lower.tail = FALSE)
Hweibull(3, 2, 1)
-pweibull(3, 2, 1, log.p = TRUE, lower.tail = FALSE)

</code></pre>

<hr>
<h2 id='wfunk'>Loglihood function of a Weibull regression</h2><span id='topic+wfunk'></span>

<h3>Description</h3>

<p>Calculates minus the log likelihood function and its first and second order
derivatives for data from a Weibull regression model. Is called by
<code><a href="#topic+weibreg">weibreg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wfunk(
  beta = NULL,
  lambda,
  p,
  X = NULL,
  Y,
  offset = rep(0, length(Y)),
  ord = 2,
  pfixed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wfunk_+3A_beta">beta</code></td>
<td>
<p>Regression parameters</p>
</td></tr>
<tr><td><code id="wfunk_+3A_lambda">lambda</code></td>
<td>
<p>The scale paramater</p>
</td></tr>
<tr><td><code id="wfunk_+3A_p">p</code></td>
<td>
<p>The shape parameter</p>
</td></tr>
<tr><td><code id="wfunk_+3A_x">X</code></td>
<td>
<p>The design (covariate) matrix.</p>
</td></tr>
<tr><td><code id="wfunk_+3A_y">Y</code></td>
<td>
<p>The response, a survival object.</p>
</td></tr>
<tr><td><code id="wfunk_+3A_offset">offset</code></td>
<td>
<p>Offset.</p>
</td></tr>
<tr><td><code id="wfunk_+3A_ord">ord</code></td>
<td>
<p>ord = 0 means only loglihood, 1 means score vector as well, 2
loglihood, score and hessian.</p>
</td></tr>
<tr><td><code id="wfunk_+3A_pfixed">pfixed</code></td>
<td>
<p>Logical, if TRUE the shape parameter is regarded as a known
constant in the calculations, meaning that it is not cosidered in the
partial derivatives.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the function returns log likelihood, score vector and minus
hessian, i.e. the observed information. The model is 
</p>
<p style="text-align: center;"><code class="reqn">h(t; p, \lambda,\beta, z) = p / \lambda (t / \lambda)^{(p-1)}\exp{(-( t / \lambda)^p})\exp(z\beta)</code>
</p>
<p> This is in correspondence with <code><a href="stats.html#topic+dweibull">dweibull</a></code>.
</p>


<h3>Value</h3>

<p>A list with components </p>
<table>
<tr><td><code>f</code></td>
<td>
<p>The log likelihood. Present if
<code>ord &gt;= 0</code></p>
</td></tr> <tr><td><code>fp</code></td>
<td>
<p>The score vector. Present if <code>ord &gt;= 1</code></p>
</td></tr>
<tr><td><code>fpp</code></td>
<td>
<p>The negative of the hessian. Present if <code>ord &gt;= 2</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Göran Broström
</p>


<h3>See Also</h3>

<p><code><a href="#topic+weibreg">weibreg</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
