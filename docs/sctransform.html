<!DOCTYPE html><html><head><title>Help for package sctransform</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sctransform}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compare_expression'><p>Compare gene expression between two groups</p></a></li>
<li><a href='#correct'><p>Correct data by setting all latent factors to their median values and reversing the regression model</p></a></li>
<li><a href='#correct_counts'><p>Correct data by setting all latent factors to their median values and reversing the regression model</p></a></li>
<li><a href='#diff_mean_test'><p>Non-parametric differential expression test for sparse non-negative data</p></a></li>
<li><a href='#diff_mean_test_conserved'><p>Find differentially expressed genes that are conserved across samples</p></a></li>
<li><a href='#generate'><p>Generate data from regularized models.</p></a></li>
<li><a href='#get_model_var'><p>Return average variance under negative binomial model</p></a></li>
<li><a href='#get_nz_median2'><p>Get median of non zero UMIs from a count matrix</p></a></li>
<li><a href='#get_residual_var'><p>Return variance of residuals of regularized models</p></a></li>
<li><a href='#get_residuals'><p>Return Pearson or deviance residuals of regularized models</p></a></li>
<li><a href='#is_outlier'><p>Identify outliers</p></a></li>
<li><a href='#make.sparse'><p>Convert a given matrix to dgCMatrix</p></a></li>
<li><a href='#pbmc'><p>Peripheral Blood Mononuclear Cells (PBMCs)</p></a></li>
<li><a href='#plot_model'><p>Plot observed UMI counts and model</p></a></li>
<li><a href='#plot_model_pars'><p>Plot estimated and fitted model parameters</p></a></li>
<li><a href='#robust_scale'><p>Robust scale using median and mad</p></a></li>
<li><a href='#robust_scale_binned'><p>Robust scale using median and mad per bin</p></a></li>
<li><a href='#row_gmean'><p>Geometric mean per row</p></a></li>
<li><a href='#row_var'><p>Variance per row</p></a></li>
<li><a href='#smooth_via_pca'><p>Smooth data by PCA</p></a></li>
<li><a href='#umify'><p>Quantile normalization of cell-level data to match typical UMI count data</p></a></li>
<li><a href='#umify_data'><p>Transformation functions for umify</p></a></li>
<li><a href='#vst'><p>Variance stabilizing transformation for UMI count data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Variance Stabilizing Transformations for Single Cell UMI Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-18</td>
</tr>
<tr>
<td>Description:</td>
<td>A normalization method for single-cell UMI count data using a 
  variance stabilizing transformation. The transformation is based on a 
  negative binomial regression model with regularized parameters. As part of the
  same regression framework, this package also provides functions for
  batch correction, and data correction. See Hafemeister and Satija (2019)
  &lt;<a href="https://doi.org/10.1186%2Fs13059-019-1874-1">doi:10.1186/s13059-019-1874-1</a>&gt;, and Choudhary and Satija (2022) &lt;<a href="https://doi.org/10.1186%2Fs13059-021-02584-9">doi:10.1186/s13059-021-02584-9</a>&gt;
  for more details.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/satijalab/sctransform">https://github.com/satijalab/sctransform</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/satijalab/sctransform/issues">https://github.com/satijalab/sctransform/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppArmadillo, Rcpp (&ge; 0.11.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, magrittr, MASS, Matrix (&ge; 1.5-0), methods,
future.apply, future, ggplot2, reshape2, rlang, gridExtra,
matrixStats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>irlba, testthat, knitr</td>
</tr>
<tr>
<td>Enhances:</td>
<td>glmGamPoi</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-19 00:10:57 UTC; choudharys</td>
</tr>
<tr>
<td>Author:</td>
<td>Christoph Hafemeister
    <a href="https://orcid.org/0000-0001-6365-8254"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Saket Choudhary <a href="https://orcid.org/0000-0001-5202-7633"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Rahul Satija <a href="https://orcid.org/0000-0001-9448-8833"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Saket Choudhary &lt;schoudhary@nygenome.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-19 04:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='compare_expression'>Compare gene expression between two groups</h2><span id='topic+compare_expression'></span>

<h3>Description</h3>

<p>Compare gene expression between two groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_expression(
  x,
  umi,
  group,
  val1,
  val2,
  method = "LRT",
  bin_size = 256,
  cell_attr = x$cell_attr,
  y = x$y,
  min_cells = 5,
  weighted = TRUE,
  randomize = FALSE,
  verbosity = 2,
  verbose = NULL,
  show_progress = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_expression_+3A_x">x</code></td>
<td>
<p>A list that provides model parameters and optionally meta data; use output of vst function</p>
</td></tr>
<tr><td><code id="compare_expression_+3A_umi">umi</code></td>
<td>
<p>A matrix of UMI counts with genes as rows and cells as columns</p>
</td></tr>
<tr><td><code id="compare_expression_+3A_group">group</code></td>
<td>
<p>A vector indicating the groups</p>
</td></tr>
<tr><td><code id="compare_expression_+3A_val1">val1</code></td>
<td>
<p>A vector indicating the values of the group vector to treat as group 1</p>
</td></tr>
<tr><td><code id="compare_expression_+3A_val2">val2</code></td>
<td>
<p>A vector indicating the values of the group vector to treat as group 2</p>
</td></tr>
<tr><td><code id="compare_expression_+3A_method">method</code></td>
<td>
<p>Either 'LRT' for likelihood ratio test, or 't_test' for t-test</p>
</td></tr>
<tr><td><code id="compare_expression_+3A_bin_size">bin_size</code></td>
<td>
<p>Number of genes that are processed between updates of progress bar</p>
</td></tr>
<tr><td><code id="compare_expression_+3A_cell_attr">cell_attr</code></td>
<td>
<p>Data frame of cell meta data</p>
</td></tr>
<tr><td><code id="compare_expression_+3A_y">y</code></td>
<td>
<p>Only used if methtod = 't_test', this is the residual matrix; default is x$y</p>
</td></tr>
<tr><td><code id="compare_expression_+3A_min_cells">min_cells</code></td>
<td>
<p>A gene has to be detected in at least this many cells in at least one of the groups being compared to be tested</p>
</td></tr>
<tr><td><code id="compare_expression_+3A_weighted">weighted</code></td>
<td>
<p>Balance the groups by using the appropriate weights</p>
</td></tr>
<tr><td><code id="compare_expression_+3A_randomize">randomize</code></td>
<td>
<p>Boolean indicating whether to shuffle group labels - only set to TRUE when testing methods</p>
</td></tr>
<tr><td><code id="compare_expression_+3A_verbosity">verbosity</code></td>
<td>
<p>An integer specifying whether to show only messages (1), messages and progress bars (2) or nothing (0) while the function is running; default is 2</p>
</td></tr>
<tr><td><code id="compare_expression_+3A_verbose">verbose</code></td>
<td>
<p>Deprecated; use verbosity instead</p>
</td></tr>
<tr><td><code id="compare_expression_+3A_show_progress">show_progress</code></td>
<td>
<p>Deprecated; use verbosity instead</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame of results
</p>

<hr>
<h2 id='correct'>Correct data by setting all latent factors to their median values and reversing the regression model</h2><span id='topic+correct'></span>

<h3>Description</h3>

<p>Correct data by setting all latent factors to their median values and reversing the regression model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct(
  x,
  data = "y",
  cell_attr = x$cell_attr,
  as_is = FALSE,
  do_round = TRUE,
  do_pos = TRUE,
  scale_factor = NA,
  verbosity = 2,
  verbose = NULL,
  show_progress = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correct_+3A_x">x</code></td>
<td>
<p>A list that provides model parameters and optionally meta data; use output of vst function</p>
</td></tr>
<tr><td><code id="correct_+3A_data">data</code></td>
<td>
<p>The name of the entry in x that holds the data</p>
</td></tr>
<tr><td><code id="correct_+3A_cell_attr">cell_attr</code></td>
<td>
<p>Provide cell meta data holding latent data info</p>
</td></tr>
<tr><td><code id="correct_+3A_as_is">as_is</code></td>
<td>
<p>Use cell attributes as is and do not use the median; set to TRUE if you want to
manually control the values of the latent factors; default is FALSE</p>
</td></tr>
<tr><td><code id="correct_+3A_do_round">do_round</code></td>
<td>
<p>Round the result to integers</p>
</td></tr>
<tr><td><code id="correct_+3A_do_pos">do_pos</code></td>
<td>
<p>Set negative values in the result to zero</p>
</td></tr>
<tr><td><code id="correct_+3A_scale_factor">scale_factor</code></td>
<td>
<p>Replace all values of UMI in the regression model by this value. Default is NA
which uses median of total UMI as the latent factor.</p>
</td></tr>
<tr><td><code id="correct_+3A_verbosity">verbosity</code></td>
<td>
<p>An integer specifying whether to show only messages (1), messages and progress bars (2) or nothing (0) while the function is running; default is 2</p>
</td></tr>
<tr><td><code id="correct_+3A_verbose">verbose</code></td>
<td>
<p>Deprecated; use verbosity instead</p>
</td></tr>
<tr><td><code id="correct_+3A_show_progress">show_progress</code></td>
<td>
<p>Deprecated; use verbosity instead</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Corrected data as UMI counts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vst_out &lt;- vst(pbmc, return_cell_attr = TRUE)
umi_corrected &lt;- correct(vst_out)


</code></pre>

<hr>
<h2 id='correct_counts'>Correct data by setting all latent factors to their median values and reversing the regression model</h2><span id='topic+correct_counts'></span>

<h3>Description</h3>

<p>This version does not need a matrix of Pearson residuals. It takes the count matrix as input and
calculates the residuals on the fly. The corrected UMI counts will be rounded to the nearest
integer and negative values clipped to 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct_counts(
  x,
  umi,
  cell_attr = x$cell_attr,
  scale_factor = NA,
  verbosity = 2,
  verbose = NULL,
  show_progress = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correct_counts_+3A_x">x</code></td>
<td>
<p>A list that provides model parameters and optionally meta data; use output of vst function</p>
</td></tr>
<tr><td><code id="correct_counts_+3A_umi">umi</code></td>
<td>
<p>The count matrix</p>
</td></tr>
<tr><td><code id="correct_counts_+3A_cell_attr">cell_attr</code></td>
<td>
<p>Provide cell meta data holding latent data info</p>
</td></tr>
<tr><td><code id="correct_counts_+3A_scale_factor">scale_factor</code></td>
<td>
<p>Replace all values of UMI in the regression model by this value. Default is NA
which uses median of total UMI as the latent factor.</p>
</td></tr>
<tr><td><code id="correct_counts_+3A_verbosity">verbosity</code></td>
<td>
<p>An integer specifying whether to show only messages (1), messages and progress bars (2) or nothing (0) while the function is running; default is 2</p>
</td></tr>
<tr><td><code id="correct_counts_+3A_verbose">verbose</code></td>
<td>
<p>Deprecated; use verbosity instead</p>
</td></tr>
<tr><td><code id="correct_counts_+3A_show_progress">show_progress</code></td>
<td>
<p>Deprecated; use verbosity instead</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Corrected data as UMI counts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vst_out &lt;- vst(pbmc, return_cell_attr = TRUE)
umi_corrected &lt;- correct_counts(vst_out, pbmc)


</code></pre>

<hr>
<h2 id='diff_mean_test'>Non-parametric differential expression test for sparse non-negative data</h2><span id='topic+diff_mean_test'></span>

<h3>Description</h3>

<p>Non-parametric differential expression test for sparse non-negative data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_mean_test(
  y,
  group_labels,
  compare = "each_vs_rest",
  R = 99,
  log2FC_th = log2(1.2),
  mean_th = 0.05,
  cells_th = 5,
  only_pos = FALSE,
  only_top_n = NULL,
  mean_type = "geometric",
  verbosity = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_mean_test_+3A_y">y</code></td>
<td>
<p>A matrix of counts; must be (or inherit from) class dgCMatrix; genes are row,
cells are columns</p>
</td></tr>
<tr><td><code id="diff_mean_test_+3A_group_labels">group_labels</code></td>
<td>
<p>The group labels (e.g. cluster identities); 
will be converted to factor</p>
</td></tr>
<tr><td><code id="diff_mean_test_+3A_compare">compare</code></td>
<td>
<p>Specifies which groups to compare, see details; default is 'each_vs_rest'</p>
</td></tr>
<tr><td><code id="diff_mean_test_+3A_r">R</code></td>
<td>
<p>The number of random permutations used to derive the p-values; default is 99</p>
</td></tr>
<tr><td><code id="diff_mean_test_+3A_log2fc_th">log2FC_th</code></td>
<td>
<p>Threshold to remove genes from testing; absolute log2FC must be at least
this large for a gene to be tested; default is <code>log2(1.2)</code></p>
</td></tr>
<tr><td><code id="diff_mean_test_+3A_mean_th">mean_th</code></td>
<td>
<p>Threshold to remove genes from testing; gene mean must be at least this
large for a gene to be tested; default is 0.05</p>
</td></tr>
<tr><td><code id="diff_mean_test_+3A_cells_th">cells_th</code></td>
<td>
<p>Threshold to remove genes from testing; gene must be detected (non-zero count)
in at least this many cells in the group with higher mean; default is 5</p>
</td></tr>
<tr><td><code id="diff_mean_test_+3A_only_pos">only_pos</code></td>
<td>
<p>Test only genes with positive fold change (mean in group 1 &gt; mean in group2); 
default is FALSE</p>
</td></tr>
<tr><td><code id="diff_mean_test_+3A_only_top_n">only_top_n</code></td>
<td>
<p>Test only the this number of genes from both ends of the log2FC spectrum
after all of the above filters have been applied; useful to get only the top markers; 
only used if set to a numeric value; default is NULL</p>
</td></tr>
<tr><td><code id="diff_mean_test_+3A_mean_type">mean_type</code></td>
<td>
<p>Which type of mean to use; if <code>'geometric'</code> (default) the geometric mean is
used; to avoid <code>log(0)</code> we use <code>log1p</code> to add 1 to all counts and log-transform, 
calculate the arithmetic mean, and then back-transform and subtract 1 using <code>exp1m</code>; if
this parameter is set to <code>'arithmetic'</code> the data is used as is</p>
</td></tr>
<tr><td><code id="diff_mean_test_+3A_verbosity">verbosity</code></td>
<td>
<p>Integer controlling how many messages the function prints; 
0 is silent, 1 (default) is not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame of results
</p>


<h3>Details</h3>

<p>This model-free test is applied to each gene (row) individually but is
optimized to make use of the efficient sparse data representation of
the input. A permutation null distribution us used to assess the 
significance of the observed difference in mean between two groups.
</p>
<p>The observed difference in mean is compared against a distribution
obtained by random shuffling of the group labels. For each gene every 
random permutation yields a difference in mean and from the population of
these background differences we estimate a mean and standard
deviation for the null distribution. 
This mean and standard deviation are used to turn the observed
difference in mean into a z-score and then into a p-value. Finally,
all p-values (for the tested genes) are adjusted using the Benjamini &amp; Hochberg
method (fdr). The log2FC values in the output are <code>log2(mean1 / mean2)</code>.
Empirical p-values are also calculated: <code>emp_pval = (b + 1) / (R + 1)</code>
where b is the number of times the absolute difference in mean from a random 
permutation is at least as large as the absolute value of the observed difference
in mean, R is the number of random permutations. This is an upper bound of
the real empirical p-value that would be obtained by enumerating all possible
group label permutations.
</p>
<p>There are multiple ways the group comparisons can be specified based on the compare
parameter. The default, <code>'each_vs_rest'</code>, does multiple comparisons, one per 
group vs all remaining cells. <code>'all_vs_all'</code>, also does multiple comparisons, 
covering all groups pairs. If compare is set to a length two character vector, e.g.
<code>c('T-cells', 'B-cells')</code>, one comparison between those two groups is done.
To put multiple groups on either side of a single comparison, use a list of length two. 
E.g. <code>compare = list(c('cluster1', 'cluster5'), c('cluster3'))</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
clustering &lt;- 1:ncol(pbmc) %% 2
vst_out &lt;- vst(pbmc, return_corrected_umi = TRUE)
de_res &lt;- diff_mean_test(y = vst_out$umi_corrected, group_labels = clustering)


</code></pre>

<hr>
<h2 id='diff_mean_test_conserved'>Find differentially expressed genes that are conserved across samples</h2><span id='topic+diff_mean_test_conserved'></span>

<h3>Description</h3>

<p>Find differentially expressed genes that are conserved across samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_mean_test_conserved(
  y,
  group_labels,
  sample_labels,
  balanced = TRUE,
  compare = "each_vs_rest",
  pval_th = 1e-04,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_mean_test_conserved_+3A_y">y</code></td>
<td>
<p>A matrix of counts; must be (or inherit from) class dgCMatrix; genes are rows,
cells are columns</p>
</td></tr>
<tr><td><code id="diff_mean_test_conserved_+3A_group_labels">group_labels</code></td>
<td>
<p>The group labels (i.e. clusters or time points); 
will be converted to factor</p>
</td></tr>
<tr><td><code id="diff_mean_test_conserved_+3A_sample_labels">sample_labels</code></td>
<td>
<p>The sample labels; will be converted to factor</p>
</td></tr>
<tr><td><code id="diff_mean_test_conserved_+3A_balanced">balanced</code></td>
<td>
<p>Boolean, see details for explanation; default is TRUE</p>
</td></tr>
<tr><td><code id="diff_mean_test_conserved_+3A_compare">compare</code></td>
<td>
<p>Specifies which groups to compare, see details; currently only 'each_vs_rest' 
(the default) is supported</p>
</td></tr>
<tr><td><code id="diff_mean_test_conserved_+3A_pval_th">pval_th</code></td>
<td>
<p>P-value threshold used to call a gene differentially expressed when summarizing 
the tests per gene</p>
</td></tr>
<tr><td><code id="diff_mean_test_conserved_+3A_...">...</code></td>
<td>
<p>Parameters passed to diff_mean_test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame of results
</p>


<h3>Details</h3>

<p>This function calls diff_mean_test repeatedly and aggregates the results per group and gene.
</p>
<p>If balanced is TRUE (the default), it is assumed that each sample spans multiple groups, 
as would be the case when merging or integrating samples from the same tissue followed by 
clustering. Here the group labels would be the clusters and cluster markers would have support
in each sample.
</p>
<p>If balanced is FALSE, an unbalanced design is assumed where each sample contributes to one
group. An example is a time series experiment where some samples are taken from time point 
1 while other samples are taken from time point 2. The time point would be the group label
and the goal would be to identify differentially expressed genes between time points that
are supported by many between-sample comparisons.
</p>
<p>Output columns:
</p>

<dl>
<dt>group1</dt><dd><p>Group label of the frist group of cells</p>
</dd>
<dt>group2</dt><dd><p>Group label of the second group of cells; currently fixed to 'rest'</p>
</dd>
<dt>gene</dt><dd><p>Gene name (from rownames of input matrix)</p>
</dd>
<dt>n_tests</dt><dd><p>The number of tests this gene participated in for this group</p>
</dd>
<dt>log2FC_min,median,max</dt><dd><p>Summary statistics for log2FC across the tests</p>
</dd>
<dt>mean1,2_median</dt><dd><p>Median of group mean across the tests</p>
</dd>
<dt>pval_max</dt><dd><p>Maximum of p-values across tests</p>
</dd>
<dt>de_tests</dt><dd><p>Number of tests that showed this gene having a log2FC going in the same
direction as log2FC_median and having a p-value &lt;= pval_th</p>
</dd>
</dl>

<p>The output is ordered by group1, -de_tests, -abs(log2FC_median), pval_max
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
clustering &lt;- 1:ncol(pbmc) %% 2
sample_id &lt;- 1:ncol(pbmc) %% 3
vst_out &lt;- vst(pbmc, return_corrected_umi = TRUE)
de_res &lt;- diff_mean_test_conserved(y = vst_out$umi_corrected, 
group_labels = clustering, sample_labels = sample_id)


</code></pre>

<hr>
<h2 id='generate'>Generate data from regularized models.</h2><span id='topic+generate'></span>

<h3>Description</h3>

<p>Generate data from regularized models. This generates data from the background,
i.e. no residuals are added to the simulated data. The cell attributes for the
generated cells are sampled from the input with replacement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate(
  vst_out,
  genes = rownames(vst_out$model_pars_fit),
  cell_attr = vst_out$cell_attr,
  n_cells = nrow(cell_attr)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_+3A_vst_out">vst_out</code></td>
<td>
<p>A list that provides model parameters and optionally meta data; use output of vst function</p>
</td></tr>
<tr><td><code id="generate_+3A_genes">genes</code></td>
<td>
<p>The gene names for which to generate data; default is rownames(vst_out$model_pars_fit)</p>
</td></tr>
<tr><td><code id="generate_+3A_cell_attr">cell_attr</code></td>
<td>
<p>Provide cell meta data holding latent data info; default is vst_out$cell_attr</p>
</td></tr>
<tr><td><code id="generate_+3A_n_cells">n_cells</code></td>
<td>
<p>Number of cells to generate; default is nrow(cell_attr)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generated data as dgCMatrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vst_out &lt;- vst(pbmc, return_cell_attr = TRUE)
generated_data &lt;- generate(vst_out)


</code></pre>

<hr>
<h2 id='get_model_var'>Return average variance under negative binomial model</h2><span id='topic+get_model_var'></span>

<h3>Description</h3>

<p>This is based on the formula var = mu + mu^2 / theta
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_model_var(
  vst_out,
  cell_attr = vst_out$cell_attr,
  use_nonreg = FALSE,
  bin_size = 256,
  verbosity = 2,
  verbose = NULL,
  show_progress = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_model_var_+3A_vst_out">vst_out</code></td>
<td>
<p>The output of a vst run</p>
</td></tr>
<tr><td><code id="get_model_var_+3A_cell_attr">cell_attr</code></td>
<td>
<p>Data frame of cell meta data</p>
</td></tr>
<tr><td><code id="get_model_var_+3A_use_nonreg">use_nonreg</code></td>
<td>
<p>Use the non-regularized parameter estimates; boolean; default is FALSE</p>
</td></tr>
<tr><td><code id="get_model_var_+3A_bin_size">bin_size</code></td>
<td>
<p>Number of genes to put in each bin (to show progress)</p>
</td></tr>
<tr><td><code id="get_model_var_+3A_verbosity">verbosity</code></td>
<td>
<p>An integer specifying whether to show only messages (1), messages and progress bars (2) or nothing (0) while the function is running; default is 2</p>
</td></tr>
<tr><td><code id="get_model_var_+3A_verbose">verbose</code></td>
<td>
<p>Deprecated; use verbosity instead</p>
</td></tr>
<tr><td><code id="get_model_var_+3A_show_progress">show_progress</code></td>
<td>
<p>Deprecated; use verbosity instead</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of variances (the average across all cells), one entry per gene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vst_out &lt;- vst(pbmc, return_cell_attr = TRUE)
res_var &lt;- get_model_var(vst_out)


</code></pre>

<hr>
<h2 id='get_nz_median2'>Get median of non zero UMIs from a count matrix</h2><span id='topic+get_nz_median2'></span>

<h3>Description</h3>

<p>Get median of non zero UMIs from a count matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nz_median2(umi, genes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_nz_median2_+3A_umi">umi</code></td>
<td>
<p>Count matrix</p>
</td></tr>
<tr><td><code id="get_nz_median2_+3A_genes">genes</code></td>
<td>
<p>A vector of genes to consider for calculating
the median. Default is NULL which uses all genes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the median of non-zero entries from the UMI matrix
</p>

<hr>
<h2 id='get_residual_var'>Return variance of residuals of regularized models</h2><span id='topic+get_residual_var'></span>

<h3>Description</h3>

<p>This never creates the full residual matrix and can be used to determine highly variable genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_residual_var(
  vst_out,
  umi,
  residual_type = "pearson",
  res_clip_range = c(-sqrt(ncol(umi)), sqrt(ncol(umi))),
  min_variance = vst_out$arguments$min_variance,
  cell_attr = vst_out$cell_attr,
  bin_size = 256,
  verbosity = vst_out$arguments$verbosity,
  verbose = NULL,
  show_progress = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_residual_var_+3A_vst_out">vst_out</code></td>
<td>
<p>The output of a vst run</p>
</td></tr>
<tr><td><code id="get_residual_var_+3A_umi">umi</code></td>
<td>
<p>The UMI count matrix that will be used</p>
</td></tr>
<tr><td><code id="get_residual_var_+3A_residual_type">residual_type</code></td>
<td>
<p>What type of residuals to return; can be 'pearson' or 'deviance'; default is 'pearson'</p>
</td></tr>
<tr><td><code id="get_residual_var_+3A_res_clip_range">res_clip_range</code></td>
<td>
<p>Numeric of length two specifying the min and max values the residuals will be clipped to; default is c(-sqrt(ncol(umi)), sqrt(ncol(umi)))</p>
</td></tr>
<tr><td><code id="get_residual_var_+3A_min_variance">min_variance</code></td>
<td>
<p>Lower bound for the estimated variance for any gene in any cell when calculating pearson residual; default is vst_out$arguments$min_variance</p>
</td></tr>
<tr><td><code id="get_residual_var_+3A_cell_attr">cell_attr</code></td>
<td>
<p>Data frame of cell meta data</p>
</td></tr>
<tr><td><code id="get_residual_var_+3A_bin_size">bin_size</code></td>
<td>
<p>Number of genes to put in each bin (to show progress)</p>
</td></tr>
<tr><td><code id="get_residual_var_+3A_verbosity">verbosity</code></td>
<td>
<p>An integer specifying whether to show only messages (1), messages and progress bars (2) or nothing (0) while the function is running; default is 2</p>
</td></tr>
<tr><td><code id="get_residual_var_+3A_verbose">verbose</code></td>
<td>
<p>Deprecated; use verbosity instead</p>
</td></tr>
<tr><td><code id="get_residual_var_+3A_show_progress">show_progress</code></td>
<td>
<p>Deprecated; use verbosity instead</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of residual variances (after clipping)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vst_out &lt;- vst(pbmc, return_cell_attr = TRUE)
res_var &lt;- get_residual_var(vst_out, pbmc)


</code></pre>

<hr>
<h2 id='get_residuals'>Return Pearson or deviance residuals of regularized models</h2><span id='topic+get_residuals'></span>

<h3>Description</h3>

<p>Return Pearson or deviance residuals of regularized models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_residuals(
  vst_out,
  umi,
  residual_type = "pearson",
  res_clip_range = c(-sqrt(ncol(umi)), sqrt(ncol(umi))),
  min_variance = vst_out$arguments$min_variance,
  cell_attr = vst_out$cell_attr,
  bin_size = 256,
  verbosity = vst_out$arguments$verbosity,
  verbose = NULL,
  show_progress = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_residuals_+3A_vst_out">vst_out</code></td>
<td>
<p>The output of a vst run</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_umi">umi</code></td>
<td>
<p>The UMI count matrix that will be used</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_residual_type">residual_type</code></td>
<td>
<p>What type of residuals to return; can be 'pearson' or 'deviance'; default is 'pearson'</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_res_clip_range">res_clip_range</code></td>
<td>
<p>Numeric of length two specifying the min and max values the results will be clipped to; default is c(-sqrt(ncol(umi)), sqrt(ncol(umi)))</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_min_variance">min_variance</code></td>
<td>
<p>Lower bound for the estimated variance for any gene in any cell when calculating pearson residual; default is vst_out$arguments$min_variance</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_cell_attr">cell_attr</code></td>
<td>
<p>Data frame of cell meta data</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_bin_size">bin_size</code></td>
<td>
<p>Number of genes to put in each bin (to show progress)</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_verbosity">verbosity</code></td>
<td>
<p>An integer specifying whether to show only messages (1), messages and progress bars (2) or nothing (0) while the function is running; default is 2</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_verbose">verbose</code></td>
<td>
<p>Deprecated; use verbosity instead</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_show_progress">show_progress</code></td>
<td>
<p>Deprecated; use verbosity instead</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of residuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vst_out &lt;- vst(pbmc, return_cell_attr = TRUE)
pearson_res &lt;- get_residuals(vst_out, pbmc)
deviance_res &lt;- get_residuals(vst_out, pbmc, residual_type = 'deviance')


</code></pre>

<hr>
<h2 id='is_outlier'>Identify outliers</h2><span id='topic+is_outlier'></span>

<h3>Description</h3>

<p>Identify outliers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_outlier(y, x, th = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_outlier_+3A_y">y</code></td>
<td>
<p>Dependent variable</p>
</td></tr>
<tr><td><code id="is_outlier_+3A_x">x</code></td>
<td>
<p>Independent variable</p>
</td></tr>
<tr><td><code id="is_outlier_+3A_th">th</code></td>
<td>
<p>Outlier score threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean vector
</p>

<hr>
<h2 id='make.sparse'>Convert a given matrix to dgCMatrix</h2><span id='topic+make.sparse'></span>

<h3>Description</h3>

<p>Convert a given matrix to dgCMatrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.sparse(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.sparse_+3A_mat">mat</code></td>
<td>
<p>Input matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dgCMatrix
</p>

<hr>
<h2 id='pbmc'>Peripheral Blood Mononuclear Cells (PBMCs)</h2><span id='topic+pbmc'></span>

<h3>Description</h3>

<p>UMI counts for a subset of cells freely available from 10X Genomics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbmc
</code></pre>


<h3>Format</h3>

<p>A sparse matrix (dgCMatrix, see Matrix package) of molecule counts.
There are 914 rows (genes) and 283 columns (cells). This is a downsampled
version of a 3K PBMC dataset available from 10x Genomics.
</p>


<h3>Source</h3>

<p><a href="https://support.10xgenomics.com/single-cell-gene-expression/datasets/1.1.0/pbmc3k">https://support.10xgenomics.com/single-cell-gene-expression/datasets/1.1.0/pbmc3k</a>
</p>

<hr>
<h2 id='plot_model'>Plot observed UMI counts and model</h2><span id='topic+plot_model'></span>

<h3>Description</h3>

<p>Plot observed UMI counts and model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_model(
  x,
  umi,
  goi,
  x_var = x$arguments$latent_var[1],
  cell_attr = x$cell_attr,
  do_log = TRUE,
  show_fit = TRUE,
  show_nr = FALSE,
  plot_residual = FALSE,
  batches = NULL,
  as_poisson = FALSE,
  arrange_vertical = TRUE,
  show_density = FALSE,
  gg_cmds = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_model_+3A_x">x</code></td>
<td>
<p>The output of a vst run</p>
</td></tr>
<tr><td><code id="plot_model_+3A_umi">umi</code></td>
<td>
<p>UMI count matrix</p>
</td></tr>
<tr><td><code id="plot_model_+3A_goi">goi</code></td>
<td>
<p>Vector of genes to plot</p>
</td></tr>
<tr><td><code id="plot_model_+3A_x_var">x_var</code></td>
<td>
<p>Cell attribute to use on x axis; will be taken from x$arguments$latent_var[1] by default</p>
</td></tr>
<tr><td><code id="plot_model_+3A_cell_attr">cell_attr</code></td>
<td>
<p>Cell attributes data frame; will be taken from x$cell_attr by default</p>
</td></tr>
<tr><td><code id="plot_model_+3A_do_log">do_log</code></td>
<td>
<p>Log10 transform the UMI counts in plot</p>
</td></tr>
<tr><td><code id="plot_model_+3A_show_fit">show_fit</code></td>
<td>
<p>Show the model fit</p>
</td></tr>
<tr><td><code id="plot_model_+3A_show_nr">show_nr</code></td>
<td>
<p>Show the non-regularized model (if available)</p>
</td></tr>
<tr><td><code id="plot_model_+3A_plot_residual">plot_residual</code></td>
<td>
<p>Add panels for the Pearson residuals</p>
</td></tr>
<tr><td><code id="plot_model_+3A_batches">batches</code></td>
<td>
<p>Manually specify a batch variable to break up the model plot in segments</p>
</td></tr>
<tr><td><code id="plot_model_+3A_as_poisson">as_poisson</code></td>
<td>
<p>Fix model parameter theta to Inf, effectively showing a Poisson model</p>
</td></tr>
<tr><td><code id="plot_model_+3A_arrange_vertical">arrange_vertical</code></td>
<td>
<p>Stack individual ggplot objects or place side by side</p>
</td></tr>
<tr><td><code id="plot_model_+3A_show_density">show_density</code></td>
<td>
<p>Draw 2D density lines over points</p>
</td></tr>
<tr><td><code id="plot_model_+3A_gg_cmds">gg_cmds</code></td>
<td>
<p>Additional ggplot layer commands</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vst_out &lt;- vst(pbmc, return_cell_attr = TRUE)
plot_model(vst_out, pbmc, 'EMC4')


</code></pre>

<hr>
<h2 id='plot_model_pars'>Plot estimated and fitted model parameters</h2><span id='topic+plot_model_pars'></span>

<h3>Description</h3>

<p>Plot estimated and fitted model parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_model_pars(
  vst_out,
  xaxis = "gmean",
  show_theta = FALSE,
  show_var = FALSE,
  verbosity = 2,
  verbose = NULL,
  show_progress = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_model_pars_+3A_vst_out">vst_out</code></td>
<td>
<p>The output of a vst run</p>
</td></tr>
<tr><td><code id="plot_model_pars_+3A_xaxis">xaxis</code></td>
<td>
<p>Variable to plot on X axis; default is &quot;gmean&quot;</p>
</td></tr>
<tr><td><code id="plot_model_pars_+3A_show_theta">show_theta</code></td>
<td>
<p>Whether to show the theta parameter; default is FALSE (only the overdispersion factor is shown)</p>
</td></tr>
<tr><td><code id="plot_model_pars_+3A_show_var">show_var</code></td>
<td>
<p>Whether to show the average model variance; default is FALSE</p>
</td></tr>
<tr><td><code id="plot_model_pars_+3A_verbosity">verbosity</code></td>
<td>
<p>An integer specifying whether to show only messages (1), messages and progress bars (2) or nothing (0) while the function is running; default is 2</p>
</td></tr>
<tr><td><code id="plot_model_pars_+3A_verbose">verbose</code></td>
<td>
<p>Deprecated; use verbosity instead</p>
</td></tr>
<tr><td><code id="plot_model_pars_+3A_show_progress">show_progress</code></td>
<td>
<p>Deprecated; use verbosity instead</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vst_out &lt;- vst(pbmc, return_gene_attr = TRUE)
plot_model_pars(vst_out)


</code></pre>

<hr>
<h2 id='robust_scale'>Robust scale using median and mad</h2><span id='topic+robust_scale'></span>

<h3>Description</h3>

<p>Robust scale using median and mad
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robust_scale(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robust_scale_+3A_x">x</code></td>
<td>
<p>Numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric
</p>

<hr>
<h2 id='robust_scale_binned'>Robust scale using median and mad per bin</h2><span id='topic+robust_scale_binned'></span>

<h3>Description</h3>

<p>Robust scale using median and mad per bin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robust_scale_binned(y, x, breaks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robust_scale_binned_+3A_y">y</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="robust_scale_binned_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="robust_scale_binned_+3A_breaks">breaks</code></td>
<td>
<p>Numeric vector of breaks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of scaled score
</p>

<hr>
<h2 id='row_gmean'>Geometric mean per row</h2><span id='topic+row_gmean'></span>

<h3>Description</h3>

<p>Geometric mean per row
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_gmean(x, eps = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_gmean_+3A_x">x</code></td>
<td>
<p>matrix of class <code>matrix</code> or <code>dgCMatrix</code></p>
</td></tr>
<tr><td><code id="row_gmean_+3A_eps">eps</code></td>
<td>
<p>small value to add to x to avoid log(0); default is 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>geometric means
</p>

<hr>
<h2 id='row_var'>Variance per row</h2><span id='topic+row_var'></span>

<h3>Description</h3>

<p>Variance per row
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_var(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_var_+3A_x">x</code></td>
<td>
<p>matrix of class <code>matrix</code> or <code>dgCMatrix</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>variances
</p>

<hr>
<h2 id='smooth_via_pca'>Smooth data by PCA</h2><span id='topic+smooth_via_pca'></span>

<h3>Description</h3>

<p>Perform PCA, identify significant dimensions, and reverse the rotation using only significant dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_via_pca(
  x,
  elbow_th = 0.025,
  dims_use = NULL,
  max_pc = 100,
  do_plot = FALSE,
  scale. = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_via_pca_+3A_x">x</code></td>
<td>
<p>A data matrix with genes as rows and cells as columns</p>
</td></tr>
<tr><td><code id="smooth_via_pca_+3A_elbow_th">elbow_th</code></td>
<td>
<p>The fraction of PC sdev drop that is considered significant; low values will lead to more PCs being used</p>
</td></tr>
<tr><td><code id="smooth_via_pca_+3A_dims_use">dims_use</code></td>
<td>
<p>Directly specify PCs to use, e.g. 1:10</p>
</td></tr>
<tr><td><code id="smooth_via_pca_+3A_max_pc">max_pc</code></td>
<td>
<p>Maximum number of PCs computed</p>
</td></tr>
<tr><td><code id="smooth_via_pca_+3A_do_plot">do_plot</code></td>
<td>
<p>Plot PC sdev and sdev drop</p>
</td></tr>
<tr><td><code id="smooth_via_pca_+3A_scale.">scale.</code></td>
<td>
<p>Boolean indicating whether genes should be divided by standard deviation after centering and prior to PCA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Smoothed data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vst_out &lt;- vst(pbmc)
y_smooth &lt;- smooth_via_pca(vst_out$y, do_plot = TRUE)


</code></pre>

<hr>
<h2 id='umify'>Quantile normalization of cell-level data to match typical UMI count data</h2><span id='topic+umify'></span>

<h3>Description</h3>

<p>Quantile normalization of cell-level data to match typical UMI count data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>umify(counts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="umify_+3A_counts">counts</code></td>
<td>
<p>A matrix of class dgCMatrix with genes as rows and columns as cells</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A UMI-fied count matrix
</p>


<h3>Details</h3>

<p>sctransform::vst operates under the assumption that gene counts approximately 
follow a Negative Binomial dristribution. For UMI-based data that seems to be 
the case, however, non-UMI data does not behave in the same way. 
In some cases it might be better to to apply a transformation to such data 
to make it look like UMI data. This function applies such a transformation function.
</p>
<p>Cells in the input matrix are processed independently. For each cell
the non-zero data is transformed to quantile values. Based on the number of genes 
detected a smooth function is used to predict the UMI-like counts.
</p>
<p>The functions have be trained on various public data sets and come as part of the 
package (see umify_data data set in this package).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
silly_example &lt;- umify(pbmc)

</code></pre>

<hr>
<h2 id='umify_data'>Transformation functions for umify</h2><span id='topic+umify_data'></span>

<h3>Description</h3>

<p>The functions have been trained on various public data sets and relate quantile
values to log-counts. Here the expected values at various points are given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>umify_data
</code></pre>


<h3>Format</h3>

<p>A list of length two. The first element is a data frame with group, quantile and 
log-counts values. The second element is a vector of breaks to be used with cut to group
observations.
</p>

<hr>
<h2 id='vst'>Variance stabilizing transformation for UMI count data</h2><span id='topic+vst'></span>

<h3>Description</h3>

<p>Apply variance stabilizing transformation to UMI count data using a regularized Negative Binomial regression model.
This will remove unwanted effects from UMI data and return Pearson residuals.
Uses future_lapply; you can set the number of cores it will use to n with plan(strategy = &quot;multicore&quot;, workers = n).
If n_genes is set, only a (somewhat-random) subset of genes is used for estimating the
initial model parameters. For details see doi: <a href="https://doi.org/10.1186/s13059-019-1874-1">10.1186/s13059-019-1874-1</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vst(
  umi,
  cell_attr = NULL,
  latent_var = c("log_umi"),
  batch_var = NULL,
  latent_var_nonreg = NULL,
  n_genes = 2000,
  n_cells = NULL,
  method = "poisson",
  do_regularize = TRUE,
  theta_regularization = "od_factor",
  res_clip_range = c(-sqrt(ncol(umi)), sqrt(ncol(umi))),
  bin_size = 500,
  min_cells = 5,
  residual_type = "pearson",
  return_cell_attr = FALSE,
  return_gene_attr = TRUE,
  return_corrected_umi = FALSE,
  min_variance = -Inf,
  bw_adjust = 3,
  gmean_eps = 1,
  theta_estimation_fun = "theta.ml",
  theta_given = NULL,
  exclude_poisson = FALSE,
  use_geometric_mean = TRUE,
  use_geometric_mean_offset = FALSE,
  fix_intercept = FALSE,
  fix_slope = FALSE,
  scale_factor = NA,
  vst.flavor = NULL,
  verbosity = 2,
  verbose = NULL,
  show_progress = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vst_+3A_umi">umi</code></td>
<td>
<p>A matrix of UMI counts with genes as rows and cells as columns</p>
</td></tr>
<tr><td><code id="vst_+3A_cell_attr">cell_attr</code></td>
<td>
<p>A data frame containing the dependent variables; if omitted a data frame with umi and gene will be generated</p>
</td></tr>
<tr><td><code id="vst_+3A_latent_var">latent_var</code></td>
<td>
<p>The independent variables to regress out as a character vector; must match column names in cell_attr; default is c(&quot;log_umi&quot;)</p>
</td></tr>
<tr><td><code id="vst_+3A_batch_var">batch_var</code></td>
<td>
<p>The dependent variables indicating which batch a cell belongs to; no batch interaction terms used if omiited</p>
</td></tr>
<tr><td><code id="vst_+3A_latent_var_nonreg">latent_var_nonreg</code></td>
<td>
<p>The non-regularized dependent variables to regress out as a character vector; must match column names in cell_attr; default is NULL</p>
</td></tr>
<tr><td><code id="vst_+3A_n_genes">n_genes</code></td>
<td>
<p>Number of genes to use when estimating parameters (default uses 2000 genes, set to NULL to use all genes)</p>
</td></tr>
<tr><td><code id="vst_+3A_n_cells">n_cells</code></td>
<td>
<p>Number of cells to use when estimating parameters (default uses all cells)</p>
</td></tr>
<tr><td><code id="vst_+3A_method">method</code></td>
<td>
<p>Method to use for initial parameter estimation; one of 'poisson', 'qpoisson', 'nb_fast', 'nb', 'nb_theta_given', 'glmGamPoi', 'offset', 'offset_shared_theta_estimate', 'glmGamPoi_offset'; default is 'poisson'</p>
</td></tr>
<tr><td><code id="vst_+3A_do_regularize">do_regularize</code></td>
<td>
<p>Boolean that, if set to FALSE, will bypass parameter regularization and use all genes in first step (ignoring n_genes); default is FALSE</p>
</td></tr>
<tr><td><code id="vst_+3A_theta_regularization">theta_regularization</code></td>
<td>
<p>Method to use to regularize theta; use 'log_theta' for the behavior prior to version 0.3; default is 'od_factor'</p>
</td></tr>
<tr><td><code id="vst_+3A_res_clip_range">res_clip_range</code></td>
<td>
<p>Numeric of length two specifying the min and max values the results will be clipped to; default is c(-sqrt(ncol(umi)), sqrt(ncol(umi)))</p>
</td></tr>
<tr><td><code id="vst_+3A_bin_size">bin_size</code></td>
<td>
<p>Number of genes to process simultaneously; this will determine how often the progress bars are updated and how much memory is being used; default is 500</p>
</td></tr>
<tr><td><code id="vst_+3A_min_cells">min_cells</code></td>
<td>
<p>Only use genes that have been detected in at least this many cells; default is 5</p>
</td></tr>
<tr><td><code id="vst_+3A_residual_type">residual_type</code></td>
<td>
<p>What type of residuals to return; can be 'pearson', 'deviance', or 'none'; default is 'pearson'</p>
</td></tr>
<tr><td><code id="vst_+3A_return_cell_attr">return_cell_attr</code></td>
<td>
<p>Make cell attributes part of the output; default is FALSE</p>
</td></tr>
<tr><td><code id="vst_+3A_return_gene_attr">return_gene_attr</code></td>
<td>
<p>Calculate gene attributes and make part of output; default is TRUE</p>
</td></tr>
<tr><td><code id="vst_+3A_return_corrected_umi">return_corrected_umi</code></td>
<td>
<p>If set to TRUE output will contain corrected UMI matrix; see <code>correct</code> function</p>
</td></tr>
<tr><td><code id="vst_+3A_min_variance">min_variance</code></td>
<td>
<p>Lower bound for the estimated variance for any gene in any cell when calculating pearson residual; one of 'umi_median', 'model_median', 'model_mean' or a
numeric. default is -Inf.  When set to 'umi_median' uses (median of non-zero UMIs / 5)^2 as the minimum variance so that a median UMI (often 1)
results in a maximum pearson residual of 5. When set to 'model_median' or 'model_mean' uses the mean/median of the model estimated mu per gene as the minimum_variance.#'</p>
</td></tr>
<tr><td><code id="vst_+3A_bw_adjust">bw_adjust</code></td>
<td>
<p>Kernel bandwidth adjustment factor used during regurlarization; factor will be applied to output of bw.SJ; default is 3</p>
</td></tr>
<tr><td><code id="vst_+3A_gmean_eps">gmean_eps</code></td>
<td>
<p>Small value added when calculating geometric mean of a gene to avoid log(0); default is 1</p>
</td></tr>
<tr><td><code id="vst_+3A_theta_estimation_fun">theta_estimation_fun</code></td>
<td>
<p>Character string indicating which method to use to estimate theta (when method = poisson); default is 'theta.ml', but 'theta.mm' seems to be a good and fast alternative</p>
</td></tr>
<tr><td><code id="vst_+3A_theta_given">theta_given</code></td>
<td>
<p>If method is set to nb_theta_given, this should be a named numeric vector of fixed theta values for the genes; if method is offset, this should be a single value; default is NULL</p>
</td></tr>
<tr><td><code id="vst_+3A_exclude_poisson">exclude_poisson</code></td>
<td>
<p>Exclude poisson genes (i.e. mu &lt; 0.001 or mu &gt; variance) from regularization; default is FALSE</p>
</td></tr>
<tr><td><code id="vst_+3A_use_geometric_mean">use_geometric_mean</code></td>
<td>
<p>Use geometric mean instead of arithmetic mean for all calculations ; default is TRUE</p>
</td></tr>
<tr><td><code id="vst_+3A_use_geometric_mean_offset">use_geometric_mean_offset</code></td>
<td>
<p>Use geometric mean instead of arithmetic mean in the offset model; default is FALSE</p>
</td></tr>
<tr><td><code id="vst_+3A_fix_intercept">fix_intercept</code></td>
<td>
<p>Fix intercept as defined in the offset model; default is FALSE</p>
</td></tr>
<tr><td><code id="vst_+3A_fix_slope">fix_slope</code></td>
<td>
<p>Fix slope to log(10) (equivalent to using library size as an offset); default is FALSE</p>
</td></tr>
<tr><td><code id="vst_+3A_scale_factor">scale_factor</code></td>
<td>
<p>Replace all values of UMI in the regression model by this value instead of the median UMI; default is NA</p>
</td></tr>
<tr><td><code id="vst_+3A_vst.flavor">vst.flavor</code></td>
<td>
<p>When set to 'v2' sets method = glmGamPoi_offset, n_cells=2000, and exclude_poisson = TRUE which causes the model to learn theta and intercept only besides excluding poisson genes from learning and regularization; default is NULL which uses the original sctransform model</p>
</td></tr>
<tr><td><code id="vst_+3A_verbosity">verbosity</code></td>
<td>
<p>An integer specifying whether to show only messages (1), messages and progress bars (2) or nothing (0) while the function is running; default is 2</p>
</td></tr>
<tr><td><code id="vst_+3A_verbose">verbose</code></td>
<td>
<p>Deprecated; use verbosity instead</p>
</td></tr>
<tr><td><code id="vst_+3A_show_progress">show_progress</code></td>
<td>
<p>Deprecated; use verbosity instead</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>Matrix of transformed data, i.e. Pearson residuals, or deviance residuals; empty if <code>residual_type = 'none'</code></p>
</td></tr>
<tr><td><code>umi_corrected</code></td>
<td>
<p>Matrix of corrected UMI counts (optional)</p>
</td></tr>
<tr><td><code>model_str</code></td>
<td>
<p>Character representation of the model formula</p>
</td></tr>
<tr><td><code>model_pars</code></td>
<td>
<p>Matrix of estimated model parameters per gene (theta and regression coefficients)</p>
</td></tr>
<tr><td><code>model_pars_outliers</code></td>
<td>
<p>Vector indicating whether a gene was considered to be an outlier</p>
</td></tr>
<tr><td><code>model_pars_fit</code></td>
<td>
<p>Matrix of fitted / regularized model parameters</p>
</td></tr>
<tr><td><code>model_str_nonreg</code></td>
<td>
<p>Character representation of model for non-regularized variables</p>
</td></tr>
<tr><td><code>model_pars_nonreg</code></td>
<td>
<p>Model parameters for non-regularized variables</p>
</td></tr>
<tr><td><code>genes_log_gmean_step1</code></td>
<td>
<p>log-geometric mean of genes used in initial step of parameter estimation</p>
</td></tr>
<tr><td><code>cells_step1</code></td>
<td>
<p>Cells used in initial step of parameter estimation</p>
</td></tr>
<tr><td><code>arguments</code></td>
<td>
<p>List of function call arguments</p>
</td></tr>
<tr><td><code>cell_attr</code></td>
<td>
<p>Data frame of cell meta data (optional)</p>
</td></tr>
<tr><td><code>gene_attr</code></td>
<td>
<p>Data frame with gene attributes such as mean, detection rate, etc. (optional)</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>Time stamps at various points in the function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the first step of the algorithm, per-gene glm model parameters are learned. This step can be done
on a subset of genes and/or cells to speed things up.
If <code>method</code> is set to 'poisson', a poisson regression is done and
the negative binomial theta parameter is estimated using the response residuals in
<code>theta_estimation_fun</code>.
If <code>method</code> is set to 'qpoisson', coefficients and overdispersion (phi) are estimated by quasi
poisson regression and theta is estimated based on phi and the mean fitted value - this is currently
the fastest method with results very similar to 'glmGamPoi'
If <code>method</code> is set to 'nb_fast', coefficients and theta are estimated as in the
'poisson' method, but coefficients are then re-estimated using a proper negative binomial
model in a second call to glm with <code>family = MASS::negative.binomial(theta = theta)</code>.
If <code>method</code> is set to 'nb', coefficients and theta are estimated by a single call to
<code>MASS::glm.nb</code>.
If <code>method</code> is set to 'glmGamPoi', coefficients and theta are estimated by a single call to
<code>glmGamPoi::glm_gp</code>.
</p>
<p>A special case is <code>method = 'offset'</code>. Here no regression parameters are learned, but
instead an offset model is assumed. The latent variable is set to log_umi and a fixed
slope of log(10) is used (offset). The intercept is given by log(gene_mean) - log(avg_cell_umi).
See Lause et al. doi: <a href="https://doi.org/10.1186/s13059-021-02451-7">10.1186/s13059-021-02451-7</a> for details.
Theta is set
to 100 by default, but can be changed using the <code>theta_given</code> parameter (single numeric value).
If the offset method is used, the following parameters are overwritten:
<code>cell_attr &lt;- NULL, latent_var &lt;- c('log_umi'), batch_var &lt;- NULL, latent_var_nonreg &lt;- NULL,
n_genes &lt;- NULL, n_cells &lt;- NULL, do_regularize &lt;- FALSE</code>. Further, <code>method = 'offset_shared_theta_estimate'</code>
exists where the 250 most highly expressed genes with detection rate of at least 0.5 are used
to estimate a theta that is then shared across all genes. Thetas are estimated per individual gene
using 5000 randomly selected cells. The final theta used for all genes is then the average.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vst_out &lt;- vst(pbmc)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
