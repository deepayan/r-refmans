<!DOCTYPE html><html><head><title>Help for package MEDseq</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MEDseq}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MEDseq-package'><p>MEDseq: Mixtures of Exponential-Distance Models with Covariates</p></a></li>
<li><a href='#biofam'><p>Family life states from the Swiss Household Panel biographical survey</p></a></li>
<li><a href='#dbs'><p>Compute the Density-based Silhouette</p></a></li>
<li><a href='#dist_freqwH'><p>Pairwise frequency-Weighted Hamming distance matrix for categorical data</p></a></li>
<li><a href='#get_MEDseq_results'><p>Extract results from a MEDseq model</p></a></li>
<li><a href='#MEDseq_AvePP'><p>Average posterior probabilities of a fitted MEDseq model</p></a></li>
<li><a href='#MEDseq_clustnames'><p>Automatic labelling of clusters using central sequences</p></a></li>
<li><a href='#MEDseq_compare'><p>Choose the best MEDseq model</p></a></li>
<li><a href='#MEDseq_control'><p>Set control values for use with MEDseq_fit</p></a></li>
<li><a href='#MEDseq_entropy'><p>Entropy of a fitted MEDseq model</p></a></li>
<li><a href='#MEDseq_fit'><p>MEDseq: Mixtures of Exponential-Distance Models with Covariates</p></a></li>
<li><a href='#MEDseq_meantime'><p>Compute the mean time spent in each sequence category</p></a></li>
<li><a href='#MEDseq_news'><p>Show the NEWS file</p></a></li>
<li><a href='#MEDseq_stderr'><p>MEDseq gating network standard errors</p></a></li>
<li><a href='#mvad'><p>MVAD: Transition from school to work</p></a></li>
<li><a href='#plot.MEDseq'><p>Plot MEDseq results</p></a></li>
<li><a href='#predict.MEDgating'><p>Predictions from MEDseq gating networks</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#wKModes'><p>Weighted K-Modes Clustering with Tie-Breaking</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-12</td>
</tr>
<tr>
<td>Title:</td>
<td>Mixtures of Exponential-Distance Models with Covariates</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a model-based clustering method for categorical life-course sequences relying on mixtures of exponential-distance models introduced by Murphy et al. (2021) &lt;<a href="https://doi.org/10.1111%2Frssa.12712">doi:10.1111/rssa.12712</a>&gt;. A range of flexible precision parameter settings corresponding to weighted generalisations of the Hamming distance metric are considered, along with the potential inclusion of a noise component. Gating covariates can be supplied in order to relate sequences to baseline characteristics and sampling weights are also accommodated. The models are fitted using the EM algorithm and tools for visualising the results are also provided.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cran.r-project.org/package=MEDseq">https://cran.r-project.org/package=MEDseq</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Keefe-Murphy/MEDseq">https://github.com/Keefe-Murphy/MEDseq</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>cluster, matrixStats (&ge; 1.0.0), nnet (&ge; 7.3-0), seriation,
stringdist, TraMineR (&ge; 1.6), WeightedCluster</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, viridisLite (&ge; 0.4.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-12 16:27:44 UTC; Keefe</td>
</tr>
<tr>
<td>Author:</td>
<td>Keefe Murphy <a href="https://orcid.org/0000-0002-7709-3159"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Thomas Brendan Murphy
    <a href="https://orcid.org/0000-0002-5668-7046"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Raffaella Piccarreta [ctb],
  Isobel Claire Gormley
    <a href="https://orcid.org/0000-0001-7713-681X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Keefe Murphy &lt;keefe.murphy@mu.ie&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-12 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='MEDseq-package'>MEDseq: Mixtures of Exponential-Distance Models with Covariates</h2><span id='topic+MEDseq'></span><span id='topic+MEDseq-package'></span>

<h3>Description</h3>

<p>Fits MEDseq models: mixtures of Exponential-Distance models with gating covariates and sampling weights. Typically used for clustering categorical/longitudinal life-course sequences.
</p>


<h3>Usage</h3>

<p>Fits _MEDseq_ models introduced by Murphy et al. (2021) &lt;<a href="https://doi.org/10.1111/rssa.12712">doi:10.1111/rssa.12712</a>&gt;, i.e. fits mixtures of exponential-distance models for clustering longitudinal life-course sequence data via the EM/CEM algorithm. 
</p>
<p>A family of parsimonious precision parameter constraints are accommodated. So too are sampling weights. Gating covariates can be supplied via formula interfaces.
</p>
<p>The most important function in the <span class="pkg">MEDseq</span> package is: <code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code>, for fitting the models via EM/CEM. This function requires the data to be in <code>"stslist"</code> format; the function <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code> is conveniently reexported from the <span class="pkg">TraMineR</span> package for this purpose.
</p>
<p><code><a href="#topic+MEDseq_control">MEDseq_control</a></code> allows supplying additional arguments which govern, among other things, controls on the initialisation of the allocations for the EM/CEM algorithm and the various model selection options. 
</p>
<p><code><a href="#topic+MEDseq_compare">MEDseq_compare</a></code> is provided for conducting model selection between different results from using different covariate combinations &amp;/or initialisation strategies, etc. 
</p>
<p><code><a href="#topic+MEDseq_stderr">MEDseq_stderr</a></code> is provided for computing the standard errors of the coefficients for the covariates in the gating network.
</p>
<p>A dedicated plotting function <code><a href="#topic+plot.MEDseq">plot.MEDseq</a></code> exists for visualising various aspects of the results, using new methods as well as some existing methods adapted from the <span class="pkg">TraMineR</span> package.
</p>
<p>Finally, the package also contains two data sets: <code><a href="#topic+biofam">biofam</a></code> and <code><a href="#topic+mvad">mvad</a></code>.
</p>


<h3>Details</h3>


<dl>
<dt>Type: </dt><dd><p>Package</p>
</dd>
<dt>Package: </dt><dd><p>MEDseq</p>
</dd>
<dt>Version: </dt><dd><p>1.4.1</p>
</dd>
<dt>Date: </dt><dd><p>2023-12-12 (this version), 2019-08-24 (original release)</p>
</dd>
<dt>Licence: </dt><dd><p>GPL (&gt;= 3)</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Further details and examples are given in the associated vignette document:<br />
<code>vignette("MEDseq", package = "MEDseq")</code>
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy [aut, cre], Thomas Brendan Murphy [ctb], Raffaella Piccarreta [ctb], Isobel Claire Gormley [ctb]
</p>
<p><strong>Maintainer</strong>: Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Murphy, T. B., Piccarreta, R., and Gormley, I. C. (2021). Clustering longitudinal life-course sequences using mixtures of exponential-distance models. <em>Journal of the Royal Statistical Society: Series A (Statistics in Society)</em>, 184(4): 1414-1451. &lt;<a href="https://doi.org/10.1111/rssa.12712">doi:10.1111/rssa.12712</a>&gt;.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://cran.r-project.org/package=MEDseq">https://cran.r-project.org/package=MEDseq</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Keefe-Murphy/MEDseq">https://github.com/Keefe-Murphy/MEDseq</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Load the MVAD data
data(mvad)
mvad$Location &lt;- factor(apply(mvad[,5:9], 1L, function(x) 
                 which(x == "yes")), labels = colnames(mvad[,5:9]))
mvad          &lt;- list(covariates = mvad[c(3:4,10:14,87)],
                      sequences = mvad[,15:86], 
                      weights = mvad[,2])
mvad.cov      &lt;- mvad$covariates

# Create a state sequence object with the first two (summer) time points removed
states        &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
labels        &lt;- c("Employment", "Further Education", "Higher Education", 
                   "Joblessness", "School", "Training")
mvad.seq      &lt;- seqdef(mvad$sequences[-c(1,2)], states=states, labels=labels)
                         
# Fit a range of unweighted models without covariates
# Only consider models with a noise component
# Supply some MEDseq_control() arguments
mod1          &lt;- MEDseq_fit(mvad.seq, G=9:10, modtype=c("CCN", "CUN", "UCN", "UUN"),
                            algo="CEM", init.z="kmodes", criterion="icl")

# Fit a model with weights and gating covariates
# Have the probability of noise-component membership be constant
mod2          &lt;- MEDseq_fit(mvad.seq, G=11, modtype="UUN", weights=mvad$weights, 
                            gating=~ gcse5eq, covars=mvad.cov, noise.gate=FALSE)
                            
# Examine this model and its gating network
summary(mod2, network=TRUE)
plot(mod2, "clusters")
</code></pre>

<hr>
<h2 id='biofam'>Family life states from the Swiss Household Panel biographical survey</h2><span id='topic+biofam'></span>

<h3>Description</h3>

<p>2000 16 year-long family life sequences built from the retrospective biographical survey carried out by the Swiss Household Panel (SHP) in 2002.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(biofam)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2000 rows, 16 state variables, 1 id variable and 7 covariates and 2 weights variables.
</p>


<h3>Details</h3>

<p>The <em>biofam</em> data set was constructed by Müller et al. (2007) from the data of the retrospective biographical survey carried out by the Swiss Household Panel (SHP) in 2002. 
</p>
<p>The data set contains (in columns 10 to 25) sequences of family life states from age 15 to 30 (sequence length is 16) and a series of covariates. The sequences are a sample of 2000 sequences of those created from the SHP biographical survey. It includes only individuals who were at least 30 years old at the time of the survey. The <em>biofam</em> data set describes family life courses of 2000 individuals born between 1909 and 1972. 
</p>
<p>The states numbered from 0 to 7 are defined from the combination of five basic states, namely Living with parents (Parent), Left home (Left), Married (Marr), Having Children (Child), Divorced:<br />
<br />
0 = &quot;Parent&quot; <br />
1 = &quot;Left&quot; <br />
2 = &quot;Married&quot; <br />
3 = &quot;Left+Marr&quot; <br />
4 = &quot;Child&quot; <br />
5 = &quot;Left+Child&quot; <br />
6 = &quot;Left+Marr+Child&quot; <br />
7 = &quot;Divorced&quot; <br />
</p>
<p>The covariates are: <br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>sex</code>      </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>birthyr</code>  </td><td style="text-align: left;"> (birth year) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>nat_1_02</code> </td><td style="text-align: left;"> (first nationality) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>plingu02</code> </td><td style="text-align: left;"> (language of questionnaire) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>p02r01</code>   </td><td style="text-align: left;"> (religion) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>p02r04</code>   </td><td style="text-align: left;"> (religious participation) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cspfaj</code>   </td><td style="text-align: left;"> (father's social status) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cspmoj</code>   </td><td style="text-align: left;"> (mother's social status) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Two additional weights variables are inserted for illustrative purpose ONLY (since <code>biofam</code> is a subsample of the original data, these weights are not adapted to the actual data): <br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>wp00tbgp</code> </td><td style="text-align: left;"> (weights inflating to the Swiss population) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>wp00tbgs</code> </td><td style="text-align: left;"> (weights respecting sample size) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>Swiss Household Panel <a href="https://forscenter.ch/projects/swiss-household-panel/">https://forscenter.ch/projects/swiss-household-panel/</a>
</p>


<h3>References</h3>

<p>Müller, N. S., Studer, M. and Ritschard, G. (2007). Classification de parcours de vie à l'aide de l'optimal matching. In <em>XIVe Rencontre de la Société francophone de classification (SFC 2007)</em>, Paris, 5-7 septembre 2007, pp. 157-160.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(biofam, package="MEDseq")

biofam         &lt;- list(covariates = biofam[2L:9L], sequences = biofam[10L:25L] + 1L)
biofam.cov     &lt;- biofam$covariates[,colSums(is.na(biofam$covariates)) == 0]
biofam.seq     &lt;- seqdef(biofam$sequences,
                        states = c("P", "L", "M", "L+M", "C", "L+C", "L+M+C", "D"),
                        labels = c("Parent", "Left", "Married", "Left+Marr", "Child", 
                                   "Left+Child", "Left+Marr+Child", "Divorced"))
biofam.cov$age &lt;- 2002 - biofam.cov$birthyr
</code></pre>

<hr>
<h2 id='dbs'>Compute the Density-based Silhouette</h2><span id='topic+dbs'></span>

<h3>Description</h3>

<p>Computes the Density-based Silhouette for a 'soft' clustering assignment matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbs(z,
    ztol = 1E-100,
    weights = NULL,
    summ = c("mean", "median"),
    clusters = NULL,
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbs_+3A_z">z</code></td>
<td>
<p>A numeric matrix such that rows correspond to observations, columns correspond to clusters, and rows sum to <code>1</code>.</p>
</td></tr>
<tr><td><code id="dbs_+3A_ztol">ztol</code></td>
<td>
<p>A small (single, numeric, non-negative) tolerance parameter governing whether small assignment probabilities are treated instead as crisp assignments. Defaults to <code>1E-100</code>.</p>
</td></tr>
<tr><td><code id="dbs_+3A_weights">weights</code></td>
<td>
<p>An optional numeric vector giving observation-specific weights for computing the (weighted) mean/median DBS (see <code>summ</code>).</p>
</td></tr>
<tr><td><code id="dbs_+3A_summ">summ</code></td>
<td>
<p>A single character string indicating whether the (possibly weighted) <code>"mean"</code> (the default) or <code>"median"</code> DBS should be computed.</p>
</td></tr>
<tr><td><code id="dbs_+3A_clusters">clusters</code></td>
<td>
<p>Optional/experimental argument for giving the indicator labels of the cluster assignments. Defaults to the MAP assignment derived from <code>z</code> when not supplied. Note that actually supplying the MAP assignment here is slightly less efficient than the <code>NULL</code> default and <strong>not</strong> advised.</p>
</td></tr>
<tr><td><code id="dbs_+3A_...">...</code></td>
<td>
<p>Catches unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<dl>
<dt><code>silvals</code></dt><dd><p>A matrix where each row contains the cluster to which each observation belongs in the first column and the observation-specific DBS width in the second column.</p>
</dd>
<dt><code>msw</code></dt><dd><p>Depending on the value of <code>summ</code>, either the mean or median DBS width.</p>
</dd>
<dt><code>wmsw</code></dt><dd><p>Depending on the value of <code>summ</code>, either the weighted mean or weighted median DBS width.</p>
</dd></dl>



<h3>Note</h3>

<p>When calling <code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code>, the <code>summ</code> argument can be passed via the <code>...</code> construct, in which case it governs both the <code>dbs</code> and <code>asw</code> criteria.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Menardi, G. (2011). Density-based silhouette diagnostics for clustering methods. <em>Statistics and Computing</em>, 21(3): 295-308.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a toy z matrix
z &lt;- abs(matrix(rnorm(50), ncol=2))
z &lt;- z/rowSums(z)

# Return the median DBS width
dbs(z, summ="median")$msw

# For real sequence data
data(mvad)

mod &lt;- MEDseq_fit(seqdef(mvad[,17:86]), G=11, modtype="UUN", weights=mvad$weight)

dbs(mod$z, weights=mvad$weight)
</code></pre>

<hr>
<h2 id='dist_freqwH'>Pairwise frequency-Weighted Hamming distance matrix for categorical data</h2><span id='topic+dist_freqwH'></span>

<h3>Description</h3>

<p>Computes the matrix of pairwise distance using a frequency-weighted variant of the Hamming distance often used in k-modes clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_freqwH(data,
            full.matrix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_freqwH_+3A_data">data</code></td>
<td>
<p>A matrix or data frame of categorical data. Objects have to be in rows, variables in columns.</p>
</td></tr>
<tr><td><code id="dist_freqwH_+3A_full.matrix">full.matrix</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), the full pairwise distance matrix is returned, otherwise an object of class <code><a href="stats.html#topic+dist">dist</a></code> is returned, i.e. a vector containing only values from the upper triangle of the distance matrix. Objects of class <code>dist</code> are smaller and can be passed directly as arguments to most clustering functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As per <code><a href="#topic+wKModes">wKModes</a></code>, the frequency weights are computed within the function and are <em>not</em> user-specified. These frequency weights are assigned on a per-feature basis and derived from the categories represented in each column of <code>data</code>.
</p>


<h3>Value</h3>

<p>The whole matrix of pairwise distances if <code>full.matrix=TRUE</code>, otherwise the corresponding <code><a href="stats.html#topic+dist">dist</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Huang, Z. (1998). Extensions to the k-means algorithm for clustering large data sets with categorical values. <em>Data Mining and Knowledge Discovery</em>, 2(3): 283-304.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wKModes">wKModes</a></code>, <code><a href="WeightedCluster.html#topic+wcAggregateCases">wcAggregateCases</a></code>, <code><a href="WeightedCluster.html#topic+wcSilhouetteObs">wcSilhouetteObs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>suppressMessages(require(WeightedCluster))
set.seed(99)
# Load the MVAD data &amp; aggregate the state sequences
data(mvad)
agg      &lt;- wcAggregateCases(mvad[,17:86], weights=mvad$weight)

# Create a state sequence object without the first two (summer) time points
states   &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
labels   &lt;- c("Employment", "Further Education", "Higher Education", 
              "Joblessness", "School", "Training")
weights  &lt;- agg$aggWeights
mvad.seq &lt;- seqdef(mvad[agg$aggIndex, 17:86], 
                   states=states, labels=labels, weights=agg$aggWeights)

# Run k-modes with weights
resW     &lt;- wKModes(mvad.seq, 2, weights=agg$aggWeights)

# Run k-modes with additional frequency weights
resF     &lt;- wKModes(mvad.seq, 2, weights=agg$aggWeights, freq.weighted=TRUE)

# Examine the average silhouette widths of both weighted solutions
weighted.mean(wcSilhouetteObs(seqdist(mvad.seq, method="HAM"), resW$cluster, weights), weights)
# weighted.mean(wcSilhouetteObs(seqdist(mvad.seq, method="HAM"), resF$cluster, weights), weights)
weighted.mean(wcSilhouetteObs(dist_freqwH(mvad.seq), resF$cluster, weights), weights)
</code></pre>

<hr>
<h2 id='get_MEDseq_results'>Extract results from a MEDseq model</h2><span id='topic+get_MEDseq_results'></span>

<h3>Description</h3>

<p>Utility function for extracting results of submodels from <code>"MEDseq"</code> objects when a range of models were run via <code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_MEDseq_results(x,
                   what = c("z", "MAP", "DBS", "ASW"), 
                   rank = 1L, 
                   criterion = c("bic", "icl", "aic", "dbs", 
                                 "asw", "cv", "nec", "loglik"), 
                   G = NULL, 
                   modtype = NULL, 
                   noise = TRUE, 
                   ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_MEDseq_results_+3A_x">x</code></td>
<td>
<p>An object of class <code>"MEDseq"</code> generated by <code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code> or an object of class <code>"MEDseqCompare"</code> generated by <code><a href="#topic+MEDseq_compare">MEDseq_compare</a></code>.</p>
</td></tr>
<tr><td><code id="get_MEDseq_results_+3A_what">what</code></td>
<td>
<p>A character string indicating the desired results to extract.</p>
</td></tr>
<tr><td><code id="get_MEDseq_results_+3A_rank">rank</code></td>
<td>
<p>A number indicating what <code>rank</code> model results should be extracted from, where the <code>rank</code> is determined by <code>criterion</code>. Defaults to <code>1</code>, i.e. the best model.</p>
</td></tr>
<tr><td><code id="get_MEDseq_results_+3A_criterion">criterion</code></td>
<td>
<p>The <code>criterion</code> used to determine the ranking. Defaults to <code>"bic"</code>.</p>
</td></tr>
<tr><td><code id="get_MEDseq_results_+3A_g">G</code></td>
<td>
<p>Optional argument giving the number of components in the model for which results are desired. Can be supplied with or without also specifying <code>modtype</code>.</p>
</td></tr>
<tr><td><code id="get_MEDseq_results_+3A_modtype">modtype</code></td>
<td>
<p>Optional argument giving the desired model type for which results are desired. Can be supplied with or without also specifying <code>G</code>.</p>
</td></tr>
<tr><td><code id="get_MEDseq_results_+3A_noise">noise</code></td>
<td>
<p>A logical indicating whether models with a noise component should be considered. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_MEDseq_results_+3A_...">...</code></td>
<td>
<p>Catches unused arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>rank</code> and <code>criterion</code> are invoked when one or more of the arguments <code>G</code> and <code>modtype</code> are missing. Thus, supplying <code>G</code> and <code>modtype</code> allows <code>rank</code> and <code>criterion</code> to be bypassed entirely.
</p>


<h3>Value</h3>

<p>The desired results extracted from the <code>MEDseq</code> model.
</p>


<h3>Note</h3>

<p>Arguments to this function can be supplied to <code><a href="#topic+plot.MEDseq">plot.MEDseq</a></code> via the <code>...</code> construct.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code>, <code><a href="#topic+plot.MEDseq">plot.MEDseq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(biofam)
# mod &lt;- MEDseq_fit(seqdef(biofam[10:25] + 1L), G=9:10)

# Extract the MAP clustering of the best 9-cluster model according to the asw criterion
# get_MEDseq_results(mod, what="MAP", G=9, criterion="asw")

# Extract the DBS values of the best UUN model according to the dbs criterion
# get_MEDseq_results(mod, what="DBS", modtype="UUN", criterion="dbs")

# Plot the DBS values of this same model, by passing get_MEDseq_results arguments through plot
# plot(mod, type="dbsvals", modtype="UUN", criterion="dbs")
</code></pre>

<hr>
<h2 id='MEDseq_AvePP'>Average posterior probabilities of a fitted MEDseq model</h2><span id='topic+MEDseq_AvePP'></span>

<h3>Description</h3>

<p>Calculates the per-component average posterior probabilities of a fitted MEDseq model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEDseq_AvePP(x,
             group = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEDseq_AvePP_+3A_x">x</code></td>
<td>
<p>An object of class <code>"MEDseq"</code> generated by <code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code> or an object of class <code>"MEDseqCompare"</code> generated by <code><a href="#topic+MEDseq_compare">MEDseq_compare</a></code>.</p>
</td></tr>
<tr><td><code id="MEDseq_AvePP_+3A_group">group</code></td>
<td>
<p>A logical indicating whether the average posterior probabilities should be computed <em>per component</em>. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>group=TRUE</code>, this function calculates AvePP, the average posterior probabilities of membership for each component for the observations assigned to that component via MAP probabilities. Otherwise, an overall measure of clustering certainty is returned.
</p>


<h3>Value</h3>

<p>When <code>group=TRUE</code>, a named vector of numbers, of length equal to the number of components (G), in the range [1/G,1], such that <em>larger</em> values indicate clearer separation of the clusters. When <code>group=FALSE</code>, a single number in the same range is returned.
</p>


<h3>Note</h3>

<p>This function will always return values of <code>1</code> for all components for models fitted using the <code>"CEM"</code> algorithm (see <code><a href="#topic+MEDseq_control">MEDseq_control</a></code>), or models with only one component.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Murphy, T. B., Piccarreta, R., and Gormley, I. C. (2021). Clustering longitudinal life-course sequences using mixtures of exponential-distance models. <em>Journal of the Royal Statistical Society: Series A (Statistics in Society)</em>, 184(4): 1414-1451. &lt;<a href="https://doi.org/10.1111/rssa.12712">doi:10.1111/rssa.12712</a>&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code>, <code><a href="#topic+MEDseq_control">MEDseq_control</a></code>, <code><a href="#topic+MEDseq_entropy">MEDseq_entropy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the MVAD data
data(mvad)
mvad$Location &lt;- factor(apply(mvad[,5:9], 1L, function(x) 
                 which(x == "yes")), labels = colnames(mvad[,5:9]))
mvad          &lt;- list(covariates = mvad[c(3:4,10:14,87)],
                      sequences = mvad[,15:86], 
                      weights = mvad[,2])
mvad.cov      &lt;- mvad$covariates

# Create a state sequence object with the first two (summer) time points removed
states        &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
labels        &lt;- c("Employment", "Further Education", "Higher Education", 
                   "Joblessness", "School", "Training")
mvad.seq      &lt;- seqdef(mvad$sequences[-c(1,2)], states=states, labels=labels)

# Fit a model with weights and a gating covariate
# Have the probability of noise-component membership be constant
mod           &lt;- MEDseq_fit(mvad.seq, G=11, modtype="UUN", weights=mvad$weights, 
                            gating=~ gcse5eq, covars=mvad.cov, noise.gate=FALSE)

# Calculate the AvePP per component
MEDseq_AvePP(mod)

# Calculte an overall measure of clustering certainty
MEDseq_AvePP(mod, group=FALSE)
</code></pre>

<hr>
<h2 id='MEDseq_clustnames'>Automatic labelling of clusters using central sequences</h2><span id='topic+MEDseq_clustnames'></span><span id='topic+MEDseq_nameclusts'></span>

<h3>Description</h3>

<p>These functions extract names for clusters according to the SPS representation of their central sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEDseq_clustnames(x,
                  cluster = TRUE,
                  size = FALSE,
                  weighted = FALSE,
                  ...)

MEDseq_nameclusts(names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEDseq_clustnames_+3A_x">x</code></td>
<td>
<p>An object of class <code>"MEDseq"</code> generated by <code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code> or an object of class <code>"MEDseqCompare"</code> generated by <code><a href="#topic+MEDseq_compare">MEDseq_compare</a></code>.</p>
</td></tr>
<tr><td><code id="MEDseq_clustnames_+3A_cluster">cluster</code></td>
<td>
<p>A logical indicating whether names should be prepended with the text &quot;<code>Cluster g: </code>&quot;, where <code>g</code> is the cluster number. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="MEDseq_clustnames_+3A_size">size</code></td>
<td>
<p>A logical indicating whether the (typically 'soft') size of each cluster is appended to the label of each group, expressed as a percentage of the total number of observations. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="MEDseq_clustnames_+3A_weighted">weighted</code></td>
<td>
<p>A logical indicating whether the sampling weights (if any) are used when appending the <code>size</code> of each cluster to the labels. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="MEDseq_clustnames_+3A_...">...</code></td>
<td>
<p>Catches unused arguments.</p>
</td></tr>
<tr><td><code id="MEDseq_clustnames_+3A_names">names</code></td>
<td>
<p>The output of <code>MEDseq_clustnames</code> to be passed to the convenience function <code>MEDseq_nameclusts</code> (see <code>Details</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike the <code><a href="WeightedCluster.html#topic+seqclustname">seqclustname</a></code> function from the <span class="pkg">WeightedCluster</span> package which inspired these functions, <code>MEDseq_clustnames</code> only returns the names themselves, not the <code>factor</code> variable indicating cluster membership with labels given by those names. Thus, <code>MEDseq_nameclusts</code> is provided as a convenience function for precisely this purpose (see <code>Examples</code>).
</p>


<h3>Value</h3>

<p>For <code>MEDseq_clustnames</code>, a character vector containing the names for each component defined by their central sequence, and optionally the cluster name (see <code>cluster</code> above) and cluster size (see <code>size</code> above). The name for the noise component, if any, will always be simply <code>"Noise"</code> (or <code>"Cluster 0: Noise"</code>).
</p>
<p>For <code>MEDseq_nameclusts</code>, a factor version of <code>x$MAP</code> with levels given by the output of <code>MEDseq_clustnames</code>.
</p>


<h3>Note</h3>

<p>The main <code>MEDseq_clustnames</code> function is used internally by <code><a href="#topic+plot.MEDseq">plot.MEDseq</a></code>, <code><a href="#topic+MEDseq_meantime">MEDseq_meantime</a></code>, <code><a href="#topic+MEDseq_stderr">MEDseq_stderr</a></code>, and also other <code>print</code> and <code>summary</code> methods, where its invocation can typically controlled via a <code>SPS</code> logical argument. However, the optional arguments <code>cluster</code>, <code>size</code>, and <code>weighted</code> can only be passed through <code><a href="#topic+plot.MEDseq">plot.MEDseq</a></code>; elsewhere <code>cluster=TRUE</code>, <code>size=FALSE</code>, and <code>weighted=FALSE</code> are always assumed.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Murphy, T. B., Piccarreta, R., and Gormley, I. C. (2021). Clustering longitudinal life-course sequences using mixtures of exponential-distance models. <em>Journal of the Royal Statistical Society: Series A (Statistics in Society)</em>, 184(4): 1414-1451. &lt;<a href="https://doi.org/10.1111/rssa.12712">doi:10.1111/rssa.12712</a>&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="TraMineR.html#topic+seqformat">seqformat</a></code>, <code><a href="WeightedCluster.html#topic+seqclustname">seqclustname</a></code>, <code><a href="#topic+plot.MEDseq">plot.MEDseq</a></code>, <code><a href="#topic+MEDseq_meantime">MEDseq_meantime</a></code>, <code><a href="#topic+MEDseq_stderr">MEDseq_stderr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load the MVAD data
data(mvad)
mvad$Location &lt;- factor(apply(mvad[,5:9], 1L, function(x) 
                 which(x == "yes")), labels = colnames(mvad[,5:9]))
mvad          &lt;- list(covariates = mvad[c(3:4,10:14,87)],
                      sequences = mvad[,15:86], 
                      weights = mvad[,2])
mvad.cov      &lt;- mvad$covariates

# Create a state sequence object with the first two (summer) time points removed
states        &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
labels        &lt;- c("Employment", "Further Education", "Higher Education", 
                   "Joblessness", "School", "Training")
mvad.seq      &lt;- seqdef(mvad$sequences[-c(1,2)], states=states, labels=labels)

# Fit a model with weights and a gating covariate
# Have the probability of noise-component membership depend on the covariate
mod    &lt;- MEDseq_fit(mvad.seq, G=5, modtype="UUN", weights=mvad$weights, 
                     gating=~ gcse5eq, covars=mvad.cov, noise.gate=TRUE)
                     
# Extract the names
names  &lt;- MEDseq_clustnames(mod, cluster=FALSE, size=TRUE)

# Get the renamed MAP cluster membership indicator vector
group  &lt;- MEDseq_nameclusts(names)

# Use the output in plots
plot(mod, type="d", soft=FALSE, weighted=FALSE, cluster=FALSE, size=TRUE, border=TRUE)
# same as:
# seqplot(mvad.seq, type="d", group=group)

# Indeed, this function is invoked by default for certain plot types
plot(mod, type="d", soft=TRUE, weighted=TRUE)
plot(mod, type="d", soft=TRUE, weighted=TRUE, SPS=FALSE)

# Invoke this function when printing the gating network coefficients
print(mod$gating, SPS=FALSE)
print(mod$gating, SPS=TRUE)

# Invoke this function in a call to MEDseq_meantime
MEDseq_meantime(mod, SPS=TRUE)
 
# Invoke this function in other plots
plot(mod, type="clusters", SPS=TRUE)
plot(mod, type="precision", SPS=TRUE)

</code></pre>

<hr>
<h2 id='MEDseq_compare'>Choose the best MEDseq model</h2><span id='topic+MEDseq_compare'></span><span id='topic+print.MEDseqCompare'></span>

<h3>Description</h3>

<p>Takes one or more sets of <code>"MEDseq"</code> models fitted by <code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code> and ranks them according to a specified model selection criterion. It's possible to respect the internal ranking within each set of models, or to discard models within each set which were already deemed sub-optimal. This function can help with model selection via exhaustive or stepwise searches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEDseq_compare(...,
               criterion = c("bic", "icl", "aic", 
                             "dbs", "asw", "cv", "nec"),
               pick = 10L,
               optimal.only = FALSE)

## S3 method for class 'MEDseqCompare'
print(x,
      index = seq_len(x$pick),
      rerank = FALSE,
      digits = 3L,
      maxi = length(index),
      ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEDseq_compare_+3A_...">...</code></td>
<td>
<p>One or more objects of class <code>"MEDseq"</code> outputted by <code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code>. All models must have been fit to the same data set. A single <em>named</em> list of such objects can also be supplied. Additionally, objects of class <code>"MEDseqCompare"</code> outputted by this very function can also be supplied here.
</p>
<p>This argument is only relevant for the <code><a href="#topic+MEDseq_compare">MEDseq_compare</a></code> function and will be ignored for the associated <code>print</code> function.</p>
</td></tr>
<tr><td><code id="MEDseq_compare_+3A_criterion">criterion</code></td>
<td>
<p>The criterion used to determine the ranking. Defaults to <code>"bic"</code>.</p>
</td></tr>
<tr><td><code id="MEDseq_compare_+3A_pick">pick</code></td>
<td>
<p>The (integer) number of models to be ranked and compared. Defaults to <code>10L</code>. Will be constrained by the number of models within the <code>"MEDseq"</code> objects supplied via <code>...</code> if <code>optimal.only</code> is <code>FALSE</code>, otherwise constrained simply by the number of <code>"MEDseq"</code> objects supplied. Setting <code>pick=Inf</code> is a valid way to select all models.</p>
</td></tr>
<tr><td><code id="MEDseq_compare_+3A_optimal.only">optimal.only</code></td>
<td>
<p>Logical indicating whether to only rank models already deemed optimal within each <code>"MEDeq"</code> object (<code>TRUE</code>), or to allow models which were deemed suboptimal enter the final ranking (<code>FALSE</code>, the default). See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="MEDseq_compare_+3A_x">x</code>, <code id="MEDseq_compare_+3A_index">index</code>, <code id="MEDseq_compare_+3A_rerank">rerank</code>, <code id="MEDseq_compare_+3A_digits">digits</code>, <code id="MEDseq_compare_+3A_maxi">maxi</code></td>
<td>
<p>Arguments required for the associated <code>print</code> function:
</p>

<dl>
<dt><code>x</code></dt><dd><p>An object of class <code>"MEDseqCompare"</code> resulting from a call to <code><a href="#topic+MEDseq_compare">MEDseq_compare</a></code>.</p>
</dd>
<dt><code>index</code></dt><dd><p>A logical or numeric vector giving the indices of the rows of the table of ranked models to print. This defaults to the full set of ranked models. It can be useful when the table of ranked models is large to examine a subset via this <code>index</code> argument, for display purposes. See <code>rerank</code>.</p>
</dd>
<dt><code>rerank</code></dt><dd><p>A logical indicating whether the ranks should be recomputed when subsetting using <code>index</code>. Defaults to <code>FALSE</code>.</p>
</dd>
<dt><code>digits</code></dt><dd><p>The number of decimal places to round model selection criteria to (defaults to <code>3</code>).</p>
</dd>
<dt><code>maxi</code></dt><dd><p>A number specifying the maximum number of rows/models to print. Defaults to <code>length(index)</code>.</p>
</dd></dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this function is to conduct model selection on <code>"MEDseq"</code> objects, fit to the same data set, with different combinations of gating network covariates or different initialisation settings.
</p>
<p>Model selection will have already been performed in terms of choosing the optimal number of components and MEDseq model type within each supplied set of results, but <code><a href="#topic+MEDseq_compare">MEDseq_compare</a></code> will respect the internal ranking of models when producing the final ranking if <code>optimal.only</code> is <code>FALSE</code>: otherwise only those models already deemed optimal within each <code>"MEDseq"</code> object will be ranked.
</p>
<p>As such if two sets of results are supplied when <code>optimal.only</code> is <code>FALSE</code>, the 1st, 2nd, and 3rd best models could all belong to the first set of results, meaning a model deemed suboptimal according to one set of covariates could be superior to one deemed optimal under another set of covariates.
</p>


<h3>Value</h3>

<p>A list of class <code>"MEDseqCompare"</code>, for which a dedicated print function exists, containing the following elements (each of length <code>pick</code>, and ranked according to <code>criterion</code>, where appropriate):
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>The name of the data set to which the models were fitted.</p>
</td></tr>
<tr><td><code>optimal</code></td>
<td>
<p>The single optimal model (an object of class <code>"MEDseq"</code>) among those supplied, according to the chosen <code>criterion</code>.</p>
</td></tr>
<tr><td><code>pick</code></td>
<td>
<p>The final number of ranked models. May be different (i.e. less than) the supplied <code>pick</code> value.</p>
</td></tr>
<tr><td><code>MEDNames</code></td>
<td>
<p>The names of the supplied <code>"MEDseq"</code> objects.</p>
</td></tr>
<tr><td><code>modelNames</code></td>
<td>
<p>The MEDseq model names (denoting the constraints or lack thereof on the precision parameters).</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>The optimal numbers of components.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The numbers of estimated parameters.</p>
</td></tr>
<tr><td><code>iters</code></td>
<td>
<p>The numbers of EM/CEM iterations.</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p>BIC values, ranked according to <code>criterion</code>.</p>
</td></tr>
<tr><td><code>icl</code></td>
<td>
<p>ICL values, ranked according to <code>criterion</code>.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC values, ranked according to <code>criterion</code>.</p>
</td></tr>
<tr><td><code>dbs</code></td>
<td>
<p>(Weighted) mean/median DBS values, ranked according to <code>criterion</code>.</p>
</td></tr>
<tr><td><code>asw</code></td>
<td>
<p>(Weighted) mean/median ASW values, ranked according to <code>criterion</code>.</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>Cross-validated log-likelihood values, ranked according to <code>criterion</code>.</p>
</td></tr>
<tr><td><code>nec</code></td>
<td>
<p>NEC values, ranked according to <code>criterion</code>.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Maximal log-likelihood values, ranked according to <code>criterion</code>.</p>
</td></tr>
<tr><td><code>gating</code></td>
<td>
<p>The gating formulas.</p>
</td></tr>
<tr><td><code>algo</code></td>
<td>
<p>The algorithm used for fitting the model - either <code>"EM"</code>, <code>"CEM"</code>, <code>"cemEM"</code>.</p>
</td></tr>
<tr><td><code>equalPro</code></td>
<td>
<p>Logical indicating whether mixing proportions were constrained to be equal across components.</p>
</td></tr>
<tr><td><code>opti</code></td>
<td>
<p>The method used for estimating the central sequence(s).</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>Logical indicating whether the given model was fitted with sampling weights.</p>
</td></tr>
<tr><td><code>noise</code></td>
<td>
<p>Logical indicating the presence/absence of a noise component. Only displayed if at least one of the compared models has a noise component.</p>
</td></tr>
<tr><td><code>noise.gate</code></td>
<td>
<p>Logical indicating whether gating covariates were allowed to influence the noise component's mixing proportion. Only printed for models with a noise component, when at least one of the compared models has gating covariates.</p>
</td></tr>
<tr><td><code>equalNoise</code></td>
<td>
<p>Logical indicating whether the mixing proportion of the noise component for <code>equalPro</code> models is also equal (<code>TRUE</code>) or estimated (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The <code>criterion</code> argument here need not comply with the criterion used for model selection within each <code>"MEDseq"</code> object, but be aware that a mismatch in terms of <code>criterion</code> <em>may</em> require the optimal model to be re-fit in order to be extracted, thereby slowing down <code><a href="#topic+MEDseq_compare">MEDseq_compare</a></code>.
</p>
<p>If random starts had been used via <code>init.z="random"</code> the <code>optimal</code> model may not necessarily correspond to the highest-ranking model in the presence of a criterion mismatch, due to the randomness of the initialisation. 
</p>
<p>A dedicated <code>print</code> function exists for objects of class <code>"MEDseqCompare"</code> and <code><a href="#topic+plot.MEDseq">plot.MEDseq</a></code> can also be called on objects of class <code>"MEDseqCompare"</code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Murphy, T. B., Piccarreta, R., and Gormley, I. C. (2021). Clustering longitudinal life-course sequences using mixtures of exponential-distance models. <em>Journal of the Royal Statistical Society: Series A (Statistics in Society)</em>, 184(4): 1414-1451. &lt;<a href="https://doi.org/10.1111/rssa.12712">doi:10.1111/rssa.12712</a>&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code>, <code><a href="#topic+plot.MEDseq">plot.MEDseq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(biofam)
seqs &lt;- seqdef(biofam[10:25] + 1L,
               states = c("P", "L", "M", "L+M", "C", 
                          "L+C", "L+M+C", "D"))
covs &lt;- cbind(biofam[2:3], age=2002 - biofam$birthyr)
 
# Fit a range of models
# m1 &lt;- MEDseq_fit(seqs, G=9:10)
# m2 &lt;- MEDseq_fit(seqs, G=9:10, gating=~sex,       covars=covs, noise.gate=FALSE)
# m3 &lt;- MEDseq_fit(seqs, G=9:10, gating=~age,       covars=covs, noise.gate=FALSE)
# m4 &lt;- MEDseq_fit(seqs, G=9:10, gating=~sex + age, covars=covs, noise.gate=FALSE)

# Rank only the optimal models (according to the dbs criterion)
# Examine the best model in more detail
# (comp &lt;- MEDseq_compare(m1, m2, m3, m4, criterion="dbs", optimal.only=TRUE))
# (best &lt;- comp$optimal)
# (summ &lt;- summary(best, parameters=TRUE))

# Examine all models visited, including those already deemed suboptimal
# Only print models with gating covariates &amp; 10 components
# comp2 &lt;- MEDseq_compare(comp, m1, m2, m3, m4, criterion="dbs", pick=Inf)
# print(comp2, index=comp2$gating != "None" &amp; comp2$G == 10)
</code></pre>

<hr>
<h2 id='MEDseq_control'>Set control values for use with MEDseq_fit</h2><span id='topic+MEDseq_control'></span>

<h3>Description</h3>

<p>Supplies a list of arguments (with defaults) for use with <code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEDseq_control(algo = c("EM", "CEM", "cemEM"), 
               init.z = c("kmedoids", "kmodes", "kmodes2", "hc", "random", "list"), 
               z.list = NULL, 
               dist.mat = NULL, 
               unique = TRUE, 
               criterion = c("bic", "icl", "aic", "dbs", "asw", "cv", "nec"), 
               tau0 = NULL, 
               noise.gate = TRUE, 
               random = TRUE,
               do.cv = FALSE, 
               do.nec = FALSE, 
               nfolds = 10L, 
               nstarts = 1L, 
               stopping = c("aitken", "relative"), 
               equalPro = FALSE, 
               equalNoise = FALSE, 
               tol = c(1E-05, 1E-08), 
               itmax = c(.Machine$integer.max, 1000L), 
               opti = c("mode", "medoid", "first", "GA"), 
               ordering = c("none", "decreasing", "increasing"), 
               MaxNWts = 1000L, 
               verbose = TRUE, 
               ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEDseq_control_+3A_algo">algo</code></td>
<td>
<p>Switch controlling whether models are fit using the <code>"EM"</code> (the default) or <code>"CEM"</code> algorithm. The option <code>"cemEM"</code> allows running the EM algorithm starting from convergence of the CEM algorithm.</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_init.z">init.z</code></td>
<td>
<p>The method used to initialise the cluster labels. All options respect the presence of sampling <code>weights</code>, if any. Defaults to <code>"kmedoids"</code>. Other options include <code>"kmodes"</code>, <code>"kmodes2"</code>, Ward's hierarchical clustering (<code>"hc"</code>, via <code><a href="stats.html#topic+hclust">hclust</a></code>), <code>"random"</code> initialisation, and a user-supplied <code>"list"</code> (see <code>z.list</code> below). For weighted sequences, <code>"kmedoids"</code> is itself initialised using Ward's hierarchical clustering.
</p>
<p>The <code>"kmodes"</code> and <code>"kmodes2"</code> options both internally call the function <code><a href="#topic+wKModes">wKModes</a></code>, which <em>typically</em> uses random initial modes. Under <code>"kmodes"</code>, the algorithm is instead initialised via the medoids of the clusters obtained from a call to <code><a href="stats.html#topic+hclust">hclust</a></code>. The option <code>"kmodes2"</code> is slightly faster, by virtue of using the <em>random</em> initial medoids. However, final results are by default still subject to randomness under both options (unless <code><a href="base.html#topic+set.seed">set.seed</a></code> is invoked), as ties for modes and cluster assignments are <em>typically</em> broken at random throughout the algorithm (see the <code>random</code> argument below, and in <code><a href="#topic+wKModes">wKModes</a></code> itself).</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_z.list">z.list</code></td>
<td>
<p>A user supplied list of initial cluster allocation matrices, with number of rows given by the number of observations, and numbers of columns given by the range of component numbers being considered. Only relevant if <code>init.z == "z.list"</code>. These matrices are allowed correspond to both soft or hard clusterings, and will be internally normalised so that the rows sum to 1.</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_dist.mat">dist.mat</code></td>
<td>
<p>An optional distance matrix to use for initialisation when <code>init.z</code> is one of <code>"kmedoids"</code> or <code>"hc"</code>. Defaults to a Hamming distance matrix. This is an experimental feature and should only be tampered with by expert users.</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_unique">unique</code></td>
<td>
<p>A logical indicating whether the model is fit only to the unique observations (defaults to <code>TRUE</code>). When there are covariates, this means all unique combinations of covariate and sequence patterns, otherwise only the sequence patterns. 
</p>
<p>When <code>weights</code> <em>are not</em> supplied to <code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code> and <code>isTRUE(unique)</code>, weights are given by the occurrence frequency of the corresponding sequences, and the model is then fit to the unique observations only.
</p>
<p>When <code>weights</code> <em>are</em> supplied and <code>isTRUE(unique)</code>, the weights are summed for each set of duplicate observations and assigned to one retained copy of each corresponding unique sequence. Hence, observations with different weights that are otherwise duplicates are treated as duplicates and significant computational gains can be made. 
</p>
<p>In both cases, the results will be unchanged, but setting <code>unique</code> to <code>TRUE</code> can often be much faster.</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_criterion">criterion</code></td>
<td>
<p>When either <code>G</code> or <code>modtype</code> is a vector, <code>criterion</code> governs how the 'best' model is determined when gathering output. Defaults to <code>"bic"</code>. Note that all criteria will be returned in any case, if possible.</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_tau0">tau0</code></td>
<td>
<p>Prior mixing proportion for the noise component. If supplied, a noise component will be added to the model in the estimation, with <code>tau0</code> giving the prior probability of belonging to the noise component for <em>all</em> observations. Typically supplied as a scalar in the interval (0, 1), e.g. <code>0.1</code>. Can be supplied as a vector when gating covariates are present and <code>noise.gate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_noise.gate">noise.gate</code></td>
<td>
<p>A logical indicating whether gating network covariates influence the mixing proportion for the noise component, if any. Defaults to <code>TRUE</code>, but leads to greater parsimony if <code>FALSE</code>. Only relevant in the presence of a noise component (i.e. the <code>"CCN"</code>, <code>"UCN"</code>, <code>"CUN"</code>, and <code>"UUN"</code> models); only affects estimation in the presence of gating covariates.</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_random">random</code></td>
<td>
<p>A logical governing how ties for estimated central sequence positions are handled. When <code>TRUE</code> (the default), such ties are broken at random. When <code>FALSE</code> (the implied default prior to version <code>1.2.0</code> of this package), the first candidate state is always chosen. This argument affects all <code>opti</code> options. If <code>verbose</code> is <code>TRUE</code> and there are tie-breaking operations performed, a warning message is printed once per model, regardless of the number of such operations. 
</p>
<p>Note that this argument is <em>also</em> passed to <code><a href="#topic+wKModes">wKModes</a></code> if <code>init.z</code> is <code>"kmodes"</code> or <code>"kmodes2"</code> and that, in certain rare cases when the <code>"CEM"</code> <code>algo</code> is invoked when <code>equalPro</code> is <code>TRUE</code> and the precision parameter(s) are somehow constrained across clusters, this argument also governs ties for cluster assignments within <code>MEDseq_fit</code> as well.</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_do.cv">do.cv</code></td>
<td>
<p>A logical indicating whether cross-validated log-likelihood scores should also be computed (see <code>nfolds</code>). Defaults to <code>FALSE</code> due to significant computational burden incurred.</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_do.nec">do.nec</code></td>
<td>
<p>A logical indicating whether the normalised entropy criterion (NEC) should also be computed (for models with more than one component). Defaults to <code>FALSE</code>. When <code>TRUE</code>, models with <code>G=1</code> are fitted always.</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_nfolds">nfolds</code></td>
<td>
<p>The number of folds to use when <code>isTRUE{do.cv}</code>.</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_nstarts">nstarts</code></td>
<td>
<p>The number of random initialisations to use when <code>init.z="random"</code>. Defaults to <code>1</code>. Results will be based on the random start yielding the highest estimated log-likelihood.</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_stopping">stopping</code></td>
<td>
<p>The criterion used to assess convergence of the EM/CEM algorithm. The default (<code>"aitken"</code>) uses Aitken's acceleration method, otherwise the <code>"relative"</code> change in log-likelihood is monitored (which may be less strict).</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_equalpro">equalPro</code></td>
<td>
<p>Logical variable indicating whether or not the mixing proportions are to be constrained to be equal in the model. Default: <code>equalPro = FALSE</code>. Only relevant when <code>gating</code> covariates are <em>not</em> supplied within <code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code>, otherwise ignored. In the presence of a noise component, only the mixing proportions for the non-noise components are constrained to be equal (by default, see <code>equalNoise</code>), after accounting for the noise component.</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_equalnoise">equalNoise</code></td>
<td>
<p>Logical which is <strong>only</strong> invoked when <code>isTRUE(equalPro)</code> and gating covariates are not supplied. Under the default setting (<code>FALSE</code>), the mixing proportion for the noise component is estimated, and remaining mixing proportions are equal; when <code>TRUE</code> all components, including the noise component, have equal mixing proportions.</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_tol">tol</code></td>
<td>
<p>A vector of length two giving <em>relative</em> convergence tolerances for 1) the log-likelihood of the EM/CEM algorithm, and 2) optimisation in the multinomial logistic regression in the gating network, respectively. The default is <code>c(1e-05, 1e-08)</code>. If only one number is supplied, it is used as the tolerance in both cases.</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_itmax">itmax</code></td>
<td>
<p>A vector of length two giving integer limits on the number of iterations for 1) the EM/CEM algorithm, and 2) the multinomial logistic regression in the gating network, respectively. The default is <code>c(.Machine$integer.max, 1000)</code>. This allows termination of the EM/CEM algorithm to be completely governed by <code>tol[1]</code>. If only one number is supplied, it is used as the iteration limit for the EM/CEM algorithm only and the other element of <code>itmax</code> retains its usual default.
</p>
<p>If, for any model with gating covariates, the multinomial logistic regression in the gating network fails to converge in <code>itmax[2]</code> iterations at any stage of the EM/CEM algorithm, an appropriate warning will be printed, prompting the user to modify this argument.</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_opti">opti</code></td>
<td>
<p>Character string indicating how central sequence parameters should be estimated. The default <code>"mode"</code> is exact and thus this experimental argument should only be tampered with by expert users. The option <code>"medoid"</code> fixes the central sequence(s) to be one of the observed sequences (like k-medoids). The other options <code>"first"</code> and <code>"GA"</code> use stochastic local search with the first-improvement and genetic algorithms, respectively, to mutate the medoid. Pre-computation of the Hamming distance matrix for the observed sequences speeds-up computation of all options other than <code>"mode"</code>.</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_ordering">ordering</code></td>
<td>
<p>Experimental feature that should only be tampered with by experienced users. Allows sequences to be reordered on the basis of the column-wise entropy when <code>opti</code> is <code>"first"</code> or <code>"GA"</code>.</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_maxnwts">MaxNWts</code></td>
<td>
<p>The maximum allowable number of weights in the call to <code><a href="nnet.html#topic+multinom">multinom</a></code> for the multinomial logistic regression in the gating network. There is no intrinsic limit in the code, but increasing <code>MaxNWts</code> will probably allow fits that are very slow and time-consuming. It may be necessary to increase <code>MaxNWts</code> when categorical concomitant variables with many levels are included or the number of components is high.</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating whether to print messages pertaining to progress to the screen during fitting. By default is <code>TRUE</code> if the session is interactive, and <code>FALSE</code> otherwise. If <code>FALSE</code>, warnings and error messages will still be printed to the screen, but everything else will be suppressed.</p>
</td></tr>
<tr><td><code id="MEDseq_control_+3A_...">...</code></td>
<td>
<p>Catches unused arguments, and also allows the optional arguments <code>ztol</code> and <code>summ</code> to be passed to <code><a href="#topic+dbs">dbs</a></code> (<code>ztol</code> and <code>summ</code>) as well as the ASW computation (<code>summ</code>), and the optional <code><a href="#topic+wKModes">wKModes</a></code> arguments <code>iter.max</code>, <code>freq.weighted</code>, and <code>fast</code> (provided <code>init.z</code> is one of <code>"kmodes"</code> or <code>"kmodes2"</code>). In such cases, the <code>wKModes</code> argument <code>random</code> is already controlled by <code>random</code> above here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+MEDseq_control">MEDseq_control</a></code> is provided for assigning values and defaults within <code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code>. While the <code>criterion</code> argument controls the choice of the optimal number of components and MEDseq model type (in terms of the constraints or lack thereof on the precision parameters), <code><a href="#topic+MEDseq_compare">MEDseq_compare</a></code> is provided for choosing between fits with different combinations of covariates or different initialisation settings.
</p>


<h3>Value</h3>

<p>A named list in which the names are the names of the arguments and the values are the values supplied to the arguments.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Murphy, T. B., Piccarreta, R., and Gormley, I. C. (2021). Clustering longitudinal life-course sequences using mixtures of exponential-distance models. <em>Journal of the Royal Statistical Society: Series A (Statistics in Society)</em>, 184(4): 1414-1451. &lt;<a href="https://doi.org/10.1111/rssa.12712">doi:10.1111/rssa.12712</a>&gt;.
</p>
<p>Menardi, G. (2011). Density-based silhouette diagnostics for clustering methods. <em>Statistics and Computing</em>, 21(3): 295-308.
</p>
<p>Hoos, H. and T. Stützle (2004). <em>Stochastic Local Search: Foundations and Applications</em>. The Morgan Kaufman Series in Artificial Intelligence. San Francisco, CA, USA: Morgan Kaufman Publishers Inc.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code>, <code><a href="#topic+dbs">dbs</a></code>, <code><a href="WeightedCluster.html#topic+wcKMedoids">wcKMedoids</a></code>, <code><a href="cluster.html#topic+pam">pam</a></code>, <code><a href="#topic+wKModes">wKModes</a></code>, <code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="TraMineR.html#topic+seqdist">seqdist</a></code>, <code><a href="nnet.html#topic+multinom">multinom</a></code>, <code><a href="#topic+MEDseq_compare">MEDseq_compare</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The CC MEDseq model is almost equivalent to k-medoids when the
# CEM algorithm is employed, mixing proportions are constrained,
# and the central sequences are restricted to the observed sequences
ctrl  &lt;- MEDseq_control(algo="CEM", equalPro=TRUE, opti="medoid", criterion="asw")

data(mvad)
# Note that ctrl must be explicitly named 'ctrl'
mod   &lt;- MEDseq_fit(seqdef(mvad[,17:86]), G=11, modtype="CC", weights=mvad$weight, ctrl=ctrl)

# Alternatively, specify the control arguments directly
mod   &lt;- MEDseq_fit(seqdef(mvad[,17:86]), G=11, modtype="CC", weights=mvad$weight,
                    algo="CEM", equalPro=TRUE, opti="medoid", criterion="asw")

# Note that supplying control arguments via a mix of the ... construct and the named argument 
# 'control' or supplying MEDseq_control output without naming it 'control' can throw an error
</code></pre>

<hr>
<h2 id='MEDseq_entropy'>Entropy of a fitted MEDseq model</h2><span id='topic+MEDseq_entropy'></span>

<h3>Description</h3>

<p>Calculates the normalised entropy of a fitted MEDseq model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEDseq_entropy(x,
               group = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEDseq_entropy_+3A_x">x</code></td>
<td>
<p>An object of class <code>"MEDseq"</code> generated by <code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code> or an object of class <code>"MEDseqCompare"</code> generated by <code><a href="#topic+MEDseq_compare">MEDseq_compare</a></code>.</p>
</td></tr>
<tr><td><code id="MEDseq_entropy_+3A_group">group</code></td>
<td>
<p>A logical (defaults to <code>FALSE</code>) indicating whether component-specific average entropies should be returned instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>group</code> is <code>FALSE</code>, this function calculates the normalised entropy via </p>
<p style="text-align: center;"><code class="reqn">H=-\frac{1}{n\log(G)}\sum_{i=1}^n\sum_{g=1}^G\hat{z}_{ig}\log(\hat{z}_{ig})</code>
</p>
<p>,
where <code class="reqn">n</code> and <code class="reqn">G</code> are the sample size and number of components, respectively, and <code class="reqn">\hat{z}_{ig}</code> is the estimated posterior probability at convergence that observation <code class="reqn">i</code> belongs to component <code class="reqn">g</code>.
</p>
<p>When <code>group</code> is <code>TRUE</code>, </p>
<p style="text-align: center;"><code class="reqn">H_i=-\frac{1}{\log(G)}\sum_{g=1}^G\hat{z}_{ig}\log(\hat{z}_{ig})</code>
</p>
<p> is computed for each observation and averaged according to the MAP classification.
</p>


<h3>Value</h3>

<p>When <code>group</code> is <code>FALSE</code>, a single number, given by <code class="reqn">1-H</code>, in the range [0,1], such that <em>larger</em> values indicate clearer separation of the clusters. Otherwise, a vector of length <code>G</code> containing the per-component averages of the observation-specific entropies is returned.
</p>


<h3>Note</h3>

<p>This function will always return a normalised entropy of <code>1</code> for models fitted using the <code>"CEM"</code> algorithm (see <code><a href="#topic+MEDseq_control">MEDseq_control</a></code>), or models with only one component.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Murphy, T. B., Piccarreta, R., and Gormley, I. C. (2021). Clustering longitudinal life-course sequences using mixtures of exponential-distance models. <em>Journal of the Royal Statistical Society: Series A (Statistics in Society)</em>, 184(4): 1414-1451. &lt;<a href="https://doi.org/10.1111/rssa.12712">doi:10.1111/rssa.12712</a>&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code>, <code><a href="#topic+MEDseq_control">MEDseq_control</a></code>, <code><a href="#topic+MEDseq_AvePP">MEDseq_AvePP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the MVAD data
data(mvad)
mvad$Location &lt;- factor(apply(mvad[,5:9], 1L, function(x) 
                 which(x == "yes")), labels = colnames(mvad[,5:9]))
mvad          &lt;- list(covariates = mvad[c(3:4,10:14,87)],
                      sequences = mvad[,15:86], 
                      weights = mvad[,2])
mvad.cov      &lt;- mvad$covariates

# Create a state sequence object with the first two (summer) time points removed
states        &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
labels        &lt;- c("Employment", "Further Education", "Higher Education", 
                   "Joblessness", "School", "Training")
mvad.seq      &lt;- seqdef(mvad$sequences[-c(1,2)], states=states, labels=labels)

# Fit a model with weights and a gating covariate
# Have the probability of noise-component membership be constant
mod           &lt;- MEDseq_fit(mvad.seq, G=11, modtype="UUN", weights=mvad$weights, 
                            gating=~ gcse5eq, covars=mvad.cov, noise.gate=FALSE)

# Calculate the normalised entropy
MEDseq_entropy(mod)

# Calculate the normalised entropy per cluster
MEDseq_entropy(mod, group=TRUE)
</code></pre>

<hr>
<h2 id='MEDseq_fit'>MEDseq: Mixtures of Exponential-Distance Models with Covariates</h2><span id='topic+MEDseq_fit'></span><span id='topic+summary.MEDseq'></span><span id='topic+print.MEDseq'></span>

<h3>Description</h3>

<p>Fits MEDseq models: mixtures of Exponential-Distance models with gating covariates and sampling weights. Typically used for clustering categorical/longitudinal life-course sequences. Additional arguments are available via the function <code><a href="#topic+MEDseq_control">MEDseq_control</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEDseq_fit(seqs, 
           G = 1L:9L, 
           modtype = c("CC", "UC", "CU", "UU", 
                       "CCN", "UCN", "CUN", "UUN"), 
           gating = NULL, 
           weights = NULL, 
           ctrl = MEDseq_control(...), 
           covars = NULL, 
           ...)

## S3 method for class 'MEDseq'
summary(object,
        classification = TRUE,
        parameters = FALSE,
        network = FALSE,
        SPS = FALSE,
        ...)

## S3 method for class 'MEDseq'
print(x,
      digits = 3L,
      ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEDseq_fit_+3A_seqs">seqs</code></td>
<td>
<p>A state-sequence object of class <code>"stslist"</code> as created by the <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code> function in the <span class="pkg">TraMineR</span> package (which is reexported by <span class="pkg">MEDseq</span> for convenience). Note that the data set must have equal sequence lengths, the intervals are assumed to be evenly spaced, and missingness is not allowed.</p>
</td></tr>
<tr><td><code id="MEDseq_fit_+3A_g">G</code></td>
<td>
<p>A positive integer vector specifying the numbers of mixture components (clusters) to fit. Defaults to <code>G=1:9</code>.</p>
</td></tr>
<tr><td><code id="MEDseq_fit_+3A_modtype">modtype</code></td>
<td>
<p>A vector of character strings indicating the type of MEDseq models to be fitted, in terms of the constraints or lack thereof on the precision parameters. By default, all valid model types are fitted (except some only where <code>G &gt; 1</code> or <code>G &gt; 2</code>, see <code>Note</code>). 
The models are named <code>"CC"</code>, <code>"CU"</code>, <code>"UC"</code>, <code>"UU"</code>, <code>"CCN"</code>, <code>"CUN"</code>, <code>"UCN"</code>, and <code>"UUN"</code>. The first letter denotes whether the precision parameters are constrained/unconstrained across clusters. The second letter denotes whether the precision parameters are constrained/unconstrained across sequence positions (i.e. time points). The third letter denotes whether one of the components is constrained to have zero-precision/infinite variance. Such a noise component assumes sequences in that cluster follow a uniform distribution.</p>
</td></tr>
<tr><td><code id="MEDseq_fit_+3A_gating">gating</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> for determining the model matrix for the multinomial logistic regression in the gating network when fixed covariates enter the mixing proportions. Defaults to <code>~1</code>, i.e. no covariates. This will be ignored where <code>G=1</code>. Continuous, categorical, and/or ordinal covariates are allowed. Logical covariates will be coerced to factors. Interactions, transformations, and higher order terms are permitted: the latter <strong>must</strong> be specified explicitly using the <code>AsIs</code> operator (<code><a href="base.html#topic+I">I</a></code>). The specification of the LHS of the formula is ignored. Intercept terms are included by default.</p>
</td></tr>
<tr><td><code id="MEDseq_fit_+3A_weights">weights</code></td>
<td>
<p>Optional numeric vector containing observation-specific sampling weights, which are accounted for in the model fitting and other functions where applicable. <code>weights</code> are always internally normalised to sum to the sample size. See the <code>unique</code> argument to <code><a href="#topic+MEDseq_control">MEDseq_control</a></code> to see how incorporating weights also yields computational benefits. Note that <code>weights</code> must <strong>always</strong> be explicitly supplied here; it is not enough to use weights when constructing the state sequence object via <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code> (reexported by <span class="pkg">MEDseq</span> for convenience). If you <em>are</em> using a weighted <code>"stslist"</code> state sequence object and do not specify <code>weights</code>, you will be prompted to explicitly specify <code>weights=attr(seqs, "weights")</code> for a weighted model or <code>weights=NULL</code> for an unweighted model.</p>
</td></tr>
<tr><td><code id="MEDseq_fit_+3A_ctrl">ctrl</code></td>
<td>
<p>A list of control parameters for the EM/CEM and other aspects of the algorithm. The defaults are set by a call to <code><a href="#topic+MEDseq_control">MEDseq_control</a></code>.</p>
</td></tr>
<tr><td><code id="MEDseq_fit_+3A_covars">covars</code></td>
<td>
<p>An optional data frame (or a matrix with named columns) in which to look for the covariates in the <code>gating</code> network formula, if any. If not found in <code>covars</code>, any supplied <code>gating</code> covariates are taken from the environment from which <code>MEDseq_fit</code> is called. Try to ensure the names of variables in <code>covars</code> do not match any of those in <code>seqs</code>.</p>
</td></tr>
<tr><td><code id="MEDseq_fit_+3A_...">...</code></td>
<td>
<p>Catches unused arguments (see <code><a href="#topic+MEDseq_control">MEDseq_control</a></code>).</p>
</td></tr>
<tr><td><code id="MEDseq_fit_+3A_x">x</code>, <code id="MEDseq_fit_+3A_object">object</code>, <code id="MEDseq_fit_+3A_digits">digits</code>, <code id="MEDseq_fit_+3A_classification">classification</code>, <code id="MEDseq_fit_+3A_parameters">parameters</code>, <code id="MEDseq_fit_+3A_network">network</code>, <code id="MEDseq_fit_+3A_sps">SPS</code></td>
<td>
<p>Arguments required for the <code>print</code> and <code>summary</code> functions: <code>x</code> and <code>object</code> are objects of class <code>"MEDseq"</code> resulting from a call to <code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code>, while <code>digits</code> gives the number of decimal places to round to for printing purposes (defaults to <code>3</code>). <code>classification</code>, <code>parameters</code>, and <code>network</code> are logicals which govern whether a table of the MAP classification of observations, the mixture component parameters, and the gating network coefficients are printed, respectively. <code>SPS</code> governs the printing of the relevant quantities in <code>"summaryMEDseq"</code> objects when any of <code>classification</code>, <code>parameters</code>, &amp;/or <code>network</code> are <code>TRUE</code> (see <code><a href="#topic+MEDseq_clustnames">MEDseq_clustnames</a></code> and <code><a href="TraMineR.html#topic+seqformat">seqformat</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function effectively allows 8 different MEDseq precision parameter settings for models with or without gating network covariates. By constraining the mixing proportions to be equal (see <code>equalPro</code> in <code><a href="#topic+MEDseq_control">MEDseq_control</a></code>) an extra special case is facilitated in the latter case. 
</p>
<p>While model selection in terms of choosing the optimal number of components and the MEDseq model type is performed within <code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code>, using one of the <code>criterion</code> options within <code><a href="#topic+MEDseq_control">MEDseq_control</a></code>, choosing between multiple fits with different combinations of covariates or different initialisation settings can be done by supplying objects of class <code>"MEDseq"</code> to <code><a href="#topic+MEDseq_compare">MEDseq_compare</a></code>.
</p>


<h3>Value</h3>

<p>A list (of class <code>"MEDseq"</code>) with the following named entries (of which some may be missing, depending on the <code>criterion</code> employed), mostly corresponding to the chosen optimal model (as determined by the <code>criterion</code> within <code><a href="#topic+MEDseq_control">MEDseq_control</a></code>):
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The input data, <code>seqs</code>.</p>
</td></tr>
<tr><td><code>modtype</code></td>
<td>
<p>A character string denoting the MEDseq model type at which the optimal <code>criterion</code> occurs.</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>The optimal number of mixture components according to <code>criterion</code>.</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>A list with the following named components:
</p>

<dl>
<dt><code>theta</code></dt><dd><p>A matrix with <code>G</code> rows and T columns, where T is the number of sequence positions, giving the central sequences of each cluster. The mean of the noise component is not reported, as it does not contribute in any way to the likelihood. A dedicated <code>print</code> function is provided.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>A matrix of precision parameters. Will contain <code>1</code> row if the 1st letter of <code>modtype</code> is &quot;C&quot; and <code>G</code> columns otherwise. Will contain <code>1</code> column if the 2nd letter of <code>modtype</code> is &quot;C&quot; and T columns otherwise, where T is the number of sequence positions. Precision parameter values of zero are reported for the noise component, if any. Note that values of <code>Inf</code> are also possible, corresponding to zero-variance, which is most likely under the <code>"UU"</code> or <code>"UUN"</code> models. A dedicated <code>print</code> function is provided.</p>
</dd>
<dt><code>tau</code></dt><dd><p>The mixing proportions: either a vector of length <code>G</code> or, if <code>gating</code> covariates were supplied, a matrix with an entry for each observation (rows) and component (columns).</p>
</dd></dl>

</td></tr>
<tr><td><code>gating</code></td>
<td>
<p>An object of class <code>"MEDgating"</code> (for which dedicated <code>print</code>, <code>summary</code>, and <code><a href="#topic+predict.MEDgating">predict</a></code> methods exist) and either <code>"multinom"</code> or <code>"glm"</code> (only for single-component models) giving the <code><a href="nnet.html#topic+multinom">multinom</a></code> regression coefficients of the <code>gating</code> network. If <code>gating</code> covariates were <em>NOT</em> supplied (or the best model has just one component), this corresponds to a RHS of <code>~1</code>, otherwise the supplied <code>gating</code> formula. As such, a fitted <code>gating</code> network is always returned even in the absence of supplied covariates or clusters. If there is a noise component (and the option <code>noise.gate=TRUE</code> is invoked), its coefficients are those for the <em>last</em> component. <strong>Users are cautioned against making inferences about statistical significance from summaries of the coefficients in the gating network. Users are instead advised to use the function <code><a href="#topic+MEDseq_stderr">MEDseq_stderr</a></code></strong>.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>The final responsibility matrix whose <code>[i,k]</code>-th entry is the probability that observation <em>i</em> belongs to the <em>k</em>-th component. If there is a noise component, its values are found in the <em>last</em> column.</p>
</td></tr>
<tr><td><code>MAP</code></td>
<td>
<p>The vector of cluster labels for the chosen model corresponding to <code>z</code>, i.e. <code>max.col(z)</code>. Observations belonging to the noise component, if any, will belong to component <code>0</code>.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>A matrix of <em>all</em> BIC values with <code>length{G}</code> rows and <code>length(modtype)</code> columns. See <code>Note</code>.</p>
</td></tr>
<tr><td><code>ICL</code></td>
<td>
<p>A matrix of <em>all</em> ICL values with <code>length{G}</code> rows and <code>length(modtype)</code> columns. See <code>Note</code>.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>A matrix of <em>all</em> AIC values with <code>length{G}</code> rows and <code>length(modtype)</code> columns. See <code>Note</code>.</p>
</td></tr>
<tr><td><code>DBS</code></td>
<td>
<p>A matrix of <em>all</em> (weighted) mean/median DBS values with <code>length{G}</code> rows and <code>length(modtype)</code> columns. See <code>Note</code> and <code><a href="#topic+dbs">dbs</a></code>.</p>
</td></tr>
<tr><td><code>DBSvals</code></td>
<td>
<p>A list of lists giving the observation-specific DBS values for <em>all</em> fitted models. The first level of the list corresponds to numbers of components, the second to the MEDseq model types.</p>
</td></tr>
<tr><td><code>dbs</code></td>
<td>
<p>The (weighted) mean/median DBS value corresponding to the optimal model. May not necessarily be the optimal DBS.</p>
</td></tr>
<tr><td><code>dbsvals</code></td>
<td>
<p>Observation-specific DBS values corresponding to the optimum model, which may not be optimal in terms of DBS.</p>
</td></tr>
<tr><td><code>ASW</code></td>
<td>
<p>A matrix of <em>all</em> (weighted) mean/median ASW values with <code>length{G}</code> rows and <code>length(modtype)</code> columns. See <code>Note</code>.</p>
</td></tr>
<tr><td><code>ASWvals</code></td>
<td>
<p>A list of lists giving the observation-specific ASW values for <em>all</em> fitted models. The first level of the list corresponds to numbers of components, the second to the MEDseq model types.</p>
</td></tr>
<tr><td><code>asw</code></td>
<td>
<p>The (weighted) mean/median ASW value corresponding to the optimal model. May not necessarily be the optimal ASW.</p>
</td></tr>
<tr><td><code>aswvals</code></td>
<td>
<p>Observation-specific ASW values corresponding to the optimum model, which may not be optimal in terms of ASW.</p>
</td></tr>
<tr><td><code>LOGLIK</code></td>
<td>
<p>A matrix of <em>all</em> maximal log-likelihood values with <code>length{G}</code> rows and <code>length(modtype)</code> columns. See <code>Note</code>.</p>
</td></tr>
<tr><td><code>DF</code></td>
<td>
<p>A matrix giving the numbers of estimated parameters (i.e. the number of 'used' degrees of freedom) for <em>all</em> visited models, with <code>length{G}</code> rows and <code>length(modtype)</code> columns. Subtract these numbers from the sample size to get the degrees of freedom. See <code>Note</code>.</p>
</td></tr>
<tr><td><code>ITERS</code></td>
<td>
<p>A matrix giving the total number of EM/CEM iterations for <em>all</em> visited models, with <code>length{G}</code> rows and <code>length(modtype)</code> columns. See <code>Note</code>.</p>
</td></tr>
<tr><td><code>CV</code></td>
<td>
<p>A matrix of <em>all</em> cross-validated log-likelihood values with <code>length{G}</code> rows and <code>length(modtype)</code> columns, if available. See <code>Note</code> and the arguments <code>do.cv</code> and <code>nfolds</code> to <code><a href="#topic+MEDseq_control">MEDseq_control</a></code>.</p>
</td></tr>
<tr><td><code>NEC</code></td>
<td>
<p>A matrix of <em>all</em> NEC values with <code>length{G}</code> rows and <code>length(modtype)</code> columns, if available. See <code>Note</code> and the argument <code>do.nec</code> to <code><a href="#topic+MEDseq_control">MEDseq_control</a></code>.</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p>The BIC value corresponding to the optimal model. May not necessarily be the optimal BIC.</p>
</td></tr>
<tr><td><code>icl</code></td>
<td>
<p>The ICL value corresponding to the optimal model. May not necessarily be the optimal ICL.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>The AIC value corresponding to the optimal model. May not necessarily be the optimal AIC.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The vector of increasing log-likelihood values for every EM/CEM iteration under the optimal model. The last element of this vector is the maximum log-likelihood achieved by the parameters returned at convergence.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The number of estimated parameters in the optimal model (i.e. the number of 'used' degrees of freedom). Subtract this number from the sample size to get the degrees of freedom.</p>
</td></tr>
<tr><td><code>iters</code></td>
<td>
<p>The total number of EM/CEM iterations for the optimal model.</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>The cross-validated log-likelihood value corresponding to the optimal model, if available. May not necessarily be the optimal one.</p>
</td></tr>
<tr><td><code>nec</code></td>
<td>
<p>The NEC value corresponding to the optimal model, if available. May not necessarily be the optimal NEC.</p>
</td></tr>
<tr><td><code>ZS</code></td>
<td>
<p>A list of lists giving the <code>z</code> matrices for <em>all</em> fitted models. The first level of the list corresponds to numbers of components, the second to the MEDseq model types.</p>
</td></tr>
<tr><td><code>uncert</code></td>
<td>
<p>The uncertainty associated with the <code>classification</code>.</p>
</td></tr>
<tr><td><code>covars</code></td>
<td>
<p>A data frame gathering the set of covariates used in the <code>gating</code> network, if any. Will contain zero columns in the absence of gating covariates. Supplied gating covariates will be excluded if the optimal model has only one component. May have fewer columns than covariates supplied via the <code>covars</code> argument also, as only the included covariates are gathered here.</p>
</td></tr>
</table>
<p>Dedicated <code><a href="#topic+plot.MEDseq">plot</a></code>, <code>print</code>, and <code>summary</code> functions exist for objects of class <code>"MEDseq"</code>.
</p>


<h3>Note</h3>

<p>Where <code>BIC</code>, <code>ICL</code>, <code>AIC</code>, <code>DBS</code>, <code>ASW</code>, <code>LOGLIK</code>, <code>DF</code>, <code>ITERS</code>, <code>CV</code>, and <code>NEC</code> contain <code>NA</code> entries, this corresponds to a model which was not run; for instance a UU model is never run for single-component models as it is equivalent to CU, while a UCN model is never run for two-component models as it is equivalent to CCN. As such, one can consider the value as not really missing, but equivalent to the corresponding value. On the other hand, <code>-Inf</code> represents models which were terminated due to error, for which a log-likelihood could not be estimated. These objects all inherit the class <code>"MEDCriterion"</code> for which dedicated <code>print</code> and <code>summary</code> methods exist. For plotting, please see <code><a href="#topic+plot.MEDseq">plot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Murphy, T. B., Piccarreta, R., and Gormley, I. C. (2021). Clustering longitudinal life-course sequences using mixtures of exponential-distance models. <em>Journal of the Royal Statistical Society: Series A (Statistics in Society)</em>, 184(4): 1414-1451. &lt;<a href="https://doi.org/10.1111/rssa.12712">doi:10.1111/rssa.12712</a>&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="TraMineR.html#topic+seqdef">seqdef</a></code> (reexported by <span class="pkg">MEDseq</span> for convenience), <code><a href="#topic+MEDseq_control">MEDseq_control</a></code>, <code><a href="#topic+MEDseq_compare">MEDseq_compare</a></code>, <code><a href="#topic+plot.MEDseq">plot.MEDseq</a></code>, <code><a href="#topic+predict.MEDgating">predict.MEDgating</a></code>, <code><a href="#topic+MEDseq_stderr">MEDseq_stderr</a></code>, <code><a href="base.html#topic+I">I</a></code>, <code><a href="#topic+MEDseq_clustnames">MEDseq_clustnames</a></code>, <code><a href="TraMineR.html#topic+seqformat">seqformat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load the MVAD data
data(mvad)
mvad$Location &lt;- factor(apply(mvad[,5:9], 1L, function(x) 
                 which(x == "yes")), labels = colnames(mvad[,5:9]))
mvad          &lt;- list(covariates = mvad[c(3:4,10:14,87)],
                      sequences = mvad[,15:86], 
                      weights = mvad[,2])
mvad.cov      &lt;- mvad$covariates

# Create a state sequence object with the first two (summer) time points removed
states        &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
labels        &lt;- c("Employment", "Further Education", "Higher Education", 
                   "Joblessness", "School", "Training")
mvad.seq      &lt;- seqdef(mvad$sequences[-c(1,2)], states=states, labels=labels)

# Fit a range of exponential-distance models without clustering
mod0          &lt;- MEDseq_fit(mvad.seq, G=1)


# Fit a range of unweighted mixture models without covariates
# Only consider models with a noise component
# Supply some MEDseq_control() arguments
# mod1        &lt;- MEDseq_fit(mvad.seq, G=9:10, modtype=c("CCN", "CUN", "UCN", "UUN"),
#                           algo="CEM", init.z="kmodes", criterion="icl")

# Fit a model with weights and a gating covariate
# Have the probability of noise-component membership be constant
mod2          &lt;- MEDseq_fit(mvad.seq, G=11, modtype="UUN", weights=mvad$weights, 
                            gating=~ gcse5eq, covars=mvad.cov, noise.gate=FALSE)
                            
# Examine this model in greater detail
summary(mod2, classification=TRUE, parameters=TRUE)
summary(mod2$gating, SPS=TRUE)
print(mod2$params$theta, SPS=TRUE)
plot(mod2, "clusters")

</code></pre>

<hr>
<h2 id='MEDseq_meantime'>Compute the mean time spent in each sequence category</h2><span id='topic+MEDseq_meantime'></span><span id='topic+print.MEDseqMeanTime'></span>

<h3>Description</h3>

<p>Computes the mean time (per cluster) spent in each sequence category (i.e. state value) for a fitted <code>MEDseq</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEDseq_meantime(x,
                MAP = FALSE,
                weighted = TRUE, 
                norm = TRUE,
                prop = FALSE, 
                map.size = FALSE,
                wt.size = FALSE,
                SPS = FALSE)

## S3 method for class 'MEDseqMeanTime'
print(x,
      digits = 3L,
      ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEDseq_meantime_+3A_x">x</code></td>
<td>
<p>An object of class <code>"MEDseq"</code> generated by <code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code> or an object of class <code>"MEDseqCompare"</code> generated by <code><a href="#topic+MEDseq_compare">MEDseq_compare</a></code>.</p>
</td></tr>
<tr><td><code id="MEDseq_meantime_+3A_map">MAP</code></td>
<td>
<p>A logical indicating whether to use the MAP classification in the computation of the averages, or the 'soft' clustering assignment probabilities given by <code>x$z</code>. Defaults to <code>FALSE</code>, but is always <code>TRUE</code> for models fitted by the CEM algorithm (see <code><a href="#topic+MEDseq_control">MEDseq_control</a></code>). See <code>weighted</code> for incorporating the sampling weights (regardless of the value of <code>MAP</code>). See <code>map.size</code> below.</p>
</td></tr>
<tr><td><code id="MEDseq_meantime_+3A_weighted">weighted</code></td>
<td>
<p>A logical indicating whether the sampling weights (if used during model fitting) are used to compute the weighted averages. These can be used alone (when <code>MAP</code> is <code>TRUE</code>) or in conjunction with the 'soft' clustering assignment probabilities (when <code>MAP</code> is <code>FALSE</code>). Defaults to <code>TRUE</code>. Note that, <em>by default</em>, the first column of the output is not affected by the value of <code>weighted</code> (see <code>wt.size</code>).</p>
</td></tr>
<tr><td><code id="MEDseq_meantime_+3A_norm">norm</code></td>
<td>
<p>A logical indicating whether the mean times (outputted values after the first column) are normalised to sum to the sequence length within each cluster (defaults to <code>TRUE</code>). Otherwise, when <code>FALSE</code>, entries beyond the first column give the total (weighted) number of times a given sequence category was observed in a given cluster.</p>
</td></tr>
<tr><td><code id="MEDseq_meantime_+3A_prop">prop</code></td>
<td>
<p>A logical (defaulting to <code>FALSE</code> and only invoked when <code>norm</code> is also <code>TRUE</code>) which further normalises the output to give the <em>proportions</em> of time spent in each state on average instead of the absolute values.</p>
</td></tr>
<tr><td><code id="MEDseq_meantime_+3A_map.size">map.size</code></td>
<td>
<p>A logical (defaulting to <code>FALSE</code>, unless the model was fitted by the CEM algorithm (see <code><a href="#topic+MEDseq_control">MEDseq_control</a></code>)) which overrides <code>MAP</code> in the <code>Size</code> column (or <code>Weighted.Size</code> column, see <code>wt.size</code>) of the output, e.g. if <code>MAP=FALSE</code> and <code>map.size=TRUE</code>, the MAP classification is used to determine the cluster sizes but the soft cluster-membership probabilities are used to calculate quantities in remaining columns. Only relevant when <code>MAP=FALSE</code> or <code>wt.size=TRUE</code>.</p>
</td></tr>
<tr><td><code id="MEDseq_meantime_+3A_wt.size">wt.size</code></td>
<td>
<p>A logical (defaults to <code>FALSE</code> and only invoked when when <code>weighted</code> is also <code>TRUE</code>) which toggles whether the weights are <em>also</em> used in the computation of the cluster sizes in the first column of the output (regardless of the values of <code>MAP</code> or <code>map.size</code>).</p>
</td></tr>
<tr><td><code id="MEDseq_meantime_+3A_sps">SPS</code></td>
<td>
<p>A logical indicating whether the output should be labelled according to the state-permanence-sequence representation of the central sequences. Defaults to <code>FALSE</code>. See <code><a href="#topic+MEDseq_clustnames">MEDseq_clustnames</a></code> and <code><a href="TraMineR.html#topic+seqformat">seqformat</a></code>.</p>
</td></tr>
<tr><td><code id="MEDseq_meantime_+3A_digits">digits</code></td>
<td>
<p>Minimum number of significant digits to be printed in values.</p>
</td></tr>
<tr><td><code id="MEDseq_meantime_+3A_...">...</code></td>
<td>
<p>Catches unused arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models with weights, covariates, &amp;/or a noise component are also accounted for.
</p>


<h3>Value</h3>

<p>A matrix with sequence category and cluster-specific mean times, giving clusters on the rows, corresponding cluster sizes (or weighted cluster sizes) in the first column, and sequence categories in the remaining columns.
</p>


<h3>Note</h3>

<p>The function <code><a href="#topic+plot.MEDseq">plot.MEDseq</a></code> with the option <code>type="mt"</code> can be used to visualise the mean times (by cluster). However, the results displayed therein (at present) always assume <code>norm=TRUE</code>, <code>prop=FALSE</code>, and <code>wt.size=TRUE</code>, while the <code>MAP</code> argument is renamed to <code>soft</code>, where <code>MAP=!soft</code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Murphy, T. B., Piccarreta, R., and Gormley, I. C. (2021). Clustering longitudinal life-course sequences using mixtures of exponential-distance models. <em>Journal of the Royal Statistical Society: Series A (Statistics in Society)</em>, 184(4): 1414-1451. &lt;<a href="https://doi.org/10.1111/rssa.12712">doi:10.1111/rssa.12712</a>&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code>, <code><a href="#topic+MEDseq_control">MEDseq_control</a></code>, <code><a href="#topic+plot.MEDseq">plot.MEDseq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(biofam)
seqs &lt;- seqdef(biofam[10:25] + 1L,
               states = c("P", "L", "M", "L+M", "C", 
                          "L+C", "L+M+C", "D"))
mod  &lt;- MEDseq_fit(seqs, G=10, modtype="UUN")

MEDseq_meantime(mod)
MEDseq_meantime(mod, prop=TRUE)
MEDseq_meantime(mod, map.size=TRUE)
MEDseq_meantime(mod, MAP=TRUE, norm=FALSE, SPS=TRUE)
</code></pre>

<hr>
<h2 id='MEDseq_news'>Show the NEWS file</h2><span id='topic+MEDseq_news'></span>

<h3>Description</h3>

<p>Show the <code>NEWS</code> file of the <code>MEDseq</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEDseq_news()
</code></pre>


<h3>Value</h3>

<p>The <code>MEDseq</code> <code>NEWS</code> file, provided the session is interactive.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MEDseq_news()
</code></pre>

<hr>
<h2 id='MEDseq_stderr'>MEDseq gating network standard errors</h2><span id='topic+MEDseq_stderr'></span>

<h3>Description</h3>

<p>Computes standard errors of the gating network coefficients in a fitted MEDseq model using either the Weighted Likelihood Bootstrap or Jackknife methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEDseq_stderr(mod,
              method = c("WLBS", "Jackknife"),
              N = 1000L,
              symmetric = TRUE,
              SPS = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEDseq_stderr_+3A_mod">mod</code></td>
<td>
<p>An object of class <code>"MEDseq"</code> generated by <code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code> or an object of class <code>"MEDseqCompare"</code> generated by <code><a href="#topic+MEDseq_compare">MEDseq_compare</a></code>.</p>
</td></tr>
<tr><td><code id="MEDseq_stderr_+3A_method">method</code></td>
<td>
<p>The method used to compute the standard errors (defaults to <code>"WLBS"</code>, the Weighted Likelihood Bootstrap).</p>
</td></tr>
<tr><td><code id="MEDseq_stderr_+3A_n">N</code></td>
<td>
<p>The (integer) number of samples to use when the <code>"WLBS"</code> <code>method</code> is employed. Defaults to <code>1000L</code>. Not relevant when <code>method="Jackknife"</code>, in which case <code>N</code> is always the number of observations. Must be &gt; 1, though <code>N</code> being greater than or equal to the sample size is recommended under <code>method="WLBS"</code>.</p>
</td></tr>
<tr><td><code id="MEDseq_stderr_+3A_symmetric">symmetric</code></td>
<td>
<p>A logical indicating whether symmetric draws from the uniform Dirichlet distribution are used for the <code>WLBS</code> method in the presence of existing sampling weights. Defaults to <code>TRUE</code>; when <code>FALSE</code>, the concentration parameters of the Dirichlet distribution are given by the sampling weights. Only relevant when <code>method="WLBS"</code> for models with existing sampling weights.</p>
</td></tr>
<tr><td><code id="MEDseq_stderr_+3A_sps">SPS</code></td>
<td>
<p>A logical indicating whether the output should be labelled according to the state-permanence-sequence representation of the central sequences. Defaults to <code>FALSE</code>. See <code><a href="#topic+MEDseq_clustnames">MEDseq_clustnames</a></code> and <code><a href="TraMineR.html#topic+seqformat">seqformat</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A progress bar is displayed as the function iterates over the <code>N</code> samples. The function may take a long time to run for large <code>N</code>. The function terminates immediately if <code>mod$G == 1</code>.
</p>


<h3>Value</h3>

<p>A list with the following two elements:
</p>

<dl>
<dt><code>Coefficients</code></dt><dd><p>The original matrix of estimated coefficients (<code>coef(mod$gating)</code>).</p>
</dd>
<dt><code>Std. Errors</code></dt><dd><p>The matrix of corresponding standard error estimates.</p>
</dd></dl>



<h3>Note</h3>

<p>The <code>symmetric</code> argument is an experimental feature. More generally, caution is advised in interpreting the standard error estimates under <em>either</em> the <code>"WLBS"</code> <strong>or</strong> the <code>"Jackknife"</code> <code>method</code> when there are existing sampling weights which arise from complex/stratified sampling designs.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Murphy, T. B., Piccarreta, R., and Gormley, I. C. (2021). Clustering longitudinal life-course sequences using mixtures of exponential-distance models. <em>Journal of the Royal Statistical Society: Series A (Statistics in Society)</em>, 184(4): 1414-1451. &lt;<a href="https://doi.org/10.1111/rssa.12712">doi:10.1111/rssa.12712</a>&gt;.
</p>
<p>O'Hagan, A., Murphy, T. B., Scrucca, L., and Gormley, I. C. (2019). Investigation of parameter uncertainty in clustering using a Gaussian mixture model via jackknife, bootstrap and weighted likelihood bootstrap. <em>Computational Statistics</em>, 34(4): 1779-1813.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code>, <code><a href="#topic+MEDseq_clustnames">MEDseq_clustnames</a></code>, <code><a href="TraMineR.html#topic+seqformat">seqformat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the MVAD data
data(mvad)
mvad$Location &lt;- factor(apply(mvad[,5:9], 1L, function(x) 
                 which(x == "yes")), labels = colnames(mvad[,5:9]))
mvad          &lt;- list(covariates = mvad[c(3:4,10:14,87)],
                      sequences = mvad[,15:86], 
                      weights = mvad[,2])
mvad.cov      &lt;- mvad$covariates

# Create a state sequence object with the first two (summer) time points removed
states        &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
labels        &lt;- c("Employment", "Further Education", "Higher Education", 
                   "Joblessness", "School", "Training")
mvad.seq      &lt;- seqdef(mvad$sequences[-c(1,2)], states=states, labels=labels)

# Fit a model with weights and a gating covariate
# Have the probability of noise-component membership be constant
# mod         &lt;- MEDseq_fit(mvad.seq, G=11, modtype="UUN", weights=mvad$weights, 
#                           gating=~ gcse5eq, covars=mvad.cov, noise.gate=FALSE)
                            
# Estimate standard errors using 100 WLBS samples
# (std        &lt;- MEDseq_stderr(mod, N=100))
</code></pre>

<hr>
<h2 id='mvad'>MVAD: Transition from school to work</h2><span id='topic+mvad'></span>

<h3>Description</h3>

<p>The data comes from a study by McVicar and Anyadike-Danes on transition from school to work. The data consist of static background characteristics and a time series sequence of 72 monthly labour market activities for each of a cohort of 712 individuals in the Status Zero Survey. The individuals were followed up from July 1993 to June 1999. The monthly states are recorded in columns 15 (<code>Jul.93</code>) to 86 (<code>Jun.99</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mvad)
</code></pre>


<h3>Format</h3>

<p>A data frame containing 712 rows, 72 state variables, 1 id variable and 13 covariates.
</p>


<h3>Details</h3>

<p>States are:<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
 <code>employment</code>  </td><td style="text-align: left;"> (EM) </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>FE</code>          </td><td style="text-align: left;"> further education (FE) </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>HE</code>          </td><td style="text-align: left;"> higher education (HE) </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>joblessness</code> </td><td style="text-align: left;"> (JL) </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>school</code>      </td><td style="text-align: left;"> (SC) </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>training</code>    </td><td style="text-align: left;"> (TR) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The data set contains also ids (<code>id</code>) and sample weights (<code>weights</code>) as well as the following binary covariates:<br />
<br />
<code>male</code><br />
<code>catholic</code><br />
<code>Belfast</code>, <code>N.Eastern</code>, <code>Southern</code>, <code>S.Eastern</code>, <code>Western</code> (location of school, one of five Education and Library Board areas in Northern Ireland)<br />
<code>Grammar</code> (type of secondary education, 1=grammar school)<br />
<code>funemp</code> (father's employment status at time of survey, 1=father unemployed)<br />
<code>gcse5eq</code> (qualifications gained by the end of compulsory education, 1=5+ GCSEs at grades A-C, or equivalent)<br />
<code>fmpr</code> (SOC code of father's current or most recent job at time of survey, 1=SOC1 (professional, managerial or related))<br />
<code>livboth</code> (living arrangements at time of first sweep of survey (June 1995), 1=living with both parents)
</p>


<h3>Note</h3>

<p>The first two months of the observation period coincide with summer holidays from school. Hence, documented examples throughout this package extract only the states in columns 17 to 86; i.e. sequences of length 70 from <code>Sep.93</code> to <code>Jun.99</code>.
</p>


<h3>Source</h3>

<p>McVicar and Anyadike-Danes (2002)
</p>


<h3>References</h3>

<p>McVicar, D. (2000). Status 0 four years on: young people and social exclusion in Northern Ireland. <em>Labour Market Bulletin</em>, 14, 114-119.
</p>
<p>McVicar, D. and Anyadike-Danes, M. (2002). Predicting successful and unsuccessful transitions from school to work by using sequence methods. <em>Journal of the Royal Statistical Society: Series A (Statistics in Society)</em>, 165(2): 317-334.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mvad, package="MEDseq")

mvad$Location &lt;- factor(apply(mvad[,5:9], 1L, function(x) 
                 which(x == "yes")), labels = colnames(mvad[,5:9]))
mvad          &lt;- list(covariates = mvad[c(3:4,10:14,87)],
                      sequences = mvad[,15:86], 
                      weights = mvad[,2])
mvad.cov      &lt;- mvad$covariates

# Create a state sequence object with the first two (summer) time points removed
states        &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
labels        &lt;- c("Employment", "Further Education", "Higher Education", 
                   "Joblessness", "School", "Training")
mvad.seq      &lt;- seqdef(mvad$sequences[-c(1,2)], states=states, 
                        labels=labels, weights=mvad$weights)
</code></pre>

<hr>
<h2 id='plot.MEDseq'>Plot MEDseq results</h2><span id='topic+plot.MEDseq'></span>

<h3>Description</h3>

<p>Produces a range of plots of the results of fitted <code>MEDseq</code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MEDseq'
plot(x,
     type = c("clusters", "central", "precision", "gating", 
              "bic", "icl", "aic", "dbs", "asw", "cv", 
              "nec", "LOGLIK", "dbsvals", "aswvals", "similarity",
              "uncert.bar", "uncert.profile", "loglik", 
              "d", "dH", "f", "Ht", "i", "I", "ms", "mt"), 
     seriated = c("observations", "both", "clusters", "none"), 
     soft = NULL,
     weighted = TRUE,
     SPS = NULL,
     smeth = "TSP",
     sortv = NULL,
     subset = NULL,
     quant.scale = FALSE, 
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.MEDseq_+3A_x">x</code></td>
<td>
<p>An object of class <code>"MEDseq"</code> generated by <code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code> or an object of class <code>"MEDseqCompare"</code> generated by <code><a href="#topic+MEDseq_compare">MEDseq_compare</a></code>.</p>
</td></tr>
<tr><td><code id="plot.MEDseq_+3A_type">type</code></td>
<td>
<p>A character string giving the type of plot requested:
</p>

<dl>
<dt><code>"clusters"</code></dt><dd><p>Visualise the data set with sequences grouped into their respective clusters. See <code>seriated</code>. Similar to the <code>type="I"</code> plot (see below). However, <code>type="clusters"</code> always plots the hard MAP partition and is unaffected by the <code>soft</code> argument below.</p>
</dd>
<dt><code>"central"</code></dt><dd><p>Visualise the central sequences (typically modal sequences, but this depends on the <code>opti</code> argument to <code><a href="#topic+MEDseq_control">MEDseq_control</a></code> used during model-fitting). See <code>seriated</code>. The central sequence for the noise component, if any, is not shown as it doesn't contribute in any way to the likelihood. See the <code>type="ms"</code> option below for an alternative means of displaying the central sequences.</p>
</dd>
<dt><code>"precision"</code></dt><dd><p>Visualise the precision parameters in the form of a heatmap. Values of <code>0</code> and <code>Inf</code> are shown in <code>"white"</code> and <code>"black"</code> respectively (see <code>quant.scale</code> and <code>seriated</code>).</p>
</dd>
<dt><code>"gating"</code></dt><dd><p>Visualise the gating network, i.e. the observation index (by default) against the mixing proportions for that observation, coloured by cluster. Such plots can be produced with or without the gating network actually having had covariates included during model-fitting. See <code>seriated</code>, but note that this argument is only relevant for models <em>with</em> gating network covariates, provided <code>x.axis</code> is not supplied. The optional argument <code>x.axis</code> can be passed via the <code>...</code> construct to change the x-axis against which mixing proportions are plotted (only advisable for models with a single gating network covariate, when <code>x.axis</code> is a quantity related to the gating network of the fitted model).</p>
</dd>
<dt><code>"bic"</code></dt><dd><p>Plots all BIC values in a fitted <code>MEDseq</code> object.</p>
</dd>
<dt><code>"icl"</code></dt><dd><p>Plots all ICL values in a fitted <code>MEDseq</code> object.</p>
</dd>
<dt><code>"aic"</code></dt><dd><p>Plots all AIC values in a fitted <code>MEDseq</code> object.</p>
</dd>
<dt><code>"dbs"</code></dt><dd><p>Plots all (weighted) mean/median DBS <em>criterion</em> values in a fitted <code>MEDseq</code> object.</p>
</dd>
<dt><code>"asw"</code></dt><dd><p>Plots all (weighted) mean/median ASW <em>criterion</em> values in a fitted <code>MEDseq</code> object.</p>
</dd>
<dt><code>"cv"</code></dt><dd><p>Plots all cross-validated log-likelihood values in a fitted <code>MEDseq</code> object.</p>
</dd>
<dt><code>"nec"</code></dt><dd><p>Plots all NEC values in a fitted <code>MEDseq</code> object.</p>
</dd>
<dt><code>"LOGLIK"</code></dt><dd><p>Plots all maximal log-likelihood values in a fitted <code>MEDseq</code> object.</p>
</dd>
<dt><code>"dbsvals"</code></dt><dd><p>Silhouette plot using observations-specific DBS values for the optimal model (coloured by cluster). See <code>seriated</code>.</p>
</dd>
<dt><code>"aswvals"</code></dt><dd><p>Silhouette plot using observations-specific ASW values for the optimal model (coloured by cluster). See <code>seriated</code>.</p>
</dd>
<dt><code>"similarity"</code></dt><dd><p>Produces a heatmap of the similarity matrix constructed from the <code>x$z</code> matrix at convergence, with observations reordered via <code>seriated</code> for visual clarity. The (potentially <code>seriated</code>) similarity matrix can also be invisibly returned.</p>
</dd>
<dt><code>"uncert.bar"</code></dt><dd><p>Plot the observation-specific clustering uncertainties, if any, in the form of a bar plot.</p>
</dd>
<dt><code>"uncert.profile"</code></dt><dd><p>Plot the observation-specific clustering uncertainties, if any, in the form of a profile plot.</p>
</dd>
<dt><code>"loglik"</code></dt><dd><p>Plot the log-likelihood at every iteration of the EM/CEM algorithm used to fit the model.</p>
</dd>
</dl>

<p>Also available are the following options which act as wrappers to types of plots produced by the <code><a href="TraMineR.html#topic+seqplot">seqplot</a></code> function in the <span class="pkg">TraMineR</span> package. All are affected by the value of <code>seriated</code> and all account for the sampling weights (if any) by default (see the <code>weighted</code> argument and the related <code>Note</code> below).
</p>
<p>Note also that all of the plot types below can be made to either work with the hard MAP partition (as per <code><a href="TraMineR.html#topic+seqplot">seqplot</a></code>), or to use the soft cluster membership probabilities, via the <code>soft</code> argument below. The soft information is used by default for all but the <code>"i"</code> and <code>"I"</code> plot types, which (by default) discard this information to instead use the MAP partition: see the <code>soft</code> argument below for modifying this default behaviour for all of the following plot types.
</p>

<dl>
<dt><code>"d"</code></dt><dd><p>State distribution plots (chronograms, by cluster).</p>
</dd>
<dt><code>"dH"</code></dt><dd><p>State distribution plots (chronograms, by cluster) with overlaid entropy line as per <code>type="Ht"</code>. Note that this option is only available if version <code>2.2-4</code> or later of <span class="pkg">TraMineR</span> is installed.</p>
</dd>
<dt><code>"f"</code></dt><dd><p>Sequence frequency plots (by cluster).</p>
</dd>
<dt><code>"Ht"</code></dt><dd><p>Transversal entropy plots (by cluster).</p>
</dd>
<dt><code>"i"</code></dt><dd><p>Selected sequence index plots (by cluster). By default, bar widths for each observation will be proportional to their weight (if any). However, this can be overruled by specifying <code>weighted=FALSE</code>.</p>
</dd>
<dt><code>"I"</code></dt><dd><p>Whole set index plots (by cluster). This plot effectively contains almost exactly the same information as <code>type="clusters"</code> plots, and is similarly affected by the <code>seriated</code> argument, albeit shown on a by-cluster basis rather than stacked in one plot. However, bar widths for each observation will (by default) be proportional to their weight (if any), which is not the case for <code>type="clusters"</code> plots. However, this can be overruled by specifying <code>weighted=FALSE</code>.</p>
</dd>
<dt><code>"ms"</code></dt><dd><p>Modal state sequence plots (by cluster). This is an alternative way of displaying the central sequences beyond the <code>type="central"</code> option above. Notably, this option respects arguments passed to <code><a href="#topic+get_MEDseq_results">get_MEDseq_results</a></code> via the <code>...</code> construct (see below), while <code>type="central"</code> does not, although still nothing is shown for the noise component. <strong>Note</strong>: unlike <code>type="central"</code>, this option always plots <em>modal</em> sequences, even if another <code>opti</code> setting was invoked during model-fitting via <code><a href="#topic+MEDseq_control">MEDseq_control</a></code>, in which case there will be a mismatch between the visualisation and <code>x$params$theta</code>. Similarly, there may be a mismatch if <code>soft</code> and/or <code>weighted</code> are modified from their default values of <code>TRUE</code>.</p>
</dd>
<dt><code>"mt"</code></dt><dd><p>Mean times plots (by cluster). This is equivalent to plotting the results of <code><a href="#topic+MEDseq_meantime">MEDseq_meantime</a>(x, MAP=!soft, weighted=weighted, norm=TRUE, prop=FALSE, map.size=FALSE, wt.size=TRUE)</code>. Other options for <code>norm=FALSE</code>, <code>prop=TRUE</code>, <code>map.size=TRUE</code>, and <code>wt.size=FALSE</code> may be added in future versions of this package.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plot.MEDseq_+3A_seriated">seriated</code></td>
<td>
<p>Switch indicating whether seriation should be used to improve the visualisation by re-ordering the <code>"observations"</code> within clusters (the default), the <code>"clusters"</code>, <code>"both"</code>, or <code>"none"</code>. See <code><a href="seriation.html#topic+seriate">seriate</a></code> and the <code>smeth</code> and <code>sortv</code> arguments below. 
</p>
<p>The <code>"clusters"</code> option (and the cluster-related part of <code>"both"</code>) is only invoked when <code>type</code> is one of <code>"clusters"</code>, <code>"central"</code>, <code>"precision"</code>, <code>"gating"</code>, <code>"dbsvals"</code>, <code>"aswvals"</code>, <code>"similarity"</code>, <code>"d"</code>, <code>"dH"</code>, <code>"f"</code>, <code>"Ht"</code>, <code>"i"</code>, <code>"I"</code>, <code>"ms"</code>, or <code>"mt"</code> and the model has more than one component.
</p>
<p>Additionally, the <code>"observations"</code> option (and the observation-related part of <code>"both"</code>) is only invoked when <code>type</code> is one of <code>"clusters"</code>, <code>"gating"</code>, <code>"similarity"</code>, <code>"i"</code> or <code>"I"</code>, which are also the only options for which <code>"both"</code> is relevant.
</p>
<p>Though all <code>seriated</code> options can be specified when <code>type</code> is <code>"gating"</code>, they are only invoked and relevant when the model actually contains gating network covariates and <code>x.axis</code> is not supplied via the <code>...</code> construct.</p>
</td></tr>
<tr><td><code id="plot.MEDseq_+3A_soft">soft</code></td>
<td>
<p>This argument is a single logical indicator which is only relevant for the <code>"d"</code>, <code>"dH"</code>, <code>"f"</code>, <code>"Ht"</code>, <code>"i"</code>, <code>"I"</code>, <code>"ms"</code>, and <code>"mt"</code> plot types borrowed from <span class="pkg">TraMineR</span>. When <code>soft=TRUE</code> (the default for all but the <code>"i"</code> and <code>"I"</code> <code>type</code> plots) the soft cluster membership probabilities are used in a manner akin to <code><a href="WeightedCluster.html#topic+fuzzyseqplot">fuzzyseqplot</a></code>. Otherwise, when <code>FALSE</code> (the default for <code>"i"</code> and <code>"I"</code> <code>type</code> plots), the soft information is discarded and the hard MAP partition is used instead. 
</p>
<p>Note that soft cluster membership probabilities will not be available if <code>x$G=1</code> or the model was fitted using the <code>algo="CEM"</code> option to <code><a href="#topic+MEDseq_control">MEDseq_control</a></code>. Plots may still be weighted when <code>soft</code> is <code>FALSE</code>, according to the observation-specific sampling weights, when <code>weighted=TRUE</code>. Note also that <code>type="Ht"</code> can be used in conjunction with <code>soft=TRUE</code>, unlike <code><a href="WeightedCluster.html#topic+fuzzyseqplot">fuzzyseqplot</a></code> for which <code>type="Ht"</code> is not permissible. Finally, be advised that plotting may be time-consuming when <code>soft=TRUE</code> for <code>"i"</code> and <code>"I"</code> <code>type</code> plots.</p>
</td></tr>
<tr><td><code id="plot.MEDseq_+3A_weighted">weighted</code></td>
<td>
<p>This argument is a single logical indicator which is only relevant for the <code>"clusters"</code>, <code>"central"</code>, and <code>"precision"</code> plot types, as well as the <code>"d"</code>, <code>"dH"</code>, <code>"f"</code>, <code>"Ht"</code>, <code>"i"</code>, <code>"I"</code>, <code>"ms"</code>, and <code>"mt"</code> plot types borrowed from <span class="pkg">TraMineR</span>. For plots borrowed from <span class="pkg">TraMineR</span>, when <code>TRUE</code> (the default), the weights (if any) are accounted for in such plots. Note that when <code>soft</code> is <code>TRUE</code>, plots will still be weighted according to the soft cluster membership probabilities; thus <code>weighted=TRUE</code> and <code>soft=TRUE</code> allows both these and the observation-specific weights to be used simultaneously (the default behaviour for both arguments). 
</p>
<p>Additionally, for these plots and the <code>"clusters"</code>, <code>"central"</code>, and <code>"precision"</code> types, <code>weighted</code> is passed through to <code><a href="#topic+MEDseq_clustnames">MEDseq_clustnames</a></code> in the rare case where <code>SPS=TRUE</code> (see below) and the optional <code><a href="#topic+MEDseq_clustnames">MEDseq_clustnames</a></code> argument <code>size=TRUE</code> is invoked (again, see below).</p>
</td></tr>
<tr><td><code id="plot.MEDseq_+3A_sps">SPS</code></td>
<td>
<p>A logical indicating whether clusters should be labelled according to the state-permanence-sequence representation of their central sequence. See <code><a href="#topic+MEDseq_clustnames">MEDseq_clustnames</a></code> and <code><a href="TraMineR.html#topic+seqformat">seqformat</a></code>. Defaults to <code>TRUE</code> for the plot types adapted from <span class="pkg">TraMineR</span>, i.e. the <code>"d"</code>, <code>"dH"</code>, <code>"f"</code>, <code>"Ht"</code>, <code>"i"</code>, <code>"I"</code>, <code>"ms"</code>, and <code>"mt"</code> <code>type</code> plots. The <code>SPS</code> argument is also relevant for the following <code>type</code> plots: <code>"clusters"</code>, <code>"central"</code>, and <code>"precision"</code>, though <code>SPS</code> defaults to <code>FALSE</code> in those instances. Note that if <code>SPS=TRUE</code> for any relevant plot type, the <code>weighted</code> argument above is relevant if the optional <code><a href="#topic+MEDseq_clustnames">MEDseq_clustnames</a></code> argument <code>size=TRUE</code> is invoked (see below).</p>
</td></tr>
<tr><td><code id="plot.MEDseq_+3A_smeth">smeth</code></td>
<td>
<p>A character string with the name of the seriation method to be used. Defaults to <code>"TSP"</code>. See <code><a href="seriation.html#topic+seriate">seriate</a></code> and <code>seriation::list_seriation_methods("dist")</code> for further details and the available methods. Only relevant when <code>seriated != "none"</code>. When <code>seriated == "obs"</code> or <code>seriated == "both"</code>, the ordering of observations can be governed by <code>smeth</code> or <em>instead</em> governed by the <code>sortv</code> argument below, but the ordering of clusters (when <code>seriated="clusters"</code> or <code>seriated="both"</code>) is always governed by <code>smeth</code>.</p>
</td></tr>
<tr><td><code id="plot.MEDseq_+3A_sortv">sortv</code></td>
<td>
<p>A sorting method governing the ordering of observations for <code>"clusters"</code>, <code>"gating"</code>, <code>"similarity"</code>, <code>"i"</code>, or <code>"I"</code> <code>type</code> plots. Potential options include <code>"dbs"</code> and <code>"asw"</code>, for sorting observations by their DBS or ASW values (if available), as well as <code>"from.start"</code> and <code>"from.end"</code> (only when <code>type</code> is <code>"clusters"</code>, <code>"i"</code>, or <code>"I"</code>), under which sequences are sorted by the elements of the alphabet at the successive positions starting from the start/end of the sequences (as per <span class="pkg">TraMineR</span>). Only relevant if <code>seriated</code> is one of <code>"observations"</code> or <code>"both"</code>. Note that the <code>sortv</code> argument overrides the setting in <code>smeth</code> as it pertains to the ordering of observations if <code>sortv</code> is supplied; otherwise <code>sortv</code> is <code>NULL</code> and <code>smeth</code> is invoked. Note that <code>smeth</code> always dictates the ordering of clusters (i.e. when <code>seriated="clusters"</code> or <code>seriated="both"</code>).
</p>
<p>Additionally, when (and only when) <code>soft=TRUE</code> and <code>type="I"</code>, the additional option <code>sortv="membership"</code> is provided in accordance with <code><a href="WeightedCluster.html#topic+fuzzyseqplot">fuzzyseqplot</a></code>, on which such plots are based.</p>
</td></tr>
<tr><td><code id="plot.MEDseq_+3A_subset">subset</code></td>
<td>
<p>An optional numeric vector giving the indices of the clusters to be plotted. For models with a noise component, values in <code>0:x$G</code> are admissible, where <code>0</code> denotes the noise component, otherwise only values in <code>1:x$G</code>. Only relevant for the <span class="pkg">TraMineR</span>-<code>type</code> plots, i.e. <code>"d"</code>, <code>"dH"</code>, <code>"f"</code>, <code>"Ht"</code>, <code>"i"</code>, <code>"I"</code>, <code>"ms"</code>, and <code>"mt"</code> <code>type</code> plots. Note however, that noise components are never plotted for <code>type="ms"</code> plots, so <code>subset</code> values of <code>0</code> will be ignored in this instance.</p>
</td></tr>
<tr><td><code id="plot.MEDseq_+3A_quant.scale">quant.scale</code></td>
<td>
<p>Logical indicating whether precision parameter heatmaps should use quantiles to determine non-linear colour break-points when <code>type="precision"</code>. This ensures each colour represents an equal proportion of the data. The behaviour of <code>0</code> or <code>Inf</code> values remains unchanged; only strictly-positive finite entries are affected. Heavily imbalanced values are more likely for the <code>"UU"</code> and <code>"UUN"</code> model types, thus <code>quant.scale</code> defaults to <code>TRUE</code> in those instances and <code>FALSE</code> otherwise. Note that <code>quant.scale</code> is <em>always</em> <code>FALSE</code> for the <code>"CC"</code> and <code>"CCN"</code> model types.</p>
</td></tr>
<tr><td><code id="plot.MEDseq_+3A_...">...</code></td>
<td>
<p>Catches unused arguments, and allows arguments to <code><a href="#topic+get_MEDseq_results">get_MEDseq_results</a></code> to be passed when <code>type</code> is one of <code>"clusters"</code>, <code>"dbsvals"</code>, <code>"aswvals"</code>, <code>"similarity"</code>, <code>"uncert.bar"</code>, <code>"uncert.profile"</code>, <code>"d"</code>, <code>"dH"</code>, <code>"f"</code>, <code>"Ht"</code>, <code>"i"</code>, <code>"I"</code>, <code>"ms"</code>, or <code>"mt"</code>, as well as the <code>x.axis</code> argument when <code>type="gating"</code>. Also allows select additional arguments to the <span class="pkg">TraMineR</span> function <code><a href="TraMineR.html#topic+seqplot">seqplot</a></code> to be used for the relevant plot types (e.g. <code>border</code>, <code>yaxis</code> and/or <code>ylab</code>, <code>serr</code> where <code>type="mt"</code>, and <code>info</code> where <code>type="ms"</code>) and the <code>size</code> argument to <code><a href="#topic+MEDseq_clustnames">MEDseq_clustnames</a></code>, where relevant.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>type</code> options related to model selection criteria plot values for <em>all</em> fitted models in the <code>"MEDseq"</code> object <code>x</code>. The remaining <code>type</code> options plot results for the optimal model, by default. However, arguments to <code>get_MEDseq_results</code> can be passed via the <code>...</code> construct to plot corresponding results for suboptimal models in <code>x</code> when <code>type</code> is one of <code>"clusters"</code>, <code>"d"</code>, <code>"dH"</code>, <code>"f"</code>, <code>"Ht"</code>, <code>"i"</code>, <code>"I"</code>, <code>"ms"</code>, or <code>"mt"</code>. See the examples below.
</p>


<h3>Value</h3>

<p>The visualisation according to <code>type</code> of the results of a fitted <code>MEDseq</code> model.
</p>


<h3>Note</h3>

<p>Every <code>type</code> of plot respects the sampling weights, if any. However, those related to <code><a href="TraMineR.html#topic+seqplot">seqplot</a></code> plots from <span class="pkg">TraMineR</span> (<code>"d"</code>, <code>"dH"</code>, <code>"f"</code>, <code>"Ht"</code>, <code>"i"</code>, <code>"I"</code>, <code>"ms"</code>, <code>"mt"</code>) do so only when <code>weighted=TRUE</code> (the default). 
</p>
<p>For these plot types borrowed from <span class="pkg">TraMineR</span>, when <code>weighted=TRUE</code>, the y-axis labels (which can be suppressed using <code>ylab=NA</code>) always display cluster sizes which correspond to the output of <code><a href="#topic+MEDseq_meantime">MEDseq_meantime</a>(x, MAP=!soft, weighted=weighted, map.size=FALSE, wt.size=TRUE)</code>, where <code>wt.size=TRUE</code> is <strong>NOT</strong> the default behaviour for <code><a href="#topic+MEDseq_meantime">MEDseq_meantime</a></code>. 
</p>
<p>Please note that <code>type="dH"</code> will be unavailable if versions of <span class="pkg">TraMineR</span> prior to <code>2.2-4</code> are in use. The colour of the entropy line(s) will be <code>"blue"</code> for <code>type="Ht"</code> and <code>"black"</code> for <code>type="dH"</code>. Finally, the plot types borrowed from <span class="pkg">TraMineR</span> may be too wide to display in the preview panel. The same may also be true when <code>type</code> is <code>"dbsvals"</code> or <code>"aswvals"</code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Murphy, T. B., Piccarreta, R., and Gormley, I. C. (2021). Clustering longitudinal life-course sequences using mixtures of exponential-distance models. <em>Journal of the Royal Statistical Society: Series A (Statistics in Society)</em>, 184(4): 1414-1451. &lt;<a href="https://doi.org/10.1111/rssa.12712">doi:10.1111/rssa.12712</a>&gt;.
</p>
<p>Studer, M. (2018). Divisive property-based and fuzzy clustering for sequence analysis. In G. Ritschard and M. Studer (Eds.), <em>Sequence Analysis and Related Approaches: Innovative Methods and Applications</em>, Volume 10 of <em>Life Course Research and Social Policies</em>, pp. 223-239. Cham, Switzerland: Springer.
</p>
<p>Gabadinho, A., Ritschard, G., Mueller, N. S., and Studer, M. (2011). Analyzing and visualizing state sequences in R with <span class="pkg">TraMineR</span>. <em>Journal of Statistical Software</em>, 40(4): 1-37.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code>, <code><a href="TraMineR.html#topic+seqplot">seqplot</a></code>, <code><a href="#topic+dbs">dbs</a></code>, <code><a href="#topic+get_MEDseq_results">get_MEDseq_results</a></code>, <code><a href="seriation.html#topic+seriate">seriate</a></code>, <code><a href="seriation.html#topic+list_seriation_methods">list_seriation_methods</a></code>, <code><a href="WeightedCluster.html#topic+fuzzyseqplot">fuzzyseqplot</a></code>, <code><a href="#topic+MEDseq_meantime">MEDseq_meantime</a></code>, <code><a href="#topic+MEDseq_clustnames">MEDseq_clustnames</a></code>, <code><a href="TraMineR.html#topic+seqformat">seqformat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load the MVAD data
data(mvad)
mvad$Location &lt;- factor(apply(mvad[,5:9], 1L, function(x) 
                 which(x == "yes")), labels = colnames(mvad[,5:9]))
mvad          &lt;- list(covariates = mvad[c(3:4,10:14,87)],
                      sequences = mvad[,15:86], 
                      weights = mvad[,2])
mvad.cov      &lt;- mvad$covariates

# Create a state sequence object with the first two (summer) time points removed
states        &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
labels        &lt;- c("Employment", "Further Education", "Higher Education", 
                   "Joblessness", "School", "Training")
mvad.seq      &lt;- seqdef(mvad$sequences[-c(1,2)], states=states, labels=labels)

# Fit a range of exponential-distance models without clustering
mod0          &lt;- MEDseq_fit(mvad.seq, G=1)

# Show the central sequence and precision parameters of the optimal model
plot(mod0, type="central")
plot(mod0, type="ms")
plot(mod0, type="precision")

# Fit a range of unweighted mixture models without covariates
# Only consider models with a noise component
# mod1        &lt;- MEDseq_fit(mvad.seq, G=9:11, modtype=c("CCN", "CUN", "UCN", "UUN"))

# Plot the DBS values for all fitted models
# plot(mod1, "dbs")

# Plot the clusters of the optimal model (according to the dbs criterion)
# plot(mod1, "clusters", criterion="dbs")

# Use seriation to order the observations and the clusters
# plot(mod1, "cluster", criterion="dbs", seriated="both")

# Use a different seriation method
# seriation::list_seriation_methods("dist")
# plot(mod1, "cluster", criterion="dbs", seriated="both", smeth="Spectral")

# Use the DBS values instead to sort the observations, and label the clusters
# plot(mod1, "cluster", criterion="dbs", seriated="both", sortv="dbs", SPS=TRUE, size=TRUE)

# Plot the observation-specific ASW values of the best CCN model (according to the asw criterion)
# plot(mod1, "aswvals", modtype="CCN", criterion="asw")

# Plot the similarity matrix (as a heatmap) of the best G=9 model (according to the icl criterion)
# plot(mod1, "similarity", G=9, criterion="icl")

# Fit a model with weights and gating covariates
# mod2        &lt;- MEDseq_fit(mvad.seq, G=10, modtype="UCN", weights=mvad$weights, 
#                           gating=~ fmpr + gcse5eq + livboth, covars=mvad.cov)

# Plot the central sequences &amp; precision parameters of this model
# plot(mod2, "central")
# plot(mod2, "precision")

# Plot the clustering uncertainties in the form of a barplot
# plot(mod2, "uncert.bar")

# Plot the observation-specific DBS values
# plot(mod2, "dbsvals")

# Plot the  transversal entropies by cluster &amp; then the state-distributions by cluster
# Note that these plots may not display properly in the preview panel
# plot(mod2, "Ht", ylab=NA)              # suppress the y-axis labels
# plot(mod2, "d", border=TRUE)           # add borders
# plot(mod2, "dH", ylab=NA, border=TRUE) # both simultaneously (needs TraMineR &gt;=2.2-4)

# The plots above use the soft cluster membership probabilities
# Discard this information and reproduce the per-cluster state-distributions plot
# plot(mod2, "d", soft=FALSE)

# The plots above use the observation-specific sampling weights
# Discard this information and plot the mean times per state per cluster
# plot(mod2, "mt", weighted=FALSE)

# Use type="I" and subset=0 to examine the noise component
# plot(mod2, "I", subset=0, border=TRUE, weighted=FALSE, seriated="none")

</code></pre>

<hr>
<h2 id='predict.MEDgating'>Predictions from MEDseq gating networks</h2><span id='topic+predict.MEDgating'></span><span id='topic+fitted.MEDgating'></span><span id='topic+residuals.MEDgating'></span>

<h3>Description</h3>

<p>Predicts mixing proportions from MEDseq gating networks. Effectively akin to predicting from a multinomial logistic regression via <code><a href="nnet.html#topic+multinom">multinom</a></code>, although here the noise component (if any) is properly accounted for. So too are models with no gating covariates at all, or models with the equal mixing proportion constraint. Prior probabilities are returned by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MEDgating'
predict(object,
        newdata = NULL,
        type = c("probs", "class"),
        keep.noise = TRUE,
        droplevels = FALSE,
        ...)

## S3 method for class 'MEDgating'
fitted(object,
       ...)

## S3 method for class 'MEDgating'
residuals(object,
          ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.MEDgating_+3A_object">object</code></td>
<td>
<p>An object of class <code>"MEDgating"</code> (typically <code>x$gating</code>, where <code>x</code> is of class <code>"MEDseq"</code>).</p>
</td></tr>
<tr><td><code id="predict.MEDgating_+3A_newdata">newdata</code></td>
<td>
<p>A matrix or data frame of test examples. If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.MEDgating_+3A_type">type</code></td>
<td>
<p>The type of output desired. The default (<code>"probs"</code>) returns prior probabilities, while <code>"class"</code> returns labels indicating the most likely group <em>a priori</em>. Note that observations classified assigned the noise component (if any) are given a label of <code>0</code>.</p>
</td></tr>
<tr><td><code id="predict.MEDgating_+3A_keep.noise">keep.noise</code></td>
<td>
<p>A logical indicating whether the output should acknowledge the noise component (if any). Defaults to <code>TRUE</code>; when <code>FALSE</code>, this column is discarded and the matrix of probabilities is renormalised accordingly.</p>
</td></tr>
<tr><td><code id="predict.MEDgating_+3A_droplevels">droplevels</code></td>
<td>
<p>A logical indicating whether unseen factor levels in categorical variables within <code>newdata</code> should be dropped (with <code>NA</code> predicted in their place). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict.MEDgating_+3A_...">...</code></td>
<td>
<p>Catches unused arguments or allows the <code>type</code> and <code>keep.noise</code> arguments to be passed through <code>fitted</code> and the <code>keep.noise</code> argument to be passed through <code>residuals</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function (unlike the <code>predict</code> method for <code><a href="nnet.html#topic+multinom">multinom</a></code> on which <code>predict.MEDgating</code> is based) accounts for sampling weights and the various ways of treating gating covariates, equal mixing proportion constraints, and noise components, although its <code>type</code> argument defaults to <code>"probs"</code> rather than <code>"class"</code>.
</p>


<h3>Value</h3>

<p>The return value depends on whether <code>newdata</code> is supplied or not and whether the model includes gating covariates to begin with. When <code>newdata</code> is not supplied, the fitted values are returned (as matrix if the model contained gating covariates, otherwise as a vector as per <code>x$params$tau</code>). If <code>newdata</code> is supplied, the output is always a matrix with the same number of rows as the <code>newdata</code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Murphy, T. B., Piccarreta, R., and Gormley, I. C. (2021). Clustering longitudinal life-course sequences using mixtures of exponential-distance models. <em>Journal of the Royal Statistical Society: Series A (Statistics in Society)</em>, 184(4): 1414-1451. &lt;<a href="https://doi.org/10.1111/rssa.12712">doi:10.1111/rssa.12712</a>&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="nnet.html#topic+multinom">multinom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the MVAD data
data(mvad)
mvad$Location &lt;- factor(apply(mvad[,5:9], 1L, function(x) 
                 which(x == "yes")), labels = colnames(mvad[,5:9]))
mvad          &lt;- list(covariates = mvad[c(3:4,10:14,87)],
                      sequences = mvad[,15:86], 
                      weights = mvad[,2])
mvad.cov      &lt;- mvad$covariates

# Create a state sequence object with the first two (summer) time points removed
states        &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
labels        &lt;- c("Employment", "Further Education", "Higher Education", 
                   "Joblessness", "School", "Training")
mvad.seq      &lt;- seqdef(mvad$sequences[-c(1,2)], states=states, labels=labels)

# Fit a model with weights and a gating covariate
# Have the probability of noise-component membership be constant
mod    &lt;- MEDseq_fit(mvad.seq, G=11, modtype="UUN", weights=mvad$weights, 
                     gating=~ gcse5eq, covars=mvad.cov, noise.gate=FALSE)
(preds &lt;- predict(mod$gating, newdata=mvad.cov[1:5,]))

# Note that the predictions are not the same as the multinom predict method
# in this instance, owing to the invocation of noise.gate=FALSE above
mod2   &lt;- mod
class(mod2$gating) &lt;- c("multinom", "nnet")
predict(mod2$gating, newdata=mvad.cov[1:5,], type="probs")

# We can make this function behave in the same way by invoking keep.noise=FALSE
predict(mod$gating, keep.noise=FALSE, newdata=mvad.cov[1:5,])
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+seqdef'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>TraMineR</dt><dd><p><code><a href="TraMineR.html#topic+seqdef">seqdef</a></code></p>
</dd>
</dl>

<hr>
<h2 id='wKModes'>Weighted K-Modes Clustering with Tie-Breaking</h2><span id='topic+wKModes'></span>

<h3>Description</h3>

<p>Perform k-modes clustering on categorical data with observation-specific sampling weights and tie-breaking adjustments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wKModes(data,
        modes,
        weights = NULL,
        iter.max = .Machine$integer.max,
        freq.weighted = FALSE,
        fast = TRUE,
        random = TRUE,
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wKModes_+3A_data">data</code></td>
<td>
<p>A matrix or data frame of categorical data. Objects have to be in rows, variables in columns.</p>
</td></tr>
<tr><td><code id="wKModes_+3A_modes">modes</code></td>
<td>
<p>Either the number of modes or a set of initial (distinct) cluster modes (where each mode is a row and <code>modes</code> has the same number of columns as <code>data</code>). If a number, a random set of (distinct) rows in <code>data</code> is chosen as the initial modes. Note, this randomness is always present, and is not governed by <code>random</code> below.</p>
</td></tr>
<tr><td><code id="wKModes_+3A_weights">weights</code></td>
<td>
<p>Optional numeric vector containing non-negative observation-specific case weights.</p>
</td></tr>
<tr><td><code id="wKModes_+3A_iter.max">iter.max</code></td>
<td>
<p>The maximum number of iterations allowed. Defaults to <code>.Machine$integer.max</code>. The algorithm terminates when <code>iter.max</code> is reached or when the partition ceases to change between iterations.</p>
</td></tr>
<tr><td><code id="wKModes_+3A_freq.weighted">freq.weighted</code></td>
<td>
<p>A logical indicating whether the usual simple-matching (Hamming) distance between objects is used, or a frequency weighted version of this distance. Defaults to <code>FALSE</code>; when <code>TRUE</code>, the frequency weights are computed within the algorithm and are <em>not</em> user-specified. Distinct from the observation-level <code>weights</code> above, the frequency weights are assigned on a per-feature basis and derived from the categories represented in each column of <code>data</code>. For convenience, the function <code>dist_freqwH</code> is provided for calculating the corresponding pairwise dissimilarity matrix for subsequent use.</p>
</td></tr>
<tr><td><code id="wKModes_+3A_fast">fast</code></td>
<td>
<p>A logical indicating whether a fast version of the algorithm should be applied. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="wKModes_+3A_random">random</code></td>
<td>
<p>A logical indicating whether ties for the modal values &amp;/or assignments are broken at random. Defaults to <code>TRUE</code>: the implied default had been <code>FALSE</code> prior to version <code>1.3.2</code> of this package, as per <code>klaR::kmodes</code> prior to version <code>1.7-1</code> (see Note). Note that when <code>modes</code> is specified as the number of modes, the algorithm is <em>always</em> randomly initialised, regardless of the specification of <code>random</code>.
</p>
<p>Regarding the modes, ties are broken at random when <code>TRUE</code> and the first candidate state is always chosen for the mode when <code>FALSE</code>. Regarding assignments, tie-breaking is always first biased in favour of the observation's most recent cluster: regarding ties thereafter, these are broken at random when <code>TRUE</code> or the first other candidate cluster is always chosen when <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="wKModes_+3A_...">...</code></td>
<td>
<p>Catches unused arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The k-modes algorithm (Huang, 1998) is an extension of the k-means algorithm by MacQueen (1967).
</p>
<p>The data given by <code>data</code> is clustered by the k-modes method (Huang, 1998) which aims to partition the objects into k groups such that the distance from objects to the assigned cluster modes is minimised. 
</p>
<p>By default, the simple-matching (Hamming) distance is used to determine the dissimilarity of two objects. It is computed by counting the number of mismatches in all variables. Alternatively, this distance can be weighted by the frequencies of the categories in data, using the <code>freq.weighted</code> argument (see Huang, 1998, for details). For convenience, the function <code>dist_freqwH</code> is provided for calculating the corresponding pairwise dissimilarity matrix for subsequent use.
</p>
<p>If an initial matrix of modes is supplied, it is possible that no object will be closest to one or more modes. In this case, fewer clusters than the number of supplied modes will be returned and a warning will be printed.
</p>
<p>If called using <code>fast = TRUE</code>, the reassignment of the data to clusters is done for the entire data set before recomputation of the modes is done. For computational reasons, this option should be chosen for all but the most moderate of data sizes.
</p>


<h3>Value</h3>

<p>An object of class <code>"wKModes"</code> which is a list with the following components:
</p>

<dl>
<dt><code>cluster</code></dt><dd><p>A vector of integers indicating the cluster to which each object is allocated.</p>
</dd>
<dt><code>size</code></dt><dd><p>The number of objects in each cluster.</p>
</dd>
<dt><code>modes</code></dt><dd><p>A matrix of cluster modes.</p>
</dd>
<dt><code>withindiff</code></dt><dd><p>The within-cluster (weighted) simple-matching distance for each cluster.</p>
</dd>
<dt><code>tot.withindiff</code></dt><dd><p>The total within-cluster (weighted) distance over all clusters. <code>tot.withindiff</code> can be used to guide the choice of the number of clusters, but beware of inherent randomness in the algorithm, which is liable to yield a jagged elbow plot (see examples).</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations the algorithm reached.</p>
</dd>
<dt><code>weighted</code></dt><dd><p>A logical indicating whether observation-level <code>weights</code> were used or not throughout the algorithm.</p>
</dd>
<dt><code>freq.weighted</code></dt><dd><p>A logical indicating whether feature-level <code>freq.weights</code> were used or not in the computation of the distances. For convenience, the function <code>dist_freqwH</code> is provided for calculating the corresponding pairwise dissimilarity matrix for subsequent use.</p>
</dd>
<dt><code>random</code></dt><dd><p>A logical indicating whether ties were broken at random or not throughout the algorithm.</p>
</dd></dl>



<h3>Note</h3>

<p>This code is adapted from the <code>kmodes</code> function in the <span class="pkg">klaR</span> package. Specifically, modifications were made to allow for random tie-breaking for the modes and assignments (see <code>random</code> above) and the incorporation of observation-specific sampling <code>weights</code>, with a view to using this function as a means to initialise the allocations for MEDseq models (see the <code><a href="#topic+MEDseq_control">MEDseq_control</a></code> argument <code>init.z</code> and the related options <code>"kmodes"</code> and <code>"kmodes2"</code>). 
</p>
<p>Notably, the <code>wKModes</code> function, when invoked inside <code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code>, is used regardless of whether the weights are true sampling weights, or the weights are merely aggregation weights, or there are no weights at all. Furthermore, the <code><a href="#topic+MEDseq_control">MEDseq_control</a></code> argument <code>random</code> is <em>also</em> passed to <code>wKModes</code> when it is invoked inside <code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code>.
</p>
<p><strong>Update</strong>: as of version <code>1.7-1</code> of <span class="pkg">klaR</span>, <code>klaR::kmodes</code> now breaks assignment ties at random only when <code>fast=TRUE</code>. It still breaks assignment ties when <code>fast=FALSE</code> and all ties for modal values in the non-random manner described above. Thus, the old behaviour of <code>klaR::kmodes</code> can be recovered by specifying <code>random=FALSE</code> here, but <code>random=TRUE</code> allows random tie-breaking for both types of ties in all situations.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
(adapted from <code>klaR::kmodes</code>)
</p>


<h3>References</h3>

<p>Huang, Z. (1998). Extensions to the k-means algorithm for clustering large data sets with categorical values. <em>Data Mining and Knowledge Discovery</em>, 2(3): 283-304.
</p>
<p>MacQueen, J. (1967). Some methods for classification and analysis of multivariate observations. In L. M. L. Cam and J. Neyman (Eds.), <em>Proceedings of the Fifth Berkeley Symposium on  Mathematical Statistics and Probability</em>, Volume 1, June 21-July 18, 1965 and December 27 1965-January 7, 1966, Statistical Laboratory of the University of California, Berkelely, CA, USA, pp. 281-297. University of California Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MEDseq_control">MEDseq_control</a></code>, <code><a href="#topic+MEDseq_fit">MEDseq_fit</a></code>, <code><a href="#topic+dist_freqwH">dist_freqwH</a></code>, <code><a href="WeightedCluster.html#topic+wcAggregateCases">wcAggregateCases</a></code>, <code><a href="TraMineR.html#topic+seqformat">seqformat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>suppressMessages(require(WeightedCluster))
set.seed(99)
# Load the MVAD data &amp; aggregate the state sequences
data(mvad)
agg      &lt;- wcAggregateCases(mvad[,17:86], weights=mvad$weight)

# Create a state sequence object without the first two (summer) time points
states   &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
labels   &lt;- c("Employment", "Further Education", "Higher Education", 
              "Joblessness", "School", "Training")
mvad.seq &lt;- seqdef(mvad[agg$aggIndex, 17:86], 
                   states=states, labels=labels, 
                   weights=agg$aggWeights)

# Run k-modes without the weights
resX     &lt;- wKModes(mvad.seq, 2)

# Run k-modes with the weights
resW     &lt;- wKModes(mvad.seq, 2, weights=agg$aggWeights)

# Examine the modal sequences of both solutions
seqformat(seqdef(resX$modes), from="STS", to="SPS", compress=TRUE)
seqformat(seqdef(resW$modes), from="STS", to="SPS", compress=TRUE)

# Using tot.withindiff to choose the number of clusters

TWdiffs   &lt;- sapply(1:5, function(k) wKModes(mvad.seq, k, weights=agg$aggWeights)$tot.withindiff)
plot(TWdiffs, type="b", xlab="K")

# Use multiple random starts to account for inherent randomness
TWDiff    &lt;- sapply(1:5, function(k) min(replicate(10, 
                    wKModes(mvad.seq, k, weights=agg$aggWeights)$tot.withindiff)))
plot(TWDiff, type="b", xlab="K")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
