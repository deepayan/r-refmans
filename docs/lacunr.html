<!DOCTYPE html><html lang="en"><head><title>Help for package lacunr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lacunr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lacunr-package'><p>lacunr: Fast 3D Lacunarity for Voxel Data</p></a></li>
<li><a href='#bounding_box'><p>Create voxel array</p></a></li>
<li><a href='#glassfire'><p>California oak forest stand before and after 2020 Glass Fire</p></a></li>
<li><a href='#lac_plot'><p>Plot lacunarity curve(s)</p></a></li>
<li><a href='#lacunarity'><p>Calculate gliding-box lacunarity</p></a></li>
<li><a href='#pad_array'><p>Add padding to 3D array</p></a></li>
<li><a href='#voxelize'><p>Voxelize point cloud</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast 3D Lacunarity for Voxel Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-03</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ElliottSmeds/lacunr">https://github.com/ElliottSmeds/lacunr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ElliottSmeds/lacunr/issues">https://github.com/ElliottSmeds/lacunr/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates 3D lacunarity from voxel data. It is designed for use
    with point clouds generated from Light Detection And Ranging (LiDAR) scans
    in order to measure the spatial heterogeneity of 3-dimensional structures
    such as forest stands. It provides fast 'C++' functions to efficiently bin
    point cloud data into voxels and calculate lacunarity using different
    variants of the gliding-box algorithm originated by Allain &amp; Cloitre (1991)
    &lt;<a href="https://doi.org/10.1103%2FPhysRevA.44.3552">doi:10.1103/PhysRevA.44.3552</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.10), data.table, abind, ggplot2, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, lidR, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppThread</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>bzip2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-03 20:55:07 UTC; easmeds</td>
</tr>
<tr>
<td>Author:</td>
<td>Elliott Smeds <a href="https://orcid.org/0000-0003-1054-7491"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  J. Antonio Guzmán Q. [cph] (Author of original version of voxelize()
    function)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Elliott Smeds &lt;elliott.alfred93@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-04 16:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='lacunr-package'>lacunr: Fast 3D Lacunarity for Voxel Data</h2><span id='topic+lacunr'></span><span id='topic+lacunr-package'></span>

<h3>Description</h3>

<p>Calculates 3D lacunarity from voxel data. It is designed for use with point clouds generated from Light Detection And Ranging (LiDAR) scans in order to measure the spatial heterogeneity of 3-dimensional structures such as forest stands. It provides fast 'C++' functions to efficiently bin point cloud data into voxels and calculate lacunarity using different variants of the gliding-box algorithm originated by Allain &amp; Cloitre (1991) <a href="https://doi.org/10.1103/PhysRevA.44.3552">doi:10.1103/PhysRevA.44.3552</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Elliott Smeds <a href="mailto:elliott.alfred93@gmail.com">elliott.alfred93@gmail.com</a> (<a href="https://orcid.org/0000-0003-1054-7491">ORCID</a>) [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> J. Antonio Guzmán Q. (Author of original version of voxelize() function) [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ElliottSmeds/lacunr">https://github.com/ElliottSmeds/lacunr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ElliottSmeds/lacunr/issues">https://github.com/ElliottSmeds/lacunr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='bounding_box'>Create voxel array</h2><span id='topic+bounding_box'></span><span id='topic+bounding_box.default'></span><span id='topic+bounding_box.lac_voxels'></span><span id='topic+bounding_box.lasmetrics3d'></span>

<h3>Description</h3>

<p><code>bounding_box()</code> takes a table of voxel data and converts it into a
3-dimensional array, with the original voxels arranged in their correct
spatial positions inside of a 3-D &quot;box&quot; of empty voxels. This array can be
input directly into <code><a href="#topic+lacunarity">lacunarity()</a></code> to generate lacunarity curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounding_box(x, threshold = 0, edge_length = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bounding_box_+3A_x">x</code></td>
<td>
<p>A '<code>lac_voxels</code>' object created by <code><a href="#topic+voxelize">voxelize()</a></code> (preferred), or a
'<code>lasmetrics3d</code>' object created by <code><a href="lidR.html#topic+aggregate">lidR::voxel_metrics()</a></code>. Users can
alternatively supply a <code>data.table</code> containing X, Y, Z,
and N columns, in which case the argument <code>edge_length</code> is required.</p>
</td></tr>
<tr><td><code id="bounding_box_+3A_threshold">threshold</code></td>
<td>
<p>An integer specifying the minimum number of points to use
when determining if a voxel is occupied. The default is <code>0</code>.
<code>bounding_box()</code> retains only those voxels where <code>x$N</code> is greater than
<code>threshold</code>.</p>
</td></tr>
<tr><td><code id="bounding_box_+3A_edge_length">edge_length</code></td>
<td>
<p>a numeric vector of length 3, specifying the X, Y, and Z
dimensions of each voxel. This argument should only be necessary when
supplying voxel data generated by a function other than <code><a href="#topic+voxelize">voxelize()</a></code> or
<code><a href="lidR.html#topic+aggregate">lidR::voxel_metrics()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bounding_box()</code> relies on the spatial coordinates of the input data
to determine the dimensions of the resulting array. Noisy point cloud data
will often produce &quot;outlier&quot; voxels surrounding points that are far removed
from the bulk of the point cloud. These can drastically alter the output,
creating an array in which the occupied voxels are surrounded by a large
region of empty space. It is highly recommended that users supply a cutoff
value for <code>threshold</code> to ideally remove these outliers. More elaborate
filtering tools for trimming the point data before voxelization are
available in the <code><a href="lidR.html#topic+lidR-package">lidR</a></code> package.
</p>


<h3>Value</h3>

<p>A 3-dimensional integer <code><a href="base.html#topic+array">array</a></code> containing values of <code>0</code>
or <code>1</code>, representing the occupancy of a given voxel. Occupied voxels (<code>1</code>)
are arranged according to their relative positions in 3-dimensional space,
and fully encapsulated within a rectangular volume of unoccupied voxels
(<code>0</code>). The XYZ positions of the voxels are retained in the array
<code><a href="base.html#topic+dimnames">dimnames</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic usage ---------------------------------------------------------------
# simulate a diagonal line of points with XYZ coordinates
pc &lt;- data.frame(X = as.numeric(0:24), 
                 Y = as.numeric(0:24), 
                 Z = as.numeric(0:24))
# convert point data to cubic voxels of length 5
vox &lt;- voxelize(pc, edge_length = c(5,5,5))
# convert to voxel array
box &lt;- bounding_box(vox)

# Using lidR::voxel_metrics -------------------------------------------------
if (require("lidR")){
# reformat point data into rudimentary LAS object
las &lt;- suppressMessages(lidR::LAS(pc))
# convert to voxels of length 5
vox &lt;- lidR::voxel_metrics(las, ~list(N = length(Z)), res = 5)
# convert to voxel array
box &lt;- bounding_box(vox)
}

</code></pre>

<hr>
<h2 id='glassfire'>California oak forest stand before and after 2020 Glass Fire</h2><span id='topic+glassfire'></span>

<h3>Description</h3>

<p>This dataset contains point cloud data from two terrestrial LiDAR scans of a
Northern California oak forest shortly before and after the Glass Fire, which
burned some 27000 hectares of land in Sonoma and Napa counties between
September 27 and October 20, 2020. The scans encompass an identical 24m by
24m rectangular plot at a study site within the Saddle Mountain Open Space
Preserve in Sonoma County.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glassfire
</code></pre>


<h3>Format</h3>

<p>A data table with 1,000,000 rows and 4 columns: <code>X</code>, <code>Y</code>, <code>Z</code>, and
<code>Year</code>
</p>

<dl>
<dt><code>X</code>,<code>Y</code>,<code>Z</code></dt><dd><p>The XYZ spatial positions of each point, in meters. X
and Y denote the East-West and North-South horizontal positions,
respectively, while Z denotes the vertical position</p>
</dd>
<dt><code>Year</code></dt><dd><p>The year each LiDAR scan was taken, either 2020, immediately
before the Glass Fire, or 2021, a few months after</p>
</dd>
</dl>



<h3>Details</h3>

<p>The original terrain topography has been removed using digital elevation
model (DEM)-based height normalization, and ground points removed by clipping
all points below 0.25m. The raw point cloud data were normalized via
voxelization at a resolution of 0.125m, and the results further down-sampled
to make the dataset more compact. The X, Y, and Z coordinates were generated
from the original Easting, Northing, and elevation by subtracting their
minimum values.
</p>
<p><code>glassfire</code> is technically encoded as a <code>lasmetrics3d</code> object from the <code>lidR</code>
package. This class inherits from <code>data.table()</code>, but has the added benefit
that it can be rendered as a 3D rgl plot using <code>lidR::plot.lasmetrics3d()</code>.
</p>

<hr>
<h2 id='lac_plot'>Plot lacunarity curve(s)</h2><span id='topic+lac_plot'></span><span id='topic+lacnorm_plot'></span><span id='topic+hr_plot'></span>

<h3>Description</h3>

<p>Plot lacunarity curve(s)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lac_plot(..., log = TRUE, group_names = NULL)

lacnorm_plot(..., log = TRUE, group_names = NULL)

hr_plot(..., group_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lac_plot_+3A_...">...</code></td>
<td>
<p>One or more <code><a href="base.html#topic+data.frame">data.frames</a></code> containing lacunarity
curve data. Must contain columns named <code style="white-space: pre;">&#8288;$box_size&#8288;</code>, <code style="white-space: pre;">&#8288;$lacunarity&#8288;</code>,
<code style="white-space: pre;">&#8288;$lac_norm&#8288;</code>, and <code style="white-space: pre;">&#8288;$H_r&#8288;</code>.</p>
</td></tr>
<tr><td><code id="lac_plot_+3A_log">log</code></td>
<td>
<p>A Boolean. <code>TRUE</code> (default) displays the axes on a logarithmic
scale, <code>FALSE</code> displays them on a linear scale. For <code>lacnorm_plot()</code> this
only controls the x axis, as normalized lacunarity is by definition on a
log scale.</p>
</td></tr>
<tr><td><code id="lac_plot_+3A_group_names">group_names</code></td>
<td>
<p>A character <code><a href="base.html#topic+vector">vector</a></code> containing labels for any
data.frames passed to <code>...</code>. These labels will appear on the plot legend.
If <code>group_names</code> is left empty, the legend uses the names of the
data.frames as supplied to <code>...</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object displaying the lacunarity or H(r) curve(s). If
multiple curves are supplied, their ordering in the plot legend will
reflect the order they were listed in the function call.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate array
a &lt;- array(data = rep(c(1,0), 125), dim = c(5,5,5))
# calculate lacunarity at all box sizes
lac_curve &lt;- lacunarity(a, box_sizes = "all")
# plot raw lacunarity curve
lac_plot(lac_curve)

</code></pre>

<hr>
<h2 id='lacunarity'>Calculate gliding-box lacunarity</h2><span id='topic+lacunarity'></span>

<h3>Description</h3>

<p>Generates <code class="reqn">\Lambda(r)</code> lacunarity curves for a specified set of box sizes, using one
of two versions of the gliding-box algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lacunarity(x, box_sizes = "twos", periodic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lacunarity_+3A_x">x</code></td>
<td>
<p>A 3-dimensional <code><a href="base.html#topic+array">array</a></code> of integer values</p>
</td></tr>
<tr><td><code id="lacunarity_+3A_box_sizes">box_sizes</code></td>
<td>
<p>Which box sizes to use for calculating lacunarity:
</p>

<ul>
<li> <p><code>"twos"</code> (the default) returns box sizes for all powers of two less than or
equal to the smallest dimension of <code>x</code>.
</p>
</li>
<li> <p><code>"all"</code> calculates every possible box size up to the smallest dimension of <code>x</code>.
</p>
</li>
<li><p> Alternatively, users may supply their own <code><a href="base.html#topic+vector">vector</a></code> of custom
box sizes. This vector must be of type &quot;<code>numeric</code>&quot; and can only contain
positive values. Values which exceed the dimensions of <code>x</code> are ignored.
</p>
</li></ul>
</td></tr>
<tr><td><code id="lacunarity_+3A_periodic">periodic</code></td>
<td>
<p>A Boolean. Determines which boundary algorithm to use, the
classic fixed boundary by Allain and Cloitre (default) or the periodic
boundary algorithm introduced by Feagin et al. 2007. The latter is slightly
slower but is more robust to edge effects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The raw <code class="reqn">\Lambda(r)</code> values depend on the proportion of occupied voxels
within the data space. As a result, it is difficult to compare two spatial
patterns with different occupancy proportions because the curves will begin
at different y-intercepts. This is rectified by normalizing the curve,
typically by log-transforming it and dividing by the lacunarity value at
the smallest box size (i.e. <code class="reqn">\log \Lambda(r)/\log \Lambda(1)</code>). <code>lacunarity()</code> outputs
both normalized and non-normalized <code class="reqn">\Lambda(r)</code> curves for convenience.
</p>
<p>The function also computes <code class="reqn">\mathrm{H}(r)</code>, a transformed lacunarity curve introduced
by Feagin 2003. <code class="reqn">\mathrm{H}(r)</code> rescales normalized <code class="reqn">\Lambda(r)</code> in terms of the Hurst
exponent, where values greater than 0.5 indicate heterogeneity and values
less than 0.5 indicate homogeneity. Where <code class="reqn">\Lambda(r)</code> describes a pattern's
deviation from translational invariance, <code class="reqn">\mathrm{H}(r)</code> describes its deviation from
standard Brownian motion.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing box sizes and their
corresponding <code class="reqn">\Lambda(r)</code>, normalized <code class="reqn">\Lambda(r)</code>, and <code class="reqn">\mathrm{H}(r)</code> values. Lacunarity is
always computed for box size 1, even if the user supplies a custom
<code>box_sizes</code> vector that omits it, as this value is required to calculate
normalized lacunarity.
</p>


<h3>References</h3>

<p>Allain, C., &amp; Cloitre, M. (1991). Characterizing the lacunarity
of random and deterministic fractal sets. <em>Physical Review A</em>, <strong>44(6)</strong>,
3552–3558. <a href="https://doi.org/10.1103/PhysRevA.44.3552">doi:10.1103/PhysRevA.44.3552</a>.
</p>
<p>Feagin, R. A. (2003). Relationship of second-order lacunarity, Hurst
exponent, Brownian motion, and pattern organization. <em>Physica A:
Statistical Mechanics and its Applications</em>, <strong>328(3-4)</strong>, 315-321.
<a href="https://doi.org/10.1016/S0378-4371%2803%2900524-7">doi:10.1016/S0378-4371(03)00524-7</a>.
</p>
<p>Feagin, R. A., Wu, X. B., &amp; Feagin, T. (2007). Edge effects in lacunarity
analysis. <em>Ecological Modelling</em>, <strong>201(3–4)</strong>, 262–268.
<a href="https://doi.org/10.1016/j.ecolmodel.2006.09.019">doi:10.1016/j.ecolmodel.2006.09.019</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate array
a &lt;- array(data = rep(c(1,0), 125), dim = c(5,5,5))
# calculate lacunarity with default options
lacunarity(a)
# supply custom vector of box sizes
lacunarity(a, box_sizes = c(1,3,5))
# calculate lacunarity at all box sizes using the periodic boundary algorithm
lacunarity(a, box_sizes = "all", periodic = TRUE)
</code></pre>

<hr>
<h2 id='pad_array'>Add padding to 3D array</h2><span id='topic+pad_array'></span>

<h3>Description</h3>

<p><code>pad_array()</code> adds additional rows, columns, or slices to a 3-dimensional
array, increasing the array's dimensions by the desired amount and filling
the new space with a uniform value. It is intended for adding empty or
occupied space to the edges of a 3D spatial map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad_array(a, x = 0, y = 0, z = 0, fill = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pad_array_+3A_a">a</code></td>
<td>
<p>A 3-dimensional <code><a href="base.html#topic+array">array</a></code> of numeric values</p>
</td></tr>
<tr><td><code id="pad_array_+3A_x">x</code></td>
<td>
<p>A positive or negative integer, denoting the number of rows to add
to the array. The sign dictates which side of the array to pad. Default is
zero.</p>
</td></tr>
<tr><td><code id="pad_array_+3A_y">y</code></td>
<td>
<p>A positive or negative integer, denoting the number of columns to
add to the array. The sign dictates which side of the array to pad. Default
is zero.</p>
</td></tr>
<tr><td><code id="pad_array_+3A_z">z</code></td>
<td>
<p>A positive or negative integer, denoting the number of &quot;slices&quot; to
add to the array. The sign dictates which side of the array to pad. Default
is zero.</p>
</td></tr>
<tr><td><code id="pad_array_+3A_fill">fill</code></td>
<td>
<p>The desired value to fill the array padding with. Default is
zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pad_array()</code> uses the signs of <code>x</code>, <code>y</code>, and <code>z</code> to determine where
to add padding. Negative values are prepended before the array's lower
indices (what one might call the &quot;top&quot;, &quot;front&quot;, or &quot;beginning&quot; of the
array), while positive values are appended after the upper indices (the
&quot;bottom&quot;, &quot;back&quot;, or &quot;end&quot; of the array).
</p>


<h3>Value</h3>

<p>A 3-dimensional <code><a href="base.html#topic+array">array</a></code> with the desired padding added.
The padded portions are labelled using their <code><a href="base.html#topic+dimnames">dimnames</a></code>. If
no padding has been specified, the function returns the original array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate array
a &lt;- array(data = rep(c(1,0), 125), dim = c(5,5,5))
# add two rows of zeroes to top of array
pad &lt;- pad_array(a, x = -2)
# add one row of zeroes to bottom of array, and two columns to beginning
pad &lt;- pad_array(a, x = 1, y = -2)

</code></pre>

<hr>
<h2 id='voxelize'>Voxelize point cloud</h2><span id='topic+voxelize'></span>

<h3>Description</h3>

<p>Bins point cloud data into 3D pixels, otherwise known as 'voxels'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voxelize(x, edge_length, threads = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="voxelize_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>data.table</code>
with columns containing the X, Y, and Z coordinates of every point. Any
additional columns are ignored.</p>
</td></tr>
<tr><td><code id="voxelize_+3A_edge_length">edge_length</code></td>
<td>
<p>A numeric <code><a href="base.html#topic+vector">vector</a></code> of length <code>3</code>, containing
values for the desired X, Y, and Z dimensions of each voxel.</p>
</td></tr>
<tr><td><code id="voxelize_+3A_threads">threads</code></td>
<td>
<p>The number of threads to use for computing the voxel data.
Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data object of class '<code>lac_voxels</code>', which inherits from
<code>data.table</code>. The output contains 4 columns: X, Y, Z, and
N. The first three columns encode the spatial coordinates of each voxel
while the fourth denotes the total number of points they contain.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate a diagonal line of points with XYZ coordinates
pc &lt;- data.frame(X = 0:99, Y = 0:99, Z = 0:99)
# convert point data to cubic voxels of length 5
voxelize(pc, edge_length = c(5,5,5))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
