<!DOCTYPE html><html><head><title>Help for package trajr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {trajr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ElapsedTimeProgressBarFn'><p>A general purpose progress bar that reports elapsed time rather than number of items</p></a></li>
<li><a href='#lines.Trajectory'><p>Add Trajectory lines to a plot</p></a></li>
<li><a href='#plot.TrajDirectionAutocorrelations'><p>Plot method for direction autocorrelation</p></a></li>
<li><a href='#plot.Trajectory'><p>Plot method for trajectories</p></a></li>
<li><a href='#plot.TrajSpeedIntervals'><p>Plot method for trajectory speed intervals</p></a></li>
<li><a href='#points.Trajectory'><p>Add Trajectory points to a plot</p></a></li>
<li><a href='#Traj3DDistance'><p>3D Trajectory distance</p></a></li>
<li><a href='#Traj3DFromCoords'><p>Create a 3D Trajectory Object</p></a></li>
<li><a href='#Traj3DLength'><p>3D trajectory length</p></a></li>
<li><a href='#Traj3DRediscretize'><p>Resample a 3D trajectory to a constant step length</p></a></li>
<li><a href='#Traj3DResampleTime'><p>Resample a 3D trajectory to a constant time interval</p></a></li>
<li><a href='#Traj3DSmoothSG'><p>Smooth a 3D trajectory using a Savitzky-Golay filter</p></a></li>
<li><a href='#Traj3DStepLengths'><p>3D trajectory step lengths</p></a></li>
<li><a href='#Traj3DStraightness'><p>Straightness of a 3D Trajectory</p></a></li>
<li><a href='#TrajAcceleration'><p>Approximates the acceleration of a trajectory</p></a></li>
<li><a href='#TrajAngles'><p>Turning angles of a Trajectory</p></a></li>
<li><a href='#TrajConvertTime'><p>Converts a delimited time string to a numeric value</p></a></li>
<li><a href='#TrajDAMinMax'><p>First direction autocorrelation minimum/maximum</p></a></li>
<li><a href='#TrajDerivatives'><p>Calculates trajectory speed and change of speed</p></a></li>
<li><a href='#TrajDirectionalChange'><p>Directional change (DC)</p></a></li>
<li><a href='#TrajDirectionAutocorrelations'><p>Direction autocorrelation</p></a></li>
<li><a href='#TrajDistance'><p>Trajectory distance</p></a></li>
<li><a href='#TrajDuration'><p>Trajectory duration</p></a></li>
<li><a href='#TrajEmax'><p>Trajectory straightness index, E-max</p></a></li>
<li><a href='#TrajExpectedSquareDisplacement'><p>Trajectory expected square displacement</p></a></li>
<li><a href='#TrajFractalDimension'><p>Fractal dimension of a trajectory</p></a></li>
<li><a href='#TrajFractalDimensionValues'><p>Fractal dimension calculation</p></a></li>
<li><a href='#TrajFromCoords'><p>Create a Trajectory Object</p></a></li>
<li><a href='#TrajFromTrjPoints'><p>Create a trajectory from a subset of another</p></a></li>
<li><a href='#TrajGenerate'><p>Generate a random trajectory</p></a></li>
<li><a href='#TrajGetFPS'><p>Trajectory frames-per-second</p></a></li>
<li><a href='#TrajGetNCoords'><p>Trajectory number of coordinates</p></a></li>
<li><a href='#TrajGetTimeUnits'><p>Trajectory temporal units</p></a></li>
<li><a href='#TrajGetUnits'><p>Trajectory spatial units</p></a></li>
<li><a href='#TrajInPolygon'><p>Test whether each of the points in a trajectory lie inside a polygon</p></a></li>
<li><a href='#TrajLength'><p>Trajectory length</p></a></li>
<li><a href='#TrajLogSequence'><p>Logarithmically spaced sequence</p></a></li>
<li><a href='#TrajMeanVectorOfTurningAngles'><p>Mean vector of turning angles</p></a></li>
<li><a href='#TrajMeanVelocity'><p>Trajectory mean velocity</p></a></li>
<li><a href='#TrajMerge'><p>Combine multiple trajectories into a single whole trajectory</p></a></li>
<li><a href='#trajr-package'><p>trajr: Animal Trajectory Analysis</p></a></li>
<li><a href='#TrajRediscretize'><p>Resample a trajectory to a constant step length</p></a></li>
<li><a href='#TrajResampleTime'><p>Resample a trajectory to a constant time interval.</p></a></li>
<li><a href='#TrajReverse'><p>Reverse a trajectory</p></a></li>
<li><a href='#TrajRotate'><p>Rotate a trajectory</p></a></li>
<li><a href='#TrajsBuild'><p>Construct multiple trajectories</p></a></li>
<li><a href='#TrajScale'><p>Scale a trajectory</p></a></li>
<li><a href='#TrajSinuosity'><p>Sinuosity of a trajectory</p></a></li>
<li><a href='#TrajSinuosity2'><p>Sinuosity of a trajectory</p></a></li>
<li><a href='#TrajsMergeStats'><p>Merge trajectory characteristics</p></a></li>
<li><a href='#TrajSmoothSG'><p>Smooth a trajectory using a Savitzky-Golay filter</p></a></li>
<li><a href='#TrajSpeedIntervals'><p>Calculate speed time intervals</p></a></li>
<li><a href='#TrajSplit'><p>Split a trajectory into multiple sections</p></a></li>
<li><a href='#TrajSplitAtFirstCrossing'><p>Split a trajectory into two parts, separated at the first boundary crossing</p></a></li>
<li><a href='#TrajsStatsReplaceNAs'><p>Replace NAs in a data frame</p></a></li>
<li><a href='#TrajsStepLengths'><p>Step lengths of multiple trajectories</p></a></li>
<li><a href='#TrajStepLengths'><p>Trajectory step lengths</p></a></li>
<li><a href='#TrajStraightness'><p>Straightness of a Trajectory</p></a></li>
<li><a href='#TrajTranslate'><p>Translate a trajectory</p></a></li>
<li><a href='#TrajVelocity'><p>Velocity of a trajectory</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Animal Trajectory Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-28</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolbox to assist with statistical analysis of animal trajectories.
    It provides simple access to algorithms for calculating and assessing a variety of 
    characteristics such as speed and acceleration, as well as multiple measures of 
    straightness or tortuosity. Some support is provided for 3-dimensional trajectories. 
    McLean &amp; Skowron Volponi (2018) &lt;<a href="https://doi.org/10.1111%2Feth.12739">doi:10.1111/eth.12739</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/JimMcL/trajr">https://github.com/JimMcL/trajr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JimMcL/trajr/issues">https://github.com/JimMcL/trajr/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>signal, utils, stats, graphics, plotrix, grDevices</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, readr, tcltk, sp, MASS, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-28 02:14:00 UTC; 87054612</td>
</tr>
<tr>
<td>Author:</td>
<td>Jim McLean [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jim McLean &lt;jim_mclean@optusnet.com.au&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-29 06:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ElapsedTimeProgressBarFn'>A general purpose progress bar that reports elapsed time rather than number of items</h2><span id='topic+ElapsedTimeProgressBarFn'></span>

<h3>Description</h3>

<p>A general purpose progress bar that reports elapsed time rather than number of items
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ElapsedTimeProgressBarFn(numItems, reportFn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ElapsedTimeProgressBarFn_+3A_numitems">numItems</code></td>
<td>
<p>Number of items to be processed</p>
</td></tr>
<tr><td><code id="ElapsedTimeProgressBarFn_+3A_reportfn">reportFn</code></td>
<td>
<p>A function used to report changing progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function which should be called for each item as it is processed.
</p>

<hr>
<h2 id='lines.Trajectory'>Add Trajectory lines to a plot</h2><span id='topic+lines.Trajectory'></span>

<h3>Description</h3>

<p>The <code>lines</code> method for Trajectory objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Trajectory'
lines(
  x,
  draw.start.pt = TRUE,
  start.pt.cex = 0.8,
  start.pt.pch = 16,
  start.pt.col = "black",
  turning.angles = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.Trajectory_+3A_x">x</code></td>
<td>
<p>An object of class &quot;Trajectory&quot;, the trajectory to be plotted.</p>
</td></tr>
<tr><td><code id="lines.Trajectory_+3A_draw.start.pt">draw.start.pt</code></td>
<td>
<p>If TRUE, draws a dot at the start point of the
trajectory.</p>
</td></tr>
<tr><td><code id="lines.Trajectory_+3A_start.pt.cex">start.pt.cex</code></td>
<td>
<p>Scale to apply when drawing the start point dot.</p>
</td></tr>
<tr><td><code id="lines.Trajectory_+3A_start.pt.pch">start.pt.pch</code></td>
<td>
<p>Pch (i.e. plot character, symbol or shape) to apply when
drawing the start point dot.</p>
</td></tr>
<tr><td><code id="lines.Trajectory_+3A_start.pt.col">start.pt.col</code></td>
<td>
<p>Colour to apply when drawing the start point dot.</p>
</td></tr>
<tr><td><code id="lines.Trajectory_+3A_turning.angles">turning.angles</code></td>
<td>
<p>If <code>"random"</code> or <code>"directed"</code>, draws step turning
angles. <code>"directed"</code> assumes errors are relative to the first recorded
step angle. <code>"random"</code> assumes errors are relative to the previous step.</p>
</td></tr>
<tr><td><code id="lines.Trajectory_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.TrajDirectionAutocorrelations'>Plot method for direction autocorrelation</h2><span id='topic+plot.TrajDirectionAutocorrelations'></span>

<h3>Description</h3>

<p>The <code>plot</code> method for <code><a href="#topic+TrajDirectionAutocorrelations">TrajDirectionAutocorrelations</a></code> objects.
Plots the direction autocorrelation function as returned by a call to
<code>TrajDirectionAutocorrelations</code>, with a optional dot at the first
local minimum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TrajDirectionAutocorrelations'
plot(
  x,
  firstMinWindowSize = 10,
  type = "l",
  ylab = expression("C(" * Delta * s * ")"),
  xlab = expression(Delta * s),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.TrajDirectionAutocorrelations_+3A_x">x</code></td>
<td>
<p>Trajectory to be plotted.</p>
</td></tr>
<tr><td><code id="plot.TrajDirectionAutocorrelations_+3A_firstminwindowsize">firstMinWindowSize</code></td>
<td>
<p>If not NULL, specifies a window size used to
calculate the first local minimum, which is then plotted as a point.</p>
</td></tr>
<tr><td><code id="plot.TrajDirectionAutocorrelations_+3A_type">type</code>, <code id="plot.TrajDirectionAutocorrelations_+3A_xlab">xlab</code>, <code id="plot.TrajDirectionAutocorrelations_+3A_ylab">ylab</code></td>
<td>
<p>Defaults for plotting.</p>
</td></tr>
<tr><td><code id="plot.TrajDirectionAutocorrelations_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.Trajectory'>Plot method for trajectories</h2><span id='topic+plot.Trajectory'></span>

<h3>Description</h3>

<p>The <code>plot</code> method for Trajectory objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Trajectory'
plot(
  x,
  add = FALSE,
  draw.start.pt = TRUE,
  start.pt.cex = 0.8,
  start.pt.pch = 16,
  start.pt.col = "black",
  turning.angles = NULL,
  xlim = grDevices::extendrange(x$x),
  ylim = grDevices::extendrange(x$y),
  xlab = ifelse(is.null(TrajGetUnits(x)), "x", sprintf("x (%s)", TrajGetUnits(x))),
  ylab = ifelse(is.null(TrajGetUnits(x)), "y", sprintf("y (%s)", TrajGetUnits(x))),
  ann = graphics::par("ann"),
  axes = TRUE,
  frame.plot = axes,
  asp = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Trajectory_+3A_x">x</code></td>
<td>
<p>An object of class &quot;Trajectory&quot;, the trajectory to be plotted.</p>
</td></tr>
<tr><td><code id="plot.Trajectory_+3A_add">add</code></td>
<td>
<p>If TRUE, the trajectory is added to the current plot.</p>
</td></tr>
<tr><td><code id="plot.Trajectory_+3A_draw.start.pt">draw.start.pt</code></td>
<td>
<p>If TRUE, draws a dot at the start point of the
trajectory.</p>
</td></tr>
<tr><td><code id="plot.Trajectory_+3A_start.pt.cex">start.pt.cex</code></td>
<td>
<p>Scale to apply when drawing the start point dot.</p>
</td></tr>
<tr><td><code id="plot.Trajectory_+3A_start.pt.pch">start.pt.pch</code></td>
<td>
<p>Pch (i.e. plot character, symbol or shape) to apply when
drawing the start point dot.</p>
</td></tr>
<tr><td><code id="plot.Trajectory_+3A_start.pt.col">start.pt.col</code></td>
<td>
<p>Colour to apply when drawing the start point dot.</p>
</td></tr>
<tr><td><code id="plot.Trajectory_+3A_turning.angles">turning.angles</code></td>
<td>
<p>If <code>"random"</code> or <code>"directed"</code>, draws step turning
angles. <code>"directed"</code> assumes errors are relative to the first recorded
step angle. <code>"random"</code> assumes errors are relative to the previous step.</p>
</td></tr>
<tr><td><code id="plot.Trajectory_+3A_xlim">xlim</code>, <code id="plot.Trajectory_+3A_ylim">ylim</code>, <code id="plot.Trajectory_+3A_xlab">xlab</code>, <code id="plot.Trajectory_+3A_ylab">ylab</code>, <code id="plot.Trajectory_+3A_asp">asp</code>, <code id="plot.Trajectory_+3A_ann">ann</code>, <code id="plot.Trajectory_+3A_axes">axes</code>, <code id="plot.Trajectory_+3A_frame.plot">frame.plot</code></td>
<td>
<p>plotting parameters with useful defaults.</p>
</td></tr>
<tr><td><code id="plot.Trajectory_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to both <code><a href="graphics.html#topic+plot">plot</a></code> and <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+TrajFromCoords">TrajFromCoords</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
trj &lt;- TrajGenerate(angularErrorSd = 1.3)
plot(trj)

</code></pre>

<hr>
<h2 id='plot.TrajSpeedIntervals'>Plot method for trajectory speed intervals</h2><span id='topic+plot.TrajSpeedIntervals'></span>

<h3>Description</h3>

<p>Plots speed over time, with intervals of fast and/or slow speed highlighted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TrajSpeedIntervals'
plot(
  x,
  slowerThanColour = "red",
  fasterThanColour = "green",
  highlightColor = "#0000FF1E",
  xlab = sprintf("Time (%s)", TrajGetTimeUnits(attr(x, "trajectory"))),
  ylab = sprintf("Speed (%s/%s)", TrajGetUnits(attr(x, "trajectory")),
    TrajGetTimeUnits(attr(x, "trajectory"))),
  type = "l",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.TrajSpeedIntervals_+3A_x">x</code></td>
<td>
<p>An object of class &quot;SpeedIntervals&quot;, as created by
<code><a href="#topic+TrajSpeedIntervals">TrajSpeedIntervals</a></code>.</p>
</td></tr>
<tr><td><code id="plot.TrajSpeedIntervals_+3A_slowerthancolour">slowerThanColour</code>, <code id="plot.TrajSpeedIntervals_+3A_fasterthancolour">fasterThanColour</code></td>
<td>
<p>The colour of the horizontal line
plotted at the &quot;slower than&quot; or &quot;faster than&quot; speed. Specify <code>NULL</code> to
prevent the line from being plotted.</p>
</td></tr>
<tr><td><code id="plot.TrajSpeedIntervals_+3A_highlightcolor">highlightColor</code></td>
<td>
<p>Colour of the highlight rectangles.</p>
</td></tr>
<tr><td><code id="plot.TrajSpeedIntervals_+3A_xlab">xlab</code>, <code id="plot.TrajSpeedIntervals_+3A_ylab">ylab</code>, <code id="plot.TrajSpeedIntervals_+3A_type">type</code></td>
<td>
<p>Plotting parameters with useful defaults.</p>
</td></tr>
<tr><td><code id="plot.TrajSpeedIntervals_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+TrajSpeedIntervals">TrajSpeedIntervals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Display speed intervals with custom x-axis labels

# Generate and smooth a trajectory
set.seed(3)
trj &lt;- TrajSmoothSG(TrajGenerate(120, fps = 0.5))
# Get speed intervals to be plotted
si &lt;- TrajSpeedIntervals(trj, slowerThan = 0.9, diff = "central")
# Plot, but don't label x axis
plot(si, xlab = "Time (min:sec)", xaxt = "n")
# Work out where x-axis tick marks should be
speeds &lt;- attr(si, "speed") # data frame containing speed over time
p &lt;- pretty(speeds$time)
# Draw x-sxis ticks and labels with custom formatting
axis(1, p, sprintf("%d:%02d", p %/% 60, p %% 60))

</code></pre>

<hr>
<h2 id='points.Trajectory'>Add Trajectory points to a plot</h2><span id='topic+points.Trajectory'></span>

<h3>Description</h3>

<p>The <code>points</code> method for Trajectory objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Trajectory'
points(x, draw.start.pt = TRUE, turning.angles = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="points.Trajectory_+3A_x">x</code></td>
<td>
<p>An object of class &quot;Trajectory&quot;, the trajectory to be plotted.</p>
</td></tr>
<tr><td><code id="points.Trajectory_+3A_draw.start.pt">draw.start.pt</code></td>
<td>
<p>If TRUE, draws a dot at the start point of the
trajectory.</p>
</td></tr>
<tr><td><code id="points.Trajectory_+3A_turning.angles">turning.angles</code></td>
<td>
<p>If <code>"random"</code> or <code>"directed"</code>, draws step turning
angles. <code>"directed"</code> assumes errors are relative to the first recorded
step angle. <code>"random"</code> assumes errors are relative to the previous step.</p>
</td></tr>
<tr><td><code id="points.Trajectory_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='Traj3DDistance'>3D Trajectory distance</h2><span id='topic+Traj3DDistance'></span>

<h3>Description</h3>

<p>Calculates the distance between the start and end of a 3-dimensional trajectory (or a
portion of a trajectory). Also called the diffusion distance, net distance,
displacement, or bee-line from start to finish.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Traj3DDistance(trj3d, startIndex = 1, endIndex = nrow(trj3d))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Traj3DDistance_+3A_trj3d">trj3d</code></td>
<td>
<p>3-dimensional trajectory whose distance is to be calculated.</p>
</td></tr>
<tr><td><code id="Traj3DDistance_+3A_startindex">startIndex</code></td>
<td>
<p>Index of the starting point.</p>
</td></tr>
<tr><td><code id="Traj3DDistance_+3A_endindex">endIndex</code></td>
<td>
<p>Index of the ending point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric distance from the start to the end of the trajectory.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Traj3DFromCoords">Traj3DFromCoords</a></code>
</p>

<hr>
<h2 id='Traj3DFromCoords'>Create a 3D Trajectory Object</h2><span id='topic+Traj3DFromCoords'></span>

<h3>Description</h3>

<p><code>Traj3DFromCoords</code> creates a new 3-dimensional trajectory object from a
set of 3-dimensional cartesian coordinates, times and some metadata. A 3D
trajectory is a 2D trajectory (see <code><a href="#topic+TrajFromCoords">TrajFromCoords</a></code>) with the
addition of a <code>z</code> coordinate. <code>trajr</code> functions that expect a 2D
trajectory will work on a 3D trajectory by simply ignoring the <code>z</code>
dimension, so should only be used with care. A small number of functions
operate on 3D trajectories, and are prefixed by <code>Traj3D</code>. Existing
<code>trajr</code> functions that that do not deal with spatial data (e.g.
<code><a href="#topic+TrajDuration">TrajDuration</a></code>, <code><a href="#topic+TrajGetNCoords">TrajGetNCoords</a></code> etc.) can safely be
used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Traj3DFromCoords(
  track,
  xCol = 1,
  yCol = 2,
  zCol = 3,
  timeCol = NULL,
  fps = 50,
  spatialUnits = "m",
  timeUnits = "s"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Traj3DFromCoords_+3A_track">track</code></td>
<td>
<p>data frame containing cartesian coordinates and optionally times
for the points in the trajectory.</p>
</td></tr>
<tr><td><code id="Traj3DFromCoords_+3A_xcol">xCol</code></td>
<td>
<p>Name or index of the <code>x</code> column in <code>track</code> (default 1).</p>
</td></tr>
<tr><td><code id="Traj3DFromCoords_+3A_ycol">yCol</code></td>
<td>
<p>Name or index of the <code>y</code> column in <code>track</code> (default 2).</p>
</td></tr>
<tr><td><code id="Traj3DFromCoords_+3A_zcol">zCol</code></td>
<td>
<p>Name or index of the <code>z</code> column in <code>track</code> (default 3).</p>
</td></tr>
<tr><td><code id="Traj3DFromCoords_+3A_timecol">timeCol</code></td>
<td>
<p>optional name or index of the column which contains coordinate
times.</p>
</td></tr>
<tr><td><code id="Traj3DFromCoords_+3A_fps">fps</code></td>
<td>
<p>Frames per second - used to calculate relative coordinate times if
<code>track</code> does not contain a <code>time</code> column. Time intervals between
coordinate are assumed to be constant throught the entire track.</p>
</td></tr>
<tr><td><code id="Traj3DFromCoords_+3A_spatialunits">spatialUnits</code></td>
<td>
<p>Abbreviation for the x, y and z units.</p>
</td></tr>
<tr><td><code id="Traj3DFromCoords_+3A_timeunits">timeUnits</code></td>
<td>
<p>Abbreviation for the units that time is recorded in.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coordinates are sometimes referred to as &quot;relocations&quot;. Rows containing
<code>NA</code> coordinate or time values at the start or end of the trajectory are
discarded. <code>NA</code> coordinates or times in the middle of the trajectory
generate an error.
</p>
<p>If <code>timeCol</code> is specified, <code>track[,timeCol]</code> is expected to contain
the time (in some numeric units) of each coordinate. Otherwise, times are
calculated for each point as <code>(coord - 1) / fps</code> where <code>coord</code> is
the index of the point; in other words, sampling at constant time intervals
is assumed. Time values require conversion if they are not numeric. It may be
possible to use 'strptime' for this purpose, or <code><a href="#topic+TrajConvertTime">TrajConvertTime</a></code>
can be used to convert multiple field time values.
</p>
<p><code>x</code> and <code>y</code> must be square units. Longitude and latitude are not
suitable for use as <code>x</code> and <code>y</code> values, since in general, <code>1°
lat != 1° lon</code>. To create a trajectory from positions in latitude and
longitude, it is first necessary to transform the positions to a suitable
spatial projection such as UTM (possibly by using <code>spTransform</code> from the
<code>rgdal</code> package).
</p>
<p>Leading and trailing rows with <code>NA</code> coordinate values are discarded.
<code>NA</code> coordinate values within a trajectory generate an error.
</p>


<h3>Value</h3>

<p>An object with class &quot;<code>Trajectory3D</code>&quot;, which is a data.frame
with the following components: </p>
<table>
<tr><td><code>x</code></td>
<td>
<p>X coordinates of trajectory
points.</p>
</td></tr> <tr><td><code>y</code></td>
<td>
<p>Y coordinates of trajectory points.</p>
</td></tr> <tr><td><code>time</code></td>
<td>
<p>Time (in
<code>timeUnits</code>) for each point. if <code>timeCol</code> is specified, values
are <code>track[,timeCol]</code>, otherwise values are calculated from
<code>fps</code>.</p>
</td></tr> <tr><td><code>displacementTime</code></td>
<td>
<p>Relative frame/observation times, with
frame/observation 1 at time <code>0</code>.</p>
</td></tr> <tr><td><code>polar</code></td>
<td>
<p>X and y coordinates
represented as complex numbers, to simplify working with 2D segment angles.
Note that the z dimension is not represented.</p>
</td></tr>
<tr><td><code>displacement</code></td>
<td>
<p>2-dimensional displacement vectors (represented as
complex numbers) between each pair of consecutive points. Note that the z
dimension is not represented.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Traj3DLength">Traj3DLength</a></code>, <code><a href="#topic+Traj3DStepLengths">Traj3DStepLengths</a></code>,
<code><a href="#topic+Traj3DDistance">Traj3DDistance</a></code>, <code><a href="#topic+Traj3DStraightness">Traj3DStraightness</a></code>,
<code><a href="#topic+Traj3DSmoothSG">Traj3DSmoothSG</a></code>, <code><a href="#topic+Traj3DResampleTime">Traj3DResampleTime</a></code>,
<code><a href="#topic+Traj3DRediscretize">Traj3DRediscretize</a></code>, <code><a href="#topic+TrajFromCoords">TrajFromCoords</a></code> for creating
2-dimensional trajectories
</p>

<hr>
<h2 id='Traj3DLength'>3D trajectory length</h2><span id='topic+Traj3DLength'></span>

<h3>Description</h3>

<p>Calculates the cumulative length of a 3-dimensional trajectory, or a portion
of a trajectory. The length is the total distance travelled along the trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Traj3DLength(trj3d, startIndex = 1, endIndex = nrow(trj3d))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Traj3DLength_+3A_trj3d">trj3d</code></td>
<td>
<p>3D trajectory whose length is to be calculated.</p>
</td></tr>
<tr><td><code id="Traj3DLength_+3A_startindex">startIndex</code></td>
<td>
<p>Index of the starting point.</p>
</td></tr>
<tr><td><code id="Traj3DLength_+3A_endindex">endIndex</code></td>
<td>
<p>Index of the ending point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric length of the trajectory.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Traj3DFromCoords">Traj3DFromCoords</a></code>, <code><a href="#topic+Traj3DStepLengths">Traj3DStepLengths</a></code>, <code><a href="#topic+TrajLength">TrajLength</a></code>
</p>

<hr>
<h2 id='Traj3DRediscretize'>Resample a 3D trajectory to a constant step length</h2><span id='topic+Traj3DRediscretize'></span>

<h3>Description</h3>

<p>Constructs a new 3-dimensional trajectory by resampling the input
3-dimensional trajectory to a fixed step (or segment) length. By
default, timing of frames is lost, so speed and acceleration cannot
be calculated on a rediscretized trajectory. However, a constant
speed may be applied to the rediscretized trajectory
(<code>simConstantSpeed = TRUE</code>), in which case the returned
trajectory will have (almost) constant speed, with average speed
approximately equal to the average speed of <code>trj3d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Traj3DRediscretize(trj3d, R, simConstantSpeed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Traj3DRediscretize_+3A_trj3d">trj3d</code></td>
<td>
<p>The 3-dimensional trajectory to be resampled.</p>
</td></tr>
<tr><td><code id="Traj3DRediscretize_+3A_r">R</code></td>
<td>
<p>rediscretization step length, in the spatial units of <code>trj</code>.</p>
</td></tr>
<tr><td><code id="Traj3DRediscretize_+3A_simconstantspeed">simConstantSpeed</code></td>
<td>
<p>If TRUE, speeds are interpolated along the new
trajectory so that average speed is approximately the same as that of
<code>trj3d</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unfortunately this operation is slow for large trajectories.
</p>
<p>Based on the appendix in Bovet and Benhamou, (1988), extended to 3
dimensions.
</p>


<h3>Value</h3>

<p>A new 3-dimensional trajectory with a constant segment length which
follows <code>trj3d</code>.
</p>


<h3>References</h3>

<p>Bovet, P., &amp; Benhamou, S. (1988). Spatial analysis of animals'
movements using a correlated random walk model. Journal of Theoretical
Biology, 131(4), 419-433. doi:10.1016/S0022-5193(88)80038-9
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Traj3DFromCoords">Traj3DFromCoords</a></code>, <code><a href="#topic+TrajRediscretize">TrajRediscretize</a></code>
</p>

<hr>
<h2 id='Traj3DResampleTime'>Resample a 3D trajectory to a constant time interval</h2><span id='topic+Traj3DResampleTime'></span>

<h3>Description</h3>

<p>Constructs a new 3-dimensional trajectory by resampling the input trajectory
to a fixed time interval. Points are linearly interpolated along the
trajectory. Spatial and time units are preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Traj3DResampleTime(trj3d, stepTime, newFps = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Traj3DResampleTime_+3A_trj3d">trj3d</code></td>
<td>
<p>The 3-dimensional trajectory to be resampled.</p>
</td></tr>
<tr><td><code id="Traj3DResampleTime_+3A_steptime">stepTime</code></td>
<td>
<p>The resampled trajectory step time. Each step in the new
trajectory will have this duration.</p>
</td></tr>
<tr><td><code id="Traj3DResampleTime_+3A_newfps">newFps</code></td>
<td>
<p>Value to be stored as the FPS value in the new trajectory (see
<code><a href="#topic+TrajGetFPS">TrajGetFPS</a></code>). It is not otherwise used by this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new 3-dimensional trajectory with a constant time interval for each
step. Points in the new trajectory are calculated by linearly interpolating
along <code>trj3d</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Traj3DFromCoords">Traj3DFromCoords</a></code>, <code><a href="#topic+TrajResampleTime">TrajResampleTime</a></code>
</p>

<hr>
<h2 id='Traj3DSmoothSG'>Smooth a 3D trajectory using a Savitzky-Golay filter</h2><span id='topic+Traj3DSmoothSG'></span>

<h3>Description</h3>

<p>Smooths a 3-dimensional trajectory using a Savitzky-Golay smoothing filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Traj3DSmoothSG(trj3d, p = 3, n = p + 3 - p%%2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Traj3DSmoothSG_+3A_trj3d">trj3d</code></td>
<td>
<p>The 3=dimensional trajectory to be smoothed.</p>
</td></tr>
<tr><td><code id="Traj3DSmoothSG_+3A_p">p</code></td>
<td>
<p>polynomial order (passed to <code><a href="signal.html#topic+sgolayfilt">sgolayfilt</a></code>).</p>
</td></tr>
<tr><td><code id="Traj3DSmoothSG_+3A_n">n</code></td>
<td>
<p>Filter length (or window size), must be an odd number.  Passed to
<code><a href="signal.html#topic+sgolayfilt">sgolayfilt</a></code>.</p>
</td></tr>
<tr><td><code id="Traj3DSmoothSG_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to
<code><a href="signal.html#topic+sgolayfilt">sgolayfilt</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider carefully the effects of smoothing a trajectory with temporal gaps
in the data. If the smoothed trajectory is used to derive speed and/or
acceleration, it may be advisable to fill in the gaps before smoothing,
possibly by calling <code>Traj3DResampleTime</code>.
</p>


<h3>Value</h3>

<p>A new trajectory which is a smoothed version of the input trajectory.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Traj3DFromCoords">Traj3DFromCoords</a></code>, <code><a href="signal.html#topic+sgolayfilt">sgolayfilt</a></code>, <code><a href="#topic+TrajSmoothSG">TrajSmoothSG</a></code>
</p>

<hr>
<h2 id='Traj3DStepLengths'>3D trajectory step lengths</h2><span id='topic+Traj3DStepLengths'></span>

<h3>Description</h3>

<p>Returns the lengths of each step in a 3-dimensional trajectory (or part of a trajectory).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Traj3DStepLengths(trj3d, startIndex = 1, endIndex = nrow(trj3d))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Traj3DStepLengths_+3A_trj3d">trj3d</code></td>
<td>
<p>Trajectory to query.</p>
</td></tr>
<tr><td><code id="Traj3DStepLengths_+3A_startindex">startIndex</code></td>
<td>
<p>Index of the starting point.</p>
</td></tr>
<tr><td><code id="Traj3DStepLengths_+3A_endindex">endIndex</code></td>
<td>
<p>Index of the ending point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of step lengths. The vector will have length <code>1 - TrajGetNCoords(trj3d)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Traj3DFromCoords">Traj3DFromCoords</a></code>, <code><a href="#topic+Traj3DLength">Traj3DLength</a></code>, <code><a href="#topic+TrajStepLengths">TrajStepLengths</a></code>
</p>

<hr>
<h2 id='Traj3DStraightness'>Straightness of a 3D Trajectory</h2><span id='topic+Traj3DStraightness'></span>

<h3>Description</h3>

<p>Calculates the straightness index of a 3-dimensional trajectory, <code class="reqn">D / L</code>,
where <code>D</code> is the beeline distance between the first and last points in
the trajectory,and <code>L</code> is the path length travelled (Batschelet, 1981).
Benhamou (2004) considers the straightness index to be a reliable measure of
the efficiency of a directed walk, but inapplicable to random trajectories.
The straightness index of a random walk tends towards zero as the number of
steps increases, hence should only be used to compare the tortuosity of
random walks consisting of a similar number of steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Traj3DStraightness(trj3d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Traj3DStraightness_+3A_trj3d">trj3d</code></td>
<td>
<p>3-dimensional trajectory to calculate straightness of.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The straightness index is also known as the net-to-gross displacement ratio.
According to Batschelet (1981), this value (termed <em>d</em>) is an
approximation of <em>r</em>, which is the length of the mean vector of turning
angles of a constant step-length trajectory (see
<code><a href="#topic+TrajMeanVectorOfTurningAngles">TrajMeanVectorOfTurningAngles</a></code> and
<code><a href="#topic+TrajRediscretize">TrajRediscretize</a></code> for creating a constant step-length
trajectory).
</p>


<h3>Value</h3>

<p>The straightness index of <code>trj</code>, which is a value between 0
(infinitely tortuous) to 1 (a straight line).
</p>


<h3>References</h3>

<p>Batschelet, E. (1981). Circular statistics in biology. ACADEMIC PRESS, 111
FIFTH AVE., NEW YORK, NY 10003, 1981, 388.
</p>
<p>Benhamou, S. (2004). How to reliably estimate the tortuosity of an animal's
path. Journal of Theoretical Biology, 229(2), 209-220.
doi:10.1016/j.jtbi.2004.03.016
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Traj3DFromCoords">Traj3DFromCoords</a></code>, <code><a href="#topic+Traj3DDistance">Traj3DDistance</a></code> for
trajectory distance (or displacement), and <code><a href="#topic+Traj3DLength">Traj3DLength</a></code> for
trajectory path length, <code><a href="#topic+Traj3DStraightness">Traj3DStraightness</a></code> for the
straightness of a 2D trajectory.
</p>

<hr>
<h2 id='TrajAcceleration'>Approximates the acceleration of a trajectory</h2><span id='topic+TrajAcceleration'></span>

<h3>Description</h3>

<p>Returns an approximation of the acceleration of a trajectory at each point
using the second-order central finite differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajAcceleration(trj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajAcceleration_+3A_trj">trj</code></td>
<td>
<p>Trajectory whose acceleration is to be calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'trajr' trajectories, which consist of straight line displacements between
sampled locations, do not contain enough information to correctly derive
velocity or acceleration. Since we have to assume a constant velocity at each
step, the first derivative is discontinuous. Acceleration, therefore, is zero
during each step and infinite at each change of velocity. The approximation
implemented by this function assumes that acceleration occurs over a period
of time: half the duration of the previous step plus half the duration of the
next step.
</p>


<h3>Value</h3>

<p>Vector of complex numbers. The modulus (<code>Mod(a)</code>) is the
magnitude of the acceleration at each point, and the argument
(<code>Arg(a)</code>) is the direction of the acceleration. The vector has an
attribute, <code>trj</code>, with the trajectory as its value. The first and last
values will always be <code>NA</code>, since acceleration cannot be estimated for
those points.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TrajVelocity">TrajVelocity</a></code> for calculating velocity,
<code><a href="#topic+TrajResampleTime">TrajResampleTime</a></code> and <code><a href="#topic+TrajRediscretize">TrajRediscretize</a></code> to
resample a trajectory to fixed time or length steps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A function to plot acceleration as arrows (scaled in length)
AccArrows &lt;- function(acc, scale = .001, trj = attr(acc, "trj"), ...) {
  graphics::arrows(trj$x, trj$y, trj$x + Re(acc) * scale, trj$y + Im(acc) * scale, ...)
}

# Generate and plot a random trajectory
set.seed(101)
trj &lt;- TrajGenerate(30)
plot(trj)

# Calculate acceleration
acc &lt;- TrajAcceleration(trj)
# Plot acceleration as red arrows at each point. They need to be scaled down to
# fit in the plot, and the arrowhead lengths need to be shortened to look good
AccArrows(acc, scale = .001, col = "red", length = .1)

</code></pre>

<hr>
<h2 id='TrajAngles'>Turning angles of a Trajectory</h2><span id='topic+TrajAngles'></span>

<h3>Description</h3>

<p>Calculates the step angles (in radians) of each segment, either relative to
the previous segment or relative to the specified compass direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajAngles(trj, lag = 1, compass.direction = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajAngles_+3A_trj">trj</code></td>
<td>
<p>the trajectory whose angles are to be calculated.</p>
</td></tr>
<tr><td><code id="TrajAngles_+3A_lag">lag</code></td>
<td>
<p>Angles between every lag'th segment are calculated. Only applies
to non-directed walks, i.e. <code>compass.direction</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="TrajAngles_+3A_compass.direction">compass.direction</code></td>
<td>
<p>If not <code>NULL</code>, step angles are calculated
relative to this angle (in radians), otherwise they are calculated relative
to the previous step angle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that since turning angles are circular quantities, i.e. 360° == 0°, it
is incorrect to treat them as linear quantities. In particular, do not
calculate arithmetic means or standard deviations of turning angles. See
Batschelet, (1981) for a detailed explanation and techniques for dealing with
circular quantities.
</p>
<p>The turning angle before and after every zero-length segment will be
<code>NA</code>, since the angle of a zero-length segment is undefined. This
behaviour began in <code>trajr</code> version 1.5.0 (or development version
1.4.0.9000). Prior to this fix, the angle of a zero-length segment was
assumed to be 0, which led to incorrect turning angles being returned. One
approach to dealing with zero-length segments is to simply remove them from
the trajectory. See <code><a href="#topic+TrajFromTrjPoints">TrajFromTrjPoints</a></code> for a means to achieve this.
</p>


<h3>Value</h3>

<p>Step angles in radians, normalised so that <code>-pi &lt; angle &lt;= pi</code>.
If <code>compass.direction</code> is <code>NULL</code> (the default), the returned
vector will have length <code>nrow(trj) - 2</code>, i.e. one angle for every pair
of adjacent segments. If <code>compass.direction</code> is not <code>NULL</code>, the
returned vector will have length <code>nrow(trj) - 1</code>, i.e. one angle for
every segment.
</p>


<h3>References</h3>

<p>Batschelet, E. (1981). Circular statistics in biology. ACADEMIC PRESS, 111
FIFTH AVE., NEW YORK, NY 10003, 1981, 388.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TrajStepLengths">TrajStepLengths</a></code>,
<code><a href="#topic+TrajMeanVectorOfTurningAngles">TrajMeanVectorOfTurningAngles</a></code>,
<code><a href="#topic+TrajFromTrjPoints">TrajFromTrjPoints</a></code>
</p>

<hr>
<h2 id='TrajConvertTime'>Converts a delimited time string to a numeric value</h2><span id='topic+TrajConvertTime'></span>

<h3>Description</h3>

<p>Time values may be imported in a format which is not immediately usable by
'trajr'. This function converts times that are specified as a number of
delimited fields to a single numeric value. The default parameter values
handle a value with 4 colon-separated values, which are hours, minutes,
seconds and milliseconds, eg: &quot;0:01:04:108&quot; represents 1 minute, 4 seconds
and 108 milliseconds, or 64.108 seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajConvertTime(time, sep = ":", factors = c(60 * 60, 60, 1, 0.001))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajConvertTime_+3A_time">time</code></td>
<td>
<p>A character string containing the time value to be converted.</p>
</td></tr>
<tr><td><code id="TrajConvertTime_+3A_sep">sep</code></td>
<td>
<p>Field separator.</p>
</td></tr>
<tr><td><code id="TrajConvertTime_+3A_factors">factors</code></td>
<td>
<p>Vector of numeric factors to be applied to each field, in the
order they occur within 'time'. The default assumes 4 fields containing
numeric hours, minutes, seconds and milliseconds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the base R strptime can be used to convert time values in more
complex date/time formats, but it does not handle millisecond fields.
</p>


<h3>Value</h3>

<p>'time' converted to a numeric value.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+strptime">strptime</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>time &lt;- c("0:00:00:029", "0:01:00:216", "0:02:01:062", "1:00:02:195", "1:06:03:949", "1:42:04:087")
seconds &lt;- TrajConvertTime(time)

</code></pre>

<hr>
<h2 id='TrajDAMinMax'>First direction autocorrelation minimum/maximum</h2><span id='topic+TrajDAMinMax'></span><span id='topic+TrajDAFindFirstMinimum'></span><span id='topic+TrajDAFindFirstMaximum'></span>

<h3>Description</h3>

<p>Determines the coordinates of the first local minimum/maximum of <code>C</code> in
the direction autocorrelation function of a trajectory as returned by
<code><a href="#topic+TrajDirectionAutocorrelations">TrajDirectionAutocorrelations</a></code>. The end point is excluded from
consideration as a minimum, similarly the start point will not be returned as
a maximum. If the trajectory does not oscillate in direction, there will not
be a local minimum/maximum, and <code>NULL</code> is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajDAFindFirstMinimum(corr, windowSize = 10)

TrajDAFindFirstMaximum(corr, windowSize = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajDAMinMax_+3A_corr">corr</code></td>
<td>
<p>A <code>TrajDirectionAutocorrelations</code> object, i.e. the direction
autocorrelation of a trajectory.</p>
</td></tr>
<tr><td><code id="TrajDAMinMax_+3A_windowsize">windowSize</code></td>
<td>
<p>Size of window used to define what constitutes a local
mimimum/maximum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with 2 values, <code>deltaS</code> and <code>C</code>, or NULL if
there is no local minimum/maximum.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TrajDirectionAutocorrelations">TrajDirectionAutocorrelations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
trj &lt;- TrajGenerate(600, angularErrorSd = 1)
smoothed &lt;- TrajSmoothSG(trj, 3, 11)

# Resample to fixed path length
resampled &lt;- TrajRediscretize(smoothed, 1)
# Calculate direction autocorrelation for resampled trajectory
corr &lt;- TrajDirectionAutocorrelations(resampled, 100)
# Extract first local minimum from autocorrelation
minPt &lt;- TrajDAFindFirstMinimum(corr, 20)

# Plot the autocorrelation function
plot(corr, type ='l')
# Plot a red dot with a black outline at the first minimum
points(minPt["deltaS"], minPt["C"], pch = 16, col = "red", lwd = 2)
points(minPt["deltaS"], minPt["C"], col = "black", lwd = 2)

</code></pre>

<hr>
<h2 id='TrajDerivatives'>Calculates trajectory speed and change of speed</h2><span id='topic+TrajDerivatives'></span>

<h3>Description</h3>

<p>Calculates speed and change of speed along a trajectory over time. These are
the first and second order derivatives of distance travelled over time. Noisy
trajectories should be smoothed before being passed to this function, as
noise is effectively amplified when taking derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajDerivatives(trj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajDerivatives_+3A_trj">trj</code></td>
<td>
<p>Trajectory whose speed and change in speed is to be calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value returned as <code>acceleration</code> is <em>not</em> technically
acceleration. In mechanics, acceleration is a vector. The returned value is a
scalar quantity: change of speed, which is sometimes known informally as
acceleration. This value corresponds to the acceleration in a 1-dimensional
trajectory, with the sign indicating the direction of acceleration relative
to the current direction of velocity. See <code><a href="#topic+TrajAcceleration">TrajAcceleration</a></code> for
an approximation of (vector) acceleration, and <code><a href="#topic+TrajVelocity">TrajVelocity</a></code> for
an approximation of velocity.
</p>


<h3>Value</h3>

<p>A list with components: </p>
<table>
<tr><td><code>speed</code></td>
<td>
<p>numeric vector, speed between
each pair of trajectory points, i.e. the speed of each step.</p>
</td></tr>
<tr><td><code>speedTimes</code></td>
<td>
<p>numeric vector, times corresponding to values in
<code>speed</code>, i.e. the time from the start of the trajectory to the end of
each step.</p>
</td></tr> <tr><td><code>acceleration</code></td>
<td>
<p>numeric vector, change in speed between
steps. Despite the name, this is not acceleration as defined by mechanics.</p>
</td></tr>
<tr><td><code>accelerationTimes</code></td>
<td>
<p>numeric vector, time from the start of the
trajectory to the end of the second step in each pair.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+TrajSpeedIntervals">TrajSpeedIntervals</a></code> for analysing intervals of low or
high speed within the trajectory. <code><a href="#topic+TrajSmoothSG">TrajSmoothSG</a></code> for smoothing
a trajectory. <code><a href="#topic+TrajAcceleration">TrajAcceleration</a></code> for calculating acceleration,
and <code><a href="#topic+TrajVelocity">TrajVelocity</a></code> for calculating velocity.
</p>

<hr>
<h2 id='TrajDirectionalChange'>Directional change (DC)</h2><span id='topic+TrajDirectionalChange'></span>

<h3>Description</h3>

<p>Calculates the time variation of directional change (DC) of a trajectory
<em>sensu</em> Kitamura &amp; Imafuku (2015). Directional change is defined as the
angular change (in degrees) between two steps in the trajectory, divided by
the time difference between the two steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajDirectionalChange(trj, nFrames = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajDirectionalChange_+3A_trj">trj</code></td>
<td>
<p>Track to calculate DC for.</p>
</td></tr>
<tr><td><code id="TrajDirectionalChange_+3A_nframes">nFrames</code></td>
<td>
<p>Frame delta to process: if 1, every frame is processed, if 2,
every 2nd frame is processed, and so on. Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the DC for each pair of consecutive steps. Kitamura &amp;
Imafuku (2015) used the mean and the standard deviation of DC for portions of
trajectories as index values of nonlinearity and irregularity respectively.
</p>


<h3>Value</h3>

<p>The directional change (DC) in degrees between every pair of
consecutive segments in the trajectory, i.e. if <code>nFrames</code> is 1, the
returned vector will have length <code>nrow(trj) - 2</code>.
</p>


<h3>References</h3>

<p>Kitamura, T., &amp; Imafuku, M. (2015). Behavioural mimicry in flight
path of Batesian intraspecific polymorphic butterfly Papilio polytes.
Proceedings of the Royal Society B: Biological Sciences, 282(1809).
doi:10.1098/rspb.2015.0483
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
trj &lt;- TrajGenerate()
SD = mean(TrajDirectionalChange(trj))
SDDC = sd(TrajDirectionalChange(trj))

</code></pre>

<hr>
<h2 id='TrajDirectionAutocorrelations'>Direction autocorrelation</h2><span id='topic+TrajDirectionAutocorrelations'></span>

<h3>Description</h3>

<p>Calculates the autocorrelation of the track for <code class="reqn">\Delta</code>s ranging from 1
to <code>deltaSMax</code>, based on Shamble et al. (2017). <code>trj</code> must have a
constant step length (see <code><a href="#topic+TrajRediscretize">TrajRediscretize</a></code>) i.e. all segments
in the trajectory must be the same length. deltaS is specified in number of
segments. Call <code><a href="#topic+TrajDAFindFirstMinimum">TrajDAFindFirstMinimum</a></code> to locate the first local
minimum which may be used to characterise directional periodicity in a
trajectory (note that the first local minimum may not exist).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajDirectionAutocorrelations(trj, deltaSMax = round(nrow(trj)/4))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajDirectionAutocorrelations_+3A_trj">trj</code></td>
<td>
<p>The trajectory to calculate the directional autocorrelations for.</p>
</td></tr>
<tr><td><code id="TrajDirectionAutocorrelations_+3A_deltasmax">deltaSMax</code></td>
<td>
<p>Maximum delta s to calculate, default is <code class="reqn">1/4</code> the
number of segments in the trajectory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with class <code>TrajDirectionAutocorrelations</code> and 2
columns, <code>deltaS</code> and <code>C</code>. Plotting this object displays a graph
of the direction autocorrelation function, optionally with the location of
the first local minimum marked
</p>


<h3>References</h3>

<p>Shamble, P. S., Hoy, R. R., Cohen, I., &amp; Beatus, T. (2017).
Walking like an ant: a quantitative and experimental approach to
understanding locomotor mimicry in the jumping spider Myrmarachne
formicaria. Proceedings of the Royal Society B: Biological Sciences,
284(1858). doi:10.1098/rspb.2017.0308
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TrajDAFindFirstMinimum">TrajDAFindFirstMinimum</a></code>,
<code><a href="#topic+plot.TrajDirectionAutocorrelations">plot.TrajDirectionAutocorrelations</a></code>
</p>

<hr>
<h2 id='TrajDistance'>Trajectory distance</h2><span id='topic+TrajDistance'></span>

<h3>Description</h3>

<p>Calculates the distance between the start and end of a trajectory (or a
portion of a trajectory). Also called the diffusion distance, net distance,
displacement, or bee-line from start to finish.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajDistance(trj, startIndex = 1, endIndex = nrow(trj))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajDistance_+3A_trj">trj</code></td>
<td>
<p>Trajectory whose distance is to be calculated.</p>
</td></tr>
<tr><td><code id="TrajDistance_+3A_startindex">startIndex</code></td>
<td>
<p>Index of the starting point.</p>
</td></tr>
<tr><td><code id="TrajDistance_+3A_endindex">endIndex</code></td>
<td>
<p>Index of the ending point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric distance from the start to the end of the trajectory.
</p>

<hr>
<h2 id='TrajDuration'>Trajectory duration</h2><span id='topic+TrajDuration'></span>

<h3>Description</h3>

<p>Calculates the temporal duration of a trajectory (or a portion of a
trajectory).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajDuration(trj, startIndex = 1, endIndex = nrow(trj))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajDuration_+3A_trj">trj</code></td>
<td>
<p>Trajectory whose duration is to be calculated.</p>
</td></tr>
<tr><td><code id="TrajDuration_+3A_startindex">startIndex</code></td>
<td>
<p>Index of the starting point.</p>
</td></tr>
<tr><td><code id="TrajDuration_+3A_endindex">endIndex</code></td>
<td>
<p>Index of the ending point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric duration of the trajectory, in time units.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TrajGetTimeUnits">TrajGetTimeUnits</a></code>
</p>

<hr>
<h2 id='TrajEmax'>Trajectory straightness index, E-max</h2><span id='topic+TrajEmax'></span>

<h3>Description</h3>

<p>Emax, the maximum expected displacement, is a single-valued measure of
straightness defined by (Cheung, Zhang, Stricker, &amp; Srinivasan, 2007). Emax-a
is a dimensionless, scale-independent measure of the maximum possible
expected displacement. Emax-b is <code>Emax-a * mean step length</code>, and gives
the maximum possible expected displacement in spatial units. Values closer to
0 are more sinuous, while larger values (approaching infinity) are
straighter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajEmax(trj, eMaxB = FALSE, compass.direction = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajEmax_+3A_trj">trj</code></td>
<td>
<p>Trajectory to be analysed.</p>
</td></tr>
<tr><td><code id="TrajEmax_+3A_emaxb">eMaxB</code></td>
<td>
<p>If TRUE, calculates and returns Emax-b, otherwise returns
Emax-a.</p>
</td></tr>
<tr><td><code id="TrajEmax_+3A_compass.direction">compass.direction</code></td>
<td>
<p>if not <code>NULL</code>, turning angles are calculated
for a directed walk, assuming the specified compass direction (in radians).
Otherwise, a random walk is assumed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Emax (-a or -b) for <code>trj</code>.
</p>


<h3>References</h3>

<p>Cheung, A., Zhang, S., Stricker, C., &amp; Srinivasan, M. V. (2007).
Animal navigation: the difficulty of moving in a straight line. Biological
Cybernetics, 97(1), 47-61. doi:10.1007/s00422-007-0158-0
</p>

<hr>
<h2 id='TrajExpectedSquareDisplacement'>Trajectory expected square displacement</h2><span id='topic+TrajExpectedSquareDisplacement'></span>

<h3>Description</h3>

<p>Calculates the expected square displacement for a trajectory assuming it is a
correlated random walk, using the formula in Kareiva &amp; Shigesada, (1983).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajExpectedSquareDisplacement(
  trj,
  n = nrow(trj),
  eqn1 = TRUE,
  compass.direction = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajExpectedSquareDisplacement_+3A_trj">trj</code></td>
<td>
<p>A Trajectory.</p>
</td></tr>
<tr><td><code id="TrajExpectedSquareDisplacement_+3A_n">n</code></td>
<td>
<p>Number of steps to calculate.</p>
</td></tr>
<tr><td><code id="TrajExpectedSquareDisplacement_+3A_eqn1">eqn1</code></td>
<td>
<p>If <code>TRUE</code>, calculate using equation 1, otherwise using
equation 2. Equation 2 applies when the mean of turning angles is 0,
i.e.turns are unbiased.</p>
</td></tr>
<tr><td><code id="TrajExpectedSquareDisplacement_+3A_compass.direction">compass.direction</code></td>
<td>
<p>If not <code>NULL</code>, step angles are calculated
relative to this angle (in radians), otherwise they are calculated relative
to the previous step angle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that Cheung, Zhang, Stricker, and Srinivasan (2007) define an
alternative formulation for expected maximum displacement, Emax (see
<code><a href="#topic+TrajEmax">TrajEmax</a></code>).
</p>


<h3>References</h3>

<p>Cheung, A., Zhang, S., Stricker, C., &amp; Srinivasan, M. V. (2007). Animal
navigation: the difficulty of moving in a straight line. Biological
Cybernetics, 97(1), 47-61. doi:10.1007/s00422-007-0158-0
</p>
<p>Kareiva, P. M., &amp; Shigesada, N. (1983). Analyzing insect movement as a
correlated random walk. Oecologia, 56(2), 234-238. doi:10.1007/bf00379695
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TrajEmax">TrajEmax</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
# A random walk
trj &lt;- TrajGenerate(200)
smoothed &lt;- TrajSmoothSG(trj)

# Calculate actual squared displacement at all points along the trajectory
sd2 &lt;- sapply(2:nrow(smoothed), function(n) TrajDistance(smoothed, 1, n) ^ 2)
# Calculate expected squared displacement
ed2_1 &lt;- sapply(2:nrow(smoothed), function(n) TrajExpectedSquareDisplacement(smoothed, n, TRUE))
ed2_2 &lt;- sapply(2:nrow(smoothed), function(n) TrajExpectedSquareDisplacement(smoothed, n, FALSE))

# Plot expected against actual. According to Kareiva &amp; Shigesada, (1983), if actual
# (approximately) matches expected, the trajectory is probably a correlated random walk
par(mar = c(5, 5, 0.1, 0.1) + .1)
plot(2:nrow(smoothed), sd2, type = 'l', pch = 16, cex = .2, lwd = 2,
     xlab = 'Number of consecutive moves',
     ylab = expression('Squared displacement, ' * R[n]^2))
lines(2:nrow(smoothed), ed2_1, col = "grey", lwd = 2)
lines(2:nrow(smoothed), ed2_2, col = "pink", lwd = 2)

legend("bottomright",
       c(expression("Actual displacement"^2),
         expression("Expected displacement"^2 * " (eqn 1)"),
         expression("Expected displacement"^2 * " (eqn 2)")),
       col = c('black', 'grey', 'pink'), lwd = 2,
       inset = c(0.01, 0.02))

</code></pre>

<hr>
<h2 id='TrajFractalDimension'>Fractal dimension of a trajectory</h2><span id='topic+TrajFractalDimension'></span>

<h3>Description</h3>

<p>Calculates the fractal dimension (<code>D</code>) of a trajectory using the
'dividers' method (Sugihara &amp; May, 1990). By default, overestimation of
<code>D</code> is compensated for as recommended by Nams (2006), by walking the
dividers backwards and forwards, and by estimating the remaining path length
at the end of the last step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajFractalDimension(trj, stepSizes, adjustD = TRUE, dMean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajFractalDimension_+3A_trj">trj</code></td>
<td>
<p>Trajectory to calculate fractal dimension for.</p>
</td></tr>
<tr><td><code id="TrajFractalDimension_+3A_stepsizes">stepSizes</code></td>
<td>
<p>Vector of step sizes (aka divider sizes) used to calculate
path lengths.</p>
</td></tr>
<tr><td><code id="TrajFractalDimension_+3A_adjustd">adjustD</code></td>
<td>
<p>If <code>TRUE</code>, path length is adjusted for truncation error
(Nams, 2006).</p>
</td></tr>
<tr><td><code id="TrajFractalDimension_+3A_dmean">dMean</code></td>
<td>
<p>If <code>TRUE</code>, the fractal dimension is calculated starting
from the beginning of the trajectory, then re-calculated starting from the
end and moving backwards. The value returned is the mean of the two fractal
dimensions (Nams, 2006).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fractal dimension may be meaningless for animal trajectories as they may not
be true fractal curves - see Benhamou (2004) and Turchin (1996), although it
may be useful for studies involving differences in behaviour at different
spatial scales (Nams, 2006).
</p>
<p>You can test whether a trajectory is a fractal curve for a range of step
sizes using the <code><a href="#topic+TrajFractalDimensionValues">TrajFractalDimensionValues</a></code> function. The
example code in its documentation demonstrates how to plot path length for a
range of step sizes. If the plotted points lie along straight line, then the
trajectory is a fractal curve for that range of step sizes. However, typical
trajectories result in a curve rather than a straight line.
</p>
<p>If you decide to use fractal dimension despite the warnings of Benhamou
(2004) and Turchin (1996), try to select a biologically meaningful range of
step sizes (and be prepared to justify your choice). If comparing fractal
dimensions across trajectories, be consistent in your choice of step sizes.
</p>


<h3>Value</h3>

<p>The fractal dimension of the trajectory for the given step sizes.
</p>


<h3>References</h3>

<p>Benhamou, S. (2004). How to reliably estimate the tortuosity of an animal's
path. Journal of Theoretical Biology, 229(2), 209-220.
doi:10.1016/j.jtbi.2004.03.016
</p>
<p>Nams, V. O. (2006). Improving Accuracy and Precision in Estimating Fractal
Dimension of Animal movement paths. Acta Biotheoretica, 54(1), 1-11.
doi:10.1007/s10441-006-5954-8
</p>
<p>Sugihara, G., &amp; M. May, R. (1990). Applications of fractals in ecology.
Trends in Ecology &amp; Evolution, 5(3), 79-86. doi:10.1016/0169-5347(90)90235-6
</p>
<p>Turchin, P. (1996). Fractal Analyses of Animal Movement: A Critique. Ecology,
77(7), 2086-2090. doi:10.2307/2265702
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TrajLogSequence">TrajLogSequence</a></code> to create a logarithmically spaced
sequence, <code><a href="#topic+TrajFractalDimensionValues">TrajFractalDimensionValues</a></code> for the function used
internally to calculate a range of path lengths for different step sizes,
<code><a href="#topic+TrajEmax">TrajEmax</a></code> and <code><a href="#topic+TrajSinuosity2">TrajSinuosity2</a></code> for some alternate
measures of trajectory tortuosity.
</p>

<hr>
<h2 id='TrajFractalDimensionValues'>Fractal dimension calculation</h2><span id='topic+TrajFractalDimensionValues'></span>

<h3>Description</h3>

<p>Calculates path length (<code class="reqn">L(\delta)</code>) for a range of step sizes
(<code class="reqn">\delta</code>). For a fractal (i.e. scale independent) curve,
<code class="reqn">log(L(\delta))</code> grows linearly as <code class="reqn">log(\delta)</code> grows smaller. In
other words, if the points returned by this function lie on a straight line
in a log-log plot, <code>trj</code> is a fractal curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajFractalDimensionValues(trj, stepSizes, adjustD = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajFractalDimensionValues_+3A_trj">trj</code></td>
<td>
<p>Trajectory to calculate fractal dimension for.</p>
</td></tr>
<tr><td><code id="TrajFractalDimensionValues_+3A_stepsizes">stepSizes</code></td>
<td>
<p>Vector of step sizes used to calculate path lengths.</p>
</td></tr>
<tr><td><code id="TrajFractalDimensionValues_+3A_adjustd">adjustD</code></td>
<td>
<p>If TRUE, path length is adjusted to reduce truncation error
(Nams, 2006).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with columns <code>stepsize</code> (<code class="reqn">\delta</code>) and
<code>pathlength</code> ((<code class="reqn">L(\delta)</code>).
</p>


<h3>References</h3>

<p>Nams, V. O. (2006). Improving Accuracy and Precision in Estimating Fractal
Dimension of Animal movement paths. Acta Biotheoretica, 54(1), 1-11.
doi:10.1007/s10441-006-5954-8
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TrajFractalDimension">TrajFractalDimension</a></code> for fractal dimension
calculation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
trj &lt;- TrajGenerate()
muL &lt;- mean(TrajStepLengths(trj))
# Use 20 step sizes from 1/2 mean step length to 5 * mean step length.
# For real use, biologically meaningful step sizes should be used.
stepSizes &lt;- TrajLogSequence(0.5 * muL, 5 * muL, 20)
plot(TrajFractalDimensionValues(trj, stepSizes), log = "xy", pch = 16, cex = .5)

</code></pre>

<hr>
<h2 id='TrajFromCoords'>Create a Trajectory Object</h2><span id='topic+TrajFromCoords'></span>

<h3>Description</h3>

<p><code>TrajFromCoords</code> creates a new trajectory object from a set of
2-dimensional cartesian coordinates, times and some metadata. The coordinates
are sometimes referred to as &quot;relocations&quot;. Rows containing <code>NA</code>
coordinate or time values at the start or end of the trajectory are
discarded. <code>NA</code> coordinates or times in the middle of the trajectory
generate an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajFromCoords(
  track,
  xCol = 1,
  yCol = 2,
  timeCol = NULL,
  fps = 50,
  spatialUnits = "m",
  timeUnits = "s"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajFromCoords_+3A_track">track</code></td>
<td>
<p>data frame containing cartesian coordinates and optionally times
for the points in the trajectory.</p>
</td></tr>
<tr><td><code id="TrajFromCoords_+3A_xcol">xCol</code></td>
<td>
<p>Name or index of the <code>x</code> column in <code>track</code> (default 1).</p>
</td></tr>
<tr><td><code id="TrajFromCoords_+3A_ycol">yCol</code></td>
<td>
<p>Name or index of the <code>y</code> column in <code>track</code> (default 2).</p>
</td></tr>
<tr><td><code id="TrajFromCoords_+3A_timecol">timeCol</code></td>
<td>
<p>optional name or index of the column which contains coordinate
times.</p>
</td></tr>
<tr><td><code id="TrajFromCoords_+3A_fps">fps</code></td>
<td>
<p>Frames per second - used to calculate relative coordinate times if
<code>track</code> does not contain a <code>time</code> column. Time intervals between
coordinate are assumed to be constant throught the entire track.</p>
</td></tr>
<tr><td><code id="TrajFromCoords_+3A_spatialunits">spatialUnits</code></td>
<td>
<p>Abbreviation for the x and y units.</p>
</td></tr>
<tr><td><code id="TrajFromCoords_+3A_timeunits">timeUnits</code></td>
<td>
<p>Abbreviation for the units that time is recorded in.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>timeCol</code> is specified, <code>track[,timeCol]</code> is expected to contain
the time (in some numeric units) of each coordinate. Otherwise, times are
calculated for each point as <code>(coord - 1) / fps</code> where <code>coord</code> is
the index of the point; in other words, sampling at constant time intervals
is assumed. Time values require conversion if they are not numeric. It may be
possible to use 'strptime' for this purpose, or <code><a href="#topic+TrajConvertTime">TrajConvertTime</a></code>
can be used to convert multiple field time values.
</p>
<p><code>x</code> and <code>y</code> must be square units. Longitude and latitude are not
suitable for use as <code>x</code> and <code>y</code> values, since in general, <code>1°
lat != 1° lon</code>. To create a trajectory from positions in latitude and
longitude, it is first necessary to transform the positions to a suitable
spatial projection such as UTM (possibly by using <code>spTransform</code> from the
<code>rgdal</code> package).
</p>
<p>Leading and trailing rows with <code>NA</code> coordinate values are discarded.
<code>NA</code> coordinate values within a trajectory generate an error.
</p>
<p>Since columns in <code>coords</code> are preserved in the returned trajectory, if
<code>coords</code> contains an <code>x</code> or <code>y</code> column which is not identified
by <code>xCol</code> or <code>yCal</code> respectively, an error will occur. This is to
prevent columns being inadvertently overwritten.
</p>


<h3>Value</h3>

<p>An object with class &quot;<code>Trajectory</code>&quot;, which is a data.frame with
the following components: </p>
<table>
<tr><td><code>x</code></td>
<td>
<p>X coordinates of trajectory points.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Y coordinates of trajectory points.</p>
</td></tr> <tr><td><code>time</code></td>
<td>
<p>Time (in
<code>timeUnits</code>) for each point. if <code>timeCol</code> is specified, values
are <code>track[,timeCol]</code>, otherwise values are calculated from
<code>fps</code>.</p>
</td></tr> <tr><td><code>displacementTime</code></td>
<td>
<p>Relative frame/observation times, with
frame/observation 1 at time <code>0</code>.</p>
</td></tr> <tr><td><code>polar</code></td>
<td>
<p>Coordinates represented
as complex numbers, to simplify working with segment angles. Beware when
using complex numbers in R; <code>Arg(0+0i)</code> should be undefined but
actually returns <code>0</code>.</p>
</td></tr>
<tr><td><code>displacement</code></td>
<td>
<p>Displacement vectors (represented as complex numbers)
between each pair of consecutive points.</p>
</td></tr>
</table>
<p>In addition, any other columns <code>coords</code> are include in the data frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TrajsBuild">TrajsBuild</a></code>, <code><a href="#topic+Traj3DFromCoords">Traj3DFromCoords</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
coords &lt;- data.frame(x = c(1, 1.5, 2, 2.5, 3, 4),
                     y = c(0, 0, 1, 1, 2, 1),
                     times = c(0, 1, 2, 3, 4, 5))
trj &lt;- TrajFromCoords(coords, timeCol = "times")

par(mar = c(4, 4, 0.5, 0.5) + 0.1)
plot(trj)

</code></pre>

<hr>
<h2 id='TrajFromTrjPoints'>Create a trajectory from a subset of another</h2><span id='topic+TrajFromTrjPoints'></span>

<h3>Description</h3>

<p>Creates a trajectory from a subset of the points in another trajectory,
preserving metadata and all columns in the original trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajFromTrjPoints(trj, idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajFromTrjPoints_+3A_trj">trj</code></td>
<td>
<p>Trajectory to extract points and metadata from.</p>
</td></tr>
<tr><td><code id="TrajFromTrjPoints_+3A_idx">idx</code></td>
<td>
<p>Indices of the points in <code>trj</code> to retain in the new
trajectory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that removing points from a trajectory that does not contain a time
column will change the timing of the points, and hence change velocity etc.
</p>


<h3>Value</h3>

<p>A new trajectory which is the same as <code>trj</code> except with a subset
of points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create a trajectory (trj2) by removing all zero-length
# segments from another trajectory (trj). Keep all points
# that are different from their preceding point, and also
# keep the start point
trj2 &lt;- TrajFromTrjPoints(trj, c(1, which(Mod(trj$displacement) != 0)))

## End(Not run)

</code></pre>

<hr>
<h2 id='TrajGenerate'>Generate a random trajectory</h2><span id='topic+TrajGenerate'></span>

<h3>Description</h3>

<p>Generates a trajectory. If <code>random</code> is <code>TRUE</code>, the trajectory will
be a correllated random walk/idiothetic directed walk (Kareiva &amp; Shigesada,
1983), corresponding to an animal navigating without a compass (Cheung,
Zhang, Stricker, &amp; Srinivasan, 2008). If <code>random</code> is <code>FALSE</code>, it
will be a directed walk/allothetic directed walk/oriented path, corresponding
to an animal navigating with a compass (Cheung, Zhang, Stricker, &amp;
Srinivasan, 2007, 2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajGenerate(
  n = 1000,
  random = TRUE,
  stepLength = 2,
  angularErrorSd = 0.5,
  angularErrorDist = function(n) stats::rnorm(n, sd = angularErrorSd),
  linearErrorSd = 0.2,
  linearErrorDist = function(n) stats::rnorm(n, sd = linearErrorSd),
  fps = 50,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajGenerate_+3A_n">n</code></td>
<td>
<p>Number of steps in the trajectory.</p>
</td></tr>
<tr><td><code id="TrajGenerate_+3A_random">random</code></td>
<td>
<p>If TRUE, a random search trajectory is returned, otherwise a
directed trajectory (with direction = 0 radians) is returned.</p>
</td></tr>
<tr><td><code id="TrajGenerate_+3A_steplength">stepLength</code></td>
<td>
<p>Mean length of each step in the trajectory, in arbitrary
length units.</p>
</td></tr>
<tr><td><code id="TrajGenerate_+3A_angularerrorsd">angularErrorSd</code></td>
<td>
<p>Standard deviation of angular errors in radians.</p>
</td></tr>
<tr><td><code id="TrajGenerate_+3A_angularerrordist">angularErrorDist</code></td>
<td>
<p>Function which accepts a single argument - the number
of values to return, and generates random deviates according to some
distribution. The returned values are added to the previous step angle
(when <code>random == TRUE</code>), or to <code>0</code> (is <code>random == FALSE</code>) to
generate the step angle for each step in the trajectory. If the mean of the
returned values is not zero, the walk will be biased.</p>
</td></tr>
<tr><td><code id="TrajGenerate_+3A_linearerrorsd">linearErrorSd</code></td>
<td>
<p>Standard deviation of linear step length errors.</p>
</td></tr>
<tr><td><code id="TrajGenerate_+3A_linearerrordist">linearErrorDist</code></td>
<td>
<p>Function which accepts a single argument - the number
of values to return, and generates random deviates according to some
distribution. The returned values are added to <code>stepLength</code> to
generate the lengths of each step.</p>
</td></tr>
<tr><td><code id="TrajGenerate_+3A_fps">fps</code></td>
<td>
<p>Simulated frames-per-second - used to generate times for each
point in the trajectory.</p>
</td></tr>
<tr><td><code id="TrajGenerate_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to <code><a href="#topic+TrajFromCoords">TrajFromCoords</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, for both random and directed walks, errors are normally
distributed, unbiased, and independent of each other, so are <em>simple
directed walks</em> in the terminology of Cheung, Zhang, Stricker, &amp; Srinivasan,
(2008). This behaviour may be modified by specifying alternative values for
the <code>angularErrorDist</code> and/or <code>linearErrorDist</code> parameters.
</p>
<p>The initial angle (for a random walk) or the intended direction (for a
directed walk) is <code>0</code> radians. To change the initial angle or intended
direction, call <code><a href="#topic+TrajRotate">TrajRotate</a></code> on the new trajectory. The starting
position is <code>(0, 0)</code>. To change the starting position, call
<code><a href="#topic+TrajTranslate">TrajTranslate</a></code> on the new trajectory.
</p>


<h3>Value</h3>

<p>A new Trajectory with <code>n</code> segments and <code>n + 1</code> coordinate
pairs.
</p>


<h3>References</h3>

<p>Kareiva, P. M., &amp; Shigesada, N. (1983). Analyzing insect movement as a
correlated random walk. Oecologia, 56(2), 234-238. doi:10.1007/bf00379695
</p>
<p>Cheung, A., Zhang, S., Stricker, C., &amp; Srinivasan, M. V. (2007). Animal
navigation: the difficulty of moving in a straight line. Biological
Cybernetics, 97(1), 47-61. doi:10.1007/s00422-007-0158-0
</p>
<p>Cheung, A., Zhang, S., Stricker, C., &amp; Srinivasan, M. V. (2008). Animal
navigation: general properties of directed walks. Biological Cybernetics,
99(3), 197-217. doi:10.1007/s00422-008-0251-z
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a 1000 step correlated random walk
trj &lt;- TrajGenerate()
plot(trj, main = "Correlated walk")

# Generate a 1000 step levy flight - paths lengths follow a cauchy distribution
trj &lt;- TrajGenerate(linearErrorDist = rcauchy)
plot(trj, main = "Levy flight")

# Generate a short directed trajectory
trj &lt;- TrajGenerate(n = 20, random = FALSE)
plot(trj, main = "Directed walk")

# Generate an uncorrelated random walk
trj &lt;- TrajGenerate(500, angularErrorDist = function(n) runif(n, -pi, pi))
plot(trj, main = "Uncorrelated walk")

# Generate a walk directed northwards, starting from (200, 300),
# with a mean step length of 200. The initially generated trajectory
# is directed to angle 0, with starting point (0, 0)
trj &lt;- TrajGenerate(n = 20, stepLength = 200, random = FALSE)
# Rotate 90 degrees about (0, 0) (i.e. from east to north)
trj &lt;- TrajRotate(trj, pi / 2, relative = FALSE)
# Translate to desired starting point
trj &lt;- TrajTranslate(trj, 200, 300)

</code></pre>

<hr>
<h2 id='TrajGetFPS'>Trajectory frames-per-second</h2><span id='topic+TrajGetFPS'></span>

<h3>Description</h3>

<p>Returns the frames-per-second recorded for this trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajGetFPS(trj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajGetFPS_+3A_trj">trj</code></td>
<td>
<p>Trajectory to query</p>
</td></tr>
</table>

<hr>
<h2 id='TrajGetNCoords'>Trajectory number of coordinates</h2><span id='topic+TrajGetNCoords'></span>

<h3>Description</h3>

<p>Returns the number of coordinates recorded for this trajectory, i.e. 1 more
than the number of steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajGetNCoords(trj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajGetNCoords_+3A_trj">trj</code></td>
<td>
<p>Trajectory to query</p>
</td></tr>
</table>

<hr>
<h2 id='TrajGetTimeUnits'>Trajectory temporal units</h2><span id='topic+TrajGetTimeUnits'></span>

<h3>Description</h3>

<p>Returns the temporal units specified for a scaled trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajGetTimeUnits(trj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajGetTimeUnits_+3A_trj">trj</code></td>
<td>
<p>Trajectory to query</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+TrajFromCoords">TrajFromCoords</a></code>, <code><a href="#topic+TrajGetUnits">TrajGetUnits</a></code>.
</p>

<hr>
<h2 id='TrajGetUnits'>Trajectory spatial units</h2><span id='topic+TrajGetUnits'></span>

<h3>Description</h3>

<p>Returns the spatial units specified for a scaled trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajGetUnits(trj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajGetUnits_+3A_trj">trj</code></td>
<td>
<p>Trajectory to query</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+TrajScale">TrajScale</a></code>, <code><a href="#topic+TrajGetTimeUnits">TrajGetTimeUnits</a></code>.
</p>

<hr>
<h2 id='TrajInPolygon'>Test whether each of the points in a trajectory lie inside a polygon</h2><span id='topic+TrajInPolygon'></span>

<h3>Description</h3>

<p>Simply a wrapper around <code><a href="sp.html#topic+point.in.polygon">point.in.polygon</a></code>. The <code>sp</code>
package must be installed for this function to be called. <code>sp</code> is not
automatically installed as a dependency of trajr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajInPolygon(trj, boundary)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajInPolygon_+3A_trj">trj</code></td>
<td>
<p>Trajectory to test</p>
</td></tr>
<tr><td><code id="TrajInPolygon_+3A_boundary">boundary</code></td>
<td>
<p>A polygon defining the region to be tested against. Can be
any structure that <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code> can handle, such as a data frame
with <code>x</code> and <code>y</code> columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer array with a value for each point in the trajectory. Values
are: 0: point is strictly exterior to boundary; 1: point is strictly
interior to boundary; 2: point lies on the relative interior of an edge of
boundary; 3: point is a vertex of boundary
</p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+point.in.polygon">point.in.polygon</a></code>, <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Square arena
boundary &lt;- data.frame(x = c(-10, 10, 10, -10), y = c(-10, -10, 10, 10))

# Generate a random trajectory
set.seed(1)
trj &lt;- TrajGenerate(n = 10, stepLength = 2, angularErrorSd = .15)

# Test which points lie inside the boundary
print(TrajInPolygon(trj, boundary))
## [1] 1 1 1 1 1 1 0 0 0 0 0

</code></pre>

<hr>
<h2 id='TrajLength'>Trajectory length</h2><span id='topic+TrajLength'></span>

<h3>Description</h3>

<p>Calculates the cumulative length of a trajectory (or a portion of a
trajectory), which is the total distance travelled along the trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajLength(trj, startIndex = 1, endIndex = nrow(trj))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajLength_+3A_trj">trj</code></td>
<td>
<p>Trajectory whose length is to be calculated.</p>
</td></tr>
<tr><td><code id="TrajLength_+3A_startindex">startIndex</code></td>
<td>
<p>Index of the starting point.</p>
</td></tr>
<tr><td><code id="TrajLength_+3A_endindex">endIndex</code></td>
<td>
<p>Index of the ending point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric length of the trajectory.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TrajStepLengths">TrajStepLengths</a></code>
</p>

<hr>
<h2 id='TrajLogSequence'>Logarithmically spaced sequence</h2><span id='topic+TrajLogSequence'></span>

<h3>Description</h3>

<p>Convenience function to return a sequence of points which are regularly
spaced when plotted on a logarithmic axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajLogSequence(from, to, length.out)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajLogSequence_+3A_from">from</code></td>
<td>
<p>Starting value of the sequence.</p>
</td></tr>
<tr><td><code id="TrajLogSequence_+3A_to">to</code></td>
<td>
<p>End (maximal) value of the sequence.</p>
</td></tr>
<tr><td><code id="TrajLogSequence_+3A_length.out">length.out</code></td>
<td>
<p>Desired length of the sequence (non-negative). Rounded up if fractional.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+seq">seq</a></code>
</p>

<hr>
<h2 id='TrajMeanVectorOfTurningAngles'>Mean vector of turning angles</h2><span id='topic+TrajMeanVectorOfTurningAngles'></span>

<h3>Description</h3>

<p>Returns the mean vector of the turning angles, as defined by Batschelet,
(1981). A unit vector is created for each turning angle in the trajectory,
and the centre-of-mass/mean vector is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajMeanVectorOfTurningAngles(trj, compass.direction = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajMeanVectorOfTurningAngles_+3A_trj">trj</code></td>
<td>
<p>Trajectory object.</p>
</td></tr>
<tr><td><code id="TrajMeanVectorOfTurningAngles_+3A_compass.direction">compass.direction</code></td>
<td>
<p>If not <code>NULL</code>, step angles are calculated
relative to this angle (in radians), otherwise they are calculated relative
to the previous step angle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to Batschelet (1981), <code>r</code> may serve as a straightness index
ranging from 0 to 1, where <code>r</code> is the length of the mean vector of
turning angles of a trajectory with constant step length. Values of <code>r</code>
near 1 indicating straighter paths. Hence, <code>r =
Mod(TrajMeanVectorOfTurningAngles(trj))</code>, assuming that <code>trj</code> has a
constant step length (e.g. has been rediscretized).
</p>


<h3>Value</h3>

<p>A complex number <code>r</code> which represents the mean vector,
<code>Mod(r)</code> is the length of the mean vector which varies between 0 and
1, <code>Arg(r)</code> is the angle.
</p>


<h3>References</h3>

<p>Batschelet, E. (1981). Circular statistics in biology. ACADEMIC PRESS, 111
FIFTH AVE., NEW YORK, NY 10003, 1981, 388.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TrajStraightness">TrajStraightness</a></code>, <code><a href="#topic+TrajAngles">TrajAngles</a></code>,
<code><a href="#topic+TrajRediscretize">TrajRediscretize</a></code> for resampling a trajectory to a constant
step length, <code><a href="#topic+TrajResampleTime">TrajResampleTime</a></code> for resampling a trajectory to
a constant step time.
</p>

<hr>
<h2 id='TrajMeanVelocity'>Trajectory mean velocity</h2><span id='topic+TrajMeanVelocity'></span>

<h3>Description</h3>

<p>Calculates the mean or net velocity of a trajectory (or a portion of a
trajectory). This is the velocity from the start point to the end point,
ignoring the path that was taken.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajMeanVelocity(trj, startIndex = 1, endIndex = nrow(trj))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajMeanVelocity_+3A_trj">trj</code></td>
<td>
<p>Trajectory whose duration is to be calculated.</p>
</td></tr>
<tr><td><code id="TrajMeanVelocity_+3A_startindex">startIndex</code></td>
<td>
<p>Index of the starting point.</p>
</td></tr>
<tr><td><code id="TrajMeanVelocity_+3A_endindex">endIndex</code></td>
<td>
<p>Index of the ending point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric duration of the trajectory, in time units.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TrajGetTimeUnits">TrajGetTimeUnits</a></code>
</p>

<hr>
<h2 id='TrajMerge'>Combine multiple trajectories into a single whole trajectory</h2><span id='topic+TrajMerge'></span>

<h3>Description</h3>

<p>This is the inverse of <code><a href="#topic+TrajSplit">TrajSplit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajMerge(parts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajMerge_+3A_parts">parts</code></td>
<td>
<p>A list containing one or more trajectories. The trajectories are
concatenated together in order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single trajectory.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TrajSplit">TrajSplit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trj &lt;- TrajGenerate(n = 20)
ntrj &lt;- TrajMerge(TrajSplit(trj, c(3, 9, 20)))
print(all(trj == ntrj))
## [1] TRUE

</code></pre>

<hr>
<h2 id='trajr-package'>trajr: Animal Trajectory Analysis</h2><span id='topic+trajr'></span><span id='topic+trajr-package'></span>

<h3>Description</h3>

<p>A toolbox to assist with statistical analysis of animal trajectories. It provides simple access to algorithms for calculating and assessing a variety of characteristics such as speed and acceleration, as well as multiple measures of straightness or tortuosity. Some support is provided for 3-dimensional trajectories. McLean &amp; Skowron Volponi (2018) <a href="https://doi.org/10.1111/eth.12739">doi:10.1111/eth.12739</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jim McLean <a href="mailto:jim_mclean@optusnet.com.au">jim_mclean@optusnet.com.au</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/JimMcL/trajr">https://github.com/JimMcL/trajr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/JimMcL/trajr/issues">https://github.com/JimMcL/trajr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='TrajRediscretize'>Resample a trajectory to a constant step length</h2><span id='topic+TrajRediscretize'></span>

<h3>Description</h3>

<p>Constructs a new trajectory by resampling the input trajectory to a
fixed step (or segment) length. By default, timing of frames is
lost, so speed and acceleration cannot be calculated on a
rediscretized trajectory. However, a constant speed may be applied
to the rediscretized trajectory (<code>simConstantSpeed = TRUE</code>),
in which case the returned trajectory will have (almost) constant
speed, with average speed approximately equal to the average speed
of <code>trj</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajRediscretize(trj, R, simConstantSpeed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajRediscretize_+3A_trj">trj</code></td>
<td>
<p>The trajectory to be resampled.</p>
</td></tr>
<tr><td><code id="TrajRediscretize_+3A_r">R</code></td>
<td>
<p>rediscretization step length, in the spatial units of <code>trj</code>.</p>
</td></tr>
<tr><td><code id="TrajRediscretize_+3A_simconstantspeed">simConstantSpeed</code></td>
<td>
<p>If TRUE, speeds are interpolated along the new
trajectory so that average speed is approximately the same as that of
<code>trj</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on the appendix in Bovet and Benhamou, (1988).
</p>


<h3>Value</h3>

<p>A new trajectory with a constant segment length which follows
<code>trj</code>.
</p>


<h3>References</h3>

<p>Bovet, P., &amp; Benhamou, S. (1988). Spatial analysis of animals'
movements using a correlated random walk model. Journal of Theoretical
Biology, 131(4), 419-433. doi:10.1016/S0022-5193(88)80038-9
</p>

<hr>
<h2 id='TrajResampleTime'>Resample a trajectory to a constant time interval.</h2><span id='topic+TrajResampleTime'></span>

<h3>Description</h3>

<p>Constructs a new trajectory by resampling the input trajectory to a fixed
time interval. Points are linearly interpolated along the trajectory. Spatial
and time units are preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajResampleTime(trj, stepTime, newFps = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajResampleTime_+3A_trj">trj</code></td>
<td>
<p>The trajectory to be resampled.</p>
</td></tr>
<tr><td><code id="TrajResampleTime_+3A_steptime">stepTime</code></td>
<td>
<p>The resampled trajectory step time. Each step in the new
trajectory will have this duration.</p>
</td></tr>
<tr><td><code id="TrajResampleTime_+3A_newfps">newFps</code></td>
<td>
<p>Value to be stored as the FPS value in the new trajectory (see
<code><a href="#topic+TrajGetFPS">TrajGetFPS</a></code>). It is not otherwise used by this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new trajectory with a constant time interval for each step. Points
in the new trajectory are calculated by linearly interpolating along
<code>trj</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a trajectory with steps every 5 hours
set.seed(46)
trj &lt;- TrajGenerate(10, stepLength = 5, fps = 1/5, timeUnits = "hours", linearErrorSd = .8)

# Resample to 1 hour steps
resampled &lt;- TrajResampleTime(trj, 1)

par(mar = c(5, 4, .5, .5))
plot(trj, lwd = 2)
points(trj, pch = 16)
points(resampled, col = "red", draw.start.pt = FALSE)

</code></pre>

<hr>
<h2 id='TrajReverse'>Reverse a trajectory</h2><span id='topic+TrajReverse'></span>

<h3>Description</h3>

<p>Reverses the direction of a trajectory, so that the starting point becomes
the last point and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajReverse(trj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajReverse_+3A_trj">trj</code></td>
<td>
<p>The Trajectory to be reversed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>trj</code> with direction reversed.
</p>

<hr>
<h2 id='TrajRotate'>Rotate a trajectory</h2><span id='topic+TrajRotate'></span>

<h3>Description</h3>

<p>Rotates a trajectory by <code>angle</code> (when <code>relative</code> is <code>FALSE</code>),
or so that <code>angle(finish - start) == angle</code> (when <code>relative</code> is
<code>TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajRotate(trj, angle = 0, origin = c(0, 0), relative = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajRotate_+3A_trj">trj</code></td>
<td>
<p>The trajectory to be rotated.</p>
</td></tr>
<tr><td><code id="TrajRotate_+3A_angle">angle</code></td>
<td>
<p>The angle of rotation in radians. Either the first and last
points in the rotated trajectory (when <code>relative = TRUE</code>), or else the
angle be rotated (when <code>relative = FALSE</code>).</p>
</td></tr>
<tr><td><code id="TrajRotate_+3A_origin">origin</code></td>
<td>
<p>Trajectory is rotated about this point.</p>
</td></tr>
<tr><td><code id="TrajRotate_+3A_relative">relative</code></td>
<td>
<p>If TRUE, <code>angle</code> is the angle (after rotation) from the
start to the end point of the trajectory. If FALSE, the trajectory is
rotated about its start point by <code>angle</code>. You probably want to use
<code>relative = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new trajectory which is a rotated version of the input trajectory.
</p>

<hr>
<h2 id='TrajsBuild'>Construct multiple trajectories</h2><span id='topic+TrajsBuild'></span>

<h3>Description</h3>

<p>Reads multiple trajectories from files, performs some basic sanity checks on
them, and optionally smooths and scales them. Attempts to collect and report
errors for multiple trajectories in a single call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajsBuild(
  fileNames,
  fps = NULL,
  scale = NULL,
  spatialUnits = NULL,
  timeUnits = NULL,
  csvStruct = list(x = 1, y = 2, time = NULL),
  smoothP = 3,
  smoothN = 41,
  translateToOrigin = FALSE,
  rootDir = NULL,
  csvReadFn = function(filename, ...) utils::read.csv(filename, stringsAsFactors = FALSE,
    ...),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajsBuild_+3A_filenames">fileNames</code></td>
<td>
<p>Vector of the names of CSV files containing trajectory
coordinates. All of the files must have the same columns. All file names
must be unique. If <code>rootDir</code> is not <code>NULL</code>, then the file names
are treated as regular expressions.</p>
</td></tr>
<tr><td><code id="TrajsBuild_+3A_fps">fps</code></td>
<td>
<p>Vector of frames-per-second values corresponding to the
trajectories in <code>fileNames</code>. If length is 1, it is repeated to
length(fileNames).</p>
</td></tr>
<tr><td><code id="TrajsBuild_+3A_scale">scale</code></td>
<td>
<p>Vector of scale values corresponding to the trajectories in
<code>fileNames</code>. May be specified as character expressions (e.g. &quot;1 /
1200&quot;) rather than numeric values. If NULL, the trajectories will not be
scaled. If length is 1, it is repeated to length(fileNames).</p>
</td></tr>
<tr><td><code id="TrajsBuild_+3A_spatialunits">spatialUnits</code></td>
<td>
<p>Abbreviated name of spatial coordinate units after
scaling, e.g. &quot;m&quot;.</p>
</td></tr>
<tr><td><code id="TrajsBuild_+3A_timeunits">timeUnits</code></td>
<td>
<p>Abbreviated name of temporal units, e.g. &quot;s&quot;.</p>
</td></tr>
<tr><td><code id="TrajsBuild_+3A_csvstruct">csvStruct</code></td>
<td>
<p>A list which identifies the columns in each CSV file which
contain x-, y-, and optionally time-values.</p>
</td></tr>
<tr><td><code id="TrajsBuild_+3A_smoothp">smoothP</code></td>
<td>
<p>Filter order to be used for Savitzky-Golay smoothing (see
<code><a href="#topic+TrajSmoothSG">TrajSmoothSG</a></code>). If <code>NA</code>, no smoothing is performed.</p>
</td></tr>
<tr><td><code id="TrajsBuild_+3A_smoothn">smoothN</code></td>
<td>
<p>Filter length to be used for Savitzky-Golay smoothing (must be
odd, see <code><a href="#topic+TrajSmoothSG">TrajSmoothSG</a></code>). If <code>NA</code>, no smoothing is
performed.</p>
</td></tr>
<tr><td><code id="TrajsBuild_+3A_translatetoorigin">translateToOrigin</code></td>
<td>
<p>If TRUE, each trajectory is translated so that its
starting point is at (0, 0).</p>
</td></tr>
<tr><td><code id="TrajsBuild_+3A_rootdir">rootDir</code></td>
<td>
<p>Optional name of a top level directory which contains the CSV
files. If <code>rootDir</code> is not NULL, the CSV files may be located anywhere
within <code>rootDir</code> or its sub-directories.</p>
</td></tr>
<tr><td><code id="TrajsBuild_+3A_csvreadfn">csvReadFn</code></td>
<td>
<p>Function used to read the CSV files. Required to accept
arguments <code>filename, ...</code>, and return a data frame of coordinates, or
a list of multiple data frames (see <code><a href="utils.html#topic+read.csv">read.csv</a></code>,
<code><a href="utils.html#topic+read.csv2">read.csv2</a></code>). The default function calls
<code><a href="utils.html#topic+read.csv">read.csv</a></code> with argument <code>stringsAsFactors =
FALSE</code>.</p>
</td></tr>
<tr><td><code id="TrajsBuild_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>csvReadFn</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>rootDir</code> is not null, it should be the name of a directory which is
searched for the files in <code>fileNames</code>. The found files are then used as
the list of files to be read in. This may be useful when the names of the
files are known, but their exact location within a directory structure is not
known.
</p>
<p>For each file name in <code>fileNames</code>, reads the file by calling
<code>csvReadFn</code> to obtain a set of coordinates and optionally times. A
Trajectory is then constructed by passing the coordinates to
<code><a href="#topic+TrajFromCoords">TrajFromCoords</a></code>, passing in the appropriate <code>fps</code> value,
and x, y and time column names/indices from <code>csvStruct</code>. If <code>scale</code>
is not <code>NULL</code>, the trajectory is scaled by calling
<code><a href="#topic+TrajScale">TrajScale</a></code>. If <code>smoothP</code> and <code>smoothN</code> are not
<code>NULL</code>, the trajectory is smoothed by calling
<code><a href="#topic+TrajSmoothSG">TrajSmoothSG</a></code>.
</p>


<h3>Value</h3>

<p>A list of trajectories.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.csv">read.csv</a></code>, <code><a href="#topic+TrajFromCoords">TrajFromCoords</a></code>,
<code><a href="#topic+TrajScale">TrajScale</a></code>, <code><a href="#topic+TrajSmoothSG">TrajSmoothSG</a></code>,
<code><a href="#topic+TrajTranslate">TrajTranslate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Names of CSV files containing trajectory coordinates
fileNames &lt;- c('xy001.csv', 'xy003.csv', 'xy004.csv')
# The files are all located somewhere under this directory
rootDir &lt;- '.'
# Scale for these files is 1 / pixels per metre
scale &lt;- c('1/1200', '1/1350', '1/1300')
# Files have columns y, x
csvStruct &lt;- list(x = 2, y = 1)
# Apply default smoothing, and the files are formatted as conventional CSV,
# so there's no need to specify csvReadFn
trjs &lt;- TrajsBuild(fileNames, fps = 50, scale = scale, units = "m",
                   csvStruct = csvStruct, rootDir = rootDir)

## End(Not run)

</code></pre>

<hr>
<h2 id='TrajScale'>Scale a trajectory</h2><span id='topic+TrajScale'></span>

<h3>Description</h3>

<p>Scales the cartesian coordinates in a trajectory, for example, to convert
units from pixels to metres.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajScale(trj, scale, units, yScale = scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajScale_+3A_trj">trj</code></td>
<td>
<p>The trajectory to be scaled.</p>
</td></tr>
<tr><td><code id="TrajScale_+3A_scale">scale</code></td>
<td>
<p>Scaling factor to be applied to the trajectory coordinates.</p>
</td></tr>
<tr><td><code id="TrajScale_+3A_units">units</code></td>
<td>
<p>Character specifying the spatial units after scaling, e.g. &quot;m&quot;
or &quot;metres&quot;</p>
</td></tr>
<tr><td><code id="TrajScale_+3A_yscale">yScale</code></td>
<td>
<p>Optional scaling factor to be applied to the y-axis, which may
be specified if the original coordinates are not square. Defaults to
<code>scale</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new scaled trajectory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
trj &lt;- TrajGenerate()
# original trajectory units are pixels, measured as having
# 47 pixels in 10 mm, so to convert to metres, scale the
# trajectory by the approriate factor, i.e. (size in metres) / (size in pixels).
scale &lt;- .01 / 47
scaled &lt;- TrajScale(trj, scale, "m")

</code></pre>

<hr>
<h2 id='TrajSinuosity'>Sinuosity of a trajectory</h2><span id='topic+TrajSinuosity'></span>

<h3>Description</h3>

<p>Calculates the sinuosity of a (constant step length) trajectory as defined by
Bovet &amp; Benhamou (1988), which is: <code class="reqn">S = 1.18\sigma / \sqrt q</code> where
<code class="reqn">\sigma</code> is the standard deviation of the step turning angles and <code class="reqn">q</code>
is the mean step length. A corrected sinuosity index is available as the
function <code><a href="#topic+TrajSinuosity2">TrajSinuosity2</a></code> which handles a wider range of
variations in step angles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajSinuosity(trj, compass.direction = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajSinuosity_+3A_trj">trj</code></td>
<td>
<p>Trajectory to calculate sinuosity of.</p>
</td></tr>
<tr><td><code id="TrajSinuosity_+3A_compass.direction">compass.direction</code></td>
<td>
<p>if not <code>NULL</code>, turning angles are calculated
for a directed walk, assuming the specified compass direction (in radians).
Otherwise, a random walk is assumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If your trajectory does not have a constant step length, it should be
_rediscretized_ by calling <code><a href="#topic+TrajRediscretize">TrajRediscretize</a></code> before calling this
function.
</p>


<h3>Value</h3>

<p>The sinuosity of <code>trj</code>.
</p>


<h3>References</h3>

<p>Bovet, P., &amp; Benhamou, S. (1988). Spatial analysis of animals' movements
using a correlated random walk model. Journal of Theoretical Biology, 131(4),
419-433. doi:10.1016/S0022-5193(88)80038-9
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TrajAngles">TrajAngles</a></code> for the turning angles in a trajectory,
<code><a href="#topic+TrajStepLengths">TrajStepLengths</a></code> for the step lengths,
<code><a href="#topic+TrajSinuosity2">TrajSinuosity2</a></code> for a corrected version of sinuosity, and
<code><a href="#topic+TrajRediscretize">TrajRediscretize</a></code> for resampling to a constant step length.
</p>

<hr>
<h2 id='TrajSinuosity2'>Sinuosity of a trajectory</h2><span id='topic+TrajSinuosity2'></span>

<h3>Description</h3>

<p>Calculates the sinuosity of a trajectory as defined by Benhamou (2004),
equation 8. This is a corrected version of the sinuosity index defined in
Bovet &amp; Benhamou (1988), which is suitable for a wider range of turning angle
distributions, and does not require a constant step length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajSinuosity2(trj, compass.direction = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajSinuosity2_+3A_trj">trj</code></td>
<td>
<p>A Trajectory object.</p>
</td></tr>
<tr><td><code id="TrajSinuosity2_+3A_compass.direction">compass.direction</code></td>
<td>
<p>if not <code>NULL</code>, turning angles are calculated
for a directed walk, assuming the specified compass direction (in radians).
Otherwise, a random walk is assumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the formula </p>
<p style="text-align: center;"><code class="reqn">S = 2[p(((1 + c)/(1 - c)) +
b^2)]^{-0.5}</code>
</p>
<p> where <code class="reqn">p</code> is the mean step length, <code class="reqn">c</code> is the mean
cosine of turning angles, and <code class="reqn">b</code> is the coefficient of variation of
the step length.
</p>


<h3>References</h3>

<p>Benhamou, S. (2004). How to reliably estimate the tortuosity of an animal's
path. Journal of Theoretical Biology, 229(2), 209-220.
doi:10.1016/j.jtbi.2004.03.016
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TrajSinuosity">TrajSinuosity</a></code> for the uncorrected sinuosity index.
</p>

<hr>
<h2 id='TrajsMergeStats'>Merge trajectory characteristics</h2><span id='topic+TrajsMergeStats'></span>

<h3>Description</h3>

<p>Builds a data frame by combining rows of statistical values for multiple
trajectories. The statistics for each trajectory are defined by the caller in
a user defined function - see the example for one way to achieve this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajsMergeStats(
  trjs,
  statsFn,
  progressBar = c("none", "text", "win", "tk"),
  check.names = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajsMergeStats_+3A_trjs">trjs</code></td>
<td>
<p>List of trajectories to be characterised.</p>
</td></tr>
<tr><td><code id="TrajsMergeStats_+3A_statsfn">statsFn</code></td>
<td>
<p>Function to calculate statistics of interest for a single
trajectory.</p>
</td></tr>
<tr><td><code id="TrajsMergeStats_+3A_progressbar">progressBar</code></td>
<td>
<p>Displays an optional progressbar, which may be helpful if
processing is very slow. The progressbar is displayed by printing to the
console, by using <code>winProgressBar</code> or
<code><a href="tcltk.html#topic+tkProgressBar">tkProgressBar</a></code>, if <code>progressBar</code> is <code>"text"</code>,
<code>"win"</code> or <code>"tk"</code> respectively. The default is no progressbar
(value <code>"none"</code>). The <code>"win"</code> progressbar is only available on
Windows.</p>
</td></tr>
<tr><td><code id="TrajsMergeStats_+3A_check.names">check.names</code></td>
<td>
<p>Passed to <code>as.data.frame</code>. Set to <code>FALSE</code> if
statistic names are not syntactically valid variable names.</p>
</td></tr>
<tr><td><code id="TrajsMergeStats_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>statsFn</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Any NULL valued statistics are converted to NAs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Define a function which calculates some statistics
# of interest for a single trajectory
characteriseTrajectory &lt;- function(trj) {
  # Measures of speed
  derivs &lt;- TrajDerivatives(trj)
  mean_speed &lt;- mean(derivs$speed)
  sd_speed &lt;- sd(derivs$speed)

  # Resample to constant step length.
  # Step length must be appropriate for the trajectory
  resampled &lt;- TrajRediscretize(trj, 2)

  # Measures of straightness
  sinuosity &lt;- TrajSinuosity2(resampled)
  Emax &lt;- TrajEmax(resampled)

  # Periodicity
  resampled &lt;- TrajRediscretize(trj, .001)
  corr &lt;- TrajDirectionAutocorrelations(resampled, round(nrow(resampled) / 4))
  first_min &lt;- TrajDAFindFirstMinimum(corr)

  # Return a list with all of the statistics for this trajectory
  list(mean_speed = mean_speed,
       sd_speed = sd_speed,
       sinuosity = sinuosity,
       Emax = Emax,
       first_min_deltaS = first_min[1],
       first_min_C = first_min[2])
}

trjs &lt;- TrajsBuild(filenames)
stats &lt;- TrajsMergeStats(trjs, characteriseTrajectory)

## End(Not run)

</code></pre>

<hr>
<h2 id='TrajSmoothSG'>Smooth a trajectory using a Savitzky-Golay filter</h2><span id='topic+TrajSmoothSG'></span>

<h3>Description</h3>

<p>Smooths a trajectory using a Savitzky-Golay smoothing filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajSmoothSG(trj, p = 3, n = p + 3 - p%%2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajSmoothSG_+3A_trj">trj</code></td>
<td>
<p>The trajectory to be smoothed.</p>
</td></tr>
<tr><td><code id="TrajSmoothSG_+3A_p">p</code></td>
<td>
<p>polynomial order (passed to <code><a href="signal.html#topic+sgolayfilt">sgolayfilt</a></code>).</p>
</td></tr>
<tr><td><code id="TrajSmoothSG_+3A_n">n</code></td>
<td>
<p>Filter length (or window size), must be an odd number.  Passed to
<code><a href="signal.html#topic+sgolayfilt">sgolayfilt</a></code>.</p>
</td></tr>
<tr><td><code id="TrajSmoothSG_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to
<code><a href="signal.html#topic+sgolayfilt">sgolayfilt</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider carefully the effects of smoothing a trajectory with temporal gaps
in the data. If the smoothed trajectory is used to derive speed and/or
acceleration, it may be advisable to fill in the gaps before smoothing,
possibly by calling <code>TrajResampleTime</code>.
</p>


<h3>Value</h3>

<p>A new trajectory which is a smoothed version of the input trajectory.
</p>


<h3>See Also</h3>

<p><code><a href="signal.html#topic+sgolayfilt">sgolayfilt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(3)
trj &lt;- TrajGenerate(500, random = TRUE, angularErrorSd = .25)
smoothed &lt;- TrajSmoothSG(trj, 3, 31)
plot(trj)
plot(smoothed, col = "red", add = TRUE)

</code></pre>

<hr>
<h2 id='TrajSpeedIntervals'>Calculate speed time intervals</h2><span id='topic+TrajSpeedIntervals'></span>

<h3>Description</h3>

<p>Calculates and returns a list of time intervals during which speed is slower
and/or faster than specified values. Speed is calculated by taking the
modulus of velocity (<code><a href="#topic+TrajVelocity">TrajVelocity</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajSpeedIntervals(
  trj,
  fasterThan = NULL,
  slowerThan = NULL,
  interpolateTimes = TRUE,
  diff = c("backward", "central", "forward")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajSpeedIntervals_+3A_trj">trj</code></td>
<td>
<p>Trajectory to be analysed.</p>
</td></tr>
<tr><td><code id="TrajSpeedIntervals_+3A_fasterthan">fasterThan</code>, <code id="TrajSpeedIntervals_+3A_slowerthan">slowerThan</code></td>
<td>
<p>If not <code>NULL</code>, intervals will cover time
periods where speed exceeds/is lower than this value. At least one of
<code>fasterThan</code>, or <code>slowerThan</code> must be specified.</p>
</td></tr>
<tr><td><code id="TrajSpeedIntervals_+3A_interpolatetimes">interpolateTimes</code></td>
<td>
<p>If <code>TRUE</code>, times will be linearly interpolated
between frames.</p>
</td></tr>
<tr><td><code id="TrajSpeedIntervals_+3A_diff">diff</code></td>
<td>
<p>Method used to calculate speed, see <code><a href="#topic+TrajVelocity">TrajVelocity</a></code>
for details. The default is <code>"backward"</code> to maintain backwards
compatibility; in general, <code>"central"</code> provides a more accurate
estimate of velocity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of class &quot;TrajSpeedIntervals&quot;, each row is an interval,
columns are: </p>
<table>
<tr><td><code>startFrame</code></td>
<td>
<p>Indices of frames at the start of each
interval.</p>
</td></tr> <tr><td><code>stopFrame</code></td>
<td>
<p>Indices of frames at the end of each interval.</p>
</td></tr>
<tr><td><code>startTime</code></td>
<td>
<p>Time since start of trajectory at the start of each
interval.</p>
</td></tr> <tr><td><code>stopTime</code></td>
<td>
<p>Time since start of trajectory at the end of
each interval</p>
</td></tr> <tr><td><code>duration</code></td>
<td>
<p>Duration of each interval.</p>
</td></tr>
</table>
<p>The data frame will also have non-standard attributes:
</p>
<table>
<tr><td><code>trajectory</code></td>
<td>
<p>Value of the <code>trj</code> argument.</p>
</td></tr>
<tr><td><code>slowerThan</code></td>
<td>
<p>Value of the <code>slowerThan</code> argument.</p>
</td></tr>
<tr><td><code>fasterThan</code></td>
<td>
<p>Value of the <code>fasterThan</code> argument.</p>
</td></tr>
<tr><td><code>speed</code></td>
<td>
<p>Data frame with columns <code>speed</code> and <code>time</code>.</p>
</td></tr>
<tr><td><code>derivs</code></td>
<td>
<p>Value returned by calling <code>TrajDerivatives(trj)</code>.
Provided for backwards-compatibility; use of the <code>speed</code> attribute
is now preferred to the <code>derivs</code> attribute.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+TrajVelocity">TrajVelocity</a></code> for calculating trajectory velocity,
<code><a href="#topic+plot.TrajSpeedIntervals">plot.TrajSpeedIntervals</a></code> for plotting speed over time with
intervals highlighted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot speed, highlighting intervals where speed drops below 50 units/sec
set.seed(4)
trj &lt;- TrajGenerate(200, random = TRUE)
smoothed &lt;- TrajSmoothSG(trj, 3, 101)
intervals &lt;- TrajSpeedIntervals(smoothed, diff = "central", slowerThan = 50, fasterThan = NULL)
plot(intervals)

# Report the duration of the longest period of low speed
cat(sprintf("Duration of the longest low-speed interval was %g secs\n", max(intervals$duration)))

</code></pre>

<hr>
<h2 id='TrajSplit'>Split a trajectory into multiple sections</h2><span id='topic+TrajSplit'></span>

<h3>Description</h3>

<p>Every point in <code>trj</code> will belong to exactly one of the returned
sections. Note that this function will happily create single point
trajectories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajSplit(trj, idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajSplit_+3A_trj">trj</code></td>
<td>
<p>The trajectory to be split</p>
</td></tr>
<tr><td><code id="TrajSplit_+3A_idx">idx</code></td>
<td>
<p>Indices of splits. Each new section starts at one of these
indices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing one or more trajectories. The first trajectory in
the list contains the first points from <code>trj</code>. Remaining trajectories
contain the points starting from each of the <code>idx</code> values, in
ascending order.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TrajMerge">TrajMerge</a></code>, <code><a href="#topic+TrajSplitAtFirstCrossing">TrajSplitAtFirstCrossing</a></code>
</p>

<hr>
<h2 id='TrajSplitAtFirstCrossing'>Split a trajectory into two parts, separated at the first boundary crossing</h2><span id='topic+TrajSplitAtFirstCrossing'></span>

<h3>Description</h3>

<p>This is basically a wrapper around <code><a href="#topic+TrajInPolygon">TrajInPolygon</a></code> and
<code><a href="#topic+TrajSplit">TrajSplit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajSplitAtFirstCrossing(trj, boundary)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajSplitAtFirstCrossing_+3A_trj">trj</code></td>
<td>
<p>The trajectory to split.</p>
</td></tr>
<tr><td><code id="TrajSplitAtFirstCrossing_+3A_boundary">boundary</code></td>
<td>
<p>A polygon defining the boundary.  Can be any structure that
<code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code> can handle, such as a data frame with <code>x</code> and
<code>y</code> columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 1 or 2 elements. If <code>trj</code> lies entirely inside or
outside <code>boundary</code>, then the list simply contains <code>trj</code>. If
<code>trj</code> crosses the boundary, then the list contains 2 trajectories. The
first is the longest part of <code>trj</code> that lies entirely inside or
outside <code>boundary</code>, and the second is the remainder of <code>trj</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TrajInPolygon">TrajInPolygon</a></code>, <code><a href="#topic+TrajSplit">TrajSplit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Square arena
boundary &lt;- data.frame(x = c(-10, 10, 10, -10), y = c(-10, -10, 10, 10))

# Generate a random trajectory
set.seed(1)
trj &lt;- TrajGenerate(n = 8, stepLength = 3, angularErrorSd = .4)
# Split the trajectory where it crosses the boundary
l &lt;- TrajSplitAtFirstCrossing(trj, boundary)

# Plot the boundary and the two trajectories
plot(NULL, xlim = range(c(boundary$x, trj$x)), ylim = range(c(boundary$y, trj$y)), asp = 1)
polygon(boundary, border = "brown", lwd = 2)
lines(l[[1]], col = "#2040ff80", lwd = 3)
lines(l[[2]], col = "#ff204080", lwd = 3)

</code></pre>

<hr>
<h2 id='TrajsStatsReplaceNAs'>Replace NAs in a data frame</h2><span id='topic+TrajsStatsReplaceNAs'></span>

<h3>Description</h3>

<p>Replaces NAs in a single column of a data frame with an imputed uninformative
numeric replacement value, so that a principal component analysis can be
applied without discarding data. Optionally adds a new &quot;flag&quot; column which
contains <code>1</code> for each row which originally contained NA, otherwise
<code>0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajsStatsReplaceNAs(
  df,
  column,
  replacementValue = mean(df[, column], na.rm = TRUE),
  flagColumn = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajsStatsReplaceNAs_+3A_df">df</code></td>
<td>
<p>Data frame to be adjusted.</p>
</td></tr>
<tr><td><code id="TrajsStatsReplaceNAs_+3A_column">column</code></td>
<td>
<p>Name or index of the column to be adjusted.</p>
</td></tr>
<tr><td><code id="TrajsStatsReplaceNAs_+3A_replacementvalue">replacementValue</code></td>
<td>
<p>Numeric value to use instead of NA.</p>
</td></tr>
<tr><td><code id="TrajsStatsReplaceNAs_+3A_flagcolumn">flagColumn</code></td>
<td>
<p>If not NULL, specifies the name of a new column to be added
to the data frame, with value 0 for non-NA rows, 1 for NA rows. The column
is added regardless of whether there are any NAs in the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>df</code> with NAs replaced in <code>column</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+prcomp">prcomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = c(1, 2, 3), y = c(NA, 5, 6), z = c(NA, NA, 9))
# Eliminate NAs in y, add a flag column, ignore other NAs
df &lt;- TrajsStatsReplaceNAs(df, "y", flagColumn = "y.was.NA")
print(df)

</code></pre>

<hr>
<h2 id='TrajsStepLengths'>Step lengths of multiple trajectories</h2><span id='topic+TrajsStepLengths'></span>

<h3>Description</h3>

<p>Returns the lengths of all of the steps in a list of trajectories
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajsStepLengths(trjs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajsStepLengths_+3A_trjs">trjs</code></td>
<td>
<p>A list of <code>Trajectory</code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the lengths of every step in every trajectory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
trjs &lt;- TrajsBuild(fileNames, scale = scale, units = "m")
# Print a summary about the step sizes across all trajectories
print(summary(TrajsStepLengths(trjs)))

## End(Not run)

</code></pre>

<hr>
<h2 id='TrajStepLengths'>Trajectory step lengths</h2><span id='topic+TrajStepLengths'></span>

<h3>Description</h3>

<p>Returns the lengths of each step in a trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajStepLengths(trj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajStepLengths_+3A_trj">trj</code></td>
<td>
<p>Trajectory to query.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+TrajLength">TrajLength</a></code>
</p>

<hr>
<h2 id='TrajStraightness'>Straightness of a Trajectory</h2><span id='topic+TrajStraightness'></span>

<h3>Description</h3>

<p>Calculates the straightness index of a trajectory, <code class="reqn">D / L</code>, where
<code>D</code> is the beeline distance between the first and last points in the
trajectory,and <code>L</code> is the path length travelled (Batschelet, 1981).
Benhamou (2004) considers the straightness index to be a reliable measure of
the efficiency of a directed walk, but inapplicable to random trajectories.
The straightness index of a random walk tends towards zero as the number of
steps increases, hence should only be used to compare the tortuosity of
random walks consisting of a similar number of steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajStraightness(trj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajStraightness_+3A_trj">trj</code></td>
<td>
<p>Trajectory to calculate straightness of.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The straightness index is also known as the net-to-gross displacement ratio.
According to Batschelet (1981), this value (termed <em>d</em>) is an
approximation of <em>r</em>, which is the length of the mean vector of turning
angles of a constant step-length trajectory (see
<code><a href="#topic+TrajMeanVectorOfTurningAngles">TrajMeanVectorOfTurningAngles</a></code> and
<code><a href="#topic+TrajRediscretize">TrajRediscretize</a></code> for creating a constant step-length
trajectory).
</p>


<h3>Value</h3>

<p>The straightness index of <code>trj</code>, which is a value between 0
(infinitely tortuous) to 1 (a straight line).
</p>


<h3>References</h3>

<p>Batschelet, E. (1981). Circular statistics in biology. ACADEMIC PRESS, 111
FIFTH AVE., NEW YORK, NY 10003, 1981, 388.
</p>
<p>Benhamou, S. (2004). How to reliably estimate the tortuosity of an animal's
path. Journal of Theoretical Biology, 229(2), 209-220.
doi:10.1016/j.jtbi.2004.03.016
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TrajDistance">TrajDistance</a></code> for trajectory distance (or
displacement), and <code><a href="#topic+TrajLength">TrajLength</a></code> for trajectory path length.
</p>

<hr>
<h2 id='TrajTranslate'>Translate a trajectory</h2><span id='topic+TrajTranslate'></span>

<h3>Description</h3>

<p>Shifts an entire trajectory by the specified delta x and y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajTranslate(trj, dx, dy, dt = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajTranslate_+3A_trj">trj</code></td>
<td>
<p>The Trajectory to be translated.</p>
</td></tr>
<tr><td><code id="TrajTranslate_+3A_dx">dx</code></td>
<td>
<p>Delta x.</p>
</td></tr>
<tr><td><code id="TrajTranslate_+3A_dy">dy</code></td>
<td>
<p>Delta y.</p>
</td></tr>
<tr><td><code id="TrajTranslate_+3A_dt">dt</code></td>
<td>
<p>Delta time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new trajectory which is a translated version of the input trajectory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Shift a trajectory so that its origin is (10, 15).
# Note that trajectories created by TrajGenerate always start at (0, 0)
set.seed(42)
trj &lt;- TrajGenerate()
trj &lt;- TrajTranslate(trj, 10, 15)

# Translate a trajectory so its origin (0, 0) and it starts at time 0
trj &lt;- TrajTranslate(trj, -trj$x[1], -trj$y[1], -trj$time[1])

</code></pre>

<hr>
<h2 id='TrajVelocity'>Velocity of a trajectory</h2><span id='topic+TrajVelocity'></span>

<h3>Description</h3>

<p>The velocity is approximated at each point of the trajectory using
first-order finite differences. Central, forward or backward differences can
be used. Central differences yield a more accurate approximation if the
velocity is smooth. As a practical guide, if velocity doesn't change much
between steps, use central differences. If it changes substantially (and not
just as an artifact of recording noise), then use either forward or backward
differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajVelocity(trj, diff = c("central", "forward", "backward"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrajVelocity_+3A_trj">trj</code></td>
<td>
<p>Trajectory whose velocity is to be calculated.</p>
</td></tr>
<tr><td><code id="TrajVelocity_+3A_diff">diff</code></td>
<td>
<p>Type of difference to be calculated, one of &quot;central&quot; (the
default), &quot;forward&quot; or &quot;backward&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intuitively, think of the central difference velocity at a point as the mean
of the velocities of the two adjacent steps. Forward difference velocity is
the velocity of the step starting at the point. Backward difference is the
velocity of the step ending at the point.
</p>


<h3>Value</h3>

<p>A vector of complex numbers representing the velocity at each point
along the trajectory. The modulus (<code>Mod(v)</code>) is the magnitude of the
velocity, i.e. the speed; the argument (<code>Arg(v)</code>) is the direction of
the velocity; the real part (<code>Re(v)</code>) is velocity in the X direction;
and the imaginary part (<code>Im(v)</code>) is velocity in the Y direction. The
vector has an attribute, <code>trj</code>, with the trajectory as its value. If
<code>diff</code> is <code>"central"</code>, the first and last velocity values are
<code>NA</code> since velocity cannot be calculated for them. If <code>diff</code> is
<code>"forward"</code>, the last value will be NA, and if <code>diff</code> is
<code>"backward"</code>, the first value will be NA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TrajAcceleration">TrajAcceleration</a></code> for calculating acceleration;
<code><a href="#topic+TrajResampleTime">TrajResampleTime</a></code> and <code><a href="#topic+TrajRediscretize">TrajRediscretize</a></code> to resample
a trajectory to fixed time or length steps; <code><a href="#topic+TrajSpeedIntervals">TrajSpeedIntervals</a></code>
for calculating when speed crosses some threshold; Finite differences on
<a href="https://en.wikipedia.org/wiki/Finite_difference">Wikipedia</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(11)
trj &lt;- TrajGenerate(100)
# calculate velocity
vel &lt;- TrajVelocity(trj)

# Obtain speed over time, with NAs removed
speed &lt;- na.omit(data.frame(speed = Mod(vel), time = trj$time))

plot(speed ~ time, speed, type = 'l')

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
