<!DOCTYPE html><html lang="en"><head><title>Help for package GenomeAdmixR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GenomeAdmixR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GenomeAdmixR-package'>
<p>Simulate Admixture of Genomes</p></a></li>
<li><a href='#ancestry_module'><p>Creates a module to start simulations tracking local ancestry</p></a></li>
<li><a href='#calculate_allele_frequencies'><p>Calculate allele frequencies</p></a></li>
<li><a href='#calculate_average_ld'><p>Calculates the  ld between two alleles</p></a></li>
<li><a href='#calculate_dist_junctions'><p>collect the full distribution of junctions in the population</p></a></li>
<li><a href='#calculate_fst'><p>Calculate FST</p></a></li>
<li><a href='#calculate_heterozygosity'><p>Calculate heterozygosity</p></a></li>
<li><a href='#calculate_ld'><p>Calculate linkage disequilibrium statistics</p>
This function calculates two matrices, once containing all pairwise
linkage disequilibrium (ld) values, and one matrix containing all pairwise r
statistics</a></li>
<li><a href='#calculate_marker_frequency'><p>Calculate allele frequencies at a specific marker location</p></a></li>
<li><a href='#combine_input_data'><p>combine sequence data that was previously read from file into a population</p></a></li>
<li><a href='#create_artificial_genomeadmixr_data'><p>function to generate artificial genomeadmixr_data</p></a></li>
<li><a href='#create_iso_female'><p>function to simulate creation of an isofemale line</p></a></li>
<li><a href='#dgrp2.3R.5k.data'><p>A subset of sequencing data from the Drosophila Genetics Reference Panel</p></a></li>
<li><a href='#iso_female_ancestry'><p>Create isofemale</p></a></li>
<li><a href='#iso_female_sequence'><p>Create isofemale</p></a></li>
<li><a href='#load_population'><p>Load a population from file</p></a></li>
<li><a href='#migration_settings'><p>Function to manage settings associated with migration</p></a></li>
<li><a href='#plink_to_genomeadmixr_data'><p>function to convert plink style (ped/map) data to genome_admixr_data</p></a></li>
<li><a href='#plot_chromosome'><p>plots a chromosome</p></a></li>
<li><a href='#plot_difference_frequencies'><p>Plot the change in frequency between the start and end of a simulation</p></a></li>
<li><a href='#plot_dist_junctions'><p>plot the distribution of junctions</p></a></li>
<li><a href='#plot_frequencies'><p>Plot the frequencies of all ancestors along the genome.</p></a></li>
<li><a href='#plot_joyplot_frequencies'><p>make a joy plot of the distribution of allele frequencies within a region</p></a></li>
<li><a href='#plot_over_time'><p>Plot the frequencies of all ancestors over time</p></a></li>
<li><a href='#plot_start_end'><p>Plot both the starting frequencies and the final frequencies in one plot</p></a></li>
<li><a href='#plot.individual'><p>plot the genome of an individual</p></a></li>
<li><a href='#print.genomeadmixr_data'><p>print an individual to the console</p></a></li>
<li><a href='#print.individual'><p>print an individual to the console</p></a></li>
<li><a href='#print.population'><p>print a population object</p></a></li>
<li><a href='#read_input_data'><p>read sequence data from file to be used in simulation</p></a></li>
<li><a href='#save_population'><p>Save a population to file</p></a></li>
<li><a href='#sequence_module'><p>create sequence module</p></a></li>
<li><a href='#simulate_admixture'><p>Individual based simulation of the breakdown of contiguous ancestry blocks.</p></a></li>
<li><a href='#simulate_ancestry'><p>Individual based simulation of the breakdown of contiguous ancestry blocks.</p></a></li>
<li><a href='#simulate_ancestry_migration'><p>Individual based simulation of the breakdown of contiguous ancestry blocks in</p>
two populations linked by migration</a></li>
<li><a href='#simulate_sequence'><p>Individual based simulation of the breakdown of contiguous ancestry blocks.</p></a></li>
<li><a href='#simulate_sequence_migration'><p>Individual based simulation of the breakdown of contiguous ancestry blocks in</p>
two populations linked by migration</a></li>
<li><a href='#simulation_data_to_genomeadmixr_data'><p>function to convert ped/map data to genome_admixr_data</p></a></li>
<li><a href='#vcfR_to_genomeadmixr_data'><p>function to convert a vcfR object to genome_admixr_data</p></a></li>
<li><a href='#write_as_plink'><p>function to write simulation output as PLINK style data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulate Admixture of Genomes</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.7</td>
</tr>
<tr>
<td>Description:</td>
<td>Individual-based simulations forward in time,
    simulating how patterns in ancestry along the genome change after
    admixture. Full description can be found in Janzen (2021)
    &lt;<a href="https://doi.org/10.1111%2F2041-210X.13612">doi:10.1111/2041-210X.13612</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/thijsjanzen/GenomeAdmixR">https://github.com/thijsjanzen/GenomeAdmixR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thijsjanzen/GenomeAdmixR/issues">https://github.com/thijsjanzen/GenomeAdmixR/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, ggridges, hierfstat, methods, Rcpp, RcppParallel,
rlang, stringr, tibble, vcfR</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, junctions, knitr, magrittr, rmarkdown, testit,
testthat, pbapply</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppParallel</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++14</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-28 09:19:46 UTC; thijsjanzen</td>
</tr>
<tr>
<td>Author:</td>
<td>Thijs Janzen [aut, cre],
  Fernando Diaz G. [ctb],
  Rich√®l J.C. Bilderbeek [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thijs Janzen &lt;thijsjanzen@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-01 21:10:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='GenomeAdmixR-package'>
Simulate Admixture of Genomes
</h2><span id='topic+GenomeAdmixR-package'></span><span id='topic+GenomeAdmixR'></span>

<h3>Description</h3>

<p>Individual-based simulations forward in time, simulating how
patterns in ancestry along the genome change after admixture. The simulation
assumes Wright-Fisher dynamics, e.g. random mating and non-overlapping generations. In the simulation, instead of specific alleles, local ancestry is tracked, thus assuming that local molecular data can always be uniquely traced back to one of the founding individuals (populations). The package provides functionality to perform such simulations, but also to perform post-hoc statistical analyses and to visualize the obtained results.
</p>
<p>Version 2.1.7  - Improve documentation <br />
Version 2.1.6  - check classes with inherits <br />
Version 2.1.5  - Removed debugging output <br />
Version 2.1.4  - Only output when verbose = TRUE <br />
Version 2.1.3  - Changed DOI link in description <br />
Version 2.1.2  - Improved testing <br />
Version 2.1.1  - Removed GNU make dependency <br />
Version 2.1    - Removed error in calculate_allele_frequency <br />
Version 2.0.1  - Moved migration outside the modules <br />
Version 2.0    - Added ancestry_module and sequence_module to distinguish between
implementations of the model <br />
Version 1.2    - Added example sequencing data <br />
Version 1.2    - Added the option to load sequence data for admixing <br />
Version 1.1    - Fixed a minor bug with plot_joyplot_frequencies <br />
Version 1.1    - Improved tests <br />
Version 1.1    - Improved recombination code (again) <br />
Version 1.0    - Release associated with bioRxiv submission, to be found here: https://doi.org/10.1101/2020.10.19.343491 <br />
Version 0.66   - Improved recombination code, about twice as fast <br />
Version 0.65   - Added testing and added logo <br />
Version 0.64   - Reduced cyclomatic complexity <br />
Version 0.63   - Updated random number generation <br />
Version 0.62   - Updated to Roxygen <br />
Version 0.61   - Added plot_over_time <br />
Version 0.60   - Added admixture with migration <br />
Version 0.59   - Updated frequency code under the hood <br />
Version 0.58   - Renamed to GenomeAdmixR <br />
Version 0.58   - Collapsed and improved many functions <br />
Version 0.57   - Added function to generate admixed individuals <br />
Version 0.56   - Added starting frequencies to 'simulate_admixture' <br />
Version 0.55   - Extended 'calculate_marker_frequency' to handle a vector of locations <br />
Version 0.55   - Increased accuracy of choosing a random position for recombination, this should prevent the rare bug fixed in version 0.54 <br />
Version 0.54   - Fixed a MAJOR bug regarding recombination: in rare cases, a crossover position could be picked on an existing junction, due to the limited number of digits in uniform() <br />
Version 0.54   - Improved plot_difference_frequencies to handle modified input <br />
Version 0.53   - Added multiplicative_selection <br />
Version 0.52   - Added plot_difference_frequencies <br />
Version 0.51   - Added tajima's d calculation <br />
Version 0.50   - Added simulated_admixture until <br />
Version 0.49   - Added 'simulate' to cpp <br />
Version 0.48   - Added a general 'simulate' function <br />
Version 0.47   - Changed the effect of migration <br />
Version 0.46   - Added joyplot &amp; increase_ancestor <br />
Version 0.45   - Removed create_two_populations <br />
Version 0.44   - Added tracking regions <br />
Version 0.43   - Fixed bugs in select_population <br />
Version 0.42   - Added initial and final frequency tables <br />
Version 0.41   - Added multiple marker support <br />
Version 0.40   - Collapsed selection functions <br />
Version 0.39   - Added support for non-additive selection <br />
Version 0.38   - Added track frequencies <br />
Version 0.37   - Removed selection on regions <br />
Version 0.36   - Added progress_bar option <br />
Version 0.35   - Added calculate_marker_frequency <br />
Version 0.34   - Added selection_markers <br />
Version 0.33   - Fixed bugs in selection <br />
Version 0.32   - Moved Fish.h code to Fish.cpp <br />
Version 0.31   - Changed random number generator to R based <br />
Version 0.30   - Added Recombination = 1 code <br />
Version 0.29   - Changed internal junction representation: removed .left <br />
Version 0.28   - Reverted to Agner Fog Random number generation <br />
Version 0.27   - Speed up return types <br />
Version 0.26   - Added class verification code <br />
Version 0.25   - Squashed plotting bug <br />
Version 0.24   - Removed Output.cpp <br />
Version 0.23   - Removed number_of_founders from calc_allele_spectrum <br />
Version 0.22   - Added save and load functions <br />
Version 0.21   - Changed random-seed management <br />
Version 0.20   - Removed superfluous code <br />
Version 0.19   - Removed number_of_founders from Fst and LD code <br />
Version 0.18   - Start of tracking changes <br />
</p>


<h3>Author(s)</h3>

<p>Thijs Janzen
Maintainer: (thijsjanzen@gmail.com)
</p>


<h3>References</h3>

<p>Janzen, T.,  Diaz, F. (2020) Individual-based simulations of genome evolution with ancestry: the GenomeAdmixR R package. bioRxiv 2020.10.19.343491; doi: https://doi.org/10.1101/2020.10.19.343491
</p>

<hr>
<h2 id='ancestry_module'>Creates a module to start simulations tracking local ancestry</h2><span id='topic+ancestry_module'></span>

<h3>Description</h3>

<p>Module to perform simulations based on local ancestry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ancestry_module(
  input_population = NA,
  number_of_founders = 2,
  initial_frequencies = NA,
  morgan = 1,
  markers = NA,
  track_junctions = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ancestry_module_+3A_input_population">input_population</code></td>
<td>
<p>Potential earlier simulated population used as
starting point for the simulation. If not provided by the user, the
simulation starts from scratch.</p>
</td></tr>
<tr><td><code id="ancestry_module_+3A_number_of_founders">number_of_founders</code></td>
<td>
<p>Number of unique ancestors / ancestries to be
tracked in the simulation</p>
</td></tr>
<tr><td><code id="ancestry_module_+3A_initial_frequencies">initial_frequencies</code></td>
<td>
<p>A vector describing the initial frequency of each
ancestor / ancestry. By default, equal frequencies are assumed. If a vector
not summing to 1 is provided, the vector is normalized.</p>
</td></tr>
<tr><td><code id="ancestry_module_+3A_morgan">morgan</code></td>
<td>
<p>Length of the genomic stretch simulated, expressed in Morgan
(e.g. the number of crossovers during meiosis)</p>
</td></tr>
<tr><td><code id="ancestry_module_+3A_markers">markers</code></td>
<td>
<p>A vector of locations of markers, with the location in Morgan.
Ancestry at these marker positions is tracked for every generation.</p>
</td></tr>
<tr><td><code id="ancestry_module_+3A_track_junctions">track_junctions</code></td>
<td>
<p>Tracks the average number of junctions over time if
TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with type = &quot;Ancestry&quot;. Can be used in simulate_admixture.
</p>

<hr>
<h2 id='calculate_allele_frequencies'>Calculate allele frequencies</h2><span id='topic+calculate_allele_frequencies'></span>

<h3>Description</h3>

<p>Calculate for a number of regularly spaced markers the relative
frequency of each ancestor in the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_allele_frequencies(
  source_pop,
  locations = seq(0, 1, length.out = 100),
  progress_bar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_allele_frequencies_+3A_source_pop">source_pop</code></td>
<td>
<p>Population for which to estimate allele frequencies</p>
</td></tr>
<tr><td><code id="calculate_allele_frequencies_+3A_locations">locations</code></td>
<td>
<p>A vector indicating the locations (in Morgan) where
to calculate the allele frequencies.</p>
</td></tr>
<tr><td><code id="calculate_allele_frequencies_+3A_progress_bar">progress_bar</code></td>
<td>
<p>Displays a progress_bar if TRUE. Default value is TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Markers are equidistantly spaced, with a distance of
<code>step_size</code> in between them.
</p>


<h3>Value</h3>

<p>A tibble containing the allele frequencies
</p>


<h3>Examples</h3>

<pre><code class='language-R'>number_founders = 20
wildpop =  simulate_admixture(
   module = ancestry_module(number_of_founders = 20, morgan = 1),
   pop_size = 1000,
   total_runtime = 10,
   num_threads = 1)

freq_output &lt;- calculate_allele_frequencies(wildpop,
                                            progress_bar = TRUE)

require(ggplot2)
ggplot(freq_output, aes(x=location, y = frequency,
                        col = as.factor(ancestor))) +
  geom_line()
</code></pre>

<hr>
<h2 id='calculate_average_ld'>Calculates the  ld between two alleles</h2><span id='topic+calculate_average_ld'></span>

<h3>Description</h3>

<p>calculate the average ld between two loci
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_average_ld(alleles_pos_1, alleles_pos_2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_average_ld_+3A_alleles_pos_1">alleles_pos_1</code></td>
<td>
<p>alleles at locus 1</p>
</td></tr>
<tr><td><code id="calculate_average_ld_+3A_alleles_pos_2">alleles_pos_2</code></td>
<td>
<p>alleles at locus 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two entries: LD and r_squared
</p>

<hr>
<h2 id='calculate_dist_junctions'>collect the full distribution of junctions in the population</h2><span id='topic+calculate_dist_junctions'></span>

<h3>Description</h3>

<p>calculates the distribution of junctions across the population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_dist_junctions(pop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_dist_junctions_+3A_pop">pop</code></td>
<td>
<p>object of the class 'population'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with two entries per individual, each indicating the number of
junctions in the respective chromosomes
</p>

<hr>
<h2 id='calculate_fst'>Calculate FST</h2><span id='topic+calculate_fst'></span>

<h3>Description</h3>

<p>The FST value between two populations is calculated, given a
number of markers. Markers are superimposed upon the (known) ancestry along
the chromosome for all sampled individuals. Markers can be chosen to be
regularly spaced, or randomly distributed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_fst(
  pop1,
  pop2,
  sampled_individuals = 10,
  number_of_markers = 100,
  random_markers = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_fst_+3A_pop1">pop1</code></td>
<td>
<p>Population object</p>
</td></tr>
<tr><td><code id="calculate_fst_+3A_pop2">pop2</code></td>
<td>
<p>Population object</p>
</td></tr>
<tr><td><code id="calculate_fst_+3A_sampled_individuals">sampled_individuals</code></td>
<td>
<p>Number of individuals to base the FST upon.
Individuals are randomly drawn from each population, a lower number speeds
up calculations.</p>
</td></tr>
<tr><td><code id="calculate_fst_+3A_number_of_markers">number_of_markers</code></td>
<td>
<p>Number of markers along the chromosome used to
calculate FST metrics.</p>
</td></tr>
<tr><td><code id="calculate_fst_+3A_random_markers">random_markers</code></td>
<td>
<p>If TRUE, markers are randomly spaced along the
chromosome, if FALSE, markers are equidistantly spaced along the chromosome.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the function <code>wc</code> from the package <code>hierfstat</code> to
calculate the FST. The function <code>wc</code> computes the Weir and Cockerham
F statistic.
</p>


<h3>Value</h3>

<p>FST value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>two_populations &lt;- simulate_admixture(
                        module = ancestry_module(),
                       migration = migration_settings(migration_rate = 0.01,
                                           population_size = c(100, 100)))

FST &lt;- calculate_fst(pop1 = two_populations$population_1,
                     pop2 = two_populations$population_2,
                     sampled_individuals = 10,
                     number_of_markers = 100,
                     random_markers = TRUE)
</code></pre>

<hr>
<h2 id='calculate_heterozygosity'>Calculate heterozygosity</h2><span id='topic+calculate_heterozygosity'></span>

<h3>Description</h3>

<p>Calculate the average population level heterozygosity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_heterozygosity(source_pop, locations, progress_bar = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_heterozygosity_+3A_source_pop">source_pop</code></td>
<td>
<p>Population for which to estimate allele frequencies, or a
list of individuals for which to calculate average heterozygosity</p>
</td></tr>
<tr><td><code id="calculate_heterozygosity_+3A_locations">locations</code></td>
<td>
<p>A vector indicating the locations (in Morgan) of markers for
which to calculate the heterozygosity</p>
</td></tr>
<tr><td><code id="calculate_heterozygosity_+3A_progress_bar">progress_bar</code></td>
<td>
<p>Displays a progress_bar if TRUE. Default value is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing the heterozygosities
</p>

<hr>
<h2 id='calculate_ld'>Calculate linkage disequilibrium statistics
This function calculates two matrices, once containing all pairwise
linkage disequilibrium (ld) values, and one matrix containing all pairwise r
statistics</h2><span id='topic+calculate_ld'></span>

<h3>Description</h3>

<p>Calculate linkage disequilibrium statistics
This function calculates two matrices, once containing all pairwise
linkage disequilibrium (ld) values, and one matrix containing all pairwise r
statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_ld(pop, sampled_individuals = 10, markers = NA, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_ld_+3A_pop">pop</code></td>
<td>
<p>focal population</p>
</td></tr>
<tr><td><code id="calculate_ld_+3A_sampled_individuals">sampled_individuals</code></td>
<td>
<p>Number of individuals randomly sampled to
calculate the LD matrices</p>
</td></tr>
<tr><td><code id="calculate_ld_+3A_markers">markers</code></td>
<td>
<p>vector of markers. If a single number is used, that number of
markers is randomly placed along the genome.</p>
</td></tr>
<tr><td><code id="calculate_ld_+3A_verbose">verbose</code></td>
<td>
<p>display verbose output, default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object containing two items:
</p>
<table role = "presentation">
<tr><td><code>ld_matrix</code></td>
<td>

<p>Pairwise ld statistics for all markers
</p>
</td></tr>
<tr><td><code>rsq_matrix</code></td>
<td>

<p>Pairwise rsq statistics for all markers
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>wildpop =  simulate_admixture(
   module = ancestry_module(number_of_founders = 10, morgan = 1),
   pop_size = 1000,
   total_runtime = 10)

ld_results &lt;- calculate_ld(pop = wildpop,
                           markers = 10)

plot(ld_results$ld_matrix~ld_results$dist_matrix,
     pch = 16,
     xlab="Distance between markers",
     ylab = "Linkage Disequilibrium")
</code></pre>

<hr>
<h2 id='calculate_marker_frequency'>Calculate allele frequencies at a specific marker location</h2><span id='topic+calculate_marker_frequency'></span>

<h3>Description</h3>

<p>Calculate the relative frequency of each ancestor in the
population at a specific marker location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_marker_frequency(pop, location)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_marker_frequency_+3A_pop">pop</code></td>
<td>
<p>Population for which to estimate allele frequencies at the
given marker</p>
</td></tr>
<tr><td><code id="calculate_marker_frequency_+3A_location">location</code></td>
<td>
<p>A vector or scalar of location(s) along the chromosome for
which allele frequencies are to be calculated. Locations are in Morgan.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing the frequency of each present ancestor at the
provided location. Ancestors with frequency = 0 are dropped out of the table.
The tibble contains three columns: location, ancestor and frequency.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wildpop =  simulate_admixture(
   module = ancestry_module(number_of_founders = 20, morgan = 1),
   pop_size = 1000,
   total_runtime = 10)

avg_frequencies &lt;- calculate_marker_frequency(pop = wildpop,
                                              location = 0.5)

frequencies &lt;-
   calculate_marker_frequency(pop = wildpop,
                              location = seq(0.4, 0.5, by = 0.01))
require(ggplot2)
ggplot(frequencies, aes(x = location, y = frequency, col = ancestor)) +
  geom_step()
</code></pre>

<hr>
<h2 id='combine_input_data'>combine sequence data that was previously read from file into a population</h2><span id='topic+combine_input_data'></span>

<h3>Description</h3>

<p>Create data in a format that can be used by GenomeAdmixR,
entries are sampled randomly from each input data set, with replacement.
Probability of sampling from each input data set is driven by the input
frequencies, and total number of individuals sampled is driven by pop_size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_input_data(input_data_list, frequencies = NA, pop_size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_input_data_+3A_input_data_list">input_data_list</code></td>
<td>
<p>list where each entry is the result of
<code>create_input_data</code></p>
</td></tr>
<tr><td><code id="combine_input_data_+3A_frequencies">frequencies</code></td>
<td>
<p>frequency of each entry in the list in the starting
population</p>
</td></tr>
<tr><td><code id="combine_input_data_+3A_pop_size">pop_size</code></td>
<td>
<p>intended population size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input data entries are combined to one single population that can
be used to seed <code>simulate_admixture_data</code>. Output is identical to
<code>create_input_data</code>
</p>

<hr>
<h2 id='create_artificial_genomeadmixr_data'>function to generate artificial genomeadmixr_data</h2><span id='topic+create_artificial_genomeadmixr_data'></span>

<h3>Description</h3>

<p>function to generate artificial genomeadmixr_data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_artificial_genomeadmixr_data(
  number_of_individuals,
  marker_locations,
  used_nucleotides = 1:4,
  nucleotide_frequencies = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_artificial_genomeadmixr_data_+3A_number_of_individuals">number_of_individuals</code></td>
<td>
<p>number of individuals</p>
</td></tr>
<tr><td><code id="create_artificial_genomeadmixr_data_+3A_marker_locations">marker_locations</code></td>
<td>
<p>location of markers, either in bp or Morgan</p>
</td></tr>
<tr><td><code id="create_artificial_genomeadmixr_data_+3A_used_nucleotides">used_nucleotides</code></td>
<td>
<p>subset or full set of [1/2/3/4] (reflecting a/c/t/g)</p>
</td></tr>
<tr><td><code id="create_artificial_genomeadmixr_data_+3A_nucleotide_frequencies">nucleotide_frequencies</code></td>
<td>
<p>frequencies of the used nucleotides, if not
provided, equal frequencies are assumed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>genomeadmixr_data object ready for simulate_admixture_data
</p>

<hr>
<h2 id='create_iso_female'>function to simulate creation of an isofemale line</h2><span id='topic+create_iso_female'></span>

<h3>Description</h3>

<p>create_isofemale simulates the creation of an isofemale line
through extreme inbreeding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_iso_female(
  module = ancestry_module(),
  n = 1,
  inbreeding_pop_size = 100,
  run_time = 2000,
  num_threads = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_iso_female_+3A_module">module</code></td>
<td>
<p>Source population from which isofemales are generated</p>
</td></tr>
<tr><td><code id="create_iso_female_+3A_n">n</code></td>
<td>
<p>Number of isofemales to be generated</p>
</td></tr>
<tr><td><code id="create_iso_female_+3A_inbreeding_pop_size">inbreeding_pop_size</code></td>
<td>
<p>Population size of the population used to generate
homozygous individuals</p>
</td></tr>
<tr><td><code id="create_iso_female_+3A_run_time">run_time</code></td>
<td>
<p>Maximum runtime used for inbreeding</p>
</td></tr>
<tr><td><code id="create_iso_female_+3A_num_threads">num_threads</code></td>
<td>
<p>number of threads. Default is 1. Set to -1 to use all
available threads</p>
</td></tr>
<tr><td><code id="create_iso_female_+3A_verbose">verbose</code></td>
<td>
<p>Displays verbose output if TRUE. Default value is FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To create an isofemale, two individuals are randomly picked from
the source population. Using these two individuals, a new population is
seeded, of size <code>inbreeding_pop_size</code>. Then, this population is allowed
to inbreed until either <code>run_time</code> is reached, or until all individuals
are homozygous and genetically identical, whatever happens first.
</p>


<h3>Value</h3>

<p>A list of length <code>n</code>, where each entry is a fully homozygous
isofemale.
</p>

<hr>
<h2 id='dgrp2.3R.5k.data'>A subset of sequencing data from the Drosophila Genetics Reference Panel</h2><span id='topic+dgrp2.3R.5k.data'></span>

<h3>Description</h3>

<p>This data set contains sequences from the 3R chromosome.
Included are 4603 SNPs with at least 0.05 minor allele frequency,  sequenced
across 410 isofemale lines. Sequences were downloaded from
&lt;http://dgrp2.gnets.ncsu.edu/data.html&gt;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dgrp2.3R.5k.data")
</code></pre>


<h3>Format</h3>

<p>genomeadmixr_data object
</p>


<h3>References</h3>

<p>Mackay, T., Richards, S., Stone, E. et al. The Drosophila
melanogaster Genetic Reference Panel. Nature 482, 173‚Äì178 (2012).
&lt;https://doi.org/10.1038/nature10811&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dgrp2.3R.5k.data")
simulate_admixture(
       module = sequence_module(molecular_data = dgrp2.3R.5k.data),
       pop_size = 100,
       total_runtime = 10)
</code></pre>

<hr>
<h2 id='iso_female_ancestry'>Create isofemale</h2><span id='topic+iso_female_ancestry'></span>

<h3>Description</h3>

<p>Creates isofemale individuals, given a population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iso_female_ancestry(
  source_pop = NA,
  n = 1,
  inbreeding_pop_size = 100,
  run_time = 2000,
  morgan = 1,
  num_threads = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iso_female_ancestry_+3A_source_pop">source_pop</code></td>
<td>
<p>Source population from which isofemales are generated</p>
</td></tr>
<tr><td><code id="iso_female_ancestry_+3A_n">n</code></td>
<td>
<p>Number of isofemales to be generated</p>
</td></tr>
<tr><td><code id="iso_female_ancestry_+3A_inbreeding_pop_size">inbreeding_pop_size</code></td>
<td>
<p>Population size of the population used to generate
homozygous individuals</p>
</td></tr>
<tr><td><code id="iso_female_ancestry_+3A_run_time">run_time</code></td>
<td>
<p>Maximum runtime used for inbreeding</p>
</td></tr>
<tr><td><code id="iso_female_ancestry_+3A_morgan">morgan</code></td>
<td>
<p>Size of the chromosome in Morgan (e.g. the number of crossovers
during meiosis)</p>
</td></tr>
<tr><td><code id="iso_female_ancestry_+3A_num_threads">num_threads</code></td>
<td>
<p>number of threads. Default is 1. Set to -1 to use all
available threads</p>
</td></tr>
<tr><td><code id="iso_female_ancestry_+3A_verbose">verbose</code></td>
<td>
<p>Displays verbose output if TRUE. Default value is FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To create an isofemale, two individuals are randomly picked from
the source population. Using these two individuals, a new population is
seeded, of size <code>inbreeding_pop_size</code>. Then, this population is allowed
to inbreed until either <code>run_time</code> is reached, or until all individuals
are homozygous and genetically identical, whatever happens first.
</p>


<h3>Value</h3>

<p>A list of length <code>n</code>, where each entry is a fully homozygous
isofemale.
</p>

<hr>
<h2 id='iso_female_sequence'>Create isofemale</h2><span id='topic+iso_female_sequence'></span>

<h3>Description</h3>

<p>Creates isofemale individuals, given a population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iso_female_sequence(
  input_data = NA,
  n = 1,
  inbreeding_pop_size = 100,
  run_time = 2000,
  morgan = 1,
  recombination_rate = NA,
  num_threads = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iso_female_sequence_+3A_input_data">input_data</code></td>
<td>
<p>Source population from which isofemales are generated</p>
</td></tr>
<tr><td><code id="iso_female_sequence_+3A_n">n</code></td>
<td>
<p>Number of isofemales to be generated</p>
</td></tr>
<tr><td><code id="iso_female_sequence_+3A_inbreeding_pop_size">inbreeding_pop_size</code></td>
<td>
<p>Population size of the population used to generate
homozygous individuals</p>
</td></tr>
<tr><td><code id="iso_female_sequence_+3A_run_time">run_time</code></td>
<td>
<p>Maximum runtime used for inbreeding</p>
</td></tr>
<tr><td><code id="iso_female_sequence_+3A_morgan">morgan</code></td>
<td>
<p>Size of the chromosome in Morgan (e.g. the number of crossovers
during meiosis)</p>
</td></tr>
<tr><td><code id="iso_female_sequence_+3A_recombination_rate">recombination_rate</code></td>
<td>
<p>rate in cM / Mbp, used to map recombination to the
markers. If the recombination_rate is not set, the value for Morgan is used,
assuming that the markers included span an entire chromosome.</p>
</td></tr>
<tr><td><code id="iso_female_sequence_+3A_num_threads">num_threads</code></td>
<td>
<p>number of threads. Default is 1. Set to -1 to use all
available threads</p>
</td></tr>
<tr><td><code id="iso_female_sequence_+3A_verbose">verbose</code></td>
<td>
<p>Displays verbose output if TRUE. Default value is FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To create an isofemale, two individuals are randomly picked from
the source population. Using these two individuals, a new population is
seeded, of size <code>inbreeding_pop_size</code>. Then, this population is allowed
to inbreed until either <code>run_time</code> is reached, or until all individuals
are homozygous and genetically identical, whatever happens first.
</p>


<h3>Value</h3>

<p>A list of length <code>n</code>, where each entry is a fully homozygous
isofemale.
</p>

<hr>
<h2 id='load_population'>Load a population from file</h2><span id='topic+load_population'></span>

<h3>Description</h3>

<p>Loads a population that has previously been written to file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_population(file_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load_population_+3A_file_name">file_name</code></td>
<td>
<p>Name of the file to save the population</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for <code>readRDS</code>.
</p>


<h3>Value</h3>

<p>A population object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+save_population">save_population</a></code>
</p>

<hr>
<h2 id='migration_settings'>Function to manage settings associated with migration</h2><span id='topic+migration_settings'></span>

<h3>Description</h3>

<p>creates a list with settings associated with migration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>migration_settings(
  migration_rate = NA,
  stop_at_critical_fst = FALSE,
  critical_fst = NA,
  population_size = c(100, 100),
  initial_frequencies = list(c(1, 0), c(0, 1)),
  generations_between_update = 10,
  sampled_individuals = 10,
  number_of_markers = 100,
  random_markers = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="migration_settings_+3A_migration_rate">migration_rate</code></td>
<td>
<p>Rate of migration between the two populations.
Migration is implemented such that with probability m (migration rate) one
of the two parents of a new offspring is from the other population, with
probability 1-m both parents are of the focal population.</p>
</td></tr>
<tr><td><code id="migration_settings_+3A_stop_at_critical_fst">stop_at_critical_fst</code></td>
<td>
<p>option to stop at a critical FST value
, default is FALSE</p>
</td></tr>
<tr><td><code id="migration_settings_+3A_critical_fst">critical_fst</code></td>
<td>
<p>the critical fst value to stop, if
<code>stop_simulation_at_critical_fst</code> is TRUE</p>
</td></tr>
<tr><td><code id="migration_settings_+3A_population_size">population_size</code></td>
<td>
<p>vector of population sizes, one size for each
population</p>
</td></tr>
<tr><td><code id="migration_settings_+3A_initial_frequencies">initial_frequencies</code></td>
<td>
<p>A list describing the initial frequency of each
ancestor in each population. Each entry in the list contains a vector with
the frequencies for all ancestor. The length of the vector indicates the
number of unique ancestors. If a vector not summing to 1 is provided, the
vector is normalized.</p>
</td></tr>
<tr><td><code id="migration_settings_+3A_generations_between_update">generations_between_update</code></td>
<td>
<p>The number of generations after which the
simulation has to check again whether the critical Fst value is exceeded</p>
</td></tr>
<tr><td><code id="migration_settings_+3A_sampled_individuals">sampled_individuals</code></td>
<td>
<p>Number of individuals to be sampled at random from
the population to estimate Fst</p>
</td></tr>
<tr><td><code id="migration_settings_+3A_number_of_markers">number_of_markers</code></td>
<td>
<p>Number of markers to be used to estimate Fst</p>
</td></tr>
<tr><td><code id="migration_settings_+3A_random_markers">random_markers</code></td>
<td>
<p>Are the markers to estimate Fst randomly distributed,
or regularly distributed? Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with migration associated settings. To be used to pass on
migration settings to simulate_admixture.
</p>

<hr>
<h2 id='plink_to_genomeadmixr_data'>function to convert plink style (ped/map) data to genome_admixr_data</h2><span id='topic+plink_to_genomeadmixr_data'></span>

<h3>Description</h3>

<p>function to convert plink style (ped/map) data to genome_admixr_data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plink_to_genomeadmixr_data(
  ped_data,
  map_data,
  chosen_chromosome,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plink_to_genomeadmixr_data_+3A_ped_data">ped_data</code></td>
<td>
<p>result of read.table(ped_file, header = F)</p>
</td></tr>
<tr><td><code id="plink_to_genomeadmixr_data_+3A_map_data">map_data</code></td>
<td>
<p>result of read.table(map_file, header = F)</p>
</td></tr>
<tr><td><code id="plink_to_genomeadmixr_data_+3A_chosen_chromosome">chosen_chromosome</code></td>
<td>
<p>chromosome of choice</p>
</td></tr>
<tr><td><code id="plink_to_genomeadmixr_data_+3A_verbose">verbose</code></td>
<td>
<p>verbose output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>genomeadmixr_data object ready for simulate_admixture_data
</p>

<hr>
<h2 id='plot_chromosome'>plots a chromosome</h2><span id='topic+plot_chromosome'></span>

<h3>Description</h3>

<p>This function plots a chromosome in the range [xmin, xmax].
Colors indicate different ancestry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_chromosome(chrom, xmin = 0, xmax = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_chromosome_+3A_chrom">chrom</code></td>
<td>
<p>object of type chromosome, typically a table with two columns.
The first column indicates the start of an ancestry block (location in
Morgan), the second column indicates the ancestry type.</p>
</td></tr>
<tr><td><code id="plot_chromosome_+3A_xmin">xmin</code></td>
<td>
<p>minimum value of the range, default = 0.</p>
</td></tr>
<tr><td><code id="plot_chromosome_+3A_xmax">xmax</code></td>
<td>
<p>maximum value of the range, default = 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wildpop =  simulate_admixture(
   module = ancestry_module(number_of_founders = 10, morgan = 1),
   pop_size = 1000,
   total_runtime = 10)

isofemale &lt;- create_iso_female(
                 module = ancestry_module(input_population = wildpop,
                                          morgan = 1),
                 n = 1,
                 inbreeding_pop_size = 100,
                 run_time = 10)

plot_chromosome(chrom = isofemale[[1]]$chromosome1)
# and a detail of the chromosome:
plot_chromosome(chrom = isofemale[[1]]$chromosome1,
                xmin = 0.4,
                xmax = 0.6)
</code></pre>

<hr>
<h2 id='plot_difference_frequencies'>Plot the change in frequency between the start and end of a simulation</h2><span id='topic+plot_difference_frequencies'></span>

<h3>Description</h3>

<p>This function plots the change in frequency of one or
multiple ancestors after performing a simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_difference_frequencies(
  results,
  picked_ancestor = "ALL",
  picked_population = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_difference_frequencies_+3A_results">results</code></td>
<td>
<p>An object which is the result of <code>simulate_admixture</code>
being a list with four properties:
<code>population</code>, <code>frequencies</code>, <code>initial_frequencies</code> and
<code>final frequencies</code></p>
</td></tr>
<tr><td><code id="plot_difference_frequencies_+3A_picked_ancestor">picked_ancestor</code></td>
<td>
<p>Default is &quot;ALL&quot;, where different colors indicate
different ancestors. Alternatively, for clarity, the user can specify a
specific ancestral allele, and only that allele is plotted</p>
</td></tr>
<tr><td><code id="plot_difference_frequencies_+3A_picked_population">picked_population</code></td>
<td>
<p>If multiple populations were simulated (in the case
of <code>simulate_admixture_migration</code>), which population should be plotted?
Default is population_1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- 0.1
select_matrix &lt;- matrix(nrow = 1, ncol = 5)
select_matrix[1, ] &lt;- c(0.25, 1.0, 1 + 0.5 * s, 1 + s, 0)

markers &lt;- seq(from = 0.2, to = 0.3, length.out = 100)

selected_pop &lt;- simulate_admixture(
                    module = ancestry_module(number_of_founders = 10,
                                             morgan = 1,
                                             markers = markers),
                    pop_size = 1000,
                    total_runtime = 11,
                    select_matrix = select_matrix)
require(ggplot2)
plot_difference_frequencies(results = selected_pop,
                            picked_ancestor = "ALL")
</code></pre>

<hr>
<h2 id='plot_dist_junctions'>plot the distribution of junctions</h2><span id='topic+plot_dist_junctions'></span>

<h3>Description</h3>

<p>plots the distribution of junctions in the population using
base R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_dist_junctions(pop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_dist_junctions_+3A_pop">pop</code></td>
<td>
<p>of the class 'population'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>

<hr>
<h2 id='plot_frequencies'>Plot the frequencies of all ancestors along the genome.</h2><span id='topic+plot_frequencies'></span>

<h3>Description</h3>

<p>This function plots the frequency of all ancestors after
performing a simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_frequencies(
  result,
  locations = seq(0, 1, length.out = 100),
  progress_bar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_frequencies_+3A_result">result</code></td>
<td>
<p>An object which is the result of <code>select_population</code> or
<code>create_population_selection</code>, being a list with four properties:
<code>population</code>, <code>frequencies</code>, <code>initial_frequencies</code> and
<code>final frequencies</code></p>
</td></tr>
<tr><td><code id="plot_frequencies_+3A_locations">locations</code></td>
<td>
<p>A vector indicating the locations (in Morgan) where to
calculate the allele frequencies.</p>
</td></tr>
<tr><td><code id="plot_frequencies_+3A_progress_bar">progress_bar</code></td>
<td>
<p>Displays a progress_bar if TRUE. Default value is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- simulate_admixture(
             module = ancestry_module(number_of_founders = 4),
             pop_size = 1000,
             total_runtime = 11)
require(ggplot2)
plot_frequencies(result = pop)
</code></pre>

<hr>
<h2 id='plot_joyplot_frequencies'>make a joy plot of the distribution of allele frequencies within a region</h2><span id='topic+plot_joyplot_frequencies'></span>

<h3>Description</h3>

<p>This function plots the distribution of allele frequencies
within a region over time, making use of a 'joyplot'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_joyplot_frequencies(
  frequencies,
  time_points,
  picked_ancestor = "ALL",
  picked_population = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_joyplot_frequencies_+3A_frequencies">frequencies</code></td>
<td>
<p>A tibble containing four columns: <code>time</code>,
<code>location</code>, <code>ancestor</code>, <code>frequency</code>. Typically one of the
items returned by <code>create_population_selection</code> or
<code>select_population</code> when the user specifies <code>track_frequency</code>.</p>
</td></tr>
<tr><td><code id="plot_joyplot_frequencies_+3A_time_points">time_points</code></td>
<td>
<p>A sequence of time points for which the user wants to
create the joyplot</p>
</td></tr>
<tr><td><code id="plot_joyplot_frequencies_+3A_picked_ancestor">picked_ancestor</code></td>
<td>
<p>Default is &quot;ALL&quot;, where different colors indicate
different ancestors. Alternatively, for clarity, the user can specify a
specific ancestral allele, and only that allele is plotted</p>
</td></tr>
<tr><td><code id="plot_joyplot_frequencies_+3A_picked_population">picked_population</code></td>
<td>
<p>If multiple populations were simulated (in the case
of <code>simulate_admixture_migration</code>), which population should be plotted?
Default is population_1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
s &lt;- 0.01
select_matrix &lt;- matrix(nrow = 1, ncol = 5)
select_matrix[1, ] &lt;- c(0.25, 1.0, 1 + 0.5 * s, 1 + s, 0)

markers &lt;- seq(from = 0.2, to = 0.3, length.out = 100)

selected_pop &lt;- simulate_admixture(
                    module = ancestry_module(number_of_founders = 10,
                                             morgan = 1,
                                             markers = markers),
                    pop_size = 1000,
                    total_runtime = 11,
                    select_matrix = select_matrix)
require(ggplot2)
plot_joyplot_frequencies(frequencies = selected_pop$frequencies,
                         time_points = 0:11,
                         picked_ancestor = "ALL")

# joyplot frequencies returns a ggplot object, so we can
# add extra elements:
plot_joyplot_frequencies(frequencies = selected_pop$frequencies,
                         time_points = 0:11,
                         picked_ancestor = "ALL") +
  ggplot2::xlab("Location") +
  ggplot2::ylab("Generations")

</code></pre>

<hr>
<h2 id='plot_over_time'>Plot the frequencies of all ancestors over time</h2><span id='topic+plot_over_time'></span>

<h3>Description</h3>

<p>This function plots the frequency of all ancestors over time at
a specific location on the chromosome, after performing a simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_over_time(frequencies, focal_location)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_over_time_+3A_frequencies">frequencies</code></td>
<td>
<p>A tibble containing four columns: <code>time</code>,
<code>location</code>, <code>ancestor</code>, <code>frequency</code>. A fifth colum
<code>population</code> can be included if the tibble is the result of
<code>simulate_admixture_migration</code>.</p>
</td></tr>
<tr><td><code id="plot_over_time_+3A_focal_location">focal_location</code></td>
<td>
<p>Location (in Morgan) where to plot the allele
frequencies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- simulate_admixture(
           module = ancestry_module(number_of_founders = 10,
                                    markers = 0.5),
           pop_size = 1000,
           total_runtime = 11)
require(ggplot2)
plot_over_time(frequencies = pop$frequencies,
               focal_location = 0.5)
</code></pre>

<hr>
<h2 id='plot_start_end'>Plot both the starting frequencies and the final frequencies in one plot</h2><span id='topic+plot_start_end'></span>

<h3>Description</h3>

<p>This function plots the distribution of both the starting and
the final frequencies in one plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_start_end(results, picked_ancestor = "ALL", picked_population = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_start_end_+3A_results">results</code></td>
<td>
<p>An object which is the result of <code>simulate_admixture</code>,
being a list with four properties:
<code>population</code>, <code>frequencies</code>, <code>initial_frequencies</code> and
<code>final frequencies</code></p>
</td></tr>
<tr><td><code id="plot_start_end_+3A_picked_ancestor">picked_ancestor</code></td>
<td>
<p>Default is &quot;ALL&quot;, where different colors indicate
different ancestors. Alternatively, for clarity, the user can specify a
specific ancestral allele, and only that allele is plotted</p>
</td></tr>
<tr><td><code id="plot_start_end_+3A_picked_population">picked_population</code></td>
<td>
<p>If multiple populations were simulated (in the case
of <code>simulate_admixture_migration</code>), which population should be plotted?
Default is population_1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>markers &lt;- seq(from = 0.2, to = 0.3, length.out = 100)

pop &lt;- simulate_admixture(
            module = ancestry_module(number_of_founders = 3,
                                     morgan = 1,
                                     markers = markers),
           pop_size = 1000,
           total_runtime = 11)
require(ggplot2)
plot_start_end(pop,
               picked_ancestor = "ALL")
plot_start_end(pop,
               picked_ancestor = 1)
</code></pre>

<hr>
<h2 id='plot.individual'>plot the genome of an individual</h2><span id='topic+plot.individual'></span>

<h3>Description</h3>

<p>visualise ancestry blocks on both chromosomes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'individual'
plot(x, cols = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.individual_+3A_x">x</code></td>
<td>
<p>object of type individual</p>
</td></tr>
<tr><td><code id="plot.individual_+3A_cols">cols</code></td>
<td>
<p>colors for the different ancestors</p>
</td></tr>
<tr><td><code id="plot.individual_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>

<hr>
<h2 id='print.genomeadmixr_data'>print an individual to the console</h2><span id='topic+print.genomeadmixr_data'></span>

<h3>Description</h3>

<p>prints an object of class genomeadmixr_data to the console
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'genomeadmixr_data'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.genomeadmixr_data_+3A_x">x</code></td>
<td>
<p>individual</p>
</td></tr>
<tr><td><code id="print.genomeadmixr_data_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>

<hr>
<h2 id='print.individual'>print an individual to the console</h2><span id='topic+print.individual'></span>

<h3>Description</h3>

<p>prints an object of class individual to the console
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'individual'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.individual_+3A_x">x</code></td>
<td>
<p>individual</p>
</td></tr>
<tr><td><code id="print.individual_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>

<hr>
<h2 id='print.population'>print a population object</h2><span id='topic+print.population'></span>

<h3>Description</h3>

<p>prints the contents of a population nicely
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'population'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.population_+3A_x">x</code></td>
<td>
<p>input population</p>
</td></tr>
<tr><td><code id="print.population_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>

<hr>
<h2 id='read_input_data'>read sequence data from file to be used in simulation</h2><span id='topic+read_input_data'></span>

<h3>Description</h3>

<p>Create data in a format that can be used by GenomeAdmixR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_input_data(
  file_names,
  type,
  chosen_chromosome,
  number_of_snps = NA,
  random_snps = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_input_data_+3A_file_names">file_names</code></td>
<td>
<p>names of input files</p>
</td></tr>
<tr><td><code id="read_input_data_+3A_type">type</code></td>
<td>
<p>type of data, options are 'ped' and 'vcf'</p>
</td></tr>
<tr><td><code id="read_input_data_+3A_chosen_chromosome">chosen_chromosome</code></td>
<td>
<p>GenomeAdmixR simulates only a single chromosome.</p>
</td></tr>
<tr><td><code id="read_input_data_+3A_number_of_snps">number_of_snps</code></td>
<td>
<p>number of snps to be loaded from file, default
is to load all snps</p>
</td></tr>
<tr><td><code id="read_input_data_+3A_random_snps">random_snps</code></td>
<td>
<p>if a subset of all snps has to be taken, should these
be sampled sequentially (e.g. the first 100 snps) or randomly (100 randomly
sampled snps) (examples are for 'number_of_snps' = 100).</p>
</td></tr>
<tr><td><code id="read_input_data_+3A_verbose">verbose</code></td>
<td>
<p>give verbose output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with two properties: <code>genomes</code> a matrix with the
sequence translated to numerics, such that [actg] corresponds to [1234], and
missing data is represented with &quot;-&quot;. Rows in the matrix correspond to
chromosomes, and columns represent bases. Two consecutive rows represent an
individual, such that rows 1-2 are individual, rows 3-4 are one individual
etc. <code>markers</code> corresponds to the locations of the markers (in bp) on
the chosen chromosome.
</p>

<hr>
<h2 id='save_population'>Save a population to file</h2><span id='topic+save_population'></span>

<h3>Description</h3>

<p>Saves a population to file for later use
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_population(population, file_name, compression = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_population_+3A_population">population</code></td>
<td>
<p>Object of class <code>population</code></p>
</td></tr>
<tr><td><code id="save_population_+3A_file_name">file_name</code></td>
<td>
<p>Name of the file to save the population</p>
</td></tr>
<tr><td><code id="save_population_+3A_compression">compression</code></td>
<td>
<p>By default, the population is compressed to reduce file
size. See for more information <code>saveRDS</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function functions as a wrapper for the base function
<code>saveRDS</code>.
</p>


<h3>Value</h3>

<p>No return value
</p>

<hr>
<h2 id='sequence_module'>create sequence module</h2><span id='topic+sequence_module'></span>

<h3>Description</h3>

<p>creates a sequence module, which contains all relevant
information in order to perform a simulation based on sequence data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequence_module(
  molecular_data = NA,
  initial_frequencies = NA,
  morgan = 1,
  recombination_rate = NA,
  markers = NA,
  mutation_rate = 0,
  substitution_matrix = matrix(1/4, 4, 4)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sequence_module_+3A_molecular_data">molecular_data</code></td>
<td>
<p>Genomic data used as input, should be of type
genomeadmixr_data. Either a single dataset is provided, or a list of
multiple genomeadmixr_data objects.</p>
</td></tr>
<tr><td><code id="sequence_module_+3A_initial_frequencies">initial_frequencies</code></td>
<td>
<p>A vector describing the initial contribution of
each provided input data set to the starting hybrid swarm. By default, equal
frequencies are assumed. If a vector not summing to 1 is provided, the vector
is normalized.</p>
</td></tr>
<tr><td><code id="sequence_module_+3A_morgan">morgan</code></td>
<td>
<p>Length of the molecular sequence in Morgan (e.g. the number of
crossovers during meiosis), alternatively, the recombination rate can be
used, see below.</p>
</td></tr>
<tr><td><code id="sequence_module_+3A_recombination_rate">recombination_rate</code></td>
<td>
<p>rate in cM / Mbp, used to map recombination to the
markers. If the recombination_rate is not set, the value for Morgan is used,
assuming that the markers included span an entire chromosome.</p>
</td></tr>
<tr><td><code id="sequence_module_+3A_markers">markers</code></td>
<td>
<p>A vector of locations of markers, these markers are
tracked for every generation.</p>
</td></tr>
<tr><td><code id="sequence_module_+3A_mutation_rate">mutation_rate</code></td>
<td>
<p>the per base probability of mutation. Default is 0.</p>
</td></tr>
<tr><td><code id="sequence_module_+3A_substitution_matrix">substitution_matrix</code></td>
<td>
<p>a 4x4 matrix representing the probability of
mutating to another base (where [1/2/3/4] = [a/c/t/g]), conditional on the
event of a mutation happening. Default is the JC69 matrix, with equal
probabilities for all transitions / transversions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sequence module object, used as starting point for
simulate_admixture.
</p>

<hr>
<h2 id='simulate_admixture'>Individual based simulation of the breakdown of contiguous ancestry blocks.</h2><span id='topic+simulate_admixture'></span>

<h3>Description</h3>

<p>Individual based simulation of the breakdown of contiguous
ancestry blocks, with or without selection. Simulations can be started from
scratch, or from a predefined input population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_admixture(
  module = ancestry_module(),
  pop_size = 100,
  total_runtime = 100,
  migration = migration_settings(),
  select_matrix = NA,
  multiplicative_selection = TRUE,
  verbose = FALSE,
  num_threads = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_admixture_+3A_module">module</code></td>
<td>
<p>Chosen module to simulate, either created with
<code>module_ancestry</code> or
<code>module_sequence</code>.</p>
</td></tr>
<tr><td><code id="simulate_admixture_+3A_pop_size">pop_size</code></td>
<td>
<p>The number of individuals in the population. If the number is
larger than the number of individuals in the input population (if provided),
additional individuals are sampled randomly from the input population to
reach the intended size.</p>
</td></tr>
<tr><td><code id="simulate_admixture_+3A_total_runtime">total_runtime</code></td>
<td>
<p>Number of generations</p>
</td></tr>
<tr><td><code id="simulate_admixture_+3A_migration">migration</code></td>
<td>
<p>settings associated with migration, should be created with
<code><a href="#topic+migration_settings">migration_settings</a></code></p>
</td></tr>
<tr><td><code id="simulate_admixture_+3A_select_matrix">select_matrix</code></td>
<td>
<p>Selection matrix indicating the markers which are under
selection. If not provided by the user, the simulation proceeds neutrally. If
provided, each row in the matrix should contain five entries:
<code>location</code> location of the marker under selection (in Morgan) 
<code>fitness of wildtype (aa)</code> <code>fitness of heterozygote (aA)</code>
<code>fitness of homozygote mutant (AA)</code> <code>Ancestral type that
represents the mutant allele A</code></p>
</td></tr>
<tr><td><code id="simulate_admixture_+3A_multiplicative_selection">multiplicative_selection</code></td>
<td>
<p>Default: TRUE. If TRUE, fitness is calculated
for multiple markers by multiplying fitness values for each marker. If FALSE,
fitness is calculated by adding fitness values for each marker.</p>
</td></tr>
<tr><td><code id="simulate_admixture_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output if TRUE. Default value is FALSE</p>
</td></tr>
<tr><td><code id="simulate_admixture_+3A_num_threads">num_threads</code></td>
<td>
<p>number of threads. Default is 1. Set to -1 to use all
available threads</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with: <code>population</code> a population object, and three tibbles
with allele frequencies (only contain values of a vector was provided to the
argument <code>markers</code>: <code>frequencies</code> , <code>initial_frequencies</code> and
<code>final_frequencies</code>. Each tibble contains four columns, <code>time</code>,
<code>location</code>, <code>ancestor</code> and <code>frequency</code>, which indicates the
number of generations, the location along the chromosome of the marker, the
ancestral allele at that location in that generation, and finally, the
frequency of that allele.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># local ancestry simulation
two_populations &lt;- simulate_admixture(
                         module = ancestry_module(number_of_founders = 3,
                                                  morgan = 0.8),
                         migration = migration_settings(
                                         migration_rate = 0.01,
                                         population_size = c(100, 100)),
                         total_runtime = 10)
 # sequence simulation
 data(dgrp2.3R.5k.data)

sequence_population &lt;-
      simulate_admixture(
                  module = sequence_module(molecular_data = dgrp2.3R.5k.data,
                           recombination_rate = 0.2,
                           mutation_rate = 1e-5),
                  pop_size = 1000,
                  total_runtime = 10)
</code></pre>

<hr>
<h2 id='simulate_ancestry'>Individual based simulation of the breakdown of contiguous ancestry blocks.</h2><span id='topic+simulate_ancestry'></span>

<h3>Description</h3>

<p>Individual based simulation of the breakdown of contiguous
ancestry blocks, with or without selection. Simulations can be started from
scratch, or from a predefined input population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_ancestry(
  input_population = NA,
  pop_size = NA,
  number_of_founders = 2,
  initial_frequencies = NA,
  total_runtime = 100,
  morgan = 1,
  num_threads = 1,
  select_matrix = NA,
  markers = NA,
  verbose = FALSE,
  track_junctions = FALSE,
  multiplicative_selection = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_ancestry_+3A_input_population">input_population</code></td>
<td>
<p>Potential earlier simulated population used as
starting point for the simulation. If not provided by the user, the
simulation starts from scratch.</p>
</td></tr>
<tr><td><code id="simulate_ancestry_+3A_pop_size">pop_size</code></td>
<td>
<p>The number of individuals in the population. If the number is
larger than the number of individuals in the input population (if provided),
additional individuals are sampled randomly from the input population to
reach the intended size.</p>
</td></tr>
<tr><td><code id="simulate_ancestry_+3A_number_of_founders">number_of_founders</code></td>
<td>
<p>Number of unique ancestors</p>
</td></tr>
<tr><td><code id="simulate_ancestry_+3A_initial_frequencies">initial_frequencies</code></td>
<td>
<p>A vector describing the initial frequency of each
ancestor. By default, equal frequencies are assumed. If a vector not summing
to 1 is provided, the vector is normalized.</p>
</td></tr>
<tr><td><code id="simulate_ancestry_+3A_total_runtime">total_runtime</code></td>
<td>
<p>Number of generations</p>
</td></tr>
<tr><td><code id="simulate_ancestry_+3A_morgan">morgan</code></td>
<td>
<p>Length of the chromosome in Morgan (e.g. the number of
crossovers during meiosis)</p>
</td></tr>
<tr><td><code id="simulate_ancestry_+3A_num_threads">num_threads</code></td>
<td>
<p>number of threads. Default is 1. Set to -1 to use all
available threads</p>
</td></tr>
<tr><td><code id="simulate_ancestry_+3A_select_matrix">select_matrix</code></td>
<td>
<p>Selection matrix indicating the markers which are under
selection. If not provided by the user, the simulation proceeds neutrally. If
provided, each row in the matrix should contain five entries:
<code>location</code> location of the marker under selection (in Morgan) 
<code>fitness of wildtype (aa)</code> <code>fitness of heterozygote (aA)</code>
<code>fitness of homozygote mutant (AA)</code> <code>Ancestral type that
represents the mutant allele A</code></p>
</td></tr>
<tr><td><code id="simulate_ancestry_+3A_markers">markers</code></td>
<td>
<p>A vector of locations of markers (relative locations in
[0, 1]). If a vector is provided, ancestry at these marker positions is
tracked for every generation.</p>
</td></tr>
<tr><td><code id="simulate_ancestry_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output if TRUE. Default value is FALSE</p>
</td></tr>
<tr><td><code id="simulate_ancestry_+3A_track_junctions">track_junctions</code></td>
<td>
<p>Track the average number of junctions over time if
TRUE</p>
</td></tr>
<tr><td><code id="simulate_ancestry_+3A_multiplicative_selection">multiplicative_selection</code></td>
<td>
<p>Default: TRUE. If TRUE, fitness is calculated
for multiple markers by multiplying fitness values for each marker. If FALSE,
fitness is calculated by adding fitness values for each marker.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with: <code>population</code> a population object, and three tibbles
with allele frequencies (only contain values of a vector was provided to the
argument <code>markers</code>: <code>frequencies</code> , <code>initial_frequencies</code> and
<code>final_frequencies</code>. Each tibble contains four columns, <code>time</code>,
<code>location</code>, <code>ancestor</code> and <code>frequency</code>, which indicates the
number of generations, the location along the chromosome of the marker, the
ancestral allele at that location in that generation, and finally, the
frequency of that allele.
</p>

<hr>
<h2 id='simulate_ancestry_migration'>Individual based simulation of the breakdown of contiguous ancestry blocks in
two populations linked by migration</h2><span id='topic+simulate_ancestry_migration'></span>

<h3>Description</h3>

<p>Individual based simulation of the breakdown of contiguous
ancestry blocks, with or without selection. Simulations can be started from
scratch, or from a predefined input population. Two populations are
simulated, connected by migration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_ancestry_migration(
  input_population_1 = NA,
  input_population_2 = NA,
  pop_size = c(100, 100),
  initial_frequencies = list(c(1, 0), c(0, 1)),
  total_runtime = 100,
  morgan = 1,
  num_threads = 1,
  select_matrix = NA,
  markers = NA,
  verbose = FALSE,
  track_junctions = FALSE,
  multiplicative_selection = TRUE,
  migration_rate = 0,
  stop_at_critical_fst = FALSE,
  critical_fst = 0.1,
  generations_between_update = 100,
  sampled_individuals = 10,
  number_of_markers = 100,
  random_markers = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_ancestry_migration_+3A_input_population_1">input_population_1</code></td>
<td>
<p>Potential earlier simulated population used as
starting point for the simulation. If not provided by the user, the
simulation starts from scratch.</p>
</td></tr>
<tr><td><code id="simulate_ancestry_migration_+3A_input_population_2">input_population_2</code></td>
<td>
<p>Potential earlier simulated population used as
starting point for the simulation. If not provided by the user,
the simulation starts from scratch.</p>
</td></tr>
<tr><td><code id="simulate_ancestry_migration_+3A_pop_size">pop_size</code></td>
<td>
<p>Vector containing the number of individuals in both
populations.</p>
</td></tr>
<tr><td><code id="simulate_ancestry_migration_+3A_initial_frequencies">initial_frequencies</code></td>
<td>
<p>A list describing the initial frequency of each
ancestor in each population. Each entry in the list contains a vector with
the frequencies for all ancestor. The length of the vector indicates the
number of unique ancestors. If a vector not summing to 1 is provided, the
vector is normalized.</p>
</td></tr>
<tr><td><code id="simulate_ancestry_migration_+3A_total_runtime">total_runtime</code></td>
<td>
<p>Number of generations</p>
</td></tr>
<tr><td><code id="simulate_ancestry_migration_+3A_morgan">morgan</code></td>
<td>
<p>Length of the chromosome in Morgan (e.g. the number of
crossovers during meiosis)</p>
</td></tr>
<tr><td><code id="simulate_ancestry_migration_+3A_num_threads">num_threads</code></td>
<td>
<p>number of threads. Default is 1. Set to -1 to use all
available threads</p>
</td></tr>
<tr><td><code id="simulate_ancestry_migration_+3A_select_matrix">select_matrix</code></td>
<td>
<p>Selection matrix indicating the markers which are under
selection. If not provided by the user, the simulation proceeds neutrally.
If provided, each row in the matrix should contain five entries:
<code>location</code> location of the marker under selection (in Morgan) 
<code>fitness of wildtype (aa)</code> <code>fitness of heterozygote (aA)</code>
<code>fitness of homozygote mutant (AA)</code> <code>Ancestral type that
representes the mutant allele A</code></p>
</td></tr>
<tr><td><code id="simulate_ancestry_migration_+3A_markers">markers</code></td>
<td>
<p>A vector of locations of markers (relative locations in
[0, 1]). If a vector is provided, ancestry at these marker positions is
tracked for every generation.</p>
</td></tr>
<tr><td><code id="simulate_ancestry_migration_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output if TRUE. Default value is FALSE</p>
</td></tr>
<tr><td><code id="simulate_ancestry_migration_+3A_track_junctions">track_junctions</code></td>
<td>
<p>Track the average number of junctions over time if
TRUE</p>
</td></tr>
<tr><td><code id="simulate_ancestry_migration_+3A_multiplicative_selection">multiplicative_selection</code></td>
<td>
<p>Default: TRUE. If TRUE, fitness is
calculated for multiple markers by multiplying fitness values for each
marker. If FALSE, fitness is calculated by adding fitness values for each
marker.</p>
</td></tr>
<tr><td><code id="simulate_ancestry_migration_+3A_migration_rate">migration_rate</code></td>
<td>
<p>Rate of migration between the two populations.
Migration is implemented such that with probability m (migration rate) one
of the two parents of a new offspring is from the other population, with
probability 1-m both parents are of the focal population.</p>
</td></tr>
<tr><td><code id="simulate_ancestry_migration_+3A_stop_at_critical_fst">stop_at_critical_fst</code></td>
<td>
<p>option to stop at a critical FST value
, default is FALSE</p>
</td></tr>
<tr><td><code id="simulate_ancestry_migration_+3A_critical_fst">critical_fst</code></td>
<td>
<p>the critical fst value to stop, if
<code>stop_simulation_at_critical_fst</code> is TRUE</p>
</td></tr>
<tr><td><code id="simulate_ancestry_migration_+3A_generations_between_update">generations_between_update</code></td>
<td>
<p>The number of generations after which the
simulation has to check again whether the critical Fst value is exceeded</p>
</td></tr>
<tr><td><code id="simulate_ancestry_migration_+3A_sampled_individuals">sampled_individuals</code></td>
<td>
<p>Number of individuals to be sampled at random from
the population to estimate Fst</p>
</td></tr>
<tr><td><code id="simulate_ancestry_migration_+3A_number_of_markers">number_of_markers</code></td>
<td>
<p>Number of markers to be used to estimate Fst</p>
</td></tr>
<tr><td><code id="simulate_ancestry_migration_+3A_random_markers">random_markers</code></td>
<td>
<p>Are the markers to estimate Fst randomly distributed,
or regularly distributed? Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with: <code>population_1</code>, <code>population_2</code> two population
objects, and three tibbles with allele frequencies (only contain values of a
vector was provided to the argument <code>markers</code>: <code>frequencies</code>,
<code>initial_frequencies</code> and <code>final_frequencies</code>. Each tibble contains
five columns, <code>time</code>, <code>location</code>, <code>ancestor</code>, <code>frequency</code>
and <code>population</code>, which indicates the number of generations, the
location along the chromosome of the marker, the ancestral allele at that
location in that generation, the frequency of that allele and the population
in which it was recorded (1 or 2). If a critical fst value was used to
terminate the simulation, and object <code>FST</code> with the final FST estimate
is returned as well.
</p>

<hr>
<h2 id='simulate_sequence'>Individual based simulation of the breakdown of contiguous ancestry blocks.</h2><span id='topic+simulate_sequence'></span>

<h3>Description</h3>

<p>Individual based simulation of the breakdown of contiguous
ancestry blocks, with or without selection. Simulations can be started from
scratch, or from a predefined input population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_sequence(
  input_data = NA,
  pop_size = NA,
  initial_frequencies = NA,
  total_runtime = 100,
  morgan = 1,
  recombination_rate = NA,
  num_threads = 1,
  select_matrix = NA,
  markers = NA,
  verbose = FALSE,
  multiplicative_selection = TRUE,
  mutation_rate = 0,
  substitution_matrix = matrix(1/4, 4, 4)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_sequence_+3A_input_data">input_data</code></td>
<td>
<p>Genomic data used as input, should be of type
genomeadmixr_data. Either a single dataset is provided, or a list of
multiple genomeadmixr_data objects.</p>
</td></tr>
<tr><td><code id="simulate_sequence_+3A_pop_size">pop_size</code></td>
<td>
<p>Vector containing the number of individuals in both
populations.</p>
</td></tr>
<tr><td><code id="simulate_sequence_+3A_initial_frequencies">initial_frequencies</code></td>
<td>
<p>A vector describing the initial contribution of
each provided input data set to the starting hybrid swarm. By default, equal
frequencies are assumed. If a vector not summing to 1 is provided, the vector
is normalized.</p>
</td></tr>
<tr><td><code id="simulate_sequence_+3A_total_runtime">total_runtime</code></td>
<td>
<p>Number of generations</p>
</td></tr>
<tr><td><code id="simulate_sequence_+3A_morgan">morgan</code></td>
<td>
<p>Length of the chromosome in Morgan (e.g. the number of
crossovers during meiosis)</p>
</td></tr>
<tr><td><code id="simulate_sequence_+3A_recombination_rate">recombination_rate</code></td>
<td>
<p>rate in cM / Mbp, used to map recombination to the
markers. If the recombination_rate is not set, the value for Morgan is used,
assuming that the markers included span an entire chromosome.</p>
</td></tr>
<tr><td><code id="simulate_sequence_+3A_num_threads">num_threads</code></td>
<td>
<p>number of threads. Default is 1. Set to -1 to use all
available threads</p>
</td></tr>
<tr><td><code id="simulate_sequence_+3A_select_matrix">select_matrix</code></td>
<td>
<p>Selection matrix indicating the markers which are under
selection. If not provided by the user, the simulation proceeds neutrally. If
provided, each row in the matrix should contain five entries:
<code>location</code> location of the marker under selection (in Morgan) 
<code>fitness of wildtype (aa)</code> <code>fitness of heterozygote (aA)</code>
<code>fitness of homozygote mutant (AA)</code> <code>Ancestral type that
represents the mutant allele A</code></p>
</td></tr>
<tr><td><code id="simulate_sequence_+3A_markers">markers</code></td>
<td>
<p>A vector of locations of markers, these markers are
tracked for every generation.</p>
</td></tr>
<tr><td><code id="simulate_sequence_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output if TRUE. Default value is FALSE</p>
</td></tr>
<tr><td><code id="simulate_sequence_+3A_multiplicative_selection">multiplicative_selection</code></td>
<td>
<p>Default: TRUE. If TRUE, fitness is calculated
for multiple markers by multiplying fitness values for each marker. If FALSE,
fitness is calculated by adding fitness values for each marker.</p>
</td></tr>
<tr><td><code id="simulate_sequence_+3A_mutation_rate">mutation_rate</code></td>
<td>
<p>the per base probability of mutation. Default is 0.</p>
</td></tr>
<tr><td><code id="simulate_sequence_+3A_substitution_matrix">substitution_matrix</code></td>
<td>
<p>a 4x4 matrix representing the probability of
mutating to another base (where [1/2/3/4] = [a/c/t/g]), conditional on the
event of a mutation happening. Default is the JC69 matrix, with equal
probabilities for all transitions / transversions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with: <code>population</code> a population object, and three tibbles
with allele frequencies (only contain values of a vector was provided to the
argument <code>markers</code>: <code>frequencies</code> , <code>initial_frequencies</code> and
<code>final_frequencies</code>. Each tibble contains four columns, <code>time</code>,
<code>location</code>, <code>ancestor</code> and <code>frequency</code>, which indicates the
number of generations, the location along the chromosome of the marker, the
ancestral allele at that location in that generation, and finally, the
frequency of that allele.
</p>

<hr>
<h2 id='simulate_sequence_migration'>Individual based simulation of the breakdown of contiguous ancestry blocks in
two populations linked by migration</h2><span id='topic+simulate_sequence_migration'></span>

<h3>Description</h3>

<p>Individual based simulation of the breakdown of contiguous
ancestry blocks, with or without selection. Simulations can be started from
scratch, or from a predefined input population. Two populations are
simulated, connected by migration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_sequence_migration(
  input_data_population_1 = NA,
  input_data_population_2 = NA,
  pop_size = c(100, 100),
  total_runtime = 100,
  morgan = 1,
  recombination_rate = NA,
  num_threads = 1,
  select_matrix = NA,
  markers = NA,
  verbose = FALSE,
  multiplicative_selection = TRUE,
  migration_rate = 0,
  stop_at_critical_fst = FALSE,
  critical_fst = NA,
  generations_between_update = 100,
  sampled_individuals = 10,
  number_of_markers = 100,
  random_markers = TRUE,
  mutation_rate = 0,
  substitution_matrix = matrix(1/4, 4, 4)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_sequence_migration_+3A_input_data_population_1">input_data_population_1</code></td>
<td>
<p>Genomic data used as input, should be created
by the function <code>create_input_data</code> or by the function
<code>combine_input_data</code></p>
</td></tr>
<tr><td><code id="simulate_sequence_migration_+3A_input_data_population_2">input_data_population_2</code></td>
<td>
<p>Genomic data used as input, should be created
by thefunction <code>create_input_data</code> or by the function
<code>combine_input_data</code></p>
</td></tr>
<tr><td><code id="simulate_sequence_migration_+3A_pop_size">pop_size</code></td>
<td>
<p>Vector containing the number of individuals in both
populations.</p>
</td></tr>
<tr><td><code id="simulate_sequence_migration_+3A_total_runtime">total_runtime</code></td>
<td>
<p>Number of generations</p>
</td></tr>
<tr><td><code id="simulate_sequence_migration_+3A_morgan">morgan</code></td>
<td>
<p>Length of the chromosome in Morgan (e.g. the number of
crossovers during meiosis)</p>
</td></tr>
<tr><td><code id="simulate_sequence_migration_+3A_recombination_rate">recombination_rate</code></td>
<td>
<p>rate in cM / Mbp, used to map recombination to the
markers. If the recombination_rate is not set, the value for morgan is used,
assuming that the markers included span an entire chromosome.</p>
</td></tr>
<tr><td><code id="simulate_sequence_migration_+3A_num_threads">num_threads</code></td>
<td>
<p>number of threads. Default is 1. Set to -1 to use all
available threads</p>
</td></tr>
<tr><td><code id="simulate_sequence_migration_+3A_select_matrix">select_matrix</code></td>
<td>
<p>Selection matrix indicating the markers which are under
selection. If not provided by the user, the simulation proceeds neutrally.
If provided, each row in the matrix should contain five entries:
<code>location</code> location of the marker under selection (in Morgan) 
<code>fitness of wildtype (aa)</code> <code>fitness of heterozygote (aA)</code>
<code>fitness of homozygote mutant (AA)</code> <code>Ancestral type that
representes the mutant allele A</code></p>
</td></tr>
<tr><td><code id="simulate_sequence_migration_+3A_markers">markers</code></td>
<td>
<p>A vector of locations of markers (relative locations in
[0, 1]). If a vector is provided, ancestry at these marker positions is
tracked for every generation.</p>
</td></tr>
<tr><td><code id="simulate_sequence_migration_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output if TRUE. Default value is FALSE</p>
</td></tr>
<tr><td><code id="simulate_sequence_migration_+3A_multiplicative_selection">multiplicative_selection</code></td>
<td>
<p>Default: TRUE. If TRUE, fitness is
calculated for multiple markers by multiplying fitness values for each
marker. If FALSE, fitness is calculated by adding fitness values for each
marker.</p>
</td></tr>
<tr><td><code id="simulate_sequence_migration_+3A_migration_rate">migration_rate</code></td>
<td>
<p>Rate of migration between the two populations.
Migration is implemented such that with probability m (migration rate) one
of the two parents of a new offspring is from the other population, with
probability 1-m both parents are of the focal population.</p>
</td></tr>
<tr><td><code id="simulate_sequence_migration_+3A_stop_at_critical_fst">stop_at_critical_fst</code></td>
<td>
<p>option to stop at a critical FST value
, default is FALSE</p>
</td></tr>
<tr><td><code id="simulate_sequence_migration_+3A_critical_fst">critical_fst</code></td>
<td>
<p>the critical fst value to stop, if
<code>stop_simulation_at_critical_fst</code> is TRUE</p>
</td></tr>
<tr><td><code id="simulate_sequence_migration_+3A_generations_between_update">generations_between_update</code></td>
<td>
<p>The number of generations after which the
simulation has to check again whether the critical Fst value is exceeded</p>
</td></tr>
<tr><td><code id="simulate_sequence_migration_+3A_sampled_individuals">sampled_individuals</code></td>
<td>
<p>Number of individuals to be sampled at random from
the population to estimate Fst</p>
</td></tr>
<tr><td><code id="simulate_sequence_migration_+3A_number_of_markers">number_of_markers</code></td>
<td>
<p>Number of markers to be used to estimate Fst</p>
</td></tr>
<tr><td><code id="simulate_sequence_migration_+3A_random_markers">random_markers</code></td>
<td>
<p>Are the markers to estimate Fst randomly distributed,
or regularly distributed? Default is TRUE.</p>
</td></tr>
<tr><td><code id="simulate_sequence_migration_+3A_mutation_rate">mutation_rate</code></td>
<td>
<p>the per base probability of mutation. Default is 0.</p>
</td></tr>
<tr><td><code id="simulate_sequence_migration_+3A_substitution_matrix">substitution_matrix</code></td>
<td>
<p>a 4x4 matrix representing the probability of
mutating to another base (where [1/2/3/4] = [a/c/t/g]), conditional on the
event of a mutation happening. Default is the JC69 matrix, with equal
probabilities for all transitions / transversions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with: <code>population_1</code>, <code>population_2</code> two population
objects, and three tibbles with allele frequencies (only contain values of a
vector was provided to the argument <code>markers</code>: <code>frequencies</code>,
<code>initial_frequencies</code> and <code>final_frequencies</code>. Each tibble contains
five columns, <code>time</code>, <code>location</code>, <code>ancestor</code>, <code>frequency</code>
and <code>population</code>, which indicates the number of generations, the
location along the chromosome of the marker, the ancestral allele at that
location in that generation, the frequency of that allele and the population
in which it was recorded (1 or 2). If a critical fst value was used to
terminate the simulation, and object <code>FST</code> with the final FST estimate
is returned as well.
</p>

<hr>
<h2 id='simulation_data_to_genomeadmixr_data'>function to convert ped/map data to genome_admixr_data</h2><span id='topic+simulation_data_to_genomeadmixr_data'></span>

<h3>Description</h3>

<p>function to convert ped/map data to genome_admixr_data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulation_data_to_genomeadmixr_data(
  simulation_data,
  markers = NA,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulation_data_to_genomeadmixr_data_+3A_simulation_data">simulation_data</code></td>
<td>
<p>result of simulate_admixture</p>
</td></tr>
<tr><td><code id="simulation_data_to_genomeadmixr_data_+3A_markers">markers</code></td>
<td>
<p>vector of locations of markers (in Morgan). If no vector is
provided, the function searches for marker locations in the simulation_data.</p>
</td></tr>
<tr><td><code id="simulation_data_to_genomeadmixr_data_+3A_verbose">verbose</code></td>
<td>
<p>provide verbose output (default is FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>genomeadmixr_data object ready for simulate_admixture_data
</p>

<hr>
<h2 id='vcfR_to_genomeadmixr_data'>function to convert a vcfR object to genome_admixr_data</h2><span id='topic+vcfR_to_genomeadmixr_data'></span>

<h3>Description</h3>

<p>function to convert a vcfR object to genome_admixr_data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcfR_to_genomeadmixr_data(
  vcfr_object,
  chosen_chromosome,
  number_of_snps = NA,
  random_snps = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcfR_to_genomeadmixr_data_+3A_vcfr_object">vcfr_object</code></td>
<td>
<p>result of vcfR::read.vcfR</p>
</td></tr>
<tr><td><code id="vcfR_to_genomeadmixr_data_+3A_chosen_chromosome">chosen_chromosome</code></td>
<td>
<p>chromosome of choice</p>
</td></tr>
<tr><td><code id="vcfR_to_genomeadmixr_data_+3A_number_of_snps">number_of_snps</code></td>
<td>
<p>number of snps to be loaded from the vcf file, default
is to load all snps</p>
</td></tr>
<tr><td><code id="vcfR_to_genomeadmixr_data_+3A_random_snps">random_snps</code></td>
<td>
<p>if a subset of all snps has to be taken, should these
be sampled sequentially (e.g. the first 100 snps) or randomly (100 randomly
sampled snps) (examples are for 'number_of_snps' = 100).</p>
</td></tr>
<tr><td><code id="vcfR_to_genomeadmixr_data_+3A_verbose">verbose</code></td>
<td>
<p>if true, print progress bar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>genomeadmixr_data object ready for simulate_admixture_data
</p>

<hr>
<h2 id='write_as_plink'>function to write simulation output as PLINK style data</h2><span id='topic+write_as_plink'></span>

<h3>Description</h3>

<p>function to write simulation output as PLINK style data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_as_plink(
  input_pop,
  marker_locations,
  file_name_prefix,
  chromosome = 1,
  recombination_rate = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_as_plink_+3A_input_pop">input_pop</code></td>
<td>
<p>input population, either of class &quot;population&quot; or of class
&quot;genomeadmixr_data&quot;</p>
</td></tr>
<tr><td><code id="write_as_plink_+3A_marker_locations">marker_locations</code></td>
<td>
<p>location of markers, in bp</p>
</td></tr>
<tr><td><code id="write_as_plink_+3A_file_name_prefix">file_name_prefix</code></td>
<td>
<p>prefix of the ped/map files.</p>
</td></tr>
<tr><td><code id="write_as_plink_+3A_chromosome">chromosome</code></td>
<td>
<p>chromosome indication for map file</p>
</td></tr>
<tr><td><code id="write_as_plink_+3A_recombination_rate">recombination_rate</code></td>
<td>
<p>recombination rate in cM / kb</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
