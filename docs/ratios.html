<!DOCTYPE html><html><head><title>Help for package ratios</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ratios}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ratios-package'><p>Ratios of environmental data</p></a></li>
<li><a href='#check_readline'><p>check_readline</p></a></li>
<li><a href='#Correction.AdheringParticles'><p>Correction.AdheringParticles</p></a></li>
<li><a href='#preparationDT2'><p>preparationDT2</p></a></li>
<li><a href='#ratio_append_smallest'><p>ratio_append_smallest</p></a></li>
<li><a href='#ratioDT'><p>ratioDT</p></a></li>
<li><a href='#relError_dataset'><p>relError_dataset</p></a></li>
<li><a href='#select.VarsElements'><p>select.VarsElements</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Calculating Ratios Between Two Data Sets and Correction for
Adhering Particles on Plants</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Solveig Pospiech [aut, cre], 
        Wiebke Fahlbusch [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Solveig Pospiech &lt;s.pospiech@gmx.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculation of ratios between two data sets containing environmental data like
    element concentrations by different methods. Additionally plant element 
    concentrations can be corrected for adhering particles (soil, airborne dust).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stringr, data.table</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-02-18 18:32:13 UTC; solveig</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-02-18 18:39:37 UTC</td>
</tr>
</table>
<hr>
<h2 id='ratios-package'>Ratios of environmental data</h2><span id='topic+ratios'></span><span id='topic+ratios-package'></span>

<h3>Description</h3>

<p>The package provides functions for calculating ratios between two data sets containing environmental data like concentration of elements.
Ratios can be calculated either by method &quot;simple&quot;, &quot;clr&quot; or &quot;alr&quot;.
Additionally for plants the amount of adhering particles on plants can be estimated and the element concentration corrected by subtraction.
</p>


<h3>Details</h3>

<p>Ratios:
</p>
<p>Calculating ratios is at the first glance a simple operation but it becomes quickly more complex if the two data sets don't have corresponding rows or columns.
A set of functions helps to faster and saver calculate ratios:
If for a data set DT1 ratios to a second data set DT2 should be calculated the function <code><a href="#topic+preparationDT2">preparationDT2</a></code> creates a 'new DT2' with equal number of rows and corresponding columns to DT1 with entries and mean of entries from DT2.
Errors are calculated by the function <code><a href="#topic+relError_dataset">relError_dataset</a></code> as well for each data set as for the ratios, too.
The function ratio.DT1_DT2 provides methods for six different types of ratios:
1. simple ratios
2. log ratios
3. ar ratios
4. alr ratios
5. cr ratios
6. clr ratios
</p>
<p>clr and alr ratios are developed from the clr (center logarithmic transformation) and alr (additive logarithmic transformation) concept introduced by Aitchison in 1986 for compositional data, which are data constrained by a constant sum like concentrations of elements.
Hence especially these two methods might be of interest if DT1 and DT2 contain compositional data.
This is probably the case for most environmental data.
The methods 'ar' and 'cr' are the same as 'alr' and 'clr', but without the logarithm.
</p>
<p>Correction for Adhering Particles
</p>
<p>Exact and reproducible analysis of element concentrations in plant tissue is the basis for many research fields such as environmental, health, phytomining, agricultural or provenance studies.
Unfortunately plant samples collected in the field will always contain particles on their tissue surfaces such as airborne dust or soil particles.
If not removed these particles may induce a bias to the element concentrations measured in plant samples.
The influence of adhering particles on element concentration in plants is negligible for elements which have a much higher concentration in the plant tissues compared to the adhering material.
This is the case for most main or minor nutrient elements such as P, K, Ca, Mg, S, Mn, B, Mo, Zn or Cu.
But elements with typically very low concentrations in plant tissue such as Al, Co, Fe, Li, Ni, Ti, Sc, Zr, or REEs, may show significantly altered concentrations measured in the plants due to adhering particles.
Mitchell (1960) proposed that elements with concentration ratios of soil to plant above 100 might show biased concentrations in the measured samples.
</p>
<p>Reducing the impact of adhering particles on trace element concentration in plants is crucial in order to be able to compare elemental composition of plants, e.g. between sampling periods or slightly different sampling methods or for biomonitoring studies.
It is also important in studies for plant nutrition to calculate the real uptake of an element by a plant, e.g. for phytoremediation/phytomining or in studies on the trace elements Co, Ni, Mn and Mo.
</p>
<p>Based on the model that the analyzed plant material is a mixture of plant tissue and a very minor amount of adhering particles we developed a general methods to calculate a correction term for adhering material.
</p>
<p>The function <code><a href="#topic+Correction.AdheringParticles">Correction.AdheringParticles</a></code> provides three different methods to calculate the influence of adhering particles in order to obtain the element concentrations in plants resulting only from uptake.
</p>
<p>For further reading and details please refer to the publication:
Pospiech, S., Fahlbusch, W., Sauer, B., Pasold, T., &amp; Ruppert, H. (2017). Alteration of trace element concentrations in plants by adhering particles–Methods of correction. Chemosphere, 182, 501-508.
</p>

<hr>
<h2 id='check_readline'>check_readline</h2><span id='topic+check_readline'></span>

<h3>Description</h3>

<p>The function checks if a given character string, e.g. value from <code><a href="base.html#topic+readline">readline</a></code>, matches one element of on a given character vector.
Without match it keeps asking for a character string by <code>readline</code> until 'q' for quit or a matching string is provided.
This is often used to avoid crashing of functions due to wrong input in the options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_readline(x, myletters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_readline_+3A_x">x</code></td>
<td>
<p>character vector to be checked, e.g. value from <code><a href="base.html#topic+readline">readline</a></code></p>
</td></tr>
<tr><td><code id="check_readline_+3A_myletters">myletters</code></td>
<td>
<p>character vector of entries which should be allowed, e.g. c(&quot;yes&quot;, &quot;no&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usage is e.g. yesno = check_readline(yesno, c(&quot;y&quot;, &quot;n&quot;)
Now the function will make sure that the variable <em>x</em> consists either of &quot;y&quot; or of &quot;n&quot;.
</p>


<h3>Value</h3>

<p>character vector with one of the values given in <code>myletters</code>
</p>


<h3>Author(s)</h3>

<p>Solveig Pospiech
</p>


<h3>See Also</h3>

<p>Other sub functions: <code><a href="#topic+relError_dataset">relError_dataset</a></code>,
<code><a href="#topic+select.VarsElements">select.VarsElements</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>possibleEntries = c("today", "yesterday")
myEntry = "today"
# or try another entry which is different from "today":
# myEntry = readline("Enter any word (without quotes):   ")
y = check_readline(x = myEntry, myletters = possibleEntries)

</code></pre>

<hr>
<h2 id='Correction.AdheringParticles'>Correction.AdheringParticles</h2><span id='topic+Correction.AdheringParticles'></span>

<h3>Description</h3>

<p>Suppose element data of one data set (DT1) are biased because the concentrations are the result of a mixture of two substances, of which one substance are the element concentrations of DT2.
In order to correct DT1 to <code class="reqn">DT_{corrected}</code> a fraction of DT2 has to be subtracted from DT1.
The basic equation for the correction is:
</p>
<p style="text-align: center;"><code class="reqn">
DT_{corrected}=\frac{DT1 - x * DT2}{1 - x}
</code>
</p>

<p>whereof <em>x</em> is the amount of DT2 to be subtracted.
</p>
<p>The function is written for the case that <em>x</em> is unknown.
To calculate <em>x</em> the condition is that in <code class="reqn">DT_{corrected}</code> at least one element concentration is zero or known.
Suppose <code class="reqn">vars_{i}</code> has a very low concentration, close to zero, in <code class="reqn">DT_{corrected}</code>: <code class="reqn">DT_{corrected}[vars_{i}]=0</code>, then:
</p>
<p style="text-align: center;"><code class="reqn">
x =  \frac{DT1[vars_{i}]}{DT2[vars_{i}]}
</code>
</p>

<p>The function was developed for the use to correct plant concentrations for adhering particles:
Exact and reproducible analysis of element concentrations in plant tissue is the basis for many research fields such as environmental, health, phytomining, agricultural or provenance studies.
Unfortunately plant samples collected in the field will always contain particles on their tissue surfaces such as airborne dust or soil particles.
If not removed these particles may induce a bias to the element concentrations measured in plant samples.
</p>
<p>For full description of the calculations and the background of correction plants for adhering particles please refer to:
</p>
<p>Pospiech, S., Fahlbusch, W., Sauer, B., Pasold, T., &amp; Ruppert, H. (2017). Alteration of trace element concentrations in plants by adhering particles–Methods of correction. <em>Chemosphere, 182, 501-508</em>.
and the section Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Correction.AdheringParticles(DT1, DT2 = NULL, vars = NULL,
  vars_ignore = c("As", "Se", "Sn", "V", "Be", "Ge", "Pt"), method, element,
  id.vars, group1.vars, group2.vars, var_subgroup, offset = 0,
  use_only_DT2 = TRUE, DT2_replace = NULL, Errors = TRUE,
  return_as_list = TRUE, negative_values = FALSE,
  set_statistical_0 = FALSE, Error_method = "gauss", STD_DT1 = STD_Plant,
  STD_DT2 = STD_Soil, minNr_DT1 = 100, minNr_DT2 = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Correction.AdheringParticles_+3A_dt1">DT1</code></td>
<td>
<p>data.frame or data.table, samples in rows and variables in columns</p>
</td></tr>
<tr><td><code id="Correction.AdheringParticles_+3A_dt2">DT2</code></td>
<td>
<p>data.frame or data.table, samples in rows and variables in columns.</p>
</td></tr>
<tr><td><code id="Correction.AdheringParticles_+3A_vars">vars</code></td>
<td>
<p>optional, character vector of column names of DT1 and DT2, default is function <code><a href="#topic+select.VarsElements">select.VarsElements</a></code>.
Please make sure the columns given in <code>vars</code> are of class numeric.</p>
</td></tr>
<tr><td><code id="Correction.AdheringParticles_+3A_vars_ignore">vars_ignore</code></td>
<td>
<p>character vector of column names, only for 'method 3'.
These variables are ignored for calculating the median of amount of DT2 (<em>x</em>) in 'method 3'.
Please note: the functions returns corrected values for these columns because they are only ignored for calculating the median of <em>x</em>.
Default is &quot;As&quot;, &quot;Se&quot;, &quot;Sn&quot;, &quot;V&quot;, &quot;Be&quot;, &quot;Ge&quot; and &quot;Pt&quot;. Please see Details for further explanation.</p>
</td></tr>
<tr><td><code id="Correction.AdheringParticles_+3A_method">method</code></td>
<td>
<p>characters (no character vector!, please give m3 instead of &quot;m3&quot;) denoting the method. Options are <em>m1</em>, <em>m2</em> and <em>m3</em> and <em>subtr</em>.
Default is m3. Please see details.</p>
</td></tr>
<tr><td><code id="Correction.AdheringParticles_+3A_element">element</code></td>
<td>
<p>string, only for method 1. Denotes the column with which amount of DT2 (<em>x</em>) is to be calculated.</p>
</td></tr>
<tr><td><code id="Correction.AdheringParticles_+3A_id.vars">id.vars</code></td>
<td>
<p>column with unique (!) entries for each row. Class can be integer (corresponding row numbers) or character (e.g. sample IDs).
If missing, all columns but <code>vars</code> will be assigned to it.
Please note: Function is faster and more stable if <code>id.vars</code> is provided.</p>
</td></tr>
<tr><td><code id="Correction.AdheringParticles_+3A_group1.vars">group1.vars</code></td>
<td>
<p>character vector, column name(s) for subsetting DT1 and DT2</p>
</td></tr>
<tr><td><code id="Correction.AdheringParticles_+3A_group2.vars">group2.vars</code></td>
<td>
<p>optional, column name for subsetting DT1 and DT2 if some entries in <code>group1.vars</code> are empty.</p>
</td></tr>
<tr><td><code id="Correction.AdheringParticles_+3A_var_subgroup">var_subgroup</code></td>
<td>
<p>optional, character vector of one column name of DT1. This option affects the only the error calculation, hence it is ignored if <code>Errors</code> is set to FALSE.
If provided, DT1 is split into subsets by <code>group1.vars</code> <em>and</em> 'var_subgroup' and the error will calculated for each of these subset.
Please read in the Details for further information.</p>
</td></tr>
<tr><td><code id="Correction.AdheringParticles_+3A_offset">offset</code></td>
<td>
<p>numeric, default is 0. The offset diminishes the subtracted amount of DT2 <em>x</em>: x = x - offset.
If used with m2 all concentrations will stay &gt; 0.
Reasonable offset is e.g. offset = 0.0001</p>
</td></tr>
<tr><td><code id="Correction.AdheringParticles_+3A_use_only_dt2">use_only_DT2</code></td>
<td>
<p>logical, default is FALSE. If there are not enough DT2 data of the location should the DT2s of the region be used? If the <code>use_only_DT2</code> is set to FALSE then the Upper Crust is used for the correction.</p>
</td></tr>
<tr><td><code id="Correction.AdheringParticles_+3A_dt2_replace">DT2_replace</code></td>
<td>
<p>optional, if a DT1 sample does not have DT2 data of the corresponding location with this option you can define which data you would like to use as DT2.
Default is the build-in data set UpperCrust (geochemical composition of the earth's upper crust).
If you would like to have something else, please provide a named vector/ one-row data.table with values used instead of DT2.</p>
</td></tr>
<tr><td><code id="Correction.AdheringParticles_+3A_errors">Errors</code></td>
<td>
<p>logical, should absolute errors get calculated appended to the list - output? Default is FALSE.
If Errors are set to TRUE it overrides the option <code>return_as_list</code> and always returns a list.</p>
</td></tr>
<tr><td><code id="Correction.AdheringParticles_+3A_return_as_list">return_as_list</code></td>
<td>
<p>logical, should the result get returned as list? Default is FALSE.</p>
</td></tr>
<tr><td><code id="Correction.AdheringParticles_+3A_negative_values">negative_values</code></td>
<td>
<p>logical, should negative values be returned? If set to FALSE negative values are set to 0. Default is FALSE.</p>
</td></tr>
<tr><td><code id="Correction.AdheringParticles_+3A_set_statistical_0">set_statistical_0</code></td>
<td>
<p>logical, only for method 3.
Should all values of the variables contributing to the median of <em>x</em> be set to 0? Default is FALSE.</p>
</td></tr>
<tr><td><code id="Correction.AdheringParticles_+3A_error_method">Error_method</code></td>
<td>
<p>method with which the error should be calculated. At the moment you can choose between &quot;gauss&quot; (default) and &quot;biggest&quot;.
See Details for explanation.</p>
</td></tr>
<tr><td><code id="Correction.AdheringParticles_+3A_std_dt1">STD_DT1</code></td>
<td>
<p>optional, data.frame or data.table object for calculating errors for DT1, e.g. the standards. Please see Details. If left empty a default of 5.2% relative error is used.</p>
</td></tr>
<tr><td><code id="Correction.AdheringParticles_+3A_std_dt2">STD_DT2</code></td>
<td>
<p>optional, data.frame or data.table object for calculating errors for DT2, e.g. the standards. Please see Details. If left empty a default of 5.2% relative error is used.</p>
</td></tr>
<tr><td><code id="Correction.AdheringParticles_+3A_minnr_dt1">minNr_DT1</code></td>
<td>
<p>minimum numbers of samples/observations in DT1 for calculating a relative error of observations.
If the number of observations of DT1 is smaller than <code>minNr_DT1</code> the error is calculated via the data set <code>STD_DT1</code>.
Default is 50.</p>
</td></tr>
<tr><td><code id="Correction.AdheringParticles_+3A_minnr_dt2">minNr_DT2</code></td>
<td>
<p>minimum numbers of samples/observations in DT2 for calculating a relative error of observations.
If the number of observations of DT1 is smaller than <code>minNr_DT2</code> the error is calculated via the data set <code>STD_DT2</code>.
Default is 50.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main option of this function is the <code>method</code> which determines how the amount of DT2 to be subtracted, the <em>x</em>, is going to be calculated.
There are four options:
</p>

<ul>
<li><p> Method 1: calculate <em>x</em> via a fixed element
</p>
</li>
<li><p> Method 2: calculate <em>x</em> via the element with the smallest ratio between DT1[vars] and DT2[vars]
</p>
</li>
<li><p> Method 3: calculate <em>x</em> via the median of several, very small ratios between DT1[vars] and DT2[vars]
</p>
</li>
<li><p> Method subtr: calculate the concentrations for <code class="reqn">x * DT2[vars]</code>
</p>
</li></ul>

<p>To Method 1:
For example using Ti as <code>element</code> <code class="reqn">DT_{corrected}</code> is calculated with <code class="reqn"> x = DT1[Ti]/DT2[Ti]</code>.
Typical elements for the option <code>element</code> are e.g. Ti, Al, Zr, Sc, ...
This will eventually lead to negative concentrations for some elements.
</p>
<p>To Method 2:
This method subtracts the smallest possible content of DT2 from DT1 (smallest <em>x</em>).
For each row/sample the element with the smallest <em>x</em> of all ratios <code class="reqn"> x = DT1[vars]/DT2[vars]</code> of each sample is taken as <em>element</em>,
hence every sample is corrected based on a different <em>element</em>.
With this method there are no negative concentrations.
</p>
<p>To Method 3:
In order to reduce the uncertainty of the content of DT2 in DT1 (<em>x</em>) based on only one element as in method 1 and 2 an average of several <em>x</em> of elements can be calculated.
With <code class="reqn">\Delta x</code> being the absolute error of <em>x</em> the median is calculated by all <em>x</em> of elements which values <code class="reqn"> x - \Delta x</code> are smaller than <code class="reqn"> x_{smallest} + \Delta x_{smallest}</code>.
The value of the median <code class="reqn">\bar{x}</code> is then used as <em>x</em>.
This will eventually lead to negative concentrations for some elements.
Because statistically the <em>x</em> of all elements, which error overlaps the error of the element with smallest <em>x</em>, are indistinguishable we suggest to set all elements contributing to <code class="reqn">\bar{x}</code> to zero, because these small values should not be interpreted:
Set option <code>set_statistical_0</code> to TRUE.
</p>
<p>It is advisable to exclude elements with a huge error margin in the option <code>vars_ignore</code> because they could severely increase the median <code class="reqn">\bar{x}</code> by &quot;opening&quot; the window of error-ranges for many elements with significantly higher ratios.
This could lead to an unnatural high median <code class="reqn">\bar{x}</code> resulting into an overcorrection.
</p>
<p>If option <code>id.vars</code> is provided the functions prints the 'group1.vars' and 'id.vars' of the sample.
</p>
<p>For examples and more information please refer to:
Pospiech, S., Fahlbusch, W., Sauer, B., Pasold, T., &amp; Ruppert, H. (2017). Alteration of trace element concentrations in plants by adhering particles–Methods of correction. <em>Chemosphere, 182, 501-508</em>.
</p>


<h3>Value</h3>

<p>data.frame (or data.table if DT1 is data.table) according to <code>method</code>.
</p>


<h3>Author(s)</h3>

<p>Solveig Pospiech
</p>


<h3>See Also</h3>

<p>Other ratio functions: <code><a href="#topic+preparationDT2">preparationDT2</a></code>,
<code><a href="#topic+ratioDT">ratioDT</a></code>,
<code><a href="#topic+ratio_append_smallest">ratio_append_smallest</a></code>
</p>

<hr>
<h2 id='preparationDT2'>preparationDT2</h2><span id='topic+preparationDT2'></span>

<h3>Description</h3>

<p>The function creates a data frame 'new DT2' from the variables <code>vars</code> of the data set DT2 with corresponding rows to the data set DT1,
hence 'new DT2' and DT1 have the same number of rows.
The aim is to generate corresponding rows for two data sets with differing dimensions and even differing number of rows for each group of rows.
For example if for one row i in DT1 there are 3 corresponding rows (j,k,l) in DT2 the function calculates for the 'new DT2' for each variable of <code>vars</code> an average over the rows j,k and l of DT2,
generating only one row corresponding to the row i in DT1.
If on the other hand for row y in DT2 there are 4 corresponding rows in DT1 the 'new DT2' will contain four times the row y of DT2 matching the four rows of DT1.
The column <code>group1.vars</code> (and optional <code>group2.vars</code>) determines which rows of DT1 and DT2 are corresponding, so <code>group1.vars</code> in DT1 is the look-up table for creating the 'new DT2'.
Generally DT1 and DT2 have to have the columns in common which are given in <code>group1.vars</code>, <code>group2.vars</code> and <code>vars</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preparationDT2(DT1, DT2, vars = NULL, group1.vars, group2.vars = NULL,
  Errors = FALSE, use_only_DT2 = FALSE, DT2_replace = NULL, minNr = 7,
  STD = NULL, return_as_list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preparationDT2_+3A_dt1">DT1</code></td>
<td>
<p>data.frame or data.table, samples in rows and variables in columns</p>
</td></tr>
<tr><td><code id="preparationDT2_+3A_dt2">DT2</code></td>
<td>
<p>data.frame or data.table, samples in rows and variables in columns.</p>
</td></tr>
<tr><td><code id="preparationDT2_+3A_vars">vars</code></td>
<td>
<p>optional, character vector of column names of DT1 and DT2, default is function <code><a href="#topic+select.VarsElements">select.VarsElements</a></code>.
Please make sure the columns given in <code>vars</code> are of class numeric.</p>
</td></tr>
<tr><td><code id="preparationDT2_+3A_group1.vars">group1.vars</code></td>
<td>
<p>character vector, column name(s) for subsetting DT1 and DT2</p>
</td></tr>
<tr><td><code id="preparationDT2_+3A_group2.vars">group2.vars</code></td>
<td>
<p>optional, column name for subsetting DT1 and DT2 if some entries in <code>group1.vars</code> are empty.</p>
</td></tr>
<tr><td><code id="preparationDT2_+3A_errors">Errors</code></td>
<td>
<p>logical, should absolute errors get calculated appended to the list - output? Default is FALSE.
If Errors are set to TRUE it overrides the option <code>return_as_list</code> and always returns a list.</p>
</td></tr>
<tr><td><code id="preparationDT2_+3A_use_only_dt2">use_only_DT2</code></td>
<td>
<p>logical, default is FALSE. If there are not enough DT2 data of the location should the DT2s of the region be used? If the <code>use_only_DT2</code> is set to FALSE then the Upper Crust is used for the correction.</p>
</td></tr>
<tr><td><code id="preparationDT2_+3A_dt2_replace">DT2_replace</code></td>
<td>
<p>mandatory if <code>use_only_DT2</code> is set to FALSE, serves as substitute for DT2 where DT2 has no corresponding rows to DT1.
A named vector or one-row data.table/ data.frame with the all <code>vars</code> present.
A column for <code>group1.vars</code> is not necessary.</p>
</td></tr>
<tr><td><code id="preparationDT2_+3A_minnr">minNr</code></td>
<td>
<p>minimum numbers of samples/observations for calculating a relative error of observations.
If the number of samples of <code>DT2</code> is smaller than <code>minNr</code> the error is calculated via the data set STD.</p>
</td></tr>
<tr><td><code id="preparationDT2_+3A_std">STD</code></td>
<td>
<p>data set for calculating the relative errors if in DT2 there are less rows per group than <code>minNr</code>.
This replacement data set could for e.g. consist of reference standards with repeated measurement for each standard.</p>
</td></tr>
<tr><td><code id="preparationDT2_+3A_return_as_list">return_as_list</code></td>
<td>
<p>logical, should the result get returned as list? Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data set 'new DT2' is generated according to following rules:
If there is more than one row in DT2 with the same entry for <code>group1.vars</code> for each column in <code>vars</code> an average (mean) of these rows of DT2 is calculated.
After this operation there is only one row for each entry value of <code>group1.vars</code>.
Each row of this averaged DT2 is replicated n times, with n being the number of rows of the subset of DT1 with the corresponding value in <code>group1.vars</code>.
If there are values in column <code>group1.vars</code> in DT1 which are not in DT2 and if option <code>use_only_DT2</code> is set to <code>TRUE</code> empty rows are generated.
If option <code>use_only_DT2</code> is set to <code>FALSE</code>, data from 'DT2_replace' are taken as substitute for DT2 to fill these empty rows.
The default 'DT2_replace' are element concentrations from the UpperCrust (Rudnick, R. L., &amp; Gao, S. 2003. Composition of the continental crust. <em>Treatise on geochemistry, 3</em>, 659.)
</p>


<h3>Value</h3>

<p>data.frame, data.table or a list, controlled by option <code>return_as_list</code>.
If <code>Errors</code> is set to TRUE <code>return_as_list</code> is ignored and return value is always a list.
The list contains one element if <code>Errors</code> is set to FALSE and two elements if <code>Errors</code> is TRUE:
[[1]] is data.table or data.frame of corresponding DT2s, [[2]] data.table or data.frame of absolute errors of corresponding DT2s.
</p>


<h3>Author(s)</h3>

<p>Solveig Pospiech
</p>


<h3>See Also</h3>

<p>Other ratio functions: <code><a href="#topic+Correction.AdheringParticles">Correction.AdheringParticles</a></code>,
<code><a href="#topic+ratioDT">ratioDT</a></code>,
<code><a href="#topic+ratio_append_smallest">ratio_append_smallest</a></code>
</p>

<hr>
<h2 id='ratio_append_smallest'>ratio_append_smallest</h2><span id='topic+ratio_append_smallest'></span>

<h3>Description</h3>

<p>The function appends for each row the smallest ratio DT1/DT2 in the column <em>ratio_smallest</em>.
The name of the column which contained the smallest ratio is appended in the column <em>ratio_smallest_Elem</em>.
This function is basically a sub-function for the function <code><a href="#topic+Correction.AdheringParticles">Correction.AdheringParticles</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ratio_append_smallest(Ratios, vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ratio_append_smallest_+3A_ratios">Ratios</code></td>
<td>
<p>list, data.frame or data.table, which is the output after using the function <code><a href="#topic+ratioDT">ratioDT</a></code></p>
</td></tr>
<tr><td><code id="ratio_append_smallest_+3A_vars">vars</code></td>
<td>
<p>optional, character vector of column names of DT1 and DT2, default is function <code><a href="#topic+select.VarsElements">select.VarsElements</a></code>.
Please make sure the columns given in <code>vars</code> are of class numeric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with [[1]] being the data set from the input with one column added containing the smallest ratio of all variables given in <code>vars</code>.
If the input was a list with one element named &quot;ratios_error&quot; the returned list contains a second element [[2]] &quot;ratios_error&quot; also with the appended columns.
</p>


<h3>Author(s)</h3>

<p>Solveig Pospiech
</p>


<h3>See Also</h3>

<p>Other ratio functions: <code><a href="#topic+Correction.AdheringParticles">Correction.AdheringParticles</a></code>,
<code><a href="#topic+preparationDT2">preparationDT2</a></code>, <code><a href="#topic+ratioDT">ratioDT</a></code>
</p>

<hr>
<h2 id='ratioDT'>ratioDT</h2><span id='topic+ratioDT'></span><span id='topic+ratio_DT1_DT2'></span>

<h3>Description</h3>

<p>The function calculates ratios of corresponding variables and corresponding rows between two data sets, DT1 and DT2.
The result is a data set with the same dimensions as DT1.
The variables can be specified by <code>vars</code>, without specification the subfunction <code><a href="#topic+select.VarsElements">select.VarsElements</a></code> matches column names with element abbreviations.
Which row of DT1 corresponds to which row in DT2 has to be specified by the variable(s) <code>group1.vars</code> (and optional <code>group2.vars</code>).
If DT2 has different number of rows than DT1 a 'new DT2' with equal dimensions to DT1 is prepared by the function <code><a href="#topic+preparationDT2">preparationDT2</a></code>.
At the moment there are three different options for calculating the ratios:
</p>

<ul>
<li><p> &quot;simple&quot;
</p>
</li>
<li><p> &quot;log&quot;
</p>
</li>
<li><p> &quot;ar&quot;
</p>
</li>
<li><p> &quot;alr&quot;
</p>
</li>
<li><p> &quot;cr&quot;
</p>
</li>
<li><p> &quot;clr&quot;
</p>
</li></ul>

<p>For more details please refer to <code><a href="#topic+preparationDT2">preparationDT2</a></code> and section Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ratioDT(DT1, DT2, vars = NULL, group1.vars, group2.vars = NULL,
  ratio_type = "simple", vars.ref, id.vars, Errors = FALSE,
  Error_method = "gauss", var_subgroup = NULL, use_only_DT2 = FALSE,
  DT2_replace = NULL, STD_DT1, STD_DT2, minNr_DT1 = 50, minNr_DT2 = 50,
  return_all = FALSE, return_as_list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ratioDT_+3A_dt1">DT1</code></td>
<td>
<p>data.frame or data.table, samples in rows and variables in columns</p>
</td></tr>
<tr><td><code id="ratioDT_+3A_dt2">DT2</code></td>
<td>
<p>data.frame or data.table, samples in rows and variables in columns.</p>
</td></tr>
<tr><td><code id="ratioDT_+3A_vars">vars</code></td>
<td>
<p>optional, character vector of column names of DT1 and DT2, default is function <code><a href="#topic+select.VarsElements">select.VarsElements</a></code>.
Please make sure the columns given in <code>vars</code> are of class numeric.</p>
</td></tr>
<tr><td><code id="ratioDT_+3A_group1.vars">group1.vars</code></td>
<td>
<p>character vector, column name(s) for subsetting DT1 and DT2</p>
</td></tr>
<tr><td><code id="ratioDT_+3A_group2.vars">group2.vars</code></td>
<td>
<p>optional, column name for subsetting DT1 and DT2 if some entries in <code>group1.vars</code> are empty.</p>
</td></tr>
<tr><td><code id="ratioDT_+3A_ratio_type">ratio_type</code></td>
<td>
<p>character vector of &quot;simple&quot;, &quot;log&quot;, &quot;ar&quot;, &quot;alr&quot;, &quot;cr&quot; and &quot;clr&quot;.
Please refer to details for explanations.</p>
</td></tr>
<tr><td><code id="ratioDT_+3A_vars.ref">vars.ref</code></td>
<td>
<p>reference variable, one out of <code>vars</code>. Only for <code>ratio_type</code> &quot;ar&quot; or &quot;alr&quot;.</p>
</td></tr>
<tr><td><code id="ratioDT_+3A_id.vars">id.vars</code></td>
<td>
<p>column with unique (!) entries for each row. Class can be integer (corresponding row numbers) or character (e.g. sample IDs).
If missing, all columns but <code>vars</code> will be assigned to it.
Please note: Function is faster and more stable if <code>id.vars</code> is provided.</p>
</td></tr>
<tr><td><code id="ratioDT_+3A_errors">Errors</code></td>
<td>
<p>logical, should absolute errors get calculated appended to the list - output? Default is FALSE.
If Errors are set to TRUE it overrides the option <code>return_as_list</code> and always returns a list.</p>
</td></tr>
<tr><td><code id="ratioDT_+3A_error_method">Error_method</code></td>
<td>
<p>method with which the error should be calculated. At the moment you can choose between &quot;gauss&quot; (default) and &quot;biggest&quot;.
See Details for explanation.</p>
</td></tr>
<tr><td><code id="ratioDT_+3A_var_subgroup">var_subgroup</code></td>
<td>
<p>optional, character vector of one column name of DT1. This option affects the only the error calculation, hence it is ignored if <code>Errors</code> is set to FALSE.
If provided, DT1 is split into subsets by <code>group1.vars</code> <em>and</em> 'var_subgroup' and the error will calculated for each of these subset.
Please read in the Details for further information.</p>
</td></tr>
<tr><td><code id="ratioDT_+3A_use_only_dt2">use_only_DT2</code></td>
<td>
<p>logical, default is FALSE. If there are not enough DT2 data of the location should the DT2s of the region be used? If the <code>use_only_DT2</code> is set to FALSE then the Upper Crust is used for the correction.</p>
</td></tr>
<tr><td><code id="ratioDT_+3A_dt2_replace">DT2_replace</code></td>
<td>
<p>mandatory if <code>use_only_DT2</code> is set to FALSE, serves as substitute for DT2 where DT2 has no corresponding rows to DT1.
A named vector or one-row data.table/ data.frame with the all <code>vars</code> present.
A column for <code>group1.vars</code> is not necessary.</p>
</td></tr>
<tr><td><code id="ratioDT_+3A_std_dt1">STD_DT1</code></td>
<td>
<p>optional, data.frame or data.table object for calculating errors for DT1, e.g. the standards. Please see Details. If left empty a default of 5.2% relative error is used.</p>
</td></tr>
<tr><td><code id="ratioDT_+3A_std_dt2">STD_DT2</code></td>
<td>
<p>optional, data.frame or data.table object for calculating errors for DT2, e.g. the standards. Please see Details. If left empty a default of 5.2% relative error is used.</p>
</td></tr>
<tr><td><code id="ratioDT_+3A_minnr_dt1">minNr_DT1</code></td>
<td>
<p>minimum numbers of samples/observations in DT1 for calculating a relative error of observations.
If the number of observations of DT1 is smaller than <code>minNr_DT1</code> the error is calculated via the data set <code>STD_DT1</code>.
Default is 50.</p>
</td></tr>
<tr><td><code id="ratioDT_+3A_minnr_dt2">minNr_DT2</code></td>
<td>
<p>minimum numbers of samples/observations in DT2 for calculating a relative error of observations.
If the number of observations of DT1 is smaller than <code>minNr_DT2</code> the error is calculated via the data set <code>STD_DT2</code>.
Default is 50.</p>
</td></tr>
<tr><td><code id="ratioDT_+3A_return_all">return_all</code></td>
<td>
<p>logical, should <em>all</em> used data sets be returned as a list? Default is FALSE.
If set to TRUE the list contains DT1, DT2, vars, ratios, and optional additional ratios_error, DT1_error and DT2_error.</p>
</td></tr>
<tr><td><code id="ratioDT_+3A_return_as_list">return_as_list</code></td>
<td>
<p>logical, should the result get returned as list? Default is FALSE.
If set to FALSE and <code>Errors</code> is set to TRUE a column <code>type_of_data</code> is appended.
This option is ignored if option 'return_all' is set to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To calculate the ratios the functions internally calls <code><a href="#topic+preparationDT2">preparationDT2</a></code> to create a data set 'new DT2' from the variables <code>vars</code> of DT2, which has equal number of rows to DT1.
Then the division is done by the now corresponding data sets by the method given in 'ratio_type'.
</p>
<p>The method &quot;simple&quot; is a simple division between DT1 and DT2:
</p>
<p style="text-align: center;"><code class="reqn">
\frac{DT1[vars]}{DT2[vars]}
</code>
</p>

<p>The method &quot;log&quot; is the logarithm of the simple ratio:
</p>
<p style="text-align: center;"><code class="reqn"> ln \left( \frac{DT1[vars]}{DT2[vars]} \right)</code>
</p>

<p>The methods &quot;ar&quot; and &quot;alr&quot; normalize all ratios to one reference column:
ar:
</p>
<p style="text-align: center;"><code class="reqn">
\frac{DT1[vars_{i}]}{DT2[vars_{i}]} * \frac{DT2[vars_n]}{DT1[vars_n]}_{i=1,\dots, n, \dots, D}
</code>
</p>

<p>alr:
</p>
<p style="text-align: center;"><code class="reqn">
ln \left(\frac{DT1[vars_{i}]}{DT2[vars_{i}]} * \frac{DT2[vars_n]}{DT1[vars_n]}\right)_{i=1,\dots, n, \dots, D}
</code>
</p>

<p>The methods &quot;cr&quot; and &quot;clr&quot; normalize all ratios to the geometric mean of all columns included by <code>vars</code>:
&quot;cr&quot; is calculated by:
</p>
<p style="text-align: center;"><code class="reqn">
\frac{DT1[vars_{i}]}{DT2[vars_{i}]} * \frac{g(x)^{DT2[vars]}}{g(x)^{DT1[vars]}}_{i=1,\dots, D}
</code>
</p>

<p>whereof the function g(x) stands for:
</p>
<p style="text-align: center;"><code class="reqn">g(x) = \sqrt[D]{DT[vars_1] \cdot DT[vars_2] \cdots DT[vars_D]} </code>
</p>

<p>and &quot;clr&quot; is calculated by:
</p>
<p style="text-align: center;"><code class="reqn">
 ln \left(\frac{DT1[vars_{i}]}{DT2[vars_{i}]} * \frac{g(x)^{DT2[vars]}}{g(x)^{DT1[vars]}}\right)_{i=1,\dots, D}
</code>
</p>

<p>The methods &quot;clr&quot; and &quot;alr&quot; should be considered if the data contain so called <em>compositional data</em> as defined by Aitchison, J. (1986): &quot;The statistical analysis of compositional data&quot;.
They names correspond to the names used in the package <code>compositions</code> by K. Gerald van den Boogaart, Raimon Tolosana and Matevz Bren.
</p>
<p>Calculating the absolute error for the ratios requires calculating the absolute errors of DT1 and DT2, too.
For calculating the errors of DT1 and DT2 the function <code><a href="#topic+relError_dataset">relError_dataset</a></code> is used.
Accordingly the options for <code>STD_DT1</code> and <code>STD_DT2</code> are passed to the option <code>STD</code> in <code>relError_dataset</code>.
If STD_DT1 and/or STD_DT2 are left empty the default of 5.2% relative error is used.
Also the options <code>minNr_DT1</code> and <code>minNr_DT2</code> are passed to the option <code>minNr</code> in <code>relError_dataset</code>.
</p>
<p>The <code>Error_method</code> determines how the absolute error of the ratios is calculated.
The error method &quot;gauss&quot; refers to the error propagation after Gauss:
</p>
<p style="text-align: center;"><code class="reqn">
\Delta x =  \frac{\Delta DT1}{DT2} - DT1 * \frac{\Delta DT2}{DT2^2}
</code>
</p>

<p>The error method &quot;biggest&quot; refers to the maximum error after Gauss:
</p>
<p style="text-align: center;"><code class="reqn">
\Delta x =  \frac{\Delta DT1}{DT2} + DT1 * \frac{\Delta DT2}{DT2^2}
</code>
</p>

<p>For example:
If you have in DT1 plant samples with <code>group1.vars = "Location"</code> the error function would calculate the relative standard deviation for all plants of one location.
But maybe you have very different plants in one location so setting <code>var_subgroup = "Species"</code> the error function will calculate the relative standard deviation for each plant species per location, if there are more species per location than given in <code>minNr_DT1</code>.
Suppose DT2 are soil data with several samples per location.
If <code>group1.vars = "Location"</code> than the function calls <code><a href="#topic+preparationDT2">preparationDT2</a></code> and calculates a mean for each location from the data set.
The ratio from plant to soil and the absolute errors of the ratios is then calculated for each plant sample to a mean of soils from one location.
</p>


<h3>Value</h3>

<p>The function returns either a data.table, data.frame or a list controlled by the option <code>return_as_list</code>.
If <code>return_as_list</code> to FALSE a data.frame (or data.table if DT1 is of class data.table) is returned.
If option <code>Errors</code> is set to TRUE ratios and error are combined into one object and a column <code>type_of_data</code> is appended with the entries <em>ratio</em> and <em>ratio_error</em> respectively.
If <code>return_as_list</code> to TRUE the DT1-DT2-ratios are named in the list as &quot;ratios&quot; and, if <code>Errors</code> is set to TRUE the absolute errors of the ratios are saved in the list as &quot;ratios_error&quot;.
If 'return_all' is set to TRUE a list with the following entries will be returned:
</p>
<p>[[1]] &quot;DT1&quot;, [[2]] &quot;DT2&quot;, [[3]] &quot;vars&quot;, [[4]] &quot;ratios&quot; and if <code>Errors</code> is set to TRUE additionally [[5]] &quot;ratios_error&quot;, [[6]] &quot;DT1_error&quot;, [[7]] &quot;DT2_error&quot;.
</p>


<h3>Author(s)</h3>

<p>Solveig Pospiech
</p>


<h3>See Also</h3>

<p>Other ratio functions: <code><a href="#topic+Correction.AdheringParticles">Correction.AdheringParticles</a></code>,
<code><a href="#topic+preparationDT2">preparationDT2</a></code>,
<code><a href="#topic+ratio_append_smallest">ratio_append_smallest</a></code>
</p>

<hr>
<h2 id='relError_dataset'>relError_dataset</h2><span id='topic+relError_dataset'></span>

<h3>Description</h3>

<p>The function calculates for each observation for every variable 'vars' in 'Data' the relative error by median absolute deviation (<code><a href="stats.html#topic+mad">mad</a></code>) and median (<code><a href="stats.html#topic+median">median</a></code>):
</p>
<p style="text-align: center;"><code class="reqn">
\delta Data[vars_{i}] = \frac{mad(Data[vars_{i}], na.rm = T)}{median(Data[vars_{i}], na.rm = T)}
</code>
</p>

<p>The observations (e.g. samples) are subset into groups by the column <code>group1.vars</code>.
The relative error is calculated by 'Data' if there are more than 'minNr' entries for each subset of observations.
If there are less observations than 'minNr' for a group in 'Data' than the relative error will be calculated by a replacement data set 'STD',
e.g. you could use a data set of standard reference samples measured at the same machine as your samples.
If you would like to calculate the relative error of all observations in 'Data' set <code>group1.vars</code> to the column of your sample ID (column with unique entries) and set minNr = 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relError_dataset(Data, vars, group1.vars, group2.vars = NULL, minNr = 7,
  STD)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relError_dataset_+3A_data">Data</code></td>
<td>
<p>a data.frame or matrix with samples (observations) as rows.</p>
</td></tr>
<tr><td><code id="relError_dataset_+3A_vars">vars</code></td>
<td>
<p>optional, character vector of variables of 'Data' for which the error should be calculated.
If left empty the function <code><a href="#topic+select.VarsElements">select.VarsElements</a></code> will try to find element abbreviations in the variables of 'Data' and 'STD' if STD is provided.</p>
</td></tr>
<tr><td><code id="relError_dataset_+3A_group1.vars">group1.vars</code></td>
<td>
<p>character vector of variables in 'Data' for splitting 'Data' into subsets. Error will be calculated for each subset.</p>
</td></tr>
<tr><td><code id="relError_dataset_+3A_group2.vars">group2.vars</code></td>
<td>
<p>optional, if a variable name of 'Data' is given here a second splitting by <code>group1.vars</code> + <code>group2.vars</code> into subsets is performed.
If for grouping by <code>group1.vars</code> for one subset there are less entries than 'minNr' the function will look up in the second subset
if there are enough entries (&gt; minNr) in the group2 corresponding to group1.
For example if <code>group1.vars</code> = &quot;Month&quot; then <code>group2.vars</code> = &quot;Year&quot; would fill up the gaps if in one month there had been less than 'minNr' observations.</p>
</td></tr>
<tr><td><code id="relError_dataset_+3A_minnr">minNr</code></td>
<td>
<p>minimum numbers of samples/observations for calculating a relative error of observations.
If the number of samples of <code>Data</code> is smaller than <code>minNr</code> the error is calculated via the data set STD.</p>
</td></tr>
<tr><td><code id="relError_dataset_+3A_std">STD</code></td>
<td>
<p>data set for calculating the relative errors if in <code>Data</code> there are less rows per group than <code>minNr</code>.
This replacement data set could for e.g. consist of reference standards with repeated measurement for each standard.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame or data.table with relative errors for each observation of 'Data'.
</p>


<h3>Author(s)</h3>

<p>Solveig Pospiech
</p>


<h3>See Also</h3>

<p>Other sub functions: <code><a href="#topic+check_readline">check_readline</a></code>,
<code><a href="#topic+select.VarsElements">select.VarsElements</a></code>
</p>

<hr>
<h2 id='select.VarsElements'>select.VarsElements</h2><span id='topic+select.VarsElements'></span>

<h3>Description</h3>

<p>The function returns a character vector of element abbreviations if the input object contained variables with element abbreviations.
Input may be data.frame, matrix, character vector or named numeric.
There are two options to use this functions:
</p>

<ul>
<li><p> A) only one object
</p>
</li>
<li><p> B) with two objects
</p>
</li></ul>

<p>For A) the function checks for the pattern of element abbreviations, e.g. Al, S, Ca, etc.
For B) the function checks for element abbreviations which are present in both objects. E.g. if x = c(&quot;Al&quot;, &quot;Ba&quot;, &quot;Ca&quot;) and y = c(&quot;Ba&quot;, &quot;K&quot;, &quot;Th&quot;) the return value will be &quot;Ba&quot;.
The resulting character vector is without duplicated entries, e.g. x = c(&quot;N&quot;, &quot;P&quot;, &quot;S&quot;, &quot;S&quot;) results into c(&quot;N&quot;, &quot;P&quot;, &quot;S&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select.VarsElements(x, y, invert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.VarsElements_+3A_x">x</code></td>
<td>
<p>data.frame, character vector or named numeric containing element abbreviations as variables</p>
</td></tr>
<tr><td><code id="select.VarsElements_+3A_y">y</code></td>
<td>
<p>optional, data.frame, character vector or named numeric containing element abbreviations as variables</p>
</td></tr>
<tr><td><code id="select.VarsElements_+3A_invert">invert</code></td>
<td>
<p>logical. If TRUE return variable names that do not match an element abbreviation pattern</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of element abbreviations
</p>


<h3>Author(s)</h3>

<p>Solveig Pospiech
</p>


<h3>See Also</h3>

<p>Other sub functions: <code><a href="#topic+check_readline">check_readline</a></code>,
<code><a href="#topic+relError_dataset">relError_dataset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c("Al", "Ba", "Ca")
y = c("Ba", "K", "Th")
select.VarsElements(x, y)

myvector = c("Al", "Location", "Date", "S", "Ba", "OH")
select.VarsElements(myvector)
select.VarsElements(myvector, invert = TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
