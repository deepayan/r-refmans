<!DOCTYPE html><html lang="en-US"><head><title>Help for package nodbi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nodbi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nodbi-package'><p>Document database connector</p></a></li>
<li><a href='#contacts'><p>Data set 'contacts'</p></a></li>
<li><a href='#diamonds'><p>Data set 'diamonds'</p></a></li>
<li><a href='#docdb_create'><p>Create documents in a database</p></a></li>
<li><a href='#docdb_delete'><p>Delete documents or container</p></a></li>
<li><a href='#docdb_exists'><p>Check if container exists in database</p></a></li>
<li><a href='#docdb_get'><p>Get all documents from container in database</p></a></li>
<li><a href='#docdb_list'><p>List containers in database</p></a></li>
<li><a href='#docdb_query'><p>Get documents or parts with filtering query</p></a></li>
<li><a href='#docdb_update'><p>Update documents</p></a></li>
<li><a href='#mapdata'><p>Data set 'mapdata'</p></a></li>
<li><a href='#src'><p>Setup database connections</p></a></li>
<li><a href='#src_couchdb'><p>Setup a CouchDB database connection</p></a></li>
<li><a href='#src_duckdb'><p>Setup a DuckDB database connection</p></a></li>
<li><a href='#src_elastic'><p>Setup an Elasticsearch database connection</p></a></li>
<li><a href='#src_mongo'><p>Setup a MongoDB database connection</p></a></li>
<li><a href='#src_postgres'><p>Setup a PostgreSQL database connection</p></a></li>
<li><a href='#src_sqlite'><p>Setup a RSQLite database connection</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>'NoSQL' Database Connector</td>
</tr>
<tr>
<td>Description:</td>
<td>Simplified JSON document database access and manipulation,
     providing a common API across supported 'NoSQL' databases 
     'Elasticsearch', 'CouchDB', 'MongoDB' as well as 
     'SQLite/JSON1', 'PostgreSQL', and 'DuckDB'.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.11.0</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/nodbi/">https://docs.ropensci.org/nodbi/</a>,
<a href="https://github.com/ropensci/nodbi">https://github.com/ropensci/nodbi</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/nodbi/issues">https://github.com/ropensci/nodbi/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Imports:</td>
<td>stringi, jsonlite, uuid, jqr, DBI, V8, R.utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sofa, elastic, mongolite, RSQLite, duckdb, RPostgres,
testthat, withr, callr, webfakes, knitr, rmarkdown, tibble</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>X-schema.org-applicationCategory:</td>
<td>Databases</td>
</tr>
<tr>
<td>X-schema.org-keywords:</td>
<td>database, MongoDB, Elasticsearch, CouchDB,
SQLite, PostgreSQL, DuckDB, NoSQL, JSON, documents</td>
</tr>
<tr>
<td>X-schema.org-isPartOf:</td>
<td>https://ropensci.org</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-10 15:07:48 UTC; ralfherold</td>
</tr>
<tr>
<td>Author:</td>
<td>Ralf Herold <a href="https://orcid.org/0000-0002-8148-6748"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Scott Chamberlain <a href="https://orcid.org/0000-0003-1444-9135"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Rich FitzJohn [aut],
  Jeroen Ooms [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ralf Herold &lt;ralf.herold@mailbox.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-10 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='nodbi-package'>Document database connector</h2><span id='topic+nodbi'></span><span id='topic+nodbi-package'></span>

<h3>Description</h3>

<p>Simplified document database access and manipulation,
providing a common API across supported 'NoSQL' databases
'Elasticsearch', 'CouchDB', 'MongoDB' as well as
'SQLite/JSON1', 'PostgreSQL' and 'DuckDB'.
</p>


<h3>Author(s)</h3>

<p>Ralf Herold <a href="mailto:ralf.herold@mailbox.org">ralf.herold@mailbox.org</a>
</p>
<p>Scott Chamberlain <a href="mailto:sckott@protonmail.com">sckott@protonmail.com</a>
</p>
<p>Rich FitzJohn <a href="mailto:rich.fitzjohn@gmail.com">rich.fitzjohn@gmail.com</a>
</p>
<p>Jeroen Ooms <a href="mailto:jeroen.ooms@stat.ucla.edu">jeroen.ooms@stat.ucla.edu</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://docs.ropensci.org/nodbi/">https://docs.ropensci.org/nodbi/</a>
</p>
</li>
<li> <p><a href="https://github.com/ropensci/nodbi">https://github.com/ropensci/nodbi</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ropensci/nodbi/issues">https://github.com/ropensci/nodbi/issues</a>
</p>
</li></ul>


<hr>
<h2 id='contacts'>Data set 'contacts'</h2><span id='topic+contacts'></span>

<h3>Description</h3>

<p>Data set 'contacts'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contacts
</code></pre>


<h3>Format</h3>

<p>A JSON string with ragged, nested contact details
</p>

<hr>
<h2 id='diamonds'>Data set 'diamonds'</h2><span id='topic+diamonds'></span>

<h3>Description</h3>

<p>Data set 'diamonds'
</p>


<h3>Format</h3>

<p>A data frame with 53940 rows and 10 variables:
</p>

<ul>
<li><p> price price in US dollars (326-18,823 USD)
</p>
</li>
<li><p> carat weight of the diamond (0.2-5.01)
</p>
</li>
<li><p> cut quality of the cut (Fair, Good, Very Good, Premium, Ideal)
</p>
</li>
<li><p> color diamond colour, from J (worst) to D (best)
</p>
</li>
<li><p> clarity a measurement of how clear the diamond is (I1 (worst),
SI1, SI2, VS1, VS2, VVS1, VVS2, IF (best))
</p>
</li>
<li><p> x length in mm (0-10.74)
</p>
</li>
<li><p> y width in mm (0-58.9)
</p>
</li>
<li><p> z depth in mm (0-31.8)
</p>
</li>
<li><p> depth total depth percentage = z / mean(x, y) = 2 * z / (x + y)
(43-79)
</p>
</li>
<li><p> table width of top of diamond relative to widest point (43-95)
</p>
</li></ul>



<h3>Source</h3>

<p>from <span class="pkg">ggplot2</span>
</p>

<hr>
<h2 id='docdb_create'>Create documents in a database</h2><span id='topic+docdb_create'></span>

<h3>Description</h3>

<p>A message is emitted if the container <code>key</code> already exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docdb_create(src, key, value, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="docdb_create_+3A_src">src</code></td>
<td>
<p>Source object, result of call to any of functions
<code><a href="#topic+src_mongo">src_mongo()</a></code>, <code><a href="#topic+src_sqlite">src_sqlite()</a></code>, <code><a href="#topic+src_elastic">src_elastic()</a></code>, <code><a href="#topic+src_couchdb">src_couchdb()</a></code>
<code><a href="#topic+src_duckdb">src_duckdb()</a></code> or <code><a href="#topic+src_postgres">src_postgres()</a></code></p>
</td></tr>
<tr><td><code id="docdb_create_+3A_key">key</code></td>
<td>
<p>(character) The name of the container in the
database backend (corresponds to <code>collection</code> for MongoDB,
<code>dbname</code> for CouchDB, <code>index</code> for Elasticsearch, and to
a table name for DuckDB, SQLite and PostgreSQL)</p>
</td></tr>
<tr><td><code id="docdb_create_+3A_value">value</code></td>
<td>
<p>The data to be created in the database:
a single data.frame, a JSON string, a list, or a
file name or URL that points to NDJSON documents</p>
</td></tr>
<tr><td><code id="docdb_create_+3A_...">...</code></td>
<td>
<p>Passed to functions <code><a href="sofa.html#topic+db_bulk_create">sofa::db_bulk_create()</a></code>,
<code><a href="elastic.html#topic+docs_bulk">elastic::docs_bulk()</a></code>, and <code><a href="mongolite.html#topic+mongo">mongolite::mongo()</a></code>$insert()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An error is raised for document(s) in <code>value</code> when their
<code style="white-space: pre;">&#8288;_id&#8288;</code> already exist(s) in the collection <code>key</code>;
use <code><a href="#topic+docdb_update">docdb_update()</a></code> to update such document(s).
</p>


<h3>Value</h3>

<p>(integer) Number of successfully created documents
</p>


<h3>Identifiers</h3>

<p>If <code>value</code> is a data.frame that has a column <code style="white-space: pre;">&#8288;_id&#8288;</code>,
or is a JSON string having a key <code style="white-space: pre;">&#8288;_id&#8288;</code> at root level,
or is a list having an item <code style="white-space: pre;">&#8288;_id&#8288;</code> at its top level,
this will be used as <code style="white-space: pre;">&#8288;_id&#8288;</code>'s and primary index
in the database. If there are no such <code style="white-space: pre;">&#8288;_id&#8288;</code>'s in <code>value</code>,
row names (if any exist) of <code>value</code> will be used as <code style="white-space: pre;">&#8288;_id&#8288;</code>'s,
otherwise random <code style="white-space: pre;">&#8288;_id&#8288;</code>'s will be created (using
<code><a href="uuid.html#topic+UUIDgenerate">uuid::UUIDgenerate()</a></code> with <code>use.time = TRUE</code> for
SQLite and PostgreSQL, or using DuckDB's built-in <code>uuid()</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
src &lt;- src_sqlite()
docdb_create(src,
  key = "diamonds_small",
  value = as.data.frame(diamonds[1:3000L, ])
)
head(docdb_get(src, "diamonds_small"))
docdb_create(src, key = "contacts", value = contacts)
docdb_get(src, "contacts")[["friends"]]

## End(Not run)

</code></pre>

<hr>
<h2 id='docdb_delete'>Delete documents or container</h2><span id='topic+docdb_delete'></span>

<h3>Description</h3>

<p>Delete documents or container
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docdb_delete(src, key, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="docdb_delete_+3A_src">src</code></td>
<td>
<p>Source object, result of call to any of functions
<code><a href="#topic+src_mongo">src_mongo()</a></code>, <code><a href="#topic+src_sqlite">src_sqlite()</a></code>, <code><a href="#topic+src_elastic">src_elastic()</a></code>, <code><a href="#topic+src_couchdb">src_couchdb()</a></code>
<code><a href="#topic+src_duckdb">src_duckdb()</a></code> or <code><a href="#topic+src_postgres">src_postgres()</a></code></p>
</td></tr>
<tr><td><code id="docdb_delete_+3A_key">key</code></td>
<td>
<p>(character) The name of the container in the
database backend (corresponds to <code>collection</code> for MongoDB,
<code>dbname</code> for CouchDB, <code>index</code> for Elasticsearch, and to
a table name for DuckDB, SQLite and PostgreSQL)</p>
</td></tr>
<tr><td><code id="docdb_delete_+3A_...">...</code></td>
<td>
<p>Optionally, specify <code>query</code> parameter with a
JSON string as per <code><a href="#topic+docdb_query">docdb_query()</a></code> to identify documents to be deleted.
If not specified (default), deletes the container <code>key</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(logical) Success of operation. Typically <code>TRUE</code> if
document(s) or collection existed, and <code>FALSE</code> if document(s)
did not exist, or collection did not exist, or delete was not successful.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
src &lt;- src_sqlite()
docdb_create(src, "iris", iris)
docdb_delete(src, "iris", query = '{"Species": {"$regex": "a$"}}')
docdb_delete(src, "iris")

## End(Not run)
</code></pre>

<hr>
<h2 id='docdb_exists'>Check if container exists in database</h2><span id='topic+docdb_exists'></span>

<h3>Description</h3>

<p>Check if container exists in database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docdb_exists(src, key, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="docdb_exists_+3A_src">src</code></td>
<td>
<p>Source object, result of call to any of functions
<code><a href="#topic+src_mongo">src_mongo()</a></code>, <code><a href="#topic+src_sqlite">src_sqlite()</a></code>, <code><a href="#topic+src_elastic">src_elastic()</a></code>, <code><a href="#topic+src_couchdb">src_couchdb()</a></code>
<code><a href="#topic+src_duckdb">src_duckdb()</a></code> or <code><a href="#topic+src_postgres">src_postgres()</a></code></p>
</td></tr>
<tr><td><code id="docdb_exists_+3A_key">key</code></td>
<td>
<p>(character) The name of the container in the
database backend (corresponds to <code>collection</code> for MongoDB,
<code>dbname</code> for CouchDB, <code>index</code> for Elasticsearch, and to
a table name for DuckDB, SQLite and PostgreSQL)</p>
</td></tr>
<tr><td><code id="docdb_exists_+3A_...">...</code></td>
<td>
<p>Passed to functions <code><a href="DBI.html#topic+dbListTables">DBI::dbListTables()</a></code>,
<code><a href="elastic.html#topic+indices">elastic::index_exists()</a></code>, and <code><a href="sofa.html#topic+db_info">sofa::db_info()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>(logical) <code>TRUE</code> or <code>FALSE</code> to indicate
existence of container <code>key</code> in database.
Note this does not indicate if the container
holds any documents.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
src &lt;- src_sqlite()
docdb_exists(src, "nonexistingcontainer")
docdb_create(src, "mtcars", mtcars)
docdb_exists(src, "mtcars")

## End(Not run)

</code></pre>

<hr>
<h2 id='docdb_get'>Get all documents from container in database</h2><span id='topic+docdb_get'></span>

<h3>Description</h3>

<p>Get all documents from container in database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docdb_get(src, key, limit = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="docdb_get_+3A_src">src</code></td>
<td>
<p>Source object, result of call to any of functions
<code><a href="#topic+src_mongo">src_mongo()</a></code>, <code><a href="#topic+src_sqlite">src_sqlite()</a></code>, <code><a href="#topic+src_elastic">src_elastic()</a></code>, <code><a href="#topic+src_couchdb">src_couchdb()</a></code>
<code><a href="#topic+src_duckdb">src_duckdb()</a></code> or <code><a href="#topic+src_postgres">src_postgres()</a></code></p>
</td></tr>
<tr><td><code id="docdb_get_+3A_key">key</code></td>
<td>
<p>(character) The name of the container in the
database backend (corresponds to <code>collection</code> for MongoDB,
<code>dbname</code> for CouchDB, <code>index</code> for Elasticsearch, and to
a table name for DuckDB, SQLite and PostgreSQL)</p>
</td></tr>
<tr><td><code id="docdb_get_+3A_limit">limit</code></td>
<td>
<p>(integer) Maximum number of documents
to be returned. If <code>NULL</code> or not set (default), 10,000 for
Elasticsearch and all documents for MongoDB, SQLite,
CouchDB, PostgreSQL, and DuckDB.</p>
</td></tr>
<tr><td><code id="docdb_get_+3A_...">...</code></td>
<td>
<p>Passed on to functions:
</p>

<ul>
<li><p> MongoDB: find() in <code><a href="mongolite.html#topic+mongo">mongolite::mongo()</a></code>
</p>
</li>
<li><p> SQLite: ignored
</p>
</li>
<li><p> Elasticsearch: <code><a href="elastic.html#topic+Search">elastic::Search()</a></code>
</p>
</li>
<li><p> CouchDB: <code><a href="sofa.html#topic+db_alldocs">sofa::db_alldocs()</a></code>
</p>
</li>
<li><p> PostgreSQL: ignored
</p>
</li>
<li><p> DuckDB: ignored
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame, one document per row
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
src &lt;- src_sqlite()
docdb_create(src, "mtcars", mtcars)
docdb_get(src, "mtcars", limit = 10L)

## End(Not run)
</code></pre>

<hr>
<h2 id='docdb_list'>List containers in database</h2><span id='topic+docdb_list'></span>

<h3>Description</h3>

<p>List containers in database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docdb_list(src, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="docdb_list_+3A_src">src</code></td>
<td>
<p>Source object, result of call to any of functions
<code><a href="#topic+src_mongo">src_mongo()</a></code>, <code><a href="#topic+src_sqlite">src_sqlite()</a></code>, <code><a href="#topic+src_elastic">src_elastic()</a></code>, <code><a href="#topic+src_couchdb">src_couchdb()</a></code>
<code><a href="#topic+src_duckdb">src_duckdb()</a></code> or <code><a href="#topic+src_postgres">src_postgres()</a></code></p>
</td></tr>
<tr><td><code id="docdb_list_+3A_...">...</code></td>
<td>
<p>Passed to function <code><a href="DBI.html#topic+dbListTables">DBI::dbListTables()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of names of containers that can be
used as parameter <code>key</code> with other functions such as
<code><a href="#topic+docdb_create">docdb_create()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
src &lt;- src_sqlite()
docdb_create(src, "iris", iris)
docdb_list(src)

## End(Not run)
</code></pre>

<hr>
<h2 id='docdb_query'>Get documents or parts with filtering query</h2><span id='topic+docdb_query'></span>

<h3>Description</h3>

<p>Complements the databases' native query and filtering functions
by using <code><a href="jqr.html#topic+jqr">jqr::jqr()</a></code>.
If <code>query = "{}"</code> and neither <code>fields</code>
nor <code>listfields</code> is specified, runs <code><a href="#topic+docdb_get">docdb_get()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docdb_query(src, key, query, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="docdb_query_+3A_src">src</code></td>
<td>
<p>Source object, result of call to any of functions
<code><a href="#topic+src_mongo">src_mongo()</a></code>, <code><a href="#topic+src_sqlite">src_sqlite()</a></code>, <code><a href="#topic+src_elastic">src_elastic()</a></code>, <code><a href="#topic+src_couchdb">src_couchdb()</a></code>
<code><a href="#topic+src_duckdb">src_duckdb()</a></code> or <code><a href="#topic+src_postgres">src_postgres()</a></code></p>
</td></tr>
<tr><td><code id="docdb_query_+3A_key">key</code></td>
<td>
<p>(character) The name of the container in the
database backend (corresponds to <code>collection</code> for MongoDB,
<code>dbname</code> for CouchDB, <code>index</code> for Elasticsearch, and to
a table name for DuckDB, SQLite and PostgreSQL)</p>
</td></tr>
<tr><td><code id="docdb_query_+3A_query">query</code></td>
<td>
<p>(character) A JSON query string, see examples.
Can use comparisons / tests (<code style="white-space: pre;">&#8288;$lt&#8288;</code>, <code style="white-space: pre;">&#8288;$lte&#8288;</code>, <code style="white-space: pre;">&#8288;$gt&#8288;</code>, <code style="white-space: pre;">&#8288;$gte&#8288;</code>,
<code style="white-space: pre;">&#8288;$ne&#8288;</code>, <code style="white-space: pre;">&#8288;$in&#8288;</code>, <code style="white-space: pre;">&#8288;$regex&#8288;</code>), with logic operators (<code style="white-space: pre;">&#8288;$and&#8288;</code>,
<code style="white-space: pre;">&#8288;$or&#8288;</code>, <code>(</code>, <code style="white-space: pre;">&#8288;)&#8288;</code>), including nested queries, see examples.
<code style="white-space: pre;">&#8288;$regex&#8288;</code> is case-sensitive.
Note that the query should target a field that holds a
scalar or an array of scalars, not more complex objects.</p>
</td></tr>
<tr><td><code id="docdb_query_+3A_...">...</code></td>
<td>
<p>Optional parameters:
</p>

<ul>
<li><p> Specify <code>fields</code> as a JSON string of fields to be returned
from anywhere in the tree, or to be excluded from being returned,
e.g. <code>fields  = '{"nameOfMy.SubFieldToInclude:" 1, "_id": 0}'</code>
and see examples. If <code>fields</code> is not specified, the complete
JSON document is returned. For <code>src_postgres()</code>, only fewer
than 50 fields can be requested to be returned by the function.
</p>
</li>
<li><p> Specify <code>limit</code> (integer) for the maximum number of documents
to be returned. If <code>NULL</code> or not set (default), 10,000 for
Elasticsearch and all documents for MongoDB, SQLite,
CouchDB, PostgreSQL, and DuckDB.
</p>
</li>
<li><p> Specify <code>listfields = TRUE</code> to return just the names of
all fields, from all documents or from the maximum number of
documents as specified in <code>limit</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with requested documents, one per row,
may have nested lists in columns;
<code>NULL</code> if no documents could be found.
If <code>listfields</code> is specified: vector of all field names
in dot path notation.
</p>


<h3>Note</h3>

<p>A dot in <code>query</code> or <code>fields</code> is interpreted as a dot path,
pointing to a field nested within another, e.g. <code>friends.id</code> in
the example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
src &lt;- src_sqlite()

docdb_create(src, "myKey", mtcars)
docdb_create(src, "myKey", contacts)
docdb_create(src, "myKey", mapdata)

docdb_query(src, "myKey", query = '{"mpg":21}')
docdb_query(src, "myKey", query = '{"mpg":21, "gear": {"$lte": 4}}')
docdb_query(src, "myKey", query = '{"mpg":21}', fields = '{"_id":0, "mpg":1, "cyl":1}')
docdb_query(src, "myKey", query = '{"_id": {"$regex": "^.+0.*$"}}', fields = '{"gear": 1}')

docdb_query(src, "myKey", query = '{"$and": [{"mpg": {"$lte": 18}}, {"gear": {"$gt": 3}}]}')
docdb_query(src, "myKey", query = '{}', fields = '{"_id":0, "mpg":1, "cyl":1}')

docdb_query(src, "myKey", query = '{"$and": [{"age": {"$gt": 21}},
 {"friends.name": {"$regex": "^B[a-z]{3,9}.*"}}]}')
docdb_query(src, "myKey", query = '{"$or": [{"rows.elements.status": "OK"}, {"$and": [
 {"_id": "5cd6785325ce3a94dfc54096"}, {"friends.name": {"$regex": "^B[a-z]{3,90}.*"}}]}]}')
docdb_query(src, "myKey", query = '{"$and": [{"_id": "5cd6785325ce3a94dfc54096"},
 {"friends.name": {"$regex": "^B[a-z]{3,90}.*"}}]}')
docdb_query(src, "myKey", query = '{"origin_addresses": {"$in": ["Santa Barbara, CA, USA",
 "New York, NY, USA"]}}', fields = '{"age": 1, "friends.id": 1, "_id": 0,
 "rows.elements.status": 1}')

docdb_query(src, "myKey", query = '{"rows.elements.status": "OK"}', listfields = TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='docdb_update'>Update documents</h2><span id='topic+docdb_update'></span>

<h3>Description</h3>

<p>Documents are updated by patching their JSON with
<code>value</code>. Documents are identified by a <code>query</code>
or by <code style="white-space: pre;">&#8288;_id&#8288;</code>'s in <code>value</code>, where the latter takes
precedence. <code>value</code> can have multiple documents (with
<code style="white-space: pre;">&#8288;_id&#8288;</code>'s), which then are iteratively updated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docdb_update(src, key, value, query, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="docdb_update_+3A_src">src</code></td>
<td>
<p>Source object, result of call to any of functions
<code><a href="#topic+src_mongo">src_mongo()</a></code>, <code><a href="#topic+src_sqlite">src_sqlite()</a></code>, <code><a href="#topic+src_elastic">src_elastic()</a></code>, <code><a href="#topic+src_couchdb">src_couchdb()</a></code>
<code><a href="#topic+src_duckdb">src_duckdb()</a></code> or <code><a href="#topic+src_postgres">src_postgres()</a></code></p>
</td></tr>
<tr><td><code id="docdb_update_+3A_key">key</code></td>
<td>
<p>(character) The name of the container in the
database backend (corresponds to <code>collection</code> for MongoDB,
<code>dbname</code> for CouchDB, <code>index</code> for Elasticsearch, and to
a table name for DuckDB, SQLite and PostgreSQL)</p>
</td></tr>
<tr><td><code id="docdb_update_+3A_value">value</code></td>
<td>
<p>The data to be created in the database:
a single data.frame, a JSON string, a list, or a
file name or URL that points to NDJSON documents</p>
</td></tr>
<tr><td><code id="docdb_update_+3A_query">query</code></td>
<td>
<p>(character) A JSON query string, see examples.
Can use comparisons / tests (<code style="white-space: pre;">&#8288;$lt&#8288;</code>, <code style="white-space: pre;">&#8288;$lte&#8288;</code>, <code style="white-space: pre;">&#8288;$gt&#8288;</code>, <code style="white-space: pre;">&#8288;$gte&#8288;</code>,
<code style="white-space: pre;">&#8288;$ne&#8288;</code>, <code style="white-space: pre;">&#8288;$in&#8288;</code>, <code style="white-space: pre;">&#8288;$regex&#8288;</code>), with logic operators (<code style="white-space: pre;">&#8288;$and&#8288;</code>,
<code style="white-space: pre;">&#8288;$or&#8288;</code>, <code>(</code>, <code style="white-space: pre;">&#8288;)&#8288;</code>), including nested queries, see examples.
Specify as <code>'{}'</code> if <code>value</code> includes <code style="white-space: pre;">&#8288;_id&#8288;</code>'s.</p>
</td></tr>
<tr><td><code id="docdb_update_+3A_...">...</code></td>
<td>
<p>Passed on to functions <code><a href="elastic.html#topic+docs_bulk_update">elastic::docs_bulk_update()</a></code>,
and <code><a href="mongolite.html#topic+mongo">mongolite::mongo()</a></code>$update().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses native functions in MongoDB (<code><a href="mongolite.html#topic+mongo">mongolite::mongo()</a></code>$update()),
SQLite (<code>jsonb_update()</code>), DuckDB (<code>jsonb_merge_patch()</code>),
Elasticsearch (<code>elastic::docs_bulk_update()</code>);
a <code>plpgsql</code> function added when calling <code>src_postgres()</code>,
and a <code><a href="jqr.html#topic+jqr">jqr::jqr()</a></code> programme for CouchDB.
</p>


<h3>Value</h3>

<p>(integer) Number of successfully updated documents
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
src &lt;- src_sqlite()
docdb_create(src, "mtcars", mtcars)
docdb_update(src, "mtcars", value = mtcars[3, 4:5], query = '{"gear": 3}')
docdb_update(src, "mtcars", value = '{"carb":999}', query = '{"gear": 5}')
docdb_update(src, "mtcars", value = '{"_id":"Fiat 128", "carb":888}', query = '{}')
docdb_get(src, "mtcars")

## End(Not run)
</code></pre>

<hr>
<h2 id='mapdata'>Data set 'mapdata'</h2><span id='topic+mapdata'></span>

<h3>Description</h3>

<p>Data set 'mapdata'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapdata
</code></pre>


<h3>Format</h3>

<p>A JSON string with ragged, nested travel details
</p>

<hr>
<h2 id='src'>Setup database connections</h2><span id='topic+src'></span>

<h3>Description</h3>

<p>There is a <code style="white-space: pre;">&#8288;src_*()&#8288;</code> function to setup a connection to each
of the database backends. The backends may have specific parameters
in the respective function <code style="white-space: pre;">&#8288;src_*()&#8288;</code>, but all other <code>nodbi</code> functions
are independent of the backend (e.g., see <code><a href="#topic+docdb_query">docdb_query()</a></code>).
</p>


<h3>Details</h3>


<ul>
<li><p> MongoDB - <code><a href="#topic+src_mongo">src_mongo()</a></code>
</p>
</li>
<li><p> SQLite - <code><a href="#topic+src_sqlite">src_sqlite()</a></code>
</p>
</li>
<li><p> Elasticsearch - <code><a href="#topic+src_elastic">src_elastic()</a></code>
</p>
</li>
<li><p> CouchDB - <code><a href="#topic+src_couchdb">src_couchdb()</a></code>
</p>
</li>
<li><p> PostgreSQL - <code><a href="#topic+src_postgres">src_postgres()</a></code>
</p>
</li>
<li><p> DuckDB - <code><a href="#topic+src_duckdb">src_duckdb()</a></code>
</p>
</li></ul>

<p>Documentation details for each database:
</p>

<ul>
<li><p> MongoDB - <a href="https://docs.mongodb.com/">https://docs.mongodb.com/</a>
</p>
</li>
<li><p> SQLite/JSON1 - <a href="https://www.sqlite.org/json1.html">https://www.sqlite.org/json1.html</a>
</p>
</li>
<li><p> Elasticsearch -
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html</a>
</p>
</li>
<li><p> CouchDB - <a href="http://docs.couchdb.org/">http://docs.couchdb.org/</a>
</p>
</li>
<li><p> PostgreSQL - <a href="https://www.postgresql.org/docs/current/functions-json.html">https://www.postgresql.org/docs/current/functions-json.html</a>
</p>
</li>
<li><p> DuckDB - <a href="https://duckdb.org/docs/extensions/json">https://duckdb.org/docs/extensions/json</a>
</p>
</li></ul>

<p>Documentation of R packages used by <code>nodbi</code> for the databases:
</p>

<ul>
<li><p> mongolite - <a href="https://CRAN.R-project.org/package=mongolite">https://CRAN.R-project.org/package=mongolite</a>
</p>
</li>
<li><p> RSQLite - <a href="https://CRAN.R-project.org/package=RSQLite">https://CRAN.R-project.org/package=RSQLite</a>
</p>
</li>
<li><p> elastic - <a href="https://CRAN.R-project.org/package=elastic">https://CRAN.R-project.org/package=elastic</a>
</p>
</li>
<li><p> sofa - <a href="https://CRAN.R-project.org/package=sofa">https://CRAN.R-project.org/package=sofa</a>
</p>
</li>
<li><p> RPostgres - <a href="https://CRAN.R-project.org/package=RPostgres">https://CRAN.R-project.org/package=RPostgres</a>
</p>
</li>
<li><p> duckdb - <a href="https://CRAN.R-project.org/package=duckdb">https://CRAN.R-project.org/package=duckdb</a>
</p>
</li></ul>


<hr>
<h2 id='src_couchdb'>Setup a CouchDB database connection</h2><span id='topic+src_couchdb'></span>

<h3>Description</h3>

<p>Setup a CouchDB database connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>src_couchdb(
  host = "127.0.0.1",
  port = 5984,
  path = NULL,
  transport = "http",
  user = NULL,
  pwd = NULL,
  headers = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="src_couchdb_+3A_host">host</code></td>
<td>
<p>(character) host value, default: 127.0.0.1</p>
</td></tr>
<tr><td><code id="src_couchdb_+3A_port">port</code></td>
<td>
<p>(integer/numeric) Port. Remember that if you don't want a port
set, set this parameter to NULL. Default: 5984</p>
</td></tr>
<tr><td><code id="src_couchdb_+3A_path">path</code></td>
<td>
<p>(character) context path that is appended to the end
of the url, e.g., bar in http://foo.com/bar. Default: NULL, ignored</p>
</td></tr>
<tr><td><code id="src_couchdb_+3A_transport">transport</code></td>
<td>
<p>(character) http or https. Default: http</p>
</td></tr>
<tr><td><code id="src_couchdb_+3A_user">user</code></td>
<td>
<p>(character) Username, if any</p>
</td></tr>
<tr><td><code id="src_couchdb_+3A_pwd">pwd</code></td>
<td>
<p>(character) Password, if any</p>
</td></tr>
<tr><td><code id="src_couchdb_+3A_headers">headers</code></td>
<td>
<p>(list) list of named headers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <span class="pkg">sofa</span> as backend. <span class="pkg">nodbi</span> creates or uses
a CouchDB database with JSON documents. If documents do not have
root-level <code style="white-space: pre;">&#8288;_id&#8288;</code>'s, UUID's are created as <code style="white-space: pre;">&#8288;_id&#8288;</code>'s. Function
<code><a href="#topic+docdb_update">docdb_update()</a></code> uses <code><a href="jqr.html#topic+jqr">jqr::jqr()</a></code> to implement patching JSON.
For a benchmark, see <a href="https://github.com/ropensci/nodbi#benchmark">https://github.com/ropensci/nodbi#benchmark</a>.
</p>


<h3>Value</h3>

<p>A <code>nodbi</code> source object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- src_couchdb()
print(con)

## End(Not run)
</code></pre>

<hr>
<h2 id='src_duckdb'>Setup a DuckDB database connection</h2><span id='topic+src_duckdb'></span>

<h3>Description</h3>

<p>Setup a DuckDB database connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>src_duckdb(drv = duckdb::duckdb(), dbdir = attr(drv, "dbdir"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="src_duckdb_+3A_drv">drv</code></td>
<td>
<p>Object returned by <code>duckdb()</code></p>
</td></tr>
<tr><td><code id="src_duckdb_+3A_dbdir">dbdir</code></td>
<td>
<p>Location for database files. Should be a path to an existing
directory in the file system. With the default (or <code>""</code>), all
data is kept in RAM.</p>
</td></tr>
<tr><td><code id="src_duckdb_+3A_...">...</code></td>
<td>
<p>Additional named parameters passed on to <code><a href="DBI.html#topic+dbConnect">DBI::dbConnect()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="duckdb.html#topic+duckdb">duckdb::duckdb()</a></code> as backend. <span class="pkg">nodbi</span> creates or
uses a DuckDB table, with columns <code style="white-space: pre;">&#8288;_id&#8288;</code> and <code>json</code> created and used
by package <code>nodbi</code>, applying SQL functions as per
<a href="https://duckdb.org/docs/extensions/json">https://duckdb.org/docs/extensions/json</a> to the <code>json</code> column.
Each row in the table represents a <code>JSON</code> document.
Any root-level <code style="white-space: pre;">&#8288;_id&#8288;</code> is extracted from the document(s) and used for
column <code style="white-space: pre;">&#8288;_id&#8288;</code>, otherwise a UUID is created as <code style="white-space: pre;">&#8288;_id&#8288;</code>.
The table is indexed on <code style="white-space: pre;">&#8288;_id&#8288;</code>.
For a benchmark, see <a href="https://github.com/ropensci/nodbi#benchmark">https://github.com/ropensci/nodbi#benchmark</a>.
</p>


<h3>Value</h3>

<p>A <code>nodbi</code> source object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- src_duckdb()
print(con)

## End(Not run)
</code></pre>

<hr>
<h2 id='src_elastic'>Setup an Elasticsearch database connection</h2><span id='topic+src_elastic'></span>

<h3>Description</h3>

<p>Setup an Elasticsearch database connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>src_elastic(
  host = "127.0.0.1",
  port = 9200,
  path = NULL,
  transport_schema = "http",
  user = NULL,
  pwd = NULL,
  force = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="src_elastic_+3A_host">host</code></td>
<td>
<p>(character) the base url, defaults to localhost
(http://127.0.0.1)</p>
</td></tr>
<tr><td><code id="src_elastic_+3A_port">port</code></td>
<td>
<p>(character) port to connect to, defaults to 9200 (optional)</p>
</td></tr>
<tr><td><code id="src_elastic_+3A_path">path</code></td>
<td>
<p>(character) context path that is appended to the end of the
url. Default: <code>NULL</code>, ignored</p>
</td></tr>
<tr><td><code id="src_elastic_+3A_transport_schema">transport_schema</code></td>
<td>
<p>(character) http or https. Default: http</p>
</td></tr>
<tr><td><code id="src_elastic_+3A_user">user</code></td>
<td>
<p>(character) User name, if required for the connection. You
can specify, but ignored for now.</p>
</td></tr>
<tr><td><code id="src_elastic_+3A_pwd">pwd</code></td>
<td>
<p>(character) Password, if required for the connection. You can
specify, but ignored for now.</p>
</td></tr>
<tr><td><code id="src_elastic_+3A_force">force</code></td>
<td>
<p>(logical) Force re-load of connection details</p>
</td></tr>
<tr><td><code id="src_elastic_+3A_...">...</code></td>
<td>
<p>Further args passed on to <code><a href="elastic.html#topic+connect">elastic::connect()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <span class="pkg">elastic</span> as backend. <span class="pkg">nodbi</span> creates or uses
an Elasticsearch index, in which <code>nodbi</code> creates JSON documents.
Any root-level <code style="white-space: pre;">&#8288;_id&#8288;</code> is extracted from the document(s) and used as
document ID <code style="white-space: pre;">&#8288;_id&#8288;</code>, otherwise a UUID is created as document ID <code style="white-space: pre;">&#8288;_id&#8288;</code>.
Only lowercase is accepted for container names (in parameter <code>key</code>).
Opensearch can equally be used.
For a benchmark, see <a href="https://github.com/ropensci/nodbi#benchmark">https://github.com/ropensci/nodbi#benchmark</a>
</p>


<h3>Value</h3>

<p>A <code>nodbi</code> source object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- src_elastic()
print(con)

## End(Not run)
</code></pre>

<hr>
<h2 id='src_mongo'>Setup a MongoDB database connection</h2><span id='topic+src_mongo'></span>

<h3>Description</h3>

<p>Setup a MongoDB database connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>src_mongo(collection = "test", db = "test", url = "mongodb://localhost", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="src_mongo_+3A_collection">collection</code></td>
<td>
<p>(character) Name of collection</p>
</td></tr>
<tr><td><code id="src_mongo_+3A_db">db</code></td>
<td>
<p>(character) Name of database</p>
</td></tr>
<tr><td><code id="src_mongo_+3A_url">url</code></td>
<td>
<p>(character) Address of the MongoDB server in Mongo connection
string URI format, see to <code><a href="mongolite.html#topic+mongo">mongolite::mongo()</a></code></p>
</td></tr>
<tr><td><code id="src_mongo_+3A_...">...</code></td>
<td>
<p>Additional named parameters passed on to <code><a href="mongolite.html#topic+mongo">mongolite::mongo()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <span class="pkg">monoglite</span> as backend. <span class="pkg">nodbi</span> creates or uses
a MongoDB collection, in which <code>nodbi</code> creates JSON documents.
If documents do not have root-level <code style="white-space: pre;">&#8288;_id&#8288;</code>'s, UUID's are created as <code style="white-space: pre;">&#8288;_id&#8288;</code>'s.
MongoDB but none of the other databases require to specify the container
already in the <code>src_mongo()</code> function.
For a benchmark, see <a href="https://github.com/ropensci/nodbi#benchmark">https://github.com/ropensci/nodbi#benchmark</a>
</p>


<h3>Value</h3>

<p>A <code>nodbi</code> source object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- src_mongo()
print(con)

## End(Not run)
</code></pre>

<hr>
<h2 id='src_postgres'>Setup a PostgreSQL database connection</h2><span id='topic+src_postgres'></span>

<h3>Description</h3>

<p>Setup a PostgreSQL database connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>src_postgres(dbname = "test", host = "localhost", port = 5432L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="src_postgres_+3A_dbname">dbname</code></td>
<td>
<p>(character) name of database,
has to exist to open a connection</p>
</td></tr>
<tr><td><code id="src_postgres_+3A_host">host</code></td>
<td>
<p>(character) host of the database,
see <code><a href="RPostgres.html#topic+Postgres">RPostgres::Postgres()</a></code></p>
</td></tr>
<tr><td><code id="src_postgres_+3A_port">port</code></td>
<td>
<p>(integer) port of the database,
see <code><a href="RPostgres.html#topic+Postgres">RPostgres::Postgres()</a></code></p>
</td></tr>
<tr><td><code id="src_postgres_+3A_...">...</code></td>
<td>
<p>additional named parameters passed
on to <code><a href="RPostgres.html#topic+Postgres">RPostgres::Postgres()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <span class="pkg">RPostgres</span> as backend. <span class="pkg">nodbi</span> creates or uses
a PostgreSQL table, with columns <code style="white-space: pre;">&#8288;_id&#8288;</code> and <code>json</code> created and used
by package <code>nodbi</code>, applying SQL functions as per
<a href="https://www.postgresql.org/docs/current/functions-json.html">https://www.postgresql.org/docs/current/functions-json.html</a>
to the <code>json</code> column.
Each row in the table represents a <code>JSON</code> document.
Any root-level <code style="white-space: pre;">&#8288;_id&#8288;</code> is extracted from the document(s) and used
for column <code style="white-space: pre;">&#8288;_id&#8288;</code>, otherwise a UUID is created as <code style="white-space: pre;">&#8288;_id&#8288;</code>.
The table is indexed on <code style="white-space: pre;">&#8288;_id&#8288;</code>. A custom <code>plpgsql</code> function
<a href="https://github.com/ropensci/nodbi/blob/master/R/src_postgres.R#L60">jsonb_merge_patch()</a>
is used for <code>docdb_update()</code>.
The order of variables in data frames returned by <code>docdb_get()</code>
and <code>docdb_query()</code> can differ from their order the input to
<code>docdb_create()</code>.
For a benchmark, see <a href="https://github.com/ropensci/nodbi#benchmark">https://github.com/ropensci/nodbi#benchmark</a>
</p>


<h3>Value</h3>

<p>A <code>nodbi</code> source object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- src_postgres()
print(con)

## End(Not run)

</code></pre>

<hr>
<h2 id='src_sqlite'>Setup a RSQLite database connection</h2><span id='topic+src_sqlite'></span>

<h3>Description</h3>

<p>Setup a RSQLite database connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>src_sqlite(dbname = ":memory:", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="src_sqlite_+3A_dbname">dbname</code></td>
<td>
<p>(character) name of database file,
defaults to &quot;:memory:&quot; for an in-memory database,
see <code><a href="RSQLite.html#topic+SQLite">RSQLite::SQLite()</a></code></p>
</td></tr>
<tr><td><code id="src_sqlite_+3A_...">...</code></td>
<td>
<p>additional named parameters passed
on to <code><a href="RSQLite.html#topic+SQLite">RSQLite::SQLite()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <span class="pkg">RSQLite</span> as backend. <span class="pkg">nodbi</span> creates or uses
an SQLite table, with columns <code style="white-space: pre;">&#8288;_id&#8288;</code> and <code>json</code> created and used by
package <code>nodbi</code>, applying SQL functions as per
<a href="https://www.sqlite.org/json1.html">https://www.sqlite.org/json1.html</a> to the <code>json</code> column.
Each row in the table represents a <code>JSON</code> document.
Any root-level <code style="white-space: pre;">&#8288;_id&#8288;</code> is extracted from the document(s) and used for
column <code style="white-space: pre;">&#8288;_id&#8288;</code>, otherwise a UUID is created as <code style="white-space: pre;">&#8288;_id&#8288;</code>.
The table is indexed on <code style="white-space: pre;">&#8288;_id&#8288;</code>.
For a benchmark, see <a href="https://github.com/ropensci/nodbi#benchmark">https://github.com/ropensci/nodbi#benchmark</a>
</p>


<h3>Value</h3>

<p>A <code>nodbi</code> source object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- src_sqlite()
print(con)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
