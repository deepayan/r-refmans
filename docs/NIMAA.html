<!DOCTYPE html><html lang="en"><head><title>Help for package NIMAA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NIMAA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#analyseNetwork'><p>General properties of the network</p></a></li>
<li><a href='#beatAML'><p>beatAML</p></a></li>
<li><a href='#drugComb'><p>drugComb</p></a></li>
<li><a href='#extractSubMatrix'><p>Extract the non-missing submatrices from a given matrix.</p></a></li>
<li><a href='#findCluster'><p>Find clusters in projected unipartite networks</p></a></li>
<li><a href='#herbIngredient'><p>herbIngredient</p></a></li>
<li><a href='#NIMAA'><p>NIMAA: A package for Nominal Data Mining Analysis.</p></a></li>
<li><a href='#nominalAsBinet'><p>Convert nominal data to a bipartite network</p></a></li>
<li><a href='#plotBipartite'><p>Plot the bipartite network and the corresponding projected networks</p></a></li>
<li><a href='#plotBipartiteInteractive'><p>Use the incidence matrix to plot an interactive bipartite network</p></a></li>
<li><a href='#plotCluster'><p>Plot the clusters in one projection of the bipartite network</p></a></li>
<li><a href='#plotIncMatrix'><p>Plot the incidence matrix.</p></a></li>
<li><a href='#predictEdge'><p>Edge prediction of weighted bipartite network.</p></a></li>
<li><a href='#robertson'><p>robertson</p></a></li>
<li><a href='#scoreCluster'><p>Score the cluster analysis in a projected network based on additional internal measures.</p></a></li>
<li><a href='#validateCluster'><p>Validate the cluster analysis in a projected network based on additional external measures.</p></a></li>
<li><a href='#validateEdgePrediction'><p>Validate and compare edge prediction methods.</p></a></li>
<li><a href='#visualClusterInBipartite'><p>Plot the bipartite graph with color coding for different clusters in both parts</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Nominal Data Mining Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for nominal data mining based on bipartite graphs, which build a pipeline for analysis and missing values imputation. Methods are mainly from the paper: Jafari, Mohieddin, et al. (2021) &lt;<a href="https://doi.org/10.1101%2F2021.03.18.436040">doi:10.1101/2021.03.18.436040</a>&gt;, some new ones are also included.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jafarilab/NIMAA">https://github.com/jafarilab/NIMAA</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jafarilab/NIMAA/issues">https://github.com/jafarilab/NIMAA/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, utils, rmarkdown, htmltools, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>plotly, tidyr, bipartite, crayon, dplyr, ggplot2, igraph,
purrr, skimr, bnstruct, RColorBrewer, fpc, mice, missMDA,
networkD3, scales, softImpute, tibble, tidytext, visNetwork,
stats</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-07 09:16:16 UTC; mohi</td>
</tr>
<tr>
<td>Author:</td>
<td>Mohieddin Jafari [aut, cre],
  Cheng Chen [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mohieddin Jafari &lt;mohieddin.jafari@helsinki.fi&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-11 14:12:45 UTC</td>
</tr>
</table>
<hr>
<h2 id='analyseNetwork'>General properties of the network</h2><span id='topic+analyseNetwork'></span>

<h3>Description</h3>

<p>Generic function for network properties, allowing you to get a quick overview of the network topology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyseNetwork(graph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyseNetwork_+3A_graph">graph</code></td>
<td>
<p>An <code>igraph</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following measurements are calculated in one step using the <a href="https://igraph.org/r/">igraph</a> package to analyze the input graph object: the Degree, Betweenness, Closeness, Kleinberg's hub score and Eigenvector centrality of nodes (vertices), the Betweenness centrality of edges, number of nodes, edges and components, the edge density, global Eigenvector centrality value and global Kleinberg's hub centrality score.
</p>


<h3>Value</h3>

<p>A list containing <code>vertices</code> and <code>edges</code> centrality values as well as <code>general_stats</code> for the whole network.
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+vcount">vcount</a></code>, <code><a href="igraph.html#topic+ecount">ecount</a></code>,
<code><a href="igraph.html#topic+edge_density">edge_density</a></code>, <code><a href="igraph.html#topic+count_components">count_components</a></code>,
<code><a href="igraph.html#topic+degree">degree</a></code>,<code><a href="igraph.html#topic+betweenness">betweenness</a></code>,
<code><a href="igraph.html#topic+edge_betweenness">edge_betweenness</a></code>,<code><a href="igraph.html#topic+closeness">closeness</a></code>,
<code><a href="igraph.html#topic+eigen_centrality">eigen_centrality</a></code>,<code><a href="igraph.html#topic+hub_score">hub_score</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a toy graph
g1 &lt;- igraph::make_graph(c(1, 2, 3, 4, 1, 3), directed = FALSE)
igraph::V(g1)$name &lt;- c("n1", "n2", "n3", "n4")

# generate random graph according to the Erdos-Renyi model
g2 &lt;- igraph::sample_gnm(10, 23)
igraph::V(g2)$name &lt;- letters[1:10]

# run analyseNetwork
analyseNetwork(g1)
analyseNetwork(g2)
</code></pre>

<hr>
<h2 id='beatAML'>beatAML</h2><span id='topic+beatAML'></span>

<h3>Description</h3>

<p>The Beat AML program produced a comprehensive dataset on acute myeloid leukemia (AML) that included genomic data (i.e., whole-exome sequencing and RNA sequencing), ex vivo drug response, and clinical data. We have included only the drug response data from this program in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beatAML
</code></pre>


<h3>Format</h3>

<p>A tibble with three variables:
</p>

<dl>
<dt><code>inhibitor</code></dt><dd><p>names of inhibitors</p>
</dd>
<dt><code>patient_id</code></dt><dd><p>anonymous patient ID</p>
</dd>
<dt><code>median</code></dt><dd><p>the median of drug response at corresponding <code>inhibitor</code> and <code>patient_id</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>Tyner, Jeffrey W., et al.(2018), Functional Genomic Landscape of Acute Myeloid Leukaemia. Nature 562 (7728): 526–31. <a href="http://vizome.org/aml/">http://vizome.org/aml/</a>
</p>

<hr>
<h2 id='drugComb'>drugComb</h2><span id='topic+drugComb'></span>

<h3>Description</h3>

<p>DrugComb is a web-based portal for storing and analyzing drug combination screening datasets, containing 739,964 drug combination experiments across 2320 cancer cell lines and 8397 drugs. Single drug screening was extracted and provided here as a subset of drug combination experiments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drugComb
</code></pre>


<h3>Format</h3>

<p>A tibble with three variables:
</p>

<dl>
<dt><code>inhibitor</code></dt><dd><p>names of inhibitors</p>
</dd>
<dt><code>cell_line</code></dt><dd><p>cell_line for each <code>inhibitor</code></p>
</dd>
<dt><code>median</code></dt><dd><p>the median of drug response at corresponding <code>inhibitor</code> and <code>cell_line</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>Zheng, S., Aldahdooh, J., Shadbahr, T., Wang, Y., Aldahdooh, D., Bao, J., Wang, W., Tang, J. (2021). DrugComb update: a more comprehensive drug sensitivity data repository and analysis portal, Nucleic Acids Research, 49(W1), W174–W184.  <a href="https://academic.oup.com/nar/article/49/W1/W174/6290546">https://academic.oup.com/nar/article/49/W1/W174/6290546</a>
</p>

<hr>
<h2 id='extractSubMatrix'>Extract the non-missing submatrices from a given matrix.</h2><span id='topic+extractSubMatrix'></span>

<h3>Description</h3>

<p>This function arranges the input matrix and extracts the submatrices with non-missing values or with a specific proportion of missing values (except for the elements-max submatrix). The result is also shown as <code>plotly</code> figure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractSubMatrix(
  x,
  shape = "All",
  verbose = FALSE,
  palette = "Greys",
  row.vars = NULL,
  col.vars = NULL,
  bar = 1,
  plot_weight = FALSE,
  print_skim = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractSubMatrix_+3A_x">x</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="extractSubMatrix_+3A_shape">shape</code></td>
<td>
<p>A string array indicating the shape of the submatrix, by default is &quot;All&quot;, other options are &quot;Square&quot;, &quot;Rectangular_row&quot;, &quot;Rectangular_col&quot;, &quot;Rectangular_element_max&quot;.</p>
</td></tr>
<tr><td><code id="extractSubMatrix_+3A_verbose">verbose</code></td>
<td>
<p>A logical value, If <code>TRUE</code>, the plot is saved as the .png file in the working directory. By default, it is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="extractSubMatrix_+3A_palette">palette</code></td>
<td>
<p>A string or number. Color palette used for the visualization. By default, it is 'Blues'.</p>
</td></tr>
<tr><td><code id="extractSubMatrix_+3A_row.vars">row.vars</code></td>
<td>
<p>A string, the name for the row variable.</p>
</td></tr>
<tr><td><code id="extractSubMatrix_+3A_col.vars">col.vars</code></td>
<td>
<p>A string, the name for the column variable.</p>
</td></tr>
<tr><td><code id="extractSubMatrix_+3A_bar">bar</code></td>
<td>
<p>A numeric value. The cut-off percentage, i.e., the proportion of non-missing values. By default, it is set to 1, indicating that no missing values are permitted in the submatrices. This argument is not applicable to the elements-max sub-matrix.</p>
</td></tr>
<tr><td><code id="extractSubMatrix_+3A_plot_weight">plot_weight</code></td>
<td>
<p>A logical value, If <code>TRUE</code>, then the function prints submatrices with weights, otherwise it prints the submatrices with all weights as 1.</p>
</td></tr>
<tr><td><code id="extractSubMatrix_+3A_print_skim">print_skim</code></td>
<td>
<p>A logical value, If <code>TRUE</code>, then the function prints <code><a href="skimr.html#topic+skim">skim</a></code> information in console. By default, it is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs row- and column-wise preprocessing in order to extract the largest submtrices. The distinction is that the first employs the original input matrix (row-wise), whereas the second employs the transposed matrix (column-wise). Following that, this function performs a &quot;three-step arrangement&quot; on the matrix, the first step being row-by-row arrangement, the second step being column-by-column arrangement, and the third step being total rearranging. Then, using four strategies, namely &quot;Square&quot;, &quot;Rectangular row&quot;, &quot;Rectangular col&quot;, and &quot;Rectangular element max&quot;, this function finds the largest possible submatrix (with no missing values), outputs the result, and prints the visualization. &quot;Square&quot; denotes the square submatric with the same number of rows and columns. &quot;Rectangular_row&quot; indicates the submatrices with the most rows. &quot;Rectangular_col&quot; denotes the submatrices with the most columns. &quot;Rectangular_element_max&quot; indicates the submatrices with the most elements which is typically a rectangular submatrix.
</p>


<h3>Value</h3>

<p>A matrix or a list of matrices with non-missing (bar = 1) or a few missing values inside. Also, a specific heat map plot is generated to visualize the topology of missing values and the submatrix sub-setting from the original incidence matrix. Additionally, the nestedness temperature is included to indicate whether the original incidence matrix should be divided into several incidence matrices beforehand.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+arrange">arrange</a></code>, <code><a href="dplyr.html#topic+arrange_if">arrange_if</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load part of the beatAML data
beatAML_data &lt;- NIMAA::beatAML[1:10000,]

# convert to incidence matrix
beatAML_incidence_matrix &lt;- nominalAsBinet(beatAML_data)

# extract submatrices with non-missing values
sub_matrices &lt;- extractSubMatrix(beatAML_incidence_matrix, col.vars = "patient_id",
 row.vars = "inhibitor")
</code></pre>

<hr>
<h2 id='findCluster'>Find clusters in projected unipartite networks</h2><span id='topic+findCluster'></span>

<h3>Description</h3>

<p>This function looks for the clusters in the projected unipartite networks of the bipartite network (the incidence matrix) that was given to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findCluster(
  inc_mat,
  part = 1,
  method = "all",
  normalization = TRUE,
  rm_weak_edges = TRUE,
  rm_method = "delete",
  threshold = "median",
  set_remaining_to_1 = TRUE,
  extra_feature = NULL,
  comparison = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findCluster_+3A_inc_mat">inc_mat</code></td>
<td>
<p>An incidence matrix.</p>
</td></tr>
<tr><td><code id="findCluster_+3A_part">part</code></td>
<td>
<p>An integer, 1 or 2, indicating which unipartite projection should be used. The default is 1.</p>
</td></tr>
<tr><td><code id="findCluster_+3A_method">method</code></td>
<td>
<p>A string array indicating the clustering methods. The defalut is &quot;all&quot;, which means all available clustering methods in this function are utilized. Other options are combinations of &quot;walktrap&quot;, &quot;multi level&quot;, &quot;infomap&quot;, &quot;label propagation&quot;, &quot;leading eigenvector&quot;, &quot;spinglass&quot;, and &quot;fast greedy&quot;.</p>
</td></tr>
<tr><td><code id="findCluster_+3A_normalization">normalization</code></td>
<td>
<p>A logical value indicating whether edge weights should be normalized before the computation proceeds. The default is TRUE.</p>
</td></tr>
<tr><td><code id="findCluster_+3A_rm_weak_edges">rm_weak_edges</code></td>
<td>
<p>A logical value indicating whether weak edges should be removed before the computation proceeds. The default is TRUE.</p>
</td></tr>
<tr><td><code id="findCluster_+3A_rm_method">rm_method</code></td>
<td>
<p>A string indicating the weak edges removing method. If <code>rm_weak_edges</code> is False, then this argument is ignored. The default is <code>delete</code>, which means deleting weak edges from the network. The other option is <code>as_zero</code>, which sets the weak edges' weights to 0.</p>
</td></tr>
<tr><td><code id="findCluster_+3A_threshold">threshold</code></td>
<td>
<p>A string indicating the weak edge threshold selection method. If <code>rm_weak_edges</code> is False, then this argument is ignored. By default, <code>median</code> is used. The other option is <code>keep_connected</code>, which prevents the network from being unconnected and removes edges in ascending order of weights.</p>
</td></tr>
<tr><td><code id="findCluster_+3A_set_remaining_to_1">set_remaining_to_1</code></td>
<td>
<p>A logical value indicating whether the remaining edges' weight should be set to 1. The default is TRUE.</p>
</td></tr>
<tr><td><code id="findCluster_+3A_extra_feature">extra_feature</code></td>
<td>
<p>A data frame object that shows the group membership of each node based on prior knowledge.</p>
</td></tr>
<tr><td><code id="findCluster_+3A_comparison">comparison</code></td>
<td>
<p>A logical value indicating whether clustering methods should be compared to each other using internal measures of clustering, including modularity, average silluoutte width, and coverage. The default value is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs optional preprocessing, such as normalization, on the input incidence matrix (bipartite network). The matrix is then used to perform bipartite network projection and optional preprocessing on one of the projected networks specified, such as removing edges with low weights (weak edges). Additionally, the user can specify the removal method, threshold value, or binarization of the weights. For the networks obtained after processing, this function implements some clustering methods in <a href="https://igraph.org/r/">igraph</a> such as &quot;walktrap&quot; and &quot;infomap&quot;, to detect the communities within the network. Furthermore, if external features (prior knowledge) are provided, the function compares the clustering results obtained with the external features in terms of similarity as an external validation of clustering. Otherwise, several internal validation criteria such as modularity and coverage are only represented to compare the clustering results.
</p>


<h3>Value</h3>

<p>A list containing the igraph object of the projected network, the clustering results of each method on the projected network separately, along with a comparison between them. The applied clustering arguments and the network's distance matrix are also included in this list for potential use in the next steps. In the case of weighted projected networks, the distance matrix is obtained by inverting the edge weights. The comparison of selected clustering methods is also presented as bar plots simultaneously.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate an incidence matrix
data &lt;- matrix(c(1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0), nrow = 3)
colnames(data) &lt;- letters[1:5]
rownames(data) &lt;- LETTERS[1:3]

# run findCluster() to do clustering
cls &lt;- findCluster(
  data,
  part = 1,
  method = "all",
  normalization = FALSE,
  rm_weak_edges = TRUE,
  comparison = TRUE
)
</code></pre>

<hr>
<h2 id='herbIngredient'>herbIngredient</h2><span id='topic+herbIngredient'></span>

<h3>Description</h3>

<p>The second version of the TCMID database was used as one of the large datasets in the TCM herb field. TCMID includes additional ingredient-specific experimental data based on herbal mass spectrometry spectra. The herb and ingredient associations from this database are provided here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>herbIngredient
</code></pre>


<h3>Format</h3>

<p>A tibble with two variables:
</p>

<dl>
<dt><code>herb</code></dt><dd><p>Scientific Latin names of available herbs in TCM database</p>
</dd>
<dt><code>pubchem_id</code></dt><dd><p>unique compound id (CID) of ingredients based on PubChem database for available <code>herb</code> in TCMID database</p>
</dd>
</dl>



<h3>Source</h3>

<p>Huang, L., Xie, D., Yu, Y., Liu, H., Shi, Y., Shi, T., &amp; Wen, C. (2018). TCMID 2.0: a comprehensive resource for TCM. Nucleic acids research, 46(D1), D1117–D1120. <a href="https://academic.oup.com/nar/article/46/D1/D1117/4584630">https://academic.oup.com/nar/article/46/D1/D1117/4584630</a>
</p>

<hr>
<h2 id='NIMAA'>NIMAA: A package for Nominal Data Mining Analysis.</h2><span id='topic+NIMAA'></span>

<h3>Description</h3>

<p>The NIMAA package contains 13 main functions that together provide a pipeline for nominal data mining. This package also includes four datasets that can be used to perform various nominal data mining analyses.
</p>

<hr>
<h2 id='nominalAsBinet'>Convert nominal data to a bipartite network</h2><span id='topic+nominalAsBinet'></span>

<h3>Description</h3>

<p>This function converts nominal data, which is represented in a data frame format as an edge list, to a bipartite network in the incidence matrix format. Nominal data is typically a data frame with two (or three) columns representing two nominal variables labels that NIMAA considers as starting and ending nodes (labels) in an edge list (or with a numeric value for each pairwise relationship of labels). The elements in the incidence matrix are the binary or numeric values of the pairwise relationships.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nominalAsBinet(
  el,
  index_nominal = c(1, 2),
  index_numeric = 3,
  print_skim = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nominalAsBinet_+3A_el">el</code></td>
<td>
<p>A data frame or matrix object as an edge list.</p>
</td></tr>
<tr><td><code id="nominalAsBinet_+3A_index_nominal">index_nominal</code></td>
<td>
<p>A vector with two values represents the indices for the columns containing nominal variables. The first value indicates the row objects and the second value indicates the column objects in the incidence matrix output.</p>
</td></tr>
<tr><td><code id="nominalAsBinet_+3A_index_numeric">index_numeric</code></td>
<td>
<p>An integer, the index for numeric values. This is the value used to pick the column containing the numeric values corresponding to the pairwise relationship of nominal variable labels. This column is used for missing value investigation and imputation steps.</p>
</td></tr>
<tr><td><code id="nominalAsBinet_+3A_print_skim">print_skim</code></td>
<td>
<p>A logical value, If <code>TRUE</code>, then the function prints <code><a href="skimr.html#topic+skim">skim</a></code> information in console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The incidence matrix representing the corresponding bipartite network. If <code>print_skim</code> set to <code>TRUE</code>, a summary of the matrix is also provided.
</p>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+pivot_wider">pivot_wider</a></code>,
<code><a href="tibble.html#topic+column_to_rownames">column_to_rownames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a data frame with two nominal variables without numeric values
el1 &lt;- data.frame(
  nominal_var_1 = c("d", "e", "e", "b", "a", "a"),
  nominal_var_2 = c("J", "N", "O", "R", "R", "L")
)

# generate a data frame with two nominal variables with numeric values
el2 &lt;- data.frame(
  nominal_var_1 = c("d", "e", "e", "b", "a", "a"),
  nominal_var_2 = c("J", "N", "O", "R", "R", "L"),
  numeric_val = c(4, 5, 5, 8, 7, 7)
)

# run nominalAsBinet() to convert the edge list to the incidence matrix
inc_mat1 &lt;- nominalAsBinet(el1)
inc_mat2 &lt;- nominalAsBinet(el2)

</code></pre>

<hr>
<h2 id='plotBipartite'>Plot the bipartite network and the corresponding projected networks</h2><span id='topic+plotBipartite'></span>

<h3>Description</h3>

<p>This function converts the incidence matrix into an igraph object and provides network visualization in multiple ways.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBipartite(
  inc_mat,
  part = 0,
  verbose = FALSE,
  vertex.label.display = FALSE,
  layout = layout.bipartite,
  vertex.shape = c("square", "circle"),
  vertix.color = c("steel blue", "orange"),
  vertex.label.cex = 0.3,
  vertex.size = 4,
  edge.width = 0.4,
  edge.color = "pink"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotBipartite_+3A_inc_mat">inc_mat</code></td>
<td>
<p>A matrix, the incidence matrix of bipartite network.</p>
</td></tr>
<tr><td><code id="plotBipartite_+3A_part">part</code></td>
<td>
<p>An integer value indicates whether the original bipartite network or its projection should be plotted. The default value of 0 represents the original bipartite network. Other possibilities are 1 and 2 for two projected networks.</p>
</td></tr>
<tr><td><code id="plotBipartite_+3A_verbose">verbose</code></td>
<td>
<p>A logical value, if it is <code>TRUE</code>, the plot is saved as the .png file in the working directory. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotBipartite_+3A_vertex.label.display">vertex.label.display</code></td>
<td>
<p>A logical value, if it is <code>TRUE</code>, then the label of each vertex is shown in the output graph. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotBipartite_+3A_layout">layout</code></td>
<td>
<p>A function from igraph package. The default is <code>layout.bipartite</code>, so the nodes on the top side are the variables in rows, and the nodes on the bottom side are those in columns.</p>
</td></tr>
<tr><td><code id="plotBipartite_+3A_vertex.shape">vertex.shape</code></td>
<td>
<p>A string vector to define the shapes for two different sets of vertices. The default value is <code>c("square", "circle")</code>, the first string value is for the nodes in rows, and the second one is for nodes in columns. If the <code>part</code> is not 0, then only the first string value is used.</p>
</td></tr>
<tr><td><code id="plotBipartite_+3A_vertix.color">vertix.color</code></td>
<td>
<p>A string vector to define the colors for two different sets of vertices. The default value is <code>c("steel blue", "orange")</code>, the first string value is for the nodes in rows, and the second one is for nodes in columns. If the <code>part</code> is not 0, then only the first string value is used.</p>
</td></tr>
<tr><td><code id="plotBipartite_+3A_vertex.label.cex">vertex.label.cex</code></td>
<td>
<p>A numeric value used to define the size of vertex labels. The default value is 0.3.</p>
</td></tr>
<tr><td><code id="plotBipartite_+3A_vertex.size">vertex.size</code></td>
<td>
<p>A numeric value used to define the size of vertex. The default value is 4.</p>
</td></tr>
<tr><td><code id="plotBipartite_+3A_edge.width">edge.width</code></td>
<td>
<p>A numeric value used to define the edge width. The default value is 0.1.</p>
</td></tr>
<tr><td><code id="plotBipartite_+3A_edge.color">edge.color</code></td>
<td>
<p>A string used to define the color of edges. The default value is &quot;pink&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph network object with visualization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load part of the beatAML data
beatAML_data &lt;- NIMAA::beatAML[1:10000,]

# convert to incidence matrix
beatAML_incidence_matrix &lt;- nominalAsBinet(beatAML_data)

# plot with the vertex label showing
plotBipartite(inc_mat = beatAML_incidence_matrix, vertex.label.display = TRUE)
</code></pre>

<hr>
<h2 id='plotBipartiteInteractive'>Use the incidence matrix to plot an interactive bipartite network</h2><span id='topic+plotBipartiteInteractive'></span>

<h3>Description</h3>

<p>This function converts the input incidence matrix into a bipartite network, and generates a customized interactive bipartite network visualization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBipartiteInteractive(inc_mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotBipartiteInteractive_+3A_inc_mat">inc_mat</code></td>
<td>
<p>A matrix, the incidence matrix of bipartite network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates customized interactive visualization for bipartite networks. The user can enter a simple incidence matrix to generate a dynamic network with a bipartite network layout, in which two parts use different colors and shapes to represent nodes. This function relies on the visNetwork package.
</p>


<h3>Value</h3>

<p>An visNetwork object for interactive figure.
</p>


<h3>See Also</h3>

<p><code><a href="visNetwork.html#topic+visNetwork">visNetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load part of the beatAML data
beatAML_data &lt;- NIMAA::beatAML[1:10000,]

# convert to incidence matrix
beatAML_incidence_matrix &lt;- nominalAsBinet(beatAML_data)

# plot with the interactive bipartite network

plotBipartiteInteractive(inc_mat = beatAML_incidence_matrix)
</code></pre>

<hr>
<h2 id='plotCluster'>Plot the clusters in one projection of the bipartite network</h2><span id='topic+plotCluster'></span>

<h3>Description</h3>

<p>This function makes an interactive network figure that shows nodes in which nodes belonging to the same cluster are colored the same and nodes belonging to other clusters are colored differently. This function has been customized to use the output of <code><a href="#topic+findCluster">findCluster</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCluster(graph, cluster, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotCluster_+3A_graph">graph</code></td>
<td>
<p>An igraph object.</p>
</td></tr>
<tr><td><code id="plotCluster_+3A_cluster">cluster</code></td>
<td>
<p>An igraph cluster object.</p>
</td></tr>
<tr><td><code id="plotCluster_+3A_...">...</code></td>
<td>
<p>Pass to <code><a href="networkD3.html#topic+forceNetwork">forceNetwork</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A networkD3 object.
</p>


<h3>See Also</h3>

<p><code><a href="networkD3.html#topic+forceNetwork">forceNetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate an incidence matrix
data &lt;- matrix(c(1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0), nrow = 3)
colnames(data) &lt;- letters[1:5]
rownames(data) &lt;- LETTERS[1:3]

# run findCluster() to do clustering
cls &lt;- findCluster(
  data,
  part = 1,
  method = "all",
  normalization = FALSE,
  rm_weak_edges = TRUE,
  comparison = FALSE
)
# plot the cluster with Louvain method
plotCluster(graph = cls$graph, cluster = cls$louvain)
</code></pre>

<hr>
<h2 id='plotIncMatrix'>Plot the incidence matrix.</h2><span id='topic+plotIncMatrix'></span>

<h3>Description</h3>

<p>This function converts a nominal data edge list to an incidence matrix and provides some information about that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotIncMatrix(
  x,
  index_nominal = c(1, 2),
  index_numeric = NULL,
  palette = "Blues",
  verbose = FALSE,
  plot_weight = FALSE,
  print_skim = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotIncMatrix_+3A_x">x</code></td>
<td>
<p>A data frame containing at least 2 nominal columns and an optional numeric column.</p>
</td></tr>
<tr><td><code id="plotIncMatrix_+3A_index_nominal">index_nominal</code></td>
<td>
<p>A vector made up of two numbers that serve as nominal columns. The first value indicates the incidence matrix's row name, while the second value represents the incidence matrix's column name. It is c (1,2) by default, which implies that the first column in the x data frame is the incidence matrix's row, and the second column in the x data frame is the incidence matrix's column.</p>
</td></tr>
<tr><td><code id="plotIncMatrix_+3A_index_numeric">index_numeric</code></td>
<td>
<p>An integer, the index of a numeric variable. This is the value used to select the column that contains weight score values for pairwise relationships, and it is used to fill the elements of the incidence matrix. These values are also utilized for investigating missing data and predicting edges via imputation.</p>
</td></tr>
<tr><td><code id="plotIncMatrix_+3A_palette">palette</code></td>
<td>
<p>A string or number. Color palette used for the heat map. By default, it sets to &quot;Blues&quot;. (Find more option in the manual of <code><a href="ggplot2.html#topic+scale_fill_distiller">scale_fill_distiller()</a></code>).</p>
</td></tr>
<tr><td><code id="plotIncMatrix_+3A_verbose">verbose</code></td>
<td>
<p>A logical value, If it is set to <code>TRUE</code>, the plot is saved as the .png file in the working directory. By default, it is set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotIncMatrix_+3A_plot_weight">plot_weight</code></td>
<td>
<p>A logical value, If it is set to <code>TRUE</code>, the plot is displayed with the corresponding colors based on weight scores, otherwise the binary matrix image is displayed. By default, it is set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotIncMatrix_+3A_print_skim">print_skim</code></td>
<td>
<p>A logical value, If <code>TRUE</code>, then the function prints <code><a href="skimr.html#topic+skim">skim</a></code> information in console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function mainly converts data in the form of edge list into matrix data. It also returns the incidence matrix object, the dimensions and proportion of missing values, as well as the matrix's image for visualization.
</p>


<h3>Value</h3>

<p>An incidence matrix object and image with the dimension and missing value proportion.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nominalAsBinet">nominalAsBinet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load part of the beatAML data
beatAML_data &lt;- NIMAA::beatAML[1:1000,]

# visualize the input dataset
beatAML_incidence_matrix &lt;- plotIncMatrix(beatAML_data,
index_numeric= 3)
</code></pre>

<hr>
<h2 id='predictEdge'>Edge prediction of weighted bipartite network.</h2><span id='topic+predictEdge'></span>

<h3>Description</h3>

<p>This function utilizes several data imputation methods in order to predict the existence of a link between two nodes by imputing the edges' weight in a weighted bipartite network of nominal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictEdge(inc_mat, method = c("svd", "median", "als", "CA"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictEdge_+3A_inc_mat">inc_mat</code></td>
<td>
<p>An incidence matrix containing missing values (edge weights), represented by NAs.</p>
</td></tr>
<tr><td><code id="predictEdge_+3A_method">method</code></td>
<td>
<p>A string or list of string. By default, it is set to this list: <code>c("svd", "median", "als", "CA")</code>. Other available methods in <code>MICE</code>, <code>knn</code>, <code>FAMD</code>, <code>PCA</code>, and <code>pmm</code>, can be called to perform at a single step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a variety of numerical imputations according to the user's input, and returns a list of imputed data matrices based on each method separately, such as <code>median</code> which replaces the missing values with the median of each rows (observations), and <code>knn</code> which uses the k-Nearest Neighbour algorithm to impute missing values.
</p>


<h3>Value</h3>

<p>A list of matrices with original and imputed values by different methods.
</p>


<h3>See Also</h3>

<p><code><a href="bnstruct.html#topic+knn.impute">knn.impute</a></code>,
<code><a href="softImpute.html#topic+softImpute">softImpute</a></code>, <code><a href="missMDA.html#topic+imputeCA">imputeCA</a></code>,
<code><a href="missMDA.html#topic+imputeFAMD">imputeFAMD</a></code>, <code><a href="missMDA.html#topic+imputePCA">imputePCA</a></code>,
<code><a href="mice.html#topic+mice">mice</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load part of the beatAML data
beatAML_data &lt;- NIMAA::beatAML[1:10000,]

# convert to incidence matrix
beatAML_incidence_matrix &lt;- nominalAsBinet(beatAML_data)

# predict the edges by imputation the weights
predictEdge(beatAML_incidence_matrix)
</code></pre>

<hr>
<h2 id='robertson'>robertson</h2><span id='topic+robertson'></span>

<h3>Description</h3>

<p>Charles Robertson's detailed collections provide as an amazing resource for long-term comparisons of numerous terrestrial plant and insect species collected in a single location. From 1884 through 1916, Robertson observed and collected 1429 insect species that visited 456 flower of plant species. He gathered this dataset in Macoupin County, Illinois, USA, within a 16-kilometer radius of Carlinville.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robertson
</code></pre>


<h3>Format</h3>

<p>A tibble with two variables:
</p>

<dl>
<dt><code>plant</code></dt><dd><p>Scientific Latin names of plants</p>
</dd>
<dt><code>pollinator</code></dt><dd><p>Scientific Latin names of pollinators for the <code>plant</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>Marlin, J. C., &amp; LaBerge, W. E. (2001). The native bee fauna of Carlinville, Illinois, revisited after 75 years: a case for persistence. Conservation Ecology, 5(1). <a href="http://www.ecologia.ib.usp.br/iwdb/html/robertson_1929.html">http://www.ecologia.ib.usp.br/iwdb/html/robertson_1929.html</a>
</p>

<hr>
<h2 id='scoreCluster'>Score the cluster analysis in a projected network based on additional internal measures.</h2><span id='topic+scoreCluster'></span>

<h3>Description</h3>

<p>This function provides additional internal cluster validity measures such as entropy and coverage. The concept of scoring is according to the weight fraction of all intra-cluster edges relative to the total weights of all edges in the graph. This function requires the community object, igraph object and distance matrix returned by <code><a href="#topic+findCluster">findCluster</a></code> to analyze.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoreCluster(community, graph, dist_mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scoreCluster_+3A_community">community</code></td>
<td>
<p>An igraph community object.</p>
</td></tr>
<tr><td><code id="scoreCluster_+3A_graph">graph</code></td>
<td>
<p>An igraph graph object.</p>
</td></tr>
<tr><td><code id="scoreCluster_+3A_dist_mat">dist_mat</code></td>
<td>
<p>A matrix containing the distance of nodes in the network. This matrix can be retrieved by the output of <code><a href="#topic+findCluster">findCluster</a></code> to analyze.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing internal cluster validity scores.
</p>


<h3>See Also</h3>

<p><code><a href="fpc.html#topic+cluster.stats">cluster.stats</a></code>, <code><a href="#topic+findCluster">findCluster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load part of the beatAML data
beatAML_data &lt;- NIMAA::beatAML[1:10000,]

# convert to incidence matrix
beatAML_incidence_matrix &lt;- nominalAsBinet(beatAML_data)

# do clustering
cls &lt;- findCluster(beatAML_incidence_matrix,
  part = 1, method = "infomap", normalization = FALSE,
  rm_weak_edges = TRUE, comparison = FALSE)

# get the scoring result
scoreCluster(community = cls$infomap, graph = cls$graph,
  dist_mat = cls$distance_matrix)

</code></pre>

<hr>
<h2 id='validateCluster'>Validate the cluster analysis in a projected network based on additional external measures.</h2><span id='topic+validateCluster'></span>

<h3>Description</h3>

<p>This function calculates the similarity of a given clustering method to the provided ground truth as external features (prior knowledge). This function provides external cluster validity measures including <code>corrected.rand</code> and <code style="white-space: pre;">&#8288;jaccard similarity&#8288;</code>. This function requires the community object, igraph object and distance matrix returned by <code><a href="#topic+findCluster">findCluster</a></code> to analyze.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateCluster(community, extra_feature, dist_mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validateCluster_+3A_community">community</code></td>
<td>
<p>An igraph community object.</p>
</td></tr>
<tr><td><code id="validateCluster_+3A_extra_feature">extra_feature</code></td>
<td>
<p>A data frame object that shows the group membership of each node based on prior knowledge.</p>
</td></tr>
<tr><td><code id="validateCluster_+3A_dist_mat">dist_mat</code></td>
<td>
<p>A matrix containing the distance of nodes in the network. This matrix can be retrieved by the output of <code><a href="#topic+findCluster">findCluster</a></code> to analyze.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the similarity measures for the clustering results and the ground truth represented as an external features, i.e., corrected Rand and Jaccard indices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load part of the beatAML data
beatAML_data &lt;- NIMAA::beatAML[1:10000,]

# convert to incidence matrix
beatAML_incidence_matrix &lt;- nominalAsBinet(beatAML_data)

# do clustering
cls &lt;- findCluster(beatAML_incidence_matrix,
  part = 1, method = c('infomap','walktrap'),
  normalization = FALSE, rm_weak_edges = TRUE,
  comparison = FALSE)

# generate a random external_feature
external_feature &lt;- data.frame(row.names = cls$infomap$names)
external_feature[,'membership'] &lt;- paste('group',
sample(c(1,2,3,4), nrow(external_feature),
replace = TRUE))

# validate clusters using random external feature
validateCluster(community = cls$walktrap,
extra_feature = external_feature,
dist_mat = cls$distance_matrix)
</code></pre>

<hr>
<h2 id='validateEdgePrediction'>Validate and compare edge prediction methods.</h2><span id='topic+validateEdgePrediction'></span>

<h3>Description</h3>

<p>This function compares the imputation approaches for predicting edges using the clustering result of a submatrix with non-missing values as a benchmark.  This function performs the same analysis as the <code>findCluster</code> function on every imputed incidence matrices independently. Then, using different similarity measures, all imputation approaches are compared to each other, revealing how edge prediction methods affects network communities (clusters). The best method should result in a higher degree of similarity (common node membership) to the non-missing submatrix as a benchmark.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateEdgePrediction(imputation, refer_community, clustering_args)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validateEdgePrediction_+3A_imputation">imputation</code></td>
<td>
<p>A list or a matrix containing the results of imputation method (s).</p>
</td></tr>
<tr><td><code id="validateEdgePrediction_+3A_refer_community">refer_community</code></td>
<td>
<p>An igraph community object obtained through <code><a href="#topic+findCluster">findCluster</a></code> using a given method.</p>
</td></tr>
<tr><td><code id="validateEdgePrediction_+3A_clustering_args">clustering_args</code></td>
<td>
<p>A list indicating the clustering arguments values used in <code><a href="#topic+findCluster">findCluster</a></code> for a given method. This list is retrievable from the output of <code><a href="#topic+findCluster">findCluster</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following indices: Jaccard similarity, Dice similarity coefficient, Rand index, Minkowski (inversed), and Fowlkes-Mallows index. The higher value indicates the greater similarity between the imputed dataset and the benchmark.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load part of the beatAML data
beatAML_data &lt;- NIMAA::beatAML[1:10000,]

# convert to incidence matrix
beatAML_incidence_matrix &lt;- nominalAsBinet(beatAML_data)

# do clustering
cls &lt;- findCluster(beatAML_incidence_matrix, part = 1)

# predict the edges by imputation the weights
imputed_beatAML &lt;- predictEdge(beatAML_incidence_matrix)

# validate the edge prediction
validateEdgePrediction(imputation = imputed_beatAML,
refer_community = cls$fast_greedy,
clustering_args = cls$clustering_args
)
</code></pre>

<hr>
<h2 id='visualClusterInBipartite'>Plot the bipartite graph with color coding for different clusters in both parts</h2><span id='topic+visualClusterInBipartite'></span>

<h3>Description</h3>

<p>The Sankey diagram is used to depict the connections between clusters within each part of the bipartite network. The display is also interactive, and by grouping nodes within each cluster as &quot;summary&quot; nodes, this function emphasizes how clusters of each part are connected together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualClusterInBipartite(
  data,
  community_left,
  community_right,
  name_left = "Left",
  name_right = "Right"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="visualClusterInBipartite_+3A_data">data</code></td>
<td>
<p>A data frame or matrix object as an edge list.</p>
</td></tr>
<tr><td><code id="visualClusterInBipartite_+3A_community_left">community_left</code></td>
<td>
<p>An igraph community object, one projection of the bipartite network to be showed on the left side.</p>
</td></tr>
<tr><td><code id="visualClusterInBipartite_+3A_community_right">community_right</code></td>
<td>
<p>An igraph community object, the other projection of the bipartite network to be showed on the right side.</p>
</td></tr>
<tr><td><code id="visualClusterInBipartite_+3A_name_left">name_left</code></td>
<td>
<p>A string value, the name of left community.</p>
</td></tr>
<tr><td><code id="visualClusterInBipartite_+3A_name_right">name_right</code></td>
<td>
<p>A string value, the name of right community.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A customized Sankey plot with a data frame containing the cluster pairwise relationship with the sum of weight values in the weighted bipartite network.
</p>


<h3>See Also</h3>

<p><code><a href="plotly.html#topic+plot_ly">plot_ly</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load part of the beatAML data
beatAML_data &lt;- NIMAA::beatAML[1:1000,]

# convert to incidence matrix
beatAML_incidence_matrix &lt;- nominalAsBinet(beatAML_data)

# extract the Recetengular_element_max submatrix
sub_matrices &lt;- extractSubMatrix(beatAML_incidence_matrix,
col.vars = "patient_id", row.vars = "inhibitor",
shape = c("Rectangular_element_max"))

# do clustering analysis
cls1 &lt;- findCluster(sub_matrices$Rectangular_element_max,
part = 1, comparison = FALSE)

cls2 &lt;- findCluster(sub_matrices$Rectangular_element_max,
part = 2, comparison = FALSE)

visualClusterInBipartite(data = beatAML_data,
community_left = cls2$leading_eigen,
community_right = cls1$fast_greedy,
name_left = 'patient_id',
name_right = 'inhibitor')
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
