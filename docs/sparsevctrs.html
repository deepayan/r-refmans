<!DOCTYPE html><html><head><title>Help for package sparsevctrs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sparsevctrs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sparsevctrs-package'><p>sparsevctrs: Sparse Vectors for Use in Data Frames</p></a></li>
<li><a href='#coerce_to_sparse_data_frame'><p>Coerce sparse matrix to data frame with sparse columns</p></a></li>
<li><a href='#coerce_to_sparse_matrix'><p>Coerce sparse data frame to sparse matrix</p></a></li>
<li><a href='#coerce_to_sparse_tibble'><p>Coerce sparse matrix to tibble with sparse columns</p></a></li>
<li><a href='#coerce-vector'><p>Coerce numeric vector to sparse double</p></a></li>
<li><a href='#extractors'><p>Information extraction from sparse vectors</p></a></li>
<li><a href='#sparse_character'><p>Create sparse character vector</p></a></li>
<li><a href='#sparse_double'><p>Create sparse double vector</p></a></li>
<li><a href='#sparse_integer'><p>Create sparse integer vector</p></a></li>
<li><a href='#sparse_logical'><p>Create sparse logical vector</p></a></li>
<li><a href='#type-predicates'><p>Sparse vector type checkers</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Sparse Vectors for Use in Data Frames</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides sparse vectors powered by ALTREP (Alternative
    Representations for R Objects) that behave like regular vectors, and
    can thus be used in data frames. Also provides tools to convert
    between sparse matrices and data frames with sparse columns and
    functions to interact with sparse vectors.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-lib/sparsevctrs">https://github.com/r-lib/sparsevctrs</a>,
<a href="https://r-lib.github.io/sparsevctrs/">https://r-lib.github.io/sparsevctrs/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/sparsevctrs/issues">https://github.com/r-lib/sparsevctrs/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.4.0), rlang (&ge; 1.1.0), vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, Matrix, methods, rmarkdown, testthat (&ge; 3.0.0),
tibble, withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate, rmarkdown, lobstr,
ggplot2, bench, tidyr, ggbeeswarm</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1.9000</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-28 23:58:30 UTC; emilhvitfeldt</td>
</tr>
<tr>
<td>Author:</td>
<td>Emil Hvitfeldt <a href="https://orcid.org/0000-0002-0679-1945"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Davis Vaughan [ctb],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emil Hvitfeldt &lt;emil.hvitfeldt@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-31 18:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='sparsevctrs-package'>sparsevctrs: Sparse Vectors for Use in Data Frames</h2><span id='topic+sparsevctrs'></span><span id='topic+sparsevctrs-package'></span>

<h3>Description</h3>

<p>Provides sparse vectors powered by ALTREP (Alternative Representations for R Objects) that behave like regular vectors, and can thus be used in data frames. Also provides tools to convert between sparse matrices and data frames with sparse columns and functions to interact with sparse vectors.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Emil Hvitfeldt <a href="mailto:emil.hvitfeldt@posit.co">emil.hvitfeldt@posit.co</a> (<a href="https://orcid.org/0000-0002-0679-1945">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Davis Vaughan <a href="mailto:davis@posit.co">davis@posit.co</a> [contributor]
</p>
</li>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/r-lib/sparsevctrs">https://github.com/r-lib/sparsevctrs</a>
</p>
</li>
<li> <p><a href="https://r-lib.github.io/sparsevctrs/">https://r-lib.github.io/sparsevctrs/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/sparsevctrs/issues">https://github.com/r-lib/sparsevctrs/issues</a>
</p>
</li></ul>


<hr>
<h2 id='coerce_to_sparse_data_frame'>Coerce sparse matrix to data frame with sparse columns</h2><span id='topic+coerce_to_sparse_data_frame'></span>

<h3>Description</h3>

<p>Turning a sparse matrix into a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coerce_to_sparse_data_frame(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coerce_to_sparse_data_frame_+3A_x">x</code></td>
<td>
<p>sparse matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The only requirement from the sparse matrix is that it contains column names.
</p>


<h3>Value</h3>

<p>data.frame with sparse columns
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coerce_to_sparse_tibble">coerce_to_sparse_tibble()</a></code> <code><a href="#topic+coerce_to_sparse_matrix">coerce_to_sparse_matrix()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
mat &lt;- matrix(sample(0:1, 100, TRUE, c(0.9, 0.1)), nrow = 10)
colnames(mat) &lt;- letters[1:10]
sparse_mat &lt;- Matrix::Matrix(mat, sparse = TRUE)
sparse_mat

res &lt;- coerce_to_sparse_data_frame(sparse_mat)
res

# All columns are sparse
vapply(res, is_sparse_vector, logical(1))

</code></pre>

<hr>
<h2 id='coerce_to_sparse_matrix'>Coerce sparse data frame to sparse matrix</h2><span id='topic+coerce_to_sparse_matrix'></span>

<h3>Description</h3>

<p>Turning data frame with sparse columns into sparse matrix using
<code><a href="Matrix.html#topic+sparseMatrix">Matrix::sparseMatrix()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coerce_to_sparse_matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coerce_to_sparse_matrix_+3A_x">x</code></td>
<td>
<p>a data frame or tibble with sparse columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No checking is currently do to <code>x</code> to determine whether it contains sparse
columns or not. Thus it works with any data frame. Needless to say, creating
a sparse matrix out of a dense data frame is not ideal.
</p>


<h3>Value</h3>

<p>sparse matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coerce_to_sparse_data_frame">coerce_to_sparse_data_frame()</a></code> <code><a href="#topic+coerce_to_sparse_tibble">coerce_to_sparse_tibble()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sparse_tbl &lt;- lapply(1:10, function(x) sparse_double(x, x, length = 10))
names(sparse_tbl) &lt;- letters[1:10]
sparse_tbl &lt;- as.data.frame(sparse_tbl)
sparse_tbl

res &lt;- coerce_to_sparse_matrix(sparse_tbl)
res

</code></pre>

<hr>
<h2 id='coerce_to_sparse_tibble'>Coerce sparse matrix to tibble with sparse columns</h2><span id='topic+coerce_to_sparse_tibble'></span>

<h3>Description</h3>

<p>Turning a sparse matrix into a tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coerce_to_sparse_tibble(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coerce_to_sparse_tibble_+3A_x">x</code></td>
<td>
<p>sparse matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The only requirement from the sparse matrix is that it contains column names.
</p>


<h3>Value</h3>

<p>tibble with sparse columns
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coerce_to_sparse_data_frame">coerce_to_sparse_data_frame()</a></code> <code><a href="#topic+coerce_to_sparse_matrix">coerce_to_sparse_matrix()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
mat &lt;- matrix(sample(0:1, 100, TRUE, c(0.9, 0.1)), nrow = 10)
colnames(mat) &lt;- letters[1:10]
sparse_mat &lt;- Matrix::Matrix(mat, sparse = TRUE)
sparse_mat

res &lt;- coerce_to_sparse_tibble(sparse_mat)
res

# All columns are sparse
vapply(res, is_sparse_vector, logical(1))

</code></pre>

<hr>
<h2 id='coerce-vector'>Coerce numeric vector to sparse double</h2><span id='topic+coerce-vector'></span><span id='topic+as_sparse_double'></span><span id='topic+as_sparse_integer'></span><span id='topic+as_sparse_character'></span><span id='topic+as_sparse_logical'></span>

<h3>Description</h3>

<p>Takes a numeric vector, integer or double, and turn it into a sparse double
vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_sparse_double(x, default = 0)

as_sparse_integer(x, default = 0L)

as_sparse_character(x, default = "")

as_sparse_logical(x, default = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coerce-vector_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="coerce-vector_+3A_default">default</code></td>
<td>
<p>default value to use. Defaults to <code>0</code>.
</p>
<p>The values of <code>x</code> must be double or integer. It must not contain any <code>Inf</code> or
<code>NaN</code> values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sparse vectors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_dense &lt;- c(3, 0, 2, 0, 0, 0, 4, 0, 0, 0)
x_sparse &lt;- as_sparse_double(x_dense)
x_sparse

is_sparse_double(x_sparse) 
</code></pre>

<hr>
<h2 id='extractors'>Information extraction from sparse vectors</h2><span id='topic+extractors'></span><span id='topic+sparse_positions'></span><span id='topic+sparse_values'></span><span id='topic+sparse_default'></span>

<h3>Description</h3>

<p>Extract positions, values, and default from sparse vectors without the need
to materialize vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_positions(x)

sparse_values(x)

sparse_default(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractors_+3A_x">x</code></td>
<td>
<p>vector to be extracted from.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sparse_default()</code> returns <code>NA</code> when applied to non-sparse vectors. This is
done to have an indicator of non-sparsity.
</p>
<p>for ease of use, these functions also works on non-sparse variables.
</p>


<h3>Value</h3>

<p>vectors of requested attributes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_sparse &lt;- sparse_double(c(pi, 5, 0.1), c(2, 5, 10), 10)
x_dense &lt;- c(0, pi, 0, 0, 0.5, 0, 0, 0, 0, 0.1)

sparse_positions(x_sparse)
sparse_values(x_sparse)
sparse_default(x_sparse)

sparse_positions(x_dense)
sparse_values(x_dense)
sparse_default(x_dense)

x_sparse_3 &lt;- sparse_double(c(pi, 5, 0.1), c(2, 5, 10), 10, default = 3)
sparse_default(x_sparse_3)
</code></pre>

<hr>
<h2 id='sparse_character'>Create sparse character vector</h2><span id='topic+sparse_character'></span>

<h3>Description</h3>

<p>Construction of vectors where only values and positions are recorded. The
Length and default values determine all other information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_character(values, positions, length, default = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparse_character_+3A_values">values</code></td>
<td>
<p>integer vector, values of non-zero entries.</p>
</td></tr>
<tr><td><code id="sparse_character_+3A_positions">positions</code></td>
<td>
<p>integer vector, indices of non-zero entries.</p>
</td></tr>
<tr><td><code id="sparse_character_+3A_length">length</code></td>
<td>
<p>integer value, Length of vector.</p>
</td></tr>
<tr><td><code id="sparse_character_+3A_default">default</code></td>
<td>
<p>integer value, value at indices not specified by <code>positions</code>.
Defaults to <code>""</code>. Cannot be <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>values</code> and <code>positions</code> are expected to be the same length, and are allowed
to both have zero length.
</p>
<p>Allowed values for <code>value</code> are character values. Missing values such as <code>NA</code>
and <code>NA_real_</code> are allowed as they are turned into <code>NA_character_</code>.
Everything else is disallowed. The values are also not allowed to take the
same value as <code>default</code>.
</p>
<p><code>positions</code> should be integers or integer-like doubles. Everything else is
not allowed. Positions should furthermore be positive (<code>0</code> not allowed),
unique, and in increasing order. Lastly they should all be smaller that
<code>length</code>.
</p>
<p>For developers:
</p>
<p>setting <code>options("sparsevctrs.verbose_materialize" = TRUE)</code> will print a
message each time a sparse vector has been forced to materialize.
</p>


<h3>Value</h3>

<p>sparse character vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparse_double">sparse_double()</a></code> <code><a href="#topic+sparse_integer">sparse_integer()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sparse_character(character(), integer(), 10)

sparse_character(c("A", "C", "E"), c(2, 5, 10), 10)

str(
  sparse_character(c("A", "C", "E"), c(2, 5, 10), 1000000000)
)
</code></pre>

<hr>
<h2 id='sparse_double'>Create sparse double vector</h2><span id='topic+sparse_double'></span>

<h3>Description</h3>

<p>Construction of vectors where only values and positions are recorded. The
Length and default values determine all other information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_double(values, positions, length, default = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparse_double_+3A_values">values</code></td>
<td>
<p>double vector, values of non-zero entries.</p>
</td></tr>
<tr><td><code id="sparse_double_+3A_positions">positions</code></td>
<td>
<p>integer vector, indices of non-zero entries.</p>
</td></tr>
<tr><td><code id="sparse_double_+3A_length">length</code></td>
<td>
<p>integer value, Length of vector.</p>
</td></tr>
<tr><td><code id="sparse_double_+3A_default">default</code></td>
<td>
<p>double value, value at indices not specified by <code>positions</code>.
Defaults to <code>0</code>. Cannot be <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>values</code> and <code>positions</code> are expected to be the same length, and are allowed
to both have zero length.
</p>
<p>Allowed values for <code>value</code> is double and integer values. integer values will
be coerced to doubles. Missing values such as <code>NA</code> and <code>NA_real_</code> are
allowed. Everything else is disallowed, This includes <code>Inf</code> and <code>NaN</code>. The
values are also not allowed to take the same value as <code>default</code>.
</p>
<p><code>positions</code> should be integers or integer-like doubles. Everything else is
not allowed. Positions should furthermore be positive (<code>0</code> not allowed),
unique, and in increasing order. Lastly they should all be smaller that
<code>length</code>.
</p>
<p>For developers:
</p>
<p>setting <code>options("sparsevctrs.verbose_materialize" = TRUE)</code> will print a
message each time a sparse vector has been forced to materialize.
</p>


<h3>Value</h3>

<p>sparse double vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparse_integer">sparse_integer()</a></code> <code><a href="#topic+sparse_character">sparse_character()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sparse_double(numeric(), integer(), 10)

sparse_double(c(pi, 5, 0.1), c(2, 5, 10), 10)

str(
  sparse_double(c(pi, 5, 0.1), c(2, 5, 10), 1000000000)
)
</code></pre>

<hr>
<h2 id='sparse_integer'>Create sparse integer vector</h2><span id='topic+sparse_integer'></span>

<h3>Description</h3>

<p>Construction of vectors where only values and positions are recorded. The
Length and default values determine all other information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_integer(values, positions, length, default = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparse_integer_+3A_values">values</code></td>
<td>
<p>integer vector, values of non-zero entries.</p>
</td></tr>
<tr><td><code id="sparse_integer_+3A_positions">positions</code></td>
<td>
<p>integer vector, indices of non-zero entries.</p>
</td></tr>
<tr><td><code id="sparse_integer_+3A_length">length</code></td>
<td>
<p>integer value, Length of vector.</p>
</td></tr>
<tr><td><code id="sparse_integer_+3A_default">default</code></td>
<td>
<p>integer value, value at indices not specified by <code>positions</code>.
Defaults to <code>0L</code>. Cannot be <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>values</code> and <code>positions</code> are expected to be the same length, and are allowed
to both have zero length.
</p>
<p>Allowed values for <code>value</code> is integer values. This means that the double
vector <code>c(1, 5, 4)</code> is accepted as it can be losslessly converted to the
integer vector <code>c(1L, 5L, 4L)</code>. Missing values such as <code>NA</code> and <code>NA_real_</code>
are allowed. Everything else is disallowed, This includes <code>Inf</code> and <code>NaN</code>.
The values are also not allowed to take the same value as <code>default</code>.
</p>
<p><code>positions</code> should be integers or integer-like doubles. Everything else is
not allowed. Positions should furthermore be positive (<code>0</code> not allowed),
unique, and in increasing order. Lastly they should all be smaller that
<code>length</code>.
</p>
<p>For developers:
</p>
<p>setting <code>options("sparsevctrs.verbose_materialize" = TRUE)</code> will print a
message each time a sparse vector has been forced to materialize.
</p>


<h3>Value</h3>

<p>sparse integer vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparse_double">sparse_double()</a></code> <code><a href="#topic+sparse_character">sparse_character()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sparse_integer(integer(), integer(), 10)

sparse_integer(c(4, 5, 7), c(2, 5, 10), 10)

str(
  sparse_integer(c(4, 5, 7), c(2, 5, 10), 1000000000)
)
</code></pre>

<hr>
<h2 id='sparse_logical'>Create sparse logical vector</h2><span id='topic+sparse_logical'></span>

<h3>Description</h3>

<p>Construction of vectors where only values and positions are recorded. The
Length and default values determine all other information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_logical(values, positions, length, default = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparse_logical_+3A_values">values</code></td>
<td>
<p>logical vector, values of non-zero entries.</p>
</td></tr>
<tr><td><code id="sparse_logical_+3A_positions">positions</code></td>
<td>
<p>integer vector, indices of non-zero entries.</p>
</td></tr>
<tr><td><code id="sparse_logical_+3A_length">length</code></td>
<td>
<p>integer value, Length of vector.</p>
</td></tr>
<tr><td><code id="sparse_logical_+3A_default">default</code></td>
<td>
<p>logical value, value at indices not specified by <code>positions</code>.
Defaults to <code>FALSE</code>. Cannot be <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>values</code> and <code>positions</code> are expected to be the same length, and are allowed
to both have zero length.
</p>
<p>Allowed values for <code>value</code> are logical values. Missing values such as <code>NA</code>
and <code>NA_real_</code> are allowed. Everything else is disallowed, The values are
also not allowed to take the same value as <code>default</code>.
</p>
<p><code>positions</code> should be integers or integer-like doubles. Everything else is
not allowed. Positions should furthermore be positive (<code>0</code> not allowed),
unique, and in increasing order. Lastly they should all be smaller that
<code>length</code>.
</p>
<p>For developers:
</p>
<p>setting <code>options("sparsevctrs.verbose_materialize" = TRUE)</code> will print a
message each time a sparse vector has been forced to materialize.
</p>


<h3>Value</h3>

<p>sparse logical vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparse_double">sparse_double()</a></code> <code><a href="#topic+sparse_integer">sparse_integer()</a></code> <code><a href="#topic+sparse_character">sparse_character()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sparse_logical(logical(), integer(), 10)

sparse_logical(c(TRUE, NA, TRUE), c(2, 5, 10), 10)

str(
  sparse_logical(c(TRUE, NA, TRUE), c(2, 5, 10), 1000000000)
)
</code></pre>

<hr>
<h2 id='type-predicates'>Sparse vector type checkers</h2><span id='topic+type-predicates'></span><span id='topic+is_sparse_vector'></span><span id='topic+is_sparse_numeric'></span><span id='topic+is_sparse_double'></span><span id='topic+is_sparse_integer'></span><span id='topic+is_sparse_character'></span><span id='topic+is_sparse_logical'></span>

<h3>Description</h3>

<p>Helper functions to determine whether an vector is a sparse vector or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_sparse_vector(x)

is_sparse_numeric(x)

is_sparse_double(x)

is_sparse_integer(x)

is_sparse_character(x)

is_sparse_logical(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="type-predicates_+3A_x">x</code></td>
<td>
<p>value to be checked.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is_sparse_vector()</code> is a general function that detects any type of sparse
vector created with this package. <code>is_sparse_double()</code>,
<code>is_sparse_integer()</code>, <code>is_sparse_character()</code>, and <code>is_sparse_logical()</code> are
more specific functions that only detects the type. <code>is_sparse_numeric()</code>
matches both sparse integers and doubles.
</p>


<h3>Value</h3>

<p>single logical value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_sparse &lt;- sparse_double(c(pi, 5, 0.1), c(2, 5, 10), 10)
x_dense &lt;- c(0, pi, 0, 0, 0.5, 0, 0, 0, 0, 0.1)

is_sparse_vector(x_sparse)
is_sparse_vector(x_dense)

is_sparse_double(x_sparse)
is_sparse_double(x_dense)

is_sparse_character(x_sparse)
is_sparse_character(x_dense)

# Forced materialization
is_sparse_vector(x_sparse[])
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
