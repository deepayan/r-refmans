<!DOCTYPE html><html lang="en"><head><title>Help for package sparsevctrs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sparsevctrs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sparsevctrs-package'><p>sparsevctrs: Sparse Vectors for Use in Data Frames</p></a></li>
<li><a href='#coerce_to_sparse_data_frame'><p>Coerce sparse matrix to data frame with sparse columns</p></a></li>
<li><a href='#coerce_to_sparse_matrix'><p>Coerce sparse data frame to sparse matrix</p></a></li>
<li><a href='#coerce_to_sparse_tibble'><p>Coerce sparse matrix to tibble with sparse columns</p></a></li>
<li><a href='#coerce-vector'><p>Coerce numeric vector to sparse double</p></a></li>
<li><a href='#extractors'><p>Information extraction from sparse vectors</p></a></li>
<li><a href='#has_sparse_elements'><p>Check for sparse elements</p></a></li>
<li><a href='#sparse_character'><p>Create sparse character vector</p></a></li>
<li><a href='#sparse_double'><p>Create sparse double vector</p></a></li>
<li><a href='#sparse_dummy'><p>Generate sparse dummy variables</p></a></li>
<li><a href='#sparse_integer'><p>Create sparse integer vector</p></a></li>
<li><a href='#sparse_is_na'><p>Detect Pressence of Missing Values</p></a></li>
<li><a href='#sparse_lag'><p>Compute lagged values for sparse vectors</p></a></li>
<li><a href='#sparse_logical'><p>Create sparse logical vector</p></a></li>
<li><a href='#sparse_mean'><p>Calculate mean from sparse vectors</p></a></li>
<li><a href='#sparse_median'><p>Calculate median from sparse vectors</p></a></li>
<li><a href='#sparse_replace_na'><p>Replace NAs with specified values in sparse vectors</p></a></li>
<li><a href='#sparse_sd'><p>Calculate standard diviation from sparse vectors</p></a></li>
<li><a href='#sparse_sqrt'><p>Calculate sqrt of sparse vectors</p></a></li>
<li><a href='#sparse_var'><p>Calculate variance from sparse vectors</p></a></li>
<li><a href='#sparse_which_na'><p>Which indices are Missing Values</p></a></li>
<li><a href='#sparse-arithmatic'><p>Vector arithmatic with sparse vectors</p></a></li>
<li><a href='#sparse-arithmatic-scalar'><p>Scalar arithmatic with sparse vectors</p></a></li>
<li><a href='#sparsevctrs_options'><p>sparsevctrs options</p></a></li>
<li><a href='#sparsity'><p>Calculate sparsity of data frames, matrices, and sparse matrices</p></a></li>
<li><a href='#type-predicates'><p>Sparse vector type checkers</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Sparse Vectors for Use in Data Frames</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides sparse vectors powered by ALTREP (Alternative
    Representations for R Objects) that behave like regular vectors, and
    can thus be used in data frames. Also provides tools to convert
    between sparse matrices and data frames with sparse columns and
    functions to interact with sparse vectors.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-lib/sparsevctrs">https://github.com/r-lib/sparsevctrs</a>,
<a href="https://r-lib.github.io/sparsevctrs/">https://r-lib.github.io/sparsevctrs/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/sparsevctrs/issues">https://github.com/r-lib/sparsevctrs/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.4.0), rlang (&ge; 1.1.0), vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, Matrix, methods, rmarkdown, testthat (&ge; 3.0.0),
tibble, withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate, rmarkdown, lobstr,
ggplot2, bench, tidyr, ggbeeswarm</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-17 19:23:40 UTC; emilhvitfeldt</td>
</tr>
<tr>
<td>Author:</td>
<td>Emil Hvitfeldt <a href="https://orcid.org/0000-0002-0679-1945"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Davis Vaughan [ctb],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emil Hvitfeldt &lt;emil.hvitfeldt@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-17 20:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sparsevctrs-package'>sparsevctrs: Sparse Vectors for Use in Data Frames</h2><span id='topic+sparsevctrs'></span><span id='topic+sparsevctrs-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Provides sparse vectors powered by ALTREP (Alternative Representations for R Objects) that behave like regular vectors, and can thus be used in data frames. Also provides tools to convert between sparse matrices and data frames with sparse columns and functions to interact with sparse vectors.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Emil Hvitfeldt <a href="mailto:emil.hvitfeldt@posit.co">emil.hvitfeldt@posit.co</a> (<a href="https://orcid.org/0000-0002-0679-1945">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Davis Vaughan <a href="mailto:davis@posit.co">davis@posit.co</a> [contributor]
</p>
</li>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/r-lib/sparsevctrs">https://github.com/r-lib/sparsevctrs</a>
</p>
</li>
<li> <p><a href="https://r-lib.github.io/sparsevctrs/">https://r-lib.github.io/sparsevctrs/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/sparsevctrs/issues">https://github.com/r-lib/sparsevctrs/issues</a>
</p>
</li></ul>


<hr>
<h2 id='coerce_to_sparse_data_frame'>Coerce sparse matrix to data frame with sparse columns</h2><span id='topic+coerce_to_sparse_data_frame'></span>

<h3>Description</h3>

<p>Turning a sparse matrix into a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coerce_to_sparse_data_frame(x, call = rlang::caller_env(0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coerce_to_sparse_data_frame_+3A_x">x</code></td>
<td>
<p>sparse matrix.</p>
</td></tr>
<tr><td><code id="coerce_to_sparse_data_frame_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The only requirement from the sparse matrix is that it contains column names.
</p>


<h3>Value</h3>

<p>data.frame with sparse columns
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coerce_to_sparse_tibble">coerce_to_sparse_tibble()</a></code> <code><a href="#topic+coerce_to_sparse_matrix">coerce_to_sparse_matrix()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
mat &lt;- matrix(sample(0:1, 100, TRUE, c(0.9, 0.1)), nrow = 10)
colnames(mat) &lt;- letters[1:10]
sparse_mat &lt;- Matrix::Matrix(mat, sparse = TRUE)
sparse_mat

res &lt;- coerce_to_sparse_data_frame(sparse_mat)
res

# All columns are sparse
vapply(res, is_sparse_vector, logical(1))

</code></pre>

<hr>
<h2 id='coerce_to_sparse_matrix'>Coerce sparse data frame to sparse matrix</h2><span id='topic+coerce_to_sparse_matrix'></span>

<h3>Description</h3>

<p>Turning data frame with sparse columns into sparse matrix using
<code><a href="Matrix.html#topic+sparseMatrix">Matrix::sparseMatrix()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coerce_to_sparse_matrix(x, call = rlang::caller_env(0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coerce_to_sparse_matrix_+3A_x">x</code></td>
<td>
<p>a data frame or tibble with sparse columns.</p>
</td></tr>
<tr><td><code id="coerce_to_sparse_matrix_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No checking is currently do to <code>x</code> to determine whether it contains sparse
columns or not. Thus it works with any data frame. Needless to say, creating
a sparse matrix out of a dense data frame is not ideal.
</p>


<h3>Value</h3>

<p>sparse matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coerce_to_sparse_data_frame">coerce_to_sparse_data_frame()</a></code> <code><a href="#topic+coerce_to_sparse_tibble">coerce_to_sparse_tibble()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sparse_tbl &lt;- lapply(1:10, function(x) sparse_double(x, x, length = 10))
names(sparse_tbl) &lt;- letters[1:10]
sparse_tbl &lt;- as.data.frame(sparse_tbl)
sparse_tbl

res &lt;- coerce_to_sparse_matrix(sparse_tbl)
res

</code></pre>

<hr>
<h2 id='coerce_to_sparse_tibble'>Coerce sparse matrix to tibble with sparse columns</h2><span id='topic+coerce_to_sparse_tibble'></span>

<h3>Description</h3>

<p>Turning a sparse matrix into a tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coerce_to_sparse_tibble(x, call = rlang::caller_env(0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coerce_to_sparse_tibble_+3A_x">x</code></td>
<td>
<p>sparse matrix.</p>
</td></tr>
<tr><td><code id="coerce_to_sparse_tibble_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The only requirement from the sparse matrix is that it contains column names.
</p>


<h3>Value</h3>

<p>tibble with sparse columns
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coerce_to_sparse_data_frame">coerce_to_sparse_data_frame()</a></code> <code><a href="#topic+coerce_to_sparse_matrix">coerce_to_sparse_matrix()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
mat &lt;- matrix(sample(0:1, 100, TRUE, c(0.9, 0.1)), nrow = 10)
colnames(mat) &lt;- letters[1:10]
sparse_mat &lt;- Matrix::Matrix(mat, sparse = TRUE)
sparse_mat

res &lt;- coerce_to_sparse_tibble(sparse_mat)
res

# All columns are sparse
vapply(res, is_sparse_vector, logical(1))

</code></pre>

<hr>
<h2 id='coerce-vector'>Coerce numeric vector to sparse double</h2><span id='topic+coerce-vector'></span><span id='topic+as_sparse_double'></span><span id='topic+as_sparse_integer'></span><span id='topic+as_sparse_character'></span><span id='topic+as_sparse_logical'></span>

<h3>Description</h3>

<p>Takes a numeric vector, integer or double, and turn it into a sparse double
vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_sparse_double(x, default = 0)

as_sparse_integer(x, default = 0L)

as_sparse_character(x, default = "")

as_sparse_logical(x, default = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coerce-vector_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="coerce-vector_+3A_default">default</code></td>
<td>
<p>default value to use. Defaults to <code>0</code>.
</p>
<p>The values of <code>x</code> must be double or integer. It must not contain any <code>Inf</code> or
<code>NaN</code> values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sparse vectors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_dense &lt;- c(3, 0, 2, 0, 0, 0, 4, 0, 0, 0)
x_sparse &lt;- as_sparse_double(x_dense)
x_sparse

is_sparse_double(x_sparse)
</code></pre>

<hr>
<h2 id='extractors'>Information extraction from sparse vectors</h2><span id='topic+extractors'></span><span id='topic+sparse_positions'></span><span id='topic+sparse_values'></span><span id='topic+sparse_default'></span>

<h3>Description</h3>

<p>Extract positions, values, and default from sparse vectors without the need
to materialize vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_positions(x)

sparse_values(x)

sparse_default(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractors_+3A_x">x</code></td>
<td>
<p>vector to be extracted from.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sparse_default()</code> returns <code>NA</code> when applied to non-sparse vectors. This is
done to have an indicator of non-sparsity.
</p>
<p>for ease of use, these functions also works on non-sparse variables.
</p>


<h3>Value</h3>

<p>vectors of requested attributes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_sparse &lt;- sparse_double(c(pi, 5, 0.1), c(2, 5, 10), 10)
x_dense &lt;- c(0, pi, 0, 0, 0.5, 0, 0, 0, 0, 0.1)

sparse_positions(x_sparse)
sparse_values(x_sparse)
sparse_default(x_sparse)

sparse_positions(x_dense)
sparse_values(x_dense)
sparse_default(x_dense)

x_sparse_3 &lt;- sparse_double(c(pi, 5, 0.1), c(2, 5, 10), 10, default = 3)
sparse_default(x_sparse_3)
</code></pre>

<hr>
<h2 id='has_sparse_elements'>Check for sparse elements</h2><span id='topic+has_sparse_elements'></span>

<h3>Description</h3>

<p>This function checks to see if a data.frame, tibble or list contains one or
more sparse vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_sparse_elements(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="has_sparse_elements_+3A_x">x</code></td>
<td>
<p>a data frame, tibble, or list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The checking in this function is done using <code><a href="#topic+is_sparse_vector">is_sparse_vector()</a></code>, but is
implemented using an early exit pattern to provide fast performance for wide
data.frames.
</p>
<p>This function does not test whether <code>x</code> is a data.frame, tibble or list. It
simply iterates over the elements and sees if they are sparse vectors.
</p>


<h3>Value</h3>

<p>A single logical value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
n_cols &lt;- 10000
mat &lt;- matrix(sample(0:1, n_cols * 10, TRUE, c(0.9, 0.1)), ncol = n_cols)
colnames(mat) &lt;- as.character(seq_len(n_cols))
sparse_mat &lt;- Matrix::Matrix(mat, sparse = TRUE)

res &lt;- coerce_to_sparse_tibble(sparse_mat)
has_sparse_elements(res)

has_sparse_elements(mtcars)

</code></pre>

<hr>
<h2 id='sparse_character'>Create sparse character vector</h2><span id='topic+sparse_character'></span>

<h3>Description</h3>

<p>Construction of vectors where only values and positions are recorded. The
Length and default values determine all other information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_character(values, positions, length, default = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_character_+3A_values">values</code></td>
<td>
<p>integer vector, values of non-zero entries.</p>
</td></tr>
<tr><td><code id="sparse_character_+3A_positions">positions</code></td>
<td>
<p>integer vector, indices of non-zero entries.</p>
</td></tr>
<tr><td><code id="sparse_character_+3A_length">length</code></td>
<td>
<p>integer value, Length of vector.</p>
</td></tr>
<tr><td><code id="sparse_character_+3A_default">default</code></td>
<td>
<p>integer value, value at indices not specified by <code>positions</code>.
Defaults to <code>""</code>. Cannot be <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>values</code> and <code>positions</code> are expected to be the same length, and are allowed
to both have zero length.
</p>
<p>Allowed values for <code>value</code> are character values. Missing values such as <code>NA</code>
and <code>NA_real_</code> are allowed as they are turned into <code>NA_character_</code>.
Everything else is disallowed. The values are also not allowed to take the
same value as <code>default</code>.
</p>
<p><code>positions</code> should be integers or integer-like doubles. Everything else is
not allowed. Positions should furthermore be positive (<code>0</code> not allowed),
unique, and in increasing order. Lastly they should all be smaller that
<code>length</code>.
</p>
<p>For developers:
</p>
<p>setting <code>options("sparsevctrs.verbose_materialize" = TRUE)</code> will print a
message each time a sparse vector has been forced to materialize.
</p>


<h3>Value</h3>

<p>sparse character vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparse_double">sparse_double()</a></code> <code><a href="#topic+sparse_integer">sparse_integer()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sparse_character(character(), integer(), 10)

sparse_character(c("A", "C", "E"), c(2, 5, 10), 10)

str(
  sparse_character(c("A", "C", "E"), c(2, 5, 10), 1000000000)
)
</code></pre>

<hr>
<h2 id='sparse_double'>Create sparse double vector</h2><span id='topic+sparse_double'></span>

<h3>Description</h3>

<p>Construction of vectors where only values and positions are recorded. The
Length and default values determine all other information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_double(values, positions, length, default = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_double_+3A_values">values</code></td>
<td>
<p>double vector, values of non-zero entries.</p>
</td></tr>
<tr><td><code id="sparse_double_+3A_positions">positions</code></td>
<td>
<p>integer vector, indices of non-zero entries.</p>
</td></tr>
<tr><td><code id="sparse_double_+3A_length">length</code></td>
<td>
<p>integer value, Length of vector.</p>
</td></tr>
<tr><td><code id="sparse_double_+3A_default">default</code></td>
<td>
<p>double value, value at indices not specified by <code>positions</code>.
Defaults to <code>0</code>. Cannot be <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>values</code> and <code>positions</code> are expected to be the same length, and are allowed
to both have zero length.
</p>
<p>Allowed values for <code>value</code> is double and integer values. integer values will
be coerced to doubles. Missing values such as <code>NA</code> and <code>NA_real_</code> are
allowed. Everything else is disallowed, This includes <code>Inf</code> and <code>NaN</code>. The
values are also not allowed to take the same value as <code>default</code>.
</p>
<p><code>positions</code> should be integers or integer-like doubles. Everything else is
not allowed. Positions should furthermore be positive (<code>0</code> not allowed),
unique, and in increasing order. Lastly they should all be smaller that
<code>length</code>.
</p>
<p>For developers:
</p>
<p>setting <code>options("sparsevctrs.verbose_materialize" = TRUE)</code> will print a
message each time a sparse vector has been forced to materialize.
</p>


<h3>Value</h3>

<p>sparse double vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparse_integer">sparse_integer()</a></code> <code><a href="#topic+sparse_character">sparse_character()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sparse_double(numeric(), integer(), 10)

sparse_double(c(pi, 5, 0.1), c(2, 5, 10), 10)

str(
  sparse_double(c(pi, 5, 0.1), c(2, 5, 10), 1000000000)
)
</code></pre>

<hr>
<h2 id='sparse_dummy'>Generate sparse dummy variables</h2><span id='topic+sparse_dummy'></span>

<h3>Description</h3>

<p>Generate sparse dummy variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_dummy(x, one_hot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_dummy_+3A_x">x</code></td>
<td>
<p>A factor.</p>
</td></tr>
<tr><td><code id="sparse_dummy_+3A_one_hot">one_hot</code></td>
<td>
<p>A single logical value. Should the first factor level be
included or not. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only factor variables can be used with <code><a href="#topic+sparse_dummy">sparse_dummy()</a></code>. A call to
<code>as.factor()</code> would be required for any other type of data.
</p>
<p>If only a single level is present after <code>one_hot</code> takes effect. Then the
vector produced won't be sparse.
</p>
<p>A missing value at the <code>i</code>th element will produce missing values for all
dummy variables at thr <code>i</code>th position.
</p>


<h3>Value</h3>

<p>A list of sparse integer dummy variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- factor(c("a", "a", "b", "c", "d", "b"))

sparse_dummy(x, one_hot = FALSE)

x &lt;- factor(c("a", "a", "b", "c", "d", "b"))

sparse_dummy(x, one_hot = TRUE)

x &lt;- factor(c("a", NA, "b", "c", "d", NA))

sparse_dummy(x, one_hot = FALSE)

x &lt;- factor(c("a", NA, "b", "c", "d", NA))

sparse_dummy(x, one_hot = TRUE)
</code></pre>

<hr>
<h2 id='sparse_integer'>Create sparse integer vector</h2><span id='topic+sparse_integer'></span>

<h3>Description</h3>

<p>Construction of vectors where only values and positions are recorded. The
Length and default values determine all other information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_integer(values, positions, length, default = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_integer_+3A_values">values</code></td>
<td>
<p>integer vector, values of non-zero entries.</p>
</td></tr>
<tr><td><code id="sparse_integer_+3A_positions">positions</code></td>
<td>
<p>integer vector, indices of non-zero entries.</p>
</td></tr>
<tr><td><code id="sparse_integer_+3A_length">length</code></td>
<td>
<p>integer value, Length of vector.</p>
</td></tr>
<tr><td><code id="sparse_integer_+3A_default">default</code></td>
<td>
<p>integer value, value at indices not specified by <code>positions</code>.
Defaults to <code>0L</code>. Cannot be <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>values</code> and <code>positions</code> are expected to be the same length, and are allowed
to both have zero length.
</p>
<p>Allowed values for <code>value</code> is integer values. This means that the double
vector <code>c(1, 5, 4)</code> is accepted as it can be losslessly converted to the
integer vector <code>c(1L, 5L, 4L)</code>. Missing values such as <code>NA</code> and <code>NA_real_</code>
are allowed. Everything else is disallowed, This includes <code>Inf</code> and <code>NaN</code>.
The values are also not allowed to take the same value as <code>default</code>.
</p>
<p><code>positions</code> should be integers or integer-like doubles. Everything else is
not allowed. Positions should furthermore be positive (<code>0</code> not allowed),
unique, and in increasing order. Lastly they should all be smaller that
<code>length</code>.
</p>
<p>For developers:
</p>
<p>setting <code>options("sparsevctrs.verbose_materialize" = TRUE)</code> will print a
message each time a sparse vector has been forced to materialize.
</p>


<h3>Value</h3>

<p>sparse integer vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparse_double">sparse_double()</a></code> <code><a href="#topic+sparse_character">sparse_character()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sparse_integer(integer(), integer(), 10)

sparse_integer(c(4, 5, 7), c(2, 5, 10), 10)

str(
  sparse_integer(c(4, 5, 7), c(2, 5, 10), 1000000000)
)
</code></pre>

<hr>
<h2 id='sparse_is_na'>Detect Pressence of Missing Values</h2><span id='topic+sparse_is_na'></span>

<h3>Description</h3>

<p>Detect Pressence of Missing Values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_is_na(x, type = "logical")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_is_na_+3A_x">x</code></td>
<td>
<p>A sparse vector.</p>
</td></tr>
<tr><td><code id="sparse_is_na_+3A_type">type</code></td>
<td>
<p>A single string. Most be one of <code>logical</code> or <code>integer</code>.
Determines the resulting vector. If <code>type = integer</code> then a sparse vector is
returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function, as with any of the other helper functions assumes that the
input <code>x</code> is a sparse numeric vector. This is done for performance reasons,
and it is thus the users responsibility to perform input checking.
</p>
<p>Note that the resulting vector will be not be a sparse vector.
</p>


<h3>Value</h3>

<p>A logical vector or sparse integer vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparse_which_na">sparse_which_na()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sparse_is_na(
  sparse_double(c(10, NA, 11), c(1, 50, 111), 1000)
)

sparse_is_na(
  sparse_double(c(10, NA, 11), c(1, 50, 111), 1000),
  type = "integer"
)
</code></pre>

<hr>
<h2 id='sparse_lag'>Compute lagged values for sparse vectors</h2><span id='topic+sparse_lag'></span>

<h3>Description</h3>

<p>Compute lagged values for sparse vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_lag(x, n = 1L, default = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_lag_+3A_x">x</code></td>
<td>
<p>A sparse vector.</p>
</td></tr>
<tr><td><code id="sparse_lag_+3A_n">n</code></td>
<td>
<p>Positive integer of length 1, giving the number of positions to lag
by.</p>
</td></tr>
<tr><td><code id="sparse_lag_+3A_default">default</code></td>
<td>
<p>The value used to pad <code style="white-space: pre;">&#8288;x`` back to its original size after the lag has been applied. The default, &#8288;</code>NULL&ldquo;, pads with a missing value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function, as with any of the other helper functions assumes that the
input <code>x</code> is a sparse numeric vector. This is done for performance reasons,
and it is thus the users responsibility to perform input checking.
</p>


<h3>Value</h3>

<p>sparse vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vec_dbl &lt;- sparse_double(c(pi, 4, 5/2), c(1, 5, 7), 10)

sparse_lag(vec_dbl)
sparse_lag(vec_dbl, n = 3)
sparse_lag(vec_dbl, n = 3, default = 0)

vec_int &lt;- sparse_integer(c(1, 2, 3), c(1, 5, 7), 10)

sparse_lag(vec_int)
sparse_lag(vec_int, n = 3)
sparse_lag(vec_int, n = 3, default = 0L)

vec_chr &lt;- sparse_character(c("A", "B", "C"), c(1, 5, 7), 10)

sparse_lag(vec_chr)
sparse_lag(vec_chr, n = 3)
sparse_lag(vec_chr, n = 3, default = "before")

vec_lgl &lt;- sparse_logical(c(TRUE, TRUE, TRUE), c(1, 5, 7), 10)

sparse_lag(vec_lgl)
sparse_lag(vec_lgl, n = 3)
sparse_lag(vec_lgl, n = 3, default = FALSE)
</code></pre>

<hr>
<h2 id='sparse_logical'>Create sparse logical vector</h2><span id='topic+sparse_logical'></span>

<h3>Description</h3>

<p>Construction of vectors where only values and positions are recorded. The
Length and default values determine all other information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_logical(values, positions, length, default = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_logical_+3A_values">values</code></td>
<td>
<p>logical vector, values of non-zero entries.</p>
</td></tr>
<tr><td><code id="sparse_logical_+3A_positions">positions</code></td>
<td>
<p>integer vector, indices of non-zero entries.</p>
</td></tr>
<tr><td><code id="sparse_logical_+3A_length">length</code></td>
<td>
<p>integer value, Length of vector.</p>
</td></tr>
<tr><td><code id="sparse_logical_+3A_default">default</code></td>
<td>
<p>logical value, value at indices not specified by <code>positions</code>.
Defaults to <code>FALSE</code>. Cannot be <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>values</code> and <code>positions</code> are expected to be the same length, and are allowed
to both have zero length.
</p>
<p>Allowed values for <code>value</code> are logical values. Missing values such as <code>NA</code>
and <code>NA_real_</code> are allowed. Everything else is disallowed, The values are
also not allowed to take the same value as <code>default</code>.
</p>
<p><code>positions</code> should be integers or integer-like doubles. Everything else is
not allowed. Positions should furthermore be positive (<code>0</code> not allowed),
unique, and in increasing order. Lastly they should all be smaller that
<code>length</code>.
</p>
<p>For developers:
</p>
<p>setting <code>options("sparsevctrs.verbose_materialize" = TRUE)</code> will print a
message each time a sparse vector has been forced to materialize.
</p>


<h3>Value</h3>

<p>sparse logical vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparse_double">sparse_double()</a></code> <code><a href="#topic+sparse_integer">sparse_integer()</a></code> <code><a href="#topic+sparse_character">sparse_character()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sparse_logical(logical(), integer(), 10)

sparse_logical(c(TRUE, NA, TRUE), c(2, 5, 10), 10)

str(
  sparse_logical(c(TRUE, NA, TRUE), c(2, 5, 10), 1000000000)
)
</code></pre>

<hr>
<h2 id='sparse_mean'>Calculate mean from sparse vectors</h2><span id='topic+sparse_mean'></span>

<h3>Description</h3>

<p>Calculate mean from sparse vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_mean(x, wts = NULL, na_rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_mean_+3A_x">x</code></td>
<td>
<p>A sparse numeric vector.</p>
</td></tr>
<tr><td><code id="sparse_mean_+3A_wts">wts</code></td>
<td>
<p>A numeric vector, should be same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="sparse_mean_+3A_na_rm">na_rm</code></td>
<td>
<p>Logical, whether to remove missing values. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function, as with any of the other helper functions assumes that the
input <code>x</code> is a sparse numeric vector. This is done for performance reasons,
and it is thus the users responsibility to perform input checking.
</p>


<h3>Value</h3>

<p>single numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sparse_mean(
  sparse_double(1000, 1, 1000)
)

sparse_mean(
  sparse_double(1000, 1, 1000, default = 1)
)

sparse_mean(
  sparse_double(c(10, 50, 11), c(1, 50, 111), 1000)
)

sparse_mean(
  sparse_double(c(10, NA, 11), c(1, 50, 111), 1000)
)

sparse_mean(
  sparse_double(c(10, NA, 11), c(1, 50, 111), 1000),
  na_rm = TRUE
)

</code></pre>

<hr>
<h2 id='sparse_median'>Calculate median from sparse vectors</h2><span id='topic+sparse_median'></span>

<h3>Description</h3>

<p>Calculate median from sparse vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_median(x, na_rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_median_+3A_x">x</code></td>
<td>
<p>A sparse numeric vector.</p>
</td></tr>
<tr><td><code id="sparse_median_+3A_na_rm">na_rm</code></td>
<td>
<p>Logical, whether to remove missing values. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function, as with any of the other helper functions assumes that the
input <code>x</code> is a sparse numeric vector. This is done for performance reasons,
and it is thus the users responsibility to perform input checking.
</p>


<h3>Value</h3>

<p>single numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sparse_median(
  sparse_double(1000, 1, 1000)
)

sparse_median(
  sparse_double(1000, 1, 1000, default = 1)
)

sparse_median(
  sparse_double(c(10, 50, 11), c(1, 50, 111), 1000)
)

sparse_median(
  sparse_double(c(10, NA, 11), c(1, 50, 111), 1000)
)

sparse_median(
  sparse_double(c(10, NA, 11), c(1, 50, 111), 1000),
  na_rm = TRUE
)

</code></pre>

<hr>
<h2 id='sparse_replace_na'>Replace NAs with specified values in sparse vectors</h2><span id='topic+sparse_replace_na'></span>

<h3>Description</h3>

<p>Replace NAs with specified values in sparse vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_replace_na(x, replace)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_replace_na_+3A_x">x</code></td>
<td>
<p>A sparse vector.</p>
</td></tr>
<tr><td><code id="sparse_replace_na_+3A_replace">replace</code></td>
<td>
<p>A single value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function, as with any of the other helper functions assumes that the
input <code>x</code> is a sparse numeric vector. This is done for performance reasons,
and it is thus the users responsibility to perform input checking.
The <code>replace</code> is likewise not type or length checked.
</p>
<p>The output type will match the values after coercion happens during
replacement.
</p>


<h3>Value</h3>

<p>A sparse vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sparse_replace_na(
  sparse_double(c(10, NA, 11), c(1, 5, 10), 10),
  5
)

sparse_replace_na(
  sparse_integer(c(10L, NA, 11L), c(1, 5, 10), 10),
  5L
)

sparse_replace_na(
  sparse_character(c("A", NA, "E"), c(2, 5, 10), 10),
  "missing"
)
</code></pre>

<hr>
<h2 id='sparse_sd'>Calculate standard diviation from sparse vectors</h2><span id='topic+sparse_sd'></span>

<h3>Description</h3>

<p>Calculate standard diviation from sparse vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_sd(x, na_rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_sd_+3A_x">x</code></td>
<td>
<p>A sparse numeric vector.</p>
</td></tr>
<tr><td><code id="sparse_sd_+3A_na_rm">na_rm</code></td>
<td>
<p>Logical, whether to remove missing values. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function, as with any of the other helper functions assumes that the
input <code>x</code> is a sparse numeric vector. This is done for performance reasons,
and it is thus the users responsibility to perform input checking.
</p>
<p>Much like <code><a href="stats.html#topic+sd">sd()</a></code> it uses the denominator <code>n-1</code>.
</p>


<h3>Value</h3>

<p>single numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sparse_sd(
  sparse_double(1000, 1, 1000)
)

sparse_sd(
  sparse_double(1000, 1, 1000, default = 1)
)

sparse_sd(
  sparse_double(c(10, 50, 11), c(1, 50, 111), 1000)
)

sparse_sd(
  sparse_double(c(10, NA, 11), c(1, 50, 111), 1000)
)

sparse_sd(
  sparse_double(c(10, NA, 11), c(1, 50, 111), 1000),
  na_rm = TRUE
)

</code></pre>

<hr>
<h2 id='sparse_sqrt'>Calculate sqrt of sparse vectors</h2><span id='topic+sparse_sqrt'></span>

<h3>Description</h3>

<p>Calculate sqrt of sparse vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_sqrt(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_sqrt_+3A_x">x</code></td>
<td>
<p>A sparse numeric vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function, as with any of the other helper functions assumes that the
input <code>x</code> is a sparse numeric vector. This is done for performance reasons,
and it is thus the users responsibility to perform input checking.
</p>
<p>The output will be a double vector regardless of the input type.
</p>


<h3>Value</h3>

<p>A sparse double vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sparse_sqrt(
  sparse_double(1000, 1, 10)
)

sparse_sqrt(
  sparse_integer(1000, 3, 10, default = 2)
)

sparse_sqrt(
  sparse_double(c(10, NA, 11), c(1, 5, 10), 10)
)
</code></pre>

<hr>
<h2 id='sparse_var'>Calculate variance from sparse vectors</h2><span id='topic+sparse_var'></span>

<h3>Description</h3>

<p>Calculate variance from sparse vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_var(x, na_rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_var_+3A_x">x</code></td>
<td>
<p>A sparse numeric vector.</p>
</td></tr>
<tr><td><code id="sparse_var_+3A_na_rm">na_rm</code></td>
<td>
<p>Logical, whether to remove missing values. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function, as with any of the other helper functions assumes that the
input <code>x</code> is a sparse numeric vector. This is done for performance reasons,
and it is thus the users responsibility to perform input checking.
</p>
<p>Much like <code><a href="stats.html#topic+var">var()</a></code> it uses the denominator <code>n-1</code>.
</p>


<h3>Value</h3>

<p>single numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sparse_var(
  sparse_double(1000, 1, 1000)
)

sparse_var(
  sparse_double(1000, 1, 1000, default = 1)
)

sparse_var(
  sparse_double(c(10, 50, 11), c(1, 50, 111), 1000)
)

sparse_var(
  sparse_double(c(10, NA, 11), c(1, 50, 111), 1000)
)

sparse_var(
  sparse_double(c(10, NA, 11), c(1, 50, 111), 1000),
  na_rm = TRUE
)

</code></pre>

<hr>
<h2 id='sparse_which_na'>Which indices are Missing Values</h2><span id='topic+sparse_which_na'></span>

<h3>Description</h3>

<p>Which indices are Missing Values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_which_na(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_which_na_+3A_x">x</code></td>
<td>
<p>A sparse vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function, as with any of the other helper functions assumes that the
input <code>x</code> is a sparse numeric vector. This is done for performance reasons,
and it is thus the users responsibility to perform input checking.
</p>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparse_is_na">sparse_is_na()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sparse_which_na(
  sparse_double(c(10, NA, 11), c(1, 50, 111), 1000)
)
</code></pre>

<hr>
<h2 id='sparse-arithmatic'>Vector arithmatic with sparse vectors</h2><span id='topic+sparse-arithmatic'></span><span id='topic+sparse_multiplication'></span>

<h3>Description</h3>

<p>Do arithmatic operations on sparse vectors while trying to void destroying
the sparsity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_multiplication(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse-arithmatic_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="sparse-arithmatic_+3A_y">y</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function works with both sparse and dense vectors for both <code>x</code>
and <code>y</code>, returning a sparse or dense vector according to the input.
</p>
<p>For <code>sparse_multiplication()</code> the class of the resulting vector depends on
the classes of <code>x</code> and <code>y</code>. If both <code>x</code> and <code>y</code> are integer vectors then an
integer vector is returned, otherwise a double vector is returned.
</p>
<p><code>sparse_multiplication()</code> will return a non-sparse vector if both <code>x</code> and <code>y</code>
is non-sparse. Otherwise a sparse vector is returned.
</p>
<p><code>sparse_multiplication()</code> will destroy sparsity of sparse vectors with non-0
<code>default</code> values.
</p>


<h3>Value</h3>

<p>A sparse vector of same type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_sparse &lt;- sparse_double(c(pi, 5, 0.1), c(2, 5, 10), 10)

sparse_multiplication(x_sparse, x_sparse)
</code></pre>

<hr>
<h2 id='sparse-arithmatic-scalar'>Scalar arithmatic with sparse vectors</h2><span id='topic+sparse-arithmatic-scalar'></span><span id='topic+sparse_division_scalar'></span><span id='topic+sparse_multiplication_scalar'></span><span id='topic+sparse_addition_scalar'></span><span id='topic+sparse_subtraction_scalar'></span>

<h3>Description</h3>

<p>Do Arithmatic on sparse vectors without destroying the sparsity. Note that
only multiplication and division preserves the default value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_division_scalar(x, val)

sparse_multiplication_scalar(x, val)

sparse_addition_scalar(x, val)

sparse_subtraction_scalar(x, val)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse-arithmatic-scalar_+3A_x">x</code></td>
<td>
<p>A sparse vector.</p>
</td></tr>
<tr><td><code id="sparse-arithmatic-scalar_+3A_val">val</code></td>
<td>
<p>A single numeric value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No checking of the inputs are being done.
</p>
<p><code>sparse_division_scalar()</code> and <code>sparse_multiplication_scalar()</code> are the most
used ones, as they preserve the default, which is often what you want to do.
</p>
<p><code>sparse_division_scalar()</code> always produces double vectors, regardless of
whether they could be represented as integers or not. Expect when <code>val = 1</code>
as the input is returned unchanged, or <code>val = NA</code> as the input returned will
be <code>NA</code> or the appropiate type.
</p>


<h3>Value</h3>

<p>A sparse vector of same type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_sparse &lt;- sparse_double(c(pi, 5, 0.1), c(2, 5, 10), 10)

sparse_division_scalar(x_sparse, 2)
sparse_multiplication_scalar(x_sparse, 2)
sparse_addition_scalar(x_sparse, 2)
sparse_subtraction_scalar(x_sparse, 2)
</code></pre>

<hr>
<h2 id='sparsevctrs_options'>sparsevctrs options</h2><span id='topic+sparsevctrs_options'></span>

<h3>Description</h3>

<p>These options can be set with <code>options()</code>.
</p>


<h3>Details</h3>



<h4>sparsevctrs.verbose_materialize</h4>

<p>This option is meant to be used as a diagnostic tool. Materialization of
sparse vectors are done silently by default. This can make it hard to
determine if your code is doing what you want.
</p>
<p>Setting <code>sparsevctrs.verbose_materialize</code> is a way to alert when
materialization occurs. Note that only the first materialization is counted
for the options below, as the materialized vector is cached.
</p>
<p>Setting <code>sparsevctrs.verbose_materialize = 1</code> or
<code>sparsevctrs.verbose_materialize = TRUE</code> will result in a message being
emitted each time a sparse vector is materialized.
</p>
<p>Setting <code>sparsevctrs.verbose_materialize = 2</code> will result in a warning being
thrown each time a sparse vector is materialized.
</p>
<p>Setting <code>sparsevctrs.verbose_materialize = 3</code> will result in an error being
thrown each time a sparse vector is materialized.
</p>


<hr>
<h2 id='sparsity'>Calculate sparsity of data frames, matrices, and sparse matrices</h2><span id='topic+sparsity'></span>

<h3>Description</h3>

<p>Turning data frame with sparse columns into sparse matrix using
<code><a href="Matrix.html#topic+sparseMatrix">Matrix::sparseMatrix()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsity(x, sample = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparsity_+3A_x">x</code></td>
<td>
<p>a data frame, matrix of sparse matrix.</p>
</td></tr>
<tr><td><code id="sparsity_+3A_sample">sample</code></td>
<td>
<p>a integer or <code>NULL</code>. Number of rows to sample to estimate
sparsity. If <code>NULL</code> then no sampling is performed. Will not be used when
<code>x</code> is a sparse matrix. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only numeric 0s are considered zeroes in this calculations. Missing values,
logical vectors and then string <code>"0"</code> aren't counted.
</p>


<h3>Value</h3>

<p>a single number, between 0 and 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data frame
sparsity(mtcars)

# Matrix
set.seed(1234)
mat &lt;- matrix(sample(0:1, 100, TRUE, c(0.9, 0.1)), nrow = 10)
colnames(mat) &lt;- letters[1:10]

sparsity(mat)

# Sparse matrix
sparse_mat &lt;- Matrix::Matrix(mat, sparse = TRUE)

sparsity(sparse_mat)
</code></pre>

<hr>
<h2 id='type-predicates'>Sparse vector type checkers</h2><span id='topic+type-predicates'></span><span id='topic+is_sparse_vector'></span><span id='topic+is_sparse_numeric'></span><span id='topic+is_sparse_double'></span><span id='topic+is_sparse_integer'></span><span id='topic+is_sparse_character'></span><span id='topic+is_sparse_logical'></span>

<h3>Description</h3>

<p>Helper functions to determine whether an vector is a sparse vector or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_sparse_vector(x)

is_sparse_numeric(x)

is_sparse_double(x)

is_sparse_integer(x)

is_sparse_character(x)

is_sparse_logical(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type-predicates_+3A_x">x</code></td>
<td>
<p>value to be checked.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is_sparse_vector()</code> is a general function that detects any type of sparse
vector created with this package. <code>is_sparse_double()</code>,
<code>is_sparse_integer()</code>, <code>is_sparse_character()</code>, and <code>is_sparse_logical()</code> are
more specific functions that only detects the type. <code>is_sparse_numeric()</code>
matches both sparse integers and doubles.
</p>


<h3>Value</h3>

<p>single logical value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_sparse &lt;- sparse_double(c(pi, 5, 0.1), c(2, 5, 10), 10)
x_dense &lt;- c(0, pi, 0, 0, 0.5, 0, 0, 0, 0, 0.1)

is_sparse_vector(x_sparse)
is_sparse_vector(x_dense)

is_sparse_double(x_sparse)
is_sparse_double(x_dense)

is_sparse_character(x_sparse)
is_sparse_character(x_dense)

# Forced materialization
is_sparse_vector(x_sparse[])
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
