<!DOCTYPE html><html><head><title>Help for package ahaz</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ahaz}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ahaz'><p>Fit semiparametric additive hazards model</p></a></li>
<li><a href='#ahaz.adjust'><p>Adjusted univariate association measures from ahaz</p></a></li>
<li><a href='#ahaz.partial'><p>Partial calculation of estimating quantities used by ahaz</p></a></li>
<li><a href='#ahaz.tune.control'><p>Tuning controls for regularization</p></a></li>
<li><a href='#ahazisis'><p>Independent screening for the semiparametric</p>
additive hazards model</a></li>
<li><a href='#ahazpen'><p>Fit penalized semiparametric additive hazards model</p></a></li>
<li><a href='#ahazpen.fit.control'><p>Controls for ahazpen fitting algorithm</p></a></li>
<li><a href='#ahazpen.pen.control'><p>Penalty controls for ahazpen</p></a></li>
<li><a href='#plot.ahaz'><p>Plot an ahaz object</p></a></li>
<li><a href='#plot.ahazpen'><p>Plot an ahazpen object</p></a></li>
<li><a href='#plot.cumahaz'><p>Plot a cumahaz object</p></a></li>
<li><a href='#plot.tune.ahazpen'><p>Plot a tune.ahazpen object</p></a></li>
<li><a href='#predict.ahaz'><p>Prediction methods for ahaz</p></a></li>
<li><a href='#predict.ahazpen'><p>Prediction methods for ahazpen</p></a></li>
<li><a href='#predict.tune.ahazpen'><p>Prediction methods for tune.ahazpen</p></a></li>
<li><a href='#print.ahazisis'><p>Print an ahazisis object</p></a></li>
<li><a href='#print.ahazpen'><p>Print an ahazpen object</p></a></li>
<li><a href='#print.summary.ahaz'><p>Print a summary.ahaz object</p></a></li>
<li><a href='#print.tune.ahazpen'><p>Print a tune.ahazpen object</p></a></li>
<li><a href='#sorlie'><p>Sorlie gene expressions</p></a></li>
<li><a href='#summary.ahaz'><p>Summarize an ahaz object</p></a></li>
<li><a href='#tune.ahazpen'><p>Choice of penalty parameter in ahazpen</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Regularization for Semiparametric Additive Hazards Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>1.15</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-12</td>
</tr>
<tr>
<td>Author:</td>
<td>Anders Gorst-Rasmussen &lt;agorstras@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anders Gorst-Rasmussen &lt;agorstras@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), survival, Matrix, methods</td>
</tr>
<tr>
<td>Description:</td>
<td>Computationally efficient procedures for regularized
        estimation with the semiparametric additive hazards regression
        model.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-12 15:54:11 UTC; AGTR</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-13 06:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='ahaz'>Fit semiparametric additive hazards model</h2><span id='topic+ahaz'></span>

<h3>Description</h3>

<p>Fit a semiparametric additive hazards regression
model. Right-censored and left-truncated survival data are supported.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ahaz(surv, X, weights, univariate=FALSE, robust=FALSE)  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ahaz_+3A_surv">surv</code></td>
<td>
<p>Response in the form of a survival object, as returned by the
function <code>Surv()</code> in the package <span class="pkg">survival</span>. Right-censoring
and left-truncation is supported. Tied survival times are not supported.</p>
</td></tr>
<tr><td><code id="ahaz_+3A_x">X</code></td>
<td>
<p>Design matrix. Missing values are not supported.</p>
</td></tr>
<tr><td><code id="ahaz_+3A_weights">weights</code></td>
<td>
<p>Optional vector of observation weights. Default is 1 for each observation.</p>
</td></tr>
<tr><td><code id="ahaz_+3A_univariate">univariate</code></td>
<td>
<p>Fit all univariate models instead of the joint
model. Default is <code>univar =
      FALSE</code>.</p>
</td></tr>
<tr><td><code id="ahaz_+3A_robust">robust</code></td>
<td>
<p>Robust calculation of variance. Default is <code>robust = FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The semiparametric additive hazards model specifies a hazard function
of the form:
</p>
<p style="text-align: center;"><code class="reqn">h(t) = h_0(t) + \beta' Z_i</code>
</p>

<p>for <code class="reqn">i=1,\ldots,n</code> where <code class="reqn">Z_i</code> is the vector of covariates,
<code class="reqn">\beta</code> the vector of regression coefficients and <code class="reqn">h_0</code> is an
unspecified baseline hazard. The semiparametric additive hazards model
can be viewed as an
additive analogue of the well-known Cox proportional hazards
regression model.
</p>
<p>Estimation is based on the estimating equations of Lin &amp; Ying (1994).
</p>
<p>The option <code>univariate</code> is intended for screening purposes in
data sets with a large number of covariates. It is substantially faster than the
standard approach of combining <code>ahaz</code> with
<code>apply</code>, see the examples.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"ahaz"</code>.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The call that produced this object.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code>nvars</code></td>
<td>
<p>Number of covariates.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>A <code>nvars x nvars</code>  matrix (or vector of length
<code>nvars</code> if <code>univar =
      TRUE</code>).</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>A vector of length <code>nvars</code>; the
regression coefficients equal <code>solve(D,d)</code>.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>An <code>nvars x nvars</code> matrix such that <code class="reqn">D^{-1} B
  D^{-1}</code> estimates the
covariance matrix of the regression coefficients. If <code>robust=FALSE</code>
then <code>B</code> is estimated using an asymptotic approximation; if
<code>robust=TRUE</code> then <code>B</code> is estimated from residuals, see <code><a href="#topic+residuals.ahaz">residuals</a></code>.</p>
</td></tr>
<tr><td><code>univariate</code></td>
<td>
<p>Is <code>univariate=TRUE</code>?</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Formatted version of original data (for internal use).</p>
</td></tr>
<tr><td><code>robust</code></td>
<td>
<p>Is <code>robust=TRUE</code>?</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lin, D.Y. &amp; Ying, Z. (1994). <em>Semiparametric analysis of
the additive risk model.</em> Biometrika; <b>81</b>:61-71.</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.ahaz">summary.ahaz</a></code>, <code><a href="#topic+predict.ahaz">predict.ahaz</a></code>,
<code><a href="#topic+plot.ahaz">plot.ahaz</a></code>.
The functions <code><a href="#topic+coef.ahaz">coef</a></code>,
<code><a href="#topic+vcov.ahaz">vcov</a></code>, <code><a href="#topic+residuals.ahaz">residuals</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sorlie)

# Break ties
set.seed(10101)
time &lt;- sorlie$time+runif(nrow(sorlie))*1e-2

# Survival data + covariates
surv &lt;- Surv(time,sorlie$status)
X &lt;- as.matrix(sorlie[,15:24])

# Fit additive hazards model
fit1 &lt;- ahaz(surv, X)
summary(fit1)

# Univariate models
X &lt;- as.matrix(sorlie[,3:ncol(sorlie)])
fit2 &lt;- ahaz(surv, X, univariate = TRUE)
# Equivalent to the following (slower) solution
beta &lt;- apply(X,2,function(x){coef(ahaz(surv,x))})
plot(beta,coef(fit2))

</code></pre>

<hr>
<h2 id='ahaz.adjust'>Adjusted univariate association measures from ahaz</h2><span id='topic+ahaz.adjust'></span>

<h3>Description</h3>

<p>Fast calculation of univariate association measures  in the
semiparametric additive risk model, adjusted for user-specified covariates</p>


<h3>Usage</h3>

<pre><code class='language-R'>ahaz.adjust(surv, X, weights, idx, method=c("coef", "z", "crit"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ahaz.adjust_+3A_surv">surv</code></td>
<td>
<p>Response in the form of a survival object, as returned by the
function <code>Surv()</code> in the package <span class="pkg">survival</span>. Right-censored
and counting process format (left-truncation) is supported. Tied
survival times are not supported.</p>
</td></tr>
<tr><td><code id="ahaz.adjust_+3A_x">X</code></td>
<td>
<p>Design matrix. Missing values are not supported.</p>
</td></tr>
<tr><td><code id="ahaz.adjust_+3A_weights">weights</code></td>
<td>
<p>Optional vector of observation weights. Default is 1
for each observation.</p>
</td></tr>
<tr><td><code id="ahaz.adjust_+3A_idx">idx</code></td>
<td>
<p>Vector specifying the indices of the covariates to adjust
for.</p>
</td></tr>
<tr><td><code id="ahaz.adjust_+3A_method">method</code></td>
<td>
<p>The type of adjusted association measure to calculate. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is intended mainly for <strong>programming use</strong> and
screening purposes, when a very large number of covariates are considered and direct application of
<code>ahaz</code> is unfeasible.
</p>
<p>Running this function is equivalent to running <code>ahaz</code> with
design matrix <code>cbind(X[,i],X[,idx])</code> for each column <code>X[,i]</code> in
<code>X</code>. By utilizing basic matrix identities, <code>ahaz.adjust</code>
runs many times faster.
</p>
<p>The following univariate association measures are currently implemented:
</p>

<ul>
<li>  <p><code>method="z"</code>,  <code class="reqn">Z</code>-statistics, obtained from a
fitted <code>ahaz</code> model.
</p>
</li>
<li>  <p><code>method="coef"</code>, regression coefficients, obtained from a
fitted <code>ahaz</code> model.
</p>
</li>
<li> <p><code>method="crit"</code>, the increase in
the natural loss function of the
semiparametric additive hazards model when the covariate is included
in the model.
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The call that produced this object.</p>
</td></tr>
<tr><td><code>idx</code></td>
<td>
<p>A copy of the argument <code>idx</code>.</p>
</td></tr>
<tr><td><code>adj</code></td>
<td>
<p>Adjusted association statistic, as specified by <code>method</code>. Entries with index in
<code>idx</code> are set to <code>NA</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ahaz">ahaz</a></code>, <code><a href="#topic+ahaz.partial">ahaz.partial</a></code>, <code><a href="#topic+ahazisis">ahazisis</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sorlie)

# Break ties
set.seed(10101)
time &lt;- sorlie$time+runif(nrow(sorlie))*1e-2

# Survival data + covariates
surv &lt;- Surv(time,sorlie$status)
X &lt;- as.matrix(sorlie[,3:ncol(sorlie)])

# Adjust for first 10 covariates
idx &lt;- 1:10
a &lt;- ahaz.adjust(surv,X,idx=idx)

# Compare with (slower) solution
b &lt;- apply(X[,-idx],2,function(x){coef(ahaz(surv,cbind(x,X[,idx])))[1]})
plot(b,a$adj[-idx])
</code></pre>

<hr>
<h2 id='ahaz.partial'>Partial calculation of estimating quantities used by ahaz</h2><span id='topic+ahaz.partial'></span>

<h3>Description</h3>

<p>Partial calculation of the quantities used in the estimating equations for
ahaz.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ahaz.partial(surv, X, weights, idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ahaz.partial_+3A_surv">surv</code></td>
<td>
<p>Response in the form of a survival object, as returned by the
function <code>Surv()</code> in the package <span class="pkg">survival</span>. Right-censored
and counting process format (left-truncation) is supported. Tied
survival times are not supported.</p>
</td></tr>
<tr><td><code id="ahaz.partial_+3A_x">X</code></td>
<td>
<p>Design matrix. Missing values are not supported.</p>
</td></tr>
<tr><td><code id="ahaz.partial_+3A_weights">weights</code></td>
<td>
<p>Optional vector of observation weights. Default is 1
for each observation.</p>
</td></tr>
<tr><td><code id="ahaz.partial_+3A_idx">idx</code></td>
<td>
<p>Vector of indices of covariates to use in the calculations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is intended mainly for <strong>programming use</strong> when a
very large number of covariates are considered and direct application of
<code>ahaz</code> is unfeasible.
</p>
<p>The estimating equations for the semiparametric additive hazards model
are of the form <code class="reqn">D\beta=d</code> with <code class="reqn">D</code> a quadratic matrix with
number of columns equal to the number of covariates. The present
function returns <code>d[idx]</code>, <code>D[idx,]</code>, and <code>B[idx,]</code>;
the latter a matrix such that <code class="reqn">D^{-1} B
  D^{-1}</code> estimates the
covariance matrix of the regression coefficients.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The call that produced this object.</p>
</td></tr>
<tr><td><code>idx</code></td>
<td>
<p>A copy of the argument <code>idx</code>.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code>nvars</code></td>
<td>
<p>Number of covariates.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>Vector of length <code>length(idx)</code>.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Matrix of size <code>length(idx) x nvars</code>.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Matrix of size <code>length(idx) x nvars</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ahaz">ahaz</a></code>, <code><a href="#topic+ahaz.adjust">ahaz.adjust</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sorlie)

# Break ties
set.seed(10101)
time &lt;- sorlie$time+runif(nrow(sorlie))*1e-2

# Survival data + covariates
surv &lt;- Surv(time,sorlie$status)
X &lt;- as.matrix(sorlie[,3:ncol(sorlie)])

# Get D for the first 10 covariates only
a&lt;-ahaz.partial(surv,X,idx=1:10)
pD1 &lt;- a$D

# Equivalent to the (slower) solution
b &lt;- ahaz(surv,X)
pD2 &lt;- b$D[1:10,]
max(abs(pD1-pD2))

</code></pre>

<hr>
<h2 id='ahaz.tune.control'>Tuning controls for regularization</h2><span id='topic+ahaz.tune.control'></span><span id='topic+cv.control'></span><span id='topic+bic.control'></span>

<h3>Description</h3>

<p>Define the type of tuning method used for regularization. Currently only used by <code>tune.ahazpen</code>. </p>


<h3>Usage</h3>

<pre><code class='language-R'># Cross-validation
cv.control(nfolds=5, reps=1, foldid=NULL, trace=FALSE)

# BIC-inspired
bic.control(factor = function(nobs){log(nobs)})
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ahaz.tune.control_+3A_nfolds">nfolds</code></td>
<td>
<p>Number of folds for cross-validation. Default is
<code>nfolds=5</code>. Each fold must
have size &gt; 1, i.e. <code>nfolds</code> must be
less than half the sample size.</p>
</td></tr>
<tr><td><code id="ahaz.tune.control_+3A_reps">reps</code></td>
<td>
<p>Number of repetitions of cross-validation with
<code>nfolds</code> folds. Default is <code>rep=1</code>. A <code>rep</code>
larger than 1 can be useful to reduce variance of cross-validation
scores.</p>
</td></tr>
<tr><td><code id="ahaz.tune.control_+3A_foldid">foldid</code></td>
<td>
<p>An optional vector of values between 1 and <code>nfolds</code>
identifying the fold to which each observation belongs. Supercedes
<code>nfolds</code> and <code>rep</code> if supplied.</p>
</td></tr>
<tr><td><code id="ahaz.tune.control_+3A_trace">trace</code></td>
<td>
<p>Print progress of cross-validation. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="ahaz.tune.control_+3A_factor">factor</code></td>
<td>
<p>Defines how strongly the number of nonzero penalty
parameters penalizes the score in a BIC-type criterion; see the details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For examples of usage, see <code><a href="#topic+tune.ahazpen">tune.ahazpen</a></code>.
</p>
<p>The regression coefficients of the semiparametric additive hazards
model are estimated by solving a linear system of estimating equations of the form
<code class="reqn">D\beta=d</code> with respect to <code class="reqn">\beta</code>. The natural loss function
for such a linear function is of the least-squares type
</p>
<p style="text-align: center;"><code class="reqn">L(\beta)=\beta' D \beta -2d'\beta.</code>
</p>

<p>This loss function is used for cross-validation as described by Martinussen
&amp; Scheike (2008).
</p>
<p>Penalty parameter selection via a BIC-inspired approach was described by
Gorst-Rasmussen &amp; Scheike (2011). With <code class="reqn">df</code> is the degrees of freedom and <code class="reqn">n</code> the number of
observations, we consider a BIC inspired criterion of the form
</p>
<p style="text-align: center;"><code class="reqn">BIC = \kappa L(\beta) + df\cdot factor(n)</code>
</p>

<p>where <code class="reqn">\kappa</code> is a scaling constant included to remove dependency on the
time scale and better mimick the behavior of a &lsquo;real&rsquo; (likelihood) BIC. The default <code>factor=function(n){log(n)}</code> has
desirable theoretical properties but may be conservative in practice.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"ahaz.tune.control"</code>. 
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>Type of penalty.</p>
</td></tr>
<tr><td><code>factor</code></td>
<td>
<p>Function specified by <code>factor</code>, if applicable</p>
</td></tr>
<tr><td><code>getfolds</code></td>
<td>
<p>A function specifying how folds are calculated, if applicable.</p>
</td></tr>
<tr><td><code>rep</code></td>
<td>
<p>How many repetitions of cross-validation, if applicable.</p>
</td></tr>
<tr><td><code>trace</code></td>
<td>
<p>Print out progress?</p>
</td></tr>
</table>


<h3>References</h3>

<p> Gorst-Rasmussen, A. &amp; Scheike,
T. H. (2011). <em>Independent screening for single-index hazard rate
models with ultra-high dimensional features.</em>  Technical report
R-2011-06, Department of Mathematical Sciences, Aalborg University.
</p>
<p>Martinussen, T. &amp; Scheike, T. H. (2008). <em>Covariate selection for
the semiparametric additive risk model.</em> Scandinavian Journal of
Statistics; <b>36</b>:602-619.  </p>


<h3>See Also</h3>

<p><code><a href="#topic+tune.ahazpen">tune.ahazpen</a></code></p>

<hr>
<h2 id='ahazisis'>Independent screening for the semiparametric
additive hazards model</h2><span id='topic+ahazisis'></span>

<h3>Description</h3>

<p>Fast and scalable model selection for the semiparametric additive hazards
model via univariate screening combined with penalized regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ahazisis(surv, X, weights, standardize=TRUE,
        nsis=floor(nobs/1.5/log(nobs)), do.isis=TRUE,
        maxloop=5, penalty=sscad.control(), tune=cv.control(),
        rank=c("FAST","coef","z","crit"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ahazisis_+3A_surv">surv</code></td>
<td>
<p>Response in the form of a survival object, as returned by the
function <code>Surv()</code> in the package <span class="pkg">survival</span>. Right-censored
and counting process format (left-truncation) is supported. Tied
survival times are not supported.</p>
</td></tr>
<tr><td><code id="ahazisis_+3A_x">X</code></td>
<td>
<p>Design matrix. Missing values are not supported.</p>
</td></tr>
<tr><td><code id="ahazisis_+3A_weights">weights</code></td>
<td>
<p>Optional vector of observation weights. Default is 1 for each observation.</p>
</td></tr>
<tr><td><code id="ahazisis_+3A_standardize">standardize</code></td>
<td>
<p>Logical flag for variable standardization, prior to
model fitting. Estimates are always returned on
the original scale. Default is <code>standardize=TRUE</code>.</p>
</td></tr>
<tr><td><code id="ahazisis_+3A_nsis">nsis</code></td>
<td>
<p>Number of covariates to recruit initially. If
<code>do.isis=TRUE</code>, then this is also the maximal number of variables
that the algorithm will recruit.  Default is
<code>nsis=floor(nobs/log(nobs)/1.5)</code></p>
</td></tr></table>
<p>. 
</p>
<table>
<tr><td><code id="ahazisis_+3A_do.isis">do.isis</code></td>
<td>
<p>Perform iterated independent screening?</p>
</td></tr>
<tr><td><code id="ahazisis_+3A_maxloop">maxloop</code></td>
<td>
<p>Maximal number of iterations of the algorithm if <code>do.isis=TRUE</code>.</p>
</td></tr>
<tr><td><code id="ahazisis_+3A_rank">rank</code></td>
<td>
<p>Method to use for (re)recruitment of variables. See details.</p>
</td></tr>
<tr><td><code id="ahazisis_+3A_penalty">penalty</code></td>
<td>
<p>A description of the penalty function to be used for
the variable selection part. This can be a character string naming a penalty
function  (currently <code>"lasso"</code> or stepwise SCAD, <code>"sscad"</code>)
or a call to the penalty function. Default is
<code>penalty=sscad.control()</code>. See <code><a href="#topic+ahazpen">ahazpen</a></code> and
<code><a href="#topic+ahazpen.pen.control">ahazpen.pen.control</a></code> for more options and examples.</p>
</td></tr>
<tr><td><code id="ahazisis_+3A_tune">tune</code></td>
<td>
<p>A description of the tuning method to be used for the
variable selection part. This can be
a character string naming a tuning control
function (currently <code>"cv"</code> or <code>"bic"</code>) or a call to the tuning control function. Default is
<code>tune=cv.control()</code>.  See <code><a href="#topic+ahaz.tune.control">ahaz.tune.control</a></code> for options
and examples.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a basic implementation of the iterated sure
independent screening method described
in Gorst-Rasmussen &amp; Scheike (2011). Briefly, the algorithm does the following:
</p>

<ol>
<li><p> Recruits the <code>nsis</code> most relevant covariates by ranking them according to the univariate ranking
method described by <code>rank</code>.
</p>
</li>
<li><p> Selects, using <code>ahazpen</code> with penalty function described
in <code>penalty</code>, a model among the
top two thirds  of the <code>nsis</code> most relevant covariates. Call the
size of this model <code class="reqn">m</code>.
</p>
</li>
<li><p> Recruits '<code>nsis</code> minus <code class="reqn">m</code>' new covariates among the non-selected
covariates by ranking their relevance according to the univariate
ranking method described in <code>rank</code>, adjusted for the already
selected variables (using an unpenalized semiparametric additive
hazards model).
</p>
</li></ol>

<p>Steps 2-3 are iterated for  <code>maxloop</code> times, or until <code>nsis</code> covariates has been recruited, or until the
set of selected covariate is stable between two iterations; whichever
comes first.
</p>
<p>The following choices of ranking method exist:
</p>

<ul>
<li>  <p><code>rank="FAST"</code> corresponds to ranking, in the initial
recruitment step only, by the basic FAST- statistic
described in Gorst-Rasmussen &amp; Scheike (2011). If <code>do.isis=TRUE</code>
then the algorithm sets <code>rank="z"</code> for subsequent rankings.
</p>
</li>
<li> <p><code>rank="coef"</code> corresponds to ranking by absolute value of
(univariate) regression coefficients, obtained via <code>ahaz</code> 

</p>
</li>
<li>  <p><code>rank="z"</code> corresponds to ranking by the <code class="reqn">|Z|</code>-statistic of
the (univariate) regression coefficients, obtained via <code>ahaz</code>
</p>
</li>
<li> <p><code>rank="crit"</code> corresponds to ranking by the size
of the decrease in
the (univariate) natural loss function used for estimation by <code>ahaz</code>.

</p>
</li></ul>



<h3>Value</h3>

<p>An object with S3 class <code>"ahazisis"</code>.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The call that produced this object.</p>
</td></tr>
<tr><td><code>initRANKorder</code></td>
<td>
<p>The initial ranking order.</p>
</td></tr>
<tr><td><code>detail.pickind</code></td>
<td>
<p>List (of length at most <code>maxloop</code>) listing
the covariates
selected in each recruitment step.</p>
</td></tr>
<tr><td><code>detail.ISISind</code></td>
<td>
<p>List (of length at most <code>maxloop</code>) listing
the covariates
selected in each variable selection step.</p>
</td></tr>
<tr><td><code>detail.ISIScoef</code></td>
<td>
<p>List (of length at most <code>maxloop</code>)
listing the estimated penalized regression coefficients corresponding to
the indices in <code>detail.ISISind</code>.</p>
</td></tr>
<tr><td><code>SISind</code></td>
<td>
<p>Indices of covariates selected in the
initial recruitment step.</p>
</td></tr>
<tr><td><code>ISISind</code></td>
<td>
<p>Indices of the final set of covariates selected by the
iterated algorithm.</p>
</td></tr>
<tr><td><code>ISIScoef</code></td>
<td>
<p>Vector of the penalized regression coefficients of the
covariates in  <code>ISISind</code>.</p>
</td></tr>
<tr><td><code>nsis</code></td>
<td>
<p>The argument <code>nsis</code>.</p>
</td></tr>
<tr><td><code>do.isis</code></td>
<td>
<p>The argument <code>do.isis</code>.</p>
</td></tr>
<tr><td><code>maxloop</code></td>
<td>
<p>The argument <code>maxloop</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gorst-Rasmussen, A. &amp; Scheike, T. H. (2011). <em>Independent screening for
single-index hazard rate models with ultra-high dimensional features.</em>
Technical report R-2011-06, Department of Mathematical Sciences, Aalborg University.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.ahazisis">print.ahazisis</a></code>, <code><a href="#topic+ahazpen">ahazpen</a></code>, <code><a href="#topic+ahaz.adjust">ahaz.adjust</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sorlie)

# Break ties
set.seed(10101)
time &lt;- sorlie$time+runif(nrow(sorlie))*1e-2

# Survival data + covariates
surv &lt;- Surv(time,sorlie$status)
X &lt;- as.matrix(sorlie[,3:ncol(sorlie)])

# Basic ISIS/SIS with a single step
set.seed(10101)
m1 &lt;- ahazisis(surv,X,maxloop=1,rank="coef")
m1
# Indices of the variables from the initial recruitment step
m1$SISind
# Indices of selected variables
m1$ISISind
# Check fit
score &lt;- X[,m1$ISISind]%*%m1$ISIScoef
plot(survfit(surv~I(score&gt;median(score))))

</code></pre>

<hr>
<h2 id='ahazpen'>Fit penalized semiparametric additive hazards model</h2><span id='topic+ahazpen'></span>

<h3>Description</h3>

<p> Fit a  semiparametric additive hazards model via penalized
estimating equations using, for example, the lasso penalty. The complete regularization path is computed  at a grid
of values for the penalty parameter lambda via the method of cyclic
coordinate descent. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ahazpen(surv, X, weights,  standardize=TRUE,  penalty=lasso.control(),
        nlambda=100, dfmax=nvars, pmax=min(nvars, 2*dfmax),
        lambda.minf=ifelse(nobs &lt; nvars,0.05, 1e-4), lambda,
        penalty.wgt=NULL, keep=NULL, control=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ahazpen_+3A_surv">surv</code></td>
<td>
<p>Response in the form of a survival object, as returned by the
function <code>Surv()</code> in the package <span class="pkg">survival</span>. Right-censored
and counting process format (left-truncation) is supported. Tied
survival times are not supported.</p>
</td></tr>
<tr><td><code id="ahazpen_+3A_x">X</code></td>
<td>
<p>Design matrix. Missing values are not supported.</p>
</td></tr>
<tr><td><code id="ahazpen_+3A_weights">weights</code></td>
<td>
<p>Optional vector of observation weights. Default is 1 for each observation.</p>
</td></tr>
<tr><td><code id="ahazpen_+3A_standardize">standardize</code></td>
<td>
<p>Logical flag for variable standardization, prior to
model fitting. Estimates are always returned on
the original scale. Default is <code>standardize=TRUE</code>.</p>
</td></tr>
<tr><td><code id="ahazpen_+3A_penalty">penalty</code></td>
<td>
<p>A description of the penalty function to be used for
model fitting. This can be a character string naming a penalty
function (currently <code>"lasso"</code> or stepwise SCAD, <code>"sscad"</code>) or a call to
the desired penalty function. <br /> See <code><a href="#topic+ahazpen.pen.control">ahazpen.pen.control</a></code> for the available
penalty functions and advanced options; see also the examples. </p>
</td></tr>
<tr><td><code id="ahazpen_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of <code>lambda</code> values. Default is
<code>nlambda=100</code>.</p>
</td></tr>
<tr><td><code id="ahazpen_+3A_dfmax">dfmax</code></td>
<td>
<p>Limit the maximum number of variables in the
model. Unless a complete
regularization path is needed, it is highly
recommended to initially choose a relatively smaller value of
<code>dfmax</code> to substantially reduce computation time. </p>
</td></tr>
<tr><td><code id="ahazpen_+3A_pmax">pmax</code></td>
<td>
<p>Limit the maximum number of variables to ever be
considered by the coordinate descent algorithm. </p>
</td></tr>
<tr><td><code id="ahazpen_+3A_lambda.minf">lambda.minf</code></td>
<td>
<p>Smallest value of <code>lambda</code>, as a fraction of
<code>lambda.max</code>, the (data-derived) smallest
value of <code>lambda</code> for which all regression coefficients are zero. The default depends on the
sample size <code>nobs</code> relative to the number of variables
<code>nvars</code>. If <code>nobs &gt;= nvars</code>, the default is <code>0.0001</code>,
close to zero.  When <code>nobs &lt; nvars</code>, the default is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="ahazpen_+3A_lambda">lambda</code></td>
<td>
<p>An optional user supplied sequence of penalty parameters. Typical usage
is to have the 
program compute its own <code>lambda</code> sequence based on
<code>nlambda</code> and <code>lambda.minf</code>. A user-specified
lambda sequence overrides <code>dfmax</code> but not <code>pmax</code>.</p>
</td></tr>
<tr><td><code id="ahazpen_+3A_penalty.wgt">penalty.wgt</code></td>
<td>
<p>A vector of nonnegative penalty weights for each
regression coefficient. This is a number that multiplies <code>lambda</code> to allow
differential penalization. Can be 0 for some variables, which implies
no penalization so that the variable is always included in the
model; or <code>Inf</code> which implies that the variable is never
included in the model. Default is 1 for all variables.</p>
</td></tr>
<tr><td><code id="ahazpen_+3A_keep">keep</code></td>
<td>
<p>A vector of indices of variables which should always be included in
the model (no penalization). Equivalent to specifying a <code>penalty.wgt</code> of 0.</p>
</td></tr>
<tr><td><code id="ahazpen_+3A_control">control</code></td>
<td>
<p>A list of parameters for controlling the
model fitting algorithm. The list is passed to <code><a href="#topic+ahazpen.fit.control">ahazpen.fit.control</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits the sequence of models implied by the penalty function
<code>penalty</code>, the sequence of penalty parameters <code>lambda</code> by
using the very efficient method of cyclic coordinate descent.
</p>
<p>For data sets with a very large number of covariates, it is recommended
to only calculate partial paths by specifying a smallish value of
<code>dmax</code>.
</p>
<p>The sequence <code>lambda</code> is computed automatically by the algorithm
but can also be set (semi)manually by specifying <code>nlambda</code> or
<code>lambda</code>. The stability and efficiency of the algorithm is highly
dependent on the grid <code>lambda</code> values being reasonably dense, and
<code>lambda</code> (and <code>nlambda</code>) should be specified accordingly. In
particular, it is not recommended to specify a single or a few lambda
values. Instead, a partial regularization path should be calculated and
the functions <code><a href="#topic+predict.ahazpen">predict.ahazpen</a></code> or
<code><a href="#topic+coef.ahazpen">coef.ahazpen</a></code> should be used to extract coefficient
estimates at specific lambda values.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"ahazpen"</code>.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The call that produced this object</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>An <code>
      nvars x length(lambda)</code> matrix (in sparse column format, class <code>dgCMatrix</code>) of penalized regression coefficients.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The sequence of actual <code>lambda</code> values used.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The number of nonzero coefficients for each value of
<code>lambda</code>.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code>nvars</code></td>
<td>
<p>Number of covariates.</p>
</td></tr>
<tr><td><code>surv</code></td>
<td>
<p>A copy of the argument <code>survival</code>.</p>
</td></tr>
<tr><td><code>npasses</code></td>
<td>
<p>Total number of passes by the fitting algorithm over the data,
for all lambda values.</p>
</td></tr>
<tr><td><code>penalty.wgt</code></td>
<td>
<p>The actually used <code>penalty.wgt</code>.</p>
</td></tr>
<tr><td><code>penalty</code></td>
<td>
<p>An object of class <code>ahaz.pen.control</code>, as
specified by <code>penalty</code>.</p>
</td></tr>
<tr><td><code>dfmax</code></td>
<td>
<p>A copy of <code>dfmax</code>.</p>
</td></tr>
<tr><td><code>penalty</code></td>
<td>
<p>A copy of <code>pmax</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gorst-Rasmussen A., Scheike T. H. (2012). <em>Coordinate Descent Methods
for the Penalized Semiparametric Additive Hazards Model</em>. Journal of
Statistical Software, <b>47</b>(9):1-17. <a href="https://www.jstatsoft.org/v47/i09/">https://www.jstatsoft.org/v47/i09/</a>
</p>
<p>Gorst-Rasmussen, A. &amp; Scheike, T. H. (2011). <em>Independent screening for
single-index hazard rate models with ultra-high dimensional features.</em>
Technical report R-2011-06, Department of Mathematical Sciences, Aalborg University.
</p>
<p>Leng, C. &amp; Ma, S. (2007). <em>Path consistent model selection in
additive risk model via Lasso</em>. Statistics in Medicine; <b>26</b>:3753-3770.
</p>
<p>Martinussen, T. &amp; Scheike, T. H. (2008). <em>Covariate selection
for the semiparametric additive risk model.</em> Scandinavian Journal of
Statistics; <b>36</b>:602-619.
</p>
<p>Zou, H. &amp; Li, R. (2008). <em>One-step sparse estimates in nonconcave
penalized likelihood models</em>, Annals of Statistics; <b>36</b>:1509-1533.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.ahazpen">print.ahazpen</a></code>, <code><a href="#topic+predict.ahazpen">predict.ahazpen</a></code>,
<code><a href="#topic+coef.ahazpen">coef.ahazpen</a></code>,  <code><a href="#topic+plot.ahazpen">plot.ahazpen</a></code>,
<code><a href="#topic+tune.ahazpen">tune.ahazpen</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sorlie)

# Break ties
set.seed(10101)
time &lt;- sorlie$time+runif(nrow(sorlie))*1e-2

# Survival data + covariates
surv &lt;- Surv(time,sorlie$status)
X &lt;- as.matrix(sorlie[,3:ncol(sorlie)])

# Fit additive hazards regression model
fit1 &lt;- ahazpen(surv, X,penalty="lasso", dfmax=30)
fit1
plot(fit1)

# Extend the grid to contain exactly 100 lambda values
lrange &lt;- range(fit1$lambda)
fit2 &lt;- ahazpen(surv, X,penalty="lasso", lambda.minf=lrange[1]/lrange[2])
plot(fit2)

# User-specified lambda sequence
lambda &lt;- exp(seq(log(0.30), log(0.1), length = 100))
fit2 &lt;- ahazpen(surv, X, penalty="lasso", lambda = lambda)
plot(fit2)

# Advanced usage - specify details of the penalty function
fit4 &lt;- ahazpen(surv, X,penalty=sscad.control(nsteps=2))
fit4
fit5 &lt;- ahazpen(surv, X,penalty=lasso.control(alpha=0.1))
plot(fit5)
</code></pre>

<hr>
<h2 id='ahazpen.fit.control'>Controls for ahazpen fitting algorithm</h2><span id='topic+ahazpen.fit.control'></span>

<h3>Description</h3>

<p>Controls the numerical algorithm  for fitting
the penalized semiparametric additive hazards model. This is typically
only used in a call to <code>ahazpen</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ahazpen.fit.control(thresh=1e-5, maxit=100000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ahazpen.fit.control_+3A_thresh">thresh</code></td>
<td>
<p>Declare convergence when the maximal relative change from the
last iteration is less than <code>thresh</code>. Default is
<code>thresh=1e-5</code>.</p>
</td></tr>
<tr><td><code id="ahazpen.fit.control_+3A_maxit">maxit</code></td>
<td>
<p>Maximal number passes by the algorithm over the data for
all values of the regularization parameter lambda. Default is <code>maxit=100000</code>. </p>
</td></tr>
<tr><td><code id="ahazpen.fit.control_+3A_...">...</code></td>
<td>
<p>For future methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements named as the arguments.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ahazpen">ahazpen</a></code></p>

<hr>
<h2 id='ahazpen.pen.control'>Penalty controls for ahazpen</h2><span id='topic+ahazpen.pen.control'></span><span id='topic+lasso.control'></span><span id='topic+sscad.control'></span>

<h3>Description</h3>

<p>Describe the penalty function to be used in the penalized
semiparametric additive hazards model. Typically only used in a call
to <code>ahazpen</code> or <code>tune.ahazpen</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'># (Adaptive) lasso/elasticnet
lasso.control(alpha=1, ada.wgt=NULL)

# Stepwise SCAD
sscad.control(a=3.7, nsteps=1, init.sol=NULL, c=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ahazpen.pen.control_+3A_alpha">alpha</code></td>
<td>
<p>Elasticnet penalty parameter with default
<code>alpha=1</code> corresponding to the standard lasso; see details.</p>
</td></tr>
<tr><td><code id="ahazpen.pen.control_+3A_ada.wgt">ada.wgt</code></td>
<td>
<p>Optional covariate weights used for fitting the adaptive
lasso. Default is <em>not</em> to use weights, i.e. fit the standard lasso. A
user-specified <code>init.sol</code>
can be a nonnegative vector of length corresponding to the number of covariates in the
model. <br /> For advanced use it may also be specified as a function with
arguments  <code>surv</code>, <code>X</code> and <code>weights</code> precisely;
see the details.</p>
</td></tr>
<tr><td><code id="ahazpen.pen.control_+3A_a">a</code></td>
<td>
<p>Parameter of the stepwise SCAD penalty, see details. Default
is <code>a=3.7</code></p>
</td></tr>
<tr><td><code id="ahazpen.pen.control_+3A_nsteps">nsteps</code></td>
<td>
<p>Number of steps in stepwise SCAD. Default is
<code>nsteps=1</code>.</p>
</td></tr>
<tr><td><code id="ahazpen.pen.control_+3A_init.sol">init.sol</code></td>
<td>
<p>Optional initial solution for stepwise SCAD
consisting of  a numerical vector of length corresponding to the number of covariates in the
model. Default
is a vector of regression coefficients obtained from
<code>ahaz</code> if there are more observations than covariates, zero
otherwise. 
For advanced use, <code>initsol</code> it can also be specified as a <b>function</b> with
arguments  <code>surv</code>, <code>X</code> and <code>weights</code> precisely;
see the details.</p>
</td></tr>
<tr><td><code id="ahazpen.pen.control_+3A_c">c</code></td>
<td>
<p>Optional scaling factor for stepwise SCAD. Usually it is not
necessary to change supply this; see the details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The lasso/elasticnet penalty function takes the form
</p>
<p style="text-align: center;"><code class="reqn">p_\lambda(\beta)=\lambda((1-\alpha)\|\beta\|_2 +
    \alpha\|\beta\|_1)</code>
</p>

<p>where <code class="reqn">0 &lt;\alpha \leq 1</code>. Choosing <code class="reqn">\alpha&lt;1</code> encourages joint selection of correlated covariates and may
improve the fit when there are substantial correlations among
covariates. 
</p>
<p>The stepwise SCAD penalty function takes the form </p>
<p style="text-align: center;"><code class="reqn">
  p_\lambda(\beta)=w_\lambda(c|b_1|)|\beta_1|+\ldots+
  w_\lambda(c|b_{nvars}|)|\beta_{nvars}|</code>
</p>

<p>where <code class="reqn">b</code> is some
initial estimate, <code class="reqn">c</code> is a scaling factor, and for
<code class="reqn">I</code> the indicator function
</p>
<p style="text-align: center;"><code class="reqn">w_\lambda(x)=\lambda I(x \le \lambda) + \frac{(a\lambda
   - x)_+}{a - 1}I(x&gt;\lambda)</code>
</p>

<p>The scaling factor <code class="reqn">c</code>  controls how &lsquo;different&rsquo; the
stepwise SCAD penalty is from the standard lasso penalty (and is
also used to remove dependency of the penalty on the scaling of the time
axis).
</p>
<p>The one-step SCAD method of Zou &amp; Li (2008) corresponds to taking
<code class="reqn">b</code> equal to the estimator derived from <code><a href="#topic+ahaz">ahaz</a></code>. See
Gorst-Rasmussen &amp; Scheike (2011) for details. By iterating such
one-step SCAD and updating the initial solution <code class="reqn">b</code> accordingly,
the algorithm approximates the solution obtained using full SCAD. Note
that calculating the full SCAD solution generally leads to a nonconvex
optimization problem: multiple solutions and erratic behavior of
solution paths can be an issue.
</p>
<p>The arguments <code>ada.wgt</code> and <code>init.sol</code> can be specified as
functions of the observations. This is convenient, for example, when
using cross-validation for tuning parameter selection. Such a function
<strong>must</strong> be specified precisely with the arguments <code>surv</code>,
<code>X</code> and <code>weights</code> and <strong>must</strong> output a numeric vector
of length corresponding to the number of covariates. <code>ahazpen</code>
will take care of scaling so the function should produce output on the
original scale. See the examples here as well as the examples for
<code><a href="#topic+tune.ahazpen">tune.ahazpen</a></code> for usage of this feature in practice.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"ahaz.pen.control"</code>. 
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>Type of penalty.</p>
</td></tr>
<tr><td><code>init.sol</code></td>
<td>
<p>Function specifying the initial solution, if applicable.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Value of <code>alpha</code>, if applicable.</p>
</td></tr>
<tr><td><code>nsteps</code></td>
<td>
<p>Number of steps for stepwise SCAD penalty, if
applicable.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>Parameter for stepwise SCAD penalty, if applicable.</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>Scaling factor for stepwise SCAD penalty, if applicable.</p>
</td></tr>
<tr><td><code>ada.wgt</code></td>
<td>
<p>Function specifying the weights for the adaptive lasso penalty, if applicable.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gorst-Rasmussen, A. &amp; Scheike, T. H. (2011). <em>Independent screening for
single-index hazard rate models with ultra-high dimensional features.</em>
Technical report R-2011-06, Department of Mathematical Sciences, Aalborg
University.
</p>
<p>Leng, C. &amp; Ma, S. (2007). <em>Path consistent model selection in
additive risk model via Lasso</em>. Statistics in Medicine; <b>26</b>:3753-3770.
</p>
<p>Martinussen, T. &amp; Scheike, T. H. (2008). <em>Covariate selection
for the semiparametric additive risk model.</em> Scandinavian Journal of
Statistics; <b>36</b>:602-619.
</p>
<p>Zou, H. &amp; Li, R. (2008). <em>One-step sparse estimates in nonconcave
penalized likelihood models</em>, Annals of Statistics; <b>36</b>:1509-1533.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ahazpen">ahazpen</a></code>, <code><a href="#topic+tune.ahazpen">tune.ahazpen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sorlie)

# Break ties
set.seed(10101)
time &lt;- sorlie$time+runif(nrow(sorlie))*1e-2

# Survival data + covariates
surv &lt;- Surv(time,sorlie$status)
X &lt;- as.matrix(sorlie[,3:ncol(sorlie)])

# Fit additive hazards regression model with elasticnet penalty
model &lt;- ahazpen(surv,X,penalty=lasso.control(alpha=0.1),dfmax=30)
plot(model)

# Adaptive lasso with weights 1/|beta_i|^0.5. Note that, although
# we do not use 'weights', it MUST be included as an argument
adafun &lt;- function(surv,X,weights)
 return(1/abs(coef(ahaz(surv,X)))^.5)
model &lt;- ahazpen(surv,X[,1:50],penalty=lasso.control(ada.wgt=adafun))
plot(model)

# One-step SCAD with initial solution derived from univariate regressions
scadfun &lt;- function(surv,X,weights){
 fit &lt;- ahaz(surv,X,univariate=TRUE)
 return(coef(fit))
}
set.seed(10101)
model.ssc &lt;- tune.ahazpen(surv,X,dfmax=30,penalty=sscad.control(init.sol=scadfun))
plot(model.ssc)
</code></pre>

<hr>
<h2 id='plot.ahaz'>Plot an ahaz object</h2><span id='topic+plot.ahaz'></span>

<h3>Description</h3>

<p>Plot method for a fitted semiparametric additive hazards model;
plots the Breslow estimate of underlying cumulative hazard function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ahaz'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ahaz_+3A_x">x</code></td>
<td>
<p>The result of an <code>ahaz</code> fit.</p>
</td></tr>
<tr><td><code id="plot.ahaz_+3A_...">...</code></td>
<td>
<p>Additional graphical arguments passed to the <code>plot</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calling <code>plot.ahaz</code> is equivalent to first calling <code>ahaz</code>, then
calling <code>predict</code> with <code>type="cumhaz"</code>, and finally
calling <code>plot</code>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ahaz">ahaz</a></code>, <code><a href="#topic+predict.ahaz">predict.ahaz</a></code>, <code><a href="#topic+plot.cumahaz">plot.cumahaz</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sorlie)

# Break ties
set.seed(10101)
time &lt;- sorlie$time+runif(nrow(sorlie))*1e-2

# Survival data + covariates
surv &lt;- Surv(time,sorlie$status)
X &lt;- as.matrix(sorlie[,15:24])

# Fit additive hazards model
fit &lt;- ahaz(surv, X)
plot(fit)
</code></pre>

<hr>
<h2 id='plot.ahazpen'>Plot an ahazpen object</h2><span id='topic+plot.ahazpen'></span>

<h3>Description</h3>

<p>Plots regularization paths for fitted penalized semiparametric additive hazards model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ahazpen'
plot(x, xvar=c("norm","lambda"), labels=FALSE, df=TRUE,
                ylab="Regression coefficients", xlab=xname,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ahazpen_+3A_x">x</code></td>
<td>
<p>The result of an <code>ahazpen</code> fit.</p>
</td></tr>
<tr><td><code id="plot.ahazpen_+3A_xvar">xvar</code></td>
<td>
<p>Scaling for first axis. Options are the <code class="reqn">L^1</code> norm of the vector of
regression coefficients (&quot;<code>norm</code>&quot;) or the penalty parameter
on a log scale (&quot;<code>lambda</code>&quot;).</p>
</td></tr>
<tr><td><code id="plot.ahazpen_+3A_labels">labels</code></td>
<td>
<p>Try to display indices for the regression coefficients in the right-hand
margin. Default is <code>labels=FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.ahazpen_+3A_df">df</code></td>
<td>
<p>Display number of nonzero parameters in top margin. Default
is <code>df=TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.ahazpen_+3A_ylab">ylab</code></td>
<td>
<p>Label for y-axis.</p>
</td></tr>
<tr><td><code id="plot.ahazpen_+3A_xlab">xlab</code></td>
<td>
<p>Label for x-axis. The default is either &quot;L1 norm&quot; or
<code class="reqn">\lambda</code>, depending on <code>xvar</code>.</p>
</td></tr>
<tr><td><code id="plot.ahazpen_+3A_...">...</code></td>
<td>
<p>Additional graphical arguments passed to the <code>plot</code> function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ahazpen">ahazpen</a></code>, <code><a href="#topic+print.ahazpen">print.ahazpen</a></code>, <code><a href="#topic+predict.ahazpen">predict.ahazpen</a></code>, <code><a href="#topic+coef.ahazpen">coef.ahazpen</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sorlie)

# Break ties
set.seed(10101)
time &lt;- sorlie$time+runif(nrow(sorlie))*1e-2

# Survival data + covariates
surv &lt;- Surv(time,sorlie$status)
X &lt;- as.matrix(sorlie[,3:ncol(sorlie)])

# Fit additive hazards regression model
fit &lt;- ahazpen(surv, X, dfmax=50)
par(mfrow=c(1,2)); plot(fit); plot(fit,xvar="lambda")

# With labels only
plot(fit,labels=TRUE,df=FALSE)
</code></pre>

<hr>
<h2 id='plot.cumahaz'>Plot a cumahaz object</h2><span id='topic+plot.cumahaz'></span>

<h3>Description</h3>

<p>Plots the Breslow estimate of cumulative hazard function,
as obtained from  the <code>predict.ahaz</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cumahaz'
plot(x, ...)  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cumahaz_+3A_x">x</code></td>
<td>
<p>Result of a call to the <code>predict.ahaz</code> function with option <code>type="cumhaz"</code>.</p>
</td></tr>
<tr><td><code id="plot.cumahaz_+3A_...">...</code></td>
<td>
<p>Additional graphical arguments passed to the <code>plot</code> function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+predict.ahaz">predict.ahaz</a></code>, <code><a href="#topic+predict.ahazpen">predict.ahazpen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sorlie)

# Break ties
set.seed(10101)
time &lt;- sorlie$time+runif(nrow(sorlie))*1e-2

# Survival data + covariates
surv &lt;- Surv(time,sorlie$status)
X &lt;- as.matrix(sorlie[,15:24])

# Fit additive hazards regression model
fit &lt;- ahaz(surv, X)

# Cumulative hazard
cumhaz &lt;- predict(fit, type="cumhaz")
plot(cumhaz)
</code></pre>

<hr>
<h2 id='plot.tune.ahazpen'>Plot a tune.ahazpen object</h2><span id='topic+plot.tune.ahazpen'></span>

<h3>Description</h3>

<p>Plot, as a function of the penalty parameter, the curve of tuning scores produced when tuning a
penalized semiparametric additive hazards model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tune.ahazpen'
plot(x, df = TRUE, ...)  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.tune.ahazpen_+3A_x">x</code></td>
<td>
<p>The result of a call to <code>tune.ahazpen</code>.</p>
</td></tr>
<tr><td><code id="plot.tune.ahazpen_+3A_df">df</code></td>
<td>
<p>Display number of nonzero parameters in top margin. Default
is <code>df=TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.tune.ahazpen_+3A_...">...</code></td>
<td>
<p>Additional graphical arguments passed to the <code>plot</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A plot is produced displaying the tuning score for each value
of penalty parameter 
(alongside upper and lower standard deviation curves, if cross-validation
has been used). The value of
<code>lambda</code> which minimizes the estimated tuning score
is indicated with a dashed vertical line.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ahazpen">ahazpen</a></code>, <code><a href="#topic+tune.ahazpen">tune.ahazpen</a></code>, <code><a href="#topic+print.tune.ahazpen">print.tune.ahazpen</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sorlie)

# Break ties
set.seed(10101)
time &lt;- sorlie$time+runif(nrow(sorlie))*1e-2

# Survival data + covariates
surv &lt;- Surv(time,sorlie$status)
X &lt;- as.matrix(sorlie[,3:ncol(sorlie)])

# Do 10 fold cross-validation
set.seed(10101)
tune.fit &lt;- tune.ahazpen(surv, X, penalty="lasso",
              dfmax=50, tune = cv.control(nfolds=10))
plot(tune.fit)

</code></pre>

<hr>
<h2 id='predict.ahaz'>Prediction methods for ahaz</h2><span id='topic+predict.ahaz'></span><span id='topic+coef.ahaz'></span><span id='topic+vcov.ahaz'></span><span id='topic+residuals.ahaz'></span>

<h3>Description</h3>

<p>Compute regression coefficients, linear predictor, cumulative hazard function, or
integrated martingale residuals for a fitted semiparametric additive hazards model. </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ahaz'
predict(object, newX, type=c("coef", "lp",
       "residuals", "cumhaz"), beta=NULL, ...)
## S3 method for class 'ahaz'
coef(object, ...)
## S3 method for class 'ahaz'
vcov(object, ...)
## S3 method for class 'ahaz'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ahaz_+3A_object">object</code></td>
<td>
<p>The result of an <code>ahaz</code> fit.</p>
</td></tr>
<tr><td><code id="predict.ahaz_+3A_newx">newX</code></td>
<td>
<p>Optional new matrix of covariates at which to do
predictions. Currently only supported for <code>type="lp"</code>.</p>
</td></tr>
<tr><td><code id="predict.ahaz_+3A_type">type</code></td>
<td>
<p>Type of prediction. Options are the regression coefficients
(&quot;<code>coef</code>&quot;), the linear
predictor (&quot;<code>lp</code>&quot;),  the martingale residuals
(&quot;<code>residuals</code>&quot;), or the cumulative hazard
(&quot;<code>cumhaz</code>&quot;). See the details.</p>
</td></tr>
<tr><td><code id="predict.ahaz_+3A_beta">beta</code></td>
<td>
<p>Optional vector of regression coefficients. If unspecified,
the regression coefficients derived from <code>object</code> are used.</p>
</td></tr>
<tr><td><code id="predict.ahaz_+3A_...">...</code></td>
<td>
<p>For future methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Breslow estimator of the baseline cumulative hazard is described
in Lin &amp; Ying (1994).
</p>
<p>The regression coefficients <code class="reqn">\beta_0</code> in the semiparametric additive hazards
model are obtained as the
solution <code class="reqn">\hat{\beta}</code> to a quadratic  system of linear equations
<code class="reqn">D\beta=d</code>. The
(integrated) martingale residuals <code class="reqn">\epsilon_i</code> for
<code class="reqn">i=1,...,n</code> are vectors, of length
corresponding to the number of covariates, so that
</p>
<p style="text-align: center;"><code class="reqn">D(\hat{\beta}-\beta_0) -d \approx \epsilon_1+\cdots+\epsilon_n</code>
</p>

<p>The residuals estimate integrated
martingales and are
asymptotically distributed as mean-zero IID multivariate Gaussian. They can be used to derive a sandwich-type variance
estimator for regression coefficients (implemented in
<code>summary.ahaz</code> when <code>robust=TRUE</code> is specified).  They can moreover be used for implementing consistent standard error
estimation under clustering; or for implementing resampling-based
inferential methods.
</p>
<p>See Martinussen &amp; Scheike (2006), Chapter 5.4 for details.  </p>


<h3>Value</h3>

<p>For <code>type="coef"</code> and <code>type="lp"</code>, a vector of
predictions.
</p>
<p>For <code>type="coef"</code>, a matrix of (integrated) martingale
residuals, with number of columns corresponding to the number of
covariates.
</p>
<p>For <code>type="cumhaz"</code>, an object with S3 class <code>"cumahaz"</code>
consisting of:
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>Jump times for the cumulative hazard estimate.</p>
</td></tr>
<tr><td><code>cumhaz</code></td>
<td>
<p>The cumulative hazard estimate.</p>
</td></tr>
<tr><td><code>event</code></td>
<td>
<p>Status at jump times (1 corresponds to death, 0
corresponds to entry/exit).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Martinussen, T. &amp; Scheike, T. H. &amp;  (2006). <em>Dynamic Regression Models for Survival Data.</em> Springer.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ahaz">ahaz</a></code>,  <code><a href="#topic+summary.ahaz">summary.ahaz</a></code>, <code><a href="#topic+plot.cumahaz">plot.cumahaz</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sorlie)

set.seed(10101)

# Break ties
time &lt;- sorlie$time+runif(nrow(sorlie))*1e-2

# Survival data + covariates
surv &lt;- Surv(time,sorlie$status)
X &lt;- as.matrix(sorlie[,15:24])

# Fit additive hazards regression model
fit &lt;- ahaz(surv, X)

# Parameter estimates
coef(fit)

# Linear predictor, equivalent to X%*%coef(fit)
predict(fit,type="lp")

# Cumulative baseline hazard
cumahaz &lt;- predict(fit, type="cumhaz")

# Residuals - model fit
resid &lt;- predict(fit, type = "residuals")
# Decorrelate, standardize, and check QQ-plots
stdres &lt;- apply(princomp(resid)$scores,2,function(x){x/sd(x)})
par(mfrow = c(2,2))
for(i in 1:4){
  qqnorm(stdres[,i])
  abline(c(0,1))
}

# Residuals - alternative variance estimation
resid &lt;- residuals(fit)
cov1 &lt;- summary(fit)$coef[,2]
invD &lt;- solve(fit$D)
Best&lt;-t(resid)%*%resid
cov2 &lt;- invD %*% Best %*% invD
# Compare with (nonrobust) SEs from 'summary.ahaz'
plot(cov1, sqrt(diag(cov2)),xlab="Nonrobust",ylab="Robust")
abline(c(0,1))
</code></pre>

<hr>
<h2 id='predict.ahazpen'>Prediction methods for ahazpen</h2><span id='topic+predict.ahazpen'></span><span id='topic+coef.ahazpen'></span>

<h3>Description</h3>

<p>Compute regression coefficient estimates, linear predictor, cumulative hazard function, or
integrated martingale residuals for a fitted penalized semiparametric additive
hazards model.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ahazpen'
predict(object, newX, type=c("coef","lp","residuals","cumhaz"),
        lambda=NULL, ...)
## S3 method for class 'ahazpen'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ahazpen_+3A_object">object</code></td>
<td>
<p>The result of an <code>ahazpen</code> fit.</p>
</td></tr>
<tr><td><code id="predict.ahazpen_+3A_newx">newX</code></td>
<td>
<p>New matrix of covariates at which to do
predictions. <br /> Required unless <code>type="coef"</code>. </p>
</td></tr>
<tr><td><code id="predict.ahazpen_+3A_lambda">lambda</code></td>
<td>
<p>Value of lambda for at which predictions are
to be made. This argument is required for <code>type="residuals"</code> and
<code>type="cumhaz"</code>. Since predictions rely on interpolations between lambda values, it is recommended not to use a lambda-value smaller than the minimum of <code>object$lambda</code>.</p>
</td></tr>
<tr><td><code id="predict.ahazpen_+3A_type">type</code></td>
<td>
<p>The type of prediction. Options are the regression coefficients
(&quot;<code>coef</code>&quot;), the linear
predictors (&quot;<code>lp</code>&quot;),  the (integrated) martingale residuals
(&quot;<code>residuals</code>&quot;), or the cumulative hazard  (&quot;<code>cumhaz</code>&quot;)</p>
</td></tr>
<tr><td><code id="predict.ahazpen_+3A_...">...</code></td>
<td>
<p>For future methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the details in <code><a href="#topic+predict.ahaz">predict.ahaz</a></code> for information on
the different types of predictions.
</p>


<h3>Value</h3>

<p> For <code>type="coef"</code> and <code>type="lp"</code>, a
matrix of regression coefficients, respectively linear predictions for
each value of the penalty parameter.
</p>
<p>For <code>type="residuals"</code>, a matrix of (integrated) martingale residuals
associated with the nonzero penalized regression coefficients for a
regularization parameter equal to <code class="reqn">lambda</code>.
</p>
<p>For <code>type="cumhaz"</code>, an object with S3 class <code>"cumahaz"</code>
based on the regression coefficients estimated for a
regularization parameter equal to <code class="reqn">lambda</code>, the object containing:
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>Jump times for the cumulative hazard estimate.</p>
</td></tr>
<tr><td><code>cumhaz</code></td>
<td>
<p>The cumulative hazard estimate.</p>
</td></tr>
<tr><td><code>event</code></td>
<td>
<p>Status at jump times (1 corresponds to death, 0
corresponds to entry/exit).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ahazpen">ahazpen</a></code>, <code><a href="#topic+print.ahazpen">print.ahazpen</a></code>,
<code><a href="#topic+plot.ahazpen">plot.ahazpen</a></code>, <code><a href="#topic+predict.ahaz">predict.ahaz</a></code>, <code><a href="#topic+plot.cumahaz">plot.cumahaz</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sorlie)

set.seed(10101)

# Break ties
time &lt;- sorlie$time+runif(nrow(sorlie))*1e-2

# Survival data + covariates
surv &lt;- Surv(time,sorlie$status)
X &lt;- as.matrix(sorlie[,3:ncol(sorlie)])

# Fit additive hazards regression model w/lasso penalty
fit &lt;- ahazpen(surv, X, dfmax=100)

# Coefficients
beta &lt;- predict(fit,X,lambda=0.08,type="coef")
barplot(as.numeric(beta))

# Linear predictions
linpred &lt;- predict(fit,X,lambda=0.1,type="lp")
riskgrp &lt;- factor(linpred &lt; median(linpred))
plot(survfit(surv~riskgrp))

# Residuals
resid &lt;- predict(fit, X, lambda=0.1, type = "residuals")
par(mfrow = c(1,2))
hist(resid[,1],main=colnames(resid)[1])
hist(resid[,2],main=colnames(resid)[2])

# Cumulative hazard
cumhaz &lt;- predict(fit,X,lambda=0.1,type="cumhaz")
plot(cumhaz)


</code></pre>

<hr>
<h2 id='predict.tune.ahazpen'>Prediction methods for tune.ahazpen</h2><span id='topic+predict.tune.ahazpen'></span><span id='topic+coef.tune.ahazpen'></span>

<h3>Description</h3>

<p>Compute regression coefficient estimates, linear predictor, cumulative hazard function, or
integrated martingale residuals for a fitted and tuned penalized semiparametric additive
hazards model.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tune.ahazpen'
predict(object, newX,  lambda="lambda.min", ...)
## S3 method for class 'tune.ahazpen'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.tune.ahazpen_+3A_object">object</code></td>
<td>
<p>The result of an <code>ahazpen</code> fit.</p>
</td></tr>
<tr><td><code id="predict.tune.ahazpen_+3A_newx">newX</code></td>
<td>
<p>New matrix of covariates at which to do
predictions. Required for some types of predictions, see <code><a href="#topic+predict.ahazpen">predict.ahazpen</a></code>.</p>
</td></tr>
<tr><td><code id="predict.tune.ahazpen_+3A_lambda">lambda</code></td>
<td>
<p>Value of lambda at which predictions are
to be made. Required for some types of predictions, see
<code><a href="#topic+predict.ahazpen">predict.ahazpen</a></code>. Default is the optimal lambda value
saved in <code>object</code>.</p>
</td></tr>
<tr><td><code id="predict.tune.ahazpen_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to
<code>predict.ahazpen</code> (usually the type of prediction required).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the details in <code><a href="#topic+predict.ahazpen">predict.ahazpen</a></code> for information on
the available types of predictions.
</p>


<h3>Value</h3>

<p>The obejct returned depends on the details in the argument <code>...</code> passed
to <code><a href="#topic+predict.ahazpen">predict.ahazpen</a></code>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.ahazpen">predict.ahazpen</a></code>, <code><a href="#topic+ahazpen">ahazpen</a></code>, <code><a href="#topic+print.ahazpen">print.ahazpen</a></code>,
<code><a href="#topic+plot.ahazpen">plot.ahazpen</a></code>, <code><a href="#topic+predict.ahaz">predict.ahaz</a></code>, <code><a href="#topic+plot.cumahaz">plot.cumahaz</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sorlie)

set.seed(10101)

# Break ties
time &lt;- sorlie$time+runif(nrow(sorlie))*1e-2

# Survival data + covariates
surv &lt;- Surv(time,sorlie$status)
X &lt;- as.matrix(sorlie[,3:ncol(sorlie)])

# Fit additive hazards regression model w/lasso penalty
cv.fit &lt;- tune.ahazpen(surv, X, dfmax=100, tune="cv")

# Predict coefficients at cv.fit$lambda.min
coef(cv.fit)

# Predict risk score at cv.fit$lambda.min
predict(cv.fit,newX=X,type="lp")

</code></pre>

<hr>
<h2 id='print.ahazisis'>Print an ahazisis object</h2><span id='topic+print.ahazisis'></span>

<h3>Description</h3>

<p>Print method for sure independence screening based on the
semiparametric additive hazards model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ahazisis'
print(x, digits=max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ahazisis_+3A_x">x</code></td>
<td>
<p>Fitted <code>ahazisis</code> object.</p>
</td></tr>
<tr><td><code id="print.ahazisis_+3A_digits">digits</code></td>
<td>
<p>Significant digits to print.</p>
</td></tr>
<tr><td><code id="print.ahazisis_+3A_...">...</code></td>
<td>
<p>For future methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The call that produced <code>x</code> is printed, alongside the
number of covariates initially recruited, the number of covariates
finally recruited (if applicable) and the number of iterations (if applicable).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ahazisis">ahazisis</a></code></p>

<hr>
<h2 id='print.ahazpen'>Print an ahazpen object</h2><span id='topic+print.ahazpen'></span><span id='topic+summary.ahazpen'></span>

<h3>Description</h3>

<p>Print method for fitted penalized semiparametric additive hazards model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ahazpen'
print(x, digits=max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ahazpen_+3A_x">x</code></td>
<td>
<p>Fitted <code>ahazpen</code> object.</p>
</td></tr>
<tr><td><code id="print.ahazpen_+3A_digits">digits</code></td>
<td>
<p>Significant digits to print.</p>
</td></tr>
<tr><td><code id="print.ahazpen_+3A_...">...</code></td>
<td>
<p>For future methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The call that produced <code>x</code> is printed, alongside the
number of observations, the number of covariates, and details on the
sequence of penalty parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ahazpen">ahazpen</a></code>, <code><a href="#topic+predict.ahazpen">predict.ahazpen</a></code>, <code><a href="#topic+coef.ahazpen">coef.ahazpen</a></code>.</p>

<hr>
<h2 id='print.summary.ahaz'>Print a summary.ahaz object</h2><span id='topic+print.summary.ahaz'></span>

<h3>Description</h3>

<p>Produces a printed summary of a fitted semiparametric additive
hazards model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.ahaz'
print(x, digits=max(getOption("digits") - 3, 3),
      signif.stars=getOption("show.signif.stars"), ...)  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.ahaz_+3A_x">x</code></td>
<td>
<p>The result of a call to <code>summary.ahaz</code>.</p>
</td></tr>
<tr><td><code id="print.summary.ahaz_+3A_digits">digits</code></td>
<td>
<p>Significant digits to print.</p>
</td></tr>
<tr><td><code id="print.summary.ahaz_+3A_signif.stars">signif.stars</code></td>
<td>
<p>Show stars to highlight small p-values.</p>
</td></tr>
<tr><td><code id="print.summary.ahaz_+3A_...">...</code></td>
<td>
<p>For future methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+summary.ahaz">summary.ahaz</a></code>, <code><a href="#topic+ahaz">ahaz</a></code>, <code><a href="#topic+plot.ahaz">plot.ahaz</a></code>.</p>

<hr>
<h2 id='print.tune.ahazpen'>Print a tune.ahazpen object</h2><span id='topic+print.tune.ahazpen'></span>

<h3>Description</h3>

<p>Print method for <code>tune.ahazpen</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tune.ahazpen'
print(x, digits=max(3, getOption("digits") - 3), ...) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.tune.ahazpen_+3A_x">x</code></td>
<td>
<p>The result of a call to <code>tune.ahazpen</code>.</p>
</td></tr>
<tr><td><code id="print.tune.ahazpen_+3A_digits">digits</code></td>
<td>
<p>Significant digits in printout.</p>
</td></tr>
<tr><td><code id="print.tune.ahazpen_+3A_...">...</code></td>
<td>
<p>Additional print arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The call that produced <code>x</code> is printed, alongside the number of
penalty parameters used, the value of the
optimal penalty and the number of non-zero regression coefficients at
the optimal penalty parameter.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ahazpen">ahazpen</a></code>, <code><a href="#topic+tune.ahazpen">tune.ahazpen</a></code>, <code><a href="#topic+plot.tune.ahazpen">plot.tune.ahazpen</a></code>.</p>

<hr>
<h2 id='sorlie'>Sorlie gene expressions</h2><span id='topic+sorlie'></span>

<h3>Description</h3>

<p>Dataset containing 549 gene expression measurement, exit time and exit status in a study of breast cancer
among 115 women.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sorlie)</code></pre>


<h3>Format</h3>


<dl>
<dt>time</dt><dd><p>Time to exit.</p>
</dd>
<dt>status</dt><dd><p>Status at exit (censoring = 0, event = 1).</p>
</dd>
<dt>X1,...,X549</dt><dd><p>Gene expression measurements.</p>
</dd> 
</dl>



<h3>References</h3>

<p>Soerlie T., et al. (2003). <em>Repeated observation
of breast tumor subtypes in independent gene expression data
sets</em>. Proc Natl Acad Sci <b>100</b>:8418-8423
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(sorlie)
</code></pre>

<hr>
<h2 id='summary.ahaz'>Summarize an ahaz object</h2><span id='topic+summary.ahaz'></span>

<h3>Description</h3>

<p>Produces a summary of a fitted semiparametric additive
hazards model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ahaz'
summary(object, ...)  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ahaz_+3A_object">object</code></td>
<td>
<p>The result of an <code>ahaz</code> fit.</p>
</td></tr>
<tr><td><code id="summary.ahaz_+3A_...">...</code></td>
<td>
<p>For future methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with S3 class <code>"summary.ahaz"</code>.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The call that produced this object.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>Vector of regression coefficients.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>Estimated covariance matrix of regression coefficients.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code>nvars</code></td>
<td>
<p>Number of covariates</p>
</td></tr>
<tr><td><code>waldtest</code></td>
<td>
<p>Vector of quantities from a Wald test.</p>
</td></tr>
<tr><td><code>univar</code></td>
<td>
<p>Logical: summarizing univariate
regressions (option <code>univariate</code> in <code>ahaz</code>)?</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ahaz">ahaz</a></code>, <code><a href="#topic+plot.ahaz">plot.ahaz</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sorlie)

# Break ties
set.seed(10101)
time &lt;- sorlie$time+runif(nrow(sorlie))*1e-2

# Survival data + covariates
surv &lt;- Surv(time,sorlie$status)
X &lt;- as.matrix(sorlie[,15:25])

# Fit additive hazards model
fit1 &lt;- ahaz(surv, X)
summary(fit1)
</code></pre>

<hr>
<h2 id='tune.ahazpen'>Choice of penalty parameter in ahazpen</h2><span id='topic+tune.ahazpen'></span>

<h3>Description</h3>

<p>Tuning of penalty parameters for  the  penalized semiparametric
additive hazards model via cross-validation - or via non-stochastic
procedures, akin to BIC for likelihood-based models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tune.ahazpen(surv, X, weights, standardize=TRUE, penalty=lasso.control(),
             tune=cv.control(), dfmax=nvars, lambda, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tune.ahazpen_+3A_surv">surv</code></td>
<td>
<p>Response in the form of a survival object, as returned by the
function <code>Surv()</code> in the package <span class="pkg">survival</span>. Right-censored
and counting process format (left-truncation) is supported. Tied
survival times are not supported.</p>
</td></tr>
<tr><td><code id="tune.ahazpen_+3A_x">X</code></td>
<td>
<p>Design matrix. Missing values are not supported.</p>
</td></tr>
<tr><td><code id="tune.ahazpen_+3A_weights">weights</code></td>
<td>
<p>Optional vector of observation weights. Default is 1 for each observation.</p>
</td></tr>
<tr><td><code id="tune.ahazpen_+3A_standardize">standardize</code></td>
<td>
<p>Logical flag for variable standardization, prior to
model fitting. Parameter estimates are always returned on
the original scale. Default is <code>standardize=TRUE</code>.</p>
</td></tr>
<tr><td><code id="tune.ahazpen_+3A_penalty">penalty</code></td>
<td>
<p>A description of the penalty function to be used for
model fitting. This can be a character string naming a penalty
function (currently <code>"lasso"</code> or stepwise SCAD, <code>"sscad"</code>)
or it can be a call to the penalty function. Default is
<code>penalty=lasso.control()</code>. See <code><a href="#topic+ahazpen.pen.control">ahazpen.pen.control</a></code> for the available
penalty functions and advanced options; see also the examples.  </p>
</td></tr>
<tr><td><code id="tune.ahazpen_+3A_dfmax">dfmax</code></td>
<td>
<p>Limit the maximum number of covariates included in the
model. Default is <code>nvars=nobs-1</code>. Unless a complete
regularization path is needed, it is <strong>highly</strong>
recommended to initially choose a relatively smaller value of
<code>dfmax</code> to reduce computation time and memory usage.</p>
</td></tr>
<tr><td><code id="tune.ahazpen_+3A_lambda">lambda</code></td>
<td>
<p>An optional user supplied sequence of penalty parameters. Typical usage
is to have the 
program compute its own <code>lambda</code> sequence based on
<code>nlambda</code> and <code>lambda.min</code>.</p>
</td></tr>
<tr><td><code id="tune.ahazpen_+3A_tune">tune</code></td>
<td>
<p>A description of the tuning method to be used. This can be
a character string naming a tuning control
function (currently <code>"cv"</code> or <code>"bic"</code>) or a call to the
tuning control function. Default is
5-fold cross-validation, 
<code>tune=cv.control()</code>, see <code><a href="#topic+ahaz.tune.control">ahaz.tune.control</a></code> for more
options. See also the examples.
</p>
</td></tr>
<tr><td><code id="tune.ahazpen_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>ahazpen</code>, see
<code><a href="#topic+ahazpen">ahazpen</a></code> for options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs an initial penalized fit based on the
penalty supplied in <code>penalty</code> to obtain a  sequence of
penalty parameters. Subsequently, it selects among these an optimal penalty parameter based on
the tuning control function described in <code>tune</code>, see  <code><a href="#topic+ahaz.tune.control">ahaz.tune.control</a></code>.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"tune.ahazpen"</code>.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The call that produced this object.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The actual sequence of <code>lambda</code> values used.</p>
</td></tr>
<tr><td><code>tunem</code></td>
<td>
<p>The tuning score for each value of <code>lambda</code> (mean
cross-validated error, if <code>tune=cv.control()</code>).</p>
</td></tr>
<tr><td><code>tunesd</code></td>
<td>
<p>Estimate of the cross-validated standard error, if <code>tune=cv.control()</code>.</p>
</td></tr>
<tr><td><code>tunelo</code></td>
<td>
<p>Lower curve = <code>tunem-tunemsd</code>, if <code>tune=cv.control()</code>.</p>
</td></tr>
<tr><td><code>tuneup</code></td>
<td>
<p>Upper curve = <code>tunem+tunemsd</code>, if <code>tune=cv.control()</code>.</p>
</td></tr>
<tr><td><code>lambda.min</code></td>
<td>
<p>Value of <code>lambda</code> for which <code>tunem</code> is
minimized.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Number of non-zero coefficients at each value of
<code>lambda</code>.</p>
</td></tr>
<tr><td><code>tune</code></td>
<td>
<p>The selected <code>tune</code> of S3 class
<code>"ahaz.tune.control"</code>.</p>
</td></tr>
<tr><td><code>penalty</code></td>
<td>
<p>The selected <code>penalty</code> of S3 class <code>"ahazpen.pen.control"</code>.</p>
</td></tr>
<tr><td><code>foldsused</code></td>
<td>
<p>Folds actually used, if <code>tune=cv.control()</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gorst-Rasmussen, A. &amp; Scheike, T. H. (2011). <em>Independent screening for
single-index hazard rate models with ultra-high dimensional features.</em>
Technical report R-2011-06, Department of Mathematical Sciences, Aalborg University.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ahaz.tune.control">ahaz.tune.control</a></code>, <code><a href="#topic+plot.tune.ahazpen">plot.tune.ahazpen</a></code>, <code><a href="#topic+ahazpen">ahazpen</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sorlie)

# Break ties
set.seed(10101)
time &lt;- sorlie$time+runif(nrow(sorlie))*1e-2

# Survival data + covariates
surv &lt;- Surv(time,sorlie$status)
X &lt;- as.matrix(sorlie[,3:ncol(sorlie)])

# Training/test data
set.seed(20202)
train &lt;- sample(1:nrow(sorlie),76)
test &lt;- setdiff(1:nrow(sorlie),train)

# Run cross validation on training data
set.seed(10101)
cv.las &lt;- tune.ahazpen(surv[train,], X[train,],dfmax=30)
plot(cv.las)

# Check fit on the test data
testrisk &lt;- predict(cv.las,X[test,],type="lp")
plot(survfit(surv[test,]~I(testrisk&lt;median(testrisk))),main="Low versus high risk")

# Advanced example, cross-validation of one-step SCAD
# with initial solution derived from univariate models.
# Since init.sol is specified as a function, it is
# automatically cross-validated as well
scadfun&lt;-function(surv,X,weights){coef(ahaz(surv,X,univariate=TRUE))}
set.seed(10101)
cv.ssc&lt;-tune.ahazpen(surv[train,],X[train,],
                     penalty=sscad.control(init.sol=scadfun),
                     tune=cv.control(rep=5),dfmax=30)
# Check fit on test data
testrisk &lt;- predict(cv.ssc,X[test,],type="lp")
plot(survfit(surv[test,]~I(testrisk&lt;median(testrisk))),main="Low versus high risk")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
