<!DOCTYPE html><html lang="en"><head><title>Help for package cpss</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cpss}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#algo'><p>Generic functions and methods: algo</p></a></li>
<li><a href='#algo_param_dim'><p>Generic functions and methods: algo_param_dim</p></a></li>
<li><a href='#coef+2Ccpss-method'><p>coef method</p></a></li>
<li><a href='#cps'><p>Generic functions and methods: cps</p></a></li>
<li><a href='#cpss'><p>cpss: Change-Point Detection by Sample-Splitting Methods</p></a></li>
<li><a href='#cpss-class'><p>cpss: an S4 class which collects data and information required for further change-point analyses and summaries</p></a></li>
<li><a href='#cpss.custom'><p>Detecting changes in uers-customized models</p></a></li>
<li><a href='#cpss.em'><p>Detecting changes in exponential family</p></a></li>
<li><a href='#cpss.glm'><p>Detecting changes in GLMs</p></a></li>
<li><a href='#cpss.lm'><p>Detecting changes in linear models</p></a></li>
<li><a href='#cpss.mean'><p>Detecting changes in mean</p></a></li>
<li><a href='#cpss.meanvar'><p>Detecting changes in mean and (co)variance</p></a></li>
<li><a href='#cpss.var'><p>Detecting changes in (co)variance</p></a></li>
<li><a href='#dat'><p>Generic functions and methods: dat</p></a></li>
<li><a href='#mdl'><p>Generic functions and methods: mdl</p></a></li>
<li><a href='#ncps'><p>Generic functions and methods: ncps</p></a></li>
<li><a href='#params'><p>Generic functions and methods: params</p></a></li>
<li><a href='#pelt_pen'><p>Generic functions and methods: pelt_pen</p></a></li>
<li><a href='#plot+2Ccpss-method'><p>plot method</p></a></li>
<li><a href='#S_vals'><p>Generic functions and methods: S_vals</p></a></li>
<li><a href='#SC'><p>Generic functions and methods: SC</p></a></li>
<li><a href='#SC_vals'><p>Generic functions and methods: SC_vals</p></a></li>
<li><a href='#summary+2Ccpss-method'><p>summary method</p></a></li>
<li><a href='#update_inputs'><p>Generic functions and methods: update_inputs</p></a></li>
<li><a href='#update+2Ccpss-method'><p>update method</p></a></li>
<li><a href='#well'><p>Well-log data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Change-Point Detection by Sample-Splitting Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements multiple change searching algorithms for a variety of 
    frequently considered parametric change-point models. In particular, it 
    integrates a criterion proposed by Zou, Wang and Li (2020) 
    &lt;<a href="https://doi.org/10.1214%2F19-AOS1814">doi:10.1214/19-AOS1814</a>&gt; to select the number of change-points in a 
    data-driven fashion. Moreover, it also provides interfaces for 
    user-customized change-point models with one's own cost function and 
    parameter estimation routine. It is easy to get started with the 
    cpss.* set of functions by accessing their documentation pages 
    (e.g., ?cpss).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, magrittr, methods, stats, mvtnorm, Rfast, tibble, dplyr,
tidyr, rlang, ggplot2, gridExtra</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ghwang-nk/cpss">https://github.com/ghwang-nk/cpss</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ghwang-nk/cpss/issues">https://github.com/ghwang-nk/cpss/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guanghui Wang &lt;ghwang.nk@gmail.com&gt;</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-21 13:48:17 UTC; work</td>
</tr>
<tr>
<td>Author:</td>
<td>Guanghui Wang [aut, cre],
  Changliang Zou [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-22 09:00:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='algo'>Generic functions and methods: algo</h2><span id='topic+algo'></span><span id='topic+algo+3C-'></span><span id='topic+algo+2Ccpss-method'></span><span id='topic+algo+3C-+2Ccpss-method'></span>

<h3>Description</h3>

<p>Generic functions and methods: algo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>algo(x)

algo(x) &lt;- value

## S4 method for signature 'cpss'
algo(x)

## S4 replacement method for signature 'cpss'
algo(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="algo_+3A_x">x</code></td>
<td>
<p>object from cpss</p>
</td></tr>
<tr><td><code id="algo_+3A_value">value</code></td>
<td>
<p>value assigned to x</p>
</td></tr>
</table>

<hr>
<h2 id='algo_param_dim'>Generic functions and methods: algo_param_dim</h2><span id='topic+algo_param_dim'></span><span id='topic+algo_param_dim+3C-'></span><span id='topic+algo_param_dim+2Ccpss-method'></span><span id='topic+algo_param_dim+3C-+2Ccpss-method'></span>

<h3>Description</h3>

<p>Generic functions and methods: algo_param_dim
</p>


<h3>Usage</h3>

<pre><code class='language-R'>algo_param_dim(x)

algo_param_dim(x) &lt;- value

## S4 method for signature 'cpss'
algo_param_dim(x)

## S4 replacement method for signature 'cpss'
algo_param_dim(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="algo_param_dim_+3A_x">x</code></td>
<td>
<p>object from cpss</p>
</td></tr>
<tr><td><code id="algo_param_dim_+3A_value">value</code></td>
<td>
<p>value assigned to x</p>
</td></tr>
</table>

<hr>
<h2 id='coef+2Ccpss-method'>coef method</h2><span id='topic+coef+2Ccpss-method'></span>

<h3>Description</h3>

<p>coef method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'cpss'
coef(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef+2B2Ccpss-method_+3A_object">object</code></td>
<td>
<p>object from cpss</p>
</td></tr>
<tr><td><code id="coef+2B2Ccpss-method_+3A_cpss">cpss</code></td>
<td>
<p>cpss class</p>
</td></tr>
</table>

<hr>
<h2 id='cps'>Generic functions and methods: cps</h2><span id='topic+cps'></span><span id='topic+cps+3C-'></span><span id='topic+cps+2Ccpss-method'></span><span id='topic+cps+3C-+2Ccpss-method'></span>

<h3>Description</h3>

<p>Generic functions and methods: cps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cps(x)

cps(x) &lt;- value

## S4 method for signature 'cpss'
cps(x)

## S4 replacement method for signature 'cpss'
cps(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cps_+3A_x">x</code></td>
<td>
<p>object from cpss</p>
</td></tr>
<tr><td><code id="cps_+3A_value">value</code></td>
<td>
<p>value assigned to x</p>
</td></tr>
</table>

<hr>
<h2 id='cpss'>cpss: Change-Point Detection by Sample-Splitting Methods</h2><span id='topic+cpss'></span>

<h3>Description</h3>

<p>Implements multiple change searching algorithms for a variety of frequently considered parametric change-point models. In particular, it integrates a criterion proposed by Zou, Wang and Li (2020) <a href="doi:10.1214/19-AOS1814">doi:10.1214/19-AOS1814</a> to select the number of change-points in a data-driven fashion. Moreover, it also provides interfaces for user-customized change-point models with one's own cost function and parameter estimation routine.
</p>


<h3>Getting started</h3>

<p>Easy to get started with the cpss.* set of functions by accessing their  documentation pages<br />
library(cpss)<br />
?cpss.mean<br />
?cpss.var<br />
?cpss.meanvar<br />
?cpss.glm<br />
?cpss.lm<br />
?cpss.em<br />
?cpss.custom
</p>

<hr>
<h2 id='cpss-class'>cpss: an S4 class which collects data and information required for further change-point analyses and summaries</h2><span id='topic+cpss-class'></span>

<h3>Description</h3>

<p>cpss: an S4 class which collects data and information required for further change-point analyses and summaries
</p>


<h3>Slots</h3>


<dl>
<dt><code>dat</code></dt><dd><p>ANY.</p>
</dd>
<dt><code>mdl</code></dt><dd><p>character.</p>
</dd>
<dt><code>algo</code></dt><dd><p>character.</p>
</dd>
<dt><code>algo_param_dim</code></dt><dd><p>numeric.</p>
</dd>
<dt><code>SC</code></dt><dd><p>character.</p>
</dd>
<dt><code>ncps</code></dt><dd><p>integer.</p>
</dd>
<dt><code>pelt_pen</code></dt><dd><p>numeric.</p>
</dd>
<dt><code>cps</code></dt><dd><p>numeric.</p>
</dd>
<dt><code>params</code></dt><dd><p>list.</p>
</dd>
<dt><code>S_vals</code></dt><dd><p>numeric.</p>
</dd>
<dt><code>SC_vals</code></dt><dd><p>matrix.</p>
</dd>
<dt><code>call</code></dt><dd><p>list.</p>
</dd>
<dt><code>update_inputs</code></dt><dd><p>list.</p>
</dd>
</dl>

<hr>
<h2 id='cpss.custom'>Detecting changes in uers-customized models</h2><span id='topic+cpss.custom'></span>

<h3>Description</h3>

<p>Detecting changes in uers-customized models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpss.custom(
  dataset,
  n,
  g_subdat,
  g_param,
  g_cost,
  algorithm = "BS",
  dist_min = floor(log(n)),
  ncps_max = ceiling(n^0.4),
  pelt_pen_val = NULL,
  pelt_K = 0,
  wbs_nintervals = 500,
  criterion = "CV",
  times = 2,
  model = NULL,
  g_smry = NULL,
  easy_cost = NULL,
  param.opt = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpss.custom_+3A_dataset">dataset</code></td>
<td>
<p>an <code>ANY</code> object that could be a vector, matrix, tensor, list, etc.</p>
</td></tr>
<tr><td><code id="cpss.custom_+3A_n">n</code></td>
<td>
<p>an integer indicating the sample size of the data <code>dataset</code>.</p>
</td></tr>
<tr><td><code id="cpss.custom_+3A_g_subdat">g_subdat</code></td>
<td>
<p>a customized R function of two arguments <code>dat</code> and <code>indices</code>, which extracts a subset of data <code>dat</code> according to a collection of time indices <code>indices</code>. The returned object inherits the class from that of <code>dataset</code>. The argument <code>dat</code> inherits the class from that of <code>dataset</code>, and the argument <code>indices</code> is a logical vector with <code>TRUE</code>s indicating extracted indices.</p>
</td></tr>
<tr><td><code id="cpss.custom_+3A_g_param">g_param</code></td>
<td>
<p>a customized R function of two arguments <code>dat</code> (cf. <code>dat</code> of <code>g\_subdat</code>) and <code>param.opt</code> (cf. <code>param.opt</code> of <code>cpss.custom</code>), which returns estimated parameters based on the data segment <code>dat</code>. It could return a numeric value, vector, matrix, list, etc.</p>
</td></tr>
<tr><td><code id="cpss.custom_+3A_g_cost">g_cost</code></td>
<td>
<p>a customized R function of two arguments <code>dat</code> (cf. <code>dat</code> of <code>g\_subdat</code>) and <code>param</code>, which returns a numeric value of the associated cost for data segment <code>dat</code> with parameters <code>param</code>. The argument <code>param</code> inherits the class from that of the returned object of <code>g\_param</code>.</p>
</td></tr>
<tr><td><code id="cpss.custom_+3A_algorithm">algorithm</code></td>
<td>
<p>a character string specifying the change-point searching algorithm, one of the following choices: &quot;SN&quot; (segment neighborhood), &quot;BS&quot; (binary segmentation), &quot;WBS&quot; (wild binary segmentation) and &quot;PELT&quot; (pruned exact linear time) algorithms.</p>
</td></tr>
<tr><td><code id="cpss.custom_+3A_dist_min">dist_min</code></td>
<td>
<p>an integer specifying minimum searching distance (length of feasible segments).</p>
</td></tr>
<tr><td><code id="cpss.custom_+3A_ncps_max">ncps_max</code></td>
<td>
<p>an integer specifying an upper bound of the number of true change-points.</p>
</td></tr>
<tr><td><code id="cpss.custom_+3A_pelt_pen_val">pelt_pen_val</code></td>
<td>
<p>a numeric vector specifying candidate values of the penalty only if <code>algorithm = "PELT"</code>.</p>
</td></tr>
<tr><td><code id="cpss.custom_+3A_pelt_k">pelt_K</code></td>
<td>
<p>a numeric value for pruning adjustment only if <code>algorithm = "PELT"</code>. It is usually taken to be 0 if the negative log-likelihood is used as a cost, see Killick et al. (2012).</p>
</td></tr>
<tr><td><code id="cpss.custom_+3A_wbs_nintervals">wbs_nintervals</code></td>
<td>
<p>an integer specifying the number of random intervals drawn only if <code>algorithm = "WBS"</code>, see Fryzlewicz (2014).</p>
</td></tr>
<tr><td><code id="cpss.custom_+3A_criterion">criterion</code></td>
<td>
<p>a character string specifying the model selection criterion, &quot;CV&quot; (&quot;cross-validation&quot;) or &quot;MS&quot; (&quot;multiple-splitting&quot;).</p>
</td></tr>
<tr><td><code id="cpss.custom_+3A_times">times</code></td>
<td>
<p>an integer specifying how many times of sample-splitting should be performed; It should be 2 if <code>criterion = "CV"</code>.</p>
</td></tr>
<tr><td><code id="cpss.custom_+3A_model">model</code></td>
<td>
<p>a character string indicating the considered change model.</p>
</td></tr>
<tr><td><code id="cpss.custom_+3A_g_smry">g_smry</code></td>
<td>
<p>a customized R function of two arguments <code>dataset</code> (cf. <code>dataset</code> of <code>cpss.custom</code>) and <code>param.opt</code> (cf. <code>param.opt</code> of <code>cpss.custom</code>), which calculates the summary statistics that will be used for cost evaluation. The returned object is a list.</p>
</td></tr>
<tr><td><code id="cpss.custom_+3A_easy_cost">easy_cost</code></td>
<td>
<p>a customized R function of three arguments <code>data_smry</code>, <code>s</code> and <code>e</code>, which evaluates the value of the cost for a date segment form observed time point $s$ to $e$. The argument <code>data_smry</code> inherits the class from that of the returned object of <code>g_smry</code>.</p>
</td></tr>
<tr><td><code id="cpss.custom_+3A_param.opt">param.opt</code></td>
<td>
<p>an <code>ANY</code> object specifying additional constant parameters needed for parameter estimation or cost evaluation beyond unknown parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cpss.custom</code> returns an object of an S4 class, called &quot;<code>cpss</code>&quot;, which collects data and information required for further change-point analyses and summaries.
</p>

<dl>
<dt><code>dat</code></dt><dd><p>data set</p>
</dd>
<dt><code>mdl</code></dt><dd><p>considered change-point model</p>
</dd>
<dt><code>algo</code></dt><dd><p>change-point searching algorithm</p>
</dd>
<dt><code>algo_param_dim</code></dt><dd><p>user-specified upper bound of the number of true change-points if <code>algorithm = "SN"/"BS"/"WBS"</code>, or user-specified candidate values of the penalty only if <code>algorithm = "PELT"</code></p>
</dd>
<dt><code>SC</code></dt><dd><p>model selection criterion</p>
</dd>
<dt><code>ncps</code></dt><dd><p>estimated number of change-points</p>
</dd>
<dt><code>pelt_pen</code></dt><dd><p>selected value of the penalty only if <code>algorithm = "PELT"</code></p>
</dd>
<dt><code>cps</code></dt><dd><p>a vector of estimated locations of change-points</p>
</dd>
<dt><code>params</code></dt><dd><p>a list object, each member is a list containing estimated parameters in the associated data segment</p>
</dd>
<dt><code>S_vals</code></dt><dd><p>a numeric vector of candidate model dimensions in terms of a sequence of numbers of change-points or values of the penalty</p>
</dd>
<dt><code>SC_vals</code></dt><dd><p>a numeric matrix, each column records the values of the  criterion based on the validation data split under the corresponding model dimension (<code>S_vals</code>), and each row represents a splitting at each time</p>
</dd>
</dl>



<h3>References</h3>

<p>Killick, R., Fearnhead, P., and Eckley, I. A. (2012). Optimal Detection of Changepoints With a Linear Computational Cost. Journal of the American Statistical Association, 107(500): 1590–1598.
</p>
<p>Fryzlewicz, P. (2014). Wild binary segmentation for multiple change-point detection. The Annals of Statistics, 42(6): 2243–2281.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library("cpss")
g_subdat_l1 &lt;- function(dat, indices) {
  dat[indices]
}
g_param_l1 &lt;- function(dat, param.opt = NULL) {
  return(median(dat))
}
g_cost_l1 &lt;- function(dat, param) {
  return(sum(abs(dat - param)))
}
res &lt;- cpss.custom(
  dataset = well, n = length(well),
  g_subdat = g_subdat_l1, g_param = g_param_l1, g_cost = g_cost_l1,
  ncps_max = 11
)
summary(res)
plot(well)
abline(v = res@cps, col = "red")

</code></pre>

<hr>
<h2 id='cpss.em'>Detecting changes in exponential family</h2><span id='topic+cpss.em'></span>

<h3>Description</h3>

<p>Detecting changes in exponential family
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpss.em(
  dataset,
  family,
  size = NULL,
  algorithm = "BS",
  dist_min = floor(log(n)),
  ncps_max = ceiling(n^0.4),
  pelt_pen_val = NULL,
  pelt_K = 0,
  wbs_nintervals = 500,
  criterion = "CV",
  times = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpss.em_+3A_dataset">dataset</code></td>
<td>
<p>a numeric matrix of dimension <code class="reqn">n\times d</code>, where each row represents an observation and each column stands for a variable. A numeric vector is also acceptable for univariate observations.</p>
</td></tr>
<tr><td><code id="cpss.em_+3A_family">family</code></td>
<td>
<p>a character string specifying the underlying distribution. In the current version, detecting changes in binomial (&quot;<code>binom</code>&quot;), multinomial (&quot;<code>multinom</code>&quot;), Poisson (&quot;<code>pois</code>&quot;), exponential (&quot;<code>exp</code>&quot;), geometric (&quot;<code>geom</code>&quot;), Dirichlet (&quot;<code>diri</code>&quot;), gamma (&quot;<code>gamma</code>&quot;), beta (&quot;<code>beta</code>&quot;), chi-square (&quot;<code>chisq</code>&quot;) and inverse gaussian (&quot;<code>invgauss</code>&quot;) distributions are supported.</p>
</td></tr>
<tr><td><code id="cpss.em_+3A_size">size</code></td>
<td>
<p>an integer indicating the number of trials only if <code>family = "binom"</code> or <code>family = "multinom"</code>.</p>
</td></tr>
<tr><td><code id="cpss.em_+3A_algorithm">algorithm</code></td>
<td>
<p>a character string specifying the change-point searching algorithm, one of the following choices: &quot;SN&quot; (segment neighborhood), &quot;BS&quot; (binary segmentation), &quot;WBS&quot; (wild binary segmentation) and &quot;PELT&quot; (pruned exact linear time) algorithms.</p>
</td></tr>
<tr><td><code id="cpss.em_+3A_dist_min">dist_min</code></td>
<td>
<p>an integer specifying minimum searching distance (length of feasible segments).</p>
</td></tr>
<tr><td><code id="cpss.em_+3A_ncps_max">ncps_max</code></td>
<td>
<p>an integer specifying an upper bound of the number of true change-points.</p>
</td></tr>
<tr><td><code id="cpss.em_+3A_pelt_pen_val">pelt_pen_val</code></td>
<td>
<p>a numeric vector specifying candidate values of the penalty only if <code>algorithm = "PELT"</code>.</p>
</td></tr>
<tr><td><code id="cpss.em_+3A_pelt_k">pelt_K</code></td>
<td>
<p>a numeric value for pruning adjustment only if <code>algorithm = "PELT"</code>. It is usually taken to be 0 if the negative log-likelihood is used as a cost, see Killick et al. (2012).</p>
</td></tr>
<tr><td><code id="cpss.em_+3A_wbs_nintervals">wbs_nintervals</code></td>
<td>
<p>an integer specifying the number of random intervals drawn only if <code>algorithm = "WBS"</code>, see Fryzlewicz (2014).</p>
</td></tr>
<tr><td><code id="cpss.em_+3A_criterion">criterion</code></td>
<td>
<p>a character string specifying the model selection criterion, &quot;CV&quot; (&quot;cross-validation&quot;) or &quot;MS&quot; (&quot;multiple-splitting&quot;).</p>
</td></tr>
<tr><td><code id="cpss.em_+3A_times">times</code></td>
<td>
<p>an integer specifying how many times of sample-splitting should be performed; It should be 2 if <code>criterion = "CV"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cpss.em</code> returns an object of an S4 class, called &quot;<code>cpss</code>&quot;, which collects data and information required for further change-point analyses and summaries. See <code><a href="#topic+cpss.custom">cpss.custom</a></code>.
</p>


<h3>References</h3>

<p>Killick, R., Fearnhead, P., and Eckley, I. A. (2012). Optimal Detection of Changepoints With a Linear Computational Cost. Journal of the American Statistical Association, 107(500):1590–1598.
</p>
<p>Fryzlewicz, P. (2014). Wild binary segmentation for multiple change-point detection. The Annals of Statistics, 42(6): 2243–2281.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpss.meanvar">cpss.meanvar</a></code> <code><a href="#topic+cpss.mean">cpss.mean</a></code> <code><a href="#topic+cpss.var">cpss.var</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("cpss")
set.seed(666)
n &lt;- 1000
tau &lt;- c(100, 300, 700, 900)
tau_ext &lt;- c(0, tau, n)
theta &lt;- c(1, 0.2, 1, 0.2, 1)
seg_len &lt;- diff(c(0, tau, n))
y &lt;- unlist(lapply(seq(1, length(tau) + 1), function(k) {
  rexp(seg_len[k], theta[k])
}))
res &lt;- cpss.em(
  y, family = "exp", algorithm = "WBS", ncps_max = 10,
  criterion = "MS", times = 10
)
cps(res)
# [1] 100 299 705 901
</code></pre>

<hr>
<h2 id='cpss.glm'>Detecting changes in GLMs</h2><span id='topic+cpss.glm'></span>

<h3>Description</h3>

<p>Detecting changes in GLMs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpss.glm(
  formula,
  family,
  data = NULL,
  algorithm = "BS",
  dist_min = floor(log(n)),
  ncps_max = ceiling(n^0.4),
  pelt_pen_val = NULL,
  pelt_K = 0,
  wbs_nintervals = 500,
  criterion = "CV",
  times = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpss.glm_+3A_formula">formula</code></td>
<td>
<p>a <code>formula</code> object specifying the GLM with change-points.</p>
</td></tr>
<tr><td><code id="cpss.glm_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to be used in the model, which can be a character string naming a family function or a family function.</p>
</td></tr>
<tr><td><code id="cpss.glm_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="cpss.glm_+3A_algorithm">algorithm</code></td>
<td>
<p>a character string specifying the change-point searching algorithm, one of the following choices: &quot;SN&quot; (segment neighborhood), &quot;BS&quot; (binary segmentation), &quot;WBS&quot; (wild binary segmentation) and &quot;PELT&quot; (pruned exact linear time) algorithms.</p>
</td></tr>
<tr><td><code id="cpss.glm_+3A_dist_min">dist_min</code></td>
<td>
<p>an integer specifying minimum searching distance (length of feasible segments).</p>
</td></tr>
<tr><td><code id="cpss.glm_+3A_ncps_max">ncps_max</code></td>
<td>
<p>an integer specifying an upper bound of the number of true change-points.</p>
</td></tr>
<tr><td><code id="cpss.glm_+3A_pelt_pen_val">pelt_pen_val</code></td>
<td>
<p>a numeric vector specifying candidate values of the penalty only if <code>algorithm = "PELT"</code>.</p>
</td></tr>
<tr><td><code id="cpss.glm_+3A_pelt_k">pelt_K</code></td>
<td>
<p>a numeric value for pruning adjustment only if <code>algorithm = "PELT"</code>. It is usually taken to be 0 if the negative log-likelihood is used as a cost, see Killick et al. (2012).</p>
</td></tr>
<tr><td><code id="cpss.glm_+3A_wbs_nintervals">wbs_nintervals</code></td>
<td>
<p>an integer specifying the number of random intervals drawn only if <code>algorithm = "WBS"</code>, see Fryzlewicz (2014).</p>
</td></tr>
<tr><td><code id="cpss.glm_+3A_criterion">criterion</code></td>
<td>
<p>a character string specifying the model selection criterion, &quot;CV&quot; (&quot;cross-validation&quot;) or &quot;MS&quot; (&quot;multiple-splitting&quot;).</p>
</td></tr>
<tr><td><code id="cpss.glm_+3A_times">times</code></td>
<td>
<p>an integer specifying how many times of sample-splitting should be performed; It should be 2 if <code>criterion = "CV"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cpss.glm</code> returns an object of an S4 class, called &quot;<code>cpss</code>&quot;, which collects data and information required for further change-point analyses and summaries. See <code><a href="#topic+cpss.custom">cpss.custom</a></code>.
</p>


<h3>References</h3>

<p>Killick, R., Fearnhead, P., and Eckley, I. A. (2012). Optimal Detection of Changepoints With a Linear Computational Cost. Journal of the American Statistical Association, 107(500):1590–1598.
</p>
<p>Fryzlewicz, P. (2014). Wild binary segmentation for multiple change-point detection. The Annals of Statistics, 42(6): 2243–2281.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpss.lm">cpss.lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("cpss")
set.seed(666)
n &lt;- 200
size &lt;- rpois(n, 20 - 1) + 1
tau &lt;- c(75, 100, 175)
tau_ext &lt;- c(0, tau, n)
be &lt;- list(c(0, 0.5), c(0, -0.5), c(0.5, -0.5), c(-0.5, -0.5))
seg_len &lt;- diff(c(0, tau, n))
x &lt;- rnorm(n)
eta &lt;- lapply(seq(1, length(tau) + 1), function(k) {
  be[[k]][1] + be[[k]][2] * x[(tau_ext[k] + 1):tau_ext[k + 1]]
})
eta &lt;- do.call(c, eta)
p &lt;- 1 / (1 + exp(-eta))
y &lt;- rbinom(n, size = size, prob = p)

pelt_pen_val &lt;- (log(n))^seq(0.5, 2, by = 0.1)
res &lt;- cpss.glm(
  formula = cbind(y, size - y) ~ x, family = binomial(),
  algorithm = "PELT", pelt_pen_val = pelt_pen_val, ncps_max = 10
)
summary(res)
# 75  105  175
coef(res)
# [1,] 0.02540872  0.08389551  0.5284425 -0.4980768
# [2,] 0.57222684 -0.45430385 -0.5203319 -0.4581678

</code></pre>

<hr>
<h2 id='cpss.lm'>Detecting changes in linear models</h2><span id='topic+cpss.lm'></span>

<h3>Description</h3>

<p>Detecting changes in linear models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpss.lm(
  formula,
  data = NULL,
  algorithm = "BS",
  dist_min = floor(log(n)),
  ncps_max = ceiling(n^0.4),
  pelt_pen_val = NULL,
  pelt_K = 0,
  wbs_nintervals = 500,
  criterion = "CV",
  times = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpss.lm_+3A_formula">formula</code></td>
<td>
<p>a <code>formula</code> object specifying the GLM with change-points.</p>
</td></tr>
<tr><td><code id="cpss.lm_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="cpss.lm_+3A_algorithm">algorithm</code></td>
<td>
<p>a character string specifying the change-point searching algorithm, one of the following choices: &quot;SN&quot; (segment neighborhood), &quot;BS&quot; (binary segmentation), &quot;WBS&quot; (wild binary segmentation) and &quot;PELT&quot; (pruned exact linear time) algorithms.</p>
</td></tr>
<tr><td><code id="cpss.lm_+3A_dist_min">dist_min</code></td>
<td>
<p>an integer specifying minimum searching distance (length of feasible segments).</p>
</td></tr>
<tr><td><code id="cpss.lm_+3A_ncps_max">ncps_max</code></td>
<td>
<p>an integer specifying an upper bound of the number of true change-points.</p>
</td></tr>
<tr><td><code id="cpss.lm_+3A_pelt_pen_val">pelt_pen_val</code></td>
<td>
<p>a numeric vector specifying candidate values of the penalty only if <code>algorithm = "PELT"</code>.</p>
</td></tr>
<tr><td><code id="cpss.lm_+3A_pelt_k">pelt_K</code></td>
<td>
<p>a numeric value for pruning adjustment only if <code>algorithm = "PELT"</code>. It is usually taken to be 0 if the negative log-likelihood is used as a cost, see Killick et al. (2012).</p>
</td></tr>
<tr><td><code id="cpss.lm_+3A_wbs_nintervals">wbs_nintervals</code></td>
<td>
<p>an integer specifying the number of random intervals drawn only if <code>algorithm = "WBS"</code>, see Fryzlewicz (2014).</p>
</td></tr>
<tr><td><code id="cpss.lm_+3A_criterion">criterion</code></td>
<td>
<p>a character string specifying the model selection criterion, &quot;CV&quot; (&quot;cross-validation&quot;) or &quot;MS&quot; (&quot;multiple-splitting&quot;).</p>
</td></tr>
<tr><td><code id="cpss.lm_+3A_times">times</code></td>
<td>
<p>an integer specifying how many times of sample-splitting should be performed; It should be 2 if <code>criterion = "CV"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cpss.lm</code> returns an object of an S4 class, called &quot;<code>cpss</code>&quot;, which collects data and information required for further change-point analyses and summaries. See <code><a href="#topic+cpss.custom">cpss.custom</a></code>.
</p>


<h3>References</h3>

<p>Killick, R., Fearnhead, P., and Eckley, I. A. (2012). Optimal Detection of Changepoints With a Linear Computational Cost. Journal of the American Statistical Association, 107(500):1590–1598.
</p>
<p>Fryzlewicz, P. (2014). Wild binary segmentation for multiple change-point detection. The Annals of Statistics, 42(6): 2243–2281.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpss.glm">cpss.glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("cpss")
set.seed(666)
n &lt;- 400
tau &lt;- c(80, 200, 300)
tau_ext &lt;- c(0, tau, n)
be &lt;- list(c(0, 1), c(1, 0.5), c(0, 1), c(-1, 0.5))
seg_len &lt;- diff(c(0, tau, n))
x &lt;- rnorm(n)
mu &lt;- lapply(seq(1, length(tau) + 1), function(k) {
  be[[k]][1] + be[[k]][2] * x[(tau_ext[k] + 1):tau_ext[k + 1]]
})
mu &lt;- do.call(c, mu)
sig &lt;- unlist(lapply(seq(1, length(tau) + 1), function(k) {
  rep(be[[k]][2], seg_len[k])
}))
y &lt;- rnorm(n, mu, sig)
res &lt;- cpss.lm(
  formula = y ~ x,
  algorithm = "BS", ncps_max = 10
)
summary(res)
# 80  202  291
coef(res)
# $coef
#             [,1]      [,2]        [,3]       [,4]
# [1,] -0.00188792 1.0457718 -0.03963209 -0.9444813
# [2,]  0.91061557 0.6291965  1.20694409  0.4410036
#
# $sigma
# [1] 0.8732233 0.4753216 0.9566516 0.4782329
</code></pre>

<hr>
<h2 id='cpss.mean'>Detecting changes in mean</h2><span id='topic+cpss.mean'></span>

<h3>Description</h3>

<p>Detecting changes in mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpss.mean(
  dataset,
  algorithm = "BS",
  dist_min = floor(log(n)),
  ncps_max = ceiling(n^0.4),
  pelt_pen_val = NULL,
  pelt_K = 0,
  wbs_nintervals = 500,
  criterion = "CV",
  times = 2,
  Sigma = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpss.mean_+3A_dataset">dataset</code></td>
<td>
<p>a numeric matrix of dimension <code class="reqn">n\times d</code>, where each row represents an observation and each column stands for a variable. A numeric vector is also acceptable for univariate observations.</p>
</td></tr>
<tr><td><code id="cpss.mean_+3A_algorithm">algorithm</code></td>
<td>
<p>a character string specifying the change-point searching algorithm, one of the following choices: &quot;SN&quot; (segment neighborhood), &quot;BS&quot; (binary segmentation), &quot;WBS&quot; (wild binary segmentation) and &quot;PELT&quot; (pruned exact linear time) algorithms.</p>
</td></tr>
<tr><td><code id="cpss.mean_+3A_dist_min">dist_min</code></td>
<td>
<p>an integer specifying minimum searching distance (length of feasible segments).</p>
</td></tr>
<tr><td><code id="cpss.mean_+3A_ncps_max">ncps_max</code></td>
<td>
<p>an integer specifying an upper bound of the number of true change-points.</p>
</td></tr>
<tr><td><code id="cpss.mean_+3A_pelt_pen_val">pelt_pen_val</code></td>
<td>
<p>a numeric vector specifying candidate values of the penalty only if <code>algorithm = "PELT"</code>.</p>
</td></tr>
<tr><td><code id="cpss.mean_+3A_pelt_k">pelt_K</code></td>
<td>
<p>a numeric value for pruning adjustment only if <code>algorithm = "PELT"</code>. It is usually taken to be 0 if the negative log-likelihood is used as a cost, see Killick et al. (2012).</p>
</td></tr>
<tr><td><code id="cpss.mean_+3A_wbs_nintervals">wbs_nintervals</code></td>
<td>
<p>an integer specifying the number of random intervals drawn only if <code>algorithm = "WBS"</code>, see Fryzlewicz (2014).</p>
</td></tr>
<tr><td><code id="cpss.mean_+3A_criterion">criterion</code></td>
<td>
<p>a character string specifying the model selection criterion, &quot;CV&quot; (&quot;cross-validation&quot;) or &quot;MS&quot; (&quot;multiple-splitting&quot;).</p>
</td></tr>
<tr><td><code id="cpss.mean_+3A_times">times</code></td>
<td>
<p>an integer specifying how many times of sample-splitting should be performed; It should be 2 if <code>criterion = "CV"</code>.</p>
</td></tr>
<tr><td><code id="cpss.mean_+3A_sigma">Sigma</code></td>
<td>
<p>if a numeric matrix (or constant) is supplied, it will be taken as the value of the common covariance (or variance). By default it is <code>NULL</code>, and the covariance is estimated by </p>
<p style="text-align: center;"><code class="reqn">\widehat{\Sigma} = \frac{1}{2(n-1)}\sum_{i=1}^{n-1} (Y_i-Y_{i+1})(Y_i-Y_{i+1})';</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cpss.mean</code> returns an object of an S4 class, called &quot;<code>cpss</code>&quot;, which collects data and information required for further change-point analyses and summaries. See <code><a href="#topic+cpss.custom">cpss.custom</a></code>.
</p>


<h3>References</h3>

<p>Killick, R., Fearnhead, P., and Eckley, I. A. (2012). Optimal Detection of Changepoints With a Linear Computational Cost. Journal of the American Statistical Association, 107(500): 1590–1598.
Fryzlewicz, P. (2014). Wild binary segmentation for multiple change-point detection. The Annals of Statistics, 42(6): 2243–2281.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpss.meanvar">cpss.meanvar</a></code> <code><a href="#topic+cpss.var">cpss.var</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("cpss")
set.seed(666)
n &lt;- 2048
tau &lt;- c(205, 267, 308, 472, 512, 820, 902, 1332, 1557, 1598, 1659)
seg_len &lt;- diff(c(0, tau, n))
mu &lt;- rep(c(0, 14.64, -3.66, 7.32, -7.32, 10.98, -4.39, 3.29, 19.03, 7.68, 15.37, 0), seg_len)
ep &lt;- 7 * rnorm(n)
y &lt;- mu + ep

res &lt;- cpss.mean(y, algorithm = "SN", ncps_max = 20)
summary(res)
# 205  267  307  471  512  820  897  1332  1557  1601  1659
plot(res, type = "scatter")
plot(res, type = "path")
out &lt;- update(res, dim_update = 12)
out@cps
# 205  267  307  471  512  820  897 1332 1557 1601 1659 1769
# coef(out)

</code></pre>

<hr>
<h2 id='cpss.meanvar'>Detecting changes in mean and (co)variance</h2><span id='topic+cpss.meanvar'></span>

<h3>Description</h3>

<p>Detecting changes in mean and (co)variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpss.meanvar(
  dataset,
  algorithm = "BS",
  dist_min = floor(log(n)),
  ncps_max = ceiling(n^0.4),
  pelt_pen_val = NULL,
  pelt_K = 0,
  wbs_nintervals = 500,
  criterion = "CV",
  times = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpss.meanvar_+3A_dataset">dataset</code></td>
<td>
<p>a numeric matrix of dimension <code class="reqn">n\times d</code>, where each row represents an observation and each column stands for a variable. A numeric vector is also acceptable for univariate observations.</p>
</td></tr>
<tr><td><code id="cpss.meanvar_+3A_algorithm">algorithm</code></td>
<td>
<p>a character string specifying the change-point searching algorithm, one of the following choices: &quot;SN&quot; (segment neighborhood), &quot;BS&quot; (binary segmentation), &quot;WBS&quot; (wild binary segmentation) and &quot;PELT&quot; (pruned exact linear time) algorithms.</p>
</td></tr>
<tr><td><code id="cpss.meanvar_+3A_dist_min">dist_min</code></td>
<td>
<p>an integer specifying minimum searching distance (length of feasible segments).</p>
</td></tr>
<tr><td><code id="cpss.meanvar_+3A_ncps_max">ncps_max</code></td>
<td>
<p>an integer specifying an upper bound of the number of true change-points.</p>
</td></tr>
<tr><td><code id="cpss.meanvar_+3A_pelt_pen_val">pelt_pen_val</code></td>
<td>
<p>a numeric vector specifying candidate values of the penalty only if <code>algorithm = "PELT"</code>.</p>
</td></tr>
<tr><td><code id="cpss.meanvar_+3A_pelt_k">pelt_K</code></td>
<td>
<p>a numeric value for pruning adjustment only if <code>algorithm = "PELT"</code>. It is usually taken to be 0 if the negative log-likelihood is used as a cost, see Killick et al. (2012).</p>
</td></tr>
<tr><td><code id="cpss.meanvar_+3A_wbs_nintervals">wbs_nintervals</code></td>
<td>
<p>an integer specifying the number of random intervals drawn only if <code>algorithm = "WBS"</code>, see Fryzlewicz (2014).</p>
</td></tr>
<tr><td><code id="cpss.meanvar_+3A_criterion">criterion</code></td>
<td>
<p>a character string specifying the model selection criterion, &quot;CV&quot; (&quot;cross-validation&quot;) or &quot;MS&quot; (&quot;multiple-splitting&quot;).</p>
</td></tr>
<tr><td><code id="cpss.meanvar_+3A_times">times</code></td>
<td>
<p>an integer specifying how many times of sample-splitting should be performed; It should be 2 if <code>criterion = "CV"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cpss.meanvar</code> returns an object of an S4 class, called &quot;<code>cpss</code>&quot;, which collects data and information required for further change-point analyses and summaries. See <code><a href="#topic+cpss.custom">cpss.custom</a></code>.
</p>


<h3>References</h3>

<p>Killick, R., Fearnhead, P., and Eckley, I. A. (2012). Optimal Detection of Changepoints With a Linear Computational Cost. Journal of the American Statistical Association, 107(500):1590–1598.
Fryzlewicz, P. (2014). Wild binary segmentation for multiple change-point detection. The Annals of Statistics, 42(6): 2243–2281.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpss.mean">cpss.mean</a></code> <code><a href="#topic+cpss.var">cpss.var</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("cpss")
if (!requireNamespace("MASS", quietly = TRUE)) {
  stop("Please install the package \"MASS\".")
}
set.seed(666)
n &lt;- 1000
tau &lt;- c(200, 400, 600, 800)
mu &lt;- list(rep(0, 2), rep(1, 2), rep(1, 2), rep(0, 2), rep(0, 2))
Sigma &lt;- list(diag(2), diag(2), matrix(c(1,-1,-1, 4), 2), matrix(c(1, 0.5, 0.5, 1), 2), diag(2))
seg_len &lt;- diff(c(0, tau, n))
y &lt;- lapply(seq(1, length(tau) + 1), function(k) {
  MASS::mvrnorm(n = seg_len[k], mu = mu[[k]], Sigma = Sigma[[k]])
})
y &lt;- do.call(rbind, y)
res &lt;- cpss.meanvar(y, algorithm = "BS", dist_min = 20)
cps(res)
# [1] 211 402 598 804
plot(res, type = "coef")
</code></pre>

<hr>
<h2 id='cpss.var'>Detecting changes in (co)variance</h2><span id='topic+cpss.var'></span>

<h3>Description</h3>

<p>Detecting changes in (co)variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpss.var(
  dataset,
  algorithm = "BS",
  dist_min = floor(log(n)),
  ncps_max = ceiling(n^0.4),
  pelt_pen_val = NULL,
  pelt_K = 0,
  wbs_nintervals = 500,
  criterion = "CV",
  times = 2,
  mu = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpss.var_+3A_dataset">dataset</code></td>
<td>
<p>a numeric matrix of dimension <code class="reqn">n\times d</code>, where each row represents an observation and each column stands for a variable. A numeric vector is also acceptable for univariate observations.</p>
</td></tr>
<tr><td><code id="cpss.var_+3A_algorithm">algorithm</code></td>
<td>
<p>a character string specifying the change-point searching algorithm, one of the following choices: &quot;SN&quot; (segment neighborhood), &quot;BS&quot; (binary segmentation), &quot;WBS&quot; (wild binary segmentation) and &quot;PELT&quot; (pruned exact linear time) algorithms.</p>
</td></tr>
<tr><td><code id="cpss.var_+3A_dist_min">dist_min</code></td>
<td>
<p>an integer specifying minimum searching distance (length of feasible segments).</p>
</td></tr>
<tr><td><code id="cpss.var_+3A_ncps_max">ncps_max</code></td>
<td>
<p>an integer specifying an upper bound of the number of true change-points.</p>
</td></tr>
<tr><td><code id="cpss.var_+3A_pelt_pen_val">pelt_pen_val</code></td>
<td>
<p>a numeric vector specifying candidate values of the penalty only if <code>algorithm = "PELT"</code>.</p>
</td></tr>
<tr><td><code id="cpss.var_+3A_pelt_k">pelt_K</code></td>
<td>
<p>a numeric value for pruning adjustment only if <code>algorithm = "PELT"</code>. It is usually taken to be 0 if the negative log-likelihood is used as a cost, see Killick et al. (2012).</p>
</td></tr>
<tr><td><code id="cpss.var_+3A_wbs_nintervals">wbs_nintervals</code></td>
<td>
<p>an integer specifying the number of random intervals drawn only if <code>algorithm = "WBS"</code>, see Fryzlewicz (2014).</p>
</td></tr>
<tr><td><code id="cpss.var_+3A_criterion">criterion</code></td>
<td>
<p>a character string specifying the model selection criterion, &quot;CV&quot; (&quot;cross-validation&quot;) or &quot;MS&quot; (&quot;multiple-splitting&quot;).</p>
</td></tr>
<tr><td><code id="cpss.var_+3A_times">times</code></td>
<td>
<p>an integer specifying how many times of sample-splitting should be performed; It should be 2 if <code>criterion = "CV"</code>.</p>
</td></tr>
<tr><td><code id="cpss.var_+3A_mu">mu</code></td>
<td>
<p>If a numeric vector or constant is supplied, it will be taken as the value of the common mean. By default it is <code>NULL</code>, and the mean is estimated by the sample mean.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cpss.var</code> returns an object of an S4 class, called &quot;<code>cpss</code>&quot;, which collects data and information required for further change-point analyses and summaries. See <code><a href="#topic+cpss.custom">cpss.custom</a></code>.
</p>


<h3>References</h3>

<p>Killick, R., Fearnhead, P., and Eckley, I. A. (2012). Optimal Detection of Changepoints With a Linear Computational Cost. Journal of the American Statistical Association, 107(500): 1590–1598.
Fryzlewicz, P. (2014). Wild binary segmentation for multiple change-point detection. The Annals of Statistics, 42(6): 2243–2281.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpss.meanvar">cpss.meanvar</a></code> <code><a href="#topic+cpss.mean">cpss.mean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("cpss")
if (!requireNamespace("MASS", quietly = TRUE)) {
  stop("Please install the package \"MASS\".")
}
set.seed(666)
n &lt;- 1000
tau &lt;- c(200, 500, 750)
mu &lt;- list(rep(0, 2), rep(0, 2), rep(0, 2), rep(0, 2))
Sigma &lt;- list(diag(2), matrix(c(1, 0, 0, 4), 2), matrix(c(1, -0.5, -0.5, 4), 2), diag(2))
seg_len &lt;- diff(c(0, tau, n))
y &lt;- lapply(seq(1, length(tau) + 1), function(k) {
  MASS::mvrnorm(n = seg_len[k], mu = mu[[k]], Sigma = Sigma[[k]])
})
y &lt;- do.call(rbind, y)
res &lt;- cpss.var(y, algorithm = "BS", dist_min = 20)
cps(res)
# [1] 215 515 751
</code></pre>

<hr>
<h2 id='dat'>Generic functions and methods: dat</h2><span id='topic+dat'></span><span id='topic+dat+3C-'></span><span id='topic+dat+2Ccpss-method'></span><span id='topic+dat+3C-+2Ccpss-method'></span>

<h3>Description</h3>

<p>Generic functions and methods: dat
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dat(x)

dat(x) &lt;- value

## S4 method for signature 'cpss'
dat(x)

## S4 replacement method for signature 'cpss'
dat(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dat_+3A_x">x</code></td>
<td>
<p>object from cpss</p>
</td></tr>
<tr><td><code id="dat_+3A_value">value</code></td>
<td>
<p>value assigned to x</p>
</td></tr>
<tr><td><code id="dat_+3A_cpss">cpss</code></td>
<td>
<p>cpss class</p>
</td></tr>
</table>

<hr>
<h2 id='mdl'>Generic functions and methods: mdl</h2><span id='topic+mdl'></span><span id='topic+mdl+3C-'></span><span id='topic+mdl+2Ccpss-method'></span><span id='topic+mdl+3C-+2Ccpss-method'></span>

<h3>Description</h3>

<p>Generic functions and methods: mdl
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdl(x)

mdl(x) &lt;- value

## S4 method for signature 'cpss'
mdl(x)

## S4 replacement method for signature 'cpss'
mdl(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mdl_+3A_x">x</code></td>
<td>
<p>object from cpss</p>
</td></tr>
<tr><td><code id="mdl_+3A_value">value</code></td>
<td>
<p>value assigned to x</p>
</td></tr>
</table>

<hr>
<h2 id='ncps'>Generic functions and methods: ncps</h2><span id='topic+ncps'></span><span id='topic+ncps+3C-'></span><span id='topic+ncps+2Ccpss-method'></span><span id='topic+ncps+3C-+2Ccpss-method'></span>

<h3>Description</h3>

<p>Generic functions and methods: ncps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncps(x)

ncps(x) &lt;- value

## S4 method for signature 'cpss'
ncps(x)

## S4 replacement method for signature 'cpss'
ncps(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ncps_+3A_x">x</code></td>
<td>
<p>object from cpss</p>
</td></tr>
<tr><td><code id="ncps_+3A_value">value</code></td>
<td>
<p>value assigned to x</p>
</td></tr>
</table>

<hr>
<h2 id='params'>Generic functions and methods: params</h2><span id='topic+params'></span><span id='topic+params+3C-'></span><span id='topic+params+2Ccpss-method'></span><span id='topic+params+3C-+2Ccpss-method'></span>

<h3>Description</h3>

<p>Generic functions and methods: params
</p>


<h3>Usage</h3>

<pre><code class='language-R'>params(x)

params(x) &lt;- value

## S4 method for signature 'cpss'
params(x)

## S4 replacement method for signature 'cpss'
params(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="params_+3A_x">x</code></td>
<td>
<p>object from cpss</p>
</td></tr>
<tr><td><code id="params_+3A_value">value</code></td>
<td>
<p>value assigned to x</p>
</td></tr>
</table>

<hr>
<h2 id='pelt_pen'>Generic functions and methods: pelt_pen</h2><span id='topic+pelt_pen'></span><span id='topic+pelt_pen+3C-'></span><span id='topic+pelt_pen+2Ccpss-method'></span><span id='topic+pelt_pen+3C-+2Ccpss-method'></span>

<h3>Description</h3>

<p>Generic functions and methods: pelt_pen
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pelt_pen(x)

pelt_pen(x) &lt;- value

## S4 method for signature 'cpss'
pelt_pen(x)

## S4 replacement method for signature 'cpss'
pelt_pen(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pelt_pen_+3A_x">x</code></td>
<td>
<p>object from cpss</p>
</td></tr>
<tr><td><code id="pelt_pen_+3A_value">value</code></td>
<td>
<p>value assigned to x</p>
</td></tr>
</table>

<hr>
<h2 id='plot+2Ccpss-method'>plot method</h2><span id='topic+plot+2Ccpss-method'></span>

<h3>Description</h3>

<p>plot method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'cpss'
plot(obj, type, x = c(), y = c(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot+2B2Ccpss-method_+3A_obj">obj</code></td>
<td>
<p>object from cpss</p>
</td></tr>
<tr><td><code id="plot+2B2Ccpss-method_+3A_type">type</code></td>
<td>
<p>type of visualization</p>
</td></tr>
<tr><td><code id="plot+2B2Ccpss-method_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="plot+2B2Ccpss-method_+3A_y">y</code></td>
<td>
<p>y</p>
</td></tr>
<tr><td><code id="plot+2B2Ccpss-method_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="plot+2B2Ccpss-method_+3A_cpss">cpss</code></td>
<td>
<p>cpss class</p>
</td></tr>
</table>

<hr>
<h2 id='S_vals'>Generic functions and methods: S_vals</h2><span id='topic+S_vals'></span><span id='topic+S_vals+3C-'></span><span id='topic+S_vals+2Ccpss-method'></span><span id='topic+S_vals+3C-+2Ccpss-method'></span>

<h3>Description</h3>

<p>Generic functions and methods: S_vals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S_vals(x)

S_vals(x) &lt;- value

## S4 method for signature 'cpss'
S_vals(x)

## S4 replacement method for signature 'cpss'
S_vals(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="S_vals_+3A_x">x</code></td>
<td>
<p>object from cpss</p>
</td></tr>
<tr><td><code id="S_vals_+3A_value">value</code></td>
<td>
<p>value assigned to x</p>
</td></tr>
</table>

<hr>
<h2 id='SC'>Generic functions and methods: SC</h2><span id='topic+SC'></span><span id='topic+SC+3C-'></span><span id='topic+SC+2Ccpss-method'></span><span id='topic+SC+3C-+2Ccpss-method'></span>

<h3>Description</h3>

<p>Generic functions and methods: SC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SC(x)

SC(x) &lt;- value

## S4 method for signature 'cpss'
SC(x)

## S4 replacement method for signature 'cpss'
SC(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SC_+3A_x">x</code></td>
<td>
<p>object from cpss</p>
</td></tr>
<tr><td><code id="SC_+3A_value">value</code></td>
<td>
<p>value assigned to x</p>
</td></tr>
</table>

<hr>
<h2 id='SC_vals'>Generic functions and methods: SC_vals</h2><span id='topic+SC_vals'></span><span id='topic+SC_vals+3C-'></span><span id='topic+SC_vals+2Ccpss-method'></span><span id='topic+SC_vals+3C-+2Ccpss-method'></span>

<h3>Description</h3>

<p>Generic functions and methods: SC_vals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SC_vals(x)

SC_vals(x) &lt;- value

## S4 method for signature 'cpss'
SC_vals(x)

## S4 replacement method for signature 'cpss'
SC_vals(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SC_vals_+3A_x">x</code></td>
<td>
<p>object from cpss</p>
</td></tr>
<tr><td><code id="SC_vals_+3A_value">value</code></td>
<td>
<p>value assigned to x</p>
</td></tr>
</table>

<hr>
<h2 id='summary+2Ccpss-method'>summary method</h2><span id='topic+summary+2Ccpss-method'></span>

<h3>Description</h3>

<p>summary method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'cpss'
summary(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary+2B2Ccpss-method_+3A_object">object</code></td>
<td>
<p>object from cpss</p>
</td></tr>
<tr><td><code id="summary+2B2Ccpss-method_+3A_cpss">cpss</code></td>
<td>
<p>cpss class</p>
</td></tr>
</table>

<hr>
<h2 id='update_inputs'>Generic functions and methods: update_inputs</h2><span id='topic+update_inputs'></span><span id='topic+update_inputs+3C-'></span><span id='topic+update_inputs+2Ccpss-method'></span><span id='topic+update_inputs+3C-+2Ccpss-method'></span>

<h3>Description</h3>

<p>Generic functions and methods: update_inputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_inputs(x)

update_inputs(x) &lt;- value

## S4 method for signature 'cpss'
update_inputs(x)

## S4 replacement method for signature 'cpss'
update_inputs(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_inputs_+3A_x">x</code></td>
<td>
<p>object from cpss</p>
</td></tr>
<tr><td><code id="update_inputs_+3A_value">value</code></td>
<td>
<p>value assigned to x</p>
</td></tr>
</table>

<hr>
<h2 id='update+2Ccpss-method'>update method</h2><span id='topic+update+2Ccpss-method'></span>

<h3>Description</h3>

<p>update method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'cpss'
update(object, dim_update)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update+2B2Ccpss-method_+3A_object">object</code></td>
<td>
<p>object from cpss</p>
</td></tr>
<tr><td><code id="update+2B2Ccpss-method_+3A_dim_update">dim_update</code></td>
<td>
<p>model dimension to update</p>
</td></tr>
<tr><td><code id="update+2B2Ccpss-method_+3A_cpss">cpss</code></td>
<td>
<p>cpss class</p>
</td></tr>
</table>

<hr>
<h2 id='well'>Well-log data</h2><span id='topic+well'></span>

<h3>Description</h3>

<p>Measurements of the nuclear magnetic response of underground rocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>well
</code></pre>


<h3>Format</h3>

<p>A vector of 4,050 measurements:
</p>

<dl>
<dt>well</dt><dd><p>Measurements.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.1111/1467-9868.00421">doi:10.1111/1467-9868.00421</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
