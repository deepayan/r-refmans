<!DOCTYPE html><html><head><title>Help for package vrnmf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vrnmf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AnchorFree'><p>Non-negative tri-factorization of co-occurence matrix using minimum volume approach.</p></a></li>
<li><a href='#factor_intensities'><p>Infer a matrix of non-negative intensities in NMF with offset/nmf-offset.</p></a></li>
<li><a href='#infer_intensities'><p>Infer a matrix of non-negative intensities in NMF</p></a></li>
<li><a href='#projection_onto_simplex'><p>Project vector onto a probabilistic simplex.</p></a></li>
<li><a href='#sim_factors'><p>Simulate matrices to explores <code>vrnmf</code></p></a></li>
<li><a href='#vol_preprocess'><p>Preprocess the data for downstream volume analysis.</p></a></li>
<li><a href='#volnmf_det'><p>Update volume-regularized matrix <code>R</code> using det volume approximation</p></a></li>
<li><a href='#volnmf_estimate'><p>Alternating optimization of volume-regularized NMF</p></a></li>
<li><a href='#volnmf_logdet'><p>Update volume-regularized matrix <code>R</code> using logdet volume approximation.</p></a></li>
<li><a href='#volnmf_main'><p>Volume-regularized NMF</p></a></li>
<li><a href='#volnmf_procrustes'><p>Procrustes algorithm estimates orthonormal transformation between two matrices.</p></a></li>
<li><a href='#volnmf_simplex_col'><p>Update of a matrix in NMF with equality contstraints on columns.</p></a></li>
<li><a href='#volnmf_simplex_row'><p>Update of a matrix in NMF with equality contstraints on rows.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Volume-Regularized Structured Matrix Factorization</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a set of routines to perform structured matrix factorization with minimum volume constraints. The NMF procedure decomposes a matrix X into a product C * D. Given conditions such that the matrix C is non-negative and has sufficiently spread columns, then volume minimization of a matrix D delivers a correct and unique, up to a scale and permutation, solution (C, D). This package provides both an implementation of volume-regularized NMF and "anchor-free" NMF, whereby the standard NMF problem is reformulated in the covariance domain. This algorithm was applied in Vladimir B. Seplyarskiy Ruslan A. Soldatov, et al. "Population sequencing data reveal a compendium of mutational processes in the human germ line". Science, 12 Aug 2021. &lt;<a href="https://doi.org/10.1126%2Fscience.aba7408">doi:10.1126/science.aba7408</a>&gt;. This package interacts with data available through the 'simulatedNMF' package, which is available in a 'drat' repository. To access this data package, see the instructions at <a href="https://github.com/kharchenkolab/vrnmf">https://github.com/kharchenkolab/vrnmf</a>. The size of the 'simulatedNMF' package is approximately 8 MB.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, ica (&ge; 1.0), lpSolveAPI (&ge; 5.5.2.0), Matrix, nnls,
parallel (&ge; 3.5.1), quadprog (&ge; 1.5), stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.28), rmarkdown (&ge; 2.1), testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kharchenkolab/vrnmf">https://github.com/kharchenkolab/vrnmf</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kharchenkolab/vrnmf/issues">https://github.com/kharchenkolab/vrnmf/issues</a></td>
</tr>
<tr>
<td>Author:</td>
<td>Ruslan Soldatov [aut],
  Peter Kharchenko [aut],
  Viktor Petukhov [aut],
  Evan Biederstedt [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Evan Biederstedt &lt;evan.biederstedt@gmail.com&gt;</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-25 04:13:35 UTC; evanbiederstedt</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-25 04:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AnchorFree'>Non-negative tri-factorization of co-occurence matrix using minimum volume approach.</h2><span id='topic+AnchorFree'></span>

<h3>Description</h3>

<p><code>AnchorFree</code> method tri-factorizes (co-occurence) matrix in a product  <code class="reqn">P ~ C*E*t(C)</code> of non-negative matrices <code class="reqn">C</code> and <code class="reqn">E</code>
such that matrix <code class="reqn">E</code> has mininum volume and columns of matrix <code class="reqn">C</code> equal to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AnchorFree(
  vol,
  n.comp = 3,
  init = NULL,
  init.type = "diag",
  n.iter = 30,
  err.cut = 1e-30,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AnchorFree_+3A_vol">vol</code></td>
<td>
<p>An output object of vol_preprocess(). The method factorizes co-occurence matrix <code>vol$P</code>.</p>
</td></tr>
<tr><td><code id="AnchorFree_+3A_n.comp">n.comp</code></td>
<td>
<p>An integer. Number of components to extract (by default 3). Defines number of columns in matrix <code class="reqn">C</code>. (default=3)</p>
</td></tr>
<tr><td><code id="AnchorFree_+3A_init">init</code></td>
<td>
<p>A numeric matrix. Initial matrix <code>M</code>. (default=3)</p>
</td></tr>
<tr><td><code id="AnchorFree_+3A_init.type">init.type</code></td>
<td>
<p>A character. A strategy to randomly initialize matrix <code>M</code>. (default=&quot;diag&quot;) Options are to
</p>
<p>1) generate diagonal unit matrix (&quot;diag&quot;),
</p>
<p>2) use ICA solution as initialization (&quot;ica&quot;, &quot;ica.pos&quot;).
</p>
<p>or sample entries from:
</p>
<p>3) uniform distribution <code>[0,1]</code> (&quot;unif.pos&quot;),
</p>
<p>4) unform distribution <code>[-1,1]</code>,
</p>
<p>5) uniform distribution <code>[0.9,1.1]</code> (&quot;similar&quot;),
</p>
<p>6) normal distribution <code>N(0,1)</code>.</p>
</td></tr>
<tr><td><code id="AnchorFree_+3A_n.iter">n.iter</code></td>
<td>
<p>An integer. Number of iterations. (default=30)</p>
</td></tr>
<tr><td><code id="AnchorFree_+3A_err.cut">err.cut</code></td>
<td>
<p>A numeric. Relative error in determinant between iterations to stop algorithm (now is not used). (default=1e-30)</p>
</td></tr>
<tr><td><code id="AnchorFree_+3A_verbose">verbose</code></td>
<td>
<p>A boolean. Print per-iteration information (default=FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implementation closely follows (Fu X <em>et al.</em>, IEEE Trans Pattern Anal Mach Intell., 2019).
</p>


<h3>Value</h3>

<p>List of objects:
</p>
<p><code>C</code>, <code>E</code> Factorization matrices.
</p>
<p><code>Pest</code> Estimate of <code>vol$P</code> co-occurence matrix <code class="reqn">Pest = C*E*t(C)</code>.
</p>
<p><code>M</code>, <code>detM</code> auxiliary matrix <code>M</code> and its determinant.
</p>
<p><code>init.type</code> type of initialization of matrix <code>M</code> that was used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>small_example &lt;- sim_factors(5, 5, 5)
vol &lt;- vol_preprocess(t(small_example$X))
vol.anchor &lt;- AnchorFree(vol)

</code></pre>

<hr>
<h2 id='factor_intensities'>Infer a matrix of non-negative intensities in NMF with offset/nmf-offset.</h2><span id='topic+factor_intensities'></span>

<h3>Description</h3>

<p><code>factor_intensities</code> estimates a non-negative matrix <code>D</code> that optimizes the objective function <code class="reqn">F = ||X - C*D - offset||^2</code>,
where offset is either column-specific offset or a &quot;1-rank nmf term&quot;: product of row vector and column vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factor_intensities(
  C,
  X,
  fit.nmf = TRUE,
  fit.factor = FALSE,
  qp.exact = FALSE,
  n.iter = 200,
  qp.iter = 10,
  rel.error.cutoff = 1e-05,
  extrapolate = TRUE,
  extrapolate.const = TRUE,
  extrapolate.convex = FALSE,
  q.factor = 1,
  verbose = TRUE,
  n.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factor_intensities_+3A_c">C</code></td>
<td>
<p>Numeric matrices.</p>
</td></tr>
<tr><td><code id="factor_intensities_+3A_x">X</code></td>
<td>
<p>Numeric matrices.</p>
</td></tr>
<tr><td><code id="factor_intensities_+3A_fit.nmf">fit.nmf</code></td>
<td>
<p>A boolean. Fit both intensities and spectrum of the offset residuals.</p>
</td></tr>
<tr><td><code id="factor_intensities_+3A_fit.factor">fit.factor</code></td>
<td>
<p>A boolean. Fit only spectrum of the offset residuals (keep intensities constant across samples).</p>
</td></tr>
<tr><td><code id="factor_intensities_+3A_qp.exact">qp.exact</code></td>
<td>
<p>A boolean. Estimate intensities using exact quadratic programming (qp.exact = TRUE) or inexact QP via gradient decent with extrapolation (qp.exact = FALSE).</p>
</td></tr>
<tr><td><code id="factor_intensities_+3A_n.iter">n.iter</code></td>
<td>
<p>An integer. Number of iterations.</p>
</td></tr>
<tr><td><code id="factor_intensities_+3A_qp.iter">qp.iter</code></td>
<td>
<p>= 1e+1 An integer. Number of iterations of inexact QP.</p>
</td></tr>
<tr><td><code id="factor_intensities_+3A_rel.error.cutoff">rel.error.cutoff</code></td>
<td>
<p>A numeric. Relative error cutoff between iterations to stop iterations.</p>
</td></tr>
<tr><td><code id="factor_intensities_+3A_extrapolate">extrapolate</code></td>
<td>
<p>A boolean. Use Nesterov-like extrapolation at each iteration.</p>
</td></tr>
<tr><td><code id="factor_intensities_+3A_extrapolate.const">extrapolate.const</code></td>
<td>
<p>A boolean. Use extrapolation scheme that adds a constant extrapolation q.factor (described below) at each iteration.</p>
</td></tr>
<tr><td><code id="factor_intensities_+3A_extrapolate.convex">extrapolate.convex</code></td>
<td>
<p>A boolean. Use Nesterov extrapolation scheme.</p>
</td></tr>
<tr><td><code id="factor_intensities_+3A_q.factor">q.factor</code></td>
<td>
<p>A numeric. Specification of a a constant extrapolation factor used in case of extrapolate.const = T.</p>
</td></tr>
<tr><td><code id="factor_intensities_+3A_verbose">verbose</code></td>
<td>
<p>A boolean.  Print per-iteration information (by default TRUE).</p>
</td></tr>
<tr><td><code id="factor_intensities_+3A_n.cores">n.cores</code></td>
<td>
<p>An integer. Number of cores to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fitted matrix <code>D</code>.
</p>

<hr>
<h2 id='infer_intensities'>Infer a matrix of non-negative intensities in NMF</h2><span id='topic+infer_intensities'></span>

<h3>Description</h3>

<p><code>infer_intensities</code> estimates a non-negative matrix <code>D</code> that optimizes the objective function <code class="reqn">F = ||X - C*D||^2</code>
using per-row quadratic programming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer_intensities(C, X, esign = "pos", n.cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infer_intensities_+3A_c">C</code></td>
<td>
<p>Numeric matrices.</p>
</td></tr>
<tr><td><code id="infer_intensities_+3A_x">X</code></td>
<td>
<p>Numeric matrices.</p>
</td></tr>
<tr><td><code id="infer_intensities_+3A_esign">esign</code></td>
<td>
<p>A character. Keep elements of matrix <code>D</code> non-negative (&quot;pos&quot;) or not (&quot;all). (default=&quot;pos&quot;)</p>
</td></tr>
<tr><td><code id="infer_intensities_+3A_n.cores">n.cores</code></td>
<td>
<p>An integer. Number of cores to use. (default=1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fitted matrix <code>D</code>.
</p>

<hr>
<h2 id='projection_onto_simplex'>Project vector onto a probabilistic simplex.</h2><span id='topic+projection_onto_simplex'></span>

<h3>Description</h3>

<p><code>projection_onto_simplex</code> projects a vector <code>unproj</code> onto a probabilistic simplex of sum <code>bound</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projection_onto_simplex(unproj, bound)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projection_onto_simplex_+3A_unproj">unproj</code></td>
<td>
<p>A numeric vector. An unprojected vector</p>
</td></tr>
<tr><td><code id="projection_onto_simplex_+3A_bound">bound</code></td>
<td>
<p>A numeric. Sum of projected vector elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A projected vector.
</p>

<hr>
<h2 id='sim_factors'>Simulate matrices to explores <code>vrnmf</code></h2><span id='topic+sim_factors'></span>

<h3>Description</h3>

<p><code>sim_factors</code> simulates non-negative factorization matrices <code>C</code> and <code>D</code>
under a variaty of conditions to explore factorization <code class="reqn">X = C*D + noise</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_factors(
  m,
  n,
  r,
  simplex = "col",
  distr = "unif",
  frac.zeros = 0.4,
  condition = FALSE,
  noise = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_factors_+3A_m">m</code></td>
<td>
<p>Integers. Size of matrices. Matrix <code>C</code> has a size of <code>m*r</code>
and matrix <code>D</code> has a size of <code>r*n</code>.</p>
</td></tr>
<tr><td><code id="sim_factors_+3A_n">n</code></td>
<td>
<p>Integers. Size of matrices. Matrix <code>C</code> has a size of <code>m*r</code>
and matrix <code>D</code> has a size of <code>r*n</code>.</p>
</td></tr>
<tr><td><code id="sim_factors_+3A_r">r</code></td>
<td>
<p>Integers. Size of matrices. Matrix <code>C</code> has a size of <code>m*r</code>
and matrix <code>D</code> has a size of <code>r*n</code>.</p>
</td></tr>
<tr><td><code id="sim_factors_+3A_simplex">simplex</code></td>
<td>
<p>A character. Either columns (&quot;col&quot;) or rows (&quot;row&quot;) of matrix <code>C</code> are projected onto unit simplex. (default=&quot;col&quot;)</p>
</td></tr>
<tr><td><code id="sim_factors_+3A_distr">distr</code></td>
<td>
<p>A character. Distribution to simulate matrix entries: &quot;unif&quot; for uniform and &quot;exp&quot; for exponential distributions. (default=&quot;unif&quot;)</p>
</td></tr>
<tr><td><code id="sim_factors_+3A_frac.zeros">frac.zeros</code></td>
<td>
<p>A numeric. Fraction of zeros in matrix <code>C</code>. It promotes sufficient scattering of matrix column/row vectors. (default=0.4)</p>
</td></tr>
<tr><td><code id="sim_factors_+3A_condition">condition</code></td>
<td>
<p>A boolean. Generate more well-conditioned matrix <code>R</code>. (default=FALSE)</p>
</td></tr>
<tr><td><code id="sim_factors_+3A_noise">noise</code></td>
<td>
<p>A numeric. Standard deviation of gaussian noise to add. (default=0e-4)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of simulated matrices:
</p>
<p><code>X.noise</code>, <code>X</code> - noisy and original matrix <code>X</code> to decompose.
</p>
<p><code>C</code>, <code>D</code> - factorization matrices.
</p>

<hr>
<h2 id='vol_preprocess'>Preprocess the data for downstream volume analysis.</h2><span id='topic+vol_preprocess'></span>

<h3>Description</h3>

<p><code>vol_preprocess</code> Routine normalizes the data (as requested), estimates covariance and SVD decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol_preprocess(X, col.norm = "sd", row.norm = NULL, pfactor = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vol_preprocess_+3A_x">X</code></td>
<td>
<p>A numeric matrix. Covariance is estimated for column vectors of <code>X</code>.</p>
</td></tr>
<tr><td><code id="vol_preprocess_+3A_col.norm">col.norm</code></td>
<td>
<p>A character. Specifies column normalization strategy (by default &quot;sd&quot;). NULL to avoid normalization.</p>
</td></tr>
<tr><td><code id="vol_preprocess_+3A_row.norm">row.norm</code></td>
<td>
<p>A character. Specifies row normalization strategy (by default NULL).</p>
</td></tr>
<tr><td><code id="vol_preprocess_+3A_pfactor">pfactor</code></td>
<td>
<p>A numeric A factor to normalize co-occurence matrix (by default NULL).
Row normalization follows column normalization. NULL to avoid normalization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects that include normalized matrix <code>X.process</code>, row and column normalization factors <code>row.factors</code> and <code>col.factors</code>,
covariance matrix <code>P0</code>, covariance matrix <code>P</code> normalized to maximum value <code>pfactor</code>,
orthonormal basis <code>U</code> and vector of eigenvalues <code>eigens</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>small_example &lt;- sim_factors(5, 5, 5)
vol &lt;- vol_preprocess(t(small_example$X))

</code></pre>

<hr>
<h2 id='volnmf_det'>Update volume-regularized matrix <code>R</code> using det volume approximation</h2><span id='topic+volnmf_det'></span>

<h3>Description</h3>

<p><code>volnmf_det</code> finds matrix <code>R</code> that minimizes objective
<code>||X-C*R||^2 + w.vol*det(R)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volnmf_det(
  C,
  X,
  R,
  posit = FALSE,
  w.vol = 0.1,
  eigen.cut = 1e-16,
  err.cut = 0.001,
  n.iter = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="volnmf_det_+3A_c">C</code></td>
<td>
<p>Numeric Matrices. Matrices involved in objective function. Matrix R serves as initialization.</p>
</td></tr>
<tr><td><code id="volnmf_det_+3A_x">X</code></td>
<td>
<p>Numeric Matrices. Matrices involved in objective function. Matrix R serves as initialization.</p>
</td></tr>
<tr><td><code id="volnmf_det_+3A_r">R</code></td>
<td>
<p>Numeric Matrices. Matrices involved in objective function. Matrix R serves as initialization.</p>
</td></tr>
<tr><td><code id="volnmf_det_+3A_posit">posit</code></td>
<td>
<p>A boolean. Set up (TRUE) or not (FALSE) non-negative constraints on matrix <code>R</code>. (default=TRUE)</p>
</td></tr>
<tr><td><code id="volnmf_det_+3A_w.vol">w.vol</code></td>
<td>
<p>A numeric. Volume (det) weight in objective function. (default=0.1)</p>
</td></tr>
<tr><td><code id="volnmf_det_+3A_eigen.cut">eigen.cut</code></td>
<td>
<p>A numeric. Threshold on eigenvalue of SVD eigenvectors. (default=1e-16)</p>
</td></tr>
<tr><td><code id="volnmf_det_+3A_err.cut">err.cut</code></td>
<td>
<p>A numeric. Stop algorithm if relative erro in R between iteration is less than <code>err.cut</code>. (default=1e-3)</p>
</td></tr>
<tr><td><code id="volnmf_det_+3A_n.iter">n.iter</code></td>
<td>
<p>An integer. Number of iterations. (default=1e+3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated matrix <code>R</code>.
</p>

<hr>
<h2 id='volnmf_estimate'>Alternating optimization of volume-regularized NMF</h2><span id='topic+volnmf_estimate'></span>

<h3>Description</h3>

<p><code>volnmf_estimate</code> provides alternating optimization of volume-regularized factorization of a matrix <code>B</code> using the following objective function:
<code class="reqn">F = ||B*Q - C*R||^2 + w.vol*volume(R)</code>. Matrix <code>C</code> is required to be non-negative and having either column or row vectors on the simplex.
Matrix <code>R</code> can optionally have non-negativity constraint. Matrix <code>Q</code> can optionally be identity matrix or any unitary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volnmf_estimate(
  B,
  C,
  R,
  Q,
  domain = "covariance",
  volf = "logdet",
  R.majorate = FALSE,
  wvol = NULL,
  delta = 1e-08,
  n.iter = 10000,
  err.cut = 1e-08,
  vol.iter = 100,
  c.iter = 100,
  extrapolate = TRUE,
  accelerate = TRUE,
  acc.C = 4/5,
  acc.R = 3/4,
  C.constraint = "col",
  C.bound = 1,
  R.constraint = "pos",
  verbose = TRUE,
  record = 100,
  Canchor = NULL,
  Ctrue = NULL,
  mutation.run = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="volnmf_estimate_+3A_b">B</code></td>
<td>
<p>A numeric matrix. A matrix to factorize (by default NULL). If not given than matrix <code>B</code> is taken to be a square root decomposition of <code class="reqn">P = B*t(B)</code>.</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_c">C</code></td>
<td>
<p>Numeric matrices. Initial matrices for optimiztion.</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_r">R</code></td>
<td>
<p>Numeric matrices. Initial matrices for optimiztion.</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_q">Q</code></td>
<td>
<p>Numeric matrices. Initial matrices for optimiztion.</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_domain">domain</code></td>
<td>
<p>A character. Optimize unitary rotation matrix <code>Q</code> (&quot;covariance&quot;) or keep it as identity matrix (as in standard NMF). By default &quot;covariance&quot;.</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_volf">volf</code></td>
<td>
<p>A character. Function that approximate volume. Can have values of &quot;logdet&quot; or &quot;det&quot; (by default &quot;logdet&quot;).</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_r.majorate">R.majorate</code></td>
<td>
<p>A boolean. Majorate logdet each iteration of <code>volnmf_logdet()</code> (by default FALSE).</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_wvol">wvol</code></td>
<td>
<p>A numeric. A weight of volume-regularized term <code>volume(R)</code>.</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_delta">delta</code></td>
<td>
<p>A numeric. Logdet regularization term <code>log(det(R) + delta)</code> (by default 1e-8).</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_n.iter">n.iter</code></td>
<td>
<p>An integer. Number of iterations (by default <code>1,000</code>).</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_err.cut">err.cut</code></td>
<td>
<p>A numeric. Relative error in determinant between iterations to stop algorithm (by default <code>1e-8</code>).</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_vol.iter">vol.iter</code></td>
<td>
<p>An integer. Number of iterations to update volume-regularized matrix <code>R</code> at each alternating step.</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_c.iter">c.iter</code></td>
<td>
<p>An integer. Number of iterations to update simplex matrix <code>C</code> at each alternating step.</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_extrapolate">extrapolate</code></td>
<td>
<p>A numeric. Do Nesterov extrapolation inside blocks of R and C optimization (by default TRUE).</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_accelerate">accelerate</code></td>
<td>
<p>A numeric. Do acceleration each update after R and C blocks estimated via Nesterov-like extrapolation.</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_acc.c">acc.C</code></td>
<td>
<p>A numeric. Acceleration parameter of matrix C.</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_acc.r">acc.R</code></td>
<td>
<p>A numeric. Acceleration parameter of matrix R.</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_c.constraint">C.constraint</code></td>
<td>
<p>A character. Constraint either sum of columns (&quot;col&quot;) or sum of rows (&quot;row) to be equal to <code>C.bound</code> (By default &quot;col&quot;).</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_c.bound">C.bound</code></td>
<td>
<p>A numeric. A simplex constraint on matrix C vectors.</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_r.constraint">R.constraint</code></td>
<td>
<p>A character. Set up non-negativity (&quot;pos&quot;) constraint on elements of <code>R</code> (by default &quot;pos&quot;, alternative &quot;no&quot;).</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_verbose">verbose</code></td>
<td>
<p>A boolean. Print per-iteration information (by default FALSE)</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_record">record</code></td>
<td>
<p>A numeric. Record parameters every 'record' iterations (by default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_canchor">Canchor</code></td>
<td>
<p>A matrix. A matrix of anchor components (unused currently). (default=NULL)</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_ctrue">Ctrue</code></td>
<td>
<p>A matrix. Correct matrix C if known. Useful for benchmark.</p>
</td></tr>
<tr><td><code id="volnmf_estimate_+3A_mutation.run">mutation.run</code></td>
<td>
<p>A boolean. Assess goodness of solution using reflection test if mutation.run=TRUE (applicable only to analysis of mutation patterns). (default=FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of objects:
</p>
<p><code>C, R, Q</code>, <code>E</code> Factorization matrices.
</p>
<p><code>iter, err</code> Number of iterations and relative per-iteration error <code>err</code> in matrix <code>C</code>.
</p>
<p><code>info.record</code> a list of objects that record and store state of matrices each <code>record</code> iterations.
</p>

<hr>
<h2 id='volnmf_logdet'>Update volume-regularized matrix <code>R</code> using logdet volume approximation.</h2><span id='topic+volnmf_logdet'></span>

<h3>Description</h3>

<p><code>volnmf_logdet</code> finds matrix <code>R</code> that minimizes objective
<code>||X-C*R||^2 + w.vol*log(det(R)+delta)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volnmf_logdet(
  C,
  X,
  R,
  R.constraint = "pos",
  majorate = FALSE,
  extrapolate = TRUE,
  qmax = 100,
  w.vol = 0.1,
  delta = 1,
  err.cut = 0.001,
  n.iter = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="volnmf_logdet_+3A_c">C</code></td>
<td>
<p>Numeric Matrices. Matrices involved in objective function.Matrix R serves as initialization.</p>
</td></tr>
<tr><td><code id="volnmf_logdet_+3A_x">X</code></td>
<td>
<p>Numeric Matrices. Matrices involved in objective function.Matrix R serves as initialization.</p>
</td></tr>
<tr><td><code id="volnmf_logdet_+3A_r">R</code></td>
<td>
<p>Numeric Matrices. Matrices involved in objective function.Matrix R serves as initialization.</p>
</td></tr>
<tr><td><code id="volnmf_logdet_+3A_r.constraint">R.constraint</code></td>
<td>
<p>A character. Set up ('pos') or not ('no') non-negative constraints on matrix <code>R</code> (by default 'pos').</p>
</td></tr>
<tr><td><code id="volnmf_logdet_+3A_majorate">majorate</code></td>
<td>
<p>A boolean. Majorate logdet each iteration (by default FALSE).</p>
</td></tr>
<tr><td><code id="volnmf_logdet_+3A_extrapolate">extrapolate</code></td>
<td>
<p>A boolean. Use Nesterov acceleration (by default FALSE, currently is not supported).</p>
</td></tr>
<tr><td><code id="volnmf_logdet_+3A_qmax">qmax</code></td>
<td>
<p>A numeric. Maximum asymptotic (1 - 1/qmax) of extrapolation step.</p>
</td></tr>
<tr><td><code id="volnmf_logdet_+3A_w.vol">w.vol</code></td>
<td>
<p>A numeric. Volume (logdet) weight in objective function.</p>
</td></tr>
<tr><td><code id="volnmf_logdet_+3A_delta">delta</code></td>
<td>
<p>A numeric. Determinant pseudocount in objective function.</p>
</td></tr>
<tr><td><code id="volnmf_logdet_+3A_err.cut">err.cut</code></td>
<td>
<p>A numeric. Stop algorithm if relative erro in R between iteration is less than <code>err.cut</code>.</p>
</td></tr>
<tr><td><code id="volnmf_logdet_+3A_n.iter">n.iter</code></td>
<td>
<p>An integer. Number of iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated matrix <code>R</code>.
</p>

<hr>
<h2 id='volnmf_main'>Volume-regularized NMF</h2><span id='topic+volnmf_main'></span>

<h3>Description</h3>

<p><code>volnmf_main</code> enables volume-regularized factorization of a matrix <code>B</code> using the following objective function:
<code class="reqn">F = ||B*Q - C*R||^2 + w.vol*volume(R)</code>. Matrix <code>C</code> is required to be non-negative and having either column or row vectors on the simplex.
Matrix <code>R</code> can optionally have non-negativity constraint. Matrix <code>Q</code> can optionally be identity matrix or any unitary.
The latter option is used to decompose co-occurence matrix <code>vol_P</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volnmf_main(
  vol,
  B = NULL,
  volnmf = NULL,
  n.comp = 3,
  n.reduce = n.comp,
  do.nmf = TRUE,
  iter.nmf = 100,
  seed = NULL,
  domain = "covariance",
  volf = "logdet",
  wvol = NULL,
  delta = 1e-08,
  n.iter = 500,
  err.cut = 1e-16,
  vol.iter = 20,
  c.iter = 20,
  extrapolate = TRUE,
  accelerate = FALSE,
  acc.C = 4/5,
  acc.R = 3/4,
  C.constraint = "col",
  C.bound = 1,
  R.constraint = "pos",
  R.majorate = FALSE,
  C.init = NULL,
  R.init = NULL,
  Q.init = NULL,
  anchor = NULL,
  Ctrue = NULL,
  verbose = TRUE,
  record = 100,
  verbose.nmf = FALSE,
  record.nmf = NULL,
  mutation.run = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="volnmf_main_+3A_vol">vol</code></td>
<td>
<p>An output object of vol_preprocess().</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_b">B</code></td>
<td>
<p>A numeric matrix. A matrix to factorize (by default NULL). If not given than matrix <code>B</code> is taken to be a square root decomposition of <code class="reqn">P = B*t(B)</code>.</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_volnmf">volnmf</code></td>
<td>
<p>An output object of <code>volnmf.main</code>. An option is useful to re-estimate solution using different parameters (by default NULL).</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_n.comp">n.comp</code></td>
<td>
<p>An integer. Number of components to extract (by default 3). Defines number of columns in matrix <code class="reqn">C</code>.</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_n.reduce">n.reduce</code></td>
<td>
<p>An integer. Dimensional reduction of matrix B (number of columns) if taken as a square root decomposition of <code>volP</code> (by default equal to <code>n.comp</code>).</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_do.nmf">do.nmf</code></td>
<td>
<p>A boolean. Estimate standard solution with <code>w.vol=0</code> as initialization before applying volume regularization (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_iter.nmf">iter.nmf</code></td>
<td>
<p>An integer. Number of iterations to get solution with <code>w.vol=0</code> if the former requested (by default <code>1,000</code>).</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_seed">seed</code></td>
<td>
<p>An integer. Fix seed.</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_domain">domain</code></td>
<td>
<p>A character. Optimize unitary rotation matrix <code>Q</code> (&quot;covariance&quot;) or keep it as identity matrix (as in standard NMF). By default &quot;covariance&quot;.</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_volf">volf</code></td>
<td>
<p>A character. Function that approximate volume. Can have values of &quot;logdet&quot; or &quot;det&quot; (by default &quot;logdet&quot;).</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_wvol">wvol</code></td>
<td>
<p>A numeric. A weight of volume-regularized term <code>volume(R)</code>.</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_delta">delta</code></td>
<td>
<p>A numeric. Logdet regularization term <code>log(det(R) + delta)</code> (by default 1e-8).</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_n.iter">n.iter</code></td>
<td>
<p>An integer. Number of iterations (by default <code>1,000</code>).</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_err.cut">err.cut</code></td>
<td>
<p>A numeric. Relative error in determinant between iterations to stop algorithm (by default <code>1e-8</code>).</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_vol.iter">vol.iter</code></td>
<td>
<p>An integer. Number of iterations to update volume-regularized matrix <code>R</code> at each alternating step.</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_c.iter">c.iter</code></td>
<td>
<p>An integer. Number of iterations to update simplex matrix <code>C</code> at each alternating step.</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_extrapolate">extrapolate</code></td>
<td>
<p>A numeric. Do Nesterov extrapolation inside blocks of R and C optimization (by default TRUE).</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_accelerate">accelerate</code></td>
<td>
<p>A numeric. Do acceleration each update after R and C blocks estimated via Nesterov-like extrapolation.</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_acc.c">acc.C</code></td>
<td>
<p>A numeric. Acceleration parameter of matrix C.</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_acc.r">acc.R</code></td>
<td>
<p>A numeric. Acceleration parameter of matrix R.</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_c.constraint">C.constraint</code></td>
<td>
<p>A character. Constraint either sum of columns (&quot;col&quot;) or sum of rows (&quot;row) to be equal to <code>C.bound</code> (By default &quot;col&quot;).</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_c.bound">C.bound</code></td>
<td>
<p>A numeric. A simplex constraint on matrix C vectors.</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_r.constraint">R.constraint</code></td>
<td>
<p>A character. Set up non-negativity (&quot;pos&quot;) constraint on elements of <code>R</code> (by default &quot;pos&quot;, alternative &quot;no&quot;).</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_r.majorate">R.majorate</code></td>
<td>
<p>A boolean. Majorate logdet each iteration of <code>volnmf_logdet()</code> (by default FALSE).</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_c.init">C.init</code></td>
<td>
<p>Numeric matrices. Initialization of matrices <code>C, R, Q</code> (by default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_r.init">R.init</code></td>
<td>
<p>Numeric matrices. Initialization of matrices <code>C, R, Q</code> (by default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_q.init">Q.init</code></td>
<td>
<p>Numeric matrices. Initialization of matrices <code>C, R, Q</code> (by default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_anchor">anchor</code></td>
<td>
<p>An output object of <code>AnchorFree()</code>. Object is used optionally to initialize matrices (by default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_ctrue">Ctrue</code></td>
<td>
<p>A matrix. Correct matrix C if known. Useful for benchmark.</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_verbose">verbose</code></td>
<td>
<p>A boolean. Print per-iteration information (by default FALSE).</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_record">record</code></td>
<td>
<p>A numeric. Record parameters every 'record' iterations (by default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_verbose.nmf">verbose.nmf</code></td>
<td>
<p>A boolean. Print per-iteration information for standard NMF (by default FALSE).</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_record.nmf">record.nmf</code></td>
<td>
<p>A numeric. Record parameters every 'record' iterations for standard NMF (by default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="volnmf_main_+3A_mutation.run">mutation.run</code></td>
<td>
<p>A boolean. Assess goodness of solution using reflection test if mutation.run=TRUE (applicable only to analysis of mutation patterns).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of objects:
</p>
<p><code>C, R, Q</code> Factorization matrices.
</p>
<p><code>C.init, R.init, Q.init</code> Initialization matrices for volume-regularized optimization.
</p>
<p><code>C.rand, R.rand, Q.rand</code> Random initialization matrices for NMF optimization <code>(w.vol=0)</code>.
</p>
<p><code>rec</code> a list of objects that record and store state of matrices each <code>record</code> iterations.
</p>

<hr>
<h2 id='volnmf_procrustes'>Procrustes algorithm estimates orthonormal transformation between two matrices.</h2><span id='topic+volnmf_procrustes'></span>

<h3>Description</h3>

<p><code>volnmf_procrustes</code> finds orthonormal matrix <code>Q</code> that minimizes objective
<code>||A-B*Q||^2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volnmf_procrustes(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="volnmf_procrustes_+3A_a">A</code></td>
<td>
<p>Numeric Matrices. Orthonormal transformation convert matrix <code>B</code> in matrix <code>A</code>.</p>
</td></tr>
<tr><td><code id="volnmf_procrustes_+3A_b">B</code></td>
<td>
<p>Numeric Matrices. Orthonormal transformation convert matrix <code>B</code> in matrix <code>A</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An optimal orthonormal tranformation matrix <code>Q</code>.
</p>

<hr>
<h2 id='volnmf_simplex_col'>Update of a matrix in NMF with equality contstraints on columns.</h2><span id='topic+volnmf_simplex_col'></span>

<h3>Description</h3>

<p><code>volnmf_simplex_col</code> finds non-negative matrix <code>C</code> that minimizes the objective <code>||X-C*R||^2</code>
under constraints that columns of C equal to 1 using local approximation with extrapolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volnmf_simplex_col(
  X,
  R,
  C.prev = NULL,
  bound = 1,
  extrapolate = TRUE,
  err.cut = 1e-10,
  n.iter = 10000,
  qmax = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="volnmf_simplex_col_+3A_x">X</code></td>
<td>
<p>Numeric Matrices. Matrices involved in the objective function.</p>
</td></tr>
<tr><td><code id="volnmf_simplex_col_+3A_r">R</code></td>
<td>
<p>Numeric Matrices. Matrices involved in the objective function.</p>
</td></tr>
<tr><td><code id="volnmf_simplex_col_+3A_c.prev">C.prev</code></td>
<td>
<p>Numeric Matrices. Matrices involved in the objective function. Matrix <code>C.prev</code> serves as initialization. (default=NULL)</p>
</td></tr>
<tr><td><code id="volnmf_simplex_col_+3A_bound">bound</code></td>
<td>
<p>A numeric. Equality constraint on columns of matrix <code>C</code>. (default=1)</p>
</td></tr>
<tr><td><code id="volnmf_simplex_col_+3A_extrapolate">extrapolate</code></td>
<td>
<p>A boolean. Use extrapolation after local approximation. (default=TRUE)</p>
</td></tr>
<tr><td><code id="volnmf_simplex_col_+3A_err.cut">err.cut</code></td>
<td>
<p>A numeric. Stop iterations if relative error between iterations is less than <code>err.cut</code> (parameter is not active now). (default=1e-10)</p>
</td></tr>
<tr><td><code id="volnmf_simplex_col_+3A_n.iter">n.iter</code></td>
<td>
<p>An integer. Number of iterations. (default=1000)</p>
</td></tr>
<tr><td><code id="volnmf_simplex_col_+3A_qmax">qmax</code></td>
<td>
<p>A numeric. Maximum asymptotic (1 - 1/qmax) of extrapolation step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated matrix <code>C</code>.
</p>

<hr>
<h2 id='volnmf_simplex_row'>Update of a matrix in NMF with equality contstraints on rows.</h2><span id='topic+volnmf_simplex_row'></span>

<h3>Description</h3>

<p><code>volnmf_simplex_row</code> finds non-negative matrix <code>C</code> that minimizes the objective <code>||X-C*R||^2</code>
under constraints that rows of C equal to 1 using per-row quadratic programming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volnmf_simplex_row(X, R, C.prev = NULL, meq = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="volnmf_simplex_row_+3A_x">X</code></td>
<td>
<p>Numeric Matrices. Matrices involved in the objective function.</p>
</td></tr>
<tr><td><code id="volnmf_simplex_row_+3A_r">R</code></td>
<td>
<p>Numeric Matrices. Matrices involved in the objective function.</p>
</td></tr>
<tr><td><code id="volnmf_simplex_row_+3A_c.prev">C.prev</code></td>
<td>
<p>Numeric Matrices. Matrices involved in the objective function. Matrix <code>C.prev</code> serves as initialization. (default=NULL)</p>
</td></tr>
<tr><td><code id="volnmf_simplex_row_+3A_meq">meq</code></td>
<td>
<p>An integer 0 or 1. Require equality (<code>meq=1</code>) or inequality (<code>meq=0</code>) constratint on rows (by default 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated matrix <code>C</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
