<!DOCTYPE html><html><head><title>Help for package blockmodeling</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {blockmodeling}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#blockmodeling'><p>An R package for Generalized and classical blockmodeling of valued networks</p></a></li>
<li><a href='#baker'><p>Citation data between social work journals for the 1985-86 period</p></a></li>
<li><a href='#canClu'><p>Create canonical partition and find unique canonical partitions in a list of partitions.</p></a></li>
<li><a href='#clu'><p>Function for extraction of some elements for objects, returend by functions for Generalized blockmodeling</p></a></li>
<li><a href='#critFunC'><p>Functions for Generalized blockmodeling for valued networks</p></a></li>
<li><a href='#expandMat'><p>Expands a square matrix by repeating each row/column the specified number of times.</p></a></li>
<li><a href='#find.cut'><p>Computing the threshold</p></a></li>
<li><a href='#formatA'><p>A formating function for numbers</p></a></li>
<li><a href='#funByBlocks.default'><p>Computation of function values by blocks</p></a></li>
<li><a href='#genMatrixMult'><p>Generalized matrix multiplication</p></a></li>
<li><a href='#genRandomPar'><p>The function for generating random partitions</p></a></li>
<li><a href='#gplot1'><p>A wrapper for function  gplot - Two-Dimensional Visualization of Graphs</p></a></li>
<li><a href='#ircNorm'><p>Function for iterated row and column normalization of valued matrices</p></a></li>
<li><a href='#loadmatrix'><p>Functions for loading and writing Pajek files</p></a></li>
<li><a href='#nanRep'><p>Replaces NaN values by the speficied values (0 by default)</p></a></li>
<li><a href='#nkpar'><p>Functions for listing all possible partitions or just counting the number of them</p></a></li>
<li><a href='#notesBorrowing'><p>The notes borrowing network between social-informatics students</p></a></li>
<li><a href='#one2two'><p>Two-mode network conversions</p></a></li>
<li><a href='#optRandomParC'><p>Optimizing a set of partitions based on the value of a criterion function</p></a></li>
<li><a href='#orderClu'><p>Orders the partition so that mean values of <code>fun</code> applied to columns (if <code>funWay=2</code>, default), rows (if <code>funWay=1</code>) or both (if <code>funWay=c(1,2)</code>) is decreasing by clusters.</p></a></li>
<li><a href='#plot.critFun'><p>Functions for plotting a partitioned matrix (representing the network)</p></a></li>
<li><a href='#printBlocks'><p>Nice printing of the <code>blocks</code> parameter as used in <code>optRandomParC</code> and <code>critFunC</code>.</p></a></li>
<li><a href='#rand'><p>Comparing partitions on one or multiple sets of units</p></a></li>
<li><a href='#recode'><p>Recode</p></a></li>
<li><a href='#REGE.FC'><p>REGE - Algorithms for compiting (dis)similarities in terms of regular equivalnece</p></a></li>
<li><a href='#relInv'><p>Functions for computing &quot;relative inverse&quot; (<code>x[1]/x</code>).</p></a></li>
<li><a href='#reorderImage'><p>Reordering an image matrix of the blockmodel (or an error matrix based on new and old partition</p></a></li>
<li><a href='#RF'><p>Calculate the value of the Relative Fit function</p></a></li>
<li><a href='#sedist'><p>Computes distances in terms of Structural equivalence (Lorrain &amp; White, 1971)</p></a></li>
<li><a href='#splitClu'><p>Functions creating a list of partitions based on a single partition and information on the number of units in each set.</p></a></li>
<li><a href='#ss'><p>Sum of Squared deviations from the mean and sum of Absolute Deviations from the median</p></a></li>
<li><a href='#unlistClu'><p>Function for &quot;unlisting&quot; a partition.</p></a></li>
<li><a href='#unlistCluInt'><p>Unlist a partition.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized and Classical Blockmodeling of Valued Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-23</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods, Matrix, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sna, doRNG, doParallel, foreach</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aleš Žiberna &lt;ales.ziberna@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>This is primarily meant as an implementation of generalized blockmodeling for valued networks.
 In addition, measures of similarity or dissimilarity based on structural equivalence and 
 regular equivalence (REGE algorithms) can be computed and partitioned matrices can be plotted:
 Žiberna (2007)&lt;<a href="https://doi.org/10.1016%2Fj.socnet.2006.04.002">doi:10.1016/j.socnet.2006.04.002</a>&gt;, Žiberna (2008)&lt;<a href="https://doi.org/10.1080%2F00222500701790207">doi:10.1080/00222500701790207</a>&gt;,
 Žiberna (2014)&lt;<a href="https://doi.org/10.1016%2Fj.socnet.2014.04.002">doi:10.1016/j.socnet.2014.04.002</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-23 11:24:46 UTC; zibernaa</td>
</tr>
<tr>
<td>Author:</td>
<td>Aleš Žiberna [aut, cre],
  Marjan Cugmas [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-23 15:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='blockmodeling'>An R package for Generalized and classical blockmodeling of valued networks</h2><span id='topic+blockmodeling'></span><span id='topic+blockmodeling-package'></span>

<h3>Description</h3>

<p>This package is primarily meant as an implementation of Generalized blockmodeling. In addition, functions for computation of (dis)similarities in terms of structural and regular equivalence, plotting and other &quot;utility&quot; functions are provided.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>References</h3>

<p>Doreian, P., Batagelj, V., &amp; Ferligoj, A. (2005). Generalized blockmodeling, (Structural analysis in the social sciences, 25). Cambridge [etc.]: Cambridge University Press.
</p>
<p>Žiberna, A. (2007). Generalized Blockmodeling of Valued Networks. Social Networks, 29(1), 105-126. doi: 10.1016/j.socnet.2006.04.002
</p>
<p>Žiberna, A. (2008). Direct and indirect approaches to blockmodeling of valued networks in terms of regular equivalence. Journal of Mathematical Sociology, 32(1), 57-84. doi: 10.1080/00222500701790207
</p>
<p>Žiberna, A. (2014). Blockmodeling of multilevel networks. Social Networks, 39(1), 46-61. doi: 10.1016/j.socnet.2014.04.002
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optRandomParC">optRandomParC</a></code>, <code><a href="#topic+critFunC">critFunC</a></code>, <code><a href="#topic+optParC">optParC</a></code>, <code><a href="#topic+IM">IM</a></code>, <code><a href="#topic+clu">clu</a></code>, <code><a href="#topic+err">err</a></code>, <code><a href="#topic+plotMat">plotMat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generating a simple network corresponding to the simple Sum of squares
# Structural equivalence with blockmodel:
# nul com
# nul nul
n &lt;- 20
net &lt;- matrix(NA, ncol = n, nrow = n)
clu &lt;- rep(1:2, times = c(5, 15))
tclu &lt;- table(clu)
net[clu == 1, clu == 1] &lt;- rnorm(n = tclu[1] * tclu[1], mean = 0, sd = 1)
net[clu == 1, clu == 2] &lt;- rnorm(n = tclu[1] * tclu[2], mean = 4, sd = 1)
net[clu == 2, clu == 1] &lt;- rnorm(n = tclu[2] * tclu[1], mean = 0, sd = 1)
net[clu == 2, clu == 2] &lt;- rnorm(n = tclu[2] * tclu[2], mean = 0, sd = 1)

# Computation of criterion function with the correct partition
res &lt;- critFunC(M = net, clu = clu, approaches = "hom", homFun = "ss", blocks = "com")
res$err # The error is relatively small
plot(res)

# Computation of criterion function with the correct partition and correct pre-specified blockmodel
# Prespecified blockmodel used
# nul com
# nul nul
B &lt;- array(NA, dim = c(1, 1, 2, 2))
B[1, 1, , ] &lt;- "nul"
B[1, 1, 1, 2] &lt;- "com"
B[1, 1, , ]
res &lt;- critFunC(M = net, clu = clu, approaches = "hom", homFun = "ss", blocks = B)
err(res) # The error is relatively small
IM(res)
plot(res)

# Computation of criterion function with the correct partition
# and pre-specified blockmodel with some alternatives
# Prespecified blockmodel used
# nul nul|com
# nul nul
B &lt;- array(NA, dim = c(2, 2, 2))
B[1, , ] &lt;- "nul"
B[2, 1, 2] &lt;- "com"
res &lt;- critFunC(M = net, clu = clu, approaches = "hom", homFun = "ss", blocks = B)
err(res) # The error is relatively small
IM(res)
plot(res)


# Optimizing a very bad partition
cluStart &lt;- rep(1:2, times = 10)
res &lt;- optParC(M = net,
               clu = cluStart,
               approaches = "hom", homFun = "ss", blocks = "com")
clu(res) # Hopefully we get the original partition)
err(res) 
plot(res) 

# Optimizing 10 random chosen partitions with optRandomParC
res &lt;- optRandomParC(M = net, k = 2, rep = 10,
approaches = "hom", homFun = "ss", blocks = "com")
clu(res) # Hopefully we get the original partition)
err(res) 
plot(res)

# Adapt network for Valued blockmodeling with the same model
net[net &gt; 4] &lt;- 4
net[net &lt; 0] &lt;- 0

# Computation of criterion function with the correct partition
res &lt;- critFunC(M = net, clu = clu, approaches = "val",
                blocks = c("nul", "com"), preSpecM = 4)
err(res) # The error is relatively small
IM(res)
# The image corresponds to the one used for generation of
# The network
plot(res)

</code></pre>

<hr>
<h2 id='baker'>Citation data between social work journals for the 1985-86 period</h2><span id='topic+baker'></span>

<h3>Description</h3>

<p>This example consists of the citation data between social 
work journals for the 1985-86 period, collected and analyzed 
in Baker (1992)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(baker)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 20 rows and 20 columns.
</p>


<h3>References</h3>

<p>Baker, D. R. (1992). A Structural Analysis of Social Work Journal Network: 1985-1986. Journal of Social Service Research, 15(3-4), 153-168. doi: 10.1300/J079v15n03_09
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data(baker)
# Transforming it to matrix format
# baker &lt;- as.matrix(baker)
# putting zeros on the diagonal
# diag(baker) &lt;- 0 
</code></pre>

<hr>
<h2 id='canClu'>Create canonical partition and find unique canonical partitions in a list of partitions.</h2><span id='topic+canClu'></span><span id='topic+canCluUniqe'></span>

<h3>Description</h3>

<p>It is used to convert any partition to a canonical partition. A canonical partition is a partition where the first unit is in cluster 1, the next unit that is not in cluster 1 in in cluster 2 and so on. So if we would take first appearances of clusters in the order they appear in the partition vector, we would get integers from 1 to the number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>canClu(clu)

canCluUniqe(cluList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="canClu_+3A_clu">clu</code></td>
<td>
<p>A partition - a vector or a list of vectors/partitions.</p>
</td></tr>
<tr><td><code id="canClu_+3A_clulist">cluList</code></td>
<td>
<p>A list of partitions(vectors).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For function <code>canClu</code> - a canonical partition or a list of such partitions.
For function <code>canCluUniqe</code> - A list of unique canonical partitions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clu">clu</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clu&lt;-c(3,2,2,3,1,2)
canClu(clu)
</code></pre>

<hr>
<h2 id='clu'>Function for extraction of some elements for objects, returend by functions for Generalized blockmodeling</h2><span id='topic+clu'></span><span id='topic+partitions'></span><span id='topic+err'></span><span id='topic+IM'></span><span id='topic+EM'></span>

<h3>Description</h3>

<p>Functions for extraction of partition (<code>clu</code>), all best partitions (<code>partitions</code>),
image or blockmodel (<code>IM</code>)) and  total error or inconsistency (<code>err</code>) for objects,
returned by functions <code><a href="#topic+critFunC">critFunC</a></code> or <code><a href="#topic+optRandomParC">optRandomParC</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clu(res, which = 1, ...)

partitions(res)

err(res, ...)

IM(res, which = 1, drop = TRUE, ...)

EM(res, which = 1, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clu_+3A_res">res</code></td>
<td>
<p>Result of function <code><a href="#topic+critFunC">critFunC</a></code> or <code><a href="#topic+optRandomParC">optRandomParC</a></code>.</p>
</td></tr>
<tr><td><code id="clu_+3A_which">which</code></td>
<td>
<p>From <code>which</code> (if there are more than one) &quot;best&quot; solution should the
element be extracted. Warning! <code>which</code> grater than the number of &quot;best&quot; partitions
produces an error.</p>
</td></tr>
<tr><td><code id="clu_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="clu_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code> (default), dimensions that have only one level are dropped
(<code>drop</code> function is applied to the final result).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The desired element.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>References</h3>

<p>Doreian, P., Batagelj, V., &amp; Ferligoj, A. (2005). Generalized blockmodeling, (Structural analysis in the social sciences, 25). Cambridge [etc.]: Cambridge University Press.
</p>
<p>Žiberna, A. (2007). Generalized Blockmodeling of Valued Networks. Social Networks, 29(1), 105-126. doi: 10.1016/j.socnet.2006.04.002
</p>
<p>Žiberna, A. (2008). Direct and indirect approaches to blockmodeling of valued networks in terms of regular equivalence. Journal of Mathematical Sociology, 32(1), 57-84. doi: 10.1080/00222500701790207
</p>


<h3>See Also</h3>

<p><code><a href="#topic+critFunC">critFunC</a></code>, <code><a href="#topic+plot.mat">plot.mat</a></code>, <code><a href="#topic+optRandomParC">optRandomParC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 8 # If larger, the number of partitions increases dramatically,
# as does if we increase the number of clusters
net &lt;- matrix(NA, ncol = n, nrow = n)
clu &lt;- rep(1:2, times = c(3, 5))
tclu &lt;- table(clu)
net[clu == 1, clu == 1] &lt;- rnorm(n = tclu[1] * tclu[1], mean = 0, sd = 1)
net[clu == 1, clu == 2] &lt;- rnorm(n = tclu[1] * tclu[2], mean = 4, sd = 1)
net[clu == 2, clu == 1] &lt;- rnorm(n = tclu[2] * tclu[1], mean = 0, sd = 1)
net[clu == 2, clu == 2] &lt;- rnorm(n = tclu[2] * tclu[2], mean = 0, sd = 1)

# We select a random partition and then optimize it
all.par &lt;- nkpartitions(n = n, k = length(tclu))
# Forming the partitions
all.par &lt;- lapply(apply(all.par, 1, list),function(x) x[[1]])
# to make a list out of the matrix
res &lt;- optParC(M = net,
   clu = all.par[[sample(1:length(all.par), size = 1)]],
    approaches = "hom", homFun = "ss", blocks = "com")
plot(res) # Hopefully we get the original partition
clu(res) # Hopefully we get the original partition
err(res) # Error
IM(res) # Image matrix/array.
EM(res) # Error matrix/array.

 
</code></pre>

<hr>
<h2 id='critFunC'>Functions for Generalized blockmodeling for valued networks</h2><span id='topic+critFunC'></span><span id='topic+optParC'></span>

<h3>Description</h3>

<p>Functions for implementation of Generalized blockmodeling for valued
networks where the values of the ties are assumed to be measured on at least interval
scale. <code>critFunC</code> calculates the criterion function, based on the network, partition and blockmodel/equivalece.
<code>optParC</code> optimizes a partition based on the criterion function based on a local search algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>critFunC(
  M,
  clu,
  approaches,
  blocks,
  isTwoMode = NULL,
  isSym = NULL,
  diag = 1,
  IM = NULL,
  EM = NULL,
  Earr = NULL,
  justChange = FALSE,
  rowCluChange = c(0, 0),
  colCluChange = c(0, 0),
  sameIM = FALSE,
  regFun = "max",
  homFun = "ss",
  usePreSpecM = NULL,
  preSpecM = NULL,
  save.initial.param = TRUE,
  relWeights = 1,
  posWeights = 1,
  blockTypeWeights = 1,
  combWeights = NULL,
  returnEnv = FALSE,
  mulReg = TRUE,
  addGroupLlErr = TRUE
)

optParC(
  M,
  clu,
  approaches,
  blocks,
  nMode = NULL,
  isSym = NULL,
  diag = 1,
  useMulti = FALSE,
  maxPar = 50,
  IM = NULL,
  EM = NULL,
  Earr = NULL,
  justChange = TRUE,
  sameIM = FALSE,
  regFun = "max",
  homFun = "ss",
  usePreSpecM = NULL,
  preSpecM = NULL,
  minUnitsRowCluster = 1,
  minUnitsColCluster = 1,
  maxUnitsRowCluster = 9999,
  maxUnitsColCluster = 9999,
  relWeights = 1,
  posWeights = 1,
  blockTypeWeights = 1,
  combWeights = NULL,
  exchageClusters = "all",
  fixClusters = NULL,
  save.initial.param = TRUE,
  mulReg = TRUE,
  addGroupLlErr = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="critFunC_+3A_m">M</code></td>
<td>
<p>A matrix representing the (usually valued) network. For multi-relational networks, this should be an array with the third dimension representing the relation. The network can have one or more modes (diferent kinds of units with no ties among themselves). If the network is not two-mode, the matrix must be square.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_clu">clu</code></td>
<td>
<p>A partition. Each unique value represents one cluster. If the nework is one-mode, than this should be a vector, else a list of vectors, one for each mode. Similarly, if units are comprised of several sets, <code>clu</code> should be the list containing one vector for each set.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_approaches">approaches</code></td>
<td>
<p>One of the approaches (for each relation in multi-relational netowrks in a vector) described in Žiberna (2007). Possible values are:<br />
&quot;bin&quot; - binary blockmodeling,<br />
&quot;val&quot; - valued blockmodeling,<br />
&quot;hom&quot; - homogeneity blockmodeling,<br />
&quot;ss&quot; - sum of squares homogeneity blockmodeling, and<br />
&quot;ad&quot; - absolute deviations homogeneity blockmodeling.<br />
<br />
The last two options are &quot;shorthand&quot; for specifying <code>approaches="hom"</code> and  <code>homFun</code> to either <code>"ss"</code> or  <code>"ad"</code>.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_blocks">blocks</code></td>
<td>
<p>A vector, a list of vectors or an array with names of allowed blocy types. <br />
<br />
Only listing of allowed block types (blockmodel is not pre-specified).<br />
A vector with names of allowed block types. For multi-relational networks, it can be a list of such vectors. For <code>approaches = "bin"</code> or <code>approaches = "val"</code>, at least two should be selected. Possible values are:<br />
<code>"nul"</code> - null or empty block<br />
<code>"com"</code> - complete block<br />
<code>"rdo"</code>, <code>"cdo"</code> - row and column-dominant blocks (binary and valued approach only)<br />
<code>"reg"</code> - (f-)regular block<br />
<code>"rre"</code>, <code>"cre"</code> - row and column-(f-)regular blocks<br />
<code>"rfn"</code>, <code>"cfn"</code> - row and column-dominant blocks (binary, valued only)<br />
<code>"den"</code> - density block (binary approach only)<br />
<code>"avg"</code> - average block (valued approach only)<br />
<code>"dnc"</code> - do not care block - the error is always zero<br />
The ordering is important, since if several block types have identical error, the first on the list is selected.<br /><br />
A pre-specified blockmodel.<br />
An array with four dimensions (see example below). The third and the fourth represent the clusters (for rows and columns). The first is as long as the maximum number of allows block types for a given block. If some block has less possible block types, the empty slots should have values <code>NA</code>. The second dimension is the number of relations (1 for single-relational networks). The values in the array should be the ones from above. The array can have only three dimensions in case of one-relational networks or if the same pre-specified blockmodel is assumed for all relations. Further, it can have only two dimensions, if in addition only one block type is allowed per block.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_istwomode">isTwoMode</code></td>
<td>
<p><code>1</code> for one-mode networks and <code>2</code> for two-mode networks. The default value is set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_issym">isSym</code></td>
<td>
<p>Specifying if the matrix (for each relation) is symmetric.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_diag">diag</code></td>
<td>
<p>Should the special status of diagonal be acknowledged. A single number or a vector equal to the number of relation. The default value is set to <code>1</code>. Codes: <br />
<code>0</code> - diagonal is treated in the same way as other values <br />
<code>1</code> - diagonal is  treated separately, or <br />
<code>2</code> - diagonal values are ignored. <br /></p>
</td></tr>
<tr><td><code id="critFunC_+3A_im">IM</code></td>
<td>
<p>The obtained image for objects. For debugging purposes only.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_em">EM</code></td>
<td>
<p>Block errors by blocks. For debugging purposes only.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_earr">Earr</code></td>
<td>
<p>The array of errors for all allowed block types by next dimensions: allowed block types, relations, row clusters and column clusters. The dimensions should match the dimensions of the block argument if specified as an array. For debugging purposes only.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_justchange">justChange</code></td>
<td>
<p>Value specifying if only the errors for changed clusters should be computed. Used only for debugging purposes by developers.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_rowcluchange">rowCluChange</code></td>
<td>
<p>An array holding the two row clusters where the change occured. Used only for debugging purposes by developers.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_colcluchange">colCluChange</code></td>
<td>
<p>An array holding the col row clusters where the change occured. Used only for debugging purposes by developers.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_sameim">sameIM</code></td>
<td>
<p>Should we demand the same blockmodel image for all relations. The default value is set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_regfun">regFun</code></td>
<td>
<p>Function f used in row-f-regular, column-f-regular, and f-regular blocks. Not used in binary approach. For multi-relational networks, it can be a vector of such character strings. The default value is set to <code>"max"</code>.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_homfun">homFun</code></td>
<td>
<p>In case of homogeneity blockmodeling two variability criteria can be used: <code>"ss"</code> - sum of squares (set by default),  <code>"ad"</code> - absolute deviations and <code>"bll"</code> - - (minus) binary log-likelihood.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_useprespecm">usePreSpecM</code></td>
<td>
<p>Specifying weather a pre-specified value should be used when computing inconsistency.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_prespecm">preSpecM</code></td>
<td>
<p>Sufficient value for individual cells for valued approach. Can be a number or a character string giving the name of a function. Set to <code>"max"</code> for implicit approach. For multi-relational networks, it can be a vector of such values. In case ob binary blockmodeling this argument is a threshold used for binerizing the network. Therefore all values with values lower than <code>preSpecM</code> are recoded into 0s, all other into 1s. For multi-relational networks, it can be a vector of such values. In case of pre-specified blockmodeling, it can have the same dimensions as <code>blocks</code>.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_save.initial.param">save.initial.param</code></td>
<td>
<p>Should the inital parameters (<code>approaches</code>, ...) be saved. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_relweights">relWeights</code></td>
<td>
<p>Weights for all type of relations in a blockmodel. The default value is set to <code>1</code>.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_posweights">posWeights</code></td>
<td>
<p>Weigths for positions in the blockmodel (the dimensions must be the same as the error matrix (rows, columns)). For now this is a matix (two-dimensional) even for multi-relational networks.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_blocktypeweights">blockTypeWeights</code></td>
<td>
<p>Weights for each type of block used, if they are to be different across block types (see <code>blocks</code> above). It must be suplied in form of a named vector, where the names are one or all allowed block types from <code>blocks</code>. If only some block types are specified, the other have a default weight of 1. The default value is set to <code>1</code>.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_combweights">combWeights</code></td>
<td>
<p>Weights for all type of block used, The default value is set to <code>NULL</code>.The dimension must be the same as <code>blocks</code>, if <code>blocks</code> would be specified in array format (which is usual in pre-specified case).</p>
</td></tr>
<tr><td><code id="critFunC_+3A_returnenv">returnEnv</code></td>
<td>
<p>Should the function also return the environment after its completion.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_mulreg">mulReg</code></td>
<td>
<p>Should the errors that apply to rows/columns (and not to cells) should be multiplied by number of rows/columns. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_addgroupllerr">addGroupLlErr</code></td>
<td>
<p>Used only when stochastic generalized blockmodeling is used. Should the total error included the part based on sizes of groups. Defaults to TRUE. Will return wrong results for two-mode networks if critFunC is called directly (should be fine if called via optParC function).</p>
</td></tr>
<tr><td><code id="critFunC_+3A_nmode">nMode</code></td>
<td>
<p>Number of nodes. If <code>NULL</code>, then determined from <code>clu</code>.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_usemulti">useMulti</code></td>
<td>
<p>Which version of local search should be used. The default value is set to <code>FALSE</code>. If <code>FALSE</code>, first possible all moves in random order and then all possible exchanges in random order are tired. When a move with lower value of criterion function is found, the algorithm moves to this new partition. If <code>TRUE</code> the version of local search where all possible moves and exchanges are tired first and then the one with the lowest error is selected and used. In this case, several optimal partitions are found. <code>maxPar</code> best partitions are returned.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_maxpar">maxPar</code></td>
<td>
<p>The number of partitions with optimal criterion fuction to be returned. Only used If <code>useMulti</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_minunitsrowcluster">minUnitsRowCluster</code></td>
<td>
<p>Minimum number of units in row cluster.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_minunitscolcluster">minUnitsColCluster</code></td>
<td>
<p>Minimum number of units in col cluster.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_maxunitsrowcluster">maxUnitsRowCluster</code></td>
<td>
<p>Maximum number of units in row cluster.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_maxunitscolcluster">maxUnitsColCluster</code></td>
<td>
<p>Maximum number of units in col cluster.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_exchageclusters">exchageClusters</code></td>
<td>
<p>A matrix of dimensions &quot;number of clusters&quot; x &quot;number of clusters&quot; indicating to which clusters can units from a specific cluster be moved. Useful for multilevel blockmodeling or/in some other cases where some units cannot mix.</p>
</td></tr>
<tr><td><code id="critFunC_+3A_fixclusters">fixClusters</code></td>
<td>
<p>Clusters to be fixed. Used only if <code>exchageClusters = "all"</code>. A vector of integers that specify clusters to be fixed, where clusters are numbered from 1 to the total (in all modes or sets) number of clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>critFunC</code> returns a list containing:
</p>
<table>
<tr><td><code>M</code></td>
<td>
<p>The matrix of the network analyzed.</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>The error or inconsistency emplirical network with the ideal network for a given blockmodel (model, approach,...) and paritition.</p>
</td></tr>
<tr><td><code>clu</code></td>
<td>
<p>The analyzed partition.</p>
</td></tr>
<tr><td><code>EM</code></td>
<td>
<p>Block errors by blocks.</p>
</td></tr>
<tr><td><code>IM</code></td>
<td>
<p>The obtained image for objects.</p>
</td></tr>
<tr><td><code>BM</code></td>
<td>
<p>Block means by block - only for Homogeneity blockmodeling.</p>
</td></tr>
<tr><td><code>Earr</code></td>
<td>
<p>The array of errors for all allowed block types by next dimensions: allowed block types, relations, row clusters and column clusters. The dimensions should match the dimensions of the block argument if specified as an array.</p>
</td></tr></table>
<p><br />
<code>optParC</code> returns a list containing:
</p>
<table>
<tr><td><code>M</code></td>
<td>
<p>The matrix of the network analyzed.</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>The error or inconsistency emplirical network with the ideal network for a given blockmodel (model, approach,...) and paritition.</p>
</td></tr>
<tr><td><code>clu</code></td>
<td>
<p>The analyzed partition.</p>
</td></tr>
<tr><td><code>EM</code></td>
<td>
<p>Block errors by blocks.</p>
</td></tr>
<tr><td><code>IM</code></td>
<td>
<p>The obtained image for objects.</p>
</td></tr>
<tr><td><code>BM</code></td>
<td>
<p>Block means by block - only for Homogeneity blockmodeling.</p>
</td></tr>
<tr><td><code>Earr</code></td>
<td>
<p>The array of errors for all allowed block types by next dimensions: allowed block types, relations, row clusters and column clusters. The dimensions should match the dimensions of the block argument if specified as an array.</p>
</td></tr>
<tr><td><code>useMulti</code></td>
<td>
<p>The value of the input paramter <code>useMulti</code>.</p>
</td></tr>
<tr><td><code>bestRowParMatrix</code></td>
<td>
<p>(If <code>useMulti = TRUE</code>) Matrix, where there are different solutions for columns, where rows represent units.</p>
</td></tr>
<tr><td><code>sameErr</code></td>
<td>
<p>The number of partitions with the minimum value of the criterion function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aleš, Žiberna
</p>


<h3>References</h3>

<p>Doreian, P., Batagelj, V., &amp; Ferligoj, A. (2005). Generalized blockmodeling, (Structural analysis in the social sciences, 25). Cambridge [etc.]: Cambridge University Press.
</p>
<p>Žiberna, A. (2007). Generalized Blockmodeling of Valued Networks. Social Networks, 29(1), 105-126. doi: 10.1016/j.socnet.2006.04.002
</p>
<p>Žiberna, A. (2008). Direct and indirect approaches to blockmodeling of valued networks in terms of regular equivalence. Journal of Mathematical Sociology, 32(1), 57-84. doi: 10.1080/00222500701790207
</p>
<p>Žiberna, A. (2014). Blockmodeling of multilevel networks. Social Networks, 39(1), 46-61. doi: 10.1016/j.socnet.2014.04.002
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optRandomParC">optRandomParC</a></code>, <code><a href="#topic+IM">IM</a></code>, <code><a href="#topic+clu">clu</a></code>, <code><a href="#topic+err">err</a></code>, <code><a href="#topic+plot.critFun">plot.critFun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating a simple network corresponding to the simple Sum of squares
# Structural equivalence with blockmodel:
# nul com
# nul nul
n &lt;- 20
net &lt;- matrix(NA, ncol = n, nrow = n)
clu &lt;- rep(1:2, times = c(5, 15))
tclu &lt;- table(clu)
net[clu == 1, clu == 1] &lt;- rnorm(n = tclu[1] * tclu[1], mean = 0, sd = 1)
net[clu == 1, clu == 2] &lt;- rnorm(n = tclu[1] * tclu[2], mean = 4, sd = 1)
net[clu == 2, clu == 1] &lt;- rnorm(n = tclu[2] * tclu[1], mean = 0, sd = 1)
net[clu == 2, clu == 2] &lt;- rnorm(n = tclu[2] * tclu[2], mean = 0, sd = 1)

# Computation of criterion function with the correct partition
res &lt;- critFunC(M = net, clu = clu, approaches = "hom", homFun = "ss", blocks = "com")
res$err # The error is relatively small
plot(res)

# Computation of criterion function with the correct partition and correct pre-specified blockmodel
# Prespecified blockmodel used
# nul com
# nul nul
B &lt;- array(NA, dim = c(1, 1, 2, 2))
B[1, 1, , ] &lt;- "nul"
B[1, 1, 1, 2] &lt;- "com"
B[1, 1, , ]
res &lt;- critFunC(M = net, clu = clu, approaches = "hom", homFun = "ss", blocks = B)
res$err # The error is relatively small
res$IM
plot(res)

# Computation of criterion function with the correct partition
# and pre-specified blockmodel with some alternatives
# Prespecified blockmodel used
# nul nul|com
# nul nul
B &lt;- array(NA, dim = c(2, 2, 2))
B[1, , ] &lt;- "nul"
B[2, 1, 2] &lt;- "com"
res &lt;- critFunC(M = net, clu = clu, approaches = "hom", homFun = "ss", blocks = B)
res$err # The error is relatively small
res$IM
plot(res)

# Computation of criterion function with random partition
set.seed(1)
clu.rnd &lt;- sample(1:2, size = n, replace = TRUE)
res.rnd &lt;- critFunC(M = net, clu = clu.rnd, approaches = "hom",
homFun = "ss", blocks = "com")
res.rnd$err # The error is larger
plot(res.rnd)

# Adapt network for Valued blockmodeling with the same model
net[net &gt; 4] &lt;- 4
net[net &lt; 0] &lt;- 0

# Computation of criterion function with the correct partition
res &lt;- critFunC(M = net, clu = clu, approaches = "val",
blocks = c("nul", "com"), preSpecM = 4)
res$err # The error is relatively small
res$IM
# The image corresponds to the one used for generation of
# The network
plot(res)

# Optimizing one partition
res &lt;- optParC(M = net, clu = clu.rnd,
   approaches = "hom", homFun = "ss", blocks = "com")
plot(res) # Hopefully we get the original partition

</code></pre>

<hr>
<h2 id='expandMat'>Expands a square matrix by repeating each row/column the specified number of times.</h2><span id='topic+expandMat'></span>

<h3>Description</h3>

<p>Expands a square matrix by repeating each row/column the specified number of times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandMat(mat, nn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expandMat_+3A_mat">mat</code></td>
<td>
<p>A square matrix to be exapanded</p>
</td></tr>
<tr><td><code id="expandMat_+3A_nn">nn</code></td>
<td>
<p>A vector of number of times each row/column must be repeated. Its length must match the number of rows/columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sum of squared deviations from the mean using only valid (non NA) values.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>

<hr>
<h2 id='find.cut'>Computing the threshold</h2><span id='topic+find.cut'></span><span id='topic+find.m'></span><span id='topic+find.m2'></span>

<h3>Description</h3>

<p>The functions compute the maximum  value of <code>m/cut</code> where a certain  block is still classified as <code>alt.blocks</code> and not &quot;null&quot;.
The difference between <code>find.m</code> and <code>find.m2</code> it that <code>find.m</code> uses an optimization  approach and is faster and more precise
than <code>find.m2</code>. However, <code>find.m</code> only supports regular (&quot;reg&quot;) and complete (&quot;com&quot;) as <code>alt.blocks</code>, while <code>find.m2</code> supports all block types.
Also, <code>find.m</code> does not always work, especially if <code>cormet</code> is not &quot;none&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.cut(M, clu, alt.blocks = "reg", cuts = "all", ...)

find.m(
  M,
  clu,
  alt.blocks = "reg",
  diag = !is.list(clu),
  cormet = "none",
  half = TRUE,
  FUN = "max"
)

find.m2(M, clu, alt.blocks = "reg", neval = 100, half = TRUE, ms = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.cut_+3A_m">M</code></td>
<td>
<p>A matrix representing the (usually valued) network. For now, only one-relational networks are supported.
The network can have one or more modes (different  kinds of units with no ties among themselves.
If the network is not two-mode, the matrix must be square.</p>
</td></tr>
<tr><td><code id="find.cut_+3A_clu">clu</code></td>
<td>
<p>A partition. Each unique value represents one cluster.
If the network  is one-mode, then this should be a vector, else a list of vectors, one for each mode.</p>
</td></tr>
<tr><td><code id="find.cut_+3A_alt.blocks">alt.blocks</code></td>
<td>
<p>Only one of allowed blocktypes, as alternative to the null block:<br />
&quot;com&quot; - complete block<br />
&quot;rdo&quot;, &quot;cdo&quot; - row and column-dominant blocks (binary, valued, and implicit approach only)<br />
&quot;reg&quot; - (f-)regular block<br />
&quot;rre&quot;, &quot;cre&quot; - row and column-(f-)regular blocks<br />
&quot;rfn&quot;, &quot;cfn&quot; - row and column-dominant blocks (binary, valued, and implicit approach only)<br />
&quot;den&quot; - density block (binary approach only)<br />
&quot;avg&quot; - average block (valued approach only).</p>
</td></tr>
<tr><td><code id="find.cut_+3A_cuts">cuts</code></td>
<td>
<p>The cuts, which should be evaluated. If <code>cuts="all"</code> (default), all unique values are evaluated.</p>
</td></tr>
<tr><td><code id="find.cut_+3A_...">...</code></td>
<td>
<p>Other parameters to <code>critFunC</code>.</p>
</td></tr>
<tr><td><code id="find.cut_+3A_diag">diag</code></td>
<td>
<p>(default = <code>TRUE</code>) Should the special status  of diagonal be acknowledged.</p>
</td></tr>
<tr><td><code id="find.cut_+3A_cormet">cormet</code></td>
<td>
<p>Which method should be used to correct for different maximum  error contributions<br />
&quot;none&quot; - no correction<br />
&quot;censor&quot; - censor values larger than <code>M</code><br />
&quot;correct&quot; -  so that the maximum  possible error contribution of the cell is the same regardless of a condition (either that something  must be 0 or at least <code>M</code>).</p>
</td></tr>
<tr><td><code id="find.cut_+3A_half">half</code></td>
<td>
<p>Should the returned value of m be one half of the value where the inconsistencies are the same.</p>
</td></tr>
<tr><td><code id="find.cut_+3A_fun">FUN</code></td>
<td>
<p>(default = &quot;max&quot;) Function f used in row-f-regular, column-f-regular, and f-regular blocks.</p>
</td></tr>
<tr><td><code id="find.cut_+3A_neval">neval</code></td>
<td>
<p>A number of different <code>m</code> values to be evaluated.</p>
</td></tr>
<tr><td><code id="find.cut_+3A_ms">ms</code></td>
<td>
<p>The values of m where the function should be evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of maximal <code>m/cut</code> values.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>References</h3>

<p>Doreian, P., Batagelj, V. &amp; Ferligoj, A. Anuška (2005). Generalized blockmodeling, (Structural analysis in the social sciences, 25). Cambridge [etc.]: Cambridge University Press.
</p>
<p>Žiberna, A. (2007). Generalized Blockmodeling of Valued Networks. Social Networks, 29(1), 105-126. doi: 10.1016/j.socnet.2006.04.002
</p>
<p>Žiberna, A. (2008). Direct and indirect approaches to blockmodeling of valued networks in terms of regular equivalence. Journal of Mathematical Sociology, 32(1), 57-84. doi: 10.1080/00222500701790207
</p>
<p>Žiberna, A. (2014). Blockmodeling of multilevel networks. Social Networks, 39(1), 46-61. doi: 10.1016/j.socnet.2014.04.002
</p>


<h3>See Also</h3>

<p><code><a href="#topic+critFunC">critFunC</a></code> and maybe also <code><a href="#topic+optParC">optParC</a></code>, <code><a href="#topic+plotMat">plotMat</a></code>
</p>

<hr>
<h2 id='formatA'>A formating function for numbers</h2><span id='topic+formatA'></span>

<h3>Description</h3>

<p>Formats a vector or matrix of numbers so that all have equal length (digits). This is especially suitable for printing tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatA(x, digits = 2, FUN = round, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatA_+3A_x">x</code></td>
<td>
<p>A numerical vector or matrix.</p>
</td></tr>
<tr><td><code id="formatA_+3A_digits">digits</code></td>
<td>
<p>The number of desired digits.</p>
</td></tr>
<tr><td><code id="formatA_+3A_fun">FUN</code></td>
<td>
<p>Function used for &quot;shortening&quot; the numbers.</p>
</td></tr>
<tr><td><code id="formatA_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>format</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find.m">find.m</a></code>, <code><a href="#topic+find.m2">find.m2</a></code>, <code><a href="#topic+find.cut">find.cut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(1, 1.02002, 0.2, 10.3), ncol = 2)
formatA(A)

</code></pre>

<hr>
<h2 id='funByBlocks.default'>Computation of function values by blocks</h2><span id='topic+funByBlocks.default'></span><span id='topic+funByBlocks.optMorePar'></span><span id='topic+funByBlocks.opt.more.par'></span><span id='topic+funByBlocks'></span><span id='topic+fun.by.blocks'></span>

<h3>Description</h3>

<p>Computes a value of a function over blocks of a matrix, defined by a partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
funByBlocks(
  x = M,
  clu,
  M = x,
  ignore.diag = "default",
  sortNames = TRUE,
  FUN = "mean",
  ...
)

## S3 method for class 'optMorePar'
funByBlocks(x, which = 1, orderClu = FALSE, sortNames = NULL, ...)

## S3 method for class 'opt.more.par'
funByBlocks(x, which = 1, orderClu = FALSE, sortNames = NULL, ...)

funByBlocks(x, ...)

fun.by.blocks(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funByBlocks.default_+3A_x">x</code></td>
<td>
<p>An object of suitable class or a matrix/array representing the (usually valued) network. For multi-relational networks, this should be an array with the third dimension representing the relation.
The network can have one or more modes (different kinds of units with no ties among themselves.
If the network is not two-mode, the matrix must be square.</p>
</td></tr>
<tr><td><code id="funByBlocks.default_+3A_clu">clu</code></td>
<td>
<p>A partition. Each unique value represents one cluster.
If the network is one-mode, then this should be a vector, else a list of vectors, one for each mode.</p>
</td></tr>
<tr><td><code id="funByBlocks.default_+3A_m">M</code></td>
<td>
<p>A matrix representing the (usually valued) network. For multi-relational networks, this should be an array with the third dimension representing the relation.
The network can have one or more modes (different  kinds of units with no ties among themselves.
If the network is not two-mode, the matrix must be square.</p>
</td></tr>
<tr><td><code id="funByBlocks.default_+3A_ignore.diag">ignore.diag</code></td>
<td>
<p>Should the diagonal be ignored.</p>
</td></tr>
<tr><td><code id="funByBlocks.default_+3A_sortnames">sortNames</code></td>
<td>
<p>Should the rows and columns of the matrix be sorted based on their names.</p>
</td></tr>
<tr><td><code id="funByBlocks.default_+3A_fun">FUN</code></td>
<td>
<p>The function to be computed over the blocks.</p>
</td></tr>
<tr><td><code id="funByBlocks.default_+3A_...">...</code></td>
<td>
<p>Further arguments to <code>funByBlocks.default</code>.</p>
</td></tr>
<tr><td><code id="funByBlocks.default_+3A_which">which</code></td>
<td>
<p>Which (if several) of the &quot;best&quot; solutions should be used.</p>
</td></tr>
<tr><td><code id="funByBlocks.default_+3A_orderclu">orderClu</code></td>
<td>
<p>Should the partition be ordered before computing. <code>FALSE</code> by default. If <code>TRUE</code>, <code><a href="#topic+orderClu">orderClu</a></code> is used (using default arguments) to order the clusters in a partition in &quot;decearsing&quot; (see <code><a href="#topic+orderClu">orderClu</a></code> for interpretation) order.  If <code>TRUE</code>, <code>sortNames</code> is set to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical matrix of <code>FUN</code> values by blocks, induced by a partition <code>clu</code>.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>References</h3>

<p>Žiberna, A. (2007). Generalized Blockmodeling of Valued Networks. Social Networks, 29(1), 105-126. doi: 10.1016/j.socnet.2006.04.002
</p>
<p>Žiberna, A. (2008). Direct and indirect approaches to blockmodeling of valued networks in terms of regular equivalence. Journal of Mathematical Sociology, 32(1), 57-84. doi: 10.1080/00222500701790207
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optRandomParC">optRandomParC</a></code>, <code><a href="#topic+optParC">optParC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 8 # If larger, the number of partitions increases dramatically,
# as does if we increase the number of clusters
net &lt;- matrix(NA, ncol = n, nrow = n)
clu &lt;- rep(1:2, times = c(3, 5))
tclu &lt;- table(clu)
net[clu == 1, clu == 1] &lt;- rnorm(n = tclu[1] * tclu[1], mean = 0, sd = 1)
net[clu == 1, clu == 2] &lt;- rnorm(n = tclu[1] * tclu[2], mean = 4, sd = 1)
net[clu == 2, clu == 1] &lt;- rnorm(n = tclu[2] * tclu[1], mean = 0, sd = 1)
net[clu == 2, clu == 2] &lt;- rnorm(n = tclu[2] * tclu[2], mean = 0, sd = 1)
# Optimizing 10 random partitions with optRandomParC
res &lt;- optRandomParC(M = net, k = 2, rep = 10, approaches = "hom", homFun = "ss", blocks = "com")
plot(res) # Hopefully we get the original partition
funByBlocks(res)
# Computing mean by blocks, ignoring the diagonal (default)

</code></pre>

<hr>
<h2 id='genMatrixMult'>Generalized matrix multiplication</h2><span id='topic+genMatrixMult'></span>

<h3>Description</h3>

<p>Computes a generalized matrix multiplication, where sum and product functions (elemet-wise and summary functions) can be replaced by arbitrary functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genMatrixMult(A, B, FUNelement = "*", FUNsummary = sum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genMatrixMult_+3A_a">A</code></td>
<td>
<p>The first matrix.</p>
</td></tr>
<tr><td><code id="genMatrixMult_+3A_b">B</code></td>
<td>
<p>The second matrix.</p>
</td></tr>
<tr><td><code id="genMatrixMult_+3A_funelement">FUNelement</code></td>
<td>
<p>Element-wise operator.</p>
</td></tr>
<tr><td><code id="genMatrixMult_+3A_funsummary">FUNsummary</code></td>
<td>
<p>Summary function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+matmult">matmult</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Operations can be anything
x &lt;- matrix(letters[1:8], ncol = 2)
y &lt;- matrix(1:10, nrow = 2)

genMatrixMult(x, y, FUNelement = paste,
FUNsummary = function(x) paste(x, collapse = "|"))

# Binary logic
set.seed(1)
x &lt;- matrix(rbinom(8, size = 1, prob = 0.5) == 1, ncol = 2)
y &lt;- matrix(rbinom(10, size = 1, prob = 0.5) == 1, nrow = 2)
genMatrixMult(x, y, FUNelement = "*", FUNsummary = any)

</code></pre>

<hr>
<h2 id='genRandomPar'>The function for generating random partitions</h2><span id='topic+genRandomPar'></span>

<h3>Description</h3>

<p>The function generates random partitions. The function is meant to be called by the function <code><a href="#topic+optRandomParC">optRandomParC</a>.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genRandomPar(
  k,
  n,
  seed = NULL,
  mingr = 1,
  maxgr = Inf,
  addParam = list(genPajekPar = TRUE, probGenMech = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genRandomPar_+3A_k">k</code></td>
<td>
<p>Number of clusters (by modes).</p>
</td></tr>
<tr><td><code id="genRandomPar_+3A_n">n</code></td>
<td>
<p>Number of units (by modes).</p>
</td></tr>
<tr><td><code id="genRandomPar_+3A_seed">seed</code></td>
<td>
<p>Seed for generating random numbers (partitions).</p>
</td></tr>
<tr><td><code id="genRandomPar_+3A_mingr">mingr</code></td>
<td>
<p>Minimal allowed group size.</p>
</td></tr>
<tr><td><code id="genRandomPar_+3A_maxgr">maxgr</code></td>
<td>
<p>Maximal allowed group size.</p>
</td></tr>
<tr><td><code id="genRandomPar_+3A_addparam">addParam</code></td>
<td>
<p>This has to be a list with the following parameters (any or all can be missing, then the default values (see usage) are used):<br />
&quot;genPajekPar&quot; - Should the partitions be generated as in Pajek (Batagelj &amp; Mrvar, 2006). If <code>FALSE</code>, all partitions are selected completely at random while making sure that the partitions have the required number of clusters. <br />
<code>probGenMech</code> - Here the probabilities for 4 different generating mechanisms can be specified. If this is not specified, the value is set to <code>c(1/3, 1/3, 1/3, 0)</code> if <code>genPajekPar</code> is <code>TRUE</code> and to <code>c(0, 0, 0, 1)</code> if <code>genPajekPar</code> is <code>FALSE</code>. The first 3 mechanisms are the same as implemented in Pajek (the second one has almost all units in only one cluster) and the fourth is completely random (from uniform distribution).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A random partition in the format required by <code><a href="#topic+optRandomParC">optRandomParC</a></code>. If a network has several modes, then a list of partitions, one for each mode.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>References</h3>

<p>Batagelj, V., &amp; Mrvar, A. (2006). Pajek 1.11. Retrieved from http://vlado.fmf.uni-lj.si/pub/networks/pajek/
</p>

<hr>
<h2 id='gplot1'>A wrapper for function  gplot - Two-Dimensional Visualization of Graphs</h2><span id='topic+gplot1'></span><span id='topic+gplot2'></span>

<h3>Description</h3>

<p>The function calls function <code>gplot</code> from the library <code>sna</code> with different defaults. Use fun for plotting image graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gplot1(
  M,
  diag = TRUE,
  displaylabels = TRUE,
  boxed.labels = FALSE,
  loop.cex = 4,
  edge.lwd = 1,
  edge.col = "default",
  rel.thresh = 0.05,
  ...
)

gplot2(
  M,
  uselen = TRUE,
  usecurve = TRUE,
  edge.len = 0.001,
  diag = TRUE,
  displaylabels = TRUE,
  boxed.labels = FALSE,
  loop.cex = 4,
  arrowhead.cex = 2.5,
  edge.lwd = 1,
  edge.col = "default",
  rel.thresh = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gplot1_+3A_m">M</code></td>
<td>
<p>A matrix (array) of a graph or set thereof.  This data may be valued.</p>
</td></tr>
<tr><td><code id="gplot1_+3A_diag">diag</code></td>
<td>
<p>Boolean indicating whether or not the diagonal should be treated as valid data
Set this <code>TRUE</code> if and only if the data can contain loops.  <code>diag</code> is <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="gplot1_+3A_displaylabels">displaylabels</code></td>
<td>
<p>Boolean; should vertex labels be displayed.</p>
</td></tr>
<tr><td><code id="gplot1_+3A_boxed.labels">boxed.labels</code></td>
<td>
<p>Boolean; place vertex labels within boxes.</p>
</td></tr>
<tr><td><code id="gplot1_+3A_loop.cex">loop.cex</code></td>
<td>
<p>An expansion factor for loops; may be given as a vector, if loops are to be of different sizes.</p>
</td></tr>
<tr><td><code id="gplot1_+3A_edge.lwd">edge.lwd</code></td>
<td>
<p>Line width scale for edges; if set greater than 0, edge widths are scaled by <code>edge.lwd*dat</code>.
May be given as a vector or adjacency matrix, if edges are to have different line widths.</p>
</td></tr>
<tr><td><code id="gplot1_+3A_edge.col">edge.col</code></td>
<td>
<p>Color for edges; may be given as a vector or adjacency matrix, if edges are to be of different colors.</p>
</td></tr>
<tr><td><code id="gplot1_+3A_rel.thresh">rel.thresh</code></td>
<td>
<p>Real number indicating the lower relative (compared to the highest value) threshold for tie values.
Only ties of value <code>thresh</code> are displayed.  By default, <code>thresh = 0</code>.</p>
</td></tr>
<tr><td><code id="gplot1_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="graphics.html#topic+plot">plot</a></code> or <code>link{sna::gplot}</code>:<br /><br />
<b><code>mode</code></b>:  the vertex placement algorithm; this must correspond to a <code>gplot.layout</code> function from package <code>sna</code>.</p>
</td></tr>
<tr><td><code id="gplot1_+3A_uselen">uselen</code></td>
<td>
<p>Boolean; should we use <code>edge.len</code> to rescale edge lengths.</p>
</td></tr>
<tr><td><code id="gplot1_+3A_usecurve">usecurve</code></td>
<td>
<p>Boolean; should we use <code>edge.curve</code>.</p>
</td></tr>
<tr><td><code id="gplot1_+3A_edge.len">edge.len</code></td>
<td>
<p>If <code>uselen == TRUE</code>, curved edge lengths are scaled by <code>edge.len</code>.</p>
</td></tr>
<tr><td><code id="gplot1_+3A_arrowhead.cex">arrowhead.cex</code></td>
<td>
<p>An expansion factor for edge arrowheads.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots a graph.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>See Also</h3>

<p><code>link{sna::gplot}</code>
</p>

<hr>
<h2 id='ircNorm'>Function for iterated row and column normalization of valued matrices</h2><span id='topic+ircNorm'></span>

<h3>Description</h3>

<p>The aim is to obtain a matrix with row and column sums equal to 1.
This is achieved by iterating row and column normalization. This is usually not possible if any row or column has only 1 non-zero cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ircNorm(M, eps = 10^-12, maxiter = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ircNorm_+3A_m">M</code></td>
<td>
<p>A non-negative valued matrix to be normalized.</p>
</td></tr>
<tr><td><code id="ircNorm_+3A_eps">eps</code></td>
<td>
<p>The maximum allows squared deviation of a row or column's maximum from 1 (if not exactly 0).
Also, if the all deviations in two consequtive iterations are smaller, the process is terminated.</p>
</td></tr>
<tr><td><code id="ircNorm_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations. If reached, the process is terminated and the current solution returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Normalized matrix.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(runif(100), ncol = 10)
A # A non-normalized matrix with different row and column sums.
apply(A, 1, sum)
apply(A, 2, sum)
A.norm &lt;- ircNorm(A)
A.norm # Normalized matrix with all row and column sums approximately 1.
apply(A.norm, 1, sum)
apply(A.norm, 2, sum)

</code></pre>

<hr>
<h2 id='loadmatrix'>Functions for loading and writing Pajek files</h2><span id='topic+loadmatrix'></span><span id='topic+Pajek'></span><span id='topic+loadnetwork'></span><span id='topic+loadnetwork2'></span><span id='topic+loadnetwork3'></span><span id='topic+loadnetwork4'></span><span id='topic+savevector'></span><span id='topic+savenetwork'></span><span id='topic+savematrix'></span><span id='topic+loadvector'></span><span id='topic+loadvector2'></span><span id='topic+loadpajek'></span>

<h3>Description</h3>

<p><code>loadmatrix</code> - Loads a Pajek &quot;.mat&quot; filename as a matrix.
</p>
<p>Functions for reading/loading and writing Pajek files:
</p>
<p><code>loadnetwork</code> - Loads a Pajek &quot;.net&quot; filename as a matrix. For now, only simple one and two-mode networks are supported (eg. only single relations, no time information).
</p>
<p><code>loadnetwork2</code> - The same as above, but adapted to be called within <code>loadpajek</code>.
</p>
<p><code>loadnetwork3</code> - Another version for reading networks.
</p>
<p><code>loadnetwork4</code> - Another version for reading networks.
</p>
<p><code>loadpajek</code> - Loads a Pajek project file name (&quot;.paj&quot;) as a list with the following components: Networks, Partitions, Vectors and Clusters. Clusters and hierarchies are dismissed.
</p>
<p><code>loadvector</code> - Loads a Pajek &quot;.clu&quot; filename as a vector.
</p>
<p><code>loadvector2</code> - The same as above, but adapted to be called within <code>loadpajek</code> - as a consequence not suited for reading clusters.
</p>
<p><code>savematrix</code> - Saves a matrix into a  Pajek &quot;.mat&quot; filename.
</p>
<p><code>savenetwork</code> - Saves a matrix into a  Pajek &quot;.net&quot; filename.
</p>
<p><code>savevector</code> - Saves a vector into a  Pajek &quot;.clu&quot; filename.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadmatrix(filename)

loadnetwork(filename, useSparseMatrix = NULL, minN = 50)

loadnetwork2(
  filename,
  useSparseMatrix = NULL,
  minN = 50,
  safe = TRUE,
  closeFile = TRUE
)

loadnetwork3(filename, useSparseMatrix = NULL, minN = 50)

loadnetwork4(filename, useSparseMatrix = NULL, minN = 50, fill = FALSE)

loadpajek(filename)

loadvector(filename)

loadvector2(filename)

savematrix(n, filename, twomode = 1)

savenetwork(n, filename, twomode = "default", symetric = NULL)

savevector(v, filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadmatrix_+3A_filename">filename</code></td>
<td>
<p>The name of the file to be loaded or saved to or an open file object.</p>
</td></tr>
<tr><td><code id="loadmatrix_+3A_usesparsematrix">useSparseMatrix</code></td>
<td>
<p>Should a sparse matrix be use instead of the ordinary one? Sparse matrices can only be used if package Matrix is installed. The default <code>NULL</code> uses sparse matrices  for networks with more that <code>minN</code> vertices.</p>
</td></tr>
<tr><td><code id="loadmatrix_+3A_minn">minN</code></td>
<td>
<p>The minimal number of units in the network to use sparse matrices.</p>
</td></tr>
<tr><td><code id="loadmatrix_+3A_safe">safe</code></td>
<td>
<p>If <code>FALSE</code> error will occur if not all vertices have labels. If <code>TRUE</code> reading works faster.</p>
</td></tr>
<tr><td><code id="loadmatrix_+3A_closefile">closeFile</code></td>
<td>
<p>Should the connection be closed at the end. Should be always <code>TRUE</code> if function is used directly.</p>
</td></tr>
<tr><td><code id="loadmatrix_+3A_fill">fill</code></td>
<td>
<p>If <code>TRUE</code>, then in case the rows have unequal length, blank fields are added.</p>
</td></tr>
<tr><td><code id="loadmatrix_+3A_n">n</code></td>
<td>
<p>A matrix representing the network.</p>
</td></tr>
<tr><td><code id="loadmatrix_+3A_twomode">twomode</code></td>
<td>
<p>1 for one-mode networks and 2 for two-mode networks. Default sets the argument to 1 for square matrices and to 2 for others.</p>
</td></tr>
<tr><td><code id="loadmatrix_+3A_symetric">symetric</code></td>
<td>
<p>If <code>TRUE</code>, only the lower part of the matrix is used and the values are interpreted as &quot;Edges&quot;, not &quot;Arcs&quot;.</p>
</td></tr>
<tr><td><code id="loadmatrix_+3A_v">v</code></td>
<td>
<p>A vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL, a matrix or a vector.
</p>


<h3>Author(s)</h3>

<p>Vladimir Batagelj &amp; Andrej Mrvar (most functions), Aleš Žiberna (<code>loadnetwork</code>, <code>loadpajek</code> and modification of others)
</p>


<h3>References</h3>

<p>Batagelj, V., &amp; Mrvar. A. (1999). Pajek - Program for Large Network Analysis. Retrieved from http://vlado.fmf.uni-lj.si/pub/networks/pajek/.
</p>
<p>de Nooy, W., Mrvar, A., &amp; Batagelj. V. (2005). Exploratory Social Network Analysis with Pajek. London: SAGE Publications.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.mat">plot.mat</a></code>, <code><a href="#topic+critFunC">critFunC</a></code>, <code><a href="#topic+optRandomParC">optRandomParC</a></code>
</p>

<hr>
<h2 id='nanRep'>Replaces NaN values by the speficied values (0 by default)</h2><span id='topic+nanRep'></span>

<h3>Description</h3>

<p>Replaces NaN values by the speficied values (0 by default)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nanRep(x, rep = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nanRep_+3A_x">x</code></td>
<td>
<p>A vector or similar where the NaNs are to be replaced.</p>
</td></tr>
<tr><td><code id="nanRep_+3A_rep">rep</code></td>
<td>
<p>A value that should replace the NaNs (0 by default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x with NaNs replaced by rep.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>

<hr>
<h2 id='nkpar'>Functions for listing all possible partitions or just counting the number of them</h2><span id='topic+nkpar'></span><span id='topic+nkpartitions'></span>

<h3>Description</h3>

<p>The function <code>nkpartitions</code> lists all possible partitions of n objects in to k clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nkpar(n, k)

nkpartitions(n, k, exact = TRUE, print = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nkpar_+3A_n">n</code></td>
<td>
<p>Number of units/objects.</p>
</td></tr>
<tr><td><code id="nkpar_+3A_k">k</code></td>
<td>
<p>Number of clusters/groups.</p>
</td></tr>
<tr><td><code id="nkpar_+3A_exact">exact</code></td>
<td>
<p>Search for partitions with exactly <code>k</code> or at most <code>k</code> clusters.</p>
</td></tr>
<tr><td><code id="nkpar_+3A_print">print</code></td>
<td>
<p>Print results as they are found.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix or number of possible partitions.
</p>


<h3>Author(s)</h3>

<p>Chris Andrews
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 8 # If larger, the number of partitions increases dramatically,
# as does if we increase the number of clusters
net &lt;- matrix(NA, ncol = n, nrow = n)
clu &lt;- rep(1:2, times = c(3, 5))
tclu &lt;- table(clu)
net[clu == 1, clu == 1] &lt;- rnorm(n = tclu[1] * tclu[1], mean = 0, sd = 1)
net[clu == 1, clu == 2] &lt;- rnorm(n = tclu[1] * tclu[2], mean = 4, sd = 1)
net[clu == 2, clu == 1] &lt;- rnorm(n = tclu[2] * tclu[1], mean = 0, sd = 1)
net[clu == 2, clu == 2] &lt;- rnorm(n = tclu[2] * tclu[2], mean = 0, sd = 1)
# Computation of criterion function with the correct partition
nkpar(n = n, k = length(tclu)) # Computing the number of partitions
all.par &lt;- nkpartitions(n = n, k = length(tclu)) # Forming the partitions
all.par &lt;- lapply(apply(all.par, 1, list), function(x) x[[1]])
# to make a list out of the matrix
res &lt;- critFunC(M = net, clu = clu, approaches = "val",
                blocks = c("nul", "com"), preSpecM = 4)
plot(res) # We get the original partition

</code></pre>

<hr>
<h2 id='notesBorrowing'>The notes borrowing network between social-informatics students</h2><span id='topic+notesBorrowing'></span>

<h3>Description</h3>

<p>The data come from a survey conducted in May 1993 on 13 social-informatics students (Hlebec, 1996).
The network was constructed from answers to the question, &quot;How often did you borrow notes from this person?&quot; for each of the fellow students.
The respondents indicated the frequency of borrowing by choosing (on a computer) a line of length 1-20, where 1 meant no borrowing. 1 was deducted from all answers, so that 0 now means no borrowing.
The data was first used for blockmodeling in Žiberna (2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("notesBorrowing")
</code></pre>


<h3>Format</h3>

<p>The data set is a valued matrix with 13 rows and columns.
</p>


<h3>References</h3>

<p>Hlebec, V., (1996). <em>Metodološke značilnosti anketnega zbiranja podatkov v analizi omrežji: Magistersko delo</em>. FDV, Ljubljana.
</p>
<p>Žiberna, A. (2007). Generalized blockmodeling of valued networks. <em>Social Networks</em>, 29, 105-126. https://doi.org/10.1016/j.socnet.2006.04.002
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(notesBorrowing)

# Plot the network.
# (The function plotMat is from blockmodeling package.)
# plotMat(nyt)

</code></pre>

<hr>
<h2 id='one2two'>Two-mode network conversions</h2><span id='topic+one2two'></span><span id='topic+two2one'></span>

<h3>Description</h3>

<p>Converting  two mode networks from two to one mode matrix representation and vice versa.
If a two-mode matrix is converted into a one-mode matrix, the original two-mode matrix lies in the upper right corner of the one-mode matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one2two(M, clu = NULL)

two2one(M, clu = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="one2two_+3A_m">M</code></td>
<td>
<p>A matrix representing the (usually valued) network.</p>
</td></tr>
<tr><td><code id="one2two_+3A_clu">clu</code></td>
<td>
<p>A partition. Each unique value represents one cluster. This should be a list of two vectors, one for each mode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns list with the elements:
a two mode matrix of a the two mode network in its upper left corner.
</p>
<table>
<tr><td><code>M</code></td>
<td>
<p>The matrix.</p>
</td></tr>
<tr><td><code>clu</code></td>
<td>
<p>The partition, in form appropriate for the mode of the matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optParC">optParC</a></code>, <code><a href="#topic+optParC">optParC</a></code>, <code><a href="#topic+optRandomParC">optRandomParC</a></code>, <code><a href="#topic+plot.mat">plot.mat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating a simple network corresponding to the simple Sum of squares
# Structural equivalence with blockmodel:
# null com
# null null
n &lt;- c(7, 13)
net &lt;- matrix(NA, nrow = n[1], ncol = n[2])
clu &lt;- list(rep(1:2, times = c(3, 4)), rep(1:2, times = c(5, 8)))
tclu &lt;- lapply(clu, table)
net[clu[[1]] == 1, clu[[2]] == 1] &lt;- rnorm(n = tclu[[1]][1] * tclu[[2]][1],
   mean = 0, sd = 1)
net[clu[[1]] == 1, clu[[2]] == 2] &lt;- rnorm(n = tclu[[1]][1] * tclu[[2]][2],
   mean = 4, sd = 1)
net[clu[[1]] == 2, clu[[2]] == 1] &lt;- rnorm(n = tclu[[1]][2] * tclu[[2]][1],
   mean = 4, sd = 1)
net[clu[[1]] == 2, clu[[2]] == 2] &lt;- rnorm(n = tclu[[1]][2] * tclu[[2]][2],
   mean = 0, sd = 1)
plot.mat(net, clu = clu) # Two mode matrix of a two mode network

# Converting to one mode network
M1 &lt;- two2one(net)$M
plot.mat(M1, clu = two2one(net)$clu) # Plotting one mode matrix
# Converting one to two mode matrix and plotting
plot.mat(one2two(M1, clu = clu)$M, clu = clu)

</code></pre>

<hr>
<h2 id='optRandomParC'>Optimizing a set of partitions based on the value of a criterion function</h2><span id='topic+optRandomParC'></span><span id='topic+print.optMorePar'></span>

<h3>Description</h3>

<p>The function optimizes a set of partitions based on the value of a criterion function  (see <code><a href="#topic+critFunC">critFunC</a></code> for details on the criterion function) for a given network and blockmodel for Generalized blockmodeling (Žiberna, 2007) based on other parameters (see below).
The optimization is done through local optimization, where the neighborhood of a partition includes all partitions that can be obtained by moving one unit from one cluster to another or by exchanging two units (from different clusters).
The number of clusters and a number of partitions to generate can be specified (<code>optParC</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optRandomParC(
  M,
  k,
  approaches,
  blocks,
  rep,
  save.initial.param = TRUE,
  save.initial.param.opt = FALSE,
  deleteMs = TRUE,
  max.iden = 10,
  switch.names = NULL,
  return.all = FALSE,
  return.err = TRUE,
  seed = NULL,
  RandomSeed = NULL,
  parGenFun = genRandomPar,
  mingr = NULL,
  maxgr = NULL,
  addParam = list(genPajekPar = TRUE, probGenMech = NULL),
  maxTriesToFindNewPar = rep * 10,
  skip.par = NULL,
  useOptParMultiC = FALSE,
  useMulti = useOptParMultiC,
  printRep = ifelse(rep &lt;= 10, 1, round(rep/10)),
  n = NULL,
  nCores = 1,
  useParLapply = FALSE,
  useLB = NULL,
  chunk.size = 1,
  cl = NULL,
  stopcl = is.null(cl),
  useRegParrallaBackend = FALSE,
  ...
)

## S3 method for class 'optMorePar'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optRandomParC_+3A_m">M</code></td>
<td>
<p>A matrix representing the (usually valued) network. For multi-relational networks, this should be an array with the third dimension representing the relation. The network can have one or more modes (diferent kinds of units with no ties among themselves). If the network is not two-mode, the matrix must be square.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_k">k</code></td>
<td>
<p>The number of clusters used in the generation of partitions.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_approaches">approaches</code></td>
<td>
<p>One of the approaches (for each relation in multi-relational netowrks in a vector) described in Žiberna (2007). Possible values are:<br />
&quot;bin&quot; - binary blockmodeling,<br />
&quot;val&quot; - valued blockmodeling,<br />
&quot;hom&quot; - homogeneity blockmodeling,<br />
&quot;ss&quot; - sum of squares homogeneity blockmodeling, and<br />
&quot;ad&quot; - absolute deviations homogeneity blockmodeling.<br />
<br />
The last two options are &quot;shorthand&quot; for specifying <code>approaches="hom"</code> and  <code>homFun</code> to either <code>"ss"</code> or  <code>"ad"</code>.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_blocks">blocks</code></td>
<td>
<p>A vector, a list of vectors or an array with names of allowed blocy types. <br />
<br />
Only listing of allowed block types (blockmodel is not pre-specified).<br />
A vector with names of allowed block types. For multi-relational networks, it can be a list of such vectors. For <code>approaches = "bin"</code> or <code>approaches = "val"</code>, at least two should be selected. Possible values are:<br />
<code>"nul"</code> - null or empty block<br />
<code>"com"</code> - complete block<br />
<code>"rdo"</code>, <code>"cdo"</code> - row and column-dominant blocks (binary and valued approach only)<br />
<code>"reg"</code> - (f-)regular block<br />
<code>"rre"</code>, <code>"cre"</code> - row and column-(f-)regular blocks<br />
<code>"rfn"</code>, <code>"cfn"</code> - row and column-dominant blocks (binary, valued only)<br />
<code>"den"</code> - density block (binary approach only)<br />
<code>"avg"</code> - average block (valued approach only)<br />
<code>"dnc"</code> - do not care block - the error is always zero<br />
The ordering is important, since if several block types have identical error, the first on the list is selected.<br /><br />
A pre-specified blockmodel.<br />
An array with four dimensions (see example below). The third and the fourth represent the clusters (for rows and columns). The first is as long as the maximum number of allows block types for a given block. If some block has less possible block types, the empty slots should have values <code>NA</code>. The second dimension is the number of relations (1 for single-relational networks). The values in the array should be the ones from above. The array can have only three dimensions in case of one-relational networks or if the same pre-specified blockmodel is assumed for all relations. Further, it can have only two dimensions, if in addition only one block type is allowed per block.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_rep">rep</code></td>
<td>
<p>The number of repetitions/different starting partitions to check.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_save.initial.param">save.initial.param</code></td>
<td>
<p>Should the inital parameters (<code>approaches</code>, ...) be saved. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_save.initial.param.opt">save.initial.param.opt</code></td>
<td>
<p>Should the inital parameters(<code>approaches</code>, ...) of using <code>optParC</code> be saved. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_deletems">deleteMs</code></td>
<td>
<p>Delete networks/matrices from the results of to save space.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_max.iden">max.iden</code></td>
<td>
<p>Maximum number of results that should be saved (in case there are more than <code>max.iden</code> results with minimal error, only the first <code>max.iden</code> will be saved).</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_switch.names">switch.names</code></td>
<td>
<p>Should partitions that only differ in group names be considered equal. By default it is set to <code>TRUE</code> if <code>blocks</code> is either a vector or a list of vectors and to <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_return.all">return.all</code></td>
<td>
<p>If <code>FALSE</code>, solution for only the best (one or more) partition/s is/are returned.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_return.err">return.err</code></td>
<td>
<p>Should the error for each optimized partition be returned.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_seed">seed</code></td>
<td>
<p>Optional. The seed for random generation of partitions.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_randomseed">RandomSeed</code></td>
<td>
<p>Optional. Integer vector, containing the random number generator. It is only looked for in the user's workspace.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_pargenfun">parGenFun</code></td>
<td>
<p>The function (object) that will generate random partitions. The default function is   <code><a href="#topic+genRandomPar">genRandomPar</a></code>. The function has to accept the following parameters: <code>k</code> (number o of partitions by modes, <code>n</code> (number of units by modes), <code>seed</code> (seed value for random generation of partition), <code>addParam</code> (a list of additional parameters).</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_mingr">mingr</code></td>
<td>
<p>Minimal allowed group size.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_maxgr">maxgr</code></td>
<td>
<p>Maximal allowed group size.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_addparam">addParam</code></td>
<td>
<p>A list of additional parameters for function specified above. In the usage section they are specified for the default function <code><a href="#topic+genRandomPar">genRandomPar</a></code>.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_maxtriestofindnewpar">maxTriesToFindNewPar</code></td>
<td>
<p>The maximum number of partition try when trying to find a new partition to optimize that was not yet checked before - the default value is <code>rep * 1000</code>.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_skip.par">skip.par</code></td>
<td>
<p>The partitions that are not allowed or were already checked and should therefore be skipped.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_useoptparmultic">useOptParMultiC</code></td>
<td>
<p>For backward compatibility. May be removed soon. See next argument.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_usemulti">useMulti</code></td>
<td>
<p>Which version of local search should be used. Default is currently <code>FALSE</code>. If <code>FALSE</code>, first possible all moves in random order and then all possible exchanges in random order are tried. When a move with lower value of criterion function is found, the algorithm moves to this new partition. If <code>TRUE</code> the version of local search where all possible moves and exchanges are tried first and then the one with the lowest error is selected and used. In this case, several optimal partitions are found. <code>maxPar</code> best partitions are returned.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_printrep">printRep</code></td>
<td>
<p>Should some information about each optimization be printed.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_n">n</code></td>
<td>
<p>The number of units by &quot;modes&quot;. It is used only for generating random partitions. It has to be set only if there are more than two modes or if there are two modes, but the matrix representing the network is one mode (both modes are in rows and columns).</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_ncores">nCores</code></td>
<td>
<p>Number of cores to be used. Value <code>0</code> means all available cores. It can also be a cluster object.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_useparlapply">useParLapply</code></td>
<td>
<p>Should <code>parLapplyLB</code> or <code>parLapply</code> (see <code>useLB</code>) be used for parallel execution (on multiple cores). Otherwise <code>mforeach</code> is used. Defaults to FALSE. If <code>useParLapply = TRUE</code> and <code>useLB = TRUE</code>, results are not reproducible.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_uselb">useLB</code></td>
<td>
<p>Should be logical if set. Only used if <code>useParLapply = TRUE</code>. Should load balancing be used (<code>parLapplyLB</code> instead of <code>parLapply</code>). Using load balancing usually means faster execution, but results are with not reproducible. Defaults to <code>NULL</code>, which is changed to <code>TRUE</code>, but a warning.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_chunk.size">chunk.size</code></td>
<td>
<p>chunk.size used in <code>parLapplyLB</code> if it is used, otherwise ignored. Defaults to 1.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_cl">cl</code></td>
<td>
<p>The cluster to use (if formed beforehand). Defaults to <code>NULL</code>. Ignored if useParLapply=FALSE (default) and foreach::getDoParRegistered is true</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_stopcl">stopcl</code></td>
<td>
<p>Should the cluster be stoped after the function finishes. Defaults to <code>is.null(cl)</code>.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_useregparrallabackend">useRegParrallaBackend</code></td>
<td>
<p>Should the function use already registered parallel backend. Defaults to <code>FALSE</code>. If <code>TRUE</code>, you must make sure that an appropriate backend is correctly set up and registered. Use only if <code>useParLapply = FALSE</code> (default) and <code>nCore</code> is not 1.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_...">...</code></td>
<td>
<p>Arguments passed to other functions, see <code><a href="#topic+critFunC">critFunC</a></code>.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_x">x</code></td>
<td>
<p>The result of <code><a href="#topic+optRandomParC">optRandomParC</a></code>.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_genpajekpar">genPajekPar</code></td>
<td>
<p>Should the partitions be generated as in Pajek.</p>
</td></tr>
<tr><td><code id="optRandomParC_+3A_probgenmech">probGenMech</code></td>
<td>
<p>Should the probabilities for different mechanisms for specifying the partitions be set. If <code>probGenMech</code> is not set, it is determined based on the parameter <code>genPajekPar</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>M</code></td>
<td>
<p>The matrix of the network analyzed.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>If <code>return.all = TRUE</code> - A list of results the same as <code>best</code> - one <code>best</code> for each partition optimized.</p>
</td></tr>
<tr><td><code>best</code></td>
<td>
<p>A list of results from <code>optParC</code>, only without <code>M</code>.</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>If <code>return.err = TRUE</code> - The vector of errors or inconsistencies of the empirical  network with the ideal network for a given blockmodel (model,approach,...) and parititions.</p>
</td></tr>
<tr><td><code>nIter</code></td>
<td>
<p>The vector of the number of iterations used - one value for each starting partition that was optimized. It can show that <code>maxiter</code> is too low if a lot of these values have the value of <code>maxiter</code>.</p>
</td></tr>
<tr><td><code>checked.par</code></td>
<td>
<p>If selected - A list of checked partitions. If <code>merge.save.skip.par</code> is <code>TRUE</code>, this list also includes the partitions in <code>skip.par</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call used to call the function.</p>
</td></tr>
<tr><td><code>initial.param</code></td>
<td>
<p>If selected - The initial parameters are used.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>It should be noted that the time complexity of package blockmodeling is increasing with
the number of units and the number of clusters (due to its algorithm). Therefore the analysis
of network with more than 100 units can take a lot of time (from a few hours to a few days).
</p>


<h3>Author(s)</h3>

<p>Aleš, Žiberna
</p>


<h3>References</h3>

<p>Batagelj, V., &amp; Mrvar, A. (2006). Pajek 1.11. Retrieved from http://vlado.fmf.uni-lj.si/pub/networks/pajek/
</p>
<p>Doreian, P., Batagelj, V. &amp; Ferligoj, A. (2005). Generalized blockmodeling, (Structural analysis in the social sciences, 25). Cambridge [etc.]: Cambridge University Press.
</p>
<p>Žiberna, A. (2007). Generalized Blockmodeling of Valued Networks. Social Networks, 29(1), 105-126. doi: 10.1016/j.socnet.2006.04.002
</p>
<p>Žiberna, A. (2008). Direct and indirect approaches to blockmodeling of valued networks in terms of regular equivalence. Journal of Mathematical Sociology, 32(1), 57-84. doi: 10.1080/00222500701790207
</p>
<p>Žiberna, A. (2014). Blockmodeling of multilevel networks. Social Networks, 39(1), 46-61. doi: 10.1016/j.socnet.2014.04.002
</p>


<h3>See Also</h3>

<p><code><a href="#topic+critFunC">critFunC</a></code>, <code><a href="#topic+IM">IM</a></code>, <code><a href="#topic+clu">clu</a></code>, <code><a href="#topic+err">err</a></code>, <code><a href="#topic+plot.optMorePar">plot.optMorePar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 8 # If larger, the number of partitions increases dramatically
# as does if we increase the number of clusters
net &lt;- matrix(NA, ncol = n, nrow = n)
clu &lt;- rep(1:2, times = c(3, 5))
tclu &lt;- table(clu)
net[clu == 1, clu == 1] &lt;- rnorm(n = tclu[1] * tclu[1], mean = 0, sd = 1)
net[clu == 1, clu == 2] &lt;- rnorm(n = tclu[1] * tclu[2], mean = 4, sd = 1)
net[clu == 2, clu == 1] &lt;- rnorm(n = tclu[2] * tclu[1], mean = 0, sd = 1)
net[clu == 2, clu == 2] &lt;- rnorm(n = tclu[2] * tclu[2], mean = 0, sd = 1)

# Optimizing 10 random chosen partitions with optRandomParC
res &lt;- optRandomParC(M = net, k = 2, rep = 10,
approaches = "hom", homFun = "ss", blocks = "com")
plot(res) # Hopefully we get the original partition

</code></pre>

<hr>
<h2 id='orderClu'>Orders the partition so that mean values of <code>fun</code> applied to columns (if <code>funWay=2</code>, default), rows (if <code>funWay=1</code>) or both (if <code>funWay=c(1,2)</code>) is decreasing by clusters.</h2><span id='topic+orderClu'></span>

<h3>Description</h3>

<p>Orders the partition so that mean values of <code>fun</code> applied to columns (if <code>funWay=2</code>, default), rows (if <code>funWay=1</code>) or both (if <code>funWay=c(1,2)</code>) is decreasing by clusters. The function can be used on the results of <code><a href="#topic+critFunC">critFunC</a></code>, <code><a href="#topic+optRandomParC">optRandomParC</a></code> or similar, or matrix and a partition can be supplied. It should also work on multirelational and lined networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderClu(
  x,
  clu = NULL,
  fun = sum,
  funWay = 2,
  nn = NULL,
  returnList = TRUE,
  scale = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orderClu_+3A_x">x</code></td>
<td>
<p>A result of <code><a href="#topic+critFunC">critFunC</a></code>, <code><a href="#topic+optRandomParC">optRandomParC</a></code> or similar (something containing M (matrix) and clu (partition)) or a matrix (or array for multirelational networks).</p>
</td></tr>
<tr><td><code id="orderClu_+3A_clu">clu</code></td>
<td>
<p>A partition - a vector or a list of vectors/partitions. It must be supplied only if <code>x</code> is a matrix or array.</p>
</td></tr>
<tr><td><code id="orderClu_+3A_fun">fun</code></td>
<td>
<p>A function used to summarize rows or columns. <code>sum</code> by default.</p>
</td></tr>
<tr><td><code id="orderClu_+3A_funway">funWay</code></td>
<td>
<p>In which &quot;way&quot; should <code>fun</code> be appluied - to columns (if <code>funWay=2</code>, default), rows (if <code>funWay=1</code>) or both (if <code>funWay=c(1,2)</code>)</p>
</td></tr>
<tr><td><code id="orderClu_+3A_nn">nn</code></td>
<td>
<p>The numbers of untis by sets of units. In principle, the function should determin this automatically.</p>
</td></tr>
<tr><td><code id="orderClu_+3A_returnlist">returnList</code></td>
<td>
<p>Logical. Should the partition be returned in form of a list (for lined networks only). <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="orderClu_+3A_scale">scale</code></td>
<td>
<p>Only used in case of multirelational networks. Should relations be scaled (<code>TRUE</code> by default) before summation. It can also be a vector of weights by relations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An ordered partition. In an attribute (&quot;reorder&quot;). the information on how things were reordered.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clu">clu</a></code>
</p>

<hr>
<h2 id='plot.critFun'>Functions for plotting a partitioned matrix (representing the network)</h2><span id='topic+plot.critFun'></span><span id='topic+plot.crit.fun'></span><span id='topic+plotMatNm'></span><span id='topic+plot.optMorePar'></span><span id='topic+plot.opt.more.par'></span><span id='topic+plot.optMoreParMode'></span><span id='topic+plot.opt.more.par.mode'></span><span id='topic+plot.optPar'></span><span id='topic+plot.opt.par'></span><span id='topic+plot.optParMode'></span><span id='topic+plot.opt.par.mode'></span><span id='topic+plotMat'></span><span id='topic+plotArray'></span><span id='topic+plot.mat'></span>

<h3>Description</h3>

<p>The main function <code>plot.mat</code> or <code>plotMat</code> plots a (optionally partitioned) matrix.
If the matrix is partitioned, the rows and columns of the matrix are rearranged according to the partitions.
Other functions are only wrappers for <code>plot.mat</code> or <code>plotMat</code> for convenience when plotting the results of the corresponding functions.
The <code>plotMatNm</code> plots two matrices based on M, normalized by rows and columns, next to each other. The <code>plotArray</code> plots an array. <code>plot.mat.nm</code> has been replaced by <code>plotMatNm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'critFun'
plot(x, main = NULL, ...)

## S3 method for class 'crit.fun'
plot(x, main = NULL, ...)

plotMatNm(
  M = x,
  x = M,
  ...,
  main.title = NULL,
  title.row = "Row normalized",
  title.col = "Column normalized",
  main.title.line = -2,
  par.set = list(mfrow = c(1, 2))
)

## S3 method for class 'optMorePar'
plot(x, main = NULL, which = 1, ...)

## S3 method for class 'opt.more.par'
plot(x, main = NULL, which = 1, ...)

## S3 method for class 'optMoreParMode'
plot(x, main = NULL, which = 1, ...)

## S3 method for class 'opt.more.par.mode'
plot(x, main = NULL, which = 1, ...)

## S3 method for class 'optPar'
plot(x, main = NULL, which = 1, ...)

## S3 method for class 'opt.par'
plot(x, main = NULL, which = 1, ...)

## S3 method for class 'optParMode'
plot(x, main = NULL, which = 1, ...)

## S3 method for class 'opt.par.mode'
plot(x, main = NULL, which = 1, ...)

plotMat(
  x = M,
  clu = NULL,
  orderClu = FALSE,
  M = x,
  ylab = "",
  xlab = "",
  main = NULL,
  print.val = !length(table(M)) &lt;= 2,
  print.0 = FALSE,
  plot.legend = !print.val &amp;&amp; !length(table(M)) &lt;= 2,
  print.legend.val = "out",
  print.digits.legend = 2,
  print.digits.cells = 2,
  print.cells.mf = NULL,
  outer.title = FALSE,
  title.line = ifelse(outer.title, -1.5, 7),
  mar = c(0.5, 7, 8.5, 0) + 0.1,
  cex.val = "default",
  val.y.coor.cor = 0,
  val.x.coor.cor = 0,
  cex.legend = 1,
  legend.title = "Legend",
  cex.axes = "default",
  print.axes.val = NULL,
  print.x.axis.val = !is.null(colnames(M)),
  print.y.axis.val = !is.null(rownames(M)),
  x.axis.val.pos = 1.01,
  y.axis.val.pos = -0.01,
  cex.main = par()$cex.main,
  cex.lab = par()$cex.lab,
  yaxis.line = -1.5,
  xaxis.line = -1,
  legend.left = 0.4,
  legend.up = 0.03,
  legend.size = 1/min(dim(M)),
  legend.text.hor.pos = 0.5,
  par.line.width = 3,
  par.line.width.newSet = par.line.width[1] * 2,
  par.line.col = "blue",
  par.line.col.newSet = "red",
  IM.dens = NULL,
  IM = NULL,
  wnet = NULL,
  wIM = NULL,
  use.IM = length(dim(IM)) == length(dim(M)) | !is.null(wIM),
  dens.leg = c(null = 100, nul = 100),
  blackdens = 70,
  plotLines = FALSE,
  frameMatrix = TRUE,
  x0ParLine = -0.1,
  x1ParLine = 1,
  y0ParLine = 0,
  y1ParLine = 1.1,
  colByUnits = NULL,
  colByRow = NULL,
  colByCol = NULL,
  mulCol = 2,
  joinColOperator = "+",
  colTies = FALSE,
  maxValPlot = NULL,
  printMultipliedMessage = TRUE,
  replaceNAdiagWith0 = TRUE,
  colLabels = FALSE,
  MplotValues = NULL,
  ...
)

plotArray(
  x = M,
  M = x,
  IM = NULL,
  ...,
  main.title = NULL,
  main.title.line = -2,
  mfrow = NULL
)

## S3 method for class 'mat'
plot(
  x = M,
  clu = NULL,
  orderClu = FALSE,
  M = x,
  ylab = "",
  xlab = "",
  main = NULL,
  print.val = !length(table(M)) &lt;= 2,
  print.0 = FALSE,
  plot.legend = !print.val &amp;&amp; !length(table(M)) &lt;= 2,
  print.legend.val = "out",
  print.digits.legend = 2,
  print.digits.cells = 2,
  print.cells.mf = NULL,
  outer.title = FALSE,
  title.line = ifelse(outer.title, -1.5, 7),
  mar = c(0.5, 7, 8.5, 0) + 0.1,
  cex.val = "default",
  val.y.coor.cor = 0,
  val.x.coor.cor = 0,
  cex.legend = 1,
  legend.title = "Legend",
  cex.axes = "default",
  print.axes.val = NULL,
  print.x.axis.val = !is.null(colnames(M)),
  print.y.axis.val = !is.null(rownames(M)),
  x.axis.val.pos = 1.01,
  y.axis.val.pos = -0.01,
  cex.main = par()$cex.main,
  cex.lab = par()$cex.lab,
  yaxis.line = -1.5,
  xaxis.line = -1,
  legend.left = 0.4,
  legend.up = 0.03,
  legend.size = 1/min(dim(M)),
  legend.text.hor.pos = 0.5,
  par.line.width = 3,
  par.line.width.newSet = par.line.width[1] * 2,
  par.line.col = "blue",
  par.line.col.newSet = "red",
  IM.dens = NULL,
  IM = NULL,
  wnet = NULL,
  wIM = NULL,
  use.IM = length(dim(IM)) == length(dim(M)) | !is.null(wIM),
  dens.leg = c(null = 100, nul = 100),
  blackdens = 70,
  plotLines = FALSE,
  frameMatrix = TRUE,
  x0ParLine = -0.1,
  x1ParLine = 1,
  y0ParLine = 0,
  y1ParLine = 1.1,
  colByUnits = NULL,
  colByRow = NULL,
  colByCol = NULL,
  mulCol = 2,
  joinColOperator = "+",
  colTies = FALSE,
  maxValPlot = NULL,
  printMultipliedMessage = TRUE,
  replaceNAdiagWith0 = TRUE,
  colLabels = FALSE,
  MplotValues = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.critFun_+3A_x">x</code></td>
<td>
<p>A result from a corresponding function or a matrix or similar object representing a network.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_main">main</code></td>
<td>
<p>Main title.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>plot.default</code> for <code>plotMat</code> and also to <code>plotMat</code> for other functions.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_m">M</code></td>
<td>
<p>A matrix or similar object representing a network - either <code>x</code> or <code>M</code> must be supplied - both are here to make the code compatible with generic and with older functions.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_main.title">main.title</code></td>
<td>
<p>Main title in <code>plotArray</code> version.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_title.row">title.row</code></td>
<td>
<p>Title for the row-normalized matrix in nm version</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_title.col">title.col</code></td>
<td>
<p>Title for the column-normalized matrix in nm version</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_main.title.line">main.title.line</code></td>
<td>
<p>The line in which main title is printed in <code>plotArray</code> version.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_par.set">par.set</code></td>
<td>
<p>A list of possible plotting parameters (to <code>par</code>) to be used in nm version</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_which">which</code></td>
<td>
<p>Which (if there are more than one) of optimal solutions to plot.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_clu">clu</code></td>
<td>
<p>A partition. Each unique value represents one cluster. If the network is one-mode,
then this should be a vector, else a list of vectors, one for each mode/set.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_orderclu">orderClu</code></td>
<td>
<p>Should the partition be ordered before plotting. <code>FALSE</code> by default. If <code>TRUE</code>, <code><a href="#topic+orderClu">orderClu</a></code> is used (using default arguments) to order the clusters in a partition in &quot;decreasing&quot; (see <code><a href="#topic+orderClu">orderClu</a></code> for interpretation) order.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_ylab">ylab</code></td>
<td>
<p>Label for y axis.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_xlab">xlab</code></td>
<td>
<p>Label for x axis.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_print.val">print.val</code></td>
<td>
<p>Should the values be printed in the matrix.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_print.0">print.0</code></td>
<td>
<p>If <code>print.val = TRUE</code> Should the 0s be printed in the matrix.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_plot.legend">plot.legend</code></td>
<td>
<p>Should the legend for shades be plotted.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_print.legend.val">print.legend.val</code></td>
<td>
<p>Should the values be printed in the legend.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_print.digits.legend">print.digits.legend</code></td>
<td>
<p>The number of digits that should appear in the legend.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_print.digits.cells">print.digits.cells</code></td>
<td>
<p>The number of digits that should appear in the cells (of the matrix and/or legend).</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_print.cells.mf">print.cells.mf</code></td>
<td>
<p>If not <code>NULL</code>, the above argument is ignored, the cell values are printed as the cell are multiplied by this factor and rounded.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_outer.title">outer.title</code></td>
<td>
<p>Should the title be printed on the 'inner' or 'outer' margin of the plot, default is 'inner' margin.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_title.line">title.line</code></td>
<td>
<p>The line (from the top) where the title should be printed. The suitable values depend heavily on the displayed type.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_mar">mar</code></td>
<td>
<p>A numerical vector of the form <code>c(bottom, left, top, right)</code> which gives the lines of margin to be specified on the four sides of the plot.
The R default for ordinary  plots is <code>c(5, 4, 4, 2) + 0.1</code>, while this function default is <code>c(0.5, 7, 8.5, 0) + 0.1</code>.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_cex.val">cex.val</code></td>
<td>
<p>The size of the values printed. The default is <code>10 / 'number of units'</code>.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_val.y.coor.cor">val.y.coor.cor</code></td>
<td>
<p>Correction for centering the values in the squares in y direction.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_val.x.coor.cor">val.x.coor.cor</code></td>
<td>
<p>Correction for centering the values in the squares in x direction.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Size of the text in the legend.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_legend.title">legend.title</code></td>
<td>
<p>The title of the legend.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_cex.axes">cex.axes</code></td>
<td>
<p>Size of the characters in axes. Default makes the cex so small that all categories can be printed.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_print.axes.val">print.axes.val</code></td>
<td>
<p>Should the axes values be printed. Default prints each axis if <code>rownames</code> or <code>colnames</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_print.x.axis.val">print.x.axis.val</code></td>
<td>
<p>Should the x axis values be printed. Default prints each axis if <code>rownames</code> or <code>colnames</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_print.y.axis.val">print.y.axis.val</code></td>
<td>
<p>Should the y axis values be printed. Default prints each axis if <code>rownames</code> or <code>colnames</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_x.axis.val.pos">x.axis.val.pos</code></td>
<td>
<p>The x coordinate of the y axis values.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_y.axis.val.pos">y.axis.val.pos</code></td>
<td>
<p>The y coordinate of the x axis values.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_cex.main">cex.main</code></td>
<td>
<p>Size of the text in the main title.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_cex.lab">cex.lab</code></td>
<td>
<p>Size of the text in matrix.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_yaxis.line">yaxis.line</code></td>
<td>
<p>The position of the y axis (the argument 'line').</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_xaxis.line">xaxis.line</code></td>
<td>
<p>The position of the x axis (the argument 'line').</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_legend.left">legend.left</code></td>
<td>
<p>How much left should the legend be from the matrix.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_legend.up">legend.up</code></td>
<td>
<p>How much up should the legend be from the matrix.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_legend.size">legend.size</code></td>
<td>
<p>Relative legend size.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_legend.text.hor.pos">legend.text.hor.pos</code></td>
<td>
<p>Horizontal position of the legend text (bottom) - 0 = bottom, 0.5 = middle,...</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_par.line.width">par.line.width</code></td>
<td>
<p>The width of the line that separates  the partitions.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_par.line.width.newset">par.line.width.newSet</code></td>
<td>
<p>The width of the line that separates  that separates the sets/modes - only used when <code>clu</code> is a list and <code>par.line.width</code> has length 1.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_par.line.col">par.line.col</code></td>
<td>
<p>The color of the line that separates the partitions.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_par.line.col.newset">par.line.col.newSet</code></td>
<td>
<p>The color of the line that separates  that separates the sets/modes - only used when <code>clu</code> is a list and <code>par.line.col</code> has length 1.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_im.dens">IM.dens</code></td>
<td>
<p>The density of shading lines in each block.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_im">IM</code></td>
<td>
<p>The image (as obtained  with <code>critFunC</code>) of the blockmodel. <code>dens.leg</code> is used to translate this image into <code>IM.dens</code>.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_wnet">wnet</code></td>
<td>
<p>Specifies which matrix (if more) should be plotted  - used if <code>M</code> is an array.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_wim">wIM</code></td>
<td>
<p>Specifies which <code>IM</code> (if more) should be used for plotting. The default value is set to <code>wnet</code>) - used if <code>IM</code> is an array.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_use.im">use.IM</code></td>
<td>
<p>Specifies if <code>IM</code> should be used for plotting.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_dens.leg">dens.leg</code></td>
<td>
<p>It is used to translate the <code>IM</code> into <code>IM.dens</code>.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_blackdens">blackdens</code></td>
<td>
<p>At which density should the values on dark colors  of lines be printed in white.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_plotlines">plotLines</code></td>
<td>
<p>Should the lines in the matrix be printed. The default value is set to <code>FALSE</code>, best set to <code>TRUE</code> for very small networks.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_framematrix">frameMatrix</code></td>
<td>
<p>Should the matrix be framed (if <code>plotLines</code> is <code>FALSE</code>). The default value is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_x0parline">x0ParLine</code></td>
<td>
<p>Coordinates for lines separating clusters.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_x1parline">x1ParLine</code></td>
<td>
<p>Coordinates for lines separating clusters.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_y0parline">y0ParLine</code></td>
<td>
<p>Coordinates for lines separating clusters.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_y1parline">y1ParLine</code></td>
<td>
<p>Coordinates for lines separating clusters.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_colbyunits">colByUnits</code></td>
<td>
<p>Coloring units. It should be a vector of unit length.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_colbyrow">colByRow</code></td>
<td>
<p>Coloring units by rows. It should be a vector of unit length.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_colbycol">colByCol</code></td>
<td>
<p>Coloring units by columns. It should be a vector of unit length.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_mulcol">mulCol</code></td>
<td>
<p>Multiply color when joining with row, column. Only used when when <code>colByUnits</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_joincoloperator">joinColOperator</code></td>
<td>
<p>Function to join <code>colByRow</code> and <code>colByCol</code>. The default value is set to <code>"+"</code>.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_colties">colTies</code></td>
<td>
<p>If <code>TRUE</code>, ties are colored, if <code>FALSE</code>, 0-ties are colored.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_maxvalplot">maxValPlot</code></td>
<td>
<p>The value to use as a maximum when computing colors (ties with maximal positive value are plotted  as black).</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_printmultipliedmessage">printMultipliedMessage</code></td>
<td>
<p>Should the message '* all values in cells were multiplied by' be printed on the plot. The default value is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_replacenadiagwith0">replaceNAdiagWith0</code></td>
<td>
<p>If <code>replaceNAdiagWith0 = TRUE</code> Should the <code>NA</code> values on the diagonal of a matrix be replaced with 0s.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_collabels">colLabels</code></td>
<td>
<p>Should the labels of units be colored. If <code>FALSE</code>, these are not colored, if <code>TRUE</code>, they are colored with colors of clusters as defined by palette.
This can be also a vector of colors (or integers) for one-mode networks or a list of two such vectors for two-mode networks.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_mplotvalues">MplotValues</code></td>
<td>
<p>A matrix to strings to plot in cells. Only to be used if other values than those in the original matrix (<code>x</code> or <code>M</code> arguments) should be used. Defaults to <code>NULL</code>, in which case the valued from original matrix are plotted (if this is not prevented by some other arguments). Overrides all other arguments that deal with cell values (e.g. <code>print.digits.cells</code>). Sets <code>print.val</code> to <code>TRUE</code> and <code>plot.legend</code> to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.critFun_+3A_mfrow">mfrow</code></td>
<td>
<p><code>mfrow</code> Argument to <code>par</code> - number of row and column plots to be plotted on one figure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions are used for their side effect - plotting.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>References</h3>

<p>Žiberna, A. (2007). Generalized Blockmodeling of Valued Networks. Social Networks, 29(1), 105-126. doi: 10.1016/j.socnet.2006.04.002
</p>
<p>Žiberna, A. (2008). Direct and indirect approaches to blockmodeling of valued networks in terms of regular equivalence. Journal of Mathematical Sociology, 32(1), 57-84. doi: 10.1080/00222500701790207
</p>


<h3>See Also</h3>

<p><code><a href="#topic+critFunC">critFunC</a></code>, <code><a href="#topic+optRandomParC">optRandomParC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generation of the network
n &lt;- 20
net &lt;- matrix(NA, ncol = n, nrow = n)
clu &lt;- rep(1:2, times = c(5, 15))
tclu &lt;- table(clu)
net[clu == 1, clu == 1] &lt;- rnorm(n = tclu[1] * tclu[1], mean = 0, sd = 1)
net[clu == 1, clu == 2] &lt;- rnorm(n = tclu[1] * tclu[2], mean = 4, sd = 1)
net[clu == 2, clu == 1] &lt;- rnorm(n = tclu[2] * tclu[1], mean = 0, sd = 1)
net[clu == 2, clu == 2] &lt;- rnorm(n = tclu[2] * tclu[2], mean = 0, sd = 1)

# Ploting the network
plotMat(M = net, clu = clu, print.digits.cells = 3)
class(net) &lt;- "mat"
plot(net, clu = clu)
# See corresponding functions for examples for other ploting
# functions
# presented, that are essentially only the wrappers for "plot.max"
</code></pre>

<hr>
<h2 id='printBlocks'>Nice printing of the <code>blocks</code> parameter as used in <code><a href="#topic+optRandomParC">optRandomParC</a></code> and <code><a href="#topic+critFunC">critFunC</a></code>.</h2><span id='topic+printBlocks'></span>

<h3>Description</h3>

<p>Nice printing of the <code>blocks</code> parameter as used in <code><a href="#topic+optRandomParC">optRandomParC</a></code> and <code><a href="#topic+critFunC">critFunC</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printBlocks(blocks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printBlocks_+3A_blocks">blocks</code></td>
<td>
<p><code>blocks</code> parameter as used in <code><a href="#topic+optRandomParC">optRandomParC</a></code> and <code><a href="#topic+critFunC">critFunC</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Used for side effects (printing)
</p>


<h3>Author(s)</h3>

<p>Aleš, Žiberna
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optRandomParC">optRandomParC</a></code>, <code><a href="#topic+critFunC">critFunC</a></code>
</p>

<hr>
<h2 id='rand'>Comparing partitions on one or multiple sets of units</h2><span id='topic+rand'></span><span id='topic+crand'></span><span id='topic+rand2'></span><span id='topic+crand2'></span>

<h3>Description</h3>

<p>Rand Index and Rand Index corrected/adjusted for chance for comparing partitions (Hubert &amp; Arabie, 1985). The functions also support computing these indices on partitions on multiple sets (where a &quot;combined&quot; partition is a list of multiple partitions).
The names of the clusters do not matter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rand(clu1, clu2, tab)

crand(
  clu1,
  clu2,
  tab,
  multiSets = c("weights", "unlist"),
  weights = c("size", "equal"),
  returnIndividual = "attr"
)

rand2(clu1, clu2)

crand2(clu1, clu2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rand_+3A_clu1">clu1</code></td>
<td>
<p>The first of the two partitions to be compared, given in the form of vectors, where for each unit a cluster membership is given. Alternatively, this can be a contingency table obtained as a <code>table(clu1, clu2)</code>. If a partition, <code>clu2</code> must also be provided. In case of multiple sets, this should be pa list of partitions.</p>
</td></tr>
<tr><td><code id="rand_+3A_clu2">clu2</code></td>
<td>
<p>If <code>clu1</code> is partition or a list of partitions, this must be a comaptible the second partition or list of partitions.</p>
</td></tr>
<tr><td><code id="rand_+3A_tab">tab</code></td>
<td>
<p>A contingency table obtained as a <code>table(clu1, clu2)</code>. This is included for back-compatibility reasons. If this is present, all other arguments are ignored.</p>
</td></tr>
<tr><td><code id="rand_+3A_multisets">multiSets</code></td>
<td>
<p>How should we compute the index in case of multiple sets of unis (if <code>clu1</code> and  <code>clu2</code> are lists of partitions)? Possible values are &quot;unlist&quot; and &quot;weight&quot; (the default).</p>
</td></tr>
<tr><td><code id="rand_+3A_weights">weights</code></td>
<td>
<p>Weights to be used if <code>multiSets</code> is &quot;weight&quot;. It can be &quot;equal&quot;, &quot;size&quot; (default) or a numeric (non-negative) vector of the same length as the number of sets (the number of partitions in the list of partitions).</p>
</td></tr>
<tr><td><code id="rand_+3A_returnindividual">returnIndividual</code></td>
<td>
<p>If <code>multiSets</code> is &quot;weight&quot;, should the indices for individual sets be also returned.  If <code>TRUE</code>, the function returns a list instead of a single value. If the values is <code>"attr"</code> (the default), the indices by sets are given as an attribute <code>"bySets"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of Rand Index (corrected/adjusted for chance) unless <code>multiSets="weight"</code> and <code>returnIndividual=FALSE</code>. In this case, a list with two items is return. The &quot;global&quot; index is in <code>global</code>, while the the indices by sets are in <code>bySets</code>.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>References</h3>

<p>Hubert, L., &amp; Arabie, P. (1985). Comparing Partitions. Journal of Classification, 2(1), 193-218.
</p>

<hr>
<h2 id='recode'>Recode</h2><span id='topic+recode'></span>

<h3>Description</h3>

<p>Recodes values in a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode(x, oldcode = sort(unique(x)), newcode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="recode_+3A_oldcode">oldcode</code></td>
<td>
<p>A vector of old codes.</p>
</td></tr>
<tr><td><code id="recode_+3A_newcode">newcode</code></td>
<td>
<p>A vector of new codes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A recoded vector.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rep(1:3, times = 1:3)
newx &lt;- recode(x, oldcode = 1:3, newcode = c("a", "b", "c"))

</code></pre>

<hr>
<h2 id='REGE.FC'>REGE - Algorithms for compiting (dis)similarities in terms of regular equivalnece</h2><span id='topic+REGE.FC'></span><span id='topic+REGE.FC.ow'></span><span id='topic+REGE'></span><span id='topic+REGE.ow'></span><span id='topic+REGE.for'></span><span id='topic+REGD.for'></span><span id='topic+REGE.ow.for'></span><span id='topic+REGD.ow.for'></span><span id='topic+REGE.ownm.for'></span><span id='topic+REGE.ownm.diag.for'></span><span id='topic+REGE.nm.for'></span><span id='topic+REGE.nm.diag.for'></span><span id='topic+REGE.ne.for'></span><span id='topic+REGE.ow.ne.for'></span><span id='topic+REGE.ownm.ne.for'></span><span id='topic+REGE.nm.ne.for'></span><span id='topic+REGD.ne.for'></span><span id='topic+REGD.ow.ne.for'></span>

<h3>Description</h3>

<p>REGE - Algorithms for compiting (dis)similarities in terms of regular equivalnece (White &amp; Reitz, 1983). 
<code>REGE, REGE.for</code> - Classical REGE or REGGE, as also implemented in Ucinet. Similarities in terms of regular equivalence are computed.  The <code>REGE.for</code> is a wrapper for calling the FORTRAN subrutine written by White (1985a), modified to be called by R. The <code>REGE</code> does the same, however it is written in R. The functions with and without &quot;.for&quot; differ only in whether they are implemented  in R of FORTRAN. Needless to say, the functions implemented in FORTRAN are much faster.
<code>REGE.ow, REGE.ow.for</code> - The above function, modified so that a best match is searched for each arc separately (and not for both arcs, if they exist, together). 
<code>REGE.nm.for</code> - REGE or REGGE, modified to use row and column normalized matrices instead of the original matrix.
<code>REGE.ownm.for</code> - The above function, modified so that a best match for an outgoing ties is searched on row-normalized network and for incoming ties on column-normalized network.
<code>REGD.for</code> - REGD or REGDI, a dissimilarity version of the classical REGE or REGGE. Dissimilarities in terms of regular equivalence  are computed.  The <code>REGD.for</code> is a wrapper for calling the FORTRAN subroutine written by White (1985b), modified to be called by R.
<code>REGE.FC</code>  - Actually an earlier version of REGE. The difference is in the denominator. See Žiberna (2007) for details.
<code>REGE.FC.ow</code> - The above function, modified so that a best match is searched for each arc separately (and not for both arcs, if they exist, together).
other - still in testing stage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>REGE.FC(
  M,
  E = 1,
  iter = 3,
  until.change = TRUE,
  use.diag = TRUE,
  normE = FALSE
)

REGE.FC.ow(
  M,
  E = 1,
  iter = 3,
  until.change = TRUE,
  use.diag = TRUE,
  normE = FALSE
)

REGE(M, E = 1, iter = 3, until.change = TRUE, use.diag = TRUE)

REGE.ow(M, E = 1, iter = 3, until.change = TRUE, use.diag = TRUE)

REGE.for(M, iter = 3, E = 1)

REGD.for(M, iter = 3, E = 0)

REGE.ow.for(M, iter = 3, E = 1)

REGD.ow.for(M, iter = 3, E = 0)

REGE.ownm.for(M, iter = 3, E = 1)

REGE.ownm.diag.for(M, iter = 3, E = 1)

REGE.nm.for(M, iter = 3, E = 1)

REGE.nm.diag.for(M, iter = 3, E = 1)

REGE.ne.for(M, iter = 3, E = 1)

REGE.ow.ne.for(M, iter = 3, E = 1)

REGE.ownm.ne.for(M, iter = 3, E = 1)

REGE.nm.ne.for(M, iter = 3, E = 1)

REGD.ne.for(M, iter = 3, E = 0)

REGD.ow.ne.for(M, iter = 3, E = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="REGE.FC_+3A_m">M</code></td>
<td>
<p>Matrix or a 3 dimensional array representing the network. The third dimension allows for several relations to be analyzed.</p>
</td></tr>
<tr><td><code id="REGE.FC_+3A_e">E</code></td>
<td>
<p>Initial (dis)similarity in terms of regular equivalnece.</p>
</td></tr>
<tr><td><code id="REGE.FC_+3A_iter">iter</code></td>
<td>
<p>The desired number of iterations.</p>
</td></tr>
<tr><td><code id="REGE.FC_+3A_until.change">until.change</code></td>
<td>
<p>Should the iterations be stopped when no change occurs.</p>
</td></tr>
<tr><td><code id="REGE.FC_+3A_use.diag">use.diag</code></td>
<td>
<p>Should the diagonal be used. If <code>FALSE</code>, all diagonal elements are set to 0.</p>
</td></tr>
<tr><td><code id="REGE.FC_+3A_norme">normE</code></td>
<td>
<p>Should the equivalence matrix be normalized after each iteration.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>E</code></td>
<td>
<p>A matrix of (dis)similarities in terms of regular equivalnece.</p>
</td></tr>
<tr><td><code>Eall</code></td>
<td>
<p>An array of (dis)similarity matrices in terms of regular equivalence, each third dimension represets one iteration. For &quot;.for&quot; functions, only the initial and the final (dis)similarities are returned.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Matrix or a 3 dimensional array representing the network used in the call.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>The desired number of iterations.</p>
</td></tr>
<tr><td><code>use.diag</code></td>
<td>
<p>Should the diagonal be used - for functions implemented in R only.</p>
</td></tr>
</table>
<p>...
</p>


<h3>References</h3>

<p>Žiberna, A. (2008). Direct and indirect approaches to blockmodeling of valued networks in terms of regular equivalence. Journal of Mathematical Sociology, 32(1), 57-84. doi: 10.1080/00222500701790207
</p>
<p>White, D. R., &amp; Reitz, K. P. (1983). Graph and semigroup homomorphisms on networks of relations. Social Networks, 5(2), 193-234.
</p>
<p>White, D. R.(1985a). DOUG WHITE'S REGULAR EQUIVALENCE PROGRAM. Retrieved from http://eclectic.ss.uci.edu/~drwhite/REGGE/REGGE.FOR
</p>
<p>White, D. R. (1985b). DOUG WHITE'S REGULAR DISTANCES PROGRAM. Retrieved from http://eclectic.ss.uci.edu/~drwhite/REGGE/REGDI.FOR
</p>
<p>White, D. R. (2005). REGGE. Retrieved from http://eclectic.ss.uci.edu/~drwhite/REGGE/
</p>
<p>#' @author Aleš Žiberna based on Douglas R. White's original REGE and REGD
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sedist">sedist</a></code>, <code><a href="#topic+critFunC">critFunC</a></code>, <code><a href="#topic+optParC">optParC</a></code>, <code><a href="#topic+plot.mat">plot.mat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 20
net &lt;- matrix(NA, ncol = n, nrow = n)
clu &lt;- rep(1:2, times = c(5, 15))
tclu &lt;- table(clu)
net[clu == 1, clu == 1] &lt;- 0
net[clu == 1, clu == 2] &lt;- rnorm(n = tclu[1] * tclu[2], mean = 4, sd = 1) * sample(c(0, 1),
   size = tclu[1] * tclu[2], replace = TRUE, prob = c(3/5, 2/5))
net[clu == 2, clu == 1] &lt;- 0
net[clu == 2, clu == 2] &lt;- 0

D &lt;- REGE.for(M = net)$E # Any other REGE function can be used
plot.mat(net, clu = cutree(hclust(d = as.dist(1 - D), method = "ward.D"),
   k = 2))
# REGE returns similarities, which have to be converted to
# disimilarities

res &lt;- optRandomParC(M = net, k = 2, rep = 10, approaches = "hom", homFun = "ss", blocks = "reg")
plot(res) # Hopefully we get the original partition

</code></pre>

<hr>
<h2 id='relInv'>Functions for computing &quot;relative inverse&quot; (<code>x[1]/x</code>).</h2><span id='topic+relInv'></span><span id='topic+relInv2'></span>

<h3>Description</h3>

<p>For a vector x, it computes <code>x[1]/x</code>. For <code>relInv2</code>, if certain elements of the result are not finite (e.g. if certain elements of x are 0), these elements are replaced with 0s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relInv(x)

relInv2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relInv_+3A_x">x</code></td>
<td>
<p>A numeric vector. For <code>relInv</code> it should not contain 0s (while for  <code>relInv2</code> it can).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector computed as <code>x[1]/x</code>. For <code>relInv2</code>, if the non-finite elements are replaced with 0s.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>

<hr>
<h2 id='reorderImage'>Reordering an image matrix of the blockmodel (or an error matrix based on new and old partition</h2><span id='topic+reorderImage'></span>

<h3>Description</h3>

<p>Reorders an image matrix of the blockmodel (or an error matrix based on new and old partition.
The partitions should be the same, except that classes can have different labels.
It is useful when we want to have a different order of classes in figures and then also in image matrices. Currently it is only suitable for one-mode blockmodels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reorderImage(IM, oldClu, newClu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reorderImage_+3A_im">IM</code></td>
<td>
<p>An image or error matrix.</p>
</td></tr>
<tr><td><code id="reorderImage_+3A_oldclu">oldClu</code></td>
<td>
<p>Old partition.</p>
</td></tr>
<tr><td><code id="reorderImage_+3A_newclu">newClu</code></td>
<td>
<p>New partition, the same as the old one except for class labeles.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Reorder matrix (rows and columns are reordred).
</p>


<h3>Author(s)</h3>

<p>Ales Ziberna
</p>


<h3>References</h3>

<p>Žiberna, A. (2007). Generalized Blockmodeling of Valued Networks. Social Networks, 29(1), 105-126. doi: 10.1016/j.socnet.2006.04.002
</p>
<p>Žiberna, A. (2008). Direct and indirect approaches to blockmodeling of valued networks in terms of regular equivalence. Journal of Mathematical Sociology, 32(1), 57-84. doi: 10.1080/00222500701790207
</p>


<h3>See Also</h3>

<p><code><a href="#topic+critFunC">critFunC</a></code>, <code><a href="#topic+plot.mat">plot.mat</a></code>, <code><a href="#topic+clu">clu</a></code>, <code><a href="#topic+IM">IM</a></code>, <code><a href="#topic+err">err</a></code>
</p>

<hr>
<h2 id='RF'>Calculate the value of the Relative Fit function</h2><span id='topic+RF'></span>

<h3>Description</h3>

<p>The function calculates the value of the Relative Fit function. Currently implemented only for one-relational one-mode or two-mode networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RF(res, m = 10, loops = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RF_+3A_res">res</code></td>
<td>
<p>An object returned by the function <code>optRandomParC</code>.</p>
</td></tr>
<tr><td><code id="RF_+3A_m">m</code></td>
<td>
<p>The number of randomized networks for the estimation of the expected value of a criterion function. It has to be as high as possible. Defaults to 10.</p>
</td></tr>
<tr><td><code id="RF_+3A_loops">loops</code></td>
<td>
<p>Whether loops are treated the same as any other values or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function randomizes an empirical network to compute the value of the Relative Fit function.
The networks are randomized in such a way that the values on the links are randomly relocated. Other approaches to 
randomization also exist and might be more appropriate in some cases, see Cugmas et al. (2021).
</p>


<h3>Value</h3>


<ul>
<li> <p><code>RF</code> - The value of the Relative Fit function.
</p>
</li>
<li> <p><code>err</code> - The value of a criterion function that is used for blockmodeling (for empirical network).
</p>
</li>
<li> <p><code>rand.err</code> - A vector with the values of the criterion function that is used for blockmodeling (for randomized networks).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Marjan Cugmas and Aleš Žiberna
</p>


<h3>References</h3>

<p>Cugmas, M., Žiberna, A., &amp; Ferligoj, A. (2021). The Relative Fit measure for evaluating a blockmodel. Statistical Methods &amp; Applications, 30(5), 1315-1335. <a href="https://doi.org/10.1007/s10260-021-00595-1">doi:10.1007/s10260-021-00595-1</a>
</p>


<h3>See Also</h3>

<p><code>optRandomParC</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 8 # If larger, the number of partitions increases 
# dramatically as does if we increase the number of clusters
net &lt;- matrix(NA, ncol = n, nrow = n)
clu &lt;- rep(1:2, times = c(3, 5))
tclu &lt;- table(clu)
net[clu == 1, clu == 1] &lt;- rnorm(n = tclu[1] * tclu[1], mean = 0, sd = 1)
net[clu == 1, clu == 2] &lt;- rnorm(n = tclu[1] * tclu[2], mean = 4, sd = 1)
net[clu == 2, clu == 1] &lt;- rnorm(n = tclu[2] * tclu[1], mean = 0, sd = 1)
net[clu == 2, clu == 2] &lt;- rnorm(n = tclu[2] * tclu[2], mean = 0, sd = 1)

res &lt;- optRandomParC(M = net, k = 2, rep = 10, approaches = "hom", homFun = "ss", blocks = "com")
RF(res = res, m = 100, loops = TRUE)
</code></pre>

<hr>
<h2 id='sedist'>Computes distances in terms of Structural equivalence (Lorrain &amp; White, 1971)</h2><span id='topic+sedist'></span>

<h3>Description</h3>

<p>The functions compute the distances in terms of Structural equivalence (Lorrain and White, 1971) between the units of a one-mode network.
Several options for treating the diagonal values are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sedist(
  M,
  method = "default",
  fun = "default",
  fun.on.rows = "default",
  handle.interaction = "switch",
  use = "pairwise.complete.obs",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sedist_+3A_m">M</code></td>
<td>
<p>A matrix representing the (usually valued) network. For now, only one-relational networks are supported. The network must be one-mode.</p>
</td></tr>
<tr><td><code id="sedist_+3A_method">method</code></td>
<td>
<p>The method used to compute distances - any of the methods allowed by functions dist, <code>"cor"</code> or <code>"cov"</code> (all <code>package::stats</code>) or just <code>"cor"</code> or <code>"cov"</code> (given as a character).</p>
</td></tr>
<tr><td><code id="sedist_+3A_fun">fun</code></td>
<td>
<p>Which function should be used to compute distances (given as a character).</p>
</td></tr>
<tr><td><code id="sedist_+3A_fun.on.rows">fun.on.rows</code></td>
<td>
<p>For non-standard function - does the function compute measure on rows (such as <code>"cor"</code>, <code>"cov"</code>,...) of the data matrix (as opposed to computing measure on columns (such as <code>dist</code>).</p>
</td></tr>
<tr><td><code id="sedist_+3A_handle.interaction">handle.interaction</code></td>
<td>
<p>How should the interaction between the vertices analysed be handled:<br />
<code>"switch"</code> (the default) - assumes that when comparing units i and j, M[i,i] should be compared with M[j,j] and M[i,j] with M[j,i]. These two comparisons are weighted by 2. This should be used with Euclidean distance to get the corrected Euclidean distance with p = 2.<br />
<code>"switch2"</code> - the same (alias)<br />
<code>"switch1"</code> - the same as above, only that the two comparisons are weighted by 1. This should be used with Euclidean distance to get the corrected Wuclidean distance with p = 1.<br />
<code>"ignore"</code> (diagonal) - Diagonal is ignored. This should be used with Euclidean distance to get the corrected Euclidean distance with p = 0.<br />
<code>"none"</code> - the matrix is used &quot;as is&quot;</p>
</td></tr>
<tr><td><code id="sedist_+3A_use">use</code></td>
<td>
<p>For use with methods <code>"cor"</code> and <code>"cov"</code>, for other methods (the default option should be used if <code>handle.interaction == "ignore"</code>), <code>"pairwise.complete.obs"</code> are always used, if <code>stats.dist.cor.cov = TRUE</code>.</p>
</td></tr>
<tr><td><code id="sedist_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>fun</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both <code>method</code> and <code>fun</code> are <code>"default"</code>, the Euclidean distances are computed.
The <code>"default"</code> method for <code>fun = "dist"</code> is &quot;euclidean&quot; and for <code>fun  = "cor"</code> &quot;pearson&quot;.
</p>


<h3>Value</h3>

<p>A matrix (usually of class dist) is returned.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>References</h3>

<p>Batagelj, V., Ferligoj, A., &amp; Doreian, P. (1992). Direct and indirect methods for structural equivalence. Social Networks, 14(1-2), 63-90. doi: 10.1016/0378-8733(92)90014-X
</p>
<p>Lorrain, F., &amp; White, H. C. (1971). Structural equivalence of individuals in social networks. Journal of Mathematical Sociology, 1(1), 49-80. doi: 10.1080/0022250X.1971.9989788
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>, <code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="#topic+REGE">REGE</a></code>, <code><a href="#topic+optParC">optParC</a></code>, <code><a href="#topic+optParC">optParC</a></code>, <code><a href="#topic+optRandomParC">optRandomParC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating a simple network corresponding to the simple Sum of squares
# Structural equivalence with blockmodel:
# null com
# null null
n &lt;- 20
net &lt;- matrix(NA, ncol = n, nrow = n)
clu &lt;- rep(1:2, times = c(5, 15))
tclu &lt;- table(clu)
net[clu == 1, clu == 1] &lt;- rnorm(n = tclu[1] * tclu[1], mean = 0, sd = 1)
net[clu == 1, clu == 2] &lt;- rnorm(n = tclu[1] * tclu[2], mean = 4, sd = 1)
net[clu == 2, clu == 1] &lt;- rnorm(n = tclu[2] * tclu[1], mean = 0, sd = 1)
net[clu == 2, clu == 2] &lt;- rnorm(n = tclu[2] * tclu[2], mean = 0, sd = 1)

D &lt;- sedist(M = net)
plot.mat(net, clu = cutree(hclust(d = D, method = "ward"), k = 2))

</code></pre>

<hr>
<h2 id='splitClu'>Functions creating a list of partitions based on a single partition and information on the number of units in each set.</h2><span id='topic+splitClu'></span><span id='topic+splitCluRes'></span>

<h3>Description</h3>

<p>Function <code>splitClu</code> creates a list of partitions based on a single partition (<code>clu</code>) and information on the number of units in each set (<code>n</code>).
</p>
<p>Function <code>splitCluRes</code> does the same but extracts the information from the result of (old versions of) functions <code><a href="#topic+critFunC">critFunC</a></code>, <code><a href="#topic+optParC">optParC</a></code>, <code><a href="#topic+optRandomParC">optRandomParC</a></code> or similar (newer versions should already return a list of partitions in case they are used on networks with more sets of units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitClu(clu, n, renumber = FALSE)

splitCluRes(res, renumber = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitClu_+3A_clu">clu</code></td>
<td>
<p>A vector representing a partition of units from different sets. Result of some legacy code for <code><a href="#topic+optRandomParC">optRandomParC</a></code> or <code><a href="#topic+optParC">optParC</a></code> or similar functions.</p>
</td></tr>
<tr><td><code id="splitClu_+3A_n">n</code></td>
<td>
<p>A vector with number of units per set. The assuption is that the first <code>n[1]</code> elements of <code>clu</code> are for the first set, the second <code>n[2]</code> elements of <code>clu</code> are for the second set and so on. <code>sum(n)</code> must be equal to <code>length(clu)</code>.</p>
</td></tr>
<tr><td><code id="splitClu_+3A_renumber">renumber</code></td>
<td>
<p>If <code>TRUE</code>, elements of each partition (for each set) in the list are renumbered to be from 1:&quot;number of clusters&quot; in that partition). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="splitClu_+3A_res">res</code></td>
<td>
<p>Result of  (old versions of) functions <code><a href="#topic+critFunC">critFunC</a></code>, <code><a href="#topic+optParC">optParC</a></code>, <code><a href="#topic+optRandomParC">optRandomParC</a></code> or similar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of partitions if <code>clu</code>, one for each set of units. A single vector if only one set of units is present.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clu">clu</a></code>, <code><a href="#topic+unlistClu">unlistClu</a></code>, <code><a href="#topic+unlistCluInt">unlistCluInt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- c(8,8) 
clu &lt;- c(rep(1:2, times = c(3, 5)), rep(3:4, times = c(3, 5)))
splitClu(clu = clu, n = n )
splitClu(clu = clu, n = n, renumber = TRUE)
 
</code></pre>

<hr>
<h2 id='ss'>Sum of Squared deviations from the mean and sum of Absolute Deviations from the median</h2><span id='topic+ss'></span><span id='topic+ssNa'></span><span id='topic+ad'></span>

<h3>Description</h3>

<p>Functions to compute Sum of Squared deviations from the mean and sum of Absolute Deviations from the median. <code>ssNa</code> removes missing values (<code>NA</code>s) before calling the <code>ss</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ss(x)

ssNa(x)

ad(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ss_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sum of Squared deviations from the mean or sum of Absolute Deviations from the median.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>

<hr>
<h2 id='unlistClu'>Function for &quot;unlisting&quot; a partition.</h2><span id='topic+unlistClu'></span>

<h3>Description</h3>

<p>Essentially, if the argument is a list (otherwise function just returns its argument), the function calls unlist on it. Before it, it however makes sure that names from different elements of the list to not repeat.  The opposite of <code><a href="#topic+splitClu">splitClu</a></code>. The <code>n</code> argument of the <code><a href="#topic+splitClu">splitClu</a></code> is returned as an attribute. If <code>renumber=TRUE</code> (default), it is practically identical to unlistCluInt.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unlistClu(clu, renumber = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unlistClu_+3A_clu">clu</code></td>
<td>
<p>A list representing a partition of units from different sets. Each element should be a partition for one set.</p>
</td></tr>
<tr><td><code id="unlistClu_+3A_renumber">renumber</code></td>
<td>
<p>If <code>TRUE</code> (default), are renumbered so that they are 1:&quot;total number of clusters&quot;. If any cluster &quot;ID&quot; is present in more than one set of units (one partition, one element of the list), this is done even if <code>renumber = FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector representing a partition. It also has an attribute <code>n</code> with the number of units that were in each set.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clu">clu</a></code>, <code><a href="#topic+splitClu">splitClu</a></code>, <code><a href="#topic+unlistCluInt">unlistCluInt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- c(8,8) 
cluList &lt;- c(rep(1:2, times = c(3, 5)), rep(5:6, times = c(3, 5)))
unlistClu(clu = clu)
unlistClu(clu = clu, renumber = FALSE)
 
</code></pre>

<hr>
<h2 id='unlistCluInt'>Unlist a partition.</h2><span id='topic+unlistCluInt'></span>

<h3>Description</h3>

<p>It is used to convert a partition by sets into a single &quot;simple&quot; partition. Simple partition is a partition of only one set, that is a vector where units with the same value are considered to belong to the same cluster. The partitions by sets is a list, where each element of a list is a &quot;simple&quot; partition that corresponds to one set. The function first converts all elements of the lists to integers, that makes sure that each set uses different integers and on the end uses unlist function on such list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unlistCluInt(clu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unlistCluInt_+3A_clu">clu</code></td>
<td>
<p>A partition by sets, that is a list of &quot;simple&quot; partitions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The unlisted partition - one vector containing only integers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clu">clu</a></code>,  <code><a href="#topic+splitClu">splitClu</a></code>, <code><a href="#topic+unlistClu">unlistClu</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cluList&lt;-list(c("a","b","a"),c("b","c","b","c"))
unlistCluInt(cluList)

cluList&lt;-list(c(1,1,1,2,2,2),c(1,1,1,2,2,2,3,3))
unlistCluInt(cluList)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
