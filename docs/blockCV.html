<!DOCTYPE html><html><head><title>Help for package blockCV</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {blockCV}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#blockCV'><p>blockCV: Spatial and Environmental Blocking for K-Fold and LOO Cross-Validation</p></a></li>
<li><a href='#buffering'><p>Use distance (buffer) around records to separate train and test folds</p></a></li>
<li><a href='#cv_block_size'><p>Explore spatial block size</p></a></li>
<li><a href='#cv_buffer'><p>Use buffer around records to separate train and test folds (a.k.a. buffered/spatial leave-one-out)</p></a></li>
<li><a href='#cv_cluster'><p>Use environmental or spatial clustering to separate train and test folds</p></a></li>
<li><a href='#cv_nndm'><p>Use the Nearest Neighbour Distance Matching (NNDM) to separate train and test folds</p></a></li>
<li><a href='#cv_plot'><p>Visualising folds created by blockCV in ggplot</p></a></li>
<li><a href='#cv_similarity'><p>Compute similarity measures to evaluate possible extrapolation in testing folds</p></a></li>
<li><a href='#cv_spatial'><p>Use spatial blocks to separate train and test folds</p></a></li>
<li><a href='#cv_spatial_autocor'><p>Measure spatial autocorrelation in spatial response data or predictor raster files</p></a></li>
<li><a href='#envBlock'><p>Use environmental clustering to separate train and test folds</p></a></li>
<li><a href='#foldExplorer'><p>Explore the generated folds</p></a></li>
<li><a href='#rangeExplorer'><p>Explore spatial block size</p></a></li>
<li><a href='#spatialAutoRange'><p>Measure spatial autocorrelation in the predictor raster files</p></a></li>
<li><a href='#spatialBlock'><p>Use spatial blocks to separate train and test folds</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial and Environmental Blocking for K-Fold and LOO
Cross-Validation</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-04</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rvalavi/blockCV">https://github.com/rvalavi/blockCV</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rvalavi/blockCV/issues">https://github.com/rvalavi/blockCV/issues</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roozbeh Valavi &lt;valavi.r@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Creating spatially or environmentally separated folds for cross-validation to provide a robust error estimation in spatially structured environments; Investigating and visualising the effective range of spatial autocorrelation in continuous raster covariates and point samples to find an initial realistic distance band to separate training and testing datasets spatially described in Valavi, R. et al. (2019) &lt;<a href="https://doi.org/10.1111%2F2041-210X.13107">doi:10.1111/2041-210X.13107</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>sf (&ge; 1.0), Rcpp (&ge; 1.0.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>terra (&ge; 1.6-41), ggplot2 (&ge; 3.3.6), cowplot, automap (&ge;
1.0-16), shiny (&ge; 1.7), tmap (&ge; 2.0), biomod2, gstat,
methods, knitr, rmarkdown, testthat (&ge; 3.0.0), covr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-04 12:40:55 UTC; rvalavi</td>
</tr>
<tr>
<td>Author:</td>
<td>Roozbeh Valavi <a href="https://orcid.org/0000-0003-2495-5277"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jane Elith [aut],
  José Lahoz-Monfort [aut],
  Ian Flint [aut],
  Gurutzeta Guillera-Arroita [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-04 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='blockCV'>blockCV: Spatial and Environmental Blocking for K-Fold and LOO Cross-Validation</h2><span id='topic+blockCV'></span>

<h3>Description</h3>

<p>Simple random selection of training and testing folds in the structured environment leads to
an underestimation of error in the evaluation of spatial
predictions and may result in inappropriate model selection (Telford and Birks, 2009; Roberts et al., 2017). The use of spatial and
environmental blocks to separate training and testing sets has been suggested as a good strategy for realistic error estimation in datasets
with dependence structures, and more generally as a robust method for estimating the predictive performance of models used to predict mapped
distributions (Roberts et al., 2017). The package <code>blockCV</code> offers
a range of functions for generating train and test folds
for <strong>k-fold</strong> and <strong>leave-one-out (LOO)</strong> cross-validation (CV). It allows for separation
of data spatially and environmentally, with various options for block construction.
Additionally, it includes a function for assessing the level of spatial autocorrelation
in response or raster covariates, to aid in selecting an appropriate distance band for
data separation. The <code>blockCV</code> package is suitable for the evaluation of a variety of
spatial modelling applications, including classification of remote sensing imagery,
soil mapping, and species distribution modelling (SDM). It also provides support for
different SDM scenarios, including presence-absence and presence-background species
data, rare and common species, and raster data for predictor variables.
</p>


<h3>Author(s)</h3>

<p>Roozbeh Valavi, Jane Elith, José Lahoz-Monfort and Gurutzeta Guillera-Arroita
</p>


<h3>References</h3>

<p>Roberts et al., (2017). Cross-validation strategies for data with temporal, spatial, hierarchical,
or phylogenetic structure. Ecography. 40: 913-929.
</p>
<p>Telford, R.J., Birks, H.J.B., (2009). Evaluation of transfer functions in spatially structured environments. Quat. Sci. Rev. 28, 1309-1316.
</p>
<p>Valavi, R., Elith, J., Lahoz-Monfort, J. J., &amp; Guillera-Arroita, G. (2019). blockCV: An R package for generating spatially or environmentally separated folds for k-fold cross-validation of species distribution models. Methods in Ecology and Evolution, 10(2), 225-232. doi:10.1111/2041-210X.13107.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv_spatial">cv_spatial</a></code>, <code><a href="#topic+cv_cluster">cv_cluster</a></code>, <code><a href="#topic+cv_buffer">cv_buffer</a></code>, and <code><a href="#topic+cv_nndm">cv_nndm</a></code> for blocking strategies.
</p>

<hr>
<h2 id='buffering'>Use distance (buffer) around records to separate train and test folds</h2><span id='topic+buffering'></span>

<h3>Description</h3>

<p>This function is deprecated and will be removed in future updates! Please use <code><a href="#topic+cv_buffer">cv_buffer</a></code> instead!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buffering(
  speciesData,
  species = NULL,
  theRange,
  spDataType = "PA",
  addBG = TRUE,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buffering_+3A_speciesdata">speciesData</code></td>
<td>
<p>A simple features (sf) or SpatialPoints object containing species data (response variable).</p>
</td></tr>
<tr><td><code id="buffering_+3A_species">species</code></td>
<td>
<p>Character. Indicating the name of the field in which species data (binary response i.e. 0 and 1) is stored. If <code>speceis = NULL</code>
the presence and absence data (response variable) will be treated the same and only training and testing records will be counted. This can be used for multi-class responses
such as land cover classes for remote sensing image classification, but it is not necessary. <em>Do not use this argument when the response variable is
continuous or count data</em>.</p>
</td></tr>
<tr><td><code id="buffering_+3A_therange">theRange</code></td>
<td>
<p>Numeric value of the specified range by which the training and testing datasets are separated.
This distance should be in <strong><em>metres</em></strong> no matter what the coordinate system is. The range can  be explored by <code><a href="#topic+spatialAutoRange">spatialAutoRange</a></code>.</p>
</td></tr>
<tr><td><code id="buffering_+3A_spdatatype">spDataType</code></td>
<td>
<p>Character input indicating the type of species data. It can take two values, <strong>PA</strong> for <em>presence-absence</em> data and <strong>PB</strong> for
<em>presence-background</em> data, when <code>species</code> argument is not <code>NULL</code>. See the details section for more information on these two approaches.</p>
</td></tr>
<tr><td><code id="buffering_+3A_addbg">addBG</code></td>
<td>
<p>Logical. Add background points to the test set when <code>spDataType = "PB"</code>.</p>
</td></tr>
<tr><td><code id="buffering_+3A_progress">progress</code></td>
<td>
<p>Logical. If TRUE a progress bar will be shown.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+cv_buffer">cv_buffer</a></code>
</p>

<hr>
<h2 id='cv_block_size'>Explore spatial block size</h2><span id='topic+cv_block_size'></span>

<h3>Description</h3>

<p>This function assists selection of block size. It allows the user to visualise the blocks
interactively, viewing the impact of block size on number and arrangement of blocks in
the landscape (and optionally on the distribution of species data in those blocks).
Slide to the selected block size, and click <em>Apply Changes</em> to change the block size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_block_size(r, x = NULL, column = NULL, min_size = NULL, max_size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_block_size_+3A_r">r</code></td>
<td>
<p>a terra SpatRaster object (optional). If provided, its extent will be used to specify the blocks.
It also supports <em>stars</em>, <em>raster</em>, or path to a raster file on disk.</p>
</td></tr>
<tr><td><code id="cv_block_size_+3A_x">x</code></td>
<td>
<p>a simple features (sf) or SpatialPoints object of spatial sample data. If <code>r</code> is supplied, this
is only added to the plot. Otherwise, the extent of <code>x</code> is used for creating the blocks.</p>
</td></tr>
<tr><td><code id="cv_block_size_+3A_column">column</code></td>
<td>
<p>character (optional). Indicating the name of the column in which response variable (e.g.
species data as a binary response i.e. 0s and 1s) is stored to be shown on the plot.</p>
</td></tr>
<tr><td><code id="cv_block_size_+3A_min_size">min_size</code></td>
<td>
<p>numeric; the minimum size of the blocks (in metres) to explore.</p>
</td></tr>
<tr><td><code id="cv_block_size_+3A_max_size">max_size</code></td>
<td>
<p>numeric; the maximum size of the blocks (in metres) to explore.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an interactive shiny session
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(interactive()){
library(blockCV)

# import presence-absence species data
points &lt;- read.csv(system.file("extdata/", "species.csv", package = "blockCV"))
pa_data &lt;- sf::st_as_sf(points, coords = c("x", "y"), crs = 7845)

# manually choose the size of spatial blocks
cv_block_size(x = pa_data,
              column = "occ",
              min_size = 2e5,
              max_size = 9e5)

}


</code></pre>

<hr>
<h2 id='cv_buffer'>Use buffer around records to separate train and test folds (a.k.a. buffered/spatial leave-one-out)</h2><span id='topic+cv_buffer'></span>

<h3>Description</h3>

<p>This function generates spatially separated train and test folds by considering buffers of
the specified distance (<code>size</code> parameter) around each observation point.
This approach is a form of <em>leave-one-out</em> cross-validation. Each fold is generated by excluding
nearby observations around each testing point within the specified distance (ideally the range of
spatial autocorrelation, see <code><a href="#topic+cv_spatial_autocor">cv_spatial_autocor</a></code>). In this method, the testing set never
directly abuts a training sample (e.g. presence or absence; 0s and 1s). For more information see the details section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_buffer(
  x,
  column = NULL,
  size,
  presence_bg = FALSE,
  add_bg = FALSE,
  progress = TRUE,
  report = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_buffer_+3A_x">x</code></td>
<td>
<p>a simple features (sf) or SpatialPoints object of spatial sample data (e.g., species data or ground truth sample for image classification).</p>
</td></tr>
<tr><td><code id="cv_buffer_+3A_column">column</code></td>
<td>
<p>character; indicating the name of the column in which response variable (e.g. species data as a binary
response i.e. 0s and 1s) is stored. This is required when <code>presence_bg = TRUE</code>, otherwise optional.</p>
</td></tr>
<tr><td><code id="cv_buffer_+3A_size">size</code></td>
<td>
<p>numeric value of the specified range by which training/testing data are separated.
This distance should be in <strong>metres</strong>. The range could be explored by <code><a href="#topic+cv_spatial_autocor">cv_spatial_autocor</a></code>.</p>
</td></tr>
<tr><td><code id="cv_buffer_+3A_presence_bg">presence_bg</code></td>
<td>
<p>logical; whether to treat data as species presence-background data. For all other data
types (presence-absence, continuous, count or multi-class responses), this option should be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cv_buffer_+3A_add_bg">add_bg</code></td>
<td>
<p>logical; add background points to the test set when <code>presence_bg = TRUE</code>. We do not
recommend this according to Radosavljevic &amp; Anderson (2014). Keep it <code>FALSE</code>, unless you mean to add
the background pints to testing points.</p>
</td></tr>
<tr><td><code id="cv_buffer_+3A_progress">progress</code></td>
<td>
<p>logical; whether to shows a progress bar.</p>
</td></tr>
<tr><td><code id="cv_buffer_+3A_report">report</code></td>
<td>
<p>logical; whether to generate print summary of records in each fold; for very big
datasets, set to <code>FALSE</code> for faster calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When working with presence-background (presence and pseudo-absence) species distribution
data (should be specified by <code>presence_bg = TRUE</code> argument), only presence records are used
for specifying the folds (recommended). Consider a target presence point. The buffer is defined around this target point,
using the specified range (<code>size</code>). By default, the testing fold comprises only the target presence point (all background
points within the buffer are also added when <code>add_bg = TRUE</code>).
Any non-target presence points inside the buffer are excluded.
All points (presence and background) outside of buffer are used for the training set.
The methods cycles through all the <em>presence</em> data, so the number of folds is equal to
the number of presence points in the dataset.
</p>
<p>For presence-absence data (and all other types of data), folds are created based on all records, both
presences and absences. As above, a target observation (presence or absence) forms a test point, all
presence and absence points other than the target point within the buffer are ignored, and the training
set comprises all presences and absences outside the buffer. Apart from the folds, the number
of <em>training-presence</em>, <em>training-absence</em>, <em>testing-presence</em> and <em>testing-absence</em>
records is stored and returned in the <code>records</code> table. If <code>column = NULL</code> and <code>presence_bg = FALSE</code>,
the procedure is like presence-absence data. All other data types (continuous, count or multi-class responses) should be
done by <code>presence_bg = FALSE</code>.
</p>


<h3>Value</h3>

<p>An object of class S3. A list of objects including:
</p>

<ul>
<li><p>folds_list - a list containing the folds. Each fold has two vectors with the training (first) and testing (second) indices
</p>
</li>
<li><p>k - number of the folds
</p>
</li>
<li><p>size - the defined range of spatial autocorrelation)
</p>
</li>
<li><p>column - the name of the column if provided
</p>
</li>
<li><p>presence_bg - whether this was treated as presence-background data
</p>
</li>
<li><p>records - a table with the number of points in each category of training and testing
</p>
</li></ul>



<h3>References</h3>

<p>Radosavljevic, A., &amp; Anderson, R. P. (2014). Making better Maxent models of species
distributions: Complexity, overfitting and evaluation. Journal of Biogeography, 41, 629–643. https://doi.org/10.1111/jbi.12227
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv_nndm">cv_nndm</a></code>, <code><a href="#topic+cv_spatial">cv_spatial</a></code>, and <code><a href="#topic+cv_spatial_autocor">cv_spatial_autocor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(blockCV)

# import presence-absence species data
points &lt;- read.csv(system.file("extdata/", "species.csv", package = "blockCV"))
# make an sf object from data.frame
pa_data &lt;- sf::st_as_sf(points, coords = c("x", "y"), crs = 7845)

bloo &lt;- cv_buffer(x = pa_data,
                  column = "occ",
                  size = 350000, # size in metres no matter the CRS
                  presence_bg = FALSE)


</code></pre>

<hr>
<h2 id='cv_cluster'>Use environmental or spatial clustering to separate train and test folds</h2><span id='topic+cv_cluster'></span>

<h3>Description</h3>

<p>This function uses clustering methods to specify sets of similar environmental
conditions based on the input covariates, or cluster of spatial coordinates of the sample data.
Sample data (i.e. species data) corresponding to any of
these groups or clusters are assigned to a fold. Clustering is done
using <code><a href="stats.html#topic+kmeans">kmeans</a></code> for both approaches. The only requirement is <code>x</code> that leads to
a clustering of the confidantes of sample data. Otherwise, by providing <code>r</code>, environmental
clustering is done.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_cluster(
  x,
  column = NULL,
  r = NULL,
  k = 5L,
  scale = TRUE,
  raster_cluster = FALSE,
  num_sample = 10000L,
  biomod2 = TRUE,
  report = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_cluster_+3A_x">x</code></td>
<td>
<p>a simple features (sf) or SpatialPoints object of spatial sample data (e.g., species data or ground truth sample for image classification).</p>
</td></tr>
<tr><td><code id="cv_cluster_+3A_column">column</code></td>
<td>
<p>character (optional). Indicating the name of the column in which response variable (e.g. species data as a binary
response i.e. 0s and 1s) is stored. This is only used to see whether all the folds contain all the classes in the final report.</p>
</td></tr>
<tr><td><code id="cv_cluster_+3A_r">r</code></td>
<td>
<p>a terra SpatRaster object of covariates to identify environmental groups. If provided, clustering will be done
in environmental space rather than spatial coordinates of sample points.</p>
</td></tr>
<tr><td><code id="cv_cluster_+3A_k">k</code></td>
<td>
<p>integer value. The number of desired folds for cross-validation. The default is <code>k = 5</code>.</p>
</td></tr>
<tr><td><code id="cv_cluster_+3A_scale">scale</code></td>
<td>
<p>logical; whether to scale the input rasters (recommended) for clustering.</p>
</td></tr>
<tr><td><code id="cv_cluster_+3A_raster_cluster">raster_cluster</code></td>
<td>
<p>logical; if <code>TRUE</code>, the clustering is done over the entire raster layer,
otherwise it will be over the extracted raster values of the sample points. See details for more information.</p>
</td></tr>
<tr><td><code id="cv_cluster_+3A_num_sample">num_sample</code></td>
<td>
<p>integer; the number of samples from raster layers to build the clusters (when <code>raster_cluster = FALSE</code>).</p>
</td></tr>
<tr><td><code id="cv_cluster_+3A_biomod2">biomod2</code></td>
<td>
<p>logical. Creates a matrix of folds that can be directly used in the <span class="pkg">biomod2</span> package as
a <em>data.split.table</em> for cross-validation.</p>
</td></tr>
<tr><td><code id="cv_cluster_+3A_report">report</code></td>
<td>
<p>logical; whether to print the report of the records per fold.</p>
</td></tr>
<tr><td><code id="cv_cluster_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>stats::kmeans</code> function, e.g. <code>algorithm = "MacQueen"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As k-means algorithms use Euclidean distance to estimate clusters, the input raster covariates should be quantitative variables.
Since variables with wider ranges of values might dominate the clusters and bias the environmental clustering (Hastie et al., 2009),
all the input rasters are first scaled and centred (<code>scale = TRUE</code>) within the function.
</p>
<p>If <code>raster_cluster = TRUE</code>, the clustering is done in the raster space. In this approach the clusters will be consistent throughout the region
and different sample datasets in the same region (for comparison). However, this may result in a cluster(s)
that covers none of the species records (the spatial location of response samples),
especially when species data is not dispersed throughout the region or the number of clusters (k or folds) is high. In this
case, the number of folds is less than specified <code>k</code>. If <code>raster_cluster = FALSE</code>, the clustering will be done in
species points and the number of the folds will be the same as <code>k</code>.
</p>
<p>Note that the input raster layer should cover all the species points, otherwise an error will rise. The records with no raster
value should be deleted prior to the analysis or another raster layer must be provided.
</p>


<h3>Value</h3>

<p>An object of class S3. A list of objects including:
</p>

<ul>
<li><p>folds_list - a list containing the folds. Each fold has two vectors with the training (first) and testing (second) indices
</p>
</li>
<li><p>folds_ids - a vector of values indicating the number of the fold for each observation (each number corresponds to the same point in x)
</p>
</li>
<li><p>biomod_table - a matrix with the folds to be used in <span class="pkg">biomod2</span> package
</p>
</li>
<li><p>k - number of the folds
</p>
</li>
<li><p>column - the name of the column if provided
</p>
</li>
<li><p>type - indicates whether spatial or environmental clustering was done.
</p>
</li>
<li><p>records - a table with the number of points in each category of training and testing
</p>
</li></ul>



<h3>References</h3>

<p>Hastie, T., Tibshirani, R., &amp; Friedman, J. (2009). The elements of statistical learning: Data mining, inference, and prediction ( 2nd ed., Vol. 1).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv_buffer">cv_buffer</a></code> and <code><a href="#topic+cv_spatial">cv_spatial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(blockCV)

# import presence-absence species data
points &lt;- read.csv(system.file("extdata/", "species.csv", package = "blockCV"))
# make an sf object from data.frame
pa_data &lt;- sf::st_as_sf(points, coords = c("x", "y"), crs = 7845)

# load raster data
path &lt;- system.file("extdata/au/", package = "blockCV")
files &lt;- list.files(path, full.names = TRUE)
covars &lt;- terra::rast(files)

# spatial clustering
set.seed(6)
sc &lt;- cv_cluster(x = pa_data,
                 column = "occ", # optional; name of the column with response
                 k = 5)

# environmental clustering
set.seed(6)
ec &lt;- cv_cluster(r = covars, # if provided will be used for environmental clustering
                 x = pa_data,
                 column = "occ", # optional; name of the column with response
                 k = 5,
                 scale = TRUE)


</code></pre>

<hr>
<h2 id='cv_nndm'>Use the Nearest Neighbour Distance Matching (NNDM) to separate train and test folds</h2><span id='topic+cv_nndm'></span>

<h3>Description</h3>

<p>A fast implementation of the Nearest Neighbour Distance Matching (NNDM) algorithm (Milà et al., 2022) in C++. Similar
to <code><a href="#topic+cv_buffer">cv_buffer</a></code>, this is a variation of leave-one-out (LOO) cross-validation. It tries to match the
nearest neighbour distance distribution function between the test and training data to the nearest neighbour
distance distribution function between the target prediction and training points (Milà et al., 2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_nndm(
  x,
  column = NULL,
  r,
  size,
  num_sample = 10000,
  sampling = "random",
  min_train = 0.05,
  presence_bg = FALSE,
  add_bg = FALSE,
  plot = TRUE,
  report = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_nndm_+3A_x">x</code></td>
<td>
<p>a simple features (sf) or SpatialPoints object of spatial sample data (e.g., species
data or ground truth sample for image classification).</p>
</td></tr>
<tr><td><code id="cv_nndm_+3A_column">column</code></td>
<td>
<p>character; indicating the name of the column in which response variable (e.g. species data as a binary
response i.e. 0s and 1s) is stored. This is required when <code>presence_bg = TRUE</code>, otherwise optional.</p>
</td></tr>
<tr><td><code id="cv_nndm_+3A_r">r</code></td>
<td>
<p>a terra SpatRaster object of a predictor variable. This defines the area that model is going to predict.</p>
</td></tr>
<tr><td><code id="cv_nndm_+3A_size">size</code></td>
<td>
<p>numeric value of the range of spatial autocorrelation (the <code>phi</code> parameter).
This distance should be in <strong>metres</strong>. The range could be explored by <code><a href="#topic+cv_spatial_autocor">cv_spatial_autocor</a></code>.</p>
</td></tr>
<tr><td><code id="cv_nndm_+3A_num_sample">num_sample</code></td>
<td>
<p>integer; the number of sample points from predictor (<code>r</code>) to be used for calculating
the G function of prediction points.</p>
</td></tr>
<tr><td><code id="cv_nndm_+3A_sampling">sampling</code></td>
<td>
<p>either <code>"random"</code> or <code>"regular"</code> for sampling prediction points.
When  <code>sampling = "regular"</code>, the actual number of samples might be less than <code>num_sample</code>
for non-rectangular rasters (points falling on no-value areas are removed).</p>
</td></tr>
<tr><td><code id="cv_nndm_+3A_min_train">min_train</code></td>
<td>
<p>numeric; between 0 and 1. A constraint on the minimum proportion of train points in each fold.</p>
</td></tr>
<tr><td><code id="cv_nndm_+3A_presence_bg">presence_bg</code></td>
<td>
<p>logical; whether to treat data as species presence-background data. For all other data
types (presence-absence, continuous, count or multi-class responses), this option should be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cv_nndm_+3A_add_bg">add_bg</code></td>
<td>
<p>logical; add background points to the test set when <code>presence_bg = TRUE</code>. We do not
recommend this according to Radosavljevic &amp; Anderson (2014). Keep it <code>FALSE</code>, unless you mean to add
the background pints to testing points.</p>
</td></tr>
<tr><td><code id="cv_nndm_+3A_plot">plot</code></td>
<td>
<p>logical; whether to plot the G functions.</p>
</td></tr>
<tr><td><code id="cv_nndm_+3A_report">report</code></td>
<td>
<p>logical; whether to generate print summary of records in each fold; for very big
datasets, set to <code>FALSE</code> for slightly faster calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When working with presence-background (presence and pseudo-absence) species distribution
data (should be specified by <code>presence_bg = TRUE</code> argument), only presence records are used
for specifying the folds (recommended). The testing fold comprises only the target <em>presence</em> point (optionally,
all background points within the distance are also included when <code>add_bg = TRUE</code>; this is the
distance that matches the nearest neighbour distance distribution function of training-testing presences and
training-presences and prediction points; often lower than <code>size</code>).
Any non-target presence points inside the distance are excluded.
All points (presence and background) outside of distance are used for the training set.
The methods cycles through all the presence data, so the number of folds is equal to
the number of presence points in the dataset.
</p>
<p>For all other types of data (including presence-absence, count, continuous, and multi-class)
set <code>presence_bg = FALE</code>, and the function behaves similar to the methods
explained by Milà and colleagues (2022).
</p>


<h3>Value</h3>

<p>An object of class S3. A list of objects including:
</p>

<ul>
<li><p>folds_list - a list containing the folds. Each fold has two vectors with the training (first) and testing (second) indices
</p>
</li>
<li><p>k - number of the folds
</p>
</li>
<li><p>size - the distance band to separated trainig and testing folds)
</p>
</li>
<li><p>column - the name of the column if provided
</p>
</li>
<li><p>presence_bg - whether this was treated as presence-background data
</p>
</li>
<li><p>records - a table with the number of points in each category of training and testing
</p>
</li></ul>



<h3>References</h3>

<p>C. Milà, J. Mateu, E. Pebesma, and H. Meyer, Nearest Neighbour Distance Matching
Leave-One-Out Cross-Validation for map validation, Methods in Ecology and Evolution (2022).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv_buffer">cv_buffer</a></code> and <code><a href="#topic+cv_spatial_autocor">cv_spatial_autocor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(blockCV)

# import presence-absence species data
points &lt;- read.csv(system.file("extdata/", "species.csv", package = "blockCV"))
# make an sf object from data.frame
pa_data &lt;- sf::st_as_sf(points, coords = c("x", "y"), crs = 7845)

# load raster data
path &lt;- system.file("extdata/au/bio_5.tif", package = "blockCV")
covar &lt;- terra::rast(path)

nndm &lt;- cv_nndm(x = pa_data,
                column = "occ", # optional
                r = covar,
                size = 350000, # size in metres no matter the CRS
                num_sample = 10000,
                sampling = "regular",
                min_train = 0.1)


</code></pre>

<hr>
<h2 id='cv_plot'>Visualising folds created by blockCV in ggplot</h2><span id='topic+cv_plot'></span>

<h3>Description</h3>

<p>This function visualises the folds create by blockCV. It also accepts a raster
layer to be used as background in the output plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_plot(
  cv,
  x,
  r = NULL,
  nrow = NULL,
  ncol = NULL,
  num_plots = 1:10,
  max_pixels = 3e+05,
  remove_na = TRUE,
  raster_colors = gray.colors(10, alpha = 1),
  points_colors = c("#E69F00", "#56B4E9"),
  points_alpha = 0.7,
  label_size = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_plot_+3A_cv">cv</code></td>
<td>
<p>a blockCV cv_* object; a <code>cv_spatial</code>, <code>cv_cluster</code>, <code>cv_buffer</code>
or <code>cv_nndm</code></p>
</td></tr>
<tr><td><code id="cv_plot_+3A_x">x</code></td>
<td>
<p>a simple features (sf) or SpatialPoints object of the spatial sample data used for creating
the <code>cv</code> object. This could be empty when <code>cv</code> is a <code>cv_spatial</code> object.</p>
</td></tr>
<tr><td><code id="cv_plot_+3A_r">r</code></td>
<td>
<p>a terra SpatRaster object (optional). If provided, it will be used as background of the plots.
It also supports <em>stars</em>, <em>raster</em>, or path to a raster file on disk.</p>
</td></tr>
<tr><td><code id="cv_plot_+3A_nrow">nrow</code></td>
<td>
<p>integer; number of rows for facet plot</p>
</td></tr>
<tr><td><code id="cv_plot_+3A_ncol">ncol</code></td>
<td>
<p>integer; number of columns for facet plot</p>
</td></tr>
<tr><td><code id="cv_plot_+3A_num_plots">num_plots</code></td>
<td>
<p>a vector of indices of folds; by default the first 10 are shown (if available).
You can choose any of the folds to be shown e.g. <code>1:3</code> or <code>c(2, 7, 16, 22)</code></p>
</td></tr>
<tr><td><code id="cv_plot_+3A_max_pixels">max_pixels</code></td>
<td>
<p>integer; maximum number of pixels used for plotting <code>r</code></p>
</td></tr>
<tr><td><code id="cv_plot_+3A_remove_na">remove_na</code></td>
<td>
<p>logical; whether to remove excluded points in <code>cv_buffer</code> from the plot</p>
</td></tr>
<tr><td><code id="cv_plot_+3A_raster_colors">raster_colors</code></td>
<td>
<p>character; a character vector of colours for raster background e.g. <code>terrain.colors(20)</code></p>
</td></tr>
<tr><td><code id="cv_plot_+3A_points_colors">points_colors</code></td>
<td>
<p>character; two colours to be used for train and test points</p>
</td></tr>
<tr><td><code id="cv_plot_+3A_points_alpha">points_alpha</code></td>
<td>
<p>numeric; the opacity of points</p>
</td></tr>
<tr><td><code id="cv_plot_+3A_label_size">label_size</code></td>
<td>
<p>integer; size of fold labels when a <code>cv_spatial</code> object is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(blockCV)

# import presence-absence species data
points &lt;- read.csv(system.file("extdata/", "species.csv", package = "blockCV"))
pa_data &lt;- sf::st_as_sf(points, coords = c("x", "y"), crs = 7845)

# spatial clustering
sc &lt;- cv_cluster(x = pa_data, k = 5)

# now plot the create folds
cv_plot(cv = sc,
        x = pa_data, # sample points
        nrow = 2,
        points_alpha = 0.5)


</code></pre>

<hr>
<h2 id='cv_similarity'>Compute similarity measures to evaluate possible extrapolation in testing folds</h2><span id='topic+cv_similarity'></span>

<h3>Description</h3>

<p>This function computes multivariate environmental similarity surface (MESS) as described
in Elith et al. (2010). MESS represents how similar a point in a testing fold is to a training
fold (as a reference set of points), with respect to a set of predictor variables in <code>r</code>.
The negative values are the sites where at least one variable has a value that is outside
the range of environments over the reference set, so these are novel environments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_similarity(
  cv,
  x,
  r,
  num_plot = seq_along(cv$folds_list),
  jitter_width = 0.1,
  points_size = 2,
  points_alpha = 0.7,
  points_colors = NULL,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_similarity_+3A_cv">cv</code></td>
<td>
<p>a blockCV cv_* object; a <code>cv_spatial</code>, <code>cv_cluster</code>, <code>cv_buffer</code>
or <code>cv_nndm</code></p>
</td></tr>
<tr><td><code id="cv_similarity_+3A_x">x</code></td>
<td>
<p>a simple features (sf) or SpatialPoints object of the spatial sample data used for creating
the <code>cv</code> object.</p>
</td></tr>
<tr><td><code id="cv_similarity_+3A_r">r</code></td>
<td>
<p>a terra SpatRaster object of environmental predictor that are going to be used for modelling. This
is used to calculate similarity between the training and testing points.</p>
</td></tr>
<tr><td><code id="cv_similarity_+3A_num_plot">num_plot</code></td>
<td>
<p>a vector of indices of folds.</p>
</td></tr>
<tr><td><code id="cv_similarity_+3A_jitter_width">jitter_width</code></td>
<td>
<p>numeric; the width of jitter points.</p>
</td></tr>
<tr><td><code id="cv_similarity_+3A_points_size">points_size</code></td>
<td>
<p>numeric; the size of points.</p>
</td></tr>
<tr><td><code id="cv_similarity_+3A_points_alpha">points_alpha</code></td>
<td>
<p>numeric; the opacity of points</p>
</td></tr>
<tr><td><code id="cv_similarity_+3A_points_colors">points_colors</code></td>
<td>
<p>character; a character vector of colours for points</p>
</td></tr>
<tr><td><code id="cv_similarity_+3A_progress">progress</code></td>
<td>
<p>logical; whether to shows a progress bar for random fold selection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(blockCV)

# import presence-absence species data
points &lt;- read.csv(system.file("extdata/", "species.csv", package = "blockCV"))
# make an sf object from data.frame
pa_data &lt;- sf::st_as_sf(points, coords = c("x", "y"), crs = 7845)

# load raster data
path &lt;- system.file("extdata/au/", package = "blockCV")
files &lt;- list.files(path, full.names = TRUE)
covars &lt;- terra::rast(files)

# hexagonal spatial blocking by specified size and random assignment
sb &lt;- cv_spatial(x = pa_data,
                 column = "occ",
                 size = 450000,
                 k = 5,
                 iteration = 1)

# compute extrapolation
cv_similarity(cv = sb, r = covars, x = pa_data)


</code></pre>

<hr>
<h2 id='cv_spatial'>Use spatial blocks to separate train and test folds</h2><span id='topic+cv_spatial'></span>

<h3>Description</h3>

<p>This function creates spatially separated folds based on a distance to number of row and/or column.
It assigns blocks to the training and testing folds <strong>randomly</strong>, <strong>systematically</strong> or
in a <strong>checkerboard pattern</strong>. The distance (<code>size</code>)
should be in <strong>metres</strong>, regardless of the unit of the reference system of
the input data (for more information see the details section). By default,
the function creates blocks according to the extent and shape of the spatial sample data (<code>x</code> e.g.
the species occurrence), Alternatively, blocks can be created based on <code>r</code> assuming that the
user has considered the landscape for the given species and case study.
Blocks can also be offset so the origin is not at the outer corner of the rasters.
Instead of providing a distance, the blocks can also be created by specifying a number of rows and/or
columns and divide the study area into vertical or horizontal bins, as presented in Wenger &amp; Olden (2012)
and Bahn &amp; McGill (2012). Finally, the blocks can be specified by a user-defined spatial polygon layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_spatial(
  x,
  column = NULL,
  r = NULL,
  k = 5L,
  hexagon = TRUE,
  flat_top = FALSE,
  size = NULL,
  rows_cols = c(10, 10),
  selection = "random",
  iteration = 100L,
  user_blocks = NULL,
  folds_column = NULL,
  deg_to_metre = 111325,
  biomod2 = TRUE,
  offset = c(0, 0),
  extend = 0,
  seed = NULL,
  progress = TRUE,
  report = TRUE,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_spatial_+3A_x">x</code></td>
<td>
<p>a simple features (sf) or SpatialPoints object of spatial sample data (e.g., species data or ground truth sample for image classification).</p>
</td></tr>
<tr><td><code id="cv_spatial_+3A_column">column</code></td>
<td>
<p>character (optional). Indicating the name of the column in which response variable (e.g. species data as a binary
response i.e. 0s and 1s) is stored to find balanced records in cross-validation folds. If <code>column = NULL</code>
the response variable classes will be treated the same and only training and testing records will be counted.
This is used for binary (e.g. presence-absence/background) or multi-class responses (e.g. land cover classes for
remote sensing image classification), and <em>you can ignore it when the response variable is
continuous or count data</em>.</p>
</td></tr>
<tr><td><code id="cv_spatial_+3A_r">r</code></td>
<td>
<p>a terra SpatRaster object (optional). If provided, its extent will be used to specify the blocks.
It also supports <em>stars</em>, <em>raster</em>, or path to a raster file on disk.</p>
</td></tr>
<tr><td><code id="cv_spatial_+3A_k">k</code></td>
<td>
<p>integer value. The number of desired folds for cross-validation. The default is <code>k = 5</code>.</p>
</td></tr>
<tr><td><code id="cv_spatial_+3A_hexagon">hexagon</code></td>
<td>
<p>logical. Creates hexagonal (default) spatial blocks. If <code>FALSE</code>, square blocks is created.</p>
</td></tr>
<tr><td><code id="cv_spatial_+3A_flat_top">flat_top</code></td>
<td>
<p>logical. Creating hexagonal blocks with topped flat.</p>
</td></tr>
<tr><td><code id="cv_spatial_+3A_size">size</code></td>
<td>
<p>numeric value of the specified range by which blocks are created and training/testing data are separated.
This distance should be in <strong>metres</strong>. The range could be explored by <code><a href="#topic+cv_spatial_autocor">cv_spatial_autocor</a></code>
and <code><a href="#topic+cv_block_size">cv_block_size</a></code> functions.</p>
</td></tr>
<tr><td><code id="cv_spatial_+3A_rows_cols">rows_cols</code></td>
<td>
<p>integer vector. Two integers to define the blocks based on row and
column e.g. <code>c(10, 10)</code> or <code>c(5, 1)</code>. Hexagonal blocks uses only the first one. This
option is ignored when <code>size</code> is provided.</p>
</td></tr>
<tr><td><code id="cv_spatial_+3A_selection">selection</code></td>
<td>
<p>type of assignment of blocks into folds. Can be <strong>random</strong> (default), <strong>systematic</strong>, <strong>checkerboard</strong>, or <strong>predefined</strong>.
The checkerboard does not work with hexagonal and user-defined spatial blocks. If the <code>selection = 'predefined'</code>, user-defined
blocks and <code>folds_column</code> must be supplied.</p>
</td></tr>
<tr><td><code id="cv_spatial_+3A_iteration">iteration</code></td>
<td>
<p>integer value. The number of attempts to create folds with balanced records. Only works when <code>selection = "random"</code>.</p>
</td></tr>
<tr><td><code id="cv_spatial_+3A_user_blocks">user_blocks</code></td>
<td>
<p>an sf or SpatialPolygons object to be used as the blocks (optional). This can be a user defined polygon and it must cover all
the species (response) points. If <code>selection = 'predefined'</code>, this argument and <strong>folds_column</strong> must be supplied.</p>
</td></tr>
<tr><td><code id="cv_spatial_+3A_folds_column">folds_column</code></td>
<td>
<p>character. Indicating the name of the column (in <code>user_blocks</code>) in which the associated folds are stored.
This argument is necessary if you choose the 'predefined' selection.</p>
</td></tr>
<tr><td><code id="cv_spatial_+3A_deg_to_metre">deg_to_metre</code></td>
<td>
<p>integer. The conversion rate of metres to degree. See the details section for more information.</p>
</td></tr>
<tr><td><code id="cv_spatial_+3A_biomod2">biomod2</code></td>
<td>
<p>logical. Creates a matrix of folds that can be directly used in the <span class="pkg">biomod2</span> package as
a <em>data.split.table</em> for cross-validation.</p>
</td></tr>
<tr><td><code id="cv_spatial_+3A_offset">offset</code></td>
<td>
<p>two number between 0 and 1 to shift blocks by that proportion of block size.
This option only works when <code>size</code> is provided.</p>
</td></tr>
<tr><td><code id="cv_spatial_+3A_extend">extend</code></td>
<td>
<p>numeric; This parameter specifies the percentage by which the map's extent is
expanded to increase the size of the square spatial blocks, ensuring that all points fall
within a block. The value should be a numeric between 0 and 5.</p>
</td></tr>
<tr><td><code id="cv_spatial_+3A_seed">seed</code></td>
<td>
<p>integer; a random seed for reproducibility (although an external seed
should also work).</p>
</td></tr>
<tr><td><code id="cv_spatial_+3A_progress">progress</code></td>
<td>
<p>logical; whether to shows a progress bar for random fold selection.</p>
</td></tr>
<tr><td><code id="cv_spatial_+3A_report">report</code></td>
<td>
<p>logical; whether to print the report of the records per fold.</p>
</td></tr>
<tr><td><code id="cv_spatial_+3A_plot">plot</code></td>
<td>
<p>logical; whether to plot the final blocks with fold numbers in ggplot.
You can re-create this with <code><a href="#topic+cv_plot">cv_plot</a></code>.</p>
</td></tr>
<tr><td><code id="cv_spatial_+3A_...">...</code></td>
<td>
<p>additional option for <code><a href="#topic+cv_plot">cv_plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To maintain consistency, all functions in this package use <strong>meters</strong> as their unit of
measurement. However, when the input map has a geographic coordinate system (in decimal degrees),
the block size is calculated by dividing the <code>size</code> parameter by <code>deg_to_metre</code> (which
defaults to 111325 meters, the standard distance of one degree of latitude on the Equator).
In reality, this value varies by a factor of the cosine of the latitude. So, an alternative sensible
value could be <code>cos(mean(sf::st_bbox(x)[c(2,4)]) * pi/180) * 111325</code>.
</p>
<p>The <code>offset</code> can be used to change the spatial position of the blocks. It can also be used to
assess the sensitivity of analysis results to shifting in the blocking arrangements.
These options are available when <code>size</code> is defined. By default the region is
located in the middle of the blocks and by setting the offsets, the blocks will shift.
</p>
<p>Roberts et. al. (2017) suggest that blocks should be substantially bigger than the range of spatial
autocorrelation (in model residual) to obtain realistic error estimates, while a buffer with the size of
the spatial autocorrelation range would result in a good estimation of error. This is because of the so-called
edge effect (O'Sullivan &amp; Unwin, 2014), whereby points located on the edges of the blocks of opposite sets are
not separated spatially. Blocking with a buffering strategy overcomes this issue (see <code><a href="#topic+cv_buffer">cv_buffer</a></code>).
</p>


<h3>Value</h3>

<p>An object of class S3. A list of objects including:
</p>

<ul>
<li><p>folds_list - a list containing the folds. Each fold has two vectors with the training (first) and testing (second) indices
</p>
</li>
<li><p>folds_ids - a vector of values indicating the number of the fold for each observation (each number corresponds to the same point in species data)
</p>
</li>
<li><p>biomod_table - a matrix with the folds to be used in <span class="pkg">biomod2</span> package
</p>
</li>
<li><p>k - number of the folds
</p>
</li>
<li><p>size - input size, if not null
</p>
</li>
<li><p>column - the name of the column if provided
</p>
</li>
<li><p>blocks - spatial polygon of the blocks
</p>
</li>
<li><p>records - a table with the number of points in each category of training and testing
</p>
</li></ul>



<h3>References</h3>

<p>Bahn, V., &amp; McGill, B. J. (2012). Testing the predictive performance of distribution models. Oikos, 122(3), 321-331.
</p>
<p>O'Sullivan, D., Unwin, D.J., (2010). Geographic Information Analysis, 2nd ed. John Wiley &amp; Sons.
</p>
<p>Roberts et al., (2017). Cross-validation strategies for data with temporal, spatial, hierarchical,
or phylogenetic structure. Ecography. 40: 913-929.
</p>
<p>Wenger, S.J., Olden, J.D., (2012). Assessing transferability of ecological models: an underappreciated aspect of statistical
validation. Methods Ecol. Evol. 3, 260-267.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv_buffer">cv_buffer</a></code> and <code><a href="#topic+cv_cluster">cv_cluster</a></code>; <code><a href="#topic+cv_spatial_autocor">cv_spatial_autocor</a></code> and <code><a href="#topic+cv_block_size">cv_block_size</a></code> for selecting block size
</p>
<p>For <em>data.split.table</em> see <code><a href="biomod2.html#topic+BIOMOD_cv">BIOMOD_cv</a></code> in <span class="pkg">biomod2</span> package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(blockCV)

# import presence-absence species data
points &lt;- read.csv(system.file("extdata/", "species.csv", package = "blockCV"))
# make an sf object from data.frame
pa_data &lt;- sf::st_as_sf(points, coords = c("x", "y"), crs = 7845)

# hexagonal spatial blocking by specified size and random assignment
sb1 &lt;- cv_spatial(x = pa_data,
                  column = "occ",
                  size = 450000,
                  k = 5,
                  selection = "random",
                  iteration = 50)

# spatial blocking by row/column and systematic fold assignment
sb2 &lt;- cv_spatial(x = pa_data,
                  column = "occ",
                  rows_cols = c(8, 10),
                  k = 5,
                  hexagon = FALSE,
                  selection = "systematic")


</code></pre>

<hr>
<h2 id='cv_spatial_autocor'>Measure spatial autocorrelation in spatial response data or predictor raster files</h2><span id='topic+cv_spatial_autocor'></span>

<h3>Description</h3>

<p>This function provides a quantitative basis for choosing block size. The spatial autocorrelation in either the
spatial sample points or all continuous predictor variables available as raster layers is assessed and reported.
The response (as defined be <code>column</code>) in spatial sample points can be binary such as species distribution data,
or continuous response like soil organic carbon. The function estimates spatial autocorrelation <em>ranges</em> of all input
raster layers or the response data. This is the range over which observations are independent and is determined by
constructing the empirical variogram, a fundamental geostatistical tool for measuring spatial autocorrelation.
The empirical variogram models the structure of spatial autocorrelation by measuring variability between all possible
pairs of points (O'Sullivan and Unwin, 2010). Results are plotted. See the details section for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_spatial_autocor(
  r,
  x,
  column = NULL,
  num_sample = 5000L,
  deg_to_metre = 111325,
  plot = TRUE,
  progress = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_spatial_autocor_+3A_r">r</code></td>
<td>
<p>a terra SpatRaster object. If provided (and <code>x</code> is missing), it will be used for to calculate range.</p>
</td></tr>
<tr><td><code id="cv_spatial_autocor_+3A_x">x</code></td>
<td>
<p>a simple features (sf) or SpatialPoints object of spatial sample data (e.g., species binary or continuous date).</p>
</td></tr>
<tr><td><code id="cv_spatial_autocor_+3A_column">column</code></td>
<td>
<p>character; indicating the name of the column in which response variable (e.g. species data as a binary
response i.e. 0s and 1s) is stored for calculating spatial autocorrelation range. This supports multiple column names.</p>
</td></tr>
<tr><td><code id="cv_spatial_autocor_+3A_num_sample">num_sample</code></td>
<td>
<p>integer; the number of sample points of each raster layer to fit variogram models. It is 5000 by default,
however it can be increased by user to represent their region well (relevant to the extent and resolution of rasters).</p>
</td></tr>
<tr><td><code id="cv_spatial_autocor_+3A_deg_to_metre">deg_to_metre</code></td>
<td>
<p>integer. The conversion rate of degrees to metres.</p>
</td></tr>
<tr><td><code id="cv_spatial_autocor_+3A_plot">plot</code></td>
<td>
<p>logical; whether to plot the results.</p>
</td></tr>
<tr><td><code id="cv_spatial_autocor_+3A_progress">progress</code></td>
<td>
<p>logical; whether to shows a progress bar.</p>
</td></tr>
<tr><td><code id="cv_spatial_autocor_+3A_...">...</code></td>
<td>
<p>additional option for <code><a href="#topic+cv_plot">cv_plot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input raster layers should be continuous for computing the variograms and estimating the range of spatial
autocorrelation. The input rasters should also have a specified coordinate reference system. However, if the reference
system is not specified, the function attempts to guess it based on the extent of the map. It assumes an un-projected
reference system for layers with extent lying between -180 and 180.
</p>
<p>Variograms are calculated based on the distances between pairs of points, so un-projected rasters (in degrees) will
not give an accurate result (especially over large latitudinal extents). For un-projected rasters, <em>the great circle distance</em>
(rather than Euclidean distance) is used to calculate the spatial distances between pairs of points. To
enable more accurate estimate, it is recommended to transform un-projected maps (geographic coordinate
system / latitude-longitude) to a projected metric reference system (e.g. UTM or Lambert) where it is possible.
See <code><a href="automap.html#topic+autofitVariogram">autofitVariogram</a></code> from <span class="pkg">automap</span> and <code><a href="gstat.html#topic+variogram">variogram</a></code> from <span class="pkg">gstat</span> packages
for further information.
</p>


<h3>Value</h3>

<p>An object of class S3. A list object including:
</p>

<ul>
<li><p>range - the suggested range (i.e. size), which is the median of all calculated ranges in case of 'r'.
</p>
</li>
<li><p>range_table - a table of input covariates names and their autocorrelation range
</p>
</li>
<li><p>plots - the output plot (the plot is shown by default)
</p>
</li>
<li><p>num_sample - number sample of 'r' used for analysis
</p>
</li>
<li><p>variograms - fitted variograms for all layers
</p>
</li></ul>



<h3>References</h3>

<p>O'Sullivan, D., Unwin, D.J., (2010). Geographic Information Analysis, 2nd ed. John Wiley &amp; Sons.
</p>
<p>Roberts et al., (2017). Cross-validation strategies for data with temporal, spatial, hierarchical,
or phylogenetic structure. Ecography. 40: 913-929.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv_block_size">cv_block_size</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(blockCV)

# import presence-absence species data
points &lt;- read.csv(system.file("extdata/", "species.csv", package = "blockCV"))
# make an sf object from data.frame
pa_data &lt;- sf::st_as_sf(points, coords = c("x", "y"), crs = 7845)

# load raster data
path &lt;- system.file("extdata/au/", package = "blockCV")
files &lt;- list.files(path, full.names = TRUE)
covars &lt;- terra::rast(files)

# spatial autocorrelation of a binary/continuous response
sac1 &lt;- cv_spatial_autocor(x = pa_data,
                           column = "occ", # binary or continuous data
                           plot = TRUE)


# spatial autocorrelation of continuous raster files
sac2 &lt;- cv_spatial_autocor(r = covars,
                           num_sample = 5000,
                           plot = TRUE)

# show the result
summary(sac2)

</code></pre>

<hr>
<h2 id='envBlock'>Use environmental clustering to separate train and test folds</h2><span id='topic+envBlock'></span>

<h3>Description</h3>

<p>This function is deprecated and will be removed in future updates! Please use <code><a href="#topic+cv_cluster">cv_cluster</a></code> instead!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>envBlock(
  rasterLayer,
  speciesData,
  species = NULL,
  k = 5,
  standardization = "normal",
  rasterBlock = TRUE,
  sampleNumber = 10000,
  biomod2Format = TRUE,
  numLimit = 0,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="envBlock_+3A_rasterlayer">rasterLayer</code></td>
<td>
<p>A raster object of covariates to identify environmental groups.</p>
</td></tr>
<tr><td><code id="envBlock_+3A_speciesdata">speciesData</code></td>
<td>
<p>A simple features (sf) or SpatialPoints object containing species data (response variable).</p>
</td></tr>
<tr><td><code id="envBlock_+3A_species">species</code></td>
<td>
<p>Character. Indicating the name of the field in which species data (binary response i.e. 0 and 1) is stored. If <code>speceis = NULL</code>
the presence and absence data (response variable) will be treated the same and only training and testing records will be counted. This can be used for multi-class responses
such as land cover classes for remote sensing image classification, but it is not necessary. <em>Do not use this argument when the response variable is
continuous or count data</em>.</p>
</td></tr>
<tr><td><code id="envBlock_+3A_k">k</code></td>
<td>
<p>Integer value. The number of desired folds for cross-validation. The default is <code>k = 5</code>.</p>
</td></tr>
<tr><td><code id="envBlock_+3A_standardization">standardization</code></td>
<td>
<p>Standardize input raster layers. Three possible inputs are &quot;normal&quot; (the default), &quot;standard&quot; and &quot;none&quot;.
See details for more information.</p>
</td></tr>
<tr><td><code id="envBlock_+3A_rasterblock">rasterBlock</code></td>
<td>
<p>Logical. If TRUE, the clustering is done in the raster layer rather than species data. See details for
more information.</p>
</td></tr>
<tr><td><code id="envBlock_+3A_samplenumber">sampleNumber</code></td>
<td>
<p>Integer. The number of samples from raster layers to build the clusters.</p>
</td></tr>
<tr><td><code id="envBlock_+3A_biomod2format">biomod2Format</code></td>
<td>
<p>Logical. Creates a matrix of folds that can be directly used in the <span class="pkg">biomod2</span> package as
a <em>DataSplitTable</em> for cross-validation.</p>
</td></tr>
<tr><td><code id="envBlock_+3A_numlimit">numLimit</code></td>
<td>
<p>Integer value. The minimum number of points in each category of data (<em>train_0</em>,
<em>train_1</em>, <em>test_0</em> and <em>test_1</em>). Shows a message if the number of points
in any of the folds happens to be less than this number.</p>
</td></tr>
<tr><td><code id="envBlock_+3A_verbose">verbose</code></td>
<td>
<p>Logical. To print the report of the recods per fold.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+cv_cluster">cv_cluster</a></code>
</p>

<hr>
<h2 id='foldExplorer'>Explore the generated folds</h2><span id='topic+foldExplorer'></span>

<h3>Description</h3>

<p>This function is deprecated! Please use <code><a href="#topic+cv_plot">cv_plot</a></code> function for plotting the folds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foldExplorer(blocks, rasterLayer, speciesData)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foldExplorer_+3A_blocks">blocks</code></td>
<td>
<p>deprecated!</p>
</td></tr>
<tr><td><code id="foldExplorer_+3A_rasterlayer">rasterLayer</code></td>
<td>
<p>deprecated!</p>
</td></tr>
<tr><td><code id="foldExplorer_+3A_speciesdata">speciesData</code></td>
<td>
<p>deprecated!</p>
</td></tr>
</table>

<hr>
<h2 id='rangeExplorer'>Explore spatial block size</h2><span id='topic+rangeExplorer'></span>

<h3>Description</h3>

<p>This function is deprecated and will be removed in future updates! Please use <code><a href="#topic+cv_block_size">cv_block_size</a></code> instead!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rangeExplorer(
  rasterLayer,
  speciesData = NULL,
  species = NULL,
  rangeTable = NULL,
  minRange = NULL,
  maxRange = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rangeExplorer_+3A_rasterlayer">rasterLayer</code></td>
<td>
<p>raster layer for make plot</p>
</td></tr>
<tr><td><code id="rangeExplorer_+3A_speciesdata">speciesData</code></td>
<td>
<p>a simple features (sf) or SpatialPoints object containing species data (response variable). If provided, the species data will be shown on the map.</p>
</td></tr>
<tr><td><code id="rangeExplorer_+3A_species">species</code></td>
<td>
<p>character value indicating the name of the field in which the species data (response variable e.g. 0s and 1s) are stored.
If provided, species presence and absence data will be shown in different colours.</p>
</td></tr>
<tr><td><code id="rangeExplorer_+3A_rangetable">rangeTable</code></td>
<td>
<p>deprecated option!</p>
</td></tr>
<tr><td><code id="rangeExplorer_+3A_minrange">minRange</code></td>
<td>
<p>a numeric value to set the minimum possible range for creating spatial blocks. It is used to limit the searching domain of
spatial block size.</p>
</td></tr>
<tr><td><code id="rangeExplorer_+3A_maxrange">maxRange</code></td>
<td>
<p>a numeric value to set the maximum possible range for creating spatial blocks. It is used to limit the searching
domain of spatial block size.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+cv_block_size">cv_block_size</a></code>
</p>

<hr>
<h2 id='spatialAutoRange'>Measure spatial autocorrelation in the predictor raster files</h2><span id='topic+spatialAutoRange'></span>

<h3>Description</h3>

<p>This function is deprecated and will be removed in future updates! Please use <code><a href="#topic+cv_spatial_autocor">cv_spatial_autocor</a></code> instead!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialAutoRange(
  rasterLayer,
  sampleNumber = 5000L,
  border = NULL,
  speciesData = NULL,
  doParallel = NULL,
  nCores = NULL,
  showPlots = TRUE,
  degMetre = 111325,
  maxpixels = 1e+05,
  plotVariograms = FALSE,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialAutoRange_+3A_rasterlayer">rasterLayer</code></td>
<td>
<p>A raster object of covariates to find spatial autocorrelation range.</p>
</td></tr>
<tr><td><code id="spatialAutoRange_+3A_samplenumber">sampleNumber</code></td>
<td>
<p>Integer. The number of sample points of each raster layer to fit variogram models. It is 5000 by default,
however it can be increased by user to represent their region well (relevant to the extent and resolution of rasters).</p>
</td></tr>
<tr><td><code id="spatialAutoRange_+3A_border">border</code></td>
<td>
<p>deprecated option!</p>
</td></tr>
<tr><td><code id="spatialAutoRange_+3A_speciesdata">speciesData</code></td>
<td>
<p>A spatial or sf object (optional). If provided, the <code>sampleNumber</code> is ignored and
variograms are created based on species locations. This option is not recommended if the species data is not
evenly distributed across the whole study area and/or the number of records is low.</p>
</td></tr>
<tr><td><code id="spatialAutoRange_+3A_doparallel">doParallel</code></td>
<td>
<p>deprecated option!</p>
</td></tr>
<tr><td><code id="spatialAutoRange_+3A_ncores">nCores</code></td>
<td>
<p>deprecated option!</p>
</td></tr>
<tr><td><code id="spatialAutoRange_+3A_showplots">showPlots</code></td>
<td>
<p>Logical. Show final plot of spatial blocks and autocorrelation ranges.</p>
</td></tr>
<tr><td><code id="spatialAutoRange_+3A_degmetre">degMetre</code></td>
<td>
<p>Numeric. The conversion rate of metres to degree. This is for constructing spatial
blocks for visualisation. When the input map is in geographic coordinate system (decimal degrees), the block size is
calculated based on deviding the calculated <em>range</em> by this value to convert to the input map's unit
(by default 111325; the standard distance of a degree in metres, on the Equator).</p>
</td></tr>
<tr><td><code id="spatialAutoRange_+3A_maxpixels">maxpixels</code></td>
<td>
<p>Number of random pixels to select the blocks over the study area.</p>
</td></tr>
<tr><td><code id="spatialAutoRange_+3A_plotvariograms">plotVariograms</code></td>
<td>
<p>deprecated option!</p>
</td></tr>
<tr><td><code id="spatialAutoRange_+3A_progress">progress</code></td>
<td>
<p>Logical. Shows progress bar. It works only when <code>doParallel = FALSE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+cv_spatial_autocor">cv_spatial_autocor</a></code>
</p>

<hr>
<h2 id='spatialBlock'>Use spatial blocks to separate train and test folds</h2><span id='topic+spatialBlock'></span>

<h3>Description</h3>

<p>This function is deprecated and will be removed in future updates! Please use <code><a href="#topic+cv_spatial">cv_spatial</a></code> instead!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialBlock(
  speciesData,
  species = NULL,
  rasterLayer = NULL,
  theRange = NULL,
  rows = NULL,
  cols = NULL,
  k = 5L,
  selection = "random",
  iteration = 100L,
  blocks = NULL,
  foldsCol = NULL,
  numLimit = 0L,
  maskBySpecies = TRUE,
  degMetre = 111325,
  border = NULL,
  showBlocks = TRUE,
  biomod2Format = TRUE,
  xOffset = 0,
  yOffset = 0,
  extend = 0,
  seed = 42,
  progress = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialBlock_+3A_speciesdata">speciesData</code></td>
<td>
<p>A simple features (sf) or SpatialPoints object containing species data (response variable).</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_species">species</code></td>
<td>
<p>Character (optional). Indicating the name of the column in which species data (response variable e.g. 0s and 1s) is stored.
This argument is used <em>to make folds with evenly distributed records</em>. <strong>This option only works by random fold selection and with binary or
multi-class responses</strong> e.g. species presence-absence/background or land cover classes for remote sensing image classification.
If <code>speceis = NULL</code> the response classes will be treated the same and only training and testing records
will be counted and balanced.</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_rasterlayer">rasterLayer</code></td>
<td>
<p>A raster object for visualisation (optional). If provided, this will be used to specify the blocks covering the area.</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_therange">theRange</code></td>
<td>
<p>Numeric value of the specified range by which blocks are created and training/testing data are separated.
This distance should be in <strong>metres</strong>. The range could be explored by <code>spatialAutoRange()</code> and <code>rangeExplorer()</code> functions.</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_rows">rows</code></td>
<td>
<p>Integer value by which the area is divided into latitudinal bins.</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_cols">cols</code></td>
<td>
<p>Integer value by which the area is divided into longitudinal bins.</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_k">k</code></td>
<td>
<p>Integer value. The number of desired folds for cross-validation. The default is <code>k = 5</code>.</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_selection">selection</code></td>
<td>
<p>Type of assignment of blocks into folds. Can be <strong>random</strong> (default), <strong>systematic</strong>, <strong>checkerboard</strong>, or <strong>predefined</strong>.
The checkerboard does not work with user-defined spatial blocks. If the selection = 'predefined', user-defined blocks and foldsCol must be supplied.</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_iteration">iteration</code></td>
<td>
<p>Integer value. The number of attempts to create folds that fulfil the set requirement for minimum number
of points in each training and testing fold (for each response class e.g. <em>train_0</em>, <em>train_1</em>, <em>test_0</em>
and <em>test_1</em>), as specified by <code>species</code> and <code>numLimit</code> arguments.</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_blocks">blocks</code></td>
<td>
<p>A sf or SpatialPolygons object to be used as the blocks (optional). This can be a user defined polygon and it must cover all
the species (response) points. If the selection = 'predefined', this argument (and foldsCol) must be supplied.</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_foldscol">foldsCol</code></td>
<td>
<p>Character. Indicating the name of the column (in user-defined blocks) in which the associated folds are stored.
This argument is necessary if you choose the 'predefined' selection.</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_numlimit">numLimit</code></td>
<td>
<p>deprecated option!</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_maskbyspecies">maskBySpecies</code></td>
<td>
<p>Since version 1.1, this option is always set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_degmetre">degMetre</code></td>
<td>
<p>Integer. The conversion rate of metres to degree. See the details section for more information.</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_border">border</code></td>
<td>
<p>deprecated option!</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_showblocks">showBlocks</code></td>
<td>
<p>Logical. If TRUE the final blocks with fold numbers will be created with ggplot and plotted. A raster layer could be specified
in <code>rasterlayer</code> argument to be as background.</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_biomod2format">biomod2Format</code></td>
<td>
<p>Logical. Creates a matrix of folds that can be directly used in the <span class="pkg">biomod2</span> package as
a <em>DataSplitTable</em> for cross-validation.</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_xoffset">xOffset</code></td>
<td>
<p>Numeric value between <strong>0</strong> and <strong>1</strong> for shifting the blocks horizontally.
The value is the proportion of block size.</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_yoffset">yOffset</code></td>
<td>
<p>Numeric value between <strong>0</strong> and <strong>1</strong> for shifting the blocks vertically. The value is the proportion of block size.</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_extend">extend</code></td>
<td>
<p>numeric; This parameter specifies the percentage by which the map's extent is
expanded to increase the size of the square spatial blocks, ensuring that all points fall
within a block. The value should be a numeric between 0 and 5.</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_seed">seed</code></td>
<td>
<p>Integer. A random seed generator for reproducibility.</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_progress">progress</code></td>
<td>
<p>Logical. If TRUE shows a progress bar when <code>numLimit = NULL</code> in random fold selection.</p>
</td></tr>
<tr><td><code id="spatialBlock_+3A_verbose">verbose</code></td>
<td>
<p>Logical. To print the report of the recods per fold.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+cv_spatial">cv_spatial</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
