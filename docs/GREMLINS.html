<!DOCTYPE html><html><head><title>Help for package GREMLINS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GREMLINS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#comparClassif'><p>Compare two classifications on all the  Functional groups</p></a></li>
<li><a href='#compLikICL'><p>compute the Integrated likeilhood and the ICL criteria for the MBM</p></a></li>
<li><a href='#defineNetwork'><p>Define a network providing its matrix of interactions and specifying the functions groups in row and col.</p></a></li>
<li><a href='#extractClustersMBM'><p>Extract the clusters in each functional group</p></a></li>
<li><a href='#GREMLINS'><p>Adjusting an extended SBM to Multipartite networks</p></a></li>
<li><a href='#MPEcoNetwork'><p>Multipartite network of mutualistic interactions between   plants and pollinators, plants and birds  and plants and ants.</p></a></li>
<li><a href='#multipartiteBM'><p>Model selection and parameter estimation of MBM</p></a></li>
<li><a href='#multipartiteBMFixedModel'><p>Model selection and estimation of multipartite blockmodels</p></a></li>
<li><a href='#predictMBM'><p>Predict NAs in a Collection of Networks from a fitted MBM</p></a></li>
<li><a href='#rMBM'><p>Simulate datasets from  the multipartite block  model (MBM).</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Multipartite Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>We define generalized multipartite networks  as the joint observation of several networks implying some common pre-specified groups of individuals. The aim is to fit an adapted version of  the popular stochastic block model to multipartite networks, as described in Bar-hen, Barbillon and Donnet (2020) &lt;<a href="https://doi.org/10.48550/arXiv.1807.10138">doi:10.48550/arXiv.1807.10138</a>&gt;.  </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://GrossSBM.github.io/GREMLINS/">https://GrossSBM.github.io/GREMLINS/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GrossSBM/GREMLINS/issues">https://github.com/GrossSBM/GREMLINS/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), spelling, knitr, rmarkdown</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, parallel, stats, utils, igraph, blockmodels, aricode,
pbmcapply</td>
</tr>
<tr>
<td>Collate:</td>
<td>'GREMLINS_package.R' 'BMPOO.R' 'defineNetwork.R'
'multipartiteBM.R' 'VEMPOOVersion.R'
'multipartiteBMFixedModel.R' 'initializeVEM.R'
'searchVKPOOVersion.R' 'utils.R' 'compLikICL.R'
'extractClustersMBM.R' 'rMBM.R' 'comparClassif.R'
'MPEcoNetwork.R' 'predictMBM.R'</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-10 15:47:52 UTC; donnet</td>
</tr>
<tr>
<td>Author:</td>
<td>Sophie Donnet <a href="https://orcid.org/0000-0003-4370-7316"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Pierre Barbillon <a href="https://orcid.org/0000-0002-7766-7693"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sophie Donnet &lt;sophie.donnet@inrae.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-10 18:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='comparClassif'>Compare two classifications on all the  Functional groups</h2><span id='topic+comparClassif'></span>

<h3>Description</h3>

<p>Compare two classifications on all the  Functional groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparClassif(classif1, classif2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparClassif_+3A_classif1">classif1</code></td>
<td>
<p>: list a length n_FG.</p>
</td></tr>
<tr><td><code id="comparClassif_+3A_classif2">classif2</code></td>
<td>
<p>: list a length n_FG.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adjusted Rand Index (ARI) for each Functional Group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nFG &lt;- 3;
vK &lt;- c(4,5,2) ;
vNQ &lt;- c(100,40,50);
classif1 &lt;- lapply(1:nFG,function(q){sample(1:vK[q],vNQ[q],replace=TRUE)})
classif2 &lt;- classif1
classif2[[2]] &lt;-  sample(1:vK[2],vNQ[2],replace=TRUE)
resCompar &lt;- comparClassif (classif1,classif2)
</code></pre>

<hr>
<h2 id='compLikICL'>compute the Integrated likeilhood and the ICL criteria for the MBM</h2><span id='topic+compLikICL'></span>

<h3>Description</h3>

<p>compute the Integrated likeilhood and the ICL criteria for the MBM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compLikICL(paramEstim, list_Net, v_distrib = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compLikICL_+3A_paramestim">paramEstim</code></td>
<td>
<p>Estimated parameters of MBM</p>
</td></tr>
<tr><td><code id="compLikICL_+3A_list_net">list_Net</code></td>
<td>
<p>A list of network</p>
</td></tr>
<tr><td><code id="compLikICL_+3A_v_distrib">v_distrib</code></td>
<td>
<p>Type of proababilistic distributions in each network : if 0/1 then Bernoulli, if counting then Poisson. My default  = Bernoulli.
Must give a vector whose length is the number of networks in list_Net</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pseudo-Likelihood and penalty
</p>

<hr>
<h2 id='defineNetwork'>Define a network providing its matrix of interactions and specifying the functions groups in row and col.</h2><span id='topic+defineNetwork'></span>

<h3>Description</h3>

<p>Define a network providing its matrix of interactions and specifying the functions groups in row and col.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defineNetwork(mat, typeInter, rowFG, colFG)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defineNetwork_+3A_mat">mat</code></td>
<td>
<p>An adjacency matrix (symmetric or not) or an incidence matrix</p>
</td></tr>
<tr><td><code id="defineNetwork_+3A_typeinter">typeInter</code></td>
<td>
<p>Type of the matrix, choice between &quot;inc&quot; (incidence), &quot;adj&quot; (adjacency) and &quot;diradj&quot; (directed adjacency)</p>
</td></tr>
<tr><td><code id="defineNetwork_+3A_rowfg">rowFG</code></td>
<td>
<p>Name of the functional group in row</p>
</td></tr>
<tr><td><code id="defineNetwork_+3A_colfg">colFG</code></td>
<td>
<p>Name of the function group in column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object formatted for the GREMLINS package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(rbinom(100,1,.2),10,10)
type &lt;- "diradj"
defineNetwork(A,"diradj","FG1","FG1")
</code></pre>

<hr>
<h2 id='extractClustersMBM'>Extract the clusters in each functional group</h2><span id='topic+extractClustersMBM'></span>

<h3>Description</h3>

<p>Extract the clusters in each functional group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractClustersMBM(resMBM, whichModel = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractClustersMBM_+3A_resmbm">resMBM</code></td>
<td>
<p>A fitted Generalized BlockModel</p>
</td></tr>
<tr><td><code id="extractClustersMBM_+3A_whichmodel">whichModel</code></td>
<td>
<p>The index corresponding to the model to plot (default is 1, the best model)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list a length the number of Functional Groups. Each element is a list of length the number of blocks composed of the index of the individuals in each block of each cluster.
</p>

<hr>
<h2 id='GREMLINS'>Adjusting an extended SBM to Multipartite networks</h2><span id='topic+GREMLINS'></span>

<h3>Description</h3>

<p>Generalized multipartite networks  consist in the joint observation of several networks implying some common pre-specified groups of individuals. GREMLIM adjusts an adapted version of  the popular stochastic block model to multipartite networks, as described in Bar-hen, Barbillon and Donnet (2020)
The GREMLINS package provides the following top-level  major functions:
</p>

<ul>
<li><p><code><a href="#topic+defineNetwork">defineNetwork</a></code> a function to define carefully a single network.
</p>
</li>
<li><p><code><a href="#topic+rMBM">rMBM</a></code> a function to simulate a collection of networks involving common functional groups of entities (with various emission distributions).
</p>
</li>
<li><p><code><a href="#topic+multipartiteBM">multipartiteBM</a></code> a function to perform inference (model selection and estimation ) of SBM for a multipartite network.
</p>
</li>
<li><p><code><a href="#topic+multipartiteBMFixedModel">multipartiteBMFixedModel</a></code> a function to estimate the parameters of SBM for a multipartite network for fixed numbers of blocks
</p>
</li></ul>



<h3>Details</h3>

<p>We also provide some additional functions useful to analyze the results:
</p>

<ul>
<li><p><code><a href="#topic+extractClustersMBM">extractClustersMBM</a></code> a function to extract the clusters in each functional group
</p>
</li>
<li><p><code><a href="#topic+comparClassif">comparClassif</a></code> a function to compute the Adjusted Rand Index (ARI) between two classifications
</p>
</li>
<li><p><code><a href="#topic+predictMBM">predictMBM</a></code> a function to compute the predictions once the model has been fitted
</p>
</li>
<li><p><code><a href="#topic+compLikICL">compLikICL</a></code> a function to	compute the Integrated Likelihood and the ICL criteria for the MBM
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Pierre Barbillon, Sophie Donnet
</p>


<h3>References</h3>

<p>Bar-Hen, A. and Barbillon, P. &amp; Donnet S. (2020), &quot;Block models for multipartite networks. Applications in ecology and  ethnobiology. Journal of Statistical Modelling (to appear)
</p>

<hr>
<h2 id='MPEcoNetwork'>Multipartite network of mutualistic interactions between   plants and pollinators, plants and birds  and plants and ants.</h2><span id='topic+MPEcoNetwork'></span>

<h3>Description</h3>

<p>Multipartite network of mutualistic interactions between   plants and pollinators, plants and birds  and plants and ants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MPEcoNetwork
</code></pre>


<h3>Format</h3>

<p>A list a 3 binary  incidence matrices
</p>

<dl>
<dt>Inc_plant_ant</dt><dd><p>Interactions between plants (rows) and ants (cols). Matrix with 141 rows and 30 columns</p>
</dd>
<dt>Inc_plant_bird</dt><dd><p>Interactions between plants (rows) and birds (cols). Matrix with141 rows and 46 columns</p>
</dd>
<dt>Inc_plant_flovis</dt><dd><p>Interactions between plants (rows) and pollinators (cols). Matrix with 141 rows and 173 columns</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>Dataset  compiled and conducted at Centro de Investigaciones Costeras La Mancha (CICOLMA), located on the central coast of the Gulf of Mexico, Veracruz, Mexico. <a href="https://royalsocietypublishing.org/doi/full/10.1098/rspb.2016.1564">https://royalsocietypublishing.org/doi/full/10.1098/rspb.2016.1564</a> <a href="https://github.com/lucaspdmedeiros/multi-network_core_removal/tree/master/data">https://github.com/lucaspdmedeiros/multi-network_core_removal/tree/master/data</a>
</p>

<hr>
<h2 id='multipartiteBM'>Model selection and parameter estimation of MBM</h2><span id='topic+multipartiteBM'></span>

<h3>Description</h3>

<p>Select the number of blocks and identify the blocks per functional group using a variational EM algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multipartiteBM(
  list_Net,
  v_distrib = NULL,
  namesFG = NULL,
  v_Kmin = 1,
  v_Kmax = 10,
  v_Kinit = NULL,
  initBM = TRUE,
  keep = FALSE,
  verbose = TRUE,
  nbCores = NULL,
  maxiterVE = NULL,
  maxiterVEM = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multipartiteBM_+3A_list_net">list_Net</code></td>
<td>
<p>a list of networks (defined via the function defineNetwork) i.e. a multipartite network</p>
</td></tr>
<tr><td><code id="multipartiteBM_+3A_v_distrib">v_distrib</code></td>
<td>
<p>an optional vector of characters of length the number of networks and specifying the distribution used in each network (possible values <code>bernoulli,poisson,gaussian,laplace</code>).   If not provided, the model will be 'bernoulli' for all the interactions  matrices.</p>
</td></tr>
<tr><td><code id="multipartiteBM_+3A_namesfg">namesFG</code></td>
<td>
<p>an optional vector of  characters containing the names of functional groups (FG) (If Specified, must correspond to the  names in <code>list_Net</code>).</p>
</td></tr>
<tr><td><code id="multipartiteBM_+3A_v_kmin">v_Kmin</code></td>
<td>
<p>an optional vector of integers, specifying the minimal number of blocks per functional group (must be provided in the same order as in <code>namesFG</code>).
v_Kmin may be a single value (same minimal number of blocks for all the FGs) or a vector with size equal to the number of FGs.
Default value  <code>= 1</code>.</p>
</td></tr>
<tr><td><code id="multipartiteBM_+3A_v_kmax">v_Kmax</code></td>
<td>
<p>an optional vector of integers specifying the maximal number of blocks per functional group provided in the same order as in <code>namesFG</code>.
v_Kmax may be a single value (same maximal number of blocks for all the FGs) or a vector with size equal to the number of FGs.
Default value  <code>= 10</code>.</p>
</td></tr>
<tr><td><code id="multipartiteBM_+3A_v_kinit">v_Kinit</code></td>
<td>
<p>an optional vector of integers specifying initial numbers of blocks per FG provided in the same order as in <code>namesFG</code>.
if <code>v_Kinit</code> is not specified, then   <code>v_Kinit = v_Kmin</code></p>
</td></tr>
<tr><td><code id="multipartiteBM_+3A_initbm">initBM</code></td>
<td>
<p>an optional boolean. If initBM = TRUE  an aditional initialisation is done using simple LBM or SBM on each network separatly.
Default value  <code>= TRUE</code></p>
</td></tr>
<tr><td><code id="multipartiteBM_+3A_keep">keep</code></td>
<td>
<p>an optional boolean. If TRUE  return the estimated parameters for intermediate visited models. Otherwise, only the better model (in ICL sense) is the ouput. Default value <code>= FALSE</code>.</p>
</td></tr>
<tr><td><code id="multipartiteBM_+3A_verbose">verbose</code></td>
<td>
<p>an optional boolean. If  TRUE, display the current step of the search algorithm</p>
</td></tr>
<tr><td><code id="multipartiteBM_+3A_nbcores">nbCores</code></td>
<td>
<p>an optional integer specifying the number or cores used for the estimation. Not parallelized on windows. If <code>ncores = NULL</code>, then half of the cores are used.</p>
</td></tr>
<tr><td><code id="multipartiteBM_+3A_maxiterve">maxiterVE</code></td>
<td>
<p>an optional integer  specifying the maximum number of iterations in the VE step of the VEM algorithm. If NULL then default value  <code>= 1000</code></p>
</td></tr>
<tr><td><code id="multipartiteBM_+3A_maxitervem">maxiterVEM</code></td>
<td>
<p>an optional integer  specifying the maximum number of iterations of the VEM algorithm. If NULL then default value Default value  <code>= 1000</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>multipartiteBM</code> selects the better numbers of blocks in each FG (with a penalized likelihood criterion). The model selection is performed with a forward backward strategy and the likelihood of each model is maximized with a variational EM).
</p>


<h3>Value</h3>

<p>a list of estimated parameters for the different models ordered by decreasing ICL. If keep <code>= FALSE</code>, the length is of length 1 (only the better model is returned).
</p>

<dl>
<dt><code>fittedModel</code></dt><dd><p>contains the results of the inference. <code>res$fittedModel[[1]]</code>  is a list with fields
</p>

<dl>
<dt><code>paramEstim</code></dt><dd><p>a MBMfit object.</p>
</dd>
<dt><code>ICL</code></dt><dd><p>the penalized likelihood criterion ICL.</p>
</dd>
<dt><code>vJ</code></dt><dd><p>the sequence of the varational bound of the likelihood through iterations of the VEM.</p>
</dd>
<dt><code>convergence</code></dt><dd><p>TRUE if the VEM reached convergence.</p>
</dd>
</dl>

</dd>
<dt><code>list_Net</code></dt><dd><p> contains the data.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>namesFG &lt;- c('A','B')
list_pi &lt;- list(c(0.5,0.5),c(0.3,0.7)) # prop of blocks in each FG
E  &lt;-  rbind(c(1,2),c(2,2)) # architecture of the multipartite net.
typeInter &lt;- c( "inc","diradj")
v_distrib &lt;- c('gaussian','bernoulli')
list_theta &lt;- list()
list_theta[[1]] &lt;- list()
list_theta[[1]]$mean  &lt;- matrix(c(6.1, 8.9, 6.6, 3), 2, 2)
list_theta[[1]]$var  &lt;-  matrix(c(1.6, 1.6, 1.8, 1.5),2, 2)
list_theta[[2]] &lt;- matrix(c(0.7,1.0, 0.4, 0.6),2, 2)
list_Net &lt;- rMBM(v_NQ = c(30,30),E , typeInter, v_distrib, list_pi,
                list_theta, namesFG = namesFG, seed = 2)$list_Net
res_MBMsimu &lt;- multipartiteBM(list_Net, v_distrib,
                              namesFG = c('A','B'), v_Kinit = c(2,2),
                              nbCores = 2,initBM = FALSE)
</code></pre>

<hr>
<h2 id='multipartiteBMFixedModel'>Model selection and estimation of multipartite blockmodels</h2><span id='topic+multipartiteBMFixedModel'></span>

<h3>Description</h3>

<p>Estimate the parameters and give the clustering for given numbers of blocks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multipartiteBMFixedModel(
  list_Net,
  v_distrib,
  namesFG,
  v_K,
  classifInit = NULL,
  nbCores = NULL,
  maxiterVE = NULL,
  maxiterVEM = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multipartiteBMFixedModel_+3A_list_net">list_Net</code></td>
<td>
<p>A list of network (defined via the function DefineNetwork)</p>
</td></tr>
<tr><td><code id="multipartiteBMFixedModel_+3A_v_distrib">v_distrib</code></td>
<td>
<p>Type of proababilistic distributions in each network : if 0/1 then bernoulli, if counting then poisson, gaussian or Zero Inflated Gaussian (ZIgaussian) My default  = Bernoulli.
Must give a vector whose length is the number of networks in list_Net</p>
</td></tr>
<tr><td><code id="multipartiteBMFixedModel_+3A_namesfg">namesFG</code></td>
<td>
<p>Names of functional groups (must correspond to names in listNet)</p>
</td></tr>
<tr><td><code id="multipartiteBMFixedModel_+3A_v_k">v_K</code></td>
<td>
<p>A vector with the numbers of blocks per functional group</p>
</td></tr>
<tr><td><code id="multipartiteBMFixedModel_+3A_classifinit">classifInit</code></td>
<td>
<p>A list of initial classification for each functional group in the same order as in namesFG</p>
</td></tr>
<tr><td><code id="multipartiteBMFixedModel_+3A_nbcores">nbCores</code></td>
<td>
<p>Number or cores used for the estimation. Not parallelized on windows. By default : half of the cores</p>
</td></tr>
<tr><td><code id="multipartiteBMFixedModel_+3A_maxiterve">maxiterVE</code></td>
<td>
<p>Maximum number of iterations in the VE step of the VEM algorithm. Default value  = 1000</p>
</td></tr>
<tr><td><code id="multipartiteBMFixedModel_+3A_maxitervem">maxiterVEM</code></td>
<td>
<p>Maximum number of iterations of the VEM algorithm. Default value  = 1000</p>
</td></tr>
<tr><td><code id="multipartiteBMFixedModel_+3A_verbose">verbose</code></td>
<td>
<p>Set to TRUE to display the current step of the search algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated parameters and a classification
</p>


<h3>Examples</h3>

<pre><code class='language-R'>namesFG &lt;- c('A','B')
list_pi &lt;- list(c(0.5,0.5),c(0.3,0.7)) # prop of blocks in each FG
E  &lt;-  rbind(c(1,2),c(2,2)) # architecture of the multipartite net.
typeInter &lt;- c( "inc","diradj")
v_distrib &lt;- c('poisson','bernoulli')
list_theta &lt;- list()
list_theta[[1]]   &lt;- matrix(c(6.1, 8.9, 6.6, 3), 2, 2)
list_theta[[2]] &lt;- matrix(c(0.7,1.0, 0.4, 0.6),2, 2)
list_Net &lt;- rMBM(v_NQ = c(20,20),E , typeInter, v_distrib, list_pi,
                list_theta, namesFG = namesFG, seed = 2)$list_Net
#res_MBMsimu_fixed &lt;- multipartiteBMFixedModel(list_Net, v_distrib,
#                                               namesFG = namesFG,
#                                               v_K = c(1,2),
#                                               nbCores = 2)
</code></pre>

<hr>
<h2 id='predictMBM'>Predict NAs in a Collection of Networks from a fitted MBM</h2><span id='topic+predictMBM'></span>

<h3>Description</h3>

<p>Predict NAs in a Collection of Networks from a fitted MBM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictMBM(RESMBM, whichModel = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictMBM_+3A_resmbm">RESMBM</code></td>
<td>
<p>a fitted multipartite blockmodel</p>
</td></tr>
<tr><td><code id="predictMBM_+3A_whichmodel">whichModel</code></td>
<td>
<p>The index corresponding to the model used for prediction (default is 1, the best model)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the collection of matrices of predictions (probability for binary, intensity for weighted network) a
</p>


<h3>Examples</h3>

<pre><code class='language-R'>namesFG &lt;- c('A','B')
list_pi &lt;- list(c(0.5,0.5),c(0.3,0.7)) # prop of blocks in each FG
E  &lt;-  rbind(c(1,2),c(2,2)) # architecture of the multipartite net.
typeInter &lt;- c( "inc","diradj")
v_distrib &lt;- c('gaussian','bernoulli')
list_theta &lt;- list()
list_theta[[1]] &lt;- list()
list_theta[[1]]$mean  &lt;- matrix(c(6.1, 8.9, 6.6, 3), 2, 2)
list_theta[[1]]$var  &lt;-  matrix(c(1.6, 1.6, 1.8, 1.5),2, 2)
list_theta[[2]] &lt;- matrix(c(0.7,1.0, 0.4, 0.6),2, 2)
list_Net &lt;- rMBM(v_NQ = c(30,30),E , typeInter, v_distrib, list_pi,
                list_theta, namesFG = namesFG, seed = 2)$list_Net
res_MBMsimu &lt;- multipartiteBM(list_Net, v_distrib,
                              namesFG = c('A','B'), v_Kinit = c(2,2),
                              nbCores = 2,initBM = FALSE)
pred &lt;- predictMBM(res_MBMsimu)
</code></pre>

<hr>
<h2 id='rMBM'>Simulate datasets from  the multipartite block  model (MBM).</h2><span id='topic+rMBM'></span>

<h3>Description</h3>

<p><code>rMBM</code> simulates a collection of networks involving common functional groups of entities. The networks may be directed, undirected or bipartite. The emission distribution of the edges may be Bernoulli, Poisson, Gaussian, Zero-Inflated Gaussian, or Laplace. See the vignette for more information about the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rMBM(
  v_NQ,
  E,
  typeInter,
  v_distrib,
  list_pi,
  list_theta,
  namesFG = NULL,
  keepClassif = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rMBM_+3A_v_nq">v_NQ</code></td>
<td>
<p>: number of individual in each Functional Group (FG)</p>
</td></tr>
<tr><td><code id="rMBM_+3A_e">E</code></td>
<td>
<p>: define the architecture of the Multipartite.</p>
</td></tr>
<tr><td><code id="rMBM_+3A_typeinter">typeInter</code></td>
<td>
<p>: type of interaction in each network: undirected adjacency (adj), directed adjacency (diradj) or incidence (inc).  (vector of size equal to nrow(E) )</p>
</td></tr>
<tr><td><code id="rMBM_+3A_v_distrib">v_distrib</code></td>
<td>
<p>: vector of the distributions: 'bernoulli', 'poisson', 'gaussian', 'ZIgaussian' (for Zero inflated gaussian) or 'laplace'  ( vector of size equal to nrow(E) )</p>
</td></tr>
<tr><td><code id="rMBM_+3A_list_pi">list_pi</code></td>
<td>
<p>: parameters of the blocks distribution</p>
</td></tr>
<tr><td><code id="rMBM_+3A_list_theta">list_theta</code></td>
<td>
<p>: parameters of the interactions distribution. For Bernoulli a probability, for Poisson positive real number, for Gaussian a list specifying mean and var (plus p0 for ZIgaussian), for Laplace a list with location and scale</p>
</td></tr>
<tr><td><code id="rMBM_+3A_namesfg">namesFG</code></td>
<td>
<p>: names of the FG.  (default value  = NULL, then the functional groups are labelled FG1, FG2, etc)</p>
</td></tr>
<tr><td><code id="rMBM_+3A_keepclassif">keepClassif</code></td>
<td>
<p>: equal to TRUE if you want to keep the simulated blocks/classification (default value  = FALSE).</p>
</td></tr>
<tr><td><code id="rMBM_+3A_seed">seed</code></td>
<td>
<p>: set the seed for the random simulation (default value  = NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists containing the networks (list_net) and if keepClassif = TRUE the classifications (classif)
Each element of  list_net corresponds to a network : each network is a list containing  the matrix (mat) , the type of network(diradj, adj, inc), the functional group in row (rowFG) and the functional group in columns (colFG)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>namesFG &lt;- c('A','B','C')
list_pi = list(c(0.16 ,0.40 ,0.44),c(0.3,0.7),c(0.5,0.5))
E  &lt;-  rbind(c(1,2),c(2,3),c(1,1))
typeInter &lt;- c( "inc","inc", "adj")
v_distrib &lt;- c('ZIgaussian','bernoulli','poisson')
list_theta &lt;- list()
list_theta[[1]] &lt;- list()
list_theta[[1]]$mean  &lt;- matrix(c(6.1, 8.9, 6.6, 9.8, 2.6, 1.0), 3, 2)
list_theta[[1]]$var  &lt;-  matrix(c(1.6, 1.6, 1.8, 1.7 ,2.3, 1.5),3, 2)
list_theta[[1]]$p0  &lt;-  matrix(c(0.4, 0.1, 0.6, 0.5 , 0.2, 0),3, 2)
list_theta[[2]] &lt;- matrix(c(0.7,1.0, 0.4, 0.6),2, 2)
m3 &lt;- matrix(c(2.5, 2.6 ,2.2 ,2.2, 2.7 ,3.0 ,3.6, 3.5, 3.3),3,3 )
list_theta[[3]] &lt;- (m3 + t(m3))/2
dataSim &lt;- rMBM(v_NQ = c(100,50,40) , E = E , typeInter = typeInter,
                v_distrib = v_distrib, list_pi = list_pi,
                list_theta = list_theta, namesFG)
list_net &lt;- dataSim$list_Net
classifTrue &lt;- dataSim$classif
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
