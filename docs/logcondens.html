<!DOCTYPE html><html lang="en"><head><title>Help for package logcondens</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {logcondens}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#logcon-package'><p>Estimate a Log-Concave Probability Density from iid Observations</p></a></li>
<li><a href='#activeSetLogCon'><p>Computes a Log-Concave Probability Density Estimate via an Active Set Algorithm</p></a></li>
<li><a href='#activeSetRoutines'><p>Auxiliary Numerical Routines for the Function activeSetLogCon</p></a></li>
<li><a href='#brightstar'><p>Bright star dataset used to illustrate log-concave density estimation</p></a></li>
<li><a href='#confIntBootLogConROC_t0'><p>Function to compute a bootstrap confidence interval for the ROC curve at a given t, based on the log-concave ROC curve</p></a></li>
<li><a href='#evaluateLogConDens'><p>Evaluates the Log-Density MLE and Smoothed Estimator at Arbitrary Real Numbers xs</p></a></li>
<li><a href='#icmaLogCon'><p>Computes a Log-Concave Probability Density Estimate via an Iterative Convex Minorant Algorithm</p></a></li>
<li><a href='#intECDF'><p>Computes the Integrated Empirical Distribution Function at Arbitrary Real Numbers in s</p></a></li>
<li><a href='#intF'><p>Computes the Integral of the estimated CDF at Arbitrary Real Numbers in s</p></a></li>
<li><a href='#isoMean'><p>Pool-Adjacent Violaters Algorithm: Least Square Fit under Monotonicity Constraint</p></a></li>
<li><a href='#Jfunctions'><p>Numerical Routine J and Some Derivatives</p></a></li>
<li><a href='#Lhat_eta'><p>Value of the Log-Likelihood Function L, where Input is in Eta-Parametrization</p></a></li>
<li><a href='#Local_LL'><p>Value of the Log-Likelihood Function L, where Input is in Phi-Parametrization</p></a></li>
<li><a href='#Local_LL_all'><p>Log-likelihood, New Candidate and Directional Derivative for L</p></a></li>
<li><a href='#logConCI'><p>Compute pointwise confidence interval for a density assuming log-concavity</p></a></li>
<li><a href='#logConCIfunctions'><p>Functions that are used by logConCI</p></a></li>
<li><a href='#logConDens'><p>Compute log-concave density estimator and related quantities</p></a></li>
<li><a href='#logConROC'><p>Compute ROC curve based on log-concave estimates for the constituent distributions</p></a></li>
<li><a href='#logconTwoSample'><p>Compute p-values for two-sample test based on log-concave CDF estimates</p></a></li>
<li><a href='#maxDiffCDF'><p>Compute maximal difference between CDFs corresponding to log-concave estimates</p></a></li>
<li><a href='#MLE'><p>Unconstrained piecewise linear MLE</p></a></li>
<li><a href='#pancreas'><p>Data from pancreatic cancer serum biomarker study</p></a></li>
<li><a href='#plot.dlc'><p>Standard plots for a dlc object</p></a></li>
<li><a href='#preProcess'><p>Compute a weighted sample from initial observations</p></a></li>
<li><a href='#Q00'><p>Numerical Routine Q</p></a></li>
<li><a href='#qloglin'><p>Quantile Function In a Simple Log-Linear model</p></a></li>
<li><a href='#quadDeriv'><p>Gradient and Diagonal of Hesse Matrix of Quadratic Approximation to Log-Likelihood Function L</p></a></li>
<li><a href='#quantilesLogConDens'><p>Function to compute Quantiles of Fhat</p></a></li>
<li><a href='#reliability'><p>Reliability dataset used to illustrate log-concave density estimation</p></a></li>
<li><a href='#reparametrizations'><p>Changes Between Parametrizations</p></a></li>
<li><a href='#rlogcon'><p>Generate random sample from the log-concave and the smoothed log-concave density estimator</p></a></li>
<li><a href='#robust'><p>Robustification and Hermite Interpolation for ICMA</p></a></li>
<li><a href='#ROCx'><p>Compute ROC curve at a given x based on log-concave estimates for the constituent distributions</p></a></li>
<li><a href='#summary.dlc'><p>Summarizing log-concave density estimation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimate a Log-Concave Probability Density from Iid Observations</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Kaspar Rufibach &lt;kaspar.rufibach@gmail.com&gt; and Lutz Duembgen &lt;duembgen@stat.unibe.ch&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kaspar Rufibach &lt;kaspar.rufibach@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ks, graphics, stats</td>
</tr>
<tr>
<td>Description:</td>
<td>Given independent and identically distributed observations X(1), ..., X(n), compute the maximum likelihood estimator (MLE) of a density as well as a smoothed version of it under the assumption that the density is log-concave, see Rufibach (2007) and Duembgen and Rufibach (2009). The main function of the package is 'logConDens' that allows computation of the log-concave MLE and its smoothed version. In addition, we provide functions to compute (1) the value of the density and distribution function estimates (MLE and smoothed) at a given point (2) the characterizing functions of the estimator, (3) to sample from the estimated distribution, (5) to compute a two-sample permutation test based on log-concave densities, (6) the ROC curve based on log-concave estimates within cases and controls, including confidence intervals for given values of false positive fractions (7) computation of a confidence interval for the value of the true density at a fixed point. Finally, three datasets that have been used to illustrate log-concave density estimation are made available.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> ,
<a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-22 11:58:12 UTC; rufiback</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-22 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='logcon-package'>Estimate a Log-Concave Probability Density from iid Observations</h2><span id='topic+logcon'></span><span id='topic+log-concave'></span><span id='topic+logcondens'></span><span id='topic+logcondens-package'></span>

<h3>Description</h3>

<p>The main function of this package is <code><a href="#topic+logConDens">logConDens</a></code>: compute the maximum likelihood estimator (MLE) of a log-concave density from one-dimensional i.i.d. observations as well as the kernel smoothed version derived from it. A list of additional functions that can be used to compute quantities relevant in that context can be found below.
</p>
<p>Two algorithms are offered to compute the estimate: An active set (<code><a href="#topic+logConDens">logConDens</a></code>) and an iterative algorithm based on the pool-adjacent-violaters algorithm (<code><a href="#topic+icmaLogCon">icmaLogCon</a></code>). The latter of these functions is only part of this package for historical reasons: it was the first method that was proposed to estimate a log-concave density, see Rufibach (2007). The more efficient way of computing the estimate is via an active set algorithm. The smoothed versions of the log-concave density and distribution function estimates discussed in Section 3 of Duembgen and Rufibach (2009) are available in the function <code><a href="#topic+evaluateLogConDens">evaluateLogConDens</a></code>.
</p>
<p>To compute a log-concave density, CDF, and survival function from interval- or right-censored observations use the package <span class="pkg">logconcens</span>. A log-concave probability mass function can be computed using the package <span class="pkg">logcondiscr</span>, see Balabdaoui et al (2012) for details. For the computation of a log-concave estimate in any dimension the package <span class="pkg">LogConDEAD</span> can be used.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> logcondens</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.1.8 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-08-21 </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The following additional functions and datasets are provided in the package:
</p>
<p><code><a href="#topic+evaluateLogConDens">evaluateLogConDens</a></code> Computes the value of the estimated log-density, density, and distribution function
of the MLE and the smoothed estimator at a given <code>x0</code>.
</p>
<p><code><a href="#topic+quantilesLogConDens">quantilesLogConDens</a></code> Computes quantiles of the estimated distribution function at a given <code>x0</code>.
</p>
<p><code><a href="#topic+intECDF">intECDF</a></code> Compute the integrated empirical distribution function of the observations at a given <code>x0</code>.
</p>
<p><code><a href="#topic+intF">intF</a></code> Compute the integral of the distribution function corresponding to the log-concave density
estimator at a given <code>x0</code>.
</p>
<p><code><a href="#topic+logconTwoSample">logconTwoSample</a></code> Compute a permutation test for the difference between two distribution functions.
</p>
<p><code><a href="#topic+logConROC">logConROC</a></code> Compute ROC curve based on log-concave density estimates within cases and controls.
</p>
<p><code><a href="#topic+confIntBootLogConROC_t0">confIntBootLogConROC_t0</a></code> Compute bootstrap confidence intervals at given false positive fractions (= 1 - specificity) for the ROC curve based on log-concave density estimates.
</p>
<p><code><a href="#topic+logConCI">logConCI</a></code> Compute a confidence interval for the value of the true density at a fixed point, based on the theory developed in Balabdaoui et al (2009). This function was contributed by Mahdis Azadbakhsh and Hanna Jankowski, see Azadbakhsh et al (2012).
</p>
<p><code><a href="#topic+isoMean">isoMean</a></code> Compute the weighted least squares regression under a monotonicity constraint (the Grenander estimator).
This function is used as part of <code><a href="#topic+icmaLogCon">icmaLogCon</a></code> but is also of independent interest.
</p>
<p>The following datasets have been used in several publications to illustrate log-concave density estimation and are
therefore included in this package:
</p>
<p><code><a href="#topic+reliability">reliability</a></code> Dataset that contains the data analyzed in Duembgen and Rufibach (2009, Figure 2).
See the help file for <code><a href="#topic+logConDens">logConDens</a></code> for the analysis of this data.
</p>
<p><code><a href="#topic+brightstar">brightstar</a></code> Dataset that contains the data analyzed in Mizera and Koenker (2009, Section 5). The
sample consists of measurements of radial and rotational velocities for the stars from the Bright Star Catalog, see
Hoffleit and Warren (1991).
</p>
<p><code><a href="#topic+pancreas">pancreas</a></code> Data from pancreatic cancer serum biomarker study, first published by Wieand et al (1989).
Contains data on serum measurements for a cancer antigen (CA-125) and
a carbohydrate antigen (CA19.9) both of which are measured on a continuous non-negative scale. The measurements were taken within a case-control
study on 90 cases with pancreatic cancer and 51 controls who did not have cancer but pancreatitis.
</p>
<p>A <code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+summary">summary</a></code> for objects of class <code>dlc</code>, generated by  <code><a href="#topic+logConDens">logConDens</a></code>, are available as well.
</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach (maintainer), <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a>
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a>
</p>
<p>Kaspar Rufibach gratefully acknowledges support by the Swiss National Science Foundation SNF, <a href="http://www.snf.ch">http://www.snf.ch</a>.
</p>
<p>MatLab code with an implementation of the active set algorithm is available on request from Lutz Duembgen.</p>


<h3>References</h3>

<p>Azadbakhsh, M., Jankowski, H. and Gao, X. (2014).
Computing confidence intervals for log-concave densities.
<em>Comput. Statist. Data Anal.</em>, <b>75</b>, 248&ndash;264.
</p>
<p>Balabdaoui, F., Jankowski, H., Rufibach, K. and Pavlides, M. (2012).
Asymptotics of the discrete log-concave maximum likelihood estimator and related applications.
<em>J. R. Stat. Soc. Ser. B Stat. Methodol.</em>, <b>75(4)</b>, 769&ndash;790.
</p>
<p>Baladbaoui, F., Rufibach, K. and Wellner, J. (2009).
Limit distribution theory for maximum likelihood estimation of a log-concave density.
<em>Ann. Statist.</em>, <b>37(3)</b>, 1299&ndash;1331.
</p>
<p>Duembgen, L., Huesler, A. and Rufibach, K. (2010).
Active set and EM algorithms for log-concave densities based on complete and censored data.
Technical report 61, IMSV, Univ. of Bern, available at <a href="https://arxiv.org/abs/0707.4643">https://arxiv.org/abs/0707.4643</a>.
</p>
<p>Duembgen, L. and Rufibach, K. (2009).
Maximum likelihood estimation of a log&ndash;concave density and its distribution function: basic properties and uniform consistency.
<em>Bernoulli</em>, <b>15(1)</b>, 40&ndash;68.
</p>
<p>Duembgen, L. and Rufibach, K. (2011).
logcondens: Computations Related to Univariate Log-Concave Density Estimation.
<em>Journal of Statistical Software</em>, <b>39(6)</b>, 1&ndash;28. <a href="https://doi.org/10.18637/jss.v039.i06">doi:10.18637/jss.v039.i06</a>
</p>
<p>Hoffleit, D., Warren, W.H. (1991).
<em>The Bright Star Catalog.</em>
Yale University Observatory, New Heaven.
</p>
<p>Mizera, I., Koenker, R. (2010).
Quasi-concave density estimation.
<em>Ann. Statist.</em>, <b>38(5)</b>, 2998&ndash;3027.
</p>
<p>Rufibach K. (2006).
<em>Log-concave Density Estimation and Bump Hunting for i.i.d. Observations.</em>
PhD Thesis, University of Bern, Switzerland and Georg-August University of Goettingen, Germany, 2006.
<br /> Available at <a href="https://slsp-ube.primo.exlibrisgroup.com/permalink/41SLSP_UBE/17e6d97/alma99116730175505511">https://slsp-ube.primo.exlibrisgroup.com/permalink/41SLSP_UBE/17e6d97/alma99116730175505511</a>.
</p>
<p>Rufibach, K. (2007).
Computing maximum likelihood estimators of a log-concave density function.
<em>J. Stat. Comput. Simul.</em> <b>77</b>, 561&ndash;574.
</p>
<p>Rufibach, K. (2012).
A smooth ROC curve estimator based on log-concave density estimates.
<em>Int. J. Biostat.</em>, <b>8</b>(1), 1&ndash;29.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## estimate gamma density
set.seed(1977)
x &lt;- rgamma(100, 2, 1)
res &lt;- logConDens(x, smoothed = FALSE, print = TRUE)
summary(res)

## compare performance to ICMA
res2 &lt;- icmaLogCon(x, T1 = 2000, robustif = TRUE, print = TRUE)

res$L
res2$L

## plot resulting functions
par(mfrow = c(2, 2), mar = c(3, 2, 1, 2))
plot(res, which = "density")
plot(res, which = "log-density")
plot(res, which = "CDF")
xli &lt;- range(res$x) + 0.1 * c(-1, 1) * diff(range(res$x))
plot(res$x, res$H, type = 'l', xlim = xli, yli = c(min(res$H) * 1.1, 0))
segments(res$knots, 0, res$knots, min(res$H) * 1.1, lty = 2)
rug(res$x); abline(h = 0, lty = 2)

## compute function values at an arbitrary point
x0 &lt;- (res$x[50] + res$x[51]) / 2
evaluateLogConDens(x0, res)

## compute 0.5 quantile of Fhat
quantilesLogConDens(0.5, res)
</code></pre>

<hr>
<h2 id='activeSetLogCon'>Computes a Log-Concave Probability Density Estimate via an Active Set Algorithm</h2><span id='topic+activeSetLogCon'></span><span id='topic+activeSet'></span>

<h3>Description</h3>

<p>Given a vector of observations <code class="reqn">{\bold{x}_n} = (x_1, \ldots, x_n)</code> 
with not necessarily equal entries, 
<code><a href="#topic+activeSetLogCon">activeSetLogCon</a></code> first computes vectors <code class="reqn">{\bold{x}_m} = (x_1, \ldots, x_m)</code> 
and <code class="reqn">{\bold{w}} = (w_1, \ldots, w_m)</code> where <code class="reqn">w_i</code> is the weight of each <code class="reqn">x_i</code> s.t. 
<code class="reqn">\sum_{i=1}^m w_i = 1</code>.
Then, <code><a href="#topic+activeSetLogCon">activeSetLogCon</a></code> computes a concave, piecewise 
linear function <code class="reqn">\widehat \phi_m</code> on <code class="reqn">[x_1, x_m]</code> with knots only in <code class="reqn">\{x_1, \ldots, x_m\}</code> such that 
</p>
<p style="text-align: center;"><code class="reqn">L(\phi) = \sum_{i=1}^m w_i \phi(x_i) - \int_{-\infty}^\infty \exp(\phi(t)) dt</code>
</p>

<p>is maximal. To accomplish this, an active set algorithm is used.</p>


<h3>Usage</h3>

<pre><code class='language-R'>activeSetLogCon(x, xgrid = NULL, print = FALSE, w = NA)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="activeSetLogCon_+3A_x">x</code></td>
<td>
<p>Vector of independent and identically distributed numbers, not necessarily unique.</p>
</td></tr>
<tr><td><code id="activeSetLogCon_+3A_xgrid">xgrid</code></td>
<td>
<p>Governs the generation of weights for observations. See <code><a href="#topic+preProcess">preProcess</a></code> for details.</p>
</td></tr>
<tr><td><code id="activeSetLogCon_+3A_print">print</code></td>
<td>
<p><code>print = TRUE</code> outputs the log-likelihood in every loop, <code>print = FALSE</code> does not. Make sure to tell <code>R</code> to output (press CTRL+W).</p>
</td></tr>
<tr><td><code id="activeSetLogCon_+3A_w">w</code></td>
<td>
<p>Optional vector of weights. If weights are provided, i.e. if <code>w != NA</code>, then <code>xgrid</code> is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>xn</code></td>
<td>
<p>Vector with initial observations <code class="reqn">x_1, \ldots, x_n</code>.</p>
</td></tr>  
<tr><td><code>x</code></td>
<td>
<p>Vector of observations <code class="reqn">x_1, \ldots, x_m</code> that was used to estimate the density. </p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>The vector of weights that had been used. Depends on the chosen setting for <code>xgrid</code>.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>Vector with entries <code class="reqn">\widehat \phi_m(x_i)</code>.</p>
</td></tr>
<tr><td><code>IsKnot</code></td>
<td>
<p>Vector with entries IsKnot<code class="reqn">_i = 1\{\widehat \phi_m</code> has a kink at <code class="reqn">x_i\}</code>.</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>The value <code class="reqn">L(\widehat {\bold{\phi}}_m)</code> of the log-likelihood-function <code class="reqn">L</code> at the 
maximum <code class="reqn">\widehat {\bold{\phi}}_m</code>.</p>
</td></tr>
<tr><td><code>Fhat</code></td>
<td>
<p>A vector <code class="reqn">(\widehat F_{m,i})_{i=1}^m</code> of the same size as <code class="reqn">{\bold{x}}</code> with entries 
</p>
<p style="text-align: center;"><code class="reqn">\widehat F_{m,i} = \int_{x_1}^{x_i} \exp(\widehat \phi_m(t)) dt.</code>
</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Vector <code class="reqn">(H_1, \ldots, H_m)'</code> where <code class="reqn">H_i</code> is the derivative of 
</p>
<p style="text-align: center;"><code class="reqn">t \to L(\phi + t\Delta_i)</code>
</p>

<p>at zero and <code class="reqn">\Delta_i(x) = \min(x - x_i, 0).</code></p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of initial observations.</p>
</td></tr>  
<tr><td><code>m</code></td>
<td>
<p>Number of unique observations.</p>
</td></tr>  
<tr><td><code>knots</code></td>
<td>
<p>Observations that correspond to the knots.</p>
</td></tr>
<tr><td><code>mode</code></td>
<td>
<p>Mode of the estimated density <code class="reqn">\hat f_m</code>.</p>
</td></tr>
<tr><td><code>sig</code></td>
<td>
<p>The standard deviation of the initial sample <code class="reqn">x_1, \ldots, x_n</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a></p>


<h3>References</h3>

<p>Duembgen, L, Huesler, A. and Rufibach, K. (2010)
Active set and EM algorithms for log-concave densities based on complete and censored data. 
Technical report 61, IMSV, Univ. of Bern, available at <a href="https://arxiv.org/abs/0707.4643">https://arxiv.org/abs/0707.4643</a>.
</p>
<p>Duembgen, L. and Rufibach, K. (2009)
Maximum likelihood estimation of a log&ndash;concave density and its distribution function: basic properties and uniform consistency. 
<em>Bernoulli</em>, <b>15(1)</b>, 40&ndash;68. 
</p>
<p>Duembgen, L. and Rufibach, K. (2011)
logcondens: Computations Related to Univariate Log-Concave Density Estimation. 
<em>Journal of Statistical Software</em>, <b>39(6)</b>, 1&ndash;28. <a href="https://doi.org/10.18637/jss.v039.i06">doi:10.18637/jss.v039.i06</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+activeSetLogCon">activeSetLogCon</a></code> can be used to estimate a log-concave density. However, to generate an object of
class <code>dlc</code> that allows application of <code><a href="base.html#topic+summary">summary</a></code> and <code><a href="base.html#topic+plot">plot</a></code> we recommend to use <code><a href="#topic+logConDens">logConDens</a></code>.
</p>
<p>The following functions are used by <code><a href="#topic+activeSetLogCon">activeSetLogCon</a></code>: 
</p>
<p><code><a href="#topic+J00">J00</a></code>, <code><a href="#topic+J10">J10</a></code>, <code><a href="#topic+J11">J11</a></code>, <code><a href="#topic+J20">J20</a></code>,
<code><a href="#topic+Local_LL">Local_LL</a></code>, <code><a href="#topic+Local_LL_all">Local_LL_all</a></code>, <code><a href="#topic+LocalCoarsen">LocalCoarsen</a></code>, 
<code><a href="#topic+LocalConvexity">LocalConvexity</a></code>, <code><a href="#topic+LocalExtend">LocalExtend</a></code>, <code><a href="#topic+LocalF">LocalF</a></code>, <code><a href="#topic+LocalMLE">LocalMLE</a></code>, 
<code><a href="#topic+LocalNormalize">LocalNormalize</a></code>, <code><a href="#topic+MLE">MLE</a></code>
</p>
<p>Log concave density estimation via an iterative convex minorant algorithm can be performed using
<code><a href="#topic+icmaLogCon">icmaLogCon</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## estimate gamma density
set.seed(1977)
n &lt;- 200
x &lt;- rgamma(n, 2, 1)
res &lt;- activeSetLogCon(x, w = rep(1 / n, n), print = FALSE)

## plot resulting functions
par(mfrow = c(2, 2), mar = c(3, 2, 1, 2))
plot(res$x, exp(res$phi), type = 'l'); rug(x)
plot(res$x, res$phi, type = 'l'); rug(x)
plot(res$x, res$Fhat, type = 'l'); rug(x)
plot(res$x, res$H, type = 'l'); rug(x)

## compute and plot function values at an arbitrary point
x0 &lt;- (res$x[100] + res$x[101]) / 2
Fx0 &lt;- evaluateLogConDens(x0, res, which = 3)[, "CDF"]
plot(res$x, res$Fhat, type = 'l'); rug(res$x)
abline(v = x0, lty = 3); abline(h = Fx0, lty = 3)

## compute and plot 0.9-quantile of Fhat
q &lt;- quantilesLogConDens(0.9, res)[2]
plot(res$x, res$Fhat, type = 'l'); rug(res$x)
abline(h = 0.9, lty = 3); abline(v = q, lty = 3)
</code></pre>

<hr>
<h2 id='activeSetRoutines'>Auxiliary Numerical Routines for the Function activeSetLogCon</h2><span id='topic+activeSetRoutines'></span><span id='topic+LocalCoarsen'></span><span id='topic+LocalConvexity'></span><span id='topic+LocalExtend'></span><span id='topic+LocalF'></span><span id='topic+LocalNormalize'></span><span id='topic+LocalMLE'></span><span id='topic+LocalVariance'></span>

<h3>Description</h3>

<p>Functions that are used by activeSetLogCon.</p>


<h3>Usage</h3>

<pre><code class='language-R'>LocalCoarsen(x, w, IsKnot)
LocalConvexity(x, phi)
LocalExtend(x, IsKnot, x2, phi2) 
LocalF(x, phi)
LocalNormalize(x, phi)
LocalMLE(x, w, IsKnot, phi_o, prec)
LocalVariance(x, w = NULL, phi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="activeSetRoutines_+3A_x">x</code></td>
<td>
<p>Vector of independent and identically distributed numbers, with strictly increasing entries.</p>
</td></tr>
<tr><td><code id="activeSetRoutines_+3A_w">w</code></td>
<td>
<p>Optional vector of nonnegative weights corresponding to <code class="reqn">{\bold{x}}</code>.</p>
</td></tr>
<tr><td><code id="activeSetRoutines_+3A_isknot">IsKnot</code></td>
<td>
<p>Vector with entries IsKnot<code class="reqn">_i = 1\{\phi</code> has a kink at <code class="reqn">x_i\}.</code></p>
</td></tr>
<tr><td><code id="activeSetRoutines_+3A_phi">phi</code></td>
<td>
<p>Vector with entries <code class="reqn">\phi(x_i).</code></p>
</td></tr>
<tr><td><code id="activeSetRoutines_+3A_x2">x2</code></td>
<td>
<p>Vector of same type as <code class="reqn">{\bold{x}}</code>.</p>
</td></tr>
<tr><td><code id="activeSetRoutines_+3A_phi2">phi2</code></td>
<td>
<p>Vector of same type as <code class="reqn">{\bold{\phi}}</code>.</p>
</td></tr>
<tr><td><code id="activeSetRoutines_+3A_phi_o">phi_o</code></td>
<td>
<p>Optional starting vector.</p>
</td></tr>
<tr><td><code id="activeSetRoutines_+3A_prec">prec</code></td>
<td>
<p>Threshold for the directional derivative during Newton-Raphson procedure.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a></p>


<h3>See Also</h3>

<p>All the above functions are used by <code><a href="#topic+activeSetLogCon">activeSetLogCon</a></code> to estimate a log-concave
probability density.
</p>
<p>Log concave density estimation via an iterative convex minorant algorithm can be performed using
<code><a href="#topic+icmaLogCon">icmaLogCon</a></code>.
</p>

<hr>
<h2 id='brightstar'>Bright star dataset used to illustrate log-concave density estimation</h2><span id='topic+brightstar'></span>

<h3>Description</h3>

<p>Dataset that contains the data analyzed in Mizera and Koenker (2009, Section 5).
The sample consists of measurements of radial and rotational velocities for the stars from the Bright Star Catalog, see Hoffleit and Warren (1991).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(brightstar)</code></pre>


<h3>Format</h3>

<p>A data frame with 9092 rows on the following 2 variables.
</p>

<dl>
<dt><code>nr</code></dt><dd><p>Location of measurements.</p>
</dd>
<dt><code>rad</code></dt><dd><p>Measurements of radial velocities.</p>
</dd>
<dt><code>rot</code></dt><dd><p>Measurements of rotational velocities.</p>
</dd>
</dl>



<h3>References</h3>

<p>Duembgen, L. and Rufibach, K. (2009)
Maximum likelihood estimation of a log&ndash;concave density and its distribution function: basic properties and uniform consistency. 
<em>Bernoulli</em>, <b>15(1)</b>, 40&ndash;68.
</p>
<p>Hoffleit, D., Warren, W.H. (1991).
<em>The Bright Star Catalog.</em>
Yale University Observatory, New Heaven.  
</p>
<p>Mizera, I., Koenker, R. (2010).
Quasi-concave density estimation.
<em>Ann. Statist.</em>, <b>38(5)</b>, 2998&ndash;3027. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ---- load rotational velocity data ----
data(brightstar)

# ---- compute and plot log-concave estimate ----
# See also Figure 3 in Koenker &amp; Mizera (2009)
x0 &lt;- sort(brightstar[, 3])
res &lt;- logConDens(x0, print = FALSE, smoothed = FALSE)
plot(res, which = "density")
</code></pre>

<hr>
<h2 id='confIntBootLogConROC_t0'>Function to compute a bootstrap confidence interval for the ROC curve at a given t, based on the log-concave ROC curve</h2><span id='topic+confIntBootLogConROC_t0'></span>

<h3>Description</h3>

<p>This function computes a bootstrap confidence interval for the ROC curve at a given value false negative fraction (1 - specificity) <code class="reqn">t</code>. The ROC curve estimate is based on log-concave densities, as discussed in Rufibach (2011).</p>


<h3>Usage</h3>

<pre><code class='language-R'>confIntBootLogConROC_t0(controls, cases, grid = c(0.2, 0.8), conf.level = 0.95, 
M = 1000, smooth = TRUE, output = TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confIntBootLogConROC_t0_+3A_cases">cases</code></td>
<td>
<p>Values of the continuous variable for the cases.</p>
</td></tr>
<tr><td><code id="confIntBootLogConROC_t0_+3A_controls">controls</code></td>
<td>
<p>Values of the continuous variable for the controls.</p>
</td></tr>
<tr><td><code id="confIntBootLogConROC_t0_+3A_grid">grid</code></td>
<td>
<p>Values of 1 - specificity where confidence intervals should be computed at (may be a vector).</p>
</td></tr>
<tr><td><code id="confIntBootLogConROC_t0_+3A_conf.level">conf.level</code></td>
<td>
<p>Confidence level of confidence interval.</p>
</td></tr>
<tr><td><code id="confIntBootLogConROC_t0_+3A_m">M</code></td>
<td>
<p>Number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="confIntBootLogConROC_t0_+3A_smooth">smooth</code></td>
<td>
<p><code>Logical</code>. Compute confidence interval also for ROC curve estimate based on smoothed log-concave densities.</p>
</td></tr>
<tr><td><code id="confIntBootLogConROC_t0_+3A_output">output</code></td>
<td>
<p><code>Logical</code>. Show progress of computations?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>qs</code></td>
<td>
<p><code>data.frame</code> with the columns <code>t</code> (false positive fractions where confidence interval is computed at) and the confidence intervals for the ROC curve at <code>grid</code>, based on the log-concave density estimate.</p>
</td></tr>
<tr><td><code>boot.mat</code></td>
<td>
<p>Bootstrap samples for the ROC curve based on the log-concave density estimate.</p>
</td></tr>
<tr><td><code>qs.smooth</code></td>
<td>
<p>If <code>smooth = TRUE</code>, same as <code>qs</code> but for the ROC curve based on the smooth log-concave density estimate.</p>
</td></tr>
<tr><td><code>boot.mat.smooth</code></td>
<td>
<p>If <code>smooth = TRUE</code>, bootstrap samples for the ROC curve based on the smoothed log-concave density estimate.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The confidence intervals are only valid if observations are <em>independent</em>, i.e. eacht patient only contributes one measurement, e.g.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach (maintainer) <br /> <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a> <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a>.</p>


<h3>References</h3>

<p>The reference for computation of these bootstrap confidence intervals is:
</p>
<p>Rufibach, K. (2012).
A smooth ROC curve estimator based on log-concave density estimates.
<em>Int. J. Biostat.</em>, <b>8</b>(1), 1&ndash;29.
</p>
<p>The bootstrap competitor based on the empirical ROC curve is described in:
</p>
<p>Zhou, X.H. and Qin, G. (2005).
Improved confidence intervals for the sensitivity at a fixed level of specificity of a continuous-scale diagnostic test.
<em>Statist. Med.</em>, <b>24</b>, 465&ndash;477.
</p>


<h3>See Also</h3>

<p>The ROC curve based on log-concave density estimates can be computed using <code><a href="#topic+logConROC">logConROC</a></code>. In the example below we analyze the <code><a href="#topic+pancreas">pancreas</a></code> data.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## ROC curve for pancreas data 
data(pancreas)
status &lt;- factor(pancreas[, "status"], levels = 0:1, labels = c("healthy", "diseased"))
var &lt;- log(pancreas[, "ca199"])
cases &lt;- var[status == "diseased"]
controls &lt;- var[status == "healthy"]

## compute confidence intervals
res &lt;- confIntBootLogConROC_t0(controls, cases, grid = c(0.2, 0.8), conf.level = 0.95, 
    M = 1000, smooth = TRUE, output = TRUE)
res

## End(Not run)
</code></pre>

<hr>
<h2 id='evaluateLogConDens'>Evaluates the Log-Density MLE and Smoothed Estimator at Arbitrary Real Numbers xs</h2><span id='topic+evaluateLogConDens'></span>

<h3>Description</h3>

<p>Based on a <code>"dlc"</code> object generated by <code><a href="#topic+logConDens">logConDens</a></code>, this function computes the values of  
</p>
<p style="text-align: center;"><code class="reqn">\widehat \phi_m(t)</code>
</p>

<p style="text-align: center;"><code class="reqn">\widehat f_m(t) = \exp(\widehat \phi_m(t))</code>
</p>

<p style="text-align: center;"><code class="reqn">\widehat F_m(t) = \int_{x_1}^t \exp(\widehat \phi_m(x)) dx</code>
</p>

<p style="text-align: center;"><code class="reqn">\widehat f_m^*(t) = \exp(\widehat \phi_m^*(t))</code>
</p>

<p style="text-align: center;"><code class="reqn">\widehat F_m^*(t) = \int_{x_1}^t \exp(\widehat \phi_m^*(x)) dx</code>
</p>

<p>at all real number <code class="reqn">t</code> in <code>xs</code>. The exact formula for <code class="reqn">\widehat F_m</code> and <code class="reqn">t \in [x_j,x_{j+1}]</code> is
</p>
<p style="text-align: center;"><code class="reqn">\widehat F_m(t)  = \widehat F_m(x_j)  + (x_{j+1}-x_j) J\Big(\widehat \phi_j, \widehat \phi_{j+1}, \frac{t-x_j}{x_{j+1}-x_j} \Big)</code>
</p>

<p>for the function <code class="reqn">J</code> introduced in <code><a href="#topic+Jfunctions">Jfunctions</a></code>. Closed formulas can also be given for <code class="reqn">\widehat f_m^*(t)</code>
and <code class="reqn">\widehat F_m^*(t)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluateLogConDens(xs, res, which = 1:5, gam = NULL, print = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluateLogConDens_+3A_xs">xs</code></td>
<td>
<p>Vector of real numbers where the functions should be evaluated at.</p>
</td></tr>
<tr><td><code id="evaluateLogConDens_+3A_res">res</code></td>
<td>
<p>An object of class <code>"dlc"</code>, usually a result of a call to <code>logConDens</code>.</p>
</td></tr>
<tr><td><code id="evaluateLogConDens_+3A_which">which</code></td>
<td>
<p>A (sub-)vector of <code>1:5</code> specifying which of the above quantities should be computed.</p>
</td></tr>
<tr><td><code id="evaluateLogConDens_+3A_gam">gam</code></td>
<td>
<p>Only necessary if <code>smoothed = TRUE</code>. The standard deviation of the normal kernel. If equal to 
<code>NULL</code>, <code>gam</code> is chosen such that the variances of the original sample <code class="reqn">x_1, \ldots, x_n</code> 
and <code class="reqn">\widehat f_n^*</code> coincide. See <code><a href="#topic+logConDens">logConDens</a></code> for details.</p>
</td></tr>
<tr><td><code id="evaluateLogConDens_+3A_print">print</code></td>
<td>
<p>Progress in computation of smooth estimates is shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with rows <code class="reqn">(x_{0, i}, \widehat \phi_m(x_{0, i}), \widehat f_m(x_{0, i}), \widehat F_m(x_{0, i}), \widehat f_m^*(x_{0, i}), \widehat F_m^*(x_{0, i}))</code>
where <code class="reqn">x_{0,i}</code> is the <code class="reqn">i</code>-th entry of <code>xs</code>.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## estimate gamma density
set.seed(1977)
x &lt;- rgamma(200, 2, 1)
res &lt;- logConDens(x, smoothed = TRUE, print = FALSE)

## compute function values at an arbitrary point
xs &lt;- (res$x[100] + res$x[101]) / 2
evaluateLogConDens(xs, res)

## only compute function values for non-smooth estimates
evaluateLogConDens(xs, res, which = 1:3)
</code></pre>

<hr>
<h2 id='icmaLogCon'>Computes a Log-Concave Probability Density Estimate via an Iterative Convex Minorant Algorithm</h2><span id='topic+icmaLogCon'></span>

<h3>Description</h3>

<p>Given a vector of observations <code class="reqn">{\bold{x}_n} = (x_1, \ldots, x_n)</code> 
with not necessarily equal entries, 
<code><a href="#topic+activeSetLogCon">activeSetLogCon</a></code> first computes vectors <code class="reqn">{\bold{x}_m} = (x_1, \ldots, x_m)</code> and
<code class="reqn">{\bold{w}} = (w_1, \ldots, w_m)</code> where <code class="reqn">w_i</code> is the weight of each <code class="reqn">x_i</code> s.t. 
<code class="reqn">\sum_{i=1}^m w_i = 1</code>.
Then, <code><a href="#topic+activeSetLogCon">activeSetLogCon</a></code> computes a concave, piecewise 
linear function <code class="reqn">\widehat \phi_m</code> on <code class="reqn">[x_1, x_m]</code> with knots only in <code class="reqn">\{x_1, \ldots, x_m\}</code> such that 
</p>
<p style="text-align: center;"><code class="reqn">L(\phi) = \sum_{i=1}^m w_i \phi(x_i) - \int_{-\infty}^\infty \exp(\phi(t)) dt</code>
</p>

<p>is maximal. In order to be able to apply the pool - adjacent - violaters algorithm, computations are performed
in the parametrization
</p>
<p style="text-align: center;"><code class="reqn">{\bold{\eta}}({\bold{\phi}}) = \Bigl(\phi_1, \Bigl(\eta_1 + \sum_{j=2}^i (x_i-x_{i-1})\eta_i\Bigr)_{i=2}^m \Bigr).</code>
</p>

<p>To find the maximum of <code class="reqn">L</code>, a variant of the iterative convex minorant using the pool - adjacent - violaters 
algorithm is used.</p>


<h3>Usage</h3>

<pre><code class='language-R'>icmaLogCon(x, xgrid = NULL, eps = 10^-8, T1 = 2000, 
    robustif = TRUE, print = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="icmaLogCon_+3A_x">x</code></td>
<td>
<p>Vector of independent and identically distributed numbers, not necessarily equal.</p>
</td></tr>
<tr><td><code id="icmaLogCon_+3A_xgrid">xgrid</code></td>
<td>
<p>Governs the generation of weights for observations. See <code><a href="#topic+preProcess">preProcess</a></code> for details.</p>
</td></tr>
<tr><td><code id="icmaLogCon_+3A_eps">eps</code></td>
<td>
<p>An arbitrary real number, typically small. Iterations are halted if the directional derivative of <code class="reqn">{\bold{\eta}} \to L({\bold{\eta}})</code> in the direction of the new candidate is <code class="reqn">\le \varepsilon</code>.</p>
</td></tr>
<tr><td><code id="icmaLogCon_+3A_t1">T1</code></td>
<td>
<p>Maximal number of iterations to perform.</p>
</td></tr>
<tr><td><code id="icmaLogCon_+3A_robustif">robustif</code></td>
<td>
<p><code>robustif = TRUE</code> performs the robustification and Hermite interpolation procedure detailed in 
Rufibach (2006, 2007), <code>robustif = FALSE</code> does not. In the latter case, convergence of the algorithm
is no longer guaranteed.</p>
</td></tr>
<tr><td><code id="icmaLogCon_+3A_print">print</code></td>
<td>
<p><code>print = TRUE</code> outputs log-likelihood in every loop, <code>print = FALSE</code> does not. Make sure to 
tell <code>R</code> to output (press CTRL+W).</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>Vector of observations <code class="reqn">x_1, \ldots, x_m</code> that was used to estimate the density. </p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>The vector of weights that had been used. Depends on the chosen setting for <code>xgrid</code>.</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Vector with entries <code class="reqn">\widehat f_m(x_i).</code></p>
</td></tr>
<tr><td><code>xn</code></td>
<td>
<p>Vector with initial observations <code class="reqn">x_1, \ldots, x_n</code>.</p>
</td></tr>  
<tr><td><code>Loglik</code></td>
<td>
<p>The value <code class="reqn">L(\widehat \phi_m)</code> of the log-likelihood-function <code class="reqn">L</code> at the maximum <code class="reqn">\widehat \phi_m.</code></p>
</td></tr>
<tr><td><code>Iterations</code></td>
<td>
<p>Number of iterations performed.</p>
</td></tr>
<tr><td><code>sig</code></td>
<td>
<p>The standard deviation of the initial sample <code class="reqn">x_1, \ldots, x_n</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a></p>


<h3>References</h3>

<p>Rufibach K. (2006) <em>Log-concave Density Estimation and Bump Hunting for i.i.d. Observations.</em>
PhD Thesis, University of Bern, Switzerland and Georg-August University of Goettingen, Germany, 2006.
<br /> Available at <a href="https://slsp-ube.primo.exlibrisgroup.com/permalink/41SLSP_UBE/17e6d97/alma99116730175505511">https://slsp-ube.primo.exlibrisgroup.com/permalink/41SLSP_UBE/17e6d97/alma99116730175505511</a>.
</p>
<p>Rufibach, K. (2007)
Computing maximum likelihood estimators of a log-concave density function.
<em>J. Stat. Comput. Simul.</em> <b>77</b>, 561&ndash;574.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icmaLogCon">icmaLogCon</a></code> can be used to estimate a log-concave density. However, to generate an object of
class <code>dlc</code> that allows application of <code><a href="base.html#topic+summary">summary</a></code> and <code><a href="base.html#topic+plot">plot</a></code> one has to 
use <code><a href="#topic+logConDens">logConDens</a></code>.
</p>
<p>The following functions are used by <code><a href="#topic+icmaLogCon">icmaLogCon</a></code>: 
</p>
<p><code><a href="#topic+phieta">phieta</a></code>, <code><a href="#topic+etaphi">etaphi</a></code>, <code><a href="#topic+Lhat_eta">Lhat_eta</a></code>, <code><a href="#topic+quadDeriv">quadDeriv</a></code>,
<code><a href="#topic+robust">robust</a></code>, <code><a href="#topic+isoMean">isoMean</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1977)
x &lt;- rgamma(200, 2, 1)
## Not run: 
res &lt;- icmaLogCon(x, T1 = 2000, robustif = TRUE, print = TRUE)

## plot resulting functions
par(mfrow = c(2, 1), mar = c(3, 2, 1, 2))
plot(x, exp(res$phi), type = 'l'); rug(x)
plot(x, res$phi, type = 'l'); rug(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='intECDF'>Computes the Integrated Empirical Distribution Function at Arbitrary Real Numbers in s</h2><span id='topic+intECDF'></span>

<h3>Description</h3>

<p>Computes the value of
</p>
<p style="text-align: center;"><code class="reqn">\bar{I}(t) = \int_{x_1}^t \bar{F}(r) d \, r</code>
</p>

<p>where <code class="reqn">\bar F</code> is the empirical distribution function of <code class="reqn">x_1,\ldots,x_m</code>, at all real numbers <code class="reqn">t</code> in the 
vector <code class="reqn">\bold{s}</code>. Note that <code class="reqn">t</code> (so all elements in <code class="reqn">\bold{s}</code>) must lie in <code class="reqn">[x_1,x_m]</code>. 
The exact formula for <code class="reqn">\bar I(t)</code> is
</p>
<p style="text-align: center;"><code class="reqn">\bar I(t)  = \Big(\sum_{i=2}^{i_0}(x_i-x_{i-1})\frac{i-1}{n} \Big) + (t-x_{i_0})\frac{i_0-1}{n}</code>
</p>

<p>where <code class="reqn">i_0 = \max_{i=1,\ldots,m} \{x_i \le t\}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intECDF(s, x)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intECDF_+3A_s">s</code></td>
<td>
<p>Vector of real numbers in <code class="reqn">[x_1,x_m]</code> where <code class="reqn">\bar{I}</code> should be evaluated at.</p>
</td></tr>
<tr><td><code id="intECDF_+3A_x">x</code></td>
<td>
<p>Vector <code class="reqn">{\bold{x}} = (x_1, \ldots, x_m)</code> of original observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of the same length as <code class="reqn">\bold{s}</code>, containing the values of <code class="reqn">\bar I</code> at the elements of <code class="reqn">\bold{s}</code>.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a></p>


<h3>References</h3>

<p>Duembgen, L. and Rufibach, K. (2009)
Maximum likelihood estimation of a log&ndash;concave density and its distribution function: basic properties and uniform consistency. 
<em>Bernoulli</em>, <b>15(1)</b>, 40&ndash;68.  
</p>
<p>Duembgen, L. and Rufibach, K. (2011)
logcondens: Computations Related to Univariate Log-Concave Density Estimation. 
<em>Journal of Statistical Software</em>, <b>39(6)</b>, 1&ndash;28. <a href="https://doi.org/10.18637/jss.v039.i06">doi:10.18637/jss.v039.i06</a>
</p>
<p>Rufibach K. (2006) <em>Log-concave Density Estimation and Bump Hunting for i.i.d. Observations.</em>
PhD Thesis, University of Bern, Switzerland and Georg-August University of Goettingen, Germany, 2006.
<br /> Available at <a href="https://slsp-ube.primo.exlibrisgroup.com/permalink/41SLSP_UBE/17e6d97/alma99116730175505511">https://slsp-ube.primo.exlibrisgroup.com/permalink/41SLSP_UBE/17e6d97/alma99116730175505511</a>.
</p>


<h3>See Also</h3>

<p>This function together with <code><a href="#topic+intF">intF</a></code> can be used to check the characterization of the log-concave density
estimator in terms of distribution functions, see Rufibach (2006) and Duembgen and Rufibach (2009).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for an example see the function intF.
</code></pre>

<hr>
<h2 id='intF'>Computes the Integral of the estimated CDF at Arbitrary Real Numbers in s</h2><span id='topic+intF'></span>

<h3>Description</h3>

<p>Based on an object of class <code>dlc</code> as output by the function <code><a href="#topic+logConDens">logConDens</a></code>, 
this function gives values of 
</p>
<p style="text-align: center;"><code class="reqn">\widehat I(t) = \int_{x_1}^t \widehat{F}(r) d r</code>
</p>

<p>at all numbers in <code class="reqn">\bold{s}</code>. Note that <code class="reqn">t</code> (so all elements in <code class="reqn">\bold{s}</code>) must lie in 
<code class="reqn">[x_1,x_m]</code>. The exact formula for <code class="reqn">\widehat I(t)</code> is
</p>
<p style="text-align: center;"><code class="reqn">\widehat I(t)  = \Bigl(\sum_{i=1}^{i_0} \widehat{I}_i(x_{i+1})\Bigr)+\widehat{I}_{i_0}(t)</code>
</p>

<p>where <code class="reqn">i_0 = </code>min<code class="reqn">\{m-1 \, , \ \{i \ : \ x_i \le t \}\}</code> and
</p>
<p style="text-align: center;"><code class="reqn">I_j(x) = \int_{x_j}^x \widehat{F}(r) d r = (x-x_j)\widehat{F}(x_j)+\Delta x_{j+1}\Bigl(\frac{\Delta x_{j+1}}{\Delta \widehat\phi_{j+1}}J\Bigl(\widehat\phi_j,\widehat\phi_{j+1}, \frac{x-x_j}{\Delta x_{j+1}}\Bigr)-\frac{\widehat f(x_j)(x-x_j)}{\Delta \widehat \phi_{j+1}}\Bigr)</code>
</p>

<p>for <code class="reqn">x \in [x_j, x_{j+1}], \ j = 1,\ldots, m-1</code>, <code class="reqn">\Delta v_{i+1} = v_{i+1} - v_i</code> for any vector <code class="reqn">\bold{v}</code>
and the function <code class="reqn">J</code> introduced in <code><a href="#topic+Jfunctions">Jfunctions</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intF(s, res)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intF_+3A_s">s</code></td>
<td>
<p>Vector of real numbers where the functions should be evaluated at.</p>
</td></tr>
<tr><td><code id="intF_+3A_res">res</code></td>
<td>
<p>An object of class <code>"dlc"</code>, usually a result of a call to <code>logConDens</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of the same length as <code class="reqn">\bold{s}</code>, containing the values of <code class="reqn">\widehat I</code> at the elements of 
<code class="reqn">\bold{s}</code>.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a></p>


<h3>References</h3>

<p>Duembgen, L. and Rufibach, K. (2009)
Maximum likelihood estimation of a log&ndash;concave density and its distribution function: basic properties and uniform consistency. 
<em>Bernoulli</em>, <b>15(1)</b>, 40&ndash;68.  
</p>
<p>Duembgen, L. and Rufibach, K. (2011)
logcondens: Computations Related to Univariate Log-Concave Density Estimation. 
<em>Journal of Statistical Software</em>, <b>39(6)</b>, 1&ndash;28. <a href="https://doi.org/10.18637/jss.v039.i06">doi:10.18637/jss.v039.i06</a>
</p>
<p>Rufibach K. (2006) <em>Log-concave Density Estimation and Bump Hunting for i.i.d. Observations.</em>
PhD Thesis, University of Bern, Switzerland and Georg-August University of Goettingen, Germany, 2006.
<br /> Available at <a href="https://slsp-ube.primo.exlibrisgroup.com/permalink/41SLSP_UBE/17e6d97/alma99116730175505511">https://slsp-ube.primo.exlibrisgroup.com/permalink/41SLSP_UBE/17e6d97/alma99116730175505511</a>.
</p>


<h3>See Also</h3>

<p>This function uses the output of <code><a href="#topic+activeSetLogCon">activeSetLogCon</a></code>. The function <code><a href="#topic+intECDF">intECDF</a></code> is similar, but based
on the empirical distribution function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## estimate gamma density
set.seed(1977)
x &lt;- rgamma(200, 2, 1)
res &lt;- logConDens(x, smoothed = FALSE, print = FALSE)

## compute and plot the process D(t) in Duembgen and Rufibach (2009)
s &lt;- seq(min(res$x), max(res$x), by = 10 ^ -3)
D1 &lt;- intF(s, res)
D2 &lt;- intECDF(s, res$xn)
par(mfrow = c(2, 1))
plot(res$x, res$phi, type = 'l'); rug(res$x)
plot(s, D1 - D2, type = 'l'); abline(h = 0, lty = 2)
</code></pre>

<hr>
<h2 id='isoMean'>Pool-Adjacent Violaters Algorithm: Least Square Fit under Monotonicity Constraint</h2><span id='topic+isoMean'></span>

<h3>Description</h3>

<p>Fits a vector <code class="reqn">\widehat {\bold{g}}</code> with nondecreasing components to the data vector 
<code class="reqn">{\bold{y}}</code> such that 
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i=1}^n (y_i - \widehat g_i)^2 </code>
</p>

<p>is minimal (pool - adjacent - violators algorithm). In case a weight vector with positive entries (and the same size as <code class="reqn">{\bold{y}}</code>) is provided, the function produces an isotonic vector minimizing 
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i=1}^n w_i(y_i - \widehat g_i)^2 .</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>isoMean(y, w)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isoMean_+3A_y">y</code></td>
<td>
<p>Vector <code class="reqn">(y_1, \ldots, y_n)</code> of data points.</p>
</td></tr>
<tr><td><code id="isoMean_+3A_w">w</code></td>
<td>
<p>Arbitrary vector <code class="reqn">(w_1, \ldots, w_n)</code> of weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns vector <code class="reqn">\widehat {\bold{g}}</code>.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## simple regression model
n &lt;- 50
x &lt;- sort(runif(n, 0, 1))
y &lt;- x ^ 2 + rnorm(n, 0, 0.2)
s &lt;- seq(0, 1, by = 0.01)
plot(s, s ^ 2, col = 2, type = 'l', xlim = range(c(0, 1, x)), 
    ylim = range(c(0, 1 , y))); rug(x)

## plot pava result
lines(x, isoMean(y, rep(1 / n, n)), type = 's')
</code></pre>

<hr>
<h2 id='Jfunctions'>Numerical Routine J and Some Derivatives</h2><span id='topic+Jfunctions'></span><span id='topic+J00'></span><span id='topic+J10'></span><span id='topic+J11'></span><span id='topic+J20'></span>

<h3>Description</h3>

<p>J00 represents the function <code class="reqn">J(x, y, v),</code> where for real numbers <code class="reqn">x, y</code> and <code class="reqn">v \in [0, 1],</code>
</p>
<p style="text-align: center;"><code class="reqn">J(x, y, v) = \int_0^v \exp((1-t)x + ty) d t = \frac{\exp(x + v(y - x)) - \exp(x)}{y - x}.</code>
</p>

<p>The functions Jab give the respective derivatives <code class="reqn">J_{ab}</code> for <code class="reqn">v = 1</code>, i.e.
</p>
<p style="text-align: center;"><code class="reqn">J_{ab}(x, y) = \frac{\partial^{a+b}}{\partial x^a \partial y^b} J(x, y).</code>
</p>

<p>Specifically, 
</p>
<p style="text-align: center;"><code class="reqn">J_{10}(x, y) = \frac{\exp(y) - \exp(x) - (y - x) \exp(x)}{(y - x)^2};</code>
</p>

<p style="text-align: center;"><code class="reqn">J_{11}(x, y) = \frac{(y - x)(\exp(x) + \exp(y)) + 2 (\exp(y) - \exp(x))}{(y - x)^3};</code>
</p>

<p style="text-align: center;"><code class="reqn">J_{20}(x, y) = 2\frac{\exp(y) - \exp(x) - (y - x)\exp(x)-(y - x)^2 \exp(x)}{(y - x)^3}.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>J00(x, y, v)
J10(x, y)
J11(x, y)
J20(x, y)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Jfunctions_+3A_x">x</code></td>
<td>
<p>Vector of length <code class="reqn">d</code> with real entries.</p>
</td></tr>
<tr><td><code id="Jfunctions_+3A_y">y</code></td>
<td>
<p>Vector of length <code class="reqn">d</code> with real entries.</p>
</td></tr>
<tr><td><code id="Jfunctions_+3A_v">v</code></td>
<td>
<p>Number in <code class="reqn">[0, 1]^d</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of the respective function.</p>


<h3>Note</h3>

<p>Taylor approximations are used if <code class="reqn">y-x</code> is small. We refer to Duembgen et al (2011, Section 6) for 
details.
</p>
<p>These functions are not intended to be invoked by the end user.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a></p>


<h3>References</h3>

<p>Duembgen, L, Huesler, A. and Rufibach, K. (2010)
Active set and EM algorithms for log-concave densities based on complete and censored data. 
Technical report 61, IMSV, Univ. of Bern, available at <a href="https://arxiv.org/abs/0707.4643">https://arxiv.org/abs/0707.4643</a>.
</p>
<p>Duembgen, L. and Rufibach, K. (2011)
logcondens: Computations Related to Univariate Log-Concave Density Estimation. 
<em>Journal of Statistical Software</em>, <b>39(6)</b>, 1&ndash;28. <a href="https://doi.org/10.18637/jss.v039.i06">doi:10.18637/jss.v039.i06</a>
</p>

<hr>
<h2 id='Lhat_eta'>Value of the Log-Likelihood Function L, where Input is in Eta-Parametrization</h2><span id='topic+Lhat_eta'></span>

<h3>Description</h3>

<p>Gives the value of 
</p>
<p style="text-align: center;"><code class="reqn">L(\phi) = \sum_{i=1}^m w_i \phi(x_i) - \int_{x_1}^{x_m} \exp(\phi(t)) dt</code>
</p>

<p>where <code class="reqn">\phi</code> is parametrized via 
</p>
<p style="text-align: center;"><code class="reqn">{\bold{\eta}}({\bold{\phi}}) = \Bigl(\phi_1, \Bigl(\eta_1 + \sum_{j=2}^i (x_i-x_{i-1})\eta_i\Bigr)_{i=2}^m\Bigr).</code>
</p>
 


<h3>Usage</h3>

<pre><code class='language-R'>Lhat_eta(x, w, eta)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lhat_eta_+3A_x">x</code></td>
<td>
<p>Vector of independent and identically distributed numbers, with strictly increasing entries.</p>
</td></tr>
<tr><td><code id="Lhat_eta_+3A_w">w</code></td>
<td>
<p>Optional vector of nonnegative weights corresponding to <code class="reqn">{\bold{x}_m}</code>.</p>
</td></tr>
<tr><td><code id="Lhat_eta_+3A_eta">eta</code></td>
<td>
<p>Some vector <code class="reqn">{\bold{\eta}}</code> of the same length as <code class="reqn">{\bold{x}}</code> and <code class="reqn">{\bold{w}}</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value <code class="reqn">L({\bold{\phi}}) = L({\bold{\phi}}({\bold{\eta}}))</code> of the log-likelihood function is returned.</p>


<h3>Note</h3>

<p>This function is not intended to be invoked by the end user.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a></p>

<hr>
<h2 id='Local_LL'>Value of the Log-Likelihood Function L, where Input is in Phi-Parametrization</h2><span id='topic+Local_LL'></span>

<h3>Description</h3>

<p>Gives the value of 
</p>
<p style="text-align: center;"><code class="reqn">L(\phi) = \sum_{i=1}^m w_i \phi(x_i) - \int_{x_1}^{x_m} \exp(\phi(t)) dt.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>Local_LL(x, w, phi)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Local_LL_+3A_x">x</code></td>
<td>
<p>Vector of independent and identically distributed numbers, with strictly increasing entries.</p>
</td></tr>
<tr><td><code id="Local_LL_+3A_w">w</code></td>
<td>
<p>Optional vector of nonnegative weights corresponding to <code class="reqn">{\bold{x}_m}</code>.</p>
</td></tr>
<tr><td><code id="Local_LL_+3A_phi">phi</code></td>
<td>
<p>Some vector <code class="reqn">{\bold{\phi}}</code> of the same length as <code class="reqn">{\bold{x}}</code> and <code class="reqn">{\bold{w}}</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value <code class="reqn">L=L({\bold{\phi}})</code> of the log-likelihood function is returned.</p>


<h3>Note</h3>

<p>This function is not intended to be invoked by the end user.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a></p>

<hr>
<h2 id='Local_LL_all'>Log-likelihood, New Candidate and Directional Derivative for L</h2><span id='topic+Local_LL_all'></span>

<h3>Description</h3>

<p>Computes the value of the log-likelihood function
</p>
<p style="text-align: center;"><code class="reqn">L(\phi) = \sum_{i=1}^m w_i \phi(x_i) - \int_{x_1}^{x_m} \exp(\phi(t)) dt,</code>
</p>

<p>a new candidate for <code class="reqn">\phi</code> via the Newton method as well as the directional derivative of <code class="reqn">{\bold{\phi}} \to L({\bold{\phi}})</code> 
into that direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Local_LL_all(x, w, phi)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Local_LL_all_+3A_x">x</code></td>
<td>
<p>Vector of independent and identically distributed numbers, with strictly increasing entries.</p>
</td></tr>
<tr><td><code id="Local_LL_all_+3A_w">w</code></td>
<td>
<p>Optional vector of nonnegative weights corresponding to <code class="reqn">{\bold{x}_m}</code>.</p>
</td></tr>
<tr><td><code id="Local_LL_all_+3A_phi">phi</code></td>
<td>
<p>Some vector <code class="reqn">{\bold{\phi}}</code> of the same length as <code class="reqn">{\bold{x}}</code> and <code class="reqn">{\bold{w}}</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ll</code></td>
<td>
<p>Value <code class="reqn">L(\phi)</code> of the log-likelihood function at <code class="reqn">\phi.</code></p>
</td></tr>
<tr><td><code>phi_new</code></td>
<td>
<p>New candidate for <code class="reqn">\phi</code> via the Newton-method, using the complete Hessian matrix.</p>
</td></tr>
<tr><td><code>dirderiv</code></td>
<td>
<p>Directional derivative of <code class="reqn">\phi \to L(\phi)</code> into the direction <code class="reqn">\phi_{new}.</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is not intended to be invoked by the end user.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a></p>

<hr>
<h2 id='logConCI'>Compute pointwise confidence interval for a density assuming log-concavity</h2><span id='topic+logConCI'></span>

<h3>Description</h3>

<p>Compute approximate confidence interval for the true log-concave density, on a grid of points.  Two main approaches are implemented:  
In the first, the confidence interval at a fixed point is based on the pointwise asymptotic theory for the log-concave maximum likelihood estimator (MLE) developed in Balabdaoui, Rufibach, and Wellner (2009). In the second, the confidence interval is estimated via the boostrap.</p>


<h3>Usage</h3>

<pre><code class='language-R'>logConCI(res, xx0, conf.level = c(0.8, 0.9, 0.95, 0.99)[3], 
    type = c("DR", "ks", "nrd", "ECDFboot", "NPMLboot")[2], 
    htype = c("hscv", "hlscv", "hpi", "hns")[4], BB = 500)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logConCI_+3A_res">res</code></td>
<td>
<p>An object of class <code>dlc</code>, usually a result of a call to <code>logConDens</code>.</p>
</td></tr>
<tr><td><code id="logConCI_+3A_xx0">xx0</code></td>
<td>
<p>Vector of grid points at which to calculate the confidence interval.</p>
</td></tr>
<tr><td><code id="logConCI_+3A_conf.level">conf.level</code></td>
<td>
<p>Confidence level for the confidence interval(s). The default is 95%.</p>
</td></tr>
<tr><td><code id="logConCI_+3A_type">type</code></td>
<td>
<p>Vector of strings indicating type of confidence interval to compute.  When <code>type = ks</code> is chosen, then <code>htype</code> should also be specified. The default is <code>type = ks</code>.</p>
</td></tr>	
<tr><td><code id="logConCI_+3A_htype">htype</code></td>
<td>
<p>Vector of strings indicating bandwidth selection method if <code>type = ks</code>. The default is <code>htype = hns</code>.</p>
</td></tr>
<tr><td><code id="logConCI_+3A_bb">BB</code></td>
<td>
<p>number of iterations in the bootstrap if <code>type = NPMLboot</code> or <code>type = ECDFboot</code>. The default is <code>BB = 500</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In Balabdaoui et al. (2009) it is shown that (if the true density is strictly log-concave) the limiting distribution of the MLE of a log-concave 
density <code class="reqn">\widehat f_n</code> at a point <code class="reqn">x</code> is
</p>
<p style="text-align: center;"><code class="reqn">n^{2/5}(\widehat f_n(x)-f(x)) \to c_2(x) \bar{C}(0).</code>
</p>

<p>The nuisance parameter <code class="reqn">c_2(x)</code> depends on the true density <code class="reqn">f</code> and the second derivative of its logarithm. The limiting process <code class="reqn">\bar{C}(0)</code> 
is found as the second derivative at zero of a particular operator (called the &quot;envelope&quot;) of an integrated Brownian motion plus <code class="reqn">t^4</code>.   
</p>
<p>Three of the confidence intervals are based on inverting the above limit using estimated quantiles of <code class="reqn">\bar{C}(0)</code>, and estimating the nuisance 
parameter <code class="reqn">c_2(x)</code>. The options for the function <code>logConCI</code> provide different ways to estimate this nuisance parameter. If <code>type = "DR"</code>, 
<code class="reqn">c_2(x)</code> is estimated using derivatives of the smoothed MLE as calculated by the function <code>logConDens</code> (this method does not perform well in 
simulations and is therefore not recommended). If <code>type="ks"</code>, <code class="reqn">c_2(x)</code> is estimated using kernel density estimates of the true density and its 
first and second derivatives. This is done using the <code>R</code> package <span class="pkg">ks</span>, and, with this option, a bandwidth selection method <code>htype</code> must also 
be chosen. The choices in <code>htype</code> correspond to the various options for bandwidth selection available in <span class="pkg">ks</span>. If <code>type = "nrd"</code>, the second 
derivative of the logarithm of the true density in <code class="reqn">c_2(x)</code> is estimated assuming a normal reference distribution. 
</p>
<p>Two of the confidence intervals are based on the bootstrap. For <code>type = "ECDFboot"</code> confidence intervals based on re-sampling from the empirical 
cumulative distribution function are computed. For <code>type = "NPMLboot"</code> confidence intervals based on re-sampling from the nonparametric maximum 
likelihood estimate of log-concave density are computed. Bootstrap confidence intervals take a few minutes to compute!  
</p>
<p>The default option is <code>type = "ks"</code> with <code>htype = "hns"</code>.  Currently available confidence levels are 80%, 90%, 95% and 99%, with a default 
of 95%.   
</p>
<p>Azadbakhsh et al. (2014) provides an empirical study of the relative performance of the various approaches available in this function.    
</p>


<h3>Value</h3>

<p>The function returns a list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>fhat</code></td>
<td>
<p>MLE evaluated at grid points.</p>
</td></tr>
<tr><td><code>up_DR</code></td>
<td>
<p>Upper confidence interval limit when <code>type = DR</code>.</p>
</td></tr>
<tr><td><code>lo_DR</code></td>
<td>
<p>Lower confidence interval limit when <code>type = DR</code>.</p>
</td></tr>
<tr><td><code>up_ks_hscv</code></td>
<td>
<p>Upper confidence interval limit when <code>type = ks</code> and <code>htype = hscv</code>.</p>
</td></tr>
<tr><td><code>lo_ks_hscv</code></td>
<td>
<p>Lower confidence interval limit when <code>type = ks</code> and <code>htype = hscv</code>.</p>
</td></tr>
<tr><td><code>up_ks_hlscv</code></td>
<td>
<p>Upper confidence interval limit when <code>type = ks</code> and <code>htype = hlscv</code>.</p>
</td></tr>
<tr><td><code>lo_ks_hlscv</code></td>
<td>
<p>Lower confidence interval limit when <code>type = ks</code> and <code>htype = hlscv</code>.</p>
</td></tr>
<tr><td><code>up_ks_hpi</code></td>
<td>
<p>Upper confidence interval limit when <code>type = ks</code> and <code>htype = hpi</code>.</p>
</td></tr>
<tr><td><code>lo_ks_hpi</code></td>
<td>
<p>Lower confidence interval limit when <code>type = ks</code> and <code>htype = hpi</code>.</p>
</td></tr>
<tr><td><code>up_ks_hns</code></td>
<td>
<p>Upper confidence interval limit when <code>type = ks</code> and <code>htype = hns</code>.</p>
</td></tr>
<tr><td><code>lo_ks_hns</code></td>
<td>
<p>Lower confidence interval limit when <code>type = ks</code> and <code>htype = hns</code>.</p>
</td></tr>
<tr><td><code>up_nrd</code></td>
<td>
<p>Upper confidence interval limit when <code>type = nrd</code>.</p>
</td></tr>
<tr><td><code>lo_nrd</code></td>
<td>
<p>Lower confidence interval limit when <code>type = nrd</code>.</p>
</td></tr>
<tr><td><code>up_npml</code></td>
<td>
<p>Upper confidence interval limit when <code>type = NPMLboot</code>.</p>
</td></tr>
<tr><td><code>lo_npml</code></td>
<td>
<p>Lower confidence interval limit when <code>boot = NPMLboot</code>.</p>
</td></tr>
<tr><td><code>up_ecdf</code></td>
<td>
<p>Upper confidence interval limit when <code>boot = ECDFboot</code>.</p>
</td></tr>
<tr><td><code>lo_ecdf</code></td>
<td>
<p>Lower confidence interval limit when <code>boot = ECDFboot</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mahdis Azadbakhsh 
</p>
<p>Hanna Jankowski, <a href="mailto:hkj@yorku.ca">hkj@yorku.ca</a>
</p>


<h3>References</h3>

<p>Azadbakhsh, M., Jankowski, H. and Gao, X. (2014).
Computing confidence intervals for log-concave densities. 
<em>Comput. Statist. Data Anal.</em>, <b>75</b>, 248&ndash;264.
</p>
<p>Baladbaoui, F., Rufibach, K. and Wellner, J. (2009)
Limit distribution theory for maximum likelihood estimation of a log-concave density.
<em>Ann. Statist.</em>, <b>37(3)</b>, 1299&ndash;1331.
</p>
<p>Tarn Duong (2012). ks: Kernel smoothing. 
R package version 1.8.10. <a href="https://CRAN.R-project.org/package=ks">https://CRAN.R-project.org/package=ks</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## ===================================================
## Confidence intervals at a fixed point for the density
## ===================================================
data(reliability)
x.rel &lt;- sort(reliability)

# calculate 95
grid &lt;- seq(min(x.rel), max(x.rel), length.out = 200)
res &lt;- logConDens(x.rel)
ci  &lt;- logConCI(res, grid, type = c("nrd", "ECDFboot"))	

par(las = 1, mar = c(2.5, 3.5, 0.5, 0.5))
hist(x.rel, n = 25, col = gray(0.9), main = "", freq = FALSE, 
    xlab = "", ylab = "", ylim = c(0, 0.0065), border = gray(0.5))
lines(grid, ci$fhat, col = "black", lwd = 2)
lines(grid, ci$lo_nrd, col = "red", lwd = 2, lty = 2)
lines(grid, ci$up_nrd, col = "red", lwd = 2, lty = 2)
lines(grid, ci$lo_ecdf, col = "blue", lwd = 2, lty = 2)
lines(grid, ci$up_ecdf, col = "blue", lwd = 2, lty = 2)
legend("topleft", col = c("black", "blue", "red"), lwd = 2, lty = c(1, 2, 2), legend = 
c("log-concave NPMLE", "CI for type = nrd", "CI for type = ECDFboot"), bty = "n")

## End(Not run)</code></pre>

<hr>
<h2 id='logConCIfunctions'>Functions that are used by logConCI</h2><span id='topic+logConCIfunctions'></span><span id='topic+ftilde'></span><span id='topic+c2hat'></span><span id='topic+rLCD'></span>

<h3>Description</h3>

<p>Functions that are used by <code><a href="#topic+logConCI">logConCI</a></code> and are not intended to be called by the user.</p>


<h3>Author(s)</h3>

<p>Mahdis Azadbakhsh 
</p>
<p>Hanna Jankowski, <a href="mailto:hkj@yorku.ca">hkj@yorku.ca</a>
</p>


<h3>References</h3>

<p>Azadbakhsh, M., Jankowski, H. and Gao, X. (2014).
Computing confidence intervals for log-concave densities. 
<em>Comput. Statist. Data Anal.</em>, <b>75</b>, 248&ndash;264.
</p>
<p>Baladbaoui, F., Rufibach, K. and Wellner, J. (2009).
Limit distribution theory for maximum likelihood estimation of a log-concave density.
<em>Ann. Statist.</em>, <b>37(3)</b>, 1299&ndash;1331.
</p>
<p>Tarn Duong (2012). ks: Kernel smoothing. 
R package version 1.8.10. <a href="https://CRAN.R-project.org/package=ks">https://CRAN.R-project.org/package=ks</a>
</p>

<hr>
<h2 id='logConDens'>Compute log-concave density estimator and related quantities</h2><span id='topic+logConDens'></span>

<h3>Description</h3>

<p>Compute the log-concave and smoothed log-concave density estimator.</p>


<h3>Usage</h3>

<pre><code class='language-R'>logConDens(x, xgrid = NULL, smoothed = TRUE, print = FALSE, 
    gam = NULL, xs = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logConDens_+3A_x">x</code></td>
<td>
<p>Vector of independent and identically distributed numbers, not necessarily unique.</p>
</td></tr>
<tr><td><code id="logConDens_+3A_xgrid">xgrid</code></td>
<td>
<p>Governs the generation of weights for observations. See <code><a href="#topic+preProcess">preProcess</a></code> for details.</p>
</td></tr>
<tr><td><code id="logConDens_+3A_smoothed">smoothed</code></td>
<td>
<p>If <code>TRUE</code>, the smoothed version of the log-concave density estimator is also computed.</p>
</td></tr>
<tr><td><code id="logConDens_+3A_print">print</code></td>
<td>
<p><code>print = TRUE</code> outputs the log-likelihood in every loop, <code>print = FALSE</code> does not. Make sure to tell <code>R</code> to output (press CTRL+W).</p>
</td></tr>
<tr><td><code id="logConDens_+3A_gam">gam</code></td>
<td>
<p>Only necessary if <code>smoothed = TRUE</code>. The standard deviation of the normal kernel. If equal to <code>NULL</code>, <code>gam</code> is chosen
such that the variances of the original sample <code class="reqn">x_1, \ldots, x_n</code> and <code class="reqn">\widehat f_n^*</code> coincide.</p>
</td></tr>
<tr><td><code id="logConDens_+3A_xs">xs</code></td>
<td>
<p>Only necessary if <code>smoothed = TRUE</code>. Either provide a vector of support points where the smoothed estimator should be computed at, or
leave as <code>NULL</code>. Then, a sufficiently width equidistant grid of points will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+activeSetLogCon">activeSetLogCon</a></code> for details on the computations.</p>


<h3>Value</h3>

<p><code><a href="#topic+logConDens">logConDens</a></code> returns an object of class <code>"dlc"</code>, a list containing the 
following components:
<code>xn</code>, <code>x</code>, <code>w</code>, <code>phi</code>, <code>IsKnot</code>, <code>L</code>, <code>Fhat</code>, <code>H</code>,
<code>n</code>, <code>m</code>, <code>knots</code>, <code>mode</code>, and <code>sig</code> as generated
by <code><a href="#topic+activeSetLogCon">activeSetLogCon</a></code>. If <code>smoothed = TRUE</code>, then the returned object additionally contains
<code>f.smoothed</code>, <code>F.smoothed</code>, <code>gam</code>, and <code>xs</code> as generated by <code><a href="#topic+evaluateLogConDens">evaluateLogConDens</a></code>. Finally, the 
entry <code>smoothed</code> of type <code>"logical"</code> returnes the value of <code>smoothed</code>.
</p>
<p>The methods <code><a href="#topic+summary.dlc">summary.dlc</a></code> and <code><a href="#topic+plot.dlc">plot.dlc</a></code> are used to obtain a summary and generate plots of the estimated
density.
</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a>
</p>


<h3>References</h3>

<p>Duembgen, L, Huesler, A. and Rufibach, K. (2010).
Active set and EM algorithms for log-concave densities based on complete and censored data. 
Technical report 61, IMSV, Univ. of Bern, available at <a href="https://arxiv.org/abs/0707.4643">https://arxiv.org/abs/0707.4643</a>.
</p>
<p>Duembgen, L. and Rufibach, K. (2009).
Maximum likelihood estimation of a log&ndash;concave density and its distribution function: basic properties and uniform consistency. 
<em>Bernoulli</em>, <b>15(1)</b>, 40&ndash;68.  
</p>
<p>Duembgen, L. and Rufibach, K. (2011).
logcondens: Computations Related to Univariate Log-Concave Density Estimation. 
<em>Journal of Statistical Software</em>, <b>39(6)</b>, 1&ndash;28. <a href="https://doi.org/10.18637/jss.v039.i06">doi:10.18637/jss.v039.i06</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ===================================================
## Illustrate on simulated data
## ===================================================

## Set parameters
n &lt;- 50
x &lt;- rnorm(n)

res &lt;- logConDens(x, smoothed = TRUE, print = FALSE, gam = NULL, 
    xs = NULL)
summary(res)
plot(res, which = "density", legend.pos = "topright")
plot(res, which = "log-density")
plot(res, which = "CDF")

## Compute slopes and intercepts of the linear functions that 
## compose phi
slopes &lt;- diff(res$phi) / diff(res$x)
intercepts &lt;- -slopes * res$x[-n] + res$phi[-n]


## ===================================================
## Illustrate method on reliability data
## Reproduce Fig. 2 in Duembgen &amp; Rufibach (2009)
## ===================================================

## Set parameters
data(reliability)
x &lt;- reliability
n &lt;- length(x)
res &lt;- logConDens(x, smooth = TRUE, print = TRUE)
phi &lt;- res$phi
f &lt;- exp(phi)

## smoothed log-concave PDF
f.smoothed &lt;- res$f.smoothed
xs &lt;- res$xs

## compute kernel density
sig &lt;- sd(x)
h &lt;- sig / sqrt(n)
f.kernel &lt;- rep(NA, length(xs))
for (i in 1:length(xs)){
    xi &lt;- xs[i]
    f.kernel[i] &lt;- mean(dnorm(xi, mean = x, sd = h))
}

## compute normal density
mu &lt;- mean(x)
f.normal &lt;- dnorm(xs, mean = mu, sd = sig)

## ===================================================
## Plot resulting densities, i.e. reproduce Fig. 2
## in Duembgen and Rufibach (2009)
## ===================================================
plot(0, 0, type = 'n', xlim = range(xs), ylim = c(0, 6.5 * 10^-3))
rug(res$x)
lines(res$x, f, col = 2)
lines(xs, f.normal, col = 3)
lines(xs, f.kernel, col = 4)
lines(xs, f.smoothed, lwd = 3, col = 5)
legend("topleft", c("log-concave", "normal", "kernel", 
    "log-concave smoothed"), lty = 1, col = 2:5, bty = "n")


## ===================================================
## Plot log-densities
## ===================================================
plot(0, 0, type = 'n', xlim = range(xs), ylim = c(-20, -5))
legend("bottomright", c("log-concave", "normal", "kernel", 
    "log-concave smoothed"), lty = 1, col = 2:5, bty = "n")
rug(res$x)
lines(res$x, phi, col = 2)
lines(xs, log(f.normal), col = 3)
lines(xs, log(f.kernel), col = 4)
lines(xs, log(f.smoothed), lwd = 3, col = 5)


## ===================================================
## Confidence intervals at a fixed point for the density
## see help file for logConCI()
## ===================================================
</code></pre>

<hr>
<h2 id='logConROC'>Compute ROC curve based on log-concave estimates for the constituent distributions</h2><span id='topic+logConROC'></span>

<h3>Description</h3>

<p>The receiver operating characteristic (ROC) curve for two constituent distributions <code class="reqn">F</code> and <code class="reqn">G</code> is defined as 
</p>
<p style="text-align: center;"><code class="reqn">R(t; F, G)  =  1 - G(F^{-1}(1 - t))</code>
</p>

<p>for <code class="reqn">t \in [0, 1]</code>. It is typically used to assess the performance of a diagnostic test used to discriminate between healthy and diseased
individuals based on a continuous variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logConROC(cases, controls, grid, smooth = TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logConROC_+3A_cases">cases</code></td>
<td>
<p>A vector of measurements for the cases.</p>
</td></tr>
<tr><td><code id="logConROC_+3A_controls">controls</code></td>
<td>
<p>A vector of measurements for the controls.</p>
</td></tr>
<tr><td><code id="logConROC_+3A_grid">grid</code></td>
<td>
<p>A vector specifying the grid where the ROC curve is computed on.</p>
</td></tr>
<tr><td><code id="logConROC_+3A_smooth">smooth</code></td>
<td>
<p>Logical, indicating whether ROC curve and AUC should also be computed based on the smoothed log-concave density estimator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In Rufibach (2011) it was shown that the ROC curve based on log-concave density estimates exhibit nice properties for finite sample sizes as well as asymptotically. Its performance is typically much better than that of the empirical ROC curve and only, if at all, sligthly worse compared to the binormal model when in fact the underlying densities are normal. However, log-concavity encompasses many parametric densities, so this new model is much more flexible than the binormal one, at little efficiency sacrifice.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>m</code></td>
<td>
<p>Number of control measurements.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of case measurements.</p>
</td></tr>
<tr><td><code>fROC</code></td>
<td>
<p>Estimated ROC curve based on the log-concave density estimate.</p>
</td></tr>
<tr><td><code>fROC.smooth</code></td>
<td>
<p>Estimated ROC curve based on the smoothed log-concave density estimate.</p>
</td></tr>
<tr><td><code>res0</code></td>
<td>
<p><code>dlc</code> object as a result of a call to <code><a href="#topic+logConDens">logConDens</a></code> for the data of the controls.</p>
</td></tr>
<tr><td><code>res1</code></td>
<td>
<p><code>dlc</code> object as a result of a call to <code><a href="#topic+logConDens">logConDens</a></code> for the data of the cases.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a></p>


<h3>References</h3>

<p>Duembgen, L. and Rufibach, K. (2009).
Maximum likelihood estimation of a log&ndash;concave density and its distribution function: basic properties and uniform consistency. 
<em>Bernoulli</em>, <b>15(1)</b>, 40&ndash;68. 
</p>
<p>Duembgen, L. and Rufibach, K. (2011).
logcondens: Computations Related to Univariate Log-Concave Density Estimation. 
<em>Journal of Statistical Software</em>, <b>39(6)</b>, 1&ndash;28. <a href="https://doi.org/10.18637/jss.v039.i06">doi:10.18637/jss.v039.i06</a>
</p>
<p>Rufibach, K. (2012).
A smooth ROC curve estimator based on log-concave density estimates.
<em>Int. J. Biostat.</em>, <b>8</b>(1), 1&ndash;29.
</p>


<h3>See Also</h3>

<p>Confidence intervals at given false-positive fractions for the ROC curve based on log-concave densities can be computed using <code><a href="#topic+confIntBootLogConROC_t0">confIntBootLogConROC_t0</a></code>. For the computation of the AUC the function <code><a href="#topic+ROCx">ROCx</a></code> is used. In the example below we analyze the 
<code><a href="#topic+pancreas">pancreas</a></code> data.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ROC curve for pancreas data 
data(pancreas)
status &lt;- factor(pancreas[, "status"], levels = 0:1, 
    labels = c("healthy", "diseased"))
var &lt;- log(pancreas[, "ca199"])
cases &lt;- var[status == "diseased"]
controls &lt;- var[status == "healthy"]

## compute and plot empirical ROC curve
## code modified from https://stat.ethz.ch/pipermail/r-help/2008-October/178531.html
xx &lt;- c(-Inf, sort(unique(c(cases, controls))), Inf)
sens &lt;- sapply(xx, function(x){mean(cases &gt;= x)})  
spec &lt;- sapply(xx, function(x){mean(controls &lt; x)})

## compute log-concave ROC curve
grid &lt;- seq(0, 1, by = 1 / 500)
roc.logcon &lt;- logConROC(cases, controls, grid)        

## plot
plot(0, 0, xlim = c(0, 1), ylim = c(0, 1), type = 'l', 
    main = "ROC curves for pancreas data", xlab = "1 - specificity", 
    ylab = "sensitivity", pty = 's')
legend("bottomright", c("empirical ROC", "log-concave ROC", "smooth log-concave ROC"), 
    lty = c(1, 1, 2), lwd = 2, col = 2:4, bty = "n")
segments(0, 0, 1, 1, col = 1)
lines(1 - spec, sens, type = 'l', col = 2, lwd = 2)
lines(grid, roc.logcon$fROC, col = 3, lwd = 2)
lines(grid, roc.logcon$fROC.smooth, col = 4, lwd = 2, lty = 2)

## Not run: 
## bootstrap confidence intervals at 1 - specificity = 0.2 and 0.8:
res &lt;- confIntBootLogConROC_t0(controls, cases, grid = c(0.2, 0.8), conf.level = 0.95, 
    M = 1000, smooth = TRUE, output = TRUE)
res

## End(Not run)
</code></pre>

<hr>
<h2 id='logconTwoSample'>Compute p-values for two-sample test based on log-concave CDF estimates</h2><span id='topic+logconTwoSample'></span>

<h3>Description</h3>

<p>Compute <code class="reqn">p</code>-values for a test for the null hypothesis of equal CDFs of two samples. The test
statistic is reminiscient of Kolmogorv-Smirnov's, but instead of computing it for the empirical CDFs, this function
computes it based on log-concave estimates for the CDFs.</p>


<h3>Usage</h3>

<pre><code class='language-R'>logconTwoSample(x, y, which = c("MLE", "smooth"), M = 999, 
    n.grid = 500, display = TRUE, seed0 = 1977)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logconTwoSample_+3A_x">x</code></td>
<td>
<p>First data sample.</p>
</td></tr>
<tr><td><code id="logconTwoSample_+3A_y">y</code></td>
<td>
<p>Second data sample.</p>
</td></tr>
<tr><td><code id="logconTwoSample_+3A_which">which</code></td>
<td>
<p>Indicate for which type of estimate the test statistic should be computed.</p>
</td></tr>
<tr><td><code id="logconTwoSample_+3A_m">M</code></td>
<td>
<p>Number of permutations.</p>
</td></tr>
<tr><td><code id="logconTwoSample_+3A_n.grid">n.grid</code></td>
<td>
<p>Number of grid points in computation of maximal difference between smoothed log-concave CDFs. See <code><a href="#topic+maxDiffCDF">maxDiffCDF</a></code> for details.</p>
</td></tr>
<tr><td><code id="logconTwoSample_+3A_display">display</code></td>
<td>
<p>If <code>TRUE</code> progress of computations is shown.</p>
</td></tr>
<tr><td><code id="logconTwoSample_+3A_seed0">seed0</code></td>
<td>
<p>Set seed to reproduce results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given two i.i.d. samples <code class="reqn">x_1, \ldots, x_{n_1}</code> and <code class="reqn">y_1, \ldots, y_{n_2}</code> this function computes a permutation
test <code class="reqn">p</code>-value that provides evidence against the null hypothesis
</p>
<p style="text-align: center;"><code class="reqn">H_0 : F_1 = F_2</code>
</p>

<p>where <code class="reqn">F_1, F_2</code> are the CDFs of the samples, respectively. A test either based on the log-concave MLE or on its
smoothed version (see Duembgen and Rufibach, 2009, Section 3) are provided. Note that computation of the smoothed
version takes considerably more time.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>p.value</code></td>
<td>
<p>A two dimensional vector containing the <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>test.stat.orig</code></td>
<td>
<p>The test statistics for the original samples.</p>
</td></tr>
<tr><td><code>test.stats</code></td>
<td>
<p>A <code class="reqn">M \times 2</code> matrix containing the test statistics for all the permutations.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Note that the algorithm that finds the maximal difference for the smoothed estimate is of approximative
nature only. It may fail for very large sample sizes.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a>
</p>


<h3>References</h3>

<p>Duembgen, L. and Rufibach, K. (2009)
Maximum likelihood estimation of a log&ndash;concave density and its distribution function: basic properties and uniform consistency. 
<em>Bernoulli</em>, <b>15(1)</b>, 40&ndash;68.  
</p>
<p>Duembgen, L. and Rufibach, K. (2011)
logcondens: Computations Related to Univariate Log-Concave Density Estimation. 
<em>Journal of Statistical Software</em>, <b>39(6)</b>, 1&ndash;28. <a href="https://doi.org/10.18637/jss.v039.i06">doi:10.18637/jss.v039.i06</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n1 &lt;- 30
n2 &lt;- 25
x &lt;- rgamma(n1, 2, 1)
y &lt;- rgamma(n2, 2, 1) + 1
twosample &lt;- logconTwoSample(x, y, which = c("MLE", "smooth")[1], M = 999)

## End(Not run)
</code></pre>

<hr>
<h2 id='maxDiffCDF'>Compute maximal difference between CDFs corresponding to log-concave estimates</h2><span id='topic+maxDiffCDF'></span>

<h3>Description</h3>

<p>Compute the maximal difference between two estimated log-concave distribution functions, either
the MLEs or the smoothed versions. This function is used to set up a two-sample permutation test
that assesses the null hypothesis of equality of distribution functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxDiffCDF(res1, res2, which = c("MLE", "smooth"), n.grid = 500)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxDiffCDF_+3A_res1">res1</code></td>
<td>
<p>An object of class <code>"dlc"</code>, usually a result of a call to <code>logConDens</code> for the first sample.</p>
</td></tr>
<tr><td><code id="maxDiffCDF_+3A_res2">res2</code></td>
<td>
<p>An object of class <code>"dlc"</code>, usually a result of a call to <code>logConDens</code> for the second sample.</p>
</td></tr>
<tr><td><code id="maxDiffCDF_+3A_which">which</code></td>
<td>
<p>Indicate for which type of estimate the maximal difference should be computed.</p>
</td></tr>
<tr><td><code id="maxDiffCDF_+3A_n.grid">n.grid</code></td>
<td>
<p>Number of grid points used to find zeros of <code class="reqn">\hat f_{n_1}^* - \hat f_{n_2}^*</code> for the smooth estimate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given two i.i.d. samples <code class="reqn">x_1, \ldots, x_{n_1}</code> and <code class="reqn">y_1, \ldots, y_{n_2}</code> this function computes the
maxima of 
</p>
<p style="text-align: center;"><code class="reqn">D_1(t) = \hat F_{n_1}(t) - \hat F_{n_2}(t)</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">D_2(t) = \hat F^*_{n_1}(t) - \hat F^*_{n_2}(t).</code>
</p>



<h3>Value</h3>

<table role = "presentation">
<tr><td><code>test.stat</code></td>
<td>
<p>A two-dimensional vector containing the above maxima.</p>
</td></tr>
<tr><td><code>location</code></td>
<td>
<p>A two-dimensional vector where the maxima occur.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Note that the algorithm that finds the maximal difference for the smoothed estimate is of approximative
nature only. It may fail for very large sample sizes.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a>
</p>


<h3>References</h3>

<p>Duembgen, L. and Rufibach, K. (2009)
Maximum likelihood estimation of a log&ndash;concave density and its distribution function: basic properties and uniform consistency. 
<em>Bernoulli</em>, <b>15(1)</b>, 40&ndash;68.  
</p>
<p>Duembgen, L. and Rufibach, K. (2011)
logcondens: Computations Related to Univariate Log-Concave Density Estimation. 
<em>Journal of Statistical Software</em>, <b>39(6)</b>, 1&ndash;28. <a href="https://doi.org/10.18637/jss.v039.i06">doi:10.18637/jss.v039.i06</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1 &lt;- 100
n2 &lt;- 120
x &lt;- sort(rgamma(n1, 2, 1))
y &lt;- sort(rgamma(n2, 2, 1))
res1 &lt;- logConDens(x, smoothed = TRUE)
res2 &lt;- logConDens(y, smoothed = TRUE)
d &lt;- maxDiffCDF(res1, res2, n.grid = 200)

## log-concave estimate
xs &lt;- seq(min(res1$xs, res2$xs), max(res1$xs, res2$xs), length = 200)
F1 &lt;- matrix(NA, nrow = length(xs), ncol = 1); F2 &lt;- F1
for (i in 1:length(xs)){
    F1[i] &lt;- evaluateLogConDens(xs[i], res1, which = 3)[, "CDF"]
    F2[i] &lt;- evaluateLogConDens(xs[i], res2, which = 3)[, "CDF"]
    }
par(mfrow = c(1, 2))
plot(xs, abs(F1 - F2), type = "l")
abline(v = d$location[1], lty = 2, col = 3)
abline(h = d$test.stat[1], lty = 2, col = 3)

## smooth estimate
xs &lt;- seq(min(res1$xs, res2$xs), max(res1$xs, res2$xs), length = 200)
F1smooth &lt;- matrix(NA, nrow = length(xs), ncol = 2); F2smooth &lt;- F1smooth
for (i in 1:length(xs)){
    F1smooth[i, ] &lt;- evaluateLogConDens(xs[i], res1, which = 4:5)[, 
        c("smooth.density", "smooth.CDF")]
    F2smooth[i, ] &lt;- evaluateLogConDens(xs[i], res2, which = 4:5)[, 
        c("smooth.density", "smooth.CDF")]
    }
plot(xs, abs(F1smooth[, 2] - F2smooth[, 2]), type = "l")
abline(h = 0)
abline(v = d$location[2], lty = 2, col = c(3, 4))
abline(h = d$test.stat[2], lty = 2, col = c(3, 4))
</code></pre>

<hr>
<h2 id='MLE'>Unconstrained piecewise linear MLE</h2><span id='topic+MLE'></span>

<h3>Description</h3>

<p>Given a vector of observations <code class="reqn">{\bold{x}} = (x_1, \ldots, x_m)</code> with pairwise distinct entries and
a vector of weights <code class="reqn">{\bold{w}}=(w_1, \ldots, w_m)</code> s.t. <code class="reqn">\sum_{i=1}^m w_i = 1</code>, this function computes a function <code class="reqn">\widehat \phi_{MLE}</code> (represented by the vector <code class="reqn">(\widehat \phi_{MLE}(x_i))_{i=1}^m</code>) supported by <code class="reqn">[x_1, x_m]</code> such that 
</p>
<p style="text-align: center;"><code class="reqn">L(\phi) = \sum_{i=1}^m w_i \phi(x_i) - \sum_{j=1}^{m-1} (x_{j+1} - x_j) J(\phi_j, \phi_{j+1})</code>
</p>

<p>is maximal over all continuous, piecewise linear functions with knots in <code class="reqn">\{x_1, \ldots, x_m\}</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MLE(x, w = NA, phi_o = NA, prec = 1e-7, print = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MLE_+3A_x">x</code></td>
<td>
<p>Vector of independent and identically distributed numbers, with strictly increasing entries.</p>
</td></tr>
<tr><td><code id="MLE_+3A_w">w</code></td>
<td>
<p>Optional vector of nonnegative weights corresponding to <code class="reqn">{\bold{x}_m}</code>.</p>
</td></tr>
<tr><td><code id="MLE_+3A_phi_o">phi_o</code></td>
<td>
<p>Optional starting vector.</p>
</td></tr>
<tr><td><code id="MLE_+3A_prec">prec</code></td>
<td>
<p>Threshold for the directional derivative during the Newton-Raphson procedure.</p>
</td></tr>
<tr><td><code id="MLE_+3A_print">print</code></td>
<td>
<p>print = TRUE outputs log-likelihood in every loop, print = FALSE does not. Make sure to tell R to output (press CTRL+W).</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>phi</code></td>
<td>
<p>Resulting column vector <code class="reqn">(\widehat \phi_{MLE}(x_i))_{i=1}^m.</code></p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>Value <code class="reqn">L(\widehat \phi_{MLE})</code> of the log-likelihood at <code class="reqn">\widehat \phi_{MLE}.</code></p>
</td></tr>
<tr><td><code>Fhat</code></td>
<td>
<p>Vector of the same length as <code class="reqn">{\bold{x}}</code> with entries <code class="reqn">\widehat F_{MLE,1} = 0</code> and 
</p>
<p style="text-align: center;"><code class="reqn">\widehat F_{MLE,k} = \sum_{j=1}^{k-1} (x_{j+1} - x_j) J(\phi_j, \phi_{j+1}) </code>
</p>

<p>for <code class="reqn">k \ge 2.</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is not intended to be invoked by the end user.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a></p>

<hr>
<h2 id='pancreas'>Data from pancreatic cancer serum biomarker study</h2><span id='topic+pancreas'></span>

<h3>Description</h3>

<p>First published by Wieand et al (1989), this dataset contains data on serum measurements for a cancer antigen (CA-125) and
a carbohydrate antigen (CA19.9) both of which are measured on a continuous non-negative scale. The measurements were taken within a case-control
study on 90 cases with pancreatic cancer and 51 controls who did not have cancer but pancreatitis. The primary question of the study was which one
of the two biomarkers best distinguishes cases from controls.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pancreas)</code></pre>


<h3>Format</h3>

<p>A data frame with 141 observations on the following 3 variables.
</p>

<dl>
<dt><code>ca199</code></dt><dd><p>CA19.9 measurements.</p>
</dd>
<dt><code>ca125</code></dt><dd><p>CA125 measurements.</p>
</dd>
<dt><code>status</code></dt><dd><p>Patient status, 0 for controls and 1 for cases.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data was downloaded from http://labs.fhcrc.org/pepe/book/ on February 2, 2011.</p>


<h3>References</h3>

<p>Wieand, S., Gail, M. H., James, B. R., and James, K.L. (1989).
A family of nonparametric statistics for comparing diagnostic markers with paired or unpaired data.
<em>Biometrika</em>, <b>76</b>, 585&ndash;592.
</p>
<p>Pepe, M.S. (2003) <em>The statistical evaluation of medical tests for classification and prediction</em>.
Oxford: Oxford University Press (Section 1.3.3).
</p>


<h3>See Also</h3>

<p>This data is analyzed in the help file for the function <code><a href="#topic+logConROC">logConROC</a></code>.</p>

<hr>
<h2 id='plot.dlc'>Standard plots for a dlc object</h2><span id='topic+plot.dlc'></span>

<h3>Description</h3>

<p><code>plot</code> method for class <code>"dlc"</code>.
Three plots (selectable by <code>which</code>) are currently available: a plot of the estimated density,
the estimated log-density, or the distribution function corresponding to the estimated log-concave density.
By default, a plot of the density estimate is provided. If <code>smoothed = TRUE</code>, the smoothed version of 
the log-concave density estimate (saved in <code>x</code>) is added to the density and log-density plot.
For the CDF, the smoothed version is not contained by default in a <code>dlc</code> object and needs to be computed
when asked to be plotted.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dlc'
plot(x, which = c("density", "log-density", "CDF"), 
    add.title = TRUE, legend.pos = "topright", ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.dlc_+3A_x">x</code></td>
<td>
<p>An object of class <code>"dlc"</code>, usually a result of a call to <code>logConDens</code>.</p>
</td></tr>
<tr><td><code id="plot.dlc_+3A_which">which</code></td>
<td>
<p>One of <code>"density"</code>, <code>"log-density"</code>, or <code>"CDF"</code>.</p>
</td></tr>
<tr><td><code id="plot.dlc_+3A_add.title">add.title</code></td>
<td>
<p>Logical, if <code>TRUE</code> adds a standard title to the plot.</p>
</td></tr>
<tr><td><code id="plot.dlc_+3A_legend.pos">legend.pos</code></td>
<td>
<p>Placement of the legend. One of <code>"bottomright"</code>, <code>"bottom"</code>, <code>"bottomleft"</code>, <code>"left"</code>, 
<code>"topleft"</code>, <code>"top"</code>, <code>"topright"</code>, <code>"right"</code>, <code>"center"</code>; or <code>"none"</code> for not displaying a legend. See <code><a href="graphics.html#topic+legend">legend</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.dlc_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+activeSetLogCon">activeSetLogCon</a></code> and <code><a href="#topic+evaluateLogConDens">evaluateLogConDens</a></code> for details on the computations.</p>


<h3>Value</h3>

<p>Chosen plot is generated.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a>
</p>


<h3>References</h3>

<p>Duembgen, L, Huesler, A. and Rufibach, K. (2010).
Active set and EM algorithms for log-concave densities based on complete and censored data. 
Technical report 61, IMSV, Univ. of Bern, available at <a href="https://arxiv.org/abs/0707.4643">https://arxiv.org/abs/0707.4643</a>.
</p>
<p>Duembgen, L. and Rufibach, K. (2009).
Maximum likelihood estimation of a log&ndash;concave density and its distribution function: basic properties and uniform consistency. 
<em>Bernoulli</em>, <b>15(1)</b>, 40&ndash;68.  
</p>
<p>Duembgen, L. and Rufibach, K. (2011)
logcondens: Computations Related to Univariate Log-Concave Density Estimation. 
<em>Journal of Statistical Software</em>, <b>39(6)</b>, 1&ndash;28. <a href="https://doi.org/10.18637/jss.v039.i06">doi:10.18637/jss.v039.i06</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See help file of function "logConDens".
</code></pre>

<hr>
<h2 id='preProcess'>Compute a weighted sample from initial observations</h2><span id='topic+preProcess'></span>

<h3>Description</h3>

<p>Generates weights from initial sample.</p>


<h3>Usage</h3>

<pre><code class='language-R'>preProcess(x, xgrid = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="preProcess_+3A_x">x</code></td>
<td>
<p>Vector of independent and identically distributed numbers, not necessarily unique.</p>
</td></tr>
<tr><td><code id="preProcess_+3A_xgrid">xgrid</code></td>
<td>
<p>Parameter that governs the generation of weights: If <code>xgrid = NULL</code> a new sample
of unique observations is generated with corresponding vector of weights. If <code>xgrid</code> is
a positive number, observations are binned in a grid with grid length <code>xgrid</code>.
Finally, an entire vector specifying a user-defined grid can be supplied.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>Vector of unique and sorted observations deduced from the input <code>x</code> according to the specification 
given by <code>xgrid</code>.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>Vector of corresponding weights, normalized to sum to one.</p>
</td></tr>
<tr><td><code>sig</code></td>
<td>
<p>Standard deviation of the inputed observations. This quantity is needed when computing the smoothed
log-concave density estimator via <code><a href="#topic+evaluateLogConDens">evaluateLogConDens</a></code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of initial observations.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is not intended to be invoked by the end user.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a></p>

<hr>
<h2 id='Q00'>Numerical Routine Q</h2><span id='topic+Q00'></span>

<h3>Description</h3>

<p>This function is used in the computation of <code class="reqn">\widehat f^*</code> and <code class="reqn">\widehat F^*</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q00(x, a, u, v, gamma, QFhat = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Q00_+3A_x">x</code></td>
<td>
<p>Number at which to compute <code class="reqn">q</code> and/or <code class="reqn">Q</code>.</p>
</td></tr>
<tr><td><code id="Q00_+3A_a">a</code></td>
<td>
<p>Vector of length <code class="reqn">m</code> with real entries.</p>
</td></tr>
<tr><td><code id="Q00_+3A_u">u</code></td>
<td>
<p>Vector of length <code class="reqn">m</code> with real entries.</p>
</td></tr>
<tr><td><code id="Q00_+3A_v">v</code></td>
<td>
<p>Vector of length <code class="reqn">m</code> with real entries.</p>
</td></tr>
<tr><td><code id="Q00_+3A_gamma">gamma</code></td>
<td>
<p>Real number. Standard deviation to be used.</p>
</td></tr>
<tr><td><code id="Q00_+3A_qfhat">QFhat</code></td>
<td>
<p>Logical. Should <code class="reqn">Q</code> be computed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector(s) <code class="reqn">q</code> and/or <code class="reqn">Q</code>.</p>


<h3>Note</h3>

<p>Taylor approximation is used if <code class="reqn">a</code> is small. In addition, as described in Duembgen and Rufibach (2011) at
the end of Appendix C, in extreme situations, e.g. when data sets contain extreme spacings, numerical problems may 
occur in the computation of the function <code class="reqn">q_\gamma</code> (eq. (7) in Duembgen and Rufibach, 2011). 
For it may happen that the exponent is rather large while the difference of Gaussian CDFs is very 
small. To moderate these problems, we are using the following bounds:
</p>
<p style="text-align: center;"><code class="reqn">\exp(- m^2/2) \bigl( \Phi(\delta) - \Phi(-\delta) \bigr) \ \le \ \Phi(b) - \Phi(a) \ \le \ \exp(- m^2/2) \cosh(m\delta) \bigl( \Phi(\delta) - \Phi(-\delta) \bigr)</code>
</p>

<p>for arbitrary numbers <code class="reqn">a &lt; b</code> and <code class="reqn">m := (a + b) / 2</code>, <code class="reqn">\delta := (b - a) / 2</code>.
</p>
<p>However, the function <code>Q00</code> is not intended to be invoked by the end user.
</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a>
</p>


<h3>References</h3>

<p>Duembgen, L. and Rufibach, K. (2011)
logcondens: Computations Related to Univariate Log-Concave Density Estimation. 
<em>Journal of Statistical Software</em>, <b>39(6)</b>, 1&ndash;28. <a href="https://www.jstatsoft.org/v39/i06">https://www.jstatsoft.org/v39/i06</a>
</p>

<hr>
<h2 id='qloglin'>Quantile Function In a Simple Log-Linear model</h2><span id='topic+qloglin'></span>

<h3>Description</h3>

<p>Suppose the random variable <code class="reqn">X</code> has density function 
</p>
<p style="text-align: center;"><code class="reqn">g_\theta(x) = \frac{\theta \exp(\theta x)}{\exp(\theta) - 1}</code>
</p>

<p>for an arbitrary real number <code class="reqn">\theta</code> and <code class="reqn">x \in [0,1]</code>. The function <code><a href="#topic+qloglin">qloglin</a></code> is simply the 
quantile function 
</p>
<p style="text-align: center;"><code class="reqn">G^{-1}_\theta(u) = \theta^{-1} \log \Big( 1 + (e^\theta - 1)u \Big)</code>
</p>
    
<p>in this model, for <code class="reqn">u \in [0,1]</code>. This quantile function is used for the computation of quantiles of <code class="reqn">\widehat F_m</code> in <code><a href="#topic+quantilesLogConDens">quantilesLogConDens</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>qloglin(u, t)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qloglin_+3A_u">u</code></td>
<td>
<p>Vector in <code class="reqn">[0,1]^d</code> where quantiles are to be computed at.</p>
</td></tr>
<tr><td><code id="qloglin_+3A_t">t</code></td>
<td>
<p>Parameter <code class="reqn">\theta</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>z</code></td>
<td>
<p>Vector containing the quantiles <code class="reqn">G_n^{-1}(u_i)</code> for <code class="reqn">i = 1, \ldots, d</code>.</p>
</td></tr></table>


<h3>Note</h3>

<p>Taylor approximation is used if <code class="reqn">\theta</code> is small.
</p>
<p>This function is not intended to be called by the end user.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a></p>

<hr>
<h2 id='quadDeriv'>Gradient and Diagonal of Hesse Matrix of Quadratic Approximation to Log-Likelihood Function L</h2><span id='topic+quadDeriv'></span>

<h3>Description</h3>

<p>Computes gradient and diagonal of the Hesse matrix w.r.t. to <code class="reqn">\eta</code> of a quadratic approximation to the 
reparametrized original log-likelihood function 
</p>
<p style="text-align: center;"><code class="reqn">L(\phi) = \sum_{i=1}^m w_i \phi(x_i) - \int_{-\infty}^{\infty} \exp(\phi(t)) dt. </code>
</p>

<p>where <code class="reqn">L</code> is parametrized via
</p>
<p style="text-align: center;"><code class="reqn">{\bold{\eta}}({\bold{\phi}}) = \Bigl(\phi_1, \Bigl(\eta_1+ \sum_{j=2}^i (x_i-x_{i-1})\eta_i\Bigr)_{i=2}^m\Bigr).</code>
</p>

<p><code class="reqn">{\bold{\phi}}</code>: vector <code class="reqn">(\phi(x_i))_{i=1}^m</code> representing concave, piecewise linear function <code class="reqn">\phi</code>,<br /> <code class="reqn">{\bold{\eta}}</code>: vector representing successive slopes of <code class="reqn">\phi.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadDeriv(dx, w, eta)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quadDeriv_+3A_dx">dx</code></td>
<td>
<p>Vector <code class="reqn">(0, x_i-x_{i-1})_{i=2}^m.</code></p>
</td></tr>
<tr><td><code id="quadDeriv_+3A_w">w</code></td>
<td>
<p>Vector of weights as in <code><a href="#topic+activeSetLogCon">activeSetLogCon</a></code>.</p>
</td></tr>
<tr><td><code id="quadDeriv_+3A_eta">eta</code></td>
<td>
<p>Vector <code class="reqn">{\bold{\eta}}.</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">m \times 2</code> matrix. First column contains gradient and second column diagonal of Hesse matrix.</p>


<h3>Note</h3>

<p>This function is not intended to be invoked by the end user.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+quadDeriv">quadDeriv</a></code> is used by the function <code><a href="#topic+icmaLogCon">icmaLogCon</a></code>.</p>

<hr>
<h2 id='quantilesLogConDens'>Function to compute Quantiles of Fhat</h2><span id='topic+quantilesLogConDens'></span>

<h3>Description</h3>

<p>Function to compute <code class="reqn">p_0</code>-quantile of 
</p>
<p style="text-align: center;"><code class="reqn">\widehat F_m(t) = \int_{x_1}^t \widehat f_m(t) dt,</code>
</p>

<p>where <code class="reqn">\widehat f_m</code> is the log-concave density estimator, typically computed via <code><a href="#topic+logConDens">logConDens</a></code>
and <code class="reqn">p_0</code> runs through the vector <code>ps</code>. 
The formula to compute a quantile at <code class="reqn">u \in [\widehat F_m(x_j), \widehat F_m(x_{j+1})]</code> for 
<code class="reqn">j = 1, \ldots, n-1</code> is:
</p>
<p style="text-align: center;"><code class="reqn">\widehat F_m^{-1}(u) = x_j + (x_{j+1}-x_j)  G^{-1}_{(x_{j+1}-x_j)(\widehat \phi_{j+1}-\widehat \phi_j)} \Big( \frac{u - \widehat F_m(x_j)}{ \widehat F_m(x_{j+1}) -  \widehat F_m(x_j)}\Big),</code>
</p>

<p>where <code class="reqn">G^{-1}_\theta</code> is described in <code><a href="#topic+qloglin">qloglin</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantilesLogConDens(ps, res)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantilesLogConDens_+3A_ps">ps</code></td>
<td>
<p>Vector of real numbers where quantiles should be computed.</p>
</td></tr>
<tr><td><code id="quantilesLogConDens_+3A_res">res</code></td>
<td>
<p>An object of class <code>"dlc"</code>, usually a result of a call to <code>logConDens</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame with row <code class="reqn">(p_{0, i}, q_{0, i})</code> where
<code class="reqn">q_{0, i} = \inf_{x}\{\widehat F_m(x) \ge p_{0, i}\}</code> and <code class="reqn">p_{0, i}</code> runs through <code>ps</code>.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## estimate gamma density
set.seed(1977)
x &lt;- rgamma(200, 2, 1)
res &lt;- logConDens(x, smoothed = FALSE, print = FALSE)

## compute 0.95 quantile of Fhat
q &lt;- quantilesLogConDens(0.95, res)[, "quantile"]
plot(res, which = "CDF", legend.pos = "none")
abline(h = 0.95, lty = 3); abline(v = q, lty = 3)
</code></pre>

<hr>
<h2 id='reliability'>Reliability dataset used to illustrate log-concave density estimation</h2><span id='topic+reliability'></span>

<h3>Description</h3>

<p>Dataset that contains the data analyzed in Duembgen and Rufibach (2009, Figure 2).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(reliability)</code></pre>


<h3>Format</h3>

<p>A vector containing the 786 observations analyzed in Duembgen and Rufibach (2009, Figure 2).</p>


<h3>Source</h3>

<p>The data was taken from Duembgen and Rufibach (2009).</p>


<h3>References</h3>

<p>Duembgen, L. and Rufibach, K. (2009)
Maximum likelihood estimation of a log&ndash;concave density and its distribution function: basic properties and uniform consistency. 
<em>Bernoulli</em>, <b>15(1)</b>, 40&ndash;68.  
</p>
<p>Duembgen, L. and Rufibach, K. (2011)
logcondens: Computations Related to Univariate Log-Concave Density Estimation. 
<em>Journal of Statistical Software</em>, <b>39(6)</b>, 1&ndash;28. <a href="https://doi.org/10.18637/jss.v039.i06">doi:10.18637/jss.v039.i06</a>
</p>


<h3>See Also</h3>

<p>See the example in <code><a href="#topic+logConDens">logConDens</a></code> for the analysis of this data.</p>

<hr>
<h2 id='reparametrizations'>Changes Between Parametrizations</h2><span id='topic+reparametrizations'></span><span id='topic+phieta'></span><span id='topic+etaphi'></span>

<h3>Description</h3>

<p>Given a vector <code class="reqn">(\phi_1, \ldots, \phi_m)</code> representing the values of a piecewise linear concave function at
<code class="reqn">x_1, \ldots, x_m,</code> <code><a href="#topic+etaphi">etaphi</a></code> returns a column vector with the entries
</p>
<p style="text-align: center;"><code class="reqn">{\bold{\eta}} = \Bigl(\phi_1, \Bigl(\eta_1 + \sum_{j=2}^m (x_i-x_{i-1})\eta_i\Bigr)_{i=2}^m\Bigr).</code>
</p>

<p>The function <code><a href="#topic+phieta">phieta</a></code> returns a vector with the entries 
</p>
<p style="text-align: center;"><code class="reqn">{\bold{\phi}} = \Bigl(\eta_1, \Bigl(\frac{\phi_i-\phi_{i-1}}{x_i-x_{i-1}}\Bigr)_{i=2}^m\Bigr).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>etaphi(x, eta)
phieta(x, phi)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reparametrizations_+3A_x">x</code></td>
<td>
<p>Vector of independent and identically distributed numbers, with strictly increasing entries.</p>
</td></tr>
<tr><td><code id="reparametrizations_+3A_eta">eta</code></td>
<td>
<p>Vector with entries <code class="reqn">\eta_i = \eta(x_i).</code></p>
</td></tr>
<tr><td><code id="reparametrizations_+3A_phi">phi</code></td>
<td>
<p>Vector with entries <code class="reqn">\phi_i = \phi(x_i).</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>These functions are not intended to be invoked by the end user.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a></p>

<hr>
<h2 id='rlogcon'>Generate random sample from the log-concave and the smoothed log-concave density estimator</h2><span id='topic+rlogcon'></span>

<h3>Description</h3>

<p>Generate a random sample from a distribution with density <code class="reqn">\hat f_n</code> and <code class="reqn">\hat f_n^*</code>,
as described in Duembgen and Rufibach (2009, Section 3).</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlogcon(n, x0)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rlogcon_+3A_n">n</code></td>
<td>
<p>Size of random sample to be generated.</p>
</td></tr>
<tr><td><code id="rlogcon_+3A_x0">x0</code></td>
<td>
<p>Sorted vector of independent and identically distributed numbers, not necessarily unique.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>Random sample from <code class="reqn">\hat f_n</code>.</p>
</td></tr>
<tr><td><code>X_star</code></td>
<td>
<p>Random sample from <code class="reqn">\hat f_n^*</code>.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>Uniform random sample of size <code>n</code> used in the generation of <code>X</code>.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>Normal random sample of size <code>n</code> used in the generation of <code>X_star</code>.</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Computed log-concave density estimator.</p>
</td></tr>
<tr><td><code>f.smoothed</code></td>
<td>
<p>List containing smoothed log-concave density estimator, as output by <code><a href="#topic+evaluateLogConDens">evaluateLogConDens</a></code>.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Vector of distinct observations generated from <code>x0</code>.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>Weights corresponding to <code>x</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a>
</p>


<h3>References</h3>

<p>Duembgen, L. and Rufibach, K. (2009)
Maximum likelihood estimation of a log&ndash;concave density and its distribution function: basic properties and uniform consistency. 
<em>Bernoulli</em>, <b>15(1)</b>, 40&ndash;68.  
</p>
<p>Duembgen, L. and Rufibach, K. (2011)
logcondens: Computations Related to Univariate Log-Concave Density Estimation. 
<em>Journal of Statistical Software</em>, <b>39(6)</b>, 1&ndash;28. <a href="https://doi.org/10.18637/jss.v039.i06">doi:10.18637/jss.v039.i06</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ===================================================
## Generate random samples as described in Section 3 of
## Duembgen and Rufibach (2009)
## ===================================================
x0 &lt;- rnorm(111)
n &lt;- 22
random &lt;- rlogcon(n, x0)

## sample of size n from the log-concave density estimator
random$X

## sample of size n from the smoothed log-concave density estimator
random$X_star
</code></pre>

<hr>
<h2 id='robust'>Robustification and Hermite Interpolation for ICMA</h2><span id='topic+robust'></span>

<h3>Description</h3>

<p>Performs robustification and Hermite interpolation in the iterative convex minorant algorithm as described in Rufibach (2006, 2007).</p>


<h3>Usage</h3>

<pre><code class='language-R'>robust(x, w, eta, etanew, grad)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robust_+3A_x">x</code></td>
<td>
<p>Vector of independent and identically distributed numbers, with strictly increasing entries.</p>
</td></tr>
<tr><td><code id="robust_+3A_w">w</code></td>
<td>
<p>Optional vector of nonnegative weights corresponding to <code class="reqn">{\bold{x}_m}</code>.</p>
</td></tr>
<tr><td><code id="robust_+3A_eta">eta</code></td>
<td>
<p>Current candidate vector.</p>
</td></tr>
<tr><td><code id="robust_+3A_etanew">etanew</code></td>
<td>
<p>New candidate vector.</p>
</td></tr>
<tr><td><code id="robust_+3A_grad">grad</code></td>
<td>
<p>Gradient of L at current candidate vector <code class="reqn">\eta.</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a (possibly) new vector <code class="reqn">\eta</code> on the segment 
</p>
<p style="text-align: center;"><code class="reqn">(1 - t_0)  \eta + t_0  \eta_{new} </code>
</p>

<p>such that the log-likelihood of this new <code class="reqn">\eta</code> is strictly greater than that of the initial <code class="reqn">\eta</code> and <code class="reqn">t_0</code> is chosen 
according to the Hermite interpolation procedure described in Rufibach (2006, 2007).</p>


<h3>Note</h3>

<p>This function is not intended to be invoked by the end user.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a></p>


<h3>References</h3>

<p>Rufibach K. (2006) <em>Log-concave Density Estimation and Bump Hunting for i.i.d. Observations.</em>
PhD Thesis, University of Bern, Switzerland and Georg-August University of Goettingen, Germany, 2006.
<br /> Available at <a href="https://slsp-ube.primo.exlibrisgroup.com/permalink/41SLSP_UBE/17e6d97/alma99116730175505511">https://slsp-ube.primo.exlibrisgroup.com/permalink/41SLSP_UBE/17e6d97/alma99116730175505511</a>.
</p>
<p>Rufibach, K. (2007)
Computing maximum likelihood estimators of a log-concave density function.
<em>J. Stat. Comput. Simul.</em> <b>77</b>, 561&ndash;574.
</p>

<hr>
<h2 id='ROCx'>Compute ROC curve at a given x based on log-concave estimates for the constituent distributions</h2><span id='topic+ROCx'></span>

<h3>Description</h3>

<p>Computes the value of the ROC curve at <code class="reqn">x</code> (which may be a vector) based on log-concave density estimates of the constituent distributions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROCx(x, res0, res1, smooth = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ROCx_+3A_x">x</code></td>
<td>
<p>Vector of numbers in <code class="reqn">[0, 1]</code> where the ROC curve should be computed at.</p>
</td></tr>
<tr><td><code id="ROCx_+3A_res0">res0</code></td>
<td>
<p><code>dlc</code> object as a result of a call to <code><a href="#topic+logConDens">logConDens</a></code> for the data of the controls.</p>
</td></tr>
<tr><td><code id="ROCx_+3A_res1">res1</code></td>
<td>
<p><code>dlc</code> object as a result of a call to <code><a href="#topic+logConDens">logConDens</a></code> for the data of the cases.</p>
</td></tr>
<tr><td><code id="ROCx_+3A_smooth">smooth</code></td>
<td>
<p>Logical. If <code>TRUE</code> kernel smoothed log-concave estimate is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number or a vector of dimension the same as <code class="reqn">x</code>, the value of the ROC curve at <code>x</code>.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a></p>


<h3>References</h3>

<p>Rufibach, K. (2012).
A smooth ROC curve estimator based on log-concave density estimates.
<em>Int. J. Biostat.</em>, <b>8</b>(1), 1&ndash;29.
</p>


<h3>See Also</h3>

<p>Used for the computation of AUC in <code><a href="#topic+logConROC">logConROC</a></code>.</p>

<hr>
<h2 id='summary.dlc'>Summarizing log-concave density estimation</h2><span id='topic+summary.dlc'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"dlc"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dlc'
summary(object, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.dlc_+3A_object">object</code></td>
<td>
<p>An object of class <code>"dlc"</code>, usually a result of a call to <code>logConDens</code>.</p>
</td></tr>
<tr><td><code id="summary.dlc_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+activeSetLogCon">activeSetLogCon</a></code> and <code><a href="#topic+evaluateLogConDens">evaluateLogConDens</a></code> for details on the computations.</p>


<h3>Value</h3>

<p>The function <code>summary.dlc</code> returns a list of summary statistics of the estimated
log-concave density as well as of its smoothed version (depending on the value of <code>smoothed</code> when calling
<code><a href="#topic+logConDens">logConDens</a></code>).</p>


<h3>Warning</h3>

<p>Note that the numbering of knots in the output relies on the vector of <em>unique</em> observations.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Lutz Duembgen, <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>, <br /> <a href="https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html">https://www.imsv.unibe.ch/about_us/staff/prof_dr_duembgen_lutz/index_eng.html</a>
</p>


<h3>References</h3>

<p>Duembgen, L, Huesler, A. and Rufibach, K. (2010).
Active set and EM algorithms for log-concave densities based on complete and censored data. 
Technical report 61, IMSV, Univ. of Bern, available at <a href="https://arxiv.org/abs/0707.4643">https://arxiv.org/abs/0707.4643</a>.
</p>
<p>Duembgen, L. and Rufibach, K. (2009).
Maximum likelihood estimation of a log&ndash;concave density and its distribution function: basic properties and uniform consistency. 
<em>Bernoulli</em>, <b>15(1)</b>, 40&ndash;68.  
</p>
<p>Duembgen, L. and Rufibach, K. (2011)
logcondens: Computations Related to Univariate Log-Concave Density Estimation. 
<em>Journal of Statistical Software</em>, <b>39(6)</b>, 1&ndash;28. <a href="https://doi.org/10.18637/jss.v039.i06">doi:10.18637/jss.v039.i06</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See help file of function "logConDens".
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
