<!DOCTYPE html><html><head><title>Help for package crul</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {crul}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Async'><p>Simple async client</p></a></li>
<li><a href='#AsyncQueue'><p>AsyncQueue</p></a></li>
<li><a href='#AsyncVaried'><p>Async client for different request types</p></a></li>
<li><a href='#auth'><p>Authentication</p></a></li>
<li><a href='#content-types'><p>Working with content types</p></a></li>
<li><a href='#cookies'><p>Working with cookies</p></a></li>
<li><a href='#crul-options'><p>Set curl options, proxy, and basic auth</p></a></li>
<li><a href='#crul-package'><p>crul</p></a></li>
<li><a href='#curl_verbose'><p>curl verbose method</p></a></li>
<li><a href='#curl-options'><p>curl options</p></a></li>
<li><a href='#handle'><p>Make a handle</p></a></li>
<li><a href='#hooks'><p>Event Hooks</p></a></li>
<li><a href='#http-headers'><p>Working with HTTP headers</p></a></li>
<li><a href='#HttpClient'><p>HTTP client</p></a></li>
<li><a href='#HttpRequest'><p>HTTP request object</p></a></li>
<li><a href='#HttpResponse'><p>Base HTTP response object</p></a></li>
<li><a href='#mock'><p>Mocking HTTP requests</p></a></li>
<li><a href='#ok'><p>check if a url is okay</p></a></li>
<li><a href='#Paginator'><p>Paginator client</p></a></li>
<li><a href='#progress'><p>progress bars</p></a></li>
<li><a href='#proxies'><p>proxy options</p></a></li>
<li><a href='#upload'><p>upload file</p></a></li>
<li><a href='#url_build'><p>Build and parse URLs</p></a></li>
<li><a href='#verb-DELETE'><p>HTTP verb info: DELETE</p></a></li>
<li><a href='#verb-GET'><p>HTTP verb info: GET</p></a></li>
<li><a href='#verb-HEAD'><p>HTTP verb info: HEAD</p></a></li>
<li><a href='#verb-PATCH'><p>HTTP verb info: PATCH</p></a></li>
<li><a href='#verb-POST'><p>HTTP verb info: POST</p></a></li>
<li><a href='#verb-PUT'><p>HTTP verb info: PUT</p></a></li>
<li><a href='#writing-options'><p>Writing data options</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>HTTP Client</td>
</tr>
<tr>
<td>Description:</td>
<td>A simple HTTP client, with tools for making HTTP requests,
    and mocking HTTP requests. The package is built on R6, and takes
    inspiration from Ruby's 'faraday' gem (<a href="https://rubygems.org/gems/faraday">https://rubygems.org/gems/faraday</a>).
    The package name is a play on curl, the widely used command line tool
    for HTTP, and this package is built on top of the R package 'curl', an
    interface to 'libcurl' (<a href="https://curl.se/libcurl/">https://curl.se/libcurl/</a>).</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.0</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/crul/">https://docs.ropensci.org/crul/</a> (website)
<a href="https://github.com/ropensci/crul">https://github.com/ropensci/crul</a> (devel)
<a href="https://books.ropensci.org/http-testing/">https://books.ropensci.org/http-testing/</a> (user manual)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/crul/issues">https://github.com/ropensci/crul/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Imports:</td>
<td>curl (&ge; 3.3), R6 (&ge; 2.2.0), urltools (&ge; 1.6.0), httpcode
(&ge; 0.2.0), jsonlite, mime</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, roxygen2 (&ge; 7.1.1), fauxpas (&ge; 0.1.0), webmockr
(&ge; 0.1.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>X-schema.org-applicationCategory:</td>
<td>Web</td>
</tr>
<tr>
<td>X-schema.org-keywords:</td>
<td>http, https, API, web-services, curl, download,
libcurl, async, mocking, caching</td>
</tr>
<tr>
<td>X-schema.org-isPartOf:</td>
<td>https://ropensci.org</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-13 02:57:08 UTC; sckott</td>
</tr>
<tr>
<td>Author:</td>
<td>Scott Chamberlain <a href="https://orcid.org/0000-0003-1444-9135"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Scott Chamberlain &lt;myrmecocystus@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-17 07:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Async'>Simple async client</h2><span id='topic+Async'></span>

<h3>Description</h3>

<p>An async client to work with many URLs, but all with the same HTTP method
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+HttpClient">HttpClient()</a></code> for information on parameters.
</p>


<h3>Value</h3>

<p>a list, with objects of class <code><a href="#topic+HttpResponse">HttpResponse()</a></code>.
Responses are returned in the order they are passed in. We print the
first 10.
</p>


<h3>Failure behavior</h3>

<p>HTTP requests mostly fail in ways that you are probably familiar with,
including when there's a 400 response (the URL not found), and when the
server made a mistake (a 500 series HTTP status code).
</p>
<p>But requests can fail sometimes where there is no HTTP status code, and
no agreed upon way to handle it other than to just fail immediately.
</p>
<p>When a request fails when using synchronous requests (see <a href="#topic+HttpClient">HttpClient</a>)
you get an error message that stops your code progression
immediately saying for example:
</p>

<ul>
<li><p> &quot;Could not resolve host: https://foo.com&quot;
</p>
</li>
<li><p> &quot;Failed to connect to foo.com&quot;
</p>
</li>
<li><p> &quot;Resolving timed out after 10 milliseconds&quot;
</p>
</li></ul>

<p>However, for async requests we don't want to fail immediately because
that would stop the subsequent requests from occurring. Thus, when
we find that a request fails for one of the reasons above we
give back a <a href="#topic+HttpResponse">HttpResponse</a> object just like any other response, and:
</p>

<ul>
<li><p> capture the error message and put it in the <code>content</code> slot of the
response object (thus calls to <code>content</code> and <code>parse()</code> work correctly)
</p>
</li>
<li><p> give back a <code>0</code> HTTP status code. we handle this specially when testing
whether the request was successful or not with e.g., the <code>success()</code>
method
</p>
</li></ul>



<h3>R6 classes</h3>

<p>This is an R6 class from the package <span class="pkg">R6</span>. Find out more
about R6 at <a href="https://r6.r-lib.org/">https://r6.r-lib.org/</a>. After creating an instance of an R6
class (e.g., <code>x &lt;- HttpClient$new(url = "https://hb.opencpu.org")</code>) you can
access values and methods on the object <code>x</code>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>urls</code></dt><dd><p>(character) one or more URLs</p>
</dd>
<dt><code>opts</code></dt><dd><p>any curl options</p>
</dd>
<dt><code>proxies</code></dt><dd><p>named list of headers</p>
</dd>
<dt><code>auth</code></dt><dd><p>an object of class <code>auth</code></p>
</dd>
<dt><code>headers</code></dt><dd><p>named list of headers</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Async-print"><code>Async$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Async-new"><code>Async$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Async-get"><code>Async$get()</code></a>
</p>
</li>
<li> <p><a href="#method-Async-post"><code>Async$post()</code></a>
</p>
</li>
<li> <p><a href="#method-Async-put"><code>Async$put()</code></a>
</p>
</li>
<li> <p><a href="#method-Async-patch"><code>Async$patch()</code></a>
</p>
</li>
<li> <p><a href="#method-Async-delete"><code>Async$delete()</code></a>
</p>
</li>
<li> <p><a href="#method-Async-head"><code>Async$head()</code></a>
</p>
</li>
<li> <p><a href="#method-Async-retry"><code>Async$retry()</code></a>
</p>
</li>
<li> <p><a href="#method-Async-verb"><code>Async$verb()</code></a>
</p>
</li>
<li> <p><a href="#method-Async-clone"><code>Async$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Async-print"></a>



<h4>Method <code>print()</code></h4>

<p>print method for Async objects
</p>


<h5>Usage</h5>

<div class="r"><pre>Async$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>self</p>
</dd>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Async-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new Async object
</p>


<h5>Usage</h5>

<div class="r"><pre>Async$new(urls, opts, proxies, auth, headers)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>urls</code></dt><dd><p>(character) one or more URLs</p>
</dd>
<dt><code>opts</code></dt><dd><p>any curl options</p>
</dd>
<dt><code>proxies</code></dt><dd><p>a <code><a href="#topic+proxy">proxy()</a></code> object</p>
</dd>
<dt><code>auth</code></dt><dd><p>an <code><a href="#topic+auth">auth()</a></code> object</p>
</dd>
<dt><code>headers</code></dt><dd><p>named list of headers</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Async</code> object.
</p>


<hr>
<a id="method-Async-get"></a>



<h4>Method <code>get()</code></h4>

<p>execute the <code>GET</code> http verb for the <code>urls</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Async$get(path = NULL, query = list(), disk = NULL, stream = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>(character) URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>(list) query terms, as a named list</p>
</dd>
<dt><code>disk</code></dt><dd><p>a path to write to. if NULL (default), memory used.
See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_disk()</a></code> for help.</p>
</dd>
<dt><code>stream</code></dt><dd><p>an R function to determine how to stream data. if
<code>NULL</code> (default), memory used. See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_stream()</a></code>
for help</p>
</dd>
<dt><code>...</code></dt><dd><p>curl options, only those in the acceptable set from
<code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code> except the following: httpget, httppost, post,
postfields, postfieldsize, and customrequest</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
(cc &lt;- Async$new(urls = c(
    'https://hb.opencpu.org/',
    'https://hb.opencpu.org/get?a=5',
    'https://hb.opencpu.org/get?foo=bar'
  )))
(res &lt;- cc$get())
}
</pre>
</div>


<hr>
<a id="method-Async-post"></a>



<h4>Method <code>post()</code></h4>

<p>execute the <code>POST</code> http verb for the <code>urls</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Async$post(
  path = NULL,
  query = list(),
  body = NULL,
  encode = "multipart",
  disk = NULL,
  stream = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>(character) URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>(list) query terms, as a named list</p>
</dd>
<dt><code>body</code></dt><dd><p>body as an R list</p>
</dd>
<dt><code>encode</code></dt><dd><p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>disk</code></dt><dd><p>a path to write to. if NULL (default), memory used.
See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_disk()</a></code> for help.</p>
</dd>
<dt><code>stream</code></dt><dd><p>an R function to determine how to stream data. if
<code>NULL</code> (default), memory used. See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_stream()</a></code>
for help</p>
</dd>
<dt><code>...</code></dt><dd><p>curl options, only those in the acceptable set from
<code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code> except the following: httpget, httppost, post,
postfields, postfieldsize, and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Async-put"></a>



<h4>Method <code>put()</code></h4>

<p>execute the <code>PUT</code> http verb for the <code>urls</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Async$put(
  path = NULL,
  query = list(),
  body = NULL,
  encode = "multipart",
  disk = NULL,
  stream = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>(character) URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>(list) query terms, as a named list</p>
</dd>
<dt><code>body</code></dt><dd><p>body as an R list</p>
</dd>
<dt><code>encode</code></dt><dd><p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>disk</code></dt><dd><p>a path to write to. if NULL (default), memory used.
See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_disk()</a></code> for help.</p>
</dd>
<dt><code>stream</code></dt><dd><p>an R function to determine how to stream data. if
<code>NULL</code> (default), memory used. See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_stream()</a></code>
for help</p>
</dd>
<dt><code>...</code></dt><dd><p>curl options, only those in the acceptable set from
<code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code> except the following: httpget, httppost, post,
postfields, postfieldsize, and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Async-patch"></a>



<h4>Method <code>patch()</code></h4>

<p>execute the <code>PATCH</code> http verb for the <code>urls</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Async$patch(
  path = NULL,
  query = list(),
  body = NULL,
  encode = "multipart",
  disk = NULL,
  stream = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>(character) URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>(list) query terms, as a named list</p>
</dd>
<dt><code>body</code></dt><dd><p>body as an R list</p>
</dd>
<dt><code>encode</code></dt><dd><p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>disk</code></dt><dd><p>a path to write to. if NULL (default), memory used.
See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_disk()</a></code> for help.</p>
</dd>
<dt><code>stream</code></dt><dd><p>an R function to determine how to stream data. if
<code>NULL</code> (default), memory used. See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_stream()</a></code>
for help</p>
</dd>
<dt><code>...</code></dt><dd><p>curl options, only those in the acceptable set from
<code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code> except the following: httpget, httppost, post,
postfields, postfieldsize, and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Async-delete"></a>



<h4>Method <code>delete()</code></h4>

<p>execute the <code>DELETE</code> http verb for the <code>urls</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Async$delete(
  path = NULL,
  query = list(),
  body = NULL,
  encode = "multipart",
  disk = NULL,
  stream = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>(character) URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>(list) query terms, as a named list</p>
</dd>
<dt><code>body</code></dt><dd><p>body as an R list</p>
</dd>
<dt><code>encode</code></dt><dd><p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>disk</code></dt><dd><p>a path to write to. if NULL (default), memory used.
See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_disk()</a></code> for help.</p>
</dd>
<dt><code>stream</code></dt><dd><p>an R function to determine how to stream data. if
<code>NULL</code> (default), memory used. See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_stream()</a></code>
for help</p>
</dd>
<dt><code>...</code></dt><dd><p>curl options, only those in the acceptable set from
<code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code> except the following: httpget, httppost, post,
postfields, postfieldsize, and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Async-head"></a>



<h4>Method <code>head()</code></h4>

<p>execute the <code>HEAD</code> http verb for the <code>urls</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Async$head(path = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>(character) URL path, appended to the base URL</p>
</dd>
<dt><code>...</code></dt><dd><p>curl options, only those in the acceptable set from
<code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code> except the following: httpget, httppost, post,
postfields, postfieldsize, and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Async-retry"></a>



<h4>Method <code>retry()</code></h4>

<p>execute the <code>RETRY</code> http verb for the <code>urls</code>. see <code><a href="#topic+HttpRequest">HttpRequest$retry</a></code> method for parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Async$retry(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>curl options, only those in the acceptable set from
<code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code> except the following: httpget, httppost, post,
postfields, postfieldsize, and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Async-verb"></a>



<h4>Method <code>verb()</code></h4>

<p>execute any supported HTTP verb
</p>


<h5>Usage</h5>

<div class="r"><pre>Async$verb(verb, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verb</code></dt><dd><p>(character) a supported HTTP verb: get, post, put, patch, delete,
head.</p>
</dd>
<dt><code>...</code></dt><dd><p>curl options, only those in the acceptable set from
<code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code> except the following: httpget, httppost, post,
postfields, postfieldsize, and customrequest</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
cc &lt;- Async$new(
  urls = c(
    'https://hb.opencpu.org/',
    'https://hb.opencpu.org/get?a=5',
    'https://hb.opencpu.org/get?foo=bar'
  )
)
(res &lt;- cc$verb('get'))
lapply(res, function(z) z$parse("UTF-8"))
}
</pre>
</div>


<hr>
<a id="method-Async-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Async$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other async: 
<code><a href="#topic+AsyncQueue">AsyncQueue</a></code>,
<code><a href="#topic+AsyncVaried">AsyncVaried</a></code>,
<code><a href="#topic+HttpRequest">HttpRequest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cc &lt;- Async$new(
  urls = c(
    'https://hb.opencpu.org/',
    'https://hb.opencpu.org/get?a=5',
    'https://hb.opencpu.org/get?foo=bar'
  )
)
cc
(res &lt;- cc$get())
res[[1]]
res[[1]]$url
res[[1]]$success()
res[[1]]$status_http()
res[[1]]$response_headers
res[[1]]$method
res[[1]]$content
res[[1]]$parse("UTF-8")
lapply(res, function(z) z$parse("UTF-8"))

# curl options/headers with async
urls = c(
 'https://hb.opencpu.org/',
 'https://hb.opencpu.org/get?a=5',
 'https://hb.opencpu.org/get?foo=bar'
)
cc &lt;- Async$new(urls = urls, 
  opts = list(verbose = TRUE),
  headers = list(foo = "bar")
)
cc
(res &lt;- cc$get())

# using auth with async
dd &lt;- Async$new(
  urls = rep('https://hb.opencpu.org/basic-auth/user/passwd', 3),
  auth = auth(user = "foo", pwd = "passwd"),
  opts = list(verbose = TRUE)
)
dd
res &lt;- dd$get()
res
vapply(res, function(z) z$status_code, double(1))
vapply(res, function(z) z$success(), logical(1))
lapply(res, function(z) z$parse("UTF-8"))

# failure behavior
## e.g. when a URL doesn't exist, a timeout, etc.
urls &lt;- c("http://stuffthings.gvb", "https://foo.com", 
  "https://hb.opencpu.org/get")
conn &lt;- Async$new(urls = urls)
res &lt;- conn$get()
res[[1]]$parse("UTF-8") # a failure
res[[2]]$parse("UTF-8") # a failure
res[[3]]$parse("UTF-8") # a success

# retry
urls = c("https://hb.opencpu.org/status/404", "https://hb.opencpu.org/status/429")
conn &lt;- Async$new(urls = urls)
res &lt;- conn$retry(verb="get")

## End(Not run)

## ------------------------------------------------
## Method `Async$get`
## ------------------------------------------------

## Not run: 
(cc &lt;- Async$new(urls = c(
    'https://hb.opencpu.org/',
    'https://hb.opencpu.org/get?a=5',
    'https://hb.opencpu.org/get?foo=bar'
  )))
(res &lt;- cc$get())

## End(Not run)

## ------------------------------------------------
## Method `Async$verb`
## ------------------------------------------------

## Not run: 
cc &lt;- Async$new(
  urls = c(
    'https://hb.opencpu.org/',
    'https://hb.opencpu.org/get?a=5',
    'https://hb.opencpu.org/get?foo=bar'
  )
)
(res &lt;- cc$verb('get'))
lapply(res, function(z) z$parse("UTF-8"))

## End(Not run)
</code></pre>

<hr>
<h2 id='AsyncQueue'>AsyncQueue</h2><span id='topic+AsyncQueue'></span>

<h3>Description</h3>

<p>An AsyncQueue client
</p>


<h3>R6 classes</h3>

<p>This is an R6 class from the package <span class="pkg">R6</span>. Find out more
about R6 at <a href="https://r6.r-lib.org/">https://r6.r-lib.org/</a>. After creating an instance of an R6
class (e.g., <code>x &lt;- HttpClient$new(url = "https://hb.opencpu.org")</code>) you can
access values and methods on the object <code>x</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+AsyncVaried">crul::AsyncVaried</a></code> -&gt; <code>AsyncQueue</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>bucket_size</code></dt><dd><p>(integer) number of requests to send at once</p>
</dd>
<dt><code>sleep</code></dt><dd><p>(integer) number of seconds to sleep between each bucket</p>
</dd>
<dt><code>req_per_min</code></dt><dd><p>(integer) requests per minute</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AsyncQueue-print"><code>AsyncQueue$print()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncQueue-new"><code>AsyncQueue$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncQueue-request"><code>AsyncQueue$request()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncQueue-responses"><code>AsyncQueue$responses()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncQueue-parse"><code>AsyncQueue$parse()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncQueue-status_code"><code>AsyncQueue$status_code()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncQueue-status"><code>AsyncQueue$status()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncQueue-content"><code>AsyncQueue$content()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncQueue-times"><code>AsyncQueue$times()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncQueue-clone"><code>AsyncQueue$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="crul" data-topic="AsyncVaried" data-id="requests"><a href='../../crul/html/AsyncVaried.html#method-AsyncVaried-requests'><code>crul::AsyncVaried$requests()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-AsyncQueue-print"></a>



<h4>Method <code>print()</code></h4>

<p>print method for AsyncQueue objects
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncQueue$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>self</p>
</dd>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AsyncQueue-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>AsyncQueue</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncQueue$new(
  ...,
  .list = list(),
  bucket_size = 5,
  sleep = NULL,
  req_per_min = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>..., .list</code></dt><dd><p>Any number of objects of class <code><a href="#topic+HttpRequest">HttpRequest()</a></code>,
must supply inputs to one of these parameters, but not both</p>
</dd>
<dt><code>bucket_size</code></dt><dd><p>(integer) number of requests to send at once.
default: 5. See Details.</p>
</dd>
<dt><code>sleep</code></dt><dd><p>(integer) seconds to sleep between buckets.
default: NULL (not set)</p>
</dd>
<dt><code>req_per_min</code></dt><dd><p>(integer) maximum number of requests per minute.
if <code>NULL</code> (default), its ignored</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Must set either <code>sleep</code> or <code>req_per_min</code>. If you set
<code>req_per_min</code> we calculate a new <code>bucket_size</code> when <code style="white-space: pre;">&#8288;$new()&#8288;</code> is
called
</p>



<h5>Returns</h5>

<p>A new <code>AsyncQueue</code> object
</p>


<hr>
<a id="method-AsyncQueue-request"></a>



<h4>Method <code>request()</code></h4>

<p>Execute asynchronous requests
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncQueue$request()</pre></div>



<h5>Returns</h5>

<p>nothing, responses stored inside object, though will print
messages if you choose verbose output
</p>


<hr>
<a id="method-AsyncQueue-responses"></a>



<h4>Method <code>responses()</code></h4>

<p>List responses
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncQueue$responses()</pre></div>



<h5>Returns</h5>

<p>a list of <code>HttpResponse</code> objects, empty list before
requests made
</p>


<hr>
<a id="method-AsyncQueue-parse"></a>



<h4>Method <code>parse()</code></h4>

<p>parse content
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncQueue$parse(encoding = "UTF-8")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>encoding</code></dt><dd><p>(character) the encoding to use in parsing.
default:&quot;UTF-8&quot;</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>character vector, empty character vector before
requests made
</p>


<hr>
<a id="method-AsyncQueue-status_code"></a>



<h4>Method <code>status_code()</code></h4>

<p>Get HTTP status codes for each response
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncQueue$status_code()</pre></div>



<h5>Returns</h5>

<p>numeric vector, empty numeric vector before requests made
</p>


<hr>
<a id="method-AsyncQueue-status"></a>



<h4>Method <code>status()</code></h4>

<p>List HTTP status objects
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncQueue$status()</pre></div>



<h5>Returns</h5>

<p>a list of <code>http_code</code> objects, empty list before requests made
</p>


<hr>
<a id="method-AsyncQueue-content"></a>



<h4>Method <code>content()</code></h4>

<p>Get raw content for each response
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncQueue$content()</pre></div>



<h5>Returns</h5>

<p>raw list, empty list before requests made
</p>


<hr>
<a id="method-AsyncQueue-times"></a>



<h4>Method <code>times()</code></h4>

<p>curl request times
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncQueue$times()</pre></div>



<h5>Returns</h5>

<p>list of named numeric vectors, empty list before requests made
</p>


<hr>
<a id="method-AsyncQueue-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncQueue$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other async: 
<code><a href="#topic+AsyncVaried">AsyncVaried</a></code>,
<code><a href="#topic+Async">Async</a></code>,
<code><a href="#topic+HttpRequest">HttpRequest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Using sleep (note this works with retry requests)
reqlist &lt;- list(
  HttpRequest$new(url = "https://hb.opencpu.org/get")$get(),
  HttpRequest$new(url = "https://hb.opencpu.org/post")$post(),
  HttpRequest$new(url = "https://hb.opencpu.org/put")$put(),
  HttpRequest$new(url = "https://hb.opencpu.org/delete")$delete(),
  HttpRequest$new(url = "https://hb.opencpu.org/get?g=5")$get(),
  HttpRequest$new(
    url = "https://hb.opencpu.org/post")$post(body = list(y = 9)),
  HttpRequest$new(
    url = "https://hb.opencpu.org/get")$get(query = list(hello = "world")),
  HttpRequest$new(url = "https://ropensci.org")$get(),
  HttpRequest$new(url = "https://ropensci.org/about")$get(),
  HttpRequest$new(url = "https://ropensci.org/packages")$get(),
  HttpRequest$new(url = "https://ropensci.org/community")$get(),
  HttpRequest$new(url = "https://ropensci.org/blog")$get(),
  HttpRequest$new(url = "https://ropensci.org/careers")$get(),
  HttpRequest$new(url = "https://hb.opencpu.org/status/404")$retry("get")
)
out &lt;- AsyncQueue$new(.list = reqlist, bucket_size = 5, sleep = 3)
out
out$bucket_size # bucket size
out$requests() # list requests
out$request() # make requests
out$responses() # list responses

# Using requests per minute
if (interactive()) {
x="https://raw.githubusercontent.com/ropensci/roregistry/gh-pages/registry.json"
z &lt;- HttpClient$new(x)$get()
urls &lt;- jsonlite::fromJSON(z$parse("UTF-8"))$packages$url
repos = Filter(length, regmatches(urls, gregexpr("ropensci/[A-Za-z]+", urls)))
repos = unlist(repos)
auth &lt;- list(Authorization = paste("token", Sys.getenv('GITHUB_PAT')))
reqs &lt;- lapply(repos[1:50], function(w) {
  HttpRequest$new(paste0("https://api.github.com/repos/", w), headers = auth)$get()
})

out &lt;- AsyncQueue$new(.list = reqs, req_per_min = 30)
out
out$bucket_size
out$requests()
out$request()
out$responses()
}
## End(Not run)
</code></pre>

<hr>
<h2 id='AsyncVaried'>Async client for different request types</h2><span id='topic+AsyncVaried'></span>

<h3>Description</h3>

<p>An async client to do many requests, each with different URLs, curl options,
etc.
</p>


<h3>Value</h3>

<p>An object of class <code>AsyncVaried</code> with variables and methods.
<a href="#topic+HttpResponse">HttpResponse</a> objects are returned in the order they are passed in.
We print the first 10.
</p>


<h3>Failure behavior</h3>

<p>HTTP requests mostly fail in ways that you are probably familiar with,
including when there's a 400 response (the URL not found), and when the
server made a mistake (a 500 series HTTP status code).
</p>
<p>But requests can fail sometimes where there is no HTTP status code, and
no agreed upon way to handle it other than to just fail immediately.
</p>
<p>When a request fails when using synchronous requests (see <a href="#topic+HttpClient">HttpClient</a>)
you get an error message that stops your code progression
immediately saying for example:
</p>

<ul>
<li><p> &quot;Could not resolve host: https://foo.com&quot;
</p>
</li>
<li><p> &quot;Failed to connect to foo.com&quot;
</p>
</li>
<li><p> &quot;Resolving timed out after 10 milliseconds&quot;
</p>
</li></ul>

<p>However, for async requests we don't want to fail immediately because
that would stop the subsequent requests from occurring. Thus, when
we find that a request fails for one of the reasons above we
give back a <a href="#topic+HttpResponse">HttpResponse</a> object just like any other response, and:
</p>

<ul>
<li><p> capture the error message and put it in the <code>content</code> slot of the
response object (thus calls to <code>content</code> and <code>parse()</code> work correctly)
</p>
</li>
<li><p> give back a <code>0</code> HTTP status code. we handle this specially when testing
whether the request was successful or not with e.g., the <code>success()</code>
method
</p>
</li></ul>



<h3>R6 classes</h3>

<p>This is an R6 class from the package <span class="pkg">R6</span>. Find out more
about R6 at <a href="https://r6.r-lib.org/">https://r6.r-lib.org/</a>. After creating an instance of an R6
class (e.g., <code>x &lt;- HttpClient$new(url = "https://hb.opencpu.org")</code>) you can
access values and methods on the object <code>x</code>.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AsyncVaried-print"><code>AsyncVaried$print()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncVaried-new"><code>AsyncVaried$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncVaried-request"><code>AsyncVaried$request()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncVaried-responses"><code>AsyncVaried$responses()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncVaried-requests"><code>AsyncVaried$requests()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncVaried-parse"><code>AsyncVaried$parse()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncVaried-status_code"><code>AsyncVaried$status_code()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncVaried-status"><code>AsyncVaried$status()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncVaried-content"><code>AsyncVaried$content()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncVaried-times"><code>AsyncVaried$times()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncVaried-clone"><code>AsyncVaried$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-AsyncVaried-print"></a>



<h4>Method <code>print()</code></h4>

<p>print method for AsyncVaried objects
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncVaried$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>self</p>
</dd>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AsyncVaried-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new AsyncVaried object
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncVaried$new(..., .list = list())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>..., .list</code></dt><dd><p>Any number of objects of class <code><a href="#topic+HttpRequest">HttpRequest()</a></code>,
must supply inputs to one of these parameters, but not both</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>AsyncVaried</code> object
</p>


<hr>
<a id="method-AsyncVaried-request"></a>



<h4>Method <code>request()</code></h4>

<p>Execute asynchronous requests
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncVaried$request()</pre></div>



<h5>Returns</h5>

<p>nothing, responses stored inside object, though will print
messages if you choose verbose output
</p>


<hr>
<a id="method-AsyncVaried-responses"></a>



<h4>Method <code>responses()</code></h4>

<p>List responses
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncVaried$responses()</pre></div>



<h5>Details</h5>

<p>An S3 print method is used to summarise results. <a href="base.html#topic+unclass">unclass</a>
the output to see the list, or index to results, e.g., <code style="white-space: pre;">&#8288;[1]&#8288;</code>, <code style="white-space: pre;">&#8288;[1:3]&#8288;</code>
</p>



<h5>Returns</h5>

<p>a list of <code>HttpResponse</code> objects, empty list before
requests made
</p>


<hr>
<a id="method-AsyncVaried-requests"></a>



<h4>Method <code>requests()</code></h4>

<p>List requests
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncVaried$requests()</pre></div>



<h5>Returns</h5>

<p>a list of <code>HttpRequest</code> objects, empty list before
requests made
</p>


<hr>
<a id="method-AsyncVaried-parse"></a>



<h4>Method <code>parse()</code></h4>

<p>parse content
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncVaried$parse(encoding = "UTF-8")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>encoding</code></dt><dd><p>(character) the encoding to use in parsing.
default:&quot;UTF-8&quot;</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>character vector, empty character vector before
requests made
</p>


<hr>
<a id="method-AsyncVaried-status_code"></a>



<h4>Method <code>status_code()</code></h4>

<p>Get HTTP status codes for each response
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncVaried$status_code()</pre></div>



<h5>Returns</h5>

<p>numeric vector, empty numeric vector before requests made
</p>


<hr>
<a id="method-AsyncVaried-status"></a>



<h4>Method <code>status()</code></h4>

<p>List HTTP status objects
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncVaried$status()</pre></div>



<h5>Returns</h5>

<p>a list of <code>http_code</code> objects, empty list before requests made
</p>


<hr>
<a id="method-AsyncVaried-content"></a>



<h4>Method <code>content()</code></h4>

<p>Get raw content for each response
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncVaried$content()</pre></div>



<h5>Returns</h5>

<p>raw list, empty list before requests made
</p>


<hr>
<a id="method-AsyncVaried-times"></a>



<h4>Method <code>times()</code></h4>

<p>curl request times
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncVaried$times()</pre></div>



<h5>Returns</h5>

<p>list of named numeric vectors, empty list before requests made
</p>


<hr>
<a id="method-AsyncVaried-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncVaried$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other async: 
<code><a href="#topic+AsyncQueue">AsyncQueue</a></code>,
<code><a href="#topic+Async">Async</a></code>,
<code><a href="#topic+HttpRequest">HttpRequest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# pass in requests via ...
req1 &lt;- HttpRequest$new(
  url = "https://hb.opencpu.org/get",
  opts = list(verbose = TRUE),
  headers = list(foo = "bar")
)$get()
req2 &lt;- HttpRequest$new(url = "https://hb.opencpu.org/post")$post()

# Create an AsyncVaried object
out &lt;- AsyncVaried$new(req1, req2)

# before you make requests, the methods return empty objects
out$status()
out$status_code()
out$content()
out$times()
out$parse()
out$responses()

# make requests
out$request()

# access various parts
## http status objects
out$status()
## status codes
out$status_code()
## content (raw data)
out$content()
## times
out$times()
## parsed content
out$parse()
## response objects
out$responses()

# use $verb() method to select http verb
method &lt;- "post"
req1 &lt;- HttpRequest$new(
  url = "https://hb.opencpu.org/post",
  opts = list(verbose = TRUE),
  headers = list(foo = "bar")
)$verb(method)
req2 &lt;- HttpRequest$new(url = "https://hb.opencpu.org/post")$verb(method)
out &lt;- AsyncVaried$new(req1, req2)
out
out$request()
out$responses()

# pass in requests in a list via .list param
reqlist &lt;- list(
  HttpRequest$new(url = "https://hb.opencpu.org/get")$get(),
  HttpRequest$new(url = "https://hb.opencpu.org/post")$post(),
  HttpRequest$new(url = "https://hb.opencpu.org/put")$put(),
  HttpRequest$new(url = "https://hb.opencpu.org/delete")$delete(),
  HttpRequest$new(url = "https://hb.opencpu.org/get?g=5")$get(),
  HttpRequest$new(
    url = "https://hb.opencpu.org/post")$post(body = list(y = 9)),
  HttpRequest$new(
    url = "https://hb.opencpu.org/get")$get(query = list(hello = "world"))
)

out &lt;- AsyncVaried$new(.list = reqlist)
out$request()
out$status()
out$status_code()
out$content()
out$times()
out$parse()

# using auth with async
url &lt;- "https://hb.opencpu.org/basic-auth/user/passwd"
auth &lt;- auth(user = "user", pwd = "passwd")
reqlist &lt;- list(
  HttpRequest$new(url = url, auth = auth)$get(),
  HttpRequest$new(url = url, auth = auth)$get(query = list(a=5)),
  HttpRequest$new(url = url, auth = auth)$get(query = list(b=3))
)
out &lt;- AsyncVaried$new(.list = reqlist)
out$request()
out$status()
out$parse()

# failure behavior
## e.g. when a URL doesn't exist, a timeout, etc.
reqlist &lt;- list(
  HttpRequest$new(url = "http://stuffthings.gvb")$get(),
  HttpRequest$new(url = "https://hb.opencpu.org")$head(),
  HttpRequest$new(url = "https://hb.opencpu.org",
   opts = list(timeout_ms = 10))$head()
)
(tmp &lt;- AsyncVaried$new(.list = reqlist))
tmp$request()
tmp$responses()
tmp$parse("UTF-8")

# access intemediate redirect headers
dois &lt;- c("10.7202/1045307ar", "10.1242/jeb.088898", "10.1121/1.3383963")
reqlist &lt;- list(
  HttpRequest$new(url = paste0("https://doi.org/", dois[1]))$get(),
  HttpRequest$new(url = paste0("https://doi.org/", dois[2]))$get(),
  HttpRequest$new(url = paste0("https://doi.org/", dois[3]))$get()
)
tmp &lt;- AsyncVaried$new(.list = reqlist)
tmp$request()
tmp
lapply(tmp$responses(), "[[", "response_headers_all")

# retry
reqlist &lt;- list(
  HttpRequest$new(url = "https://hb.opencpu.org/get")$get(),
  HttpRequest$new(url = "https://hb.opencpu.org/post")$post(),
  HttpRequest$new(url = "https://hb.opencpu.org/status/404")$retry("get"),
  HttpRequest$new(url = "https://hb.opencpu.org/status/429")$retry("get",
   retry_only_on = c(403, 429), times = 2)
)
tmp &lt;- AsyncVaried$new(.list = reqlist)
tmp
tmp$request()
tmp$responses()[[3]]

## End(Not run)
</code></pre>

<hr>
<h2 id='auth'>Authentication</h2><span id='topic+auth'></span>

<h3>Description</h3>

<p>Authentication
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auth(user, pwd, auth = "basic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auth_+3A_user">user</code></td>
<td>
<p>(character) username, required. see Details.</p>
</td></tr>
<tr><td><code id="auth_+3A_pwd">pwd</code></td>
<td>
<p>(character) password, required. see Details.</p>
</td></tr>
<tr><td><code id="auth_+3A_auth">auth</code></td>
<td>
<p>(character) authentication type, one of basic (default),
digest, digest_ie, gssnegotiate, ntlm, or any. required</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only supporting simple auth for now, OAuth later maybe.
</p>
<p>For <code>user</code> and <code>pwd</code> you are required to pass in some value.
The value can be <code>NULL</code> to - which is equivalent to passing in an
empty string like <code>""</code> in <code>httr::authenticate</code>. You may want to pass
in <code>NULL</code> for both <code>user</code> and <code>pwd</code> for example if you are using
<code>gssnegotiate</code> auth type. See example below.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>auth(user = "foo", pwd = "bar", auth = "basic")
auth(user = "foo", pwd = "bar", auth = "digest")
auth(user = "foo", pwd = "bar", auth = "ntlm")
auth(user = "foo", pwd = "bar", auth = "any")

# gssnegotiate auth
auth(NULL, NULL, "gssnegotiate")

## Not run: 
# with HttpClient
(res &lt;- HttpClient$new(
  url = "https://hb.opencpu.org/basic-auth/user/passwd",
  auth = auth(user = "user", pwd = "passwd")
))
res$auth
x &lt;- res$get()
jsonlite::fromJSON(x$parse("UTF-8"))

# with HttpRequest
(res &lt;- HttpRequest$new(
  url = "https://hb.opencpu.org/basic-auth/user/passwd",
  auth = auth(user = "user", pwd = "passwd")
))
res$auth

## End(Not run)
</code></pre>

<hr>
<h2 id='content-types'>Working with content types</h2><span id='topic+content-types'></span>

<h3>Description</h3>

<p>The <a href="#topic+HttpResponse">HttpResponse</a> class holds all the responses elements for an HTTP
request. This document details how to work specifically with the
content-type of the response headers
</p>


<h3>Content types</h3>

<p>The &quot;Content-Type&quot; header in HTTP responses gives the media type of the
response. The media type is both the data format and how the data is
intended to be processed by a recipient. (modified from rfc7231)
</p>


<h3>Behavior of the parameters HttpResponse raise_for_ct* methods</h3>


<ul>
<li><p> type: (only applicable for the <code>raise_for_ct()</code> method): instead of
using one of the three other content type methods for html, json, or xml,
you can specify a mime type to check, any of those in <a href="mime.html#topic+mimemap">mime::mimemap</a>
</p>
</li>
<li><p> charset: if you don't give a value to this parameter, we only
check that the content type is what you expect; that is, the charset,
if given, is ignored.
</p>
</li>
<li><p> behavior: by default when you call this method, and the content type
does not match what the method expects, then we run <code>stop()</code> with a
message. Instead of stopping, you can choose <code>behavior="warning"</code>
and we'll throw a warning instead, allowing any downstream processing
to proceed.
</p>
</li></ul>



<h3>References</h3>

<p>spec for content types:
<a href="https://datatracker.ietf.org/doc/html/rfc7231#section-3.1.1.5">https://datatracker.ietf.org/doc/html/rfc7231#section-3.1.1.5</a>
</p>
<p>spec for media types:
<a href="https://datatracker.ietf.org/doc/html/rfc7231#section-3.1.1.1">https://datatracker.ietf.org/doc/html/rfc7231#section-3.1.1.1</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+HttpResponse">HttpResponse</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
(x &lt;- HttpClient$new(url = "https://hb.opencpu.org"))
(res &lt;- x$get())

## see the content type
res$response_headers

## check that the content type is text/html
res$raise_for_ct_html()

## it's def. not json
# res$raise_for_ct_json()

## give custom content type
res$raise_for_ct("text/html")
# res$raise_for_ct("application/json")
# res$raise_for_ct("foo/bar")

## check charset in addition to the media type
res$raise_for_ct_html(charset = "utf-8")
# res$raise_for_ct_html(charset = "utf-16")

# warn instead of stop
res$raise_for_ct_json(behavior = "warning")

## End(Not run)
</code></pre>

<hr>
<h2 id='cookies'>Working with cookies</h2><span id='topic+cookies'></span>

<h3>Description</h3>

<p>Working with cookies
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- HttpClient$new(
  url = "https://hb.opencpu.org",
  opts = list(
    cookie = "c=1;f=5",
    verbose = TRUE
  )
)
x

# set cookies
(res &lt;- x$get("cookies"))
jsonlite::fromJSON(res$parse("UTF-8"))

(x &lt;- HttpClient$new(url = "https://hb.opencpu.org"))
res &lt;- x$get("cookies/set", query = list(foo = 123, bar = "ftw"))
jsonlite::fromJSON(res$parse("UTF-8"))
curl::handle_cookies(handle = res$handle)

# reuse handle
res2 &lt;- x$get("get", query = list(hello = "world"))
jsonlite::fromJSON(res2$parse("UTF-8"))
curl::handle_cookies(handle = res2$handle)

# DOAJ
x &lt;- HttpClient$new(url = "https://doaj.org")
res &lt;- x$get("api/v1/journals/f3f2e7f23d444370ae5f5199f85bc100",
  verbose = TRUE)
res$response_headers$`set-cookie`
curl::handle_cookies(handle = res$handle)
res2 &lt;- x$get("api/v1/journals/9abfb36b06404e8a8566e1a44180bbdc",
  verbose = TRUE)

## reset handle
x$handle_pop()
## cookies no longer sent, as handle reset
res2 &lt;- x$get("api/v1/journals/9abfb36b06404e8a8566e1a44180bbdc",
  verbose = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='crul-options'>Set curl options, proxy, and basic auth</h2><span id='topic+crul-options'></span><span id='topic+set_opts'></span><span id='topic+set_verbose'></span><span id='topic+set_proxy'></span><span id='topic+set_auth'></span><span id='topic+set_headers'></span><span id='topic+crul_settings'></span>

<h3>Description</h3>

<p>Set curl options, proxy, and basic auth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_opts(...)

set_verbose()

set_proxy(x)

set_auth(x)

set_headers(...)

crul_settings(reset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crul-options_+3A_...">...</code></td>
<td>
<p>For <code>set_opts()</code> any curl option in the set
<code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code>. For <code>set_headers()</code> a named list of headers</p>
</td></tr>
<tr><td><code id="crul-options_+3A_x">x</code></td>
<td>
<p>For <code>set_proxy()</code> a <code>proxy</code> object made with <code><a href="#topic+proxy">proxy()</a></code>. For
<code>set_auth()</code> an <code>auth</code> object made with <code><a href="#topic+auth">auth()</a></code></p>
</td></tr>
<tr><td><code id="crul-options_+3A_reset">reset</code></td>
<td>
<p>(logical) reset all settings (aka, delete them).
Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>set_opts()</code>: set curl options; supports any options in
<code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code>
</p>
</li>
<li> <p><code>set_verbose()</code>: set custom curl verbose; sets <code>verbose=TRUE</code>
and <code>debugfunction</code> to the callback result from <code><a href="#topic+curl_verbose">curl_verbose()</a></code>
</p>
</li>
<li> <p><code>set_proxy()</code>: set proxy settings, accepts <code><a href="#topic+proxy">proxy()</a></code>
</p>
</li>
<li> <p><code>set_auth()</code>: set authorization, accepts <code><a href="#topic+auth">auth()</a></code>
</p>
</li>
<li> <p><code>set_headers()</code>: set request headers, a named list
</p>
</li>
<li> <p><code>crul_settings()</code>: list all settigns set via these functions
</p>
</li></ul>



<h3>Note</h3>

<p>the <code>mock</code> option will be seen in output of <code>crul_settings()</code>
but is set via the function <code><a href="#topic+mock">mock()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# get settings
crul_settings()

# curl options
set_opts(timeout_ms = 1000)
crul_settings()
set_opts(timeout_ms = 4000)
crul_settings()
set_opts(verbose = TRUE)
crul_settings()
## Not run: 
HttpClient$new('https://hb.opencpu.org')$get('get')

## End(Not run)
# set_verbose - sets: `verbose=TRUE`, and `debugfunction` to 
# result of call to `curl_verbose()`, see `?curl_verbose`
set_verbose()
crul_settings()

# basic authentication
set_auth(auth(user = "foo", pwd = "bar", auth = "basic"))
crul_settings()

# proxies
set_proxy(proxy("http://97.77.104.22:3128"))
crul_settings()

# headers
crul_settings(TRUE) # reset first
set_headers(foo = "bar")
crul_settings()
set_headers(`User-Agent` = "hello world")
crul_settings()
## Not run: 
set_opts(verbose = TRUE)
HttpClient$new('https://hb.opencpu.org')$get('get')

## End(Not run)

# reset
crul_settings(TRUE)
crul_settings()

# works with async functions
## Async
set_opts(verbose = TRUE)
cc &lt;- Async$new(urls = c(
    'https://hb.opencpu.org/get?a=5',
    'https://hb.opencpu.org/get?foo=bar'))
(res &lt;- cc$get())

## AsyncVaried
set_opts(verbose = TRUE)
set_headers(stuff = "things")
reqlist &lt;- list(
  HttpRequest$new(url = "https://hb.opencpu.org/get")$get(),
  HttpRequest$new(url = "https://hb.opencpu.org/post")$post())
out &lt;- AsyncVaried$new(.list = reqlist)
out$request()
}
</code></pre>

<hr>
<h2 id='crul-package'>crul</h2><span id='topic+crul-package'></span><span id='topic+crul'></span>

<h3>Description</h3>

<p><strong>HTTP R client</strong>
</p>


<h3>Package API</h3>


<ul>
<li> <p><code><a href="#topic+HttpClient">HttpClient()</a></code> - create a connection client, set all
your http options, make http requests
</p>
</li>
<li> <p><code><a href="#topic+HttpResponse">HttpResponse()</a></code> - mostly for internal use, handles
http responses
</p>
</li>
<li> <p><code><a href="#topic+Paginator">Paginator()</a></code> - auto-paginate through requests
</p>
</li>
<li> <p><code><a href="#topic+Async">Async()</a></code> - asynchronous requests
</p>
</li>
<li> <p><code><a href="#topic+AsyncVaried">AsyncVaried()</a></code> - varied asynchronous requests
</p>
</li>
<li> <p><code><a href="#topic+HttpRequest">HttpRequest()</a></code> - generate an HTTP request, mostly for
use in building requests to be used in <code>Async</code> or <code>AsyncVaried</code>
</p>
</li>
<li> <p><code><a href="#topic+mock">mock()</a></code> - Turn on/off mocking, via <code>webmockr</code>
</p>
</li>
<li> <p><code><a href="#topic+auth">auth()</a></code> - Simple authentication helper
</p>
</li>
<li> <p><code><a href="#topic+proxy">proxy()</a></code> - Proxy helper
</p>
</li>
<li> <p><code><a href="#topic+upload">upload()</a></code> - File upload helper
</p>
</li>
<li><p> set curl options globally: <code><a href="#topic+set_auth">set_auth()</a></code>, <code><a href="#topic+set_headers">set_headers()</a></code>,
<code><a href="#topic+set_opts">set_opts()</a></code>, <code><a href="#topic+set_proxy">set_proxy()</a></code>, and <code><a href="#topic+crul_settings">crul_settings()</a></code>
</p>
</li></ul>



<h3>HTTP verbs (or HTTP request methods)</h3>

<p>See <a href="#topic+verb-GET">verb-GET</a>, <a href="#topic+verb-POST">verb-POST</a>, <a href="#topic+verb-PUT">verb-PUT</a>, <a href="#topic+verb-PATCH">verb-PATCH</a>, <a href="#topic+verb-DELETE">verb-DELETE</a>,
<a href="#topic+verb-HEAD">verb-HEAD</a> for details.
</p>

<ul>
<li> <p><a href="#topic+HttpClient">HttpClient</a> is the main interface for making HTTP requests,
and includes methods for each HTTP verb
</p>
</li>
<li> <p><a href="#topic+HttpRequest">HttpRequest</a> allows you to prepare a HTTP payload for use with
<a href="#topic+AsyncVaried">AsyncVaried</a>, which provides asynchronous requests for varied
HTTP methods
</p>
</li>
<li> <p><a href="#topic+Async">Async</a> provides asynchronous requests for a single HTTP method
at a time
</p>
</li>
<li><p> the <code>verb()</code> method can be used on all the above to request
a specific HTTP verb
</p>
</li></ul>



<h3>Checking HTTP responses</h3>

<p><code><a href="#topic+HttpResponse">HttpResponse()</a></code> has helpers for checking and raising warnings/errors.
</p>

<ul>
<li> <p><a href="#topic+content-types">content-types</a> details the various options for checking content
types and throwing a warning or error if the response content
type doesn't match what you expect. Mis-matched content-types are
typically a good sign of a bad response. There's methods built
in for json, xml and html, with the ability to set any
custom content type
</p>
</li>
<li> <p><code>raise_for_status()</code> is a method on <code><a href="#topic+HttpResponse">HttpResponse()</a></code> that checks
the HTTP status code, and errors with the appropriate message for
the HTTP status code, optionally using the package <code>fauxpas</code>
if it's installed.
</p>
</li></ul>



<h3>HTTP conditions</h3>

<p>We use <code>fauxpas</code> if you have it installed for handling HTTP
conditions but if it's not installed we use <span class="pkg">httpcode</span>
</p>


<h3>Mocking</h3>

<p>Mocking HTTP requests is supported via the <span class="pkg">webmockr</span>
package. See <a href="#topic+mock">mock</a> for guidance, and
<a href="https://books.ropensci.org/http-testing/">https://books.ropensci.org/http-testing/</a>
</p>


<h3>Caching</h3>

<p>Caching HTTP requests is supported via the <span class="pkg">vcr</span>
package. See <a href="https://books.ropensci.org/http-testing/">https://books.ropensci.org/http-testing/</a>
</p>


<h3>Links</h3>

<p>Source code: <a href="https://github.com/ropensci/crul">https://github.com/ropensci/crul</a>
</p>
<p>Bug reports/feature requests: <a href="https://github.com/ropensci/crul/issues">https://github.com/ropensci/crul/issues</a>
</p>


<h3>Author(s)</h3>

<p>Scott Chamberlain <a href="mailto:myrmecocystus@gmail.com">myrmecocystus@gmail.com</a>
</p>

<hr>
<h2 id='curl_verbose'>curl verbose method</h2><span id='topic+curl_verbose'></span>

<h3>Description</h3>

<p>curl verbose method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curl_verbose(data_out = TRUE, data_in = FALSE, info = FALSE, ssl = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curl_verbose_+3A_data_out">data_out</code></td>
<td>
<p>Show data sent to the server</p>
</td></tr>
<tr><td><code id="curl_verbose_+3A_data_in">data_in</code></td>
<td>
<p>Show data recieved from the server</p>
</td></tr>
<tr><td><code id="curl_verbose_+3A_info">info</code></td>
<td>
<p>Show informational text from curl. This is mainly useful for
debugging https and auth problems, so is disabled by default</p>
</td></tr>
<tr><td><code id="curl_verbose_+3A_ssl">ssl</code></td>
<td>
<p>Show even data sent/recieved over SSL connections?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>line prefixes:
</p>

<ul>
<li> <p><code>*</code> informative curl messages
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;=&gt;&#8288;</code> headers sent (out)
</p>
</li>
<li> <p><code>&gt;</code> data sent (out)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;*&gt;&#8288;</code> ssl data sent (out)
</p>
</li>
<li> <p><code>&lt;=</code> headers received (in)
</p>
</li>
<li> <p><code>&lt;</code> data received (in)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;&lt;*&#8288;</code> ssl data received (in)
</p>
</li></ul>



<h3>Note</h3>

<p>adapted from <code>httr::verbose</code>
</p>

<hr>
<h2 id='curl-options'>curl options</h2><span id='topic+curl-options'></span><span id='topic+user-agent'></span><span id='topic+verbose'></span><span id='topic+timeout'></span>

<h3>Description</h3>

<p>With the <code>opts</code> parameter you can pass in various
curl options, including user agent string, whether to get verbose
curl output or not, setting a timeout for requests, and more. See
<code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code> for all the options you can use. Note that
you need to give curl options exactly as given in
<code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
url &lt;- "https://hb.opencpu.org"

# set curl options on client initialization
(res &lt;- HttpClient$new(url = url, opts = list(verbose = TRUE)))
res$opts
res$get('get')

# or set curl options when performing HTTP operation
(res &lt;- HttpClient$new(url = url))
res$get('get', verbose = TRUE)
res$get('get', stuff = "things")

# set a timeout
(res &lt;- HttpClient$new(url = url, opts = list(timeout_ms = 1)))
# res$get('get')

# set user agent either as a header or an option
HttpClient$new(url = url,
  headers = list(`User-Agent` = "hello world"),
  opts = list(verbose = TRUE)
)$get('get')

HttpClient$new(url = url,
  opts = list(verbose = TRUE, useragent = "hello world")
)$get('get')

# You can also set custom debug function via the verbose 
# parameter when calling `$new()`
res &lt;- HttpClient$new(url, verbose=curl_verbose())
res
res$get("get")
res &lt;- HttpClient$new(url, verbose=curl_verbose(data_in=TRUE))
res$get("get")
res &lt;- HttpClient$new(url, verbose=curl_verbose(info=TRUE))
res$get("get")

## End(Not run)
</code></pre>

<hr>
<h2 id='handle'>Make a handle</h2><span id='topic+handle'></span>

<h3>Description</h3>

<p>Make a handle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle(url, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_+3A_url">url</code></td>
<td>
<p>(character) A url. required.</p>
</td></tr>
<tr><td><code id="handle_+3A_...">...</code></td>
<td>
<p>options passed on to <code><a href="curl.html#topic+handle">curl::new_handle()</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>handle("https://hb.opencpu.org")

# handles - pass in your own handle
## Not run: 
h &lt;- handle("https://hb.opencpu.org")
(res &lt;- HttpClient$new(handle = h))
out &lt;- res$get("get")

## End(Not run)
</code></pre>

<hr>
<h2 id='hooks'>Event Hooks</h2><span id='topic+hooks'></span>

<h3>Description</h3>

<p>Trigger functions to run on requests and/or responses.
See Details for more.
</p>


<h3>Details</h3>

<p>Functions passed to <code>request</code> are run <strong>before</strong> the
request occurs. The meaning of triggering a function on the
request is that you can do things to the request object.
</p>
<p>Functions passed to <code>response</code> are run <strong>once</strong> the
request is done, and the response object is created.
The meaning of triggering a function on the
response is to do things on the response object.
</p>
<p>The above for request and response applies the same
whether you make real HTTP requests or mock with
<code>webmockr</code>.
</p>


<h3>Note</h3>

<p>Only supported on <a href="#topic+HttpClient">HttpClient</a> for now
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# hooks on the request
fun_req &lt;- function(request) {
  cat(paste0("Requesting: ", request$url$url), sep = "\n")
}
(x &lt;- HttpClient$new(url = "https://hb.opencpu.org",
  hooks = list(request = fun_req)))
x$hooks
x$hooks$request
r1 &lt;- x$get('get')

captured_req &lt;- list()
fun_req2 &lt;- function(request) {
  cat("Capturing Request", sep = "\n")
  captured_req &lt;&lt;- request
}
(x &lt;- HttpClient$new(url = "https://hb.opencpu.org",
  hooks = list(request = fun_req2)))
x$hooks
x$hooks$request
r1 &lt;- x$get('get')
captured_req



# hooks on the response
fun_resp &lt;- function(response) {
  cat(paste0("status_code: ", response$status_code), sep = "\n")
}
(x &lt;- HttpClient$new(url = "https://hb.opencpu.org",
  hooks = list(response = fun_resp)))
x$url
x$hooks
r1 &lt;- x$get('get')

# both
(x &lt;- HttpClient$new(url = "https://hb.opencpu.org",
  hooks = list(request = fun_req, response = fun_resp)))
x$get("get")

## End(Not run)
</code></pre>

<hr>
<h2 id='http-headers'>Working with HTTP headers</h2><span id='topic+http-headers'></span>

<h3>Description</h3>

<p>Working with HTTP headers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
(x &lt;- HttpClient$new(url = "https://hb.opencpu.org"))

# set headers
(res &lt;- HttpClient$new(
  url = "https://hb.opencpu.org",
  opts = list(
    verbose = TRUE
  ),
  headers = list(
    a = "stuff",
    b = "things"
  )
))
res$headers
# reassign header value
res$headers$a &lt;- "that"
# define new header
res$headers$c &lt;- "what"
# request
res$get('get')

## setting content-type via headers
(res &lt;- HttpClient$new(
  url = "https://hb.opencpu.org",
  opts = list(
    verbose = TRUE
  ),
  headers = list(`Content-Type` = "application/json")
))
res$get('get')

## End(Not run)
</code></pre>

<hr>
<h2 id='HttpClient'>HTTP client</h2><span id='topic+HttpClient'></span>

<h3>Description</h3>

<p>Create and execute HTTP requests
</p>


<h3>Value</h3>

<p>an <a href="#topic+HttpResponse">HttpResponse</a> object
</p>


<h3>R6 classes</h3>

<p>This is an R6 class from the package <span class="pkg">R6</span>. Find out more
about R6 at <a href="https://r6.r-lib.org/">https://r6.r-lib.org/</a>. After creating an instance of an R6
class (e.g., <code>x &lt;- HttpClient$new(url = "https://hb.opencpu.org")</code>) you can
access values and methods on the object <code>x</code>.
</p>


<h3>handles</h3>

<p>curl handles are re-used on the level of the connection object, that is,
each <code>HttpClient</code> object is separate from one another so as to better
separate connections.
</p>
<p>If you don't pass in a curl handle to the <code>handle</code> parameter,
it gets created when a HTTP verb is called. Thus, if you try to get <code>handle</code>
after creating a <code>HttpClient</code> object only passing <code>url</code> parameter, <code>handle</code>
will be <code>NULL</code>. If you pass a curl handle to the <code>handle</code> parameter, then
you can get the handle from the <code>HttpClient</code> object. The response from a
http verb request does have the handle in the <code>handle</code> slot.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>url</code></dt><dd><p>(character) a url</p>
</dd>
<dt><code>opts</code></dt><dd><p>(list) named list of curl options</p>
</dd>
<dt><code>proxies</code></dt><dd><p>a <code><a href="#topic+proxy">proxy()</a></code> object</p>
</dd>
<dt><code>auth</code></dt><dd><p>an <code><a href="#topic+auth">auth()</a></code> object</p>
</dd>
<dt><code>headers</code></dt><dd><p>(list) named list of headers, see <a href="#topic+http-headers">http-headers</a></p>
</dd>
<dt><code>handle</code></dt><dd><p>a <code><a href="#topic+handle">handle()</a></code></p>
</dd>
<dt><code>progress</code></dt><dd><p>only supports <code>httr::progress()</code>, see <a href="#topic+progress">progress</a></p>
</dd>
<dt><code>hooks</code></dt><dd><p>a named list, see <a href="#topic+hooks">hooks</a></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HttpClient-print"><code>HttpClient$print()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-new"><code>HttpClient$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-get"><code>HttpClient$get()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-post"><code>HttpClient$post()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-put"><code>HttpClient$put()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-patch"><code>HttpClient$patch()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-delete"><code>HttpClient$delete()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-head"><code>HttpClient$head()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-verb"><code>HttpClient$verb()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-retry"><code>HttpClient$retry()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-handle_pop"><code>HttpClient$handle_pop()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-url_fetch"><code>HttpClient$url_fetch()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-clone"><code>HttpClient$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-HttpClient-print"></a>



<h4>Method <code>print()</code></h4>

<p>print method for <code>HttpClient</code> objects
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>self</p>
</dd>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HttpClient-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new HttpClient object
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$new(
  url,
  opts,
  proxies,
  auth,
  headers,
  handle,
  progress,
  hooks,
  verbose
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>url</code></dt><dd><p>(character) A url. One of <code>url</code> or <code>handle</code> required.</p>
</dd>
<dt><code>opts</code></dt><dd><p>any curl options</p>
</dd>
<dt><code>proxies</code></dt><dd><p>a <code><a href="#topic+proxy">proxy()</a></code> object</p>
</dd>
<dt><code>auth</code></dt><dd><p>an <code><a href="#topic+auth">auth()</a></code> object</p>
</dd>
<dt><code>headers</code></dt><dd><p>named list of headers, see <a href="#topic+http-headers">http-headers</a></p>
</dd>
<dt><code>handle</code></dt><dd><p>a <code><a href="#topic+handle">handle()</a></code></p>
</dd>
<dt><code>progress</code></dt><dd><p>only supports <code>httr::progress()</code>, see <a href="#topic+progress">progress</a></p>
</dd>
<dt><code>hooks</code></dt><dd><p>a named list, see <a href="#topic+hooks">hooks</a></p>
</dd>
<dt><code>verbose</code></dt><dd><p>a special handler for verbose curl output,
accepts a function only. default is <code>NULL</code>. if used, <code>verbose</code>
and <code>debugfunction</code> curl options are ignored if passed to <code>opts</code>
on <code style="white-space: pre;">&#8288;$new()&#8288;</code> and ignored if <code>...</code> passed to a http method call</p>
</dd>
<dt><code>urls</code></dt><dd><p>(character) one or more URLs</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>HttpClient</code> object
</p>


<hr>
<a id="method-HttpClient-get"></a>



<h4>Method <code>get()</code></h4>

<p>Make a GET request
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$get(path = NULL, query = list(), disk = NULL, stream = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>query terms, as a named list. any numeric values are
passed through <code><a href="base.html#topic+format">format()</a></code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>disk</code></dt><dd><p>a path to write to. if NULL (default), memory used.
See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_disk()</a></code> for help.</p>
</dd>
<dt><code>stream</code></dt><dd><p>an R function to determine how to stream data. if
NULL (default), memory used. See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_stream()</a></code>
for help</p>
</dd>
<dt><code>...</code></dt><dd><p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HttpClient-post"></a>



<h4>Method <code>post()</code></h4>

<p>Make a POST request
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$post(
  path = NULL,
  query = list(),
  body = NULL,
  disk = NULL,
  stream = NULL,
  encode = "multipart",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>query terms, as a named list. any numeric values are
passed through <code><a href="base.html#topic+format">format()</a></code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>body</code></dt><dd><p>body as an R list</p>
</dd>
<dt><code>disk</code></dt><dd><p>a path to write to. if NULL (default), memory used.
See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_disk()</a></code> for help.</p>
</dd>
<dt><code>stream</code></dt><dd><p>an R function to determine how to stream data. if
NULL (default), memory used. See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_stream()</a></code>
for help</p>
</dd>
<dt><code>encode</code></dt><dd><p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>...</code></dt><dd><p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HttpClient-put"></a>



<h4>Method <code>put()</code></h4>

<p>Make a PUT request
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$put(
  path = NULL,
  query = list(),
  body = NULL,
  disk = NULL,
  stream = NULL,
  encode = "multipart",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>query terms, as a named list. any numeric values are
passed through <code><a href="base.html#topic+format">format()</a></code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>body</code></dt><dd><p>body as an R list</p>
</dd>
<dt><code>disk</code></dt><dd><p>a path to write to. if NULL (default), memory used.
See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_disk()</a></code> for help.</p>
</dd>
<dt><code>stream</code></dt><dd><p>an R function to determine how to stream data. if
NULL (default), memory used. See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_stream()</a></code>
for help</p>
</dd>
<dt><code>encode</code></dt><dd><p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>...</code></dt><dd><p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HttpClient-patch"></a>



<h4>Method <code>patch()</code></h4>

<p>Make a PATCH request
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$patch(
  path = NULL,
  query = list(),
  body = NULL,
  disk = NULL,
  stream = NULL,
  encode = "multipart",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>query terms, as a named list. any numeric values are
passed through <code><a href="base.html#topic+format">format()</a></code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>body</code></dt><dd><p>body as an R list</p>
</dd>
<dt><code>disk</code></dt><dd><p>a path to write to. if NULL (default), memory used.
See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_disk()</a></code> for help.</p>
</dd>
<dt><code>stream</code></dt><dd><p>an R function to determine how to stream data. if
NULL (default), memory used. See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_stream()</a></code>
for help</p>
</dd>
<dt><code>encode</code></dt><dd><p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>...</code></dt><dd><p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HttpClient-delete"></a>



<h4>Method <code>delete()</code></h4>

<p>Make a DELETE request
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$delete(
  path = NULL,
  query = list(),
  body = NULL,
  disk = NULL,
  stream = NULL,
  encode = "multipart",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>query terms, as a named list. any numeric values are
passed through <code><a href="base.html#topic+format">format()</a></code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>body</code></dt><dd><p>body as an R list</p>
</dd>
<dt><code>disk</code></dt><dd><p>a path to write to. if NULL (default), memory used.
See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_disk()</a></code> for help.</p>
</dd>
<dt><code>stream</code></dt><dd><p>an R function to determine how to stream data. if
NULL (default), memory used. See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_stream()</a></code>
for help</p>
</dd>
<dt><code>encode</code></dt><dd><p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>...</code></dt><dd><p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HttpClient-head"></a>



<h4>Method <code>head()</code></h4>

<p>Make a HEAD request
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$head(path = NULL, query = list(), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>query terms, as a named list. any numeric values are
passed through <code><a href="base.html#topic+format">format()</a></code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>...</code></dt><dd><p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HttpClient-verb"></a>



<h4>Method <code>verb()</code></h4>

<p>Use an arbitrary HTTP verb supported on this class
Supported verbs: &quot;get&quot;, &quot;post&quot;, &quot;put&quot;, &quot;patch&quot;, &quot;delete&quot;, &quot;head&quot;. Also
supports retry
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$verb(verb, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verb</code></dt><dd><p>an HTTP verb supported on this class: &quot;get&quot;,
&quot;post&quot;, &quot;put&quot;, &quot;patch&quot;, &quot;delete&quot;, &quot;head&quot;. Also supports retry.</p>
</dd>
<dt><code>...</code></dt><dd><p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
(x &lt;- HttpClient$new(url = "https://hb.opencpu.org"))
x$verb('get')
x$verb('GET')
x$verb('GET', query = list(foo = "bar"))
x$verb('retry', 'GET', path = "status/400")
}
</pre>
</div>


<hr>
<a id="method-HttpClient-retry"></a>



<h4>Method <code>retry()</code></h4>

<p>Retry a request
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$retry(
  verb,
  ...,
  pause_base = 1,
  pause_cap = 60,
  pause_min = 1,
  times = 3,
  terminate_on = NULL,
  retry_only_on = NULL,
  onwait = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verb</code></dt><dd><p>an HTTP verb supported on this class: &quot;get&quot;,
&quot;post&quot;, &quot;put&quot;, &quot;patch&quot;, &quot;delete&quot;, &quot;head&quot;. Also supports retry.</p>
</dd>
<dt><code>...</code></dt><dd><p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
<dt><code>pause_base, pause_cap, pause_min</code></dt><dd><p>basis, maximum, and minimum for
calculating wait time for retry. Wait time is calculated according to the
exponential backoff with full jitter algorithm. Specifically, wait time is
chosen randomly between <code>pause_min</code> and the lesser of <code>pause_base * 2</code> and
<code>pause_cap</code>, with <code>pause_base</code> doubling on each subsequent retry attempt.
Use <code>pause_cap = Inf</code> to not terminate retrying due to cap of wait time
reached.</p>
</dd>
<dt><code>times</code></dt><dd><p>the maximum number of times to retry. Set to <code>Inf</code> to
not stop retrying due to exhausting the number of attempts.</p>
</dd>
<dt><code>terminate_on, retry_only_on</code></dt><dd><p>a vector of HTTP status codes. For
<code>terminate_on</code>, the status codes for which to terminate retrying, and for
<code>retry_only_on</code>, the status codes for which to retry the request.</p>
</dd>
<dt><code>onwait</code></dt><dd><p>a callback function if the request will be retried and
a wait time is being applied. The function will be passed two parameters,
the response object from the failed request, and the wait time in seconds.
Note that the time spent in the function effectively adds to the wait time,
so it should be kept simple.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Retries the request given by <code>verb</code> until successful
(HTTP response status &lt; 400), or a condition for giving up is met.
Automatically recognizes <code>Retry-After</code> and <code>X-RateLimit-Reset</code> headers
in the response for rate-limited remote APIs.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
x &lt;- HttpClient$new(url = "https://hb.opencpu.org")

# retry, by default at most 3 times
(res_get &lt;- x$retry("GET", path = "status/400"))

# retry, but not for 404 NOT FOUND
(res_get &lt;- x$retry("GET", path = "status/404", terminate_on = c(404)))

# retry, but only for exceeding rate limit (note that e.g. Github uses 403)
(res_get &lt;- x$retry("GET", path = "status/429", retry_only_on = c(403, 429)))
}
</pre>
</div>


<hr>
<a id="method-HttpClient-handle_pop"></a>



<h4>Method <code>handle_pop()</code></h4>

<p>reset your curl handle
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$handle_pop()</pre></div>


<hr>
<a id="method-HttpClient-url_fetch"></a>



<h4>Method <code>url_fetch()</code></h4>

<p>get the URL that would be sent (i.e., before executing
the request) the only things that change the URL are path and query
parameters; body and any curl options don't change the URL
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$url_fetch(path = NULL, query = list())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>query terms, as a named list. any numeric values are
passed through <code><a href="base.html#topic+format">format()</a></code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>URL (character)
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>x &lt;- HttpClient$new(url = "https://hb.opencpu.org")
x$url_fetch()
x$url_fetch('get')
x$url_fetch('post')
x$url_fetch('get', query = list(foo = "bar"))
</pre>
</div>


<hr>
<a id="method-HttpClient-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Note</h3>

<p>A little quirk about <code>crul</code> is that because user agent string can
be passed as either a header or a curl option (both lead to a <code>User-Agent</code>
header being passed in the HTTP request), we return the user agent
string in the <code>request_headers</code> list of the response even if you
pass in a <code>useragent</code> string as a curl option. Note that whether you pass
in as a header like <code>User-Agent</code> or as a curl option like <code>useragent</code>,
it is returned as <code>request_headers$User-Agent</code> so at least accessing
it in the request headers is consistent.
</p>


<h3>See Also</h3>

<p><a href="#topic+http-headers">http-headers</a>, <a href="#topic+writing-options">writing-options</a>, <a href="#topic+cookies">cookies</a>, <a href="#topic+hooks">hooks</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set your own handle
(h &lt;- handle("https://hb.opencpu.org"))
(x &lt;- HttpClient$new(handle = h))
x$handle
x$url
(out &lt;- x$get("get"))
x$handle
x$url
class(out)
out$handle
out$request_headers
out$response_headers
out$response_headers_all

# if you just pass a url, we create a handle for you
#  this is how most people will use HttpClient
(x &lt;- HttpClient$new(url = "https://hb.opencpu.org"))
x$url
x$handle # is empty, it gets created when a HTTP verb is called
(r1 &lt;- x$get('get'))
x$url
x$handle
r1$url
r1$handle
r1$content
r1$response_headers
r1$parse()

(res_get2 &lt;- x$get('get', query = list(hello = "world")))
res_get2$parse()
library("jsonlite")
jsonlite::fromJSON(res_get2$parse())

# post request
(res_post &lt;- x$post('post', body = list(hello = "world")))

## empty body request
x$post('post')

# put request
(res_put &lt;- x$put('put'))

# delete request
(res_delete &lt;- x$delete('delete'))

# patch request
(res_patch &lt;- x$patch('patch'))

# head request
(res_head &lt;- x$head())

# query params are URL encoded for you, so DO NOT do it yourself
## if you url encode yourself, it gets double encoded, and that's bad
(x &lt;- HttpClient$new(url = "https://hb.opencpu.org"))
res &lt;- x$get("get", query = list(a = 'hello world'))

# access intermediate headers in response_headers_all
x &lt;- HttpClient$new("https://doi.org/10.1007/978-3-642-40455-9_52-1")
bb &lt;- x$get()
bb$response_headers_all

## End(Not run)

## ------------------------------------------------
## Method `HttpClient$verb`
## ------------------------------------------------

## Not run: 
(x &lt;- HttpClient$new(url = "https://hb.opencpu.org"))
x$verb('get')
x$verb('GET')
x$verb('GET', query = list(foo = "bar"))
x$verb('retry', 'GET', path = "status/400")

## End(Not run)

## ------------------------------------------------
## Method `HttpClient$retry`
## ------------------------------------------------

## Not run: 
x &lt;- HttpClient$new(url = "https://hb.opencpu.org")

# retry, by default at most 3 times
(res_get &lt;- x$retry("GET", path = "status/400"))

# retry, but not for 404 NOT FOUND
(res_get &lt;- x$retry("GET", path = "status/404", terminate_on = c(404)))

# retry, but only for exceeding rate limit (note that e.g. Github uses 403)
(res_get &lt;- x$retry("GET", path = "status/429", retry_only_on = c(403, 429)))

## End(Not run)

## ------------------------------------------------
## Method `HttpClient$url_fetch`
## ------------------------------------------------

x &lt;- HttpClient$new(url = "https://hb.opencpu.org")
x$url_fetch()
x$url_fetch('get')
x$url_fetch('post')
x$url_fetch('get', query = list(foo = "bar"))
</code></pre>

<hr>
<h2 id='HttpRequest'>HTTP request object</h2><span id='topic+HttpRequest'></span>

<h3>Description</h3>

<p>Create HTTP requests
</p>


<h3>Details</h3>

<p>This R6 class doesn't do actual HTTP requests as does
<code><a href="#topic+HttpClient">HttpClient()</a></code> - it is for building requests to use for async HTTP
requests in <code><a href="#topic+AsyncVaried">AsyncVaried()</a></code>
</p>
<p>Note that you can access HTTP verbs after creating an <code>HttpRequest</code>
object, just as you can with <code>HttpClient</code>. See examples for usage.
</p>
<p>Also note that when you call HTTP verbs on a <code>HttpRequest</code> object you
don't need to assign the new object to a variable as the new details
you've added are added to the object itself.
</p>
<p>See <code><a href="#topic+HttpClient">HttpClient()</a></code> for information on parameters.
</p>


<h3>R6 classes</h3>

<p>This is an R6 class from the package <span class="pkg">R6</span>. Find out more
about R6 at <a href="https://r6.r-lib.org/">https://r6.r-lib.org/</a>. After creating an instance of an R6
class (e.g., <code>x &lt;- HttpClient$new(url = "https://hb.opencpu.org")</code>) you can
access values and methods on the object <code>x</code>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>url</code></dt><dd><p>(character) a url</p>
</dd>
<dt><code>opts</code></dt><dd><p>(list) named list of curl options</p>
</dd>
<dt><code>proxies</code></dt><dd><p>a <code><a href="#topic+proxy">proxy()</a></code> object</p>
</dd>
<dt><code>auth</code></dt><dd><p>an <code><a href="#topic+auth">auth()</a></code> object</p>
</dd>
<dt><code>headers</code></dt><dd><p>(list) named list of headers, see <a href="#topic+http-headers">http-headers</a></p>
</dd>
<dt><code>handle</code></dt><dd><p>a <code><a href="#topic+handle">handle()</a></code></p>
</dd>
<dt><code>progress</code></dt><dd><p>only supports <code>httr::progress()</code>, see <a href="#topic+progress">progress</a></p>
</dd>
<dt><code>payload</code></dt><dd><p>resulting payload after request</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HttpRequest-print"><code>HttpRequest$print()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpRequest-new"><code>HttpRequest$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpRequest-get"><code>HttpRequest$get()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpRequest-post"><code>HttpRequest$post()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpRequest-put"><code>HttpRequest$put()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpRequest-patch"><code>HttpRequest$patch()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpRequest-delete"><code>HttpRequest$delete()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpRequest-head"><code>HttpRequest$head()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpRequest-verb"><code>HttpRequest$verb()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpRequest-retry"><code>HttpRequest$retry()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpRequest-method"><code>HttpRequest$method()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpRequest-clone"><code>HttpRequest$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-HttpRequest-print"></a>



<h4>Method <code>print()</code></h4>

<p>print method for <code>HttpRequest</code> objects
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpRequest$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>self</p>
</dd>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HttpRequest-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>HttpRequest</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpRequest$new(url, opts, proxies, auth, headers, handle, progress)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>url</code></dt><dd><p>(character) A url. One of <code>url</code> or <code>handle</code> required.</p>
</dd>
<dt><code>opts</code></dt><dd><p>any curl options</p>
</dd>
<dt><code>proxies</code></dt><dd><p>a <code><a href="#topic+proxy">proxy()</a></code> object</p>
</dd>
<dt><code>auth</code></dt><dd><p>an <code><a href="#topic+auth">auth()</a></code> object</p>
</dd>
<dt><code>headers</code></dt><dd><p>named list of headers, see <a href="#topic+http-headers">http-headers</a></p>
</dd>
<dt><code>handle</code></dt><dd><p>a <code><a href="#topic+handle">handle()</a></code></p>
</dd>
<dt><code>progress</code></dt><dd><p>only supports <code>httr::progress()</code>, see <a href="#topic+progress">progress</a></p>
</dd>
<dt><code>urls</code></dt><dd><p>(character) one or more URLs</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>HttpRequest</code> object
</p>


<hr>
<a id="method-HttpRequest-get"></a>



<h4>Method <code>get()</code></h4>

<p>Define a GET request
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpRequest$get(path = NULL, query = list(), disk = NULL, stream = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>query terms, as a named list</p>
</dd>
<dt><code>disk</code></dt><dd><p>a path to write to. if NULL (default), memory used.
See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_disk()</a></code> for help.</p>
</dd>
<dt><code>stream</code></dt><dd><p>an R function to determine how to stream data. if
NULL (default), memory used. See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_stream()</a></code>
for help</p>
</dd>
<dt><code>...</code></dt><dd><p>curl options, only those in the acceptable set from
<code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code> except the following: httpget, httppost, post,
postfields, postfieldsize, and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HttpRequest-post"></a>



<h4>Method <code>post()</code></h4>

<p>Define a POST request
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpRequest$post(
  path = NULL,
  query = list(),
  body = NULL,
  disk = NULL,
  stream = NULL,
  encode = "multipart",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>query terms, as a named list</p>
</dd>
<dt><code>body</code></dt><dd><p>body as an R list</p>
</dd>
<dt><code>disk</code></dt><dd><p>a path to write to. if NULL (default), memory used.
See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_disk()</a></code> for help.</p>
</dd>
<dt><code>stream</code></dt><dd><p>an R function to determine how to stream data. if
NULL (default), memory used. See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_stream()</a></code>
for help</p>
</dd>
<dt><code>encode</code></dt><dd><p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>...</code></dt><dd><p>curl options, only those in the acceptable set from
<code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code> except the following: httpget, httppost, post,
postfields, postfieldsize, and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HttpRequest-put"></a>



<h4>Method <code>put()</code></h4>

<p>Define a PUT request
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpRequest$put(
  path = NULL,
  query = list(),
  body = NULL,
  disk = NULL,
  stream = NULL,
  encode = "multipart",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>query terms, as a named list</p>
</dd>
<dt><code>body</code></dt><dd><p>body as an R list</p>
</dd>
<dt><code>disk</code></dt><dd><p>a path to write to. if NULL (default), memory used.
See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_disk()</a></code> for help.</p>
</dd>
<dt><code>stream</code></dt><dd><p>an R function to determine how to stream data. if
NULL (default), memory used. See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_stream()</a></code>
for help</p>
</dd>
<dt><code>encode</code></dt><dd><p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>...</code></dt><dd><p>curl options, only those in the acceptable set from
<code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code> except the following: httpget, httppost, post,
postfields, postfieldsize, and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HttpRequest-patch"></a>



<h4>Method <code>patch()</code></h4>

<p>Define a PATCH request
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpRequest$patch(
  path = NULL,
  query = list(),
  body = NULL,
  disk = NULL,
  stream = NULL,
  encode = "multipart",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>query terms, as a named list</p>
</dd>
<dt><code>body</code></dt><dd><p>body as an R list</p>
</dd>
<dt><code>disk</code></dt><dd><p>a path to write to. if NULL (default), memory used.
See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_disk()</a></code> for help.</p>
</dd>
<dt><code>stream</code></dt><dd><p>an R function to determine how to stream data. if
NULL (default), memory used. See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_stream()</a></code>
for help</p>
</dd>
<dt><code>encode</code></dt><dd><p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>...</code></dt><dd><p>curl options, only those in the acceptable set from
<code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code> except the following: httpget, httppost, post,
postfields, postfieldsize, and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HttpRequest-delete"></a>



<h4>Method <code>delete()</code></h4>

<p>Define a DELETE request
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpRequest$delete(
  path = NULL,
  query = list(),
  body = NULL,
  disk = NULL,
  stream = NULL,
  encode = "multipart",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>query terms, as a named list</p>
</dd>
<dt><code>body</code></dt><dd><p>body as an R list</p>
</dd>
<dt><code>disk</code></dt><dd><p>a path to write to. if NULL (default), memory used.
See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_disk()</a></code> for help.</p>
</dd>
<dt><code>stream</code></dt><dd><p>an R function to determine how to stream data. if
NULL (default), memory used. See <code><a href="curl.html#topic+curl_fetch">curl::curl_fetch_stream()</a></code>
for help</p>
</dd>
<dt><code>encode</code></dt><dd><p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>...</code></dt><dd><p>curl options, only those in the acceptable set from
<code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code> except the following: httpget, httppost, post,
postfields, postfieldsize, and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HttpRequest-head"></a>



<h4>Method <code>head()</code></h4>

<p>Define a HEAD request
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpRequest$head(path = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>URL path, appended to the base URL</p>
</dd>
<dt><code>...</code></dt><dd><p>curl options, only those in the acceptable set from
<code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code> except the following: httpget, httppost, post,
postfields, postfieldsize, and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HttpRequest-verb"></a>



<h4>Method <code>verb()</code></h4>

<p>Use an arbitrary HTTP verb supported on this class
Supported verbs: get, post, put, patch, delete, head
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpRequest$verb(verb, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verb</code></dt><dd><p>an HTTP verb supported on this class: get,
post, put, patch, delete, head. Also supports retry.</p>
</dd>
<dt><code>...</code></dt><dd><p>curl options, only those in the acceptable set from
<code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code> except the following: httpget, httppost, post,
postfields, postfieldsize, and customrequest</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>z &lt;- HttpRequest$new(url = "https://hb.opencpu.org/get")
res &lt;- z$verb('get', query = list(hello = "world"))
res$payload
</pre>
</div>


<hr>
<a id="method-HttpRequest-retry"></a>



<h4>Method <code>retry()</code></h4>

<p>Define a RETRY request
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpRequest$retry(
  verb,
  ...,
  pause_base = 1,
  pause_cap = 60,
  pause_min = 1,
  times = 3,
  terminate_on = NULL,
  retry_only_on = NULL,
  onwait = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verb</code></dt><dd><p>an HTTP verb supported on this class: get,
post, put, patch, delete, head. Also supports retry.</p>
</dd>
<dt><code>...</code></dt><dd><p>curl options, only those in the acceptable set from
<code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code> except the following: httpget, httppost, post,
postfields, postfieldsize, and customrequest</p>
</dd>
<dt><code>pause_base, pause_cap, pause_min</code></dt><dd><p>basis, maximum, and minimum for
calculating wait time for retry. Wait time is calculated according to the
exponential backoff with full jitter algorithm. Specifically, wait time is
chosen randomly between <code>pause_min</code> and the lesser of <code>pause_base * 2</code> and
<code>pause_cap</code>, with <code>pause_base</code> doubling on each subsequent retry attempt.
Use <code>pause_cap = Inf</code> to not terminate retrying due to cap of wait time
reached.</p>
</dd>
<dt><code>times</code></dt><dd><p>the maximum number of times to retry. Set to <code>Inf</code> to
not stop retrying due to exhausting the number of attempts.</p>
</dd>
<dt><code>terminate_on, retry_only_on</code></dt><dd><p>a vector of HTTP status codes. For
<code>terminate_on</code>, the status codes for which to terminate retrying, and for
<code>retry_only_on</code>, the status codes for which to retry the request.</p>
</dd>
<dt><code>onwait</code></dt><dd><p>a callback function if the request will be retried and
a wait time is being applied. The function will be passed two parameters,
the response object from the failed request, and the wait time in seconds.
Note that the time spent in the function effectively adds to the wait time,
so it should be kept simple.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HttpRequest-method"></a>



<h4>Method <code>method()</code></h4>

<p>Get the HTTP method (if defined)
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpRequest$method()</pre></div>



<h5>Returns</h5>

<p>(character) the HTTP method
</p>


<hr>
<a id="method-HttpRequest-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpRequest$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><a href="#topic+http-headers">http-headers</a>, <a href="#topic+writing-options">writing-options</a>
</p>
<p>Other async: 
<code><a href="#topic+AsyncQueue">AsyncQueue</a></code>,
<code><a href="#topic+AsyncVaried">AsyncVaried</a></code>,
<code><a href="#topic+Async">Async</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- HttpRequest$new(url = "https://hb.opencpu.org/get")
## note here how the HTTP method is shown on the first line to the right
x$get()

## assign to a new object to keep the output
z &lt;- x$get()
### get the HTTP method
z$method()

(x &lt;- HttpRequest$new(url = "https://hb.opencpu.org/get")$get())
x$url
x$payload

(x &lt;- HttpRequest$new(url = "https://hb.opencpu.org/post"))
x$post(body = list(foo = "bar"))

HttpRequest$new(
  url = "https://hb.opencpu.org/get",
  headers = list(
    `Content-Type` = "application/json"
  )
)

# retry
(x &lt;- HttpRequest$new(url = "https://hb.opencpu.org/post"))
x$retry("post", body = list(foo = "bar"))

## End(Not run)

## ------------------------------------------------
## Method `HttpRequest$verb`
## ------------------------------------------------

z &lt;- HttpRequest$new(url = "https://hb.opencpu.org/get")
res &lt;- z$verb('get', query = list(hello = "world"))
res$payload
</code></pre>

<hr>
<h2 id='HttpResponse'>Base HTTP response object</h2><span id='topic+HttpResponse'></span>

<h3>Description</h3>

<p>Class with methods for handling HTTP responses
</p>


<h3>Details</h3>

<p><strong>Additional Methods</strong>
</p>

<dl>
<dt><code>raise_for_ct(type, charset = NULL, behavior = "stop")</code></dt><dd>
<p>Check response content-type; stop or warn if not matched. Parameters:
</p>

<ul>
<li><p> type: (character) a mime type to match against; see
<a href="mime.html#topic+mimemap">mime::mimemap</a> for allowed values
</p>
</li>
<li><p> charset: (character) if a charset string given, we check that
it matches the charset in the content type header. default: NULL
</p>
</li>
<li><p> behavior: (character) one of stop (default) or warning
</p>
</li></ul>

</dd>
<dt><code>raise_for_ct_html(charset = NULL, behavior = "stop")</code></dt><dd>
<p>Check that the response content-type is <code>text/html</code>; stop or warn if
not matched. Parameters: see <code>raise_for_ct()</code>
</p>
</dd>
<dt><code>raise_for_ct_json(charset = NULL, behavior = "stop")</code></dt><dd>
<p>Check that the response content-type is <code>application/json</code>; stop or
warn if not matched. Parameters: see <code>raise_for_ct()</code>
</p>
</dd>
<dt><code>raise_for_ct_xml(charset = NULL, behavior = "stop")</code></dt><dd>
<p>Check that the response content-type is <code>application/xml</code>; stop or warn if
not matched. Parameters: see <code>raise_for_ct()</code>
</p>
</dd>
</dl>



<h3>R6 classes</h3>

<p>This is an R6 class from the package <span class="pkg">R6</span>. Find out more
about R6 at <a href="https://r6.r-lib.org/">https://r6.r-lib.org/</a>. After creating an instance of an R6
class (e.g., <code>x &lt;- HttpClient$new(url = "https://hb.opencpu.org")</code>) you can
access values and methods on the object <code>x</code>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>method</code></dt><dd><p>(character) one or more URLs</p>
</dd>
<dt><code>url</code></dt><dd><p>(character) one or more URLs</p>
</dd>
<dt><code>opts</code></dt><dd><p>(character) one or more URLs</p>
</dd>
<dt><code>handle</code></dt><dd><p>(character) one or more URLs</p>
</dd>
<dt><code>status_code</code></dt><dd><p>(character) one or more URLs</p>
</dd>
<dt><code>request_headers</code></dt><dd><p>(character) one or more URLs</p>
</dd>
<dt><code>response_headers</code></dt><dd><p>(character) one or more URLs</p>
</dd>
<dt><code>response_headers_all</code></dt><dd><p>(character) one or more URLs</p>
</dd>
<dt><code>modified</code></dt><dd><p>(character) one or more URLs</p>
</dd>
<dt><code>times</code></dt><dd><p>(character) one or more URLs</p>
</dd>
<dt><code>content</code></dt><dd><p>(character) one or more URLs</p>
</dd>
<dt><code>request</code></dt><dd><p>(character) one or more URLs</p>
</dd>
<dt><code>raise_for_ct</code></dt><dd><p>for ct method (general)</p>
</dd>
<dt><code>raise_for_ct_html</code></dt><dd><p>for ct method (html)</p>
</dd>
<dt><code>raise_for_ct_json</code></dt><dd><p>for ct method (json)</p>
</dd>
<dt><code>raise_for_ct_xml</code></dt><dd><p>for ct method (xml)</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HttpResponse-print"><code>HttpResponse$print()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpResponse-new"><code>HttpResponse$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpResponse-parse"><code>HttpResponse$parse()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpResponse-success"><code>HttpResponse$success()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpResponse-status_http"><code>HttpResponse$status_http()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpResponse-raise_for_status"><code>HttpResponse$raise_for_status()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpResponse-clone"><code>HttpResponse$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-HttpResponse-print"></a>



<h4>Method <code>print()</code></h4>

<p>print method for HttpResponse objects
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpResponse$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>self</p>
</dd>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HttpResponse-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new HttpResponse object
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpResponse$new(
  method,
  url,
  opts,
  handle,
  status_code,
  request_headers,
  response_headers,
  response_headers_all,
  modified,
  times,
  content,
  request
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>(character) HTTP method</p>
</dd>
<dt><code>url</code></dt><dd><p>(character) A url, required</p>
</dd>
<dt><code>opts</code></dt><dd><p>(list) curl options</p>
</dd>
<dt><code>handle</code></dt><dd><p>A handle</p>
</dd>
<dt><code>status_code</code></dt><dd><p>(integer) status code</p>
</dd>
<dt><code>request_headers</code></dt><dd><p>(list) request headers, named list</p>
</dd>
<dt><code>response_headers</code></dt><dd><p>(list) response headers, named list</p>
</dd>
<dt><code>response_headers_all</code></dt><dd><p>(list) all response headers, including
intermediate redirect headers, unnamed list of named lists</p>
</dd>
<dt><code>modified</code></dt><dd><p>(character) modified date</p>
</dd>
<dt><code>times</code></dt><dd><p>(vector) named vector</p>
</dd>
<dt><code>content</code></dt><dd><p>(raw) raw binary content response</p>
</dd>
<dt><code>request</code></dt><dd><p>request object, with all details</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HttpResponse-parse"></a>



<h4>Method <code>parse()</code></h4>

<p>Parse the raw response content to text
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpResponse$parse(encoding = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>encoding</code></dt><dd><p>(character) A character string describing the
current encoding. If left as <code>NULL</code>, we attempt to guess the
encoding. Passed to <code>from</code> parameter in <code>iconv</code></p>
</dd>
<dt><code>...</code></dt><dd><p>additional parameters passed on to <code>iconv</code> (options: sub,
mark, toRaw). See <code>?iconv</code> for help</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>character string
</p>


<hr>
<a id="method-HttpResponse-success"></a>



<h4>Method <code>success()</code></h4>

<p>Was status code less than or equal to 201
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpResponse$success()</pre></div>



<h5>Returns</h5>

<p>boolean
</p>


<hr>
<a id="method-HttpResponse-status_http"></a>



<h4>Method <code>status_http()</code></h4>

<p>Get HTTP status code, message, and explanation
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpResponse$status_http(verbose = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verbose</code></dt><dd><p>(logical) whether to get verbose http status description,
default: <code>FALSE</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>object of class &quot;http_code&quot;, a list with slots for status_code,
message, and explanation
</p>


<hr>
<a id="method-HttpResponse-raise_for_status"></a>



<h4>Method <code>raise_for_status()</code></h4>

<p>Check HTTP status and stop with appropriate
HTTP error code and message if &gt;= 300. otherwise use <span class="pkg">httpcode</span>.
If you have <code>fauxpas</code> installed we use that.
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpResponse$raise_for_status()</pre></div>



<h5>Returns</h5>

<p>stop or warn with message
</p>


<hr>
<a id="method-HttpResponse-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpResponse$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><a href="#topic+content-types">content-types</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- HttpResponse$new(method = "get", url = "https://hb.opencpu.org")
x$url
x$method

x &lt;- HttpClient$new(url = 'https://hb.opencpu.org')
(res &lt;- x$get('get'))
res$request_headers
res$response_headers
res$parse()
res$status_code
res$status_http()
res$status_http()$status_code
res$status_http()$message
res$status_http()$explanation
res$success()

x &lt;- HttpClient$new(url = 'https://hb.opencpu.org/status/404')
(res &lt;- x$get())
# res$raise_for_status()

x &lt;- HttpClient$new(url = 'https://hb.opencpu.org/status/414')
(res &lt;- x$get())
# res$raise_for_status()

## End(Not run)
</code></pre>

<hr>
<h2 id='mock'>Mocking HTTP requests</h2><span id='topic+mock'></span>

<h3>Description</h3>

<p>Mocking HTTP requests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mock(on = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mock_+3A_on">on</code></td>
<td>
<p>(logical) turn mocking on with <code>TRUE</code> or turn off with <code>FALSE</code>.
By default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>webmockr</code> package required for mocking behavior
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

if (interactive()) {
  # load webmockr
  library(webmockr)
  library(crul)

  URL &lt;- "https://hb.opencpu.org"

  # turn on mocking
  crul::mock()

  # stub a request
  stub_request("get", file.path(URL, "get"))
  webmockr:::webmockr_stub_registry

  # create an HTTP client
  (x &lt;- HttpClient$new(url = URL))

  # make a request - matches stub - no real request made
  x$get('get')

  # allow net connect
  webmockr::webmockr_allow_net_connect()
  x$get('get', query = list(foo = "bar"))
  webmockr::webmockr_disable_net_connect()
  x$get('get', query = list(foo = "bar"))
}


## End(Not run)
</code></pre>

<hr>
<h2 id='ok'>check if a url is okay</h2><span id='topic+ok'></span>

<h3>Description</h3>

<p>check if a url is okay
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ok(x, status = 200L, info = TRUE, verb = "head", ua_random = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ok_+3A_x">x</code></td>
<td>
<p>either a URL as a character string, or an object of
class <a href="#topic+HttpClient">HttpClient</a></p>
</td></tr>
<tr><td><code id="ok_+3A_status">status</code></td>
<td>
<p>(integer) one or more HTTP status codes, must be integers.
default: <code>200L</code>, since this is the most common signal
that a URL is okay, but there may be cases in which your URL
is okay if it's a <code>201L</code>, or some other status code.</p>
</td></tr>
<tr><td><code id="ok_+3A_info">info</code></td>
<td>
<p>(logical) in the case of an error, do you want a
<code>message()</code> about it? Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="ok_+3A_verb">verb</code></td>
<td>
<p>(character) use &quot;head&quot; (default) or &quot;get&quot; HTTP verb
for the request. note that &quot;get&quot; will take longer as it returns a
body. however, &quot;verb=get&quot; may be your only option if a url
blocks head requests</p>
</td></tr>
<tr><td><code id="ok_+3A_ua_random">ua_random</code></td>
<td>
<p>(logical) use a random user agent string?
default: <code>TRUE</code>. if you set <code>useragent</code> curl option it will override
this setting. The random user agent string is pulled from a vector of
50 user agent strings generated from <code>charlatan::UserAgentProvider</code>
(by executing <code>replicate(30, UserAgentProvider$new()$user_agent())</code>)</p>
</td></tr>
<tr><td><code id="ok_+3A_...">...</code></td>
<td>
<p>args passed on to <a href="#topic+HttpClient">HttpClient</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>We internally verify that status is an integer and
in the known set of HTTP status codes, and that info is a boolean
</p>
<p>You may have to fiddle with the parameters to <code>ok()</code> as well as
curl options to get the &quot;right answer&quot;. If you think you are getting
incorrectly getting <code>FALSE</code>, the first thing to do is to pass in
<code>verbose=TRUE</code> to <code>ok()</code>. That will give you verbose curl output and will
help determine what the issue may be. Here's some different scenarios:
</p>

<ul>
<li><p> the site blocks head requests: some sites do this, try <code>verb="get"</code>
</p>
</li>
<li><p> it will be hard to determine a site that requires this, but it's
worth trying a random useragent string, e.g., <code>ok(useragent = "foobar")</code>
</p>
</li>
<li><p> some sites are up and reachable but you could get a 403 Unauthorized
error, there's nothing you can do in this case other than having access
</p>
</li>
<li><p> its possible to get a weird HTTP status code, e.g., LinkedIn gives
a 999 code, they're trying to prevent any programmatic access
</p>
</li></ul>

<p>A <code>FALSE</code> result may be incorrect depending on the use case. For example,
if you want to know if curl based scraping will work without fiddling with
curl options, then the <code>FALSE</code> is probably correct, but if you want to
fiddle with curl options, then first step would be to send <code>verbose=TRUE</code>
to see whats going on with any redirects and headers. You can set headers,
user agent strings, etc. to get closer to the request you want to know
about. Note that a user agent string is always passed by default, but it
may not be the one you want.
</p>


<h3>Value</h3>

<p>a single boolean, if <code>TRUE</code> the URL is up and okay,
if <code>FALSE</code> it is down; but, see Details
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# 200
ok("https://www.google.com") 
# 200
ok("https://hb.opencpu.org/status/200")
# more than one status
ok("https://www.google.com", status = c(200L, 202L))
# 404
ok("https://hb.opencpu.org/status/404")
# doesn't exist
ok("https://stuff.bar")
# doesn't exist
ok("stuff")

# use get verb instead of head
ok("http://animalnexus.ca")
ok("http://animalnexus.ca", verb = "get")

# some urls will require a different useragent string
# they probably regex the useragent string
ok("https://doi.org/10.1093/chemse/bjq042")
ok("https://doi.org/10.1093/chemse/bjq042", verb = "get", useragent = "foobar")

# with random user agent's
## here, use a request hook to print out just the user agent string so 
## we can see what user agent string is being sent off
fun_ua &lt;- function(request) {
  message(paste0("User-agent: ", request$options$useragent), sep = "\n")
}
z &lt;- crul::HttpClient$new("https://doi.org/10.1093/chemse/bjq042", 
 hooks = list(request = fun_ua))
z
replicate(5, ok(z, ua_random=TRUE), simplify=FALSE)
## if you set useragent option it will override ua_random=TRUE
ok("https://doi.org/10.1093/chemse/bjq042", useragent="foobar", ua_random=TRUE)

# with HttpClient
z &lt;- crul::HttpClient$new("https://hb.opencpu.org/status/404", 
 opts = list(verbose = TRUE))
ok(z)

## End(Not run)
</code></pre>

<hr>
<h2 id='Paginator'>Paginator client</h2><span id='topic+Paginator'></span>

<h3>Description</h3>

<p>A client to help you paginate
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+HttpClient">HttpClient()</a></code> for information on parameters
</p>


<h3>Value</h3>

<p>a list, with objects of class <code><a href="#topic+HttpResponse">HttpResponse()</a></code>.
Responses are returned in the order they are passed in.
</p>


<h3>R6 classes</h3>

<p>This is an R6 class from the package <span class="pkg">R6</span>. Find out more
about R6 at <a href="https://r6.r-lib.org/">https://r6.r-lib.org/</a>. After creating an instance of an R6
class (e.g., <code>x &lt;- HttpClient$new(url = "https://hb.opencpu.org")</code>) you can
access values and methods on the object <code>x</code>.
</p>


<h3>Methods to paginate</h3>

<p>Supported now:
</p>

<ul>
<li> <p><code>limit_offset</code>: the most common way (in my experience), so is the default.
This method involves setting how many records and what record to start at
for each request. We send these query parameters for you.
</p>
</li>
<li> <p><code>page_perpage</code>: set the page to fetch and (optionally) how many records
to get per page
</p>
</li></ul>

<p>Supported later, hopefully:
</p>

<ul>
<li> <p><code>link_headers</code>: link headers are URLS for the next/previous/last
request given in the response header from the server. This is relatively
uncommon, though is recommended by JSONAPI and is implemented by a
well known API (GitHub).
</p>
</li>
<li> <p><code>cursor</code>: this works by a single string given back in each response, to
be passed in the subsequent response, and so on until no more records
remain. This is common in Solr
</p>
</li></ul>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>http_req</code></dt><dd><p>an object of class <code>HttpClient</code></p>
</dd>
<dt><code>by</code></dt><dd><p>(character) how to paginate. Only 'limit_offset' supported
for now. In the future will support 'link_headers' and 'cursor'.
See Details.</p>
</dd>
<dt><code>chunk</code></dt><dd><p>(numeric/integer) the number by which to chunk
requests, e.g., 10 would be be each request gets 10 records.
number is passed through <code><a href="base.html#topic+format">format()</a></code> to prevent larger numbers
from being scientifically formatted</p>
</dd>
<dt><code>limit_param</code></dt><dd><p>(character) the name of the limit parameter.
Default: limit</p>
</dd>
<dt><code>offset_param</code></dt><dd><p>(character) the name of the offset parameter.
Default: offset</p>
</dd>
<dt><code>limit</code></dt><dd><p>(numeric/integer) the maximum records wanted.
number is passed through <code><a href="base.html#topic+format">format()</a></code> to prevent larger numbers
from being scientifically formatted</p>
</dd>
<dt><code>page_param</code></dt><dd><p>(character) the name of the page parameter.
Default: NULL</p>
</dd>
<dt><code>per_page_param</code></dt><dd><p>(character) the name of the per page parameter.
Default: NULL</p>
</dd>
<dt><code>progress</code></dt><dd><p>(logical) print a progress bar, using <a href="utils.html#topic+txtProgressBar">utils::txtProgressBar</a>.
Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Paginator-print"><code>Paginator$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-new"><code>Paginator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-get"><code>Paginator$get()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-post"><code>Paginator$post()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-put"><code>Paginator$put()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-patch"><code>Paginator$patch()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-delete"><code>Paginator$delete()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-head"><code>Paginator$head()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-responses"><code>Paginator$responses()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-status_code"><code>Paginator$status_code()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-status"><code>Paginator$status()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-parse"><code>Paginator$parse()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-content"><code>Paginator$content()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-times"><code>Paginator$times()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-url_fetch"><code>Paginator$url_fetch()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-clone"><code>Paginator$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Paginator-print"></a>



<h4>Method <code>print()</code></h4>

<p>print method for <code>Paginator</code> objects
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>self</p>
</dd>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Paginator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Paginator</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$new(
  client,
  by = "limit_offset",
  limit_param = NULL,
  offset_param = NULL,
  limit = NULL,
  chunk = NULL,
  page_param = NULL,
  per_page_param = NULL,
  progress = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>client</code></dt><dd><p>an object of class <code>HttpClient</code>, from a call to <a href="#topic+HttpClient">HttpClient</a></p>
</dd>
<dt><code>by</code></dt><dd><p>(character) how to paginate. Only 'limit_offset' supported for
now. In the future will support 'link_headers' and 'cursor'. See Details.</p>
</dd>
<dt><code>limit_param</code></dt><dd><p>(character) the name of the limit parameter.
Default: limit</p>
</dd>
<dt><code>offset_param</code></dt><dd><p>(character) the name of the offset parameter.
Default: offset</p>
</dd>
<dt><code>limit</code></dt><dd><p>(numeric/integer) the maximum records wanted</p>
</dd>
<dt><code>chunk</code></dt><dd><p>(numeric/integer) the number by which to chunk requests,
e.g., 10 would be be each request gets 10 records</p>
</dd>
<dt><code>page_param</code></dt><dd><p>(character) the name of the page parameter.</p>
</dd>
<dt><code>per_page_param</code></dt><dd><p>(character) the name of the per page parameter.</p>
</dd>
<dt><code>progress</code></dt><dd><p>(logical) print a progress bar, using <a href="utils.html#topic+txtProgressBar">utils::txtProgressBar</a>.
Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Paginator</code> object
</p>


<hr>
<a id="method-Paginator-get"></a>



<h4>Method <code>get()</code></h4>

<p>make a paginated GET request
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$get(path = NULL, query = list(), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>query terms, as a named list. any numeric values are
passed through <code><a href="base.html#topic+format">format()</a></code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>...</code></dt><dd><p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Paginator-post"></a>



<h4>Method <code>post()</code></h4>

<p>make a paginated POST request
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$post(
  path = NULL,
  query = list(),
  body = NULL,
  encode = "multipart",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>query terms, as a named list. any numeric values are
passed through <code><a href="base.html#topic+format">format()</a></code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>body</code></dt><dd><p>body as an R list</p>
</dd>
<dt><code>encode</code></dt><dd><p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>...</code></dt><dd><p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Paginator-put"></a>



<h4>Method <code>put()</code></h4>

<p>make a paginated PUT request
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$put(
  path = NULL,
  query = list(),
  body = NULL,
  encode = "multipart",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>query terms, as a named list. any numeric values are
passed through <code><a href="base.html#topic+format">format()</a></code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>body</code></dt><dd><p>body as an R list</p>
</dd>
<dt><code>encode</code></dt><dd><p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>...</code></dt><dd><p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Paginator-patch"></a>



<h4>Method <code>patch()</code></h4>

<p>make a paginated PATCH request
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$patch(
  path = NULL,
  query = list(),
  body = NULL,
  encode = "multipart",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>query terms, as a named list. any numeric values are
passed through <code><a href="base.html#topic+format">format()</a></code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>body</code></dt><dd><p>body as an R list</p>
</dd>
<dt><code>encode</code></dt><dd><p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>...</code></dt><dd><p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Paginator-delete"></a>



<h4>Method <code>delete()</code></h4>

<p>make a paginated DELETE request
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$delete(
  path = NULL,
  query = list(),
  body = NULL,
  encode = "multipart",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>query terms, as a named list. any numeric values are
passed through <code><a href="base.html#topic+format">format()</a></code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>body</code></dt><dd><p>body as an R list</p>
</dd>
<dt><code>encode</code></dt><dd><p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>...</code></dt><dd><p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Paginator-head"></a>



<h4>Method <code>head()</code></h4>

<p>make a paginated HEAD request
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$head(path = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>URL path, appended to the base URL</p>
</dd>
<dt><code>...</code></dt><dd><p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>not sure if this makes any sense or not yet
</p>


<hr>
<a id="method-Paginator-responses"></a>



<h4>Method <code>responses()</code></h4>

<p>list responses
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$responses()</pre></div>



<h5>Returns</h5>

<p>a list of <code>HttpResponse</code> objects, empty list before requests made
</p>


<hr>
<a id="method-Paginator-status_code"></a>



<h4>Method <code>status_code()</code></h4>

<p>Get HTTP status codes for each response
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$status_code()</pre></div>



<h5>Returns</h5>

<p>numeric vector, empty numeric vector before requests made
</p>


<hr>
<a id="method-Paginator-status"></a>



<h4>Method <code>status()</code></h4>

<p>List HTTP status objects
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$status()</pre></div>



<h5>Returns</h5>

<p>a list of <code>http_code</code> objects, empty list before requests made
</p>


<hr>
<a id="method-Paginator-parse"></a>



<h4>Method <code>parse()</code></h4>

<p>parse content
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$parse(encoding = "UTF-8")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>encoding</code></dt><dd><p>(character) the encoding to use in parsing.
default:&quot;UTF-8&quot;</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>character vector, empty character vector before
requests made
</p>


<hr>
<a id="method-Paginator-content"></a>



<h4>Method <code>content()</code></h4>

<p>Get raw content for each response
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$content()</pre></div>



<h5>Returns</h5>

<p>raw list, empty list before requests made
</p>


<hr>
<a id="method-Paginator-times"></a>



<h4>Method <code>times()</code></h4>

<p>curl request times
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$times()</pre></div>



<h5>Returns</h5>

<p>list of named numeric vectors, empty list before requests made
</p>


<hr>
<a id="method-Paginator-url_fetch"></a>



<h4>Method <code>url_fetch()</code></h4>

<p>get the URL that would be sent (i.e., before executing
the request) the only things that change the URL are path and query
parameters; body and any curl options don't change the URL
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$url_fetch(path = NULL, query = list())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt><dd><p>query terms, as a named list. any numeric values are
passed through <code><a href="base.html#topic+format">format()</a></code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>URLs (character)
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
cli &lt;- HttpClient$new(url = "https://api.crossref.org")
cc &lt;- Paginator$new(client = cli, limit_param = "rows",
   offset_param = "offset", limit = 50, chunk = 10)
cc$url_fetch('works')
cc$url_fetch('works', query = list(query = "NSF"))
}
</pre>
</div>


<hr>
<a id="method-Paginator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (interactive()) {
# limit/offset approach
con &lt;- HttpClient$new(url = "https://api.crossref.org")
cc &lt;- Paginator$new(client = con, limit_param = "rows",
   offset_param = "offset", limit = 50, chunk = 10)
cc
cc$get('works')
cc
cc$responses()
cc$status()
cc$status_code()
cc$times()
# cc$content()
cc$parse()
lapply(cc$parse(), jsonlite::fromJSON)

# page/per page approach (with no per_page param allowed)
conn &lt;- HttpClient$new(url = "https://discuss.ropensci.org")
cc &lt;- Paginator$new(client = conn, by = "page_perpage",
 page_param = "page", per_page_param = "per_page", limit = 90, chunk = 30)
cc
cc$get('c/usecases/l/latest.json')
cc$responses()
lapply(cc$parse(), jsonlite::fromJSON)

# page/per_page
conn &lt;- HttpClient$new('https://api.inaturalist.org')
cc &lt;- Paginator$new(conn, by = "page_perpage", page_param = "page",
 per_page_param = "per_page", limit = 90, chunk = 30)
cc
cc$get('v1/observations', query = list(taxon_name="Helianthus"))
cc$responses()
res &lt;- lapply(cc$parse(), jsonlite::fromJSON)
res[[1]]$total_results
vapply(res, "[[", 1L, "page")
vapply(res, "[[", 1L, "per_page")
vapply(res, function(w) NROW(w$results), 1L)
## another
ccc &lt;- Paginator$new(conn, by = "page_perpage", page_param = "page",
 per_page_param = "per_page", limit = 500, chunk = 30, progress = TRUE)
ccc
ccc$get('v1/observations', query = list(taxon_name="Helianthus"))
res2 &lt;- lapply(ccc$parse(), jsonlite::fromJSON)
vapply(res2, function(w) NROW(w$results), 1L)

# progress bar
(con &lt;- HttpClient$new(url = "https://api.crossref.org"))
cc &lt;- Paginator$new(client = con, limit_param = "rows",
   offset_param = "offset", limit = 50, chunk = 10,
   progress = TRUE)
cc
cc$get('works')
}
## End(Not run)

## ------------------------------------------------
## Method `Paginator$url_fetch`
## ------------------------------------------------

## Not run: 
cli &lt;- HttpClient$new(url = "https://api.crossref.org")
cc &lt;- Paginator$new(client = cli, limit_param = "rows",
   offset_param = "offset", limit = 50, chunk = 10)
cc$url_fetch('works')
cc$url_fetch('works', query = list(query = "NSF"))

## End(Not run)
</code></pre>

<hr>
<h2 id='progress'>progress bars</h2><span id='topic+progress'></span>

<h3>Description</h3>

<p>progress bars
</p>


<h3>Details</h3>

<p>pass <code>httr::progress()</code> to <code>progress</code> param in <a href="#topic+HttpClient">HttpClient</a>,
which pulls out relevant info to pass down to <span class="pkg">curl</span>
</p>
<p>if file sizes known you get progress bar; if file sizes not
known you get bytes downloaded
</p>
<p>See the README for examples
</p>

<hr>
<h2 id='proxies'>proxy options</h2><span id='topic+proxies'></span><span id='topic+proxy'></span>

<h3>Description</h3>

<p>proxy options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proxy(url, user = NULL, pwd = NULL, auth = "basic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proxies_+3A_url">url</code></td>
<td>
<p>(character) URL, with scheme (http/https), domain and
port (must be numeric). required.</p>
</td></tr>
<tr><td><code id="proxies_+3A_user">user</code></td>
<td>
<p>(character) username, optional</p>
</td></tr>
<tr><td><code id="proxies_+3A_pwd">pwd</code></td>
<td>
<p>(character) password, optional</p>
</td></tr>
<tr><td><code id="proxies_+3A_auth">auth</code></td>
<td>
<p>(character) authentication type, one of basic (default),
digest, digest_ie, gssnegotiate, ntlm, any or <code>NULL</code>. optional</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See https://www.hidemyass.com/proxy for a list of proxies you
can use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>proxy("http://97.77.104.22:3128")
proxy("97.77.104.22:3128")
proxy("http://97.77.104.22:3128", "foo", "bar")
proxy("http://97.77.104.22:3128", "foo", "bar", auth = "digest")
proxy("http://97.77.104.22:3128", "foo", "bar", auth = "ntlm")

# socks
proxy("socks5://localhost:9050/", auth = NULL)

## Not run: 
# with proxy (look at request/outgoing headers)
# (res &lt;- HttpClient$new(
#   url = "http://www.google.com",
#   proxies = proxy("http://97.77.104.22:3128")
# ))
# res$proxies
# res$get(verbose = TRUE)

# vs. without proxy (look at request/outgoing headers)
# (res2 &lt;- HttpClient$new(url = "http://www.google.com"))
# res2$get(verbose = TRUE)


# Use authentication
# (res &lt;- HttpClient$new(
#   url = "http://google.com",
#   proxies = proxy("http://97.77.104.22:3128", user = "foo", pwd = "bar")
# ))

# another example
# (res &lt;- HttpClient$new(
#   url = "http://ip.tyk.nu/",
#   proxies = proxy("http://200.29.191.149:3128")
# ))
# res$get()$parse("UTF-8")

## End(Not run)
</code></pre>

<hr>
<h2 id='upload'>upload file</h2><span id='topic+upload'></span>

<h3>Description</h3>

<p>upload file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upload(path, type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upload_+3A_path">path</code></td>
<td>
<p>(character) a single path, file must exist</p>
</td></tr>
<tr><td><code id="upload_+3A_type">type</code></td>
<td>
<p>(character) a file type, guessed by <a href="mime.html#topic+guess_type">mime::guess_type</a> if
not given</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# image
path &lt;- file.path(Sys.getenv("R_DOC_DIR"), "html/logo.jpg")
(x &lt;- HttpClient$new(url = "https://hb.opencpu.org"))
res &lt;- x$post(path = "post", body = list(y = upload(path)))
res$content

# text file, in a list
file &lt;- upload(system.file("CITATION"))
res &lt;- x$post(path = "post", body = list(y = file))
jsonlite::fromJSON(res$parse("UTF-8"))

# text file, as data
res &lt;- x$post(path = "post", body = file)
jsonlite::fromJSON(res$parse("UTF-8"))

## End(Not run)
</code></pre>

<hr>
<h2 id='url_build'>Build and parse URLs</h2><span id='topic+url_build'></span><span id='topic+url_parse'></span>

<h3>Description</h3>

<p>Build and parse URLs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>url_build(url, path = NULL, query = NULL)

url_parse(url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="url_build_+3A_url">url</code></td>
<td>
<p>(character) a url, length 1</p>
</td></tr>
<tr><td><code id="url_build_+3A_path">path</code></td>
<td>
<p>(character) a path, length 1</p>
</td></tr>
<tr><td><code id="url_build_+3A_query">query</code></td>
<td>
<p>(list) a named list of query parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>url_build</code> returns a character string URL; <code>url_parse</code>
returns a list with URL components
</p>


<h3>Examples</h3>

<pre><code class='language-R'>url_build("https://hb.opencpu.org")
url_build("https://hb.opencpu.org", "get")
url_build("https://hb.opencpu.org", "post")
url_build("https://hb.opencpu.org", "get", list(foo = "bar"))

url_parse("hb.opencpu.org")
url_parse("https://hb.opencpu.org")
url_parse(url = "https://hb.opencpu.org")
url_parse("https://hb.opencpu.org/get")
url_parse("https://hb.opencpu.org/get?foo=bar")
url_parse("https://hb.opencpu.org/get?foo=bar&amp;stuff=things")
url_parse("https://hb.opencpu.org/get?foo=bar&amp;stuff=things[]")
</code></pre>

<hr>
<h2 id='verb-DELETE'>HTTP verb info: DELETE</h2><span id='topic+verb-DELETE'></span>

<h3>Description</h3>

<p>The DELETE method deletes the specified resource.
</p>


<h3>The DELETE method</h3>

<p>The DELETE method requests that the origin server remove the
association between the target resource and its current
functionality.  In effect, this method is similar to the rm command
in UNIX: it expresses a deletion operation on the URI mapping of the
origin server rather than an expectation that the previously
associated information be deleted.
</p>


<h3>References</h3>

<p><a href="https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.5">https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.5</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+crul-package">crul-package</a>
</p>
<p>Other verbs: 
<code><a href="#topic+verb-GET">verb-GET</a></code>,
<code><a href="#topic+verb-HEAD">verb-HEAD</a></code>,
<code><a href="#topic+verb-PATCH">verb-PATCH</a></code>,
<code><a href="#topic+verb-POST">verb-POST</a></code>,
<code><a href="#topic+verb-PUT">verb-PUT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- HttpClient$new(url = "https://hb.opencpu.org")
x$delete(path = 'delete')

## a list
(res1 &lt;- x$delete('delete', body = list(hello = "world"), verbose = TRUE))
jsonlite::fromJSON(res1$parse("UTF-8"))

## a string
(res2 &lt;- x$delete('delete', body = "hello world", verbose = TRUE))
jsonlite::fromJSON(res2$parse("UTF-8"))

## empty body request
x$delete('delete', verbose = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='verb-GET'>HTTP verb info: GET</h2><span id='topic+verb-GET'></span>

<h3>Description</h3>

<p>The GET method requests a representation of the specified resource.
Requests using GET should only retrieve data.
</p>


<h3>The GET method</h3>

<p>The GET method requests transfer of a current selected
representation for the target resource.  GET is the primary
mechanism of information retrieval and the focus of almost all
performance optimizations. Hence, when people speak of retrieving
some identifiable information via HTTP, they are generally referring
to making a GET request.
</p>
<p>It is tempting to think of resource identifiers as remote file system
pathnames and of representations as being a copy of the contents of
such files.  In fact, that is how many resources are implemented (see
Section 9.1 (<a href="https://datatracker.ietf.org/doc/html/rfc7231#section-9.1">https://datatracker.ietf.org/doc/html/rfc7231#section-9.1</a>)
for related security considerations).  However, there are
no such limitations in practice.  The HTTP interface for a resource
is just as likely to be implemented as a tree of content objects, a
programmatic view on various database records, or a gateway to other
information systems.  Even when the URI mapping mechanism is tied to
a file system, an origin server might be configured to execute the
files with the request as input and send the output as the
representation rather than transfer the files directly.  Regardless,
only the origin server needs to know how each of its resource identifiers
corresponds to an implementation and how each implementation manages
to select and send a current representation of the target resource
in a response to GET.
</p>
<p>A client can alter the semantics of GET to be a &quot;range request&quot;,
requesting transfer of only some part(s) of the selected
representation, by sending a Range header field in the request
(RFC7233: <a href="https://datatracker.ietf.org/doc/html/rfc7233">https://datatracker.ietf.org/doc/html/rfc7233</a>).
</p>
<p>A payload within a GET request message has no defined semantics;
sending a payload body on a GET request might cause some existing
implementations to reject the request.
</p>
<p>The response to a GET request is cacheable; a cache MAY use it to
satisfy subsequent GET and HEAD requests unless otherwise indicated
by the Cache-Control header field (Section 5.2 of RFC7234:
<a href="https://datatracker.ietf.org/doc/html/rfc7234#section-5.2">https://datatracker.ietf.org/doc/html/rfc7234#section-5.2</a>).
</p>


<h3>References</h3>

<p><a href="https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.1">https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.1</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+crul-package">crul-package</a>
</p>
<p>Other verbs: 
<code><a href="#topic+verb-DELETE">verb-DELETE</a></code>,
<code><a href="#topic+verb-HEAD">verb-HEAD</a></code>,
<code><a href="#topic+verb-PATCH">verb-PATCH</a></code>,
<code><a href="#topic+verb-POST">verb-POST</a></code>,
<code><a href="#topic+verb-PUT">verb-PUT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- HttpClient$new(url = "https://hb.opencpu.org")
x$get(path = 'get')

## End(Not run)

</code></pre>

<hr>
<h2 id='verb-HEAD'>HTTP verb info: HEAD</h2><span id='topic+verb-HEAD'></span>

<h3>Description</h3>

<p>The HEAD method asks for a response identical to that of a GET request,
but without the response body.
</p>


<h3>The HEAD method</h3>

<p>The HEAD method is identical to GET except that the
server MUST NOT send a message body in the response (i.e., the
response terminates at the end of the header section).  The server
SHOULD send the same header fields in response to a HEAD request as
it would have sent if the request had been a GET, except that the
payload header fields MAY be omitted.  This method can
be used for obtaining metadata about the selected representation
without transferring the representation data and is often used for
testing hypertext links for validity, accessibility, and recent
modification.
</p>


<h3>References</h3>

<p><a href="https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.2">https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.2</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+crul-package">crul-package</a>
</p>
<p>Other verbs: 
<code><a href="#topic+verb-DELETE">verb-DELETE</a></code>,
<code><a href="#topic+verb-GET">verb-GET</a></code>,
<code><a href="#topic+verb-PATCH">verb-PATCH</a></code>,
<code><a href="#topic+verb-POST">verb-POST</a></code>,
<code><a href="#topic+verb-PUT">verb-PUT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- HttpClient$new(url = "https://hb.opencpu.org")
x$head()

## End(Not run)

</code></pre>

<hr>
<h2 id='verb-PATCH'>HTTP verb info: PATCH</h2><span id='topic+verb-PATCH'></span>

<h3>Description</h3>

<p>The PATCH method is used to apply partial modifications to a resource.
</p>


<h3>The PATCH method</h3>

<p>The PATCH method requests that a set of changes described in the
request entity be applied to the resource identified by the Request-
URI.  The set of changes is represented in a format called a &quot;patch
document&quot; identified by a media type.  If the Request-URI does not
point to an existing resource, the server MAY create a new resource,
depending on the patch document type (whether it can logically modify
a null resource) and permissions, etc.
</p>


<h3>References</h3>

<p><a href="https://datatracker.ietf.org/doc/html/rfc5789">https://datatracker.ietf.org/doc/html/rfc5789</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+crul-package">crul-package</a>
</p>
<p>Other verbs: 
<code><a href="#topic+verb-DELETE">verb-DELETE</a></code>,
<code><a href="#topic+verb-GET">verb-GET</a></code>,
<code><a href="#topic+verb-HEAD">verb-HEAD</a></code>,
<code><a href="#topic+verb-POST">verb-POST</a></code>,
<code><a href="#topic+verb-PUT">verb-PUT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- HttpClient$new(url = "https://hb.opencpu.org")
x$patch(path = 'patch', body = list(hello = "mars"))

## End(Not run)

</code></pre>

<hr>
<h2 id='verb-POST'>HTTP verb info: POST</h2><span id='topic+verb-POST'></span>

<h3>Description</h3>

<p>The POST method is used to submit an entity to the specified resource,
often causing a change in state or side effects on the server.
</p>


<h3>The POST method</h3>

<p>If one or more resources has been created on the origin server as a
result of successfully processing a POST request, the origin server
SHOULD send a 201 (Created) response containing a Location header
field that provides an identifier for the primary resource created
(Section 7.1.2 <a href="https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.2">https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.2</a>)
and a representation that describes the status of the
request while referring to the new resource(s).
</p>


<h3>References</h3>

<p><a href="https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.3">https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.3</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+crul-package">crul-package</a>
</p>
<p>Other verbs: 
<code><a href="#topic+verb-DELETE">verb-DELETE</a></code>,
<code><a href="#topic+verb-GET">verb-GET</a></code>,
<code><a href="#topic+verb-HEAD">verb-HEAD</a></code>,
<code><a href="#topic+verb-PATCH">verb-PATCH</a></code>,
<code><a href="#topic+verb-PUT">verb-PUT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- HttpClient$new(url = "https://hb.opencpu.org")

# a named list
x$post(path='post', body = list(hello = "world"))

# a string
x$post(path='post', body = "hello world")

# an empty body request
x$post(path='post')

# encode="form"
res &lt;- x$post(path="post",
  encode = "form",
  body = list(
    custname = 'Jane',
    custtel = '444-4444',
    size = 'small',
    topping = 'bacon',
    comments = 'make it snappy'
  )
)
jsonlite::fromJSON(res$parse("UTF-8"))

# encode="json"
res &lt;- x$post("post",
  encode = "json",
  body = list(
    genus = 'Gagea',
    species = 'pratensis'
  )
)
jsonlite::fromJSON(res$parse())

## End(Not run)

</code></pre>

<hr>
<h2 id='verb-PUT'>HTTP verb info: PUT</h2><span id='topic+verb-PUT'></span>

<h3>Description</h3>

<p>The PUT method replaces all current representations of the target
resource with the request payload.
</p>


<h3>The PUT method</h3>

<p>The PUT method requests that the state of the target resource be
created or replaced with the state defined by the representation
enclosed in the request message payload.  A successful PUT of a given
representation would suggest that a subsequent GET on that same
target resource will result in an equivalent representation being
sent in a 200 (OK) response. However, there is no guarantee that
such a state change will be observable, since the target resource
might be acted upon by other user agents in parallel, or might be
subject to dynamic processing by the origin server, before any
subsequent GET is received.  A successful response only implies that
the user agent's intent was achieved at the time of its processing by
the origin server.
</p>
<p>If the target resource does not have a current representation and the
PUT successfully creates one, then the origin server MUST inform the
user agent by sending a 201 (Created) response.  If the target
resource does have a current representation and that representation
is successfully modified in accordance with the state of the enclosed
representation, then the origin server MUST send either a 200 (OK) or
a 204 (No Content) response to indicate successful completion of the
request.
</p>


<h3>References</h3>

<p><a href="https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.4">https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.4</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+crul-package">crul-package</a>
</p>
<p>Other verbs: 
<code><a href="#topic+verb-DELETE">verb-DELETE</a></code>,
<code><a href="#topic+verb-GET">verb-GET</a></code>,
<code><a href="#topic+verb-HEAD">verb-HEAD</a></code>,
<code><a href="#topic+verb-PATCH">verb-PATCH</a></code>,
<code><a href="#topic+verb-POST">verb-POST</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- HttpClient$new(url = "https://hb.opencpu.org")
x$put(path = 'put', body = list(foo = "bar"))

## End(Not run)

</code></pre>

<hr>
<h2 id='writing-options'>Writing data options</h2><span id='topic+writing-options'></span>

<h3>Description</h3>

<p>Writing data options
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# write to disk
(x &lt;- HttpClient$new(url = "https://hb.opencpu.org"))
f &lt;- tempfile()
res &lt;- x$get("get", disk = f)
res$content # when using write to disk, content is a path
readLines(res$content)
close(file(f))

# streaming response
(x &lt;- HttpClient$new(url = "https://hb.opencpu.org"))
res &lt;- x$get('stream/50', stream = function(x) cat(rawToChar(x)))
res$content # when streaming, content is NULL


## Async
(cc &lt;- Async$new(
  urls = c(
    'https://hb.opencpu.org/get?a=5',
    'https://hb.opencpu.org/get?foo=bar',
    'https://hb.opencpu.org/get?b=4',
    'https://hb.opencpu.org/get?stuff=things',
    'https://hb.opencpu.org/get?b=4&amp;g=7&amp;u=9&amp;z=1'
  )
))
files &lt;- replicate(5, tempfile())
(res &lt;- cc$get(disk = files, verbose = TRUE))
lapply(files, readLines)

## Async varied
### disk
f &lt;- tempfile()
g &lt;- tempfile()
req1 &lt;- HttpRequest$new(url = "https://hb.opencpu.org/get")$get(disk = f)
req2 &lt;- HttpRequest$new(url = "https://hb.opencpu.org/post")$post(disk = g)
req3 &lt;- HttpRequest$new(url = "https://hb.opencpu.org/get")$get()
(out &lt;- AsyncVaried$new(req1, req2, req3))
out$request()
out$content()
readLines(f)
readLines(g)
out$parse()
close(file(f))
close(file(g))

### stream - to console
fun &lt;- function(x) print(x)
req1 &lt;- HttpRequest$new(url = "https://hb.opencpu.org/get"
)$get(query = list(foo = "bar"), stream = fun)
req2 &lt;- HttpRequest$new(url = "https://hb.opencpu.org/get"
)$get(query = list(hello = "world"), stream = fun)
(out &lt;- AsyncVaried$new(req1, req2))
out$request()
out$content()

### stream - to an R object
lst &lt;- list()
fun &lt;- function(x) lst &lt;&lt;- append(lst, list(x))
req1 &lt;- HttpRequest$new(url = "https://hb.opencpu.org/get"
)$get(query = list(foo = "bar"), stream = fun)
req2 &lt;- HttpRequest$new(url = "https://hb.opencpu.org/get"
)$get(query = list(hello = "world"), stream = fun)
(out &lt;- AsyncVaried$new(req1, req2))
out$request()
lst
cat(vapply(lst, function(z) rawToChar(z$content), ""), sep = "\n")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
