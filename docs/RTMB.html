<!DOCTYPE html><html><head><title>Help for package RTMB</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RTMB}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%~%'><p>Distributional assignment operator</p></a></li>
<li><a href='#ADapply'><p>AD apply functions</p></a></li>
<li><a href='#ADcomplex'><p>AD complex numbers</p></a></li>
<li><a href='#ADconstruct'><p>AD aware numeric constructors</p></a></li>
<li><a href='#ADmatrix'><p>AD matrix methods (sparse and dense)</p></a></li>
<li><a href='#ADoverload'><p>Enable extra RTMB convenience methods</p></a></li>
<li><a href='#ADvector'><p>The AD vector and its methods</p></a></li>
<li><a href='#Distributions'><p>Distributions and special functions for which AD is implemented</p></a></li>
<li><a href='#expAv'><p>Matrix exponential of sparse matrix multiplied by a vector.</p></a></li>
<li><a href='#Interpolation'><p>Interpolation</p></a></li>
<li><a href='#MVgauss'><p>Multivariate Gaussian densities</p></a></li>
<li><a href='#OSA-residuals'><p>Recursive quantile residuals</p></a></li>
<li><a href='#RTMB-package'><p>RTMB: R bindings for 'TMB'</p></a></li>
<li><a href='#Simulation'><p>Simulation</p></a></li>
<li><a href='#Tape'><p>The AD tape</p></a></li>
<li><a href='#TMB-interface'><p>Interface to TMB</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'R' Bindings for 'TMB'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-01</td>
</tr>
<tr>
<td>Author:</td>
<td>Kasper Kristensen <a href="https://orcid.org/0000-0003-3425-3762"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kasper Kristensen &lt;kaskr@dtu.dk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Native 'R' interface to 'TMB' (Template Model Builder) so models can be written entirely in 'R' rather than 'C++'. Automatic differentiation, to any order, is available for a rich subset of 'R' features, including linear algebra for dense and sparse matrices, complex arithmetic, Fast Fourier Transform, probability distributions and special functions. 'RTMB' provides easy access to model fitting and validation following the principles of Kristensen, K., Nielsen, A., Berg, C. W., Skaug, H., &amp; Bell, B. M. (2016) &lt;<a href="https://doi.org/10.18637%2Fjss.v070.i05">doi:10.18637/jss.v070.i05</a>&gt; and Thygesen, U.H., Albertsen, C.M., Berg, C.W. et al. (2017) &lt;<a href="https://doi.org/10.1007%2Fs10651-017-0372-4">doi:10.1007/s10651-017-0372-4</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.9), Matrix, methods, TMB (&ge; 1.9.7), MASS</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, TMB, RcppEigen</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, igraph, tinytest</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kaskr/RTMB">https://github.com/kaskr/RTMB</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kaskr/RTMB/issues">https://github.com/kaskr/RTMB/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-01 09:59:11 UTC; kaskr</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-01 11:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25~+25'>Distributional assignment operator</h2><span id='topic++25~+25'></span>

<h3>Description</h3>

<p>Distributional assignment operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %~% distr
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25~+2B25_+3A_x">x</code></td>
<td>
<p>LHS; Random effect or data for which distribution assignment applies</p>
</td></tr>
<tr><td><code id="+2B25~+2B25_+3A_distr">distr</code></td>
<td>
<p>RHS; Distribution expression</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provides a slightly simplified syntax <em>inspired by</em>, but <em>not</em> compatible with, other probabilistic programming languages (e.g. BUGS/JAGS):
</p>

<ul>
<li> <p><code>x %~% distribution(...)</code> is syntactic sugar for <code>.nll &lt;- .nll - sum(distribution(x,...,log=TRUE))</code>
</p>
</li>
<li><p> The variable <code>.nll</code> is automatically initialized to <code>0</code> and returned on exit.
</p>
</li></ul>



<h3>Value</h3>

<p>The updated value of the hidden variable <code>.nll</code>.
</p>


<h3>Note</h3>

<p>If the shorter name <code>~</code> is preferred, it can be locally overloaded using <code>"~" &lt;- RTMB::"%~%"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(parms) {
  getAll(parms)
  x %~% dnorm(mu, 1)
  y %~% dpois(exp(x))
}
p &lt;- list(mu=0, x=numeric(10))
y &lt;- 1:10
obj &lt;- MakeADFun(f, p, random="x")
</code></pre>

<hr>
<h2 id='ADapply'>AD apply functions</h2><span id='topic+ADapply'></span><span id='topic+apply+2Cadvector-method'></span><span id='topic+sapply+2Cadvector-method'></span>

<h3>Description</h3>

<p>These <strong>base</strong> apply methods have been modified to keep the AD class attribute (which would otherwise be lost).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'advector'
apply(X, MARGIN, FUN, ..., simplify = TRUE)

## S4 method for signature 'advector'
sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ADapply_+3A_x">X</code></td>
<td>
<p>As <a href="base.html#topic+apply">apply</a></p>
</td></tr>
<tr><td><code id="ADapply_+3A_margin">MARGIN</code></td>
<td>
<p>As <a href="base.html#topic+apply">apply</a></p>
</td></tr>
<tr><td><code id="ADapply_+3A_fun">FUN</code></td>
<td>
<p>As <a href="base.html#topic+apply">apply</a></p>
</td></tr>
<tr><td><code id="ADapply_+3A_...">...</code></td>
<td>
<p>As <a href="base.html#topic+apply">apply</a></p>
</td></tr>
<tr><td><code id="ADapply_+3A_simplify">simplify</code></td>
<td>
<p>As <a href="base.html#topic+sapply">sapply</a></p>
</td></tr>
<tr><td><code id="ADapply_+3A_use.names">USE.NAMES</code></td>
<td>
<p>As <a href="base.html#topic+sapply">sapply</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"advector"</code> with a dimension attribute.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>apply(advector)</code>: As <a href="base.html#topic+apply">apply</a>
</p>
</li>
<li> <p><code>sapply(advector)</code>: As <a href="base.html#topic+sapply">sapply</a>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>F &lt;- MakeTape(function(x) apply(matrix(x,2,2), 2, sum), numeric(4))
F$jacobian(1:4)
</code></pre>

<hr>
<h2 id='ADcomplex'>AD complex numbers</h2><span id='topic+ADcomplex'></span><span id='topic+adcomplex'></span><span id='topic+Re.adcomplex'></span><span id='topic+Im.adcomplex'></span><span id='topic+show+2Cadcomplex-method'></span><span id='topic+dim.adcomplex'></span><span id='topic+dim+3C-.adcomplex'></span><span id='topic++5B.adcomplex'></span><span id='topic++5B+3C-.adcomplex'></span><span id='topic+t.adcomplex'></span><span id='topic+length.adcomplex'></span><span id='topic+Conj.adcomplex'></span><span id='topic+Mod.adcomplex'></span><span id='topic++2B.adcomplex'></span><span id='topic+-.adcomplex'></span><span id='topic++2A.adcomplex'></span><span id='topic++2F.adcomplex'></span><span id='topic+exp.adcomplex'></span><span id='topic+sqrt.adcomplex'></span><span id='topic+fft+2Cadcomplex-method'></span><span id='topic+fft+2Cadvector-method'></span>

<h3>Description</h3>

<p>A limited set of complex number operations can be used when constructing AD tapes. The available methods are listed in this help page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adcomplex(real, imag = rep(advector(0), length(real)))

## S3 method for class 'adcomplex'
Re(z)

## S3 method for class 'adcomplex'
Im(z)

## S4 method for signature 'adcomplex'
show(object)

## S3 method for class 'adcomplex'
dim(x)

## S3 replacement method for class 'adcomplex'
dim(x) &lt;- value

## S3 method for class 'adcomplex'
x[...]

## S3 replacement method for class 'adcomplex'
x[...] &lt;- value

## S3 method for class 'adcomplex'
t(x)

## S3 method for class 'adcomplex'
length(x)

## S3 method for class 'adcomplex'
Conj(z)

## S3 method for class 'adcomplex'
Mod(z)

## S3 method for class 'adcomplex'
x + y

## S3 method for class 'adcomplex'
x - y

## S3 method for class 'adcomplex'
x * y

## S3 method for class 'adcomplex'
x / y

## S3 method for class 'adcomplex'
exp(x)

## S3 method for class 'adcomplex'
sqrt(x)

## S4 method for signature 'adcomplex'
fft(z, inverse = FALSE)

## S4 method for signature 'advector'
fft(z, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ADcomplex_+3A_real">real</code></td>
<td>
<p>Real part</p>
</td></tr>
<tr><td><code id="ADcomplex_+3A_imag">imag</code></td>
<td>
<p>Imaginary part</p>
</td></tr>
<tr><td><code id="ADcomplex_+3A_z">z</code></td>
<td>
<p>An object of class <code>'adcomplex'</code></p>
</td></tr>
<tr><td><code id="ADcomplex_+3A_object">object</code></td>
<td>
<p>An object of class <code>'adcomplex'</code></p>
</td></tr>
<tr><td><code id="ADcomplex_+3A_x">x</code></td>
<td>
<p>An object of class <code>'adcomplex'</code></p>
</td></tr>
<tr><td><code id="ADcomplex_+3A_value">value</code></td>
<td>
<p>Replacement value</p>
</td></tr>
<tr><td><code id="ADcomplex_+3A_...">...</code></td>
<td>
<p>As <a href="base.html#topic++5B">[</a></p>
</td></tr>
<tr><td><code id="ADcomplex_+3A_y">y</code></td>
<td>
<p>An object of class <code>'adcomplex'</code></p>
</td></tr>
<tr><td><code id="ADcomplex_+3A_inverse">inverse</code></td>
<td>
<p>As <a href="stats.html#topic+fft">fft</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"adcomplex"</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>adcomplex()</code>: Construct <code>adcomplex</code> vector
</p>
</li>
<li> <p><code>Re(adcomplex)</code>: As <a href="base.html#topic+complex">complex</a>
</p>
</li>
<li> <p><code>Im(adcomplex)</code>: As <a href="base.html#topic+complex">complex</a>
</p>
</li>
<li> <p><code>show(adcomplex)</code>: Print method
</p>
</li>
<li> <p><code>dim(adcomplex)</code>: As <a href="base.html#topic+dim">dim</a>
</p>
</li>
<li> <p><code>dim(adcomplex) &lt;- value</code>: As <a href="base.html#topic+dim">dim</a>
</p>
</li>
<li> <p><code>[</code>: As <a href="base.html#topic++5B">[</a>
</p>
</li>
<li> <p><code>`[`(adcomplex) &lt;- value</code>: As <a href="base.html#topic++5B+3C-">[&lt;-</a>
</p>
</li>
<li> <p><code>t(adcomplex)</code>: As <a href="base.html#topic+t">t</a>
</p>
</li>
<li> <p><code>length(adcomplex)</code>: As <a href="base.html#topic+length">length</a>
</p>
</li>
<li> <p><code>Conj(adcomplex)</code>: As <a href="base.html#topic+complex">complex</a>
</p>
</li>
<li> <p><code>Mod(adcomplex)</code>: As <a href="base.html#topic+complex">complex</a>
</p>
</li>
<li> <p><code> + </code>: As <a href="base.html#topic+complex">complex</a>
</p>
</li>
<li> <p><code> - </code>: As <a href="base.html#topic+complex">complex</a>
</p>
</li>
<li> <p><code> * </code>: As <a href="base.html#topic+complex">complex</a>
</p>
</li>
<li> <p><code> / </code>: As <a href="base.html#topic+complex">complex</a>
</p>
</li>
<li> <p><code>exp(adcomplex)</code>: As <a href="base.html#topic+complex">complex</a>
</p>
</li>
<li> <p><code>sqrt(adcomplex)</code>: As <a href="base.html#topic+complex">complex</a>
</p>
</li>
<li> <p><code>fft(adcomplex)</code>: Fast Fourier Transform equivalent to <a href="stats.html#topic+fft">fft</a>. Notably this is the <strong>multivariate</strong> transform when <code>x</code> is an array.
</p>
</li>
<li> <p><code>fft(advector)</code>: If real input is supplied it is first converted to complex.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Tape using complex operations
F &lt;- MakeTape(function(x) {
  x &lt;- as.complex(x)
  y &lt;- exp( x * ( 1 + 2i ) )
  c(Re(y), Im(y))
}, numeric(1))
F
F(1)
## Complex FFT on the tape
G &lt;- MakeTape(function(x) sum(Re(fft(x))), numeric(3))
G$simplify()
G$print()
</code></pre>

<hr>
<h2 id='ADconstruct'>AD aware numeric constructors</h2><span id='topic+ADconstruct'></span><span id='topic+diag+2Cadvector+2CANY+2CANY-method'></span><span id='topic+matrix+2Cadvector-method'></span>

<h3>Description</h3>

<p>These base constructors have been extended to keep the AD class attribute of the data argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'advector,ANY,ANY'
diag(x, nrow, ncol)

## S4 method for signature 'advector'
matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ADconstruct_+3A_x">x</code></td>
<td>
<p>As <a href="base.html#topic+diag">diag</a></p>
</td></tr>
<tr><td><code id="ADconstruct_+3A_nrow">nrow</code></td>
<td>
<p>As <a href="base.html#topic+matrix">matrix</a></p>
</td></tr>
<tr><td><code id="ADconstruct_+3A_ncol">ncol</code></td>
<td>
<p>As <a href="base.html#topic+matrix">matrix</a></p>
</td></tr>
<tr><td><code id="ADconstruct_+3A_data">data</code></td>
<td>
<p>As <a href="base.html#topic+matrix">matrix</a></p>
</td></tr>
<tr><td><code id="ADconstruct_+3A_byrow">byrow</code></td>
<td>
<p>As <a href="base.html#topic+matrix">matrix</a></p>
</td></tr>
<tr><td><code id="ADconstruct_+3A_dimnames">dimnames</code></td>
<td>
<p>As <a href="base.html#topic+matrix">matrix</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"advector"</code> with a dimension attribute.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>diag(x = advector, nrow = ANY, ncol = ANY)</code>: Equivalent of <a href="base.html#topic+diag">diag</a>
</p>
</li>
<li> <p><code>matrix(advector)</code>: Equivalent of <a href="base.html#topic+matrix">matrix</a>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>func &lt;- function(x) {
  M &lt;- matrix(x, 2, 2)
  print(class(M))
  D &lt;- diag(x)
  print(class(D))
  0
}
invisible(func(1:4))            ## 'matrix' 'array'
invisible(MakeTape(func, 1:4))  ## 'advector'
</code></pre>

<hr>
<h2 id='ADmatrix'>AD matrix methods (sparse and dense)</h2><span id='topic+ADmatrix'></span><span id='topic+t.adsparse'></span><span id='topic++5B.adsparse'></span><span id='topic++5B+3C-.adsparse'></span><span id='topic+diag+2Cadsparse+2Cmissing+2Cmissing-method'></span><span id='topic+expm+2Cadvector-method'></span><span id='topic+expm+2Cadsparse-method'></span><span id='topic+dim+2Cadsparse-method'></span><span id='topic++25+2A+25+2Canysparse+2Cad-method'></span><span id='topic++25+2A+25+2Cad+2Canysparse-method'></span><span id='topic++25+2A+25+2Cadsparse+2Cadsparse-method'></span><span id='topic++25+2A+25+2Cad+2Cad-method'></span><span id='topic+tcrossprod+2Cadvector+2CANY-method'></span><span id='topic+crossprod+2Cadvector+2CANY-method'></span><span id='topic+solve+2Cad+2Cad.-method'></span><span id='topic+solve+2Cnum+2Cnum.-method'></span><span id='topic+solve+2Canysparse+2Cad.-method'></span><span id='topic+colSums+2Cadvector-method'></span><span id='topic+rowSums+2Cadvector-method'></span><span id='topic+cbind.advector'></span><span id='topic+rbind.advector'></span>

<h3>Description</h3>

<p>Matrices (<strong>base</strong> package) and sparse matrices (<strong>Matrix</strong> package) can be used inside the <code>RTMB</code> objective function as part of the calculations. Behind the scenes these R objects are converted to AD representations when needed. AD objects have a temporary lifetime, so you probably won't see them / need to know them. The only important thing is which <em>methods</em> work for the objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adsparse'
t(x)

## S3 method for class 'adsparse'
x[...]

## S3 replacement method for class 'adsparse'
x[...] &lt;- value

## S4 method for signature 'adsparse,missing,missing'
diag(x)

## S4 method for signature 'advector'
expm(x)

## S4 method for signature 'adsparse'
expm(x)

## S4 method for signature 'adsparse'
dim(x)

## S4 method for signature 'anysparse,ad'
x %*% y

## S4 method for signature 'ad,anysparse'
x %*% y

## S4 method for signature 'adsparse,adsparse'
x %*% y

## S4 method for signature 'ad,ad'
x %*% y

## S4 method for signature 'advector,ANY'
tcrossprod(x, y = NULL)

## S4 method for signature 'advector,ANY'
crossprod(x, y = NULL)

## S4 method for signature 'ad,ad.'
solve(a, b)

## S4 method for signature 'num,num.'
solve(a, b)

## S4 method for signature 'anysparse,ad.'
solve(a, b)

## S4 method for signature 'advector'
colSums(x)

## S4 method for signature 'advector'
rowSums(x)

## S3 method for class 'advector'
cbind(...)

## S3 method for class 'advector'
rbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ADmatrix_+3A_x">x</code></td>
<td>
<p>matrix (sparse or dense)</p>
</td></tr>
<tr><td><code id="ADmatrix_+3A_...">...</code></td>
<td>
<p>As <a href="base.html#topic+cbind">cbind</a></p>
</td></tr>
<tr><td><code id="ADmatrix_+3A_value">value</code></td>
<td>
<p>Replacement value</p>
</td></tr>
<tr><td><code id="ADmatrix_+3A_y">y</code></td>
<td>
<p>matrix (sparse or dense)</p>
</td></tr>
<tr><td><code id="ADmatrix_+3A_a">a</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="ADmatrix_+3A_b">b</code></td>
<td>
<p>matrix, vector or missing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>advector</code> with a dimension attribute for dense matrix operations; Object of class <code>adsparse</code> for sparse matrix operations.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>t(adsparse)</code>: AD sparse matrix transpose. Re-directs to <a href="Matrix.html#topic+t+2CCsparseMatrix-method">t,CsparseMatrix-method</a>.
</p>
</li>
<li> <p><code>[</code>: AD sparse matrix subsetting. Re-directs to <a href="Matrix.html#topic++5B-methods">[-methods</a>.
</p>
</li>
<li> <p><code>`[`(adsparse) &lt;- value</code>: AD sparse matrix subset assignment. Re-directs to <a href="Matrix.html#topic++5B+3C--methods">[&lt;&ndash;methods</a>.
</p>
</li>
<li> <p><code>diag(x = adsparse, nrow = missing, ncol = missing)</code>: AD sparse matrix diagonal extract. Re-directs to <a href="Matrix.html#topic+diag+2CCsparseMatrix-method">diag,CsparseMatrix-method</a>.
</p>
</li>
<li> <p><code>expm(advector)</code>: AD matrix exponential
</p>
</li>
<li> <p><code>expm(adsparse)</code>: AD matrix exponential
</p>
</li>
<li> <p><code>dim(adsparse)</code>: AD sparse matrix dimension
</p>
</li>
<li> <p><code>x %*% y</code>: AD matrix multiply
</p>
</li>
<li> <p><code>x %*% y</code>: AD matrix multiply
</p>
</li>
<li> <p><code>x %*% y</code>: AD matrix multiply
</p>
</li>
<li> <p><code>x %*% y</code>: AD matrix multiply
</p>
</li>
<li> <p><code>tcrossprod(x = advector, y = ANY)</code>: AD matrix multiply
</p>
</li>
<li> <p><code>crossprod(x = advector, y = ANY)</code>: AD matrix multiply
</p>
</li>
<li> <p><code>solve(a = ad, b = ad.)</code>: AD matrix inversion and solve
</p>
</li>
<li> <p><code>solve(a = num, b = num.)</code>: AD matrix inversion and solve
</p>
</li>
<li> <p><code>solve(a = anysparse, b = ad.)</code>: Sparse AD matrix solve (not yet implemented)
</p>
</li>
<li> <p><code>colSums(advector)</code>: AD matrix (or array) colsums
</p>
</li>
<li> <p><code>rowSums(advector)</code>: AD matrix (or array) rowsums
</p>
</li>
<li> <p><code>cbind(advector)</code>: AD matrix column bind
</p>
</li>
<li> <p><code>rbind(advector)</code>: AD matrix row bind
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>F &lt;- MakeTape(function(x) matrix(1:9,3,3) %*% x, numeric(3))
F$jacobian(1:3)
F &lt;- MakeTape(function(x) Matrix::expm(matrix(x,2,2)), numeric(4))
F$jacobian(1:4)
</code></pre>

<hr>
<h2 id='ADoverload'>Enable extra RTMB convenience methods</h2><span id='topic+ADoverload'></span>

<h3>Description</h3>

<p>Enable extra RTMB convenience methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ADoverload(x = c("[&lt;-", "c", "diag&lt;-"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ADoverload_+3A_x">x</code></td>
<td>
<p>Name of primitive to overload</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Work around limitations in R's method dispatch system by overloading some selected primitives, currently:
</p>

<ul>
<li><p> Inplace replacement, so you can do <code>x[i] &lt;- y</code> when <code>x</code> is numeric and <code>y</code> is AD.
</p>
</li>
<li><p> Mixed combine, so you can do e.g. <code>c(x, y)</code> when <code>x</code> numeric and <code>y</code> is AD.
</p>
</li>
<li><p> Diagonal assignment, so you can do <code>diag(x) &lt;- y</code> when <code>x</code> is a numeric matrix and <code>y</code> is AD.
</p>
</li></ul>

<p>In all cases, the result should be AD.
The methods are automatically <strong>temporarily</strong> attached to the search path (<code>search()</code>) when entering <a href="#topic+MakeTape">MakeTape</a> or <a href="#topic+MakeADFun">MakeADFun</a>.
Alternatively, methods can be overloaded locally inside functions using e.g. <code>"[&lt;-" &lt;- ADoverload("[&lt;-")</code>. This is only needed when using RTMB from a package.
</p>


<h3>Value</h3>

<p>Function representing the overload.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MakeTape(function(x) {print(search()); x}, numeric(0))
MakeTape(function(x) c(1,x), 1:3)
MakeTape(function(x) {y &lt;- 1:3; y[2] &lt;- x; y}, 1)
MakeTape(function(x) {y &lt;- matrix(0,3,3); diag(y) &lt;- x; y}, 1:3)
</code></pre>

<hr>
<h2 id='ADvector'>The AD vector and its methods</h2><span id='topic+ADvector'></span><span id='topic+advector'></span><span id='topic+Ops.advector'></span><span id='topic+Math.advector'></span><span id='topic+as.vector.advector'></span><span id='topic+as.complex.advector'></span><span id='topic+aperm.advector'></span><span id='topic+c.advector'></span><span id='topic++5B.advector'></span><span id='topic++5B+3C-.advector'></span><span id='topic++5B+5B.advector'></span><span id='topic+rep.advector'></span><span id='topic+sum.advector'></span><span id='topic+prod.advector'></span><span id='topic+is.numeric.advector'></span><span id='topic+Complex.advector'></span><span id='topic+Summary.advector'></span><span id='topic+diff.advector'></span><span id='topic+print.advector'></span><span id='topic+ifelse+2Cnum+2Cad+2Cad-method'></span><span id='topic+ifelse+2Cnum+2Cnum+2Cnum-method'></span><span id='topic+outer+2Cadvector+2Cadvector+2Cmissing-method'></span>

<h3>Description</h3>

<p>An <code>advector</code> is a class used behind the scenes to replace
normal R numeric objects during automatic differentiation. An
<code>advector</code> has a 'temporary lifetime' and therefore you do not
<em>see</em> / <em>need to know</em> it as a normal user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>advector(x)

## S3 method for class 'advector'
Ops(e1, e2)

## S3 method for class 'advector'
Math(x, ...)

## S3 method for class 'advector'
as.vector(x, mode = "any")

## S3 method for class 'advector'
as.complex(x, ...)

## S3 method for class 'advector'
aperm(a, perm, ...)

## S3 method for class 'advector'
c(...)

## S3 method for class 'advector'
x[...]

## S3 replacement method for class 'advector'
x[...] &lt;- value

## S3 method for class 'advector'
x[[...]]

## S3 method for class 'advector'
rep(x, ...)

## S3 method for class 'advector'
sum(x, ..., na.rm = FALSE)

## S3 method for class 'advector'
prod(x, ..., na.rm)

## S3 method for class 'advector'
is.numeric(x)

## S3 method for class 'advector'
Complex(z)

## S3 method for class 'advector'
Summary(..., na.rm = FALSE)

## S3 method for class 'advector'
diff(x, lag = 1L, differences = 1L, ...)

## S3 method for class 'advector'
print(x, ...)

## S4 method for signature 'num,ad,ad'
ifelse(test, yes, no)

## S4 method for signature 'num,num,num'
ifelse(test, yes, no)

## S4 method for signature 'advector,advector,missing'
outer(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ADvector_+3A_x">x</code></td>
<td>
<p>numeric or advector</p>
</td></tr>
<tr><td><code id="ADvector_+3A_e1">e1</code></td>
<td>
<p>advector</p>
</td></tr>
<tr><td><code id="ADvector_+3A_e2">e2</code></td>
<td>
<p>advector</p>
</td></tr>
<tr><td><code id="ADvector_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
<tr><td><code id="ADvector_+3A_mode">mode</code></td>
<td>
<p>FIXME might not be handled correctly by <code>as.vector</code></p>
</td></tr>
<tr><td><code id="ADvector_+3A_a">a</code></td>
<td>
<p>advector with dimension attribute</p>
</td></tr>
<tr><td><code id="ADvector_+3A_perm">perm</code></td>
<td>
<p>Permutation as in <code>aperm</code></p>
</td></tr>
<tr><td><code id="ADvector_+3A_value">value</code></td>
<td>
<p>Replacement value implicitly converted to AD</p>
</td></tr>
<tr><td><code id="ADvector_+3A_na.rm">na.rm</code></td>
<td>
<p>Must be FALSE (default)</p>
</td></tr>
<tr><td><code id="ADvector_+3A_z">z</code></td>
<td>
<p>Complex (not allowed)</p>
</td></tr>
<tr><td><code id="ADvector_+3A_lag">lag</code></td>
<td>
<p>As <a href="base.html#topic+diff">diff</a></p>
</td></tr>
<tr><td><code id="ADvector_+3A_differences">differences</code></td>
<td>
<p>As <a href="base.html#topic+diff">diff</a></p>
</td></tr>
<tr><td><code id="ADvector_+3A_test">test</code></td>
<td>
<p><code>logical</code> vector</p>
</td></tr>
<tr><td><code id="ADvector_+3A_yes">yes</code></td>
<td>
<p><code>advector</code></p>
</td></tr>
<tr><td><code id="ADvector_+3A_no">no</code></td>
<td>
<p><code>advector</code></p>
</td></tr>
<tr><td><code id="ADvector_+3A_x">X</code></td>
<td>
<p>As <a href="base.html#topic+outer">outer</a></p>
</td></tr>
<tr><td><code id="ADvector_+3A_y">Y</code></td>
<td>
<p>As <a href="base.html#topic+outer">outer</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>An AD vector (class='advector') is an atomic R vector of 'codes'
that are internally interpretable as 'AD scalars'. A substantial
part of R's existing S3 matrix and array functionality can be
re-used for AD vectors.
</p>


<h3>Value</h3>

<p>Object of class <code>"advector"</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>advector()</code>: Construct a new advector
</p>
</li>
<li> <p><code>Ops(advector)</code>: Binary operations
</p>
</li>
<li> <p><code>Math(advector)</code>: Unary operations
</p>
</li>
<li> <p><code>as.vector(advector)</code>: Makes <code>array(x)</code> work.
</p>
</li>
<li> <p><code>as.complex(advector)</code>: Convert to <a href="#topic+ADcomplex">ADcomplex</a>. Note that dimensions are dropped for consistency with base R.
</p>
</li>
<li> <p><code>aperm(advector)</code>: Equivalent of <a href="base.html#topic+aperm">aperm</a>
</p>
</li>
<li> <p><code>c(advector)</code>: Equivalent of <a href="base.html#topic+c">c</a>. However note the limitation for mixed types: If <code>x</code> is an AD type, <code>c(x,1)</code> works while <code>c(1,x)</code> does not!
</p>
</li>
<li> <p><code>[</code>: Equivalent of <a href="base.html#topic++5B">[</a>
</p>
</li>
<li> <p><code>`[`(advector) &lt;- value</code>: Equivalent of <a href="base.html#topic++5B+3C-">[&lt;-</a>
</p>
</li>
<li> <p><code>[[</code>: Equivalent of <a href="base.html#topic++5B+5B">[[</a>
</p>
</li>
<li> <p><code>rep(advector)</code>: Equivalent of <a href="base.html#topic+rep">rep</a>. Makes <code>outer(x,x,...)</code> work.
</p>
</li>
<li> <p><code>sum(advector)</code>: Equivalent of <a href="base.html#topic+sum">sum</a>. <code>na.rm=TRUE</code> is allowed, but note that this feature assumes correct propagation of NAs via C-level arithmetic.
</p>
</li>
<li> <p><code>prod(advector)</code>: Equivalent of <a href="base.html#topic+prod">prod</a> except <code>na.rm</code> not allowed.
</p>
</li>
<li> <p><code>is.numeric(advector)</code>: Makes <code>cov2cor()</code> work. FIXME: Any unwanted side-effects with this?
</p>
</li>
<li> <p><code>Complex(advector)</code>: <a href="methods.html#topic+Complex">Complex</a> operations are not allowed and will throw an error.
</p>
</li>
<li> <p><code>Summary(advector)</code>: Non differentiable <a href="methods.html#topic+Summary">Summary</a> operations (e.g. <code>min</code> <code>max</code>) are not allowed and will throw an error.
</p>
</li>
<li> <p><code>diff(advector)</code>: Equivalent of <a href="base.html#topic+diff">diff</a>
</p>
</li>
<li> <p><code>print(advector)</code>: Print method
</p>
</li>
<li> <p><code>ifelse(test = num, yes = ad, no = ad)</code>: Equivalent of <a href="base.html#topic+ifelse">ifelse</a>
</p>
</li>
<li> <p><code>ifelse(test = num, yes = num, no = num)</code>: Default method
</p>
</li>
<li> <p><code>outer(X = advector, Y = advector, FUN = missing)</code>: Equivalent of <a href="base.html#topic+outer">outer</a>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- advector(1:9)
a &lt;- array(x, c(3,3))  ## as an array
outer(x, x, "+") ## Implicit via 'rep'
rev(x)           ## Implicit via '['
</code></pre>

<hr>
<h2 id='Distributions'>Distributions and special functions for which AD is implemented</h2><span id='topic+Distributions'></span><span id='topic+dexp+2Cad+2Cad.+2Clogical.-method'></span><span id='topic+dexp+2Cnum+2Cnum.+2Clogical.-method'></span><span id='topic+dexp+2Cosa+2CANY+2CANY-method'></span><span id='topic+dexp+2Csimref+2CANY+2CANY-method'></span><span id='topic+dweibull+2Cad+2Cad+2Cad.+2Clogical.-method'></span><span id='topic+dweibull+2Cnum+2Cnum+2Cnum.+2Clogical.-method'></span><span id='topic+dweibull+2Cosa+2CANY+2CANY+2CANY-method'></span><span id='topic+dweibull+2Csimref+2CANY+2CANY+2CANY-method'></span><span id='topic+dbinom+2Cad+2Cad+2Cad+2Clogical.-method'></span><span id='topic+dbinom+2Cnum+2Cnum+2Cnum+2Clogical.-method'></span><span id='topic+dbinom+2Cosa+2CANY+2CANY+2CANY-method'></span><span id='topic+dbinom+2Csimref+2CANY+2CANY+2CANY-method'></span><span id='topic+dbeta+2Cad+2Cad+2Cad+2Cmissing+2Clogical.-method'></span><span id='topic+dbeta+2Cnum+2Cnum+2Cnum+2Cmissing+2Clogical.-method'></span><span id='topic+dbeta+2Cosa+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+dbeta+2Csimref+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+df+2Cad+2Cad+2Cad+2Cmissing+2Clogical.-method'></span><span id='topic+df+2Cnum+2Cnum+2Cnum+2Cmissing+2Clogical.-method'></span><span id='topic+df+2Cosa+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+df+2Csimref+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+dlogis+2Cad+2Cad.+2Cad.+2Clogical.-method'></span><span id='topic+dlogis+2Cnum+2Cnum.+2Cnum.+2Clogical.-method'></span><span id='topic+dlogis+2Cosa+2CANY+2CANY+2CANY-method'></span><span id='topic+dlogis+2Csimref+2CANY+2CANY+2CANY-method'></span><span id='topic+dt+2Cad+2Cad+2Cmissing+2Clogical.-method'></span><span id='topic+dt+2Cnum+2Cnum+2Cmissing+2Clogical.-method'></span><span id='topic+dt+2Cosa+2CANY+2CANY+2CANY-method'></span><span id='topic+dt+2Csimref+2CANY+2CANY+2CANY-method'></span><span id='topic+dnbinom+2Cad+2Cad+2Cad+2Cmissing+2Clogical.-method'></span><span id='topic+dnbinom+2Cnum+2Cnum+2Cnum+2Cmissing+2Clogical.-method'></span><span id='topic+dnbinom+2Cosa+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+dnbinom+2Csimref+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+dpois+2Cad+2Cad+2Clogical.-method'></span><span id='topic+dpois+2Cnum+2Cnum+2Clogical.-method'></span><span id='topic+dpois+2Cosa+2CANY+2CANY-method'></span><span id='topic+dpois+2Csimref+2CANY+2CANY-method'></span><span id='topic+dgamma+2Cad+2Cad+2Cmissing+2Cad.+2Clogical.-method'></span><span id='topic+dgamma+2Cnum+2Cnum+2Cmissing+2Cnum.+2Clogical.-method'></span><span id='topic+dgamma+2Cosa+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+dgamma+2Csimref+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+pnorm+2Cad+2Cad.+2Cad.+2Cmissing+2Cmissing-method'></span><span id='topic+pnorm+2Cnum+2Cnum.+2Cnum.+2Cmissing+2Cmissing-method'></span><span id='topic+pgamma+2Cad+2Cad+2Cmissing+2Cad.+2Cmissing+2Cmissing-method'></span><span id='topic+pgamma+2Cnum+2Cnum+2Cmissing+2Cnum.+2Cmissing+2Cmissing-method'></span><span id='topic+ppois+2Cad+2Cad+2Cmissing+2Cmissing-method'></span><span id='topic+ppois+2Cnum+2Cnum+2Cmissing+2Cmissing-method'></span><span id='topic+pexp+2Cad+2Cad.+2Cmissing+2Cmissing-method'></span><span id='topic+pexp+2Cnum+2Cnum.+2Cmissing+2Cmissing-method'></span><span id='topic+pweibull+2Cad+2Cad+2Cad.+2Cmissing+2Cmissing-method'></span><span id='topic+pweibull+2Cnum+2Cnum+2Cnum.+2Cmissing+2Cmissing-method'></span><span id='topic+pbeta+2Cad+2Cad+2Cad+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+pbeta+2Cnum+2Cnum+2Cnum+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+qnorm+2Cad+2Cad.+2Cad.+2Cmissing+2Cmissing-method'></span><span id='topic+qnorm+2Cnum+2Cnum.+2Cnum.+2Cmissing+2Cmissing-method'></span><span id='topic+qgamma+2Cad+2Cad+2Cmissing+2Cad.+2Cmissing+2Cmissing-method'></span><span id='topic+qgamma+2Cnum+2Cnum+2Cmissing+2Cnum.+2Cmissing+2Cmissing-method'></span><span id='topic+qexp+2Cad+2Cad.+2Cmissing+2Cmissing-method'></span><span id='topic+qexp+2Cnum+2Cnum.+2Cmissing+2Cmissing-method'></span><span id='topic+qweibull+2Cad+2Cad+2Cad.+2Cmissing+2Cmissing-method'></span><span id='topic+qweibull+2Cnum+2Cnum+2Cnum.+2Cmissing+2Cmissing-method'></span><span id='topic+qbeta+2Cad+2Cad+2Cad+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+qbeta+2Cnum+2Cnum+2Cnum+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+besselK+2Cad+2Cad+2Cmissing-method'></span><span id='topic+besselK+2Cnum+2Cnum+2Cmissing-method'></span><span id='topic+besselI+2Cad+2Cad+2Cmissing-method'></span><span id='topic+besselI+2Cnum+2Cnum+2Cmissing-method'></span><span id='topic+besselJ+2Cad+2Cad-method'></span><span id='topic+besselJ+2Cnum+2Cnum-method'></span><span id='topic+besselY+2Cad+2Cad-method'></span><span id='topic+besselY+2Cnum+2Cnum-method'></span><span id='topic+dbinom_robust'></span><span id='topic+dsn'></span><span id='topic+dSHASHo'></span><span id='topic+dtweedie'></span><span id='topic+dnbinom2'></span><span id='topic+dnbinom_robust'></span><span id='topic+dlgamma'></span><span id='topic+dnorm+2Cad+2Cad.+2Cad.+2Clogical.-method'></span><span id='topic+dnorm+2Cnum+2Cnum.+2Cnum.+2Clogical.-method'></span><span id='topic+dnorm+2Cosa+2CANY+2CANY+2CANY-method'></span><span id='topic+dnorm+2Csimref+2CANY+2CANY+2CANY-method'></span><span id='topic+plogis+2Cadvector+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+qlogis+2Cadvector+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+dcompois'></span><span id='topic+dcompois2'></span><span id='topic+pbinom+2Cad+2Cad+2Cad+2Cmissing+2Cmissing-method'></span><span id='topic+pbinom+2Cnum+2Cnum+2Cnum+2Cmissing+2Cmissing-method'></span><span id='topic+dmultinom+2Cad+2Cad.+2Cad+2Clogical.-method'></span><span id='topic+dmultinom+2Cnum+2Cnum.+2Cnum+2Clogical.-method'></span><span id='topic+dmultinom+2Cosa+2CANY+2CANY+2CANY-method'></span><span id='topic+dmultinom+2Csimref+2CANY+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>The functions listed in this help page are all applicable for AD types.
Method dispatching follows a simple rule:
<em>If at least one argument is an AD type then a special AD
implementation is selected. In all other cases a default
implementation is used</em> (typically that of the <b>stats</b>
package).
Argument recycling follows the R standard (although wihout any warnings).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ad,ad.,logical.'
dexp(x, rate = 1, log = FALSE)

## S4 method for signature 'num,num.,logical.'
dexp(x, rate = 1, log = FALSE)

## S4 method for signature 'osa,ANY,ANY'
dexp(x, rate = 1, log = FALSE)

## S4 method for signature 'simref,ANY,ANY'
dexp(x, rate = 1, log = FALSE)

## S4 method for signature 'ad,ad,ad.,logical.'
dweibull(x, shape, scale = 1, log = FALSE)

## S4 method for signature 'num,num,num.,logical.'
dweibull(x, shape, scale = 1, log = FALSE)

## S4 method for signature 'osa,ANY,ANY,ANY'
dweibull(x, shape, scale = 1, log = FALSE)

## S4 method for signature 'simref,ANY,ANY,ANY'
dweibull(x, shape, scale = 1, log = FALSE)

## S4 method for signature 'ad,ad,ad,logical.'
dbinom(x, size, prob, log = FALSE)

## S4 method for signature 'num,num,num,logical.'
dbinom(x, size, prob, log = FALSE)

## S4 method for signature 'osa,ANY,ANY,ANY'
dbinom(x, size, prob, log = FALSE)

## S4 method for signature 'simref,ANY,ANY,ANY'
dbinom(x, size, prob, log = FALSE)

## S4 method for signature 'ad,ad,ad,missing,logical.'
dbeta(x, shape1, shape2, log)

## S4 method for signature 'num,num,num,missing,logical.'
dbeta(x, shape1, shape2, log)

## S4 method for signature 'osa,ANY,ANY,ANY,ANY'
dbeta(x, shape1, shape2, log)

## S4 method for signature 'simref,ANY,ANY,ANY,ANY'
dbeta(x, shape1, shape2, log)

## S4 method for signature 'ad,ad,ad,missing,logical.'
df(x, df1, df2, log)

## S4 method for signature 'num,num,num,missing,logical.'
df(x, df1, df2, log)

## S4 method for signature 'osa,ANY,ANY,ANY,ANY'
df(x, df1, df2, log)

## S4 method for signature 'simref,ANY,ANY,ANY,ANY'
df(x, df1, df2, log)

## S4 method for signature 'ad,ad.,ad.,logical.'
dlogis(x, location = 0, scale = 1, log = FALSE)

## S4 method for signature 'num,num.,num.,logical.'
dlogis(x, location = 0, scale = 1, log = FALSE)

## S4 method for signature 'osa,ANY,ANY,ANY'
dlogis(x, location = 0, scale = 1, log = FALSE)

## S4 method for signature 'simref,ANY,ANY,ANY'
dlogis(x, location = 0, scale = 1, log = FALSE)

## S4 method for signature 'ad,ad,missing,logical.'
dt(x, df, log)

## S4 method for signature 'num,num,missing,logical.'
dt(x, df, log)

## S4 method for signature 'osa,ANY,ANY,ANY'
dt(x, df, log)

## S4 method for signature 'simref,ANY,ANY,ANY'
dt(x, df, log)

## S4 method for signature 'ad,ad,ad,missing,logical.'
dnbinom(x, size, prob, log)

## S4 method for signature 'num,num,num,missing,logical.'
dnbinom(x, size, prob, log)

## S4 method for signature 'osa,ANY,ANY,ANY,ANY'
dnbinom(x, size, prob, log)

## S4 method for signature 'simref,ANY,ANY,ANY,ANY'
dnbinom(x, size, prob, log)

## S4 method for signature 'ad,ad,logical.'
dpois(x, lambda, log = FALSE)

## S4 method for signature 'num,num,logical.'
dpois(x, lambda, log = FALSE)

## S4 method for signature 'osa,ANY,ANY'
dpois(x, lambda, log = FALSE)

## S4 method for signature 'simref,ANY,ANY'
dpois(x, lambda, log = FALSE)

## S4 method for signature 'ad,ad,missing,ad.,logical.'
dgamma(x, shape, scale, log)

## S4 method for signature 'num,num,missing,num.,logical.'
dgamma(x, shape, scale, log)

## S4 method for signature 'osa,ANY,ANY,ANY,ANY'
dgamma(x, shape, scale, log)

## S4 method for signature 'simref,ANY,ANY,ANY,ANY'
dgamma(x, shape, scale, log)

## S4 method for signature 'ad,ad.,ad.,missing,missing'
pnorm(q, mean, sd)

## S4 method for signature 'num,num.,num.,missing,missing'
pnorm(q, mean, sd)

## S4 method for signature 'ad,ad,missing,ad.,missing,missing'
pgamma(q, shape, scale)

## S4 method for signature 'num,num,missing,num.,missing,missing'
pgamma(q, shape, scale)

## S4 method for signature 'ad,ad,missing,missing'
ppois(q, lambda)

## S4 method for signature 'num,num,missing,missing'
ppois(q, lambda)

## S4 method for signature 'ad,ad.,missing,missing'
pexp(q, rate)

## S4 method for signature 'num,num.,missing,missing'
pexp(q, rate)

## S4 method for signature 'ad,ad,ad.,missing,missing'
pweibull(q, shape, scale)

## S4 method for signature 'num,num,num.,missing,missing'
pweibull(q, shape, scale)

## S4 method for signature 'ad,ad,ad,missing,missing,missing'
pbeta(q, shape1, shape2)

## S4 method for signature 'num,num,num,missing,missing,missing'
pbeta(q, shape1, shape2)

## S4 method for signature 'ad,ad.,ad.,missing,missing'
qnorm(p, mean, sd)

## S4 method for signature 'num,num.,num.,missing,missing'
qnorm(p, mean, sd)

## S4 method for signature 'ad,ad,missing,ad.,missing,missing'
qgamma(p, shape, scale)

## S4 method for signature 'num,num,missing,num.,missing,missing'
qgamma(p, shape, scale)

## S4 method for signature 'ad,ad.,missing,missing'
qexp(p, rate)

## S4 method for signature 'num,num.,missing,missing'
qexp(p, rate)

## S4 method for signature 'ad,ad,ad.,missing,missing'
qweibull(p, shape, scale)

## S4 method for signature 'num,num,num.,missing,missing'
qweibull(p, shape, scale)

## S4 method for signature 'ad,ad,ad,missing,missing,missing'
qbeta(p, shape1, shape2)

## S4 method for signature 'num,num,num,missing,missing,missing'
qbeta(p, shape1, shape2)

## S4 method for signature 'ad,ad,missing'
besselK(x, nu)

## S4 method for signature 'num,num,missing'
besselK(x, nu)

## S4 method for signature 'ad,ad,missing'
besselI(x, nu)

## S4 method for signature 'num,num,missing'
besselI(x, nu)

## S4 method for signature 'ad,ad'
besselJ(x, nu)

## S4 method for signature 'num,num'
besselJ(x, nu)

## S4 method for signature 'ad,ad'
besselY(x, nu)

## S4 method for signature 'num,num'
besselY(x, nu)

dbinom_robust(x, size, logit_p, log)

dsn(x, alpha, log)

dSHASHo(x, mu, sigma, nu, tau, log)

dtweedie(x, mu, phi, p, log)

dnbinom2(x, mu, var, log)

dnbinom_robust(x, log_mu, log_var_minus_mu, log)

dlgamma(x, shape, scale, log)

## S4 method for signature 'ad,ad.,ad.,logical.'
dnorm(x, mean = 0, sd = 1, log = FALSE)

## S4 method for signature 'num,num.,num.,logical.'
dnorm(x, mean = 0, sd = 1, log = FALSE)

## S4 method for signature 'osa,ANY,ANY,ANY'
dnorm(x, mean = 0, sd = 1, log = FALSE)

## S4 method for signature 'simref,ANY,ANY,ANY'
dnorm(x, mean = 0, sd = 1, log = FALSE)

## S4 method for signature 'advector,missing,missing,missing,missing'
plogis(q)

## S4 method for signature 'advector,missing,missing,missing,missing'
qlogis(p)

dcompois(x, mode, nu, log = FALSE)

dcompois2(x, mean, nu, log = FALSE)

## S4 method for signature 'ad,ad,ad,missing,missing'
pbinom(q, size, prob)

## S4 method for signature 'num,num,num,missing,missing'
pbinom(q, size, prob)

## S4 method for signature 'ad,ad.,ad,logical.'
dmultinom(x, size = NULL, prob, log = FALSE)

## S4 method for signature 'num,num.,num,logical.'
dmultinom(x, size = NULL, prob, log = FALSE)

## S4 method for signature 'osa,ANY,ANY,ANY'
dmultinom(x, size = NULL, prob, log = FALSE)

## S4 method for signature 'simref,ANY,ANY,ANY'
dmultinom(x, size = NULL, prob, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Distributions_+3A_x">x</code></td>
<td>
<p>observation vector</p>
</td></tr>
<tr><td><code id="Distributions_+3A_rate">rate</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_log">log</code></td>
<td>
<p>Logical; Return log density/probability?</p>
</td></tr>
<tr><td><code id="Distributions_+3A_shape">shape</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_scale">scale</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_size">size</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_prob">prob</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_shape1">shape1</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_shape2">shape2</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_df1">df1</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_df2">df2</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_location">location</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_df">df</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_lambda">lambda</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="Distributions_+3A_mean">mean</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_sd">sd</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_p">p</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_nu">nu</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_logit_p">logit_p</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_alpha">alpha</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_mu">mu</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_sigma">sigma</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_tau">tau</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_phi">phi</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_var">var</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_log_mu">log_mu</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_log_var_minus_mu">log_var_minus_mu</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="Distributions_+3A_mode">mode</code></td>
<td>
<p>parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specific documentation of the functions and arguments should be looked up elsewhere:
</p>

<ul>
<li><p> All S4 methods behave as the corresponding functions in the
<b>stats</b> package. However, some arguements may not be
implemented in the AD case (e.g. <code>lower-tail</code>).
</p>
</li>
<li><p> Other funtions behave as the corresponding TMB versions for
which documentation should be looked up online.
</p>
</li></ul>



<h3>Value</h3>

<p>In autodiff contexts an object of class <code>"advector"</code> is returned; Otherwise a standard numeric vector.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>dexp(x = ad, rate = ad., log = logical.)</code>: AD implementation of <a href="stats.html#topic+dexp">dexp</a>
</p>
</li>
<li> <p><code>dexp(x = num, rate = num., log = logical.)</code>: Default method
</p>
</li>
<li> <p><code>dexp(x = osa, rate = ANY, log = ANY)</code>: OSA implementation
</p>
</li>
<li> <p><code>dexp(x = simref, rate = ANY, log = ANY)</code>: Simulation implementation. Modifies <code>x</code> and returns zero.
</p>
</li>
<li> <p><code>dweibull(x = ad, shape = ad, scale = ad., log = logical.)</code>: AD implementation of <a href="stats.html#topic+dweibull">dweibull</a>
</p>
</li>
<li> <p><code>dweibull(x = num, shape = num, scale = num., log = logical.)</code>: Default method
</p>
</li>
<li> <p><code>dweibull(x = osa, shape = ANY, scale = ANY, log = ANY)</code>: OSA implementation
</p>
</li>
<li> <p><code>dweibull(x = simref, shape = ANY, scale = ANY, log = ANY)</code>: Simulation implementation. Modifies <code>x</code> and returns zero.
</p>
</li>
<li> <p><code>dbinom(x = ad, size = ad, prob = ad, log = logical.)</code>: AD implementation of <a href="stats.html#topic+dbinom">dbinom</a>
</p>
</li>
<li> <p><code>dbinom(x = num, size = num, prob = num, log = logical.)</code>: Default method
</p>
</li>
<li> <p><code>dbinom(x = osa, size = ANY, prob = ANY, log = ANY)</code>: OSA implementation
</p>
</li>
<li> <p><code>dbinom(x = simref, size = ANY, prob = ANY, log = ANY)</code>: Simulation implementation. Modifies <code>x</code> and returns zero.
</p>
</li>
<li> <p><code>dbeta(x = ad, shape1 = ad, shape2 = ad, ncp = missing, log = logical.)</code>: AD implementation of <a href="stats.html#topic+dbeta">dbeta</a>
</p>
</li>
<li> <p><code>dbeta(x = num, shape1 = num, shape2 = num, ncp = missing, log = logical.)</code>: Default method
</p>
</li>
<li> <p><code>dbeta(x = osa, shape1 = ANY, shape2 = ANY, ncp = ANY, log = ANY)</code>: OSA implementation
</p>
</li>
<li> <p><code>dbeta(x = simref, shape1 = ANY, shape2 = ANY, ncp = ANY, log = ANY)</code>: Simulation implementation. Modifies <code>x</code> and returns zero.
</p>
</li>
<li> <p><code>df(x = ad, df1 = ad, df2 = ad, ncp = missing, log = logical.)</code>: AD implementation of <a href="stats.html#topic+df">df</a>
</p>
</li>
<li> <p><code>df(x = num, df1 = num, df2 = num, ncp = missing, log = logical.)</code>: Default method
</p>
</li>
<li> <p><code>df(x = osa, df1 = ANY, df2 = ANY, ncp = ANY, log = ANY)</code>: OSA implementation
</p>
</li>
<li> <p><code>df(x = simref, df1 = ANY, df2 = ANY, ncp = ANY, log = ANY)</code>: Simulation implementation. Modifies <code>x</code> and returns zero.
</p>
</li>
<li> <p><code>dlogis(x = ad, location = ad., scale = ad., log = logical.)</code>: AD implementation of <a href="stats.html#topic+dlogis">dlogis</a>
</p>
</li>
<li> <p><code>dlogis(x = num, location = num., scale = num., log = logical.)</code>: Default method
</p>
</li>
<li> <p><code>dlogis(x = osa, location = ANY, scale = ANY, log = ANY)</code>: OSA implementation
</p>
</li>
<li> <p><code>dlogis(x = simref, location = ANY, scale = ANY, log = ANY)</code>: Simulation implementation. Modifies <code>x</code> and returns zero.
</p>
</li>
<li> <p><code>dt(x = ad, df = ad, ncp = missing, log = logical.)</code>: AD implementation of <a href="stats.html#topic+dt">dt</a>
</p>
</li>
<li> <p><code>dt(x = num, df = num, ncp = missing, log = logical.)</code>: Default method
</p>
</li>
<li> <p><code>dt(x = osa, df = ANY, ncp = ANY, log = ANY)</code>: OSA implementation
</p>
</li>
<li> <p><code>dt(x = simref, df = ANY, ncp = ANY, log = ANY)</code>: Simulation implementation. Modifies <code>x</code> and returns zero.
</p>
</li>
<li> <p><code>dnbinom(x = ad, size = ad, prob = ad, mu = missing, log = logical.)</code>: AD implementation of <a href="stats.html#topic+dnbinom">dnbinom</a>
</p>
</li>
<li> <p><code>dnbinom(x = num, size = num, prob = num, mu = missing, log = logical.)</code>: Default method
</p>
</li>
<li> <p><code>dnbinom(x = osa, size = ANY, prob = ANY, mu = ANY, log = ANY)</code>: OSA implementation
</p>
</li>
<li> <p><code>dnbinom(x = simref, size = ANY, prob = ANY, mu = ANY, log = ANY)</code>: Simulation implementation. Modifies <code>x</code> and returns zero.
</p>
</li>
<li> <p><code>dpois(x = ad, lambda = ad, log = logical.)</code>: AD implementation of <a href="stats.html#topic+dpois">dpois</a>
</p>
</li>
<li> <p><code>dpois(x = num, lambda = num, log = logical.)</code>: Default method
</p>
</li>
<li> <p><code>dpois(x = osa, lambda = ANY, log = ANY)</code>: OSA implementation
</p>
</li>
<li> <p><code>dpois(x = simref, lambda = ANY, log = ANY)</code>: Simulation implementation. Modifies <code>x</code> and returns zero.
</p>
</li>
<li> <p><code>dgamma(x = ad, shape = ad, rate = missing, scale = ad., log = logical.)</code>: AD implementation of <a href="stats.html#topic+dgamma">dgamma</a>
</p>
</li>
<li> <p><code>dgamma(x = num, shape = num, rate = missing, scale = num., log = logical.)</code>: Default method
</p>
</li>
<li> <p><code>dgamma(x = osa, shape = ANY, rate = ANY, scale = ANY, log = ANY)</code>: OSA implementation
</p>
</li>
<li> <p><code>dgamma(x = simref, shape = ANY, rate = ANY, scale = ANY, log = ANY)</code>: Simulation implementation. Modifies <code>x</code> and returns zero.
</p>
</li>
<li> <p><code>pnorm(q = ad, mean = ad., sd = ad., lower.tail = missing, log.p = missing)</code>: AD implementation of <a href="stats.html#topic+pnorm">pnorm</a>
</p>
</li>
<li> <p><code>pnorm(q = num, mean = num., sd = num., lower.tail = missing, log.p = missing)</code>: Default method
</p>
</li>
<li> <p><code>pgamma(
  q = ad,
  shape = ad,
  rate = missing,
  scale = ad.,
  lower.tail = missing,
  log.p = missing
)</code>: AD implementation of <a href="stats.html#topic+pgamma">pgamma</a>
</p>
</li>
<li> <p><code>pgamma(
  q = num,
  shape = num,
  rate = missing,
  scale = num.,
  lower.tail = missing,
  log.p = missing
)</code>: Default method
</p>
</li>
<li> <p><code>ppois(q = ad, lambda = ad, lower.tail = missing, log.p = missing)</code>: AD implementation of <a href="stats.html#topic+ppois">ppois</a>
</p>
</li>
<li> <p><code>ppois(q = num, lambda = num, lower.tail = missing, log.p = missing)</code>: Default method
</p>
</li>
<li> <p><code>pexp(q = ad, rate = ad., lower.tail = missing, log.p = missing)</code>: AD implementation of <a href="stats.html#topic+pexp">pexp</a>
</p>
</li>
<li> <p><code>pexp(q = num, rate = num., lower.tail = missing, log.p = missing)</code>: Default method
</p>
</li>
<li> <p><code>pweibull(
  q = ad,
  shape = ad,
  scale = ad.,
  lower.tail = missing,
  log.p = missing
)</code>: AD implementation of <a href="stats.html#topic+pweibull">pweibull</a>
</p>
</li>
<li> <p><code>pweibull(
  q = num,
  shape = num,
  scale = num.,
  lower.tail = missing,
  log.p = missing
)</code>: Default method
</p>
</li>
<li> <p><code>pbeta(
  q = ad,
  shape1 = ad,
  shape2 = ad,
  ncp = missing,
  lower.tail = missing,
  log.p = missing
)</code>: AD implementation of <a href="stats.html#topic+pbeta">pbeta</a>
</p>
</li>
<li> <p><code>pbeta(
  q = num,
  shape1 = num,
  shape2 = num,
  ncp = missing,
  lower.tail = missing,
  log.p = missing
)</code>: Default method
</p>
</li>
<li> <p><code>qnorm(p = ad, mean = ad., sd = ad., lower.tail = missing, log.p = missing)</code>: AD implementation of <a href="stats.html#topic+qnorm">qnorm</a>
</p>
</li>
<li> <p><code>qnorm(p = num, mean = num., sd = num., lower.tail = missing, log.p = missing)</code>: Default method
</p>
</li>
<li> <p><code>qgamma(
  p = ad,
  shape = ad,
  rate = missing,
  scale = ad.,
  lower.tail = missing,
  log.p = missing
)</code>: AD implementation of <a href="stats.html#topic+qgamma">qgamma</a>
</p>
</li>
<li> <p><code>qgamma(
  p = num,
  shape = num,
  rate = missing,
  scale = num.,
  lower.tail = missing,
  log.p = missing
)</code>: Default method
</p>
</li>
<li> <p><code>qexp(p = ad, rate = ad., lower.tail = missing, log.p = missing)</code>: AD implementation of <a href="stats.html#topic+qexp">qexp</a>
</p>
</li>
<li> <p><code>qexp(p = num, rate = num., lower.tail = missing, log.p = missing)</code>: Default method
</p>
</li>
<li> <p><code>qweibull(
  p = ad,
  shape = ad,
  scale = ad.,
  lower.tail = missing,
  log.p = missing
)</code>: AD implementation of <a href="stats.html#topic+qweibull">qweibull</a>
</p>
</li>
<li> <p><code>qweibull(
  p = num,
  shape = num,
  scale = num.,
  lower.tail = missing,
  log.p = missing
)</code>: Default method
</p>
</li>
<li> <p><code>qbeta(
  p = ad,
  shape1 = ad,
  shape2 = ad,
  ncp = missing,
  lower.tail = missing,
  log.p = missing
)</code>: AD implementation of <a href="stats.html#topic+qbeta">qbeta</a>
</p>
</li>
<li> <p><code>qbeta(
  p = num,
  shape1 = num,
  shape2 = num,
  ncp = missing,
  lower.tail = missing,
  log.p = missing
)</code>: Default method
</p>
</li>
<li> <p><code>besselK(x = ad, nu = ad, expon.scaled = missing)</code>: AD implementation of <a href="base.html#topic+besselK">besselK</a>
</p>
</li>
<li> <p><code>besselK(x = num, nu = num, expon.scaled = missing)</code>: Default method
</p>
</li>
<li> <p><code>besselI(x = ad, nu = ad, expon.scaled = missing)</code>: AD implementation of <a href="base.html#topic+besselI">besselI</a>
</p>
</li>
<li> <p><code>besselI(x = num, nu = num, expon.scaled = missing)</code>: Default method
</p>
</li>
<li> <p><code>besselJ(x = ad, nu = ad)</code>: AD implementation of <a href="base.html#topic+besselJ">besselJ</a>
</p>
</li>
<li> <p><code>besselJ(x = num, nu = num)</code>: Default method
</p>
</li>
<li> <p><code>besselY(x = ad, nu = ad)</code>: AD implementation of <a href="base.html#topic+besselY">besselY</a>
</p>
</li>
<li> <p><code>besselY(x = num, nu = num)</code>: Default method
</p>
</li>
<li> <p><code>dbinom_robust()</code>: AD implementation
</p>
</li>
<li> <p><code>dsn()</code>: AD implementation
</p>
</li>
<li> <p><code>dSHASHo()</code>: AD implementation
</p>
</li>
<li> <p><code>dtweedie()</code>: AD implementation
</p>
</li>
<li> <p><code>dnbinom2()</code>: AD implementation
</p>
</li>
<li> <p><code>dnbinom_robust()</code>: AD implementation
</p>
</li>
<li> <p><code>dlgamma()</code>: AD implementation
</p>
</li>
<li> <p><code>dnorm(x = ad, mean = ad., sd = ad., log = logical.)</code>: AD implementation of <a href="stats.html#topic+dnorm">dnorm</a>
</p>
</li>
<li> <p><code>dnorm(x = num, mean = num., sd = num., log = logical.)</code>: Default method
</p>
</li>
<li> <p><code>dnorm(x = osa, mean = ANY, sd = ANY, log = ANY)</code>: OSA implementation
</p>
</li>
<li> <p><code>dnorm(x = simref, mean = ANY, sd = ANY, log = ANY)</code>: Simulation implementation. Modifies <code>x</code> and returns zero.
</p>
</li>
<li> <p><code>plogis(
  q = advector,
  location = missing,
  scale = missing,
  lower.tail = missing,
  log.p = missing
)</code>: Minimal AD implementation of <a href="stats.html#topic+plogis">plogis</a>
</p>
</li>
<li> <p><code>qlogis(
  p = advector,
  location = missing,
  scale = missing,
  lower.tail = missing,
  log.p = missing
)</code>: Minimal AD implementation of <a href="stats.html#topic+qlogis">qlogis</a>
</p>
</li>
<li> <p><code>dcompois()</code>: Conway-Maxwell-Poisson. Calculate density.
</p>
</li>
<li> <p><code>dcompois2()</code>: Conway-Maxwell-Poisson. Calculate density parameterized via the mean.
</p>
</li>
<li> <p><code>pbinom(q = ad, size = ad, prob = ad, lower.tail = missing, log.p = missing)</code>: AD implementation of <a href="stats.html#topic+pbinom">pbinom</a>
</p>
</li>
<li> <p><code>pbinom(q = num, size = num, prob = num, lower.tail = missing, log.p = missing)</code>: Default method
</p>
</li>
<li> <p><code>dmultinom(x = ad, size = ad., prob = ad, log = logical.)</code>: AD implementation of <a href="stats.html#topic+dmultinom">dmultinom</a>
</p>
</li>
<li> <p><code>dmultinom(x = num, size = num., prob = num, log = logical.)</code>: Default method
</p>
</li>
<li> <p><code>dmultinom(x = osa, size = ANY, prob = ANY, log = ANY)</code>: OSA implementation
</p>
</li>
<li> <p><code>dmultinom(x = simref, size = ANY, prob = ANY, log = ANY)</code>: Simulation implementation. Modifies <code>x</code> and returns zero.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>MakeTape( function(x) pnorm(x), x=numeric(5))$jacobian(1:5)
</code></pre>

<hr>
<h2 id='expAv'>Matrix exponential of sparse matrix multiplied by a vector.</h2><span id='topic+expAv'></span>

<h3>Description</h3>

<p>Calculates <code>expm(A) %*% v</code> using plain series summation. The number of terms is determined adaptively when <code>uniformization=TRUE</code>.
The uniformization method essentially pushes the spectrum of the operator inside a zero centered disc, within which a uniform error bound is available.
If <code>A</code> is a generator matrix (i.e. <code>expm(A)</code> is a probability matrix) and if <code>v</code> is a probability vector, then the relative error of the result is bounded by <code>tol</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expAv(A, v, transpose = FALSE, uniformization = TRUE, tol = 1e-08, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expAv_+3A_a">A</code></td>
<td>
<p>Sparse matrix (usually a generator)</p>
</td></tr>
<tr><td><code id="expAv_+3A_v">v</code></td>
<td>
<p>Vector (or matrix)</p>
</td></tr>
<tr><td><code id="expAv_+3A_transpose">transpose</code></td>
<td>
<p>Calculate <code>expm(t(A)) %*% v</code> ? (faster due to the way sparse matrices are stored)</p>
</td></tr>
<tr><td><code id="expAv_+3A_uniformization">uniformization</code></td>
<td>
<p>Use uniformization method?</p>
</td></tr>
<tr><td><code id="expAv_+3A_tol">tol</code></td>
<td>
<p>Accuracy if A is a generator matrix and v a probability vector.</p>
</td></tr>
<tr><td><code id="expAv_+3A_...">...</code></td>
<td>
<p>Extra configuration parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional supported arguments via <code>...</code> currently include:
</p>

<ul>
<li> <p><code>Nmax</code> Use no more than this number of terms even if the spcified accuracy cannot be met.
</p>
</li>
<li> <p><code>warn</code> Give warning if number of terms is truncated by <code>Nmax</code>.
</p>
</li>
<li> <p><code>trace</code> Trace the number of terms when it adaptively changes.
</p>
</li></ul>



<h3>Value</h3>

<p>Vector (or matrix)
</p>


<h3>References</h3>

<p>Grassmann, W. K. (1977). Transient solutions in Markovian queueing systems. <em>Computers &amp; Operations Research</em>, 4(1), 47&ndash;53.
</p>
<p>Sherlock, C. (2021). Direct statistical inference for finite Markov jump processes via the matrix exponential. <em>Computational Statistics</em>, 36(4), 2863&ndash;2887.
</p>

<hr>
<h2 id='Interpolation'>Interpolation</h2><span id='topic+Interpolation'></span><span id='topic+interpol1Dfun'></span><span id='topic+interpol2Dfun'></span><span id='topic+splinefun+2CANY+2Cadvector+2CANY+2Cmissing-method'></span><span id='topic+splinefun+2Cadvector+2Cmissing+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Some interpolation methods are available to be used as part of 'RTMB' objective functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpol1Dfun(z, xlim = c(1, length(z)), ...)

interpol2Dfun(z, xlim = c(1, nrow(z)), ylim = c(1, ncol(z)), ...)

## S4 method for signature 'ANY,advector,ANY,missing'
splinefun(x, y, method = c("fmm", "periodic", "natural"))

## S4 method for signature 'advector,missing,ANY,missing'
splinefun(x, method = c("fmm", "periodic", "natural"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Interpolation_+3A_z">z</code></td>
<td>
<p>Matrix to be interpolated</p>
</td></tr>
<tr><td><code id="Interpolation_+3A_xlim">xlim</code></td>
<td>
<p>Domain of x</p>
</td></tr>
<tr><td><code id="Interpolation_+3A_...">...</code></td>
<td>
<p>Configuration parameters</p>
</td></tr>
<tr><td><code id="Interpolation_+3A_ylim">ylim</code></td>
<td>
<p>Domain of y</p>
</td></tr>
<tr><td><code id="Interpolation_+3A_x">x</code></td>
<td>
<p>spline x coordinates</p>
</td></tr>
<tr><td><code id="Interpolation_+3A_y">y</code></td>
<td>
<p>spline y coordinates</p>
</td></tr>
<tr><td><code id="Interpolation_+3A_method">method</code></td>
<td>
<p>Same as for the stats version, however only the three first are available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>interpol1Dfun</code> and <code>interpol2Dfun</code> are kernel smoothers useful in the case where you need a 3rd order <em>smooth</em> representation of a <em>data</em> vector or matrix.
A typical use case is when a high-resolution map needs to be accessed along a random effect trajectory.
Both 1D and 2D cases accept an 'interpolation radius' parameter (default R=2) controlling the degree of smoothness. Note, that only the value R=1 will match the data exactly, while higher radius trades accuracy for smoothness. Note also that these smoothers do not attempt to extrapolate: The returned value will be <code>NaN</code> outside the valid range (<code>xlim</code> / <code>ylim</code>).
</p>
<p><code>splinefun</code> imitates the corresponding <code>stats</code> function. The AD implementation (in contrast to <code>interpol1Dfun</code>) works for parameter dependent y-coordinates.
</p>


<h3>Value</h3>

<p>function of x.
</p>
<p>function of x and y.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>interpol1Dfun()</code>: Construct a kernel smoothed representation of a vector.
</p>
</li>
<li> <p><code>interpol2Dfun()</code>: Construct a kernel smoothed representation of a matrix.
</p>
</li>
<li> <p><code>splinefun(x = ANY, y = advector, method = ANY, ties = missing)</code>: Construct a spline function.
</p>
</li>
<li> <p><code>splinefun(x = advector, y = missing, method = ANY, ties = missing)</code>: Construct a spline function.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## ======= interpol1D
## R=1 =&gt; exact match of observations
f &lt;- interpol1Dfun(sin(1:10), R=1)
layout(t(1:2))
plot(sin(1:10))
plot(f, 1, 10, add=TRUE)
title("R=1")
F &lt;- MakeTape(f, 0)
F3 &lt;- F$jacfun()$jacfun()$jacfun()
plot(Vectorize(F3), 1, 10)
title("3rd derivative")
## ======= interpol2D
f &lt;- interpol2Dfun(volcano, xlim=c(0,1), ylim=c(0,1))
F &lt;- MakeTape(function(x) f(x[1],x[2]), c(.5,.5))
## ======= splinefun
T &lt;- MakeTape(function(x){
   S &lt;- splinefun(sin(x))
   S(4:6)
}, 1:10)
</code></pre>

<hr>
<h2 id='MVgauss'>Multivariate Gaussian densities</h2><span id='topic+MVgauss'></span><span id='topic+dmvnorm'></span><span id='topic+dgmrf'></span><span id='topic+dautoreg'></span><span id='topic+dseparable'></span><span id='topic+unstructured'></span>

<h3>Description</h3>

<p>Multivariate Gaussian densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvnorm(x, mu = 0, Sigma, log = FALSE, scale = 1)

dgmrf(x, mu = 0, Q, log = FALSE, scale = 1)

dautoreg(x, mu = 0, phi, log = FALSE, scale = 1)

dseparable(...)

unstructured(k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MVgauss_+3A_x">x</code></td>
<td>
<p>Density evaluation point</p>
</td></tr>
<tr><td><code id="MVgauss_+3A_mu">mu</code></td>
<td>
<p>Mean parameter vector</p>
</td></tr>
<tr><td><code id="MVgauss_+3A_sigma">Sigma</code></td>
<td>
<p>Covariance matrix</p>
</td></tr>
<tr><td><code id="MVgauss_+3A_log">log</code></td>
<td>
<p>Logical; Return log density?</p>
</td></tr>
<tr><td><code id="MVgauss_+3A_scale">scale</code></td>
<td>
<p>Extra scale parameter - see section 'Scaling'.</p>
</td></tr>
<tr><td><code id="MVgauss_+3A_q">Q</code></td>
<td>
<p>Sparse precision matrix</p>
</td></tr>
<tr><td><code id="MVgauss_+3A_phi">phi</code></td>
<td>
<p>Autoregressive parameters</p>
</td></tr>
<tr><td><code id="MVgauss_+3A_...">...</code></td>
<td>
<p>Log densities</p>
</td></tr>
<tr><td><code id="MVgauss_+3A_k">k</code></td>
<td>
<p>Dimension</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multivariate normal density evaluation is done using <code>dmvnorm()</code>. This is meant for dense covariance matrices. If <em>many evaluations</em> are needed for the <em>same covariance matrix</em> please note that you can pass matrix arguments: When <code>x</code> is a matrix the density is applied to each row of <code>x</code> and the return value will be a vector (length = <code>nrow(x)</code>) of densities.
</p>
<p>The function <code>dgmrf()</code> is essentially identical to <code>dmvnorm()</code> with the only difference that <code>dgmrf()</code> is specified via the <em>precision</em> matrix (inverse covariance) assuming that this matrix is <em>sparse</em>.
</p>
<p>Autoregressive density evaluation is implemented for all orders via <code>dautoreg()</code> (including the simplest AR1).
We note that this variant is for a <em>stationary</em>, <em>mean zero</em> and <em>variance one</em> process.
FIXME: Provide parameterization via partial correlations.
</p>
<p>Separable extension can be constructed for an unlimited number of inputs. Each input must be a function returning a <em>gaussian</em> <em>mean zero</em> <strong>log</strong> density. The output of <code>dseparable</code> is another <strong>log</strong> density which can be evaluated for array arguments. For example <code>dseparable(f1,f2,f3)</code> takes as input a 3D array <code>x</code>. <code>f1</code> acts in 1st array dimension of <code>x</code>, <code>f2</code> in 2nd dimension and so on. In addition to <code>x</code>, parameters <code>mu</code> and <code>scale</code> can be supplied - see below.
</p>


<h3>Value</h3>

<p>Vector of densities.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>dmvnorm()</code>: Multivariate normal distribution. <a href="#topic+OSA-residuals">OSA-residuals</a> can be used for argument <code>x</code>.
</p>
</li>
<li> <p><code>dgmrf()</code>: Multivariate normal distribution. OSA is <em>not</em> implemented.
</p>
</li>
<li> <p><code>dautoreg()</code>: Gaussian stationary mean zero AR(k) density
</p>
</li>
<li> <p><code>dseparable()</code>: Separable extension of Gaussian log-densities
</p>
</li>
<li> <p><code>unstructured()</code>: Helper to generate an unstructured correlation matrix to use with <code>dmvnorm</code>
</p>
</li></ul>


<h3>Scaling</h3>

<p>All the densities accept a <code>scale</code> argument which replaces <code>SCALE</code> and <code>VECSCALE</code> functionality of TMB.
Scaling is applied elementwise on the residual <code>x-mu</code>. This works as expected when <code>scale</code> is a <em>scalar</em> or a <em>vector</em> object of the same length as <code>x</code>.
In addition, <code>dmvnorm</code> and <code>dgmrf</code> can be scaled by a vector of length equal to the covariance/precision dimension. In this case the <code>scale</code> parameter is recycled by row to meet the special row-wise vectorization of these densities.
</p>


<h3>Unstructured correlation</h3>

<p>Replacement of <code>UNSTRUCTURED_CORR</code> functionality of TMB. Constuct object using <code>us &lt;- unstructured(k)</code>.
Now <code>us</code> has two methods: <code>x &lt;- us$parms()</code> gives the parameter vector used as input to the objective function, and <code>us$corr(x)</code> turns the parameter vector into an unstructured correlation matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>func &lt;- function(x, sd, parm, phi) {
   ## IID N(0, sd^2)
   f1 &lt;- function(x)sum(dnorm(x, sd=sd, log=TRUE))
   Sigma &lt;- diag(2) + parm
   ## MVNORM(0, Sigma)
   f2 &lt;- function(x)dmvnorm(x, Sigma=Sigma, log=TRUE)
   ## AR(2) process
   f3 &lt;- function(x)dautoreg(x, phi=phi, log=TRUE)
   ## Separable extension (implicit log=TRUE)
   -dseparable(f1, f2, f3)(x)
}
parameters &lt;- list(x = array(0, c(10, 2, 10)), sd=2, parm=1, phi=c(.9, -.2))
obj &lt;- MakeADFun(function(p)do.call(func, p), parameters, random="x")
## Check that density integrates to 1
obj$fn()
## Check that integral is independent of the outer parameters
obj$gr()
## Check that we can simulate from this density
s &lt;- obj$simulate()
</code></pre>

<hr>
<h2 id='OSA-residuals'>Recursive quantile residuals</h2><span id='topic+OSA-residuals'></span><span id='topic+oneStepPredict'></span><span id='topic++5B.osa'></span><span id='topic+length.osa'></span><span id='topic+dim.osa'></span><span id='topic+is.array.osa'></span><span id='topic+is.matrix.osa'></span>

<h3>Description</h3>

<p>OSA residuals are computed using the function
<code>oneStepPredict</code>. For this to work, you need to mark the
observation inside the objective function using the <a href="#topic+OBS">OBS</a>
function. Thereafter, residual calculation is as simple as
<code>oneStepPredict(obj)</code>. However, you probably want specify a
<code>method</code> to use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneStepPredict(
  obj,
  observation.name = names(obj$env$obs)[1],
  data.term.indicator = "_RTMB_keep_",
  ...
)

## S3 method for class 'osa'
x[...]

## S3 method for class 'osa'
length(x)

## S3 method for class 'osa'
dim(x)

## S3 method for class 'osa'
is.array(x)

## S3 method for class 'osa'
is.matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OSA-residuals_+3A_obj">obj</code></td>
<td>
<p>TMB model object (output from <code>MakeADFun</code>)</p>
</td></tr>
<tr><td><code id="OSA-residuals_+3A_observation.name">observation.name</code></td>
<td>
<p>Auto detected - use the default</p>
</td></tr>
<tr><td><code id="OSA-residuals_+3A_data.term.indicator">data.term.indicator</code></td>
<td>
<p>Auto detected - use the default</p>
</td></tr>
<tr><td><code id="OSA-residuals_+3A_...">...</code></td>
<td>
<p>Passed to <code>TMB::</code><a href="TMB.html#topic+oneStepPredict">oneStepPredict</a> - <b>please carefully read the documentation</b>, especially the <code>method</code> argument.</p>
</td></tr>
<tr><td><code id="OSA-residuals_+3A_x">x</code></td>
<td>
<p>Object of class 'osa'</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with standardized residuals; Same as <a href="TMB.html#topic+oneStepPredict">oneStepPredict</a>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>oneStepPredict()</code>: Calculate the residuals. See documentation of <code>TMB::</code><a href="TMB.html#topic+oneStepPredict">oneStepPredict</a>.
</p>
</li>
<li> <p><code>[</code>: Subset observations marked for OSA calculation.
This function makes sure that when you subset an observation of class <code>"osa"</code> such as
<code>obs &lt;- new("osa", x=advector(matrix(1:10,2)), keep = cbind(rep(TRUE,10),FALSE,FALSE))</code>
the 'keep' attribute will be adjusted accordingly
<code>obs[,1:2]</code>
</p>
</li>
<li> <p><code>length(osa)</code>: Equivalent of <a href="base.html#topic+length">length</a>
</p>
</li>
<li> <p><code>dim(osa)</code>: Equivalent of <a href="base.html#topic+dim">dim</a>
</p>
</li>
<li> <p><code>is.array(osa)</code>: Equivalent of <a href="base.html#topic+is.array">is.array</a>
</p>
</li>
<li> <p><code>is.matrix(osa)</code>: Equivalent of <a href="base.html#topic+is.matrix">is.matrix</a>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
rw &lt;- cumsum(.5*rnorm(20))
obs &lt;- rpois(20, lambda=exp(rw))
func &lt;- function(p) {
  obs &lt;- OBS(obs) ## Mark 'obs' for OSA calculation on request
  ans &lt;- 0
  jump &lt;- c(p$rw[1], diff(p$rw))
  ans &lt;- ans - sum(dnorm(jump, sd=p$sd, log=TRUE))
  ans &lt;- ans - sum(dpois(obs, lambda=exp(p$rw), log=TRUE))
  ans
}
obj &lt;- MakeADFun(func,
                 parameters=list(rw=rep(0,20), sd=1),
                 random="rw")
nlminb(obj$par, obj$fn, obj$gr)
res &lt;- oneStepPredict(obj,
                      method="oneStepGeneric",
                      discrete=TRUE,
                      range=c(0,Inf))$residual
</code></pre>

<hr>
<h2 id='RTMB-package'>RTMB: R bindings for 'TMB'</h2><span id='topic+RTMB-package'></span><span id='topic+RTMB'></span>

<h3>Description</h3>

<p>The package 'RTMB' provides a native R interface for <em>a subset of</em>
'TMB' so you can avoid coding in C++.  'RTMB' only affects the
'TMB' function 'MakeADFun' that builds the objective function. Once
'MakeADFun' has been invoked, everything else is <em>exactly the same</em>
and <em>models run as fast</em> as if coded in C++.
</p>


<h3>Details</h3>

<p>'RTMB' offers a greatly simplified interface to 'TMB'. The TMB objective function can now be written entirely in R rather than C++ (<a href="#topic+TMB-interface">TMB-interface</a>). In addition, we highlight two new simplifications:
</p>

<ol>
<li><p> For the most cases, simulation testing can be carried out <em>automatically</em> without the need to add simulation blocks (<a href="#topic+Simulation">Simulation</a>).
</p>
</li>
<li><p> Also, quantile residuals can be obtained without any essential modifications to the objective function (<a href="#topic+OSA-residuals">OSA-residuals</a>).
</p>
</li></ol>

<p>The introduction vignette describes these basic features - see <code>vignette("RTMB-introduction")</code>.
</p>
<p>In addition to the usual <a href="#topic+MakeADFun">MakeADFun</a> interface, 'RTMB' offers a lower level interface to the AD machinery (<code>MakeTape</code>). <a href="#topic+MakeTape">MakeTape</a> replaces the functionality you would normally get in 'TMB' using C++ functors, such as calculating derivatives inside the objective function.
</p>
<p>The advanced vignette covers these topics - see <code>vignette("RTMB-advanced")</code>.
</p>


<h3>Note</h3>

<p>'RTMB' relies heavily on the new AD framework 'TMBad' without which this interface would not be possible.
</p>


<h3>Author(s)</h3>

<p>Kasper Kristensen
</p>
<p>Maintainer: <a href="mailto:kaskr@dtu.dk">kaskr@dtu.dk</a>
</p>

<hr>
<h2 id='Simulation'>Simulation</h2><span id='topic+Simulation'></span><span id='topic+simref'></span><span id='topic+dim+3C-.simref'></span><span id='topic+length.simref'></span><span id='topic+dim.simref'></span><span id='topic+is.array.simref'></span><span id='topic+is.matrix.simref'></span><span id='topic+as.array.simref'></span><span id='topic+is.na.simref'></span><span id='topic++5B.simref'></span><span id='topic++5B+3C-.simref'></span><span id='topic+Ops.simref'></span><span id='topic+Math.simref'></span><span id='topic+t.simref'></span><span id='topic+diff.simref'></span><span id='topic+Summary.simref'></span>

<h3>Description</h3>

<p>An RTMB objective function can be run in 'simulation mode' where standard likelihood evaluation is replaced by corresponding random number generation. This facilitates automatic simulation under some restrictions. Simulations can be obtained directly from the model object by <code>obj$simulate()</code> or used indirectly via <a href="#topic+checkConsistency">checkConsistency</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simref(n)

## S3 replacement method for class 'simref'
dim(x) &lt;- value

## S3 method for class 'simref'
length(x)

## S3 method for class 'simref'
dim(x)

## S3 method for class 'simref'
is.array(x)

## S3 method for class 'simref'
is.matrix(x)

## S3 method for class 'simref'
as.array(x, ...)

## S3 method for class 'simref'
is.na(x)

## S3 method for class 'simref'
x[...]

## S3 replacement method for class 'simref'
x[...] &lt;- value

## S3 method for class 'simref'
Ops(e1, e2)

## S3 method for class 'simref'
Math(x, ...)

## S3 method for class 'simref'
t(x)

## S3 method for class 'simref'
diff(x, lag = 1L, differences = 1L, ...)

## S3 method for class 'simref'
Summary(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Simulation_+3A_n">n</code></td>
<td>
<p>Length</p>
</td></tr>
<tr><td><code id="Simulation_+3A_x">x</code></td>
<td>
<p>Object of class 'simref'</p>
</td></tr>
<tr><td><code id="Simulation_+3A_value">value</code></td>
<td>
<p>Replacement (numeric)</p>
</td></tr>
<tr><td><code id="Simulation_+3A_...">...</code></td>
<td>
<p>Extra arguments</p>
</td></tr>
<tr><td><code id="Simulation_+3A_e1">e1</code></td>
<td>
<p>First argument</p>
</td></tr>
<tr><td><code id="Simulation_+3A_e2">e2</code></td>
<td>
<p>Second argument</p>
</td></tr>
<tr><td><code id="Simulation_+3A_lag">lag</code></td>
<td>
<p>As <a href="base.html#topic+diff">diff</a></p>
</td></tr>
<tr><td><code id="Simulation_+3A_differences">differences</code></td>
<td>
<p>As <a href="base.html#topic+diff">diff</a></p>
</td></tr>
<tr><td><code id="Simulation_+3A_na.rm">na.rm</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In simulation mode all log density evaluation, involving either random effects or observations, is interpreted as probability assignment.
</p>
<p><b>direct vs indirect</b> Assignments can be 'direct' as for example
</p>
<p><code>dnorm(u, log=TRUE)      ## u ~ N(0, 1)</code>
</p>
<p>or 'indirect' as in
</p>
<p><code>dnorm(2*(u+1), log=TRUE)  ## u ~ N(-1, .25)</code>
</p>
<p>Indirect assignment works for a limited set of easily invertible functions - see <code>methods(class="simref")</code>.
</p>
<p><b>Simulation order</b> Note that probability assignments are sequential: All information required to draw a new variable must already be simulated.
Vectorized assignment implicitly occurs elementwise from left to right.
For example the assignment
</p>
<p><code>dnorm(diff(u), log=TRUE)</code>
</p>
<p>is not valid without a prior assignment of <code>u[1]</code>, e.g.
</p>
<p><code>dnorm(u[1], log=TRUE)</code>
</p>
<p><b>Supported distributions</b> Assignment must use supported density functions. I.e.
</p>
<p><code>dpois(N, exp(u), log=TRUE)</code>
</p>
<p>cannot be replaced by
</p>
<p><code>N * u - exp(u)</code>
</p>
<p>The latter will have no effect in simulation mode (the simulation will be <code>NA</code>).
</p>
<p><b>Return value</b> Note that when in simulation mode, the density functions all return zero. The actual simulation is written to the input argument by reference. This is very unlike standard R semantics.
</p>


<h3>Value</h3>

<p>An object with write access to store the simulation.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>simref()</code>: Construct <code>simref</code>
</p>
</li>
<li> <p><code>dim(simref) &lt;- value</code>: Equivalent of <a href="base.html#topic+dim+3C-">dim&lt;-</a>
</p>
</li>
<li> <p><code>length(simref)</code>: Equivalent of <a href="base.html#topic+length">length</a>
</p>
</li>
<li> <p><code>dim(simref)</code>: Equivalent of <a href="base.html#topic+dim">dim</a>
</p>
</li>
<li> <p><code>is.array(simref)</code>: Equivalent of <a href="base.html#topic+is.array">is.array</a>
</p>
</li>
<li> <p><code>is.matrix(simref)</code>: Equivalent of <a href="base.html#topic+is.matrix">is.matrix</a>
</p>
</li>
<li> <p><code>as.array(simref)</code>: Equivalent of <a href="base.html#topic+as.array">as.array</a>
</p>
</li>
<li> <p><code>is.na(simref)</code>: Equivalent of <a href="base.html#topic+is.na">is.na</a>
</p>
</li>
<li> <p><code>[</code>: Equivalent of <a href="base.html#topic++5B">[</a>
</p>
</li>
<li> <p><code>`[`(simref) &lt;- value</code>: Equivalent of <a href="base.html#topic++5B+3C-">[&lt;-</a>
</p>
</li>
<li> <p><code>Ops(simref)</code>: Equivalent of <a href="base.html#topic+Ops">Ops</a>
</p>
</li>
<li> <p><code>Math(simref)</code>: Equivalent of <a href="base.html#topic+Math">Math</a>
</p>
</li>
<li> <p><code>t(simref)</code>: Equivalent of <a href="base.html#topic+t">t</a>
</p>
</li>
<li> <p><code>diff(simref)</code>: Equivalent of <a href="base.html#topic+diff">diff</a>
</p>
</li>
<li> <p><code>Summary(simref)</code>: <a href="methods.html#topic+Summary">Summary</a> operations are not invertible and will throw an error.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- simref(4)
s2 &lt;- 2 * s[1:2] + 1
s2[] &lt;- 7
s ## 3 3 NA NA
## Random walk
func &lt;- function(p) {
  u &lt;- p$u
  ans &lt;- -dnorm(u[1], log=TRUE) ## u[1] ~ N(0,1)
  ans &lt;- ans - sum(dnorm(diff(u), log=TRUE)) ## u[i]-u[i-1] ~ N(0,1)
}
obj &lt;- MakeADFun(func, list(u=numeric(20)), random="u")
obj$simulate()
</code></pre>

<hr>
<h2 id='Tape'>The AD tape</h2><span id='topic+Tape'></span><span id='topic+MakeTape'></span><span id='topic++24.Tape'></span><span id='topic+print.Tape'></span><span id='topic+TapeConfig'></span><span id='topic+DataEval'></span><span id='topic+GetTape'></span>

<h3>Description</h3>

<p>The AD tape as an R function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeTape(f, x)

## S3 method for class 'Tape'
x$name

## S3 method for class 'Tape'
print(x, ...)

TapeConfig(
  comparison = c("forbid", "tape", "allow"),
  atomic = c("enable", "disable"),
  vectorize = c("disable", "enable")
)

DataEval(f, x)

GetTape(obj, name = c("ADFun", "ADGrad", "ADHess"), warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tape_+3A_f">f</code></td>
<td>
<p>R function</p>
</td></tr>
<tr><td><code id="Tape_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="Tape_+3A_name">name</code></td>
<td>
<p>Name of a tape method</p>
</td></tr>
<tr><td><code id="Tape_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="Tape_+3A_comparison">comparison</code></td>
<td>
<p>Set behaviour of AD comparison (<code>"&gt;"</code>,<code>"=="</code>, etc).</p>
</td></tr>
<tr><td><code id="Tape_+3A_atomic">atomic</code></td>
<td>
<p>Set behaviour of AD BLAS operations (notably matrix multiply).</p>
</td></tr>
<tr><td><code id="Tape_+3A_vectorize">vectorize</code></td>
<td>
<p>Enable/disable AD vectorized 'Ops' and 'Math'.</p>
</td></tr>
<tr><td><code id="Tape_+3A_obj">obj</code></td>
<td>
<p>Output from <code>MakeADFun</code></p>
</td></tr>
<tr><td><code id="Tape_+3A_warn">warn</code></td>
<td>
<p>Give warning if <code>obj</code> was created using another DLL?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A 'Tape' is a representation of a function that accepts <em>fixed size</em> numeric input and returns <em>fixed size</em> numeric output.
The tape can be constructed using <code>F &lt;- MakeTape(f, x)</code> where <code>f</code> is a standard <em>differentiable</em> R function (or more precisely: One using only functions that are documented to work for AD types).
Having constructed a tape F, a number of methods are available:
</p>
<p>Evaluation:
</p>

<ul>
<li><p> Normal function evaluation 'F(x)' for numeric input.
</p>
</li>
<li><p> AD evaluation 'F(x)' as part of other tapes.
</p>
</li>
<li><p> Jacobian calculations using 'F$jacobian(x)'.
</p>
</li></ul>

<p>Transformation:
</p>

<ul>
<li><p> Jacobian function transformation 'F$jacfun()'
</p>
</li>
<li><p> Laplace approximation transformation 'F$laplace()'. Also allows Saddle Point Approximation (SPA).
</p>
</li></ul>



<h3>Value</h3>

<p>Object of class <code>"Tape"</code>.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>$</code>: Get a tape method.
</p>
</li>
<li> <p><code>print(Tape)</code>: Print method
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>MakeTape()</code>: Generate a 'Tape' of an R function.
</p>
</li>
<li> <p><code>TapeConfig()</code>: Global configuration parameters of the tape (experts only!)
<b>comparison</b> By default, AD comparison gives an error
(<code>comparison="forbid"</code>).
This is the safe and recommended behaviour, because comparison is a
non-differentiable operation. If you are building a tape that
requires indicator functions e.g. <code>f(x)*(x&lt;0)+g(x)*(x&gt;=0)</code>
then use <code>comparison="tape"</code> to add the indicators to the
tape. A final option <code>comparison="allow"</code> exists for
testing/illustration purposes. Do not use.
</p>
</li>
<li> <p><code>DataEval()</code>: Move a chunk of data from R to the tape by evaluating a normal R function (replaces TMB functionality 'DATA_UPDATE').
</p>
</li>
<li> <p><code>GetTape()</code>: Extract tapes from a model object created by <code>MakeADFun</code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>F &lt;- MakeTape(prod, numeric(3))
show(F)
F$print()
H &lt;- F$jacfun()$jacfun() ## Hessian tape
show(H)
#### Handy way to plot the graph of F
if (requireNamespace("igraph")) {
   G &lt;- igraph::graph_from_adjacency_matrix(F$graph())
   plot(G, vertex.size=17, layout=igraph::layout_as_tree)
}
## Taped access of an element of 'rivers' dataset
F &lt;- MakeTape(function(i) DataEval( function(i) rivers[i] , i), 1 )
F(1)
F(2)
</code></pre>

<hr>
<h2 id='TMB-interface'>Interface to TMB</h2><span id='topic+TMB-interface'></span><span id='topic+MakeADFun'></span><span id='topic+sdreport'></span><span id='topic+ADREPORT'></span><span id='topic+REPORT'></span><span id='topic+getAll'></span><span id='topic+OBS'></span><span id='topic+checkConsistency'></span>

<h3>Description</h3>

<p>Interface to TMB
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeADFun(
  func,
  parameters,
  random = NULL,
  profile = NULL,
  integrate = NULL,
  map = list(),
  ADreport = FALSE,
  silent = FALSE,
  ridge.correct = FALSE,
  ...
)

sdreport(obj, ...)

ADREPORT(x)

REPORT(x)

getAll(..., warn = TRUE)

OBS(x)

checkConsistency(obj, fast = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TMB-interface_+3A_func">func</code></td>
<td>
<p>Function taking a parameter list (or parameter vector) as input.</p>
</td></tr>
<tr><td><code id="TMB-interface_+3A_parameters">parameters</code></td>
<td>
<p>Parameter list (or parameter vector) used by <code>func</code>.</p>
</td></tr>
<tr><td><code id="TMB-interface_+3A_random">random</code></td>
<td>
<p>As <a href="TMB.html#topic+MakeADFun">MakeADFun</a>.</p>
</td></tr>
<tr><td><code id="TMB-interface_+3A_profile">profile</code></td>
<td>
<p>As <a href="TMB.html#topic+MakeADFun">MakeADFun</a>.</p>
</td></tr>
<tr><td><code id="TMB-interface_+3A_integrate">integrate</code></td>
<td>
<p>As <a href="TMB.html#topic+MakeADFun">MakeADFun</a>.</p>
</td></tr>
<tr><td><code id="TMB-interface_+3A_map">map</code></td>
<td>
<p>As <a href="TMB.html#topic+MakeADFun">MakeADFun</a>.</p>
</td></tr>
<tr><td><code id="TMB-interface_+3A_adreport">ADreport</code></td>
<td>
<p>As <a href="TMB.html#topic+MakeADFun">MakeADFun</a>.</p>
</td></tr>
<tr><td><code id="TMB-interface_+3A_silent">silent</code></td>
<td>
<p>As <a href="TMB.html#topic+MakeADFun">MakeADFun</a>.</p>
</td></tr>
<tr><td><code id="TMB-interface_+3A_ridge.correct">ridge.correct</code></td>
<td>
<p>Experimental</p>
</td></tr>
<tr><td><code id="TMB-interface_+3A_...">...</code></td>
<td>
<p>Passed to TMB</p>
</td></tr>
<tr><td><code id="TMB-interface_+3A_obj">obj</code></td>
<td>
<p>TMB model object (output from <a href="#topic+MakeADFun">MakeADFun</a>)</p>
</td></tr>
<tr><td><code id="TMB-interface_+3A_x">x</code></td>
<td>
<p>Observation object</p>
</td></tr>
<tr><td><code id="TMB-interface_+3A_warn">warn</code></td>
<td>
<p>Give a warning if overwriting an existing object?</p>
</td></tr>
<tr><td><code id="TMB-interface_+3A_fast">fast</code></td>
<td>
<p>Pass <code>observation.name</code> to <code>TMB</code> ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TMB model object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>MakeADFun()</code>: Interface to <a href="TMB.html#topic+MakeADFun">MakeADFun</a>.
</p>
</li>
<li> <p><code>sdreport()</code>: Interface to <a href="TMB.html#topic+sdreport">sdreport</a>.
</p>
</li>
<li> <p><code>ADREPORT()</code>: Can be used inside the objective function to report quantities for which uncertainties will be calculated by <a href="#topic+sdreport">sdreport</a>.
</p>
</li>
<li> <p><code>REPORT()</code>: Can be used inside the objective function to report quantities via the model object using <code>obj$report()</code>.
</p>
</li>
<li> <p><code>getAll()</code>: Can be used to assign all parameter or data objects from a list inside the objective function.
</p>
</li>
<li> <p><code>OBS()</code>: Mark the observation to be used by either <code>oneStepPredict</code> or by <code>obj$simulate</code>.
If your objective function is using an observation <code>x</code>, you simply need
to run <code>x &lt;- OBS(x)</code> <em>inside the objective function</em>.
This will (1) allow <code>oneStepPredict</code> to change the class of <code>x</code> to
<code>"osa"</code> (<a href="#topic+OSA-residuals">OSA-residuals</a>) or (2) allow <code>obj$simulate</code> to change the class of <code>x</code> to
<code>"simref"</code> (<a href="#topic+Simulation">Simulation</a>) on request.
</p>
</li>
<li> <p><code>checkConsistency()</code>: Interface to <a href="TMB.html#topic+checkConsistency">checkConsistency</a>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>data(rivers)
f &lt;- function(p) { -sum(dnorm(rivers, p$mu, p$sd, log=TRUE)) }
obj &lt;- MakeADFun(f, list(mu=0, sd=1), silent=TRUE)
opt &lt;- nlminb(obj$par, obj$fn, obj$gr)
sdreport(obj)
## 'REML trick'
obj2 &lt;- MakeADFun(f, list(mu=0, sd=1), random="mu", silent=TRUE)
opt2 &lt;- nlminb(obj2$par, obj2$fn, obj2$gr)
sdreport(obj2) ## Compare with sd(rivers)
## Single argument vector function with numeric 'parameters'
fr &lt;- function(x) {   ## Rosenbrock Banana function
    x1 &lt;- x[1]
    x2 &lt;- x[2]
    100 * (x2 - x1 * x1)^2 + (1 - x1)^2
}
obj &lt;- MakeADFun(fr, numeric(2), silent=TRUE)
nlminb(c(-1.2, 1), obj$fn, obj$gr, obj$he)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
