<!DOCTYPE html><html><head><title>Help for package greed</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {greed}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Alg-class'><p>Abstract optimization algorithm class</p></a></li>
<li><a href='#available_algorithms'><p>Display the list of every currently available optimization algorithm</p></a></li>
<li><a href='#available_models'><p>Display the list of every currently available DLVM</p></a></li>
<li><a href='#Books'><p>Books about US politics network dataset</p></a></li>
<li><a href='#clustering'><p>Method to extract the clustering results from an <code>IclFit-class</code> object</p></a></li>
<li><a href='#coef,DcLbmFit-method'><p>Extract parameters from an <code>DcLbmFit-class</code> object</p></a></li>
<li><a href='#coef,DcSbmFit-method'><p>Extract parameters from an <code>DcSbmFit-class</code> object</p></a></li>
<li><a href='#coef,DiagGmmFit-method'><p>Extract mixture parameters from <code>DiagGmmFit-class</code> object</p></a></li>
<li><a href='#coef,GmmFit-method'><p>Extract mixture parameters from <code>GmmFit-class</code> object</p></a></li>
<li><a href='#coef,IclFit-method'><p>Extract parameters from an <code>IclFit-class</code> object</p></a></li>
<li><a href='#coef,LcaFit-method'><p>Extract parameters from an <code>LcaFit-class</code> object</p></a></li>
<li><a href='#coef,MoMFit-method'><p>Extract parameters from an <code>MoMFit-class</code> object</p></a></li>
<li><a href='#coef,MoRFit-method'><p>Extract mixture parameters from <code>MoRFit-class</code> object using MAP estimation</p></a></li>
<li><a href='#coef,MultSbmFit-method'><p>Extract parameters from an <code>MultSbmFit-class</code> object</p></a></li>
<li><a href='#coef,SbmFit-method'><p>Extract parameters from an <code>SbmFit-class</code> object</p></a></li>
<li><a href='#CombinedModels'><p>Combined Models classes</p></a></li>
<li><a href='#CombinedModelsFit-class'><p>Combined Models fit results class</p></a></li>
<li><a href='#CombinedModelsPath-class'><p>Combined Models hierarchical fit results class</p></a></li>
<li><a href='#cut,DcLbmPath-method'><p>Method to cut a DcLbmPath solution to a desired number of cluster</p></a></li>
<li><a href='#cut,IclPath-method'><p>Generic method to cut a path solution to a desired number of cluster</p></a></li>
<li><a href='#DcLbm'><p>Degree Corrected Latent Block Model for bipartite graph class</p></a></li>
<li><a href='#DcLbmFit-class'><p>Degree corrected Latent Block Model fit results class</p></a></li>
<li><a href='#DcLbmPath-class'><p>Degree corrected Latent Block Model hierarchical fit results class</p></a></li>
<li><a href='#DcSbm'><p>Degree Corrected Stochastic Block Model Prior class</p></a></li>
<li><a href='#DcSbmFit-class'><p>Degree Corrected Stochastic Block Model fit results class</p></a></li>
<li><a href='#DcSbmPath-class'><p>Degree Corrected Stochastic Block Model hierarchical fit results class</p></a></li>
<li><a href='#DiagGmm'><p>Diagonal Gaussian Mixture Model Prior description class</p></a></li>
<li><a href='#DiagGmmFit-class'><p>Diagonal Gaussian mixture model fit results class</p></a></li>
<li><a href='#DiagGmmPath-class'><p>Diagonal Gaussian mixture model hierarchical fit results class</p></a></li>
<li><a href='#DlvmCoPrior-class'><p>Abstract class to represent a generative model for co-clustering</p></a></li>
<li><a href='#DlvmPrior-class'><p>Abstract class to represent a generative model for clustering</p></a></li>
<li><a href='#extractSubModel'><p>Extract a part of a <code>CombinedModelsPath-class</code> object</p></a></li>
<li><a href='#fashion'><p>Fashion mnist dataset</p></a></li>
<li><a href='#Fifa'><p>Fifa data</p></a></li>
<li><a href='#Football'><p>American College football network dataset</p></a></li>
<li><a href='#Genetic-class'><p>Genetic optimization algorithm</p></a></li>
<li><a href='#Gmm'><p>Gaussian Mixture Model Prior description class</p></a></li>
<li><a href='#GmmFit-class'><p>Gaussian mixture model fit results class</p></a></li>
<li><a href='#gmmpairs'><p>Make a matrix of plots with a given data and gmm fitted parameters</p></a></li>
<li><a href='#GmmPath-class'><p>Gaussian mixture model hierarchical fit results class</p></a></li>
<li><a href='#greed'><p>Model based hierarchical clustering</p></a></li>
<li><a href='#H'><p>Compute the entropy of a discrete sample</p></a></li>
<li><a href='#Hybrid-class'><p>Hybrid optimization algorithm</p></a></li>
<li><a href='#ICL'><p>Generic method to extract the ICL value from an <code>IclFit-class</code> object</p></a></li>
<li><a href='#IclFit-class'><p>Abstract class to represent a clustering result</p></a></li>
<li><a href='#IclPath-class'><p>Abstract class to represent a hierarchical clustering result</p></a></li>
<li><a href='#Jazz'><p>Jazz musicians network dataset</p></a></li>
<li><a href='#K'><p>Generic method to get the number of clusters from an <code>IclFit-class</code> object</p></a></li>
<li><a href='#Lca'><p>Latent Class Analysis Model Prior class</p></a></li>
<li><a href='#LcaFit-class'><p>Latent Class  Analysis fit results class</p></a></li>
<li><a href='#LcaPath-class'><p>Latent Class Analysis hierarchical fit results class</p></a></li>
<li><a href='#MI'><p>Compute the mutual information of two discrete samples</p></a></li>
<li><a href='#MoM'><p>Mixture of Multinomial Model Prior description class</p></a></li>
<li><a href='#MoMFit-class'><p>Mixture of Multinomial fit results class</p></a></li>
<li><a href='#MoMPath-class'><p>Mixture of Multinomial hierarchical fit results class</p></a></li>
<li><a href='#MoR'><p>Multivariate mixture of regression Prior model description class</p></a></li>
<li><a href='#MoRFit-class'><p>Clustering with a multivariate mixture of regression model fit results class</p></a></li>
<li><a href='#MoRPath-class'><p>Multivariate mixture of regression model hierarchical fit results class</p></a></li>
<li><a href='#Multistarts-class'><p>Greedy algorithm with multiple start class</p></a></li>
<li><a href='#MultSbm'><p>Multinomial Stochastic Block Model Prior class</p></a></li>
<li><a href='#MultSbmFit-class'><p>Multinomial Stochastic Block Model fit results class</p></a></li>
<li><a href='#MultSbmPath-class'><p>Multinomial Stochastic Block Model hierarchical fit results class</p></a></li>
<li><a href='#mushroom'><p>Mushroom data</p></a></li>
<li><a href='#Ndrangheta'><p>Ndrangheta mafia covert network dataset</p></a></li>
<li><a href='#NewGuinea'><p>NewGuinea data</p></a></li>
<li><a href='#NMI'><p>Compute the normalized mutual information of two discrete samples</p></a></li>
<li><a href='#plot,DcLbmFit,missing-method'><p>Plot a <code>DcLbmFit-class</code></p></a></li>
<li><a href='#plot,DcLbmPath,missing-method'><p>Plot a <code>DcLbmPath-class</code></p></a></li>
<li><a href='#plot,DcSbmFit,missing-method'><p>Plot a <code>DcSbmFit-class</code> object</p></a></li>
<li><a href='#plot,DiagGmmFit,missing-method'><p>Plot a <code>DiagGmmFit-class</code> object</p></a></li>
<li><a href='#plot,GmmFit,missing-method'><p>Plot a <code>GmmFit-class</code> object</p></a></li>
<li><a href='#plot,IclPath,missing-method'><p>Plot an <code>IclPath-class</code> object</p></a></li>
<li><a href='#plot,LcaFit,missing-method'><p>Plot a <code>LcaFit-class</code> object</p></a></li>
<li><a href='#plot,MoMFit,missing-method'><p>Plot a <code>MoMFit-class</code> object</p></a></li>
<li><a href='#plot,MultSbmFit,missing-method'><p>Plot a <code>MultSbmFit-class</code> object</p></a></li>
<li><a href='#plot,SbmFit,missing-method'><p>Plot a <code>SbmFit-class</code> object</p></a></li>
<li><a href='#prior'><p>Generic method to extract the prior used to fit <code>IclFit-class</code> object</p></a></li>
<li><a href='#rdcsbm'><p>Generates graph adjacency matrix using a degree corrected SBM</p></a></li>
<li><a href='#rlbm'><p>Generate a data matrix using a Latent Block Model</p></a></li>
<li><a href='#rlca'><p>Generate data from lca model</p></a></li>
<li><a href='#rmm'><p>Generate data using a Multinomial Mixture</p></a></li>
<li><a href='#rmreg'><p>Generate data from a mixture of regression model</p></a></li>
<li><a href='#rmultsbm'><p>Generate a graph adjacency matrix using a Stochastic Block Model</p></a></li>
<li><a href='#rsbm'><p>Generate a graph adjacency matrix using a Stochastic Block Model</p></a></li>
<li><a href='#Sbm'><p>Stochastic Block Model Prior class</p></a></li>
<li><a href='#SbmFit-class'><p>Stochastic Block Model fit results class</p></a></li>
<li><a href='#SbmPath-class'><p>Stochastic Block Model hierarchical fit results class</p></a></li>
<li><a href='#Seed-class'><p>Greedy algorithm with seeded initialization</p></a></li>
<li><a href='#SevenGraders'><p>SevenGraders data</p></a></li>
<li><a href='#show,IclFit-method'><p>Show an IclPath object</p></a></li>
<li><a href='#spectral'><p>Regularized spectral clustering</p></a></li>
<li><a href='#to_multinomial'><p>Convert a binary adjacency matrix with missing value to a cube</p></a></li>
<li><a href='#Youngpeoplesurvey'><p>Young People survey data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Clustering and Model Selection with the Integrated
Classification Likelihood</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-27</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://comeetie.github.io/greed/">https://comeetie.github.io/greed/</a>,
<a href="https://github.com/comeetie/greed">https://github.com/comeetie/greed</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/comeetie/greed/issues">https://github.com/comeetie/greed/issues</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Etienne Côme &lt;etienne.come@univ-eiffel.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An ensemble of algorithms that enable the clustering of networks and data matrices (such as counts, categorical or continuous) with different type of generative models. Model selection and clustering is performed in combination by optimizing the Integrated Classification Likelihood (which is equivalent to minimizing the description length). Several models are available such as: Stochastic Block Model, degree corrected Stochastic Block Model, Mixtures of Multinomial, Latent Block Model. The optimization is performed thanks to a combination of greedy local search and a genetic algorithm (see &lt;arXiv:2002:11577&gt; for more details).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.0), Matrix, future, listenv, ggplot2, graphics,
methods, stats,RSpectra,grid,gtable,gridExtra,cba,cli</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, MASS, knitr, rmarkdown, spelling, igraph,
tidygraph, ggraph</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2.9000</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'tools_misc.R' 'models_classes.R'
'fit_classes.R' 'tools_cleanpath.R' 'alg_genetic.R'
'alg_hybrid.R' 'alg_classes.R' 'alg_multistart.R' 'data.R'
'greed.R' 'model_combinedmodels.R' 'model_dclbm.R'
'model_dcsbm.R' 'model_diaggmm.R' 'model_gmm.R' 'model_lca.R'
'model_mom.R' 'model_mor.R' 'model_multsbm.R' 'model_sbm.R'
'tools_generator.R' 'tools_ploting.R'</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-03 10:12:02 UTC; comeetie</td>
</tr>
<tr>
<td>Author:</td>
<td>Etienne Côme [aut, cre],
  Nicolas Jouvin [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-03 22:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='Alg-class'>Abstract optimization algorithm class</h2><span id='topic+Alg-class'></span>

<h3>Description</h3>

<p>An S4 class to represent an abstract optimization algorithm.
</p>

<hr>
<h2 id='available_algorithms'>Display the list of every currently available optimization algorithm</h2><span id='topic+available_algorithms'></span>

<h3>Description</h3>

<p>Display the list of every currently available optimization algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>available_algorithms()
</code></pre>

<hr>
<h2 id='available_models'>Display the list of every currently available DLVM</h2><span id='topic+available_models'></span>

<h3>Description</h3>

<p>Display the list of every currently available DLVM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>available_models()
</code></pre>

<hr>
<h2 id='Books'>Books about US politics network dataset</h2><span id='topic+Books'></span>

<h3>Description</h3>

<p>A network of books about US politics published around the time of the 2004 presidential election and sold by the online bookseller Amazon.com. Edges between books represent frequent co-purchasing of books by the same buyers.
The network was compiled by V. Krebs and is unpublished, but can found on Krebs' web site. Thanks to Valdis Krebs for permission to post these data on this web site.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Books)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> with two fields;
</p>

<dl>
<dt>X</dt><dd><p>network adjacency matrix as a <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code> of size 105x105</p>
</dd>
<dt>label</dt><dd><p> a factor of length  (size 105) with levels &quot;l&quot;, &quot;n&quot;, or &quot;c&quot; to indicate whether the books are liberal, neutral, or conservative</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(Books)
</code></pre>

<hr>
<h2 id='clustering'>Method to extract the clustering results from an <code><a href="#topic+IclFit-class">IclFit-class</a></code> object</h2><span id='topic+clustering'></span><span id='topic+clustering+2CIclFit-method'></span>

<h3>Description</h3>

<p>This method take a <code><a href="#topic+IclFit-class">IclFit-class</a></code> object and return an integer vector with the cluster assignments that were found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustering(fit)

## S4 method for signature 'IclFit'
clustering(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustering_+3A_fit">fit</code></td>
<td>
<p>an <code>IclFit</code> solution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector with cluster assignments. Zero indicates noise points.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>IclFit</code>: IclFit-class method
</p>
</li></ul>

<hr>
<h2 id='coef+2CDcLbmFit-method'>Extract parameters from an <code><a href="#topic+DcLbmFit-class">DcLbmFit-class</a></code> object</h2><span id='topic+coef+2CDcLbmFit-method'></span>

<h3>Description</h3>

<p>Extract parameters from an <code><a href="#topic+DcLbmFit-class">DcLbmFit-class</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DcLbmFit'
coef(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef+2B2CDcLbmFit-method_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+DcLbmFit-class">DcLbmFit-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the model parameters estimates (MAP), the fields are:
</p>

<ul>
<li> <p><code>'pirows'</code>: row cluster proportions
</p>
</li>
<li> <p><code>'picols'</code>: row cluster proportions
</p>
</li>
<li> <p><code>'thetakl'</code>: between clusters connection probabilities (matrix of size Krow x Kcol),
</p>
</li>
<li> <p><code>'gammarows'</code>: rows degree correction parameters (size Nrows),
</p>
</li>
<li> <p><code>'gammacols'</code>: cols degree correction parameters (size Ncols),
</p>
</li></ul>


<hr>
<h2 id='coef+2CDcSbmFit-method'>Extract parameters from an <code><a href="#topic+DcSbmFit-class">DcSbmFit-class</a></code> object</h2><span id='topic+coef+2CDcSbmFit-method'></span>

<h3>Description</h3>

<p>Extract parameters from an <code><a href="#topic+DcSbmFit-class">DcSbmFit-class</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DcSbmFit'
coef(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef+2B2CDcSbmFit-method_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+DcSbmFit-class">DcSbmFit-class</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>in case of undirected graph
</p>


<h3>Value</h3>

<p>a list with the model parameters estimates (MAP), the fields are the following for &quot;directed&quot; models :
</p>

<ul>
<li> <p><code>'pi'</code>: cluster proportions
</p>
</li>
<li> <p><code>'thetakl'</code>: between cluster normalized connection intensities (matrix of size K x K),
</p>
</li>
<li> <p><code>gammain</code>: node in-degree correction parameter
</p>
</li>
<li> <p><code>gammaout</code>: node out-degree correction parameter
</p>
</li></ul>

<p>And as follow for un-directed models :
#' </p>

<ul>
<li> <p><code>'pi'</code>: cluster proportions
</p>
</li>
<li> <p><code>'thetakl'</code>: between cluster normalized connection intensities (matrix of size K x K),
</p>
</li>
<li> <p><code>gamma</code>: node degree correction parameter
</p>
</li></ul>


<hr>
<h2 id='coef+2CDiagGmmFit-method'>Extract mixture parameters from <code><a href="#topic+DiagGmmFit-class">DiagGmmFit-class</a></code> object</h2><span id='topic+coef+2CDiagGmmFit-method'></span>

<h3>Description</h3>

<p>Extract mixture parameters from <code><a href="#topic+DiagGmmFit-class">DiagGmmFit-class</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DiagGmmFit'
coef(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef+2B2CDiagGmmFit-method_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+DiagGmmFit-class">DiagGmmFit-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the mixture parameters estimates (MAP), the fields are:
</p>

<ul>
<li> <p><code>'pi'</code>: cluster proportions
</p>
</li>
<li> <p><code>'muk'</code>: cluster means
</p>
</li>
<li> <p><code>'Sigmak'</code>: cluster co-variance matrices
</p>
</li></ul>


<hr>
<h2 id='coef+2CGmmFit-method'>Extract mixture parameters from <code><a href="#topic+GmmFit-class">GmmFit-class</a></code> object</h2><span id='topic+coef+2CGmmFit-method'></span>

<h3>Description</h3>

<p>Extract mixture parameters from <code><a href="#topic+GmmFit-class">GmmFit-class</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GmmFit'
coef(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef+2B2CGmmFit-method_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+GmmFit-class">GmmFit-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the mixture parameters estimates (MAP), the fields are:
</p>

<ul>
<li> <p><code>'pi'</code>: cluster proportions
</p>
</li>
<li> <p><code>'muk'</code>: cluster means
</p>
</li>
<li> <p><code>'Sigmak'</code>: cluster co-variance matrices
</p>
</li></ul>


<hr>
<h2 id='coef+2CIclFit-method'>Extract parameters from an <code><a href="#topic+IclFit-class">IclFit-class</a></code> object</h2><span id='topic+coef+2CIclFit-method'></span>

<h3>Description</h3>

<p>Extract parameters from an <code><a href="#topic+IclFit-class">IclFit-class</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'IclFit'
coef(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef+2B2CIclFit-method_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+IclFit-class">IclFit-class</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The results depends of the used model, in case the method is not yet implemented for a model, this generic method will be used. Which will return the <code>obs_stats</code> slot of the model.
</p>


<h3>Value</h3>

<p>a list with the model parameters estimates (MAP)
</p>

<hr>
<h2 id='coef+2CLcaFit-method'>Extract parameters from an <code><a href="#topic+LcaFit-class">LcaFit-class</a></code> object</h2><span id='topic+coef+2CLcaFit-method'></span>

<h3>Description</h3>

<p>Extract parameters from an <code><a href="#topic+LcaFit-class">LcaFit-class</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LcaFit'
coef(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef+2B2CLcaFit-method_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+LcaFit-class">LcaFit-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the model parameters estimates (MAP), the fields are:
</p>

<ul>
<li> <p><code>'pi'</code>: cluster proportions
</p>
</li>
<li> <p><code>'thetav'</code>: cluster profile probabilities (list of matrix of size K x Dv),
</p>
</li></ul>


<hr>
<h2 id='coef+2CMoMFit-method'>Extract parameters from an <code><a href="#topic+MoMFit-class">MoMFit-class</a></code> object</h2><span id='topic+coef+2CMoMFit-method'></span>

<h3>Description</h3>

<p>Extract parameters from an <code><a href="#topic+MoMFit-class">MoMFit-class</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MoMFit'
coef(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef+2B2CMoMFit-method_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+MoMFit-class">MoMFit-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the model parameters estimates (MAP), the fields are:
</p>

<ul>
<li> <p><code>'pi'</code>: cluster proportions
</p>
</li>
<li> <p><code>'thetak'</code>: cluster profile probabilities (matrix of size K x D),
</p>
</li></ul>


<hr>
<h2 id='coef+2CMoRFit-method'>Extract mixture parameters from <code><a href="#topic+MoRFit-class">MoRFit-class</a></code> object using MAP estimation</h2><span id='topic+coef+2CMoRFit-method'></span>

<h3>Description</h3>

<p>Extract mixture parameters from <code><a href="#topic+MoRFit-class">MoRFit-class</a></code> object using MAP estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MoRFit'
coef(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef+2B2CMoRFit-method_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+MoRFit-class">MoRFit-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the mixture parameters estimates (MAP), the fields are:
</p>

<ul>
<li> <p><code>'pi'</code>: cluster proportions
</p>
</li>
<li> <p><code>'A'</code>: cluster regression matrix
</p>
</li>
<li> <p><code>'Sigmak'</code>: cluster noise co-variance matrices
</p>
</li></ul>


<hr>
<h2 id='coef+2CMultSbmFit-method'>Extract parameters from an <code><a href="#topic+MultSbmFit-class">MultSbmFit-class</a></code> object</h2><span id='topic+coef+2CMultSbmFit-method'></span>

<h3>Description</h3>

<p>Extract parameters from an <code><a href="#topic+MultSbmFit-class">MultSbmFit-class</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MultSbmFit'
coef(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef+2B2CMultSbmFit-method_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+MultSbmFit-class">MultSbmFit-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the model parameters estimates (MAP), the fields are:
</p>

<ul>
<li> <p><code>'pi'</code>: cluster proportions
</p>
</li>
<li> <p><code>'thetakl'</code>: cluster profile probabilities (array of size K x K x D),
</p>
</li></ul>


<hr>
<h2 id='coef+2CSbmFit-method'>Extract parameters from an <code><a href="#topic+SbmFit-class">SbmFit-class</a></code> object</h2><span id='topic+coef+2CSbmFit-method'></span>

<h3>Description</h3>

<p>Extract parameters from an <code><a href="#topic+SbmFit-class">SbmFit-class</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SbmFit'
coef(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef+2B2CSbmFit-method_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+SbmFit-class">SbmFit-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the model parameters estimates (MAP), the fields are:
</p>

<ul>
<li> <p><code>'pi'</code>: cluster proportions
</p>
</li>
<li> <p><code>'thetakl'</code>: between clusters connections probabilities (matrix of size K x K)
</p>
</li></ul>


<hr>
<h2 id='CombinedModels'>Combined Models classes</h2><span id='topic+CombinedModels'></span><span id='topic+CombinedModels-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a combined clustering models, where several models are used to model different datasets. A conditional independence assumption between the view knowing the cluster is made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CombinedModels(models, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CombinedModels_+3A_models">models</code></td>
<td>
<p>a named list of DlvmPrior's object</p>
</td></tr>
<tr><td><code id="CombinedModels_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameter over the cluster proportions (default to 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The filed name in the models list must match the name of the list use to provide the datasets to cluster together.
</p>


<h3>Value</h3>

<p>a <code>CombinedModels-class</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CombinedModelsFit-class">CombinedModelsFit-class</a></code>, <code><a href="#topic+CombinedModelsPath-class">CombinedModelsPath-class</a></code>
</p>
<p>Other DlvmModels: 
<code><a href="#topic+DcLbm">DcLbm</a></code>,
<code><a href="#topic+DcSbm">DcSbm</a></code>,
<code><a href="#topic+DiagGmm">DiagGmm</a></code>,
<code><a href="#topic+DlvmPrior-class">DlvmPrior-class</a></code>,
<code><a href="#topic+Gmm">Gmm</a></code>,
<code><a href="#topic+Lca">Lca</a></code>,
<code><a href="#topic+MoM">MoM</a></code>,
<code><a href="#topic+MoR">MoR</a></code>,
<code><a href="#topic+MultSbm">MultSbm</a></code>,
<code><a href="#topic+Sbm">Sbm</a></code>,
<code><a href="#topic+greed">greed</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CombinedModels(models = list(continuous = GmmPrior(), discrete = LcaPrior()))
</code></pre>

<hr>
<h2 id='CombinedModelsFit-class'>Combined Models fit results class</h2><span id='topic+CombinedModelsFit-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a fit of a degree corrected stochastic block model for co_clustering, extend <code><a href="#topic+IclFit-class">IclFit-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>a <code><a href="#topic+DcSbm-class">DcSbm-class</a></code> object to store the model fitted</p>
</dd>
<dt><code>name</code></dt><dd><p>generative model name</p>
</dd>
<dt><code>icl</code></dt><dd><p>icl value of the fitted model</p>
</dd>
<dt><code>K</code></dt><dd><p>number of extracted clusters over row and columns</p>
</dd>
<dt><code>cl</code></dt><dd><p>a numeric vector with row and columns cluster indexes</p>
</dd>
<dt><code>obs_stats</code></dt><dd><p>a list with the following elements:</p>
</dd>
<dt><code>move_mat</code></dt><dd><p>binary matrix which store move constraints</p>
</dd>
<dt><code>train_hist</code></dt><dd><p>data.frame with training history information (details depends on the training procedure)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+extractSubModel+2CCombinedModelsPath+2Ccharacter-method">extractSubModel,CombinedModelsPath,character-method</a></code>
</p>

<hr>
<h2 id='CombinedModelsPath-class'>Combined Models hierarchical fit results class</h2><span id='topic+CombinedModelsPath-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a hierarchical fit of a degree corrected stochastic block model, extend <code><a href="#topic+IclPath-class">IclPath-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>a <code><a href="#topic+DcSbm-class">DcSbm-class</a></code> object to store the model fitted</p>
</dd>
<dt><code>name</code></dt><dd><p>generative model name</p>
</dd>
<dt><code>icl</code></dt><dd><p>icl value of the fitted model</p>
</dd>
<dt><code>K</code></dt><dd><p>number of extracted clusters over row and columns</p>
</dd>
<dt><code>cl</code></dt><dd><p>a numeric vector with row and columns cluster indexes</p>
</dd>
<dt><code>obs_stats</code></dt><dd><p>a list with the following elements:</p>
</dd>
<dt><code>path</code></dt><dd><p>a list of size K-1 with each part of the path described by:
</p>

<ul>
<li><p> icl1: icl value reach with this solution for alpha=1
</p>
</li>
<li><p> logalpha: log(alpha) value were this solution is better than its parent
</p>
</li>
<li><p> K: number of clusters
</p>
</li>
<li><p> cl: vector of cluster indexes
</p>
</li>
<li><p> k,l: index of the cluster that were merged at this step
</p>
</li>
<li><p> merge_mat: lower triangular matrix of delta icl values
</p>
</li>
<li><p> obs_stats: a list with the elements:
</p>
</li></ul>
</dd>
<dt><code>logalpha</code></dt><dd><p>value of log(alpha)</p>
</dd>
<dt><code>ggtree</code></dt><dd><p>data.frame with complete merge tree for easy plotting with <code>ggplot2</code></p>
</dd>
<dt><code>tree</code></dt><dd><p>numeric vector with merge tree <code>tree[i]</code> contains the index of <code>i</code> father</p>
</dd>
<dt><code>train_hist</code></dt><dd><p>data.frame with training history information (details depends on the training procedure)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+extractSubModel+2CCombinedModelsPath+2Ccharacter-method">extractSubModel,CombinedModelsPath,character-method</a></code>
</p>

<hr>
<h2 id='cut+2CDcLbmPath-method'>Method to cut a DcLbmPath solution to a desired number of cluster</h2><span id='topic+cut+2CDcLbmPath-method'></span>

<h3>Description</h3>

<p>This method take a <code><a href="#topic+DcLbmPath-class">DcLbmPath-class</a></code> and an integer K and return the solution from the path with K clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DcLbmPath'
cut(x, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut+2B2CDcLbmPath-method_+3A_x">x</code></td>
<td>
<p>A an <code><a href="#topic+DcLbmPath-class">DcLbmPath-class</a></code> solution</p>
</td></tr>
<tr><td><code id="cut+2B2CDcLbmPath-method_+3A_k">K</code></td>
<td>
<p>Desired number of cluster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code><a href="#topic+IclPath-class">IclPath-class</a></code> object with the desired number of cluster
</p>

<hr>
<h2 id='cut+2CIclPath-method'>Generic method to cut a path solution to a desired number of cluster</h2><span id='topic+cut+2CIclPath-method'></span>

<h3>Description</h3>

<p>This method take a <code><a href="#topic+IclPath-class">IclPath-class</a></code> object and an integer K and return the solution from the path with K clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'IclPath'
cut(x, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut+2B2CIclPath-method_+3A_x">x</code></td>
<td>
<p>A an <code>IclPath</code> solution</p>
</td></tr>
<tr><td><code id="cut+2B2CIclPath-method_+3A_k">K</code></td>
<td>
<p>Desired number of cluster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code><a href="#topic+IclPath-class">IclPath-class</a></code> object with the desired number of cluster
</p>

<hr>
<h2 id='DcLbm'>Degree Corrected Latent Block Model for bipartite graph class</h2><span id='topic+DcLbm'></span><span id='topic+DcLbmPrior-class'></span><span id='topic+DcLbm-class'></span><span id='topic+DcLbmPrior'></span>

<h3>Description</h3>

<p>An S4 class to represent a degree corrected stochastic block model for co_clustering of bipartite graph.
Such model can be used to cluster graph vertex, and model a bipartite graph adjacency matrix <code class="reqn">X</code> with the following generative model :
</p>
<p style="text-align: center;"><code class="reqn"> \pi \sim Dirichlet(\alpha)</code>
</p>

<p style="text-align: center;"><code class="reqn"> Z_i^r  \sim \mathcal{M}(1,\pi^r)</code>
</p>

<p style="text-align: center;"><code class="reqn"> Z_j^c  \sim \mathcal{M}(1,\pi^c)</code>
</p>

<p style="text-align: center;"><code class="reqn"> \theta_{kl} \sim Exponential(p)</code>
</p>

<p style="text-align: center;"><code class="reqn"> \gamma_i^r\sim \mathcal{U}(S_k)</code>
</p>

<p style="text-align: center;"><code class="reqn"> \gamma_i^c\sim \mathcal{U}(S_l)</code>
</p>

<p style="text-align: center;"><code class="reqn"> X_{ij}|Z_{ik}^cZ_{jl}^r=1 \sim \mathcal{P}(\gamma_i^r\theta_{kl}\gamma_j^c)</code>
</p>

<p>The individuals parameters <code class="reqn">\gamma_i^r,\gamma_j^c</code> allow to take into account the node degree heterogeneity.
These parameters have uniform priors over simplex <code class="reqn">S_k</code>.
These classes mainly store the prior parameters value <code class="reqn">\alpha,p</code> of this generative model.
The <code>DcLbm-class</code> must be used when fitting a simple Diagonal Gaussian Mixture Model whereas the <code>DcLbmPrior-class</code> must be sued when fitting a <code><a href="#topic+CombinedModels-class">CombinedModels-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DcLbmPrior(p = NaN)

DcLbm(alpha = 1, p = NaN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DcLbm_+3A_p">p</code></td>
<td>
<p>Exponential prior parameter (default to Nan, in this case p will be estimated from data as the average intensities of X)</p>
</td></tr>
<tr><td><code id="DcLbm_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameter over the cluster proportions (default to 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>DcLbmPrior-class</code>
</p>
<p>a <code>DcLbm-class</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DcLbmFit-class">DcLbmFit-class</a></code>, <code><a href="#topic+DcLbmPath-class">DcLbmPath-class</a></code>
</p>
<p>Other DlvmModels: 
<code><a href="#topic+CombinedModels">CombinedModels</a></code>,
<code><a href="#topic+DcSbm">DcSbm</a></code>,
<code><a href="#topic+DiagGmm">DiagGmm</a></code>,
<code><a href="#topic+DlvmPrior-class">DlvmPrior-class</a></code>,
<code><a href="#topic+Gmm">Gmm</a></code>,
<code><a href="#topic+Lca">Lca</a></code>,
<code><a href="#topic+MoM">MoM</a></code>,
<code><a href="#topic+MoR">MoR</a></code>,
<code><a href="#topic+MultSbm">MultSbm</a></code>,
<code><a href="#topic+Sbm">Sbm</a></code>,
<code><a href="#topic+greed">greed</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DcLbmPrior()
DcLbmPrior(p = 0.7)
DcLbm()
DcLbm(p = 0.7)
</code></pre>

<hr>
<h2 id='DcLbmFit-class'>Degree corrected Latent Block Model fit results class</h2><span id='topic+DcLbmFit-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a fit of a degree corrected stochastic block model for co_clustering, extend <code><a href="#topic+IclFit-class">IclFit-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>a <code><a href="#topic+DcLbm-class">DcLbm-class</a></code> object to store the model fitted</p>
</dd>
<dt><code>name</code></dt><dd><p>generative model name</p>
</dd>
<dt><code>icl</code></dt><dd><p>icl value of the fitted model</p>
</dd>
<dt><code>K</code></dt><dd><p>number of extracted clusters over row and columns</p>
</dd>
<dt><code>Krow</code></dt><dd><p>number of extracted row clusters</p>
</dd>
<dt><code>Kcol</code></dt><dd><p>number of extracted column clusters</p>
</dd>
<dt><code>cl</code></dt><dd><p>a numeric vector with row and columns cluster indexes</p>
</dd>
<dt><code>obs_stats</code></dt><dd><p>a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> din: numeric vector of size K which store the sums of in-degrees for each clusters
</p>
</li>
<li><p> dout: numeric vector of size K which store the sums of out-degrees for each clusters
</p>
</li>
<li><p> x_counts: matrix of size K*K with the number of links between each pair of clusters
</p>
</li>
<li><p> co_x_counts: matrix of size Krow*Kcol with the number of links between each pair of row and column cluster
</p>
</li></ul>
</dd>
<dt><code>clrow</code></dt><dd><p>a numeric vector with row cluster indexes</p>
</dd>
<dt><code>clcol</code></dt><dd><p>a numeric vector with column cluster indexes</p>
</dd>
<dt><code>Nrow</code></dt><dd><p>number of rows</p>
</dd>
<dt><code>Ncol</code></dt><dd><p>number of columns</p>
</dd>
<dt><code>move_mat</code></dt><dd><p>binary matrix which store move constraints</p>
</dd>
<dt><code>train_hist</code></dt><dd><p>data.frame with training history information (details depends on the training procedure)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+coef+2CDcLbmFit-method">coef,DcLbmFit-method</a></code>
</p>

<hr>
<h2 id='DcLbmPath-class'>Degree corrected Latent Block Model hierarchical fit results class</h2><span id='topic+DcLbmPath-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a fit of a degree corrected stochastic block model for co_clustering, extend <code><a href="#topic+IclPath-class">IclPath-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>a <code><a href="#topic+DcLbm-class">DcLbm-class</a></code> object to store the model fitted</p>
</dd>
<dt><code>name</code></dt><dd><p>generative model name</p>
</dd>
<dt><code>icl</code></dt><dd><p>icl value of the fitted model</p>
</dd>
<dt><code>K</code></dt><dd><p>number of extracted clusters over row and columns</p>
</dd>
<dt><code>Krow</code></dt><dd><p>number of extracted row clusters</p>
</dd>
<dt><code>Kcol</code></dt><dd><p>number of extracted column clusters</p>
</dd>
<dt><code>cl</code></dt><dd><p>a numeric vector with row and columns cluster indexes</p>
</dd>
<dt><code>obs_stats</code></dt><dd><p>a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> din: numeric vector of size K which store the sums of in-degrees for each clusters
</p>
</li>
<li><p> dout: numeric vector of size K which store the sums of out-degrees for each clusters
</p>
</li>
<li><p> x_counts: matrix of size K*K with the number of links between each pair of clusters
</p>
</li>
<li><p> co_x_counts: matrix of size Krow*Kcol with the number of links between each pair of row and column cluster
</p>
</li></ul>
</dd>
<dt><code>clrow</code></dt><dd><p>a numeric vector with row cluster indexes</p>
</dd>
<dt><code>clcol</code></dt><dd><p>a numeric vector with column cluster indexes</p>
</dd>
<dt><code>Nrow</code></dt><dd><p>number of rows</p>
</dd>
<dt><code>Ncol</code></dt><dd><p>number of columns</p>
</dd>
<dt><code>path</code></dt><dd><p>a list of size K-1 with each part of the path described by:
</p>

<ul>
<li><p> icl1: icl value reach with this solution for alpha=1
</p>
</li>
<li><p> logalpha: log(alpha) value were this solution is better than its parent
</p>
</li>
<li><p> K: number of clusters
</p>
</li>
<li><p> cl: vector of cluster indexes
</p>
</li>
<li><p> k,l: index of the cluster that were merged at this step
</p>
</li>
<li><p> merge_mat: lower triangular matrix of delta icl values
</p>
</li>
<li><p> obs_stats: a list with the elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> din: numeric vector of size K which store the sums of in-degrees for each clusters
</p>
</li>
<li><p> dout: numeric vector of size K which store the sums of out-degrees for each clusters
</p>
</li>
<li><p> x_counts: matrix of size K*K with the number of links between each pair of clusters
</p>
</li>
<li><p> co_x_counts: matrix of size Krow*Kcol with the number of links between each pair of row and column cluster
</p>
</li></ul>

</li></ul>
</dd>
<dt><code>logalpha</code></dt><dd><p>value of log(alpha)</p>
</dd>
<dt><code>ggtree</code></dt><dd><p>data.frame with complete merge tree for easy plotting with <code>ggplot2</code></p>
</dd>
<dt><code>tree</code></dt><dd><p>numeric vector with merge tree <code>tree[i]</code> contains the index of <code>i</code> father</p>
</dd>
<dt><code>ggtreerow</code></dt><dd><p>data.frame with complete merge tree of row clusters for easy plotting with <code>ggplot2</code></p>
</dd>
<dt><code>ggtreecol</code></dt><dd><p>data.frame with complete merge tree of column clusters for easy plotting with <code>ggplot2</code></p>
</dd>
<dt><code>train_hist</code></dt><dd><p>data.frame with training history information (details depends on the training procedure)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+plot+2CDcLbmPath+2Cmissing-method">plot,DcLbmPath,missing-method</a></code>
</p>

<hr>
<h2 id='DcSbm'>Degree Corrected Stochastic Block Model Prior class</h2><span id='topic+DcSbm'></span><span id='topic+DcSbmPrior-class'></span><span id='topic+DcSbm-class'></span><span id='topic+DcSbmPrior'></span>

<h3>Description</h3>

<p>An S4 class to represent a Degree Corrected Stochastic Block Model.
Such model can be used to cluster graph vertex, and model a square adjacency matrix <code class="reqn">X</code> with the following generative model :
</p>
<p style="text-align: center;"><code class="reqn"> \pi \sim Dirichlet(\alpha)</code>
</p>

<p style="text-align: center;"><code class="reqn"> Z_i  \sim \mathcal{M}(1,\pi)</code>
</p>

<p style="text-align: center;"><code class="reqn"> \theta_{kl} \sim Exponential(p)</code>
</p>

<p style="text-align: center;"><code class="reqn"> \gamma_i^+,\gamma_i^- \sim \mathcal{U}(S_k)</code>
</p>

<p style="text-align: center;"><code class="reqn"> X_{ij}|Z_{ik}Z_{jl}=1 \sim \mathcal{P}(\gamma_i^+\theta_{kl}\gamma_j^-)</code>
</p>

<p>The individuals parameters <code class="reqn">\gamma_i^+,\gamma_i^-</code> allow to take into account the node degree heterogeneity.
These parameters have uniform priors over the simplex <code class="reqn">S_k</code> ie. <code class="reqn">\sum_{i:z_{ik}=1}\gamma_i^+=1</code>.
These classes mainly store the prior parameters value <code class="reqn">\alpha,p</code> of this generative model.
The <code>DcSbm-class</code> must be used when fitting a simple Degree Corrected Stochastic Block Model whereas the <code>DcSbmPrior-class</code> must be used when fitting a <code><a href="#topic+CombinedModels-class">CombinedModels-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DcSbmPrior(p = NaN, type = "guess")

DcSbm(alpha = 1, p = NaN, type = "guess")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DcSbm_+3A_p">p</code></td>
<td>
<p>Exponential prior parameter (default to NaN, in this case p will be estimated from data as the mean connection probability)</p>
</td></tr>
<tr><td><code id="DcSbm_+3A_type">type</code></td>
<td>
<p>define the type of networks (either &quot;directed&quot;, &quot;undirected&quot; or &quot;guess&quot;, default to &quot;guess&quot;)</p>
</td></tr>
<tr><td><code id="DcSbm_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameter over the cluster proportions (default to 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>DcSbmPrior-class</code> object
</p>
<p>a <code>DcSbm-class</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DcSbmFit-class">DcSbmFit-class</a></code>, <code><a href="#topic+DcSbmPath-class">DcSbmPath-class</a></code>
</p>
<p>Other DlvmModels: 
<code><a href="#topic+CombinedModels">CombinedModels</a></code>,
<code><a href="#topic+DcLbm">DcLbm</a></code>,
<code><a href="#topic+DiagGmm">DiagGmm</a></code>,
<code><a href="#topic+DlvmPrior-class">DlvmPrior-class</a></code>,
<code><a href="#topic+Gmm">Gmm</a></code>,
<code><a href="#topic+Lca">Lca</a></code>,
<code><a href="#topic+MoM">MoM</a></code>,
<code><a href="#topic+MoR">MoR</a></code>,
<code><a href="#topic+MultSbm">MultSbm</a></code>,
<code><a href="#topic+Sbm">Sbm</a></code>,
<code><a href="#topic+greed">greed</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DcSbmPrior()
DcSbmPrior(type = "undirected")
DcSbm()
DcSbm(type = "undirected")
</code></pre>

<hr>
<h2 id='DcSbmFit-class'>Degree Corrected Stochastic Block Model fit results class</h2><span id='topic+DcSbmFit-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a fit of a degree corrected stochastic block model for co_clustering, extend <code><a href="#topic+IclFit-class">IclFit-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>a <code><a href="#topic+DcSbm-class">DcSbm-class</a></code> object to store the model fitted</p>
</dd>
<dt><code>name</code></dt><dd><p>generative model name</p>
</dd>
<dt><code>icl</code></dt><dd><p>icl value of the fitted model</p>
</dd>
<dt><code>K</code></dt><dd><p>number of extracted clusters over row and columns</p>
</dd>
<dt><code>cl</code></dt><dd><p>a numeric vector with row and columns cluster indexes</p>
</dd>
<dt><code>obs_stats</code></dt><dd><p>a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> din: numeric vector of size K which store the sums of in-degrees for each clusters
</p>
</li>
<li><p> dout: numeric vector of size K which store the sums of out-degrees for each clusters
</p>
</li>
<li><p> x_counts: matrix of size K*K with the number of links between each pair of clusters
</p>
</li></ul>
</dd>
<dt><code>obs_stats_cst</code></dt><dd><p>a list with the following elements:
</p>

<ul>
<li><p> din_node: node in-degree, a vector of size N
</p>
</li>
<li><p> dout_node: node in-degree vector of size N
</p>
</li></ul>
</dd>
<dt><code>move_mat</code></dt><dd><p>binary matrix which store move constraints</p>
</dd>
<dt><code>train_hist</code></dt><dd><p>data.frame with training history information (details depends on the training procedure)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+coef+2CDcSbmFit-method">coef,DcSbmFit-method</a></code>
</p>

<hr>
<h2 id='DcSbmPath-class'>Degree Corrected Stochastic Block Model hierarchical fit results class</h2><span id='topic+DcSbmPath-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a hierarchical fit of a degree corrected stochastic block model, extend <code><a href="#topic+IclPath-class">IclPath-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>a <code><a href="#topic+DcSbm-class">DcSbm-class</a></code> object to store the model fitted</p>
</dd>
<dt><code>name</code></dt><dd><p>generative model name</p>
</dd>
<dt><code>icl</code></dt><dd><p>icl value of the fitted model</p>
</dd>
<dt><code>K</code></dt><dd><p>number of extracted clusters over row and columns</p>
</dd>
<dt><code>cl</code></dt><dd><p>a numeric vector with row and columns cluster indexes</p>
</dd>
<dt><code>obs_stats</code></dt><dd><p>a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> din: numeric vector of size K which store the sums of in-degrees for each clusters
</p>
</li>
<li><p> dout: numeric vector of size K which store the sums of out-degrees for each clusters
</p>
</li>
<li><p> x_counts: matrix of size K*K with the number of links between each pair of clusters
</p>
</li></ul>
</dd>
<dt><code>path</code></dt><dd><p>a list of size K-1 with each part of the path described by:
</p>

<ul>
<li><p> icl1: icl value reach with this solution for alpha=1
</p>
</li>
<li><p> logalpha: log(alpha) value were this solution is better than its parent
</p>
</li>
<li><p> K: number of clusters
</p>
</li>
<li><p> cl: vector of cluster indexes
</p>
</li>
<li><p> k,l: index of the cluster that were merged at this step
</p>
</li>
<li><p> merge_mat: lower triangular matrix of delta icl values
</p>
</li>
<li><p> obs_stats: a list with the elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> din: numeric vector of size K which store the sums of in-degrees for each clusters
</p>
</li>
<li><p> dout: numeric vector of size K which store the sums of out-degrees for each clusters
</p>
</li>
<li><p> x_counts: matrix of size K*K with the number of links between each pair of clusters
</p>
</li></ul>

</li></ul>
</dd>
<dt><code>logalpha</code></dt><dd><p>value of log(alpha)</p>
</dd>
<dt><code>ggtree</code></dt><dd><p>data.frame with complete merge tree for easy plotting with <code>ggplot2</code></p>
</dd>
<dt><code>tree</code></dt><dd><p>numeric vector with merge tree <code>tree[i]</code> contains the index of <code>i</code> father</p>
</dd>
<dt><code>train_hist</code></dt><dd><p>data.frame with training history information (details depends on the training procedure)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+plot+2CDcSbmFit+2Cmissing-method">plot,DcSbmFit,missing-method</a></code>
</p>

<hr>
<h2 id='DiagGmm'>Diagonal Gaussian Mixture Model Prior description class</h2><span id='topic+DiagGmm'></span><span id='topic+DiagGmmPrior-class'></span><span id='topic+DiagGmm-class'></span><span id='topic+DiagGmmPrior'></span>

<h3>Description</h3>

<p>An S4 class to represent a multivariate diagonal Gaussian mixture model.
The model corresponds to the following generative model:
</p>
<p style="text-align: center;"><code class="reqn"> \pi \sim Dirichlet(\alpha)</code>
</p>

<p style="text-align: center;"><code class="reqn"> Z_i  \sim \mathcal{M}(1,\pi)</code>
</p>

<p style="text-align: center;"><code class="reqn"> \lambda_k^{(d)} \sim \mathcal{G}(\kappa,\beta)</code>
</p>

<p style="text-align: center;"><code class="reqn"> \mu_k^{(d)} \sim \mathcal{N}(\mu,(\tau \lambda_k)^{-1})</code>
</p>

<p style="text-align: center;"><code class="reqn"> X_{i.}|Z_{ik}=1 \sim \mathcal{N}(\mu_k,\lambda_{k}^{-1})</code>
</p>

<p>with <code class="reqn">\mathcal{G}(\kappa,\beta)</code> the Gamma distribution with shape parameter <code class="reqn">\kappa</code> and rate parameter <code class="reqn">\beta</code>.
These classes mainly store the prior parameters value (<code class="reqn">\alpha,\tau,\kappa\beta,\mu</code>) of this generative model.
The <code>DiagGmm-class</code> must be used when fitting a simple Diagonal Gaussian Mixture Model whereas the <code>DiagGmmPrior-class</code> must be sued when fitting a <code><a href="#topic+CombinedModels-class">CombinedModels-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiagGmmPrior(tau = 0.01, kappa = 1, beta = NaN, mu = NaN)

DiagGmm(alpha = 1, tau = 0.01, kappa = 1, beta = NaN, mu = NaN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiagGmm_+3A_tau">tau</code></td>
<td>
<p>Prior parameter (inverse variance), (default 0.01)</p>
</td></tr>
<tr><td><code id="DiagGmm_+3A_kappa">kappa</code></td>
<td>
<p>Prior parameter (gamma shape), (default to 1)</p>
</td></tr>
<tr><td><code id="DiagGmm_+3A_beta">beta</code></td>
<td>
<p>Prior parameter (gamma rate), (default to NaN, in this case beta will be estimated from data as 0.1 time the mean of X columns variances)</p>
</td></tr>
<tr><td><code id="DiagGmm_+3A_mu">mu</code></td>
<td>
<p>Prior for the means (vector of size D), (default to NaN, in this case mu will be estimated from data as the mean of X)</p>
</td></tr>
<tr><td><code id="DiagGmm_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameter over the cluster proportions (default to 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>DiagGmmPrior-class</code> object
</p>
<p>a <code>DiagGmm-class</code> object
</p>


<h3>References</h3>

<p>Bertoletti, Marco &amp; Friel, Nial &amp; Rastelli, Riccardo. (2014). Choosing the number of clusters in a finite mixture model using an exact Integrated Completed Likelihood criterion. METRON. 73. 10.1007/s40300-015-0064-5. #'
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DiagGmmFit-class">DiagGmmFit-class</a></code>, <code><a href="#topic+DiagGmmPath-class">DiagGmmPath-class</a></code>
</p>
<p>Other DlvmModels: 
<code><a href="#topic+CombinedModels">CombinedModels</a></code>,
<code><a href="#topic+DcLbm">DcLbm</a></code>,
<code><a href="#topic+DcSbm">DcSbm</a></code>,
<code><a href="#topic+DlvmPrior-class">DlvmPrior-class</a></code>,
<code><a href="#topic+Gmm">Gmm</a></code>,
<code><a href="#topic+Lca">Lca</a></code>,
<code><a href="#topic+MoM">MoM</a></code>,
<code><a href="#topic+MoR">MoR</a></code>,
<code><a href="#topic+MultSbm">MultSbm</a></code>,
<code><a href="#topic+Sbm">Sbm</a></code>,
<code><a href="#topic+greed">greed</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DiagGmmPrior()
DiagGmmPrior(tau = 0.1)
DiagGmm()
DiagGmm(tau = 0.1)
</code></pre>

<hr>
<h2 id='DiagGmmFit-class'>Diagonal Gaussian mixture model fit results class</h2><span id='topic+DiagGmmFit-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a fit of a multivariate diagonal Gaussian mixture model, extend <code><a href="#topic+IclFit-class">IclFit-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>a <code><a href="#topic+DiagGmm-class">DiagGmm-class</a></code> object to store the model fitted</p>
</dd>
<dt><code>name</code></dt><dd><p>generative model name</p>
</dd>
<dt><code>icl</code></dt><dd><p>icl value of the fitted model</p>
</dd>
<dt><code>K</code></dt><dd><p>number of extracted clusters over row and columns</p>
</dd>
<dt><code>cl</code></dt><dd><p>a numeric vector with row and columns cluster indexes</p>
</dd>
<dt><code>obs_stats</code></dt><dd><p>a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> regs: list of size $K$ with statistics for each clusters
</p>
</li></ul>
</dd>
<dt><code>move_mat</code></dt><dd><p>binary matrix which store move constraints</p>
</dd>
<dt><code>train_hist</code></dt><dd><p>data.frame with training history information (details depends on the training procedure)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+coef+2CDiagGmmFit-method">coef,DiagGmmFit-method</a></code>
</p>

<hr>
<h2 id='DiagGmmPath-class'>Diagonal Gaussian mixture model hierarchical fit results class</h2><span id='topic+DiagGmmPath-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a hierarchical fit of a diagonal gaussian mixture model, extend <code><a href="#topic+IclPath-class">IclPath-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>a <code><a href="#topic+DiagGmm-class">DiagGmm-class</a></code> object to store the model fitted</p>
</dd>
<dt><code>name</code></dt><dd><p>generative model name</p>
</dd>
<dt><code>icl</code></dt><dd><p>icl value of the fitted model</p>
</dd>
<dt><code>K</code></dt><dd><p>number of extracted clusters over row and columns</p>
</dd>
<dt><code>cl</code></dt><dd><p>a numeric vector with row and columns cluster indexes</p>
</dd>
<dt><code>obs_stats</code></dt><dd><p>a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> regs: list of size $K$ with statistics for each clusters
</p>
</li></ul>
</dd>
<dt><code>path</code></dt><dd><p>a list of size K-1 with each part of the path described by:
</p>

<ul>
<li><p> icl1: icl value reach with this solution for alpha=1
</p>
</li>
<li><p> logalpha: log(alpha) value were this solution is better than its parent
</p>
</li>
<li><p> K: number of clusters
</p>
</li>
<li><p> cl: vector of cluster indexes
</p>
</li>
<li><p> k,l: index of the cluster that were merged at this step
</p>
</li>
<li><p> merge_mat: lower triangular matrix of delta icl values
</p>
</li>
<li><p> obs_stats: a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> regs: list of size $K$ with statistics for each clusters
</p>
</li></ul>

</li></ul>
</dd>
<dt><code>logalpha</code></dt><dd><p>value of log(alpha)</p>
</dd>
<dt><code>ggtree</code></dt><dd><p>data.frame with complete merge tree for easy plotting with <code>ggplot2</code></p>
</dd>
<dt><code>tree</code></dt><dd><p>numeric vector with merge tree <code>tree[i]</code> contains the index of <code>i</code> father</p>
</dd>
<dt><code>train_hist</code></dt><dd><p>data.frame with training history information (details depends on the training procedure)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+plot+2CDiagGmmFit+2Cmissing-method">plot,DiagGmmFit,missing-method</a></code>
</p>

<hr>
<h2 id='DlvmCoPrior-class'>Abstract class to represent a generative model for co-clustering</h2><span id='topic+DlvmCoPrior-class'></span>

<h3>Description</h3>

<p>An S4 class to represent an abstract generative model
</p>


<h3>Slots</h3>


<dl>
<dt><code>alpha</code></dt><dd><p>a numeric vector of length 1 which define the parameters of the Dirichlet over the cluster proportions (default to 1)</p>
</dd>
</dl>

<hr>
<h2 id='DlvmPrior-class'>Abstract class to represent a generative model for clustering</h2><span id='topic+DlvmPrior-class'></span>

<h3>Description</h3>

<p>An S4 class to represent an abstract generative model
</p>


<h3>Slots</h3>


<dl>
<dt><code>alpha</code></dt><dd><p>a numeric vector of length 1 which define the parameters of the Dirichlet over the cluster proportions (default to 1)</p>
</dd>
</dl>


<h3>See Also</h3>

<p>Other DlvmModels: 
<code><a href="#topic+CombinedModels">CombinedModels</a></code>,
<code><a href="#topic+DcLbm">DcLbm</a></code>,
<code><a href="#topic+DcSbm">DcSbm</a></code>,
<code><a href="#topic+DiagGmm">DiagGmm</a></code>,
<code><a href="#topic+Gmm">Gmm</a></code>,
<code><a href="#topic+Lca">Lca</a></code>,
<code><a href="#topic+MoM">MoM</a></code>,
<code><a href="#topic+MoR">MoR</a></code>,
<code><a href="#topic+MultSbm">MultSbm</a></code>,
<code><a href="#topic+Sbm">Sbm</a></code>,
<code><a href="#topic+greed">greed</a>()</code>
</p>

<hr>
<h2 id='extractSubModel'>Extract a part of a <code><a href="#topic+CombinedModelsPath-class">CombinedModelsPath-class</a></code> object</h2><span id='topic+extractSubModel'></span><span id='topic+extractSubModel+2CCombinedModelsPath+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Extract a part of a <code><a href="#topic+CombinedModelsPath-class">CombinedModelsPath-class</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractSubModel(sol, sub_model_name)

## S4 method for signature 'CombinedModelsPath,character'
extractSubModel(sol, sub_model_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractSubModel_+3A_sol">sol</code></td>
<td>
<p>an <code><a href="#topic+CombinedModelsPath-class">CombinedModelsPath-class</a></code> object</p>
</td></tr>
<tr><td><code id="extractSubModel_+3A_sub_model_name">sub_model_name</code></td>
<td>
<p>a string which specify the part of the model to
extract. Note that the name must correspond to the one of the names used in
the list of models during the origin call to <code><a href="#topic+greed">greed</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+IclFit-class">IclFit-class</a></code> object of the relevant class
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>sol = CombinedModelsPath,sub_model_name = character</code>: CombinedModelsPath method
</p>
</li></ul>

<hr>
<h2 id='fashion'>Fashion mnist dataset</h2><span id='topic+fashion'></span>

<h3>Description</h3>

<p>Zalando fashionmnist dataset, sample of 1 000 Zalando's article images from the test set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fashion)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> with a random sample of 1000 images (one per rows) extracted from the fashionmnist dataset.
</p>


<h3>Source</h3>

<p><a href="https://github.com/zalandoresearch/fashion-mnist">https://github.com/zalandoresearch/fashion-mnist</a>
</p>


<h3>References</h3>

<p>Fashion-MNIST: a Novel Image Dataset for Benchmarking Machine Learning Algorithms. Han Xiao, Kashif Rasul, Roland Vollgraf (2017)
(<a href="https://arxiv.org/abs/1708.07747">arXiv:1708.07747</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fashion)
</code></pre>

<hr>
<h2 id='Fifa'>Fifa data</h2><span id='topic+Fifa'></span>

<h3>Description</h3>

<p>A random sample of 6000 players from the FIFA videogame with various statistics on all player ranging
from position, cost in the game, capacity in offense/defense, speed, etc. 
Two columns pos_x, pos_y with average player possible positions (in opta coordiantes)
were derived from the raw data.  was also u.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Fifa)
</code></pre>


<h3>Format</h3>

<p>An R data.frame with columns containing each of the descriptive
statistics of a player.
</p>


<h3>Source</h3>

<p><a href="https://www.kaggle.com/stefanoleone992/fifa-20-complete-player-dataset?select=players_20.csv">https://www.kaggle.com/stefanoleone992/fifa-20-complete-player-dataset?select=players_20.csv</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Fifa)
</code></pre>

<hr>
<h2 id='Football'>American College football network dataset</h2><span id='topic+Football'></span>

<h3>Description</h3>

<p>Network of American football games between Division IA colleges during regular season Fall 2000.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Football)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> with two fields;
</p>

<dl>
<dt>X</dt><dd><p>network adjacency matrix as a <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code> of size 115x115</p>
</dd>
<dt>label</dt><dd><p>vector of teams conferences of size 115 with the following encoding (0 = Atlantic Coast,
1 = Big East,
2 = Big Ten,
3 = Big Twelve,
4 = Conference USA,
5 = Independents,
6 = Mid-American,
7 = Mountain West,
8 = Pacific Ten,
9 = Southeastern,
10 = Sun Belt,
11 = Western Athletic)</p>
</dd>
</dl>



<h3>References</h3>

<p>M. Girvan and M. E. J. Newman, Community structure in social and biological networks, Proc. Natl. Acad. Sci. USA 99, 7821-7826 (2002)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Football)
</code></pre>

<hr>
<h2 id='Genetic-class'>Genetic optimization algorithm</h2><span id='topic+Genetic-class'></span><span id='topic+Genetic'></span>

<h3>Description</h3>

<p>An S4 class to represent a genetic algorithm (extends <code><a href="#topic+Alg-class">Alg-class</a></code> class).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Genetic(pop_size = 100, nb_max_gen = 20, prob_mutation = 0.25, sel_frac = 0.75)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Genetic-class_+3A_pop_size">pop_size</code></td>
<td>
<p>size of the solutions populations (default to 10)</p>
</td></tr>
<tr><td><code id="Genetic-class_+3A_nb_max_gen">nb_max_gen</code></td>
<td>
<p>maximal number of generation to produce (default to 4)</p>
</td></tr>
<tr><td><code id="Genetic-class_+3A_prob_mutation">prob_mutation</code></td>
<td>
<p>probability of mutation (default to 0.25)</p>
</td></tr>
<tr><td><code id="Genetic-class_+3A_sel_frac">sel_frac</code></td>
<td>
<p>fraction of best solutions selected for crossing  (default to 0.75)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>Genetic-class</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>Genetic</code>: Genetic algorithm class constructor
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>pop_size</code></dt><dd><p>size of the solutions populations (default to 10)</p>
</dd>
<dt><code>nb_max_gen</code></dt><dd><p>maximal number of generation to produce (default to 4)</p>
</dd>
<dt><code>prob_mutation</code></dt><dd><p>probability of mutation (default to 0.25)</p>
</dd>
<dt><code>sel_frac</code></dt><dd><p>fraction of best solutions selected for crossing  (default to 0.75)</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>Genetic()
Genetic(pop_size = 500)
</code></pre>

<hr>
<h2 id='Gmm'>Gaussian Mixture Model Prior description class</h2><span id='topic+Gmm'></span><span id='topic+GmmPrior-class'></span><span id='topic+Gmm-class'></span><span id='topic+GmmPrior'></span>

<h3>Description</h3>

<p>An S4 class to represent a multivariate Gaussian mixture model.
The model corresponds to the following generative model:
</p>
<p style="text-align: center;"><code class="reqn"> \pi \sim Dirichlet(\alpha)</code>
</p>

<p style="text-align: center;"><code class="reqn"> Z_i  \sim \mathcal{M}(1,\pi)</code>
</p>

<p style="text-align: center;"><code class="reqn"> V_k \sim \mathcal{W}(\varepsilon^{-1},n_0)</code>
</p>

<p style="text-align: center;"><code class="reqn"> \mu_k \sim \mathcal{N}(\mu,(\tau V_k)^{-1})</code>
</p>

<p style="text-align: center;"><code class="reqn"> X_{i}|Z_{ik}=1 \sim \mathcal{N}(\mu_k,V_{k}^{-1})</code>
</p>

<p>with <code class="reqn">\mathcal{W}(\varepsilon^{-1},n_0)</code> the Wishart distribution.
The <code>Gmm-class</code> must be used when fitting a simple Gaussian Mixture Model whereas the <code>GmmPrior-class</code> must be used when fitting a <code><a href="#topic+CombinedModels-class">CombinedModels-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GmmPrior(tau = 0.01, N0 = NaN, mu = NaN, epsilon = NaN)

Gmm(tau = 0.01, N0 = NaN, mu = NaN, epsilon = NaN, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gmm_+3A_tau">tau</code></td>
<td>
<p>Prior parameter (inverse variance) default 0.01</p>
</td></tr>
<tr><td><code id="Gmm_+3A_n0">N0</code></td>
<td>
<p>Prior parameter (pseudo count) should be &gt; number of features (default to NaN, in this case it will be estimated from data as the number of columns of X)</p>
</td></tr>
<tr><td><code id="Gmm_+3A_mu">mu</code></td>
<td>
<p>Prior parameters for the means (vector of size D), (default to NaN, in this case mu will be estimated from the data and will be equal to the mean of X)</p>
</td></tr>
<tr><td><code id="Gmm_+3A_epsilon">epsilon</code></td>
<td>
<p>Prior parameter co-variance matrix prior (matrix of size D x D), (default to a matrix of NaN, in this case epsilon will be estimated from data and will corresponds to 0.1 times a diagonal matrix with the variances of the X columns)</p>
</td></tr>
<tr><td><code id="Gmm_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameter over the cluster proportions (default to 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>GmmPrior-class</code> object
</p>
<p>a <code>Gmm-class</code> object
</p>


<h3>References</h3>

<p>Bertoletti, Marco &amp; Friel, Nial &amp; Rastelli, Riccardo. (2014). Choosing the number of clusters in a finite mixture model using an exact Integrated Completed Likelihood criterion. METRON. 73. 10.1007/s40300-015-0064-5.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GmmFit-class">GmmFit-class</a></code>, <code><a href="#topic+GmmPath-class">GmmPath-class</a></code>
</p>
<p>Other DlvmModels: 
<code><a href="#topic+CombinedModels">CombinedModels</a></code>,
<code><a href="#topic+DcLbm">DcLbm</a></code>,
<code><a href="#topic+DcSbm">DcSbm</a></code>,
<code><a href="#topic+DiagGmm">DiagGmm</a></code>,
<code><a href="#topic+DlvmPrior-class">DlvmPrior-class</a></code>,
<code><a href="#topic+Lca">Lca</a></code>,
<code><a href="#topic+MoM">MoM</a></code>,
<code><a href="#topic+MoR">MoR</a></code>,
<code><a href="#topic+MultSbm">MultSbm</a></code>,
<code><a href="#topic+Sbm">Sbm</a></code>,
<code><a href="#topic+greed">greed</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GmmPrior()
GmmPrior(tau = 0.1)
Gmm()
Gmm(tau = 0.1, alpha = 0.5)
</code></pre>

<hr>
<h2 id='GmmFit-class'>Gaussian mixture model fit results class</h2><span id='topic+GmmFit-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a fit of a multivariate mixture of regression model, extend <code><a href="#topic+IclFit-class">IclFit-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>a <code><a href="#topic+GmmPrior-class">GmmPrior-class</a></code> object to store the model fitted</p>
</dd>
<dt><code>name</code></dt><dd><p>generative model name</p>
</dd>
<dt><code>icl</code></dt><dd><p>icl value of the fitted model</p>
</dd>
<dt><code>K</code></dt><dd><p>number of extracted clusters over row and columns</p>
</dd>
<dt><code>cl</code></dt><dd><p>a numeric vector with row and columns cluster indexes</p>
</dd>
<dt><code>obs_stats</code></dt><dd><p>a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> regs: list of size $K$ with statistics for each clusters
</p>
</li></ul>
</dd>
<dt><code>move_mat</code></dt><dd><p>binary matrix which store move constraints</p>
</dd>
<dt><code>train_hist</code></dt><dd><p>data.frame with training history information (details depends on the training procedure)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+coef+2CGmmFit-method">coef,GmmFit-method</a></code>
</p>

<hr>
<h2 id='gmmpairs'>Make a matrix of plots with a given data and gmm fitted parameters</h2><span id='topic+gmmpairs'></span>

<h3>Description</h3>

<p>Make a matrix of plots with a given data and gmm fitted parameters with ellipses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmmpairs(sol, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmmpairs_+3A_sol">sol</code></td>
<td>
<p>a <code><a href="#topic+GmmFit-class">GmmFit-class</a></code> or <code><a href="#topic+DiagGmmFit-class">DiagGmmFit-class</a></code></p>
</td></tr>
<tr><td><code id="gmmpairs_+3A_x">X</code></td>
<td>
<p>the data used for the fit a data.frame or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> graphic
</p>

<hr>
<h2 id='GmmPath-class'>Gaussian mixture model hierarchical fit results class</h2><span id='topic+GmmPath-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a hierarchical fit of a gaussian mixture model, extend <code><a href="#topic+IclPath-class">IclPath-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>a <code><a href="#topic+GmmPrior-class">GmmPrior-class</a></code> object to store the model fitted</p>
</dd>
<dt><code>name</code></dt><dd><p>generative model name</p>
</dd>
<dt><code>icl</code></dt><dd><p>icl value of the fitted model</p>
</dd>
<dt><code>K</code></dt><dd><p>number of extracted clusters over row and columns</p>
</dd>
<dt><code>cl</code></dt><dd><p>a numeric vector with row and columns cluster indexes</p>
</dd>
<dt><code>obs_stats</code></dt><dd><p>a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> gmm: list of size $K$ with statistics for each clusters
</p>
</li></ul>
</dd>
<dt><code>path</code></dt><dd><p>a list of size K-1 with each part of the path described by:
</p>

<ul>
<li><p> icl1: icl value reach with this solution for alpha=1
</p>
</li>
<li><p> logalpha: log(alpha) value were this solution is better than its parent
</p>
</li>
<li><p> K: number of clusters
</p>
</li>
<li><p> k,l: index of the cluster that were merged at this step
</p>
</li>
<li><p> merge_mat: lower triangular matrix of delta icl values
</p>
</li>
<li><p> obs_stats: a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> gmm: list of size $K$ with statistics for each clusters
</p>
</li></ul>

</li></ul>
</dd>
<dt><code>logalpha</code></dt><dd><p>value of log(alpha)</p>
</dd>
<dt><code>ggtree</code></dt><dd><p>data.frame with complete merge tree for easy plotting with <code>ggplot2</code></p>
</dd>
<dt><code>tree</code></dt><dd><p>numeric vector with merge tree <code>tree[i]</code> contains the index of <code>i</code> father</p>
</dd>
<dt><code>train_hist</code></dt><dd><p>data.frame with training history information (details depends on the training procedure)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+plot+2CGmmFit+2Cmissing-method">plot,GmmFit,missing-method</a></code>
</p>

<hr>
<h2 id='greed'>Model based hierarchical clustering</h2><span id='topic+greed'></span>

<h3>Description</h3>

<p>This function is the main function for fitting Dlvms with greed. 
In the simplest case you may only provide a dataset and greed will find a suitable one. 
The accepted classes for <code>X</code>  depends on the generative used which can be specified with the <code>model</code> argument. 
See the <code><a href="#topic+DlvmPrior-class">DlvmPrior-class</a></code> and the derived classes for details.
</p>
<p>Greed enables the clustering of networks and count data matrix with different models. 
Model selection and clustering are performed in
combination by optimizing the Integrated Classification Likelihood.
Optimization is performed thanks to a combination of greedy local search and
a genetic algorithm. The main entry point is the <code><a href="#topic+greed">greed</a></code> function
to perform the clustering, which is documented below. The package also
provides sampling functions for all the implemented DLVMs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greed(X, model = find_model(X), K = 20, alg = Hybrid(), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="greed_+3A_x">X</code></td>
<td>
<p>data to cluster either a data.frame, a matrix, an array, ... depending on the used generative model</p>
</td></tr>
<tr><td><code id="greed_+3A_model">model</code></td>
<td>
<p>a generative model to fit such as <code><a href="#topic+Gmm">Gmm</a></code>,<code><a href="#topic+Sbm">Sbm</a></code>,..</p>
</td></tr>
<tr><td><code id="greed_+3A_k">K</code></td>
<td>
<p>initial number of cluster</p>
</td></tr>
<tr><td><code id="greed_+3A_alg">alg</code></td>
<td>
<p>an optimization algorithm of class <code><a href="#topic+Alg-class">Alg-class</a></code> such as <code><a href="#topic+Hybrid-class">Hybrid-class</a></code> (default), <code><a href="#topic+Multistarts-class">Multistarts-class</a></code>, <code><a href="#topic+Seed-class">Seed-class</a></code> or <code><a href="#topic+Genetic-class">Genetic-class</a></code></p>
</td></tr>
<tr><td><code id="greed_+3A_verbose">verbose</code></td>
<td>
<p>boolean value for verbose mode</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code><a href="#topic+IclPath-class">IclPath-class</a></code> object
</p>


<h3>See Also</h3>

<p>Other DlvmModels: 
<code><a href="#topic+CombinedModels">CombinedModels</a></code>,
<code><a href="#topic+DcLbm">DcLbm</a></code>,
<code><a href="#topic+DcSbm">DcSbm</a></code>,
<code><a href="#topic+DiagGmm">DiagGmm</a></code>,
<code><a href="#topic+DlvmPrior-class">DlvmPrior-class</a></code>,
<code><a href="#topic+Gmm">Gmm</a></code>,
<code><a href="#topic+Lca">Lca</a></code>,
<code><a href="#topic+MoM">MoM</a></code>,
<code><a href="#topic+MoR">MoR</a></code>,
<code><a href="#topic+MultSbm">MultSbm</a></code>,
<code><a href="#topic+Sbm">Sbm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sbm &lt;- rsbm(50, c(0.5, 0.5), diag(2) * 0.1 + 0.01)
sol &lt;- greed(sbm$x, model = Sbm())
table(sbm$cl,clustering(sol))
</code></pre>

<hr>
<h2 id='H'>Compute the entropy of a discrete sample</h2><span id='topic+H'></span>

<h3>Description</h3>

<p>Compute the entropy of a discrete sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H(cl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="H_+3A_cl">cl</code></td>
<td>
<p>vector of discrete labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the entropy of the sample
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cl &lt;- sample(2, 500, replace = TRUE)
H(cl)
</code></pre>

<hr>
<h2 id='Hybrid-class'>Hybrid optimization algorithm</h2><span id='topic+Hybrid-class'></span><span id='topic+Hybrid'></span>

<h3>Description</h3>

<p>An S4 class to represent an hybrid genetic/greedy algorithm (extends <code><a href="#topic+Alg-class">Alg-class</a></code> class).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hybrid(pop_size = 20, nb_max_gen = 10, prob_mutation = 0.25, Kmax = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hybrid-class_+3A_pop_size">pop_size</code></td>
<td>
<p>size of the solutions populations (default to 20)</p>
</td></tr>
<tr><td><code id="Hybrid-class_+3A_nb_max_gen">nb_max_gen</code></td>
<td>
<p>maximal number of generation to produce (default to 10)</p>
</td></tr>
<tr><td><code id="Hybrid-class_+3A_prob_mutation">prob_mutation</code></td>
<td>
<p>mutation probability (default to 0.25)</p>
</td></tr>
<tr><td><code id="Hybrid-class_+3A_kmax">Kmax</code></td>
<td>
<p>maximum number of clusters (default to 100)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>Hybrid-class</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>Hybrid</code>: Hybrid algorithm class constructor
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>pop_size</code></dt><dd><p>size of the solutions populations (default to 20)</p>
</dd>
<dt><code>nb_max_gen</code></dt><dd><p>maximal number of generation to produce (default to 10)</p>
</dd>
<dt><code>prob_mutation</code></dt><dd><p>mutation probability (default to 0.25)</p>
</dd>
<dt><code>Kmax</code></dt><dd><p>maximum number of clusters (default to 100)</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>Hybrid()
Hybrid(pop_size = 100)
</code></pre>

<hr>
<h2 id='ICL'>Generic method to extract the ICL value from an <code><a href="#topic+IclFit-class">IclFit-class</a></code> object</h2><span id='topic+ICL'></span><span id='topic+ICL+2CIclFit-method'></span>

<h3>Description</h3>

<p>This method take a <code><a href="#topic+IclFit-class">IclFit-class</a></code> object and return its ICL score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICL(fit)

## S4 method for signature 'IclFit'
ICL(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICL_+3A_fit">fit</code></td>
<td>
<p>an <code>IclFit</code> solution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ICL value achieved
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>IclFit</code>: IclFit method
</p>
</li></ul>

<hr>
<h2 id='IclFit-class'>Abstract class to represent a clustering result</h2><span id='topic+IclFit-class'></span>

<h3>Description</h3>

<p>An S4 abstract class to represent an icl fit of a clustering model.
</p>


<h3>Slots</h3>


<dl>
<dt><code>K</code></dt><dd><p>a numeric vector of length 1 which correspond to the number of clusters</p>
</dd>
<dt><code>icl</code></dt><dd><p>a numeric vector of length 1 which store the the icl value</p>
</dd>
<dt><code>cl</code></dt><dd><p>a numeric vector of length N which store the clusters labels</p>
</dd>
<dt><code>obs_stats</code></dt><dd><p>a list to store the observed statistics of the model needed to compute ICL.</p>
</dd>
<dt><code>obs_stats_cst</code></dt><dd><p>a list to store the observed statistics of the model that do not depend on the clustering.</p>
</dd>
<dt><code>move_mat</code></dt><dd><p>binary matrix which store move constraints</p>
</dd>
<dt><code>train_hist</code></dt><dd><p>a data.frame to store training history (format depends on the used algorithm used).</p>
</dd>
<dt><code>name</code></dt><dd><p>generative model name</p>
</dd>
</dl>

<hr>
<h2 id='IclPath-class'>Abstract class to represent a hierarchical clustering result</h2><span id='topic+IclPath-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a hierarchical path of solution.
</p>


<h3>Slots</h3>


<dl>
<dt><code>path</code></dt><dd><p>a list of merge moves describing the hierarchy of merge followed to complete totally the merge path.</p>
</dd>
<dt><code>tree</code></dt><dd><p>a tree representation of the merges.</p>
</dd>
<dt><code>ggtree</code></dt><dd><p>a data.frame for easy plotting of the dendrogram</p>
</dd>
<dt><code>logalpha</code></dt><dd><p>a numeric value which corresponds to the starting value of log(alpha).</p>
</dd>
</dl>

<hr>
<h2 id='Jazz'>Jazz musicians network dataset</h2><span id='topic+Jazz'></span>

<h3>Description</h3>

<p>List of edges of the network of Jazz musicians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Jazz)
</code></pre>


<h3>Format</h3>

<p>An object of class <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code> with the network adjacency matrix.
</p>


<h3>References</h3>

<p>P.Gleiser and L. Danon , Community Structure in jazz, Adv. Complex Syst.6, 565 (2003) (<a href="https://arxiv.org/abs/cond-mat/0307434">Arxiv</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Jazz)
</code></pre>

<hr>
<h2 id='K'>Generic method to get the number of clusters from an <code><a href="#topic+IclFit-class">IclFit-class</a></code> object</h2><span id='topic+K'></span><span id='topic+K+2CIclFit-method'></span>

<h3>Description</h3>

<p>This method take a <code><a href="#topic+IclFit-class">IclFit-class</a></code> object and return its ICL score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>K(fit)

## S4 method for signature 'IclFit'
K(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="K_+3A_fit">fit</code></td>
<td>
<p>an <code>IclFit</code> solution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of clusters
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>IclFit</code>: IclFit method
</p>
</li></ul>

<hr>
<h2 id='Lca'>Latent Class Analysis Model Prior class</h2><span id='topic+Lca'></span><span id='topic+LcaPrior-class'></span><span id='topic+Lca-class'></span><span id='topic+LcaPrior'></span>

<h3>Description</h3>

<p>An S4 class to represent a Latent Class Analysis model
Such model can be used to cluster a data.frame <code class="reqn">X</code> with several columns of factors with the following generative model :
</p>
<p style="text-align: center;"><code class="reqn">\pi \sim \textrm{Dirichlet}(\alpha),</code>
</p>

<p style="text-align: center;"><code class="reqn">\forall k, \forall j, \quad \theta_{kj} \sim \textrm{Dirichlet}_{d_j}(\beta),</code>
</p>

<p style="text-align: center;"><code class="reqn">Z_i \sim \mathcal{M}_K(1,\pi),</code>
</p>

<p style="text-align: center;"><code class="reqn">\forall j=1, \ldots, p, \quad X_{ij}|Z_{ik}=1 \sim \mathcal{M}_{d_j}(1, \theta_{kj}),</code>
</p>

<p>These classes mainly store the prior parameters value (<code class="reqn">\alpha,\beta</code>) of this generative model.
The <code>Lca-class</code> must be used when fitting a simple Latent Class Analysis whereas the <code>LcaPrior-class</code> must be used when fitting a <code><a href="#topic+CombinedModels-class">CombinedModels-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LcaPrior(beta = 1)

Lca(alpha = 1, beta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lca_+3A_beta">beta</code></td>
<td>
<p>Dirichlet prior parameter for all the categorical feature (default to 1)</p>
</td></tr>
<tr><td><code id="Lca_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameter over the cluster proportions (default to 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>LcaPrior-class</code> object
</p>
<p>a <code>Lca-class</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LcaFit-class">LcaFit-class</a></code>, <code><a href="#topic+LcaPath-class">LcaPath-class</a></code>
</p>
<p>Other DlvmModels: 
<code><a href="#topic+CombinedModels">CombinedModels</a></code>,
<code><a href="#topic+DcLbm">DcLbm</a></code>,
<code><a href="#topic+DcSbm">DcSbm</a></code>,
<code><a href="#topic+DiagGmm">DiagGmm</a></code>,
<code><a href="#topic+DlvmPrior-class">DlvmPrior-class</a></code>,
<code><a href="#topic+Gmm">Gmm</a></code>,
<code><a href="#topic+MoM">MoM</a></code>,
<code><a href="#topic+MoR">MoR</a></code>,
<code><a href="#topic+MultSbm">MultSbm</a></code>,
<code><a href="#topic+Sbm">Sbm</a></code>,
<code><a href="#topic+greed">greed</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LcaPrior()
LcaPrior(beta = 0.5)
Lca()
Lca(beta = 0.5)
</code></pre>

<hr>
<h2 id='LcaFit-class'>Latent Class  Analysis fit results class</h2><span id='topic+LcaFit-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a fit of a Latent Class Analysis model
for categorical data clustering, extend <code><a href="#topic+IclFit-class">IclFit-class</a></code>. The
original data must be an n x p matrix where p is the number of variables
and each variable is encoded as a factor (integer-valued).
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>a <code><a href="#topic+Lca-class">Lca-class</a></code> object to store the model fitted</p>
</dd>
<dt><code>name</code></dt><dd><p>generative model name</p>
</dd>
<dt><code>icl</code></dt><dd><p>icl value of the fitted model</p>
</dd>
<dt><code>K</code></dt><dd><p>number of extracted clusters over row and columns</p>
</dd>
<dt><code>cl</code></dt><dd><p>a numeric vector with cluster indexes</p>
</dd>
<dt><code>obs_stats</code></dt><dd><p>a list with the following elements: </p>
 <ul>
<li><p> counts:
numeric vector of size K with number of elements in each clusters </p>
</li>
<li>
<p>x_counts: matrix of size K*D with the number of occurrences of each
modality for each clusters </p>
</li></ul>
</dd>
<dt><code>move_mat</code></dt><dd><p>binary matrix which store move constraints</p>
</dd>
<dt><code>train_hist</code></dt><dd><p>data.frame with training history information (details
depends on the training procedure)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+coef+2CLcaFit-method">coef,LcaFit-method</a></code>
</p>

<hr>
<h2 id='LcaPath-class'>Latent Class Analysis hierarchical fit results class</h2><span id='topic+LcaPath-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a fit of a Latent Class Analysis model, extend <code><a href="#topic+IclPath-class">IclPath-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>a <code><a href="#topic+Lca-class">Lca-class</a></code> object to store the model fitted</p>
</dd>
<dt><code>name</code></dt><dd><p>generative model name</p>
</dd>
<dt><code>icl</code></dt><dd><p>icl value of the fitted model</p>
</dd>
<dt><code>K</code></dt><dd><p>number of extracted clusters over row and columns</p>
</dd>
<dt><code>cl</code></dt><dd><p>a numeric vector with row and columns cluster indexes</p>
</dd>
<dt><code>obs_stats</code></dt><dd><p>a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> x_counts: matrix of size K*D with the number of occurrence of modality word in each clusters
</p>
</li></ul>
</dd>
<dt><code>path</code></dt><dd><p>a list of size K-1 with each part of the path described by:
</p>

<ul>
<li><p> icl1: icl value reach with this solution for alpha=1
</p>
</li>
<li><p> logalpha: log(alpha) value were this solution is better than its parent
</p>
</li>
<li><p> K: number of clusters
</p>
</li>
<li><p> cl: vector of cluster indexes
</p>
</li>
<li><p> k,l: index of the cluster that were merged at this step
</p>
</li>
<li><p> merge_mat: lower triangular matrix of delta icl values
</p>
</li>
<li><p> obs_stats a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> x_counts: matrix of size K*D with the number of occurrence of modality word in each clusters
</p>
</li></ul>

</li></ul>
</dd>
<dt><code>logalpha</code></dt><dd><p>value of log(alpha)</p>
</dd>
<dt><code>ggtree</code></dt><dd><p>data.frame with complete merge tree for easy plotting with <code>ggplot2</code></p>
</dd>
<dt><code>tree</code></dt><dd><p>numeric vector with merge tree <code>tree[i]</code> contains the index of <code>i</code> father</p>
</dd>
<dt><code>train_hist</code></dt><dd><p>data.frame with training history information (details depends on the training procedure)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+plot+2CLcaFit+2Cmissing-method">plot,LcaFit,missing-method</a></code>
</p>

<hr>
<h2 id='MI'>Compute the mutual information of two discrete samples</h2><span id='topic+MI'></span>

<h3>Description</h3>

<p>Compute the mutual information of two discrete samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MI(cl1, cl2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MI_+3A_cl1">cl1</code></td>
<td>
<p>vector of discrete labels</p>
</td></tr>
<tr><td><code id="MI_+3A_cl2">cl2</code></td>
<td>
<p>vector of discrete labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the mutual information between the two discrete samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cl1 &lt;- sample(2, 500, replace = TRUE)
cl2 &lt;- sample(2, 500, replace = TRUE)
MI(cl1, cl2)
</code></pre>

<hr>
<h2 id='MoM'>Mixture of Multinomial Model Prior description class</h2><span id='topic+MoM'></span><span id='topic+MoMPrior-class'></span><span id='topic+MoM-class'></span><span id='topic+MoMPrior'></span>

<h3>Description</h3>

<p>An S4 class to represent a Mixture of Multinomial model.
Such model can be used to cluster a data matrix <code class="reqn">X</code> with the following generative model :
</p>
<p style="text-align: center;"><code class="reqn"> \pi \sim Dirichlet(\alpha)</code>
</p>

<p style="text-align: center;"><code class="reqn"> Z_i  \sim \mathcal{M}(1,\pi)</code>
</p>

<p style="text-align: center;"><code class="reqn"> \theta_{k} \sim Dirichlet(\beta)</code>
</p>

<p style="text-align: center;"><code class="reqn"> X_{i.}|Z_{ik}=1 \sim \mathcal{M}(L_i,\theta_{k})</code>
</p>

<p>With <code class="reqn">L_i=\sum_d=1^DX_{id}</code>. These classes mainly store the prior parameters value (<code class="reqn">\alpha,\beta</code>) of this generative model.
The <code>MoM-class</code> must be used when fitting a simple Mixture of Multinomials whereas the <code>MoMPrior-class</code> must be sued when fitting a <code><a href="#topic+CombinedModels-class">CombinedModels-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoMPrior(beta = 1)

MoM(alpha = 1, beta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MoM_+3A_beta">beta</code></td>
<td>
<p>Dirichlet over vocabulary prior parameter (default to 1)</p>
</td></tr>
<tr><td><code id="MoM_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameter over the cluster proportions (default to 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>MoMPrior-class</code> object
</p>
<p>a <code>MoM-class</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MoMFit-class">MoMFit-class</a></code>, <code><a href="#topic+MoMPath-class">MoMPath-class</a></code>
</p>
<p>Other DlvmModels: 
<code><a href="#topic+CombinedModels">CombinedModels</a></code>,
<code><a href="#topic+DcLbm">DcLbm</a></code>,
<code><a href="#topic+DcSbm">DcSbm</a></code>,
<code><a href="#topic+DiagGmm">DiagGmm</a></code>,
<code><a href="#topic+DlvmPrior-class">DlvmPrior-class</a></code>,
<code><a href="#topic+Gmm">Gmm</a></code>,
<code><a href="#topic+Lca">Lca</a></code>,
<code><a href="#topic+MoR">MoR</a></code>,
<code><a href="#topic+MultSbm">MultSbm</a></code>,
<code><a href="#topic+Sbm">Sbm</a></code>,
<code><a href="#topic+greed">greed</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MoMPrior()
MoMPrior(beta = 0.5)
MoM()
MoM(beta = 0.5)
</code></pre>

<hr>
<h2 id='MoMFit-class'>Mixture of Multinomial fit results class</h2><span id='topic+MoMFit-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a fit of a degree corrected stochastic block model for co_clustering, extend <code><a href="#topic+IclFit-class">IclFit-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>a <code><a href="#topic+MoM-class">MoM-class</a></code> object to store the model fitted</p>
</dd>
<dt><code>name</code></dt><dd><p>generative model name</p>
</dd>
<dt><code>icl</code></dt><dd><p>icl value of the fitted model</p>
</dd>
<dt><code>K</code></dt><dd><p>number of extracted clusters over row and columns</p>
</dd>
<dt><code>cl</code></dt><dd><p>a numeric vector with row and columns cluster indexes</p>
</dd>
<dt><code>obs_stats</code></dt><dd><p>a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> x_counts: matrix of size K*D with the number of occurrences of each modality for each clusters
</p>
</li></ul>
</dd>
<dt><code>move_mat</code></dt><dd><p>binary matrix which store move constraints</p>
</dd>
<dt><code>train_hist</code></dt><dd><p>data.frame with training history information (details depends on the training procedure)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+coef+2CLcaFit-method">coef,LcaFit-method</a></code>
</p>

<hr>
<h2 id='MoMPath-class'>Mixture of Multinomial hierarchical fit results class</h2><span id='topic+MoMPath-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a fit of a stochastic block model, extend <code><a href="#topic+IclPath-class">IclPath-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>a <code><a href="#topic+MoM-class">MoM-class</a></code> object to store the model fitted</p>
</dd>
<dt><code>name</code></dt><dd><p>generative model name</p>
</dd>
<dt><code>icl</code></dt><dd><p>icl value of the fitted model</p>
</dd>
<dt><code>K</code></dt><dd><p>number of extracted clusters over row and columns</p>
</dd>
<dt><code>cl</code></dt><dd><p>a numeric vector with row and columns cluster indexes</p>
</dd>
<dt><code>obs_stats</code></dt><dd><p>a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> x_counts: matrix of size K*D with the number of occurrence of modality word in each clusters
</p>
</li></ul>
</dd>
<dt><code>path</code></dt><dd><p>a list of size K-1 with each part of the path described by:
</p>

<ul>
<li><p> icl1: icl value reach with this solution for alpha=1
</p>
</li>
<li><p> logalpha: log(alpha) value were this solution is better than its parent
</p>
</li>
<li><p> K: number of clusters
</p>
</li>
<li><p> cl: vector of cluster indexes
</p>
</li>
<li><p> k,l: index of the cluster that were merged at this step
</p>
</li>
<li><p> merge_mat: lower triangular matrix of delta icl values
</p>
</li>
<li><p> obs_stats a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> x_counts: matrix of size K*D with the number of occurrence of modality word in each clusters
</p>
</li></ul>

</li></ul>
</dd>
<dt><code>logalpha</code></dt><dd><p>value of log(alpha)</p>
</dd>
<dt><code>ggtree</code></dt><dd><p>data.frame with complete merge tree for easy plotting with <code>ggplot2</code></p>
</dd>
<dt><code>tree</code></dt><dd><p>numeric vector with merge tree <code>tree[i]</code> contains the index of <code>i</code> father</p>
</dd>
<dt><code>train_hist</code></dt><dd><p>data.frame with training history information (details depends on the training procedure)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+plot+2CLcaFit+2Cmissing-method">plot,LcaFit,missing-method</a></code>
</p>

<hr>
<h2 id='MoR'>Multivariate mixture of regression Prior model description class</h2><span id='topic+MoR'></span><span id='topic+MoRPrior-class'></span><span id='topic+MoR-class'></span><span id='topic+MoRPrior'></span>

<h3>Description</h3>

<p>An S4 class to represent a multivariate mixture of regression model.
The model follows [minka-linear](https://tminka.github.io/papers/minka-linear.pdf) .
The model corresponds to the following generative model:
</p>
<p style="text-align: center;"><code class="reqn"> \pi \sim Dirichlet(\alpha)</code>
</p>

<p style="text-align: center;"><code class="reqn"> Z_i  \sim \mathcal{M}(1,\pi)</code>
</p>

<p style="text-align: center;"><code class="reqn"> V_k \sim \mathcal{W}(\varepsilon^{-1},n_0)</code>
</p>

<p style="text-align: center;"><code class="reqn"> A_k \sim \mathcal{MN}(0,(V_k)^{-1},\tau XX^\top)</code>
</p>

<p style="text-align: center;"><code class="reqn"> Y_{i.}|X_{i.}, A_k, Z_{ik}=1 \sim \mathcal{N}(A_k x_{i.},V_{k}^{-1})</code>
</p>

<p>with <code class="reqn">\mathcal{W}(\epsilon^{-1},n_0)</code> the Wishart distribution and <code class="reqn">\mathcal{MN}</code> the matrix-normal distribution.
The <code>MoR-class</code> must be used when fitting a simple Mixture of Regression whereas the <code>MoRPrior-class</code> must be used when fitting a <code><a href="#topic+CombinedModels-class">CombinedModels-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoRPrior(formula, tau = 0.001, N0 = NaN, epsilon = as.matrix(NaN))

MoR(formula, alpha = 1, tau = 0.1, N0 = NaN, epsilon = as.matrix(NaN))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MoR_+3A_formula">formula</code></td>
<td>
<p>a <code><a href="stats.html#topic+formula">formula</a></code> that describe the linear model to use</p>
</td></tr>
<tr><td><code id="MoR_+3A_tau">tau</code></td>
<td>
<p>Prior parameter (inverse variance) default 0.001</p>
</td></tr>
<tr><td><code id="MoR_+3A_n0">N0</code></td>
<td>
<p>Prior parameter (default to NaN, in this case N0 will be fixed equal to the number of columns of Y.)</p>
</td></tr>
<tr><td><code id="MoR_+3A_epsilon">epsilon</code></td>
<td>
<p>Covariance matrix prior parameter (default to NaN, in this case epsilon will be fixed to a diagonal variance matrix equal to 0.1 time the variance of the regression residuals with only one cluster.)</p>
</td></tr>
<tr><td><code id="MoR_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameter over the cluster proportions (default to 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>MoRPrior-class</code> object
</p>
<p>a <code>MoR-class</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MoRFit-class">MoRFit-class</a></code>, <code><a href="#topic+MoRPath-class">MoRPath-class</a></code>
</p>
<p>Other DlvmModels: 
<code><a href="#topic+CombinedModels">CombinedModels</a></code>,
<code><a href="#topic+DcLbm">DcLbm</a></code>,
<code><a href="#topic+DcSbm">DcSbm</a></code>,
<code><a href="#topic+DiagGmm">DiagGmm</a></code>,
<code><a href="#topic+DlvmPrior-class">DlvmPrior-class</a></code>,
<code><a href="#topic+Gmm">Gmm</a></code>,
<code><a href="#topic+Lca">Lca</a></code>,
<code><a href="#topic+MoM">MoM</a></code>,
<code><a href="#topic+MultSbm">MultSbm</a></code>,
<code><a href="#topic+Sbm">Sbm</a></code>,
<code><a href="#topic+greed">greed</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MoRPrior(y ~ x1 + x2)
MoRPrior(y ~ x1 + x2, N0 = 100)
MoRPrior(cbind(y1, y2) ~ x1 + x2, N0 = 100)
MoR(y ~ x1 + x2)
MoR(y ~ x1 + x2, N0 = 100)
MoR(cbind(y1, y2) ~ x1 + x2, N0 = 100)
</code></pre>

<hr>
<h2 id='MoRFit-class'>Clustering with a multivariate mixture of regression model fit results class</h2><span id='topic+MoRFit-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a fit of a multivariate mixture of regression model, extend <code><a href="#topic+IclFit-class">IclFit-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>a <code><a href="#topic+MoR-class">MoR-class</a></code> object to store the model fitted</p>
</dd>
<dt><code>name</code></dt><dd><p>generative model name</p>
</dd>
<dt><code>icl</code></dt><dd><p>icl value of the fitted model</p>
</dd>
<dt><code>K</code></dt><dd><p>number of extracted clusters over row and columns</p>
</dd>
<dt><code>cl</code></dt><dd><p>a numeric vector with row and columns cluster indexes</p>
</dd>
<dt><code>obs_stats</code></dt><dd><p>a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> mvmregs: list of size $K$ with statistics for each clusters
</p>
</li></ul>
</dd>
<dt><code>move_mat</code></dt><dd><p>binary matrix which store move constraints</p>
</dd>
<dt><code>train_hist</code></dt><dd><p>data.frame with training history information (details depends on the training procedure)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+coef+2CMoRFit-method">coef,MoRFit-method</a></code>
</p>

<hr>
<h2 id='MoRPath-class'>Multivariate mixture of regression model hierarchical fit results class</h2><span id='topic+MoRPath-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a hierarchical fit of a multivariate mixture of regression model, extend <code><a href="#topic+IclPath-class">IclPath-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>a <code><a href="#topic+MoR-class">MoR-class</a></code> object to store the model fitted</p>
</dd>
<dt><code>name</code></dt><dd><p>generative model name</p>
</dd>
<dt><code>icl</code></dt><dd><p>icl value of the fitted model</p>
</dd>
<dt><code>K</code></dt><dd><p>number of extracted clusters over row and columns</p>
</dd>
<dt><code>cl</code></dt><dd><p>a numeric vector with row and columns cluster indexes</p>
</dd>
<dt><code>obs_stats</code></dt><dd><p>a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> mvmregs: list of size $K$ with statistics for each clusters
</p>
</li></ul>
</dd>
<dt><code>path</code></dt><dd><p>a list of size K-1 with each part of the path described by:
</p>

<ul>
<li><p> icl1: icl value reach with this solution for alpha=1
</p>
</li>
<li><p> logalpha: log(alpha) value were this solution is better than its parent
</p>
</li>
<li><p> K: number of clusters
</p>
</li>
<li><p> k,l: index of the cluster that were merged at this step
</p>
</li>
<li><p> merge_mat: lower triangular matrix of delta icl values
</p>
</li>
<li><p> obs_stats: a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> mvregs: list of size $K$ with statistics for each clusters
</p>
</li></ul>

</li></ul>
</dd>
<dt><code>logalpha</code></dt><dd><p>value of log(alpha)</p>
</dd>
<dt><code>ggtree</code></dt><dd><p>data.frame with complete merge tree for easy plotting with <code>ggplot2</code></p>
</dd>
<dt><code>tree</code></dt><dd><p>numeric vector with merge tree <code>tree[i]</code> contains the index of <code>i</code> father</p>
</dd>
<dt><code>train_hist</code></dt><dd><p>data.frame with training history information (details depends on the training procedure)</p>
</dd>
</dl>

<hr>
<h2 id='Multistarts-class'>Greedy algorithm with multiple start class</h2><span id='topic+Multistarts-class'></span><span id='topic+Multistarts'></span>

<h3>Description</h3>

<p>An S4 class to represent a greedy algorithm  with multiple start (extends <code><a href="#topic+Alg-class">Alg-class</a></code> class).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Multistarts(nb_start = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Multistarts-class_+3A_nb_start">nb_start</code></td>
<td>
<p>number of random starts (default to 10)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>Multistarts-class</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>Multistarts</code>: Multistarts algorithm class constructor
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>nb_start</code></dt><dd><p>number of random starts (default to 10)</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>Multistarts()
Multistarts(15)
</code></pre>

<hr>
<h2 id='MultSbm'>Multinomial Stochastic Block Model Prior class</h2><span id='topic+MultSbm'></span><span id='topic+MultSbmPrior-class'></span><span id='topic+MultSbm-class'></span><span id='topic+MultSbmPrior'></span>

<h3>Description</h3>

<p>An S4 class to represent a Multinomial Stochastic Block Model. Such model can be used to cluster multi-layer graph vertex, and model a square adjacency cube <code class="reqn">X</code> of size NxNxM with the following generative model :
</p>
<p style="text-align: center;"><code class="reqn"> \pi \sim Dirichlet(\alpha)</code>
</p>

<p style="text-align: center;"><code class="reqn"> Z_i  \sim \mathcal{M}(1,\pi)</code>
</p>

<p style="text-align: center;"><code class="reqn"> \theta_{kl} \sim Dirichlet(\beta)</code>
</p>

<p style="text-align: center;"><code class="reqn"> X_{ij.}|Z_{ik}Z_{jl}=1 \sim \mathcal{M}(L_{ij},\theta_{kl})</code>
</p>

<p>With <code class="reqn">L_{ij}=\sum_{m=1}^MX_{ijm}</code>. These classes mainly store the prior parameters value <code class="reqn">\alpha,\beta</code> of this generative model.
The <code>MultSbm-class</code> must be used when fitting a simple MultSbm whereas the <code>MultSbmPrior-class</code> must be sued when fitting a <code><a href="#topic+CombinedModels-class">CombinedModels-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MultSbmPrior(beta = 1, type = "guess")

MultSbm(alpha = 1, beta = 1, type = "guess")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultSbm_+3A_beta">beta</code></td>
<td>
<p>Dirichlet prior parameter over Multinomial links</p>
</td></tr>
<tr><td><code id="MultSbm_+3A_type">type</code></td>
<td>
<p>define the type of networks (either &quot;directed&quot;, &quot;undirected&quot; or &quot;guess&quot;, default to &quot;guess&quot;), for undirected graphs the adjacency matrix is supposed to be symmetric.</p>
</td></tr>
<tr><td><code id="MultSbm_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameter over the cluster proportions (default to 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>MultSbmPrior-class</code> object
</p>
<p>a <code>MultSbm-class</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MultSbmFit-class">MultSbmFit-class</a></code>, <code><a href="#topic+MultSbmPath-class">MultSbmPath-class</a></code>
</p>
<p>Other DlvmModels: 
<code><a href="#topic+CombinedModels">CombinedModels</a></code>,
<code><a href="#topic+DcLbm">DcLbm</a></code>,
<code><a href="#topic+DcSbm">DcSbm</a></code>,
<code><a href="#topic+DiagGmm">DiagGmm</a></code>,
<code><a href="#topic+DlvmPrior-class">DlvmPrior-class</a></code>,
<code><a href="#topic+Gmm">Gmm</a></code>,
<code><a href="#topic+Lca">Lca</a></code>,
<code><a href="#topic+MoM">MoM</a></code>,
<code><a href="#topic+MoR">MoR</a></code>,
<code><a href="#topic+Sbm">Sbm</a></code>,
<code><a href="#topic+greed">greed</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MultSbmPrior()
MultSbmPrior(type = "undirected")
MultSbm()
MultSbm(type = "undirected")
</code></pre>

<hr>
<h2 id='MultSbmFit-class'>Multinomial Stochastic Block Model fit results class</h2><span id='topic+MultSbmFit-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a fit of a Multinomial Stochastic Block Model, extend <code><a href="#topic+IclFit-class">IclFit-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>a <code><a href="#topic+MultSbm-class">MultSbm-class</a></code> object to store the model fitted</p>
</dd>
<dt><code>name</code></dt><dd><p>generative model name</p>
</dd>
<dt><code>icl</code></dt><dd><p>icl value of the fitted model</p>
</dd>
<dt><code>K</code></dt><dd><p>number of extracted clusters over row and columns</p>
</dd>
<dt><code>cl</code></dt><dd><p>a numeric vector with row and columns cluster indexes</p>
</dd>
<dt><code>obs_stats</code></dt><dd><p>a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> x_counts: cube of size KxKxM with the number of links between each pair of clusters
</p>
</li></ul>
</dd>
<dt><code>move_mat</code></dt><dd><p>binary matrix which store move constraints</p>
</dd>
<dt><code>train_hist</code></dt><dd><p>data.frame with training history information (details depends on the training procedure)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+coef+2CMultSbmFit-method">coef,MultSbmFit-method</a></code>
</p>

<hr>
<h2 id='MultSbmPath-class'>Multinomial Stochastic Block Model hierarchical fit results class</h2><span id='topic+MultSbmPath-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a hierarchical fit of a Multinomial Stochastic Block Model, extend <code><a href="#topic+IclPath-class">IclPath-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>a <code><a href="#topic+MultSbm-class">MultSbm-class</a></code> object to store the model fitted</p>
</dd>
<dt><code>name</code></dt><dd><p>generative model name</p>
</dd>
<dt><code>icl</code></dt><dd><p>icl value of the fitted model</p>
</dd>
<dt><code>K</code></dt><dd><p>number of extracted clusters over row and columns</p>
</dd>
<dt><code>cl</code></dt><dd><p>a numeric vector with row and columns cluster indexes</p>
</dd>
<dt><code>obs_stats</code></dt><dd><p>a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> x_counts: matrix of size KxKxM with the number of links between each pair of clusters
</p>
</li></ul>
</dd>
<dt><code>path</code></dt><dd><p>a list of size K-1 with each part of the path described by:
</p>

<ul>
<li><p> icl1: icl value reach with this solution for alpha=1
</p>
</li>
<li><p> logalpha: log(alpha) value were this solution is better than its parent
</p>
</li>
<li><p> K: number of clusters
</p>
</li>
<li><p> cl: vector of cluster indexes
</p>
</li>
<li><p> k,l: index of the cluster that were merged at this step
</p>
</li>
<li><p> merge_mat: lower triangular matrix of delta icl values
</p>
</li>
<li><p> obs_stats: a list with the elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> x_counts: matrix of size KxKxM with the number of links between each pair of clusters
</p>
</li></ul>

</li></ul>
</dd>
<dt><code>logalpha</code></dt><dd><p>value of log(alpha)</p>
</dd>
<dt><code>ggtree</code></dt><dd><p>data.frame with complete merge tree for easy plotting with <code>ggplot2</code></p>
</dd>
<dt><code>tree</code></dt><dd><p>numeric vector with merge tree <code>tree[i]</code> contains the index of <code>i</code> father</p>
</dd>
<dt><code>train_hist</code></dt><dd><p>data.frame with training history information (details depends on the training procedure)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+plot+2CMultSbmFit+2Cmissing-method">plot,MultSbmFit,missing-method</a></code>
</p>

<hr>
<h2 id='mushroom'>Mushroom data</h2><span id='topic+mushroom'></span>

<h3>Description</h3>

<p>Categorical data from UCI Machine Learning Repository describing 8124
mushrooms with 22 phenotype variables. Each mushroom is classified as &quot;edible&quot;
or &quot;poisonous&quot; and the goal is to recover the mushroom class from its
phenotype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mushroom)
</code></pre>


<h3>Format</h3>

<p>An R data.frame with a variable edibility used as label and 22
categorical variables with no names. More detail on the UCI webpage
describing the data.
</p>


<h3>Source</h3>

<p><a href="https://archive.ics.uci.edu/ml/datasets/Mushroom">https://archive.ics.uci.edu/ml/datasets/Mushroom</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mushroom)
</code></pre>

<hr>
<h2 id='Ndrangheta'>Ndrangheta mafia covert network dataset</h2><span id='topic+Ndrangheta'></span>

<h3>Description</h3>

<p>Network of co-attendance occurrence attendance of suspected members of the Ndrangheta criminal organization at summits (meetings whose purpose is to make important decisions and/or affiliations, but also to solve internal problems and to establish roles and powers) taking place between 2007 and 2009.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Ndrangheta)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> with two fields;
</p>

<dl>
<dt>X</dt><dd><p>network adjacency matrix as a <code>matrix</code> of size 146x146</p>
</dd>
<dt>node_meta</dt><dd><p>data frame of nodes meta information with features :</p>
</dd>
</dl>

<dl>
<dt>Id</dt><dd><p>id of the node, rownames of network adjacency matrix</p>
</dd>
<dt>Locale</dt><dd><p>factor with the locali affiliation of the node , &quot;OUT&quot;: Suspects not belonging to La Lombardia, &quot;MISS&quot;: Information not available, other Locali Id.</p>
</dd>
<dt>Role</dt><dd><p>factor with the type of hierarchical position of the node &quot;MISS&quot;: Information not available,&quot;boss&quot;: high hierarchical position, &quot;aff&quot;: affiliate</p>
</dd>
</dl>




<h3>Source</h3>

<p><a href="https://sites.google.com/site/ucinetsoftware/datasets/covert-networks">ucinetsoftware/datasets/covert-networks</a>
</p>


<h3>References</h3>

<p>Extended Stochastic Block Models with Application to Criminal Networks, Sirio Legramanti and Tommaso Rigon and Daniele Durante and David B. Dunson, 2021,
(<a href="https://arxiv.org/abs/2007.08569v2">arXiv:2007.08569</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Ndrangheta)
</code></pre>

<hr>
<h2 id='NewGuinea'>NewGuinea data</h2><span id='topic+NewGuinea'></span>

<h3>Description</h3>

<p><code><a href="#topic+NewGuinea">NewGuinea</a></code> a social network of 16 tribes, where two types of interactions were recorded, amounting to either friendship or enmity [read-cultures-1954].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NewGuinea)
</code></pre>


<h3>Format</h3>

<p>A binary array of size (16,16,3) the first layer encodes enmity, the second, the friendship relations. The third, no relations between the two tribes.
</p>


<h3>Source</h3>

<p><a href="https://networks.skewed.de/net/new_guinea_tribes">https://networks.skewed.de/net/new_guinea_tribes</a>
</p>


<h3>References</h3>

<p>Kenneth E. Read, “Cultures of the Central Highlands, New Guinea”, Southwestern J. of Anthropology, 10(1):1-43 (1954). DOI: 10.1086/soutjanth.10.1.3629074
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(NewGuinea)
</code></pre>

<hr>
<h2 id='NMI'>Compute the normalized mutual information of two discrete samples</h2><span id='topic+NMI'></span>

<h3>Description</h3>

<p>Compute the normalized mutual information of two discrete samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMI(cl1, cl2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMI_+3A_cl1">cl1</code></td>
<td>
<p>vector of discrete labels</p>
</td></tr>
<tr><td><code id="NMI_+3A_cl2">cl2</code></td>
<td>
<p>vector of discrete labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the normalized mutual information between the two discrete samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cl1 &lt;- sample(2, 500, replace = TRUE)
cl2 &lt;- sample(2, 500, replace = TRUE)
NMI(cl1, cl2)
</code></pre>

<hr>
<h2 id='plot+2CDcLbmFit+2Cmissing-method'>Plot a <code><a href="#topic+DcLbmFit-class">DcLbmFit-class</a></code></h2><span id='topic+plot+2CDcLbmFit+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot a <code><a href="#topic+DcLbmFit-class">DcLbmFit-class</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DcLbmFit,missing'
plot(x, type = "blocks")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CDcLbmFit+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+DcLbmFit-class">DcLbmFit-class</a></code></p>
</td></tr>
<tr><td><code id="plot+2B2CDcLbmFit+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>a string which specify plot type:
</p>

<ul>
<li> <p><code>'blocks'</code>: plot a block matrix with summarizing connections between row and column clusters
</p>
</li>
<li> <p><code>'nodelink'</code>: plot a nodelink diagram of the bipartite graph summarizing connections between row and column clusters
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> graphic
</p>

<hr>
<h2 id='plot+2CDcLbmPath+2Cmissing-method'>Plot a <code><a href="#topic+DcLbmPath-class">DcLbmPath-class</a></code></h2><span id='topic+plot+2CDcLbmPath+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot a <code><a href="#topic+DcLbmPath-class">DcLbmPath-class</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DcLbmPath,missing'
plot(x, type = "tree")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CDcLbmPath+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+DcLbmPath-class">DcLbmPath-class</a></code></p>
</td></tr>
<tr><td><code id="plot+2B2CDcLbmPath+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>a string which specify plot type:
</p>

<ul>
<li> <p><code>'tree'</code>: plot a co-dendogram of rows and columns clusters
</p>
</li>
<li> <p><code>'blocks'</code>: plot a block matrix with summarizing connections between row and column clusters
</p>
</li>
<li> <p><code>'biplot'</code>: plot a block matrix with summarizing connections between row and column clusters aligned with row and clusters drendograms
</p>
</li>
<li> <p><code>'nodelink'</code>: plot a nodelink diagram of the bipartite graph summarizing connections between row and column clusters
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> graphic
</p>

<hr>
<h2 id='plot+2CDcSbmFit+2Cmissing-method'>Plot a <code><a href="#topic+DcSbmFit-class">DcSbmFit-class</a></code> object</h2><span id='topic+plot+2CDcSbmFit+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot a <code><a href="#topic+DcSbmFit-class">DcSbmFit-class</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DcSbmFit,missing'
plot(x, type = "blocks")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CDcSbmFit+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+DcSbmFit-class">DcSbmFit-class</a></code></p>
</td></tr>
<tr><td><code id="plot+2B2CDcSbmFit+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>a string which specify plot type:
</p>

<ul>
<li> <p><code>'blocks'</code>: plot a block matrix with summarizing connections between clusters
</p>
</li>
<li> <p><code>'nodelink'</code>: plot a nodelink diagram of the graph summarizing connections between clusters
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> graphic
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot+2CIclPath+2Cmissing-method">plot,IclPath,missing-method</a></code>
</p>

<hr>
<h2 id='plot+2CDiagGmmFit+2Cmissing-method'>Plot a <code><a href="#topic+DiagGmmFit-class">DiagGmmFit-class</a></code> object</h2><span id='topic+plot+2CDiagGmmFit+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot a <code><a href="#topic+DiagGmmFit-class">DiagGmmFit-class</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DiagGmmFit,missing'
plot(x, type = "marginals")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CDiagGmmFit+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+DiagGmmFit-class">DiagGmmFit-class</a></code></p>
</td></tr>
<tr><td><code id="plot+2B2CDiagGmmFit+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>a string which specify plot type:
</p>

<ul>
<li> <p><code>'marginals'</code>: plot the marginal densities
</p>
</li>
<li> <p><code>'violins'</code>: make a violin plot for each clusters and features
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> graphic
</p>

<hr>
<h2 id='plot+2CGmmFit+2Cmissing-method'>Plot a <code><a href="#topic+GmmFit-class">GmmFit-class</a></code> object</h2><span id='topic+plot+2CGmmFit+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot a <code><a href="#topic+GmmFit-class">GmmFit-class</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GmmFit,missing'
plot(x, type = "marginals")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CGmmFit+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+GmmFit-class">GmmFit-class</a></code></p>
</td></tr>
<tr><td><code id="plot+2B2CGmmFit+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>a string which specify plot type:
</p>

<ul>
<li> <p><code>'marginals'</code>: plot the marginal densities
</p>
</li>
<li> <p><code>'violins'</code>: make a violin plot for each clusters and features
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> graphic
</p>

<hr>
<h2 id='plot+2CIclPath+2Cmissing-method'>Plot an <code><a href="#topic+IclPath-class">IclPath-class</a></code> object</h2><span id='topic+plot+2CIclPath+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot an <code><a href="#topic+IclPath-class">IclPath-class</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'IclPath,missing'
plot(x, type = "tree")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CIclPath+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+IclPath-class">IclPath-class</a></code></p>
</td></tr>
<tr><td><code id="plot+2B2CIclPath+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>a string which specify plot type:
</p>

<ul>
<li> <p><code>'front'</code>: plot the extracted front ICL, log(alpha)
</p>
</li>
<li> <p><code>'path'</code>: plot the evolution of ICL with respect to K
</p>
</li>
<li> <p><code>'tree'</code>: plot the associated dendrogram
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> graphic
</p>

<hr>
<h2 id='plot+2CLcaFit+2Cmissing-method'>Plot a <code><a href="#topic+LcaFit-class">LcaFit-class</a></code> object</h2><span id='topic+plot+2CLcaFit+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot a <code><a href="#topic+LcaFit-class">LcaFit-class</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LcaFit,missing'
plot(x, type = "marginals")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CLcaFit+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+LcaFit-class">LcaFit-class</a></code></p>
</td></tr>
<tr><td><code id="plot+2B2CLcaFit+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>a string which specify plot type:
</p>

<ul>
<li> <p><code>'blocks'</code>: plot a block matrix with summarizing connections between clusters
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> graphic
</p>

<hr>
<h2 id='plot+2CMoMFit+2Cmissing-method'>Plot a <code><a href="#topic+MoMFit-class">MoMFit-class</a></code> object</h2><span id='topic+plot+2CMoMFit+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot a <code><a href="#topic+MoMFit-class">MoMFit-class</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MoMFit,missing'
plot(x, type = "blocks")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CMoMFit+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+MoMFit-class">MoMFit-class</a></code></p>
</td></tr>
<tr><td><code id="plot+2B2CMoMFit+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>a string which specify plot type:
</p>

<ul>
<li> <p><code>'blocks'</code>: plot a block matrix with summarizing connections between clusters
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> graphic
</p>

<hr>
<h2 id='plot+2CMultSbmFit+2Cmissing-method'>Plot a <code><a href="#topic+MultSbmFit-class">MultSbmFit-class</a></code> object</h2><span id='topic+plot+2CMultSbmFit+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot a <code><a href="#topic+MultSbmFit-class">MultSbmFit-class</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MultSbmFit,missing'
plot(x, type = "blocks")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CMultSbmFit+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+MultSbmFit-class">MultSbmFit-class</a></code></p>
</td></tr>
<tr><td><code id="plot+2B2CMultSbmFit+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>a string which specify plot type:
</p>

<ul>
<li> <p><code>'blocks'</code>: plot a block matrix with summarizing connections between clusters
</p>
</li>
<li> <p><code>'nodelink'</code>: plot a nodelink diagram of the graph summarizing connections between clusters
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> graphic
</p>

<hr>
<h2 id='plot+2CSbmFit+2Cmissing-method'>Plot a <code><a href="#topic+SbmFit-class">SbmFit-class</a></code> object</h2><span id='topic+plot+2CSbmFit+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot a <code><a href="#topic+SbmFit-class">SbmFit-class</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SbmFit,missing'
plot(x, type = "blocks")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CSbmFit+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+SbmFit-class">SbmFit-class</a></code></p>
</td></tr>
<tr><td><code id="plot+2B2CSbmFit+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>a string which specify plot type:
</p>

<ul>
<li> <p><code>'blocks'</code>: plot a block matrix with summarizing connections between clusters
</p>
</li>
<li> <p><code>'nodelink'</code>: plot a nodelink diagram of the graph summarizing connections between clusters
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> graphic
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot+2CIclPath+2Cmissing-method">plot,IclPath,missing-method</a></code>
</p>

<hr>
<h2 id='prior'>Generic method to extract the prior used to fit <code><a href="#topic+IclFit-class">IclFit-class</a></code> object</h2><span id='topic+prior'></span><span id='topic+prior+2CIclFit-method'></span>

<h3>Description</h3>

<p>This method take a <code><a href="#topic+IclFit-class">IclFit-class</a></code> object and return the prior used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prior(fit)

## S4 method for signature 'IclFit'
prior(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prior_+3A_fit">fit</code></td>
<td>
<p>an <code>IclFit</code> solution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 object describing the prior parameters
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>IclFit</code>: IclFit method
</p>
</li></ul>

<hr>
<h2 id='rdcsbm'>Generates graph adjacency matrix using a degree corrected SBM</h2><span id='topic+rdcsbm'></span>

<h3>Description</h3>

<p><code>rdcsbm</code> returns an adjacency matrix and the cluster labels generated randomly using a Degree Corrected Stochastic Block Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdcsbm(N, pi, mu, betain, betaout)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdcsbm_+3A_n">N</code></td>
<td>
<p>A numeric value the size of the graph to generate</p>
</td></tr>
<tr><td><code id="rdcsbm_+3A_pi">pi</code></td>
<td>
<p>A numeric vector of length K with clusters proportions. Must sum up to 1.</p>
</td></tr>
<tr><td><code id="rdcsbm_+3A_mu">mu</code></td>
<td>
<p>A numeric matrix of dim K x K with the connectivity pattern to generate, elements in [0,1].</p>
</td></tr>
<tr><td><code id="rdcsbm_+3A_betain">betain</code></td>
<td>
<p>A numeric vector of length N which specify the in-degree correction will be normalized per cluster during the generation.</p>
</td></tr>
<tr><td><code id="rdcsbm_+3A_betaout">betaout</code></td>
<td>
<p>A numeric vector of length N which specify the out-degree correction will be normalized per cluster during the generation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It takes the sample size, cluster proportions and emission matrix, and   as input and sample a graph accordingly together with the clusters labels.
</p>


<h3>Value</h3>

<p>A list with fields:
</p>

<ul>
<li><p> x: the count matrix as a <code>dgCMatrix</code>
</p>
</li>
<li><p> K: number of generated clusters
</p>
</li>
<li><p> N: number of vertex
</p>
</li>
<li><p> cl: vector of clusters labels
</p>
</li>
<li><p> pi: clusters proportions
</p>
</li>
<li><p> mu: connectivity matrix
</p>
</li>
<li><p> betain: normalized in-degree parameters
</p>
</li>
<li><p> betaout: normalized out-degree parameters
</p>
</li></ul>


<hr>
<h2 id='rlbm'>Generate a data matrix using a Latent Block Model</h2><span id='topic+rlbm'></span>

<h3>Description</h3>

<p><code>rlbm</code> returns the adjacency matrix and the cluster labels generated randomly with a Latent Block Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlbm(Nr, Nc, pir, pic, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlbm_+3A_nr">Nr</code></td>
<td>
<p>desired Number of rows</p>
</td></tr>
<tr><td><code id="rlbm_+3A_nc">Nc</code></td>
<td>
<p>desired Number of column</p>
</td></tr>
<tr><td><code id="rlbm_+3A_pir">pir</code></td>
<td>
<p>A numeric vector of length Kr with rows clusters proportions (will be normalized to sum up to 1).</p>
</td></tr>
<tr><td><code id="rlbm_+3A_pic">pic</code></td>
<td>
<p>A numeric vector of length Kc with columns clusters proportions (will be normalized to sum up to 1).</p>
</td></tr>
<tr><td><code id="rlbm_+3A_mu">mu</code></td>
<td>
<p>A numeric matrix of dim Kr x Kc with the connectivity pattern to generate. elements in [0,1].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the desired graph size, cluster proportions and connectivity matrix as input and sample a graph accordingly together with the clusters labels.
</p>


<h3>Value</h3>

<p>A list with fields:
</p>

<ul>
<li><p> x: the generated data matrix as a <code>dgCMatrix</code>
</p>
</li>
<li><p> clr: vector of row clusters labels
</p>
</li>
<li><p> clc: vector of column clusters labels
</p>
</li>
<li><p> Kr: number of generated row clusters
</p>
</li>
<li><p> Kc: number of generated column clusters
</p>
</li>
<li><p> Nr: number of rows
</p>
</li>
<li><p> Nc: number of column
</p>
</li>
<li><p> pir: row clusters proportions
</p>
</li>
<li><p> pic: column clusters proportions
</p>
</li>
<li><p> mu: connectivity matrix
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>simu &lt;- rlbm(500, 1000, rep(1 / 5, 5), rep(1 / 10, 10), matrix(runif(50), 5, 10))
</code></pre>

<hr>
<h2 id='rlca'>Generate data from lca model</h2><span id='topic+rlca'></span>

<h3>Description</h3>

<p><code>rlca</code> returns a data.frame with factor sampled from an lca model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlca(N, pi, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlca_+3A_n">N</code></td>
<td>
<p>The size of the graph to generate</p>
</td></tr>
<tr><td><code id="rlca_+3A_pi">pi</code></td>
<td>
<p>A numeric vector of length K with clusters proportions (will be normalized to sum up to 1).</p>
</td></tr>
<tr><td><code id="rlca_+3A_theta">theta</code></td>
<td>
<p>A list of size V</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the desired graph size, cluster proportions and connectivity matrix as input and sample a graph accordingly together with the clusters labels.
</p>


<h3>Value</h3>

<p>A list with fields:
</p>

<ul>
<li><p> x: the multi-graph adjacency matrix as an <code>array</code>
</p>
</li>
<li><p> K: number of generated clusters
</p>
</li>
<li><p> N: number of vertex
</p>
</li>
<li><p> cl: vector of clusters labels
</p>
</li>
<li><p> pi: clusters proportions
</p>
</li>
<li><p> theta:
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>theta &lt;- list(
  matrix(c(0.1, 0.9, 0.9, 0.1, 0.5, 0.5, 0.3, 0.7), ncol = 2, byrow = TRUE),
  matrix(c(0.5, 0.5, 0.3, 0.7, 0.05, 0.95, 0.3, 0.7), ncol = 2, byrow = TRUE),
  matrix(c(0.5, 0.5, 0.9, 0.1, 0.5, 0.5, 0.1, 0.9), ncol = 2, byrow = TRUE)
)
lca.data &lt;- rlca(100, rep(1 / 4, 4), theta)
</code></pre>

<hr>
<h2 id='rmm'>Generate data using a Multinomial Mixture</h2><span id='topic+rmm'></span>

<h3>Description</h3>

<p><code>rmm</code> returns a count matrix and the cluster labels generated randomly with a Mixture of Multinomial model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmm(N, pi, mu, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmm_+3A_n">N</code></td>
<td>
<p>A numeric value the size of the graph to generate</p>
</td></tr>
<tr><td><code id="rmm_+3A_pi">pi</code></td>
<td>
<p>A numeric vector of length K with clusters proportions. Must sum up to 1.</p>
</td></tr>
<tr><td><code id="rmm_+3A_mu">mu</code></td>
<td>
<p>A numeric matrix of dim k x D with the clusters patterns to generate, all elements in [0,1].</p>
</td></tr>
<tr><td><code id="rmm_+3A_lambda">lambda</code></td>
<td>
<p>A numeric value which specify the expectation for the row sums.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It takes the sample size, cluster proportions and emission matrix, and  as input and sample a graph accordingly together with the clusters labels.
</p>


<h3>Value</h3>

<p>A list with fields:
</p>

<ul>
<li><p> x: the count matrix as a <code>dgCMatrix</code>
</p>
</li>
<li><p> K: number of generated clusters
</p>
</li>
<li><p> N: number of vertex
</p>
</li>
<li><p> cl: vector of clusters labels
</p>
</li>
<li><p> pi: clusters proportions
</p>
</li>
<li><p> mu: connectivity matrix
</p>
</li>
<li><p> lambda: expectation of row sums
</p>
</li></ul>


<hr>
<h2 id='rmreg'>Generate data from a mixture of regression model</h2><span id='topic+rmreg'></span>

<h3>Description</h3>

<p><code>rmreg</code> returns an X matrix, a y vector and the cluster labels generated randomly with a Mixture of regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmreg(
  N,
  pi,
  A,
  sigma,
  X = cbind(rep(1, N), matrix(stats::rnorm(N * (ncol(A) - 1)), N, ncol(A) - 1))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmreg_+3A_n">N</code></td>
<td>
<p>A numeric value the size of the graph to generate</p>
</td></tr>
<tr><td><code id="rmreg_+3A_pi">pi</code></td>
<td>
<p>A numeric vector of length K with clusters proportions (must sum up to 1)</p>
</td></tr>
<tr><td><code id="rmreg_+3A_a">A</code></td>
<td>
<p>A numeric matrix of dim K x d with the regression coefficient</p>
</td></tr>
<tr><td><code id="rmreg_+3A_sigma">sigma</code></td>
<td>
<p>A numeric of length 1 with the target conditional variance</p>
</td></tr>
<tr><td><code id="rmreg_+3A_x">X</code></td>
<td>
<p>A matrix of covariate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It takes the sample size, cluster proportions and regression parameters matrix and variance  as input accordingly
</p>


<h3>Value</h3>

<p>A list with fields:
</p>

<ul>
<li><p> X: the covariate matrix
</p>
</li>
<li><p> y: the target feature
</p>
</li>
<li><p> K: number of generated clusters
</p>
</li>
<li><p> N: sample size
</p>
</li>
<li><p> cl: vector of clusters labels
</p>
</li>
<li><p> pi: clusters proportions
</p>
</li>
<li><p> A: regression coefficients used in the simulation
</p>
</li>
<li><p> sigma: conditional variance
</p>
</li></ul>


<hr>
<h2 id='rmultsbm'>Generate a graph adjacency matrix using a Stochastic Block Model</h2><span id='topic+rmultsbm'></span>

<h3>Description</h3>

<p><code>rmultsbm</code> returns the multi-graph adjacency matrix and the cluster labels generated randomly with a Multinomial Stochastic Block Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmultsbm(N, pi, mu, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmultsbm_+3A_n">N</code></td>
<td>
<p>The size of the graph to generate</p>
</td></tr>
<tr><td><code id="rmultsbm_+3A_pi">pi</code></td>
<td>
<p>A numeric vector of length K with clusters proportions (will be normalized to sum up to 1).</p>
</td></tr>
<tr><td><code id="rmultsbm_+3A_mu">mu</code></td>
<td>
<p>A numeric array of dim K x K x M with the connectivity pattern to generate. elements in [0,1].</p>
</td></tr>
<tr><td><code id="rmultsbm_+3A_lambda">lambda</code></td>
<td>
<p>A double with the Poisson intensity to generate the total counts</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the desired graph size, cluster proportions and connectivity matrix as input and sample a graph accordingly together with the clusters labels.
</p>


<h3>Value</h3>

<p>A list with fields:
</p>

<ul>
<li><p> x: the multi-graph adjacency matrix as an <code>array</code>
</p>
</li>
<li><p> K: number of generated clusters
</p>
</li>
<li><p> N: number of vertex
</p>
</li>
<li><p> cl: vector of clusters labels
</p>
</li>
<li><p> pi: clusters proportions
</p>
</li>
<li><p> mu: connectivity matrix
</p>
</li>
<li><p> lambda:
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>simu &lt;- rsbm(100, rep(1 / 5, 5), diag(rep(0.1, 5)) + 0.001)
</code></pre>

<hr>
<h2 id='rsbm'>Generate a graph adjacency matrix using a Stochastic Block Model</h2><span id='topic+rsbm'></span>

<h3>Description</h3>

<p><code>rsbm</code> returns the adjacency matrix and the cluster labels generated randomly with a Stochastic Block Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsbm(N, pi, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsbm_+3A_n">N</code></td>
<td>
<p>The size of the graph to generate</p>
</td></tr>
<tr><td><code id="rsbm_+3A_pi">pi</code></td>
<td>
<p>A numeric vector of length K with clusters proportions (will be normalized to sum up to 1).</p>
</td></tr>
<tr><td><code id="rsbm_+3A_mu">mu</code></td>
<td>
<p>A numeric matrix of dim K x K with the connectivity pattern to generate. elements in [0,1].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the desired graph size, cluster proportions and connectivity matrix as input and sample a graph accordingly together with the clusters labels.
</p>


<h3>Value</h3>

<p>A list with fields:
</p>

<ul>
<li><p> x: the graph adjacency matrix as a <code>dgCMatrix</code>
</p>
</li>
<li><p> K: number of generated clusters
</p>
</li>
<li><p> N: number of vertex
</p>
</li>
<li><p> cl: vector of clusters labels
</p>
</li>
<li><p> pi: clusters proportions
</p>
</li>
<li><p> mu: connectivity matrix
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>simu &lt;- rsbm(100, rep(1 / 5, 5), diag(rep(0.1, 5)) + 0.001)
</code></pre>

<hr>
<h2 id='Sbm'>Stochastic Block Model Prior class</h2><span id='topic+Sbm'></span><span id='topic+SbmPrior-class'></span><span id='topic+Sbm-class'></span><span id='topic+SbmPrior'></span>

<h3>Description</h3>

<p>An S4 class to represent a Stochastic Block Model.
Such model can be used to cluster graph vertex, and model a square adjacency matrix <code class="reqn">X</code> with the following generative model :
</p>
<p style="text-align: center;"><code class="reqn"> \pi \sim Dirichlet(\alpha)</code>
</p>

<p style="text-align: center;"><code class="reqn"> Z_i  \sim \mathcal{M}(1,\pi)</code>
</p>

<p style="text-align: center;"><code class="reqn"> \theta_{kl} \sim Beta(a_0,b_0)</code>
</p>

<p style="text-align: center;"><code class="reqn"> X_{ij}|Z_{ik}Z_{jl}=1 \sim \mathcal{B}(\theta_{kl})</code>
</p>

<p>These classes mainly store the prior parameters value <code class="reqn">\alpha,a_0,b_0</code> of this generative model.
The <code>Sbm-class</code> must be used when fitting a simple Sbm whereas the <code>SbmPrior-class</code> must be used when fitting a <code><a href="#topic+CombinedModels-class">CombinedModels-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SbmPrior(a0 = 1, b0 = 1, type = "guess")

Sbm(alpha = 1, a0 = 1, b0 = 1, type = "guess")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sbm_+3A_a0">a0</code></td>
<td>
<p>Beta prior parameter over links (default to 1)</p>
</td></tr>
<tr><td><code id="Sbm_+3A_b0">b0</code></td>
<td>
<p>Beta prior parameter over no-links (default to 1)</p>
</td></tr>
<tr><td><code id="Sbm_+3A_type">type</code></td>
<td>
<p>define the type of networks (either &quot;directed&quot;, &quot;undirected&quot; or &quot;guess&quot;, default to &quot;guess&quot;), for undirected graphs the adjacency matrix is supposed to be symmetric.</p>
</td></tr>
<tr><td><code id="Sbm_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameter over the cluster proportions (default to 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>SbmPrior-class</code> object
</p>
<p>a <code>Sbm-class</code> object
</p>


<h3>References</h3>

<p>Nowicki, Krzysztof and Tom A B Snijders (2001). “Estimation and prediction for stochastic block structures”. In:Journal of the American statistical association 96.455, pp. 1077–1087
</p>


<h3>See Also</h3>

<p><code><a href="#topic+greed">greed</a></code>
</p>
<p><code><a href="#topic+SbmFit-class">SbmFit-class</a></code>,<code><a href="#topic+SbmPath-class">SbmPath-class</a></code>
</p>
<p>Other DlvmModels: 
<code><a href="#topic+CombinedModels">CombinedModels</a></code>,
<code><a href="#topic+DcLbm">DcLbm</a></code>,
<code><a href="#topic+DcSbm">DcSbm</a></code>,
<code><a href="#topic+DiagGmm">DiagGmm</a></code>,
<code><a href="#topic+DlvmPrior-class">DlvmPrior-class</a></code>,
<code><a href="#topic+Gmm">Gmm</a></code>,
<code><a href="#topic+Lca">Lca</a></code>,
<code><a href="#topic+MoM">MoM</a></code>,
<code><a href="#topic+MoR">MoR</a></code>,
<code><a href="#topic+MultSbm">MultSbm</a></code>,
<code><a href="#topic+greed">greed</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Sbm()
SbmPrior()
SbmPrior(type = "undirected")
Sbm()
Sbm(type = "undirected")
</code></pre>

<hr>
<h2 id='SbmFit-class'>Stochastic Block Model fit results class</h2><span id='topic+SbmFit-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a fit of a Stochastic Block Model, extend <code><a href="#topic+IclFit-class">IclFit-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>a <code><a href="#topic+Sbm-class">Sbm-class</a></code> object to store the model fitted</p>
</dd>
<dt><code>name</code></dt><dd><p>generative model name</p>
</dd>
<dt><code>icl</code></dt><dd><p>icl value of the fitted model</p>
</dd>
<dt><code>K</code></dt><dd><p>number of extracted clusters over rows and columns</p>
</dd>
<dt><code>cl</code></dt><dd><p>a numeric vector with row and columns cluster indexes</p>
</dd>
<dt><code>obs_stats</code></dt><dd><p>a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> x_counts: matrix of size K*K with the number of links between each pair of clusters
</p>
</li></ul>
</dd>
<dt><code>move_mat</code></dt><dd><p>binary matrix which store move constraints</p>
</dd>
<dt><code>train_hist</code></dt><dd><p>data.frame with training history information (details depends on the training procedure)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+coef+2CSbmFit-method">coef,SbmFit-method</a></code>
</p>

<hr>
<h2 id='SbmPath-class'>Stochastic Block Model hierarchical fit results class</h2><span id='topic+SbmPath-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a hierarchical fit of a stochastic block model, extend <code><a href="#topic+IclPath-class">IclPath-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>a <code><a href="#topic+Sbm-class">Sbm-class</a></code> object to store the model fitted</p>
</dd>
<dt><code>name</code></dt><dd><p>generative model name</p>
</dd>
<dt><code>icl</code></dt><dd><p>icl value of the fitted model</p>
</dd>
<dt><code>K</code></dt><dd><p>number of extracted clusters over row and columns</p>
</dd>
<dt><code>cl</code></dt><dd><p>a numeric vector with row and columns cluster indexes</p>
</dd>
<dt><code>obs_stats</code></dt><dd><p>a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> x_counts: matrix of size K*K with the number of links between each pair of clusters
</p>
</li></ul>
</dd>
<dt><code>path</code></dt><dd><p>a list of size K-1 with that store all the solutions along the path. Each element is a list with the following fields:
</p>

<ul>
<li><p> icl1: icl value reach with this solution for alpha=1
</p>
</li>
<li><p> logalpha: log(alpha) value were this solution is better than its parent
</p>
</li>
<li><p> K: number of clusters
</p>
</li>
<li><p> cl: vector of cluster indexes
</p>
</li>
<li><p> k,l: index of the cluster that were merged at this step
</p>
</li>
<li><p> merge_mat: lower triangular matrix of delta icl values
</p>
</li>
<li><p> obs_stats: a list with the following elements:
</p>

<ul>
<li><p> counts: numeric vector of size K with number of elements in each clusters
</p>
</li>
<li><p> x_counts: matrix of size K*K with the number of links between each pair of clusters
</p>
</li></ul>

</li></ul>
</dd>
<dt><code>logalpha</code></dt><dd><p>value of log(alpha)</p>
</dd>
<dt><code>ggtree</code></dt><dd><p>data.frame with complete merge tree for easy plotting with <code>ggplot2</code></p>
</dd>
<dt><code>tree</code></dt><dd><p>numeric vector with merge tree <code>tree[i]</code> contains the index of <code>i</code> father</p>
</dd>
<dt><code>train_hist</code></dt><dd><p>data.frame with training history information (details depends on the training procedure)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+plot+2CSbmFit+2Cmissing-method">plot,SbmFit,missing-method</a></code>
</p>

<hr>
<h2 id='Seed-class'>Greedy algorithm with seeded initialization</h2><span id='topic+Seed-class'></span><span id='topic+Seed'></span>

<h3>Description</h3>

<p>An S4 class to represent a greedy algorithm with initialization from spectral clustering and or k-means (extends <code><a href="#topic+Alg-class">Alg-class</a></code> class ).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Seed()
</code></pre>


<h3>Value</h3>

<p>a <code>Seed-class</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>Seed</code>: Seed algorithm class constructor
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>Seed()
</code></pre>

<hr>
<h2 id='SevenGraders'>SevenGraders data</h2><span id='topic+SevenGraders'></span>

<h3>Description</h3>

<p><code><a href="#topic+SevenGraders">SevenGraders</a></code> A small multiplex network of friendships among 29 seventh grade students in Victoria, Australia. Students nominated classmates for three different activities (who do you get on with in the class, who are your best friends, and who would you prefer to work with). Edge direction for each of these three types of edges indicates if node i nominated node j, and the edge weight gives the frequency of this nomination. Students 1-12 are boys and 13-29 are girls. The KONECT version of this network is the collapse of de Domenico's multiplex version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SevenGraders)
</code></pre>


<h3>Format</h3>

<p>A binary array of size (29,29,3) containing directed graphs. The first layer encodes &quot;getting along in class&quot; while the second encodes the best-friendship (can be one-way). The third encodes the preferred work relation.
</p>


<h3>Source</h3>

<p><a href="https://networks.skewed.de/net/7th_graders">https://networks.skewed.de/net/7th_graders</a>
</p>


<h3>References</h3>

<p>M. Vickers and S. Chan, &quot;Representing Classroom Social Structure.&quot; Melbourne: Victoria Institute of Secondary Education, (1981).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SevenGraders)
</code></pre>

<hr>
<h2 id='show+2CIclFit-method'>Show an IclPath object</h2><span id='topic+show+2CIclFit-method'></span>

<h3>Description</h3>

<p>Print an <code><a href="#topic+IclPath-class">IclPath-class</a></code> object, model type and number of found clusters are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'IclFit'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CIclFit-method_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+IclPath-class">IclPath-class</a></code> object to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None (invisible NULL). No return value, called for side effects.
</p>

<hr>
<h2 id='spectral'>Regularized spectral clustering</h2><span id='topic+spectral'></span>

<h3>Description</h3>

<p>performs regularized spectral clustering of a sparse adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectral(X, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectral_+3A_x">X</code></td>
<td>
<p>An adjacency matrix in sparse format (see the <code>Matrix</code> package)</p>
</td></tr>
<tr><td><code id="spectral_+3A_k">K</code></td>
<td>
<p>Desired number of cluster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cl Vector of cluster labels
</p>


<h3>References</h3>

<p>Tai Qin, Karl Rohe. Regularized Spectral Clustering under the Degree-Corrected Stochastic Block Model. Nips 2013.
</p>

<hr>
<h2 id='to_multinomial'>Convert a binary adjacency matrix with missing value to a cube</h2><span id='topic+to_multinomial'></span>

<h3>Description</h3>

<p>Convert a binary adjacency matrix with missing value to a cube
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_multinomial(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_multinomial_+3A_x">X</code></td>
<td>
<p>A binary adjacency matrix with NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cube
</p>

<hr>
<h2 id='Youngpeoplesurvey'>Young People survey data</h2><span id='topic+Youngpeoplesurvey'></span>

<h3>Description</h3>

<p>Young people survey data from Miroslav Sabo and available on the Kaggle
platform. This is an authentic example of questionnaire data where Slovakian
young people (15-30 years old) were asked musical preferences according to
different genres (rock, hip-hop, classical, etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Youngpeoplesurvey)
</code></pre>


<h3>Format</h3>

<p>An R data.frame with columns containing each of the 150 original
variables of the study.
</p>


<h3>Source</h3>

<p><a href="https://www.kaggle.com/miroslavsabo/young-people-survey">https://www.kaggle.com/miroslavsabo/young-people-survey</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Youngpeoplesurvey)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
