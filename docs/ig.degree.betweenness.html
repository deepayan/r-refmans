<!DOCTYPE html><html lang="en"><head><title>Help for package ig.degree.betweenness</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ig.degree.betweenness}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cluster_degree_betweenness'><p>Community structure detection based on node degree centrality and edge betweenness</p></a></li>
<li><a href='#plot_simplified_edgeplot'><p>Plot Simplified Edgeplot</p></a></li>
<li><a href='#prep_unlabeled_graph'><p>Prepared Unlabeled Graph to work with Degree-Betweenness Algorithm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>"Smith-Pittman Community Detection Algorithm for 'igraph'
Objects (2024)"</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the "Smith-Pittman" community detection algorithm  
    for network analysis using 'igraph' objects. This algorithm combines node 
    degree and betweenness centrality measures to identify communities within 
    networks, with a gradient evident in social partitioning. The package 
    provides functions for community detection, visualization, and analysis of 
    the resulting community structure. Methods are based on results from Smith, 
    Pittman and Xu (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2411.01394">doi:10.48550/arXiv.2411.01394</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/benyamindsmith/ig.degree.betweenness">https://github.com/benyamindsmith/ig.degree.betweenness</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/benyamindsmith/ig.degree.betweenness/issues">https://github.com/benyamindsmith/ig.degree.betweenness/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, igraphdata, rlist, BBmisc, qgraph</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-11 15:46:46 UTC; ben29</td>
</tr>
<tr>
<td>Author:</td>
<td>Benjamin Smith <a href="https://orcid.org/0009-0007-2206-0177"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Tyler Pittman <a href="https://orcid.org/0000-0002-5013-6980"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Wei Xu <a href="https://orcid.org/0000-0002-0257-8856"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benjamin Smith &lt;benyamin.smith@mail.utoronto.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-11 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cluster_degree_betweenness'>Community structure detection based on node degree centrality and edge betweenness</h2><span id='topic+cluster_degree_betweenness'></span>

<h3>Description</h3>

<p>Referred to as the &quot;Smith-Pittman&quot; algorithm in Smith et al (2024). This algorithm detects communities by calculating the degree centrality measures of nodes and edge betweenness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_degree_betweenness(graph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_degree_betweenness_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This can be thought of as an alternative version of <code>igraph::cluster_edge_betweeness()</code>.
</p>
<p>The function iteratively removes edges based on their betweenness centrality and the degree of their adjacent nodes. At each iteration, it identifies the edge with the highest betweenness centrality among those connected to nodes with the highest degree.It then removes that edge and recalculates the modularity of the resulting graph. The process continues until all edges have been assessed or until no further subgraph can be created with the optimal number of communites being chosen based on maximization of modularity.
</p>


<h3>Value</h3>

<p>An igraph &quot;communities&quot; object with detected communities via the Smith-Pittman algorithm.
</p>


<h3>References</h3>

<p>Smith et al (2024) &quot;Centrality in Collaboration: A Novel Algorithm for Social Partitioning Gradients in Community Detection for Multiple Oncology Clinical Trial Enrollments&quot;, &lt;doi:10.48550/arXiv.2411.01394&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraphdata)
data("karate")
ndb &lt;- cluster_degree_betweenness(karate)
plot(
ndb,
karate,
main= "Degree-Betweenness Clustering"
)

ndb

# UNLABELED GRAPH EXAMPLE

data("UKfaculty")
# Making graph undirected so it looks nicer when its plotted
uk_faculty &lt;- prep_unlabeled_graph(UKfaculty) |&gt;
  igraph::as.undirected()

ndb &lt;- cluster_degree_betweenness(uk_faculty)

plot(
  ndb,
  uk_faculty,
  main= "Smith-Pittman Clustering for UK Faculty"
)

</code></pre>

<hr>
<h2 id='plot_simplified_edgeplot'>Plot Simplified Edgeplot</h2><span id='topic+plot_simplified_edgeplot'></span>

<h3>Description</h3>

<p>This function generates a simplified edge plot of an igraph object, optionally highlighting communities if provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_simplified_edgeplot(graph, communities = NULL, edge.arrow.size = 0.2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_simplified_edgeplot_+3A_graph">graph</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="plot_simplified_edgeplot_+3A_communities">communities</code></td>
<td>
<p>optional; A communities object</p>
</td></tr>
<tr><td><code id="plot_simplified_edgeplot_+3A_edge.arrow.size">edge.arrow.size</code></td>
<td>
<p>edge.arrow size arg. See ?igraph::plot.igraph for more details</p>
</td></tr>
<tr><td><code id="plot_simplified_edgeplot_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the <code>plot()</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is ideally for networks with a low number of nodes having varying numbers of connection and self loops. See the example for a better visual understanding.
</p>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the igraph package
library(igraph)
library(ig.degree.betweenness)
# Set parameters
num_nodes &lt;- 15    # Number of nodes (adjust as needed)
initial_edges &lt;- 1   # Starting edges for preferential attachment

# Create a directed, scale-free network using the Barab√°si-Albert model
g &lt;- sample_pa(n = num_nodes, m = initial_edges, directed = TRUE)

# Introduce additional edges to high-degree nodes to accentuate popularity differences
num_extra_edges &lt;- 350   # Additional edges to create more popular nodes
set.seed(123)           # For reproducibility

for (i in 1:num_extra_edges) {
  # Sample nodes with probability proportional to their degree (to reinforce popularity)
  from &lt;- sample(V(g), 1, prob = degree(g, mode = "in") + 1)  # +1 to avoid zero probabilities
  to &lt;- sample(V(g), 1)

  # Ensure we don't add the same edge repeatedly unless intended, allowing self-loops
  g &lt;- add_edges(g, c(from, to))
}

# Add self-loops to a subset of nodes
num_self_loops &lt;- 5
for (i in 1:num_self_loops) {
  node &lt;- sample(V(g), 1)
  g &lt;- add_edges(g, c(node, node))
}


g_ &lt;- ig.degree.betweenness::prep_unlabeled_graph(g)

ig.degree.betweenness::plot_simplified_edgeplot(g_,main="Simulated Data")
</code></pre>

<hr>
<h2 id='prep_unlabeled_graph'>Prepared Unlabeled Graph to work with Degree-Betweenness Algorithm</h2><span id='topic+prep_unlabeled_graph'></span>

<h3>Description</h3>

<p>Presently, <code>cluster_degree_betweenness()</code> function only works with labeled graphs. <code>prep_unlabeled_graph()</code> is a utility function that gives an unlabeled graph labels which are string values of their vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_unlabeled_graph(graph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_unlabeled_graph_+3A_graph">graph</code></td>
<td>
<p>an unlabeled graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An &quot;igraph&quot; object with named vertices.
</p>


<h3>See Also</h3>

<p>[cluster_degree_betweenness()] which this function aids.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
library(igraphdata)
library(ig.degree.betweenness)
data("UKfaculty")
# Making graph undirected so it looks nicer when its plotted
uk_faculty &lt;- prep_unlabeled_graph(UKfaculty) |&gt;
  as.undirected()

ndb &lt;- cluster_degree_betweenness(uk_faculty)

plot(
ndb,
uk_faculty,
main= "Node Degree Clustering"
)

ndb
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
