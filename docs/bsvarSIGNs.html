<!DOCTYPE html><html lang="en"><head><title>Help for package bsvarSIGNs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bsvarSIGNs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bsvarSIGNs-package'><p>Bayesian Estimation of Structural Vector Autoregressions Identified</p>
by Sign, Zero, and Narrative Restrictions</a></li>
<li><a href='#compute_conditional_sd.PosteriorBSVARSIGN'><p>Computes posterior draws of structural shock conditional standard deviations</p></a></li>
<li><a href='#compute_fitted_values.PosteriorBSVARSIGN'><p>Computes posterior draws from data predictive density</p></a></li>
<li><a href='#compute_historical_decompositions.PosteriorBSVARSIGN'><p>Computes posterior draws of historical decompositions</p></a></li>
<li><a href='#compute_impulse_responses.PosteriorBSVARSIGN'><p>Computes posterior draws of impulse responses</p></a></li>
<li><a href='#compute_structural_shocks.PosteriorBSVARSIGN'><p>Computes posterior draws of structural shocks</p></a></li>
<li><a href='#compute_variance_decompositions.PosteriorBSVARSIGN'><p>Computes posterior draws of the forecast error variance decomposition</p></a></li>
<li><a href='#estimate.BSVARSIGN'><p>Bayesian estimation of a Structural Vector Autoregression</p>
with traditional and narrative sign restrictions via Gibbs sampler</a></li>
<li><a href='#forecast.PosteriorBSVARSIGN'><p>Forecasting using Structural Vector Autoregression</p></a></li>
<li><a href='#monetary'><p>A 6-variable US monetary policy data, from 1965 Jan to 2007 Aug</p></a></li>
<li><a href='#optimism'><p>A 5-variable US business cycle data, from 1955 Q1 to 2004 Q4</p></a></li>
<li><a href='#specify_bsvarSIGN'><p>R6 Class representing the specification of the BSVARSIGN model</p></a></li>
<li><a href='#specify_identification_bsvarSIGN'><p>R6 Class Representing IdentificationBSVARSIGN</p></a></li>
<li><a href='#specify_narrative'><p>vector specifying one narrative restriction</p></a></li>
<li><a href='#specify_posterior_bsvarSIGN'><p>R6 Class Representing PosteriorBSVARSIGN</p></a></li>
<li><a href='#specify_prior_bsvarSIGN'><p>R6 Class Representing PriorBSVAR</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian SVARs with Sign, Zero, and Narrative Restrictions</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-28</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xiaolei Wang &lt;adamwang15@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements state-of-the-art algorithms for the Bayesian analysis of Structural Vector Autoregressions (SVARs) identified by sign, zero, and narrative restrictions. The core model is based on a flexible Vector Autoregression with estimated hyper-parameters of the Minnesota prior and the dummy observation priors as in Giannone, Lenza, Primiceri (2015) &lt;<a href="https://doi.org/10.1162%2FREST_a_00483">doi:10.1162/REST_a_00483</a>&gt;. The sign restrictions are implemented employing the methods proposed by Rubio-Ramírez, Waggoner &amp; Zha (2010) &lt;<a href="https://doi.org/10.1111%2Fj.1467-937X.2009.00578.x">doi:10.1111/j.1467-937X.2009.00578.x</a>&gt;, while identification through sign and zero restrictions follows the approach developed by Arias, Rubio-Ramírez, &amp; Waggoner (2018) &lt;<a href="https://doi.org/10.3982%2FECTA14468">doi:10.3982/ECTA14468</a>&gt;. Furthermore, our tool provides algorithms for identification via sign and narrative restrictions, in line with the methods introduced by Antolín-Díaz and Rubio-Ramírez (2018) &lt;<a href="https://doi.org/10.1257%2Faer.20161852">doi:10.1257/aer.20161852</a>&gt;. Users can also estimate a model with sign, zero, and narrative restrictions imposed at once. The package facilitates predictive and structural analyses using impulse responses, forecast error variance and historical decompositions, forecasting and conditional forecasting, as well as analyses of structural shocks and fitted values. All this is complemented by colourful plots, user-friendly summary functions, and comprehensive documentation including the vignette by Wang &amp; Woźniak (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2501.16711">doi:10.48550/arXiv.2501.16711</a>&gt;. The 'bsvarSIGNs' package is aligned regarding objects, workflows, and code structure with the R package 'bsvars' by Woźniak (2024) &lt;<a href="https://doi.org/10.32614%2FCRAN.package.bsvars">doi:10.32614/CRAN.package.bsvars</a>&gt;, and they constitute an integrated toolset. It was granted the Di Cook Open-Source Statistical Software Award by the Statistical Society of Australia in 2024.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.12), RcppProgress, R6</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress, bsvars</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0), RcppArmadillo, bsvars</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, tinytest</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bsvars.org/bsvarSIGNs/">https://bsvars.org/bsvarSIGNs/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bsvars/bsvarSIGNs/issues">https://github.com/bsvars/bsvarSIGNs/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-30 02:32:02 UTC; adam</td>
</tr>
<tr>
<td>Author:</td>
<td>Xiaolei Wang <a href="https://orcid.org/0009-0005-6192-9061"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Tomasz Woźniak <a href="https://orcid.org/0000-0003-2212-2378"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-30 03:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bsvarSIGNs-package'>Bayesian Estimation of Structural Vector Autoregressions Identified 
by Sign, Zero, and Narrative Restrictions</h2><span id='topic+bsvarSIGNs-package'></span><span id='topic+bsvarSIGNs'></span>

<h3>Description</h3>

<p>Implements state-of-the-art algorithms for the Bayesian analysis 
of Structural Vector Autoregressions identified by sign, zero, and narrative 
restrictions. The core model is based on a flexible Vector Autoregression with 
estimated hyper-parameters of the Minnesota prior and the dummy observation priors
as in Giannone, Lenza, Primiceri (2015) &lt;doi:10.1162/REST_a_00483&gt;. The sign 
restrictions are implemented employing the methods proposed by 
Rubio-Ramírez, Waggoner &amp; Zha (2010) &lt;doi:10.1111/j.1467-937X.2009.00578.x&gt;, 
while identification through sign and zero restrictions follows the approach 
developed by Arias, Rubio-Ramírez, &amp; Waggoner (2018) &lt;doi:10.3982/ECTA14468&gt;. 
Furthermore, our tool provides algorithms for identification via sign and 
narrative restrictions, in line with the methods introduced by 
Antolín-Díaz and Rubio-Ramírez (2018) &lt;doi:10.1257/aer.20161852&gt;. Users can 
also estimate a model with sign, zero, and narrative restrictions imposed at 
once. The package facilitates predictive and structural analyses using 
impulse responses, forecast error variance and historical decompositions, 
forecasting and conditional forecasting, as well as analyses of structural 
shocks and fitted values. All this is complemented by colourful plots, 
user-friendly summary functions, and comprehensive documentation. The 
'bsvarSIGNs' package is aligned regarding objects, workflows, and code 
structure with the R package 'bsvars' by 
Woźniak (2024) &lt;doi:10.32614/CRAN.package.bsvars&gt;, and they constitute an 
integrated toolset. It was granted the Di Cook Open-Source Statistical 
Software Award by the Statistical Society of Australia in 2024.
</p>


<h3>Details</h3>

<p><strong>Models.</strong> All the SVAR models in this package are specified by two 
equations, including the reduced form equation:
</p>
<p style="text-align: center;"><code class="reqn">y_t = Ax_t + \epsilon_t</code>
</p>

<p>where <code class="reqn">y_t</code> is an <code>N</code>-vector of dependent variables, 
<code class="reqn">x_t</code> is a <code>K</code>-vector of explanatory variables, 
<code class="reqn">\epsilon_t</code> is an <code>N</code>-vector of reduced form error terms, 
and <code class="reqn">A</code> is an <code>NxK</code> matrix of autoregressive slope coefficients and 
parameters on deterministic terms in <code class="reqn">x_t</code>.
</p>
<p>The structural equation is given by:
</p>
<p style="text-align: center;"><code class="reqn">B\epsilon_t = u_t</code>
</p>

<p>where <code class="reqn">u_t</code> is an <code>N</code>-vector of structural shocks, and
<code class="reqn">B</code> is an <code>NxN</code> matrix of contemporaneous relationships.
</p>
<p>Finally, all of the models share the following assumptions regarding the 
structural shocks <code>u_t</code>, namely, joint conditional normality given the 
past observations collected in matrix <code>x_t</code>, and temporal and 
contemporaneous independence. The latter implies zero correlations and 
autocorrelations.
</p>
<p><strong>Identification.</strong> The identification of the SVAR model is achieved by 
imposing:
</p>

<ul>
<li><p> sign restrictions on the structural matrix <code class="reqn">B</code>,
</p>
</li>
<li><p> sign and zero restrictions on the zero-horizon impulse responses <code class="reqn">\Theta_0 = B^{-1}</code>,
</p>
</li>
<li><p> sign restrictions on the impulse responses at other horizons <code class="reqn">\Theta_i</code> for <code class="reqn">i = 1, 2, \ldots</code>,
</p>
</li>
<li><p> sign restrictions on selected structural shocks <code class="reqn">u_t</code>,
</p>
</li>
<li><p> two types of sign restrictions on the historical decompositions.
</p>
</li></ul>

<p>These restrictions determine the sampling algorithms of the structural matrix 
<code class="reqn">B</code> defined as
</p>
<p style="text-align: center;"><code class="reqn">B = Q'L</code>
</p>

<p>where <code class="reqn">Q</code> is an <code>NxN</code> orthogonal matrix and <code class="reqn">L</code> is a lower-triangular 
matrix <code class="reqn">L = chol(\Sigma)^{-1}</code>, and <code class="reqn">\Sigma</code> is the <code>NxN</code> 
conditional covariance matrix of the reduced-form error term <code class="reqn">\epsilon_t</code>.
Consult the original papers by Rubio-Ramírez, Waggoner &amp; Zha (2010), 
Arias, Rubio-Ramírez, &amp; Waggoner (2018) and Antolín-Díaz and Rubio-Ramírez (2018)
for more details.
</p>
<p><strong>Prior distributions.</strong> All the models feature a hierarchical Minnesota 
prior following the specification proposed by Giannone, Lenza, Primiceri (2015)
and featuring:
</p>

<ul>
<li><p> appropriate handling of unit-root non-stationary variables through 
the prior mean of the autoregressive coefficients <code class="reqn">A</code>,
</p>
</li>
<li><p> normal prior shrinkage exhibiting exponential decay in the lag order 
of the autoregressive matrices,
</p>
</li>
<li><p> sum-of-coefficients and dummy-initial-observation prior,
</p>
</li>
<li><p> estimated shrinkage hyper-parameters,
</p>
</li>
<li><p> inverse-Wishart prior for the reduced-form covariance matrix <code class="reqn">\Sigma</code>,
</p>
</li>
<li><p> estimated diagonal elements of the inverse-Wishart prior scale matrix.
</p>
</li></ul>



<h3>Note</h3>

<p>This package is currently in active development. Your comments,
suggestions and requests are warmly welcome!
</p>


<h3>Author(s)</h3>

<p>Xiaolei Wang <a href="mailto:adamwang15@gmail.com">adamwang15@gmail.com</a> &amp; Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Antolín-Díaz &amp; Rubio-Ramírez (2018) Narrative Sign Restrictions for SVARs, American Economic Review, 108(10), 2802-29, &lt;doi:10.1257/aer.20161852&gt;.
</p>
<p>Arias, Rubio-Ramírez, &amp; Waggoner (2018), Inference Based on Structural Vector Autoregressions Identified With Sign and Zero Restrictions: Theory and Applications, Econometrica, 86(2), 685-720, &lt;doi:10.3982/ECTA14468&gt;.
</p>
<p>Giannone, Lenza, Primiceri (2015) Prior Selection for Vector Autoregressions, Review of Economics and Statistics, 97(2), 436-451 &lt;doi:10.1162/REST_a_00483&gt;.
</p>
<p>Rubio-Ramírez, Waggoner &amp; Zha (2010) Structural Vector Autoregressions: Theory of Identification and Algorithms for Inference, The Review of Economic Studies, 77(2), 665-696, &lt;doi:10.1111/j.1467-937X.2009.00578.x&gt;.
</p>
<p>Woźniak (2024) bsvars: Bayesian Estimation of Structural Vector Autoregressive Models. R package version 3.1, &lt;doi:10.32614/CRAN.package.bsvars&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># investigate the effects of the optimism shock
data(optimism)

# specify identifying restrictions:
# + no effect on productivity (zero restriction)
# + positive effect on stock prices (positive sign restriction)
sign_irf       = matrix(c(0, 1, rep(NA, 23)), 5, 5)

# specify the model
specification  = specify_bsvarSIGN$new(optimism * 100,
                                       p        = 4,
                                       sign_irf = sign_irf)
                                       
# estimate the model
posterior      = estimate(specification, S = 100)

# compute and plot impulse responses
irf            = compute_impulse_responses(posterior, horizon = 40)
plot(irf, probability = 0.68)

</code></pre>

<hr>
<h2 id='compute_conditional_sd.PosteriorBSVARSIGN'>Computes posterior draws of structural shock conditional standard deviations</h2><span id='topic+compute_conditional_sd.PosteriorBSVARSIGN'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models is 
transformed into a draw from the posterior distribution of the structural 
shock conditional standard deviations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARSIGN'
compute_conditional_sd(posterior)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_conditional_sd.PosteriorBSVARSIGN_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARSIGN</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PosteriorSigma</code>, that is, an <code>NxTxS</code> 
array with attribute <code>PosteriorSigma</code> containing <code>S</code> draws of the 
structural shock conditional standard deviations.
</p>


<h3>Author(s)</h3>

<p>Xiaolei Wang <a href="mailto:adamwang15@gmail.com">adamwang15@gmail.com</a> and Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate.BSVARSIGN">estimate.BSVARSIGN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(optimism)

# specify the model and set seed
set.seed(123)

# + no effect on productivity (zero restriction)
# + positive effect on stock prices (positive sign restriction) 
sign_irf       = matrix(c(0, 1, rep(NA, 23)), 5, 5)
specification  = specify_bsvarSIGN$new(optimism, sign_irf = sign_irf)

# estimate the model
posterior      = estimate(specification, 10)

# compute structural shocks' conditional standard deviations
sigma          = compute_conditional_sd(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
optimism |&gt;
  specify_bsvarSIGN$new(sign_irf = sign_irf) |&gt; 
  estimate(S = 10) |&gt; 
  compute_conditional_sd() -&gt; csd

</code></pre>

<hr>
<h2 id='compute_fitted_values.PosteriorBSVARSIGN'>Computes posterior draws from data predictive density</h2><span id='topic+compute_fitted_values.PosteriorBSVARSIGN'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from 
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the data predictive density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARSIGN'
compute_fitted_values(posterior)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_fitted_values.PosteriorBSVARSIGN_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARSIGN</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PosteriorFitted</code>, that is, an <code>NxTxS</code> 
array with attribute <code>PosteriorFitted</code> containing <code>S</code> draws from 
the data predictive density.
</p>


<h3>Author(s)</h3>

<p>Xiaolei Wang <a href="mailto:adamwang15@gmail.com">adamwang15@gmail.com</a> and Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate.BSVARSIGN">estimate.BSVARSIGN</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="base.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(optimism)

# specify the model and set seed
set.seed(123)

# + no effect on productivity (zero restriction)
# + positive effect on stock prices (positive sign restriction) 
sign_irf       = matrix(c(0, 1, rep(NA, 23)), 5, 5)
specification  = specify_bsvarSIGN$new(optimism, sign_irf = sign_irf)

# estimate the model
posterior      = estimate(specification, 10)

# compute draws from in-sample predictive density
fitted         = compute_fitted_values(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
optimism |&gt;
  specify_bsvarSIGN$new(sign_irf = sign_irf) |&gt; 
  estimate(S = 20) |&gt; 
  compute_fitted_values() -&gt; fitted

</code></pre>

<hr>
<h2 id='compute_historical_decompositions.PosteriorBSVARSIGN'>Computes posterior draws of historical decompositions</h2><span id='topic+compute_historical_decompositions.PosteriorBSVARSIGN'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the posterior distribution of the historical decompositions. 
IMPORTANT! The historical decompositions are interpreted correctly for 
covariance stationary data. Application to unit-root non-stationary data might
result in non-interpretable outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARSIGN'
compute_historical_decompositions(posterior, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_historical_decompositions.PosteriorBSVARSIGN_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARSIGN</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="compute_historical_decompositions.PosteriorBSVARSIGN_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value, if <code>TRUE</code> the estimation progress bar is visible</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PosteriorHD</code>, that is, an <code>NxNxTxS</code> array 
with attribute <code>PosteriorHD</code> containing <code>S</code> draws of the historical 
decompositions.
</p>


<h3>Author(s)</h3>

<p>Xiaolei Wang <a href="mailto:adamwang15@gmail.com">adamwang15@gmail.com</a> and Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Kilian, L., &amp; Lütkepohl, H. (2017). Structural VAR Tools, Chapter 4, In: Structural vector autoregressive analysis. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate.BSVARSIGN">estimate.BSVARSIGN</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="base.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(optimism)

# specify the model and set seed
set.seed(123)

# + no effect on productivity (zero restriction)
# + positive effect on stock prices (positive sign restriction) 
sign_irf       = matrix(c(0, 1, rep(NA, 23)), 5, 5)
specification  = specify_bsvarSIGN$new(optimism, sign_irf = sign_irf)

# estimate the model
posterior      = estimate(specification, 10)

# compute historical decompositions
hd            = compute_historical_decompositions(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
optimism |&gt;
  specify_bsvarSIGN$new(sign_irf = sign_irf) |&gt; 
  estimate(S = 10) |&gt; 
  compute_historical_decompositions() -&gt; hd
  
</code></pre>

<hr>
<h2 id='compute_impulse_responses.PosteriorBSVARSIGN'>Computes posterior draws of impulse responses</h2><span id='topic+compute_impulse_responses.PosteriorBSVARSIGN'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from 
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the posterior distribution of the impulse responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARSIGN'
compute_impulse_responses(posterior, horizon, standardise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_impulse_responses.PosteriorBSVARSIGN_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARSIGN</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="compute_impulse_responses.PosteriorBSVARSIGN_+3A_horizon">horizon</code></td>
<td>
<p>a positive integer number denoting the forecast horizon for the impulse responses computations.</p>
</td></tr>
<tr><td><code id="compute_impulse_responses.PosteriorBSVARSIGN_+3A_standardise">standardise</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the impulse responses are standardised 
so that the variables' own shocks at horizon 0 are equal to 1. Otherwise, the parameter estimates 
determine this magnitude.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class PosteriorIR, that is, an <code>NxNx(horizon+1)xS</code> array with attribute PosteriorIR 
containing <code>S</code> draws of the impulse responses.
</p>


<h3>Author(s)</h3>

<p>Xiaolei Wang <a href="mailto:adamwang15@gmail.com">adamwang15@gmail.com</a> and Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Kilian, L., &amp; Lütkepohl, H. (2017). Structural VAR Tools, Chapter 4, In: Structural vector autoregressive analysis. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate.BSVARSIGN">estimate.BSVARSIGN</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="base.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(optimism)

# specify the model and set seed
set.seed(123)

# + no effect on productivity (zero restriction)
# + positive effect on stock prices (positive sign restriction) 
sign_irf       = matrix(c(0, 1, rep(NA, 23)), 5, 5)
specification  = specify_bsvarSIGN$new(optimism, sign_irf = sign_irf)

# estimate the model
posterior      = estimate(specification, 10)

# compute impulse responses 2 years ahead
irf           = compute_impulse_responses(posterior, horizon = 8)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
optimism |&gt;
  specify_bsvarSIGN$new(sign_irf = sign_irf) |&gt; 
  estimate(S = 10) |&gt; 
  compute_impulse_responses(horizon = 8) -&gt; ir


</code></pre>

<hr>
<h2 id='compute_structural_shocks.PosteriorBSVARSIGN'>Computes posterior draws of structural shocks</h2><span id='topic+compute_structural_shocks.PosteriorBSVARSIGN'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the posterior distribution of the structural shocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARSIGN'
compute_structural_shocks(posterior)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_structural_shocks.PosteriorBSVARSIGN_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARSIGN</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PosteriorShocks</code>, that is, an <code>NxTxS</code> 
array with attribute <code>PosteriorShocks</code> containing <code>S</code> draws of the 
structural shocks.
</p>


<h3>Author(s)</h3>

<p>Xiaolei Wang <a href="mailto:adamwang15@gmail.com">adamwang15@gmail.com</a> and Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate.BSVARSIGN">estimate.BSVARSIGN</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="base.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(optimism)

# specify the model and set seed
set.seed(123)

# + no effect on productivity (zero restriction)
# + positive effect on stock prices (positive sign restriction) 
sign_irf       = matrix(c(0, 1, rep(NA, 23)), 5, 5)
specification  = specify_bsvarSIGN$new(optimism, sign_irf = sign_irf)

# estimate the model
posterior      = estimate(specification, 10)

# compute structural shocks
shocks         = compute_structural_shocks(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
optimism |&gt;
  specify_bsvarSIGN$new(sign_irf = sign_irf) |&gt; 
  estimate(S = 20) |&gt; 
  compute_structural_shocks() -&gt; ss

</code></pre>

<hr>
<h2 id='compute_variance_decompositions.PosteriorBSVARSIGN'>Computes posterior draws of the forecast error variance decomposition</h2><span id='topic+compute_variance_decompositions.PosteriorBSVARSIGN'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of the model
is transformed into a draw from the posterior distribution of the forecast 
error variance decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARSIGN'
compute_variance_decompositions(posterior, horizon)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_variance_decompositions.PosteriorBSVARSIGN_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARSIGN</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="compute_variance_decompositions.PosteriorBSVARSIGN_+3A_horizon">horizon</code></td>
<td>
<p>a positive integer number denoting the forecast horizon for 
the impulse responses computations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PosteriorFEVD</code>, that is, an <code>NxNx(horizon+1)xS</code> 
array with attribute <code>PosteriorFEVD</code> containing <code>S</code> draws of the 
forecast error variance decomposition.
</p>


<h3>Author(s)</h3>

<p>Xiaolei Wang <a href="mailto:adamwang15@gmail.com">adamwang15@gmail.com</a> and Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Kilian, L., &amp; Lütkepohl, H. (2017). Structural VAR Tools, Chapter 4, In: Structural vector autoregressive analysis. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_impulse_responses.PosteriorBSVARSIGN">compute_impulse_responses.PosteriorBSVARSIGN</a></code>, <code><a href="#topic+estimate.BSVARSIGN">estimate.BSVARSIGN</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="base.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(optimism)

# specify the model and set seed
set.seed(123)

# + no effect on productivity (zero restriction)
# + positive effect on stock prices (positive sign restriction) 
sign_irf       = matrix(c(0, 1, rep(NA, 23)), 5, 5)
specification  = specify_bsvarSIGN$new(optimism, sign_irf = sign_irf)

# estimate the model
posterior      = estimate(specification, 10)

# compute forecast error variance decomposition 2 years ahead
fevd           = compute_variance_decompositions(posterior, horizon = 8)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
optimism |&gt;
  specify_bsvarSIGN$new(sign_irf = sign_irf) |&gt; 
  estimate(S = 10) |&gt; 
  compute_variance_decompositions(horizon = 8) -&gt; fevd
  
</code></pre>

<hr>
<h2 id='estimate.BSVARSIGN'>Bayesian estimation of a Structural Vector Autoregression
with traditional and narrative sign restrictions via Gibbs sampler</h2><span id='topic+estimate.BSVARSIGN'></span>

<h3>Description</h3>

<p>Estimates Bayesian Structural Vector Autoregression model
using the Gibbs sampler proposed by Waggoner &amp; Zha (2003) with traditional sign restrictions 
following Rubio-Ramírez, Waggoner &amp; Zha (2010) and narrative sign restrictions 
following Antolín-Díaz &amp; Rubio-Ramírez (2018). Additionally, the parameter matrices <code class="reqn">A</code> and <code class="reqn">B</code>
follow a Minnesota prior and generalised-normal prior distributions respectively with the matrix-specific
overall shrinkage parameters estimated using a hierarchical prior distribution. 
</p>
<p>Given sign restrictions, in each Gibbs sampler iteration, the sampler draws rotation matrix 
<code class="reqn">Q</code> uniformly from the space of <code>NxN</code> orthogonal matrices and checks if the sign restrictions
are satisfied. If a valid <code class="reqn">Q</code> is found within <code>max_tries</code> (defined in <code>specify_bsvarSIGN</code>),
the sampler saves the current <code class="reqn">A</code> and <code class="reqn">B</code> draw and proceeds to the next iteration.
Otherwise, the sampler then proceeds to next iteration without saving the current <code class="reqn">A</code> and <code class="reqn">B</code> draw.
If a narrative sign restriction is given, the posterior
draws are resampled with <code>algorithm 1</code> in Antolín-Díaz &amp; Rubio-Ramírez (2018).
</p>
<p>See section <b>Details</b> for the model equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BSVARSIGN'
estimate(specification, S, thin = 1, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate.BSVARSIGN_+3A_specification">specification</code></td>
<td>
<p>an object of class BSVARSIGN generated using the <code>specify_bsvarSIGN$new()</code> function.</p>
</td></tr>
<tr><td><code id="estimate.BSVARSIGN_+3A_s">S</code></td>
<td>
<p>a positive integer, the number of posterior draws to be generated</p>
</td></tr>
<tr><td><code id="estimate.BSVARSIGN_+3A_thin">thin</code></td>
<td>
<p>a positive integer, specifying the frequency of MCMC output thinning</p>
</td></tr>
<tr><td><code id="estimate.BSVARSIGN_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value, if <code>TRUE</code> the estimation progress bar is visible</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Structural VAR model is given by the reduced form equation:
</p>
<p style="text-align: center;"><code class="reqn">Y = AX + E</code>
</p>

<p>where <code class="reqn">Y</code> is an <code>NxT</code> matrix of dependent variables, <code class="reqn">X</code> is a <code>KxT</code> matrix of explanatory variables, 
<code class="reqn">E</code> is an <code>NxT</code> matrix of reduced form error terms, and <code class="reqn">A</code> is an <code>NxK</code> matrix of
autoregressive slope coefficients and parameters on deterministic terms in <code class="reqn">X</code>.
</p>
<p>The structural equation is given by
</p>
<p style="text-align: center;"><code class="reqn">BE = U</code>
</p>

<p>where <code class="reqn">U</code> is an <code>NxT</code> matrix of structural form error terms, and
<code class="reqn">B</code> is an <code>NxN</code> matrix of contemporaneous relationships. More specifically,
</p>
<p style="text-align: center;"><code class="reqn">B = Q'P</code>
</p>

<p>where <code class="reqn">Q</code> is an <code>NxN</code> rotation matrix and <code class="reqn">P</code> is an <code>NxN</code> lower triangular matrix.
</p>
<p>Finally, the structural shocks, <code>U</code>, are temporally and contemporaneously independent and jointly normally distributed with zero mean and unit variances.
</p>


<h3>Value</h3>

<p>An object of class <code>PosteriorBSVARSIGN</code> containing the Bayesian estimation output and containing two elements:
</p>
<p><code>posterior</code> a list with a collection of <code>S</code> draws from the posterior distribution generated via Gibbs sampler containing:
</p>

<dl>
<dt>A</dt><dd><p>an <code>NxKxS</code> array with the posterior draws for matrix <code class="reqn">A</code></p>
</dd>
<dt>B</dt><dd><p>an <code>NxNxS</code> array with the posterior draws for matrix <code class="reqn">B</code></p>
</dd>
<dt>hyper</dt><dd><p>a <code>5xS</code> matrix with the posterior draws for the hyper-parameters of the hierarchical prior distribution</p>
</dd>
<dt>skipped</dt><dd><p>an integer of the total skipped iterations,
the Gibbs sampler performs a total of S+skipped iterations,
when the sampler does not find a valid rotation matrix <code>Q</code> within <code>max_tries</code>,
the current iteration is skipped (i.e. the current draw of <code>A,B</code> is not saved).
A message is shown when skipped/(skipped+S/thin) &gt; 0.05, where S/thin is the total number of draws returned.
</p>
</dd>
</dl>

<p><code>last_draw</code> an object of class BSVARSIGN with the last draw of the current MCMC run as the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>, Xiaolei Wang <a href="mailto:adamwang15@gmail.com">adamwang15@gmail.com</a>
</p>


<h3>References</h3>

<p>Antolín-Díaz &amp; Rubio-Ramírez (2018) Narrative Sign Restrictions for SVARs, American Economic Review, 108(10), 2802-29, &lt;doi:10.1257/aer.20161852&gt;.
</p>
<p>Arias, Rubio-Ramírez, &amp; Waggoner (2018), Inference Based on Structural Vector Autoregressions Identified With Sign and Zero Restrictions: Theory and Applications, Econometrica, 86(2), 685-720, &lt;doi:10.3982/ECTA14468&gt;.
</p>
<p>Giannone, Lenza, Primiceri (2015) Prior Selection for Vector Autoregressions, Review of Economics and Statistics, 97(2), 436-451 &lt;doi:10.1162/REST_a_00483&gt;.
</p>
<p>Rubio-Ramírez, Waggoner &amp; Zha (2010) Structural Vector Autoregressions: Theory of Identification and Algorithms for Inference, The Review of Economic Studies, 77(2), 665-696, &lt;doi:10.1111/j.1467-937X.2009.00578.x&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># investigate the effects of the optimism shock
data(optimism)

# specify identifying restrictions:
# + no effect on productivity (zero restriction)
# + positive effect on stock prices (positive sign restriction) 
sign_irf       = matrix(c(0, 1, rep(NA, 23)), 5, 5)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvarSIGN$new(optimism * 100,
                                       p        = 12,
                                       sign_irf = sign_irf)
                                       
# estimate the model
posterior      = estimate(specification, S = 10)

</code></pre>

<hr>
<h2 id='forecast.PosteriorBSVARSIGN'>Forecasting using Structural Vector Autoregression</h2><span id='topic+forecast.PosteriorBSVARSIGN'></span>

<h3>Description</h3>

<p>Samples from the joint predictive density of all of the dependent 
variables for models from packages <span class="pkg">bsvars</span>, <span class="pkg">bsvarSIGNs</span> or 
<span class="pkg">bvarPANELs</span> at forecast horizons from 1 to <code>horizon</code> specified as 
an argument of the function. Also facilitates forecasting using models with 
exogenous variables and conditional forecasting given projected future 
trajcetories of (some of the) variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARSIGN'
forecast(
  posterior,
  horizon = 1,
  exogenous_forecast = NULL,
  conditional_forecast = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forecast.PosteriorBSVARSIGN_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARSIGN</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="forecast.PosteriorBSVARSIGN_+3A_horizon">horizon</code></td>
<td>
<p>a positive integer, specifying the forecasting horizon.</p>
</td></tr>
<tr><td><code id="forecast.PosteriorBSVARSIGN_+3A_exogenous_forecast">exogenous_forecast</code></td>
<td>
<p>a matrix of dimension <code>horizon x d</code> containing 
forecasted values of the exogenous variables.</p>
</td></tr>
<tr><td><code id="forecast.PosteriorBSVARSIGN_+3A_conditional_forecast">conditional_forecast</code></td>
<td>
<p>a <code>horizon x N</code> matrix with forecasted values 
for selected variables. It should only contain <code>numeric</code> or <code>NA</code> 
values. The entries with <code>NA</code> values correspond to the values that are 
forecasted conditionally on the realisations provided as <code>numeric</code> values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>Forecasts</code> containing the
draws from the predictive density and data. The output list includes element:
</p>

<dl>
<dt>forecasts</dt><dd><p>an <code>NxhorizonxS</code> array with the draws from predictive density</p>
</dd>
<dt>Y</dt><dd><p>an <code class="reqn">NxT</code> matrix with the data on dependent variables</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a> and Xiaolei Wang <a href="mailto:adamwang15@gmail.com">adamwang15@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate.BSVARSIGN">estimate.BSVARSIGN</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="base.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(optimism)

# specify the model and set seed
set.seed(123)

# + no effect on productivity (zero restriction)
# + positive effect on stock prices (positive sign restriction) 
sign_irf       = matrix(c(0, 1, rep(NA, 23)), 5, 5)
specification  = specify_bsvarSIGN$new(optimism, sign_irf = sign_irf)

# estimate the model
posterior      = estimate(specification, 10)

# sample from predictive density 1 year ahead
predictive     = forecast(posterior, 4)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
optimism |&gt;
  specify_bsvarSIGN$new(sign_irf = sign_irf) |&gt;
  estimate(S = 20) |&gt; 
  forecast(horizon = 4) -&gt; predictive

# conditional forecasting 2 quarters ahead conditioning on 
#  provided future values for the Gross Domestic Product 
############################################################
cf         = matrix(NA , 2, 5)
# # conditional forecasts equal to the last consumption observation
cf[,3]     = tail(optimism, 1)[3]
predictive = forecast(posterior, 2, conditional_forecast = cf)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
optimism |&gt;
  specify_bsvarSIGN$new(sign_irf = sign_irf) |&gt;
  estimate(S = 10) |&gt; 
  forecast(horizon = 2, conditional_forecast = cf) -&gt; predictive

</code></pre>

<hr>
<h2 id='monetary'>A 6-variable US monetary policy data, from 1965 Jan to 2007 Aug</h2><span id='topic+monetary'></span>

<h3>Description</h3>

<p>A sample data to identify monetary policy shock.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(monetary)
</code></pre>


<h3>Format</h3>

<p>A matrix and a <code>ts</code> object with time series of over two hundred observations on 5 variables:
</p>

<dl>
<dt>gdpc1</dt><dd><p>monthly real gross domestic product</p>
</dd>
<dt>gdpdef</dt><dd><p>monthly gross domestic product: implicit price deflator</p>
</dd>
<dt>cprindex</dt><dd><p>monthly consumer price index</p>
</dd>
<dt>totresns</dt><dd><p>monthly reserves of depository institutions</p>
</dd>
<dt>bognonbr</dt><dd><p>monthly non-borrowed reserves of depository institutions</p>
</dd>
<dt>fedfunds</dt><dd><p>monthly federal funds effective rate</p>
</dd>
</dl>



<h3>Source</h3>

<p>Replication package, <a href="https://www.aeaweb.org/articles?id=10.1257/aer.20161852">https://www.aeaweb.org/articles?id=10.1257/aer.20161852</a>
</p>


<h3>References</h3>

<p>Antolín-Díaz &amp; Rubio-Ramírez (2018) Narrative Sign Restrictions for SVARs, American Economic Review, 108(10), 2802-29, &lt;doi:10.1257/aer.20161852&gt;.
</p>

<hr>
<h2 id='optimism'>A 5-variable US business cycle data, from 1955 Q1 to 2004 Q4</h2><span id='topic+optimism'></span>

<h3>Description</h3>

<p>A sample data to identify optimism shock.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(optimism)
</code></pre>


<h3>Format</h3>

<p>A matrix and a <code>ts</code> object with time series of over two hundred observations on 5 variables:
</p>

<dl>
<dt>productivity</dt><dd><p>quarterly factor-utilization-adjusted total factor productivity</p>
</dd>
<dt>stock_prices</dt><dd><p>quarterly end-of-period S&amp;P 500 divided by CPI</p>
</dd>
<dt>consumption</dt><dd><p>quarterly real consumption expenditures on nondurable goods and services</p>
</dd>
<dt>real_interest_rate</dt><dd><p>quarterly real interest rate</p>
</dd>
<dt>hours_worked</dt><dd><p>quarterly hours of all persons in the non-farm business sector</p>
</dd>
</dl>

<p>The series are as described by Beaudry, Nam and Wang (2011) in section 2.2.
</p>


<h3>Source</h3>

<p>Replication package, <a href="https://www.econometricsociety.org/publications/econometrica/2018/03/01/inference-based-structural-vector-autoregressions-identified">https://www.econometricsociety.org/publications/econometrica/2018/03/01/inference-based-structural-vector-autoregressions-identified</a>
</p>


<h3>References</h3>

<p>Arias, Jonas E., Juan F. Rubio‐Ramírez, and Daniel F. Waggoner. &quot;Inference based on structural vector autoregressions identified with sign and zero restrictions: Theory and applications.&quot; Econometrica 86, no. 2 (2018): 685-720. &lt;doi:10.3982/ECTA14468&gt;
</p>
<p>Beaudry, Paul, Deokwoo Nam, and Jian Wang. Do mood swings drive business cycles and is it rational?. No. w17651. National Bureau of Economic Research, 2011. &lt;doi:10.3386/w17651&gt;
</p>

<hr>
<h2 id='specify_bsvarSIGN'>R6 Class representing the specification of the BSVARSIGN model</h2><span id='topic+specify_bsvarSIGN'></span>

<h3>Description</h3>

<p>The class BSVARSIGN presents complete specification for the Bayesian Structural VAR model with sign and narrative restrictions.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>p</code></dt><dd><p>a non-negative integer specifying the autoregressive lag order of the model.</p>
</dd>
<dt><code>identification</code></dt><dd><p>an object IdentificationBSVARSIGN with the identifying restrictions.</p>
</dd>
<dt><code>prior</code></dt><dd><p>an object PriorBSVARSIGN with the prior specification.</p>
</dd>
<dt><code>data_matrices</code></dt><dd><p>an object DataMatricesBSVARSIGN with the data matrices.</p>
</dd>
<dt><code>starting_values</code></dt><dd><p>an object StartingValuesBSVARSIGN with the starting values.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-BSVARSIGN-new"><code>specify_bsvarSIGN$new()</code></a>
</p>
</li>
<li> <p><a href="#method-BSVARSIGN-get_data_matrices"><code>specify_bsvarSIGN$get_data_matrices()</code></a>
</p>
</li>
<li> <p><a href="#method-BSVARSIGN-get_identification"><code>specify_bsvarSIGN$get_identification()</code></a>
</p>
</li>
<li> <p><a href="#method-BSVARSIGN-get_prior"><code>specify_bsvarSIGN$get_prior()</code></a>
</p>
</li>
<li> <p><a href="#method-BSVARSIGN-get_starting_values"><code>specify_bsvarSIGN$get_starting_values()</code></a>
</p>
</li>
<li> <p><a href="#method-BSVARSIGN-clone"><code>specify_bsvarSIGN$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-BSVARSIGN-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new specification of the Bayesian Structural VAR model with sign and narrative restrictions BSVARSIGN.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvarSIGN$new(
  data,
  p = 1L,
  sign_irf,
  sign_narrative,
  sign_structural,
  max_tries = Inf,
  exogenous = NULL,
  stationary = rep(FALSE, ncol(data))
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>a <code>(T+p)xN</code> matrix with time series data.</p>
</dd>
<dt><code>p</code></dt><dd><p>a positive integer providing model's autoregressive lag order.</p>
</dd>
<dt><code>sign_irf</code></dt><dd><p>a <code>NxNxH</code> array - sign and zero restrictions 
on the impulse response functions, ±1 for positive/negative sign restriction
0 for zero restrictions and NA for no restrictions,
the <code>h</code>-th slice <code>NxN</code> matrix contains the
restrictions on the <code>h-1</code> horizon.</p>
</dd>
<dt><code>sign_narrative</code></dt><dd><p>a list of objects of class &quot;narrative&quot; - narrative sign restrictions.</p>
</dd>
<dt><code>sign_structural</code></dt><dd><p>a <code>NxN</code> matrix with entries ±1 or NA - sign restrictions on the
contemporaneous relations <code>B</code> between reduced-form errors <code>E</code> and
structural shocks <code>U</code> where <code>BE=U</code>.</p>
</dd>
<dt><code>max_tries</code></dt><dd><p>a positive integer with the maximum number of iterations
for finding a rotation matrix <code class="reqn">Q</code> that would satisfy sign restrictions</p>
</dd>
<dt><code>exogenous</code></dt><dd><p>a <code>(T+p)xd</code> matrix of exogenous variables.</p>
</dd>
<dt><code>stationary</code></dt><dd><p>an <code>N</code> logical vector - its element set to <code>FALSE</code> sets
the prior mean for the autoregressive parameters of the <code>N</code>th equation to the white noise process,
otherwise to random walk.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new complete specification for the Bayesian Structural VAR model BSVARSIGN.
</p>


<hr>
<a id="method-BSVARSIGN-get_data_matrices"></a>



<h4>Method <code>get_data_matrices()</code></h4>

<p>Returns the data matrices as the DataMatricesBSVAR object.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvarSIGN$get_data_matrices()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre># specify a model with the optimism data and 4 lags

data(optimism)
spec = specify_bsvarSIGN$new(
   data = optimism,
   p = 4
)

# get the data matrices
spec$get_data_matrices()

</pre>
</div>


<hr>
<a id="method-BSVARSIGN-get_identification"></a>



<h4>Method <code>get_identification()</code></h4>

<p>Returns the identifying restrictions as the IdentificationBSVARSIGN object.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvarSIGN$get_identification()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre># specify a model with the optimism data and 4 lags
data(optimism)
spec = specify_bsvarSIGN$new(
   data = optimism,
   p = 4
)

# get the identifying restrictions
spec$get_identification()

</pre>
</div>


<hr>
<a id="method-BSVARSIGN-get_prior"></a>



<h4>Method <code>get_prior()</code></h4>

<p>Returns the prior specification as the PriorBSVAR object.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvarSIGN$get_prior()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre># specify a model with the optimism data and 4 lags

data(optimism)
spec = specify_bsvarSIGN$new(
   data = optimism,
   p = 4
)

# get the prior specification
spec$get_prior()

</pre>
</div>


<hr>
<a id="method-BSVARSIGN-get_starting_values"></a>



<h4>Method <code>get_starting_values()</code></h4>

<p>Returns the starting values as the StartingValuesBSVAR object.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvarSIGN$get_starting_values()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre># specify a model with the optimism data and 4 lags

data(optimism)
spec = specify_bsvarSIGN$new(
   data = optimism,
   p = 4
)

# get the starting values
spec$get_starting_values()

</pre>
</div>


<hr>
<a id="method-BSVARSIGN-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvarSIGN$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+estimate.BSVARSIGN">estimate.BSVARSIGN</a></code>, <code><a href="#topic+specify_posterior_bsvarSIGN">specify_posterior_bsvarSIGN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># specify a model with the optimism data and 4 lags

data(optimism)
specification = specify_bsvarSIGN$new(
   data = optimism,
   p = 4
)


## ------------------------------------------------
## Method `specify_bsvarSIGN$get_data_matrices`
## ------------------------------------------------

# specify a model with the optimism data and 4 lags

data(optimism)
spec = specify_bsvarSIGN$new(
   data = optimism,
   p = 4
)

# get the data matrices
spec$get_data_matrices()


## ------------------------------------------------
## Method `specify_bsvarSIGN$get_identification`
## ------------------------------------------------

# specify a model with the optimism data and 4 lags
data(optimism)
spec = specify_bsvarSIGN$new(
   data = optimism,
   p = 4
)

# get the identifying restrictions
spec$get_identification()


## ------------------------------------------------
## Method `specify_bsvarSIGN$get_prior`
## ------------------------------------------------

# specify a model with the optimism data and 4 lags

data(optimism)
spec = specify_bsvarSIGN$new(
   data = optimism,
   p = 4
)

# get the prior specification
spec$get_prior()


## ------------------------------------------------
## Method `specify_bsvarSIGN$get_starting_values`
## ------------------------------------------------

# specify a model with the optimism data and 4 lags

data(optimism)
spec = specify_bsvarSIGN$new(
   data = optimism,
   p = 4
)

# get the starting values
spec$get_starting_values()

</code></pre>

<hr>
<h2 id='specify_identification_bsvarSIGN'>R6 Class Representing IdentificationBSVARSIGN</h2><span id='topic+specify_identification_bsvarSIGN'></span>

<h3>Description</h3>

<p>The class IdentificationBSVARSIGN presents the identifying restrictions for the Bayesian Structural VAR models with sign and narrative restrictions.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>VB</code></dt><dd><p>a list of <code>N</code> matrices determining the unrestricted elements of matrix <code class="reqn">B</code>.</p>
</dd>
<dt><code>sign_irf</code></dt><dd><p>a <code>NxNxH</code> array of sign restrictions on the impulse response functions.</p>
</dd>
<dt><code>sign_narrative</code></dt><dd><p>a <code>ANYx6</code> matrix of narrative sign restrictions.</p>
</dd>
<dt><code>sign_structural</code></dt><dd><p>a <code>NxN</code> matrix of sign restrictions on contemporaneous relations.</p>
</dd>
<dt><code>max_tries</code></dt><dd><p>a positive integer with the maximum number of iterations 
for finding a rotation matrix <code class="reqn">Q</code> that would satisfy sign restrictions.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-IdentificationBSVARSIGN-new"><code>specify_identification_bsvarSIGN$new()</code></a>
</p>
</li>
<li> <p><a href="#method-IdentificationBSVARSIGN-get_identification"><code>specify_identification_bsvarSIGN$get_identification()</code></a>
</p>
</li>
<li> <p><a href="#method-IdentificationBSVARSIGN-set_identification"><code>specify_identification_bsvarSIGN$set_identification()</code></a>
</p>
</li>
<li> <p><a href="#method-IdentificationBSVARSIGN-clone"><code>specify_identification_bsvarSIGN$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-IdentificationBSVARSIGN-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create new identifying restrictions IdentificationBSVARSIGN.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_identification_bsvarSIGN$new(
  N,
  sign_irf,
  sign_narrative,
  sign_structural,
  max_tries = Inf
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>N</code></dt><dd><p>a positive integer - the number of dependent variables in the model.</p>
</dd>
<dt><code>sign_irf</code></dt><dd><p>a <code>NxNxH</code> array - sign and zero restrictions 
on the impulse response functions, ±1 for positive/negative sign restriction
0 for zero restrictions and NA for no restrictions,
the <code>h</code>-th slice <code>NxN</code> matrix contains the
restrictions on the <code>h-1</code> horizon.</p>
</dd>
<dt><code>sign_narrative</code></dt><dd><p>a list of objects of class &quot;narrative&quot; - narrative sign restrictions.</p>
</dd>
<dt><code>sign_structural</code></dt><dd><p>a <code>NxN</code> matrix with entries ±1 or NA - sign restrictions on the
contemporaneous relations <code>B</code> between reduced-form errors <code>E</code> and
structural shocks <code>U</code> where <code>BE=U</code>.</p>
</dd>
<dt><code>max_tries</code></dt><dd><p>a positive integer with the maximum number of iterations
for finding a rotation matrix <code class="reqn">Q</code> that would satisfy sign restrictions.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Identifying restrictions IdentificationBSVARSIGN.
</p>


<hr>
<a id="method-IdentificationBSVARSIGN-get_identification"></a>



<h4>Method <code>get_identification()</code></h4>

<p>Returns the elements of the identification pattern IdentificationBSVARSIGN as a <code>list</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_identification_bsvarSIGN$get_identification()</pre></div>


<hr>
<a id="method-IdentificationBSVARSIGN-set_identification"></a>



<h4>Method <code>set_identification()</code></h4>

<p>Set new starting values StartingValuesBSVARSIGN.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_identification_bsvarSIGN$set_identification(
  N,
  sign_irf,
  sign_narrative,
  sign_structural
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>N</code></dt><dd><p>a positive integer - the number of dependent variables in the model.</p>
</dd>
<dt><code>sign_irf</code></dt><dd><p>a <code>NxNxH</code> array - sign and zero restrictions 
on the impulse response functions, ±1 for positive/negative sign restriction
0 for zero restrictions and NA for no restrictions,
the <code>h</code>-th slice <code>NxN</code> matrix contains the
restrictions on the <code>h-1</code> horizon.</p>
</dd>
<dt><code>sign_narrative</code></dt><dd><p>a list of objects of class &quot;narrative&quot; - narrative sign restrictions.</p>
</dd>
<dt><code>sign_structural</code></dt><dd><p>a <code>NxN</code> matrix with entries ±1 or NA - sign restrictions on the
contemporaneous relations <code>B</code> between reduced-form errors <code>E</code> and
structural shocks <code>U</code> where <code>BE=U</code>.</p>
</dd>
<dt><code>max_tries</code></dt><dd><p>a positive integer with the maximum number of iterations
for finding a rotation matrix <code class="reqn">Q</code> that would satisfy sign restrictions</p>
</dd>
</dl>

</div>


<hr>
<a id="method-IdentificationBSVARSIGN-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_identification_bsvarSIGN$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># recursive specification for a 5-variable system
specify_identification_bsvarSIGN$new(N = 5)

# specify sign restrictions of the first shock on the contemporaneous IRF
# + no effect on the first variable
# + positive effect on the second variable
sign_irf = matrix(c(0, 1, rep(NA, 23)), 5, 5)
specify_identification_bsvarSIGN$new(N = 5, sign_irf = sign_irf) 

</code></pre>

<hr>
<h2 id='specify_narrative'>vector specifying one narrative restriction</h2><span id='topic+specify_narrative'></span>

<h3>Description</h3>

<p>The class narrative specifies a single narrative restriction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specify_narrative(
  start,
  periods = 1,
  type = "S",
  sign = 1,
  shock = 1,
  var = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="specify_narrative_+3A_start">start</code></td>
<td>
<p>positive integer - the period in which the narrative starts (greater than the number of lags).</p>
</td></tr>
<tr><td><code id="specify_narrative_+3A_periods">periods</code></td>
<td>
<p>positive integer - the number of periods the narrative restriction lasts.</p>
</td></tr>
<tr><td><code id="specify_narrative_+3A_type">type</code></td>
<td>
<p>character - the type of the narrative restriction (one of &quot;S&quot;, &quot;A&quot;, &quot;B&quot;), where:
&quot;S&quot; for restrictions on structural shocks;
&quot;A&quot; for type A restrictions on historical decomposition, i.e. if the absolute value of the historical decomposition
of shock to var is the greatest/least among all shocks;
&quot;B&quot; for type B restrictions on historical decomposition, i.e. if the absolute value of the historical decomposition
of shock to var is the greater/less than the sum of all other shocks.</p>
</td></tr>
<tr><td><code id="specify_narrative_+3A_sign">sign</code></td>
<td>
<p>integer - the sign of the narrative restriction (1 or -1).</p>
</td></tr>
<tr><td><code id="specify_narrative_+3A_shock">shock</code></td>
<td>
<p>positive integer - the index of the shock to which the narrative restriction applies.</p>
</td></tr>
<tr><td><code id="specify_narrative_+3A_var">var</code></td>
<td>
<p>positive integer - the index of the variable to which the narrative restriction applies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>narrative</code> specifying one narrative restriction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># specify a narrative restriction
narrative       = specify_narrative(
                    start = 166, 
                    periods = 1, 
                    type = "S", 
                    sign = 1, 
                    shock = 1, 
                    var = 6
                  )
# use it to specify the model
specification   = specify_bsvarSIGN$new(monetary, sign_narrative = list(narrative))

</code></pre>

<hr>
<h2 id='specify_posterior_bsvarSIGN'>R6 Class Representing PosteriorBSVARSIGN</h2><span id='topic+specify_posterior_bsvarSIGN'></span>

<h3>Description</h3>

<p>The class PosteriorBSVARSIGN contains posterior output and the specification including
the last MCMC draw for the Bayesian Structural VAR model with sign and narrative restrictions.
Note that due to the thinning of the MCMC output the starting value in element <code>last_draw</code>
might not be equal to the last draw provided in element <code>posterior</code>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>last_draw</code></dt><dd><p>an object of class BSVARSIGN with the last draw of the current MCMC run as
the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>a list containing Bayesian estimation output including:
an <code>NxNxS</code> array <code>B</code>, an <code>NxKxS</code> array <code>A</code>, and a <code>5xS</code> matrix <code>hyper</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PosteriorBSVARSIGN-new"><code>specify_posterior_bsvarSIGN$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARSIGN-get_posterior"><code>specify_posterior_bsvarSIGN$get_posterior()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARSIGN-is_normalised"><code>specify_posterior_bsvarSIGN$is_normalised()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARSIGN-clone"><code>specify_posterior_bsvarSIGN$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PosteriorBSVARSIGN-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new posterior output PosteriorBSVARSIGN.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvarSIGN$new(specification_bsvarSIGN, posterior_bsvarSIGN)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>specification_bsvarSIGN</code></dt><dd><p>an object of class BSVARSIGN with the last draw of the current
MCMC run as the starting value.</p>
</dd>
<dt><code>posterior_bsvarSIGN</code></dt><dd><p>a list containing Bayesian estimation output collected in elements
an <code>NxNxS</code> array <code>B</code>, an <code>NxKxS</code> array <code>A</code>, and a <code>5xS</code> matrix <code>hyper</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A posterior output PosteriorBSVARSIGN.
</p>


<hr>
<a id="method-PosteriorBSVARSIGN-get_posterior"></a>



<h4>Method <code>get_posterior()</code></h4>

<p>Returns a list containing Bayesian estimation output collected in elements
an <code>NxNxS</code> array <code>B</code>, an <code>NxKxS</code> array <code>A</code>, and a <code>5xS</code> matrix <code>hyper</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvarSIGN$get_posterior()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(optimism)
specification  = specify_bsvarSIGN$new(optimism)
set.seed(123)
estimate       = estimate(specification, 50)
estimate$get_posterior()

</pre>
</div>


<hr>
<a id="method-PosteriorBSVARSIGN-is_normalised"></a>



<h4>Method <code>is_normalised()</code></h4>

<p>Returns <code>TRUE</code> if the posterior has been normalised using <code>normalise_posterior()</code>
and <code>FALSE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvarSIGN$is_normalised()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(optimism)
specification  = specify_bsvarSIGN$new(optimism)
set.seed(123)
estimate       = estimate(specification, 20)

# check normalisation status afterwards
posterior$is_normalised()

</pre>
</div>


<hr>
<a id="method-PosteriorBSVARSIGN-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvarSIGN$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+estimate.BSVARSIGN">estimate.BSVARSIGN</a></code>, <code><a href="#topic+specify_bsvarSIGN">specify_bsvarSIGN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is a function that is used within estimate()
data(optimism)
specification  = specify_bsvarSIGN$new(optimism, p = 4)
set.seed(123)
posterior      = estimate(specification, 50)
class(posterior)


## ------------------------------------------------
## Method `specify_posterior_bsvarSIGN$get_posterior`
## ------------------------------------------------

data(optimism)
specification  = specify_bsvarSIGN$new(optimism)
set.seed(123)
estimate       = estimate(specification, 50)
estimate$get_posterior()


## ------------------------------------------------
## Method `specify_posterior_bsvarSIGN$is_normalised`
## ------------------------------------------------

data(optimism)
specification  = specify_bsvarSIGN$new(optimism)
set.seed(123)
estimate       = estimate(specification, 20)

# check normalisation status afterwards
posterior$is_normalised()

</code></pre>

<hr>
<h2 id='specify_prior_bsvarSIGN'>R6 Class Representing PriorBSVAR</h2><span id='topic+specify_prior_bsvarSIGN'></span>

<h3>Description</h3>

<p>The class PriorBSVARSIGN presents a prior specification for the homoskedastic bsvar model.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>p</code></dt><dd><p>a positive integer - the number of lags.</p>
</dd>
<dt><code>hyper</code></dt><dd><p>a <code>(N+3)xS</code> matrix of hyper-parameters <code class="reqn">\mu, \delta, \lambda, \psi</code>.</p>
</dd>
<dt><code>A</code></dt><dd><p>a <code>NxK</code> normal prior mean matrix for the autoregressive 
parameters.</p>
</dd>
<dt><code>V</code></dt><dd><p>a <code>KxK</code> matrix determining  the normal prior column-specific 
covariance for the autoregressive parameters.</p>
</dd>
<dt><code>S</code></dt><dd><p>an <code>NxN</code> matrix determining the inverted-Wishart prior scale 
of error terms covariance matrix.</p>
</dd>
<dt><code>nu</code></dt><dd><p>a positive scalar greater than <code>N+1</code> - the shape of the 
inverted-Wishart prior for error terms covariance matrix.</p>
</dd>
<dt><code>data</code></dt><dd><p>an <code>TxN</code> matrix of observations.</p>
</dd>
<dt><code>Y</code></dt><dd><p>an <code>NxT</code> matrix of dependent variables.</p>
</dd>
<dt><code>X</code></dt><dd><p>an <code>KxT</code> matrix of independent variables.</p>
</dd>
<dt><code>Ysoc</code></dt><dd><p>an <code>NxN</code> matrix with the sum-of-coefficients dummy observations.</p>
</dd>
<dt><code>Xsoc</code></dt><dd><p>an <code>KxN</code> matrix with the sum-of-coefficients dummy observations.</p>
</dd>
<dt><code>Ysur</code></dt><dd><p>an <code>NxN</code> matrix with the single-unit-root dummy observations.</p>
</dd>
<dt><code>Xsur</code></dt><dd><p>an <code>KxN</code> matrix with the single-unit-root dummy observations.</p>
</dd>
<dt><code>mu.scale</code></dt><dd><p>a positive scalar - the shape of the gamma prior for <code class="reqn">\mu</code>.</p>
</dd>
<dt><code>mu.shape</code></dt><dd><p>a positive scalar - the shape of the gamma prior for <code class="reqn">\mu</code>.</p>
</dd>
<dt><code>delta.scale</code></dt><dd><p>a positive scalar - the shape of the gamma prior for <code class="reqn">\delta</code>.</p>
</dd>
<dt><code>delta.shape</code></dt><dd><p>a positive scalar - the shape of the gamma prior for <code class="reqn">\delta</code>.</p>
</dd>
<dt><code>lambda.scale</code></dt><dd><p>a positive scalar - the shape of the gamma prior for <code class="reqn">\lambda</code>.</p>
</dd>
<dt><code>lambda.shape</code></dt><dd><p>a positive scalar - the shape of the gamma prior for <code class="reqn">\lambda</code>.</p>
</dd>
<dt><code>psi.scale</code></dt><dd><p>a positive scalar - the shape of the inverted gamma prior for <code class="reqn">\psi</code>.</p>
</dd>
<dt><code>psi.shape</code></dt><dd><p>a positive scalar - the shape of the inverted gamma prior for <code class="reqn">\psi</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PriorBSVARSIGN-new"><code>specify_prior_bsvarSIGN$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PriorBSVARSIGN-get_prior"><code>specify_prior_bsvarSIGN$get_prior()</code></a>
</p>
</li>
<li> <p><a href="#method-PriorBSVARSIGN-estimate_hyper"><code>specify_prior_bsvarSIGN$estimate_hyper()</code></a>
</p>
</li>
<li> <p><a href="#method-PriorBSVARSIGN-clone"><code>specify_prior_bsvarSIGN$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PriorBSVARSIGN-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new prior specification PriorBSVAR.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_prior_bsvarSIGN$new(
  data,
  p,
  exogenous = NULL,
  stationary = rep(FALSE, ncol(data))
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>the <code>TxN</code> data matrix of observations.</p>
</dd>
<dt><code>p</code></dt><dd><p>a positive integer - the autoregressive lag order of the SVAR model.</p>
</dd>
<dt><code>exogenous</code></dt><dd><p>a <code>Txd</code> matrix of exogenous variables.</p>
</dd>
<dt><code>stationary</code></dt><dd><p>an <code>N</code> logical vector - its element set to <code>FALSE</code> sets 
the prior mean for the autoregressive parameters of the <code>N</code>th equation to the white noise process, 
otherwise to random walk.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new prior specification PriorBSVARSIGN.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># a prior for 5-variable example with one lag and stationary data
data(optimism)
prior = specify_prior_bsvarSIGN$new(optimism, p = 1)
prior$B # show autoregressive prior mean

</pre>
</div>


<hr>
<a id="method-PriorBSVARSIGN-get_prior"></a>



<h4>Method <code>get_prior()</code></h4>

<p>Returns the elements of the prior specification PriorBSVAR as a <code>list</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_prior_bsvarSIGN$get_prior()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre># a prior for 5-variable example with four lags
prior = specify_prior_bsvar$new(N = 5, p = 4)
prior$get_prior() # show the prior as list

</pre>
</div>


<hr>
<a id="method-PriorBSVARSIGN-estimate_hyper"></a>



<h4>Method <code>estimate_hyper()</code></h4>

<p>Estimates hyper-parameters with adaptive Metropolis algorithm.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_prior_bsvarSIGN$estimate_hyper(
  S = 10000,
  burn_in = S/2,
  mu = FALSE,
  delta = FALSE,
  lambda = TRUE,
  psi = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>S</code></dt><dd><p>number of MCMC draws.</p>
</dd>
<dt><code>burn_in</code></dt><dd><p>number of burn-in draws.</p>
</dd>
<dt><code>mu</code></dt><dd><p>whether to estimate the hyper-parameter in the 
sum-of-coefficients dummy prior.</p>
</dd>
<dt><code>delta</code></dt><dd><p>whether to estimate the hyper-parameter in the 
single-unit-root dummy prior.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>whether to estimate the hyper-parameter of the 
shrinkage in the Minnesota prior.</p>
</dd>
<dt><code>psi</code></dt><dd><p>whether to estimate the hyper-parameter of the 
variances in the Minnesota prior.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre># specify the model and set seed
set.seed(123)
data(optimism)
prior = specify_prior_bsvarSIGN$new(optimism, p = 4)

# estimate hyper parameters with adaptive Metropolis algorithm
prior$estimate_hyper(S = 10, psi = TRUE)

# trace plot
hyper = t(prior$hyper)
colnames(hyper) = c("mu", "delta", "lambda", paste("psi", 1:5, sep = ""))
plot.ts(hyper)

</pre>
</div>


<hr>
<a id="method-PriorBSVARSIGN-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_prior_bsvarSIGN$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># a prior for 5-variable example with one lag
data(optimism)
prior = specify_prior_bsvarSIGN$new(optimism, p = 1)
prior$A  # show autoregressive prior mean


## ------------------------------------------------
## Method `specify_prior_bsvarSIGN$new`
## ------------------------------------------------

# a prior for 5-variable example with one lag and stationary data
data(optimism)
prior = specify_prior_bsvarSIGN$new(optimism, p = 1)
prior$B # show autoregressive prior mean


## ------------------------------------------------
## Method `specify_prior_bsvarSIGN$get_prior`
## ------------------------------------------------

# a prior for 5-variable example with four lags
prior = specify_prior_bsvar$new(N = 5, p = 4)
prior$get_prior() # show the prior as list


## ------------------------------------------------
## Method `specify_prior_bsvarSIGN$estimate_hyper`
## ------------------------------------------------

# specify the model and set seed
set.seed(123)
data(optimism)
prior = specify_prior_bsvarSIGN$new(optimism, p = 4)

# estimate hyper parameters with adaptive Metropolis algorithm
prior$estimate_hyper(S = 10, psi = TRUE)

# trace plot
hyper = t(prior$hyper)
colnames(hyper) = c("mu", "delta", "lambda", paste("psi", 1:5, sep = ""))
plot.ts(hyper)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
