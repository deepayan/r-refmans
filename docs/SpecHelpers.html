<!DOCTYPE html><html><head><title>Help for package SpecHelpers</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SpecHelpers}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SpecHelpers-package'><p>Spectroscopy Related Utilities</p>
Maintainer: Bryan A. Hanson <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a></a></li>
<li><a href='#avgLambda'><p>Convert Wavelengths to Integer Values and Average Corresponding Absorbances</p></a></li>
<li><a href='#CIExyz'><p>Spectral Locus for the 1931 CIE chromaticity diagram</p></a></li>
<li><a href='#emSpectrum'><p>Plot a pretty electromagnetic spectrum</p></a></li>
<li><a href='#gatherCsv'><p>Combine csv Files Containing Spectral Data into a Data Frame</p></a></li>
<li><a href='#gatherSpecFiles'><p>Process LoggerPro Spectral Files into a Data Frame</p></a></li>
<li><a href='#gaussCurve'><p>Compute a Gaussian Curve</p></a></li>
<li><a href='#getGamutValues'><p>Look up gamut and white point values in the 1931 CIE system</p></a></li>
<li><a href='#jSeq'><p>Utility for Creating NMR Multiplets</p></a></li>
<li><a href='#lorentzCurve'><p>Compute a Lorentzian Curve</p></a></li>
<li><a href='#makeSpec'><p>Draw a Chromatogram or Spectrum</p></a></li>
<li><a href='#plot2DNMRspec'><p>Draw a 2D NMR Spectrum</p></a></li>
<li><a href='#plotCIEchrom'><p>Draw the 1931 CIE chromaticity diagram</p></a></li>
<li><a href='#plotNMRspec'><p>Create and Plot an NMR Spectrum</p></a></li>
<li><a href='#prepCIEgradient'><p>Compute a gradient to fill the CIE chromaticity diagram</p></a></li>
<li><a href='#qMS'><p>Draw a Simple Mass Spectrum Showing the Parent Ion</p></a></li>
<li><a href='#txt2csv'><p>Utility Functions to Clean and Convert Spectral Files to csv</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spectroscopy Related Utilities</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-07-26</td>
</tr>
<tr>
<td>Author:</td>
<td>Bryan A. Hanson DePauw University, Greencastle Indiana USA</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bryan A. Hanson &lt;hanson@depauw.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Utility functions for spectroscopy. 1. Functions to simulate
    spectra for use in teaching or testing. 2. Functions to process files created by
    'LoggerPro' and 'SpectraSuite' software.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>gsubfn, utils, stats, graphics, splancs</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bryanhanson/SpecHelpers">https://github.com/bryanhanson/SpecHelpers</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bryanhanson/SpecHelpers/issues">https://github.com/bryanhanson/SpecHelpers/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-07-26 18:01:35 UTC; bryanhanson</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-07-26 18:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='SpecHelpers-package'>Spectroscopy Related Utilities
Maintainer: Bryan A. Hanson <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a></h2><span id='topic+SpecHelpers-package'></span><span id='topic+SpecHelpers'></span>

<h3>Description</h3>

<p>SpecHelpers: Spectroscopy Related Utilities
</p>


<h3>Details</h3>

<p>Utility functions for spectroscopy.  1. Functions to simulate spectra for
use in teaching or testing.  2.  Functions to process files created by
LoggerPro and SpectraSuite software.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University, Greencastle Indiana USA
</p>

<hr>
<h2 id='avgLambda'>Convert Wavelengths to Integer Values and Average Corresponding Absorbances</h2><span id='topic+avgLambda'></span>

<h3>Description</h3>

<p>This function reads a csv file containing columns of wavelength and
absorbances.  It rounds the wavelengths to integers and replaces the
absorbances corresponding to the rounded values with their averages.  NOTE
THAT ALL THE csv FILES IN THE CURRENT DIRECTORY ARE PROCESSED AND REPLACED
WITH THE MODIFIED FILEs.  You should use this function on a copy of the
directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avgLambda()
</code></pre>


<h3>Value</h3>

<p>The original files are overwritten with the modified files.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gatherSpecFiles">gatherSpecFiles</a></code> which is the function the user should
call.
</p>

<hr>
<h2 id='CIExyz'>Spectral Locus for the 1931 CIE chromaticity diagram</h2><span id='topic+CIExyz'></span>

<h3>Description</h3>

<p>This data set gives wavelengths every 1.0 nm, along
with the associated CIE xyz values for the spectral locus of
the 1931 CIE chromaticity diagram.  They are called xyz values
here as they are called that in the original source, but they
are also known as xyY or XYZ values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CIExyz
</code></pre>


<h3>Format</h3>

<p>A data frame with 4400 observations each with the
following 4 variables:
</p>

<dl>
<dt>wavelength</dt><dd><p>wavelength in nm</p>
</dd>
<dt>x</dt><dd><p>x values</p>
</dd>
<dt>y</dt><dd><p>y values</p>
</dd>
<dt>z</dt><dd><p>z values</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>Source</h3>

<p>Color Vision Research Lab.  <a href="cvrl.ioo.ucl.ac.uk/index.htm">cvrl.ioo.ucl.ac.uk/index.htm</a>
Go to this URL, then choose 'NEW CIE XYZ...' In the new page that opens,
go to 'New physiologically-relevant CIE x,y chromaticity coordinates
(proposed)' and get the 2-deg coordinates at 1.0 nm resolution
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotCIEchrom">plotCIEchrom</a></code> for examples of this data in use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CIExyz)
</code></pre>

<hr>
<h2 id='emSpectrum'>Plot a pretty electromagnetic spectrum</h2><span id='topic+emSpectrum'></span>

<h3>Description</h3>

<p>This function plots an annotated electromagnetic spectrum.
There are options to include annotations about the molecular
effects and/or typical applications in technology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emSpectrum(molecular = TRUE, applications = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emSpectrum_+3A_molecular">molecular</code></td>
<td>
<p>Logical. Add annotations about molecular effects?</p>
</td></tr>
<tr><td><code id="emSpectrum_+3A_applications">applications</code></td>
<td>
<p>Logical. Add annotations about applications?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Side effect is a plot.
</p>


<h3>Note</h3>

<p>The diagram is wider than a standard <code>R</code> graphics device.
You should send it to a <code>pdf</code> or similar device
with the width set to 11&quot; or so.
</p>


<h3>Details</h3>

<p>Obviously not to scale, but hopefully aesthetically pleasing!
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dev.new(width = 10.5, height = 3)
emSpectrum()
emSpectrum(molecular = FALSE, applications = FALSE)
dev.off()
</code></pre>

<hr>
<h2 id='gatherCsv'>Combine csv Files Containing Spectral Data into a Data Frame</h2><span id='topic+gatherCsv'></span>

<h3>Description</h3>

<p>This function processes csv files containing two columns, wavelength and
absorbance (or intensity etc), into a data frame, which is then written out as a csv file.  The
files should have no header row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gatherCsv()
</code></pre>


<h3>Details</h3>

<p>It is assumed that the csv files have already been cleaned up so that they
contain only wavelength and absorbance data.  The wavelength data column
must be the same in all the files (as they would be if they came from the
same instrument with the same settings).
</p>


<h3>Value</h3>

<p>A data frame containing the wavelengths in the first column and the
absorbances in the other columns, one per file, with the file name
generating the column name.  The data frame is written out in a file called
&quot;All Spec Files.csv&quot;.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gatherSpecFiles">gatherSpecFiles</a></code> which is the function the user should
call.
</p>

<hr>
<h2 id='gatherSpecFiles'>Process LoggerPro Spectral Files into a Data Frame</h2><span id='topic+gatherSpecFiles'></span>

<h3>Description</h3>

<p>This function will go through all the files of a specified format in a
directory and convert them into a data frame with one column containing the
wavelength information and the other columns the absorbances of each sample
(file).  The file names are used to create the column names in the data
frame.  Optionally, non-integer wavelengths in the file can be combined to
give integer wavelengths. Keep in mind that this function specifically
modifies formats written by LoggerPro.  Each format, as it comes from
LoggerPro, has various amounts of crap in it which has to be removed or
modified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gatherSpecFiles(type = "txt", intLambda = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gatherSpecFiles_+3A_type">type</code></td>
<td>
<p>A character string giving the type of files to be processed.
Currently, either &quot;txt&quot;, &quot;csv&quot; or &quot;cmbl&quot; extensions can be processed.</p>
</td></tr>
<tr><td><code id="gatherSpecFiles_+3A_intlambda">intLambda</code></td>
<td>
<p>Logical.  If TRUE, non-integer wavelengths that round to
the same value will be combined and averaged and reported as integer values.</p>
</td></tr>
<tr><td><code id="gatherSpecFiles_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed downstream.  Currently none
possible.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All files of a given extension in the directory will be processed, so make
certain there are no extra files in the directory.  The files will be
modified and written back out as .csv files so look for the number of files
in the directory to double.  In the case of csv files, the original csv
files will be overwritten.  These files have no header row.
</p>


<h3>Value</h3>

<p>A data frame containing the wavelengths in the first column and the
absorbances in the other columns, one column per file, with column names
generated from the file names.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University
</p>

<hr>
<h2 id='gaussCurve'>Compute a Gaussian Curve</h2><span id='topic+gaussCurve'></span>

<h3>Description</h3>

<p>Computes the y values describing a Gaussian distribution given a range of x
values and parameters for mu, sigma, and area.  A tail may be introduced
into the curve to simulate the behavior of some chromatography peaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussCurve(x, area, mu, sigma, tail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussCurve_+3A_x">x</code></td>
<td>
<p>A vector of x values which will be used to compute the
corresponding y values.  Use enough to give good resolution.</p>
</td></tr>
<tr><td><code id="gaussCurve_+3A_area">area</code></td>
<td>
<p>The area of the peak, in arbitrary units.</p>
</td></tr>
<tr><td><code id="gaussCurve_+3A_mu">mu</code></td>
<td>
<p>The position of the peak.  Must fall in the range of x, of course.</p>
</td></tr>
<tr><td><code id="gaussCurve_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation of the peak.</p>
</td></tr>
<tr><td><code id="gaussCurve_+3A_tail">tail</code></td>
<td>
<p>A value describing any tailing desired.  If NA, no tailing is
applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of y values corresponding to the x values supplied.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lorentzCurve">lorentzCurve</a></code>, <code><a href="#topic+makeSpec">makeSpec</a></code> which uses this
function to make either spectra or chromatograms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### A pure Gaussian curve

myx &lt;- seq(0, 100, length.out = 1000) # use lots of point for resolution
myy &lt;- gaussCurve(x = myx, area = 1, mu = 40, sigma = 1.5, tail = NA)
plot(myx, myy, type = "l", main = "Pure Gaussian Curve")

### Now with tailing

myy2 &lt;- gaussCurve(x = myx, area = 1, mu = 40, sigma = 1.5, tail = 0.1)
plot(myx, myy2, type = "l", main = "Gaussian Curve with Tailing")

</code></pre>

<hr>
<h2 id='getGamutValues'>Look up gamut and white point values in the 1931 CIE system</h2><span id='topic+getGamutValues'></span><span id='topic+getWhiteValues'></span><span id='topic+getWhiteValues'></span>

<h3>Description</h3>

<p>These functions provide a simple way of storing white point and
gamut data for use in drawing CIE chromaticity diagrams.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGamutValues(gamut)

getWhiteValues(white)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGamutValues_+3A_gamut">gamut</code></td>
<td>
<p>A character string giving the name of the desired gamut.  One of
<code>c("Apple", "CIE", "Adobe", "sRGB", "NTSC", "SWOP")</code>.</p>
</td></tr>
<tr><td><code id="getGamutValues_+3A_white">white</code></td>
<td>
<p>The desired white point value.  One of <code>c("D65", "E", "C", "D50")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns x, y containing the vertices of the
requested gamut in CIE chromaticity coordinates, or, for a white point,
a data frame containing the coordinates of the requested white point.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotCIEchrom">plotCIEchrom</a></code> for examples of this function in use.
</p>

<hr>
<h2 id='jSeq'>Utility for Creating NMR Multiplets</h2><span id='topic+jSeq'></span>

<h3>Description</h3>

<p>This function creates sequences, centered on zero, which correspond to odd
or even NMR multiplets.  Not intended for direct use. Called by
<code><a href="#topic+plotNMRspec">plotNMRspec</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jSeq(length.out)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jSeq_+3A_length.out">length.out</code></td>
<td>
<p>An integer giving the number of peaks in the sequence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector describing the spacing of the parts of an NMR multiplet in
terms of multiples of the coupling constant, J.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotNMRspec">plotNMRspec</a></code> which calls this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp &lt;- jSeq(5) # a multiplet with an odd number of peaks
tmp
tmp &lt;- jSeq(6) # an even number
tmp

</code></pre>

<hr>
<h2 id='lorentzCurve'>Compute a Lorentzian Curve</h2><span id='topic+lorentzCurve'></span>

<h3>Description</h3>

<p>Computes the y values describing a Lorentzian curve such as seen in an NMR
peak. Requires a range of x values and parameters for peak position, area,
and gamma (half the peak width at half-height).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lorentzCurve(x, x0, area, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lorentzCurve_+3A_x">x</code></td>
<td>
<p>A vector of x values which will be used to compute the
corresponding y values.  Use enough to give good resolution.</p>
</td></tr>
<tr><td><code id="lorentzCurve_+3A_x0">x0</code></td>
<td>
<p>The position of the peak.  Must fall in the range of x, of course.</p>
</td></tr>
<tr><td><code id="lorentzCurve_+3A_area">area</code></td>
<td>
<p>The area of the peak, in arbitrary units.</p>
</td></tr>
<tr><td><code id="lorentzCurve_+3A_gamma">gamma</code></td>
<td>
<p>HWHM, half-width at half-maximum.  The peak &quot;width&quot; in units
corresponding to x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of y values corresponding to the x values supplied.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gaussCurve">gaussCurve</a></code>, <code><a href="#topic+makeSpec">makeSpec</a></code>,
<code><a href="#topic+plotNMRspec">plotNMRspec</a></code>
and <code><a href="#topic+plot2DNMRspec">plot2DNMRspec</a></code> for drawing NMR spectra.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
myx &lt;- seq(0, 100, length.out = 1000) # use lots of point for resolution
myy &lt;- lorentzCurve(x = myx, area = 1, x0 = 40, gamma = 5)
plot(myx, myy, type = "l", main = "Pure Lorentzian Curve")
y = 0.5*max(myy)
x = seq(40, 45, 0.5)
points(x = x, y = rep(y, length(x)), col = "blue", type = "l")
text(x = 42, y = y + 0.005, labels = c("gamma"), col = "blue", srt = 90)

</code></pre>

<hr>
<h2 id='makeSpec'>Draw a Chromatogram or Spectrum</h2><span id='topic+makeSpec'></span>

<h3>Description</h3>

<p>This function creates a chromatogram or spectrum from a list of appropriate
parameters describing the peaks.  The individual curves are computed using
the mathematical definition of either a Gaussian curve, possibly with
tailing, or a Lorentzian curve.  Gaussian curves are appropriate for
simulating chromatograms or UV-Vis spectra, while Lorentzians are
used for simulating NMR peaks.  The function computes the individual curves
as well as their sum (which is the whole chromatogram or spectrum).  A plot
can be made, which may display the separate underlying curves.  If you want
to draw NMR spectra, use <code><a href="#topic+plotNMRspec">plotNMRspec</a></code> which is a much more
natural interface to this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSpec(peak.list, x.range, plot = TRUE, curves = FALSE, type = "gauss",
  noise = 0, dd = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeSpec_+3A_peak.list">peak.list</code></td>
<td>
<p>For a Gaussian curve, a data frame with the following
columns: mu, sd, area, tail.  mu is the retention time (or center
frequency).  sd is the standard deviation (or peak width).  area is the area
under the peak.  tail is the tailing parameter - use NA when a pure Gaussian
with no tailing is desired.  One row of the data frame contains data related
to one peak.
</p>
<p>For a Lorentzian curve, a data frame with the following columns: x0, area,
gamma.  x0 is the center frequency or chemical shift.  gamma is the half the
peak width at half-height.  area is the area under the peak.</p>
</td></tr>
<tr><td><code id="makeSpec_+3A_x.range">x.range</code></td>
<td>
<p>A numeric vector of length 2 giving the retention time range
(or frequency range) desired.  Must make sense in light of the peak list
given (i.e. a wider range, possibly much wider depending up the values of
<code>sd</code> and <code>tail</code>), as these broaden the peaks.</p>
</td></tr>
<tr><td><code id="makeSpec_+3A_plot">plot</code></td>
<td>
<p>Logical; if TRUE, a plot is produced.</p>
</td></tr>
<tr><td><code id="makeSpec_+3A_curves">curves</code></td>
<td>
<p>Logical; if TRUE, the individual curves are plotted (provided
<code>plot = TRUE</code>.  Not very useful for NMR spectra, but great for showing,
for instance, how shoulders arise on peaks in a chromatogram.</p>
</td></tr>
<tr><td><code id="makeSpec_+3A_type">type</code></td>
<td>
<p>A character string.  Use &quot;gauss&quot; to generate Gaussian curves
(for chromatograms, or UV-Vis spectra).  Use &quot;lorentz&quot; to generate
Lorentzian curves as found in NMR spectra.</p>
</td></tr>
<tr><td><code id="makeSpec_+3A_noise">noise</code></td>
<td>
<p>A number giving the amount of noise to be added to the
individual curves (the net spectrum has the noise from the individual
spectra, it has no additional noise added to it).  Value corresponds to the
argument <code>factor</code> in function <code>jitter</code>.</p>
</td></tr>
<tr><td><code id="makeSpec_+3A_dd">dd</code></td>
<td>
<p>The density of data points per unit of <code>x.range</code>.  The total
number of data points used to create the spectrum or chromatogram is
<code>dd*abs(diff(x.range))</code> and thus it also depends on the units of
<code>x.range</code>.  This approach ensures that peaks are not distorted when
changing <code>x.range</code> for the same <code>peak.list</code>.</p>
</td></tr>
<tr><td><code id="makeSpec_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed downstream.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the x values (retention times or
frequencies) in the first row, and the complete chromatogram (spectrum) in
the second row.  Additional rows contain chromatograms (spectra) of the
individual components.  The row names of the data frame are character
strings describing the chromatogram (spectrum) in that row.  The matrix
contains <code>dd*abs(diff(x.range))</code> columns.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gaussCurve">gaussCurve</a></code>, <code><a href="#topic+lorentzCurve">lorentzCurve</a></code>,
<code><a href="#topic+plotNMRspec">plotNMRspec</a></code> and <code><a href="#topic+plot2DNMRspec">plot2DNMRspec</a></code>, the preferred
interfaces for drawing NMR spectra.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### A simple chromatogram

chrom &lt;- data.frame(mu = c(2, 5, 11), sd = c(0.5, 1, 2),
area = c(1, 0.5, 1), tail =  c(NA, NA, 0.1))
ex1 &lt;- makeSpec(chrom, x.range = c(0, 20), plot = TRUE, curves = TRUE,
dd = 5, main = "Chromatogram with Underlying Pure Curves")

### Faux ethyl group NMR with J = 0.1 ppm.
# Note that a much better
# NMR spectrum can be generated using plotNMRspec which also uses
# a more natural input format
#
spec &lt;- data.frame(mu = c(3.5, 3.4, 3.3, 3.2, 1.4, 1.3, 1.2),
sd = rep(0.01, 7), tail =  rep(NA, 7),
area = c(1, 3, 3, 1, 1, 2, 1) * c(0.5, 0.5, 0.5, 0.5, 0.66, 0.66, 0.66))
ex2 &lt;- makeSpec(spec, x.range = c(5, 0), plot = TRUE, curves = FALSE,
dd = 100, main = "Simulated 1H NMR of an Ethyl Group")

</code></pre>

<hr>
<h2 id='plot2DNMRspec'>Draw a 2D NMR Spectrum</h2><span id='topic+plot2DNMRspec'></span>

<h3>Description</h3>

<p>This function simulates 2D NMR spectra.  Only 1st order coupling can be
handled &ndash; there is currently no capacity for doublet of doublets and
other such peaks.  The field strength of the &quot;instrument&quot; is taken into
account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot2DNMRspec(peaks, x.range = c(0, 12), MHz = 300, ppHz = 1,
  type = "COSY", M = NULL, levels = seq(0.5, 1, by = 0.1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot2DNMRspec_+3A_peaks">peaks</code></td>
<td>
<p>A data frame with the following columns: delta, mult
(multiplicity), J, area, pw.  Multiplicity should be given by a number, so
use 2 for a doublet.  J is in Hz (use 0 for singlets).  pw is the peak width
at half-height in Hz.</p>
</td></tr>
<tr><td><code id="plot2DNMRspec_+3A_x.range">x.range</code></td>
<td>
<p>A numeric vector of length 2 giving the ppm range desired.
Must be increasing.</p>
</td></tr>
<tr><td><code id="plot2DNMRspec_+3A_mhz">MHz</code></td>
<td>
<p>Integer.  The operating frequency of the instrument, in MHz.</p>
</td></tr>
<tr><td><code id="plot2DNMRspec_+3A_pphz">ppHz</code></td>
<td>
<p>Points per Hz: The number of data points per Hz to use in
calculating the spectrum (passed as argument <code>dd</code> to <code>makeSpec</code>).
The default (1) works well for 1H NMR spectra.
Note that this function uses Hz internally so that the <code>x.range</code>, which
is in ppm, is multiplied by <code>Mhz</code> before being sent to
<code><a href="#topic+makeSpec">makeSpec</a></code>, and once there, <code>makeSpec</code> will multiply it by
<code>ppHz</code>.  Thus the total data points used is <code>ppHz * Mhz *
abs(diff(x.range))</code>.  This approach ensures that peaks are not distorted
when changing <code>x.range</code> for the same <code>peak.list</code>.</p>
</td></tr>
<tr><td><code id="plot2DNMRspec_+3A_type">type</code></td>
<td>
<p>The type of 2D spectrum desired.  One of <code>c("COSY", "TOCSY")</code>.</p>
</td></tr>
<tr><td><code id="plot2DNMRspec_+3A_m">M</code></td>
<td>
<p>An adjacency matrix indicating which peaks are coupled.
The order of rows and columns must be the same as in <code>peaks</code>.</p>
</td></tr>
<tr><td><code id="plot2DNMRspec_+3A_levels">levels</code></td>
<td>
<p>A vector of levels for the contour plot.  Must be in (0...1).</p>
</td></tr>
<tr><td><code id="plot2DNMRspec_+3A_...">...</code></td>
<td>
<p>Parameters to be passed to the plotting function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeSpec">makeSpec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### ethyl 2-ethyl-3-oxobutyrate
### Set up data

peaks1 &lt;- data.frame(
#             A     B     C     D     E     F
	delta = c(4.20, 3.34, 2.23, 1.88, 1.28, 0.94),
	mult = c(4, 3, 1, 5, 3, 3),
	J = c(14, 14, 0, 14, 14, 14),
	area = c(2, 1, 3, 2, 3, 3),
	pw = c(2, 2, 2, 2, 2, 2))

#              A, B, C, D, E, F
AM &lt;- matrix(c(0, 0, 0, 0, 1, 0,  # A
               0, 0, 0, 1, 0, 0,  # B
               0, 0, 0, 0, 0, 0,  # C
               0, 1, 0, 0, 0, 1,  # D
               1, 0, 0, 0, 0, 0,  # E
               0, 0, 0, 1, 0, 0), # F
			   ncol = 6)

### 1D 1H NMR plot for reference
# CRAN checks will skip some examples to save time


jnk &lt;- plotNMRspec(peaks = peaks1, x.range = c(0, 5), MHz = 500,
main = "1H NMR of ethyl 2-ethyl-3-oxobutyrate")

### 2D COSY plot

res &lt;- plot2DNMRspec(peaks = peaks1, x.range = c(0, 5), MHz = 500, ppHz = 1, M = AM,
main = "COSY of ethyl 2-ethyl-3-oxobutyrate")

### 2D TOCSY plot

## Not run: 

res &lt;- plot2DNMRspec(peaks = peaks1, x.range = c(0, 5), MHz = 500, ppHz = 1,
levels = c(0.85, 0.9, 0.95), type = "TOCSY",
main = "TOCSY of ethyl 2-ethyl-3-oxobutyrate")

## End(Not run)
</code></pre>

<hr>
<h2 id='plotCIEchrom'>Draw the 1931 CIE chromaticity diagram</h2><span id='topic+plotCIEchrom'></span>

<h3>Description</h3>

<p>This function draws the 1931 CIE chromaticity diagram with
various decorations and annotations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCIEchrom(gradient = NULL, colSpace = "sRGB", ex = 1, opts = c("D65",
  "specLocus", "purples"), title = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCIEchrom_+3A_gradient">gradient</code></td>
<td>
<p>Character: either <code>"sl"</code>, <code>NULL</code>, or a
data frame with columns x and y.  If <code>NULL</code>, no gradient is drawn.
If <code>"sl"</code> a gradient filling the entire spectral locus is drawn.
If a data frame, the vertices should specify a polygon to be filled with
the gradient (see the examples for convenient ways to specify the gradient).</p>
</td></tr>
<tr><td><code id="plotCIEchrom_+3A_colspace">colSpace</code></td>
<td>
<p>Character string giving the color space to use for
drawing the gradient.  One of <code>c("sRGB", "Apple RGB")</code>.
<code>Apple RGB</code> is mainly of historical interest; no physical
devices use it at this time.</p>
</td></tr>
<tr><td><code id="plotCIEchrom_+3A_ex">ex</code></td>
<td>
<p>Numeric.  The 'exposure' to use.  The exposure must be
used with <strong>extreme care</strong>.  Larger values of <code>exposure</code>
make the white point whiter in the plot, and lightens colors near
the spectral locus (driving some off the plot!).  The purpose is to
alter the aesthetics of the plot - that is, to make the white &quot;whiter&quot;
so that it looks &quot;right&quot;.  The effect of exposure will vary with the display device.</p>
</td></tr>
<tr><td><code id="plotCIEchrom_+3A_opts">opts</code></td>
<td>
<p>A character vector of options to be employed.  One or
more of c(&quot;D65&quot;, &quot;D50&quot;, &quot;C&quot;, &quot;E&quot;, &quot;specLocus&quot;, &quot;purples&quot;, &quot;Munsell&quot;,
&quot;sRGB&quot;, &quot;SWOP&quot;, &quot;Apple&quot;, &quot;NTSC&quot;, &quot;Adobe&quot;, &quot;CIE&quot;).  The first few of
these are reference white points.  <code>"specLocus"</code> and <code>"purples"</code>
cause the spectral locus and line of purples to be labeled.  <code>"Munsell"</code>
causes the approximate Munsell hues to be marked along the spectral
locus at the appropriate wavelength.  The last few options cause the requested gamut to be outlined.</p>
</td></tr>
<tr><td><code id="plotCIEchrom_+3A_title">title</code></td>
<td>
<p>A character string to be plotted at the top of the diagram.
If NULL, the title defaults to &quot;1931 CIE Chromaticity Diagram&quot;.
If no title is desired, set it to an empty string.</p>
</td></tr>
<tr><td><code id="plotCIEchrom_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed downstream, to <code>grid</code> functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot is drawn using <code>grid</code> graphics.
</p>


<h3>Warning</h3>

<p>The appearance of the color gradient will vary with the
device, surface and incident light used to view it and is not likely correct
anywhere.  <strong>The appearance varies strongly with exposure</strong>.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>References</h3>

<p>For <code>opts = "Munsell"</code>
the Munsell designation by wavelength are taken from Romney &amp; Indow
<a href="pnas.org/cgi/doi/10.1073/pnas.162368999">pnas.org/cgi/doi/10.1073/pnas.162368999</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("grid")
plotCIEchrom() # no gradient
## These are a too slow for CRAN checks:
## Not run: 
plotCIEchrom(gradient = "sl") # basic plot
# Notice there is not much yellow in that plot.  Increase
# the exposure to bring in some yellow, at the expense of some blues:
plotCIEchrom(gradient = "sl", ex = 1.4)
# Next show a gradient for the CMYK printing process
# and outline the colors a typical monitor can display.
plotCIEchrom(gradient = getGamutValues("SWOP"), opts = c("D65", "SWOP", "sRGB"))

## End(Not run)
</code></pre>

<hr>
<h2 id='plotNMRspec'>Create and Plot an NMR Spectrum</h2><span id='topic+plotNMRspec'></span>

<h3>Description</h3>

<p>This function simulates simple NMR spectra.  Only 1st order coupling can be
handled &ndash; there is currently no capacity for doublet of doublets and
other such peaks.  The field strength of the &quot;instrument&quot; is taken into
account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotNMRspec(peaks, x.range = c(12, 0), MHz = 300, ppHz = 1,
  nuclei = "1H", pkLabs = TRUE, lab.pos = NULL, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotNMRspec_+3A_peaks">peaks</code></td>
<td>
<p>A data frame with the following columns: delta, mult
(multiplicity), J, area, pw.  Multiplicity should be given by a number, so
use 2 for a doublet.  J is in Hz (use 0 for singlets).  pw is the peak width
at half-height in Hz.</p>
</td></tr>
<tr><td><code id="plotNMRspec_+3A_x.range">x.range</code></td>
<td>
<p>A numeric vector of length 2 giving the ppm range desired.</p>
</td></tr>
<tr><td><code id="plotNMRspec_+3A_mhz">MHz</code></td>
<td>
<p>Integer.  The operating frequency of the instrument, in MHz.</p>
</td></tr>
<tr><td><code id="plotNMRspec_+3A_pphz">ppHz</code></td>
<td>
<p>Integer, but numeric works too!
Points per Hz: The number of data points per Hz to use in
calculating the spectrum (passed as argument <code>dd</code> to <code>makeSpec</code>).
The default (1) works well for 1H NMR spectra.  For 13C NMR spectra, where
the peaks are very narrow, one may need to increase the data density so that
enough points define the peaks (a value of 4 is a good starting point).
See Details.</p>
</td></tr>
<tr><td><code id="plotNMRspec_+3A_nuclei">nuclei</code></td>
<td>
<p>Character.  One of <code>c("1H", "13C")</code>. Controls the spacing
of the tick marks and labeling of the peaks.</p>
</td></tr>
<tr><td><code id="plotNMRspec_+3A_pklabs">pkLabs</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, and <code>nuclei = 1H</code>, the integral
is drawn next to the peak.  If <code>FALSE</code>, no labels are drawn.</p>
</td></tr>
<tr><td><code id="plotNMRspec_+3A_lab.pos">lab.pos</code></td>
<td>
<p>A vector of label positions as along as the number of rows in
<code>peaks</code> (the number of peaks in the spectrum).  A numeric vector
where 2 = left and 4 = right.  This adjusts the positions of the labels
to be either left or right of the peak as a way to avoid overlaps.  The
order must correspond to the order in <code>peaks</code>.</p>
</td></tr>
<tr><td><code id="plotNMRspec_+3A_plot">plot</code></td>
<td>
<p>Logical: Shall a plot be made?</p>
</td></tr>
<tr><td><code id="plotNMRspec_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed downstream.  These may affect
the plot.  You can also include <code>noise = some number</code> to add noise
(passed through to <code>makeSpec</code>).  In this case, warnings are raised
from the plotting routines, but they can be ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame of the type produced by <code><a href="#topic+makeSpec">makeSpec</a></code>.
See there for details.  x values are in Hz.
</p>


<h3>Details</h3>

<p>Note that this function uses Hz internally so that the <code>x.range</code>, which
is in ppm, is multiplied by <code>Mhz</code> before being sent to
<code><a href="#topic+makeSpec">makeSpec</a></code>, and once there, <code>makeSpec</code> will multiply it by
<code>ppHz</code>.  Thus the total data points used is <code>floor(ppHz * Mhz *
abs(diff(x.range)))</code>.  This approach ensures that peaks are not distorted
when changing <code>x.range</code> for the same <code>peak.list</code>.
</p>
<p>Note that <code>ppHz</code> can be numeric as well, due to the use of <code>floor</code>.
This can be useful: if you wanted your simulated NMR spectrum to be composed
of exactly 16384 data points as real data might be, you can call the function
with <code>ppHz</code> specified like <code>ppHz = 2^14/(12*500)</code> and it works!
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lorentzCurve">lorentzCurve</a></code>, <code><a href="#topic+makeSpec">makeSpec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### A simulated 1H NMR spectrum

peaks1 &lt;- data.frame(
	delta = c(1.3, 3.75, 3.9, 10.2),
	mult = c(3, 4, 2, 1),
	J = c(14, 14, 14, 0),
	area = c(3, 2, 1, 1),
	pw = c(2, 2, 2, 10))

res &lt;- plotNMRspec(peaks1, x.range = c(12, 0), MHz = 500,
	main = "500 MHz Simulated 1H NMR Spectrum")

### Compare to the same data at 200 MHz and plot together

par(mfrow = c(2,1))
res &lt;- plotNMRspec(peaks1, x.range = c(12, 0), MHz = 500,
	main = "500 MHz Simulated 1H NMR Spectrum")
res &lt;- plotNMRspec(peaks1, x.range = c(12, 0), MHz = 200,
	main = "200 MHz Simulated 1H NMR Spectrum")
par(mfrow = c(1,1))

### Zoom in to show off

par(mfrow = c(2,1))
res &lt;- plotNMRspec(peaks1, x.range = c(4.5, 1), MHz = 500,
	main = "500 MHz Simulated 1H NMR Spectrum")
res &lt;- plotNMRspec(peaks1, x.range = c(4.5, 1), MHz = 200,
	main = "200 MHz Simulated 1H NMR Spectrum")
par(mfrow = c(1,1))

### A simulated 13C NMR spectrum

# This is substantially slower due to the large
# chemical shift range

peaks2 &lt;- data.frame(
	delta = c(160, 155, 145, 143, 135, 60, 32),
	mult = rep(1, 7),
	J = rep(1, 7),
	area = c(0.1, 0.3, 0.3, 1, 1, 0.5, 0.5),
	pw = rep(1, 7))

res &lt;- plotNMRspec(peaks2, x.range = c(180, 0), MHz = 200,
	main = "200 MHz Simulated 13C NMR Spectrum", ppHz = 4,
	pkLabs = FALSE, nuclei = "13C")

# Try repeating the above with ppHz = 1; note the peaks heights are not quite right
# as there are not enough data points to define the peak properly.

</code></pre>

<hr>
<h2 id='prepCIEgradient'>Compute a gradient to fill the CIE chromaticity diagram</h2><span id='topic+prepCIEgradient'></span>

<h3>Description</h3>

<p>This function creates a gradient to fill the CIE chromaticity diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepCIEgradient(vertices = NULL, colSpace = "sRGB", ex = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepCIEgradient_+3A_vertices">vertices</code></td>
<td>
<p>The vertices of a polygon that is to be filled with
the gradient.</p>
</td></tr>
<tr><td><code id="prepCIEgradient_+3A_colspace">colSpace</code></td>
<td>
<p>Character.  The color space model to use.</p>
</td></tr>
<tr><td><code id="prepCIEgradient_+3A_ex">ex</code></td>
<td>
<p>Numeric.  The exposure factor. This shifts the gradient.
Be extremely careful with this.  See <code><a href="#topic+plotCIEchrom">plotCIEchrom</a></code>
for full details.</p>
</td></tr>
<tr><td><code id="prepCIEgradient_+3A_...">...</code></td>
<td>
<p>Arguments to be passed downstream.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array containing the data needed to draw the gradient.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotCIEchrom">plotCIEchrom</a></code> for examples of this function in use.
</p>

<hr>
<h2 id='qMS'>Draw a Simple Mass Spectrum Showing the Parent Ion</h2><span id='topic+qMS'></span>

<h3>Description</h3>

<p>Given a molecular formula, this function computes the mass of the parent
ion, including any M + n peaks due to Br or Cl, and plots it.  Intended to
draw the parent ion region for small organic molecules, especially those
with Br or Cl.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qMS(f = NULL, xlab = "m/z", ylab = "intensity", main = "Mass Spectrum",
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qMS_+3A_f">f</code></td>
<td>
<p>A character string giving the molecular formula of the molecule of
interest.  Order of elements does not matter.  Elements should be given
as their atomic symbols, e.g. &quot;Br&quot; not &quot;br&quot;.</p>
</td></tr>
<tr><td><code id="qMS_+3A_xlab">xlab</code></td>
<td>
<p>A character string giving the x axis label.</p>
</td></tr>
<tr><td><code id="qMS_+3A_ylab">ylab</code></td>
<td>
<p>A character string giving the y axis label.</p>
</td></tr>
<tr><td><code id="qMS_+3A_main">main</code></td>
<td>
<p>A character string giving the title of the plot.</p>
</td></tr>
<tr><td><code id="qMS_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed downstream.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function currently accepts formulas containing C, H, N, O, Br and Cl in
any quantities.
</p>


<h3>Value</h3>

<p>Draws a plot.  Returns a data frame giving the peak masses and
relative intensites.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ms &lt;- qMS(f = "C5H8BrCl", xlim = c(150, 200), main = "Parent Ion of C5H8BrCl")

</code></pre>

<hr>
<h2 id='txt2csv'>Utility Functions to Clean and Convert Spectral Files to csv</h2><span id='topic+txt2csv'></span><span id='topic+cmbl2csv'></span><span id='topic+sstab2csv'></span>

<h3>Description</h3>

<p>These functions clean out extraneous information from exported spectral data
files and then write them out in csv format.  <code>txt2csv</code> and <code>cmbl2csv</code> handle
files exported by LoggerPro software.  <code>sstab2csv</code> handles files exported by
Spectra Suite software.  Not directly called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>txt2csv(in.file = "", out.file = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="txt2csv_+3A_in.file">in.file</code></td>
<td>
<p>The name of the input file.</p>
</td></tr>
<tr><td><code id="txt2csv_+3A_out.file">out.file</code></td>
<td>
<p>The name of the output file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extraneous text at the beginning of the file is removed.  In the case of
cmbl files, lines containing &quot;Z2&quot; or &quot;&gt;&quot; are removed.  Absorbances marked as
&quot;Z1&quot; are replaced with zero.  The data are initially in one long column; the
wavelength and absorbances are reunited into two columns.
</p>


<h3>Value</h3>

<p>A modifed file in csv format.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gatherSpecFiles">gatherSpecFiles</a></code> which is the function the user should
call.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
