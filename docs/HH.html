<!DOCTYPE html><html><head><title>Help for package HH</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HH}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#HH-package'>
<p>Statistical Analysis and Data Display: Heiberger and Holland</p></a></li>
<li><a href='#ae.dotplot'><p> AE (Adverse Events) dotplot of incidence and relative risk</p></a></li>
<li><a href='#AEdotplot'><p> AE (Adverse Events) dotplot of incidence and relative risk</p></a></li>
<li><a href='#AEdotplot.data.frame'><p> AE (Adverse Events) dotplot of incidence and relative risk,</p>
support functions</a></li>
<li><a href='#ancova'><p>Compute and plot oneway analysis of covariance</p></a></li>
<li><a href='#ancova-class'><p>Class &quot;ancova&quot; Analysis of Covariance</p></a></li>
<li><a href='#ancovaplot'>
<p>Analysis of Covariance Plots</p></a></li>
<li><a href='#anova.ancovaplot'>
<p>ANOVA table for a c(&quot;ancovaplot&quot;,&quot;trellis&quot;) object.</p></a></li>
<li><a href='#anovaMean'><p>ANOVA table from the group sample sizes, means, and standard deviations.</p></a></li>
<li><a href='#aovSufficient'><p>Analysis of variance from sufficient statistics for groups.</p></a></li>
<li><a href='#arima.diag.hh'><p>Repair design error in S-Plus arima.diag</p></a></li>
<li><a href='#arma.loop'><p>Loop through a series of ARIMA models and display coordinated</p>
tables and diagnoastic graphs.</a></li>
<li><a href='#as.likert'><p>Support functions for diverging stacked barcharts for Likert, semantic</p>
differential, and rating scale data.</a></li>
<li><a href='#as.matrix.listOfNamedMatrices'><p>Convert a list of numeric matrices to a single matrix</p></a></li>
<li><a href='#as.multicomp'><p>Support functions in R for MMC (mean&ndash;mean multiple comparisons) plots.</p></a></li>
<li><a href='#as.vector.trellis'>
<p>Convert a two-dimensional trellis object into a one-dimensional trellis object.</p>
Change the order of panels in a trellis object.</a></li>
<li><a href='#axis.i2wt'><p>specialized axis function for interaction2wt.</p></a></li>
<li><a href='#bivariateNormal'>
<p>Plot the bivariate normal density using wireframe for specified rho.</p></a></li>
<li><a href='#ci.plot'><p>Plot confidence and prediction intervals for simple linear regression</p></a></li>
<li><a href='#CIplot'>
<p>Illustration of the meaning of confidence levels.</p></a></li>
<li><a href='#col.hh'><p>Initializing Trellis Displays</p></a></li>
<li><a href='#col3x2'>
<p>col3x2 color dataset</p></a></li>
<li><a href='#combineLimits.trellisvector'>
<p>Combine limits on a one-dimensional trellis object.</p></a></li>
<li><a href='#cp.calc'><p> Rearranges and improves the legibility of the output from</p>
the stepwise function in S-Plus.</a></li>
<li><a href='#cplx'>
<p>Generate a sequence spanning the xlim of a lattice window.</p></a></li>
<li><a href='#datasets'><p>Datasets for Statistical Analysis and Data Display, Heiberger and</p>
Holland</a></li>
<li><a href='#dchisq.intermediate'><p>Intermediate f and chisq functions to simplify writing</p>
for both R and S-Plus.</a></li>
<li><a href='#diag.maybe.null'><p>Returns a value for the diagonal of NA and NULL arguments.</p></a></li>
<li><a href='#diagplot5new'>
<p>Transpose of ECDF for centered fitted values and residuals from a linear model.</p></a></li>
<li><a href='#diagQQ'>
<p>QQ plot of regression residuals.</p></a></li>
<li><a href='#Discrete4'>
<p>Discrete with four levels color dataset.</p></a></li>
<li><a href='#do.formula.trellis.xysplom'><p>Interprets model formulas for xysplom and extended bwplots</p></a></li>
<li><a href='#EmphasizeVerticalPanels'>
<p>Helper function for likertWeighted(). used for vertical spacing and</p>
horizontal borders of grouped panels.</a></li>
<li><a href='#emptyMainLeftAxisLeftStripBottomLegend'>
<p>Remove main title, left axis tick labels, left strip, bottom legend</p>
from plot and keep the vertical spacing allocated to those items.</a></li>
<li><a href='#export.eps'><p> Exports a graph to an EPS file.</p></a></li>
<li><a href='#extra'><p>Miscellaneous functions that I wish were in or consistent between</p>
S-Plus and R.</a></li>
<li><a href='#F.curve'><p>plot a chisquare or a F-curve.</p></a></li>
<li><a href='#glhtWithMCP.993'><p>Retain averaging behavior that was previously available in glht.</p></a></li>
<li><a href='#gof.calculation'><p>Calculate Box&ndash;Ljung Goodness of Fit for ARIMA models in S-Plus.</p></a></li>
<li><a href='#grid.yaxis.hh'><p>make x- and y-axis labels</p></a></li>
<li><a href='#GSremove'><p>Remove selected GraphSheetPages in the S-Plus Windows GUI Graphsheet</p></a></li>
<li><a href='#HH-internal'><p>Internal HH functions</p></a></li>
<li><a href='#HH.regsubsets'><p>Display tabular results for Best Subsets Regression.</p></a></li>
<li><a href='#hhpdf'>
<p>R tools for writing HH2: hhpdf, hhdev.off, hhcapture, hhcode, hhpng, hhlatex</p></a></li>
<li><a href='#HHscriptnames'><p>Find absolute pathname of a script file for the HH book in the HH</p>
package.</a></li>
<li><a href='#hov'><p>Homogeneity of Variance</p></a></li>
<li><a href='#hovBF'>
<p>Homogeneity of Variance:  Brown&ndash;Forsyth method</p></a></li>
<li><a href='#if.R'><p> Conditional Execution for R or S-Plus</p></a></li>
<li><a href='#InsertVerticalPanels'>
<p>Expand a 3D array on the second dimension, inserting empty layers where</p>
the input vector has a <code>0</code> value.  A 2D argument <code>x</code> with <code>dim(x)==c(r,c)</code> is
first extended to 3D with <code>dim(x)==c(1,r,c)</code>, and then the result is
collapsed back to 2D.</a></li>
<li><a href='#interaction.positioned'><p>interaction method for positioned factors.</p></a></li>
<li><a href='#interaction2wt'><p>Plot all main effects and twoway interactions in a multifactor design</p></a></li>
<li><a href='#interval'><p>Prediction and Confidence Intervals for glm Objects</p></a></li>
<li><a href='#intxplot'><p>Interaction plot, with an option to print standard error bars.</p></a></li>
<li><a href='#ladder'><p>Draw a &quot;ladder of powers&quot; plot, plotting each of several powers</p>
of y against the same powers of x.</a></li>
<li><a href='#latex.array'>
<p>Generate the latex code for an <code>"array"</code> or <code>"table"</code> with 3, 4, or more dimensions.</p></a></li>
<li><a href='#latticeresids'>
<p>Subroutine used by residual.plots.lattice</p></a></li>
<li><a href='#legendGrob2wt'><p>place separate keys to the left of each row of a trellis</p></a></li>
<li><a href='#likert'><p>Diverging stacked barcharts for Likert, semantic</p>
differential, rating scale data, and population pyramids.</a></li>
<li><a href='#likertColor'><p>Selection of colors for Likert plots.</p></a></li>
<li><a href='#likertMosaic'><p>Diverging stacked barcharts for Likert, semantic</p>
differential, rating scale data, and population pyramids
based on mosaic as the plotting style.
</p></a></li>
<li><a href='#LikertPercentCountColumns'><p>Display likert plots with percents in the first column of panels</p>
and counts in the second column of panels.</a></li>
<li><a href='#likertWeighted'>
<p>Special case wrapper for likert() when multiple columns are to have the</p>
same bar thicknesses.  Uses formula with one or two conditioning variables.</a></li>
<li><a href='#lm.case'><p> case statistics for regression analysis</p></a></li>
<li><a href='#lm.regsubsets'><p>Evaluate lm model with highest adjusted $R^2$.</p></a></li>
<li><a href='#lmatPairwise'>
<p>lmatPairwise</p></a></li>
<li><a href='#lmatRows'><p>Find the row numbers in the lmat</p>
corresponding to the focus factor.</a></li>
<li><a href='#lmplot'>
<p>Four types of residual plots for linear models.</p></a></li>
<li><a href='#logit'><p>Logistic and odds functions and their inverses.</p></a></li>
<li><a href='#matrix.trellis'>
<p>Convert a one-dimensional trellis object to a two-dimensional trellis object.</p>
This permits combineLimits and useOuterStrips to work.</a></li>
<li><a href='#mcalinfct'><p>MCA multiple comparisons analysis (pairwise)</p></a></li>
<li><a href='#mmc'><p>MMC (Mean&ndash;mean Multiple Comparisons) plots.</p></a></li>
<li><a href='#mmc.mean'><p> MMC (Mean&ndash;mean Multiple Comparisons) plots from the sufficient</p>
statistics for a one-way design.</a></li>
<li><a href='#mmcAspect'>
<p>Control aspect ratio in MMC plots to maintain isomeans grid as a square.</p></a></li>
<li><a href='#mmcisomeans'>
<p>Functions used by mmcplot.</p></a></li>
<li><a href='#mmcplot'>
<p>MMC (Mean-mean Multiple Comparisons) plots in lattice.</p></a></li>
<li><a href='#mmcPruneIsomeans'>
<p>MMC plots in lattice&mdash;suppress isomeans grid lines for specified levels</p>
of the factor.</a></li>
<li><a href='#multicomp.order'><p>Update a multicomp object by ordering its contrasts.</p></a></li>
<li><a href='#multicomp.reverse'><p>Force all comparisons in a &quot;multicomp&quot; object to have the same sign.</p></a></li>
<li><a href='#norm.curve'><p>plot a normal or a t-curve with both x and z axes.</p></a></li>
<li><a href='#NormalAndTplot'><p>Specify plots to illustrate Normal and t Hypothesis Tests or Confidence Intervals.</p></a></li>
<li><a href='#NormalAndTPower'>
<p>Construct a power graph based on the NTplot.</p></a></li>
<li><a href='#normalApproxBinomial'>
<p>Plots to illustrate Normal Approximation to the</p>
Binomial&mdash;hypothesis tests or confidence intervals.</a></li>
<li><a href='#npar.arma'><p>Count the number of parameters in an ARIMA model specification.</p></a></li>
<li><a href='#NTplot'><p>Specify plots to illustrate Normal and t Hypothesis Tests or</p>
Confidence Intervals, including normal approximation to the binomial.</a></li>
<li><a href='#objip'><p>loop through all attached directories looking for pattern,</p>
possibly restricting to specified class or mode.</a></li>
<li><a href='#OddsRatio'><p> Calculate or plot the odds ratio for a 2x2 table of counts.</p></a></li>
<li><a href='#OneWayVarPlot'>
<p>Displays a three-panel <code>bwplot</code> of the data by group, of the group</p>
means, and of the entire dataset.  This is an approximate visualization
of the Mean Square lines from the ANOVA table for a one-way ANOVA model.</a></li>
<li><a href='#orthog.complete'><p>Construct an orthogonal matrix which is an arbitrary completion</p>
of the column space of the input set of columns.</a></li>
<li><a href='#panel.acf'><p>Panel functions for tsdiagplot.</p></a></li>
<li><a href='#panel.axis.right'>
<p>Right-justify right-axis tick labels.</p></a></li>
<li><a href='#panel.bwplot.intermediate.hh'><p>Panel functions for bwplot.</p></a></li>
<li><a href='#panel.bwplot.superpose'>
<p>Panel function for bwplot that displays an entire box in the colors coded</p>
by groups.</a></li>
<li><a href='#panel.bwplott'><p>Extension to S-Plus trellis to allow transposed plots.</p></a></li>
<li><a href='#panel.cartesian'><p>trellis panel function, with labeled rows and columns and without</p>
strip labels.</a></li>
<li><a href='#panel.ci.plot'><p>Default Panel Function for ci.plot</p></a></li>
<li><a href='#panel.confintMMC'>
<p>Confidence interval panel for MMC tiebreaker plots, or confidence</p>
interval plot.</a></li>
<li><a href='#panel.dotplot.tb'><p>Dotplot with evenly spaced tiebreakers.</p></a></li>
<li><a href='#panel.interaction2wt'><p>Plot all main effects and twoway interactions in a multifactor design</p></a></li>
<li><a href='#panel.isomeans'>
<p>isomeans grid for MMC plots.</p></a></li>
<li><a href='#panel.likert'><p>Panel functions for likert that include a stackWidth argument</p></a></li>
<li><a href='#panel.pairs.hh'><p>Function based on S-Plus panel.pairs to add the subpanel.scales</p>
and panel.cex arguments.</a></li>
<li><a href='#panel.xysplom'><p>panel method for xysplom.</p></a></li>
<li><a href='#partial.corr'><p>partial correlations</p></a></li>
<li><a href='#pdf.latex'>
<p>Construct a pdf file from a &quot;latex&quot; file.  See Hmisc::latex for concepts.</p></a></li>
<li><a href='#pdiscunif'><p>Discrete Uniform Distribution</p></a></li>
<li><a href='#perspPlane'><p>Helper functions for regr2.plot</p></a></li>
<li><a href='#plot.hov'><p>Homogeneity of Variance Plot</p></a></li>
<li><a href='#plot.mmc.multicomp'><p>MMC (Mean&ndash;mean Multiple Comparisons) plot.</p></a></li>
<li><a href='#plot.multicomp'><p>Multiple comparisons plot that gives independent user control</p>
over the appearance of the significant and not significant comparisons.</a></li>
<li><a href='#position'><p>Find or assign the implied position for graphing the levels of a</p>
factor.
A new class &quot;positioned&quot;, which inherits from &quot;ordered&quot; and &quot;factor&quot;,
is defined.</a></li>
<li><a href='#positioned-class'><p>Class &quot;positioned&quot;, extends &quot;ordered&quot; to specify the position</p>
for graphing the levels of a factor.</a></li>
<li><a href='#print.latticeresids'>
<p>Print a <code>latticeresids</code> object.</p></a></li>
<li><a href='#print.NormalAndTplot'><p>Print method for Normal and t plots from NTplot.</p></a></li>
<li><a href='#print.tsdiagplot'><p>Print a &quot;tsdiagplot&quot; object.</p></a></li>
<li><a href='#print.TwoTrellisColumns'><p>Print two conformable trellis plots in adjacent columns with user</p>
control of widths.</a></li>
<li><a href='#push.vp.hh'><p>push and pop a grid viewport, turn clipping off, change scale.</p></a></li>
<li><a href='#pyramidLikert'><p>Print a Likert plot as a Population Triangle</p></a></li>
<li><a href='#rbind.trellis'>
<p>Extend matrix reshaping functions to trellis objects.</p></a></li>
<li><a href='#regr1.plot'><p>plot x and y,</p>
with optional straight line fit and display of squared residuals</a></li>
<li><a href='#regr2.plot'><p>3D plot of z against x and y,</p>
with regression plane fit and display of squared residuals.</a></li>
<li><a href='#regrresidplot'>
<p>Draw a plot of y vs x from a linear model object, with residuals</p>
indicated by lines or squares.</a></li>
<li><a href='#resid.squares'><p>plot squared residuals in inches to match the y-dimension</p></a></li>
<li><a href='#residual.plots'><p>Residual plots for a linear model.</p></a></li>
<li><a href='#residual.plots.lattice'>
<p>Construct four sets of regression plots: Y against X, residuals</p>
against X, partial residuals against X, partial residuals against each
X adjusted for all the other X columns.
</p></a></li>
<li><a href='#residVSfitted'>
<p>Draw plots of resid ~ y.hat and sqrt(abs(resid)) ~ y.hat</p></a></li>
<li><a href='#ResizeEtc'><p>Display multiple independent trellis objects on the same</p>
coordinated scale.</a></li>
<li><a href='#ResizeEtc.likertPlot'><p>Display multiple independent trellis objects, representing</p>
likert plots, on the same coordinated scale.</a></li>
<li><a href='#rowPcts'>
<p>Row and columns percents</p></a></li>
<li><a href='#seqplot'><p>Time series plot.</p></a></li>
<li><a href='#seqplotForecast'><p>seqplot with confidence bands for the forecast region.</p></a></li>
<li><a href='#strip.background0'><p> Turn off the coloring in the trellis strip labels.  Color 0 is the</p>
background color.</a></li>
<li><a href='#strip.useOuterStrips.first'>
<p>Functions based on strip.default for use with the useOuterScales function.</p></a></li>
<li><a href='#strip.xysplom'><p>strip function that is able to place the correlation or regression</p>
coefficient into the strip label.</a></li>
<li><a href='#sufficient'><p> Calculates the mean, standard deviation, and number of</p>
observations in each group of a data.frame that has one continuous
variable and two factors.</a></li>
<li><a href='#summary.arma.loop'><p>summary and print and subscript methods for tsdiagplot and related objects.</p></a></li>
<li><a href='#ToBW.likert'>
<p>Change colors in a likert plot to shades of Black and White.</p></a></li>
<li><a href='#toCQxR'>
<p>Reshape a 3-way array to a 2-way data.frame that can can be used with a</p>
trellis conditioning formula to get the three-way behavior.
Used with likertWeighted().</a></li>
<li><a href='#tsacfplots'><p>Coordinated time series and ACF and PCF plots.</p></a></li>
<li><a href='#tsdiagplot'><p>Times series diagnostic plots for a structured set of</p>
ARIMA models.</a></li>
<li><a href='#useOuterScales'><p> Put scales for axes only on the bottom and left panels of a</p>
lattice display, and give fine control over the placement of strips</a></li>
<li><a href='#useOuterStripsT2L1'><p>Three-factor generalization of latticeExtra::useOuterStrips</p></a></li>
<li><a href='#vif'><p> Calculate the Variance Inflation Factor</p></a></li>
<li><a href='#X.residuals'><p> Residuals from the regression of each column of a</p>
data.frame against all the other columns.</a></li>
<li><a href='#xysplom'><p>scatterplot matrix with potentially different sets of variables</p>
on the rows and columns.</a></li>
<li><a href='#z.test'><p> Z test for known population standard deviation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Analysis and Data Display: Heiberger and Holland</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1-52</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Richard M. Heiberger</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Richard M. Heiberger &lt;rmh@temple.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2), lattice, stats, grid, latticeExtra, multcomp,
gridExtra (&ge; 2.0.0), graphics</td>
</tr>
<tr>
<td>Imports:</td>
<td>reshape2, leaps, vcd, colorspace, RColorBrewer, shiny (&ge;
0.13.1), Hmisc, abind, Rmpfr (&ge; 0.6.0), grDevices, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mvtnorm, car, Rcmdr, RcmdrPlugin.HH, microplot</td>
</tr>
<tr>
<td>Description:</td>
<td>Support software for Statistical Analysis and Data Display (Second Edition, Springer, ISBN 978-1-4939-2121-8, 2015) and (First Edition, Springer, ISBN 0-387-40270-5, 2004) by Richard M. Heiberger and Burt Holland.  This contemporary presentation of statistical methods features extensive use of graphical displays for exploring data and for displaying the analysis.  The second edition includes redesigned graphics and additional chapters. The authors emphasize how to construct and interpret graphs, discuss principles of graphical design, and show how accompanying traditional tabular results are used to confirm the visual impressions derived directly from the graphs. Many of the graphical formats are novel and appear here for the first time in print.  All chapters have exercises.  All functions introduced in the book are in the package.  R code for all examples, both graphs and tables, in the book is included in the scripts directory of the package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-10 20:07:55 UTC; rmh</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-11 00:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='HH-package'>
Statistical Analysis and Data Display: Heiberger and Holland
</h2><span id='topic+HH-package'></span><span id='topic+HH'></span>

<h3>Description</h3>

<p>Support software for Statistical Analysis and Data Display (Second Edition, Springer, ISBN 978-1-4939-2121-8, 2015) and (First Edition, Springer, ISBN 0-387-40270-5, 2004) by Richard M. Heiberger and Burt Holland.  This contemporary presentation of statistical methods features extensive use of graphical displays for exploring data and for displaying the analysis.  The second edition includes redesigned graphics and additional chapters. The authors emphasize how to construct and interpret graphs, discuss principles of graphical design, and show how accompanying traditional tabular results are used to confirm the visual impressions derived directly from the graphs. Many of the graphical formats are novel and appear here for the first time in print.  All chapters have exercises.  All functions introduced in the book are in the package.  R code for all examples, both graphs and tables, in the book is included in the scripts directory of the package.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> HH</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Statistical Analysis and Data Display: Heiberger and Holland</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 3.1-52</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-02-10</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Richard M. Heiberger</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Richard M. Heiberger &lt;rmh@temple.edu&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.0.2), lattice, stats, grid, latticeExtra, multcomp, gridExtra (&gt;= 2.0.0), graphics</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> reshape2, leaps, vcd, colorspace, RColorBrewer, shiny (&gt;= 0.13.1), Hmisc, abind, Rmpfr (&gt;= 0.6.0), grDevices, methods</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> mvtnorm, car, Rcmdr, RcmdrPlugin.HH, microplot</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Support software for Statistical Analysis and Data Display (Second Edition, Springer, ISBN 978-1-4939-2121-8, 2015) and (First Edition, Springer, ISBN 0-387-40270-5, 2004) by Richard M. Heiberger and Burt Holland.  This contemporary presentation of statistical methods features extensive use of graphical displays for exploring data and for displaying the analysis.  The second edition includes redesigned graphics and additional chapters. The authors emphasize how to construct and interpret graphs, discuss principles of graphical design, and show how accompanying traditional tabular results are used to confirm the visual impressions derived directly from the graphs. Many of the graphical formats are novel and appear here for the first time in print.  All chapters have exercises.  All functions introduced in the book are in the package.  R code for all examples, both graphs and tables, in the book is included in the scripts directory of the package.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
AEdotplot               AE (Adverse Events) dotplot of incidence and
                        relative risk
AEdotplot.data.frame    AE (Adverse Events) dotplot of incidence and
                        relative risk, support functions
CIplot                  Illustration of the meaning of confidence
                        levels.
Discrete4               Discrete with four levels color dataset.
EmphasizeVerticalPanels
                        Helper function for likertWeighted(). used for
                        vertical spacing and horizontal borders of
                        grouped panels.
F.curve                 plot a chisquare or a F-curve.
GSremove                Remove selected GraphSheetPages in the S-Plus
                        Windows GUI Graphsheet
HH-package              Statistical Analysis and Data Display:
                        Heiberger and Holland
HH.regsubsets           Display tabular results for Best Subsets
                        Regression.
HHscriptnames           Find absolute pathname of a script file for the
                        HH book in the HH package.
InsertVerticalPanels    Expand a 3D array on the second dimension,
                        inserting empty layers where the input vector
                        has a '0' value.  A 2D argument 'x' with
                        'dim(x)==c(r,c)' is first extended to 3D with
                        'dim(x)==c(1,r,c)', and then the result is
                        collapsed back to 2D.
LikertPercentCountColumns
                        Display likert plots with percents in the first
                        column of panels and counts in the second
                        column of panels.
NTplot                  Specify plots to illustrate Normal and t
                        Hypothesis Tests or Confidence Intervals,
                        including normal approximation to the binomial.
NormalAndTPower         Construct a power graph based on the NTplot.
NormalAndTplot          Specify plots to illustrate Normal and t
                        Hypothesis Tests or Confidence Intervals.
OddsRatio               Calculate or plot the odds ratio for a 2x2
                        table of counts.
OneWayVarPlot           Displays a three-panel 'bwplot' of the data by
                        group, of the group means, and of the entire
                        dataset.  This is an approximate visualization
                        of the Mean Square lines from the ANOVA table
                        for a one-way ANOVA model.
ResizeEtc               Display multiple independent trellis objects on
                        the same coordinated scale.
ResizeEtc.likertPlot    Display multiple independent trellis objects,
                        representing likert plots, on the same
                        coordinated scale.
ToBW.likert             Change colors in a likert plot to shades of
                        Black and White.
X.residuals             Residuals from the regression of each column of
                        a data.frame against all the other columns.
ae.dotplot              AE (Adverse Events) dotplot of incidence and
                        relative risk
ancova                  Compute and plot oneway analysis of covariance
ancova-class            Class "ancova" Analysis of Covariance
ancovaplot              Analysis of Covariance Plots
anova.ancovaplot        ANOVA table for a c("ancovaplot","trellis")
                        object.
anovaMean               ANOVA table from the group sample sizes, means,
                        and standard deviations.
aovSufficient           Analysis of variance from sufficient statistics
                        for groups.
arima.diag.hh           Repair design error in S-Plus arima.diag
arma.loop               Loop through a series of ARIMA models and
                        display coordinated tables and diagnoastic
                        graphs.
as.likert               Support functions for diverging stacked
                        barcharts for Likert, semantic differential,
                        and rating scale data.
as.matrix.listOfNamedMatrices
                        Convert a list of numeric matrices to a single
                        matrix
as.multicomp            Support functions in R for MMC (mean-mean
                        multiple comparisons) plots.
as.rts                  Miscellaneous functions that I wish were in or
                        consistent between S-Plus and R.
as.vector.trellis       Convert a two-dimensional trellis object into a
                        one-dimensional trellis object. Change the
                        order of panels in a trellis object.
axis.i2wt               specialized axis function for interaction2wt.
bivariateNormal         Plot the bivariate normal density using
                        wireframe for specified rho.
case                    case statistics for regression analysis
ci.plot                 Plot confidence and prediction intervals for
                        simple linear regression
col.hh                  Initializing Trellis Displays
col3x2                  col3x2 color dataset
combineLimits.trellisvector
                        Combine limits on a one-dimensional trellis
                        object.
cp.calc                 Rearranges and improves the legibility of the
                        output from the stepwise function in S-Plus.
cplx                    Generate a sequence spanning the xlim of a
                        lattice window.
datasets                Datasets for Statistical Analysis and Data
                        Display, Heiberger and Holland
dchisq.intermediate     Intermediate f and chisq functions to simplify
                        writing for both R and S-Plus.
diag.maybe.null         Returns a value for the diagonal of NA and NULL
                        arguments.
diagQQ                  QQ plot of regression residuals.
diagplot5new            Transpose of ECDF for centered fitted values
                        and residuals from a linear model.
do.formula.trellis.xysplom
                        Interprets model formulas for xysplom and
                        extended bwplots
emptyMainLeftAxisLeftStripBottomLegend
                        Remove main title, left axis tick labels, left
                        strip, bottom legend from plot and keep the
                        vertical spacing allocated to those items.
export.eps              Exports a graph to an EPS file.
glhtWithMCP.993         Retain averaging behavior that was previously
                        available in glht.
gof.calculation         Calculate Box-Ljung Goodness of Fit for ARIMA
                        models in S-Plus.
grid.yaxis.hh           make x- and y-axis labels
hhpdf                   R tools for writing HH2: hhpdf, hhdev.off,
                        hhcapture, hhcode, hhpng, hhlatex
hov                     Homogeneity of Variance
hovBF                   Homogeneity of Variance: Brown-Forsyth method
hovPlot                 Homogeneity of Variance Plot
if.R                    Conditional Execution for R or S-Plus
interaction.positioned
                        interaction method for positioned factors.
interaction2wt          Plot all main effects and twoway interactions
                        in a multifactor design
interval                Prediction and Confidence Intervals for glm
                        Objects
intxplot                Interaction plot, with an option to print
                        standard error bars.
ladder                  Draw a "ladder of powers" plot, plotting each
                        of several powers of y against the same powers
                        of x.
latex.array             Generate the latex code for an '"array"' or
                        '"table"' with 3, 4, or more dimensions.
latticeresids           Subroutine used by residual.plots.lattice
legendGrob2wt           place separate keys to the left of each row of
                        a trellis
likert                  Diverging stacked barcharts for Likert,
                        semantic differential, rating scale data, and
                        population pyramids.
likertColor             Selection of colors for Likert plots.
likertMosaic            Diverging stacked barcharts for Likert,
                        semantic differential, rating scale data, and
                        population pyramids based on mosaic as the
                        plotting style.
likertWeighted          Special case wrapper for likert() when multiple
                        columns are to have the same bar thicknesses.
                        Uses formula with one or two conditioning
                        variables.
lm.regsubsets           Evaluate lm model with highest adjusted $R^2$.
lmatPairwise            lmatPairwise
lmatRows                Find the row numbers in the lmat corresponding
                        to the focus factor.
lmplot                  Four types of residual plots for linear models.
logit                   Logistic and odds functions and their inverses.
matrix.trellis          Convert a one-dimensional trellis object to a
                        two-dimensional trellis object. This permits
                        combineLimits and useOuterStrips to work.
mcalinfct               MCA multiple comparisons analysis (pairwise)
mmc                     MMC (Mean-mean Multiple Comparisons) plots.
mmc.mean                MMC (Mean-mean Multiple Comparisons) plots from
                        the sufficient statistics for a one-way design.
mmcAspect               Control aspect ratio in MMC plots to maintain
                        isomeans grid as a square.
mmcPruneIsomeans        MMC plots in lattice-suppress isomeans grid
                        lines for specified levels of the factor.
mmcisomeans             Functions used by mmcplot.
mmcplot                 MMC (Mean-mean Multiple Comparisons) plots in
                        lattice.
multicomp.order         Update a multicomp object by ordering its
                        contrasts.
multicomp.reverse       Force all comparisons in a "multicomp" object
                        to have the same sign.
norm.curve              plot a normal or a t-curve with both x and z
                        axes.
normalApproxBinomial    Plots to illustrate Normal Approximation to the
                        Binomial-hypothesis tests or confidence
                        intervals.
npar.arma               Count the number of parameters in an ARIMA
                        model specification.
objip                   loop through all attached directories looking
                        for pattern, possibly restricting to specified
                        class or mode.
orthog.complete         Construct an orthogonal matrix which is an
                        arbitrary completion of the column space of the
                        input set of columns.
panel.acf               Panel functions for tsdiagplot.
panel.axis.right        Right-justify right-axis tick labels.
panel.bwplot.intermediate.hh
                        Panel functions for bwplot.
panel.bwplot.superpose
                        Panel function for bwplot that displays an
                        entire box in the colors coded by groups.
panel.bwplott           Extension to S-Plus trellis to allow transposed
                        plots.
panel.cartesian         trellis panel function, with labeled rows and
                        columns and without strip labels.
panel.ci.plot           Default Panel Function for ci.plot
panel.confintMMC        Confidence interval panel for MMC tiebreaker
                        plots, or confidence interval plot.
panel.dotplot.tb        Dotplot with evenly spaced tiebreakers.
panel.interaction2wt    Plot all main effects and twoway interactions
                        in a multifactor design
panel.isomeans          isomeans grid for MMC plots.
panel.likert            Panel functions for likert that include a
                        stackWidth argument
panel.pairs.hh          Function based on S-Plus panel.pairs to add the
                        subpanel.scales and panel.cex arguments.
panel.xysplom           panel method for xysplom.
partial.corr            partial correlations
pdf.latex               Construct a pdf file from a "latex" file.  See
                        Hmisc::latex for concepts.
pdiscunif               Discrete Uniform Distribution
perspPlane              Helper functions for regr2.plot
plot.mmc.multicomp      MMC (Mean-mean Multiple Comparisons) plot.
plot.multicomp          Multiple comparisons plot that gives
                        independent user control over the appearance of
                        the significant and not significant
                        comparisons.
position                Find or assign the implied position for
                        graphing the levels of a factor.  A new class
                        "positioned", which inherits from "ordered" and
                        "factor", is defined.
positioned-class        Class "positioned", extends "ordered" to
                        specify the position for graphing the levels of
                        a factor.
print.NormalAndTplot    Print method for Normal and t plots from
                        NTplot.
print.TwoTrellisColumns5
                        Print two conformable trellis plots in adjacent
                        columns with user control of widths.
print.latticeresids     Print a 'latticeresids' object.
print.tsdiagplot        Print a "tsdiagplot" object.
push.vp.hh              push and pop a grid viewport, turn clipping
                        off, change scale.
pyramidLikert           Print a Likert plot as a Population Triangle
rbind.trellis           Extend matrix reshaping functions to trellis
                        objects.
regr1.plot              plot x and y, with optional straight line fit
                        and display of squared residuals
regr2.plot              3D plot of z against x and y, with regression
                        plane fit and display of squared residuals.
regrresidplot           Draw a plot of y vs x from a linear model
                        object, with residuals indicated by lines or
                        squares.
resid.squares           plot squared residuals in inches to match the
                        y-dimension
residVSfitted           Draw plots of resid ~ y.hat and
                        sqrt(abs(resid)) ~ y.hat
residual.plots          Residual plots for a linear model.
residual.plots.lattice
                        Construct four sets of regression plots: Y
                        against X, residuals against X, partial
                        residuals against X, partial residuals against
                        each X adjusted for all the other X columns.
rowPcts                 Row and columns percents
seqplot                 Time series plot.
seqplotForecast         seqplot with confidence bands for the forecast
                        region.
strip.background0       Turn off the coloring in the trellis strip
                        labels.  Color 0 is the background color.
strip.useOuterStrips.first
                        Functions based on strip.default for use with
                        the useOuterScales function.
strip.xysplom           strip function that is able to place the
                        correlation or regression coefficient into the
                        strip label.
sufficient              Calculates the mean, standard deviation, and
                        number of observations in each group of a
                        data.frame that has one continuous variable and
                        two factors.
summary.arma.loop       summary and print and subscript methods for
                        tsdiagplot and related objects.
toCQxR                  Reshape a 3-way array to a 2-way data.frame
                        that can can be used with a trellis
                        conditioning formula to get the three-way
                        behavior. Used with likertWeighted().
tsacfplots              Coordinated time series and ACF and PCF plots.
tsdiagplot              Times series diagnostic plots for a structured
                        set of ARIMA models.
useOuterScales          Put scales for axes only on the bottom and left
                        panels of a lattice display, and give fine
                        control over the placement of strips
useOuterStripsT2L1      Three-factor generalization of
                        latticeExtra::useOuterStrips
vif                     Calculate the Variance Inflation Factor
xysplom                 scatterplot matrix with potentially different
                        sets of variables on the rows and columns.
z.test                  Z test for known population standard deviation
</pre>
<p>data display, scatterplot matrix, (MMC Mean&ndash;mean Multiple Comparison)
plots, interaction plots, ANCOVA plots, regression diagnostics, time
series, ARIMA models, boxplots
</p>


<h3>Author(s)</h3>

<p>Richard M. Heiberger
</p>
<p>Maintainer: Richard M. Heiberger &lt;rmh@temple.edu&gt;
</p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>
<p>Heiberger, Richard M. and Holland, Burt (2004).
<em>Statistical Analysis and Data Display: An Intermediate Course
with Examples in S-Plus, R, and SAS</em>, First Edition.
Springer Texts in Statistics. Springer.
<a href="https://link.springer.com/book/10.1007/978-1-4757-4284-8">https://link.springer.com/book/10.1007/978-1-4757-4284-8</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ancovaplot">ancovaplot</a></code>,
<code><a href="#topic+ci.plot">ci.plot</a></code>,
<code><a href="#topic+interaction2wt">interaction2wt</a></code>,
<code><a href="#topic+ladder">ladder</a></code>,
<code><a href="#topic+case.lm">case.lm</a></code>,
<code><a href="#topic+NTplot">NTplot</a></code> for Normal and <code class="reqn">t</code> plots,
<code><a href="#topic+hov">hov</a></code>,
<code><a href="#topic+resid.squares">resid.squares</a></code>,
<code><a href="#topic+MMC">MMC</a></code>,

<code><a href="#topic+AEdotplot">AEdotplot</a></code>,
<code><a href="#topic+likert">likert</a></code>,
<code><a href="#topic+tsacfplots">tsacfplots</a></code>,
<code><a href="#topic+tsdiagplot">tsdiagplot</a></code>
</p>
<p><code>demo(package="HH")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## In addition to the examples for each function,
## there are seven interactive shiny apps in the HH package:
## Not run: 
if (interactive())   NTplot(mean0=0, mean1=1, shiny=TRUE)
if (interactive())   shiny::runApp(system.file("shiny/bivariateNormal", package="HH"))
if (interactive())   shiny::runApp(system.file("shiny/bivariateNormalScatterplot", package="HH"))
if (interactive())   shiny::runApp(system.file("shiny/PopulationPyramid", package="HH"))
if (interactive())   shiny.CIplot(height = "auto")
if (interactive())   shiny::runApp(system.file("shiny/AEdotplot", package="HH"))
if (interactive())   shiny::runApp(system.file("shiny/likert", package="HH"))

## End(Not run)
</code></pre>

<hr>
<h2 id='ae.dotplot'> AE (Adverse Events) dotplot of incidence and relative risk </h2><span id='topic+ae.dotplot'></span><span id='topic+AE.dotplot'></span><span id='topic+ae.dotplot.long'></span><span id='topic+aeReshapeToLong'></span><span id='topic+panel.ae.leftplot'></span><span id='topic+panel.ae.rightplot'></span><span id='topic+panel.ae.dotplot'></span><span id='topic+logrelrisk'></span>

<h3>Description</h3>

<p>A two-panel display of the most
frequently occurring AEs in the active arm of a clinical
study. The first panel displays their incidence by
treatment group, with different symbols for each
group. The second panel displays the relative risk
of an event on the active arm relative to the
placebo arm, with 95% confidence intervals for a <code class="reqn">2\times2</code> table.
By default, the AEs are ordered by
relative risk so that events with the largest
increases in risk for the active treatment are
prominent at the top of the display.  See the Details section for
information
on changing the sort order.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ae.dotplot(ae, ...)

ae.dotplot.long(xr,
                A.name = levels(xr$RAND)[1], B.name = levels(xr$RAND)[2],
                col.AB = c("red","blue"), pch.AB = c(16, 17),
                main.title = paste("Most Frequent On-Therapy Adverse Events",
                                   "Sorted by Relative Risk"),
                main.cex = 1,
                cex.AB.points = NULL, cex.AB.y.scale = 0.6,
                position.left = c(0, 0, 0.7, 1), position.right = c(0.61, 0, 0.98, 1),
                key.y = -0.2, CI.percent=95)

logrelrisk(ae, A.name, B.name, crit.value=1.96)

panel.ae.leftplot(x, y, groups, col.AB, ...)

panel.ae.rightplot(x, y, ..., lwd=6, lower, upper, cex=.7)

panel.ae.dotplot(x, y, groups, ..., col.AB, pch.AB, lower, upper) ## R only

aeReshapeToLong(aewide)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ae.dotplot_+3A_ae">ae</code></td>
<td>
<p>For <code>ae.dotplot</code>, either a data.frame containing the Adverse
Event data in long format as described by the detail for <code>xr</code>
below, or a data.frame containing the Adverse event data in wide format as
described by the detail for <code>aewide</code> below.
For <code>logrelrisk</code>, a data.frame containing the first 4 columns of <code>xr</code>
described below.
</p>
</td></tr>
<tr><td><code id="ae.dotplot_+3A_...">...</code></td>
<td>
<p>For <code>ae.dotplot</code>, all the arguments listed in the
calling sequence for <code>ae.ddotplot.long</code> and possibly standard panel
function arguments.
</p>
<p>For the other functions, just standard panel function arguments.
</p>
</td></tr>
<tr><td><code id="ae.dotplot_+3A_xr">xr</code></td>
<td>

<ul>
<li><p><code>RAND</code>:   treatment as randomized (factor).
</p>
</li>
<li><p><code>PREF</code>:   adverse event symptom name (factor).
</p>
</li>
<li><p><code>SN</code>:     number of patients in treatment group.
</p>
</li>
<li><p><code>SAE</code>:    number of patients  in each group for whom the event PREF was observed.
</p>
</li>
<li><p><code>PCT</code>: <code>SAE</code>/<code>SN</code> as a percent.
</p>
</li>
<li><p><code>relrisk</code>: Relative risk defined as <code>PCT</code> for the B
treatment divided by <code>PCT</code> for the A treatment.
</p>
</li>
<li><p><code>logrelrisk</code>: natural logarithm of <code>relrisk</code>.
</p>
</li>
<li><p><code>ase.logrelrisk</code>: asymptotic standard error of <code>logrelrisk</code>.
</p>
</li>
<li><p><code>logrelriskCI.lower, logrelriskCI.upper</code>: confidence interval for
</p>
</li>
<li><p><code>logrelrisk</code>.
</p>
</li>
<li><p><code>relriskCI.lower, relriskCI.upper</code>: back transform of the CI for
the log relative risk into the relative risk scale.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ae.dotplot_+3A_aewide">aewide</code></td>
<td>

<ul>
<li><p><code>Event</code>: adverse event symptom name (factor).
</p>
</li>
<li><p><code>N.A, N.B</code>: number of patients in treatment groups A and B.
</p>
</li>
<li><p><code>AE.A, AE.B</code>: number of patients in treatment groups A and B for
whom the event Event was observed.
</p>
</li>
<li><p><code>PCT.A, PCT.B</code>: <code>AE.A</code>/<code>N.A</code> and  <code>AE.B</code>/<code>N.B</code> as a percent.
</p>
</li>
<li><p><code>Relative.Risk</code>: Relative risk defined as <code>PCT.B</code>
divided by <code>PCT.A</code>.
</p>
</li>
<li><p><code>logrelrisk</code>: natural logarithm of <code>relrisk</code>.
</p>
</li>
<li><p><code>ase.logrelrisk</code>: asymptotic standard error of <code>logrelrisk</code>.
</p>
</li>
<li><p><code>logrelriskCI.lower, logrelriskCI.upper</code>: confidence interval for
</p>
</li>
<li><p><code>logrelrisk</code>.
</p>
</li>
<li><p><code>relriskCI.lower, relriskCI.upper</code>: back transform of the CI for
the log relative risk into the relative risk scale.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ae.dotplot_+3A_a.name">A.name</code>, <code id="ae.dotplot_+3A_b.name">B.name</code></td>
<td>
<p>Names of treatment groups (in <code>x$RAND</code>).</p>
</td></tr>
<tr><td><code id="ae.dotplot_+3A_col.ab">col.AB</code>, <code id="ae.dotplot_+3A_pch.ab">pch.AB</code>, <code id="ae.dotplot_+3A_cex.ab.points">cex.AB.points</code></td>
<td>
<p>color, plotting character and
character expansion for the individual points on the left plot.</p>
</td></tr>
<tr><td><code id="ae.dotplot_+3A_cex.ab.y.scale">cex.AB.y.scale</code></td>
<td>
<p>Character expansion for the left tick labels
(the symptom names). </p>
</td></tr>
<tr><td><code id="ae.dotplot_+3A_main.title">main.title</code>, <code id="ae.dotplot_+3A_main.cex">main.cex</code></td>
<td>
<p>Main title and character expansion for the
combined plot in <code>ae.dotplot</code>.</p>
</td></tr>
<tr><td><code id="ae.dotplot_+3A_cex">cex</code></td>
<td>
<p>The character expansion for the points in the left and
right plots.</p>
</td></tr>
<tr><td><code id="ae.dotplot_+3A_position.left">position.left</code>, <code id="ae.dotplot_+3A_position.right">position.right</code></td>
<td>
<p><code>position</code> of the left and
right plots.  This argument is use in S-Plus only, not in R.
See the discussion of <code>position</code> in
<code><a href="lattice.html#topic+print.trellis">print.trellis</a></code>,
</p>
</td></tr>
<tr><td><code id="ae.dotplot_+3A_key.y">key.y</code></td>
<td>
<p>Position of the key (legend) in the combined plot.  This
is the <code>y</code> argument of the <code>key</code>.
See the discussion of the <code>key</code> argument to <code>xyplot</code> in
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="ae.dotplot_+3A_crit.value">crit.value</code></td>
<td>
<p>Critical value used to compute confidence intervals
on the log relative risk.  Defaults to 1.96.  User is responsible
for specifying both <code>crit.value</code> and <code>CI.percent</code>
consistently.</p>
</td></tr>
<tr><td><code id="ae.dotplot_+3A_ci.percent">CI.percent</code></td>
<td>
<p>Confidence percent associated with the
<code>crit.value</code> Defaults to 95.  User is responsible for
specifying both <code>crit.value</code> and <code>CI.percent</code>
consistently.</p>
</td></tr>
<tr><td><code id="ae.dotplot_+3A_x">x</code>, <code id="ae.dotplot_+3A_y">y</code>, <code id="ae.dotplot_+3A_groups">groups</code>, <code id="ae.dotplot_+3A_lwd">lwd</code></td>
<td>
<p>standard panel function arguments.</p>
</td></tr>
<tr><td><code id="ae.dotplot_+3A_lower">lower</code>, <code id="ae.dotplot_+3A_upper">upper</code></td>
<td>
<p><code>xr$logrelriskCI.lower</code> and
<code>xr$logrelriskCI.upper</code> inside the panel functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The second panel shows relative risk of an event on the active arm
(treatment B)
relative to the placebo arm (treatment A), with 95% confidence
intervals for a <code class="reqn">2\times2</code> table.  Confidence intervals on the log
relative risk are calculated using the asymptotic standard error
formula given as Equation 3.18 in Agresti A., Categorical Data
Analysis. Wiley: New York, 1990.
</p>
<p>By default the <code>ae.dotplot</code> function sorts the events by relative risk.
To change the sort order, you must redefine the ordering of the
ordered factor <code>PREF</code>.  See the examples below.
</p>


<h3>Value</h3>

<p><code>logrelrisk</code> takes an input data.frame of the form <code>x</code>
described in the argument list and returns a data.frame consisting of
the input argument with additional columns as described in the
argument <code>xr</code>.  The result column of symptom names <code>PREF</code> is
an ordered factor, with the order specified by the relative risk.
</p>
<p><code>ae.leftplot</code> returns a <code>"trellis"</code> object containing a
horizontal dotplot of the percents against each of the symptom names.
</p>
<p><code>ae.rightplot</code> returns a <code>"trellis"</code> object containing a
horizontal plot on the log scale of the relative risk confidence
intervals against each of the symptom names.
</p>
<p><code>ae.dotplot</code> calls both <code>ae.leftplot</code> and <code>ae.rightplot</code>
and combines their plots into a single display with a single set of
left axis labels, a main title, and a key.  The value returned
invisibly is a list of the full left trellis object and the right
trellis object with its left labels blanked out.  Printing the value
will not usually be interesting as the main title and key are not
included.
It is better to call <code>ae.dotplot</code> directly, perhaps with a change
in some of the positioning arguments.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Ohad Amit, Richard M. Heiberger, and Peter W. Lane. (2008)
&ldquo;Graphical Approaches to the Analysis of Safety Data from Clinical Trials&rdquo;.
<em>Pharmaceutical Statistics</em>,
<b>7</b>, 1, 20&ndash;35.
<a href="https://onlinelibrary.wiley.com/doi/10.1002/pst.254">https://onlinelibrary.wiley.com/doi/10.1002/pst.254</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AEdotplot">AEdotplot</a></code> for a three-panel version that also has
an associated shiny app.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## variable names in the input data.frame aeanonym
## RAND   treatment as randomized
## PREF   adverse event symptom name
## SN     number of patients in treatment group
## SAE    number of patients  in each group for whom the event PREF was observed
##
## Input sort order is PREF/RAND

data(aeanonym)
head(aeanonym)

## Calculate log relative risk and confidence intervals (95% by default).
## logrelrisk sets the sort order for PREF to match the relative risk.
aeanonymr &lt;- logrelrisk(aeanonym) ## sorts by relative risk
head(aeanonymr)

## construct and print plot on current graphics device
ae.dotplot(aeanonymr,
           A.name="TREATMENT A (N=216)",
           B.name="TREATMENT B (N=431)")
## export.eps(h2("stdt/figure/aerelrisk.eps"))
## This looks great on screen and exports badly to eps.
## We recommend drawing this plot directly to the postscript device:
##
## trellis.device(postscript, color=TRUE, horizontal=TRUE,
##                colors=ps.colors.rgb[
##                  c("black", "blue", "red", "green",
##                    "yellow", "cyan","magenta","brown"),],
##                onefile=FALSE, print.it=FALSE,
##                file=h2("stdt/figure/aerelrisk.ps"))
## ae.dotplot(aeanonymr,
##            A.name="TREATMENT A (N=216)",
##            B.name="TREATMENT B (N=431)")
## dev.off()

## To change the sort order, redefine the PREF factor.
## For this example, to plot alphabetically, use the statement
aeanonymr$PREF &lt;- ordered(aeanonymr$PREF, levels=sort(levels(aeanonymr$PREF)))
ae.dotplot(aeanonymr,
           A.name="TREATMENT A (N=216)",
           B.name="TREATMENT B (N=431)",
           main.title="change the main title to reflect the new sort order")

## Not run: 
## to restore the order back to the default, use
relrisk &lt;- aeanonymr[seq(1, nrow(aeanonymr), 2), "relrisk"]
PREF &lt;- unique(aeanonymr$PREF)
aeanonymr$PREF &lt;- ordered(aeanonymr$PREF, levels=PREF[order(relrisk)])
ae.dotplot(aeanonymr,
           A.name="TREATMENT A (N=216)",
           B.name="TREATMENT B (N=431)",
           main.title="back to the original sort order")

## smaller artifical example with the wide format
aewide &lt;- data.frame(Event=letters[1:6],
                     N.A=c(50,50,50,50,50,50),
                     N.B=c(90,90,90,90,90,90),
                     AE.A=2*(1:6),
                     AE.B=1:6)
aewtol &lt;- aeReshapeToLong(aewide)
xr &lt;- logrelrisk(aewtol)
ae.dotplot(xr)

## End(Not run)
</code></pre>

<hr>
<h2 id='AEdotplot'> AE (Adverse Events) dotplot of incidence and relative risk </h2><span id='topic+AEdotplot'></span><span id='topic+AEdotplot.formula'></span>

<h3>Description</h3>

<p>A three-panel display of the most
frequently occurring AEs in the active arm of a clinical
study. The first panel displays their incidence by
treatment group, with different symbols for each
group. The second panel displays the relative risk
of an event on the active arm relative to the
placebo arm, with 95% confidence intervals for a <code class="reqn">2\times2</code> table.
By default, the AEs are ordered by
relative risk so that events with the largest
increases in risk for the active treatment are
prominent at the top of the display.
By setting the argument <code>sortbyRelativeRisk=FALSE</code>, the AEs retain
the order specified by the levels of the factor.
The third panel displays the numerical values of number of patients for
each treatment,
number of adverse events for each treatment, and relative risk.
The third panel can be suppressed by the <code>print</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  AEdotplot(xr, ...)

  ## S3 method for class 'formula'
AEdotplot(xr, groups=NULL, data=NULL,
          sortbyRelativeRisk=TRUE,
          ...,
          sub=list(deparse(this.call[1:4],
                                width.cutoff=500), cex=.7))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AEdotplot_+3A_xr">xr</code></td>
<td>
<p>For the formula method, a formula of the form
<code>AE ~ nAE/nTRT | OrgSys</code>, where the condition variable is
optional.
For the formula method only, the variable names are not restricted.
See <code><a href="#topic+AEdotplot.data.frame">AEdotplot.data.frame</a></code> for the support methods.
</p>
</td></tr>
<tr><td><code id="AEdotplot_+3A_groups">groups</code></td>
<td>
<p>Variable containing the treatment levels.</p>
</td></tr>
<tr><td><code id="AEdotplot_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing at least four variables:
containing the AE name as a factor, the treatment level as a factor, the number of observed
AE in that treatment level, the number of
patients in that treatment group. It may also contain a fifth variable
containing a condition variable used to
split the <code>data.frame</code> into partitions.
It may be used to partition the plot,
for example by organ system or by gender.
The treatment factor must have exactly two levels.
Each AE name must appear exactly once for each level of the treatment.</p>
</td></tr>
<tr><td><code id="AEdotplot_+3A_sortbyrelativerisk">sortbyRelativeRisk</code></td>
<td>
<p>logical.  If <code>TRUE</code>, then make the
Adverse Events an ordered factor ordering by relative risk.
If <code>FALSE</code>, then make the
Adverse Events an ordered factor retaining the order of the input levels.</p>
</td></tr>
<tr><td><code id="AEdotplot_+3A_sub">sub</code></td>
<td>
<p>Subtitle for the plot.  The default value is the command
that generates the plot.</p>
</td></tr>
<tr><td><code id="AEdotplot_+3A_...">...</code></td>
<td>
<p>Any of the arguments (such as the sorting options) listed in the
calling sequence for the methods documented in
<code><a href="#topic+AEdotplot.data.frame">AEdotplot.data.frame</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first panel is an ordinary dotplot of the percent of AE observed for each
treatment by AE.
</p>
<p>The second panel shows relative risk of an event on the Treatment B arm
(usually the active compound)
relative to the Treatment A arm (usually the placebo), with 95% confidence
intervals for a <code class="reqn">2\times2</code> table.  Confidence intervals on the log
relative risk are calculated using the asymptotic standard error
formula given as Equation 3.18 in Agresti A., <em>Categorical Data
Analysis.</em> Wiley: New York, 1990.
</p>
<p>By default the <code>AEdotplot</code> function sorts the events by relative risk.
To retain the sort order implied by the <code>levels</code> of the AE
factor, specify the argument <code>sortbyRelativeRisk=FALSE</code>.
To control the sort order, make the AE factor in the input dataset
an <code>ordered</code> factor
and specify the levels in the order you want.
</p>
<p>The third panel shows the numerical values of the number and percent
of observed events on each arm and the relative risk.
The display of third panel can be suppressed by specifying the
<code>panel.widths</code> argument.  See the discussion of the
<code>panel.widths</code> in <code><a href="#topic+AEdotplot.data.frame">AEdotplot.data.frame</a></code>.
</p>


<h3>Value</h3>

<p>The primary interest is in the display of the plot.
</p>
<p>The function returns
an <code>AEdotplot</code> object which is a list of three <code>trellis</code>
objects,
one for the the Percent plot, one for the Relative Risk plot, and one
for
the Text plot containing the table of input values.  The object has
attributes
</p>

<ol>
<li> <p><code>main</code> and <code>sub</code> hold the main and subtitles.  Each must
be a list containing the text in the first component.
</p>
</li>
<li> <p><code>ae.key</code> is a key as described in
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
</li>
<li> <p><code>n.events</code> is a vector containing the number of events in
each subpanel.
</p>
</li>
<li> <p><code>panel.widths</code> is a vector of relative widths of the three components
of
the graph.  The numbers must sum to one.  Zero values are permitted.
The first width includes the left axis and the Percent plot.  The second
is the Relative Risk plot, and the third is the plot of the table
values.
</p>
</li>
<li> <p><code>AEtable</code> is a table containing the data plotted on its row.
</p>
</li></ol>



<h3>Note</h3>

<p>Ann Liu-Ferrara was a beta tester for the shiny app.</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Ohad Amit, Richard M. Heiberger, and Peter W. Lane. (2008)
&ldquo;Graphical Approaches to the Analysis of Safety Data from Clinical Trials&rdquo;.
<em>Pharmaceutical Statistics</em>,
<b>7</b>, 1, 20&ndash;35.
<a href="https://onlinelibrary.wiley.com/doi/10.1002/pst.254">https://onlinelibrary.wiley.com/doi/10.1002/pst.254</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AEdotplot.data.frame">AEdotplot.data.frame</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## formula method.  See ?AEdotplot.data.frame for other methods.
data(AEdata)
head(AEdata)

AEdotplot(AE ~ nAE/nTRT, groups = TRT, data = AEdata)           ## sort by Relative Risk
AEdotplot(AE ~ nAE/nTRT | OrgSys, groups = TRT, data = AEdata)  ## conditioned on Organ System

## Not run: 
AEdotplot(AE ~ nAE/nTRT, groups = TRT, data = AEdata, sortbyVar="PCT")                   ## PCT A
AEdotplot(AE ~ nAE/nTRT, groups = TRT, data = AEdata, sortbyVar="PCT", sortbyVarBegin=2) ## PCT B
AEdotplot(AE ~ nAE/nTRT, groups = TRT, data = AEdata, sortbyRelativeRisk=FALSE)     ## levels(AE)
AEdotplot(AE ~ nAE/nTRT | OrgSys, groups = TRT, data = AEdata, sortbyVar="ase.logrelrisk")

## End(Not run)


## Not run: 
AEdotplot(AE ~ nAE/nTRT | OrgSys, groups = TRT,
          data = AEdata[c(AEdata$OrgSys %in% c("GI","Resp")),])

## test sortbyRelativeRisk=FALSE
ABCD.12345 &lt;- AEdata[1:12,]
head(ABCD.12345)
AEdotplot(AE ~ nAE/nTRT | OrgSys, groups=TRT, data=ABCD.12345)
AEdotplot(AE ~ nAE/nTRT | OrgSys, groups=TRT, data=ABCD.12345, sort=FALSE)

## suppress third panel
tmp &lt;- AEdotplot(AE ~ nAE/nTRT, groups = TRT, data = AEdata)
print(tmp, AEtable=FALSE)

## End(Not run)

## Not run: 
  ## run the shiny app
 if (interactive())  shiny::runApp(system.file("shiny/AEdotplot", package="HH"))

## End(Not run)

</code></pre>

<hr>
<h2 id='AEdotplot.data.frame'> AE (Adverse Events) dotplot of incidence and relative risk,
support functions </h2><span id='topic+AEdotplot.data.frame'></span><span id='topic+AEdotplot.AElogrelrisk'></span><span id='topic+AEdotplot.AEtable'></span><span id='topic+print.AEdotplot'></span><span id='topic+c.AEdotplot'></span><span id='topic+AElogrelrisk'></span><span id='topic+AEmatchSortorder'></span><span id='topic+update.AEdotplot'></span>

<h3>Description</h3>

<p>Support functions for the <code><a href="#topic+AEdotplot">AEdotplot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'data.frame'
AEdotplot(xr, ...,
          conditionVariable=NULL,
          conditionName=deparse(substitute(xr)),
          useCondition=!is.null(conditionVariable),
          sub=list(conditionName, cex=.7))

  ## S3 method for class 'AElogrelrisk'
AEdotplot(xr,
          A.name=paste(levels(xr$RAND)[1], " (n=", xr$SN[1], ")", sep=""),
          B.name=paste(levels(xr$RAND)[2], " (n=", xr$SN[2], ")", sep=""),
          col.AB=c("red","blue"), pch.AB=c(16,17),
           main=if (sortbyRelativeRisk)
              list("Most Frequent On-Therapy Adverse Events Sorted by Relative Risk",
                   cex=1)
           else
              list("Most Frequent On-Therapy Adverse Events", cex=1),
          cex.AB.points=NULL, cex.AB.y.scale=.6, cex.x.scale=.6,
          panel.widths=c(.55, .22, .23),
          key.y=-.2, CI.percent=95,
          conditionName=deparse(substitute(xr)),
          sortbyRelativeRisk=TRUE,
          ...,
          sub=list(conditionName, cex=.7),
          par.strip.text=list(cex=.7))

  ## S3 method for class 'AEtable'
AEdotplot(xr, ..., useCondition=TRUE,
                              sub="sub for AEsecond")

  ## S3 method for class 'AEdotplot'
print(x, ...,
      main=attr(x, "main"),
      sub=attr(x,"sub"),
      ae.key=attr(x, "ae.key"),
      panel.widths=attr(x,"panel.widths"),
      AEtable=TRUE)

  ## S3 method for class 'AEdotplot'
c(..., panel.widths=attr(aedp[[1]], "panel.widths"),
                        par.strip.text=list(cex=.7))

  AElogrelrisk(ae,
               A.name=levels(ae$RAND)[1],
               B.name=levels(ae$RAND)[2],
               crit.value=1.96,
               sortbyRelativeRisk=TRUE, ...,
                         sortbyVar=c("PREF", ## Event name
                           "PCT",            ## Percent
                           "SN",             ## Number of Patients
                           "SAE",            ## Number of Observed Events
                           "relrisk",        ## Relative Risk (RR)
                           "ase.logrelrisk", ## Asymptotic Standard Error(log(RR))
                           "relriskCI.lower", ## Confidence Interval Bounds
                           "relriskCI.upper"),
                         sortbyVarBegin=1)   ## 1 for A treatment, 2 for B treatment

  AEmatchSortorder(AEstandard,
                   AEsecond,
                   AEsecond.AEtable=attr(AEsecond, "AEtable"),
                   levels.order=
                      lapply(attr(AEstandard,"AEtable"),
                             function(AEsubtable) levels(AEsubtable$PREF)),
                   main.second=list(paste("Most Frequent On-Therapy Adverse Events",
                                          "Sorted to Match First Table"),
                                    cex=1))

  ## S3 method for class 'AEdotplot'
update(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AEdotplot.data.frame_+3A_ae">ae</code></td>
<td>
<p>For <code>AElogrelrisk</code>, a data.frame containing at least the
first 4 columns of <code>xr</code>.
</p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_xr">xr</code></td>
<td>
<p>For the formula method documented in
<code><a href="#topic+AEdotplot">AEdotplot</a></code>, a formula of the form<br />
<code>AE ~ nAE/nTRT | OrgSys</code>, where the condition variable is
optional.
For the formula method only, the variable names are not restricted.
</p>
<p>For the other methods, <code>xr</code> is a <code>data.frame</code> containing the Adverse
Event data in long format. It must have variables named<br />
<code>RAND</code>:   treatment as randomized (factor with exactly two levels).<br />
<code>PREF</code>:   adverse event symptom name (factor).<br />
<code>SN</code>:     number of patients in treatment group.<br />
<code>SAE</code>:    number of patients in each group for whom the event
PREF was observed.
</p>
<p>If the <code>xr</code> object is a <code>AElogrelrisk</code> object, then it must
also have variables<br />
<code>PCT</code>: <code>SAE</code>/<code>SN</code> as a percent.<br />
<code>relrisk</code>: Relative risk defined as <code>PCT</code> for the B
treatment divided by <code>PCT</code> for the A treatment.<br />
<code>logrelrisk</code>: natural logarithm of <code>relrisk</code>.<br />
<code>ase.logrelrisk</code>: asymptotic standard error of <code>logrelrisk</code>.<br />
<code>logrelriskCI.lower, logrelriskCI.upper</code>: confidence interval for
<code>logrelrisk</code>.<br />
<code>relriskCI.lower, relriskCI.upper</code>: back transform of the CI for
the log relative risk into the relative risk scale.
</p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_sortbyrelativerisk">sortbyRelativeRisk</code></td>
<td>
<p>logical.  If <code>TRUE</code>, then make the
Adverse Events an ordered factor ordering by relative risk.
If <code>FALSE</code>, then make the
Adverse Events an ordered factor retaining the order of the input levels.</p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_conditionvariable">conditionVariable</code></td>
<td>
<p>Vector of same length as number of rows in
<code>xr</code>, it may be one of the columns in <code>xr</code> in which case
its full name in the form xr$varname must be used.  It will be used to
split the <code>data.frame</code> into partitions.
It may be used to partition the plot,
for example by organ system or by gender.</p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_conditionname">conditionName</code></td>
<td>
<p>Character. Name to be used in <code>left.strip</code>.</p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_usecondition">useCondition</code></td>
<td>
<p>logical.  If <code>FALSE</code>, then a non-<code>NULL</code>
<code>ConditionVariable</code> won't be used.</p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_x">x</code></td>
<td>
<p>object to be printed.</p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_panel.widths">panel.widths</code></td>
<td>
<p>Vector of three non-negative numerics that sum to 1.
These are the widths of each of the three panels in the output plot.
The left panel contains the AE names as y-tick labels and the Percent plot.
The middle panel contains the Relative Risk plot.
The right panel contains a table of the numerical values of number of patients
for each treatment,
number of adverse events for each treatment, and relative risk.
Setting the third value to 0 suppresses the table of numerical
values from the display.
</p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_aetable">AEtable</code></td>
<td>
<p>logical.  For the <code>print.AEdotplot</code> function.
If <code>TRUE</code> (the default), display all three panels.  If
<code>FALSE</code>, then display only the Percent and Relative Risk plots.</p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_main">main</code>, <code id="AEdotplot.data.frame_+3A_sub">sub</code></td>
<td>
<p>Main title and subtitle for the combined plot
in <code>AEdotplot</code>.</p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_main.second">main.second</code></td>
<td>
<p>Main title for second plot whose sort order has
been changed to match the first plot.</p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_a.name">A.name</code>, <code id="AEdotplot.data.frame_+3A_b.name">B.name</code></td>
<td>
<p>Names of treatment groups (in <code>x$RAND</code>).</p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_col.ab">col.AB</code>, <code id="AEdotplot.data.frame_+3A_pch.ab">pch.AB</code>, <code id="AEdotplot.data.frame_+3A_cex.ab.points">cex.AB.points</code></td>
<td>
<p>color, plotting character and
character expansion for the individual points on the left plot.</p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_cex.ab.y.scale">cex.AB.y.scale</code></td>
<td>
<p>Character expansion for the left tick labels
(the Adverse Effects names). </p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_cex.x.scale">cex.x.scale</code></td>
<td>
<p>Character expansion for the x-axis tick labels.</p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_key.y">key.y</code></td>
<td>
<p>Position of the key (legend) in the combined plot.  This
is the <code>y</code> argument of the <code>key</code>.
See the discussion of the <code>key</code> argument to <code>xyplot</code> in
<code><a href="lattice.html#topic+xyplot">xyplot</a></code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="AEdotplot.data.frame_+3A_ae.key">ae.key</code></td>
<td>
<p>is a key as described in <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_aestandard">AEstandard</code>, <code id="AEdotplot.data.frame_+3A_aesecond">AEsecond</code>, <code id="AEdotplot.data.frame_+3A_aesecond.aetable">AEsecond.AEtable</code>, <code id="AEdotplot.data.frame_+3A_levels.order">levels.order</code></td>
<td>
<p>Arguments
that force the Adverse Events in the panels of <code>AEsecond</code> to
have the same sort order <code>levels.order</code> of <code>PREF</code> as the
panels of <code>AEstandard</code>. <code>AEstandard</code> and <code>AEsecond</code>
are two <code>"AEdotplot"</code> objects with the same set of panels and
the same Adverse Events in corresponding panels.
<code>AEsecond.AEtable</code> is the <code>AEtable</code> object from
<code>AEsecond</code>.  <code>levels.order</code> is the new order for
<code>AEsecond</code>; normally the same order as in <code>AEprimary</code>.  </p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_crit.value">crit.value</code></td>
<td>
<p>Critical value used to compute confidence intervals
on the log relative risk.  Defaults to 1.96.  User is responsible
for specifying both <code>crit.value</code> and <code>CI.percent</code>
consistently.</p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_ci.percent">CI.percent</code></td>
<td>
<p>Confidence percent associated with the
<code>crit.value</code> Defaults to 95.  User is responsible for
specifying both <code>crit.value</code> and <code>CI.percent</code>
consistently.</p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_...">...</code></td>
<td>
<p>For <code>AEdotplot</code> and <code>AEdotplot.data.frame</code>,
all the arguments listed in the
calling sequence for <code>AEddotplot.AErelrisk</code>..
For <code>c.AEdotplot</code>, one or more <code>"AEdotplot"</code> objects.
For <code>print.AEdotplot</code>, the <code>...</code> arguments are ignored.
</p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_sortbyvar">sortbyVar</code></td>
<td>

<p>Specify which variable will be used to provide the sort order in the
plot.
The names are the internal names for the variables.
</p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_sortbyvarbegin">sortbyVarBegin</code></td>
<td>

<p>1 for A treatment, 2 for B treatment.
</p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_object">object</code></td>
<td>
<p>An <code>AEdotplot</code> object.  The <code>update</code> method
updates the components of each of the constituent <code>trellis</code>
objects.  It does not update the <code>"main"</code> and <code>"sub"</code>
attributes (nor any other attribute) of the <code>AEdotplot</code> object.</p>
</td></tr>
<tr><td><code id="AEdotplot.data.frame_+3A_par.strip.text">par.strip.text</code></td>
<td>
<p>Default value for strip labels.  See
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>
for details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first panel is an ordinary dotplot of the percent of AE observed for each
treatment by AE.
</p>
<p>The second panel shows relative risk of an event on the Treatment B arm
(usually the active compound)
relative to the Treatment A arm (usually the placebo), with 95% confidence
intervals for a <code class="reqn">2\times2</code> table.  Confidence intervals on the log
relative risk are calculated using the asymptotic standard error
formula given as Equation 3.18 in Agresti A., <em>Categorical Data
Analysis.</em> Wiley: New York, 1990.
</p>
<p>By default the <code>AEdotplot</code> function sorts the events by relative risk.
To retain the sort order implied by the <code>levels</code> of the AE
factor, specify the argument <code>sortbyRelativeRisk=FALSE</code>.
To control the sort order, make the AE factor in the input dataset
an <code>ordered</code> factor
and specify the levels in the order you want.
</p>
<p>The third panel shows the numerical values of the number and percent
of observed events on each arm and the relative risk.
The display of third panel can be suppressed by specifying the
<code>panel.widths</code> argument.
</p>


<h3>Value</h3>

<p>The primary interest is in the display of the plot.
</p>
<p>The function returns
an <code>AEdotplot</code> object which is a list of three <code>trellis</code>
objects,
one for the the Percent plot, one for the Relative Risk plot, and one
for
the Text plot containing the table of input values.  The object has
attributes
</p>

<ol>
<li> <p><code>main</code> and <code>sub</code> hold the main and subtitles.  Each must
be a list containing the text in the first component.
</p>
</li>
<li> <p><code>ae.key</code> is a key as described in
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
</li>
<li> <p><code>n.events</code> is a vector containing the number of events in
each subpanel.
</p>
</li>
<li> <p><code>panel.widths</code> is a vector of relative widths of the three components
of
the graph.  The numbers must sum to one.  Zero values are permitted.
The first width includes the left axis and the Percent plot.  The second
is the Relative Risk plot, and the third is the plot of the table
values.
</p>
</li>
<li> <p><code>AEtable</code> is a table containing the data plotted on its row.
</p>
</li></ol>



<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Ohad Amit, Richard M. Heiberger, and Peter W. Lane. (2008)
&ldquo;Graphical Approaches to the Analysis of Safety Data from Clinical Trials&rdquo;.
<em>Pharmaceutical Statistics</em>,
<b>7</b>, 1, 20&ndash;35.
<a href="https://onlinelibrary.wiley.com/doi/10.1002/pst.254">https://onlinelibrary.wiley.com/doi/10.1002/pst.254</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AEdotplot">AEdotplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## variable names in the input data.frame aeanonym
## RAND   treatment as randomized
## PREF   adverse event symptom name
## SN     number of patients in treatment group
## SAE    number of patients  in each group for whom the event PREF was observed
## OrgSys Organ System
##
## Input sort order is PREF/RAND

data(aeanonym)
head(aeanonym)

## variable names are hard-wired in the program
## names(aeanonym) &lt;- c("RAND", "PREF", "SAE", "SN", "OrgSys")


## Calculate log relative risk and confidence intervals (95
## AElogrelrisk sets the sort order for PREF to match the relative risk.
aeanonymr &lt;- AElogrelrisk(aeanonym) ## PREF sorted by relative risk
head(aeanonymr)
class(aeanonymr$PREF)
levels(aeanonymr$PREF)

AEdotplot(aeanonym)

AEdotplot(aeanonym, sort=FALSE)

AEdotplot(aeanonym, conditionVariable=aeanonym$OrgSys)

aefake &lt;- rbind(cbind(aeanonym, group="ABC"), cbind(aeanonym, group="DEF"))
aefake$SAE[67:132] &lt;- sample(aefake$SAE[67:132])
aefake$OrgSys.group &lt;- with(aefake, interaction(OrgSys, group))

## fake 2
KEEP &lt;- aefake$OrgSys %in% c("GI","Resp")
AEfakeGR &lt;- AEdotplot(aefake[KEEP,], conditionVariable=aefake$OrgSys.group[KEEP],
            sub=list("ABC and DEF have different sort orders for PREF", cex=.7))
AEfakeGR ## ABC and DEF have different sort orders for PREF

AEfakeGR1 &lt;- AEdotplot(aefake[KEEP &amp; (1:132) &lt;= 66,],
                       conditionVariable=aefake$OrgSys.group[KEEP &amp; (1:132) &lt;= 66])
AEfakeGR2 &lt;- AEdotplot(aefake[KEEP &amp; (1:132) &gt;= 67,],
                       conditionVariable=aefake$OrgSys.group[KEEP &amp; (1:132) &gt;= 67])

AEfakeGR1
AEfakeGR2

AEfakeMatched &lt;- AEmatchSortorder(AEfakeGR1, AEfakeGR2)
update(do.call(c, AEfakeMatched),
       main="ABC sorted by Relative Risk; DEF matches ABC order")

## End(Not run)
## Please see  ?AEdotplot  for examples using the formula method
##
## Many more examples are in demo("AEdotplotManyExamples")
</code></pre>

<hr>
<h2 id='ancova'>Compute and plot oneway analysis of covariance</h2><span id='topic+ancova'></span><span id='topic+analysis+20of+20covariance'></span><span id='topic+covariance'></span><span id='topic+anova.ancova'></span><span id='topic+predict.ancova'></span><span id='topic+print.ancova'></span><span id='topic+model.frame.ancova'></span><span id='topic+summary.ancova'></span><span id='topic+plot.ancova'></span><span id='topic+coef.ancova'></span><span id='topic+panel.ancova'></span>

<h3>Description</h3>

<p>Compute and plot oneway analysis of covariance.
The result object is an <code>ancova</code> object which consists of
an ordinary <code>aov</code> object with an additional <code>trellis</code>
attribute.  The
<code>trellis</code> attribute is a <code>trellis</code> object consisting of
a series of plots of <code>y ~ x</code>.  The left set of panels is
conditioned on the levels of the factor <code>groups</code>.  The right
panel is a superpose of all the groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ancova(formula, data.in = NULL, ...,
       x, groups, transpose = FALSE,
       display.plot.command = FALSE,
       superpose.level.name = "superpose",
       ignore.groups = FALSE, ignore.groups.name = "ignore.groups",
       blocks, blocks.pch = letters[seq(levels(blocks))],
       layout, between, main,
       pch=trellis.par.get()$superpose.symbol$pch)

panel.ancova(x, y, subscripts, groups,
 transpose = FALSE, ...,
 coef, contrasts, classes,
 ignore.groups, blocks, blocks.pch, blocks.cex, pch)

## The following are ancova methods for generic functions.
## S3 method for class 'ancova'
anova(object, ...)

## S3 method for class 'ancova'
predict(object, ...)

## S3 method for class 'ancova'
print(x, ...) ## prints the anova(x) and the trellis attribute

## S3 method for class 'ancova'
model.frame(formula, ...)

## S3 method for class 'ancova'
summary(object, ...)

## S3 method for class 'ancova'
plot(x, y, ...) ## standard lm plot.  y is always ignored.

## S3 method for class 'ancova'
coef(object, ...)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ancova_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the model.</p>
</td></tr>
<tr><td><code id="ancova_+3A_data.in">data.in</code></td>
<td>
<p>A data frame in which the variables specified in the
formula will be found. If missing, the variables are searched for in
the standard way.</p>
</td></tr>
<tr><td><code id="ancova_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>aov</code>, such as <code>subset</code>
or <code>na.action</code>.</p>
</td></tr>
<tr><td><code id="ancova_+3A_x">x</code></td>
<td>
<p>Covariate in <code>ancova</code>, needed for plotting when the
formula does not include <code>x</code>.
<code>"aov"</code> object in <code>print.ancova</code>, to match the argument of
the <code>print</code> generic function.
Variable to plotted in <code>"panel.ancova"</code>.
</p>
</td></tr>
<tr><td><code id="ancova_+3A_groups">groups</code></td>
<td>
<p>Factor.  Needed for plotting when the formula does not
include <code>groups</code> after the conditioning bar <code>"|"</code>.</p>
</td></tr>
<tr><td><code id="ancova_+3A_transpose">transpose</code></td>
<td>
<p>S-Plus: The axes in each panel of the plot are
transposed.  The analysis
is identical, just the axes displaying it have been interchanged.
R: no effect.</p>
</td></tr>
<tr><td><code id="ancova_+3A_display.plot.command">display.plot.command</code></td>
<td>
<p>The default setting is usually what the user
wants.  The alternate value <code>TRUE</code> prints on the console the
command that draws the graph.  This is strictly for debugging the
<code>ancova</code> command.</p>
</td></tr>
<tr><td><code id="ancova_+3A_superpose.level.name">superpose.level.name</code></td>
<td>
<p>Name used in strip label for superposed panel.</p>
</td></tr>
<tr><td><code id="ancova_+3A_ignore.groups">ignore.groups</code></td>
<td>
<p>When <code>TRUE</code>, an additional panel showing all
groups together with a common regression line is displayed.</p>
</td></tr>
<tr><td><code id="ancova_+3A_ignore.groups.name">ignore.groups.name</code></td>
<td>
<p>Name used in strip label for
<code>ignore.groups</code> panel.</p>
</td></tr>
<tr><td><code id="ancova_+3A_pch">pch</code></td>
<td>
<p>Plotting character for groups.</p>
</td></tr>
<tr><td><code id="ancova_+3A_blocks">blocks</code></td>
<td>
<p>Additional factor used to label points in the panels.</p>
</td></tr>
<tr><td><code id="ancova_+3A_blocks.pch">blocks.pch</code></td>
<td>
<p>Alternate set of labels used when a <code>blocks</code>
factor is specified.</p>
</td></tr>
<tr><td><code id="ancova_+3A_blocks.cex">blocks.cex</code></td>
<td>
<p>Alternate set of <code>cex</code> used when a <code>blocks</code>
factor is specified.</p>
</td></tr>
<tr><td><code id="ancova_+3A_layout">layout</code></td>
<td>
<p>The layout of multiple panels.  The default is a single
row.  See details.</p>
</td></tr>
<tr><td><code id="ancova_+3A_between">between</code></td>
<td>
<p>Space between the panels for the individual group
levels and the superpose panel including all groups.</p>
</td></tr>
<tr><td><code id="ancova_+3A_main">main</code></td>
<td>
<p>Character with a main header title to be done on the top
of each page.</p>
</td></tr>
<tr><td><code id="ancova_+3A_y">y</code>, <code id="ancova_+3A_subscripts">subscripts</code></td>
<td>
<p>In <code>"panel.ancova"</code>,
see <code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="ancova_+3A_object">object</code></td>
<td>
<p>An <code>"aov"</code></p>
</td></tr></table>
<p> object.  The functions using this
argument are methods for the similarly named generic functions.
</p>
<table>
<tr><td><code id="ancova_+3A_coef">coef</code>, <code id="ancova_+3A_contrasts">contrasts</code>, <code id="ancova_+3A_classes">classes</code></td>
<td>
<p>Internal variables used to communicate between
<code>ancova</code> and <code>panel.ancova</code>.  They keep track
of the constant or different slopes and intercepts in each
panel of the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The <code>ancova</code> function does two things.  It passes its
arguments directly to the <code>aov</code> function and returns the entire
<code>aov</code> object.  It also rearranges the data and formula in its
argument and passes that to the <code>xyplot</code> function.  The
<code>trellis</code> attribute is a <code>trellis</code> object consisting of
a series of plots of <code>y ~ x</code>.  The left set of panels is
conditioned on the levels of the factor <code>groups</code>.  The right
panel is a superpose of all the groups. </p>


<h3>Value</h3>

<p> The result object is an <code>ancova</code> object which consists of
an ordinary <code>aov</code> object with an additional <code>trellis</code>
attribute.  The default print method is to print both the <code>anova</code>
of the object and the <code>trellis</code> attribute.  </p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ancova-class">ancova-class</a></code>
<code><a href="stats.html#topic+aov">aov</a></code>
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
See <code><a href="#topic+ancovaplot">ancovaplot</a></code> for a newer set of functions that keep the
graph and the <code>aov</code> object separate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hotdog)

## y ~ x                     ## constant line across all groups
ancova(Sodium ~ Calories,     data=hotdog, groups=Type)

## y ~ a                     ## different horizontal line in each group
ancova(Sodium ~            Type, data=hotdog, x=Calories)

## This is the usual usage
## y ~ x + a  or  y ~ a + x  ## constant slope, different intercepts
ancova(Sodium ~ Calories + Type, data=hotdog)
ancova(Sodium ~ Type + Calories, data=hotdog)

## y ~ x * a  or  y ~ a * x  ## different slopes, and different intercepts
ancova(Sodium ~ Calories * Type, data=hotdog)
ancova(Sodium ~ Type * Calories, data=hotdog)

## y ~ a * x ## save the object and print the trellis graph
hotdog.ancova &lt;- ancova(Sodium ~ Type * Calories, data=hotdog)
attr(hotdog.ancova, "trellis")


## label points in the panels by the value of the block factor
data(apple)
ancova(yield ~ treat + pre, data=apple, blocks=block)

## Please see
##      demo("ancova")
## for a composite graph illustrating the four models listed above.
</code></pre>

<hr>
<h2 id='ancova-class'>Class &quot;ancova&quot; Analysis of Covariance </h2><span id='topic+ancova-class'></span>

<h3>Description</h3>

<p>Analysis of Covariance.  The class is an extension of &quot;aov&quot;
and &quot;lm&quot;.  It is identical to the &quot;aov&quot; for a single factor and a single
covariate plus an attribute which contains a <code>"trellis"</code> object.
Four different models are included in the class.  See <code><a href="#topic+ancova">ancova</a></code>
for the examples.
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code>"aov"</code>, directly.
Class <code>"lm"</code>, by class &quot;aov&quot;, distance 2.
Class <code>"mlm"</code>, by class &quot;aov&quot;, distance 2, with explicit test and coerce.
Class <code>"oldClass"</code>, by class &quot;aov&quot;, distance 3.
Class <code>"oldClass"</code>, by class &quot;aov&quot;, distance 4, with explicit test and coerce.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;ancova&quot; in the signature.
S3-type methods are
<code>"anova.ancova"</code>, <code>"coef.ancova"</code>,
<code>"coefficients.ancova"</code>, <code>"model.frame.ancova"</code>,
<code>"plot.ancova"</code>, <code>"predict.ancova"</code>,
<code>"print.ancova"</code>, <code>"summary.ancova"</code>.
<code>"plot.ancova(x)"</code> plots a standard lm plot of <code>x</code>.
<code>"print.ancova(x)"</code> prints the <code>anova(x)</code> and the trellis attribute.
The remaining methods use <code>NextMethod</code>.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ancova">ancova</a></code>
</p>

<hr>
<h2 id='ancovaplot'>
Analysis of Covariance Plots
</h2><span id='topic+ancovaplot'></span><span id='topic+ancovaplot.formula'></span><span id='topic+panel.ancova.superpose'></span>

<h3>Description</h3>

<p>Analysis of Covariance Plots. Any of the ancova models<br />
<code>y ~ x * t</code><br />
<code>y ~ t * x</code><br />
<code>y ~ x + t</code><br />
<code>y ~ t + x</code><br />
<code>y ~ x    , groups=t</code><br />
<code>y ~     t, x=x</code><br />
<code>y ~ x * t, groups=b</code><br />
<code>y ~ t * x, groups=b</code><br />
<code>y ~ x + t, groups=b</code><br />
<code>y ~ t + x, groups=b</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ancovaplot(object, ...)
## S3 method for class 'formula'
ancovaplot(object, data, groups=NULL, x=NULL, ...,
           formula=object,
           col=rep(tpg$col,
             length=length(levels(as.factor(groups)))),
           pch=rep(c(15,19,17,18,16,20, 0:14),
             length=length(levels(as.factor(groups)))),
           slope, intercept,
           layout=c(length(levels(cc)), 1),
           col.line=col, lty=1,
           superpose.panel=TRUE,
           between=if (superpose.panel)
                      list(x=c(rep(0, length(levels(cc))-1), 1))
                   else
                      list(x=0),
           col.by.groups=FALSE ## ignored unless groups= is specified
           )

panel.ancova.superpose(x, y, subscripts, groups,
                       slope, intercept,
                       col, pch, ...,
                       col.line, lty,
                       superpose.panel,
                       col.by.groups,
                       condition.factor,
                       groups.cc.incompatible,
                       plot.resids=FALSE,
                       print.resids=FALSE,
                       mean.x.line=FALSE,
                       col.mean.x.line="gray80")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ancovaplot_+3A_formula">formula</code>, <code id="ancovaplot_+3A_object">object</code></td>
<td>

<p><code>formula</code> specifying the <code>aov</code> model.  The function modifies it for the
<code>xyplot</code> specification.
</p>
</td></tr>
<tr><td><code id="ancovaplot_+3A_data">data</code></td>
<td>

<p><code>data.frame</code>
</p>
</td></tr>
<tr><td><code id="ancovaplot_+3A_groups">groups</code></td>
<td>

<p>If the treatment factor is included in the <code>formula</code>, then <code>groups</code> is not
needed.  By default <code>groups</code> will be set to the treatment factor, but the
user may specify another factor for <code>groups</code>, usually a blocking factor.  The
<code>pch</code> will follow the value of <code>groups</code>.  If the treatment
is not included in the <code>formula</code>, then <code>groups</code> is required.
</p>
</td></tr>
<tr><td><code id="ancovaplot_+3A_x">x</code></td>
<td>

<p>Covariate.  Required by <code>ancovaplot.formula</code> if the covariate is
not included in the <code>formula</code>.
</p>
<p>For <code>panel.ancova.superpose</code>, see <code><a href="lattice.html#topic+panel.superpose">panel.superpose</a></code>.
</p>
</td></tr>
<tr><td><code id="ancovaplot_+3A_...">...</code></td>
<td>

<p>Other arguments to be passed to <code>xyplot</code>.
</p>
</td></tr>
<tr><td><code id="ancovaplot_+3A_col">col</code>, <code id="ancovaplot_+3A_pch">pch</code></td>
<td>

<p>Standard <span class="pkg">lattice</span> arguments.  <code>pch</code> follows the value of
<code>groups</code>.  When <code>col.by.groups</code> is <code>TRUE</code>, then
<code>col</code> follow the value of <code>groups</code>.
When <code>col.by.groups</code> is <code>FALSE</code>, then
<code>col</code> follows the value of the treatment factor, and is constant in
each panel.
</p>
</td></tr>
<tr><td><code id="ancovaplot_+3A_slope">slope</code>, <code id="ancovaplot_+3A_intercept">intercept</code></td>
<td>

<p>Vector, the length of the number of treatment levels, containing slope
and intercept of the <code>abline</code> in each panel.
This is by default calculated based on the formula.  The user may
override each independently.
</p>
</td></tr>
<tr><td><code id="ancovaplot_+3A_layout">layout</code>, <code id="ancovaplot_+3A_between">between</code></td>
<td>

<p>Standard <span class="pkg">lattice</span> arguments.
</p>
</td></tr>
<tr><td><code id="ancovaplot_+3A_col.line">col.line</code>, <code id="ancovaplot_+3A_lty">lty</code></td>
<td>

<p>Standard <span class="pkg">lattice</span> arguments.  By default, they follow the value of the
treatment factor in the <code>formula</code>. <code>col.line</code> is recycled to
the number of panels in the plot.
</p>
</td></tr>
<tr><td><code id="ancovaplot_+3A_y">y</code>, <code id="ancovaplot_+3A_subscripts">subscripts</code></td>
<td>

<p>See <code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="ancovaplot_+3A_superpose.panel">superpose.panel</code></td>
<td>

<p>logical.  if <code>TRUE</code> (the default), there is an additional panel on
the right containing the superposition of the points and lines for all treatment levels.
</p>
</td></tr>
<tr><td><code id="ancovaplot_+3A_col.by.groups">col.by.groups</code></td>
<td>

<p>logical. See the discussion in argument <code>col</code>.
</p>
</td></tr>
<tr><td><code id="ancovaplot_+3A_condition.factor">condition.factor</code>, <code id="ancovaplot_+3A_groups.cc.incompatible">groups.cc.incompatible</code></td>
<td>

<p>These are both internal variables.  <code>condition.factor</code> contains a
copy of the treatment factor.  <code>groups.cc.incompatible</code> is a
logical which is set to <code>TRUE</code> when the <code>groups</code> argument is
explicitly set by the user.
</p>
</td></tr>
<tr><td><code id="ancovaplot_+3A_plot.resids">plot.resids</code>, <code id="ancovaplot_+3A_print.resids">print.resids</code>, <code id="ancovaplot_+3A_mean.x.line">mean.x.line</code>, <code id="ancovaplot_+3A_col.mean.x.line">col.mean.x.line</code></td>
<td>

<p>logical, logical, logical or numeric, color name.
When <code>plot.resids==TRUE</code> then vertical line segments
connecting the data points and the fitted line are drawn.
The other two arguments are interpreted only when
<code>plot.resids==TRUE</code>.
When <code>print.resids==TRUE</code> then the values of the residuals are
printed on the console.  When <code>is.numeric(mean.x.line)</code> then a vertical
reference line is drawn at the specified value, which will normally be
specified by the user as the mean of the full set of x values.
The reference line will have color specified by <code>col.mean.x.line</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
  <code>ancova=aov specification</code></td><td style="text-align: left;"><code>xyplot specification</code></td><td style="text-align: left;"><code>abline         </code></td><td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>y ~ x * t               </code></td><td style="text-align: left;"><code>y ~ x | t, groups=t </code></td><td style="text-align: left;"><code>lm(y[t] ~ x[t])</code></td><td style="text-align: left;"><code>## separate lines</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>y ~ t * x               </code></td><td style="text-align: left;"><code>y ~ x | t, groups=t </code></td><td style="text-align: left;"><code>lm(y[t] ~ x[t])</code></td><td style="text-align: left;"><code>## separate lines</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>y ~ x + t               </code></td><td style="text-align: left;"><code>y ~ x | t, groups=t </code></td><td style="text-align: left;"><code>lm(y ~ x + t)  </code></td><td style="text-align: left;"><code>## parallel lines</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>y ~ t + x               </code></td><td style="text-align: left;"><code>y ~ x | t, groups=t </code></td><td style="text-align: left;"><code>lm(y ~ x + t)  </code></td><td style="text-align: left;"><code>## parallel lines</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>y ~ x    , groups=t     </code></td><td style="text-align: left;"><code>y ~ x | t, groups=t </code></td><td style="text-align: left;"><code>lm(y ~ x)      </code></td><td style="text-align: left;"><code>## single regression line</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>y ~     t, x=x          </code></td><td style="text-align: left;"><code>y ~ x | t, groups=t </code></td><td style="text-align: left;"><code>mean(t)        </code></td><td style="text-align: left;"><code>## separate horizontal lines</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>y ~ x * t, groups=b     </code></td><td style="text-align: left;"><code>y ~ x | t, groups=b </code></td><td style="text-align: left;"><code>lm(y[t] ~ x[t])</code></td><td style="text-align: left;"><code>## sep lines, pch&amp;col follow b</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>y ~ t * x, groups=b     </code></td><td style="text-align: left;"><code>y ~ x | t, groups=b </code></td><td style="text-align: left;"><code>lm(y[t] ~ x[t])</code></td><td style="text-align: left;"><code>## sep lines, pch&amp;col follow b</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>y ~ x + t, groups=b     </code></td><td style="text-align: left;"><code>y ~ x | t, groups=b </code></td><td style="text-align: left;"><code>lm(y ~ x + t)  </code></td><td style="text-align: left;"><code>## par lines, pch&amp;col follow b</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>y ~ t + x, groups=b     </code></td><td style="text-align: left;"><code>y ~ x | t, groups=b </code></td><td style="text-align: left;"><code>lm(y ~ x + t)  </code></td><td style="text-align: left;"><code>## par lines, pch&amp;col follow b</code>
</td>
</tr>

</table>



<h3>Value</h3>

<p><code>ancovaplot</code> returns a <code>c("ancova","trellis")</code> object.
<code>panel.ancova.superpose</code> is an ordinary <span class="pkg">lattice</span> <code>panel</code> function.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>


<h3>See Also</h3>

<p>See the older <code><a href="#topic+ancova">ancova</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(hotdog, package="HH")
  ancovaplot(Sodium ~ Calories + Type, data=hotdog)
  ancovaplot(Sodium ~ Calories * Type, data=hotdog)
  ancovaplot(Sodium ~ Calories, groups=Type, data=hotdog)
  ancovaplot(Sodium ~ Type, x=Calories, data=hotdog)

  ## Please see demo("ancova", package="HH") to coordinate placement
  ## of all four of these plots on the same page.

  ancovaplot(Sodium ~ Calories + Type, data=hotdog, plot.resids=TRUE)

</code></pre>

<hr>
<h2 id='anova.ancovaplot'>
ANOVA table for a c(&quot;ancovaplot&quot;,&quot;trellis&quot;) object.
</h2><span id='topic+anova.ancovaplot'></span><span id='topic+aov.ancovaplot'></span><span id='topic+aovStatement'></span><span id='topic+aovStatement.ancovaplot'></span><span id='topic+aovStatementAndAnova'></span><span id='topic+aovStatementAndAnova.ancovaplot'></span><span id='topic+model.tables.ancovaplot'></span>

<h3>Description</h3>

<p>ANOVA table for a c(&quot;ancovaplot&quot;,&quot;trellis&quot;) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ancovaplot'
anova(object, ...)
aov.ancovaplot(object, warn=TRUE)
aovStatement(object, ...)
## S3 method for class 'ancovaplot'
aovStatement(object, ...)
aovStatementAndAnova(object, ...)
## S3 method for class 'ancovaplot'
aovStatementAndAnova(object, ...)
## S3 method for class 'ancovaplot'
model.tables(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.ancovaplot_+3A_object">object</code>, <code id="anova.ancovaplot_+3A_x">x</code></td>
<td>

<p><code>c("ancovaplot","trellis")</code> object.
</p>
</td></tr>
<tr><td><code id="anova.ancovaplot_+3A_warn">warn</code>, <code id="anova.ancovaplot_+3A_...">...</code></td>
<td>
<p><code>warn</code> is logical with default <code>TRUE</code>.
See the Details section for the interpretation of <code>warn</code>.  When <code>...</code> is
received by <code>aov.ancovaplot</code>, it is evaluated if it is <code>warn</code> and
ignored for all other values.  When <code>...</code> is
received by <code>model.tables</code> it is interpreted normally.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>aov.ancovaplot</code> modifies the <code>call</code> item into an
<code>aov</code> call with the same formula and data.  If there are
<code>groups</code> in the call specified as a name, the <code>groups</code>
factor is included in the constructed <code>aov</code> call only if there
are both a factor and a covariate in the right-hand-side of the
formula.  In that case they the <code>groups</code> will be interpreted as a
block factor and will be placed first.  If the <code>groups</code> are
specified as a vector of values in the call, the <code>groups</code> are
ignored with a warning.  If there is only one term in the
right-hand-side, then the <code>groups</code> factor will not be placed
into the <code>aov</code> formula.  In this case, there will be a warning if
the argument <code>warn</code> is <code>TRUE</code>, and no warning if the <code>warn</code>
argument is <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+ancovaplot">ancovaplot</a></code>
</p>

<hr>
<h2 id='anovaMean'>ANOVA table from the group sample sizes, means, and standard deviations.</h2><span id='topic+anovaMean'></span>

<h3>Description</h3>

<p>Oneway ANOVA table from the summary information consisting of group
sample sizes, means, and standard deviations.  The full dataset is not
needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anovaMean(object, n, ybar, s, ..., ylabel = "ylabel")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anovaMean_+3A_object">object</code></td>
<td>
<p>level names</p>
</td></tr>
<tr><td><code id="anovaMean_+3A_n">n</code></td>
<td>
<p>sample size for each level</p>
</td></tr>
<tr><td><code id="anovaMean_+3A_ybar">ybar</code></td>
<td>
<p>sample mean for each level</p>
</td></tr>
<tr><td><code id="anovaMean_+3A_s">s</code></td>
<td>
<p>sample standard deviation for each level</p>
</td></tr>
<tr><td><code id="anovaMean_+3A_...">...</code></td>
<td>
<p>other arguments (not used)</p>
</td></tr>
<tr><td><code id="anovaMean_+3A_ylabel">ylabel</code></td>
<td>
<p>name of response variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Analysis of variance table, identical to the ANOVA table
that would have been produced by <code>anova.lm</code>
if the original data, rather than the summary data, had been available.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+anova.lm">anova.lm</a></code>,
</p>
<p><code><a href="#topic+plot.mmc.multicomp">plot.mmc.multicomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## pulmonary data used in Hsu and Peruggia paper defining the mean-mean plot
## See ?plot.mmc.multicomp for details on the dataset.

data(pulmonary)

anovaMean(pulmonary$smoker,
          pulmonary$n,
          pulmonary$FVC,
          pulmonary$s,
          ylabel="pulmonary")
</code></pre>

<hr>
<h2 id='aovSufficient'>Analysis of variance from sufficient statistics for groups.</h2><span id='topic+aovSufficient'></span><span id='topic+vcovSufficient'></span>

<h3>Description</h3>

<p>Analysis of variance from sufficient statistics for groups.
For each group, we need the factor level, the response mean, the
within-group standard deviation, and the sample size.
The correct ANOVA table is produced.  The residuals are fake.
The generic <code>vcov</code> and <code>summary.lm</code> don't work for the
variance of the regression coefficients in this case.
Use <code>vcovSufficient</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aovSufficient(formula, data = NULL,
              projections = FALSE, qr = TRUE, contrasts = NULL,
              weights = data$n, sd = data$s,
              ...)

vcovSufficient(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aovSufficient_+3A_formula">formula</code>, <code id="aovSufficient_+3A_data">data</code>, <code id="aovSufficient_+3A_projections">projections</code>, <code id="aovSufficient_+3A_qr">qr</code>, <code id="aovSufficient_+3A_contrasts">contrasts</code>, <code id="aovSufficient_+3A_...">...</code></td>
<td>
<p>See
<code><a href="stats.html#topic+aov">aov</a></code>.
</p>
</td></tr>
<tr><td><code id="aovSufficient_+3A_weights">weights</code></td>
<td>
<p>See
<code><a href="stats.html#topic+lm">lm</a></code>.
</p>
</td></tr>
<tr><td><code id="aovSufficient_+3A_sd">sd</code></td>
<td>
<p>vector of within-group standard deviations.</p>
</td></tr>
<tr><td><code id="aovSufficient_+3A_object">object</code></td>
<td>
<p><code>"aov"</code> object constructed by
<code>aovSufficient</code>.  It also works with regular <code>aov</code> objects.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>aovSufficient</code>, an object of class c(&quot;aov&quot;, &quot;lm&quot;).
For <code>vcovSufficient</code>, a function that returns the covariance
matrix of the regression coefficients.</p>


<h3>Note</h3>

<p>The residuals are fake.  They are all identical and equal to the MLE
standard error (<code>sqrt(SumSq.res/df.tot)</code>).  They give the right
ANOVA table.  They may cause confusion or warnings in other programs.
The standard errors and t-tests of the coefficients are not calculated
by <code>summary.lm</code>.
Using the <code>aov</code> object from <code>aovSufficient</code> in <code>glht</code>
requires the <code>vcov.</code> and <code>df</code> arguments.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+MMC">MMC</a></code> and
<code><a href="stats.html#topic+aov">aov</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This example is from Hsu and Peruggia

## This is the R version
## See ?mmc.mean for S-Plus

if.R(s={},
r={

data(pulmonary)
pulmonary
pulmonary.aov &lt;- aovSufficient(FVC ~ smoker,
                                data=pulmonary)
summary(pulmonary.aov)

## Not run: 
pulmonary.mmc &lt;- mmc(pulmonary.aov,
                     linfct=mcp(smoker="Tukey"),
                     df=pulmonary.aov$df.residual,
                     vcov.=vcovSufficient)
mmcplot(pulmonary.mmc, style="both")

## orthogonal contrasts
pulm.lmat &lt;- cbind("npnl-mh"=c( 1, 1, 1, 1,-2,-2), ## not.much vs lots
                   "n-pnl"  =c( 3,-1,-1,-1, 0, 0), ## none vs light
                   "p-nl"   =c( 0, 2,-1,-1, 0, 0), ## {} arbitrary 2 df
                   "n-l"    =c( 0, 0, 1,-1, 0, 0), ## {} for 3 types of light
                   "m-h"    =c( 0, 0, 0, 0, 1,-1)) ## moderate vs heavy
dimnames(pulm.lmat)[[1]] &lt;- row.names(pulmonary)
pulm.lmat

pulmonary.mmc &lt;- mmc(pulmonary.aov,
                     linfct=mcp(smoker="Tukey"),
                     df=pulmonary.aov$df.residual,
                     vcov.=vcovSufficient,
                     focus.lmat=pulm.lmat)

mmcplot(pulmonary.mmc, style="both", type="lmat")

## End(Not run)
})
</code></pre>

<hr>
<h2 id='arima.diag.hh'>Repair design error in S-Plus arima.diag</h2><span id='topic+arima.diag.hh'></span>

<h3>Description</h3>

<p>Repair design error in S-Plus <code>arima.diag</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arima.diag.hh(z, acf.resid = TRUE,
              lag.max = round(max(gof.lag + n.parms + 1, 10 * log10(n))),
              gof.lag = 15, resid = FALSE,
              std.resid = TRUE, plot = TRUE, type = "h", ...,
              x=eval(parse(text = series.name)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arima.diag.hh_+3A_z">z</code>, <code id="arima.diag.hh_+3A_acf.resid">acf.resid</code>, <code id="arima.diag.hh_+3A_lag.max">lag.max</code>, <code id="arima.diag.hh_+3A_gof.lag">gof.lag</code>, <code id="arima.diag.hh_+3A_resid">resid</code>, <code id="arima.diag.hh_+3A_std.resid">std.resid</code>, <code id="arima.diag.hh_+3A_plot">plot</code>, <code id="arima.diag.hh_+3A_type">type</code>, <code id="arima.diag.hh_+3A_...">...</code></td>
<td>

<p>This function is a no-op in R.  The arguments are not used.
</p>
</td></tr>
<tr><td><code id="arima.diag.hh_+3A_x">x</code></td>
<td>
<p>The time series.  This must be specified when arima.diag is
called from inside another function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Repairs design flaw in S-Plus <code>arima.diag</code>.  The location of the time
series is hardwired one level up, so it can't be found when
<code>arima.diag</code>
is not one level down from the top.
</p>
<p>This function is a no-op in R.
</p>


<h3>Value</h3>

<p>This function is a no-op in R.  It returns <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+tsdiagplot">tsdiagplot</a></code> in both systems and
<code>arima.diag</code>
</p>
<p>in S-Plus.
</p>

<hr>
<h2 id='arma.loop'>Loop through a series of ARIMA models and display coordinated
tables and diagnoastic graphs.</h2><span id='topic+arma.loop'></span><span id='topic+diag.arma.loop'></span><span id='topic+rearrange.diag.arma.loop'></span>

<h3>Description</h3>

<p>Loop through a series of ARIMA models and display coordinated
tables and diagnostic graphs.  The complete example from the Heiberger
and Teles article, also included in the Heiberger and Holland book, is
illustrated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma.loop(x,
          model,             ## S-Plus
          order, seasonal,   ## R
          series=deparse(substitute(x)), ...)

diag.arma.loop(z,
               x=stop("The time series x is needed in S-Plus when p=q=0."),
               lag.max = 36, gof.lag = lag.max)

rearrange.diag.arma.loop(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arma.loop_+3A_x">x</code></td>
<td>
<p>Time series vector.  In S-Plus, <code>x</code> must be an <code>"rts"</code>.</p>
</td></tr>
<tr><td><code id="arma.loop_+3A_model">model</code></td>
<td>
<p>A valid S-Plus <code>model</code> for
<code>arima.mle</code>.
</p>
</td></tr>
<tr><td><code id="arma.loop_+3A_order">order</code>, <code id="arma.loop_+3A_seasonal">seasonal</code></td>
<td>
<p>A valid R <code>order</code> and <code>seasonal</code> for
<code><a href="stats.html#topic+arima">arima</a></code>.
</p>
</td></tr>
<tr><td><code id="arma.loop_+3A_series">series</code></td>
<td>
<p>Character string describing the time series.</p>
</td></tr>
<tr><td><code id="arma.loop_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>arima.mle</code> or <code>arima</code>.</p>
</td></tr>
<tr><td><code id="arma.loop_+3A_z">z</code></td>
<td>
<p>For <code>diag.arma.loop</code>, an &quot;arma.loop&quot; object.
For  <code>rearrange.diag.arma.loop</code>, an &quot;diag.arma.loop&quot; object.</p>
</td></tr>
<tr><td><code id="arma.loop_+3A_lag.max">lag.max</code></td>
<td>
<p>Maximum lag for the acf and pacf plots.</p>
</td></tr>
<tr><td><code id="arma.loop_+3A_gof.lag">gof.lag</code></td>
<td>
<p>Maximum lag for the gof plots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>S-Plus and R have different functions, with different input argument names
and different components in their value.
</p>


<h3>Value</h3>

<p><code>arma.loop</code>: <code>"arma.loop"</code> object which is a matrix of
lists, each containing an arima model.
</p>
<p><code>diag.arma.loop</code>: <code>"diag.arma.loop"</code> object which is a
matrix of lists, each containing the standard diagnostics for one
arima model.
</p>
<p><code>rearrange.diag.arma.loop</code>: List of matrices, each containing
all the values for a specific diagnostic measure collected from the
set of arima models.
</p>


<h3>Author(s)</h3>

<p>Richard M. Heiberger (rmh@temple.edu)</p>


<h3>References</h3>

<p>&quot;Displays for Direct Comparison of ARIMA Models&quot;
The American Statistician, May 2002, Vol. 56, No. 2, pp. 131-138.
Richard M. Heiberger, Temple University, and
Paulo Teles, Faculdade de Economia do Porto.
</p>
<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsdiagplot">tsdiagplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## see tsdiagplot for the example
</code></pre>

<hr>
<h2 id='as.likert'>Support functions for diverging stacked barcharts for Likert, semantic
differential, and rating scale data.</h2><span id='topic+is.likert'></span><span id='topic+as.likert'></span><span id='topic+as.likert.data.frame'></span><span id='topic+as.likert.formula'></span><span id='topic+as.likert.ftable'></span><span id='topic+as.likert.table'></span><span id='topic+as.likert.matrix'></span><span id='topic+as.likert.listOfNamedMatrices'></span><span id='topic+as.likert.array'></span><span id='topic+as.likert.default'></span><span id='topic+is.likertCapable'></span><span id='topic+rev.likert'></span>

<h3>Description</h3>

<p>Constructs class=&quot;likert&quot; objects to be used by the plot.likert methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
is.likert(x)

as.likert(x, ...)
## Default S3 method:
as.likert(x, ...)
## S3 method for class 'data.frame'
as.likert(x, ...)
## S3 method for class 'formula'
as.likert(x, ...)  ## doesn't work yet
## S3 method for class 'ftable'
as.likert(x, ...)
## S3 method for class 'table'
as.likert(x, ...)
## S3 method for class 'matrix'
as.likert(x,
          ReferenceZero=NULL,
          ...,
          rowlabel=NULL, collabel=NULL,
          xlimEqualLeftRight=FALSE,
          xTickLabelsPositive=TRUE,
          padding=FALSE,
          reverse.left=TRUE)
## S3 method for class 'listOfNamedMatrices'
as.likert(x, ...)
## S3 method for class 'array'
as.likert(x, ...)

## S3 method for class 'likert'
rev(x)

is.likertCapable(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.likert_+3A_x">x</code></td>
<td>
<p>For the <code>as.likert</code> methods, a numeric object stored as a vector, matrix,
two-dimensional table, two-dimensional ftable,
two-dimensional structable (as defined in the <code>vcd</code> package),
or list of named matrices.
For functions <code>is.likert</code> and <code>is.likertCapable</code>, any object.
This is the only required argument.</p>
</td></tr>
<tr><td><code id="as.likert_+3A_rowlabel">rowlabel</code>, <code id="as.likert_+3A_collabel">collabel</code></td>
<td>
<p><code>names(dimnames(x))</code>, where <code>x</code> is
the argument to the <code>as.likert</code> functions.
These will become the <code>xlab</code> and <code>ylab</code> of the likert plot.</p>
</td></tr>
<tr><td><code id="as.likert_+3A_...">...</code></td>
<td>
<p>other arguments.  They will be ignored by
the <code>as.likert</code> method.</p>
</td></tr>
<tr><td><code id="as.likert_+3A_referencezero">ReferenceZero</code></td>
<td>
<p>Please see discussion of this argument
in <code><a href="#topic+likert">likert</a></code>.</p>
</td></tr>
<tr><td><code id="as.likert_+3A_xlimequalleftright">xlimEqualLeftRight</code></td>
<td>
<p>Logical. The default is <code>FALSE</code>.  If
<code>TRUE</code>, then the left and right x limits are set to negative
and positive of the larger of the absolute value of the original x limits.</p>
</td></tr>
<tr><td><code id="as.likert_+3A_xticklabelspositive">xTickLabelsPositive</code></td>
<td>
<p>Logical. The default is <code>TRUE</code>.
If <code>TRUE</code>, then the tick labels on the negative side are
displayed as positive values.</p>
</td></tr>
<tr><td><code id="as.likert_+3A_padding">padding</code>, <code id="as.likert_+3A_reverse.left">reverse.left</code></td>
<td>
<p><code>padding</code> is <code>FALSE</code> for
<code>likert</code> and <code>TRUE</code> for <code>likertMosaic</code>.
<code>reverse.left</code> is <code>TRUE</code> for <code>likert</code> and <code>FALSE</code>
for <code>likertMosaic</code>.  <code>likert</code> is based on
<code><a href="lattice.html#topic+xyplot">barchart</a></code>
and requires that the sequencing of negative values be reversed. <code>likertMosiac</code> is
based on <code><a href="vcd.html#topic+mosaic">mosaic</a></code> and needs padding on left and right
to fill the rectangle implied by the convex hull of the plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see <code><a href="#topic+likert">likert</a></code> for information on the plot for which
<code>as.likert</code> prepares the data.
</p>


<h3>Value</h3>

<p>For the <code>as.likert</code> methods, a <code>likert</code> object, which is
a matrix with additional attributes that are needed to make the
<code>barchart</code> method used by the <code><a href="#topic+plot.likert">plot.likert</a></code> methods
work with the data.  Columns for respondents who
disagree have negated values.
Any <code>NA</code> values in the argument <code>x</code> are changed to <code>0</code>.
The column of the original data for respondents who
neither agree nor disagree is split into two columns, each containing
halved values&mdash;one positive and one negative.
Negative columns come first in the sequence of &quot;No Opinion&quot;(negative)&ndash;&quot;Strongly
Disagree&quot;,
followed by &quot;No Opinion&quot;(positive)&ndash;&quot;Strongly Agree&quot;.
There are four
attributes:
<code>"even.col"</code> indicating whether there were originally an even
number of columns, <code>"n.levels"</code> the original number of levels,
<code>"levels"</code>
the original levels in the original order, <code>"positive.order"</code>
The sequence in which to display the rows in order to make the right
hand sides progress with high values on top.
</p>
<p><code>is.likert</code> returns a <code>TRUE</code> or <code>FALSE</code> value.
</p>
<p><code>is.likertCapable</code> returns a <code>TRUE</code> or <code>FALSE</code> value
if the argument can used as an argument to one of the <code>plot.likert</code> methods.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Richard M. Heiberger, Naomi B. Robbins (2014).,
&quot;Design of Diverging Stacked Bar Charts for Likert Scales and Other Applications&quot;,
Journal of Statistical Software, 57(5), 1&ndash;32,

<a href="https://doi.org/10.18637/jss.v057.i05">doi:10.18637/jss.v057.i05</a>.
</p>
<p>Naomi Robbins &lt;naomi@nbr-graphs.com&gt;, &quot;Visualizing Data: Challenges to
Presentation of Quality Graphics&mdash;and Solutions&quot;, Amstat News,
September 2011, 28&ndash;30.
</p>
<p>Naomi B. Robbins and Richard M. Heiberger (2011).  Plotting Likert and
Other Rating Scales.  In JSM Proceedings, Section on Survey Research
Methods. Alexandria, VA: American Statistical Association.
</p>
<p>Luo, Amy and Tim Keyes (2005). &quot;Second Set of Results in from the Career
Track Member Survey,&quot; Amstat News. Arlington, VA: American Statistical
Association.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+likert">likert</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Please see ?likert to see these functions used in context.

tmp2 &lt;- array(1:12, dim=c(3,4), dimnames=list(B=LETTERS[3:5], C=letters[6:9]))
as.likert(tmp2)  ## even number of levels.

is.likert(tmp2)
is.likert(as.likert(tmp2))
</code></pre>

<hr>
<h2 id='as.matrix.listOfNamedMatrices'>Convert a list of numeric matrices to a single matrix</h2><span id='topic+as.matrix.listOfNamedMatrices'></span><span id='topic+is.listOfNamedMatrices'></span><span id='topic+as.data.frame.listOfNamedMatrices'></span><span id='topic+as.listOfNamedMatrices'></span><span id='topic+print.listOfNamedMatrices'></span><span id='topic+as.MatrixList'></span><span id='topic+as.MatrixList.array'></span><span id='topic+print.MatrixList'></span><span id='topic+matrix'></span><span id='topic++5B.listOfNamedMatrices'></span><span id='topic+as.listOfNamedMatrices.array'></span><span id='topic+as.listOfNamedMatrices.list'></span><span id='topic+as.listOfNamedMatrices.MatrixList'></span><span id='topic+as.likertDataFrame'></span><span id='topic+as.likertDataFrame.listOfNamedMatrices'></span><span id='topic+as.likertDataFrame.array'></span>

<h3>Description</h3>

<p>Convert a list of numeric matrices to a single matrix.  This function is used
to improve legibility of the printed object.  The
<code>as.matrix.listOfNamedMatrices</code> display is easier to read when the rownames
are very long, as in the example illustrated here.  Because the
default print of the matrix repeats the rownames several times, with
only a few columns of the data shown in each repetition, the actual
matrix structure of the data values is obscured.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'listOfNamedMatrices'
as.matrix(x, abbreviate = TRUE, minlength = 4, ...)
is.listOfNamedMatrices(x,  xName=deparse(substitute(x)))
## S3 method for class 'listOfNamedMatrices'
as.data.frame(x, ...)
as.listOfNamedMatrices(x,  xName=deparse(substitute(x)), ...)
## S3 method for class 'listOfNamedMatrices'
x[...]
## S3 method for class 'array'
as.listOfNamedMatrices(x, xName=deparse(substitute(x)), ...)
## S3 method for class 'list'
as.listOfNamedMatrices(x, xName=deparse(substitute(x)), ...)
## S3 method for class 'MatrixList'
as.listOfNamedMatrices(x, xName=deparse(substitute(x)), ...)
## S3 method for class 'listOfNamedMatrices'
print(x, ...)

as.MatrixList(x)
## S3 method for class 'array'
as.MatrixList(x)
## S3 method for class 'MatrixList'
print(x, ...)

as.likertDataFrame(x, xName=deparse(substitute(x)))
## S3 method for class 'listOfNamedMatrices'
as.likertDataFrame(x, xName=deparse(substitute(x)))
## S3 method for class 'array'
as.likertDataFrame(x, xName=deparse(substitute(x)))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.listOfNamedMatrices_+3A_x">x</code></td>
<td>
<p>Named list of numeric matrices.  All matrices in the list
should have the same number of columns and the same column names.
The names of the list items will normally be long; NA, as
introduced by the <code><a href="base.html#topic+addNA">addNA</a></code>, is a valid name.  The
row names will normally be long.  The number of rows and their names
will normally differ across the matrices.  Each named item in the
list may be a vector, matrix, array, data.frame, two-dimensional
table, two-dimensional ftable, or two-dimensional structable.  For
the <code>as.MatrixList</code> methods, an array.
</p>
</td></tr>
<tr><td><code id="as.matrix.listOfNamedMatrices_+3A_...">...</code></td>
<td>
<p>Other arguments.  Not used.</p>
</td></tr>
<tr><td><code id="as.matrix.listOfNamedMatrices_+3A_abbreviate">abbreviate</code></td>
<td>

<p>Logical.  If <code>TRUE</code>, then use the
<code><a href="base.html#topic+abbreviate">abbreviate</a></code>
function on the item names and row names.
</p>
</td></tr>
<tr><td><code id="as.matrix.listOfNamedMatrices_+3A_minlength">minlength</code></td>
<td>
<p>the minimum length of the abbreviations.</p>
</td></tr>
<tr><td><code id="as.matrix.listOfNamedMatrices_+3A_xname">xName</code></td>
<td>
<p>Name of the argument in its original environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of <code>as.listOfNamedMatrices</code> is a list with
<code>class=c("listOfNamedMatrices", "list")</code>.
</p>
<p>The result of <code>as.matrix.listOfNamedMatrices</code> is an <code>rbind</code> of
the individual matrices in the argument list <code>x</code>.  The rownames of
the result matrix are constructed by pasting the abbreviation of the
list item names with the abbreviation of the individual matrix rownames.
The original names are retained as the <code>"Subtables.Rows"</code>
attribute.
</p>
<p>The result of <code>is.listOfNamedMatrices</code> is logical value.
</p>
<p><code>print.listOfNamedMatrices</code> prints
<code>as.matrix.listOfNamedMatrices</code> of its argument and returns the
original argument.
</p>
<p><code>as.data.frame.listOfNamedMatrices(x, ...)</code> is an unfortunate
kluge.  The result is the original <code>x</code> that has NOT been
transformed to a <code>data.frame</code>.  A <code>warning</code> message is
generated that states that the conversion has not taken place.  This
kluge is needed to use <code>"listOfNamedMatrices"</code> objects with the
<code><a href="Rcmdr.html#topic+Commander">Commander</a></code> package because <code>Rcmdr</code> follows
its calls to the R <code><a href="utils.html#topic+data">data</a></code> function with an attempt,
futile in this case, to force the resulting object to be a <code>data.frame</code>.
</p>
<p>The <code>as.MatrixList</code> methods construct a list of matrices from an
array.  Each matrix has the first two dimensions of the array.  The
result list is itself an array defined by all but the first two
dimensions of the argument array.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+likert">likert</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ProfChal)

tmp &lt;- data.matrix(ProfChal[,1:5])
rownames(tmp) &lt;- ProfChal$Question
ProfChal.list &lt;- split.data.frame(tmp, ProfChal$Subtable)

## Original list of matrices is difficult to read because
## it is displayed on too many lines.
ProfChal.list[2:3]

## Single matrix with long list item names and long row names
## of argument list retained as an attribute.
as.listOfNamedMatrices(ProfChal.list[2:3], minlength=6)

## Not run: 
## NA as a dimname value
tmp &lt;- structure(c(0, 0, 0, 6293, 18200, 2122,
                   0, 0, 0, 2462, 7015, 5589, 
                   6908, 5337, 842, 0, 0, 0),
                 .Dim = c(3L, 2L, 3L),
                 .Dimnames = list(c("A", "B", "C"),
                                  c("D", "E"),
                                  c("F", "G", NA)))
tmp
as.MatrixList(tmp)

## End(Not run)

## Not run: 
sapply(as.MatrixList(tmp3), as.likert, simplify=FALSE)  ## odd number of levels.

data(NZScienceTeaching)
likert(Question ~ ., NZScienceTeaching)
likert(Question ~ . | Subtable, data=NZScienceTeaching)
likert(Question ~ . | Subtable, data=NZScienceTeaching,
       layout=c(1,2), scales=list(y=list(relation="free")))



## End(Not run)
</code></pre>

<hr>
<h2 id='as.multicomp'>Support functions in R for MMC (mean&ndash;mean multiple comparisons) plots.</h2><span id='topic+as.multicomp'></span><span id='topic+as.multicomp.glht'></span><span id='topic+as.glht'></span><span id='topic+as.glht.multicomp'></span><span id='topic+print.mmc.multicomp'></span><span id='topic+print.mmc.multicomp'></span><span id='topic+print.multicomp'></span><span id='topic+print.multicomp.hh'></span>

<h3>Description</h3>

<p>MMC plots: In R, functions used to interface the <code>glht</code> in R to the MMC
functions designed with S-Plus <code>multicomp</code> notation.  These are
all internal functions that the user doesn't see.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmc.multicomp'
print(x, ..., width.cutoff=options()$width-5)

## S3 method for class 'multicomp'
print(x, ...)

## print.multicomp.hh(x, digits = 4, ..., height=T) ## S-Plus only

## S3 method for class 'multicomp.hh'
print(x, ...) ## R only


as.multicomp(x, ...)

## S3 method for class 'glht'
as.multicomp(x,       ## glht object
           focus=x$focus,
           ylabel=deparse(terms(x$model)[[2]]),
           means=model.tables(x$model, type="means",
                              cterm=focus)$tables[[focus]],
           height=rev(1:nrow(x$linfct)),
           lmat=t(x$linfct),
           lmat.rows=lmatRows(x, focus),
           lmat.scale.abs2=TRUE,
           estimate.sign=1,
           order.contrasts=TRUE,
           contrasts.none=FALSE,
           level=0.95,
           calpha=NULL,
           method=x$type,
           df,
           vcov.,
           ...
           )

as.glht(x, ...)

## S3 method for class 'multicomp'
as.glht(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.multicomp_+3A_x">x</code></td>
<td>
<p><code>"glht"</code> object for <code>as.multicomp</code>.
A <code>"mmc.multicomp"</code> object for <code>print.mmc.multicomp</code>.

A <code>"multicomp"</code> object for <code>as.glht</code> and <code>print.multicomp</code>.</p>
</td></tr>
<tr><td><code id="as.multicomp_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>

<tr><td><code id="as.multicomp_+3A_focus">focus</code></td>
<td>
<p>name of focus factor.</p>
</td></tr>
<tr><td><code id="as.multicomp_+3A_ylabel">ylabel</code></td>
<td>
<p>response variable name on the graph.</p>
</td></tr>
<tr><td><code id="as.multicomp_+3A_means">means</code></td>
<td>
<p>means of the response variable on the <code>focus</code> factor.</p>
</td></tr>
<tr><td><code id="as.multicomp_+3A_lmat">lmat</code>, <code id="as.multicomp_+3A_lmat.rows">lmat.rows</code></td>
<td>
<p><code><a href="#topic+mmc">mmc</a></code></p>
</td></tr>
<tr><td><code id="as.multicomp_+3A_lmat.scale.abs2">lmat.scale.abs2</code></td>
<td>
<p>logical, almost always <code>TRUE</code>.  If it is
not <code>TRUE</code>, then the contrasts will not be properly placed
on the MMC plot.</p>
</td></tr>
<tr><td><code id="as.multicomp_+3A_estimate.sign">estimate.sign</code></td>
<td>
<p>numeric. 1: force all contrasts to be positive by
reversing negative contrasts. $-1$: force all contrasts to be negative by
reversing positive contrasts.  Leave contrasts as they are constructed
by <code>glht</code>.</p>
</td></tr>
<tr><td><code id="as.multicomp_+3A_order.contrasts">order.contrasts</code>, <code id="as.multicomp_+3A_height">height</code></td>
<td>
<p>logical.  If <code>TRUE</code>, order contrasts by
<code>height</code> (see <code><a href="#topic+mmc">mmc</a></code>).</p>
</td></tr>
<tr><td><code id="as.multicomp_+3A_contrasts.none">contrasts.none</code></td>
<td>
<p>logical.  This is an internal detail.  The
&ldquo;contrasts&rdquo; for the group means are not real contrasts in the
sense they don't compare anything.  <code>mmc.glht</code> sets this
argument to <code>TRUE</code> for the <code>none</code> component.
</p>
</td></tr>
<tr><td><code id="as.multicomp_+3A_level">level</code></td>
<td>
<p>Confidence level.  Defaults to 0.95.</p>
</td></tr>
<tr><td><code id="as.multicomp_+3A_calpha">calpha</code></td>
<td>
<p>R only.  User-specified critical point.
See
<code><a href="multcomp.html#topic+methods">confint.glht</a></code>.
</p>
</td></tr>
<tr><td><code id="as.multicomp_+3A_df">df</code>, <code id="as.multicomp_+3A_vcov.">vcov.</code></td>
<td>
<p>R only.  Arguments forwarded through <code>glht</code> to
<code><a href="multcomp.html#topic+modelparm">modelparm</a></code>.
</p>
</td></tr>
<tr><td><code id="as.multicomp_+3A_method">method</code></td>
<td>
<p>R only.  See <code>type</code> in
<code><a href="multcomp.html#topic+methods">confint.glht</a></code>.
</p>
</td></tr>
<tr><td><code id="as.multicomp_+3A_width.cutoff">width.cutoff</code></td>
<td>
<p>See <code><a href="base.html#topic+deparse">deparse</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>mmc.multicomp</code> <code>print</code>
method displays the confidence intervals and heights on the
MMC plot for each component of the <code>mmc.multicomp</code> object.
</p>
<p><code>print.multicomp</code> displays the confidence intervals and heights for
a single component.
</p>


<h3>Value</h3>

<p><code>as.multicomp</code> is a generic function to change its argument to a
<code>"multicomp"</code> object.
</p>
<p><code>as.multicomp.glht</code> changes an <code>"glht"</code> object to a
<code>"multicomp"</code> object.  If the model component of the argument <code>"x"</code>
is an <code>"aov"</code> object then the standard error is taken from the
<code>anova(x$model)</code> table, otherwise from the <code>summary(x)</code>.
With a large number of levels for the focus factor, the
<code>summary(x)</code>
function is exceedingly slow (80 minutes for 30 levels on 1.5GHz Windows
XP).
For the same example, the <code>anova(x$model)</code> takes a fraction of
a second.</p>


<h3>Note</h3>

<p>The multiple comparisons calculations in R and S-Plus use
completely different functions.
MMC plots in R are based on
<code><a href="multcomp.html#topic+glht">glht</a></code>.
</p>
<p>MMC plots in S-Plus are based on
<code>multicomp</code>.
</p>
<p>The MMC plot is the same in both systems.  The details of gettting the
plot differ.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>
<p>Heiberger, Richard M. and Holland, Burt (2006).
&quot;Mean&ndash;mean multiple comparison displays for families of linear contrasts.&quot;
<em>Journal of Computational and Graphical Statistics</em>, 15:937&ndash;955.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmc">mmc</a></code>,
<code><a href="multcomp.html#topic+glht">glht</a></code>.
</p>

<hr>
<h2 id='as.vector.trellis'>
Convert a two-dimensional trellis object into a one-dimensional trellis object.
Change the order of panels in a trellis object.
</h2><span id='topic+as.vector.trellis'></span><span id='topic+reorder.trellis'></span>

<h3>Description</h3>

<p><code>as.vector.trellis</code> converts a two-dimensional trellis object into
a one-dimensional trellis object.
<code>reorder.trellis</code> changes the order of the <code>panel.args</code> component in a trellis object.
These are are mostly used as utilities by <code><a href="#topic+matrix.trellis">matrix.trellis</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trellis'
as.vector(x, mode = "any")
## S3 method for class 'trellis'
reorder(x, X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.vector.trellis_+3A_x">x</code></td>
<td>

<p><code>trellis</code> object.
</p>
</td></tr>
<tr><td><code id="as.vector.trellis_+3A_mode">mode</code></td>
<td>

<p>We are hijacking the <code>mode</code> argument.  It is used here for the
names of the panels.
</p>
</td></tr>
<tr><td><code id="as.vector.trellis_+3A_...">...</code></td>
<td>

<p>Other arguments are ignored.
</p>
</td></tr>
<tr><td><code id="as.vector.trellis_+3A_x">X</code></td>
<td>

<p>Subscript vector specifying the new order of the panels.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>trellis object with <code>length(dim(x)) == 1</code>.
<code>as.vector</code> retains the original order of the
panels. <code>reorder</code> changes the order to the one specified by using
the <code>X</code> argument as a subscript.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- data.frame(a=letters[c(1:3,1:3,1:3)],
                  b=1:9,
                  d=1:9,
                  e=LETTERS[c(4,4,4,5,5,5,6,6,6)])
tmp
a6 &lt;- xyplot(b ~ d | a*e, data=tmp, pch=19)
a6
dim(a6)
a62 &lt;- as.vector(a6)
a62
dim(a62)
a63 &lt;- reorder(a6, c(1,4,7, 2,5,8, 3,6,9))
a63
dim(a63)
a64 &lt;- matrix.trellis(a63, nrow=3, ncol=3, dimnames=dimnames(a6), byrow=TRUE)
a64
dim(a64)
</code></pre>

<hr>
<h2 id='axis.i2wt'>specialized axis function for interaction2wt.</h2><span id='topic+axis.i2wt'></span>

<h3>Description</h3>

<p>Labels the bottom axis with the x-factor name for each column.
Labels the right axis with the response variable name in all rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axis.i2wt(side, scales, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axis.i2wt_+3A_side">side</code>, <code id="axis.i2wt_+3A_scales">scales</code>, <code id="axis.i2wt_+3A_...">...</code></td>
<td>
<p>See <code><a href="lattice.html#topic+axis.default">axis.default</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard M. Heiberger, with asssistance from Deepayan Sarkar.</p>


<h3>See Also</h3>

<p><code><a href="#topic+interaction2wt">interaction2wt</a></code></p>

<hr>
<h2 id='bivariateNormal'>
Plot the bivariate normal density using wireframe for specified rho.
</h2><span id='topic+bivariateNormal'></span>

<h3>Description</h3>

<p>Plot the bivariate normal density using wireframe for specified rho.
There is a shiny app that allows this to be done dynamically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bivariateNormal(rho = 0, layout = c(3, 3), lwd = 0.2,
                angle = c(22.5, 67.5, 112.5, 337.5, 157.5, 292.5, 247.5, 202.5),
                col.regions = trellis.par.get("regions")$col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bivariateNormal_+3A_rho">rho</code></td>
<td>

<p>Correlation between $x$ and $y$.
</p>
</td></tr>
<tr><td><code id="bivariateNormal_+3A_layout">layout</code>, <code id="bivariateNormal_+3A_lwd">lwd</code></td>
<td>

<p>Standard <span class="pkg">lattice</span> arguments.
</p>
</td></tr>
<tr><td><code id="bivariateNormal_+3A_angle">angle</code></td>
<td>

<p>This is used as the <code>z</code> component of the <code>screen</code> argument to
<code><a href="lattice.html#topic+panel.cloud">panel.wireframe</a></code>.
</p>
</td></tr>
<tr><td><code id="bivariateNormal_+3A_col.regions">col.regions</code>, <code id="bivariateNormal_+3A_...">...</code></td>
<td>

<p>See <code><a href="lattice.html#topic+cloud">wireframe</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default setting shows the view as seen from a series of eight angles.
To see just a single view, see the example.
</p>


<h3>Value</h3>

<p><code>"trellis"</code> object.
</p>


<h3>Note</h3>

<p>Based on the <code>galaxy</code> example on pages 204&ndash;205 in
<em>S &amp; S-PLUS Trellis Graphics User's Manual</em>,
Richard A. Becker and William S. Cleveland (1996),
<a href="https://www.stat.auckland.ac.nz/~ihaka/courses/120/trellis.user.pdf">https://www.stat.auckland.ac.nz/~ihaka/courses/120/trellis.user.pdf</a> 
</p>


<h3>Author(s)</h3>

<p>Richard M. Heiberger (rmh@temple.edu)</p>


<h3>Examples</h3>

<pre><code class='language-R'>bv8 &lt;- bivariateNormal(.7)  ## all views on one page
bv8
update(bv8[3], layout=c(1,1)) ## one panel
## Not run: 
  if (interactive())
    shiny::runApp(file.path(system.file(package="HH"), "shiny/bivariateNormal")) ## 3D
  if (interactive())
    shiny::runApp(system.file("shiny/bivariateNormalScatterplot", package="HH")) ## scatterplot

## End(Not run)
</code></pre>

<hr>
<h2 id='ci.plot'>Plot confidence and prediction intervals for simple linear regression</h2><span id='topic+ci.plot'></span><span id='topic+ci.plot.lm'></span>

<h3>Description</h3>

<p>The data, the least squares line, the confidence interval lines, and the
prediction interval lines for a simple
linear regression (<code>lm(y ~ x)</code>) are displayed.  Tick marks are
placed at the location of xbar, the x-value of the narrowest interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci.plot(lm.object, ...)

## S3 method for class 'lm'
ci.plot(lm.object,
        xlim=range(data[, x.name]),
        newdata,
        conf.level=.95,
        data=model.frame(lm.object),
        newfit,
        ylim,
        pch=19,
        lty=c(1,3,4,2),
        lwd=2,
        main.cex=1,
        main=list(paste(100*conf.level,
          "% confidence and prediction intervals for ",
          substitute(lm.object), sep=""), cex=main.cex), ...
        )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci.plot_+3A_lm.object">lm.object</code></td>
<td>
<p>Linear model for one <code>y</code> and one <code>x</code> variable.</p>
</td></tr>
<tr><td><code id="ci.plot_+3A_xlim">xlim</code></td>
<td>
<p><code>xlim</code> for plot.  Default is based on data from which
<code>lm.object</code> was constructed.</p>
</td></tr>
<tr><td><code id="ci.plot_+3A_newdata">newdata</code></td>
<td>
<p><code>data.frame</code> containing data for which predictions
are wanted.  The variable name of the column must be identical to
the name of the predictor variable in the model object.
Defaults to a data.frame containing a vector
spanning the range of observed data.  User-specified values are
appended to the default vector.</p>
</td></tr>
<tr><td><code id="ci.plot_+3A_conf.level">conf.level</code></td>
<td>
<p>Confidence level for intervals, defaults to <code>.95</code></p>
</td></tr>
<tr><td><code id="ci.plot_+3A_data">data</code></td>
<td>
<p><code>data</code> extracted from the <code>lm.object</code></p>
</td></tr>
<tr><td><code id="ci.plot_+3A_newfit">newfit</code></td>
<td>
<p>Constructed <code>data.frame</code> containing the
predictions,confidence interval, and prediction interval
for the <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="ci.plot_+3A_ylim">ylim</code></td>
<td>
<p><code>ylim</code> for plot.  Default is based on the
constructed prediction interval.</p>
</td></tr>
<tr><td><code id="ci.plot_+3A_pch">pch</code></td>
<td>
<p>Plotting character for observed points.</p>
</td></tr>
<tr><td><code id="ci.plot_+3A_lty">lty</code>, <code id="ci.plot_+3A_lwd">lwd</code></td>
<td>
<p>Line types and line width for fit and intervals.</p>
</td></tr>
<tr><td><code id="ci.plot_+3A_main.cex">main.cex</code></td>
<td>
<p>Font size for main title.</p>
</td></tr>
<tr><td><code id="ci.plot_+3A_main">main</code></td>
<td>
<p>Main title for plot</p>
</td></tr>
<tr><td><code id="ci.plot_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to panel function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"trellis"</code> object containing the plot.
</p>


<h3>Note</h3>

<p>The <code>predict.lm</code> functions in S-Plus and R differ.
The S-Plus function can produce both confidence and prediction
intervals with a single call.  The R function produces only one
of them in a single call.  Therefore the default calculation of
<code>newfit</code> within the function depends on the system.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+predict.lm">predict.lm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- data.frame(x=rnorm(20), y=rnorm(20))
tmp.lm &lt;- lm(y ~ x, data=tmp)
ci.plot(tmp.lm)
</code></pre>

<hr>
<h2 id='CIplot'>
Illustration of the meaning of confidence levels.
</h2><span id='topic+CIplot'></span><span id='topic+confintervaldata'></span><span id='topic+confinterval.matrix'></span><span id='topic+confintervalplot'></span><span id='topic+shiny.CIplot'></span>

<h3>Description</h3>

<p>Illustration of the meaning of confidence levels.  Generate sets of
confidence intervals for independent randomly generated sets of normally
distributed numbers.  Low confidence levels give narrow intervals that
are less likely to bracket the true value.  Higher confidence levels
increase the probability of bracketing the true value, and are also much
wider and therefore less precise.  The shiny app can animate how the
increase in confidence level and width leads to a consequent decrease in
precision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CIplot(n.intervals = 100,
       n.per.row = 40,
       pop.mean = 0,
       pop.sd = 1,
       conf.level = 0.95,
       ...)

confintervaldata(n.intervals = 100,
                 n.per.row = 40,
                 pop.mean = 0,
                 pop.sd = 1,
                 conf.level = 0.95,
                 seed,
                 ...)

confinterval.matrix(x,
                    conf.level = attr(x, "conf.level"),
                    ...)

confintervalplot(x.ci,
                 n.intervals = nrow(x.ci),
                 pop.mean = attr(x.ci, "pop.mean"),
                 pop.sd = attr(x.ci, "pop.sd"),
                 n.per.row = attr(x.ci, "n.per.row"),
                 xlim, ylim, ...)

shiny.CIplot(height = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CIplot_+3A_n.intervals">n.intervals</code></td>
<td>

<p>Number of sets of observations to generate.
Each set leads to one confidence interval on the plot.
</p>
</td></tr>
<tr><td><code id="CIplot_+3A_n.per.row">n.per.row</code></td>
<td>

<p>Number of observations in each set.
</p>
</td></tr>
<tr><td><code id="CIplot_+3A_pop.mean">pop.mean</code>, <code id="CIplot_+3A_pop.sd">pop.sd</code></td>
<td>

<p>Population mean and standard deviation for generated set of
<code>n.per.row</code> independent normally distributed random numbers.
</p>
</td></tr>
<tr><td><code id="CIplot_+3A_conf.level">conf.level</code></td>
<td>

<p>Confidence level of each of the <code>n.per.row</code> confidence intervals
calculated from the generated datasets.
</p>
</td></tr>
<tr><td><code id="CIplot_+3A_seed">seed</code></td>
<td>
<p>Standard argument to <code><a href="stats.html#topic+Normal">rnorm</a></code>.</p>
</td></tr>
<tr><td><code id="CIplot_+3A_x">x</code></td>
<td>
<p>Output matrix from <code>confintervaldata</code>.</p>
</td></tr>
<tr><td><code id="CIplot_+3A_x.ci">x.ci</code></td>
<td>
<p>Output <code>data.frame</code> from <code>confinterval.matrix</code>.</p>
</td></tr>
<tr><td><code id="CIplot_+3A_xlim">xlim</code>, <code id="CIplot_+3A_ylim">ylim</code></td>
<td>
<p>Standard <code><a href="lattice.html#topic+xyplot">xyplot</a></code> arguments.</p>
</td></tr>
<tr><td><code id="CIplot_+3A_height">height</code></td>
<td>
<p>Height of graph on web page in pixels.</p>
</td></tr>
<tr><td><code id="CIplot_+3A_...">...</code></td>
<td>

<p>Additional arguments.  For <code>CIplot</code>,  <code>seed</code> will be forwarded
to <code>confintervaldata</code>, and <code>xlim</code> and <code>ylim</code> will be
forwarded to <code>confintervalplot</code>.  Any other additional arguments
will be ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The shiny app has sliders for the <code>n.intervals</code>, <code>n.per.row</code>,
<code>pop.mean</code>, <code>pop.sd</code>, and <code>conf.level</code>.
Changes in the <code>conf.level</code> slider, either manually by animation,
use the same set of generated data to show how increasing the confidence
level increases the width of the confidence interval and consequently
decreases the precision of the interval estimator.
</p>


<h3>Value</h3>

<p><code>CIplot</code> and <code>confintervalplot</code> return a <code>"trellis"</code>
plot containing a plot of Confidence Intervals.
</p>
<p><code>confintervaldata</code> returns a matrix of <code>n.intervals</code> rows by
<code>n.per.row</code> columns of independent normally distributed random
numbers.
The matrix has a set of attributes recording the arguments to the
function.
</p>
<p><code>confinterval.matrix</code> returns a <code>data.frame</code> of  <code>n.intervals</code>
with three columns containing the lower bound, center, and upper bound
of the confidence interval for each row of its input matrix.
The <code>data.frame</code> has a set of attributes recording the arguments to the
function.
</p>
<p><code>shiny.CIplot</code> returns a shiny app object which, when printed,
runs a shiny app displaying the Confidence Interval plot and several
slider controls.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A. from the console

## example 1
CIplot()

## example 2
## Not run: 
CIplot(n.intervals=100,
       n.per.row=40,
       pop.mean=0,
       pop.sd=1,
       conf.level=.95)

## End(Not run)

## example 3
## Not run: 
tmp.data &lt;- confintervaldata()
tmp.ci &lt;- confinterval.matrix(tmp.data)
confintervalplot(tmp.ci)

## End(Not run)

## example 4
## Not run: 
tmp.data &lt;- confintervaldata(n.intervals=100,
                             n.per.row=40,
                             pop.mean=0,
                             pop.sd=1,
                             conf.level=.95)
tmp.ci &lt;- confinterval.matrix(tmp.data)
confintervalplot(tmp.ci)

## End(Not run)


## B. shiny, initiated from the console

## example 5
## Not run: 
  if (interactive())
    shiny.CIplot()

## End(Not run)

## example 6
## Not run: 
  if (interactive())
    shiny.CIplot(height=800)  ## px
  ## take control of the height of the graph in the web page

## End(Not run)
</code></pre>

<hr>
<h2 id='col.hh'>Initializing Trellis Displays</h2><span id='topic+col.hh'></span>

<h3>Description</h3>

<p>Initialization of an R display device with the graphical
parameters that rmh prefers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col.hh()
</code></pre>


<h3>Value</h3>

<p>List of graphical parameters to be used in the <code>theme</code> argument
to the <code>trellis.device</code> or <code>trellis.par.set</code> functions.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+trellis.device">trellis.device</a></code>, <code><a href="lattice.html#topic+trellis.par.get">trellis.par.get</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
trellis.device(theme="col.hh") ## Open a device with the theme

trellis.device(theme=col.hh()) ## Open a device with the theme

trellis.par.set(theme=col.hh())## Add theme to already open device

## End(Not run)
</code></pre>

<hr>
<h2 id='col3x2'>
col3x2 color dataset
</h2><span id='topic+col3x2'></span>

<h3>Description</h3>

<p>col3x2 color dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("col3x2")</code></pre>


<h3>Format</h3>

<p>The format is:
chr [1:6] &quot;#1B9E77&quot; &quot;#D95F02&quot; &quot;#7570B3&quot; &quot;#66C2A5&quot; &quot;#FC8D62&quot; &quot;#8DA0CB&quot;
</p>


<h3>Details</h3>

<p>3x2 color scheme.
These colors look like a 3x2 color array when run through
the vischeck simulator to see how they look for the three most
common color vision deficiencies: Deuteranope, Protanope, Tritanope.
</p>


<h3>References</h3>

<p>About 10% of the population have color deficient vision.
Your job is make your graphs legible to everyone.
Download <code>ImageJ</code> from <code>https://imagej.net/Downloads</code> and
<code>VischeckJ</code> from
<a href="http://vischeck.com">http://vischeck.com</a> and follow the instructions in those sites.
This program will allow you to simulate color deficient vision on your computer.
</p>
<p>On my Mac, I need to doubleclick ij.jar to open the program.  Then open
the &quot;Vischeck Panel&quot; on the Plugins menu and navigate to a png file with
the &quot;File Open&quot; menu.  Click on each of the three types of color
deficiency.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(col3x2)
col3x2

## Not run: 
library(RColorBrewer)
library(lattice)
col3x2 &lt;- c(brewer.pal(n=3, "Dark2"), brewer.pal(n=3, "Set2"))
col3x2
## save(col3x2, file="col3x2.rda") ## data(col3x2, package="HH")

## End(Not run)

## Not run: 
barchart(~ 1:6, col=col3x2, lwd=0, origin=0, horizontal=FALSE,
         scales=list(x=list(at=1:6, labels=col3x2)))


tmp &lt;- array(c(1, rep(0,6)), c(1,3,2,6),
             dimnames=list("",
                           c("green","orange","blue"),
                           c("Dark2","Set2"),
                           col3x2))

useOuterStrips(barchart(tmp, col=col3x2,
                        between=list(x=1, y=1),
                        scales=list(x=list(at=-1)),
                        main="col3x2", xlab="")) +
  layer(panel.text(x=.5, y=1.45, labels=col3x2[panel.number()]))


## End(Not run)
</code></pre>

<hr>
<h2 id='combineLimits.trellisvector'>
Combine limits on a one-dimensional trellis object.
</h2><span id='topic+combineLimits.trellisvector'></span>

<h3>Description</h3>

<p>Combine limits on a one-dimensional trellis object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineLimits.trellisvector(x, margin.x = 1:2, margin.y = 1:2,
                            layout = x$layout,
                            ncol=x$layout[1], nrow=x$layout[2],
                            condlevels = x$condlevels[[1]], ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineLimits.trellisvector_+3A_x">x</code></td>
<td>

<p><code>trellis</code> object.
</p>
</td></tr>
<tr><td><code id="combineLimits.trellisvector_+3A_margin.x">margin.x</code>, <code id="combineLimits.trellisvector_+3A_margin.y">margin.y</code></td>
<td>

<p>See <code><a href="latticeExtra.html#topic+combineLimits">combineLimits</a></code>.
</p>
</td></tr>
<tr><td><code id="combineLimits.trellisvector_+3A_layout">layout</code></td>
<td>

<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="combineLimits.trellisvector_+3A_condlevels">condlevels</code></td>
<td>

<p>Character.  Names of each panel of the result.  Defaults to the names
of the panels of the argument.
</p>
</td></tr>
<tr><td><code id="combineLimits.trellisvector_+3A_...">...</code></td>
<td>

<p>Other arguments are ignored.
</p>
</td></tr>
<tr><td><code id="combineLimits.trellisvector_+3A_nrow">nrow</code>, <code id="combineLimits.trellisvector_+3A_ncol">ncol</code></td>
<td>

<p>See <code><a href="#topic+matrix.trellis">matrix.trellis</a></code>.  These arguments default to the levels
of <code>x$layout</code> if it is non-null.
Otherwise <code>nrow==1</code> and ncol==<code>dim(x)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The one-dimensional object is converted to a two-dimensional object
which
is forwarded to the standard <code>combineLimits</code> function.  The result
is converted back to a one-dimensional object.
</p>


<h3>Value</h3>

<p>One-dimensional trellis object with combined xlim and ylim values across
all panels.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="latticeExtra.html#topic+combineLimits">combineLimits</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- data.frame(a=1:3,
                  b=c(4,5,7),
                  c=5:7,
                  d=c(8, 9, 12),
                  e=9:11)
tmp

a2 &lt;- xyplot(a + b ~ c + d + e, data=tmp, outer=TRUE,
             scales=list(relation="free"), main="a2")
a2
dim(a2)
combineLimits.trellisvector(a2)
a21 &lt;- combineLimits.trellisvector(update(a2, layout=c(3,2)))
a21
dim(a21)
</code></pre>

<hr>
<h2 id='cp.calc'> Rearranges and improves the legibility of the output from
the stepwise function in S-Plus.  </h2><span id='topic+cp.calc'></span><span id='topic+print.cp.object'></span><span id='topic++5B.cp.object'></span>

<h3>Description</h3>

<p>Rearranges and improves the legibility of the output from
the
<code>stepwise</code>
</p>
<p>function in S-Plus.
The output can be used for the Cp plot.
<code>cp.calc</code> works only in S-Plus.
Use
<code><a href="leaps.html#topic+regsubsets">regsubsets</a></code>
</p>
<p>in R.  The example below works in
both languages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cp.calc(sw, data, y.name)

## S3 method for class 'cp.object'
print(x, ...)

## S3 method for class 'cp.object'
x[..., drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cp.calc_+3A_sw">sw</code></td>
<td>
<p>Output from the S-Plus
<code>stepwise</code>
</p>
<p>function.</p>
</td></tr>
<tr><td><code id="cp.calc_+3A_data">data</code></td>
<td>
<p>Dataset name from which <code>"sw"</code> was calculated.</p>
</td></tr>
<tr><td><code id="cp.calc_+3A_y.name">y.name</code></td>
<td>
<p>Name of response variable for which <code>"sw"</code> was calculated.</p>
</td></tr>
<tr><td><code id="cp.calc_+3A_x">x</code></td>
<td>
<p>Object of class <code>"cp.object"</code>. </p>
</td></tr>
<tr><td><code id="cp.calc_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>"["</code> or <code>"print"</code>.</p>
</td></tr>
<tr><td><code id="cp.calc_+3A_drop">drop</code></td>
<td>
<p>Argument to the <code>print</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"cp.object"</code>, which is a data.frame containing information
about each model that was attempted with additional
attributes:
<code>tss</code> total sum of squares,
<code>n</code> number of observations,
<code>y.name</code> response variable,
<code>full.i</code> row name of full model.  The columns are
</p>
<table>
<tr><td><code>p</code></td>
<td>
<p>number of parameters in the model</p>
</td></tr>
<tr><td><code>cp</code></td>
<td>
<p>Cp statistic</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC statistic</p>
</td></tr>
<tr><td><code>rss</code></td>
<td>
<p>Residual sum of squares</p>
</td></tr>
<tr><td><code>r2</code></td>
<td>
<p><code class="reqn">R^2</code></p>
</td></tr>
<tr><td><code>r2.adj</code></td>
<td>
<p>Adjusted <code class="reqn">R^2</code></p>
</td></tr>
<tr><td><code>xvars</code></td>
<td>
<p>X variables</p>
</td></tr>
<tr><td><code>sw.names</code></td>
<td>
<p>Model name produced by <code>stepwise</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This example is from Section 9.15 of Heiberger and Holland (2004).
data(usair)
if.R(s={usair &lt;- usair}, r={})

splom(~usair, main="U.S. Air Pollution Data with SO2 response", cex=.5)
## export.eps(hh("regb/figure/regb.f1.usair.eps"))

usair$lnSO2 &lt;- log(usair$SO2)
usair$lnmfg &lt;- log(usair$mfgfirms)
usair$lnpopn &lt;- log(usair$popn)

usair[1:3,]   ## lnSO2 is in position 8, SO2 is in position 1
              ## lnmfg is in position 9, lnpopn is in position 10

splom(~usair[, c(8,2,9,10,5:7)],
              main="U.S. Air Pollution Data with 3 log-transformed variables",
              cex=.5)
## export.eps(hh("regb/figure/regb.f2.usair.eps"))

if.R(s={
  usair.step &lt;- stepwise(y=usair$lnSO2,
                         x=usair[, c(2,9,10,5:7)],
                         method="exhaustive",
                         plot=FALSE, nbest=2)
  ## print for pedagogical purposes only.  The plot of cp ~ p is more useful.
  ## The line with rss=1e35 is a stepwise() bug, that we reported to S-Plus.
  print(usair.step, digits=4)
  usair.cp &lt;- cp.calc(usair.step, usair, "lnSO2")
  ## print for pedagogical purposes only.  The plot of cp ~ p is more useful.
  usair.cp
  tmp &lt;- (usair.cp$cp &lt;= 10)
  usair.cp[tmp,]

  old.par &lt;- par(mar=par()$mar+c(0,1,0,0))
  tmp &lt;- (usair.cp$cp &lt;= 10)
  plot(cp ~ p, data=usair.cp[tmp,], ylim=c(0,10), type="n", cex=1.3)
  abline(b=1)
  text(x=usair.cp$p[tmp], y=usair.cp$cp[tmp],
       row.names(usair.cp)[tmp], cex=1.3)
  title(main="Cp plot for usair.dat, Cp&lt;10")
  par(old.par)
## export.eps(hh("regb/figure/regb.f3.usair.eps"))
},r={
  usair.regsubset &lt;- leaps::regsubsets(lnSO2~lnmfg+lnpopn+precip+raindays+temp+wind,
                                       data=usair, nbest=2)
  usair.subsets.Summary &lt;- summaryHH(usair.regsubset)
  tmp &lt;- (usair.subsets.Summary$cp &lt;= 10)
  usair.subsets.Summary[tmp,]
  plot(usair.subsets.Summary[tmp,], statistic='cp', legend=FALSE)

  usair.lm7 &lt;- lm.regsubsets(usair.regsubset, 7)
  anova(usair.lm7)
  summary(usair.lm7)
})

vif(lnSO2 ~ temp + lnmfg + lnpopn + wind + precip + raindays, data=usair)

vif(lnSO2 ~ temp + lnmfg + wind + precip, data=usair)

usair.lm &lt;- lm(lnSO2 ~ temp + lnmfg + wind + precip, data=usair)
anova(usair.lm)
summary(usair.lm, corr=FALSE)
</code></pre>

<hr>
<h2 id='cplx'>
Generate a sequence spanning the xlim of a lattice window.
</h2><span id='topic+cplx'></span>

<h3>Description</h3>

<p>Generate a sequence of <code>length</code> points spanning the
<code>current.panel.limits()$xlim</code> of a lattice window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cplx(length)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cplx_+3A_length">length</code></td>
<td>

<p>Integer number of points.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One-column matrix containing <code>length</code> rows.
The first value is the x-value at the left side of the window.  The
last value is the x-value at the right side of the window.
The in between points are evenly spaced.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scale">scale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cplx(11)
</code></pre>

<hr>
<h2 id='datasets'>Datasets for Statistical Analysis and Data Display, Heiberger and
Holland</h2><span id='topic+datasets'></span><span id='topic+AEdata'></span><span id='topic+AudiencePercent'></span><span id='topic+Design_2.8_2'></span><span id='topic+Design_2.8_2_full'></span><span id='topic+NZScienceTeaching'></span><span id='topic+PoorChildren'></span><span id='topic+ProfChal'></span><span id='topic+ProfDiv'></span><span id='topic+SFF8121'></span><span id='topic+abc'></span><span id='topic+abrasion'></span><span id='topic+acacia'></span><span id='topic+aeanonym'></span><span id='topic+animal'></span><span id='topic+anneal'></span><span id='topic+apple'></span><span id='topic+ara'></span><span id='topic+balance'></span><span id='topic+barleyp'></span><span id='topic+batch'></span><span id='topic+bean'></span><span id='topic+birthweight'></span><span id='topic+blood'></span><span id='topic+blyth'></span><span id='topic+breast'></span><span id='topic+budworm'></span><span id='topic+byss'></span><span id='topic+c3c4'></span><span id='topic+catalystm'></span><span id='topic+cc135'></span><span id='topic+cc176'></span><span id='topic+cement'></span><span id='topic+census4'></span><span id='topic+cereals'></span><span id='topic+chimp'></span><span id='topic+circuit'></span><span id='topic+co2'></span><span id='topic+concord'></span><span id='topic+crash'></span><span id='topic+crime'></span><span id='topic+darwin'></span><span id='topic+diamond'></span><span id='topic+display'></span><span id='topic+distress'></span><span id='topic+draft'></span><span id='topic+draft70mn'></span><span id='topic+drunk'></span><span id='topic+eggs'></span><span id='topic+elnino'></span><span id='topic+employM16'></span><span id='topic+energy'></span><span id='topic+esr'></span><span id='topic+fabricwear'></span><span id='topic+fat.dat'></span><span id='topic+fat'></span><span id='topic+feed'></span><span id='topic+filmcoat'></span><span id='topic+filter'></span><span id='topic+fruitflies'></span><span id='topic+furnace'></span><span id='topic+girlht'></span><span id='topic+glasses'></span><span id='topic+golf'></span><span id='topic+gum'></span><span id='topic+gunload'></span><span id='topic+har1'></span><span id='topic+har2'></span><span id='topic+har3'></span><span id='topic+hardness'></span><span id='topic+heartvalve'></span><span id='topic+hooppine'></span><span id='topic+hospital'></span><span id='topic+hotdog'></span><span id='topic+houseprice'></span><span id='topic+hpErie'></span><span id='topic+htwt'></span><span id='topic+iceskate'></span><span id='topic+icu'></span><span id='topic+income'></span><span id='topic+inconsistent'></span><span id='topic+intubate'></span><span id='topic+ironpot'></span><span id='topic+kangaroo'></span><span id='topic+kidney'></span><span id='topic+kyphosis'></span><span id='topic+jury'></span><span id='topic+lake'></span><span id='topic+leukemia'></span><span id='topic+lft.asat'></span><span id='topic+lifeins'></span><span id='topic+longley'></span><span id='topic+lymph'></span><span id='topic+maiz'></span><span id='topic+manhours'></span><span id='topic+market'></span><span id='topic+mice'></span><span id='topic+mileage'></span><span id='topic+mortality'></span><span id='topic+mpg'></span><span id='topic+muscle'></span><span id='topic+njgolf'></span><span id='topic+normtemp'></span><span id='topic+notch'></span><span id='topic+oats'></span><span id='topic+odoffna'></span><span id='topic+operator'></span><span id='topic+oral'></span><span id='topic+ozone'></span><span id='topic+paper'></span><span id='topic+patient'></span><span id='topic+plasma'></span><span id='topic+political'></span><span id='topic+potency'></span><span id='topic+pox'></span><span id='topic+product'></span><span id='topic+psycho'></span><span id='topic+pulmonary'></span><span id='topic+pulse'></span><span id='topic+R282'></span><span id='topic+R282.y'></span><span id='topic+radioact'></span><span id='topic+rent'></span><span id='topic+retard'></span><span id='topic+rhiz.alfalfa'></span><span id='topic+rhiz.clover'></span><span id='topic+rhizobium1'></span><span id='topic+rhizobium3'></span><span id='topic+salary'></span><span id='topic+salinity'></span><span id='topic+salk'></span><span id='topic+seeding'></span><span id='topic+selfexam'></span><span id='topic+shipment'></span><span id='topic+sickle'></span><span id='topic+skateslc'></span><span id='topic+smokers'></span><span id='topic+spacshu'></span><span id='topic+spindle'></span><span id='topic+sprint'></span><span id='topic+stopdist'></span><span id='topic+surface'></span><span id='topic+tablet1'></span><span id='topic+teachers'></span><span id='topic+testing'></span><span id='topic+testscore'></span><span id='topic+tires'></span><span id='topic+tongue'></span><span id='topic+tser.mystery.X'></span><span id='topic+tser.mystery.Y'></span><span id='topic+tser.mystery.Z'></span><span id='topic+tsq'></span><span id='topic+turkey'></span><span id='topic+tv'></span><span id='topic+usair'></span><span id='topic+uscrime'></span><span id='topic+vocab'></span><span id='topic+vulcan'></span><span id='topic+washday'></span><span id='topic+water'></span><span id='topic+weightloss'></span><span id='topic+weld'></span><span id='topic+wheat'></span><span id='topic+wool'></span><span id='topic+workstation'></span><span id='topic+yates'></span><span id='topic+yatesppl'></span>

<h3>Description</h3>

<p>Most of the datasets are described in the book <em>Statistical Analysis and Data
Display</em>.
</p>
<p>For <code>ProfChal</code>, see <code><a href="#topic+plot.likert">plot.likert</a></code>.
</p>
<p><code>AudiencePercent</code> is from personal communication by the market
researcher who did the study.
</p>
<p><code>SFF8121</code> is student evaluations of my class compared to the
average of all graduate classes in the Spring 2010 semester.
Personal communication from the Temple University
Office of the Provost to me.
</p>
<p><code>ProfDiv</code> is &quot;Profit-and-Dividend Status of 348 Corportations in
the United States for the period from 1929 to 1935&quot; from
Brinton WC (1939),
<em>Graphic Presentation</em>.
Brinton Associates.
<a href="http://www.archive.org/details/graphicpresentat00brinrich">http://www.archive.org/details/graphicpresentat00brinrich</a>.
</p>
<p><code>NZScienceTeaching</code> is from
New Zealand Ministry of Research Science and Technology(2006),
&ldquo;Staying in Science.&quot;
This URL is no longer valid.
<code>http://www.morst.govt.nz/Documents/publications/researchreports/Staying-in-Science-summary.pdf</code>.
</p>
<p><code>PoorChildren</code> is from
&ldquo;Poor Children, Working Parents&quot;,
Analysis of data from the CensusBureau's American Community Survey.
Comparison of Census areas of 100,000 or more people,
based on samples from 2005 to 2009.
</p>
<p>Source: Data from the U.S. Census Bureau's American Community Survey;
analysis by Andrew A. Beveridge, QueensCollege.
Copyright 2011 The New York Times Company
</p>
<p><a href="https://archive.nytimes.com/www.nytimes.com/imagepages/2011/12/03/opinion/03blow-ch.html?ref=opinion">https://archive.nytimes.com/www.nytimes.com/imagepages/2011/12/03/opinion/03blow-ch.html?ref=opinion</a>
</p>
<p><a href="https://www.nytimes.com/2011/12/03/opinion/blow-newts-war-on-poor-children.html?_r=1">https://www.nytimes.com/2011/12/03/opinion/blow-newts-war-on-poor-children.html?_r=1</a>
</p>
<p>Naomi Robbins and I discuss the PoorChildren example in the Forbes online column:
<a href="https://www.forbes.com/sites/naomirobbins/2011/12/20/alternative-to-charles-blows-figure-in-newts-war-on-poor-children-2/">https://www.forbes.com/sites/naomirobbins/2011/12/20/alternative-to-charles-blows-figure-in-newts-war-on-poor-children-2/</a>
<code>demo(PoorChildren, package="HH")</code>
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>

<hr>
<h2 id='dchisq.intermediate'>Intermediate f and chisq functions to simplify writing
for both R and S-Plus.</h2><span id='topic+dchisq.intermediate'></span><span id='topic+pchisq.intermediate'></span><span id='topic+qchisq.intermediate'></span><span id='topic+df.intermediate'></span><span id='topic+pf.intermediate'></span><span id='topic+qf.intermediate'></span>

<h3>Description</h3>

<p>Intermediate f and chisq functions to simplify writing for both R and S-Plus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dchisq.intermediate(x, df, ncp=0, log=FALSE)
pchisq.intermediate(q, df, ncp=0, lower.tail=TRUE, log.p=FALSE)
qchisq.intermediate(p, df, ncp=0, lower.tail=TRUE, log.p=FALSE)
df.intermediate(x, df1, df2, ncp=0, log=FALSE)
pf.intermediate(q, df1, df2, ncp=0, lower.tail=TRUE, log.p=FALSE)
qf.intermediate(p, df1, df2, ncp=0, lower.tail=TRUE, log.p=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dchisq.intermediate_+3A_x">x</code>, <code id="dchisq.intermediate_+3A_p">p</code>, <code id="dchisq.intermediate_+3A_q">q</code>, <code id="dchisq.intermediate_+3A_df">df</code>, <code id="dchisq.intermediate_+3A_df1">df1</code>, <code id="dchisq.intermediate_+3A_df2">df2</code>, <code id="dchisq.intermediate_+3A_ncp">ncp</code>, <code id="dchisq.intermediate_+3A_log">log</code>, <code id="dchisq.intermediate_+3A_log.p">log.p</code>, <code id="dchisq.intermediate_+3A_lower.tail">lower.tail</code></td>
<td>
<p>See
<code><a href="stats.html#topic+pchisq">pchisq</a></code> and <code><a href="stats.html#topic+pf">pf</a></code>.  Some arguments
don't exist in S-Plus.  That is why these functions are needed.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>

<hr>
<h2 id='diag.maybe.null'>Returns a value for the diagonal of NA and NULL arguments.</h2><span id='topic+diag.maybe.null'></span>

<h3>Description</h3>

<p>Returns the argument for the diagonal of NA and NULL arguments.
For all other arguments, it calls the regular <code>diag</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag.maybe.null(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag.maybe.null_+3A_x">x</code></td>
<td>
<p>matrix, vector, NA, </p>
</td></tr>
<tr><td><code id="diag.maybe.null_+3A_...">...</code></td>
<td>
<p>Other arguments to <code>diag</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard M. Heiberger (rmh@temple.edu)</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+diag">diag</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diag.maybe.null(NULL)
diag.maybe.null(NA)
diag.maybe.null(1:5)
</code></pre>

<hr>
<h2 id='diagplot5new'>
Transpose of ECDF for centered fitted values and residuals from a linear model.
</h2><span id='topic+diagplot5new'></span>

<h3>Description</h3>

<p>Transpose of ECDF (Empirical CDF) for centered fitted values and residuals from a linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagplot5new(linearmodel, ..., pch = 19)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagplot5new_+3A_linearmodel">linearmodel</code></td>
<td>

<p><code>"lm"</code> object.
</p>
</td></tr>
<tr><td><code id="diagplot5new_+3A_pch">pch</code>, <code id="diagplot5new_+3A_...">...</code></td>
<td>

<p>Arguments to <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation in <code><a href="lattice.html#topic+xyplot">xyplot</a></code>
of the &quot;r-f spread&quot; plot.
</p>


<h3>Value</h3>

<p><code>"trellis"</code> object.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>William Cleveland (1993), <em>Visualizing Data</em>, Hobart Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See ?residVSfitted
## Not run: 
data(fat)
fat.lm &lt;- lm(bodyfat ~ abdomin, data=fat)
diagplot5new(fat.lm)

## End(Not run)
</code></pre>

<hr>
<h2 id='diagQQ'>
QQ plot of regression residuals.
</h2><span id='topic+diagQQ'></span>

<h3>Description</h3>

<p>QQ plot of regression residuals. The <code><a href="lattice.html#topic+panel.qqmathline">panel.qqmathline</a></code> is displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagQQ(lm.object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagQQ_+3A_lm.object">lm.object</code></td>
<td>

<p><code>"lm"</code> object.
</p>
</td></tr>
<tr><td><code id="diagQQ_+3A_...">...</code></td>
<td>

<p>Additional arguments to <code>qqmath</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"trellis"</code> object.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+qqmath">qqmath</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See ?residVSfitted
## Not run: 
data(fat)
fat.lm &lt;- lm(bodyfat ~ abdomin, data=fat)
diagQQ(fat.lm)

## End(Not run)
</code></pre>

<hr>
<h2 id='Discrete4'>
Discrete with four levels color dataset.
</h2><span id='topic+Discrete4'></span>

<h3>Description</h3>

<p>Discrete with four levels color dataset.
These colors look like four distinct colors when run through
the vischeck simulator to see how they look for the three most
common color vision deficiencies: Deuteranope, Protanope, Tritanope.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Discrete4")</code></pre>


<h3>Format</h3>

<p>The format is:
chr [1:4]  &quot;#E31A1C&quot; &quot;#1F78B4&quot; &quot;#FB9A99&quot; &quot;#A6CEE3&quot;
</p>


<h3>Details</h3>

<p>4x1 color scheme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Discrete4)
## Not run: 
library(RColorBrewer)
library(lattice)
Discrete4 &lt;- brewer.pal(n=12, "Paired")[c(6,2,5,1)]
Discrete4
## save(Discrete4, file="Discrete4.rda") ## data(Discrete4, package="HH")
##
barchart(~ 1:4, col=Discrete4, lwd=0, origin=0, horizontal=FALSE,
         xlab="Colors", scales=list(x=list(labels=Discrete4), y=list(labels=NULL)),
         main=paste("These colors look like four distinct colors when run through",
                    "the vischeck simulator to see how they look for the three most",
                    "common color vision deficiencies: Deuteranope, Protanope, Tritanope.",
                    sep="\n"))

## End(Not run)
</code></pre>

<hr>
<h2 id='do.formula.trellis.xysplom'>Interprets model formulas for xysplom and extended bwplots</h2><span id='topic+do.formula.trellis.xysplom'></span>

<h3>Description</h3>

<p>Interprets a model formula in the context of its data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do.formula.trellis.xysplom(formula, data, na.action = na.pass)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do.formula.trellis.xysplom_+3A_formula">formula</code></td>
<td>
<p>model formula</p>
</td></tr>
<tr><td><code id="do.formula.trellis.xysplom_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="do.formula.trellis.xysplom_+3A_na.action">na.action</code></td>
<td>
<p>see <code><a href="stats.html#topic+na.action">na.action</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing three data.frames and three formula, one for each.
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p><code>data.frame</code> containing the variables on the right-hand side
of the model formula.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p><code>data.frame</code> containing the variables on the left-hand side
of the model formula.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p><code>data.frame</code> containing the variables, if any, after
the conditioning bar <code>|</code> of the model formula.</p>
</td></tr>
<tr><td><code>x.formula</code></td>
<td>
<p><code>formula</code> containing the right-hand side
of the model formula.</p>
</td></tr>
<tr><td><code>y.formula</code></td>
<td>
<p><code>formula</code> containing the left-hand side
of the model formula.</p>
</td></tr>
<tr><td><code>g.formula</code></td>
<td>
<p><code>formula</code> containing the formula after the
conditioning bar <code>|</code> of the model formula.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+formula">formula</a></code>, <code><a href="stats.html#topic+na.action">na.action</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- data.frame(y=1, x=2, z=3, g=4)
do.formula.trellis.xysplom( y ~ x + z | g, data=tmp)
</code></pre>

<hr>
<h2 id='EmphasizeVerticalPanels'>
Helper function for likertWeighted(). used for vertical spacing and
horizontal borders of grouped panels.
</h2><span id='topic+EmphasizeVerticalPanels'></span>

<h3>Description</h3>

<p>Helper function for <code>likertWeighted()</code> used for vertical spacing and
horizontal borders of grouped panels.  Horizontal rules between panels
are suppressed by default by <code>likertWeighted</code> unless <code>y.between</code> is
non-zero.
See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EmphasizeVerticalPanels(x, y.between)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EmphasizeVerticalPanels_+3A_x">x</code></td>
<td>

<p><code>"trellis"</code> object, normally one constructed by <code><a href="#topic+likertWeighted">likertWeighted</a></code>.
</p>
</td></tr>
<tr><td><code id="EmphasizeVerticalPanels_+3A_y.between">y.between</code></td>
<td>

<p>The <code>between=list(y=numericvector)</code> argument applied to a trellis object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Revised <code>trellis</code> object.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+likertWeighted">likertWeighted</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp1 &lt;- array(1:60, c(5, 4, 3), list(letters[1:5],letters[6:9],letters[10:12]))
tmp2 &lt;- toCQxR(tmp1)
colnames(tmp2)

likertWeighted(~ . | group + row, tmp2)

likertWeighted(~ . | group + row, tmp2, h.resize.panels=1:5,
               between=list(y=c(0,0,3,0)),
               h.resizePanels=1:5,
               ylab=c("Bottom","Top"),
               xlab.top=c("First","Second","Third"),
               auto.key.title="Response Level",
               main="Three Questions by Five Levels of Classification")

likertObject &lt;- likertWeighted(~ . | group + row, tmp2)
likertObject

EmphasizeVerticalPanels(likertObject, y.between=c(0,0,1,0))

</code></pre>

<hr>
<h2 id='emptyMainLeftAxisLeftStripBottomLegend'>
Remove main title, left axis tick labels, left strip, bottom legend
from plot and keep the vertical spacing allocated to those items.
</h2><span id='topic+emptyMainLeftAxisLeftStripBottomLegend'></span>

<h3>Description</h3>

<p>Remove main title, left axis tick labels, left strip, bottom legend from
plot and keep the vertical spacing allocated to those items.  This
function is used to prepare a trellis object to be placed next to
another trellis object.  The current object will have much of its
annotation
removed with the intent of sharing annotation with the other object.
This is motivated by the <code>ProfChal</code> example in <code><a href="#topic+plot.likert">plot.likert</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emptyMainLeftAxisLeftStripBottomLegend(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emptyMainLeftAxisLeftStripBottomLegend_+3A_x">x</code></td>
<td>
<p>A <code>"trellis"</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We manipulate the items inside the trellis object.
</p>


<h3>Value</h3>

<p>A <code>"trellis"</code> object with the stated items replaced by non-printing
values.  The vertical spacing of the original object is retained.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>The manipulations are similar to those in the
<code><a href="latticeExtra.html#topic+c.trellis">c.trellis</a></code> and related functions in the
<code>latticeExtra</code> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.likert">plot.likert</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## This is a small example.
## See ?plot.likert for the complete example including motivation.
##
require(grid)
require(lattice)
require(latticeExtra)
require(HH)

data(ProfChal)

tmp &lt;- data.matrix(ProfChal[,1:5])
rownames(tmp) &lt;- ProfChal$Question
ProfChal.list &lt;- split.data.frame(tmp, ProfChal$Subtable)

Empl &lt;- ProfChal.list[[2]]

pct   &lt;- likert(Empl, as.percent="noRightAxis", xlab="Percent")
pct
count &lt;- likert(Empl, rightAxis=TRUE,
                xlab="Count", ylab.right="Row Count Totals",
                scales=list(x=list(at=c(0, 100, 200))))
count
countEmptied &lt;- HH:::emptyMainLeftAxisLeftStripBottomLegend(count)
countEmptied

tmp &lt;- update(resizePanels(c(pct, countEmptied, y.same=TRUE, layout=c(2,1)), w=c(.8, .2)),
              scales=list(y=list(alternating=3, limits=count$y.limits),
                          x=list(at=list(pct$x.scales$at, count$x.scales$at),
                                 labels=list(pct$x.scales$labels,
                                             count$x.scales$labels))),
              xlab=c(" ", pct$xlab, " ", count$xlab),
              between=list(x=1))
tmp
</code></pre>

<hr>
<h2 id='export.eps'> Exports a graph to an EPS file.</h2><span id='topic+export.eps'></span>

<h3>Description</h3>

<p>Exports a graph from the current device in R,
or the <code>graphsheet</code> in S-Plus, to an <code>EPS</code> file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export.eps(FileName.in, Name.in="GSD2", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export.eps_+3A_filename.in">FileName.in</code></td>
<td>
<p> name of file to be created.</p>
</td></tr>
<tr><td><code id="export.eps_+3A_name.in">Name.in</code></td>
<td>
<p>Name of graphsheet in S-Plus, ignored in R.</p>
</td></tr>
<tr><td><code id="export.eps_+3A_...">...</code></td>
<td>
<p>other arguments in R, ignored in S-Plus.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+dev2">dev2</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  if (interactive()) {
    trellis.device()
    plot(1:10)
    export.eps("abcd.eps")
  }
  
## End(Not run)
</code></pre>

<hr>
<h2 id='extra'>Miscellaneous functions that I wish were in or consistent between
S-Plus and R.</h2><span id='topic+as.rts'></span><span id='topic+title.trellis'></span><span id='topic+title.grob'></span><span id='topic+as.character.arima.model'></span><span id='topic+arima.model'></span><span id='topic+coefArimaHH'></span><span id='topic+.arima.info.names.not.ordered'></span>

<h3>Description</h3>

<p>Miscellaneous functions that I wish were in or consistent between
S-Plus and R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.rts(x, ...)

title.trellis(main = NULL, sub = NULL, xlab = NULL, ylab = NULL,
    line = NA, outer = FALSE, axes=NULL, ...)

title.grob(main=NULL, y=.99, gp=gpar(cex=1.5))

## S3 method for class 'arima.model'
as.character(x, ...)

arima.model(x)

coefArimaHH(object, ...)

.arima.info.names.not.ordered (model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extra_+3A_x">x</code></td>
<td>
<p>vector or time series</p>
</td></tr>
<tr><td><code id="extra_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="extra_+3A_main">main</code>, <code id="extra_+3A_sub">sub</code>, <code id="extra_+3A_xlab">xlab</code>, <code id="extra_+3A_ylab">ylab</code>, <code id="extra_+3A_line">line</code>, <code id="extra_+3A_outer">outer</code>, <code id="extra_+3A_axes">axes</code></td>
<td>
<p>See <code>title</code>.</p>
</td></tr>
<tr><td><code id="extra_+3A_model">model</code></td>
<td>
<p>A time series model specification in the S-Plus notation.</p>
</td></tr>
<tr><td><code id="extra_+3A_object">object</code></td>
<td>
<p><code>"arima"</code> object in S-Plus.</p>
</td></tr>
<tr><td><code id="extra_+3A_y">y</code>, <code id="extra_+3A_gp">gp</code></td>
<td>
<p>See <code><a href="grid.html#topic+grid.text">grid.text</a></code> in R.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> The result object of <code>arima.model</code> has class <code>"arima.model"</code></p>


<h3>Author(s)</h3>

<p>Richard M. Heiberger (rmh@temple.edu)</p>


<h3>See Also</h3>

<p><code><a href="#topic+arma.loop">arma.loop</a></code></p>

<hr>
<h2 id='F.curve'>plot a chisquare or a F-curve.</h2><span id='topic+chisq.curve'></span><span id='topic+chisq.observed'></span><span id='topic+chisq.setup'></span><span id='topic+F.curve'></span><span id='topic+F.observed'></span><span id='topic+F.setup'></span>

<h3>Description</h3>

<p>Plot a chisquare or a F-curve.  Shade a region for
rejection region or do-not-reject region.  <code>F.observed</code> and
<code>chisq.observed</code> plots a vertical line with arrowhead markers at
the location of the observed xbar and outlines the area corresponding
to the <code class="reqn">p</code>-value.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>F.setup(df1=1,
        df2=Inf,
        ncp=0,
        log.p=FALSE,
        xlim.in=c(0, 5),
        ylim.in=range(c(0, 1.1*df.intermediate(x=seq(.5,1.5,.01),
                       df1=df1, df2=df2, ncp=ncp, log=log.p))),
        main.in=main.calc, ylab.in="F density",
        ...)

F.curve(df1=1,
        df2=Inf,
        ncp=0,
        log.p=FALSE,
        alpha=.05,
        critical.values=f.alpha,
        f=seq(0, par()$usr[2], length=109),
        shade="right", col=par("col"),
        axis.name="f",
        ...)

F.observed(f.obs, col="green",
           df1=1,
           df2=Inf,
           ncp=0,
           log.p=FALSE,
           axis.name="f",
           shade="right",
           shaded.area=0,
           display.obs=TRUE)

chisq.setup(df=1,
           ncp=0,
           log.p=FALSE,
           xlim.in=c(0, qchisq.intermediate(p=1-.01, df=df, ncp=ncp, log.p=log.p)),
           ylim.in=range(c(0, 1.1*dchisq.intermediate(x=seq(max(0.5,df-2),df+2,.01),
                         df=df, ncp=ncp, log=log.p))),
           main.in=main.calc, ylab.in="Chisq density",
           ...)

chisq.curve(df=1,
            ncp=0,
            log.p=FALSE,
            alpha=.05,
            critical.values=chisq.alpha,
            chisq=seq(0, par()$usr[2], length=109),
            shade="right", col=par("col"),
            axis.name="chisq",
            ...)

chisq.observed(chisq.obs, col="green",
               df=1,
               ncp=0,
               log.p=FALSE,
               axis.name="chisq",
               shade="right",
               shaded.area=0,
               display.obs=TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F.curve_+3A_xlim.in">xlim.in</code>, <code id="F.curve_+3A_ylim.in">ylim.in</code></td>
<td>
<p>Initial settings for <code>xlim, ylim</code>.
The defaults are calculated for the degrees of freedom.</p>
</td></tr>
<tr><td><code id="F.curve_+3A_df">df</code>, <code id="F.curve_+3A_df1">df1</code>, <code id="F.curve_+3A_df2">df2</code>, <code id="F.curve_+3A_ncp">ncp</code>, <code id="F.curve_+3A_log.p">log.p</code></td>
<td>
<p>Degrees of freedom,
non-centrality parameter, probabilities are given as log(p).
See <code><a href="stats.html#topic+pchisq">pchisq</a></code> and <code><a href="stats.html#topic+pf">pf</a></code>.</p>
</td></tr>
<tr><td><code id="F.curve_+3A_alpha">alpha</code></td>
<td>
<p>Probability of a Type I error.  <code>alpha</code> is a vector
of
one or two values.  If one value, it is the right alpha.  If two values,
they are the <code>c(left.alpha, right.alpha)</code>.</p>
</td></tr>
<tr><td><code id="F.curve_+3A_critical.values">critical.values</code></td>
<td>
<p>Critical values.  Initial values correspond
to the specified <code>alpha</code> levels.
A scalar value implies a one-sided test on the right side.
A vector of two values
implies a two-sided test.</p>
</td></tr>
<tr><td><code id="F.curve_+3A_main.in">main.in</code>, <code id="F.curve_+3A_ylab.in">ylab.in</code></td>
<td>
<p>Main title, default ylab.</p>
</td></tr>
<tr><td><code id="F.curve_+3A_shade">shade</code></td>
<td>

<p>Valid values for shade are &quot;right&quot;, &quot;left&quot;, &quot;inside&quot;, &quot;outside&quot;, &quot;none&quot;.
Default is &quot;right&quot; for one-sided critical.values and &quot;outside&quot;
for two-sided critical values.</p>
</td></tr>
<tr><td><code id="F.curve_+3A_col">col</code></td>
<td>
<p>color of the shaded region and the area of the shaded region.</p>
</td></tr>
<tr><td><code id="F.curve_+3A_shaded.area">shaded.area</code></td>
<td>
<p>Numerical value of the area.  This value may
be cumulated over two calls to the function (one call for left, one
call for right).
The <code>shaded.area</code> is the return value of the function.
The calling program is responsible for the
cumulation.</p>
</td></tr>
<tr><td><code id="F.curve_+3A_display.obs">display.obs</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, print the numerical value
of the observed value, plot a vertical <code>abline</code> at the value,
and use it for showing the <code class="reqn">p</code>-value.
If <code>FALSE</code>, don't print or plot the observed value; just use it
for showing the <code class="reqn">p</code>-value.</p>
</td></tr>
<tr><td><code id="F.curve_+3A_f">f</code>, <code id="F.curve_+3A_chisq">chisq</code></td>
<td>
<p>Values used to draw curve.  Replace them if more
resolution is needed.</p>
</td></tr>
<tr><td><code id="F.curve_+3A_f.obs">f.obs</code>, <code id="F.curve_+3A_chisq.obs">chisq.obs</code></td>
<td>
<p>Observed values of statistic.  <code class="reqn">p</code>-values are
calculated for these values.</p>
</td></tr>
<tr><td><code id="F.curve_+3A_axis.name">axis.name</code></td>
<td>
<p>Axis name.</p>
</td></tr>
<tr><td><code id="F.curve_+3A_...">...</code></td>
<td>
<p>Other arguments which are ignored.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>Examples</h3>

<pre><code class='language-R'>old.omd &lt;- par(omd=c(.05,.88, .05,1))
chisq.setup(df=12)
chisq.curve(df=12, col='blue')
chisq.observed(22, df=12)
par(old.omd)

old.omd &lt;- par(omd=c(.05,.88, .05,1))
chisq.setup(df=12)
chisq.curve(df=12, col='blue', alpha=c(.05, .05))
par(old.omd)

old.omd &lt;- par(omd=c(.05,.88, .05,1))
F.setup(df1=5, df2=30)
F.curve(df1=5, df2=30, col='blue')
F.observed(3, df1=5, df2=30)
par(old.omd)

old.omd &lt;- par(omd=c(.05,.88, .05,1))
F.setup(df1=5, df2=30)
F.curve(df1=5, df2=30, col='blue', alpha=c(.05, .05))
par(old.omd)

</code></pre>

<hr>
<h2 id='glhtWithMCP.993'>Retain averaging behavior that was previously available in glht.</h2><span id='topic+glhtWithMCP.993'></span><span id='topic+mcp2matrix.993'></span>

<h3>Description</h3>

<p>For some ANOVA models with two or more factors, we need to average over
interaction terms.  These functions use an older version of glht.mcp
and mcp2matrix to do that averaging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glhtWithMCP.993(model, linfct, ...)
mcp2matrix.993(model, linfct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glhtWithMCP.993_+3A_model">model</code>, <code id="glhtWithMCP.993_+3A_linfct">linfct</code>, <code id="glhtWithMCP.993_+3A_...">...</code></td>
<td>
<p>See <code><a href="multcomp.html#topic+glht">glht</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mcp2matrix</code> is taken from from <code>multcomp_0.993-2.tar.gz/R/mcp.R</code>.
</p>
<p><code>glhtWithMCP.993</code> is based on <code>glht.mcp</code> in
<code>multcomp_1.0-0/R/glht.R</code>
with the call to <code>mcp2matrix</code> replaced by a call to <code>mcp2matrix.993</code>.
</p>


<h3>Value</h3>

<p>See <code><a href="multcomp.html#topic+glht">glht</a></code>
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+mmc">mmc</a></code></p>

<hr>
<h2 id='gof.calculation'>Calculate Box&ndash;Ljung Goodness of Fit for ARIMA models in S-Plus.</h2><span id='topic+gof.calculation'></span>

<h3>Description</h3>

<p>Calculate Box&ndash;Ljung Goodness of Fit for ARIMA models in S-Plus.
In R we use the <code>Box.test</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof.calculation(acf.list, gof.lag, n, n.parms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof.calculation_+3A_acf.list">acf.list</code></td>
<td>
<p>An <code>"acf"</code> object.</p>
</td></tr>
<tr><td><code id="gof.calculation_+3A_gof.lag">gof.lag</code></td>
<td>
<p>The number of model parameters is the number of lags to
use for computing the Portmanteau goodness of fit statistic</p>
</td></tr>
<tr><td><code id="gof.calculation_+3A_n">n</code></td>
<td>
<p>Number of residuals in model.</p>
</td></tr>
<tr><td><code id="gof.calculation_+3A_n.parms">n.parms</code></td>
<td>
<p>Number of AR and MA parameters in the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is isolated from the S-Plus <code>arima.diag</code> function.
It is used only in S-Plus.
</p>


<h3>Value</h3>

<p>See the <code>gof</code> value described in
<code>arima.diag</code>
</p>
<p>in S-Plus.
</p>


<h3>Author(s)</h3>

<p>Richard M. Heiberger (rmh@temple.edu)</p>


<h3>See Also</h3>

<p><code>arima.diag</code>
</p>
<p>in S-Plus. </p>


<h3>Examples</h3>

<pre><code class='language-R'>if.R(s={
co2.arima &lt;- arima.mle(co2, list(list(order=c(0,1,1)),
                                 list(order=c(0,1,1), period=12)))
co2.acf &lt;- acf(resid(co2.arima), plot=FALSE, lag=40)
co2.gof &lt;- gof.calculation(co2.acf, 36, length(co2), 2)
xyplot(p.value ~ lag, data=co2.gof, panel=panel.gof,
       ylim=range(0, co2.gof$p.value))
},r={})
</code></pre>

<hr>
<h2 id='grid.yaxis.hh'>make x- and y-axis labels</h2><span id='topic+grid.yaxis.hh'></span><span id='topic+make.yaxis.hh.labels'></span><span id='topic+grid.xaxis.hh'></span><span id='topic+make.xaxis.hh.labels'></span>

<h3>Description</h3>

<p>uses modified older version of grid functions.
Includes optional specification of the axis labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.yaxis.hh(at = NULL, label = TRUE, main = TRUE, gp = gpar(),
              draw = TRUE, vp = NULL, labels)

make.yaxis.hh.labels(at, main, labels = at)

grid.xaxis.hh(at = NULL, label = TRUE, main = TRUE, gp = gpar(),
              draw = TRUE, vp = NULL, labels)

make.xaxis.hh.labels(at, main, labels = at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.yaxis.hh_+3A_at">at</code>, <code id="grid.yaxis.hh_+3A_label">label</code>, <code id="grid.yaxis.hh_+3A_main">main</code>, <code id="grid.yaxis.hh_+3A_gp">gp</code>, <code id="grid.yaxis.hh_+3A_draw">draw</code>, <code id="grid.yaxis.hh_+3A_vp">vp</code></td>
<td>
<p>See <code>link[grid]{grid.xaxis}</code>.</p>
</td></tr>
<tr><td><code id="grid.yaxis.hh_+3A_labels">labels</code></td>
<td>
<p>label values if you don't want the defaults </p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code>link[grid]{grid.xaxis}</code>.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code>link[grid]{grid.xaxis}</code></p>

<hr>
<h2 id='GSremove'>Remove selected GraphSheetPages in the S-Plus Windows GUI Graphsheet</h2><span id='topic+GSremove'></span>

<h3>Description</h3>

<p>Remove selected GraphSheetPages in the S-Plus Windows GUI Graphsheet.
This does the same task as right-click/delete on the tabs of the GraphSheet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GSremove(pages, sheet = "GSD2$Page")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GSremove_+3A_pages">pages</code></td>
<td>
<p>Page numbers in the tabs at the bottom of the Graphsheet.</p>
</td></tr>
<tr><td><code id="GSremove_+3A_sheet">sheet</code></td>
<td>
<p>Defaults to <code>GSD2</code>, the first name that is used when
the <code>graphsheet</code> or <code>trellis.device</code> function is used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code>graphsheet</code>
</p>
<p>in S-Plus.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
trellis.device()
plot(1:10); plot(11:20); plot(21:30)
GSremove(c(1,3))

## End(Not run)
</code></pre>

<hr>
<h2 id='HH-internal'>Internal HH functions</h2><span id='topic+latex'></span>

<h3>Description</h3>

<p>Internal HH functions.</p>


<h3>Details</h3>

<p><code>latex</code> is imported from <span class="pkg">Hmisc</span>. See
<code><a href="Hmisc.html#topic+sys">sys</a></code>.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>

<hr>
<h2 id='HH.regsubsets'>Display tabular results for Best Subsets Regression.</h2><span id='topic+HH.regsubsets'></span><span id='topic+summaryHH'></span><span id='topic+summaryHH.regsubsets'></span><span id='topic+print.summaryHH.regsubsets'></span><span id='topic+plot.summaryHH.regsubsets'></span>

<h3>Description</h3>

<p>Print a tabular display of the results of Best Subsets Regression.
This is an alternate display for the object from the <code>regsubsets</code>
function.  This function is based on <code><a href="leaps.html#topic+regsubsets">regsubsets</a></code>.
The functions described here are designed for the HH package in R and
use the leaps package in R.
The leaps package is not in S-Plus, hence these functions
do not work in the HH package for S-Plus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
`summaryHH`(object, ...)

## S3 method for class 'regsubsets'
summaryHH(object,
           names = abbreviate(dimnames(incidence)[[2]], minlength = abbrev),
           abbrev = 1, min.size = 1, max.size = dim(sumry$which)[2],
           statistic = c("bic", "cp", "adjr2", "rsq", "rss", "stderr"),
           las = par("las"),
           cex.subsets = 1, ..., main=statistic)

## S3 method for class 'summaryHH.regsubsets'
plot(x, ...,
           statistic="adjr2", legend=FALSE,
           col="darkgray", cex=1, pch=16,
           col.text="black", cex.text=1, col.abline="darkgray")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HH.regsubsets_+3A_object">object</code></td>
<td>
<p> An object of class <code>"regsubsets"</code>.</p>
</td></tr>
<tr><td><code id="HH.regsubsets_+3A_x">x</code></td>
<td>
<p> An object of class <code>"summaryHH.regsubsets"</code>.</p>
</td></tr>
<tr><td><code id="HH.regsubsets_+3A_statistic">statistic</code></td>
<td>
<p>Name of statistic to be plotted for each model.</p>
</td></tr>
<tr><td><code id="HH.regsubsets_+3A_...">...</code></td>
<td>
<p> Other arguments to be passed down to
<code>subsets.regsubsets</code> and <code>plot</code>.</p>
</td></tr>
<tr><td><code id="HH.regsubsets_+3A_names">names</code></td>
<td>
<p>Abbreviations of variable names.</p>
</td></tr>
<tr><td><code id="HH.regsubsets_+3A_abbrev">abbrev</code></td>
<td>
<p>minimum number of letters in each abbreviation.</p>
</td></tr>
<tr><td><code id="HH.regsubsets_+3A_min.size">min.size</code></td>
<td>
<p>minimum size subset to plot; default is 1.</p>
</td></tr>
<tr><td><code id="HH.regsubsets_+3A_max.size">max.size</code></td>
<td>
<p>maximum size subset to plot; default is number of predictors.</p>
</td></tr>
<tr><td><code id="HH.regsubsets_+3A_legend">legend</code></td>
<td>
<p>logical variable, <code>TRUE</code> if the legend should be
printed.
If the legend is printed, the execution halts until the user clicks an
empty space in the graph where the legend should be placed.</p>
</td></tr>
<tr><td><code id="HH.regsubsets_+3A_las">las</code></td>
<td>
<p>Orientation for model names on graph.</p>
</td></tr>
<tr><td><code id="HH.regsubsets_+3A_cex.subsets">cex.subsets</code></td>
<td>
<p>can be used to change the relative size of the characters used to
plot the regression subsets; default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="HH.regsubsets_+3A_main">main</code></td>
<td>
<p><code>"main"</code> title for graph.</p>
</td></tr>
<tr><td><code id="HH.regsubsets_+3A_col">col</code>, <code id="HH.regsubsets_+3A_cex">cex</code>, <code id="HH.regsubsets_+3A_pch">pch</code></td>
<td>
<p><code>par</code> values for dot locating statistic.</p>
</td></tr>
<tr><td><code id="HH.regsubsets_+3A_col.text">col.text</code>, <code id="HH.regsubsets_+3A_cex.text">cex.text</code></td>
<td>
<p><code>par</code> values for abbreviations of
models on plot.</p>
</td></tr>
<tr><td><code id="HH.regsubsets_+3A_col.abline">col.abline</code></td>
<td>
<p><code>par</code> parameters for <code>abline</code> when the
statistic is <code>cp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summaryHH</code> produces a table of models, with
<code>p, rsq, rss, adjr2, cp, bic, stderr</code> for each.
<code>plot.summaryHH.regsubsets</code> plots the specified statistic
from the summary.
All the others are support functions.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="leaps.html#topic+regsubsets">regsubsets</a></code>

</p>

<hr>
<h2 id='hhpdf'>
R tools for writing HH2: hhpdf, hhdev.off, hhcapture, hhcode, hhpng, hhlatex
</h2><span id='topic+hhpdf'></span><span id='topic+hhdev.off'></span><span id='topic+hhcapture'></span><span id='topic+hhcode'></span><span id='topic+hhpng'></span><span id='topic+hhlatex'></span>

<h3>Description</h3>

<p>R tools for writing HH2: hhpdf, hhdev.off, hhcapture, hhcode, hhpng, hhlatex.
These functions in the HH package are placeholders used by
the <code>scripts</code> files.  See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hhpdf(file, ...)

hhdev.off(...)

hhcapture(file, text, echo=TRUE, print.eval=TRUE)

hhcode(file, text)

hhpng(file, ...)

hhlatex(file="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hhpdf_+3A_file">file</code></td>
<td>

<p>Output file name.  Ignored.
</p>
</td></tr>
<tr><td><code id="hhpdf_+3A_text">text</code></td>
<td>

<p>Multi-line character string.  It will be
displayed on the console by <code>hhcode</code>, and will be executed
and the resulting value displayed on the console by
<code>hhcapture</code>.
</p>
</td></tr>
<tr><td><code id="hhpdf_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="hhpdf_+3A_echo">echo</code>, <code id="hhpdf_+3A_print.eval">print.eval</code></td>
<td>

<p>See <code><a href="base.html#topic+source">source</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The files in <code><a href="#topic+HHscriptnames">HHscriptnames</a></code><code>()</code>
contain R code for all examples and figures in the book.
The examples can all be directly executed by the user.
The code examples all use these functions.
</p>
<p>The versions of these functions here are essentially placeholders.
Functions <code>hhpdf</code>, <code>hhpng</code>, and <code>hhdev.off</code> are no-ops and return <code>NULL</code>.
As a consequence, the code between them will execute and display on
the default graphics device.
Function <code>hhcapture</code> sources its text argument and prints the
output to the console.
Function <code>hhcode</code> prints its text argument to the console.
Function <code>hhlatex</code> prints the latex source to the
console and returns <code>NULL</code>.
</p>
<p>While writing the book, these placeholder functions are
replaced by more elaborate functions
with the same names that write the graphs onto pdf or png files, the
console output to text files, and the latex code to a file.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>

<hr>
<h2 id='HHscriptnames'>Find absolute pathname of a script file for the HH book in the HH
package.</h2><span id='topic+HHscriptnames'></span><span id='topic+WindowsPath'></span>

<h3>Description</h3>

<p>Find absolute pathname of a script file for the HH book in the <span class="pkg">HH</span>
package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>HHscriptnames(chapternumbers=NULL, edition=2)

WindowsPath(x, display=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HHscriptnames_+3A_chapternumbers">chapternumbers</code></td>
<td>
<p>A number or letter name for a chapter in the HH
book.  For the Second edition, the valid values are from the set
<code>c(1:18, LETTERS[1:15])</code>.
For the First edition, the valid values are from the set
<code>c(1:18)</code>.
The argument may be a vector of one or more items.
The file basename for the corresponding chapter is also accepted.
If the <code>chapternumbers</code> is <code>NULL</code> (the default) then the
directory containing the script files for the <code>edition</code> is returned.</p>
</td></tr>
<tr><td><code id="HHscriptnames_+3A_edition">edition</code></td>
<td>
<p>Either 2 or 1, for the second or first edition of the
book <em>Statistical Analysis and Data Display</em>.</p>
</td></tr>
<tr><td><code id="HHscriptnames_+3A_x">x</code></td>
<td>
<p>A vector or matrix of pathnames as generated by <span class="rlang"><b>R</b></span>, with <code>"/"</code> as the
separator character.</p>
</td></tr>
<tr><td><code id="HHscriptnames_+3A_display">display</code></td>
<td>
<p>Logical.  With the default <code>TRUE</code>, the
<code>WindowsPath</code> function
prints the pathname on the console with a single <code>\</code> character as the
separator suitable for copy and paste into a Windows program and
returns its result invisibly.  With
<code>FALSE</code>
the <code>WindowsPath</code> function does not print anything;  it returns its result visibly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>HHscriptnames</code>, matrix of full pathnames to script files in the HH
package.
</p>
<p>For <code>WindowsPath</code>, a vector or matrix of full pathnames with all <code>"/"</code> characters
changed to <code>"\\"</code> (which displays as <code>\</code> by the
<code>cat</code> function).  When <code>display</code> is <code>TRUE</code> the
function also prints at the console the pathnames with a single
<code>\</code> character suitable for copy and paste into a Windows program.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ## All Operating Systems

  ## Second Edition
  HHscriptnames()
  HHscriptnames(6)
  HHscriptnames("6")
  HHscriptnames("oway")

  HHscriptnames("H")
  HHscriptnames("RApx")

  HHscriptnames(c(1:18, LETTERS[1:15]))

  ## with Windows pathname separators
  WindowsPath(HHscriptnames())
  WindowsPath(HHscriptnames(6))
  WindowsPath(HHscriptnames(6), display=FALSE)
  WindowsPath(HHscriptnames(6:8))
  WindowsPath(HHscriptnames(6:8), display=FALSE)

  ## First Edition
  HHscriptnames(6, edition=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='hov'>Homogeneity of Variance</h2><span id='topic+hov'></span><span id='topic+hov.bf'></span>

<h3>Description</h3>

<p>Oneway analysis of variance makes the assumption that the variances of
the groups are equal.
Brown and Forsyth, 1974 present the recommended test of this assumption.
The Brown and Forsyth test statistic is the <code class="reqn">F</code> statistic resulting
from an ordinary one-way analysis of variance on the
absolute deviations from the median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hov(x, data=NULL, method = "bf") ## x is a formula

## users will normally use the formula above and will not call the
## method directly.
hov.bf(x, group,  ## x is the response variable
       y.name = deparse(substitute(x)),
       group.name = deparse(substitute(group)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hov_+3A_x">x</code></td>
<td>
<p> Formula appropriate for oneway anova in <code>hov</code>.
Response variable in <code>hov.bf</code>.</p>
</td></tr>
<tr><td><code id="hov_+3A_data">data</code></td>
<td>
<p> data.frame </p>
</td></tr>
<tr><td><code id="hov_+3A_method">method</code></td>
<td>
<p>Character string defining method.  At this time the only
recognized method is <code>"bf"</code> for the Brown&ndash;Forsyth method.
</p>
</td></tr>
<tr><td><code id="hov_+3A_group">group</code></td>
<td>
<p> factor. </p>
</td></tr>
<tr><td><code id="hov_+3A_y.name">y.name</code></td>
<td>
<p> name of response variable,
defaults to variable name in formula. </p>
</td></tr>
<tr><td><code id="hov_+3A_group.name">group.name</code></td>
<td>
<p>name of factor, defaults to variable name in
formula. </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"htest"</code> object for the hov test.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>
<p>Brown, M.~B. and Forsyth, A.~B. (1974).
<em>Robust tests for equality of variances</em>.
<em>Journal of the American Statistical Association</em>, 69:364&ndash;367.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+aov">aov</a></code>,  <code><a href="#topic+hovPlot">hovPlot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(turkey)

hov(wt.gain ~ diet, data=turkey)
hovPlot(wt.gain ~ diet, data=turkey)
</code></pre>

<hr>
<h2 id='hovBF'>
Homogeneity of Variance:  Brown&ndash;Forsyth method
</h2><span id='topic+hovBF'></span><span id='topic+hovplotBF'></span>

<h3>Description</h3>

<p>Homogeneity of Variance:  Brown&ndash;Forsyth method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hovBF(x, data=NULL, ..., na.rm = TRUE)
hovplotBF(x, data, ..., na.rm = TRUE,
          main = "Brown-Forsyth Homogeneity of Variance", plotmath = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hovBF_+3A_x">x</code></td>
<td>

<p>Model formula with one response variable and one factor.
</p>
</td></tr>
<tr><td><code id="hovBF_+3A_data">data</code></td>
<td>

<p><code>data.frame</code>
</p>
</td></tr>
<tr><td><code id="hovBF_+3A_...">...</code></td>
<td>

<p>Other arguments. <code>hovplotBF</code> sends them on to the panel function. <code>hovBF</code> ignores them.
</p>
</td></tr>
<tr><td><code id="hovBF_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical value indicating whether 'NA' values should be
stripped before the computation proceeds. See <code><a href="stats.html#topic+median">median</a></code>.</p>
</td></tr>
<tr><td><code id="hovBF_+3A_main">main</code></td>
<td>

<p><code>main</code> title for the plot.
</p>
</td></tr>
<tr><td><code id="hovBF_+3A_plotmath">plotmath</code></td>
<td>

<p>Logical.  When <code>TRUE</code> (the default) the strip labels use
<code>plotmath</code>. When <code>FALSE</code> the strip labels use ASCII.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>hovplotBF</code> returns a three-panel <code>trellis</code> object.
<code>hovBF</code> returns an <code>htest</code> object.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Brown, M.~B. and Forsyth, A.~B. (1974).
&ldquo;Robust tests for equality of variances.&rdquo;
<em>Journal of the American Statistical Association</em>, 69:364&ndash;367.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(batch)
batch1.aov &lt;- aov(Calcium ~ Batch, data=batch)
anova(batch1.aov)
hovBF(Calcium ~ Batch, data=batch)
hovplotBF(Calcium ~ Batch, data=batch)
</code></pre>

<hr>
<h2 id='if.R'> Conditional Execution for R or S-Plus </h2><span id='topic+if.R'></span><span id='topic+is.R'></span>

<h3>Description</h3>

<p><code>if.R</code> uses the <code>is.R</code> function to determine whether to
execute the expression in the <code>r</code> argument or the expression
in the <code>s</code> argument. <code>is.R</code>, copied from the now defunct
base R function, returns <code>TRUE</code> if running under R and returns
<code>FALSE</code> otherwise (initially designed for S/S-PLUS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>if.R(r, s)

is.R()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="if.R_+3A_r">r</code></td>
<td>
<p>Any R expression, including a group of expressions nested in
braces.  Assignments made in this expression are available
to the enclosing function.</p>
</td></tr>
<tr><td><code id="if.R_+3A_s">s</code></td>
<td>
<p>Any S-Plus expression, including a group of expressions
nested in braces.  Assignments made in this expression are available
to the enclosing function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all functions are in both implementations of the S language.  In
particular, panel functions for <code>lattice</code> in R (based on
<code>grid</code> graphics) are very different from panel functions for
<code>trellis</code> (based on the older graphics technology) in S-Plus.
</p>
<p><code>is.R</code> is copied from the now defunct base R function of the same name.
</p>


<h3>Value</h3>

<p>For <code>if.R</code> the result of the executed expression.
</p>
<p><code>is.R</code> returns <code>TRUE</code> if we are using R and <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code>R.Version</code></p>


<h3>Examples</h3>

<pre><code class='language-R'> if.R(r={"This is R."},
      s={"This is S-Plus"})

 is.R()
</code></pre>

<hr>
<h2 id='InsertVerticalPanels'>
Expand a 3D array on the second dimension, inserting empty layers where
the input vector has a <code>0</code> value.  A 2D argument <code>x</code> with <code>dim(x)==c(r,c)</code> is
first extended to 3D with <code>dim(x)==c(1,r,c)</code>, and then the result is
collapsed back to 2D.
</h2><span id='topic+InsertVerticalPanels'></span>

<h3>Description</h3>

<p>Expand a 3D array on the second dimension, inserting empty layers where
the input vector has a <code>0</code> value.  A 2D argument <code>x</code> with <code>dim(x)==c(r,c)</code> is
first extended to 3D with <code>dim(x)==c(1,r,c)</code>, and then the result is
collapsed back to 2D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InsertVerticalPanels(x, expansion, newRowheights=5, newValue=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InsertVerticalPanels_+3A_x">x</code></td>
<td>

<p>Three-dimensional array, for example, one defined as a set of matrices
for the <code>likert</code> and related functions.
<code>x[1,,]</code> and more generally <code>x[i,,]</code> will be an argument to <code>likert</code>.
</p>
</td></tr>
<tr><td><code id="InsertVerticalPanels_+3A_expansion">expansion</code></td>
<td>

<p>Vector of <code>0</code> and <code>1</code>, with <code>1</code> indicating an existing layer in dimension 2, and <code>0</code> a
placeholder for where a new layer in dimension 2 should be inserted.
</p>
</td></tr>
<tr><td><code id="InsertVerticalPanels_+3A_newrowheights">newRowheights</code></td>
<td>

<p>Value to be used for inserted row by <code>likertWeighted</code> function.
</p>
</td></tr>
<tr><td><code id="InsertVerticalPanels_+3A_newvalue">newValue</code></td>
<td>

<p>Value to be inserted in all positions of inserted layer.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array similarly structured to the input array <code>x</code>, but with more
layers on the second dimension.  The <code>"rowheights"</code> attribute
gives the <code>rowheights</code> used by <code>EmphasizeVerticalPanels</code>.  The
<code>newRows</code>
gives the row (second dimension) numbers in the result that are the
generated values.  All data items in the <code>newRows</code> will have
value in the <code>newValue</code> argument.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p>EmphasizeVerticalPanels</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- array(1:24, c(3, 4, 2),
                dimnames = list(letters[1:3], LETTERS[4:7], letters[8:9]))
x

expansion &lt;- c(1, 1, 0, 1, 0, 1)
result &lt;- InsertVerticalPanels(x, expansion)
result

Pop.labels1 &lt;- result[1,, ]
Pop.labels1[ attr(result, "newRows"),] &lt;- " "

Pop.labels2 &lt;- result[2,, ]
Pop.labels2[ attr(result, "newRows"),] &lt;- " "

Pct.labels1 &lt;- format(round(HH::rowPcts(result[1,, ])))
Pct.labels1[ attr(result, "newRows"),] &lt;- " "

Pct.labels2 &lt;- format(round(HH::rowPcts(result[2,, ])))
Pct.labels2[ attr(result, "newRows"),] &lt;- " "

</code></pre>

<hr>
<h2 id='interaction.positioned'>interaction method for positioned factors.</h2><span id='topic+interaction.positioned'></span>

<h3>Description</h3>

<p>This is intended to be a method for <code>interaction</code> for positioned
factors.  Since <code>interaction</code> is not currently implemented as
a generic, <code>interaction.positioned</code> is a standalone function.
The result is assigned a <code>position</code>.  The position for each interaction
level is the position of the corresponding <code>a</code> factor plus a
scaled level of the <code>b</code> factor.  The default scale is .1.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interaction.positioned(...,  ## exactly two factors
             drop = FALSE, sep = ".",
             b.offset=0,
             b.scale=.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interaction.positioned_+3A_...">...</code></td>
<td>
<p>exactly two factors.  The first
factor <code>a</code> is used as the major factor in sort order.
The second factor <code>b</code> is used as minor factor in sort order.</p>
</td></tr>
<tr><td><code id="interaction.positioned_+3A_b.offset">b.offset</code></td>
<td>
<p>amount added to <code>position(b)</code> to adjust appearance.</p>
</td></tr>
<tr><td><code id="interaction.positioned_+3A_b.scale">b.scale</code></td>
<td>
<p>scale to relate units of <code>position(a)</code> to
units of <code>position(b)</code>.</p>
</td></tr>
<tr><td><code id="interaction.positioned_+3A_drop">drop</code>, <code id="interaction.positioned_+3A_sep">sep</code></td>
<td>
<p>See <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"positioned"</code> object containing the ordinary interaction with a
<code>"position"</code> attribute.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+positioned">positioned</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- positioned(letters[c(1,2,3,1,2,3)], value=c(1,4,9))
b &lt;- positioned(LETTERS[c(4,4,4,5,5,5)], value=c(1,2))
a.b &lt;- interaction.positioned(a, b)
a.b.2 &lt;- interaction.positioned(a, b, b.scale=.2)
b.a &lt;- interaction.positioned(b, a)
</code></pre>

<hr>
<h2 id='interaction2wt'>Plot all main effects and twoway interactions in a multifactor design</h2><span id='topic+interaction2wt'></span><span id='topic+interaction2wt.formula'></span><span id='topic+interaction2wt.default'></span>

<h3>Description</h3>

<p>The main diagonal
displays boxplots for the main effects of each factor.  The
off-diagonals show the interaction plots for each pair of factors.
The <code>i,j</code> panel shows the same factors as the <code>j,i</code> but with
the trace- and x-factor roles interchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interaction2wt(x, ...)

## S3 method for class 'formula'
interaction2wt(x, data=NULL, responselab, ...)

## Default S3 method:
interaction2wt(x,
               response.var,
               responselab = deparse(substitute(response.var)),
               responselab.expression = responselab,
               relation = list(x = "same", y = "same"),
               x.relation = relation$x,
               y.relation = relation$y,
               digits = 3,
               x.between=1,
               y.between=1,
               between,
               cex = 0.75,
               rot=c(0,0),
               panel.input = panel.interaction2wt,
               strip.input =
                if (label.as.interaction.formula) strip.default
                else strip.interaction2wt,
               par.strip.text.input = trellis.par.get()$add.text,
               scales.additional,
               main.in =
                 paste(responselab,
                       ": ", c("main", "simple")[1+simple],
                       " effects and 2-way interactions",
                       sep=""),
               xlab = "",
               ylab = "",
               simple=FALSE,
               box.ratio=if (simple) .32 else 1,
               label.as.interaction.formula=TRUE,
               ...,
               main.cex,
               key.cex.title=.8,
               key.cex.text=.7,
               factor.expressions=names.x,
               simple.pch=NULL,
               col.by.row=TRUE,
               col  =trellis.par.get("superpose.line")$col,
               lty  =trellis.par.get("superpose.line")$lty,
               lwd  =trellis.par.get("superpose.line")$lwd,
               alpha=trellis.par.get("superpose.line")$alpha
)
</code></pre>


<h3>Arguments</h3>

<p>Arguments when <code>x</code> is a formula.
</p>
<table>
<tr><td><code id="interaction2wt_+3A_x">x</code></td>
<td>

<p>The object on which method dispatch is carried out.
</p>
<p>For the <code>"formula"</code> method, a formula describing the response
variable and factors.
The formula is generally of the form <code>y ~ g1 + g2 + ...</code>.
There may be one or more factors in the formula.
</p>
<p>For the <code>"default"</code> method, <code>data.frame</code> of factors.  This
is usually constructed by <code>formula</code> method from the input
data and the input formula.
</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_data">data</code></td>
<td>

<p>For the <code>formula</code> method, a data frame containing values for
any variables in the formula.  In the R version,
if not found in <code>data</code>, or if
<code>data</code> is unspecified, the variables are looked for in the
environment of the formula.
</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_responselab">responselab</code></td>
<td>
<p>Character name of response variable, defaults to
the name of the response variable in the <code>formula</code>.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_responselab.expression">responselab.expression</code></td>
<td>
<p><code>plotmath</code> or character name
of response variable, defaults to <code>responselab</code>.
</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_...">...</code></td>
<td>
<p>additional arguments, primarily trellis arguments.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_response.var">response.var</code></td>
<td>
<p>For the <code>"default"</code> method, the
response variable.  This is usually constructed by
<code>formula</code> method from the input data and the input formula.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_simple">simple</code></td>
<td>
<p>logical.  <code>TRUE</code> if simple effects are to be
displayed.  Arguments <code>simple.offset</code>, <code>simple.scale</code>, and
<code>col.by.row</code> may also be needed.  See
<code><a href="#topic+panel.interaction2wt">panel.interaction2wt</a></code> for details.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_box.ratio">box.ratio</code></td>
<td>

<p><code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
</table>
<p>Trellis/Lattice arguments.  Default values are set by the
the <code>formula</code> method.  The user may override the defaults.
See also
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
<table>
<tr><td><code id="interaction2wt_+3A_relation">relation</code></td>
<td>
<p><code>trellis</code> argument.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_x.relation">x.relation</code></td>
<td>
<p><code>x</code> value of <code>relation</code> argument.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_y.relation">y.relation</code></td>
<td>
<p><code>y</code> value of <code>relation</code> argument.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_digits">digits</code></td>
<td>
<p>doesn't do anything at the moment</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_x.between">x.between</code></td>
<td>
<p><code>x</code> value of <code>between</code> argument.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_y.between">y.between</code></td>
<td>
<p><code>y</code> value of <code>between</code> argument.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_between">between</code></td>
<td>
<p>trellis/lattice <code>between</code> argument.
If used, <code>between</code> has precedence over both the
<code>x.between</code> and <code>y.between</code> arguments.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_cex">cex</code></td>
<td>
<p>S-Plus: changes the size of the median dot in the
boxplots.  R: doesn't do anything.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_panel.input">panel.input</code></td>
<td>
<p>panel function.  Default is <code>panel.interaction2wt</code>.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_label.as.interaction.formula">label.as.interaction.formula</code></td>
<td>
<p>logical.  If <code>TRUE</code>, each
panel has a single strip label of the form <code>y ~ a | b</code>.  If
<code>FALSE</code>, each panel has a pair of strip labels, one for the
<code>trace</code> factor and one for the <code>x</code> factor.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_strip.input">strip.input</code></td>
<td>
<p>strip function.  Default depends on the value of
<code>label.as.interaction.formula</code>.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_par.strip.text.input">par.strip.text.input</code></td>
<td>
<p><code>par.strip.text</code> argument.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_scales.additional">scales.additional</code></td>
<td>
<p>additional arguments to <code>scales</code>
argument of <code><a href="#topic+interaction.positioned">interaction.positioned</a></code>.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_main.in">main.in</code></td>
<td>
<p>Text of main title.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_xlab">xlab</code></td>
<td>
<p>No effect.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_ylab">ylab</code></td>
<td>
<p>No effect.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_main.cex">main.cex</code></td>
<td>
<p><code>cex</code> for main title.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_key.cex.title">key.cex.title</code></td>
<td>
<p><code>cex</code> key title.  Defaults to <code>cex</code> for
<code>xlab</code>.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_key.cex.text">key.cex.text</code></td>
<td>
<p><code>cex</code> group names in key.  Defaults to <code>cex</code> for
<code>axis.text</code>.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_factor.expressions">factor.expressions</code></td>
<td>
<p>Expressions for titles of keys and
<code>xlab</code> for each column.  Defaults to the names of the factors in
the input formula.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_rot">rot</code></td>
<td>
<p>Rotation of x tick labels and y tick labels.  Only 0 and 90
will look good.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_simple.pch">simple.pch</code></td>
<td>
<p>Named list containing plotting characters for each
level of one or more of the factors.  <code>simple.pch</code> is used only when
<code>simple==TRUE</code>.  If the argument <code>simple.pch</code> is missing,
then the integers for the levels of the factors are used.  The
characters are used for the median of the box plots in the diagonal
panels.  They match the trace factor of the interaction panel in the
same column of the display.  </p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_col.by.row">col.by.row</code></td>
<td>
<p>logical.  If <code>TRUE</code> (the default), simple
effects plots color the simple effects on the main diagonals in the same
color as the trace levels in their row.  If <code>FALSE</code>, then simple
effects are colored to match the x levels in their column.</p>
</td></tr>
<tr><td><code id="interaction2wt_+3A_col">col</code>, <code id="interaction2wt_+3A_lty">lty</code>, <code id="interaction2wt_+3A_lwd">lwd</code>, <code id="interaction2wt_+3A_alpha">alpha</code></td>
<td>
<p>Arguments to
<code>trellis.par.set(superpose.line=list())</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"trellis"</code> object containing the plot.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+panel.interaction2wt">panel.interaction2wt</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vulcan)

interaction2wt(wear ~ filler + pretreat + raw, data=vulcan,
               par.strip.text=list(cex=.7))

interaction2wt(wear ~ filler + pretreat + raw, data=vulcan,
               par.strip.text=list(cex=.7),
               label.as.interaction.formula=FALSE)

interaction2wt(wear ~ filler + raw, data=vulcan,
               simple=TRUE)

interaction2wt(wear ~ filler + raw, data=vulcan,
               simple=TRUE, col.by.row=FALSE)

interaction2wt(wear ~ filler + raw, data=vulcan,
               simple=TRUE, simple.scale=c(filler=.15, raw=.2),
               xlim=c(.3, 5.6))

interaction2wt(wear ~ filler + raw, data=vulcan,
               col=1:5, lwd=1:5, lty=1:5)

interaction2wt(wear ~ filler + raw, data=vulcan,
               simple=TRUE, col=1:5, lwd=1:5, lty=1:5)

interaction2wt(wear ~ filler + raw, data=vulcan,
               simple=TRUE, col=1:5, lwd=1:5, lty=1:5, col.by.row=FALSE,
               simple.pch=list(filler=LETTERS[1:5], raw=letters[6:9]), cex=2)



ToothGrowth$dose &lt;- positioned(ToothGrowth$dose) ## modify local copy
anova(aov(len ~ supp*dose, data=ToothGrowth))
interaction2wt(len ~ supp + dose, data=ToothGrowth)


esoph$ntotal &lt;- with(esoph, ncases + ncontrols) ## modify local copy
esoph$rate   &lt;- with(esoph, ncases/ntotal)      ## modify local copy

position(esoph$alcgp) &lt;- 2:5
position(esoph$tobgp) &lt;- 2:5

interaction2wt(rate ~ agegp + alcgp + tobgp, esoph, rot=c(90,0),
               par.strip.text=list(cex=.8))

interaction2wt(rate ~ agegp + alcgp + tobgp, esoph, rot=c(90,0),
               par.strip.text=list(cex=.8),
               factor.expressions=c(
                 agegp=expression(Age~~(years)),
                 alcgp=expression(Alcohol~
                   bgroup("(",scriptstyle(frac(gm, day)),")")),
                 tobgp=expression(Tobacco~
                   bgroup("(",scriptstyle(frac(gm, day)),")"))),
               par.settings=list(
                 par.xlab.text=list(cex=.8),
                 par.ylab.text=list(cex=.8)),
               responselab.expression="Cancer\nRate",
               main=list(
"Esophogeal Cancer Rate ~ Alcohol Consumption + Tobacco Consumption",
                 cex=1.2))

esoph.aov &lt;- aov(rate ~ agegp + alcgp + tobgp, data=esoph)
anova(esoph.aov)

</code></pre>

<hr>
<h2 id='interval'>Prediction and Confidence Intervals for glm Objects</h2><span id='topic+interval'></span><span id='topic+interval.glm'></span>

<h3>Description</h3>

<p>Prediction and Confidence Intervals for <code>glm</code> Objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>interval(glm.object, ...)
## S3 method for class 'glm'
interval(glm.object, linkfit.object,
         type = c("link", "response"),
         conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interval_+3A_glm.object">glm.object</code></td>
<td>
<p>result from a call to the <code>glm</code> function.</p>
</td></tr>
<tr><td><code id="interval_+3A_linkfit.object">linkfit.object</code></td>
<td>
<p>result from a call to the <code>predict</code>
function for the <code>glm.object</code> with <code>type="link", se.fit=TRUE</code>.</p>
</td></tr>
<tr><td><code id="interval_+3A_type">type</code></td>
<td>
<p>Either <code>"link"</code> or <code>"response"</code>.  See
<code><a href="stats.html#topic+predict.glm">predict.glm</a></code> for details.</p>
</td></tr>
<tr><td><code id="interval_+3A_conf.level">conf.level</code></td>
<td>
<p>Confidence level, for example <code>.95</code> for 95%.</p>
</td></tr>
<tr><td><code id="interval_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code>predict.glm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with five columns: <code>fit, ci.low, ci.hi, pi.low,
    pi.hi</code> and as many rows as <code>predict.glm</code> returns.</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spacshu)
spacshu.bin.glm &lt;- glm(damage ~ tempF, data=spacshu, family=binomial)

## observed data
spacshu.interval          &lt;- interval(spacshu.bin.glm)

## new data, link
spacshu.interval.link     &lt;- interval(spacshu.bin.glm, newdata=data.frame(tempF=30:85))

## new data, response
spacshu.interval.response &lt;- interval(spacshu.bin.glm, newdata=data.frame(tempF=30:85),
                                      type="response")
</code></pre>

<hr>
<h2 id='intxplot'>Interaction plot, with an option to print standard error bars.
</h2><span id='topic+intxplot'></span><span id='topic+panel.intxplot'></span>

<h3>Description</h3>

<p>Interaction plot, with an option to print standard error bars.
There is an option to offset group lines to prevent the
bars from overprinting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intxplot(x, data=NULL, groups.in,
          scales,
          key.length=1,
          key.lines,
          key=TRUE,
          trace.factor.name=deparse(substitute(groups.in)),
          x.factor.name=x.factor,
          xlab=x.factor.name,
          main=list(main.title, cex=main.cex),
          condition.name="condition",
          panel="panel.intxplot",
          summary.function="sufficient",
          se,
          ...,
          data.is.summary=FALSE,
          main.title=paste(
            "Interactions of", trace.factor.name, "and",
            x.factor.name,
            if (length(x[[3]]) &gt; 1)
            paste("|", condition.name.to.use)),
          main.cex=1.5,
          col, lwd, lty, alpha)

panel.intxplot(x, y, subscripts, groups, type = "l", se, cv=1.96,
               offset.use=(!missing(groups) &amp;&amp; !missing(se)),
               offset.scale=2*max(as.numeric(groups)),
               offset=
               as.numeric(groups[match(levels(groups), groups)]) / offset.scale,
               rug.use=offset.use,
               col, lwd, lty, alpha,
               ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intxplot_+3A_x">x</code></td>
<td>
<p>For <code>intxplot</code>, a formula with a factor as the
predictor variable.
For <code>panel.intxplot</code>, standard argument for panel functions.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_data">data</code></td>
<td>
<p>data.frame, as used in <code>xyplot</code>.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_groups.in">groups.in</code></td>
<td>
<p><code>groups.in</code>, as used in <code>xyplot</code>.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_scales">scales</code></td>
<td>
<p>Optional, additional arguments for the standard <code>scales</code>
in <code>xyplot</code>.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_key.length">key.length</code></td>
<td>
<p>Number of columns in the key.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_key.lines">key.lines</code></td>
<td>
<p>default value for the <code>lines</code> argument of <code>key</code>.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_key">key</code></td>
<td>
<p>logical.  If <code>TRUE</code>, draw the key.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_trace.factor.name">trace.factor.name</code></td>
<td>
<p>Name of the grouping variable.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_x.factor.name">x.factor.name</code></td>
<td>
<p>name of the dependent variable.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_xlab">xlab</code></td>
<td>
<p>as in <code>xyplot</code>, defaults to the name of the predictor variable
from the formula.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_main">main</code></td>
<td>
<p>as in <code>xyplot</code>.  Defaults to the <code>main.title</code> argument.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_panel">panel</code></td>
<td>
<p>as in <code>xyplot</code>.  Defaults to the <code>"panel.intxplot"</code>.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_condition.name">condition.name</code></td>
<td>
<p>name of the conditioning variable.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_summary.function">summary.function</code></td>
<td>
<p>The default <code>sufficient</code> finds the mean,
standard deviation, and sample size of the response variable for each
level of the conditioning factor. See <code><a href="#topic+sufficient">sufficient</a></code>.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_se">se</code></td>
<td>
<p>standard errors to be passed to <code>panel.intxplot</code>.
<code>se</code> Missing, logical, or a numeric vector.
If missing or <code>FALSE</code>, standard errors are not plotted.
If <code>se=TRUE</code> in <code>intxplot</code>,
the standard errors are calculated from the
sufficient statistics for each group as the group's standard deviation
divided by the square root of the group's observation
count.  If <code>se</code> is numeric vector, it is evaluated in the environment of
the sufficient statistics.
the <code>se</code> argument to <code>panel.intxplot</code> must be numeric.
</p>
</td></tr></table>
<p>,
</p>
<table>
<tr><td><code id="intxplot_+3A_...">...</code></td>
<td>
<p>In <code>intxplot</code>, arguments for <code>panel.intxplot</code>.
In <code>panel.intxplot</code>, arguments for <code>panel.superpose</code>.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_data.is.summary">data.is.summary</code></td>
<td>
<p>logical, defaults to <code>FALSE</code> under the
assumption that the input data.frame is the original data and the
<code>intxplot</code> function will generate the summary information
(primarily standard deviation <code>sd</code> and number of
observations <code>nobs</code> for each group).  When <code>TRUE</code>, the
standard error calculation assumes variables <code>sd</code> and
<code>nobs</code> are in the dataset.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_main.title">main.title</code></td>
<td>
<p>Default main title for plot.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_main.cex">main.cex</code></td>
<td>
<p>Default character expansion for main title.</p>
</td></tr>

<tr><td><code id="intxplot_+3A_y">y</code>, <code id="intxplot_+3A_subscripts">subscripts</code>, <code id="intxplot_+3A_groups">groups</code>, <code id="intxplot_+3A_type">type</code></td>
<td>
<p>Standard arguments for panel functions.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_cv">cv</code></td>
<td>
<p>critical value for confidence intervals. Defaults to 1.96.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_offset.use">offset.use</code></td>
<td>
<p>logical.  If <code>TRUE</code>, offset the endpoints
of each group.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_offset.scale">offset.scale</code></td>
<td>
<p>Scale number indicating how far apart the
ends of the groups will be placed.  Larger numbers make them closer
together.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_offset">offset</code></td>
<td>
<p>Actual numbers by which the end of the groups are offset
from their nominal location which is the <code>as.numeric</code> of the
group levels.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_rug.use">rug.use</code></td>
<td>
<p>logical. If <code>TRUE</code>, display a rug for the endpoints
of each group.</p>
</td></tr>
<tr><td><code id="intxplot_+3A_col">col</code>, <code id="intxplot_+3A_lwd">lwd</code>, <code id="intxplot_+3A_lty">lty</code>, <code id="intxplot_+3A_alpha">alpha</code></td>
<td>
<p>Arguments to
<code>trellis.par.set(superpose.line=list())</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"trellis"</code> object.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+sufficient">sufficient</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## This uses the same data as the HH Section 12.13 rhizobium example.

data(rhiz.clover)

## interaction plot, no SE
intxplot(Npg ~ strain, groups=comb, data=rhiz.clover,
         main="Interaction Plot. No SE")

## interaction plot, individual SE for each treatment combination
## Rescaled to allow the CI bars to stay within the plot region
intxplot(Npg ~ strain, groups=comb, data=rhiz.clover, se=TRUE,
         ylim=c(17,47),
         main="Interaction Plot. Rescaled to keep CI bars within the plot region")

## Common SE based on ANOVA table. Rescaled to allow the CI bars to stay within the plot region
intxplot(Npg ~ strain, groups=comb, data=rhiz.clover,
         se=sqrt(sum((nobs-1)*sd^2)/(sum(nobs-1)))/sqrt(5),
         ylim=c(16,41),
         main=paste("Interaction Plot. Common SE based on ANOVA table.\n",
                    "Rescaled to keep CI bars within the plot region"))

## change distance between endpoints
intxplot(Npg ~ strain, groups=comb, data=rhiz.clover, se=TRUE,
         offset.scale=10, ylim=c(18,46),
         main="Interaction plot. Change distance between endpoints")

## When data includes the nobs and sd variables, data.is.summary=TRUE is needed.
intxplot(Npg ~ strain, groups=comb,
         se=sqrt(sum((nobs-1)*sd^2)/(sum(nobs-1)))/sqrt(5),
         data=sufficient(rhiz.clover, y="Npg", c("strain","comb")),
         data.is.summary=TRUE,
         ylim=c(16,41),
         main=paste("Interaction plot. When data includes the nobs and sd variables,\n",
           "'data.is.summary=TRUE' is needed"))

</code></pre>

<hr>
<h2 id='ladder'>Draw a &quot;ladder of powers&quot; plot, plotting each of several powers
of y against the same powers of x.</h2><span id='topic+ladder'></span><span id='topic+ladder3'></span><span id='topic+ladder.f'></span><span id='topic+ladder.fstar'></span><span id='topic+strip.ladder'></span>

<h3>Description</h3>

<p>Draw a &quot;ladder of powers&quot; plot, plotting each of several powers
of y against the same powers of x.  The powers are
</p>
<p><code>result &lt;- data.frame(-1/x, -1/sqrt(x), log(x), sqrt(x), x, x^2)</code>
</p>
<p><code>names(result) &lt;- c(-1, -.5, 0, .5, 1, 2)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ladder(formula.in, data=NULL,
       main.in="Ladders of Powers",
       panel.in=panel.cartesian,
       xlab=deparse(formula.in[[3]]),
       ylab=deparse(formula.in[[2]]),
       scales=list(alternating=FALSE,
         labels=FALSE, ticks=FALSE, cex=.6),
       par.strip.text=list(cex=.6),
       cex=.5, pch=16, between=list(x=.3, y=.3),
       dsx=xlab,
       dsy=ylab,
       ladder.function=ladder.f,
       strip.number=2,
       strip.names,
       strip.style=1,
       strip,
       oma=c(0,0,0,0),  ## S-Plus
       axis3.line=.61,
       layout=c(length(tmp$x.power), length(tmp$y.power)),
       axis.key.padding = 10, ## R right axis
       key.axis.padding = 10, ## R top axis
       useOuter=TRUE, ## R useOuterStrips(combineLimits(result))
       ...)

ladder3(x, y,
        dsx=deparse(substitute(x)),
        dsy=deparse(substitute(y)),
        ladder.function=ladder.f)

ladder.f(x, name.prefix="")

ladder.fstar(x, name.prefix="")

strip.ladder(which.given,
             which.panel,
             var.name,
             factor.levels,
             shingle.intervals,
             par.strip.text=trellis.par.get("add.text"),
             strip.names=c(TRUE,TRUE),
             style=1,
             ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ladder_+3A_formula.in">formula.in</code></td>
<td>
<p>A formula with exactly one variable on each side.</p>
</td></tr>
<tr><td><code id="ladder_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="ladder_+3A_main.in">main.in</code></td>
<td>
<p><code>main</code> title for <code>xyplot</code></p>
</td></tr>
<tr><td><code id="ladder_+3A_panel.in">panel.in</code></td>
<td>
<p><code>panel.cartesian</code> has many arguments in addition
to the arguments in <code>panel.xyplot</code>.  Any replacement
panel function must have those argument names, even if it
doesn't do anything with them.</p>
</td></tr>
<tr><td><code id="ladder_+3A_xlab">xlab</code>, <code id="ladder_+3A_ylab">ylab</code></td>
<td>
<p>Trellis arguments,  default to right- and left-sides
of the <code>formula.in</code>.</p>
</td></tr>
<tr><td><code id="ladder_+3A_strip">strip</code></td>
<td>
<p>Strip function. Our default is <code>strip.ladder</code>
(see below).  The other viable argument value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ladder_+3A_cex">cex</code>, <code id="ladder_+3A_pch">pch</code>, <code id="ladder_+3A_between">between</code>, <code id="ladder_+3A_scales">scales</code>, <code id="ladder_+3A_layout">layout</code></td>
<td>
<p>arguments for <code>xyplot</code>.</p>
</td></tr>
<tr><td><code id="ladder_+3A_dsx">dsx</code>, <code id="ladder_+3A_dsy">dsy</code></td>
<td>
<p>Names to be used as level names in
<code>ladder.function</code> for the generated factor distinguishing the
powers.  They default to <code>xlab, ylab</code>.  For long variable names,
an abbreviated name here will decrease clutter in the ladder of powers
plot.  These names are not visible in the plot when
<code>strip=FALSE</code>.</p>
</td></tr>
<tr><td><code id="ladder_+3A_ladder.function">ladder.function</code></td>
<td>
<p>function to use to create data.frame of powers
of input variable.</p>
</td></tr>
<tr><td><code id="ladder_+3A_name.prefix">name.prefix</code></td>
<td>
<p>Base name used for column names of powers.  The
default is empty (<code>""</code>).  An alternative must include
the power symbol <code>"^"</code>, for example, <code>"abc^"</code>.</p>
</td></tr>
<tr><td><code id="ladder_+3A_strip.number">strip.number</code></td>
<td>
<p>Number of strip labels in each panel of the display.
0: no strip labels; 1: one strip label of the form <code>y^p ~ x^q</code>;
2: two strip labels of the form <code>ylab: y^p</code> and <code>xlab: x^q</code>,
where <code>p</code> and <code>q</code> are the powers returned by <code>ladders</code>;
<code>y</code> and <code>x</code> are the arguments <code>dsy</code> and <code>dsx</code>.</p>
</td></tr>
<tr><td><code id="ladder_+3A_useouter">useOuter</code></td>
<td>
<p>logical, defaults to <code>TRUE</code>. In R, this implies
that <code>strip.number</code> is forced to <code>2</code> and that the
resulting <code>"trellis"</code> object will be sent through<br />
<code>useOuterStrips(combineLimits(result))</code>.<br />
This argument is ignored by S-Plus.</p>
</td></tr>
<tr><td><code id="ladder_+3A_strip.style">strip.style</code></td>
<td>
<p><code>style</code> argument to <code>strip</code>.</p>
</td></tr>
<tr><td><code id="ladder_+3A_oma">oma</code></td>
<td>
<p>argument to <code>par</code> in S-Plus.</p>
</td></tr>
<tr><td><code id="ladder_+3A_...">...</code></td>
<td>
<p>other arguments to <code>xyplot</code>.</p>
</td></tr>
<tr><td><code id="ladder_+3A_axis3.line">axis3.line</code></td>
<td>
<p>extra space to make the top axis align with the top
of the top row of panels.  Trial and error to choose a good value.</p>
</td></tr>
<tr><td><code id="ladder_+3A_axis.key.padding">axis.key.padding</code></td>
<td>
<p>Extra space on right of set of panels in R.</p>
</td></tr>
<tr><td><code id="ladder_+3A_key.axis.padding">key.axis.padding</code></td>
<td>
<p>Extra space on top of set of panels in R.</p>
</td></tr>
<tr><td><code id="ladder_+3A_x">x</code>, <code id="ladder_+3A_y">y</code></td>
<td>
<p>variables.</p>
</td></tr>
<tr><td><code id="ladder_+3A_which.given">which.given</code>, <code id="ladder_+3A_which.panel">which.panel</code>, <code id="ladder_+3A_var.name">var.name</code>, <code id="ladder_+3A_factor.levels">factor.levels</code>, <code id="ladder_+3A_shingle.intervals">shingle.intervals</code>, <code id="ladder_+3A_par.strip.text">par.strip.text</code></td>
<td>
<p>See
<code><a href="lattice.html#topic+strip.default">strip.default</a></code>.
</p>
</td></tr>
<tr><td><code id="ladder_+3A_strip.names">strip.names</code>, <code id="ladder_+3A_style">style</code></td>
<td>
<p>We always print the <code>strip.names</code>
in <code>style=1</code>.  Multicolored styles are too busy.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ladder</code> function uses <code>panel.cartesian</code> which is
defined differently in R (using grid graphics) and S-Plus (using
traditional graphics).  Therefore the fine control over appearance
uses different arguments or different values for the same arguments.
</p>


<h3>Value</h3>

<p><code>ladder</code> returns a <code>"trellis"</code> object.
</p>
<p>The functions <code>ladder.fstar</code> and <code>ladder.f</code> take an input
vector <code>x</code> of non-negative values and construct a data.frame by
taking the input to the powers <code>c(-1, -.5, 0, .5, 1, 2)</code>, one
column per power.  <code>ladder.f</code> uses the simple powers and
<code>ladder.fstar</code> uses the scaled Box&ndash;Cox transformation.
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>ladder.fstar</code>        </td><td style="text-align: left;"> <code>ladder.fstar</code>         </td><td style="text-align: right;"> notation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>(x^p - 1)/p</code>         </td><td style="text-align: left;"> <code>(x^p - 1)/p</code>          </td><td style="text-align: right;">    p     </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>(1/x - 1)/(-1)</code>      </td><td style="text-align: left;"> <code>(1/x - 1)/(-1)</code>       </td><td style="text-align: right;">   -1.0   </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>(1/sqrt(x)-1)/(-.5)</code> </td><td style="text-align: left;"> <code>(1/sqrt(x)-1)/(-.5)</code>  </td><td style="text-align: right;">   -0.5   </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>log(x)</code>              </td><td style="text-align: left;"> <code>log(x)</code>               </td><td style="text-align: right;">    0.0   </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>((sqrt(x)-1)/.5)</code>    </td><td style="text-align: left;"> <code>((sqrt(x)-1)/.5)</code>     </td><td style="text-align: right;">    0.5   </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>x-1</code>                 </td><td style="text-align: left;"> <code>x-1</code>                  </td><td style="text-align: right;">    1.0   </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>(x^2 - 1)/2</code>         </td><td style="text-align: left;"> <code>(x^2 - 1)/2</code>          </td><td style="text-align: right;">    2.0   </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td>
</tr>

</table>

<p><code>ladder3</code> takes two vectors as arguments.  It returns a
<code>data.frame</code> with five columns:
</p>
<p><code>X, Y</code>: data to be plotted.  The column <code>X</code> contains the data
from the input <code>x</code> taken to all the powers and aligned with the
similarly expanded column <code>Y</code>.
</p>
<p><code>x, y</code>: symbolic labeling of the power corresponding to <code>X,Y</code>.
</p>
<p><code>group</code>: result from pasting the labels in <code>x, y</code> with <code>*</code>
between them.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>
<p>Hoaglin, D.~C., Mosteller, F., and Tukey, J.~W., editors (1983).
<em>Understanding Robust and Exploratory Data Analysis</em>.
Wiley.
</p>
<p>Box, G. E.~P. and Cox, D.~R. (1964).
An analysis of transformations.
<em>J. Royal Statist Soc B</em>, 26:211&ndash;252.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+panel.cartesian">panel.cartesian</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tv)

## default
## R: outer strip labels
ladder(life.exp ~ ppl.per.phys, data=tv,
       main="Ladder of Powers for Life Expectancy and People per Physician")

## Not run: 
## one strip label
  ladder(life.exp ~ ppl.per.phys, data=tv, strip.number=1, useOuter=FALSE,
         dsx="ppp", dsy="le")

## two strip labels
  ladder(life.exp ~ ppl.per.phys, data=tv, strip.number=2, useOuter=FALSE)

## outer strip labels
ladder(life.exp ~ ppl.per.phys, data=tv, useOuter=TRUE)

## no strip labels (probably silly, but possible)
ladder(life.exp ~ ppl.per.phys, data=tv, strip.number=0, useOuter=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='latex.array'>
Generate the latex code for an <code>"array"</code> or <code>"table"</code> with 3, 4, or more dimensions.
</h2><span id='topic+latex.array'></span><span id='topic+latex.matrix'></span><span id='topic+latex.table'></span>

<h3>Description</h3>

<p>Generate the latex code for an <code>"array"</code> or <code>"table"</code> with 3, 4, or more dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
latex(object, ...,
       var.sep = "}\\tabularnewline{\\bfseries ", value.sep = ": ",
       use.ndn = TRUE, cgroup = NULL,
       ## rgroup here captures and ignores any incoming rgroup argument
       rgroup = NULL, n.rgroup = NULL,
       title = first.word(deparse(substitute(object))),
       rowlabel=title,
            rsubgroup=NULL, n.rsubgroup=NULL)

## S3 method for class 'matrix'
latex(object, ...,
        use.ndn=TRUE, cgroup=NULL,
        title=first.word(deparse(substitute(object))),
        rowlabel=title)

## S3 method for class 'table'
latex(object, ...) ## prepend c("matrix", "array") to the
        ## class of the input object, and then call latex.default

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latex.array_+3A_object">object</code></td>
<td>

<p>A <code>c("matrix", "array")</code> or <code>"table"</code> object.
</p>
</td></tr>
<tr><td><code id="latex.array_+3A_...">...</code></td>
<td>

<p>Arguments forwarded to the &quot;default&quot; method for <code><a href="Hmisc.html#topic+latex">latex</a></code>.
</p>
</td></tr>
<tr><td><code id="latex.array_+3A_use.ndn">use.ndn</code></td>
<td>
<p>Logical.
<code>ndn</code> is an abbreviation for &quot;Names of DimNames&quot;.  When
<code>TRUE</code> (the default), the <code>rowlabel</code>, <code>cgroup</code>, and
<code>rgroup</code> values will be taken from the
<code>names(dimnames(object))</code>.
</p>
</td></tr>
<tr><td><code id="latex.array_+3A_rgroup">rgroup</code>, <code id="latex.array_+3A_n.rgroup">n.rgroup</code></td>
<td>

<p>These are the standard arguments for <code><a href="Hmisc.html#topic+latex">latex</a></code>.
Incoming values for <code>rgroup</code> and <code>n.rgroup</code> are ignored by <code>latex.array</code>
and replaced with values constructed from the names of the dimnames of the third
and higher dimensions of the input array <code>object</code>.
Each item in <code>rgroup</code> is assigned the appropriate
combination of <code>names(dimnames(object))[-(1:2)]</code>.</p>
</td></tr>
<tr><td><code id="latex.array_+3A_rsubgroup">rsubgroup</code>, <code id="latex.array_+3A_n.rsubgroup">n.rsubgroup</code></td>
<td>

<p>These are based on the standard arguments for <code><a href="Hmisc.html#topic+latex">latex</a></code>.
Incoming values for <code>rsubgroup</code> and <code>n.rsubgroup</code> are 
applied to the rows of each <code>rgroup</code>.</p>
</td></tr>
<tr><td><code id="latex.array_+3A_title">title</code>, <code id="latex.array_+3A_rowlabel">rowlabel</code>, <code id="latex.array_+3A_cgroup">cgroup</code></td>
<td>

<p>These are the standard arguments for <code><a href="Hmisc.html#topic+latex">latex</a></code>.
When <code>use.ndn</code> is <code>TRUE</code> (the default), then
<code>rowlabel</code> is assigned the <code>names(dimnames(object))[1]</code> and
<code>cgroup</code> is assigned the <code>names(dimnames(object))[2]</code>.
</p>
</td></tr>
<tr><td><code id="latex.array_+3A_value.sep">value.sep</code></td>
<td>
<p>When <code>use.ndn</code> is <code>TRUE</code> (the default), and
<code>length(dim(object)) &gt;= 3</code> then this string is used in the
constructed <code>rgroup</code> values
to separate the factor name from the factor level of the specified
dimension, for example <code>ABC: 5</code>.
</p>
</td></tr>
<tr><td><code id="latex.array_+3A_var.sep">var.sep</code></td>
<td>
<p>When <code>use.ndn</code> is <code>TRUE</code> (the default), and
<code>length(dim(object)) &gt;= 4</code> then this string is used in the
in the constructed <code>rgroup</code> values
to separate the name and level of each dimension, for example
<code>ABC: 5 ; DEF: 6</code>.  The default value is exactly what
<code>Hmisc::latex</code>
needs in order to place two or more lines (one for each dimension) in boldface.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>latex.matrix</code> calls <code>latex.default</code> directly.
When <code>use.ndn</code> is <code>TRUE</code> (the default), <code>rowlabel</code> and
<code>cgroup</code> are constructed from <code>names(dimnames(object))</code>
unless the user explicitly specified them.
</p>
<p><code>latex.array</code> appends all two-dimensional layers
<code>object[,, one, at, a, time]</code> into a single long <code>"matrix"</code>,
ignores any incoming <code>rgroup</code> and <code>n.rgroup</code> (with a warning),
and constructs <code>rgroup</code> and <code>n.rgroup</code> to label the layers.
When <code>use.ndn</code> is <code>TRUE</code> (the default), <code>rowlabel</code> and
<code>cgroup</code> are constructed from <code>names(dimnames(object))</code>
unless the user explicitly specified them.
</p>
<p><code>latex.table</code> prepends <code>c("matrix", "array")</code> to the class of
the <code>"table"</code> object, then calls the generic <code>"latex"</code>.
This step is necessary because the <code>survey</code> package creates
objects whose class includes the value <code>"table"</code> but not the values
<code>c("matrix", "array")</code>.  Should this object be sent directly to
<code>latex.default</code>, it would cause on error for any table with
dimension larger than two.
</p>


<h3>Value</h3>

<p>See <code><a href="Hmisc.html#topic+latex">latex</a></code>.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="Hmisc.html#topic+latex">latex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## These are the recommended options.  See ?Hmisc::latex for details.
options(latexcmd='pdflatex')
options(dviExtension='pdf')
options(xdvicmd='open')  ## Macintosh, Windows,      SMP linux

## End(Not run)

## This sets up the defaults for latex to write to a pdf file
microplot::latexSetOptions()
## It is needed for R CMD check.
## It is recommended if you normally use pdflatex.
## If you want some other destination for latex, use a non-default argument.


  tmp3 &lt;- array(1:8, c(2,2,2),
                list(letters[1:2],
                     letters[3:4],
                     letters[5:6]))

  tmp3

  ltmp3 &lt;- latex(tmp3) ## assignment prevents display of the generated pdf file
                       ## enter the object name to display the file on screen
  ## ltmp3

  ## latex(tmp3) causes a file tmp3.tex to be created in the working directory.
  ## A user might want to keep tmp3.tex and \input{tmp3.tex} it into a longer .tex file.
  ## R CMD check doesn't like tmp3.tex to remain, so it is removed here.
  file.remove("tmp3.tex")

## Not run: 
  try(  ## warning: Input rgroup and n.rgroup are ignored
    latex(tmp3, rgroup=letters[1:3], n.rgroup=c(1,1,2), file="ignorergroup.tex")
     )

  names(dimnames(tmp3)) &lt;- LETTERS[24:26]
  latex(tmp3, file="LETTERS3.tex")
  latex(tmp3, rowlabel="Something Else", file="SomethingElse.tex")


  tmp4 &lt;- array(1:120, c(5,4,3,2),
                list(letters[1:5],
                     letters[6:9],
                     letters[10:12],
                     letters[13:14]))

  tmp4
  latex(tmp4, var.sep=" ; ")

  names(dimnames(tmp4)) &lt;- LETTERS[23:26]
  latex(tmp4, file="LETTERS4.tex")


  ## with rsubgroup and n.rsubgroup
  latex(tmp4, var.sep=" ; ", file="LETTERS4sub.tex",
        rsubgroup=c("Three","Two"), n.rsubgroup=c(3,2))

  ## with rsubgroup and n.rsubgroup and cgroup and n.cgroup
  latex(tmp4, var.sep=" ; ", file="LETTERS4sub.tex",
        rsubgroup=c("Three","Two"), n.rsubgroup=c(3,2),
        cgroup=c("FGH","I"), n.cgroup=c(3,1))


  tmp2 &lt;- array(1:6, c(3,2),
                list(Rows=letters[1:3],
                     Columns=letters[4:5]))

  tmp2

  latex(tmp2)

  ## Input rgroup honored for "matrix"
  latex(tmp2, rgroup=c("Two","One"), n.rgroup=c(2,1), file="rgroup.tex")

  latex(tmp2, rowlabel="something else", file="something.tex")

  ## tableDemo is based on a table constructed from
  ##         survey::svytable(~ FactorA + FactorB + FactorC, Survey.Design.Object)
  tableDemo &lt;- structure(c(28, 25, 33, 12, 6, 22,  8, 12, 23, 24,  6, 32,
                           32, 31, 59, 11, 2, 33, 10,  3, 23,  7,  2, 26),
                         .Dim = c(3L, 4L, 2L),
                         .Dimnames = list(FactorA = c("a", "b", "c"),
                                          FactorB = c("d", "e", "f", "g"),
                                          FactorC = c("h", "i")),
                         class = "table")

  class(tableDemo)
  latex(tableDemo)

## End(Not run)

</code></pre>

<hr>
<h2 id='latticeresids'>
Subroutine used by residual.plots.lattice
</h2><span id='topic+latticeresids'></span>

<h3>Description</h3>

<p>Subroutine used by <code>residual.plots.lattice</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latticeresids(x, data,
              main = "please use an appropriate main title",
              par.strip.text, scales.cex, y.relation, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latticeresids_+3A_x">x</code>, <code id="latticeresids_+3A_data">data</code>, <code id="latticeresids_+3A_main">main</code>, <code id="latticeresids_+3A_par.strip.text">par.strip.text</code>, <code id="latticeresids_+3A_...">...</code></td>
<td>

<p><span class="pkg">lattice</span> arguments.  See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="latticeresids_+3A_scales.cex">scales.cex</code></td>
<td>

<p><code>cex</code> for the <code>scales</code> argument in <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="latticeresids_+3A_y.relation">y.relation</code></td>
<td>

<p><code>relation</code> for the <code>y</code> argument to <code>scales</code> argument in <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"trellis"</code> object.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+residual.plots.lattice">residual.plots.lattice</a></code>
</p>

<hr>
<h2 id='legendGrob2wt'>place separate keys to the left of each row of a trellis</h2><span id='topic+legendGrob2wt'></span>

<h3>Description</h3>

<p>Each key is created and then inserted into a single grob.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legendGrob2wt(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="legendGrob2wt_+3A_...">...</code></td>
<td>
<p>key1, key2, etc.  Each key will normally be the result of
a <code>draw.key</code> with <code>draw=FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Grid frame object (that inherits from 'grob').
</p>


<h3>Author(s)</h3>

<p>Richard M. Heiberger, with asssistance from Deepayan Sarkar.</p>


<h3>See Also</h3>

<p><code><a href="#topic+interaction2wt">interaction2wt</a></code></p>

<hr>
<h2 id='likert'>Diverging stacked barcharts for Likert, semantic
differential, rating scale data, and population pyramids.</h2><span id='topic+likert'></span><span id='topic+plot.likert'></span><span id='topic+likertplot'></span><span id='topic+plot.likert.formula'></span><span id='topic+plot.likert.matrix'></span><span id='topic+plot.likert.default'></span><span id='topic+plot.likert.array'></span><span id='topic+plot.likert.likert'></span><span id='topic+plot.likert.list'></span><span id='topic+plot.likert.table'></span><span id='topic+plot.likert.ftable'></span><span id='topic+plot.likert.structable'></span><span id='topic+plot.likert.data.frame'></span><span id='topic+xscale.components.top.HH'></span><span id='topic+yscale.components.right.HH'></span><span id='topic+floating'></span><span id='topic+pyramid'></span><span id='topic+sliding'></span><span id='topic+semantic'></span><span id='topic+differential'></span>

<h3>Description</h3>

<p>Constructs and plots diverging stacked barcharts for Likert, semantic
differential, rating scale data, and population pyramids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likert(x, ...)
likertplot(x, ...)
## S3 method for class 'likert'
plot(x, ...)
## S3 method for class 'formula'
plot.likert(x, data, ReferenceZero=NULL, value, levelsName="",
                                scales.in=NULL,   ## use scales=
                                between=list(x=1 + (horizontal), y=.5 + 2*(!horizontal)),
                                auto.key.in=NULL, ## use auto.key=
                                panel.in=NULL,    ## use panel=
                                horizontal=TRUE,
                                par.settings.in=NULL, ## use par.settings=
                                ...,
                                as.percent = FALSE,
                                ## titles
                                ylab= if (horizontal) {
                                  if (length(x)==3)
                                    deparse(x[[2]])
                                  else
                                    "Question"
                                }
                                else
                                if (as.percent != FALSE) "Percent" else "Count",

                                xlab= if (!horizontal) {
                                  if (length(x)==3)
                                    deparse(x[[2]])
                                  else
                                    "Question"
                                }
                                else
                                if (as.percent != FALSE) "Percent" else "Count",

                                main = x.sys.call,

                                ## right axis
                                rightAxisLabels = rowSums(data.list$Nums),
                                rightAxis = !missing(rightAxisLabels),
                                ylab.right = if (rightAxis) "Row Count Totals" else NULL,
                                xlab.top = NULL,
                                right.text.cex =
                                  if (horizontal) { ## lazy evaluation
                                    if (!is.null(scales$y$cex)) scales$y$cex else .8
                                  }
                                  else
                                    {
                                      if (!is.null(scales$x$cex)) scales$x$cex else .8
                                    },

                                ## scales
                                xscale.components = xscale.components.top.HH,
                                yscale.components = yscale.components.right.HH,
                                xlimEqualLeftRight = FALSE,
                                xTickLabelsPositive = TRUE,

                                ## row sequencing
                                as.table=TRUE,
                                positive.order=FALSE,
                                data.order=FALSE,
                                reverse=ifelse(horizontal, as.table, FALSE),

                                ## resizePanels arguments
                                h.resizePanels=sapply(result$y.used.at, length),
                                w.resizePanels=sapply(result$x.used.at, length),

                                ## color options
                                reference.line.col="gray65",
                                col.strip.background="gray97",
                                key.border.white=TRUE,
                                col=likertColor(Nums.attr$nlevels,
                                  ReferenceZero=ReferenceZero,
                                  colorFunction=colorFunction,
                                  colorFunctionOption=colorFunctionOption),
                                colorFunction="diverge_hcl",
                                colorFunctionOption="lighter"
                                )
## S3 method for class 'matrix'
plot.likert(x,
            positive.order=FALSE,
            ylab=names(dimnames(x)[1]),
            xlab=if (as.percent != FALSE) "Percent" else "Count",
            main=xName,
            reference.line.col="gray65",
            col.strip.background="gray97",
            col=likertColor(attr(x, "nlevels"),
              ReferenceZero=ReferenceZero,
              colorFunction=colorFunction,
              colorFunctionOption=colorFunctionOption),
            colorFunction="diverge_hcl",
            colorFunctionOption="lighter",
            as.percent=FALSE,
            par.settings.in=NULL,
            horizontal=TRUE,
            ReferenceZero=NULL,
            ...,
            key.border.white=TRUE,
            xName=deparse(substitute(x)),
            rightAxisLabels=rowSums(abs(x)),
            rightAxis=!missing(rightAxisLabels),
            ylab.right=if (rightAxis) "Row Count Totals" else NULL,
            panel=panel.barchart,
            xscale.components=xscale.components.top.HH,
            yscale.components=yscale.components.right.HH,
            xlimEqualLeftRight=FALSE,
            xTickLabelsPositive=TRUE,
            reverse=FALSE)

## Default S3 method:
plot.likert(x, ...)  ## calls plot.likert.matrix

## S3 method for class 'array'
plot.likert(x,
             condlevelsName=paste("names(dimnames(", xName, "))[-(1:2)]",
                                  sep=""),
             xName=deparse(substitute(x)),
             main=paste("layers of", xName, "by", condlevelsName),
             ...)

## S3 method for class 'likert'
plot.likert(x, ...)  ## See Details

## S3 method for class 'list'
plot.likert(x,  ## named list of matrices, 2D tables,
                               ## 2D ftables, or 2D structables,
                               ## or all-numeric data.frames
            condlevelsName="ListNames",
            xName=deparse(substitute(x)),
            main=paste("List items of", xName, "by", condlevelsName),
            layout=if (length(dim.x) &gt; 1) dim.x else {
                               if (horizontal) c(1, length(x)) else c(length(x), 1)},
            positive.order=FALSE,
            strip=!horizontal,
            strip.left=horizontal,
            strip.left.values=names(x),
            strip.values=names(x),
            strip.par=list(cex=1, lines=1),
            strip.left.par=list(cex=1, lines=1),
            horizontal=TRUE,
            ...,
            rightAxisLabels=sapply(x, function(x) rowSums(abs(x)), simplify = FALSE),
            rightAxis=!missing(rightAxisLabels),
            resize.height.tuning=-.5,
            resize.height=if (missing(layout) || length(dim.x) != 2) {
              c("nrow","rowSums")
            } else {
              rep(1, layout[2])
            },
            resize.width=if (missing(layout)) {1 } else {
              rep(1, layout[1])
            },
            box.ratio=if (
              length(resize.height)==1 &amp;&amp;
              resize.height == "rowSums") 1000 else 2,
            xscale.components=xscale.components.top.HH,
            yscale.components=yscale.components.right.HH)

## S3 method for class 'table'
plot.likert(x, ..., xName=deparse(substitute(x)))
## S3 method for class 'ftable'
plot.likert(x, ..., xName=deparse(substitute(x)))
## S3 method for class 'structable'
plot.likert(x, ..., xName=deparse(substitute(x)))
## S3 method for class 'data.frame'
plot.likert(x, ..., xName=deparse(substitute(x)))


xscale.components.top.HH(...)
yscale.components.right.HH(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likert_+3A_x">x</code></td>
<td>
<p>For the formula method, a model formula.  All terms in the
formula must be the names of columns in the data.frame argument
<code>data</code> or the special abbreviation <code>.</code> only on the right-hand-side.  Functions of the
names will not work.  The right-hand-side must be either <code>.</code> or
the sum of the names of numeric variables in <code>data</code>.
Non-syntactic names must be in quotes (single <code style="white-space: pre;">&#8288;'&#8288;</code> or double
<code style="white-space: pre;">&#8288;"&#8288;</code>), 
but not backticks <code style="white-space: pre;">&#8288;`&#8288;</code>.

The <code>.</code> on the
right-hand-side is expanded to the formula containing the sum of all
remaining (after the response and the conditioning variables)
numeric columns in <code>data</code>.  An empty left-hand-side is
interpreted as the <code>rownames(data)</code>.  See the examples
for all possible forms of formula recognized by the <code>likert</code> function.
</p>
<p>Otherwise, any numeric object stored as a vector, matrix, array,
data.frame, table, ftable, structable (as defined in the <code>vcd</code>
package), or as a list of named two-dimensional objects.  This is
the only required argument.  See the Details section for
restrictions on the form of data.frame, list, ftable, and structable
arguments.
</p>
</td></tr>
<tr><td><code id="likert_+3A_data">data</code></td>
<td>
<p>For the formula method, a <code>data.frame</code>.
Do not use variable names <code>".value"</code> or <code>".variable"</code>.</p>
</td></tr>
<tr><td><code id="likert_+3A_referencezero">ReferenceZero</code></td>
<td>
<p>Numeric scalar or <code>NULL</code>.  The position in
the range<br />
<code>seq(0, attr(x, "nlevels")+.5, .5)</code> where the
reference line at 0 will be placed.  <code>attr(x, "nlevels")</code> is the
number of columns of the original argument <code>x</code>, <em>before</em> it
has been coerced to a <code>"likert"</code> object.  The default
<code>NULL</code> corresponds to the middle level if there are an odd
number of levels, and to half-way between the two middle levels if
there are an even number of levels.  This argument is used when the
number of positive levels and the number of negative levels are not
the same.  For example, with 4 levels<br />
<code>c("Disagree", "Neutral", "Weak Agree", "Strong Agree")</code>, the
argument would be specified <code>ReferenceZero=2</code> indicating that
the graphical split would be in the middle of the second group with
label <code>"Neutral"</code>.</p>
</td></tr>
<tr><td><code id="likert_+3A_value">value</code></td>
<td>
<p>Name of the numeric variable containing the data when the
formula method is used with the long data form.  The predictor in the
formula will be a factor name.  The name of the predictor will be
used as the title in the key.</p>
</td></tr>
<tr><td><code id="likert_+3A_levelsname">levelsName</code></td>
<td>
<p>(optional) Name of the implied factor distinguishing the
columns of the response variables when the formula method is used
with the wide data form.  This name will be used as the title in the key.</p>
</td></tr>
<tr><td><code id="likert_+3A_positive.order">positive.order</code></td>
<td>
<p>If <code>FALSE</code>, the default value, the original
order of the rows is retained.  This is necessary for arrays,
because each panel has the same rownames.  If <code>TRUE</code>, rows are
ordered within each panel with the row whose bar goes farthest to
the right at the top of a panel of horizontal bars or at the left of
a panel of vertical bars.
<code>positive.order</code> is frequently set to <code>TRUE</code> for lists.</p>
</td></tr>
<tr><td><code id="likert_+3A_data.order">data.order</code></td>
<td>
<p><code>formula</code> method only.  If
<code>positive.order</code> is <code>TRUE</code>, this <code>data.order</code>
variable is ignored.
If <code>FALSE</code>, the default value, and the rows are specified by a
factor, then they are ordered by their levels.  If <code>TRUE</code>, then
the rows are ordered by their order in the input <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="likert_+3A_as.percent">as.percent</code></td>
<td>
<p>When <code>as.percent==TRUE</code> or
<code>as.percent=="noRightAxis"</code>, then the values in each row are rescaled
to row percents.
When <code>as.percent==TRUE</code> the original row totals are used as
<code>rightAxisLabels</code>,
<code>rightAxis</code> is set to <code>TRUE</code>, the <code>ylab.right</code> is by
default set to <code>"Row Count Totals"</code> (the user can change its value in
the calling sequence).   When <code>as.percent=="noRightAxis"</code>, then
<code>rightAxis</code> will be set to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="likert_+3A_as.table">as.table</code></td>
<td>
<p>Standard <code>lattice</code> argument.  See <code><a href="lattice.html#topic+xyplot">barchart</a></code>.</p>
</td></tr>
<tr><td><code id="likert_+3A_par.settings.in">par.settings.in</code>, <code id="likert_+3A_scales.in">scales.in</code>, <code id="likert_+3A_auto.key.in">auto.key.in</code>, <code id="likert_+3A_panel.in">panel.in</code></td>
<td>
<p>These are placeholders
for <code>lattice</code> arguments that lets the user
specify some lattice <code>par.settings</code> and still retain the
ones that are prespecified in the<br />
<code>plot.likert.default</code>.</p>
</td></tr>
<tr><td><code id="likert_+3A_ylab">ylab</code>, <code id="likert_+3A_xlab">xlab</code>, <code id="likert_+3A_ylab.right">ylab.right</code>, <code id="likert_+3A_xlab.top">xlab.top</code>, <code id="likert_+3A_main">main</code></td>
<td>
<p>Standard <code>lattice</code> graph
labels in <code><a href="lattice.html#topic+xyplot">barchart</a></code>.</p>
</td></tr>
<tr><td><code id="likert_+3A_right.text.cex">right.text.cex</code></td>
<td>
<p>The right axis, as used here for the
&quot;Row Count Totals&quot;, has non-standard controls.  It's <code>cex</code>
follows the <code>cex</code> of the left axis, unless this argument is
used to override that value.  When <code>horizontal=FALSE</code>, then
the top axis defaults to follow the bottom
axis unless overridden by <code>right.text.cex</code>.</p>
</td></tr>
<tr><td><code id="likert_+3A_between">between</code></td>
<td>
<p>Standard <code>lattice</code> argument.</p>
</td></tr>
<tr><td><code id="likert_+3A_col">col</code></td>
<td>
<p>Vector of color names for the levels of the agreement factor.
Although the colors can be specified as an arbitrary vector of color names, for example,
<code>col=c('red','blue','#4AB3F2')</code>, usually specifying one of the diverging
palettes from <code><a href="colorspace.html#topic+rainbow_hcl">diverge_hcl</a></code> or sequential
palettes from <code><a href="colorspace.html#topic+rainbow_hcl">sequential_hcl</a></code> will suffice.
For less intense colors, you can use the middle colors from a larger
set of colors; e.g., <code>col=sequential_hcl(11)[5:2]</code>.  See the last
<code>AudiencePercent</code> example below for this usage.
</p>
</td></tr>
<tr><td><code id="likert_+3A_colorfunction">colorFunction</code>, <code id="likert_+3A_colorfunctionoption">colorFunctionOption</code></td>
<td>
<p>See <code><a href="#topic+likertColor">likertColor</a></code>.</p>
</td></tr>
<tr><td><code id="likert_+3A_reference.line.col">reference.line.col</code></td>
<td>
<p>Color for reference line at zero.</p>
</td></tr>
<tr><td><code id="likert_+3A_col.strip.background">col.strip.background</code></td>
<td>
<p>Background color for the strip labels.</p>
</td></tr>
<tr><td><code id="likert_+3A_key.border.white">key.border.white</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then place a white
border around the <code>rect</code> in the key, else use the <code>col</code> of
the rect itself.</p>
</td></tr>
<tr><td><code id="likert_+3A_horizontal">horizontal</code></td>
<td>
<p>Logical, with default <code>TRUE</code> indicating
horizontal bars, will be passed to the
<code>barchart</code> function by the <code>plot.likert</code> method.
In addition, it interchanges the meaning of <code>resize.height</code> and
<code>resize.width</code> arguments
to the <code>likert</code> functions applied to arrays and lists.</p>
</td></tr>
<tr><td><code id="likert_+3A_...">...</code></td>
<td>
<p>other arguments.  These will be passed to the <code>barchart</code>
function by the <code>plot.likert</code> method.  The most useful of these
is the <code>border</code> argument which defaults to make the borders of
the bars the same color as the bars themselves.  A scalar
alternative (<code>border="white"</code> being our first choice) puts a border
around each bar in the stacked barchart.  This works very well when
the <code>ReferenceZero</code> line is between two levels.  It gives a
misleading division of the central bar when the <code>ReferenceZero</code>
is in the middle of a level.  See the example in the examples
section.
Arguments to the <code>lattice</code> <code>auto.key=list()</code> argument
(described in <code><a href="lattice.html#topic+xyplot">barchart</a></code>) will be used in the
legend.  See the examples.</p>
</td></tr>
















<tr><td><code id="likert_+3A_strip.left">strip.left</code>, <code id="likert_+3A_strip">strip</code></td>
<td>
<p>Logical. The default <code>strip.left=TRUE</code>
places the strip
labels on the left of each panel as in the
first professional challenges example.
The alternative<br />
<code>strip.left=FALSE</code> puts
the strip labels on the top of each panel, the traditional
lattice strip label position.</p>
</td></tr>
<tr><td><code id="likert_+3A_condlevelsname">condlevelsName</code>, <code id="likert_+3A_strip.left.values">strip.left.values</code>, <code id="likert_+3A_strip.values">strip.values</code>, <code id="likert_+3A_strip.par">strip.par</code>, <code id="likert_+3A_strip.left.par">strip.left.par</code>, <code id="likert_+3A_layout">layout</code></td>
<td>
<p>Arguments which will be passed to
<code><a href="#topic+ResizeEtc">ResizeEtc</a></code>.</p>
</td></tr>
<tr><td><code id="likert_+3A_xname">xName</code></td>
<td>
<p>Name of the argument in its original environment.</p>
</td></tr>
<tr><td><code id="likert_+3A_rightaxis">rightAxis</code></td>
<td>
<p>logical.  Should right axis values be displayed?
Defaults to <code>FALSE</code> unless<br />
<code>rightAxisLabels</code> are specified.</p>
</td></tr>
<tr><td><code id="likert_+3A_rightaxislabels">rightAxisLabels</code></td>
<td>
<p>Values to be displayed on the right axis.  The
default values are the row totals.  These are sensible for
tables of counts.  When the data is rescaled to percents by the
<code>as.percent=TRUE</code> argument, then the <code>rightAxisLabels</code>
are still defaulted to the row totals for the counts.
We illustrate this usage in the <code>ProfChal</code> example.</p>
</td></tr>
<tr><td><code id="likert_+3A_resize.height.tuning">resize.height.tuning</code></td>
<td>
<p>Tuning parameter used to adjust the space
between bars as specified by the <code>resize.height</code> argument to
the <code><a href="#topic+ResizeEtc">ResizeEtc</a></code> function.</p>
</td></tr>
<tr><td><code id="likert_+3A_h.resizepanels">h.resizePanels</code>, <code id="likert_+3A_resize.height">resize.height</code></td>
<td>
<p>Either character scalar or numeric vector.
If <code>"nrow"</code>, then the panels heights are proportional to the number of
bars in each panel.  If <code>"rowSums"</code> and there is exactly one bar
per panel,
then the panels heights are proportional to the total count in each
bar, and see the discussion of the <code>box.ratio</code> argument.
If a numeric vector, the panel heights are proportional to the numbers
in the argument.</p>
</td></tr>
<tr><td><code id="likert_+3A_w.resizepanels">w.resizePanels</code>, <code id="likert_+3A_resize.width">resize.width</code></td>
<td>
<p>Numeric vector.  The panel widths are proportional to the numbers
in the argument.</p>
</td></tr>
<tr><td><code id="likert_+3A_box.ratio">box.ratio</code></td>
<td>
<p>If there are more than one bar in any panel, then
this defaults to the <code>trellis</code> standard value of 2.
If there is exactly one bar in a panel, then the value is 1000, with
the intent to minimize the white space in the panel.  In this way,
when <code>as.percent==TRUE</code>, the
bar total area is the count and the bar widths are all equal at
100%.  See the example below.</p>
</td></tr>
<tr><td><code id="likert_+3A_panel">panel</code></td>
<td>
<p>panel function eventually to be used by <code>barchart</code>.



</p>
</td></tr>
<tr><td><code id="likert_+3A_xscale.components">xscale.components</code>, <code id="likert_+3A_yscale.components">yscale.components</code></td>
<td>
<p>See
<code><a href="lattice.html#topic+axis.default">yscale.components.default</a></code>.
<code>xscale.components.top.HH</code> constructs the top x-axis
labels, when needed, as the names of the bottom x-axis labels.
<code>yscale.components.right.HH</code> constructs the right y-axis
labels, when needed, as the names of the left y-axis labels.  The
names are placed automatically by the <code>plot.likert</code> methods based on
the value of the arguments <code>as.percent</code>, <code>rightAxis</code>,
and <code>rightAxisLabels</code>.  By default, when <code>rightAxis != FALSE</code> the <code>layout.widths</code>
are set to <code>list(ylab.right=5, right.padding=0)</code>.  Otherwise,
those arguments are left at their default values.  They may be
adjusted with an argument of the form <code>par.settings.in=</code><br />
<code>list(layout.widths=list(ylab.right=5, right.padding=0))</code>.<br />
Similarly, spacing for the top labels can be adjusted with an
argument of the form
<code>par.settings.in=list(layout.heights=list(key.axis.padding=6))</code>.
</p>
</td></tr>
<tr><td><code id="likert_+3A_xlimequalleftright">xlimEqualLeftRight</code></td>
<td>
<p>Logical. The default is <code>FALSE</code>.  If
<code>TRUE</code> and <code>at</code> and <code>labels</code> are not explicitly specified,
then the left and right x limits are set to negative
and positive of the larger of the absolute value of the original x limits.
When <code>!horizontal</code>, this argument applies to the y coordinate.</p>
</td></tr>
<tr><td><code id="likert_+3A_xticklabelspositive">xTickLabelsPositive</code></td>
<td>
<p>Logical. The default is <code>TRUE</code>.
If <code>TRUE</code> and <code>at</code> and <code>labels</code> are not explicitly specified,
then the tick labels on the negative side are
displayed as positive values.  When <code>!horizontal</code>, this argument
applies to the y coordinate.</p>
</td></tr>
<tr><td><code id="likert_+3A_reverse">reverse</code></td>
<td>
<p>Logical. The default is <code>FALSE</code>.
If <code>TRUE</code>, the rows of the input matrix are reversed.
The default is to plot the rows from top-to-bottom
for horizontal bars
and from left-to-write for vertical bars.
<code>reverse</code>, <code>positive.order</code>, and <code>horizontal</code> are
independent.
All eight combinations are possible. See the<br />
<code>Eight sequences and orientations</code> section
in the example for all eight.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The counts (or percentages) of respondents on each row who agree with
the statement are shown to the right of the zero line; the counts (or
percentages) who disagree are shown to the left. The counts (or
percentages) for respondents who neither agree nor disagree are split
down the middle and are shown in a neutral color. The neutral category
is omitted when the scale has an even number of choices.
It is difficult to compare
lengths without a common baseline. In this situation, we are primarily
interested in the total count (or percent) to the right or left of the
zero line; the breakdown into strongly or not is of lesser interest so
that the primary comparisons do have a common baseline of zero. The
rows within each panel are displayed in their original order by
default. If the argument <code>positive.order=TRUE</code> is specified, the rows
are ordered by the counts (or percentages) who agree.
</p>
<p>Diverging stacked barcharts are also called &quot;two-directional stacked
barcharts&quot;.  Some authors use the term &quot;floating barcharts&quot; for
vertical diverging stacked barcharts and the term &quot;sliding barcharts&quot;
for horizontal diverging stacked barcharts.
</p>
<p>All items in a list of named two-dimensional objects must have the
same number of columns.  If the items have different column names, the
column names of the last item in the list will be used in the key.  If
the dimnames of the matrices are named, the names will be used in the
plot.  It is possible to produce a likert plot with a list of objects
with different numbers of columns, but not with the
<code>plot.likert.list</code> method.  These must be done manually by using
the <code><a href="#topic+ResizeEtc">ResizeEtc</a></code> function on each of the individual likert
plots.  The difficulty is that the legend is based on the last item in
the list and will have the wrong number of values for some of the
panels.
</p>
<p>A single data.frame <code>x</code> will be plotted as <code>data.matrix(x[sapply(x, is.numeric)])</code>.
The subscripting on the class of the columns is there to remove
columns of characters (which would otherwise be coerced to NA) and
factor columns (which would otherwise be coerced to integers).
A data.frame with only numeric columns will work in a named list.
A list of data.frame with factors or characters will be plotted by
automatically removing columns that are not numeric.
</p>
<p><code>ftable</code> and <code>structable</code> arguments <code>x</code> will be plotted as
<code>as.table(x)</code>.  This changes the display sequence.
Therefore the user will probably want to use <code>aperm</code> on the
<code>ftable</code> or <code>structable</code> before using <code>plot.likert</code>.
</p>
<p>The <code>likert</code> method is designed for use with <code>"likert"</code>
objects created with the independent <span class="pkg">likert</span> package.  It is not
recommended that the <span class="pkg">HH</span> package and the <code>likert</code> package
both be loaded at the same time, as they have incompatible usage of
the exported function names <code>likert</code> and <code>plot.likert</code>.  If
the <span class="pkg">likert</span> package is installed, it can be run without loading
by using the function calls <code>likert::likert()</code> and
<code>likert:::plot.likert()</code>.
</p>


<h3>Value</h3>

<p>A <code>"trellis"</code> object containing the plot.  The plot will be
automatically displayed unless the result is assigned to an object.
</p>


<h3>Note</h3>

<p>The current version of the <code>likert</code> function uses the default diverging
palette from <code><a href="colorspace.html#topic+rainbow_hcl">diverge_hcl</a></code> as the default.
Previous versions used the <code>RColorBrewer</code> palette <code>"RdBu"</code> as the default
color palette.  The previous color palette is still available with an explicit
call to <code><a href="#topic+likertColorBrewer">likertColorBrewer</a></code>, for example
</p>
<p><code>col=likertColorBrewer(nc, ReferenceZero=ReferenceZero,</code><br />
<code>                      BrewerPaletteName="RdBu", middle.color="gray90")</code>
</p>


<h3>Note</h3>

<p>Ann Liu-Ferrara was a beta tester for the shiny app.</p>


<h3>Note</h3>


<dl>
<dt>Documentation note:</dt><dd>
<p>Most of the plots drawn by <code>plot.likert</code> have a long
left-axis tick label.  They therefore require a wider window
than R's default of a nominal 7in <code class="reqn">\times</code> 7in window.  The
comments with the examples suggest aesthetic window sizes.
</p>
</dd>
<dt>Technical note:</dt><dd>
<p>There are three (almost) equivalent calling sequences for likert plots.
</p>

<ol>
<li>
<p><code>likert(x)  ## recommended</code><br />
<code>likert</code> is an alias for <code>plot.likert()</code>.
</p>
</li>
<li>
<p><code>plot.likert(x)</code><br />
<code>plot.likert</code> is both a method of
<code>plot</code> for <code>"likert"</code> objects, and a generic function in its own
right.  There are methods of <code>plot.likert</code> for
<code>"formula"</code>,
<code>"matrix"</code>,
<code>"array"</code>, <code>"table"</code>, and several other classes of input objects.
</p>
</li>
<li>
<p><code>plot(as.likert(x))</code><br />
Both <code>likert</code> and <code>plot.likert</code> work by calling the
<code>as.likert</code> function on their argument <code>x</code>.  Once <code>as.likert</code>
has converted its argument to a <code>"likert"</code> object, the method
dispatch technology for the generic <code>plot.likert</code> is in play.
The user can make the explicit call <code>as.likert(x)</code> to see what
a <code>"likert"</code> object looks like, but is very unlikely to want to
look a second time.
</p>
</li></ol>
</dd></dl>


<h3>Author(s)</h3>

<p>Richard M. Heiberger, with contributions from Naomi B. Robbins &lt;naomi@nbr-graphs.com&gt;.
</p>
<p>Maintainer: Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Richard M. Heiberger, Naomi B. Robbins (2014).,
&quot;Design of Diverging Stacked Bar Charts for Likert Scales and Other Applications&quot;,
Journal of Statistical Software, 57(5), 1&ndash;32,

<a href="https://doi.org/10.18637/jss.v057.i05">doi:10.18637/jss.v057.i05</a>.
</p>
<p>Richard Heiberger and Naomi Robbins (2011),
&quot;Alternative to Charles Blow's Figure in \&quot;Newt's War on Poor Children\&quot;&quot;,
Forbes OnLine, December 20, 2011.
<a href="https://www.forbes.com/sites/naomirobbins/2011/12/20/alternative-to-charles-blows-figure-in-newts-war-on-poor-children-2/">https://www.forbes.com/sites/naomirobbins/2011/12/20/alternative-to-charles-blows-figure-in-newts-war-on-poor-children-2/</a>
</p>
<p>Naomi Robbins (2011), &quot;Visualizing Data: Challenges to
Presentation of Quality Graphics&mdash;and Solutions&quot;, Amstat News,
September 2011, 28&ndash;30.
<code>http://magazine.amstat.org/blog/2011/09/01/visualizingdata/</code>
</p>
<p>Luo, Amy and Tim Keyes (2005). &quot;Second Set of Results in from the Career
Track Member Survey,&quot; Amstat News. Arlington, VA: American Statistical
Association.
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+xyplot">barchart</a></code>, <code><a href="#topic+ResizeEtc">ResizeEtc</a></code>,
<code><a href="#topic+as.likert">as.likert</a></code>,
<code><a href="#topic+as.matrix.listOfNamedMatrices">as.matrix.listOfNamedMatrices</a></code>,
<code><a href="#topic+pyramidLikert">pyramidLikert</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## See file HH/demo/likert-paper.r for a complete set of examples using
## the formula method into the underlying lattice:::barchart plotting
## technology.  See file HH/demo/likert-paper-noFormula.r for the same
## set of examples using the matrix and list of matrices methods.  See
## file HH/demo/likertMosaic-paper.r for the same set of examples using
## the still experimental functions built on the vcd:::mosaic as the
## underlying plotting technology

data(ProfChal)  ## ProfChal is a data.frame.
## See below for discussion of the dataset.


## Count plot
likert(Question ~ . , ProfChal[ProfChal$Subtable=="Employment sector",],
       main='Is your job professionally challenging?',
       ylab=NULL,
       sub="This plot looks better in a 9in x 4in window.")

## Percent plot calculated automatically from Count data
likert(Question ~ . , ProfChal[ProfChal$Subtable=="Employment sector",],
       as.percent=TRUE,
       main='Is your job professionally challenging?',
       ylab=NULL,
       sub="This plot looks better in a 9in x 4in window.")

## formula method
data(NZScienceTeaching)
likert(Question ~ . | Subtable, data=NZScienceTeaching,
       ylab=NULL,
       scales=list(y=list(relation="free")), layout=c(1,2))

## Not run: 
## formula notation with expanded right-hand-side
likert(Question ~
       "Strongly disagree" + Disagree + Neutral + Agree + "Strongly agree" |
       Subtable, data=NZScienceTeaching,
       ylab=NULL,
       scales=list(y=list(relation="free")), layout=c(1,2))

## End(Not run)

## Not run: 
## formula notation with long data arrangement
NZScienceTeachingLong &lt;- reshape2::melt(NZScienceTeaching,
                                        id.vars=c("Question", "Subtable"))
names(NZScienceTeachingLong)[3] &lt;- "Agreement"
head(NZScienceTeachingLong)

likert(Question ~ Agreement | Subtable, value="value", data=NZScienceTeachingLong,
       ylab=NULL,
       scales=list(y=list(relation="free")), layout=c(1,2))

## End(Not run)

## Examples with higher-dimensional arrays.
tmp3 &lt;- array(1:24, dim=c(2,3,4),
              dimnames=list(A=letters[1:2], B=LETTERS[3:5], C=letters[6:9]))

## positive.order=FALSE is the default.  With arrays
## the rownames within each item of an array are identical.

## likert(tmp3)
likert(tmp3, layout=c(1,4))
likert(tmp3, layout=c(2,2), resize.height=c(2,1), resize.width=c(3,4))


## plot.likert interprets vectors as single-row matrices.
## http://survey.cvent.com/blog/customer-insights-2/box-scores-are-not-just-for-baseball
Responses &lt;- c(15, 13, 12, 25, 35)
names(Responses) &lt;- c("Strongly Disagree", "Disagree", "No Opinion",
                      "Agree", "Strongly Agree")
## Not run: 
likert(Responses, main="Retail-R-Us offers the best everyday prices.",
       sub="This plot looks better in a 9in x 2.6in window.")

## End(Not run)
## reverse=TRUE  is needed for a single-column key with
## horizontal=FALSE and with space="right"
likert(Responses, horizontal=FALSE,
       aspect=1.5,
       main="Retail-R-Us offers the best everyday prices.",
       auto.key=list(space="right", columns=1,
                     reverse=TRUE, padding.text=2),
       sub="This plot looks better in a 4in x 3in window.")


## Not run: 
## Since age is always positive and increases in a single direction,
## this example uses colors from a sequential palette for the age
## groups.  In this example we do not use a diverging palette that is
## appropriate when groups are defined by a characteristic, such as
## strength of agreement or disagreement, that can increase in two directions.

## Initially we use the default Blue palette in the sequential_hcl function.
data(AudiencePercent)
likert(AudiencePercent,
       auto.key=list(between=1, between.columns=2),
       xlab=paste("Percentage of audience younger than 35 (left of zero)",
                  "and older than 35 (right of zero)"),
       main="Target Audience",
       col=rev(colorspace::sequential_hcl(4)),
       sub="This plot looks better in a 7in x 3.5in window.")

## The really light colors in the previous example are too light.
## Therefore we use the col argument directly.  We chose to use an
## intermediate set of Blue colors selected from a longer Blue palette.
likert(AudiencePercent,
       positive.order=TRUE,
       auto.key=list(between=1, between.columns=2),
       xlab=paste("Percentage of audience younger than 35",
         "(left of zero) and older than 35 (right of zero)"),
       main="Brand A has the most even distribution of ages",
       col=colorspace::sequential_hcl(11)[5:2],
       scales=list(x=list(at=seq(-90,60,10),
                     labels=as.vector(rbind("",seq(-80,60,20))))),
      sub="This plot looks better in a 7in x 3.5in window.")

## End(Not run)


## Not run: 
## See the ?as.pyramidLikert help page for these examples
## Population Pyramid
data(USAge.table)
USA79 &lt;- USAge.table[75:1, 2:1, "1979"]/1000000
PL &lt;- likert(USA79,
             main="Population of United States 1979 (ages 0-74)",
             xlab="Count in Millions",
             ylab="Age",
             scales=list(
               y=list(
                 limits=c(0,77),
                 at=seq(1,76,5),
                 labels=seq(0,75,5),
                 tck=.5))
             )
PL
as.pyramidLikert(PL)

likert(USAge.table[75:1, 2:1, c("1939","1959","1979")]/1000000,
       main="Population of United States 1939,1959,1979 (ages 0-74)",
       sub="Look for the Baby Boom",
       xlab="Count in Millions",
       ylab="Age",
       scales=list(
         y=list(
           limits=c(0,77),
           at=seq(1,76,5),
           labels=seq(0,75,5),
           tck=.5)),
       strip.left=FALSE, strip=TRUE,
       layout=c(3,1), between=list(x=.5))

## End(Not run)


Pop &lt;- rbind(a=c(3,2,4,9), b=c(6,10,12,10))
dimnames(Pop)[[2]] &lt;- c("Very Low", "Low", "High", "Very High")
likert(as.listOfNamedMatrices(Pop),
            as.percent=TRUE,
            resize.height="rowSums",
            strip=FALSE,
            strip.left=FALSE,
            main=paste("Area and Height are proportional to 'Row Count Totals'.",
                       "Width is exactly 100%.", sep="\n"))


## Professional Challenges example.
##
## The data for this example is a list of related likert scales, with
## each item in the list consisting of differently named rows.  The data
## is from a questionnaire analyzed in a recent Amstat News article.
## The study population was partitioned in several ways.  Data from one
## of the partitions (Employment sector) was used in the first example
## in this help file.  The examples here show various options for
## displaying all partitions on the same plot.
##
data(ProfChal)
levels(ProfChal$Subtable)[6] &lt;- "Prof Recog" ## reduce length of label

## 1. Plot counts with rows in each panel sorted by positive counts.
##
## Not run: 
likert(Question ~ . | Subtable, ProfChal,
       positive.order=TRUE,
       main="This works, but needs more specified arguments to look good")

likert(Question ~ . | Subtable, ProfChal,
       scales=list(y=list(relation="free")), layout=c(1,6),
       positive.order=TRUE,
       between=list(y=0),
       strip=FALSE, strip.left=strip.custom(bg="gray97"),
       par.strip.text=list(cex=.6, lines=5),
       main="Is your job professionally challenging?",
       ylab=NULL,
       sub="This looks better in a 10inx7in window")

## End(Not run)

ProfChalCountsPlot &lt;-
likert(Question ~ . | Subtable, ProfChal,
       scales=list(y=list(relation="free")), layout=c(1,6),
       positive.order=TRUE,
       box.width=unit(.4,"cm"),
       between=list(y=0),
       strip=FALSE, strip.left=strip.custom(bg="gray97"),
       par.strip.text=list(cex=.6, lines=5),
       main="Is your job professionally challenging?",
       rightAxis=TRUE,  ## display Row Count Totals
       ylab=NULL,
       sub="This looks better in a 10inx7in window")
ProfChalCountsPlot


## Not run: 
## 2. Plot percents with rows in each panel sorted by positive percents.
##    This is a different sequence than the counts.  Row Count Totals are
##    displayed on the right axis.
ProfChalPctPlot &lt;-
likert(Question ~ . | Subtable, ProfChal,
       as.percent=TRUE,    ## implies display Row Count Totals
       scales=list(y=list(relation="free")), layout=c(1,6),
       positive.order=TRUE,
       box.width=unit(.4,"cm"),
       between=list(y=0),
       strip=FALSE, strip.left=strip.custom(bg="gray97"),
       par.strip.text=list(cex=.6, lines=5),
       main="Is your job professionally challenging?",
       rightAxis=TRUE,  ## display Row Count Totals
       ylab=NULL,
       sub="This looks better in a 10inx7in window")
ProfChalPctPlot

## 3. Putting both percents and counts on the same plot, both in
##    the order of the positive percents.

LikertPercentCountColumns(Question ~ . | Subtable, ProfChal,
                          layout=c(1,6), scales=list(y=list(relation="free")),
                          ylab=NULL, between=list(y=0),
                          strip.left=strip.custom(bg="gray97"), strip=FALSE,
                          par.strip.text=list(cex=.7),
                          positive.order=TRUE,
                          main="Is your job professionally challenging?")


## Restore original name
## levels(ProfChal$Subtable)[6] &lt;- "Attitude\ntoward\nProfessional\nRecognition"

## End(Not run)

## Not run: 
## 4. All possible forms of formula for the likert formula method:
data(ProfChal)
row.names(ProfChal) &lt;- abbreviate(ProfChal$Question, 8)

likert( Question ~ . | Subtable,
       data=ProfChal, scales=list(y=list(relation="free")), layout=c(1,6))

likert( Question ~
          "Strongly Disagree" + Disagree + "No Opinion" + Agree + "Strongly Agree" | Subtable,
       data=ProfChal, scales=list(y=list(relation="free")), layout=c(1,6))

likert( Question ~ . ,
       data=ProfChal)

likert( Question ~ "Strongly Disagree" + Disagree + "No Opinion" + Agree + "Strongly Agree",
       data=ProfChal)

likert( ~ . | Subtable,
       data=ProfChal, scales=list(y=list(relation="free")), layout=c(1,6))

likert( ~ "Strongly Disagree" + Disagree + "No Opinion" + Agree + "Strongly Agree" | Subtable,
       data=ProfChal, scales=list(y=list(relation="free")), layout=c(1,6))

likert( ~ . ,
       data=ProfChal)

likert( ~ "Strongly Disagree" + Disagree + "No Opinion" + Agree + "Strongly Agree",
       data=ProfChal)


## End(Not run)

## Not run: 
## 5. putting the x-axis tick labels on top for horizontal plots
##    putting the y-axis tick lables on right for vertical plots
##
## This non-standard specification is a consequence of using the right
## axis labels for different values than appear on the left axis labels
## with horizontal plots, and using the top axis labels for different
## values than appear on the bottom axis labels with vertical plots.

## Percent plot calculated automatically from Count data

tmph &lt;-
likert(Question ~ . , ProfChal[ProfChal$Subtable=="Employment sector",],
       as.percent=TRUE,
       main='Is your job professionally challenging?',
       ylab=NULL,
       sub="This plot looks better in a 9in x 4in window.")
tmph$x.scales$labels
names(tmph$x.scales$labels) &lt;- tmph$x.scales$labels
update(tmph, scales=list(x=list(alternating=2)), xlab=NULL, xlab.top="Percent")

tmpv &lt;-
likert(Question ~ . , ProfChal[ProfChal$Subtable=="Employment sector",],
       as.percent=TRUE,
       main='Is your job professionally challenging?',
       sub="likert plots with long Question names look better horizontally.
With effort they can be made to look adequate vertically.",
       horizontal=FALSE,
       scales=list(y=list(alternating=2), x=list(rot=c(90, 0))),
       ylab.right="Percent",
       ylab=NULL,
       xlab.top="Column Count Totals",
       par.settings=list(
         layout.heights=list(key.axis.padding=5),
         layout.widths=list(key.right=1.5, right.padding=0))
)
tmpv$y.scales$labels
names(tmpv$y.scales$labels) &lt;- tmpv$y.scales$labels
tmpv
tmpv$x.limits &lt;- abbreviate(tmpv$x.limits,8)
tmpv$x.scales$rot=c(0, 0)
tmpv


## End(Not run)

## Not run: 
## illustration that a border on the bars is misleading when it splits a bar.
tmp &lt;- data.frame(a=1, b=2, c=3)
likert(~ . , data=tmp, ReferenceZero=2, main="No border. OK.")
likert(~ . , data=tmp, ReferenceZero=2, border="white",
       main="Border. Misleading split of central bar.")
likert(~ . , data=tmp, ReferenceZero=2.5, main="No border. OK.")
likert(~ . , data=tmp, ReferenceZero=2.5, border="white", main="Border. OK.")

## End(Not run)

## Not run: 
  ## run the shiny app
if (interactive())  shiny::runApp(system.file("shiny/likert", package="HH"))

## End(Not run)

## The ProfChal data is done again with explicit use of ResizeEtc
## in ?HH:::ResizeEtc

</code></pre>

<hr>
<h2 id='likertColor'>Selection of colors for Likert plots.</h2><span id='topic+likertColor'></span><span id='topic+likertColorBrewer'></span><span id='topic+brewer.pal.likert'></span><span id='topic+ColorSet'></span>

<h3>Description</h3>

<p>Selection of colors for Likert plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ColorSet(nc, ReferenceZero=NULL)
likertColor(nc, ReferenceZero=NULL,
                colorFunction=c("diverge_hcl","sequential_hcl"),
                colorFunctionOption=c("lighter","flatter","default"),
                colorFunctionArgs=
                  likertColorFunctionArgs[[colorFunctionOption, colorFunction]],
                ...)
likertColorBrewer(nc, ReferenceZero=NULL,
                  BrewerPaletteName="RdBu", middle.color="gray90")

brewer.pal.likert(n, name, middle.color)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likertColor_+3A_n">n</code>, <code id="likertColor_+3A_nc">nc</code></td>
<td>
<p>Number of colors in the palette.
If there are more levels than <code>RColorBrewer</code> normally handles, we
automatically interpolate with
<code><a href="grDevices.html#topic+colorRamp">colorRampPalette</a></code>.
</p>
</td></tr>
<tr><td><code id="likertColor_+3A_referencezero">ReferenceZero</code></td>
<td>
<p>Numeric scalar or <code>NULL</code>.  The position in
the range<br />
<code>seq(0, attr(x, "nlevels")+.5, .5)</code> where the
reference line at 0 will be placed.  <code>attr(x, "nlevels")</code> is the
number of columns of the original argument <code>x</code>, <em>before</em> it
has been coerced to a <code>"likert"</code> object.  The default
<code>NULL</code> corresponds to the middle level if there are an odd
number of levels, and to half-way between the two middle levels if
there are an even number of levels.  This argument is used when the
number of positive levels and the number of negative levels are not
the same.  For example, with 4 levels<br />
<code>c("Disagee", "Neutral", "Weak Agree", "Strong Agree")</code>, the
argument would be specified <code>ReferenceZero=2</code> indicating that
the graphical split would be in the middle of the second group with
label <code>"Neutral"</code>.
</p>
</td></tr>
<tr><td><code id="likertColor_+3A_colorfunction">colorFunction</code></td>
<td>
<p>Function name from the <span class="pkg">colorspace</span> package,
either <code>"diverge_hcl"</code> or<br />
<code>"sequential_hcl"</code>.</p>
</td></tr>
<tr><td><code id="likertColor_+3A_colorfunctionoption">colorFunctionOption</code></td>
<td>
<p>Name of a list item defined inside the
<code>likertColor</code>
function.  The item contains a list of parameters to the function
identified in the <code>colorFunction</code> argument.</p>
</td></tr>
<tr><td><code id="likertColor_+3A_colorfunctionargs">colorFunctionArgs</code></td>
<td>
<p>list of arguments to the <span class="pkg">colorspace</span>
function.
The default selects the values by indexing into a list defined in the
<code>likertColor</code> function using the values of the two arguments
<code>colorFunction</code> and  <code>colorFunctionOption</code></p>
</td></tr></table>
<p>.  For
non-default usage, see the BlueOrange example in this help page.
</p>
<table>
<tr><td><code id="likertColor_+3A_...">...</code></td>
<td>
<p>Other arguments are ignored.</p>
</td></tr>
<tr><td><code id="likertColor_+3A_brewerpalettename">BrewerPaletteName</code>, <code id="likertColor_+3A_name">name</code></td>
<td>
<p><code><a href="RColorBrewer.html#topic+ColorBrewer">RColorBrewer</a></code>
palette names. We default to the diverging palette <code>RdBu</code>.
Diverging palettes are usually appropriate for two-directional
scales (Agree&ndash;Disagree).  Sequential palettes are often appropriate
for one-directional scales (Age Ranges).  Qualitative palettes are
usually not appropriate for likert plots.
</p>
</td></tr>
<tr><td><code id="likertColor_+3A_middle.color">middle.color</code></td>
<td>
<p>Darker middle color than the default
<code>"#F7F7F7"</code> in the <code>RdBu</code> scheme.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are support functions for the <code>plot.likert</code> function.
Please see <code><a href="#topic+plot.likert">plot.likert</a></code> for details.
</p>
<p><code>likertColor</code> uses by default the <code><a href="colorspace.html#topic+rainbow_hcl">diverge_hcl</a></code>
diverging palette defined by the argument<br />
<code>colorFunctionOption="lighter"</code>.
</p>
<p><code>likertColorBrewer</code> by default uses the <code>"RdBu"</code>
diverging palette from <code><a href="RColorBrewer.html#topic+ColorBrewer">RColorBrewer</a></code>.
</p>


<h3>Value</h3>

<p><code>ColorSet</code> returns a vector of integers, one per each level,
corresponding to the strength of the levels from Disagree to Agree.
For balanced levels, such as<br />
<code>c("Disagree Strongly", "Disagree Weakly", "Agree
    Weakly", "Agree Strongly")</code>,<br />
corresponding to <code>nc=4,
  ReferenceZero=2.5</code>, it returns <code>-2 -1  1  2</code>.
For unbalanced levels, such as <code>c("Disagree", "Neutral", "Agree
  Weakly", "Agree Strongly")</code>, corresponding to <code>nc=4,
  ReferenceZero=2</code>, it returns <code>-1 0  1  2</code>.
</p>
<p><code>likertColor</code> returns a subset of a palette constructed by
either <code><a href="colorspace.html#topic+rainbow_hcl">diverge_hcl</a></code> or
<code><a href="colorspace.html#topic+rainbow_hcl">sequential_hcl</a></code> in the
<span class="pkg">colorspace</span> package.
The subset corresponds to the levels specified by <code>ColorSet</code>.
</p>
<p><code>brewer.pal.likert</code> returns a
<code><a href="RColorBrewer.html#topic+ColorBrewer">RColorBrewer</a></code> palette.
</p>
<p><code>likertColorBrewer</code> returns a subset of a palette constructed by
<code>brewer.pal.likert</code>.
The subset corresponds to the levels specified by <code>ColorSet</code>.
</p>


<h3>Author(s)</h3>

<p>Richard M. Heiberger,
with contributions from Naomi B. Robbins &lt;naomi@nbr-graphs.com&gt;.
</p>
<p>Maintainer: Richard M. Heiberger &lt;rmh@temple.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.likert">plot.likert</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>brewer.pal.likert(4, "RdBu")
brewer.pal.likert(5, "RdBu")
ColorSet(4)
ColorSet(4, 2)
likertColor(4)
likertColor(4, 2.5) ## same as above
likertColor(4, 2)   ## one negative level and two positive levels: default
likertColor(5, 3)[-2] ## one negative level and two positive levels: stronger negative

## Not run: 
  ## Examples illustrating the six predefined likertColor palettes, and how
  ## to define additional hcl color palettes for use with the likert functions.

  data(ProfDiv)
  ProfDiv.df &lt;- data.frame(ProfDiv)

  likert( ~ . , ProfDiv.df, horizontal=FALSE, positive.order=FALSE)
  likert( ~ . , ProfDiv.df, horizontal=FALSE, positive.order=FALSE,
         colorFunctionOption="default")
  likert( ~ . , ProfDiv.df, horizontal=FALSE, positive.order=FALSE,
         colorFunctionOption="flatter")
  likert( ~ . , ProfDiv.df, horizontal=FALSE, positive.order=FALSE,
         colorFunction="sequential_hcl")
  likert( ~ . , ProfDiv.df, horizontal=FALSE, positive.order=FALSE,
         colorFunction="sequential_hcl", colorFunctionOption="default")
  likert( ~ . , ProfDiv.df, horizontal=FALSE, positive.order=FALSE,
         colorFunction="sequential_hcl", colorFunctionOption="flatter")

  likert(ProfDiv, horizontal=FALSE, positive.order=FALSE)
  likert(ProfDiv, horizontal=FALSE, positive.order=FALSE,
         colorFunctionOption="default")
  likert(ProfDiv, horizontal=FALSE, positive.order=FALSE,
         colorFunctionOption="flatter")
  likert(ProfDiv, horizontal=FALSE, positive.order=FALSE,
         colorFunction="sequential_hcl")
  likert(ProfDiv, horizontal=FALSE, positive.order=FALSE,
         colorFunction="sequential_hcl", colorFunctionOption="default")
  likert(ProfDiv, horizontal=FALSE, positive.order=FALSE,
         colorFunction="sequential_hcl", colorFunctionOption="flatter")

  likertMosaic(ProfDiv.df)
  likertMosaic(ProfDiv.df, colorFunctionOption="default")
  likertMosaic(ProfDiv.df, colorFunctionOption="flatter")
  likertMosaic(ProfDiv.df, colorFunction="sequential_hcl")
  likertMosaic(ProfDiv.df, colorFunction="sequential_hcl",
               colorFunctionOption="default")
  likertMosaic(ProfDiv.df, colorFunction="sequential_hcl",
               colorFunctionOption="flatter")

  ## specify an hcl palette for use with the likert functions.
  BlueOrange &lt;- likertColor(nc=4, ReferenceZero=NULL,
                            colorFunction="diverge_hcl",
                            colorFunctionArgs=
                              list(h=c(246, 40), c=96, l=c(65,90), power=1.5))
  likert( ~ . , ProfDiv.df, horizontal=FALSE, positive.order=FALSE, col=BlueOrange)

## End(Not run)
</code></pre>

<hr>
<h2 id='likertMosaic'>Diverging stacked barcharts for Likert, semantic
differential, rating scale data, and population pyramids
based on mosaic as the plotting style.
</h2><span id='topic+likertMosaic'></span><span id='topic+likertMosaic.array'></span><span id='topic+likertMosaic.data.frame'></span><span id='topic+likertMosaic.default'></span><span id='topic+likertMosaic.formula'></span><span id='topic+likertMosaic.list'></span><span id='topic+likertMosaic.matrix'></span>

<h3>Description</h3>

<p>Constructs and plots diverging stacked barcharts for Likert, semantic
differential, rating scale data, and population pyramids,
.based on <code>mosaic</code> as the plotting style.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likertMosaic(x, ...)

## S3 method for class 'formula'
likertMosaic(x, data, ReferenceZero = NULL, spacing=NULL,
                   ..., between.y = c(1.2, 0.3))

## S3 method for class 'array'
likertMosaic(x, ReferenceZero = NULL, col = NULL, main = NULL,
             ...,
             as.percent = FALSE, variable.width = NULL, positive.order = FALSE,
             Conditions = NULL,
             x.legend = list(text = list(dimnames(x)[[ndim]]),
                             columns = x.dim[ndim],
                             space = "bottom",
                             size = 2,
                             cex = 0.8,
                             between = 0.6,
                             rect= list(col = col, border = "white")),
             legend.y = 0.05,
             spacing = spacing_highlighting,
             split_vertical = c(TRUE, FALSE),
             margins = c(3, 2, 4, 22),
             keep_aspect = FALSE,
             rot_labels = c(0, 0, 90, 0),
             just_labels = c("center", "center", "center", "right"),
             labels = c(TRUE, TRUE, FALSE, TRUE),
             varnames = FALSE,
             zero_size = 0,
             gp = gpar(fill = col.extended, col = 0),
             colorFunction="diverge_hcl",
             colorFunctionOption="lighter")

## S3 method for class 'data.frame'
likertMosaic(x, ...)

## Default S3 method:
likertMosaic(x, ...) ## most likely for a vector

## S3 method for class 'list'
likertMosaic(x, ...)

## S3 method for class 'matrix'
likertMosaic(x, ...,
 split_vertical = c(FALSE, TRUE),
 rot_labels = c(90, 0, 0, 0),
 just_labels = c("left", "center", "center", "right"),
 labels = c(TRUE, FALSE))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likertMosaic_+3A_x">x</code></td>
<td>
<p>For the formula method, a model formula.  Otherwise,
any numeric object stored as a vector, matrix, array,
data.frame, table, ftable,
structable (as defined in the <code>vcd</code> package), or as a list of
named two-dimensional objects.  This is the only required argument.
See the Details section for restrictions on the form of data.frame,
list, ftable, and structable arguments.
</p>
</td></tr>
<tr><td><code id="likertMosaic_+3A_data">data</code></td>
<td>
<p>For the formula method, a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="likertMosaic_+3A_referencezero">ReferenceZero</code></td>
<td>
<p>Numeric scalar or <code>NULL</code>.  The position in
the range<br />
<code>seq(0, attr(x, "nlevels")+.5, .5)</code> where the
reference line at 0 will be placed.  <code>attr(x, "nlevels")</code> is the
number of columns of the original argument <code>x</code>, <em>before</em> it
has been coerced to a <code>"likert"</code> object.  The default
<code>NULL</code> corresponds to the middle level if there are an odd
number of levels, and to half-way between the two middle levels if
there are an even number of levels.  This argument is used when the
number of positive levels and the number of negative levels are not
the same.  For example, with 4 levels<br />
<code>c("Disagee", "Neutral", "Weak Agree", "Strong Agree")</code>, the
argument would be specified <code>ReferenceZero=2</code> indicating that
the graphical split would be in the middle of the second group with
label <code>"Neutral"</code>.</p>
</td></tr>
<tr><td><code id="likertMosaic_+3A_positive.order">positive.order</code></td>
<td>
<p>If <code>FALSE</code>, the default value, the original
order of the rows is retained.  This is necessary for arrays,
because each panel has the same rownames.  If <code>TRUE</code>, rows are
ordered within each panel with the row whose bar goes farthest to
the right at the top of a panel of horizontal bars or at the left of
a panel of vertical bars.
<code>positive.order</code> is frequently set to <code>TRUE</code> for lists.</p>
</td></tr>
<tr><td><code id="likertMosaic_+3A_as.percent">as.percent</code></td>
<td>
<p>When <code>as.percent==TRUE</code> or
<code>as.percent=="noRightAxis"</code>, then the values in each row are rescaled
to row percents.
</p>
</td></tr>
<tr><td><code id="likertMosaic_+3A_variable.width">variable.width</code></td>
<td>

<p>When <code>TRUE</code> and <code>as.percent==TRUE</code>, then the area of the bars
(percent along the length times the width) is proportional to the counts.
</p>
</td></tr>
<tr><td><code id="likertMosaic_+3A_col">col</code></td>
<td>

<p>Colors for the bars.  With the default value <code>NULL</code>, the colors are
chosen from the default <code><a href="colorspace.html#topic+rainbow_hcl">diverge_hcl</a></code> diverging
palette.  Any color specification that R understands can be used here.
</p>
</td></tr>
<tr><td><code id="likertMosaic_+3A_colorfunction">colorFunction</code>, <code id="likertMosaic_+3A_colorfunctionoption">colorFunctionOption</code></td>
<td>
<p>See <code><a href="#topic+likertColor">likertColor</a></code>.</p>
</td></tr>
<tr><td><code id="likertMosaic_+3A_main">main</code></td>
<td>

<p><code>main</code> title for the plot.
</p>
</td></tr>
<tr><td><code id="likertMosaic_+3A_...">...</code></td>
<td>

<p>Additional arguments, passed to the next method and possibly all the way
to <code>strucplot</code>.
</p>
</td></tr>
<tr><td><code id="likertMosaic_+3A_conditions">Conditions</code></td>
<td>

<p>Factor used to divide the rows of the plot into sets of rows
corresponding to levels of Condition. In the formula method, the
conditions are the factors appearing after the <code>|</code> symbol.
</p>
</td></tr>
<tr><td><code id="likertMosaic_+3A_between.y">between.y</code></td>
<td>

<p>vertical spacing between bars.  <code>between.y[1]</code> is used between levels
of conditioning factors, and <code>between.y[2]</code> is used between bars within the
same level of the conditioning factor.
</p>
</td></tr>
<tr><td><code id="likertMosaic_+3A_x.legend">x.legend</code></td>
<td>

<p>Description of legend using the terminology and conventions of the
<code>lattice</code> package.
</p>
</td></tr>
<tr><td><code id="likertMosaic_+3A_legend.y">legend.y</code></td>
<td>

<p>Adjust vertical location of legend.
</p>
</td></tr>
<tr><td><code id="likertMosaic_+3A_spacing">spacing</code>, <code id="likertMosaic_+3A_split_vertical">split_vertical</code>, <code id="likertMosaic_+3A_margins">margins</code>, <code id="likertMosaic_+3A_keep_aspect">keep_aspect</code>, <code id="likertMosaic_+3A_rot_labels">rot_labels</code>, <code id="likertMosaic_+3A_just_labels">just_labels</code>, <code id="likertMosaic_+3A_labels">labels</code></td>
<td>

<p>Please see <code><a href="vcd.html#topic+strucplot">strucplot</a></code> for details.
</p>
</td></tr>
<tr><td><code id="likertMosaic_+3A_varnames">varnames</code>, <code id="likertMosaic_+3A_zero_size">zero_size</code>, <code id="likertMosaic_+3A_gp">gp</code></td>
<td>

<p>Please see <code><a href="vcd.html#topic+strucplot">strucplot</a></code> for details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The counts (or percentages) of respondents on each row who agree with
the statement are shown to the right of the zero line; the counts (or
percentages) who disagree are shown to the left. The counts (or
percentages) for respondents who neither agree nor disagree are split
down the middle and are shown in a neutral color. The neutral category
is omitted when the scale has an even number of choices.
It is difficult to compare
lengths without a common baseline. In this situation, we are primarily
interested in the total count (or percent) to the right or left of the
zero line; the breakdown into strongly or not is of lesser interest so
that the primary comparisons do have a common baseline of zero. The
rows within each panel are displayed in their original order by
default. If the argument <code>positive.order=TRUE</code> is specified, the rows
are ordered by the counts (or percentages) who agree.
</p>
<p>Diverging stacked barcharts are also called &quot;two-directional stacked
barcharts&quot;.  Some authors use the term &quot;floating barcharts&quot; for
vertical diverging stacked barcharts and the term &quot;sliding barcharts&quot;
for horizontal diverging stacked barcharts.
</p>
<p>All items in a list of named two-dimensional objects must have the
same number of columns.  If the items have different column names, the
column names of the last item in the list will be used in the key.  If
the dimnames of the matrices are named, the names will be used in the
plot.  It is possible to produce a likert plot with a list of objects
with different numbers of columns, but not with the
<code>plot.likert.list</code> method.  These must be done manually by using
the <code><a href="#topic+ResizeEtc">ResizeEtc</a></code> function on each of the individual likert
plots.  The difficulty is that the legend is based on the last item in
the list and will have the wrong number of values for some of the
panels.
</p>
<p>A single data.frame <code>x</code> will be plotted as <code>data.matrix(x)</code>;
therefore factor columns will be converted to integers and character
columns will become <code>NA</code> and will be plotted as if they had value
0.  A data.frame with only numeric columns will work in a named list.
A data.frame with factors or characters won't work in a named list.
</p>
<p>ftable and structable arguments <code>x</code> will be plotted as
<code>as.table(x)</code>.  This changes the display sequence.
Therefore the user will probably want to use <code>aperm</code> on the
ftable or structable before using <code>plot.likert</code>.
</p>


<h3>Value</h3>

<p>Please see <code><a href="vcd.html#topic+strucplot">strucplot</a></code> for a description of the
returned object.
</p>


<h3>Note</h3>

<p>The functions described here are currently missing the following features:
</p>

<ol>
<li><p> no axis ticks, number, nor axis label for the x axis
</p>
</li>
<li><p> no zero reference line
</p>
</li>
<li><p> no right-axis labels for Row Count Totals
</p>
</li>
<li><p> no strip.left labels for grouping by Conditions
</p>
</li>
<li><p> In Figure 8 and 9 (<code>HH/demo/likertMosaic-paper.r</code>),
no control of the thickness of the bars
</p>
</li>
<li><p> All bars are horizontal.
</p>
</li>
<li><p> No borders on the overall plot nor on the panels in plots with
grouping by Conditions
</p>
</li>
<li><p> No control of <code>between=list(x=number)</code>
</p>
</li>
<li> <p><code>cex</code> for labeling
</p>
</li>
<li><p> border on empty boxes
</p>
</li>
<li><p> I am using a lattice legend, not a native strucplot legend
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Richard M. Heiberger,
with contributions from Naomi B. Robbins &lt;naomi@nbr-graphs.com&gt;.
</p>
<p>Maintainer: Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Richard M. Heiberger, Naomi B. Robbins (2014).,
&quot;Design of Diverging Stacked Bar Charts for Likert Scales and Other Applications&quot;,
Journal of Statistical Software, 57(5), 1&ndash;32,

<a href="https://doi.org/10.18637/jss.v057.i05">doi:10.18637/jss.v057.i05</a>.
</p>
<p>Richard Heiberger and Naomi Robbins (2011),
&quot;Alternative to Charles Blow's Figure in \&quot;Newt's War on Poor Children\&quot;&quot;,
Forbes OnLine, December 20, 2011.
<a href="https://www.forbes.com/sites/naomirobbins/2011/12/20/alternative-to-charles-blows-figure-in-newts-war-on-poor-children-2/">https://www.forbes.com/sites/naomirobbins/2011/12/20/alternative-to-charles-blows-figure-in-newts-war-on-poor-children-2/</a>
</p>
<p>Naomi Robbins (2011), &quot;Visualizing Data: Challenges to
Presentation of Quality Graphics&mdash;and Solutions&quot;, Amstat News,
September 2011, 28&ndash;30.
<code>http://magazine.amstat.org/blog/2011/09/01/visualizingdata/</code>
</p>
<p>Luo, Amy and Tim Keyes (2005). &quot;Second Set of Results in from the Career
Track Member Survey,&quot; Amstat News. Arlington, VA: American Statistical
Association.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+likert">likert</a></code>, <code><a href="vcd.html#topic+mosaic">mosaic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See file HH/demo/likertMosaic-paper.r for a complete set of examples.
## Not run: 
  require(vcd)
  data(ProfChal)
  likertMosaic(Question ~ . | Subtable, ProfChal,
               main="Is your job professionally challenging?")
  likertMosaic(Question ~ . | Subtable, ProfChal,
               main="Is your job professionally challenging?", as.percent=TRUE)
  likertMosaic(Question ~ . | Subtable, ProfChal,
               main="Is your job professionally challenging?", as.percent=TRUE,
               positive.order=TRUE)
  likertMosaic(Question ~ . | Subtable, ProfChal,
               main="Is your job professionally challenging?", as.percent=TRUE,
               variable.width=TRUE)

  EmpRows &lt;- ProfChal$Subtable == "Employment sector"
  ProfChal2 &lt;- ProfChal[EmpRows, 1:5]
  rownames(ProfChal2) &lt;- substr(ProfChal[EmpRows, "Question"], 1, 5)

  likertMosaic(ProfChal2)
  likertMosaic(ProfChal2, main="Employment")
  likertMosaic(ProfChal2, main="Employment", ReferenceZero=0)
  likertMosaic(ProfChal2, main="Employment", ReferenceZero=3.5)
  likertMosaic(ProfChal2, main="Employment", ReferenceZero=4)
  likertMosaic(ProfChal2, main="Employment", ReferenceZero=6)
  likertMosaic(ProfChal2, main="Employment", positive.order=TRUE)
  likertMosaic(ProfChal2, main="Employment", variable.width=TRUE)

  likertMosaic(~ ., data.frame(ProfChal2), main="Employment", positive.order=TRUE)

  likertMosaic(~ ., data.frame(ProfChal2), main="Employment", variable.width=TRUE)
  likert(~ ., data.frame(ProfChal2), main="Employment", variable.width=TRUE)

  data(SFF8121)
  likertMosaic(aperm(SFF8121, c(3,1,2)))


## End(Not run)
</code></pre>

<hr>
<h2 id='LikertPercentCountColumns'>Display likert plots with percents in the first column of panels
and counts in the second column of panels.</h2><span id='topic+LikertPercentCountColumns'></span>

<h3>Description</h3>

<p>Display likert plots with percents in the first column of
panels and counts in the second column of panels.  Order the rows
either in their original order or by the positive order of the percent
display.</p>


<h3>Usage</h3>

<pre><code class='language-R'>LikertPercentCountColumns(
           x, data,
           px=list( ## defaults designed for long QuestionName values
             LL=c(.00,  .50), ## and 7in x 7in window
             LP=c(.50,  .70),
             ML=c(.50,  .51),  ## arbitrary, visually center the labels and legend
             RP=c(.71,  .87),
             RL=c(.87, 1.00)),
           ...,
           QuestionName="Question",
           as.percent="Capture and then ignore this argument",
           positive.order=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LikertPercentCountColumns_+3A_x">x</code>, <code id="LikertPercentCountColumns_+3A_data">data</code>, <code id="LikertPercentCountColumns_+3A_positive.order">positive.order</code></td>
<td>
<p>formula, data.frame, Logical.
See <code><a href="#topic+likert">likert</a></code>.</p>
</td></tr>
<tr><td><code id="LikertPercentCountColumns_+3A_...">...</code></td>
<td>
<p>other arguments that can be used for <code><a href="#topic+likert">likert</a></code>.</p>
</td></tr>
<tr><td><code id="LikertPercentCountColumns_+3A_px">px</code></td>
<td>
<p>See <code><a href="#topic+as.TwoTrellisColumns5">as.TwoTrellisColumns5</a></code>.</p>
</td></tr>
<tr><td><code id="LikertPercentCountColumns_+3A_as.percent">as.percent</code></td>
<td>
<p>Capture this argument and ignore it.  The
<code>as.percent</code> argument of <code><a href="#topic+likert">likert</a></code> will be
<code>TRUE</code> in the left (Percent) column of the resulting
<code>"TwoTrellisColumns5"</code> object and <code>FALSE</code> in the right
(Count) column.</p>
</td></tr>
<tr><td><code id="LikertPercentCountColumns_+3A_questionname">QuestionName</code></td>
<td>
<p>Character string containing the name of the
column in <code>data</code> containing the values of the response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"TwoTrellisColumns5"</code> object, consisting of a list
containing the constructed left, middle, and right trellis objects,
and an attribute containing the <code>px</code> value.
See <code><a href="#topic+as.TwoTrellisColumns5">as.TwoTrellisColumns5</a></code> for details.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+likert">likert</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## These are based on the Professional Challenges example in ?likert
data(ProfChal)

levels(ProfChal$Subtable)[6] &lt;- "Prof Recog" ## reduce length of label

## See ?print.TwoTrellisColumns for this example using the original ordering

## Order both the plot of the count plot and the percent plot by the
## positive.order of the percent plot.

LikertPercentCountColumns(Question ~ . | Subtable, ProfChal,
                          layout=c(1,6), scales=list(y=list(relation="free")),
                          ylab=NULL, between=list(y=0),
                          strip.left=strip.custom(bg="gray97"), strip=FALSE,
                          par.strip.text=list(cex=.7),
                          positive.order=TRUE,
                          main="Is your job professionally challenging?")
## Not run: 
## Retain original order of the Question variable

LikertPercentCountColumns(Question ~ . | Subtable, ProfChal,
                          layout=c(1,6), scales=list(y=list(relation="free")),
                          ylab=NULL, between=list(y=0),
                          strip.left=strip.custom(bg="gray97"), strip=FALSE,
                          par.strip.text=list(cex=.7),
                          main="Is your job professionally challenging?")

## Order both the plot of the count plot and the percent plot by the
## positive.order of the percent plot.
## Just the "Employment sector".
LPCCEs &lt;-
LikertPercentCountColumns(Question ~ . ,
                          ProfChal[ProfChal$Subtable == "Employment sector", -7],
                          ylab=NULL, between=list(y=0),
                          par.strip.text=list(cex=.7),
                          positive.order=TRUE,
                          main="Is your job professionally challenging?\nEmployment sector",
                          px=list( ## defaults designed for long QuestionName values
                            LL=c(.00,  .50), ## and 7in x 7in window
                            LP=c(.49,  .70),
                            ML=c(.50,  .51),  ## arbitrary, visually center the labels and legend
                            RP=c(.71,  .84),
                            RL=c(.87, 1.00)))
LPCCEs$RP$x.scales$at &lt;- c(0,100,200)
LPCCEs$RP$x.scales$labels &lt;- c(0,100,200)
LPCCEs

## End(Not run)
</code></pre>

<hr>
<h2 id='likertWeighted'>
Special case wrapper for likert() when multiple columns are to have the
same bar thicknesses.  Uses formula with one or two conditioning variables.
</h2><span id='topic+likertWeighted'></span><span id='topic+likertWeighted.formula'></span><span id='topic+likertWeighted.array'></span><span id='topic+likertWeighted.default'></span>

<h3>Description</h3>

<p>Special case wrapper for likert() when multiple columns are to have the
same bar thicknesses.  Uses formula with one or two conditioning variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likertWeighted(x, ...) ## generic

## S3 method for class 'array'
likertWeighted(x, ..., C = 1, Q = 3, R = 2) ## array

## Default S3 method:
likertWeighted(x, ...) ## matrix, table, data.frame

## S3 method for class 'formula'
likertWeighted(x, data,
               xlim=c(-100, 100),
               scales=list(y=list(relation="free", cex=1.3),
                           x=list(at=seq(-100, 100, 50),
                           labels=abs(seq(-100, 100, 50)), cex=.5)),
               box.ratio=1000,
               as.percent=TRUE, rightAxis=FALSE,
               between=list(x=1, y=0),
               strip=FALSE, strip.left=FALSE,
               par.settings=list(clip=list(panel="off")),
               h.resizePanels=1,
               auto.key.title=NULL,
               auto.key.columns=dim(data)[[2]] -
               NumberOfConditioningVariables(formula), ## excludes conditioning variables
               auto.key.cex=1.2,
               auto.key.cex.title=1.2,
               auto.key.lines.title=3,
               ylab=NULL,
               axis.top=dimnames(result)[[1]], ## Questions
               axis.top.row=1,
               ...)
               </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likertWeighted_+3A_x">x</code></td>
<td>

<p>For the default method, a matrix or data.frame or two-dimensional
table.  For the array method, a two- or-three-dimensional array.
For the formula method, a formula.
</p>
</td></tr>
<tr><td><code id="likertWeighted_+3A_formula">formula</code></td>
<td>

<p>Standard trellis formula, usually <code> ~ . | row + column</code> or
<code> ~ . | row</code>
</p>
</td></tr>
<tr><td><code id="likertWeighted_+3A_data">data</code></td>
<td>

<p>A <code>data.frame</code> that has been constructed from a 2D object (<code>matrix</code>
or <code>table</code> or <code>data.frame</code>) to include an additional column <code>row</code>, or
constructed from a 3D <code>array</code> by <code><a href="#topic+toCQxR">toCQxR</a></code> to include
two additional columns <code>group</code> and <code>row</code>.  The <code>default</code>
and <code>array</code> methods do that construction.
</p>
</td></tr>
<tr><td><code id="likertWeighted_+3A_c">C</code>, <code id="likertWeighted_+3A_r">R</code>, <code id="likertWeighted_+3A_q">Q</code></td>
<td>

<p>Integers, one each of 1,2,3; positions of the three dimensions.  Used in
<code>array</code> method.  See <code><a href="#topic+toCQxR">toCQxR</a></code>.
</p>
</td></tr>
<tr><td><code id="likertWeighted_+3A_xlim">xlim</code>, <code id="likertWeighted_+3A_between">between</code>, <code id="likertWeighted_+3A_strip">strip</code>, <code id="likertWeighted_+3A_strip.left">strip.left</code>, <code id="likertWeighted_+3A_par.settings">par.settings</code>, <code id="likertWeighted_+3A_ylab">ylab</code></td>
<td>

<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>
</p>
</td></tr>
<tr><td><code id="likertWeighted_+3A_scales">scales</code></td>
<td>

<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.  For <code>likertWeighted</code>, when scales for x is
changed, scales for y must be stated also.
</p>
</td></tr>
<tr><td><code id="likertWeighted_+3A_box.ratio">box.ratio</code></td>
<td>

<p>See <code><a href="lattice.html#topic+panel.bwplot">panel.bwplot</a></code>.
</p>
</td></tr>
<tr><td><code id="likertWeighted_+3A_as.percent">as.percent</code>, <code id="likertWeighted_+3A_rightaxis">rightAxis</code>, <code id="likertWeighted_+3A_...">...</code>, <code id="likertWeighted_+3A_h.resizepanels">h.resizePanels</code></td>
<td>

<p>First see the formula method for <code>likertWeighted</code>, and then <code><a href="#topic+likert">likert</a></code>.
</p>
</td></tr>
<tr><td><code id="likertWeighted_+3A_auto.key.title">auto.key.title</code>, <code id="likertWeighted_+3A_auto.key.columns">auto.key.columns</code>, <code id="likertWeighted_+3A_auto.key.cex">auto.key.cex</code>, <code id="likertWeighted_+3A_auto.key.cex.title">auto.key.cex.title</code>, <code id="likertWeighted_+3A_auto.key.lines.title">auto.key.lines.title</code></td>
<td>

<p>Values which will be used in <code>trellis</code> argument
<code>auto.key=list(title=auto.key.title, columns=auto.key.columns,
    cex=auto.key.cex, cex.title=auto.key.cex.title,
    lines.title=auto.key.lines.title)</code>
</p>
</td></tr>
<tr><td><code id="likertWeighted_+3A_axis.top">axis.top</code></td>
<td>

<p>Label to be placed at <code>x=0</code> for top (and other specified) panel of each column.
</p>
</td></tr>
<tr><td><code id="likertWeighted_+3A_axis.top.row">axis.top.row</code></td>
<td>

<p>Which rows will have <code>axis.top</code> displayed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+likert">likert</a></code> plot as a <code>"trellis"</code> object.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+likert">likert</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simplest 2D example
tmp &lt;- matrix(1:12, 3, 4,
              dimnames=list(c("A","B","C"),
                            c(letters[4:7]))) * c(1,2,3)
tmp
rowSums(tmp)

likertWeighted(tmp,
               h.resizePanels=rowSums(tmp),
               main="likertWeighted, simplest example,
                     defaults to Percent,
                     specified row thicknesses")

## Same example with explicit use of the formula method
## (default method does this for you).
tmpdd &lt;- data.frame(tmp, row=row.names(tmp))
tmpdd
likertWeighted(~ . | row, tmpdd,            ## tmpdd
               h.resizePanels=rowSums(tmp), ## tmp
main="likertWeighted,
same example but with explicit formula method")

## show subgroups
likertWeighted(tmp,
               h.resizePanels=rowSums(tmp),
               between=list(y=c(0, 1)),
               ylab=c("C in its own group","A and B together"),
               main="between=list(y=c(0,1) ## standard lattice between argument
Adjacent A and B with y.between = 0 are in the same bordered group.
Adjacent B and C with y.between != 0 are in different bordered groups.")


## simplest 3D example
## This is natural when multiple questions are asked of the
## same set of respondents in a survey.
## This example simulates that situation.
##
tmp3D &lt;- abind::abind(h=tmp, i=tmp, j=tmp, along=3)
tmp3D[1,,"i"] &lt;- tmp3D[1,c(4,2,1,3),"h"]
tmp3D[2,,"i"] &lt;- tmp3D[2,c(2,4,3,1),"h"]
tmp3D[3,,"i"] &lt;- tmp3D[3,c(4,1,2,3),"h"]
tmp3D[1,,"j"] &lt;- tmp3D[1,c(4,3,2,1),"h"]
tmp3D[2,,"j"] &lt;- tmp3D[2,c(1,4,3,2),"h"]
tmp3D[3,,"j"] &lt;- tmp3D[3,c(2,4,3,1),"h"]
## now
rowSums(tmp3D[,,1]) == rowSums(tmp3D[,,2])
rowSums(tmp3D[,,1]) == rowSums(tmp3D[,,3])


likertWeighted(tmp3D, h.resizePanels=rowSums(tmp3D[,,1]),
               main="simplest 3D example, array method")

likertWeighted(tmp3D, h.resizePanels=rowSums(tmp3D[,,1]),
               between=list(x=1, y=c(0, 1)),
               main="simplest 3D example, array method, with subgroups")

## Same example with explicit use of the formula method
## (array method does this for you).
tmp3Ddf &lt;- toCQxR(tmp3D)
dimnames(tmp3Ddf)
tmp3Ddf
likertWeighted(~ . | group + row, tmp3Ddf, h.resizePanels=rowSums(tmp3D[,,1]),
               main="simplest 3D example, formula method")


</code></pre>

<hr>
<h2 id='lm.case'> case statistics for regression analysis</h2><span id='topic+case'></span><span id='topic+case.lm'></span><span id='topic+plot.case'></span><span id='topic+panel.case'></span>

<h3>Description</h3>

<p>Case statistics for regression analysis.
<code>case.lm</code> calculates the statistics.
<code>plot.case</code> plots the cases, one statistic per panel, and
illustrates and flags all observations for which the standard
thresholds are exceeded.  <code>plot.case</code> returns an object with
class <code>c("trellis.case", "trellis")</code>
containing the plot and the row.names of the
flagged observations.  The object is printed by a method which
displays the set of graphs and prints the list of flagged cases.
<code>panel.case</code> is a panel function for <code>plot.case</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>case(fit, ...)
## S3 method for class 'lm'
case(fit, lms = summary.lm(fit), lmi = lm.influence(fit), ...)

## S3 method for class 'case'
plot(x, fit,
          which=c("stu.res","si","h","cook","dffits",
            dimnames(x)[[2]][-(1:8)]),  ##DFBETAS
          between.in=list(y=4, x=9),
          cex.threshold=1.2,
          main.in=list(
            paste(deparse(fit$call), collapse=""),
            cex=main.cex),
          sigma.in=summary.lm(fit)$sigma,
          p.in=summary.lm(fit)$df[1]-1,
          main.cex=NULL,
          ...)

panel.case(x, y, subscripts, rownames, group.names,
           thresh, case.large,
           nn, pp, ss, cex.threshold,
           ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm.case_+3A_fit">fit</code></td>
<td>
<p><code>"lm"</code> object computed with <code>x=TRUE</code></p>
</td></tr>
<tr><td><code id="lm.case_+3A_lms">lms</code></td>
<td>
<p><code>summary.lm(fit)</code></p>
</td></tr>
<tr><td><code id="lm.case_+3A_lmi">lmi</code></td>
<td>
<p><code>lm.influence(fit)</code></p>
</td></tr>
<tr><td><code id="lm.case_+3A_x">x</code></td>
<td>
<p>In <code>plot.case</code>, the matrix output from <code>case.lm</code>
containing case diagnostics on each observation in the original
dataset.
In <code>panel.case</code>, the x variable to be plotted</p>
</td></tr>
<tr><td><code id="lm.case_+3A_which">which</code></td>
<td>
<p>In <code>plot.case</code>, the names of the columns of x
that are to be graphed.</p>
</td></tr>
<tr><td><code id="lm.case_+3A_between.in">between.in</code></td>
<td>
<p><code>between</code> trellis/lattice argument.</p>
</td></tr>
<tr><td><code id="lm.case_+3A_cex.threshold">cex.threshold</code></td>
<td>
<p>Multiplier for <code>cex</code> for the threshold values.</p>
</td></tr>
<tr><td><code id="lm.case_+3A_main.in">main.in</code></td>
<td>
<p><code>main</code> title for <code>xyplot</code>. The default main title
displays the linear model formula from <code>fit</code>.</p>
</td></tr>
<tr><td><code id="lm.case_+3A_sigma.in">sigma.in</code></td>
<td>
<p>standard error for the <code>fit</code>.</p>
</td></tr>
<tr><td><code id="lm.case_+3A_p.in">p.in</code></td>
<td>
<p>The number of degrees of freedom associated with the fitted
model.</p>
</td></tr>
<tr><td><code id="lm.case_+3A_main.cex">main.cex</code></td>
<td>
<p><code>cex</code> for main title.</p>
</td></tr>
<tr><td><code id="lm.case_+3A_...">...</code></td>
<td>
<p>other arguments to <code>xyplot</code></p>
</td></tr>
<tr><td><code id="lm.case_+3A_y">y</code></td>
<td>
<p>the y variable to be plotted.</p>
</td></tr>
<tr><td><code id="lm.case_+3A_thresh">thresh</code></td>
<td>
<p>Named list of lists.  Each list contains the components
threshold ($y$-locations where a reference line will be drawn),
thresh.label (the right-axis labels for the reference lines), thresh.id
(the bounds defining &quot;Noteworthy Observations&quot;).</p>
</td></tr>
<tr><td><code id="lm.case_+3A_case.large">case.large</code></td>
<td>
<p>Named list of &quot;Noteworthy Observations&quot;.</p>
</td></tr>
<tr><td><code id="lm.case_+3A_nn">nn</code></td>
<td>
<p>Number of rows in original dataset.</p>
</td></tr>
<tr><td><code id="lm.case_+3A_pp">pp</code></td>
<td>
<p>The number of degrees of freedom associated with the fitted model.</p>
</td></tr>
<tr><td><code id="lm.case_+3A_ss">ss</code></td>
<td>
<p>Standard error for the <code>fit</code>.</p>
</td></tr>
<tr><td><code id="lm.case_+3A_subscripts">subscripts</code></td>
<td>
<p>trellis/lattice argument, position in the reshaped
dataset constructed by <code>plot.case</code> before calling <code>xyplot</code>.</p>
</td></tr>
<tr><td><code id="lm.case_+3A_rownames">rownames</code></td>
<td>
<p>row name in the original data.frame.</p>
</td></tr>
<tr><td><code id="lm.case_+3A_group.names">group.names</code></td>
<td>
<p>names of the individual statistics.</p>
</td></tr>




</table>


<h3>Details</h3>

<p><code>lm.influence</code> is part of S-Plus and R
<code>case.lm</code> and <code>plot.case</code> are based on:
Section 4.3.3 &quot;Influence of Individual Obervations
in Chambers and Hastie&quot;, <em>Statistical Models in S</em>.
</p>


<h3>Value</h3>

<p><code>case.lm</code> returns a matrix, with one row for each observation
in the original dataset.  The columns contain the diagnostic statistics:
<code>e</code> (residuals),
<code>h</code>* (hat diagonals),
<code>si</code>* (deleted standard deviation),
<code>sta.res</code> (standardized residuals),
<code>stu.res</code>* (Studentized deleted resididuals),
<code>dffit</code> (difference in fits, change in predicted y when
observation i is deleted),
<code>dffits</code>* (standardized difference in fits, standardized change
in predicted y when observation i is deleted),
<code>cook</code>* (Cook's distance),
and DFBETAs* (standardized difference in regression coefficients when
observation i is deleted, one for each column of the x-matrix,
including the intercept).
</p>
<p><code>plot.case</code> returns a <code>c("trellis.case", "trellis")</code> object
containing the plot
(including the starred columns by default) and also retains the
row.names of the flagged observations in the
<code>$panel.args.common$case.large</code>
component.  The print method for the <code>c("trellis.case",
    "trellis")</code>
object prints the graph and the list of flagged observations.
</p>
<p><code>panel.case</code> is a panel function for <code>plot.case</code>.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm.influence">lm.influence</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(kidney)

kidney2.lm &lt;- lm(clearance ~ concent + age + weight + concent*age,
                 data=kidney,
                 na.action=na.exclude)  ## recommended

kidney2.case &lt;- case(kidney2.lm)

## this picture looks much better in portrait, specification is device dependent

plot(kidney2.case, kidney2.lm, par.strip.text=list(cex=.9),
     layout=c(2,3))
</code></pre>

<hr>
<h2 id='lm.regsubsets'>Evaluate lm model with highest adjusted $R^2$.</h2><span id='topic+lm.regsubsets'></span>

<h3>Description</h3>

<p>The <code>regsubsets</code> function in the <code>leaps</code> package finds the
model with the highest adjusted <code class="reqn">R^2</code>.  This function evaluates the full
<code>lm</code> object for that model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.regsubsets(object, model.number, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm.regsubsets_+3A_object">object</code></td>
<td>
<p> An object of class <code>"regsubsets"</code>. </p>
</td></tr>
<tr><td><code id="lm.regsubsets_+3A_model.number">model.number</code></td>
<td>
<p>Index number generated by <code>Rcmdr</code>.</p>
</td></tr>
<tr><td><code id="lm.regsubsets_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"lm"</code> object for the selected model.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>,  <code><a href="leaps.html#topic+regsubsets">regsubsets</a></code>
</p>

<hr>
<h2 id='lmatPairwise'>
lmatPairwise
</h2><span id='topic+lmatPairwise'></span><span id='topic+lmatPairwise.matrix'></span><span id='topic+lmatPairwise.glht'></span><span id='topic+lmatPairwise.mmc.multicomp'></span><span id='topic+lmatPairwise.mmc'></span>

<h3>Description</h3>

<p>lmatPairwise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmatPairwise(x, ...)
## S3 method for class 'matrix'
lmatPairwise(x, levels, ...)
## S3 method for class 'glht'
lmatPairwise(x, ...)
## S3 method for class 'mmc.multicomp'
lmatPairwise(x, ...)
## S3 method for class 'mmc'
lmatPairwise(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmatPairwise_+3A_x">x</code></td>
<td>

<p>x
</p>
</td></tr>
<tr><td><code id="lmatPairwise_+3A_...">...</code></td>
<td>

<p>...
</p>
</td></tr>
<tr><td><code id="lmatPairwise_+3A_levels">levels</code></td>
<td>

<p>levels
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>details
</p>


<h3>Value</h3>

<p>matrix
</p>


<h3>Author(s)</h3>

<p>rmh
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmc">mmc</a></code>, <code><a href="multcomp.html#topic+mcp">mcp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(catalystm)
catalystm1.aov &lt;- aov(concent ~ catalyst, data=catalystm)
catalystm.mmc &lt;- mmc(catalystm1.aov)
lmatPairwise(catalystm.mmc)
</code></pre>

<hr>
<h2 id='lmatRows'>Find the row numbers in the lmat 
corresponding to the focus factor.</h2><span id='topic+lmatRows'></span><span id='topic+lmatRows.mmc.multicomp'></span><span id='topic+lmatRows.multicomp'></span><span id='topic+lmatRows.glht'></span><span id='topic+lmatRows.lm'></span><span id='topic+lmatContrast'></span>

<h3>Description</h3>

<p><code>lmatRows</code> finds the row numbers in the lmat (column numbers in the linfct in R)
corresponding to the focus factor.  See <code><a href="#topic+mmc">mmc</a></code> for more information.
These are internal functions that the user doesn't see.
They are necessary when the design has more than one factor.
<code>lmatContrast</code> converts user-specified contrasts of levels of a
factor to the full <code>lmat</code> or <code>linfct</code> matrix that carries the
information about other factors and their interactions and covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmatRows(x, focus)
## S3 method for class 'mmc.multicomp'
lmatRows(x, focus)
## S3 method for class 'multicomp'
lmatRows(x, focus)
## S3 method for class 'glht'
lmatRows(x, focus) ## R only
## S3 method for class 'lm'
lmatRows(x, focus)
lmatContrast(lmat.none, contrast.matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmatRows_+3A_x">x</code></td>
<td>
<p><code>"lm"</code> or <code>"mmc.multicomp"</code> or <code>"multicomp"</code>
or <code>"glht"</code> object.
</p>
</td></tr>
<tr><td><code id="lmatRows_+3A_focus">focus</code></td>
<td>
<p>The name of the term in the ANOVA table for which
multiple comparisons are to be constructed.</p>
</td></tr>
<tr><td><code id="lmatRows_+3A_lmat.none">lmat.none</code></td>
<td>
<p><code>lmat</code> matrix with the S-Plus <code>multicomp</code>
package or <code>t(linfct)</code> matrix with the R <code>multcomp</code> package.
In both packages the matrix is the one used for estimating the group
means.
</p>
</td></tr>
<tr><td><code id="lmatRows_+3A_contrast.matrix">contrast.matrix</code></td>
<td>
<p>Matrix of column contrasts for a factor.
The columns are the contrasts, the rows are the levels of the factor.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>MMC</code> function are based on <code>glht</code> in R and on
<code>multicomp</code>
in S-Plus.  The two packages have different conventions for specifying
the linear contrasts.  The <code>lmatRows</code> function gives appropriate
values in each system.
</p>


<h3>Value</h3>

<p>For <code>lmatRows</code>, vector of row numbers of the <code>lmat</code>,
the matrix of linear contrasts defining the comparisons of interest.
For <code>lmatContrast</code>, a linear contrast matrix that follows the
conventions of the multiple comparisons package.  It has columns for each contrast
specified by the input <code>contrast.matrix</code> and rows as needed for
the other terms in the model.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+mmc">mmc</a></code>,
<code><a href="multcomp.html#topic+glht">glht</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## catalystm example
## See ?MMC for more on this example
data(catalystm)
catalystm1.aov &lt;- aov(concent ~ catalyst, data=catalystm)

catalystm.mmc &lt;-
  if.R(r=mmc(catalystm1.aov, linfct = mcp(catalyst = "Tukey")),
       s=multicomp.mmc(catalystm1.aov, plot=FALSE))
dimnames(catalystm.mmc$mca$lmat)[[1]]
lmatRows(catalystm1.aov, focus="catalyst")

## user-specified contrasts
catalystm.lmat &lt;- cbind("AB-D" =c( 1, 1, 0,-2),
                        "A-B"  =c( 1,-1, 0, 0),
                        "ABD-C"=c( 1, 1,-3, 1))
dimnames(catalystm.lmat)[[1]] &lt;- levels(catalystm$catalyst)
zapsmall(lmatContrast(catalystm.mmc$none$lmat, catalystm.lmat))
</code></pre>

<hr>
<h2 id='lmplot'>
Four types of residual plots for linear models.
</h2><span id='topic+lmplot'></span>

<h3>Description</h3>

<p>Four types of residual plots for linear models.  The first three are redesigns of
plots that <code>stats:::plot.lm</code> presents.
The first two show the positive residuals in <code>col[2]</code> and the
negative residuals
in color <code>col[1]</code>.  The third and fourth use color <code>col[1]</code>.
The fourth is based on an S-Plus
panel that <span class="rlang"><b>R</b></span>\ doesn't provide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmplot(lm.object, ..., main=NULL,
       col=trellis.par.get("superpose.symbol")$col[1:2],
       ylim=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmplot_+3A_lm.object">lm.object</code></td>
<td>

<p>Linear model object.  See <code><a href="stats.html#topic+lm">lm</a></code> for details.
</p>
</td></tr>
<tr><td><code id="lmplot_+3A_col">col</code></td>
<td>
<p>Vector of color names.  Only the first two are used.
If not specified, then
<code>trellis.par.get("superpose.symbol")$col[1:2]</code> is used.
</p>
</td></tr>
<tr><td><code id="lmplot_+3A_main">main</code></td>
<td>
<p>standard <code>main</code> title for plots.</p>
</td></tr>
<tr><td><code id="lmplot_+3A_ylim">ylim</code></td>
<td>
<p>standard <span class="pkg">lattice</span> argument.
It is used as specified for the <code>residVSfitted</code>, <code>diagQQ</code>, and
<code>diagplot5new</code> plots.  For the <code>scaleLocation</code> plot, the
<code>ylim</code> is modified to <code>c(0, max(abs(ylim)))</code>.  The main reason
for using the <code>ylim</code> argument is to allow visual comparison of
the residuals for two different models on the same scale.
</p>
</td></tr>
<tr><td><code id="lmplot_+3A_...">...</code></td>
<td>

<p>Other arguments, currently ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trellis plots from  the four functions <code><a href="#topic+residVSfitted">residVSfitted</a></code>,
<code><a href="#topic+scaleLocation">scaleLocation</a></code>, <code><a href="#topic+diagQQ">diagQQ</a></code>, <code><a href="#topic+diagplot5new">diagplot5new</a></code>
are displayed on the current device in a coordinated display.
</p>


<h3>Value</h3>

<p>A list of three trellis objects is returned invisibly, the first
contains the result of <code><a href="#topic+residVSfitted">residVSfitted</a></code> and
<code><a href="#topic+scaleLocation">scaleLocation</a></code> together.  The second <code><a href="#topic+diagQQ">diagQQ</a></code>,
and the third <code><a href="#topic+diagplot5new">diagplot5new</a></code>.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+residVSfitted">residVSfitted</a></code>, <code><a href="#topic+scaleLocation">scaleLocation</a></code>,
<code><a href="#topic+diagQQ">diagQQ</a></code>, <code><a href="#topic+diagplot5new">diagplot5new</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- data.frame(y=rnorm(100), x1=rnorm(100), x2=rnorm(100))
tmp.lm &lt;- lm(y ~ x1 + x2, data=tmp)
lmplot(tmp.lm)
</code></pre>

<hr>
<h2 id='logit'>Logistic and odds functions and their inverses.</h2><span id='topic+logit'></span><span id='topic+antilogit'></span><span id='topic+odds'></span><span id='topic+antiodds'></span>

<h3>Description</h3>

<p>Logistic and odds functions and their inverses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(p)
antilogit(x)

odds(p)
antiodds(o)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_+3A_p">p</code></td>
<td>
<p>Probability value, a vector of numbers between 0 and 1, inclusive.</p>
</td></tr>
<tr><td><code id="logit_+3A_x">x</code></td>
<td>
<p>Real number, a vector of numbers between <code>-Inf</code> and <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="logit_+3A_o">o</code></td>
<td>
<p>Real number, a vector of numbers between <code>0</code> and <code>Inf</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of real values <code>log(p/(1-p))</code> for <code>logit</code>.
Vector of probabilities <code>exp(x)/(1+exp(x))</code> for <code>antilogit</code> with
boundary values of <code>-Inf</code> and <code>Inf</code> for <code>x</code> correctly handled.
Vector of real values <code>p/(1-p)</code> for <code>odds</code>.
Vector of probabilities <code>o/(o+1)</code> for <code>antiodds</code> with the
boundary value of <code>Inf</code> for <code>o</code> correctly handled.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>Examples</h3>

<pre><code class='language-R'>logit(seq(0, 1, .1))
antilogit(logit(seq(0, 1, .1)))

odds(seq(0, 1, .1))
antiodds(odds(seq(0, 1, .1)))
</code></pre>

<hr>
<h2 id='matrix.trellis'>
Convert a one-dimensional trellis object to a two-dimensional trellis object.
This permits combineLimits and useOuterStrips to work.
</h2><span id='topic+matrix.trellis'></span><span id='topic+as.matrix.trellis'></span>

<h3>Description</h3>

<p>matrix.trellis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.trellis(x = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)

## S3 method for class 'trellis'
as.matrix(x, ..., row = FALSE, yname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.trellis_+3A_x">x</code></td>
<td>

<p>x
</p>
</td></tr>
<tr><td><code id="matrix.trellis_+3A_nrow">nrow</code>, <code id="matrix.trellis_+3A_ncol">ncol</code>, <code id="matrix.trellis_+3A_byrow">byrow</code>, <code id="matrix.trellis_+3A_dimnames">dimnames</code></td>
<td>

<p>See <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</td></tr>
<tr><td><code id="matrix.trellis_+3A_row">row</code></td>
<td>

<p>Logical.  The default is <code>FALSE</code> to match the behavior of the
generic <code><a href="base.html#topic+matrix">as.matrix</a></code>.  I think <code>TRUE</code> usually
looks better.
</p>
</td></tr>
<tr><td><code id="matrix.trellis_+3A_yname">yname</code></td>
<td>

<p>Character. Provides the name of the generated conditioning factor.
</p>
</td></tr>
<tr><td><code id="matrix.trellis_+3A_...">...</code></td>
<td>

<p>Other arguments are ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>matrix.trellis</code> lets the user specify <code>nrow</code> and <code>ncol</code>.
<code>as.matrix.trellis</code> produces either be a single column (by
default) or a single row.
</p>


<h3>Value</h3>

<p><code>trellis</code> object with <code>length(dim(x)) == 2</code> and specified nrow and ncol.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- data.frame(a=1:3,
                  b=c(4,5,7),
                  c=5:7,
                  d=c(8, 9, 12),
                  e=9:11)
tmp
a1 &lt;- xyplot(a + b ~ c + d + e, data=tmp, outer=TRUE,
             main="a1")
a1
dim(a1)
a2 &lt;- xyplot(a + b ~ c + d + e, data=tmp, outer=TRUE,
             scales=list(relation="free"), main="a2")
a2
dim(a2)
try(combineLimits(a2))
combineLimits.trellisvector(a2)
combineLimits.trellisvector(update(a2, layout=c(3,2)))

a21 &lt;- matrix.trellis(a2, ncol=3, nrow=2, byrow=TRUE)
a21 &lt;- update(a21, main="a21")
a21
dim(a21)
a21$x.scales$at
combineLimits(a21)

a22 &lt;- update(a21, main="a22")
a22$x.scales$at &lt;- list(FALSE, FALSE, FALSE, NULL, NULL, NULL)
a22$y.scales$at &lt;- list(FALSE, NULL, NULL, FALSE, NULL, NULL)
a22

a23 &lt;- useOuterStrips(combineLimits(a21))
a23 &lt;- update(a23, main="a23")
a23
a23$condlevels
a23$condlevels &lt;- list(letters[3:5], letters[1:2])
a23

a24 &lt;- resizePanels(update(a23, main="a24"), h=c(3,4), w=c(3,5,3))
a24

a25 &lt;- update(a23, xlab=letters[3:5], ylab.right=letters[1:2],
              xlab.top="column variables",
              ylab="row variables",
              scales=list(x=list(alternating=1), y=list(alternating=2)),
              main="a25: what I want\nxyplot(a + b ~ c + d + e, data=tmp, outer=TRUE)\nto produce.")
a25

as.matrix(a1)
as.matrix(a1, yname="abcd")
as.matrix(a1, yname="abcd", row=TRUE)

</code></pre>

<hr>
<h2 id='mcalinfct'>MCA multiple comparisons analysis (pairwise)</h2><span id='topic+mcalinfct'></span>

<h3>Description</h3>

<p>MCA multiple comparisons analysis (pairwise).  We calculate the
contrast matrix for all pairwise comparisons, taking account of
covariates and interactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcalinfct(model, focus,
          mmm.data=model$model,
          formula.in=terms(model),
          linfct.Means=
          
          multcomp.meanslinfct(model, focus, mmm.data, formula.in,
                         contrasts.arg=model$contrasts),
          type="Tukey"
          )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcalinfct_+3A_model">model</code></td>
<td>
<p><code>aov</code> object</p>
</td></tr>
<tr><td><code id="mcalinfct_+3A_focus">focus</code></td>
<td>
<p>name of one of the factors in the model, as a character object.</p>
</td></tr>
<tr><td><code id="mcalinfct_+3A_mmm.data">mmm.data</code></td>
<td>
<p><code>data.frame</code> from which the model was estimated.
Normally, the default is the correct value.</p>
</td></tr>
<tr><td><code id="mcalinfct_+3A_formula.in">formula.in</code></td>
<td>
<p><code>formula</code> of the model which was estimated.
Normally, the default is the correct value.  The use of the
<code>terms</code>
function honors the <code>keep.order=TRUE</code> if it was specified.</p>
</td></tr>
<tr><td><code id="mcalinfct_+3A_linfct.means">linfct.Means</code></td>
<td>
<p>Contrast matrix for the adjusted means of each
level of the focus factor.   Normally, the default is the correct value.</p>
</td></tr>
<tr><td><code id="mcalinfct_+3A_type">type</code></td>
<td>
<p>Name of the multiple comparison procedure to be used.
See <code><a href="multcomp.html#topic+contrMat">contrMat</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix to be used as a value for the <code>linfct</code> argument to
<code><a href="multcomp.html#topic+glht">glht</a></code>.
</p>


<h3>Note</h3>

<p>This function provides results similar to the
<code>mcp(focusname="Tukey")</code> argument to <code>glht</code>.
I think it provides better values for covariate and interaction terms.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

 <p><code><a href="#topic+MMC">MMC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the examples in HH/scripts/MMC.cc176.R
</code></pre>

<hr>
<h2 id='mmc'>MMC (Mean&ndash;mean Multiple Comparisons) plots.</h2><span id='topic+mmc'></span><span id='topic+MMC'></span><span id='topic+multicomp'></span><span id='topic+multicomp.mmc'></span><span id='topic+mmc'></span><span id='topic+mmc.glht'></span><span id='topic+mmc.default'></span><span id='topic++5B.mmc.multicomp'></span>

<h3>Description</h3>

<p>Constructs a <code>"mmc.multicomp"</code> object from the formula and
other arguments.  The constructed object must be explicitly plotted
with the <code><a href="#topic+mmcplot">mmcplot</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmc(model, ...)  ## R

## S3 method for class 'glht'
mmc(model, ...)


## Default S3 method:
mmc(model,       ## lm object
    linfct=NULL,
    focus=
    if (is.null(linfct))
    {
      if (length(model$contrasts)==1) names(model$contrasts)
      else stop("focus or linfct must be specified.")
    }
    else
    {
      if (is.null(names(linfct)))
        stop("focus must be specified.")
      else names(linfct)
    },
    focus.lmat,
    ylabel=deparse(terms(model)[[2]]),
    lmat=if (missing(focus.lmat)) {
      t(linfct)
    } else {
      lmatContrast(t(none.glht$linfct), focus.lmat)
      },
    lmat.rows=lmatRows(model, focus),
    lmat.scale.abs2=TRUE,
    estimate.sign=1,
    order.contrasts=TRUE,
    level=.95,
    calpha=NULL,
    alternative = c("two.sided", "less", "greater"),
    ...
    )

multicomp.mmc(x,  ## S-Plus
              focus=dimnames(attr(x$terms,"factors"))[[2]][1],
              comparisons="mca",
              lmat,
              lmat.rows=lmatRows(x, focus),
              lmat.scale.abs2=TRUE,
              ry,
              plot=TRUE,
              crit.point,
              iso.name=TRUE,
              estimate.sign=1,
              x.offset=0,
              order.contrasts=TRUE,
              main,
              main2,
              focus.lmat,
              ...)

## S3 method for class 'mmc.multicomp'
x[..., drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmc_+3A_model">model</code></td>
<td>
<p><code>"aov"</code> object in <code>"lm"</code> method.</p>
</td></tr>
<tr><td><code id="mmc_+3A_ylabel">ylabel</code></td>
<td>
<p>name of the response variable.</p>
</td></tr>
<tr><td><code id="mmc_+3A_lmat">lmat</code></td>
<td>
<p>contrast matrix as in the S-Plus <code>multicomp</code>.
The convention for <code>lmat</code> in R is to use
the transpose of the <code>linfct</code> component produced by
<code>glht</code>.   Required for user-specified contrasts.</p>
</td></tr>
<tr><td><code id="mmc_+3A_lmat.rows">lmat.rows</code></td>
<td>
<p>rows in <code>lmat</code> for the <code>focus</code> factor.</p>
</td></tr>
<tr><td><code id="mmc_+3A_focus">focus</code></td>
<td>
<p>define the factor to compute contrasts of.
In R this argument often can be used to simplify the call.
The statement <code>mmc(my.aov, focus="factorA")</code> is interpreted as
<code>mmc(my.aov, factorA="Tukey", `interaction_average`=TRUE, `covariate_average`=TRUE)</code>
With <code>TRUE, TRUE</code>, <code>multcomp::glht</code> always gives the same result as the S-Plus
<code>multcomp</code> function.  Without the <code>TRUE, TRUE</code>,
<code>multcomp::glht</code> gives a
different answer when there are interactions or covariates in the model.
See
<code><a href="multcomp.html#topic+glht">glht</a></code>.
</p>
</td></tr>
<tr><td><code id="mmc_+3A_focus.lmat">focus.lmat</code></td>
<td>
<p>R only.  Contrast matrix used in the user-specified
comparisons of the <code>focus</code> factor.  This is the matrix the user
constructs.
Row names must include all levels of the factor.
Column names are the names the user assigns to the contrasts.
Each column must sum to zero.  See <code>catalystm.lmat</code> in the Examples
section for an example.
The <code>focus.lmat</code> matrix is multiplied by the <code>lmat</code> from the <code>none</code>
component to create the <code>lmat</code> for the user-specified contrasts.
Display the <code>hibrido.lmat</code> and <code>maiz2.lmat</code> in the maiz
example below to see what is happening.
</p>
</td></tr>
<tr><td><code id="mmc_+3A_linfct">linfct</code></td>
<td>
<p>In R, see
<code><a href="multcomp.html#topic+glht">glht</a></code>.
</p>
</td></tr>
<tr><td><code id="mmc_+3A_...">...</code></td>
<td>
<p>other arguments.  <code>alternative</code> and
<code>base</code> are frequently used with <code>glht</code>.</p>
</td></tr>
<tr><td><code id="mmc_+3A_comparisons">comparisons</code></td>
<td>
<p>argument to <code>multicomp</code></p>
</td></tr>
<tr><td><code id="mmc_+3A_lmat.scale.abs2">lmat.scale.abs2</code></td>
<td>
<p>logical, scale the contrasts in the columns of
<code>lmat</code> to make the sum of the absolute values of each column equal 2.</p>
</td></tr>
<tr><td><code id="mmc_+3A_estimate.sign">estimate.sign</code></td>
<td>
<p>numeric.  If <code>0</code>, leave contrasts in the
default lexicographic direction.  If positive, force all contrasts to positive,
reversing their names if needed (if contrast A-B is negative, reverse it
to B-A).  If negative, the force all contrasts to positive.</p>
</td></tr>
<tr><td><code id="mmc_+3A_order.contrasts">order.contrasts</code></td>
<td>
<p>sort the contrasts in the (<code>mca</code>, <code>none</code>,
<code>lmat</code>) components by height on the MMC plot.  This will place the
contrasts in the multicomp plots in the same order as in the MMC plot.</p>
</td></tr>
<tr><td><code id="mmc_+3A_alternative">alternative</code></td>
<td>
<p>Direction of alternative hypothesis.
See
<code><a href="multcomp.html#topic+glht">glht</a></code>
</p>
<p>in R.  S-Plus <code>multicomp</code>
uses the argument <code>bounds</code> for this concept.
</p>
</td></tr>
<tr><td><code id="mmc_+3A_level">level</code></td>
<td>
<p>Confidence level.  Defaults to 0.95.</p>
</td></tr>
<tr><td><code id="mmc_+3A_crit.point">crit.point</code>, <code id="mmc_+3A_calpha">calpha</code></td>
<td>
<p>critical value for the tests.  The value from the
specified <code>multicomp</code> method is used for the user-specified
contrasts when <code>lmat</code> is specified.  This argument is called
<code>crit.point</code> with <code>multicomp</code> in S-Plus and <code>calpha</code>
when used with <code>glht</code> and <code>confint</code> in R.
In R, with a large number of levels for the focus factor, <code>calpha</code>
should
be specified.  See notes below for discussion of the timing issues
and the examples for an illustration how to use <code>calpha</code>.</p>
</td></tr>
<tr><td><code id="mmc_+3A_plot">plot</code></td>
<td>
<p>logical, display the plot if <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mmc_+3A_ry">ry</code>, <code id="mmc_+3A_iso.name">iso.name</code>, <code id="mmc_+3A_x.offset">x.offset</code>, <code id="mmc_+3A_main">main</code>, <code id="mmc_+3A_main2">main2</code></td>
<td>
<p>arguments to
<code>plot.mmc.multicomp</code>.</p>
</td></tr>
<tr><td><code id="mmc_+3A_x">x</code>, <code id="mmc_+3A_drop">drop</code></td>
<td>
<p>See <code>"["</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, if <code>lmat</code> is not specified, we plot the isomeans grid
and the pairwise comparisons for the <code>focus</code> factor.  By default,
we plot the specified contrasts if the <code>lmat</code> is specified.
Each contrast is plotted at a height which is the weighted average of
the means being compared.  The weights are scaled to the sum of their
absolute values equals 2.
</p>
<p>We get the right contrasts automatically if the aov is oneway.  If we
specify an lmat for oneway it must have a leading row of 0.
</p>
<p>For any more complex design, we must study the <code>lmat</code> from the <code>mca</code>
component of the result to see how to construct the <code>lmat</code> (with the
extra rows as needed) and how to specify the <code>lmat.rows</code>
corresponding to the rows for the focus factor.
</p>
<p><code>mmc</code> in R works from either an <code>"glht"</code> object or an
<code>"aov"</code> object.  <code>multicomp.mmc</code> in S-Plus works from an
<code>"aov"</code> object.
</p>


<h3>Value</h3>

<p>An <code>"mmc.multicomp"</code> object contains either the first two or all
three of the <code>"multicomp"</code> components <code>mca</code>, <code>none</code>,
<code>lmat</code> described here.  Each <code>"multicomp"</code> component in
R also contains a <code>"glht"</code> object.
</p>
<table>
<tr><td><code>mca</code></td>
<td>
<p>Object containing the pairwise comparisons.</p>
</td></tr>
<tr><td><code>none</code></td>
<td>
<p>Object comparing each mean to 0.</p>
</td></tr>
<tr><td><code>lmat</code></td>
<td>
<p>Object for the contrasts specified in
the <code>lmat</code> argument.</p>
</td></tr>
</table>
<p><code>"[.mmc.multicomp"</code> is a subscript method.
</p>


<h3>Note</h3>

<p>The multiple comparisons calculations in R and S-Plus use
completely different functions.
MMC plots in R are constructed by <code>mmc</code>
based on
<code><a href="multcomp.html#topic+glht">glht</a></code>.
</p>
<p>MMC plots in S-Plus are constructed by
<code>multicomp.mmc</code> based on the S-Plus
<code>multicomp</code>.
</p>
<p>The MMC plot is the same in both systems.  The details of getting the
plot differ.
</p>
<p>Function <code>mmc</code> calls
<code><a href="multcomp.html#topic+glht">glht</a></code> and <code><a href="multcomp.html#topic+methods">confint.glht</a></code>.
</p>
<p>With a large number of levels
for the focus factor, the <code>confint</code> function is exceedingly slow
(80 minutes for 30 levels on 1.5GHz Windows XP). Therefore,
always specify <code>calpha</code> to reduce the time to under a second for
the same example.
</p>
<p>There are two plotting functions for MMC plots.  <code><a href="#topic+mmcplot">mmcplot</a></code>, the
newer <span class="pkg">lattice</span>-based function, is recommended.   <code>mmcplot</code>,
chooses better default values for it arguments and is better coordinated
with the tiebreaker plot.
</p>
<p>The older
<code><a href="#topic+plot.mmc.multicomp">plot.mmc.multicomp</a></code>, built on <span class="pkg">base</span> graphics, chooses sensible defaults for its many
arguments, but they still often need manual adjustment.  The examples show
several types of adjustments.  We have changed the centering and scaling
to avoid overprinting of label information.  By default the significant
contrasts are shown in a more intense color than the nonsignificant
contrasts.
We have an option to reduce the color intensity of the isomeans grid.
</p>






<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>
<p>Heiberger, Richard M. and Holland, Burt (2006).
&quot;Mean&ndash;mean multiple comparison displays for families of linear contrasts.&quot;
<em>Journal of Computational and Graphical Statistics</em>, 15:937&ndash;955.
</p>
<p>Hsu, J. and Peruggia, M. (1994).
&quot;Graphical representations of Tukey's multiple comparison method.&quot;
<em>Journal of Computational and Graphical Statistics</em>, 3:143&ndash;161.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmcplot">mmcplot</a></code>, <code><a href="#topic+plot.mmc.multicomp">plot.mmc.multicomp</a></code>, <code><a href="#topic+as.multicomp">as.multicomp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use mmc with R.
## Use multicomp.mmc with S-Plus.

## data and ANOVA
## catalystm example
data(catalystm)

bwplot(concent ~ catalyst, data=catalystm,
       scales=list(cex=1.5),
       ylab=list("concentration", cex=1.5),
       xlab=list("catalyst",cex=1.5))


catalystm1.aov &lt;- aov(concent ~ catalyst, data=catalystm)
summary(catalystm1.aov)

catalystm.mca &lt;-
glht(catalystm1.aov, linfct = mcp(catalyst = "Tukey"))
confint(catalystm.mca)
plot(catalystm.mca)                      ## multcomp plot
mmcplot(catalystm.mca, focus="catalyst") ## HH plot

## pairwise comparisons
catalystm.mmc &lt;-
  mmc(catalystm1.aov, focus="catalyst")
catalystm.mmc

## Not run: 
## these three statements are identical for a one-way aov
  mmc(catalystm1.aov)  ## simplest
  mmc(catalystm1.aov, focus="catalyst") ## generalizes to higher-order designs
  mmc(catalystm1.aov, linfct = mcp(catalyst = "Tukey")) ## glht arguments

## End(Not run)

mmcplot(catalystm.mmc, style="both")


## User-Specified Contrasts
## Row names must include all levels of the factor.
## Column names are the names the user assigns to the contrasts.
## Each column must sum to zero.
catalystm.lmat &lt;- cbind("AB-D" =c( 1, 1, 0,-2),
                        "A-B"  =c( 1,-1, 0, 0),
                        "ABD-C"=c( 1, 1,-3, 1))
dimnames(catalystm.lmat)[[1]] &lt;- levels(catalystm$catalyst)
catalystm.lmat

catalystm.mmc &lt;-
mmc(catalystm1.aov,
       linfct = mcp(catalyst = "Tukey"),
       focus.lmat=catalystm.lmat)
catalystm.mmc

mmcplot(catalystm.mmc, style="both", type="lmat")


## Not run: 
## Dunnett's test
## weightloss example
data(weightloss)
bwplot(loss ~ group, data=weightloss,
       scales=list(cex=1.5),
       ylab=list("Weight Loss", cex=1.5),
       xlab=list("group",cex=1.5))

weightloss.aov &lt;- aov(loss ~ group, data=weightloss)
summary(weightloss.aov)

group.count &lt;- table(weightloss$group)

tmp.dunnett &lt;-
  glht(weightloss.aov,
       linfct=mcp(group=contrMat(group.count, base=4)),
       alternative="greater")
mmcplot(tmp.dunnett, main="contrasts in alphabetical order", focus="group")

tmp.dunnett.mmc &lt;-
  mmc(weightloss.aov,
      linfct=mcp(group=contrMat(group.count, base=4)),
      alternative="greater")
mmcplot(tmp.dunnett.mmc,
        main="contrasts ordered by average value of the means\nof the two levels in the contrasts")

tmp.dunnett.mmc

## End(Not run)

## Not run: 
## two-way ANOVA
## display example

data(display)

interaction2wt(time ~ emergenc * panel.ordered, data=display)

displayf.aov &lt;- aov(time ~ emergenc * panel, data=display)
anova(displayf.aov)

## multiple comparisons
## MMC plot
displayf.mmc &lt;- mmc(displayf.aov, focus="panel")
displayf.mmc

## same thing using glht argument list
displayf.mmc &lt;-
  mmc(displayf.aov,
      linfct=mcp(panel="Tukey", `interaction_average`=TRUE, `covariate_average`=TRUE))

mmcplot(displayf.mmc)


panel.lmat &lt;- cbind("3-12"=c(-1,-1,2),
                    "1-2"=c( 1,-1,0))
dimnames(panel.lmat)[[1]] &lt;- levels(display$panel)
panel.lmat

displayf.mmc &lt;-
  mmc(displayf.aov, focus="panel", focus.lmat=panel.lmat)

## same thing using glht argument list
displayf.mmc &lt;-
  mmc(displayf.aov,
      linfct=mcp(panel="Tukey", `interaction_average`=TRUE, `covariate_average`=TRUE),
      focus.lmat=panel.lmat)

mmcplot(displayf.mmc, type="lmat")

## End(Not run)

## Not run: 
## split plot design with tiebreaker plot
##
## This example is based on the query by Tomas Goicoa to R-news
## http://article.gmane.org/gmane.comp.lang.r.general/76275/match=goicoa
## It is a split plot similar to the one in HH Section 14.2 based on
## Yates 1937 example.  I am using the Goicoa example here because its
## MMC plot requires a tiebreaker plot.


data(maiz)

interaction2wt(yield ~ hibrido+nitrogeno+bloque, data=maiz,
               par.strip.text=list(cex=.7))
interaction2wt(yield ~ hibrido+nitrogeno, data=maiz)

maiz.aov &lt;- aov(yield ~ nitrogeno*hibrido + Error(bloque/nitrogeno), data=maiz)

summary(maiz.aov)
summary(maiz.aov,
        split=list(hibrido=list(P3732=1, Mol17=2, A632=3, LH74=4)))

try(glht(maiz.aov, linfct=mcp(hibrido="Tukey")))  ## can't use 'aovlist' objects in glht

## R glht() requires aov, not aovlist
maiz2.aov &lt;- aov(terms(yield ~ bloque*nitrogeno + hibrido/nitrogeno,
                       keep.order=TRUE),
                 data=maiz)
summary(maiz2.aov)

## There are many ties in the group means.
## These are easily seen in the MMC plot, where the two clusters
## c("P3747", "P3732", "LH74") and c("Mol17", "A632")
## are evident from the top three contrasts including zero and the
## bottom contrast including zero.  The significant contrasts are the
## ones comparing hybrids in the top group of three to ones in the
## bottom group of two.

## We have two graphical responses to the ties.
## 1. We constructed the tiebreaker plot.
## 2. We construct a set of orthogonal contrasts to illustrate
##    the clusters.

## pairwise contrasts with tiebreakers.
maiz2.mmc &lt;- mmc(maiz2.aov,
                 linfct=mcp(hibrido="Tukey", interaction_average=TRUE))
mmcplot(maiz2.mmc, style="both")  ## MMC and Tiebreaker


## orthogonal contrasts
## user-specified contrasts
hibrido.lmat &lt;- cbind("PPL-MA" =c(2, 2,-3,-3, 2),
                      "PP-L"   =c(1, 1, 0, 0,-2),
                      "P47-P32"=c(1,-1, 0, 0, 0),
                      "M-A"    =c(0, 0, 1,-1, 0))
dimnames(hibrido.lmat)[[1]] &lt;- levels(maiz$hibrido)
hibrido.lmat

maiz2.mmc &lt;-
  mmc(maiz2.aov, focus="hibrido", focus.lmat=hibrido.lmat)
maiz2.mmc

## same thing using glht argument list
maiz2.mmc &lt;-
  mmc(maiz2.aov, linfct=mcp(hibrido="Tukey",
      `interaction_average`=TRUE), focus.lmat=hibrido.lmat)

  mmcplot(maiz2.mmc, style="both", type="lmat")

## End(Not run)
</code></pre>

<hr>
<h2 id='mmc.mean'> MMC (Mean&ndash;mean Multiple Comparisons) plots from the sufficient
statistics for a one-way design.</h2><span id='topic+mmc.mean'></span><span id='topic+multicomp.mean'></span><span id='topic+multicomp.mmc.mean'></span>

<h3>Description</h3>

<p>Constructs a <code>"mmc.multicomp"</code> object from the sufficient statistics
for a one-way design.  The object must be explicitly plotted.
This is the S-Plus version.  See ?aovSufficient for R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
multicomp.mean(group, n, ybar, s, alpha=.05,  ## S-Plus
               ylabel="ylabel", focus.name="focus.factor", plot=FALSE,
               lmat, labels=NULL, ...,
               df=sum(n) - length(n),
               sigmahat=(sum((n-1)*s^2) / df)^.5)

multicomp.mmc.mean(group, n, ybar, s, ylabel, focus.name,  ## S-Plus
                   lmat,
                   ...,
                   comparisons="mca",
                   lmat.rows=seq(length=length(ybar)),
                   ry,
                   plot=TRUE,
                   crit.point,
                   iso.name=TRUE,
                   estimate.sign=1,
                   x.offset=0,
                   order.contrasts=TRUE,
                   method="tukey",
                   df=sum(n)-length(n),
                   sigmahat=(sum((n-1)*s^2)/df)^.5)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmc.mean_+3A_group">group</code></td>
<td>
<p>character vector of levels</p>
</td></tr>
<tr><td><code id="mmc.mean_+3A_n">n</code></td>
<td>
<p>numeric vector of sample sizes</p>
</td></tr>
<tr><td><code id="mmc.mean_+3A_ybar">ybar</code></td>
<td>
<p>vector of group means </p>
</td></tr>
<tr><td><code id="mmc.mean_+3A_s">s</code></td>
<td>
<p>vector of group standard deviations</p>
</td></tr>
<tr><td><code id="mmc.mean_+3A_alpha">alpha</code></td>
<td>
<p>Significance levels of test</p>
</td></tr>
<tr><td><code id="mmc.mean_+3A_ylabel">ylabel</code></td>
<td>
<p>name of response variable </p>
</td></tr>
<tr><td><code id="mmc.mean_+3A_focus.name">focus.name</code></td>
<td>
<p>name of factor</p>
</td></tr>
<tr><td><code id="mmc.mean_+3A_plot">plot</code></td>
<td>
<p>logical.  Should the <code>"mmc.multicomp"</code> object be
automatically plotted?  ignored in R.</p>
</td></tr>
<tr><td><code id="mmc.mean_+3A_lmat">lmat</code></td>
<td>
<p><code>lmat</code> from <code>multicomp</code> in S-Plus or
<code>t(linfct)</code> from <code>glht</code> in R.</p>
</td></tr>
<tr><td><code id="mmc.mean_+3A_labels">labels</code></td>
<td>
<p><code>labels</code> argument for <code>multicomp</code> in S-Plus.
Not used in R.</p>
</td></tr>
<tr><td><code id="mmc.mean_+3A_method">method</code></td>
<td>
<p>method for critical point calculation.  This corresponds
to <code>method</code> in S-Plus <code>multicomp</code> and to <code>type</code>
in R <code>glht</code></p>
</td></tr>
<tr><td><code id="mmc.mean_+3A_df">df</code></td>
<td>
<p>scalar, residual degrees of freedom</p>
</td></tr>
<tr><td><code id="mmc.mean_+3A_sigmahat">sigmahat</code></td>
<td>
<p><code>sqrt(MSE)</code> from the ANOVA table</p>
</td></tr>
<tr><td><code id="mmc.mean_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
<tr><td><code id="mmc.mean_+3A_comparisons">comparisons</code></td>
<td>
<p>argument to S-Plus <code>multicomp</code> only.</p>
</td></tr>
<tr><td><code id="mmc.mean_+3A_estimate.sign">estimate.sign</code>, <code id="mmc.mean_+3A_order.contrasts">order.contrasts</code>, <code id="mmc.mean_+3A_lmat.rows">lmat.rows</code></td>
<td>
<p>See <code>lmat.rows</code> in
<code><a href="#topic+mmc">mmc</a></code>.</p>
</td></tr>
<tr><td><code id="mmc.mean_+3A_ry">ry</code></td>
<td>
<p>See argument <code>ry.mmc</code> in <code><a href="#topic+plot.mmc.multicomp">plot.mmc.multicomp</a></code>.</p>
</td></tr>
<tr><td><code id="mmc.mean_+3A_crit.point">crit.point</code></td>
<td>
<p>See argument <code>crit.point</code> in S-Plus
<code>multicomp</code>.
</p>
<p>The equivalent is not in <code>glht</code>.</p>
</td></tr>
<tr><td><code id="mmc.mean_+3A_iso.name">iso.name</code>, <code id="mmc.mean_+3A_x.offset">x.offset</code></td>
<td>
<p>See <code><a href="#topic+plot.mmc.multicomp">plot.mmc.multicomp</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>multicomp.mmc.mean</code> returns a &quot;mmc.multicomp&quot; object.
</p>
<p><code>multicomp.mean</code> returns a &quot;multicomp&quot; object.
</p>


<h3>Note</h3>

<p>The multiple comparisons calculations in R and S-Plus use
completely different functions.
MMC plots in R are constructed by <code>mmc</code>
based on
<code><a href="multcomp.html#topic+glht">glht</a></code>.
</p>
<p>MMC plots in S-Plus are constructed by
<code>multicomp.mmc</code> based on the S-Plus
<code>multicomp</code>.
</p>
<p>The MMC plot is the same in both systems.  The details of getting the
plot differ.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>
<p>Heiberger, Richard M. and Holland, Burt (2006).
&quot;Mean&ndash;mean multiple comparison displays for families of linear contrasts.&quot;
<em>Journal of Computational and Graphical Statistics</em>, 15:937&ndash;955.
</p>
<p>Hsu, J. and Peruggia, M. (1994).
&quot;Graphical representations of Tukey's multiple comparison method.&quot;
<em>Journal of Computational and Graphical Statistics</em>, 3:143&ndash;161.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmc">mmc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## This example is from Hsu and Peruggia

## This is the S-Plus version
## See ?aovSufficient for R

if.R(r={},
s={

data(pulmonary)
pulmonary.aov &lt;- aovSufficient(FVC ~ smoker,
                               data=pulmonary)
summary(pulmonary.aov)


## multicomp object
pulmonary.mca &lt;-
multicomp.mean(pulmonary$smoker,
               pulmonary$n,
               pulmonary$FVC,
               pulmonary$s,
               ylabel="pulmonary",
               focus="smoker")


pulmonary.mca
## lexicographic ordering of contrasts, some positive and some negative
plot(pulmonary.mca)



pulm.lmat &lt;- cbind("npnl-mh"=c( 1, 1, 1, 1,-2,-2), ## not.much vs lots
                   "n-pnl"  =c( 3,-1,-1,-1, 0, 0), ## none vs light
                   "p-nl"   =c( 0, 2,-1,-1, 0, 0), ## {} arbitrary 2 df
                   "n-l"    =c( 0, 0, 1,-1, 0, 0), ## {} for 3 types of light
                   "m-h"    =c( 0, 0, 0, 0, 1,-1)) ## moderate vs heavy
dimnames(pulm.lmat)[[1]] &lt;- row.names(pulmonary)
pulm.lmat


## mmc.multicomp object
pulmonary.mmc &lt;-
multicomp.mmc.mean(pulmonary$smoker,
                   pulmonary$n,
                   pulmonary$FVC,
                   pulmonary$s,
                   ylabel="pulmonary",
                   focus="smoker",
                   lmat=pulm.lmat,
                   plot=FALSE)


old.omd &lt;- par(omd=c(0,.95, 0,1))

## pairwise comparisons
plot(pulmonary.mmc, print.mca=TRUE, print.lmat=FALSE)

## tiebreaker plot, with contrasts ordered to match MMC plot,
## with all contrasts forced positive and with names also reversed,
## and with matched x-scale.
plotMatchMMC(pulmonary.mmc$mca)

## orthogonal contrasts
plot(pulmonary.mmc)

## pairwise and orthogonal contrasts on the same plot
plot(pulmonary.mmc, print.mca=TRUE, print.lmat=TRUE)

par(old.omd)
})
</code></pre>

<hr>
<h2 id='mmcAspect'>
Control aspect ratio in MMC plots to maintain isomeans grid as a square.
</h2><span id='topic+mmcAspect'></span>

<h3>Description</h3>

<p>Control aspect ratio in MMC plots to maintain isomeans grid as a square.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmcAspect(trellis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmcAspect_+3A_trellis">trellis</code></td>
<td>

<p>A <code>trellis</code> object.  If there is more than one panel, the first
panel will be used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New numeric aspect ratio that will force the isomeans grid to be a
square rotated to have vertical and horizontal diagonals.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+mmcplot">mmcplot</a></code>
</p>

<hr>
<h2 id='mmcisomeans'>
Functions used by mmcplot.
</h2><span id='topic+mmcisomeans'></span><span id='topic+mmcmatch'></span><span id='topic+mmcboth'></span>

<h3>Description</h3>

<p>Functions used by mmcplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmcisomeans(mmc, col=c("black","red"), lwd=c(1,1), lty=c(2,1),
            type = "mca", xlim = NULL, ylim = NULL, ...,
            axis.right=2.2,
            ylab=paste(
              mmc$none$ylabel, "means",
              " | ",
              mmc$none$focus, "level"),
            ylab.right=NULL,
            xlab="contrast value",
            contrast.label=TRUE,
            means.height=TRUE)

mmcmatch(mmc, col=c("black","red"), lwd=c(1,1), lty=c(2,1),
         type = "mca", xlim = NULL, ylim = NULL, ...,
         axis.right=2.2,
         ylab=NULL,
         ylab.right=NULL,
         xlab="contrast value",
         contrast.label=TRUE,
         xlim.match=(type != "none"))

mmcboth(mmc, col=c("black","red"), lwd=c(1,1), lty=c(2,1),
        type = "mca", h = c(0.7, 0.3), xlim = NULL, ylim = NULL, ...,
        ylab.right=NULL, MMCname="MMC", Tiebreakername="Tiebreaker")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmcisomeans_+3A_mmc">mmc</code></td>
<td>

<p><code>mmc</code> object or other object as indicated by method.
</p>
</td></tr>
<tr><td><code id="mmcisomeans_+3A_type">type</code></td>
<td>

<p>One of <code>c("mca", "lmat", "linfct", "none")</code>.
For the default <code>"mca"</code>, an MMC plot is drawn of the pairwise contrasts.
For  <code>"lmat"</code> or <code>"linfct"</code>, an MMC plot is drawn of the
contrasts specified to <code>mmc</code> in the <code>lmat</code> or
<code>linfct</code> argument.  For <code>"none"</code>, a confidence interval
plot for the group means is drawn.
</p>
</td></tr>
<tr><td><code id="mmcisomeans_+3A_h">h</code></td>
<td>

<p><code>h</code> argument for <code><a href="latticeExtra.html#topic+resizePanels">resizePanels</a></code>.
</p>
</td></tr>
<tr><td><code id="mmcisomeans_+3A_xlim">xlim</code>, <code id="mmcisomeans_+3A_ylim">ylim</code>, <code id="mmcisomeans_+3A_xlab">xlab</code>, <code id="mmcisomeans_+3A_ylab">ylab</code>, <code id="mmcisomeans_+3A_ylab.right">ylab.right</code></td>
<td>
<p>Standard
<code><a href="lattice.html#topic+xyplot">xyplot</a></code> arguments.
</p>
</td></tr>
<tr><td><code id="mmcisomeans_+3A_col">col</code>, <code id="mmcisomeans_+3A_lwd">lwd</code>, <code id="mmcisomeans_+3A_lty">lty</code></td>
<td>
<p>Standard
<code><a href="lattice.html#topic+xyplot">xyplot</a></code> arguments applied to the line segments
representing the contrasts.
</p>
</td></tr>
<tr><td><code id="mmcisomeans_+3A_...">...</code></td>
<td>

<p>Other arguments, to be forwarded to methods.
</p>
</td></tr>
<tr><td><code id="mmcisomeans_+3A_axis.right">axis.right</code></td>
<td>

<p>Value used internally for<br />
<code>par.settings=list(layout.widths=list(axis.right=axis.right))</code>.
The user may need to set this in two circumstances.  First, if the
contrast names overflow the right edge of the plotting window, then use
a larger value than the default.
Second, if there is a <code>ylab.right</code> and it is too far away from the
figure,
then use a smaller value than the default.
</p>
</td></tr>
<tr><td><code id="mmcisomeans_+3A_contrast.label">contrast.label</code></td>
<td>

<p>Logical.  The default <code>TRUE</code> means place the word <code>contrasts</code>
at the bottom of the right axis under the tick labels.
<code>FALSE</code> means don't place anything there.
</p>
</td></tr>
<tr><td><code id="mmcisomeans_+3A_mmcname">MMCname</code>, <code id="mmcisomeans_+3A_tiebreakername">Tiebreakername</code></td>
<td>

<p>Panel names when <code>mmcplot</code> is used with <code>style="both"</code>.
</p>
</td></tr>
<tr><td><code id="mmcisomeans_+3A_xlim.match">xlim.match</code></td>
<td>

<p>Logical.  If <code>TRUE</code>, use <code>xlim</code> based on the contrasts in the <code>mca</code>
component.  If <code>FALSE</code>, use <code>xlim</code> based on the values of the
estimates
in the current component.
</p>
</td></tr>
<tr><td><code id="mmcisomeans_+3A_means.height">means.height</code></td>
<td>
<p>Logical, with default value <code>TRUE</code>.  When
<code>TRUE</code>, then display the values of the group means as the left axis tick labels.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"trellis"</code> object.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>See <code><a href="#topic+mmc">mmc</a></code> for the references.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmc">mmc</a></code> for the discussion of the MMC.
<code><a href="#topic+mmcplot">mmcplot</a></code> for the user calls that get executed by the
functions documented here.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ## these examples exercise all optional arguments
data(catalystm)
catalystm1.aov &lt;- aov(concent ~ catalyst, data=catalystm)

catalystm.glht &lt;-
   glht(catalystm1.aov, linfct = mcp(catalyst = "Tukey"))
confint(catalystm.glht)

plot(catalystm.glht)  ## this is the multcomp:::plot.glht

mmcplot(catalystm.glht)  ## mmcplot.glht sends its argument to HH:::as.multicomp.glht with
## the default arguments (estimate.sign = 1, order.contrasts = TRUE) unless overridden:
##
mmcplot(catalystm.glht, order.contrasts=FALSE, estimate.sign=0, main="B'")

catalystm.lmat &lt;- cbind("AB-D" =c(1, 1, 0,-2),
                        "A-B"  =c(1,-1, 0, 0),
                        "ABD-C"=c(1, 1,-3, 1))
dimnames(catalystm.lmat)[[1]] &lt;- levels(catalystm$catalyst)
catalystm.mmc &lt;-
   mmc(catalystm1.aov,
       linfct = mcp(catalyst = "Tukey"),
       focus.lmat=catalystm.lmat)

mmcplot(catalystm.mmc, type="mca",  style="confint")
mmcplot(catalystm.mmc, type="lmat", style="confint")
mmcplot(catalystm.mmc, type="none", style="confint")
mmcplot(catalystm.mmc, type="none", style="confint", xlim.match=FALSE,
        main="xlim.match=FALSE is default for none confint")
mmcplot(catalystm.mmc, type="none", style="confint", xlim.match=TRUE, main="out of bounds")

mmcplot(catalystm.mmc$mca,  style="confint")
mmcplot(catalystm.mmc$lmat, style="confint")
mmcplot(catalystm.mmc$none, style="confint")

plot(catalystm.mmc) ## HH:::plot.mmc.multicomp method

mmcplot(catalystm.mmc)

mmcplot(catalystm.mmc)
mmcplot(catalystm.mmc, style="isomeans")
mmcplot(catalystm.mmc, style="confint")
mmcplot(catalystm.mmc, style="both")

mmcplot(catalystm.mmc, style="isomeans", type="mca")
mmcplot(catalystm.mmc, style="isomeans", type="lmat")
mmcplot(catalystm.mmc, style="isomeans", type="linfct")
mmcplot(catalystm.mmc, style="isomeans", type="none")
mmcplot(catalystm.mmc, style="isomeans", type="none", xlim.match=FALSE)

mmcplot(catalystm.mmc, style="confint",  type="mca")
mmcplot(catalystm.mmc, style="confint",  type="lmat")
mmcplot(catalystm.mmc, style="confint",  type="linfct")
mmcplot(catalystm.mmc, style="confint",  type="none")
mmcplot(catalystm.mmc, style="confint",  type="none", xlim.match=FALSE)

mmcplot(catalystm.mmc, style="both",     type="mca")
mmcplot(catalystm.mmc, style="both",     type="lmat")
mmcplot(catalystm.mmc, style="both",     type="linfct")
mmcplot(catalystm.mmc, style="both",     type="none")
mmcplot(catalystm.mmc, style="both",     type="none", xlim.match=FALSE)

mmcplot(catalystm.mmc$mca)
mmcplot(catalystm.mmc$mca$glht)
mmcplot(catalystm.mmc$none)
mmcplot(catalystm.mmc$none$glht)
mmcplot(catalystm.mmc$lmat)
mmcplot(catalystm.mmc$lmat$glht)

mmcplot(catalystm.mmc, type="none")
mmcplot(catalystm.mmc, type="none", xlim.match=FALSE)
mmcplot(catalystm.mmc$none)

## End(Not run)
</code></pre>

<hr>
<h2 id='mmcplot'>
MMC (Mean-mean Multiple Comparisons) plots in lattice.
</h2><span id='topic+mmcplot'></span><span id='topic+mmcplot.mmc'></span><span id='topic+mmcplot.glht'></span><span id='topic+mmcplot.mmc.multicomp'></span><span id='topic+mmcplot.multicomp'></span><span id='topic+mmcplot.default'></span>

<h3>Description</h3>

<p>MMC (Mean&ndash;mean Multiple Comparisons) plots in lattice
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmcplot(mmc, ...)
## S3 method for class 'mmc'
mmcplot(mmc, col=c("black","red"), lwd=c(1,1), lty=c(2,1), ...,
                  style=c("isomeans", "confint", "both"),
                  type=c("mca", "lmat", "linfct", "none"))
## S3 method for class 'glht'
mmcplot(mmc, col=c("black","red"), lwd=c(1,1), lty=c(2,1),
                  focus=mmc$focus, ...)
## S3 method for class 'mmc.multicomp'
mmcplot(mmc, col=c("black","red"), lwd=c(1,1), lty=c(2,1), ...)
## S3 method for class 'multicomp'
mmcplot(mmc, col=c("black","red"), lwd=c(1,1), lty=c(2,1), ...)
## Default S3 method:
mmcplot(mmc, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmcplot_+3A_mmc">mmc</code></td>
<td>

<p><code>mmc</code> object or other object as indicated by method.
</p>
</td></tr>
<tr><td><code id="mmcplot_+3A_col">col</code>, <code id="mmcplot_+3A_lwd">lwd</code>, <code id="mmcplot_+3A_lty">lty</code></td>
<td>
<p>Standard
<code><a href="lattice.html#topic+xyplot">xyplot</a></code> arguments applied to the line segments
representing the contrasts.
</p>
</td></tr>
<tr><td><code id="mmcplot_+3A_focus">focus</code></td>
<td>
<p>Name of the factor for which the <code>glht</code> object was constructed.</p>
</td></tr>
<tr><td><code id="mmcplot_+3A_...">...</code></td>
<td>

<p>Other arguments to be passed on to the functions called by the methods.
</p>
</td></tr>
<tr><td><code id="mmcplot_+3A_style">style</code></td>
<td>

<p>Style of graph: The default <code>isomeans</code> is the standard MMC plot with the
isomeans grid.  <code>confint</code> is a confidence interval plot, similar to
the plot produced by <code>multcomp:::plot.glht</code>.
<code>both</code> prints both the <code>isomeans</code> and
the <code>confint</code> plot as two panels of a <code>trellis</code> structure.
When the underlying sets of means are close to each other, there will
of necessity be overprinting in the <code>isomeans</code> panel and the
<code>confint</code> panel will be needed as a tiebreaker.
By default the <code>xlim</code> for the <code>confint</code> style will match the
<code>xlim</code> of the corresponding <code>isomeans</code> plot.
</p>
</td></tr>
<tr><td><code id="mmcplot_+3A_type">type</code></td>
<td>

<p><code>mca</code> for the default paired-comparisons plot.  <code>lmat</code> or
<code>linfct</code>
for a user-specified set of contrasts.  <code>none</code> for confidence
intervals on the set of group means (that is, no comparisons).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>trellis</code> object containing the graphs.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>See <code><a href="#topic+mmc">mmc</a></code> for the references.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmc">mmc</a></code> for the discussion of the MMC and for many examples.
The functions <code><a href="#topic+mmcisomeans">mmcisomeans</a></code>, <code><a href="#topic+mmcmatch">mmcmatch</a></code>,
<code><a href="#topic+mmcboth">mmcboth</a></code> are the internal functions that do the
actual work of plotting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(catalystm)
catalystm1.aov &lt;- aov(concent ~ catalyst, data=catalystm)
catalystm.mmc &lt;-
   mmc(catalystm1.aov, linfct = mcp(catalyst = "Tukey"))
mmcplot(catalystm.mmc)
mmcplot(catalystm.mmc, style="both", MMCname="catalyst")
</code></pre>

<hr>
<h2 id='mmcPruneIsomeans'>
MMC plots in lattice&mdash;suppress isomeans grid lines for specified levels
of the factor.
</h2><span id='topic+mmcPruneIsomeans'></span>

<h3>Description</h3>

<p>MMC plots in lattice&mdash;suppress isomeans grid lines for specified levels
of the factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmcPruneIsomeans(mmc, keep=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmcPruneIsomeans_+3A_mmc">mmc</code></td>
<td>

<p>An <code>"mmc.multicomp"</code> object.
</p>
</td></tr>
<tr><td><code id="mmcPruneIsomeans_+3A_keep">keep</code></td>
<td>

<p>Index vector of rows of <code>mmc$none$table</code> that will be kept in the display.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified <code>"mmc.multicomp"</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmc">mmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## needed
## Not run: 
## See file hh/scripts/hh2/tway.R for the complete example.
## A better example is needed for the .Rd documentation.
## possibly based on filmcoat temperature | pressure example.
data(rhiz.clover)
c(1,2,5,10,11,12)
rhiz.clover$cs &lt;- with(rhiz.clover, interaction(comb, strain))
rhiz.clover.cs.aov &lt;- aov(Npg ~ cs, data=rhiz.clover)
rhiz.clover.cs.aov
cs.mmc &lt;- mmc(rhiz.clover.cs.aov, linfct=mcp(cs="Tukey"),
              calpha=qtukey( .95, 6,  48)/sqrt(2))
dlmat2 &lt;- dimnames(cs.mmc$mca$lmat)[[2]]
cl.index &lt;- grep("clover\\.[[:print:]]*clover\\.", dlmat2, value=TRUE)
cl.index
clover.lmat &lt;- cs.mmc$mca$lmat[, cl.index] ## suppress "clover+alfalfa" contrasts
dimnames(clover.lmat)[[1]]
dimnames(clover.lmat)[[1]] &lt;- levels(rhiz.clover$cs)
clover.lmat[1,] &lt;- -colSums(clover.lmat[-1, ])
clover.lmat
csc.mmc &lt;- mmc(rhiz.clover.cs.aov, linfct=mcp(cs="Tukey"),
               focus.lmat=clover.lmat,
               calpha=qtukey( .95, 6,  48)/sqrt(2))
## this example needs a window 11 inches high and 14 inches wide
mmcplot(csc.mmc, type="lmat", style="both")

## suppress "clover+alfalfa" means
csc.mmc.clover &lt;- mmcPruneIsomeans(csc.mmc, keep = c(1,2,5,10,11,12))
csc.mmc.clover
## this example needs a window 11 inches high and 14 inches wide
mmcplot(csc.mmc.clover, type="lmat", style="both")

## End(Not run)
</code></pre>

<hr>
<h2 id='multicomp.order'>Update a multicomp object by ordering its contrasts.</h2><span id='topic+multicomp.order'></span><span id='topic+multicomp.label.change'></span><span id='topic+multicomp.label.change.multicomp'></span><span id='topic+multicomp.label.change.mmc.multicomp'></span>

<h3>Description</h3>

<p>Update a multicomp object by ordering its contrasts.
The default <code>sort.by = "height"</code> matches the order in the MMC plot.
An alternate <code>sort.by = "estimate"</code> matches the order of the
half-normal plot.  Or the argument <code>sort.order</code> can be used
to specify any other order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multicomp.order(mca, sort.by = "height", sort.order = NULL)

multicomp.label.change(x, old="adj", new="new", how.many=2)

## S3 method for class 'multicomp'
multicomp.label.change(x, old="adj", new="new", how.many=2)

## S3 method for class 'mmc.multicomp'
multicomp.label.change(x, old="adj", new="new", how.many=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multicomp.order_+3A_mca">mca</code></td>
<td>
<p><code>"multicomp"</code> object.  This is the result of
<code>multicomp</code> in S-Plus or the result from applying <code>as.multicomp</code> to
a <code>"glht"</code> object in R.</p>
</td></tr>
<tr><td><code id="multicomp.order_+3A_sort.by">sort.by</code></td>
<td>
<p>Either <code>"height"</code> or <code>"estimate"</code>.</p>
</td></tr>
<tr><td><code id="multicomp.order_+3A_sort.order">sort.order</code></td>
<td>
<p>Vector of indices by which the contrasts are to be
sorted.  When <code>sort.order</code> in non-<code>NULL</code>, it is used.</p>
</td></tr>

<tr><td><code id="multicomp.order_+3A_x">x</code></td>
<td>
<p><code>"multicomp"</code> object.</p>
</td></tr>
<tr><td><code id="multicomp.order_+3A_old">old</code></td>
<td>
<p>character string to be removed from contrast names.</p>
</td></tr>
<tr><td><code id="multicomp.order_+3A_new">new</code></td>
<td>
<p>replacement character string to be inserted in contrast names.</p>
</td></tr>
<tr><td><code id="multicomp.order_+3A_how.many">how.many</code></td>
<td>
<p>number of times to make the replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result is a <code>"multicomp"</code> object containing the same
contrasts as the argument.<br />
<code>multicomp.order</code> sorts the contrasts
(and renames them consistently) according to the specifications.<br />
<code>multicomp.label.change</code>
changes the contrast names according to the specifications.
</p>
<p>When <code>sort.by=="height"</code>, sort the contrasts by the reverse order
of the heights.  This provides a <code>"multicomp"</code> object that will be
plotted by <code>plot.multicomp</code> in the same order used by<br />
<code>mmcplot</code> or the older <code>plot.mmc.multicomp</code>.  If there is not <code>"height"</code> component,
the original <code>"multicomp"</code> object is returned.
</p>
<p>When <code>sort.by=="estimate"</code>, sort the contrasts by the reverse order
of the contrast estimates.  This provides the same order as the
half-normal plot.
</p>
<p>When <code>sort.order</code> in non-<code>NULL</code>, sort the contrasts in
that order.
</p>


<h3>Note</h3>

<p>S-Plus use the <code>multicomp</code> functions
and R uses the <code>multcomp</code> package.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>
<p>Heiberger, Richard M. and Holland, Burt (2006).
&quot;Mean&ndash;mean multiple comparison displays for families of linear contrasts.&quot;
<em>Journal of Computational and Graphical Statistics</em>, 15:937&ndash;955.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MMC">MMC</a></code>, <code><a href="#topic+as.glht">as.glht</a> in R</code>,
<code><a href="#topic+multicomp.reverse">multicomp.reverse</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## continue with the example in mmc in R, or multicomp.mmc in S-Plus
data(catalystm)

catalystm1.aov &lt;- aov(concent ~ catalyst, data=catalystm)

if.R(r={
catalystm.mca &lt;-
   glht(catalystm1.aov, linfct = mcp(catalyst = "Tukey"))
print(confint(catalystm.mca))

catalystm.mmc &lt;-
   mmc(catalystm1.aov, linfct = mcp(catalyst = "Tukey"))
## the contrasts have been ordered by height (see ?MMC),
## which in this example corresponds to sort.order=c(1,2,4,3,5,6),
## and reversed, to make the contrast Estimates positive.
print(as.glht(catalystm.mmc$mca))

## ## For consistency with the S-Plus example,
## ## we change all factor level "A" to "control".
## as.glht(multicomp.label.change(catalystm.mmc$mca, "A", "control"))
},s={
catalystm.mca &lt;-
   multicomp(catalystm1.aov, method="Tukey")
print(catalystm.mca)

catalystm.mmc &lt;-
   multicomp.mmc(catalystm1.aov, method="Tukey", plot=FALSE)
## the contrasts have been ordered by height (see ?MMC),
## which in this example corresponds to sort.order=c(1,2,4,3,5,6),
## and reversed, to make the contrast Estimates positive.
print(catalystm.mmc$mca)

## S-Plus multicomp already uses simple names.  This function is
## therefore used in more complex two-way ANOVA examples.  We illustrate
## here by changing all factor level "A" to "control".
print(multicomp.label.change(catalystm.mmc$mca, "A", "control"))
})

</code></pre>

<hr>
<h2 id='multicomp.reverse'>Force all comparisons in a &quot;multicomp&quot; object to have the same sign.</h2><span id='topic+multicomp.reverse'></span>

<h3>Description</h3>

<p>Force all comparisons in a <code>"multicomp"</code> object
to have the same sign.  If the contrast <code>"A-B"</code> has a negative estimate,
reverse it show the contrast <code>"B-A"</code> with a positive estimate.
If a contrast name does not include a minus sign <code>"-"</code> and the
contrast is reversed, then an informative message is printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multicomp.reverse(y, estimate.sign = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multicomp.reverse_+3A_y">y</code></td>
<td>
<p><code>"multicomp"</code> object</p>
</td></tr>
<tr><td><code id="multicomp.reverse_+3A_estimate.sign">estimate.sign</code></td>
<td>
<p>If <code>estimate.sign==1</code>, reverse the negatives.
If <code>estimate.sign==-1</code>, reverse the positives.
Both the names of the comparisons and the numerical values are reversed.
If <code>estimate.sign==0</code>, return the argument.</p>
</td></tr>
<tr><td><code id="multicomp.reverse_+3A_...">...</code></td>
<td>
<p>other arguments not used. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result is a <code>"multicomp"</code> object containing the same contrasts
as the argument but with the sign of the contrasts changed as needed.
</p>


<h3>Note</h3>

<p>S-Plus use the <code>multicomp</code> functions and R uses the <code>multcomp</code>
package.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>
<p>Heiberger, Richard M. and Holland, Burt (2006).
&quot;Mean&ndash;mean multiple comparison displays for families of linear contrasts.&quot;
<em>Journal of Computational and Graphical Statistics</em>, 15:937&ndash;955.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MMC">MMC</a></code>, <code><a href="#topic+multicomp.order">multicomp.order</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## see example in multicomp.order
</code></pre>

<hr>
<h2 id='norm.curve'>plot a normal or a t-curve with both x and z axes.</h2><span id='topic+norm.setup'></span><span id='topic+norm.curve'></span><span id='topic+norm.observed'></span><span id='topic+norm.outline'></span><span id='topic+normal.and.t.dist'></span>

<h3>Description</h3>

<p>Plot a normal curve or a t-curve with both x (with <code>mean</code> and <code>se</code>
as specified) and z or t (mean=0, se=1) axes.
Shade a region for rejection region, acceptance region, confidence
interval.
The density axis is marked in units appropriate for the z or t axis.
The existence of any of the arguments <code>se</code>, <code>sd</code>, <code>n</code>
forces dual <code>x</code> and (<code>z</code> or <code>t</code>) scales.  When none of these
arguments
are used, the main title defaults to
<code>"Standard Normal Density N(0,1)"</code> and only the <code>z</code> scale is
printed.  A second density curve, appropriate for an alternative
hypothesis
is displayed when the argument <code>axis.name="z1"</code> is specified.
The shaded area is printed on the plot.
</p>
<p>When the optional argument <code>df.t</code> is specified, then a
t-distribution with <code>df.t</code> degrees of freedom is plotted.
</p>
<p><code>norm.observed</code> plots a vertical line with arrowhead markers at
the location of the observed xbar.
</p>
<p><code>normal.and.t.dist</code> is a driver function that uses all the
others.  It's primary function is drawing a plot.  It returns
an invisible list containing the values it calculated and
displayed on the graph.
</p>
<p><code>norm.curve</code> draws the curves and filled areas as requested
by the <code>normal.and.t.dist</code> function.  Any <code>out of bounds</code>
errors (for example, with <code>normal.and.t.dist(deg.free=1)</code>)
are suppressed with <code>par(err=-1)</code> by this function and
restored to the previous value when the <code>norm.curve</code> function completes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal.and.t.dist(mu.H0          = 0,
                  mu.H1          = NA,
                  obs.mean       = 0,
                  std.dev        = 1,
                  n              = NA,
                  deg.freedom    = NA,
                  alpha.left     = alpha.right,
                  alpha.right    = .05,
                  Use.mu.H1      = FALSE,
                  Use.obs.mean   = FALSE,
                  Use.alpha.left = FALSE,
                  Use.alpha.right= TRUE,
                  hypoth.or.conf = 'Hypoth',
                  xmin           = NA,
                  xmax           = NA,
                  gxbar.min      = NA,
                  gxbar.max      = NA,
                  cex.crit       = 1.2,
                  polygon.density= -1,
                  polygon.lwd    = 4,
                  col.mean       = 'limegreen',
                  col.mean.label = 'limegreen',
                  col.alpha      = 'blue',
                  col.alpha.label= 'blue',
                  col.beta       = 'red',
                  col.beta.label = 'red',
                  col.conf       = 'palegreen',
                  col.conf.arrow = 'darkgreen',
                  col.conf.label = 'darkgreen'
                  )

norm.setup(xlim=c(-2.5,2.5),
           ylim = c(0, 0.4)/se,
           mean=0,
           main=main.calc,
           se=sd/sqrt(n), sd=1, n=1,
           df.t=NULL,
           Use.obs.mean=TRUE,
            ...)

norm.curve(mean=0, se=sd/sqrt(n),
          critical.values=mean + se*c(-1, 1)*z.975,
          z=if(se==0) 0 else
               do.call("seq", as.list(c((par()$usr[1:2]-mean)/se, length=109))),
          shade, col="blue",
          axis.name=ifelse(is.null(df.t) || df.t==Inf, "z", "t"),
          second.axis.label.line=3,
          sd=1, n=1,
          df.t=NULL,
          axis.name.expr=axis.name,
          Use.obs.mean=TRUE,
          col.label=col,
          hypoth.or.conf="Hypoth",
          col.conf.arrow=par("col"),
          col.conf.label=par("col"),
          col.crit=ifelse(hypoth.or.conf=="Hypoth", 'blue', col.conf.arrow),
          cex.crit=1.2,
          polygon.density=-1,
          polygon.lwd=4,
          col.border=ifelse(is.na(polygon.density), FALSE, col),
          ...)

norm.observed(xbar, t.xbar, t.xbar.H1=NULL,
              col="green",
              p.val=NULL, p.val.x=par()$usr[2]+ left.margin,
              t.or.z=ifelse(is.null(deg.free) || deg.free==Inf, "z", "t"),
              t.or.z.position=par()$usr[1]-left.margin,
              cex.small=par()$cex*.7, col.label=col,
              xbar.negt=NULL, cex.large=par()$cex,
              left.margin=.15*diff(par()$usr[1:2]),
              sided="", deg.free=NULL)

norm.outline(dfunction, left, right, mu.H0, se, deg.free=NULL,
             col.mean="green")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm.curve_+3A_xlim">xlim</code>, <code id="norm.curve_+3A_ylim">ylim</code>, <code id="norm.curve_+3A_xmin">xmin</code>, <code id="norm.curve_+3A_xmax">xmax</code>, <code id="norm.curve_+3A_gxbar.min">gxbar.min</code>, <code id="norm.curve_+3A_gxbar.max">gxbar.max</code></td>
<td>
<p><code>xlim, ylim</code>.
Defaults to correct values for standard
Normal(0,1).  User must set values for other mean and standard
error.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_mean">mean</code></td>
<td>
<p>Mean of the normal distribution in xbar-scale,
used in calls to <code>dnorm</code>.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_se">se</code></td>
<td>
<p>standard error of the normal distribution in xbar-scale,
used in calls to <code>dnorm</code>.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_sd">sd</code>, <code id="norm.curve_+3A_std.dev">std.dev</code>, <code id="norm.curve_+3A_n">n</code></td>
<td>
<p>standard deviation and sample size of the normal
distribution in x-scale.  These may be used as an alternate way of
specifying the standard error <code>se</code>.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_df.t">df.t</code>, <code id="norm.curve_+3A_deg.freedom">deg.freedom</code></td>
<td>
<p>Degrees of freedom for the t distribution.  When
<code>df.t</code> is <code>NULL</code>, the normal distribution is used.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_critical.values">critical.values</code></td>
<td>
<p>Critical values in xbar-scale.
A scalar value implies a one-sided test.  A vector of two values
implies a two-sided test.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_main">main</code></td>
<td>
<p>Main title.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_z">z</code></td>
<td>
<p>z-values (standardized to N(0,1)) used as base of plot.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_shade">shade</code></td>
<td>

<p>Valid values for shade are &quot;right&quot;, &quot;left&quot;, &quot;inside&quot;, &quot;outside&quot;, &quot;none&quot;.
Default is &quot;right&quot; for one-sided critical.values and &quot;outside&quot;
for two-sided critical values.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_col">col</code></td>
<td>
<p>color of the shaded region.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_col.label">col.label</code>, <code id="norm.curve_+3A_col.alpha">col.alpha</code>, <code id="norm.curve_+3A_col.alpha.label">col.alpha.label</code></td>
<td>
<p>color of the area of
the shaded rejection region and its label.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_col.beta">col.beta</code>, <code id="norm.curve_+3A_col.beta.label">col.beta.label</code></td>
<td>
<p>color of the area of the shaded region
For Type II error and its label.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_hypoth.or.conf">hypoth.or.conf</code></td>
<td>
<p><code>"Hypoth"</code> or <code>"Conf"</code></p>
</td></tr>
<tr><td><code id="norm.curve_+3A_col.conf">col.conf</code></td>
<td>
<p>Color of plot within confidence limits.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_col.conf.arrow">col.conf.arrow</code></td>
<td>
<p>Color of arrow denoting confidence limits.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_col.conf.label">col.conf.label</code></td>
<td>
<p>Color of label giving confidence level.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_col.mean.label">col.mean.label</code></td>
<td>
<p>Color of label for observed mean.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_col.crit">col.crit</code>, <code id="norm.curve_+3A_cex.crit">cex.crit</code></td>
<td>
<p>Color and cex of critical values.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_axis.name">axis.name</code>, <code id="norm.curve_+3A_axis.name.expr">axis.name.expr</code></td>
<td>
<p>defaults to <code>"z"</code>
for the standard normal scale centered on
the null hypothesis value of the mean or to <code>"t"</code> for
the t distribution with <code>df.t</code> degrees of freedom.
For alternative hypotheses, the user must specify either
<code>"z1"</code> or <code>"t1"</code> for the standard normal scale,
or t distibution with <code>df.t</code> degrees of freedom, centered on
the alternate hypothesis value of the mean.  The
<code>axis.name.expr</code> allows R users to say
<code>expression(z[1])</code> to get real subscripts.
</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_second.axis.label.line">second.axis.label.line</code></td>
<td>
<p>Defaults to <code>3</code>.
Normally not needed.  When two curves are drawn, one normal and one t,
then the second curve needs a different label for the y-axis.
Set this value to 4 to avoid overprinting.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_xbar">xbar</code>, <code id="norm.curve_+3A_obs.mean">obs.mean</code></td>
<td>
<p>xbar-value of the observed data.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_t.xbar">t.xbar</code></td>
<td>
<p>t-value of the observed data under the null hypothesis.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_...">...</code></td>
<td>
<p>Other arguments which are ignored.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_use.obs.mean">Use.obs.mean</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, then include <code>"mean"</code>
on the plot.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_alpha.right">alpha.right</code>, <code id="norm.curve_+3A_alpha.left">alpha.left</code></td>
<td>
<p>Area in tail of curve.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_use.alpha.right">Use.alpha.right</code>, <code id="norm.curve_+3A_use.alpha.left">Use.alpha.left</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, then
include the specified <code class="reqn">\alpha</code> on the plot.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_t.xbar.h1">t.xbar.H1</code></td>
<td>
<p>t-value under alternate hypothesis.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_p.val">p.val</code></td>
<td>
<p>under specified hypothesis</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_p.val.x">p.val.x</code>, <code id="norm.curve_+3A_t.or.z.position">t.or.z.position</code></td>
<td>
<p>location on x-axis to put label</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_t.or.z">t.or.z</code></td>
<td>
<p>label for axis.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_cex.small">cex.small</code></td>
<td>
<p>cex for left margin labels of axis.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_xbar.negt">xbar.negt</code></td>
<td>
<p>location in data scale of negative t- or z-value
corresponding to observed x-value.  Used for two-sided p-values.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_cex.large">cex.large</code></td>
<td>
<p>cex for labels in top margin.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_left.margin">left.margin</code></td>
<td>
<p>distance to the left of <code>par()$usr[1]</code>.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_sided">sided</code></td>
<td>
<p>type of test.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_deg.free">deg.free</code></td>
<td>
<p>degrees of freedom or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_dfunction">dfunction</code></td>
<td>
<p><code>"dnorm"</code> or <code>"dt"</code></p>
</td></tr>
<tr><td><code id="norm.curve_+3A_left">left</code></td>
<td>
<p>left end of interval</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_right">right</code></td>
<td>
<p>right end of interval</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_mu.h0">mu.H0</code>, <code id="norm.curve_+3A_mu.h1">mu.H1</code></td>
<td>
<p>mean under the null hypothesis and alternative hypothesis.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_use.mu.h1">Use.mu.H1</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, then include <code>mu.H1</code>
on the plot.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_col.mean">col.mean</code></td>
<td>
<p>Color of outline.</p>
</td></tr>
<tr><td><code id="norm.curve_+3A_polygon.density">polygon.density</code>, <code id="norm.curve_+3A_polygon.lwd">polygon.lwd</code>, <code id="norm.curve_+3A_col.border">col.border</code></td>
<td>
<p><code>density, lwd,
      border</code> arguments to <code>polygon</code>.  <code>polygon.density</code>
is <code class="reqn">-1</code> by default to give a solid color filled region.
Setting <code>polygon.density</code> to a positive value (we recommend 10)
gives a diagonally-hatched area appropriate for printing the graph
on a black and white printer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible list containing the
calculated values of probabilities and critical values in the data
scale, the null hypothesis z- or t-scale, and the alternative
hypothesis z- or t-scale, as specified.  The components are:
<code>beta.left, beta.middle, beta.right, crit.val, crit.val.H1,</code><br />
<code>crit.val.H1.left, crit.val.left, crit.val.left.z, crit.val.z, obs.mean.H0.p.val,</code><br />
<code>obs.mean.H0.side, obs.mean.H0.z, obs.mean.H1.z, obs.mean.x.neg, obs.mean.x.pos,</code><br />
<code>obs.mean.z.pos, standard, standard.error, standard.normal</code>
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>Examples</h3>

<pre><code class='language-R'>normal.and.t.dist()
normal.and.t.dist(xmin=-4)
normal.and.t.dist(std.dev=2)
normal.and.t.dist(std.dev=2, Use.alpha.left=TRUE, deg.free=6)
normal.and.t.dist(std.dev=2, Use.alpha.left=TRUE, deg.free=6, gxbar.max=.20)
normal.and.t.dist(std.dev=2, Use.alpha.left=TRUE, deg.free=6,
                  gxbar.max=.20, polygon.density=10)
normal.and.t.dist(std.dev=2, Use.alpha.left=FALSE, deg.free=6,
                  gxbar.max=.20, polygon.density=10,
                  mu.H1=2, Use.mu.H1=TRUE,
                  obs.mean=2.5, Use.obs.mean=TRUE, xmin=-7)
normal.and.t.dist(std.dev=2, hypoth.or.conf="Conf")
normal.and.t.dist(std.dev=2, hypoth.or.conf="Conf", deg.free=8)

old.par &lt;- par(oma=c(4,0,2,5), mar=c(7,7,4,2)+.1)

norm.setup()
norm.curve()

norm.setup(xlim=c(75,125), mean=100, se=5)
norm.curve(100, 5, 100+5*(1.645))
norm.observed(112, (112-100)/5)
norm.outline("dnorm", 112, par()$usr[2], 100, 5)

norm.setup(xlim=c(75,125), mean=100, se=5)
norm.curve(100, 5, 100+5*(-1.645), shade="left")

norm.setup(xlim=c(75,125), mean=100, se=5)
norm.curve(mean=100, se=5, col='red')

norm.setup(xlim=c(75,125), mean=100, se=5)
norm.curve(100, 5, 100+5*c(-1.96, 1.96))

norm.setup(xlim=c(-3, 6))
norm.curve(critical.values=1.645, mean=1.645+1.281552, col='green',
           shade="left", axis.name="z1")
norm.curve(critical.values=1.645, col='red')

norm.setup(xlim=c(-6, 12), se=2)
norm.curve(critical.values=2*1.645, se=2, mean=2*(1.645+1.281552),
           col='green', shade="left", axis.name="z1")
norm.curve(critical.values=2*1.645, se=2, mean=0,
           col='red', shade="right")


par(mfrow=c(2,1))
norm.setup()
norm.curve()
mtext("norm.setup(); norm.curve()", side=1,  line=5)
norm.setup(n=1)
norm.curve(n=1)
mtext("norm.setup(n=1); norm.curve(n=1)", side=1,  line=5)
par(mfrow=c(1,1))


par(mfrow=c(2,2))

## naively scaled,
## areas under the curve are numerically the same but visually different
norm.setup(n=1)
norm.curve(n=1)
norm.observed(1.2, 1.2/(1/sqrt(1)))
norm.setup(n=2)
norm.curve(n=2)
norm.observed(1.2, 1.2/(1/sqrt(2)))
norm.setup(n=4)
norm.curve(n=4)
norm.observed(1.2, 1.2/(1/sqrt(4)))
norm.setup(n=10)
norm.curve(n=10)
norm.observed(1.2, 1.2/(1/sqrt(10)))
mtext("areas under the curve are numerically the same but visually different",
      side=3, outer=TRUE)

## scaled so all areas under the curve are numerically and visually the same
norm.setup(n=1, ylim=c(0,1.3))
norm.curve(n=1)
norm.observed(1.2, 1.2/(1/sqrt(1)))
norm.setup(n=2, ylim=c(0,1.3))
norm.curve(n=2)
norm.observed(1.2, 1.2/(1/sqrt(2)))
norm.setup(n=4, ylim=c(0,1.3))
norm.curve(n=4)
norm.observed(1.2, 1.2/(1/sqrt(4)))
norm.setup(n=10, ylim=c(0,1.3))
norm.curve(n=10)
norm.observed(1.2, 1.2/(1/sqrt(10)))
mtext("all areas under the curve are numerically and visually the same",
      side=3, outer=TRUE)

par(mfrow=c(1,1))


## t distribution
mu.H0 &lt;- 16
se.val &lt;- .4
df.val &lt;- 10
crit.val &lt;- mu.H0 - qt(.95, df.val) * se.val
mu.alt &lt;- 15
obs.mean &lt;- 14.8

alt.t &lt;- (mu.alt - crit.val) / se.val
norm.setup(xlim=c(12, 19), se=se.val, df.t=df.val)
norm.curve(critical.values=crit.val, se=se.val, df.t=df.val, mean=mu.alt,
           col='green', shade="left", axis.name="t1")
norm.curve(critical.values=crit.val, se=se.val, df.t=df.val, mean=mu.H0,
           col='gray', shade="right")
norm.observed(obs.mean, (obs.mean-mu.H0)/se.val)

## normal
norm.setup(xlim=c(12, 19), se=se.val)
norm.curve(critical.values=crit.val, se=se.val, mean=mu.alt,
           col='green', shade="left", axis.name="z1")
norm.curve(critical.values=crit.val, se=se.val, mean=mu.H0,
           col='gray', shade="right")
norm.observed(obs.mean, (obs.mean-mu.H0)/se.val)



## normal and t
norm.setup(xlim=c(12, 19), se=se.val, main="t(6) and normal")
norm.curve(critical.values=15.5, se=se.val, mean=16.3,
           col='gray', shade="right")
norm.curve(critical.values=15.5, se.val, df.t=6, mean=14.7,
           col='green', shade="left", axis.name="t1", second.axis.label.line=4)
norm.curve(critical.values=15.5, se=se.val, mean=16.3,
           col='gray', shade="none")

norm.setup(xlim=c(12, 19), se=se.val, main="t(6) and normal")
norm.curve(critical.values=15.5, se=se.val, mean=15.5,
           col='gray', shade="right")
norm.curve(critical.values=15.5, se=se.val, df.t=6, mean=15.5,
           col='green', shade="left", axis.name="t1", second.axis.label.line=4)
norm.curve(critical.values=15.5, se=se.val, mean=15.5,
           col='gray', shade="none")



par(old.par)
</code></pre>

<hr>
<h2 id='NormalAndTplot'>Specify plots to illustrate Normal and t Hypothesis Tests or Confidence Intervals.</h2><span id='topic+NormalAndTplot'></span><span id='topic+NormalAndTplot.default'></span><span id='topic+NormalAndTplot.htest'></span>

<h3>Description</h3>

<p>Specify plots to illustrate Normal and t Hypothesis Tests
or Confidence Intervals.</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormalAndTplot(mean0, ...)
## Default S3 method:
NormalAndTplot(mean0=0,
             mean1=NA,
             xbar=NA,
             df=Inf, n=1,
             sd=1,
             xlim=c(-3, 3)*sd/sqrt(n) + range(c(mean0, mean1, xbar), na.rm=TRUE),
             ylim, alpha.right=.05, alpha.left=0,
             float=TRUE, ntcolors="original",
             digits=4, digits.axis=digits, digits.float=digits,
             distribution.name=c("normal","z","t","binomial"),
             type=c("hypothesis", "confidence"),
             zaxis=FALSE, z1axis=FALSE,
             cex.z=.5, cex.xbar=.5, cex.y=.5, cex.prob=.6, cex.top.axis=1,
             cex.left.axis=1, cex.pb.axis=1,
             cex.xlab=1, cex.ylab=1.5, cex.strip=1,
             main=NA, xlab, ylab,
             prob.labels=(type=="hypothesis"),
             xhalf.multiplier=1,
             yhalf.multiplier=1,
             cex.main=1,
             key.axis.padding=4.5,
             number.vars=1,
             sub=NULL,
             NTmethod="default",
             power=FALSE,
             beta=FALSE,
              ...)
## S3 method for class 'htest'
NormalAndTplot(mean0, type="hypothesis", xlim=NULL, mean1=NA, ...,
             xbar, sd, df, n, alpha.left, alpha.right, ## ignored
             distribution.name, sub ## these input arguments will be ignored
             )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NormalAndTplot_+3A_mean0">mean0</code></td>
<td>

<p>Null hypothesis <code class="reqn">\mu_0</code>.
When graphing a confidence interval, <code>mean0</code> will be used for
<code>xbar</code> should <code>xbar</code> itself have the value <code>NA</code>.
For the <code>htest</code> method, <code>mean0</code> is an <code>"htest"</code>
object.
See <code><a href="#topic+NTplot">NTplot</a></code> for more information.
</p>
</td></tr>
<tr><td><code id="NormalAndTplot_+3A_mean1">mean1</code></td>
<td>

<p>Alternative hypothesis <code class="reqn">\mu_1</code>.
</p>
</td></tr>
<tr><td><code id="NormalAndTplot_+3A_xbar">xbar</code></td>
<td>

<p>Observed <code class="reqn">\bar{x}</code>.
</p>
</td></tr>
<tr><td><code id="NormalAndTplot_+3A_sd">sd</code></td>
<td>

<p>Standard deviation in the data scale <code class="reqn">\sigma</code> for normal-, or <code class="reqn">s</code> for <code class="reqn">t</code>-distribution.
</p>
</td></tr>
<tr><td><code id="NormalAndTplot_+3A_df">df</code></td>
<td>

<p>Degrees of freedom for <code class="reqn">t</code>-distribution.
</p>
</td></tr>
<tr><td><code id="NormalAndTplot_+3A_n">n</code></td>
<td>

<p>Number of observations per group.
</p>
</td></tr>
<tr><td><code id="NormalAndTplot_+3A_main">main</code>, <code id="NormalAndTplot_+3A_xlab">xlab</code>, <code id="NormalAndTplot_+3A_ylab">ylab</code>, <code id="NormalAndTplot_+3A_xlim">xlim</code>, <code id="NormalAndTplot_+3A_ylim">ylim</code>, <code id="NormalAndTplot_+3A_sub">sub</code></td>
<td>

<p>Standard <code><a href="lattice.html#topic+xyplot">xyplot</a></code> arguments.  Default values
are constructed if these arguments are missing. The input value
<code>main=NA</code>
forces a new constructed <code>main</code> instead of using the <code>main</code> coming in through the
<code>htest</code> methods.
</p>
</td></tr>
<tr><td><code id="NormalAndTplot_+3A_...">...</code></td>
<td>

<p>Additional <code><a href="lattice.html#topic+xyplot">xyplot</a></code> arguments.
</p>
</td></tr>
<tr><td><code id="NormalAndTplot_+3A_number.vars">number.vars</code></td>
<td>

<p>Number of variables. 1 for a one-sample test, 2 for two-sample tests
and paired tests.
</p>
</td></tr>
<tr><td><code id="NormalAndTplot_+3A_alpha.left">alpha.left</code>, <code id="NormalAndTplot_+3A_alpha.right">alpha.right</code></td>
<td>
<p>For <code>type="hypothesis"</code>,
the sum of these two numbers is the probability of the Type I Error
<code class="reqn">\alpha</code>.  When both of these numbers are positive, there is a two-sided
test.  Note that it is not required that they be equal.  If one of the
numbers is 0, then it is a one-sided test.  For
<code>type="confidence"</code>, 1 minus the sum of these two numbers is the
confidence level.
</p>
</td></tr>
<tr><td><code id="NormalAndTplot_+3A_float">float</code></td>
<td>

<p>Logical.  If <code>TRUE</code>, then the probabilities <code class="reqn">\alpha</code>, <code class="reqn">\beta</code>, power, and
<code class="reqn">p</code>-values or the confidence value are displayed on the graph.  If <code>FALSE</code>, these values
are not displayed.
</p>
</td></tr>
<tr><td><code id="NormalAndTplot_+3A_ntcolors">ntcolors</code></td>
<td>

<p>Vector of colors used in the graph.  The default value is
<code>"original"</code> and two named alternatives are <code>"stoplight"</code> and
<code>"BW"</code>.
The sets of colors associated with these three named sets are shown in a <code>dontrun</code>
section of the examples.
The user can enter any other color scheme by specifying a vector of ten
named colors.  The names are:
<code>col.alpha, col.notalpha, col.beta, col.power, col.pvalue,
  col.pvaluetranslucent, col.critical, col.border, col.text, col.conf</code>.
</p>
</td></tr>
<tr><td><code id="NormalAndTplot_+3A_digits.axis">digits.axis</code>, <code id="NormalAndTplot_+3A_digits.float">digits.float</code>, <code id="NormalAndTplot_+3A_digits">digits</code></td>
<td>

<p><code>digits.axis</code> is the number of significant digits for the top
axis.  <code>digits.float</code> is the number of significant digits for
the floating probability values on the graph.  <code>digits</code> is a
convenience argument to set both <code>digits.axis</code> and
<code>digits.float</code> at the same time.  These number is passed to the
<code><a href="base.html#topic+format">format</a></code> function.
</p>
</td></tr>
<tr><td><code id="NormalAndTplot_+3A_distribution.name">distribution.name</code></td>
<td>

<p>Name of distribution.
</p>
</td></tr>
<tr><td><code id="NormalAndTplot_+3A_type">type</code></td>
<td>

<p>&quot;hypothesis&quot; for a Hypothesis Test graph, or &quot;confidence&quot; for a
Confidence Interval graph.
</p>
</td></tr>
<tr><td><code id="NormalAndTplot_+3A_zaxis">zaxis</code>, <code id="NormalAndTplot_+3A_z1axis">z1axis</code></td>
<td>

<p>Logical or list.  Should the <code class="reqn">z</code>-axis centered on <code class="reqn">\mu_0</code>, or the
<code class="reqn">z_1</code>-axis centered on <code class="reqn">\mu_1</code>, be displayed?  The list
version of the argument must have two components <code>at</code> and <code>labels</code> as
specified in <code><a href="lattice.html#topic+panel.axis">panel.axis</a></code>.
</p>
</td></tr>
<tr><td><code id="NormalAndTplot_+3A_cex.z">cex.z</code>, <code id="NormalAndTplot_+3A_cex.xbar">cex.xbar</code>, <code id="NormalAndTplot_+3A_cex.y">cex.y</code>, <code id="NormalAndTplot_+3A_cex.prob">cex.prob</code>, <code id="NormalAndTplot_+3A_cex.top.axis">cex.top.axis</code>, <code id="NormalAndTplot_+3A_cex.left.axis">cex.left.axis</code>, <code id="NormalAndTplot_+3A_cex.pb.axis">cex.pb.axis</code>, <code id="NormalAndTplot_+3A_cex.xlab">cex.xlab</code>, <code id="NormalAndTplot_+3A_cex.ylab">cex.ylab</code>, <code id="NormalAndTplot_+3A_cex.strip">cex.strip</code>, <code id="NormalAndTplot_+3A_cex.main">cex.main</code></td>
<td>

<p><code>cex.z</code> is the <code>cex</code> value for the <code class="reqn">z</code> and <code class="reqn">z_1</code>
axes on the plot.  <code>cex.prob</code> is the <code>cex</code> value for the
floating probabilities on the graph. <code>cex.top.axis</code> is the <code>cex</code> value
for the top axis values.  <code>cex.main</code> is the <code>cex</code> value for
the main title.  <code>cex.xbar</code> and <code>cex.y</code> are the <code>cex</code>
values for the horizontal and vertical axes of the plot.
<code>cex.left.axis</code> and <code>cex.pb.axis</code> are the <code>cex</code> values
for the power or beta (Type II error) values and the <code class="reqn">\mu_1</code> value
in the power and beta plots.  <code>cex.xlab</code>, <code>cex.ylab</code>, and
<code>cex.strip</code> are the <code>cex</code> values for <code>xlab</code>,
<code>ylab</code>, and <code>strip</code> labels.
</p>
</td></tr>
<tr><td><code id="NormalAndTplot_+3A_key.axis.padding">key.axis.padding</code></td>
<td>
<p>tuning constant to create additional room above the
graph for a larger <code>cex.main</code> to fit.</p>
</td></tr>
<tr><td><code id="NormalAndTplot_+3A_prob.labels">prob.labels</code></td>
<td>
<p>logical. If <code>TRUE</code> label the floating
probability values with their name, such as <code class="reqn">\alpha</code>.  If
<code>FALSE</code>,
then don't label them.  The default is <code>TRUE</code> for
<code>type="hypothesis"</code>
and <code>FALSE</code> for <code>type="confidence"</code>.
</p>
</td></tr>
<tr><td><code id="NormalAndTplot_+3A_xhalf.multiplier">xhalf.multiplier</code>, <code id="NormalAndTplot_+3A_yhalf.multiplier">yhalf.multiplier</code></td>
<td>

<p>Numerical tuning constants to control the width and height of the floating
probability values.  Empirically, we need a smaller value for the
<span class="pkg">shiny</span>
app then we need for direct writing onto a graphic device.
</p>
</td></tr>
<tr><td><code id="NormalAndTplot_+3A_ntmethod">NTmethod</code></td>
<td>
<p>Character string used when <code>shiny=TRUE</code>.  It is
normally calculated by the methods.  <code>NTmethod</code> tells
<code>shiny</code> how to use or ignore the <code>df</code> and <code>n</code>
sliders.
</p>
<p><code>"htest"</code> objects by default are interpreted
as a single observation (<code>n=1</code>) of a <code class="reqn">t</code>-statistic with
<code>df</code> degrees of freedom.  The slider will let the user change
the <code>df</code>, but not the <code>n</code>.
</p>
<p><code>"power.htest"</code> objects are interpreted as a set of <code class="reqn">n</code>
obervations per group and <code>df</code> is calculated as <code class="reqn">(n-1)</code> for
single-sample tests and as <code class="reqn">2(n-1)</code> for two-sample tests.
The slider will let the user change <code>n</code> and will calculate the
revised <code>df</code>.
</p>
<p>For the normal approximation to the binomial
(<code>distribution.name="binomial"</code>),
only <code>n</code> is meaningful.  The <code>df</code> is always ignored.
</p>
<p>For the default situation of <code>t</code>, determined by the initially
specified sample size <code class="reqn">n&gt;1</code>, the degrees of freedom is
calculated as <code class="reqn">(n-1)</code> for single-sample tests and as
<code class="reqn">2(n-1)</code> for two-sample tests.  The default <code>z</code>, is
initially specified by a sample size <code class="reqn">n=1</code>.
</p>
<p>In all cases except the <code>"binomial"</code>, the user can change the
interpretation of the <code>n</code> and <code>df</code> sliders.  The
interpretation when both <code>n</code> and <code>df</code> are under user
control is not always obvious.
</p>
</td></tr>
<tr><td><code id="NormalAndTplot_+3A_power">power</code>, <code id="NormalAndTplot_+3A_beta">beta</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, then display that graph,
else don't display it.  Passed forward to
<code><a href="#topic+powerplot">powerplot</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The graphs produced by this single function cover most of the first semester
introductory Statistics course.  The <code>htest</code> method plots the
results of the <code>stats::t.test</code> function.
</p>
<p><code>NormalAndTplot</code> is built on <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
Most of the arguments detailed in <code>xyplot</code> documentation work to
control the appearance of the plot.
</p>


<h3>Value</h3>

<p><code>"trellis"</code> object.
</p>


<h3>Note</h3>

<p>This function is built on <span class="pkg">lattice</span> and <span class="pkg">latticeExtra</span>.
It supersedes the similar function
<code>normal.and.t.dist</code> built on base graphics that is used in many
displays in the book by Erich Neuwirth and me: <em>R through Excel</em>, Springer
(2009).
<a href="https://link.springer.com/book/10.1007/978-1-4419-0052-4">https://link.springer.com/book/10.1007/978-1-4419-0052-4</a>.  Many details,
particularly the
alternate color scheme and the concept of floating probability labels,
grew out of discussions that Erich and I have had since the book was
published.
The method for <code>"htest"</code> objects incorporates ideas that Jay Kerns and I developed at the 2011 UseR! conference.
This version incorporates some ideas suggested by Moritz Heene.
</p>


<h3>Author(s)</h3>

<p>Richard M. Heiberger (rmh@temple.edu)</p>


<h3>See Also</h3>

<p><code><a href="#topic+NTplot">NTplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>   NTplot(mean0=0, mean1=2,  xbar=1.8,  xlim=c(-3, 5))
   NTplot(mean0=0, mean1=2,  xbar=1.8,  xlim=c(-3, 5), distribution.name="t", df=4)
   NTplot(mean0=100, sd=12, mean1=113,  xbar=105,  xlim=c(92, 120), n=20)
   NTplot(mean0=100, sd=12, mean1=113,  xbar=105,  xlim=c(92, 120), n=20,
          zaxis=TRUE, z1axis=TRUE)
   NTplot(mean0=100, sd=12,  xbar=105,  xlim=c(92, 108), n=20, ntcolors="stoplight")
   NTplot(xbar=95, sd=10, xlim=c(65, 125), type="confidence",
          alpha.left=.025, alpha.right=.025)


x &lt;- rnorm(12, mean=.78)
x.t &lt;- t.test(x)
NTplot(x.t)
NTplot(x.t, type="confidence")
x.tg &lt;- t.test(x, alternative="greater")
NTplot(x.tg)

y &lt;- rnorm(12, mean=-.05)
xy.t &lt;- t.test(x, y)
NTplot(xy.t)
NTplot(xy.t, type="confidence")

## Not run: 
  if (interactive())
    NTplot(shiny=TRUE)  ## with any other arguments for initialization of the shiny app.

## End(Not run)

## Not run: 
   ##  The partially transparent colors are:
   black127="#0000007F" ## HH:::ColorWithAlpha("black")
   green127="#00FF007F" ## HH:::ColorWithAlpha("green")
   blue127 ="#0000FF7F" ## HH:::ColorWithAlpha("blue")


## this is the default set of colors that are assigned when
## ntcolors="original" or when ntcolors is not specified
c(col.alpha = "blue",
  col.notalpha = "lightblue",
  col.beta = "red",
  col.power = "pink",
  col.pvalue = "green",
  col.pvaluetranslucent = green127,
  col.critical = "gray50",
  col.border = black127,
  col.text = "black",
  col.conf = "lightgreen")

  NTplot(                 )
  NTplot(mean1 = 2,       )
  NTplot(           xbar=1)
  NTplot(mean1 = 2, xbar=1)
  NTplot(type="confidence")


## this is the set of colors that are assigned when ntcolors="stoplight"
c(col.alpha = "red",
  col.notalpha = "honeydew2",
  col.beta = "orange",
  col.power = "pink",
  col.pvalue = "blue",
  col.pvaluetranslucent = blue127,
  col.critical = "gray50",
  col.border = black127,
  col.text = "black",
  col.conf = "lightgreen")

  NTplot(                   ntcolors="stoplight")
  NTplot(mean1 = 2,         ntcolors="stoplight")
  NTplot(           xbar=1, ntcolors="stoplight")
  NTplot(mean1 = 2, xbar=1, ntcolors="stoplight")
  NTplot(type="confidence", ntcolors="stoplight")

## this is the set of colors that are assigned when ntcolors="BW"
c(col.alpha             = "gray35",
  col.notalpha          = "gray85",
  col.beta              = "gray15",
  col.power             = "gray40",
  col.pvalue            = "gray50",
  col.pvaluetranslucent = HH:::ColorWithAlpha("gray65"),
  col.critical          = "gray15",
  col.border            = "gray75",
  col.text              = "black",
  col.conf              = "gray45")

  NTplot(                   ntcolors="BW")
  NTplot(mean1 = 2,         ntcolors="BW")
  NTplot(           xbar=1, ntcolors="BW")
  NTplot(mean1 = 2, xbar=1, ntcolors="BW")
  NTplot(type="confidence", ntcolors="BW")


## End(Not run)

## Not run: 
## mean1 and xbar
  NTplot(mean0=0, mean1=2,  xbar=1.8,  xlim=c(-3, 5))
  NTplot(mean0=0, mean1=-2, xbar=-1.8, xlim=c(-5, 3),
         alpha.left=.05,  alpha.right=0)
  NTplot(mean0=0, mean1=2,  xbar=2.1,  xlim=c(-3, 5),
         alpha.left=.025, alpha.right=.025)
  NTplot(mean0=0, mean1=-2, xbar=-2.1, xlim=c(-5, 3),
         alpha.left=.025, alpha.right=.025)

## mean1
  NTplot(mean0=0, mean1=2,  xbar=NA, xlim=c(-3, 5))
  NTplot(mean0=0, mean1=-2, xbar=NA, xlim=c(-5, 3),
         alpha.left=.05,  alpha.right=0)
  NTplot(mean0=0, mean1=2,  xbar=NA, xlim=c(-3, 5),
         alpha.left=.025, alpha.right=.025)
  NTplot(mean0=0, mean1=-2, xbar=NA, xlim=c(-5, 3),
         alpha.left=.025, alpha.right=.025)

## xbar
  NTplot(mean0=0, mean1=NA, xbar=1.8,  xlim=c(-3, 5))
  NTplot(mean0=0, mean1=NA, xbar=-1.8, xlim=c(-5, 3),
         alpha.left=.05,  alpha.right=0)
  NTplot(mean0=0, mean1=NA, xbar=2.1,  xlim=c(-3, 5),
         alpha.left=.025, alpha.right=.025)
  NTplot(mean0=0, mean1=NA, xbar=-2.1, xlim=c(-5, 3),
         alpha.left=.025, alpha.right=.025)

## t distribution
## mean1 and xbar
  NTplot(mean0=0, mean1=2,  xbar=1.8,  xlim=c(-3, 5),
         distribution.name="t", df=4)
  NTplot(mean0=0, mean1=-2, xbar=-1.8, xlim=c(-5, 3),
         alpha.left=.05,  alpha.right=0, distribution.name="t", df=4)
  NTplot(mean0=0, mean1=2,  xbar=2.1,  xlim=c(-3, 5),
         alpha.left=.025, alpha.right=.025, distribution.name="t", df=4)
  NTplot(mean0=0, mean1=-2, xbar=-2.1, xlim=c(-5, 3),
         alpha.left=.025, alpha.right=.025, distribution.name="t", df=4)

## mean1
  NTplot(mean0=0, mean1=2,  xbar=NA, xlim=c(-3, 5),
         distribution.name="t", df=4)
  NTplot(mean0=0, mean1=-2, xbar=NA, xlim=c(-5, 3),
         alpha.left=.05,  alpha.right=0, distribution.name="t", df=4)
  NTplot(mean0=0, mean1=2,  xbar=NA, xlim=c(-3, 5),
         alpha.left=.025, alpha.right=.025, distribution.name="t", df=4)
  NTplot(mean0=0, mean1=-2, xbar=NA, xlim=c(-5, 3),
         alpha.left=.025, alpha.right=.025, distribution.name="t", df=4)

## xbar
  NTplot(mean0=0, mean1=NA, xbar=1.8,  xlim=c(-3, 5),
         distribution.name="t", df=4)
  NTplot(mean0=0, mean1=NA, xbar=-1.8, xlim=c(-5, 3),
         alpha.left=.05,  alpha.right=0, distribution.name="t", df=4)
  NTplot(mean0=0, mean1=NA, xbar=2.1,  xlim=c(-3, 5),
         alpha.left=.025, alpha.right=.025, distribution.name="t", df=4)
  NTplot(mean0=0, mean1=NA, xbar=-2.1, xlim=c(-5, 3),
         alpha.left=.025, alpha.right=.025, distribution.name="t", df=4)

## confidence intervals

  NTplot(mean0=0, xlim=c(-3, 4), type="confidence")
  NTplot(xbar=01, xlim=c(-3, 4), type="confidence")
  NTplot(mean0=0, xlim=c(-4, 3), type="confidence",
         alpha.left=.05,  alpha.right=0)
  NTplot(mean0=0, xlim=c(-3, 3), type="confidence",
         alpha.left=.025, alpha.right=.025)
  NTplot(mean0=95, sd=10, xlim=c(65, 125), type="confidence",
         alpha.left=.025, alpha.right=.025)
  NTplot(mean0=95, sd=10, xlim=c(65, 125), type="confidence",
         alpha.left=.025, alpha.right=.025,
         distribution="t", df=10)


## End(Not run)
</code></pre>

<hr>
<h2 id='NormalAndTPower'>
Construct a power graph based on the NTplot.
</h2><span id='topic+NormalAndTPower'></span><span id='topic+powerplot'></span><span id='topic+powerplot.NormalAndTplot'></span><span id='topic+power+20curve'></span><span id='topic+beta+20curve'></span><span id='topic+operating+20characteristic+20curve'></span>

<h3>Description</h3>

<p>Construct a power graph based on the <code>NTplot</code>.  The exported function
<code>powerplot</code> calls <code>NormalAndTPower</code> to construct a power curve or beta curve (operating
characteristic curve) (or both) from its argument and catenates it to the original
graph.  The unexported function <code>NormalAndTPower</code> does the
construction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerplot(nt, ...)

## S3 method for class 'NormalAndTplot'
powerplot(nt, power=TRUE, beta=FALSE, ...,
                         hh=if (power &amp;&amp; beta) c(6,2,2) else c(6,2))

NormalAndTPower(nt,
                which=c("power","beta"),
                digits=4,
                digits.top.axis=digits, digits.left=digits,
                col.power=attr(nt, "color")["col.power"],
                col.beta=attr(nt, "color")["col.beta"],
                cex.pb.axis=1, cex.left.axis=1, cex.xbar=1,
                lwd.reference=4, lwd.line=2,
                main=which, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NormalAndTPower_+3A_nt">nt</code></td>
<td>
<p>For the generic <code>powerplot</code>, an object.
For the <code>NormalAndTplot</code> method, a <code>"NormalAndTplot"</code> object from <code><a href="#topic+NTplot">NTplot</a></code>.
</p>
</td></tr>
<tr><td><code id="NormalAndTPower_+3A_power">power</code>, <code id="NormalAndTPower_+3A_beta">beta</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, then display that graph,
else don't display it.  Used by <code>powerplot</code>.
</p>
</td></tr>
<tr><td><code id="NormalAndTPower_+3A_which">which</code></td>
<td>
<p>Which graph is to be displayed? <code>"power"</code> for the
power curve, or <code>"beta"</code> for the operating characteristic curve.
Used by <code>NormalAndTPower</code>.
</p>
</td></tr>
<tr><td><code id="NormalAndTPower_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
<tr><td><code id="NormalAndTPower_+3A_hh">hh</code></td>
<td>
<p>The <code>h</code> argument for <code><a href="latticeExtra.html#topic+resizePanels">resizePanels</a></code>.</p>
</td></tr>
<tr><td><code id="NormalAndTPower_+3A_digits.top.axis">digits.top.axis</code>, <code id="NormalAndTPower_+3A_digits.left">digits.left</code>, <code id="NormalAndTPower_+3A_digits">digits</code>, <code id="NormalAndTPower_+3A_cex.pb.axis">cex.pb.axis</code>, <code id="NormalAndTPower_+3A_cex.left.axis">cex.left.axis</code>, <code id="NormalAndTPower_+3A_cex.xbar">cex.xbar</code></td>
<td>

<p><code>digits.top.axis</code> is the number of significant digits for the top
axis.  <code>digits.left</code> is the number of significant digits for
the observed power or beta on the left axis.  <code>digits</code> is a
convenience argument to set both <code>digits.axis</code> and
<code>digits.left</code> at the same time.  These number is passed to the
<code><a href="base.html#topic+format">format</a></code> function. <code>cex.top.axis</code> is the <code>cex</code> value
for the top axis values.  <code>cex.left.axis</code> is the <code>cex</code> value for
the observed power or beta on the left axis.   <code>cex.xbar</code> is
the <code>cex</code> value for the horizontal axis.
</p>
</td></tr>
<tr><td><code id="NormalAndTPower_+3A_col.power">col.power</code>, <code id="NormalAndTPower_+3A_col.beta">col.beta</code></td>
<td>
<p>Colors used for the crosshairs on the power and beta
panels.
The default values are the colors used for the power and beta regions of the
<code>NTplot</code> panel.
</p>
</td></tr>
<tr><td><code id="NormalAndTPower_+3A_lwd.reference">lwd.reference</code>, <code id="NormalAndTPower_+3A_lwd.line">lwd.line</code></td>
<td>
<p><code>lwd</code> values for the power or beta
panel.
<code>lwd.line</code> is used for the power curve or beta curve.
<code>lwd.reference</code>
is used for the crosshairs.
</p>
</td></tr>
<tr><td><code id="NormalAndTPower_+3A_main">main</code></td>
<td>
<p>Main title for graph.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"trellis"</code> object.
</p>


<h3>Author(s)</h3>

<p>Richard M. Heiberger (rmh@temple.edu)</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nt &lt;- NTplot(mean0=2, mean1=4, sd=3, n=20, xlim=c(-.1, 6.1), xbar=3.5)
powerplot(nt)

## Not run: 
tt &lt;- NTplot(mean0=2, mean1=4, sd=3, n=20, xlim=c(-.1, 6.1), xbar=3.5, df=4, distribution.name="t")
powerplot(tt)

ntc &lt;- NTplot(xbar=2, sd=3, n=20, xlim=c(-.1, 4.1), type="confidence",
              alpha.left=.025, alpha.right=.025)
ntc
try(powerplot(ntc))

## End(Not run)
</code></pre>

<hr>
<h2 id='normalApproxBinomial'>
Plots to illustrate Normal Approximation to the
Binomial&mdash;hypothesis tests or confidence intervals.
</h2><span id='topic+normalApproxBinomial'></span>

<h3>Description</h3>

<p>Plots to illustrate Normal Approximation to the
Binomial&mdash;hypothesis tests or confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalApproxBinomial(p0= if (number.vars==1) .5 else 0,
                     p1=NA, p2=NA,
                     p.hat=if (number.vars==1) .75 else 0,
                     n=1,
                     xlim=if (number.vars==1) c(0,1) else c(-1,1),
                     ylim=c(0, 5),
                     type=c("hypothesis","confidence"),
                     alpha.left=if (type=="hypothesis") 0 else .025,
                     alpha.right=if (type=="hypothesis") .05 else .025,
                     xlab=if (number.vars==1)
                            "w = p = population proportion"
                          else
                            "w = p[1] - p[2] :: population proportions", ...,
                     number.vars=if (!is.na(p1) &amp;&amp; !is.na(p2)) 2 else 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalApproxBinomial_+3A_p0">p0</code></td>
<td>

<p>Null hypothesis value of <code class="reqn">p</code>.
</p>
</td></tr>
<tr><td><code id="normalApproxBinomial_+3A_p1">p1</code></td>
<td>

<p>Alternate hypothesis value of <code class="reqn">p</code> for one-sample cases.
Second sample value of <code class="reqn">p</code> for two-sample cases.
</p>
</td></tr>
<tr><td><code id="normalApproxBinomial_+3A_p2">p2</code></td>
<td>

<p>Second sample value of <code class="reqn">p</code>.
</p>
</td></tr>
<tr><td><code id="normalApproxBinomial_+3A_p.hat">p.hat</code></td>
<td>

<p>Observed  value of <code class="reqn">p</code>.
</p>
</td></tr>
<tr><td><code id="normalApproxBinomial_+3A_n">n</code></td>
<td>

<p>Number of observations (for example, number of coins tossed).
</p>
</td></tr>
<tr><td><code id="normalApproxBinomial_+3A_xlim">xlim</code>, <code id="normalApproxBinomial_+3A_ylim">ylim</code>, <code id="normalApproxBinomial_+3A_xlab">xlab</code></td>
<td>

<p>Standard <code><a href="lattice.html#topic+xyplot">xyplot</a></code> arguments...
</p>
</td></tr>
<tr><td><code id="normalApproxBinomial_+3A_type">type</code></td>
<td>

<p>&quot;hypothesis&quot; for a Hypothesis Test graph, or &quot;confidence&quot; for a
Confidence Interval graph.
</p>
</td></tr>
<tr><td><code id="normalApproxBinomial_+3A_...">...</code>, <code id="normalApproxBinomial_+3A_alpha.left">alpha.left</code>, <code id="normalApproxBinomial_+3A_alpha.right">alpha.right</code></td>
<td>

<p>Additional arguments forwarded to <code><a href="#topic+NTplot">NTplot</a></code>.
</p>
</td></tr>
<tr><td><code id="normalApproxBinomial_+3A_number.vars">number.vars</code></td>
<td>

<p>Number of variables. 1 for a one-sample test, 2 for two-sample tests
and paired tests.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper function for the plots in <code><a href="#topic+NTplot">NTplot</a></code>.
</p>


<h3>Value</h3>

<p><code>"trellis"</code> object.
</p>


<h3>Author(s)</h3>

<p>Richard M. Heiberger (rmh@temple.edu)</p>


<h3>Examples</h3>

<pre><code class='language-R'>NTplot(distribution.name="binomial", n=20, ylim=c(0,4.2), p1=.8)
NTplot(distribution.name="binomial", n=20, type="confidence", ylim=c(0,4.2))
## Not run: 
NTplot(distribution.name="binomial", n=20, zaxis=TRUE, z1axis=TRUE,
       p1=.8678, ylim=c(0, 5.2))
NTplot(p0=.4, p.hat=.65, p1=.7, distribution.name="binomial", n=15)
NTplot(p.hat=.65, distribution.name="binomial", n=15, type="confidence")

## End(Not run)
## Not run:  ## these are interactive and won't work in R CMD check
  if (interactive())
    NTplot(distribution.name="binomial", n=20, ylim=c(0,4.2), p1=.8, shiny=TRUE)
  if (interactive())
    NTplot(p0=.4, p.hat=.65, p1=.7, distribution.name="binomial", n=15, shiny=TRUE)
  if (interactive())
    NTplot(p.hat=.65, distribution.name="binomial", n=15, type="confidence", shiny=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='npar.arma'>Count the number of parameters in an ARIMA model specification.</h2><span id='topic+npar.arma'></span><span id='topic+npar.rarma'></span><span id='topic+npar.sarma'></span>

<h3>Description</h3>

<p>Count the number of parameters in an ARIMA model specification.
When <code>arima==FALSE</code>, just the AR and MA parameters are counted.
When <code>arima==TRUE</code>, then the number of difference parameters are
also included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npar.arma(x, arima=FALSE)
npar.sarma(model, arima=FALSE)
npar.rarma(arma, arima=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npar.arma_+3A_x">x</code></td>
<td>
<p>An <code>"arima"</code> object in S-Plus or a <code>"Arima"</code> object
in R.</p>
</td></tr>
<tr><td><code id="npar.arma_+3A_model">model</code></td>
<td>
<p>A <code>model</code> specification in the S-Plus style.</p>
</td></tr>
<tr><td><code id="npar.arma_+3A_arma">arma</code></td>
<td>
<p>A <code>arma</code> specification in the R style</p>
</td></tr>
<tr><td><code id="npar.arma_+3A_arima">arima</code></td>
<td>
<p>Logical.  <code>TRUE</code> is number of differencings is to be
counted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar number giving the count.
</p>


<h3>Author(s)</h3>

<p>Richard M. Heiberger (rmh@temple.edu)</p>


<h3>Examples</h3>

<pre><code class='language-R'>co2.arima &lt;-
  if.R(s=
       arima.mle(co2, list(list(order=c(0,1,1)),
                           list(order=c(0,1,1), period=12)))
       ,r=
       arima(co2, 
             order=c(0,1,1),
             seasonal=list(order=c(0,1,1), period=12))
       )

npar.arma(co2.arima)

npar.arma(co2.arima, arima=TRUE)

npar.sarma(list(list(order=c(0,1,1)),
                list(order=c(0,1,1), period=12)))

npar.sarma(list(list(order=c(0,1,1)),
                list(order=c(0,1,1), period=12)),
           arima=TRUE)

if.R(s={},
     r=npar.rarma(co2.arima$arma)
)
if.R(s={},
     r=npar.rarma(co2.arima$arma,
           arima=TRUE)
)

</code></pre>

<hr>
<h2 id='NTplot'>Specify plots to illustrate Normal and t Hypothesis Tests or
Confidence Intervals, including normal approximation to the binomial.</h2><span id='topic+NTplot'></span><span id='topic+NTplot.default'></span><span id='topic+NTplot.htest'></span><span id='topic+NTplot.power.htest'></span><span id='topic+NTplot.NormalAndTplot'></span>

<h3>Description</h3>

<p>Specify plots to illustrate Normal and t Hypothesis Tests
or Confidence Intervals, including normal approximation to the binomial.</p>


<h3>Usage</h3>

<pre><code class='language-R'>NTplot(mean0, ...)
## Default S3 method:
NTplot(mean0=0, ..., shiny=FALSE,
        distribution.name = c("normal","z","t","binomial"))
## S3 method for class 'htest'
NTplot(mean0, ..., shiny=FALSE, NTmethod="htest")
## S3 method for class 'power.htest'
NTplot(mean0, ..., shiny=FALSE, xbar=NA, ## these input values are used
        mean1, n, df, sd, distribution.name, sub, ## these input values ignored
        alpha.left, alpha.right, number.vars) ## these input values ignored
        ## NTplot(NTplot(htest.object), n=20) ## allows override of arguments
## S3 method for class 'NormalAndTplot'
NTplot(mean0, ..., shiny=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NTplot_+3A_mean0">mean0</code></td>
<td>

<p>For the default method, <code>mean0</code> is either missing or a numeric
argument for the mean under the null hypothesis.
For the <code>htest</code> method, <code>mean0</code> is an <code>htest</code> object
from the <code><a href="stats.html#topic+t.test">t.test</a></code> or the
<code>z.test</code> function.
For the <code>NormalAndTplot</code> method
<code>mean0</code> is a <code>"NormalAndTplot"</code> object from a previous use
of the <code>NTplot</code> function.
For the <code>power.htest</code> method, <code>mean0</code> is a <code>power.htest</code>
object from the <code><a href="stats.html#topic+power.t.test">power.t.test</a></code> function.
</p>
</td></tr>
<tr><td><code id="NTplot_+3A_xbar">xbar</code></td>
<td>
<p>See <code><a href="#topic+NormalAndTplot">NormalAndTplot</a></code>.</p>
</td></tr>
<tr><td><code id="NTplot_+3A_...">...</code></td>
<td>
<p>Other arguments, selected from the options for the
default method <code><a href="#topic+NormalAndTplot">NormalAndTplot</a></code>.  Three named color schemes
are available: the default <code>ntcolors="original"</code>,
<code>ntcolors="stoplight"</code>, and <code>ntcolors="BW"</code>.  Their
definitions, along with information on specifying other color schemes, are
shown in <code><a href="#topic+NormalAndTplot">NormalAndTplot</a></code>.
</p>
</td></tr>
<tr><td><code id="NTplot_+3A_shiny">shiny</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, a <code><a href="shiny.html#topic+shiny-package">shiny</a></code>
app is started to provide an interactive graphics device in a
web-browser.  If
<code>FALSE</code>, a plot is drawn on the current graphics device.
For short browser windows (<code>height &lt; 800</code> pixels), you may
adjust the pixel height of the plot in the last user input field on
the <code>Fonts</code> tab.
</p>
</td></tr>
<tr><td><code id="NTplot_+3A_htest">htest</code></td>
<td>
<p>logical. <code>TRUE</code> for <code>"htest"</code> objects.</p>
</td></tr>
<tr><td><code id="NTplot_+3A_mean1">mean1</code>, <code id="NTplot_+3A_n">n</code>, <code id="NTplot_+3A_df">df</code>, <code id="NTplot_+3A_sd">sd</code>, <code id="NTplot_+3A_sub">sub</code>, <code id="NTplot_+3A_alpha.left">alpha.left</code>, <code id="NTplot_+3A_alpha.right">alpha.right</code>, <code id="NTplot_+3A_number.vars">number.vars</code></td>
<td>
<p>These variables are ignored here.  They
are captured so they won't interfere with similarly named variables
that are generated in the <code>power.htest</code> method.</p>
</td></tr>
<tr><td><code id="NTplot_+3A_distribution.name">distribution.name</code></td>
<td>
<p>Ignored by <code>htest</code> and
<code>power.htest</code> methods.
Otherwise passed on to the next method.</p>
</td></tr>
<tr><td><code id="NTplot_+3A_ntmethod">NTmethod</code></td>
<td>
<p>Character string used when <code>shiny=TRUE</code>.  It is
normally calculated by the methods.  <code>NTmethod</code> tells
<code>shiny</code> how to use or ignore the <code>df</code> and <code>n</code>
sliders.  See the extended discussion in <code><a href="#topic+NormalAndTplot">NormalAndTplot</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The graphs produced by this single function cover most of the first semester
introductory Statistics course.
All options of the <code>t.test</code>, <code>power.t.test</code>, and <code>z.test</code>
are accepted and displayed.
</p>
<p><code>NTplot</code> is built on <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
Most of the arguments detailed in <code>xyplot</code> documentation work to
control the appearance of the plot.
</p>
<p>The shiny app (called when the argument <code>shiny=TRUE</code>)
provides animated sliders for the means, standard
deviation, xlimits, significance levels, df, and n.  The df and n are
rounded to integers for the sliders (relevant for <code>htest</code> and
<code>power.htest</code> objects). Checkboxes and Radio buttons are available
for
various display options
</p>
<p>When you have a graph on the shiny window that you wish to keep, click
on the &quot;Display Options&quot; tab, and then on the &quot;Display Call&quot; radio
button.  The main shiny window will show an R command which will
reproduce the current plot.  Pick it up with the mouse and drop it into
an R console window.
</p>
<p>To get out of the shiny window and return to an interactive R console,
move the cursor back to the console window and interrupt the shiny call, usually
by entering <code>Ctrl-C</code> or <code>ESC</code>.
</p>


<h3>Value</h3>

<p><code>"trellis"</code> object. The object can be plotted or fed back into the
<code>NTplot</code> function with argument <code>shiny=TRUE</code> to allow
interactive graphical investigation of the hypothesis test or confidence
interval.
The attributes of the object\
<code>NTobj &lt;- NTplot()</code>\
<code>attr(NTobj, "scales")</code> and <code>attr(NTobj, "prob")</code> make the
data values and probability values accessible for further R
computations.
The <code>"call"</code> attribute
<code>cat(attr(NT.object, "call"), "\n")</code>
displays a statement that can be copied back into R to reproduce the graph.
The <code>cat()</code> is needed to unescape embedded quotes.
The <code>"call.list"</code> attribute
<code>attr(NT.object, "call.list")</code>
is a list that can be used with <code>do.call</code> to reproduce the graph.
<code>do.call(NTplot, attr(NT.object, "call.list"))</code>.  This is usually
not needed by the user because the simpler statement
<code>NTplot(NT.object)</code>
does it for you.
</p>


<h3>Note</h3>

<p>This function is built on <span class="pkg">lattice</span> and <span class="pkg">latticeExtra</span>.
It supersedes the similar function
<code>normal.and.t.dist</code> built on base graphics that is used in many
displays in the book by Erich Neuwirth and me: <em>R through Excel</em>, Springer
(2009).
<a href="https://link.springer.com/book/10.1007/978-1-4419-0052-4">https://link.springer.com/book/10.1007/978-1-4419-0052-4</a>.  Many details,
particularly the
alternate color scheme and the concept of floating probability labels,
grew out of discussions that Erich and I have had since the book was
published.
It incorporates ideas that Jay Kerns and I developed at the 2011 UseR! conference.
This version incorporates some ideas suggested by Moritz Heene.
</p>


<h3>Author(s)</h3>

<p>Richard M. Heiberger (rmh@temple.edu)</p>


<h3>See Also</h3>

<p><code><a href="#topic+NormalAndTplot">NormalAndTplot</a></code>, <code><a href="#topic+print.NormalAndTplot">print.NormalAndTplot</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- rnorm(12)
x2 &lt;- rnorm(12, mean=.5)

NT.object &lt;- NTplot(mean0=0, mean1=1)
NT.object
attr(NT.object, "scales")
attr(NT.object, "prob")
cat(attr(NT.object, "call"), "\n") ## the cat() is needed to unescape embedded quotes.

NTplot(t.test(x1, x2))
NTplot(power.t.test(power = .90, delta = 1, alternative = "one.sided"))

## Not run: 
## 22 distinct calls are shown in
demo(NTplot, ask=FALSE)

## End(Not run)

## Not run:  ## these are interactive and do not work in static checking of the code
  if (interactive())
    NTplot(mean0=0, mean1=1, shiny=TRUE)
  if (interactive())
    NTplot(shiny=TRUE, px.height=475) ## default value is 575
  if (interactive())
    NTplot(t.test(x1, x2), shiny=TRUE, mean1=1)
  if (interactive())
    NTplot(power.t.test(power = .90, delta = 1, alternative = "one.sided"), shiny=TRUE)
  if (interactive())
    NTplot(NT.object, shiny=TRUE)

## run the shiny app
if (interactive())  shiny::runApp(system.file("shiny/NTplot", package="HH"))

## End(Not run)

</code></pre>

<hr>
<h2 id='objip'>loop through all attached directories looking for pattern,
possibly restricting to specified class or mode.</h2><span id='topic+objip'></span>

<h3>Description</h3>

<p>Loop <code>objects()</code> through all attached directories
(items in the <code>search()</code> list) looking for a regular expression pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objip(pattern, where = search(), all.names=FALSE, mode="any", class,
      ls.function=if (mode != "any" || !missing(class)) "ls.str" else "ls")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objip_+3A_pattern">pattern</code></td>
<td>
<p>Character string containing a regular expression
that is used to list only a subset of the objects.
Only names matching 'pattern' are returned.</p>
</td></tr>
<tr><td><code id="objip_+3A_where">where</code></td>
<td>
<p>an object defining a database in the search list.</p>
</td></tr>
<tr><td><code id="objip_+3A_all.names">all.names</code></td>
<td>
<p>In R, a logical that is passed to the <code>ls</code> function.
If 'TRUE', all object names are returned.
If 'FALSE', names which begin with a '.' are omitted.</p>
</td></tr>
<tr><td><code id="objip_+3A_mode">mode</code>, <code id="objip_+3A_class">class</code></td>
<td>
<p>See <code><a href="utils.html#topic+ls_str">ls.str</a></code> and
<code><a href="base.html#topic+mode">mode</a></code> for storage mode of an object.
See <code><a href="base.html#topic+class">class</a></code> for object classes.</p>
</td></tr>
<tr><td><code id="objip_+3A_ls.function">ls.function</code></td>
<td>
<p>Either <code>ls</code> or <code>ls.str</code>.  If either
<code>mode</code> or <code>class</code> is specified then the default is
<code>ls.str</code>.  If neither is specified then the default is
<code>ls</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 0 or more character vectors.  Each character vector has the
name of one of the items in the <code>search()</code> list.  Each character
vector contains the names of the objects in the specified environment
which match the <code>pattern</code>.  If there are no matching names in an
environment, then the corresponding character vector is removed from the
result.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+ls">ls</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>objip("qq")
objip("^qq")
objip("qq$")
## Not run: 
## R only
objip("rowSums", all.names=TRUE)

## list all objects in the second and third attached packages
search()
objip()[2:3]

## End(Not run)
</code></pre>

<hr>
<h2 id='OddsRatio'> Calculate or plot the odds ratio for a 2x2 table of counts.</h2><span id='topic+OddsRatio'></span><span id='topic+plotOddsRatio'></span><span id='topic+plotOddsRatio.base'></span>

<h3>Description</h3>

<p>Calculate or plot the odds ratio for a 2x2 table of counts.
The plot shows the confidence intervals on the probability of
row2 for fixed odds ratio
and specified probability for row1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OddsRatio(x, alpha = 0.05)

plotOddsRatio(x,
              ylab="prob(col1 | row1)",
              xlab="prob(col1 | row2)",
              alpha=c(.50, .05),
              col=trellis.par.get("superpose.line")$col,
              lwd=trellis.par.get("superpose.line")$lwd,
              lwd.reference=1,
              ...)

plotOddsRatio.base(x,
 ylab = "prob(col1 | row1)", xlab = "prob(col1 | row2)",
 alpha = c(0.05, 0.5),
 legend.x=1.05,
 oma=c(0,0,0,5), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OddsRatio_+3A_x">x</code></td>
<td>
<p>2 x 2 table of counts</p>
</td></tr>
<tr><td><code id="OddsRatio_+3A_alpha">alpha</code></td>
<td>
<p>Significance levels of test.
<code>OddsRatio</code> requires a single number in the range [0,1].
<code>plotOddsRatio</code> accepts more than one number on the range
[0,1] and draws confidence lines at each value.</p>
</td></tr>  <tr><td><code id="OddsRatio_+3A_xlab">xlab</code>, <code id="OddsRatio_+3A_ylab">ylab</code></td>
<td>
<p>x- and y-labels for the plot  Sensible defaults are
generated.</p>
</td></tr>
<tr><td><code id="OddsRatio_+3A_col">col</code>, <code id="OddsRatio_+3A_lwd">lwd</code></td>
<td>
<p>Colors and linewidths to be used in the graph.</p>
</td></tr>
<tr><td><code id="OddsRatio_+3A_lwd.reference">lwd.reference</code></td>
<td>
<p>linewidth for reference line.</p>
</td></tr>
<tr><td><code id="OddsRatio_+3A_...">...</code></td>
<td>
<p>other arguments, currently ignored.</p>
</td></tr>
<tr><td><code id="OddsRatio_+3A_legend.x">legend.x</code></td>
<td>
<p>x position of left-hand side of legend.</p>
</td></tr>
<tr><td><code id="OddsRatio_+3A_oma">oma</code></td>
<td>
<p>outer margin <code>par()$oma</code>, needed to make room for legend. </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plotOddsRatio</code> returns a lattice object.
</p>
<p>The older <code>plotOddsRatio.base</code> draws a plot with base graphics and invisibly returns the same
list as <code>OddsRatio</code> returns for the first value of <code>alpha</code>.
</p>
<p><code>OddsRatio</code> returns the list:
</p>
<table>
<tr><td><code>p1</code>, <code>p2</code></td>
<td>
<p>proportion of each row total observed in the first column.</p>
</td></tr>
<tr><td><code>omega1</code>, <code>omega2</code></td>
<td>
<p>odds for each row, p/(1-p)</p>
</td></tr>
<tr><td><code>psihat</code></td>
<td>
<p>odds ratio, omega2/omega1</p>
</td></tr>
<tr><td><code>s.ln.psihat</code></td>
<td>
<p>standard deviation of <code>ln(psihat)</code></p>
</td></tr>
<tr><td><code>ci.ln.psihat</code></td>
<td>
<p>confidence interval for <code>ln(psihat)</code>
using normal approximation</p>
</td></tr>
<tr><td><code>ci.psihat</code></td>
<td>
<p>confidence interval for <code>psihat</code> calculated
ase <code>p(ci.ln.psihat)</code></p>
</td></tr>
<tr><td><code>prob1</code></td>
<td>
<p><code>seq(0,1,.05)</code>, set of p1 values for plotting.</p>
</td></tr>
<tr><td><code>odds1</code></td>
<td>
<p><code>p1/(1-p1)</code></p>
</td></tr>
<tr><td><code>odds2</code></td>
<td>
<p>odds for the second row needed to retain <code>psihat</code> with
the specified <code>odds1</code>, calculated as <code>odds1*psihat</code>.</p>
</td></tr>
<tr><td><code>ci.odds2</code></td>
<td>
<p>confidence interval for <code>odds2</code></p>
</td></tr>
<tr><td><code>prob2</code></td>
<td>
<p><code>odds2 / (odds2+1)</code></p>
</td></tr>
<tr><td><code>ci.prob2</code></td>
<td>
<p><code>ci.odds2 / (ci.odds2+1)</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(glasses)

## draw the iso-odds ratio plot with 50% CI and 95% CI,
plotOddsRatio(glasses)

## return the 95% CI information
OddsRatio(glasses)

## draw the iso-odds ratio plot with 50% CI and 95% CI,
## invisibly return the 95% CI information
plotOddsRatio.base(glasses)
</code></pre>

<hr>
<h2 id='OneWayVarPlot'>
Displays a three-panel <code>bwplot</code> of the data by group, of the group
means, and of the entire dataset.  This is an approximate visualization
of the Mean Square lines from the ANOVA table for a one-way ANOVA model.
</h2><span id='topic+OneWayVarPlot'></span>

<h3>Description</h3>

<p>Displays a three-panel <code>bwplot</code> of the data by group, of the group
means, and of the entire dataset.  This is an approximate visualization
of the Mean Square lines from the ANOVA table for a one-way ANOVA model.
The groups are centered using medians by default.  Means, and anything
else, is an option.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OneWayVarPlot(x, data, ...,
              main="Variability of Groups, Centers of Groups, and all Data",
              centerFunctionName="median",
              center=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OneWayVarPlot_+3A_x">x</code></td>
<td>

<p>Model formula with one response variable and one factor.
</p>
</td></tr>
<tr><td><code id="OneWayVarPlot_+3A_data">data</code></td>
<td>

<p><code>data.frame</code>
</p>
</td></tr>
<tr><td><code id="OneWayVarPlot_+3A_...">...</code></td>
<td>

<p>Other arguments to be forwarded to the panel function.
</p>
</td></tr>
<tr><td><code id="OneWayVarPlot_+3A_main">main</code></td>
<td>

<p><code>main</code> title for graph.
</p>
</td></tr>
<tr><td><code id="OneWayVarPlot_+3A_centerfunctionname">centerFunctionName</code></td>
<td>
<p>Name of centering function, with
<code>"median"</code> as the default.  <code>"mean"</code> is another option.
</p>
</td></tr>
<tr><td><code id="OneWayVarPlot_+3A_center">center</code></td>
<td>

<p>Logical.  If <code>TRUE</code>, the default, the bwplots are centered by
subtracting their center (by default the median).  If <code>FALSE</code>
the bwplots are plotted at their observed values.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Three-panel <code>trellis</code> object.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(batch)
OneWayVarPlot(Calcium ~ Batch, data = batch)
</code></pre>

<hr>
<h2 id='orthog.complete'>Construct an orthogonal matrix which is an arbitrary completion
of the column space of the input set of columns.</h2><span id='topic+orthog.complete'></span><span id='topic+orthog.construct'></span>

<h3>Description</h3>

<p>Construct an orthogonal matrix which is an arbitrary completion
of the column space of the input set of columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthog.complete(x, normalize=TRUE, abs2.rows=1:nrow(x),
                Int=TRUE, drop.Int=Int)

orthog.construct(y, x, x.rows, normalize=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orthog.complete_+3A_x">x</code></td>
<td>
<p>For <code>orthog.complete</code>, an n-row matrix of one or more
columns.<br />
For <code>orthog.construct</code>, a set of contrasts for a factor.</p>
</td></tr>
<tr><td><code id="orthog.complete_+3A_y">y</code></td>
<td>
<p>matrix of coefficients specifying the linear combinations
estimated.  This will usually be the <code>lmat</code> from an S-Plus
<code>"multicomp"</code> object or the <code>linfct</code> component from an
R <code>"glht"</code> object.</p>
</td></tr>
<tr><td><code id="orthog.complete_+3A_normalize">normalize</code>, <code id="orthog.complete_+3A_abs2.rows">abs2.rows</code>, <code id="orthog.complete_+3A_x.rows">x.rows</code></td>
<td>
<p>The default normalizes the
sum of squares of the rows
in <code>abs2.rows</code> or <code>x.rows</code> to 1.  The optional value
<code>normalize="abs2"</code> scales the rows
in <code>abs2.rows</code> or <code>x.rows</code> to make the sum of all
positive value equal 1 and the sum of all negative values equal <code class="reqn">-1</code>.
Together, the sum of the absolute values of the specified rows in
each column is 2.
</p>
</td></tr>
<tr><td><code id="orthog.complete_+3A_int">Int</code></td>
<td>
<p>logical.  Default <code>TRUE</code> means make all columns
orthogonal to the constant column (Intercept in regression
terminology).  The alternative is to use only the columns in the
input matrix <code>x</code>.
</p>
</td></tr>
<tr><td><code id="orthog.complete_+3A_drop.int">drop.Int</code></td>
<td>
<p>logical.  The default is to drop the constant column
and to keep all columns when the constant is not automatically generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on <code>qr.Q</code>.  The input matrix <code>x</code> has
<code>n</code> rows and an arbitrary non-zero number of columns.  The result
is an <code>n</code> by <code>n</code> orthogonal matrix.  By default the first
column of the result is constant and is not returned.  The second
column of the result is orthogonal to the first result column.
Together the first two result columns span the space of the constant
column and the first input column.  The third result column is
orthogonal to the first two result columns and the the three result
columns together span the space of the constant column and the first
two inout columns.  Similarly for the remaining result columns.
Result columns beyond the number of input columns are constructed as
an arbitrary orthogonal completion.
</p>
<p>If the input columns are orthogonal to each other and to the constant
column, then the result columns are rescaled versions of the input
columns.
</p>
<p>Optionally (<code>drop.Int=FALSE</code>), the constant column can be returned.
</p>
<p>By default the columns are scaled to have sum of squares equal 1.  If
<code>normalize="abs2"</code>, they are scaled to make the sum of all
positive value equal 1 and the sum of all negative values equal <code class="reqn">-1</code>.
Together, the sum of the absolute values of each column is 2.
</p>
<p>If the input is a set of columns from a contrast matrix for a design
that has multiple terms, the <code>abs2.rows</code> argument is used to
specify which rows are to be included in the normalization.  These
will normally be rows associated with one of the main effects.
</p>


<h3>Value</h3>

<p>Matrix of orthogonal columns.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MMC">MMC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>zapsmall(
orthog.complete(cbind("4-12"=c(-1,-1, 0, 2),
                      "1-2" =c( 1,-1, 0, 0)))
)

zapsmall(
orthog.complete(cbind("4-12"=c(-1,-1, 0, 2),
                      "1-2" =c( 1,-1, 0, 0)),
                drop.Int=FALSE)
)

zapsmall(
orthog.complete(cbind("4-12"=c(-1,-1, 0, 2),
                      "1-2" =c( 1,-1, 0, 0)),
                normalize="abs2")
)


## used in MMC plots
tmp &lt;- data.frame(y=rnorm(12),
                  a=factor(c("u","u","u","u",
                             "v","v","v","v",
                             "w","w","w","w")))
tmp.aov &lt;- aov(y ~ a, data=tmp)
lmat &lt;- if.R(
  s=multicomp(tmp.aov, focus="a")$lmat,
  r={lmat.reduced &lt;- t(glht(tmp.aov, linfct=mcp(a="Tukey"))$linfct)
     rbind(lmat.reduced, AU=-apply(lmat.reduced[-1,], 2, sum))
    })
zapsmall(lmat)

lmat.complete &lt;- orthog.complete(lmat, abs2.rows=-1,
                                 normalize="abs2",
                                 drop.Int=FALSE)[,1:3]
zapsmall(lmat.complete)
if.R(r=zapsmall(lmat.complete[-4,]),
     s={})


</code></pre>

<hr>
<h2 id='panel.acf'>Panel functions for tsdiagplot.</h2><span id='topic+panel.acf'></span><span id='topic+panel.std.resid'></span><span id='topic+panel.gof'></span>

<h3>Description</h3>

<p>Panel functions for <code>tsdiagplot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.acf(..., n.used)
panel.std.resid(...)
panel.gof(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.acf_+3A_...">...</code></td>
<td>
<p>standard arguments to panel functions.</p>
</td></tr>
<tr><td><code id="panel.acf_+3A_n.used">n.used</code></td>
<td>
<p>number of lags.  THis number is needed to calculate the
confidence interval which is <code>2//sqrt(n.used)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard M. Heiberger (rmh@temple.edu)</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsdiagplot">tsdiagplot</a></code></p>

<hr>
<h2 id='panel.axis.right'>
Right-justify right-axis tick labels.
</h2><span id='topic+panel.axis.right'></span><span id='topic+axis.RightAdjustRight'></span>

<h3>Description</h3>

<p><code>panel.axis.right</code> is almost identical to
<code><a href="lattice.html#topic+panel.axis">panel.axis</a></code>.
<code>axis.RightAdjustRight</code> is almost identical to <code><a href="lattice.html#topic+axis.default">axis.default</a></code>.
The only difference is that these functions right-justify right-axis tick labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.axis.right(side = c("bottom", "left", "top", "right"),
                 at = pretty(scale.range),
                 labels = TRUE, draw.labels = TRUE,
                 check.overlap = FALSE, outside = FALSE, ticks = TRUE,
                 half = !outside,
                 which.half = switch(side, bottom = "lower",
                                     left = "upper", top = "upper",
                                     right = "lower"),
                 tck = as.numeric(ticks),
                 rot = if (is.logical(labels)) 0 else c(90, 0),
                 text.col = axis.text$col, text.alpha = axis.text$alpha,
                 text.cex = axis.text$cex, text.font = axis.text$font,
                 text.fontfamily = axis.text$fontfamily,
                 text.fontface = axis.text$fontface,
                 text.lineheight = axis.text$lineheight,
                 line.col = axis.line$col, line.lty = axis.line$lty,
                 line.lwd = axis.line$lwd, line.alpha = axis.line$alpha)

axis.RightAdjustRight(side = c("top", "bottom", "left", "right"),
                      scales, components, as.table,
                      labels = c("default", "yes", "no"),
                      ticks = c("default", "yes", "no"),
                      ...,
                      
                      prefix = lattice.lattice.getStatus("current.prefix"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.axis.right_+3A_side">side</code>, <code id="panel.axis.right_+3A_at">at</code>, <code id="panel.axis.right_+3A_labels">labels</code>, <code id="panel.axis.right_+3A_draw.labels">draw.labels</code>, <code id="panel.axis.right_+3A_check.overlap">check.overlap</code>, <code id="panel.axis.right_+3A_outside">outside</code>, <code id="panel.axis.right_+3A_ticks">ticks</code>, <code id="panel.axis.right_+3A_half">half</code>, <code id="panel.axis.right_+3A_which.half">which.half</code></td>
<td>

<p>See <code><a href="lattice.html#topic+panel.axis">panel.axis</a></code> and
<code><a href="lattice.html#topic+axis.default">axis.default</a></code>
</p>
</td></tr>
<tr><td><code id="panel.axis.right_+3A_tck">tck</code>, <code id="panel.axis.right_+3A_rot">rot</code>, <code id="panel.axis.right_+3A_text.col">text.col</code>, <code id="panel.axis.right_+3A_text.alpha">text.alpha</code>, <code id="panel.axis.right_+3A_text.cex">text.cex</code>, <code id="panel.axis.right_+3A_text.font">text.font</code>, <code id="panel.axis.right_+3A_text.fontfamily">text.fontfamily</code></td>
<td>

<p>See <code><a href="lattice.html#topic+panel.axis">panel.axis</a></code> and
<code><a href="lattice.html#topic+axis.default">axis.default</a></code>
</p>
</td></tr>
<tr><td><code id="panel.axis.right_+3A_text.fontface">text.fontface</code>, <code id="panel.axis.right_+3A_text.lineheight">text.lineheight</code>, <code id="panel.axis.right_+3A_line.col">line.col</code>, <code id="panel.axis.right_+3A_line.lty">line.lty</code>, <code id="panel.axis.right_+3A_line.lwd">line.lwd</code>, <code id="panel.axis.right_+3A_line.alpha">line.alpha</code></td>
<td>

<p>See <code><a href="lattice.html#topic+panel.axis">panel.axis</a></code> and
<code><a href="lattice.html#topic+axis.default">axis.default</a></code>
</p>
</td></tr>
<tr><td><code id="panel.axis.right_+3A_scales">scales</code>, <code id="panel.axis.right_+3A_components">components</code>, <code id="panel.axis.right_+3A_as.table">as.table</code>, <code id="panel.axis.right_+3A_...">...</code>, <code id="panel.axis.right_+3A_prefix">prefix</code></td>
<td>
<p>See <code><a href="lattice.html#topic+axis.default">axis.default</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Deepayan Sarkar <code>Deepayan.Sarkar@R-project.org</code> wrote
<code>panel.axis</code> and <code>axis.default</code>.
David Winsemius wrote the modification <code>panel.axis.right</code>.
Richard Heiberger <code>rmh@temple.edu</code> wrote the modification <code>axis.RightAdjustRight</code>.
Richard Heiberger is maintaining this
distribution of both functions.
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+panel.axis">panel.axis</a></code>
</p>

<hr>
<h2 id='panel.bwplot.intermediate.hh'>Panel functions for bwplot.</h2><span id='topic+panel.bwplot.intermediate.hh'></span>

<h3>Description</h3>

<p>Panel function for <code>bwplot</code> that give the user
control over the placement of the boxes.  When used with a positioned
factor, the boxes are placed according to the position associated with
the factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.bwplot.intermediate.hh(x, y, horizontal = TRUE,
          pch, col, lwd,
          ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.bwplot.intermediate.hh_+3A_x">x</code>, <code id="panel.bwplot.intermediate.hh_+3A_y">y</code>, <code id="panel.bwplot.intermediate.hh_+3A_pch">pch</code>, <code id="panel.bwplot.intermediate.hh_+3A_col">col</code>, <code id="panel.bwplot.intermediate.hh_+3A_lwd">lwd</code>, <code id="panel.bwplot.intermediate.hh_+3A_horizontal">horizontal</code></td>
<td>
<p>see
<code><a href="lattice.html#topic+xyplot">xyplot</a></code> and
<code><a href="lattice.html#topic+panel.bwplot">panel.bwplot</a></code>.</p>
</td></tr>
<tr><td><code id="panel.bwplot.intermediate.hh_+3A_...">...</code></td>
<td>
<p> Extra arguments, if any, for 'panel.bwplot'.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course
with Examples in R</em>, Second Edition.
Springer Texts in Statistics. Springer.
ISBN 978-1-4939-2121-8.
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code>,
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>, <code><a href="#topic+interaction2wt">interaction2wt</a></code>,
<code><a href="#topic+position">position</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples at
## Not run: 
  demo("bwplot.examples", package="HH")

## End(Not run)
</code></pre>

<hr>
<h2 id='panel.bwplot.superpose'>
Panel function for bwplot that displays an entire box in the colors coded
by groups.
</h2><span id='topic+panel.bwplot.superpose'></span><span id='topic+panel.bwplot.groups'></span>

<h3>Description</h3>

<p>Panel function for bwplot that displays an entire box (central dot, box,
umbrella, outliers) in the same color, coded by the groups argument.
The function is based on <code>panel.superpose</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.bwplot.superpose(x, y, ...,
                       groups=groups,
                       col=rep(trellis.par.get("superpose.symbol")$col,
                               length=length(groups)),
                       pch=trellis.par.get("box.dot")$pch,
                       panel.groups=panel.bwplot.groups)

panel.bwplot.groups(..., col, pch, fill, fill.alpha=NULL, group.number)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.bwplot.superpose_+3A_x">x</code>, <code id="panel.bwplot.superpose_+3A_y">y</code></td>
<td>

<p>Standard arguments to a <span class="pkg">lattice</span> panel function.
When <code>x</code> has class <code>positioned</code> (see <code><a href="#topic+position">position</a></code>), the
position  will be forwarded by <code>panel.bwplot.superpose</code> to <code>panel.bwplot.groups</code>.
</p>
</td></tr>
<tr><td><code id="panel.bwplot.superpose_+3A_...">...</code></td>
<td>

<p>Additional <span class="pkg">lattice</span> arguments.
</p>
</td></tr>
<tr><td><code id="panel.bwplot.superpose_+3A_groups">groups</code></td>
<td>

<p>Factor to be used for color coding entire boxes: central dot,
rectangle, umbrella, and outlier symbol.
</p>
</td></tr>
<tr><td><code id="panel.bwplot.superpose_+3A_col">col</code></td>
<td>

<p>Colors to be assigned to the levels of the group.  The default colors
are taken from <code>trellis.par.get("superpose.symbol")$col</code>.
</p>
</td></tr>
<tr><td><code id="panel.bwplot.superpose_+3A_pch">pch</code></td>
<td>

<p>Standard <span class="pkg">lattice</span> arguments.
The <code>pch</code> describes the central dot.  The outlier dots are
specified in the <code>plot.symbol</code> component of <code>trellis.par.get</code>.
</p>
</td></tr>
<tr><td><code id="panel.bwplot.superpose_+3A_fill">fill</code>, <code id="panel.bwplot.superpose_+3A_fill.alpha">fill.alpha</code></td>
<td>

<p>These are related to the similarly named arguments in <code>panel.bwplot</code>.
The <code>fill</code> argument is ignored.  It is there to capture the
automatically
generated <code>fill</code> argument.  The default<code>NULL</code> value of <code>fill.alpha</code>
implies that there is no background color for the boxes.  The user can set
<code>fill.alpha</code>
to a number between 0 and 1.  The boxes will be shaded in a lighter
version of their color as implied by the <code>groups</code> argument.  The
value 0 gives a transparent fill, and the value one makes the box the
full opaque color.
</p>
</td></tr>
<tr><td><code id="panel.bwplot.superpose_+3A_panel.groups">panel.groups</code>, <code id="panel.bwplot.superpose_+3A_group.number">group.number</code></td>
<td>

<p>See <code><a href="lattice.html#topic+panel.superpose">panel.superpose</a></code> for details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>panel.bwplot.superpose</code> is the user-level function.
<code>panel.bwplot.groups</code> is the <code>panel.groups</code> function called by <code>panel.superpose</code>.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+position">position</a></code>, <code><a href="#topic+panel.bwplot.intermediate.hh">panel.bwplot.intermediate.hh</a></code>,
<code><a href="lattice.html#topic+panel.superpose">panel.superpose</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- data.frame(Response=rnorm(20), Group=factor(rep(LETTERS[1:3], c(5,7,8))))

bwplot(Group ~ Response, data=tmp,
       main="Default panel.bwplot, groups ignored", groups=Group)

bwplot(Group ~ Response, data=tmp,
       main="panel.bwplot.superpose",
       groups=Group, panel=panel.bwplot.superpose)

bwplot(Group ~ Response, data=tmp,
       main="panel.bwplot.superpose with fill specified",
       groups=Group, panel=panel.bwplot.superpose,
       fill.alpha=.33)


bwplot(Group ~ Response, data=tmp,
       main="panel.bwplot.superpose, with color specified",
       groups=Group, panel=panel.bwplot.superpose,
       col=c("forestgreen","blue", "brown"))


Test &lt;- data.frame(id=rep(letters, each=4),
                   Week=rep(c(0,1,3,6), 26),
                   Treatment=rep(factor(c("A","B"), levels=c("A","B")), each=52),
                   y=rep(1:4, 52) + rep(4:5, each=52) + rnorm(104),
                   stringsAsFactors=FALSE)
Test$WeekTrt &lt;- with(Test, interaction(Week, Treatment))
position(Test$Week) &lt;- unique(Test$Week)
position(Test$WeekTrt) &lt;- as.vector(outer(position(Test$Week), c(-.2, .2), `+`))

tapply(Test$y, Test[c("Week", "Treatment")], median)

bwplot( y ~ WeekTrt, groups = Treatment, data = Test,
      main="default panel.bwplot, groups ignored")

bwplot( y ~ WeekTrt, groups = Treatment, data = Test,
      panel=panel.bwplot.superpose,
      scales=list(x=list(limits=c(-1, 7))),
      main="Minimal use of panel.bwplot.superpose")

bwplot( y ~ WeekTrt, groups = Treatment, data = Test,
       panel=panel.bwplot.superpose,
       scales=list(x=list(limits=c(-1, 7), at=position(Test$Week))),
       box.width=.3,
       xlab="Week",
       pch=c(17, 16),
       key=list(col=trellis.par.get()$superpose.symbol$col[1:2],
           border=TRUE, title="Treatment", cex.title=1, columns=2,
           text=list(levels(Test$Treatment)),
           points=list(pch=c(17, 16))),
       par.settings=list(plot.symbol=list(pch=c(17, 16), cex=.5)),
       main="panel.bwplot.superpose with additional annotations")


bwplot( y ~ WeekTrt, groups = Treatment, data = Test,
       panel=panel.bwplot.superpose,
       scales=list(x=list(limits=c(-1, 7), at=position(Test$Week))),
       box.width=.3,
       xlab="Week",
       pch=c(17, 16),
       key=list(col=trellis.par.get()$superpose.symbol$col[1:2],
           border=TRUE, title="Treatment", cex.title=1, columns=2,
           text=list(levels(Test$Treatment)),
           points=list(pch=c(17, 16))),
       par.settings=list(plot.symbol=list(pch=c(17, 16), cex=.5)),
       main="panel.bwplot.superpose with fill and more complex panel.groups",
       panel.groups = function(...) {
           panel.stripplot(...)
           panel.bwplot.groups(...)
       },
       fill.alpha=.33,
       jitter.data = TRUE)

</code></pre>

<hr>
<h2 id='panel.bwplott'>Extension to S-Plus trellis to allow transposed plots.</h2><span id='topic+panel.bwplott'></span>

<h3>Description</h3>

<p>Extension to S-Plus trellis to allow transposed plots.  All
x - and y-components of the trellis object are interchanged.
This function is not needed in R as lattice has a horizontal argument
in its definitions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.bwplott(x, y, box.ratio = 1,
              font = box.dot$font, pch = box.dot$pch, cex = box.dot$cex,
              col = box.dot$col, ..., transpose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.bwplott_+3A_x">x</code>, <code id="panel.bwplott_+3A_y">y</code>, <code id="panel.bwplott_+3A_box.ratio">box.ratio</code>, <code id="panel.bwplott_+3A_font">font</code>, <code id="panel.bwplott_+3A_pch">pch</code>, <code id="panel.bwplott_+3A_cex">cex</code>, <code id="panel.bwplott_+3A_col">col</code>, <code id="panel.bwplott_+3A_...">...</code></td>
<td>
<p>See
<code><a href="lattice.html#topic+panel.bwplot">panel.bwplot</a></code>.
</p>
</td></tr>
<tr><td><code id="panel.bwplott_+3A_transpose">transpose</code></td>
<td>
<p>logical.  If <code>FALSE</code>, the plot is printed in the
default orientation.  If <code>TRUE</code>, the <code>x</code>- and
<code>y</code>-components
of the trellis object are interchanged.  This has the effect, for
example,
of displaying vertical boxplots instead of the default horizontal boxplots.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function is used for its side effect of drawing boxplots in a
trellis panel.
</p>


<h3>Note</h3>

<p>This function is not needed in R.  If it is used and 
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>

<hr>
<h2 id='panel.cartesian'>trellis panel function, with labeled rows and columns and without
strip labels.</h2><span id='topic+panel.cartesian'></span>

<h3>Description</h3>

<p>trellis panel function, with labeled rows and columns and without
strip labels.  Designed for use with the ladder of powers plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.cartesian(x, y,
                x.label=unique(panel.labels[,"x"]),
                y.label=unique(panel.labels[,"y"]),
                group.label.side="",
                axis3.line=1,
                xg.label, yg.label, g.cex=.7,
                rescale=list(x=TRUE,y=TRUE), ...,
                browser.on=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.cartesian_+3A_x">x</code>, <code id="panel.cartesian_+3A_y">y</code></td>
<td>
<p>x and y as for any other panel function</p>
</td></tr>
<tr><td><code id="panel.cartesian_+3A_x.label">x.label</code></td>
<td>
<p>labels for the columns of the scatterplot matrix</p>
</td></tr>
<tr><td><code id="panel.cartesian_+3A_y.label">y.label</code></td>
<td>
<p>labels for the rows of the scatterplot matrix</p>
</td></tr>
<tr><td><code id="panel.cartesian_+3A_axis3.line">axis3.line</code></td>
<td>
<p>The <code>x.label</code> doesn't always show up in the
right place.  This allows the user to adjust it's position. </p>
</td></tr>
<tr><td><code id="panel.cartesian_+3A_group.label.side">group.label.side</code></td>
<td>
<p><code>c("","left","top")</code>, when the plotting
formula is conditioned on a group factor, the levels of the group are
displayed in the margins of the plot.  The appearance depends on the
setting of the trellis <code>between</code> argument.  Getting it to look good
for any given plot requires experimentation.  Since it is redundant with
the information in the strip labels, leaving it at the default <code>""</code>
is often the best thing to do.</p>
</td></tr>
<tr><td><code id="panel.cartesian_+3A_xg.label">xg.label</code></td>
<td>
<p>group labels for rows of the scatterplot matrix</p>
</td></tr>
<tr><td><code id="panel.cartesian_+3A_yg.label">yg.label</code></td>
<td>
<p>group labels for rows of the scatterplot matrix</p>
</td></tr>
<tr><td><code id="panel.cartesian_+3A_g.cex">g.cex</code></td>
<td>
<p><code>cex</code> for the group labels</p>
</td></tr>
<tr><td><code id="panel.cartesian_+3A_rescale">rescale</code></td>
<td>
<p>alternate way to get something similar to <code>relation="free"</code></p>
</td></tr>
<tr><td><code id="panel.cartesian_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
<tr><td><code id="panel.cartesian_+3A_browser.on">browser.on</code></td>
<td>
<p>logical, normally <code>FALSE</code>.  This is a debugging
tool.  When <code>TRUE</code>, the <code>browser()</code> is turned on at various
critical points.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ladder">ladder</a></code>, <code><a href="#topic+xysplom">xysplom</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rent)  ## Weisberg's file alr162

rent.lm &lt;- lm(rnt.alf ~ rnt.till + cow.dens + lime, data=rent)
rent$resid.rent &lt;- resid(rent.lm)

xysplom(resid.rent ~ rnt.till + cow.dens | lime, data=rent,
        layout=c(2,2))

xysplom(resid.rent ~ rnt.till + cow.dens | lime, data=rent,
        layout=c(2,2),
        xlab="", ylab="",
        x.label="", y.label="",
        group.label.side="",
        par.strip.text=list(cex=1.2),
        panel=panel.cartesian,
        axis3.line=2.4,
        scales=list(
          relation="same",
          alternating=FALSE, labels=FALSE, ticks=FALSE),
        between=list(x=1, y=3))

xysplom(resid.rent ~ rnt.till + cow.dens | lime, data=rent,
        layout=c(2,2),
        xlab="", ylab="",
        x.label="", y.label="",
        group.label.side="",
        par.strip.text=list(cex=1.2),
        panel=panel.cartesian,
        axis3.line=3.6,
        scales=list(
          relation="same",
          alternating=FALSE, labels=FALSE, ticks=FALSE),
        rescale=list(x=FALSE, y=FALSE),
        between=list(x=1, y=3))

xysplom(resid.rent ~ rnt.till + cow.dens | lime, data=rent,
        layout=c(2,2),
        xlab="", ylab="",
        x.label="", y.label="",
        group.label.side="",
        par.strip.text=list(cex=1.2),
        panel=panel.cartesian,
        axis3.line=3.6,
        scales=list(
          relation="free",
          alternating=FALSE, labels=FALSE, ticks=FALSE),
        between=list(x=1, y=3))

tmp &lt;-
xysplom(resid.rent ~ rnt.till + cow.dens | lime, data=rent,
        layout=c(2,2),
        xlab="", ylab="",
        y.label="resid",
        group.label.side="top",
        par.strip.text=list(cex=1.2),
        panel=panel.cartesian,
        axis3.line=3.6,
        scales=list(alternating=FALSE, labels=FALSE, ticks=FALSE),
        rescale=list(x=FALSE, y=FALSE),
        between=list(x=4, y=5))
if.R(r=tmp$par.settings &lt;- list(layout.widths=list(right.padding=4)),
     s={})
tmp

</code></pre>

<hr>
<h2 id='panel.ci.plot'>Default Panel Function for ci.plot </h2><span id='topic+panel.ci.plot'></span>

<h3>Description</h3>

<p>This is the default panel function for <code>ci.plot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.ci.plot(x, y, newdata, newfit = newfit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.ci.plot_+3A_x">x</code></td>
<td>
<p>Observed values of predictor variable.</p>
</td></tr>
<tr><td><code id="panel.ci.plot_+3A_y">y</code></td>
<td>
<p>Observed values of response variable.</p>
</td></tr>
<tr><td><code id="panel.ci.plot_+3A_newdata">newdata</code></td>
<td>
<p><code>x</code> values for which predictions are calculated.</p>
</td></tr>
<tr><td><code id="panel.ci.plot_+3A_newfit">newfit</code></td>
<td>
<p><code>data.frame</code> containing six components:
<code>"fit"</code>, <code>"se.fit"</code>, <code>"residual.scale"</code>, <code>"df"</code>,
<code>"ci.fit"</code>, <code>"pi.fit"</code>.  In S-Plus these are the output from the
<code>predict.lm</code> function.  In R they are a rearrangement of the
output of the <code>predict.lm</code> function.</p>
</td></tr>
<tr><td><code id="panel.ci.plot_+3A_...">...</code></td>
<td>
<p>  other arguments passed to <code>panel.xyplot</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+ci.plot">ci.plot</a></code>, <code><a href="lattice.html#topic+xyplot">xyplot</a></code>, <code><a href="stats.html#topic+lm">lm</a></code></p>

<hr>
<h2 id='panel.confintMMC'>
Confidence interval panel for MMC tiebreaker plots, or confidence
interval plot.
</h2><span id='topic+panel.confintMMC'></span>

<h3>Description</h3>

<p>Confidence interval panel for MMC tiebreaker plots, or confidence
interval plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.confintMMC(x, y, subscripts, ..., col, lwd, lty, lower, upper,
                 contrast.name, right.text.cex = 0.8,
                 contrast.height=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.confintMMC_+3A_x">x</code></td>
<td>

<p>means
</p>
</td></tr>
<tr><td><code id="panel.confintMMC_+3A_y">y</code></td>
<td>

<p>When called from <code>mmcisomeans</code>, the heights associated with the contrasts.
When called from <code>mmcmatch</code>, integers from one to the number of means.
</p>
</td></tr>
<tr><td><code id="panel.confintMMC_+3A_subscripts">subscripts</code></td>
<td>

<p>Index into the <code>contrast.names</code>.
</p>
</td></tr>
<tr><td><code id="panel.confintMMC_+3A_...">...</code></td>
<td>

<p>Additional arguments are ignored.
</p>
</td></tr>
<tr><td><code id="panel.confintMMC_+3A_col">col</code>, <code id="panel.confintMMC_+3A_lty">lty</code>, <code id="panel.confintMMC_+3A_lwd">lwd</code></td>
<td>

<p>Standard <span class="pkg">lattice</span> arguments.
</p>
</td></tr>
<tr><td><code id="panel.confintMMC_+3A_lower">lower</code></td>
<td>

<p>Vector of lower bounds for the intervals.
</p>
</td></tr>
<tr><td><code id="panel.confintMMC_+3A_upper">upper</code></td>
<td>

<p>Vector of upper bounds for the intervals.
</p>
</td></tr>
<tr><td><code id="panel.confintMMC_+3A_contrast.name">contrast.name</code></td>
<td>

<p>Names of the contrasts.
</p>
</td></tr>
<tr><td><code id="panel.confintMMC_+3A_right.text.cex">right.text.cex</code></td>
<td>
<p>The right axis has non-standard controls.</p>
</td></tr>
<tr><td><code id="panel.confintMMC_+3A_contrast.height">contrast.height</code></td>
<td>
<p>Logical.  The alternate <code>TRUE</code> means
display the values of the contrast heights as the left axis tick labels.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p>See <code><a href="#topic+mmc">mmc</a></code> for the references and examples.
</p>

<hr>
<h2 id='panel.dotplot.tb'>Dotplot with evenly spaced tiebreakers.</h2><span id='topic+panel.dotplot.tb'></span>

<h3>Description</h3>

<p>Dotplot with evenly spaced tiebreakers.
Multiple hits on a specific x value are stacked.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.dotplot.tb(x, y, factor=.1,
                 jitter.data=TRUE, horizontal=TRUE,
                 max.freq=max(sapply(subsets, length)),
                 ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.dotplot.tb_+3A_x">x</code>, <code id="panel.dotplot.tb_+3A_y">y</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="panel.dotplot.tb_+3A_factor">factor</code></td>
<td>
<p>jitter factor, see <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
Increment is <code>factor/max.freq</code> where <code>max.freq</code> is the
maximum number of duplicates of any x value in any y group.</p>
</td></tr>
<tr><td><code id="panel.dotplot.tb_+3A_jitter.data">jitter.data</code>, <code id="panel.dotplot.tb_+3A_horizontal">horizontal</code></td>
<td>
<p>Always <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="panel.dotplot.tb_+3A_max.freq">max.freq</code></td>
<td>
<p>maximum number of observation at any combination of
response values, factor levels, and group levels.
If the formula includes one or more conditioning factors, then the
user is responsible for providing a value for <code>max.freq</code>.</p>
</td></tr>
<tr><td><code id="panel.dotplot.tb_+3A_...">...</code></td>
<td>
<p>Other arguments for <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates (possibly grouped) Dotplot of x against y.  y is the &lsquo;factor&rsquo;.
</p>


<h3>Warning </h3>

 
<p>If the formula includes one or more conditioning factors, then the
user is responsible for providing a value for <code>max.freq</code>.
The default behavior is a different <code>max.freq</code> for each panel
in a multi-panel display.  
</p>


<h3>Author(s)</h3>

<p>Richard M. Heiberger
</p>
<p>Maintainer: Richard M. Heiberger &lt;rmh@temple.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1,1,2,2,2,5,4,2,1,5)
y &lt;- factor(letters[rep(1:2, 5)])

dotplot(x, panel=panel.dotplot.tb)
dotplot(x, panel=panel.dotplot.tb, factor=.2)
dotplot(y ~ x, panel=panel.dotplot.tb)
dotplot(y ~ x, panel=panel.dotplot.tb, cex=1.5, factor=.15)



quiz &lt;- data.frame(scores=sample(10, 360, replace=TRUE),
                   date=rep(rep(c("0902", "0916", "0930"), c(40,40,40)), 3),
                   section=rep(
                     c("Stat1-3", "Stat1-5", "Stat1-8"),
                     c(120,120,120)))

dotplot(date ~ scores | section, data=quiz,
        panel=panel.dotplot.tb, factor=.5)

dotplot(date ~ scores | section, data=quiz,
        panel=panel.dotplot.tb, factor=.5,
        layout=c(1,3), between=list(y=1),
        main='Three quizzes for three sections of Stat 1')


## If the formula includes one or more conditioning factors, then the
## user is responsible for providing a value for the argument max.freq
##
a &lt;- rep(1, 10)
z &lt;- c(1,1,2,2,2,3,2,3,1,1)
g &lt;- LETTERS[c(1,1,1,1,1,2,2,2,2,2)]

print(split=c(1,1,2,1), more=TRUE,
dotplot( a ~ z | g, panel=panel.dotplot.tb,
        factor=.6, cex=1.5, layout=c(2,1),
        main="different scaling in each panel")
)

print(split=c(2,1,2,1), more=FALSE,
dotplot( a ~ z | g, panel=panel.dotplot.tb, max.freq=3,
        factor=.6, cex=1.5, layout=c(2,1),
        main="same scaling in each panel")
)

</code></pre>

<hr>
<h2 id='panel.interaction2wt'>Plot all main effects and twoway interactions in a multifactor design</h2><span id='topic+panel.interaction2wt'></span><span id='topic+strip.interaction2wt'></span>

<h3>Description</h3>

<p>This is the panel function for <code>interaction2wt</code>.  The main diagonal
displays boxplots for the main effects of each factor.  The
off-diagonals show the interaction plots for each pair of factors.
The <code>i,j</code> panel shows the same factors as the <code>j,i</code> but with
the trace- and x-factor roles interchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.interaction2wt(x, y, subscripts,
                     responselab, trace.values,
                     factor.levels, factor.position,
                     fun = mean,
                     se,
                     type="l",
                     ...,
                     box.ratio,
                     simple=FALSE,
                     simple.offset,
                     simple.scale,
                     simple.pch,
                     data.x,
                     col.by.row=TRUE,
                     col  =trellis.par.get("superpose.line")$col,
                     lty  =trellis.par.get("superpose.line")$lty,
                     lwd  =trellis.par.get("superpose.line")$lwd,
                     alpha=trellis.par.get("superpose.line")$alpha
)

strip.interaction2wt(which.given, which.panel, var.name,
                     factor.levels, shingle.intervals,
                     strip.names = c(TRUE, TRUE), style = 1, ...)
</code></pre>


<h3>Arguments</h3>

<p><code>panel.interaction2wt</code> arguments:
</p>
<table>
<tr><td><code id="panel.interaction2wt_+3A_x">x</code></td>
<td>
<p>levels of x-factor</p>
</td></tr>
<tr><td><code id="panel.interaction2wt_+3A_y">y</code></td>
<td>
<p> Summary value of response variable at each level of
x- and trace-factors. </p>
</td></tr>
<tr><td><code id="panel.interaction2wt_+3A_subscripts">subscripts</code></td>
<td>
<p>used to get the right set of response values for the
summary statistics on the off-diagonals</p>
</td></tr>
<tr><td><code id="panel.interaction2wt_+3A_responselab">responselab</code></td>
<td>
<p>Character name of response variable, defaults to
the name of the response variable.</p>
</td></tr>
<tr><td><code id="panel.interaction2wt_+3A_trace.values">trace.values</code></td>
<td>
<p>levels of trace-factor</p>
</td></tr>
<tr><td><code id="panel.interaction2wt_+3A_fun">fun</code></td>
<td>
<p>Summary function, defaults to <code>mean</code></p>
</td></tr>
<tr><td><code id="panel.interaction2wt_+3A_se">se</code></td>
<td>
<p>standard errors to be passed to <code>panel.intxplot</code>.
Missing, logical, or a numeric vector.
If  <code>se</code> is  missing or <code>FALSE</code>, or if <code>simple</code> is
<code>FALSE</code>, then standard errors are not plotted.
If <code>TRUE</code>, the standard errors are calculated from the
sufficient statistics for each group as the group's standard deviation
divided by the square root of the group's observation
count.  If a numeric vector, it is evaluated in the environment of
the sufficient statistics.
</p>
</td></tr></table>
<p>,
</p>
<table>
<tr><td><code id="panel.interaction2wt_+3A_type">type</code></td>
<td>
<p>See <code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code>.</p>
</td></tr></table>
<p>,
</p>
<table>
<tr><td><code id="panel.interaction2wt_+3A_box.ratio">box.ratio</code></td>
<td>
<p>passed to <code>panel.bwplot.intermediate.hh</code></p>
</td></tr></table>
<p>,
</p>
<table>
<tr><td><code id="panel.interaction2wt_+3A_...">...</code></td>
<td>
<p>extra arguments, primarily color,
to be passed to <code>panel.bwplot.intermediate.hh</code></p>
</td></tr>
<tr><td><code id="panel.interaction2wt_+3A_factor.position">factor.position</code></td>
<td>
<p><code>"position"</code> attribute of factor.</p>
</td></tr>
<tr><td><code id="panel.interaction2wt_+3A_simple">simple</code></td>
<td>
<p>logical.  If <code>TRUE</code>, then simple effects are to be displayed.</p>
</td></tr>
<tr><td><code id="panel.interaction2wt_+3A_simple.offset">simple.offset</code>, <code id="panel.interaction2wt_+3A_simple.scale">simple.scale</code></td>
<td>
<p>named list of offset and scale for the
response and trace factors.<br />
See <code><a href="#topic+interaction.positioned">interaction.positioned</a></code> for their use.</p>
</td></tr>
<tr><td><code id="panel.interaction2wt_+3A_simple.pch">simple.pch</code></td>
<td>
<p>Named list containing plotting characters for each
level of one or more of the factors.  <code>simple.pch</code> is used only when
<code>simple==TRUE</code>.  If the argument <code>simple.pch</code> is missing,
then the integers for the levels of the factors are used.  The
characters are used for the median of the box plots in the diagonal
panels.  They match the trace factor of the interaction panel in the
same column of the display.  </p>
</td></tr>
<tr><td><code id="panel.interaction2wt_+3A_data.x">data.x</code></td>
<td>
<p><code>data.frame</code> containing factors from the input data.frame</p>
</td></tr>
<tr><td><code id="panel.interaction2wt_+3A_col.by.row">col.by.row</code></td>
<td>
<p>logical.  If <code>TRUE</code> (the default), simple
effects plots color the simple effects on the main diagonals in the same
color as the trace levels in their row.  If <code>FALSE</code>, then simple
effects are colored to match the x levels in their column.</p>
</td></tr>
<tr><td><code id="panel.interaction2wt_+3A_col">col</code>, <code id="panel.interaction2wt_+3A_lty">lty</code>, <code id="panel.interaction2wt_+3A_lwd">lwd</code>, <code id="panel.interaction2wt_+3A_alpha">alpha</code></td>
<td>
<p>Arguments to
<code>trellis.par.set(superpose.line=list())</code>.</p>
</td></tr>
</table>
<p><code>strip.interaction2wt</code> arguments
</p>
<table>
<tr><td><code id="panel.interaction2wt_+3A_which.given">which.given</code>, <code id="panel.interaction2wt_+3A_which.panel">which.panel</code>, <code id="panel.interaction2wt_+3A_var.name">var.name</code>, <code id="panel.interaction2wt_+3A_factor.levels">factor.levels</code>, <code id="panel.interaction2wt_+3A_shingle.intervals">shingle.intervals</code></td>
<td>
<p>see documentation
for <code><a href="lattice.html#topic+strip.default">strip.default</a></code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="panel.interaction2wt_+3A_strip.names">strip.names</code></td>
<td>
<p>Force <code>strip.names=TRUE</code></p>
</td></tr>
<tr><td><code id="panel.interaction2wt_+3A_style">style</code></td>
<td>
<p>force <code>style=1</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interaction2wt">interaction2wt</a></code>,
<code><a href="#topic+panel.bwplot.intermediate.hh">panel.bwplot.intermediate.hh</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tmp &lt;- data.frame(y=rnorm(48),
                  A=factor(rep(1:2, 24)),
                  B=factor(rep(rep(1:3, each=2), 8)),
                  C=factor(rep(rep(1:4, each=6), 2)))
interaction2wt(y ~ A+B+C, data=tmp,
               key.in=list(x=-3), ## key.in is ignored by R
               xlim=c(.4, 4.5))
interaction2wt(y ~ B+C, data=tmp, key.in=list(x=-2), xlim=c(.4, 4.5))
position(tmp$B) &lt;- c(1, 2.4, 3.8)
interaction2wt(y ~ B+C, data=tmp, key.in=list(x=-2), xlim=c(.4, 4.5))
interaction2wt(y ~ B+C, data=tmp, simple=TRUE,
               simple.scale=list(B=.18, C=.27),  box.ratio=.2,
               key.in=list(x=-2), xlim=c(.4, 4.5))
interaction2wt(y ~ C+B, data=tmp, simple=TRUE,
               simple.scale=list(B=.18, C=.27),  box.ratio=.2,
               key.in=list(x=-2), xlim=c(.4, 4.5))
interaction2wt(y ~ B+C, data=tmp, simple=TRUE,
               simple.scale=list(B=.18, C=.27),  box.ratio=.2,
               simple.pch=list(C=c(16,17,18,19)),
               key.in=list(x=-2), xlim=c(.4, 4.5))
interaction2wt(y ~ C+B, data=tmp, simple=TRUE,
               simple.scale=list(B=.18, C=.27),  box.ratio=.2,
               simple.pch=list(C=c(16,17,18,19)),
               key.in=list(x=-2), xlim=c(.4, 4.5))
interaction2wt(y ~ C+B, data=tmp, simple=TRUE,
               simple.scale=list(B=.18, C=.27),  box.ratio=.2,
               simple.pch=list(A=c(1:2), B=c(3:5), C=c(16,17,18,19)),
               key.in=list(x=-2), xlim=c(.4, 4.5))
interaction2wt(y ~ C+B, data=tmp, simple=TRUE,
               simple.scale=list(B=.18, C=.27),  box.ratio=.2,
               simple.pch=list(A=c(1:2)),
               key.in=list(x=-2), xlim=c(.4, 4.5))
interaction2wt(y ~ B+C, data=tmp, simple=TRUE,
               simple.scale=list(B=.18, C=.27),  box.ratio=.2,
               simple.pch=list(B=c(16,17,18)),
               key.in=list(x=-2), xlim=c(.4, 4.5),
               se=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='panel.isomeans'>
isomeans grid for MMC plots.
</h2><span id='topic+panel.isomeans'></span>

<h3>Description</h3>

<p>isomeans grid for MMC plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.isomeans(ybar,
               lty.iso=7,
               col.iso='darkgray',
               lwd.iso=1,
               lty.contr0=2,
               col.contr0='darkgray',
               lwd.contr0=1,
               ...,
               col, lwd, lty ## capture potentially ambiguous name
               )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.isomeans_+3A_ybar">ybar</code></td>
<td>

<p>Vector of means.
</p>
</td></tr>
<tr><td><code id="panel.isomeans_+3A_lty.iso">lty.iso</code>, <code id="panel.isomeans_+3A_col.iso">col.iso</code>, <code id="panel.isomeans_+3A_lwd.iso">lwd.iso</code></td>
<td>
<p>color, line type,
line width for the isomeans grid.</p>
</td></tr>
<tr><td><code id="panel.isomeans_+3A_lty.contr0">lty.contr0</code>, <code id="panel.isomeans_+3A_col.contr0">col.contr0</code>, <code id="panel.isomeans_+3A_lwd.contr0">lwd.contr0</code></td>
<td>
<p>color, line type,
line width for the vertical contrast=0 line.</p>
</td></tr>
<tr><td><code id="panel.isomeans_+3A_...">...</code></td>
<td>
<p>ignore any additional arguments</p>
</td></tr>
<tr><td><code id="panel.isomeans_+3A_col">col</code>, <code id="panel.isomeans_+3A_lwd">lwd</code>, <code id="panel.isomeans_+3A_lty">lty</code></td>
<td>
<p>ignore these arguments.  They are captured here to avoid
ambiguity with <code>col.iso</code> and <code>lty.iso</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p>See <code><a href="#topic+mmc">mmc</a></code> for the references and examples.
</p>

<hr>
<h2 id='panel.likert'>Panel functions for likert that include a stackWidth argument</h2><span id='topic+panel.likert'></span><span id='topic+panel.barchart2'></span>

<h3>Description</h3>

<p><code>panel.barchart2</code> is based on <code>panel.barchart</code><br />
The changes are<br />
* the heights in each horizontal stacked bar are constant.<br />
* the widths in each vertical stacked bar are constant.<br />
* the panel.barchart heights and widths are based on the box.width argument.<br />
* the panel.barchart2 heights and widths when <code>stack==TRUE</code> are also based
on the new <code>stackWidth</code> argument.
</p>
<p><code>panel.likert</code> calls <code>panel.barchart2</code>
</p>
<p>scaling of <code>stackWidth</code>:<br />
<code>stackWidth &lt;- stackWidth/mean(stackWidth) ## and maybe smaller with another /2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.barchart2(x, y, box.ratio = 1, box.width = box.ratio/(1 + box.ratio),
    horizontal = TRUE, origin = NULL, reference = TRUE, stack = FALSE,
    groups = NULL,
    col = if (is.null(groups)) plot.polygon$col else superpose.polygon$col,
    border = if (is.null(groups)) plot.polygon$border else superpose.polygon$border,
    lty = if (is.null(groups)) plot.polygon$lty else superpose.polygon$lty,
    lwd = if (is.null(groups)) plot.polygon$lwd else superpose.polygon$lwd,
    ..., identifier = "barchart",
          stackWidth=NULL)

panel.likert(..., horizontal=TRUE, reference.line.col="gray65")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.likert_+3A_x">x</code>, <code id="panel.likert_+3A_y">y</code>, <code id="panel.likert_+3A_box.ratio">box.ratio</code>, <code id="panel.likert_+3A_box.width">box.width</code>, <code id="panel.likert_+3A_horizontal">horizontal</code>, <code id="panel.likert_+3A_origin">origin</code>, <code id="panel.likert_+3A_reference">reference</code>, <code id="panel.likert_+3A_stack">stack</code>, <code id="panel.likert_+3A_groups">groups</code>, <code id="panel.likert_+3A_col">col</code></td>
<td>
<p>See <code><a href="lattice.html#topic+panel.barchart">panel.barchart</a></code>.</p>
</td></tr>
<tr><td><code id="panel.likert_+3A_border">border</code>, <code id="panel.likert_+3A_lty">lty</code>, <code id="panel.likert_+3A_lwd">lwd</code>, <code id="panel.likert_+3A_identifier">identifier</code></td>
<td>
<p>See <code><a href="lattice.html#topic+panel.barchart">panel.barchart</a></code>.</p>
</td></tr>
<tr><td><code id="panel.likert_+3A_...">...</code></td>
<td>
<p>Extra arguments, if any, for <code>panel.barchart</code>.</p>
</td></tr>
<tr><td><code id="panel.likert_+3A_stackwidth">stackWidth</code></td>
<td>
<p>Heights in each horizontal stacked bar, when
stack=TRUE, are constant and specified by this argument.  We
recommend starting with<br />
<code>stackWidth &lt;- stackWidth/mean(stackWidth)</code> and adjusting as seems appropriate.</p>
</td></tr>
<tr><td><code id="panel.likert_+3A_reference.line.col">reference.line.col</code></td>
<td>
<p>See <code><a href="#topic+likert">likert</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+likert">likert</a></code></p>

<hr>
<h2 id='panel.pairs.hh'>Function based on S-Plus panel.pairs to add the subpanel.scales
and panel.cex arguments.</h2><span id='topic+panel.pairs.hh'></span>

<h3>Description</h3>

<p>Function based on S-Plus <code>panel.pairs</code> to add the <code>subpanel.scales</code> and
<code>panel.cex</code> arguments.  In R, this is an alias for <code>panel.pairs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.pairs.hh(x, y, z, subscripts, pscales, subpanel = panel.splom,
           varnames = dimnames(x)[[2]], ...,
           subpanel.scales, panel.cex=par()$cex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.pairs.hh_+3A_x">x</code>, <code id="panel.pairs.hh_+3A_y">y</code>, <code id="panel.pairs.hh_+3A_z">z</code>, <code id="panel.pairs.hh_+3A_subscripts">subscripts</code>, <code id="panel.pairs.hh_+3A_pscales">pscales</code>, <code id="panel.pairs.hh_+3A_subpanel">subpanel</code>, <code id="panel.pairs.hh_+3A_varnames">varnames</code>, <code id="panel.pairs.hh_+3A_...">...</code></td>
<td>
<p>See
<code>splom</code>
</p>
<p>in S-Plus.</p>
</td></tr>
<tr><td><code id="panel.pairs.hh_+3A_subpanel.scales">subpanel.scales</code></td>
<td>
<p>Controls the size of the tick labels in the
diagonal panel.</p>
</td></tr>
<tr><td><code id="panel.pairs.hh_+3A_panel.cex">panel.cex</code></td>
<td>
<p>Controls the size of the variable names in the
diagonal panel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"trellis" object</code>.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code>splom</code>
</p>
<p>in S-Plus. </p>


<h3>Examples</h3>

<pre><code class='language-R'>if.R(s={
     longley &lt;- data.frame(longley.x, Employed = longley.y)
     },r={
     data(longley)
     })

if.R(s=
     splom( ~ longley, pch=16, cex=.55,
           superpanel=panel.pairs.hh, subpanel.scales=list(cex=.8),
           pscales=2,
           panel.cex=.8)
     ,r=
     splom( ~ longley, pch=16,
           pscales=2,
           varname.cex=.8,
           axis.text.cex=.5)
   )
</code></pre>

<hr>
<h2 id='panel.xysplom'>panel method for xysplom.</h2><span id='topic+panel.xysplom'></span>

<h3>Description</h3>

<p>panel method for xysplom.  It has a <code>corr</code> argument that is
removed
before sending the information on to panel.xyplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.xysplom(corr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.xysplom_+3A_corr">corr</code></td>
<td>
<p>logical.  If <code>TRUE</code>, display the correlation and/or
the regression
coefficient for <code>lm(y ~ x)</code> for each panel in an additional
strip label.</p>
</td></tr>
<tr><td><code id="panel.xysplom_+3A_...">...</code></td>
<td>
<p>Remaining arguments to <code>panel.xyplot</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+xysplom">xysplom</a></code></p>

<hr>
<h2 id='partial.corr'>partial correlations</h2><span id='topic+partial.corr'></span>

<h3>Description</h3>

<p>The partial correlation of x and y conditioning on z is the
ordinary correlation of the residuals from the regression of x on z
and the regression of y on z.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial.corr(vars, cond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial.corr_+3A_vars">vars</code></td>
<td>
<p>matrix of data.frame of all the variables to be correlated.</p>
</td></tr>
<tr><td><code id="partial.corr_+3A_cond">cond</code></td>
<td>
<p>matrix of data.frame of all the variables to be
conditioned on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of partial correlations of the numeric variables in the argument
<code>vars</code> conditioning on the numeric variables in <code>cond</code>.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>Examples</h3>

<pre><code class='language-R'>if.R(r=
partial.corr(longley[,1:3], longley[,4:6])
,s=
partial.corr(longley.x[,1:3], longley.x[,4:6])
)
</code></pre>

<hr>
<h2 id='pdf.latex'>
Construct a pdf file from a &quot;latex&quot; file.  See Hmisc::latex for concepts.
</h2><span id='topic+pdf.latex'></span>

<h3>Description</h3>

<p>Construct a <code>"pdf"</code> file from a <code>"latex"</code> file.  See <code><a href="Hmisc.html#topic+latex">latex</a></code> for concepts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdf.latex(latex.object, ..., file, overwrite = TRUE, copy.mode = TRUE, copy.date = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.latex_+3A_latex.object">latex.object</code></td>
<td>

<p>Result from a call to <code>Hmisc::latex()</code>.
</p>
</td></tr>
<tr><td><code id="pdf.latex_+3A_...">...</code></td>
<td>

<p>Optional arguments to <code>Hmisc::dvi()</code>
</p>
</td></tr>
<tr><td><code id="pdf.latex_+3A_file">file</code></td>
<td>

<p>File name in <code>getwd()</code> to place resulting pdf file.
</p>
</td></tr>
<tr><td><code id="pdf.latex_+3A_overwrite">overwrite</code></td>
<td>

<p>If the file already exists, <code>TRUE</code> means replace it.
</p>
</td></tr>
<tr><td><code id="pdf.latex_+3A_copy.mode">copy.mode</code>, <code id="pdf.latex_+3A_copy.date">copy.date</code></td>
<td>

<p>If <code>TRUE</code> copy file mode and date from temporary directory to <code>getwd()</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Filename of class <code>"dvi"</code>
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="Hmisc.html#topic+latex">latex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## you will normally need these options.  See ?Hmisc::latex for details.
options(latexcmd='pdflatex')
options(dviExtension='pdf')
options(xdvicmd='open')  ## Macintosh, Windows,      SMP linux

## Not run: 
## these examples place files in your current working directory

## matrix
tmp &lt;- array(1:20, c(4,5), list(LETTERS[1:4], LETTERS[5:9]))
tmp

pdf.latex(latex(tmp)) ## for matrix, accept the default structure.tex and structure.pdf filenames.

pdf.latex(latex(tmp, title="tmp")) ## specify name of .tex and .pdf file.



## 3D array
tmp3 &lt;- array(1:40, c(4,5,2), list(LETTERS[1:4], LETTERS[5:9], LETTERS[10:11]))
tmp3

pdf.latex(latex(tmp3)) ## for array, the default base filename is the
                       ##  name of the argument, hence tmp3.tex and tmp3.pdf

pdf.latex(latex(tmp3, title="somethingelse")) ## or specify somethingelse

## End(Not run)

</code></pre>

<hr>
<h2 id='pdiscunif'>Discrete Uniform Distribution</h2><span id='topic+pdiscunif'></span><span id='topic+qdiscunif'></span><span id='topic+ddiscunif'></span><span id='topic+rdiscunif'></span>

<h3>Description</h3>

<p>Discrete Uniform Distribution</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdiscunif(q, size)
qdiscunif(p, size)
ddiscunif(q, size)
rdiscunif(n, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdiscunif_+3A_size">size</code></td>
<td>
<p>parameter of distribution.  Numbers from 1 to  size
are equally likely.</p>
</td></tr>
<tr><td><code id="pdiscunif_+3A_q">q</code></td>
<td>
<p>Quantiles.</p>
</td></tr>
<tr><td><code id="pdiscunif_+3A_p">p</code></td>
<td>
<p>Probability.</p>
</td></tr>
<tr><td><code id="pdiscunif_+3A_n">n</code></td>
<td>
<p>number of items in the random sample.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>Examples</h3>

<pre><code class='language-R'>  q &lt;- seq(-.5, 7.5, .5)

  pp &lt;- pdiscunif(q, 6)

  ## xyplot(pp ~ q,
  ##        scales=list(
  ##        x=list(at=floor(min(q)):ceiling(max(q))),
  ##        y=list(at=seq(0, 1, .1))))

  qq &lt;- qdiscunif(pp, 6)

  dd &lt;- ddiscunif(q, 6)

  cbind(q, pp, qq, dd)

  rdiscunif(12, 6)
</code></pre>

<hr>
<h2 id='perspPlane'>Helper functions for regr2.plot</h2><span id='topic+perspPlane'></span><span id='topic+perspFloor'></span><span id='topic+perspBack.wall.x'></span><span id='topic+perspBack.wall.y'></span>

<h3>Description</h3>

<p>Helper functions for <code>regr2.plot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perspPlane(x, y, z, persp.out, ...)
perspFloor(x, y, z, persp.out, ...)
perspBack.wall.x(x, y, z, persp.out, ...)
perspBack.wall.y(x, y, z, persp.out, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perspPlane_+3A_x">x</code>, <code id="perspPlane_+3A_y">y</code>, <code id="perspPlane_+3A_z">z</code></td>
<td>
<p>Arguments to <code>trans3d</code> in R, or <code>perspp</code> in S-Plus.</p>
</td></tr>
<tr><td><code id="perspPlane_+3A_persp.out">persp.out</code></td>
<td>
<p>Result from previous call to <code>persp</code>.</p>
</td></tr>
<tr><td><code id="perspPlane_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>persp</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+regr2.plot">regr2.plot</a></code></p>

<hr>
<h2 id='plot.hov'>Homogeneity of Variance Plot</h2><span id='topic+hovPlot'></span><span id='topic+hovPlot.bf'></span><span id='topic+panel.hov'></span>

<h3>Description</h3>

<p>Oneway analysis of variance makes the assumption that the variances of
the groups are equal.
Brown and Forsyth, 1974 present the recommended test of this assumption.
The Brown and Forsyth test statistic is the <code class="reqn">F</code> statistic resulting
from an ordinary one-way analysis of variance on the
absolute deviations from the median.  The <code>hovPlot</code> function
graphs the components of the Brown and Forsyth test statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hovPlot(x, data=NULL, method = "bf",  ## x is a formula
        transpose = TRUE, ...)

## users will normally use the formula above and will not call the
## method directly.
hovPlot.bf(x, group,  ## x is the response variable
           y.name = deparse(substitute(x)),
           group.name = deparse(substitute(group)),
           transpose = TRUE, ...)

## users will normally use the formula above and will not call the
## panel function directly.
panel.hov(..., transpose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hov_+3A_x">x</code></td>
<td>
<p> Formula appropriate for oneway anova in <code>hovPlot</code>.
Response variable in <code>hovPlot.bf</code>.</p>
</td></tr>
<tr><td><code id="plot.hov_+3A_data">data</code></td>
<td>
<p> data.frame</p>
</td></tr>
<tr><td><code id="plot.hov_+3A_method">method</code></td>
<td>
<p>Character string defining method.  At this time the only
recognized method is &quot;bf&quot; for the Brown-Forsyth method.</p>
</td></tr>
<tr><td><code id="plot.hov_+3A_transpose">transpose</code></td>
<td>
<p>Always <code>TRUE</code> in R.
Normally <code>TRUE</code> in S-Plus to force vertical boxplots.</p>
</td></tr>
<tr><td><code id="plot.hov_+3A_group">group</code></td>
<td>
<p> factor. </p>
</td></tr>
<tr><td><code id="plot.hov_+3A_y.name">y.name</code></td>
<td>
<p> name of response variable,
defaults to variable name in formula. </p>
</td></tr>
<tr><td><code id="plot.hov_+3A_group.name">group.name</code></td>
<td>
<p>name of factor, defaults to variable name in formula. </p>
</td></tr>
<tr><td><code id="plot.hov_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"trellis"</code> object with three panels containing boxplots for each
group: The observed data <code>"y"</code>, the data with the median
subtracted <code>"y-med(y)"</code>, and the absolute deviations from the
median <code>"abs(y-med(y))"</code> The Brown and Forsyth test statistic is
the <code class="reqn">F</code> statistic resulting from an ordinary one-way analysis of
variance on the data points in the third panel.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>
<p>Brown, M.~B. and Forsyth, A.~B. (1974).
<em>Robust tests for equality of variances</em>.
<em>Journal of the American Statistical Association</em>, 69:364&ndash;367.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+aov">aov</a></code>,  <code><a href="#topic+hov">hov</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(turkey)

hov(wt.gain ~ diet, data=turkey)
hovPlot(wt.gain ~ diet, data=turkey)
</code></pre>

<hr>
<h2 id='plot.mmc.multicomp'>MMC (Mean&ndash;mean Multiple Comparisons) plot.</h2><span id='topic+plot.mmc.multicomp'></span>

<h3>Description</h3>

<p>MMC (Mean&ndash;mean Multiple Comparisons) plot.  The <code>plot</code> method documented
here is no longer recommended for R; use <code><a href="#topic+mmcplot">mmcplot</a></code> instead.
This method is still necessary for S-Plus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmc.multicomp'
plot(x,
     xlab="contrast value",
     ylab=none$ylabel,
     focus=none$focus,
     main= main.method.phrase,
     main2=main2.method.phrase,
     main.method.phrase=
       paste("multiple comparisons of means of", ylab),
     main2.method.phrase=paste("simultaneous ",
       100*(1-none$alpha),"% confidence limits, ",
       method, " method", sep="" ),
     ry.mmc=TRUE,
     key.x=par()$usr[1]+ diff(par()$usr[1:2])/20,
     key.y=par()$usr[3]+ diff(par()$usr[3:4])/3,
     method=if (is.null(mca)) lmat$method else mca$method,
     print.lmat=(!is.null(lmat)),
     print.mca=(!is.null(mca) &amp;&amp; (!print.lmat)),
     iso.name=TRUE,
     x.offset=0,
     col.mca.signif="red",  col.mca.not.signif="black",
     lty.mca.signif=1,  lty.mca.not.signif=6,
     lwd.mca.signif=1,  lwd.mca.not.signif=1,
     col.lmat.signif="blue", col.lmat.not.signif="black",
     lty.lmat.signif=1, lty.lmat.not.signif=6,
     lwd.lmat.signif=1, lwd.lmat.not.signif=1,
     lty.iso=7, col.iso="darkgray", lwd.iso=1,
     lty.contr0=2, col.contr0="darkgray", lwd.contr0=1,
     decdigits.ybar=2,
     ...
     )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mmc.multicomp_+3A_x">x</code></td>
<td>
<p><code>mmc.multicomp</code> object</p>
</td></tr>
<tr><td><code id="plot.mmc.multicomp_+3A_xlab">xlab</code></td>
<td>
<p><code>"contrast value"</code>.  An alternate <code>""</code> can help
unclutter a figure when several MMC plots are displayed together.</p>
</td></tr>
<tr><td><code id="plot.mmc.multicomp_+3A_ylab">ylab</code></td>
<td>
<p>name of response variable</p>
</td></tr>
<tr><td><code id="plot.mmc.multicomp_+3A_focus">focus</code></td>
<td>
<p>define the factor to compute contrasts of. </p>
</td></tr>
<tr><td><code id="plot.mmc.multicomp_+3A_main">main</code>, <code id="plot.mmc.multicomp_+3A_main2">main2</code></td>
<td>
<p>main and second line of title of plot</p>
</td></tr>
<tr><td><code id="plot.mmc.multicomp_+3A_main.method.phrase">main.method.phrase</code>, <code id="plot.mmc.multicomp_+3A_main2.method.phrase">main2.method.phrase</code></td>
<td>
<p>default expressions for title of plot</p>
</td></tr>
<tr><td><code id="plot.mmc.multicomp_+3A_ry.mmc">ry.mmc</code></td>
<td>
<p>range of values on the y-axis.  It is similar to
<code>par("ylim")</code>, but not the same as additional calculations are
needed to maintain the isomeans grid as a square.</p>
</td></tr>
<tr><td><code id="plot.mmc.multicomp_+3A_key.x">key.x</code>, <code id="plot.mmc.multicomp_+3A_key.y">key.y</code></td>
<td>
<p>location of the key displayed when <code>iso.name=FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.mmc.multicomp_+3A_method">method</code></td>
<td>
<p>method used to construct contrasts and confidence
intervals.  See the <code>type</code> argument to
<code><a href="multcomp.html#topic+glht">glht</a></code> for the list.</p>
</td></tr>
<tr><td><code id="plot.mmc.multicomp_+3A_print.lmat">print.lmat</code></td>
<td>
<p>logical.  If <code>TRUE</code>, then display the
user-specified contrasts.</p>
</td></tr>
<tr><td><code id="plot.mmc.multicomp_+3A_print.mca">print.mca</code></td>
<td>
<p>logical.  If <code>TRUE</code>, then display the
pair-wise contrasts.</p>
</td></tr>
<tr><td><code id="plot.mmc.multicomp_+3A_iso.name">iso.name</code></td>
<td>
<p>logical.  If <code>TRUE</code>, label the isomeans grid with
the factor levels.  If <code>FALSE</code>, label the isomeans grid with
sequential numbers and display a key relating the numbers to the
factor levels.</p>
</td></tr>
<tr><td><code id="plot.mmc.multicomp_+3A_x.offset">x.offset</code></td>
<td>
<p>amount to move the vertical 0 line to the left or
right to reduce overprinting of labels and plotted lines.</p>
</td></tr>
<tr><td><code id="plot.mmc.multicomp_+3A_col.mca.signif">col.mca.signif</code>, <code id="plot.mmc.multicomp_+3A_lty.mca.signif">lty.mca.signif</code>, <code id="plot.mmc.multicomp_+3A_lwd.mca.signif">lwd.mca.signif</code></td>
<td>
<p>color, line type, line width for significant pairwise contrasts.</p>
</td></tr>
<tr><td><code id="plot.mmc.multicomp_+3A_col.mca.not.signif">col.mca.not.signif</code>, <code id="plot.mmc.multicomp_+3A_lty.mca.not.signif">lty.mca.not.signif</code>, <code id="plot.mmc.multicomp_+3A_lwd.mca.not.signif">lwd.mca.not.signif</code></td>
<td>
<p>color, line type, line width for non-significant pairwise contrasts.</p>
</td></tr>
<tr><td><code id="plot.mmc.multicomp_+3A_col.lmat.signif">col.lmat.signif</code>, <code id="plot.mmc.multicomp_+3A_lty.lmat.signif">lty.lmat.signif</code>, <code id="plot.mmc.multicomp_+3A_lwd.lmat.signif">lwd.lmat.signif</code></td>
<td>
<p>color, line type,
line width for significant user-specified contrasts.</p>
</td></tr>
<tr><td><code id="plot.mmc.multicomp_+3A_col.lmat.not.signif">col.lmat.not.signif</code>, <code id="plot.mmc.multicomp_+3A_lty.lmat.not.signif">lty.lmat.not.signif</code>, <code id="plot.mmc.multicomp_+3A_lwd.lmat.not.signif">lwd.lmat.not.signif</code></td>
<td>
<p>color, line type,
line width for non-significant user-specified contrasts.</p>
</td></tr>
<tr><td><code id="plot.mmc.multicomp_+3A_lty.iso">lty.iso</code>, <code id="plot.mmc.multicomp_+3A_col.iso">col.iso</code>, <code id="plot.mmc.multicomp_+3A_lwd.iso">lwd.iso</code></td>
<td>
<p>color, line type,
line width for the isomeans grid.</p>
</td></tr>
<tr><td><code id="plot.mmc.multicomp_+3A_lty.contr0">lty.contr0</code>, <code id="plot.mmc.multicomp_+3A_col.contr0">col.contr0</code>, <code id="plot.mmc.multicomp_+3A_lwd.contr0">lwd.contr0</code></td>
<td>
<p>color, line type,
line width for the vertical contrast=0 line.</p>
</td></tr>
<tr><td><code id="plot.mmc.multicomp_+3A_decdigits.ybar">decdigits.ybar</code></td>
<td>
<p>number of decimal digits in the left-axis labels.</p>
</td></tr>
<tr><td><code id="plot.mmc.multicomp_+3A_...">...</code></td>
<td>
<p>other arguments, currently ignored.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>plot.mmc.multicomp</code> chooses sensible defaults for its many
arguments.  They will often need manual adjustment.  The examples show
several types of adjustments.  We have changed the centering and scaling
to avoid overprinting of label information.  By default the significant
contrasts are shown in a more intense color than the nonsignificant
contrasts.
We have an option to reduce the color intensity of the isomeans grid.
</p>
<p>When there is overprinting of labels (a consequence of level means being
close together), a tiebreaker plot may be needed.  See <code>?MMC</code> for
an example.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>
<p>Heiberger, Richard M. and Holland, Burt (2006).
&quot;Mean&ndash;mean multiple comparison displays for families of linear contrasts.&quot;
<em>Journal of Computational and Graphical Statistics</em>, 15:937&ndash;955.
</p>
<p>Hsu, J. and Peruggia, M. (1994).
&quot;Graphical representations of Tukey's multiple comparison method.&quot;
<em>Journal of Computational and Graphical Statistics</em>, 3:143&ndash;161.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmc">mmc</a></code>, <code><a href="#topic+plotMatchMMC">plotMatchMMC</a></code>, <code><a href="#topic+mmcplot">mmcplot</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(catalystm)
catalystm1.aov &lt;- aov(concent ~ catalyst, data=catalystm)
summary(catalystm1.aov)

## See ?MMC to see why these contrasts are chosen
catalystm.lmat &lt;- cbind("AB-D" =c( 1, 1, 0,-2),
                        "A-B"  =c( 1,-1, 0, 0),
                        "ABD-C"=c( 1, 1,-3, 1))
dimnames(catalystm.lmat)[[1]] &lt;- levels(catalystm$catalyst)


catalystm.mmc &lt;-
if.R(r={mmc(catalystm1.aov, linfct = mcp(catalyst = "Tukey"),
            focus.lmat=catalystm.lmat)}
    ,s={multicomp.mmc(catalystm1.aov, focus.lmat=catalystm.lmat,
                     plot=FALSE)}
)

## Not run: 
## pairwise contrasts, default settings
plot(catalystm.mmc, print.lmat=FALSE)

## End(Not run)

## Centering, scaling, emphasize significant contrasts.
## Needed in R with 7in x 7in default plot window.
## Not needed in S-Plus with 4x3 aspect ratio of plot window.
plot(catalystm.mmc, x.offset=2.1, ry.mmc=c(50,58), print.lmat=FALSE)

## user-specified contrasts
plot(catalystm.mmc, x.offset=2.1, ry.mmc=c(50,58))

## reduce intensity of isomeans grid, number isomeans grid lines
plot(catalystm.mmc, x.offset=2.1, ry.mmc=c(50,58),
     lty.iso=2, col.iso='darkgray', iso.name=FALSE)

## both pairwise contrasts and user-specified contrasts
plot(catalystm.mmc, x.offset=2.1, ry.mmc=c(50,58), lty.iso=2,
     col.iso='darkgray', print.mca=TRUE)

## Not run: 
## newer mmcplot
mmcplot(catalystm.mmc)
mmcplot(catalystm.mmc, type="lmat")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.multicomp'>Multiple comparisons plot that gives independent user control
over the appearance of the significant and not significant comparisons.
</h2><span id='topic+plot.multicomp'></span><span id='topic+plot.multicomp.hh'></span><span id='topic+plot.multicomp.adjusted'></span><span id='topic+plotMatchMMC'></span>

<h3>Description</h3>

<p>Multiple comparisons plot that gives independent user control
over the appearance of the significant and not significant
comparisons.
In R, both <code>plot.multicomp</code> <code>plot.multicomp.hh</code> coerce their argument
to an <code>"glht"</code> object and plots
that with the appropriate <code>plot</code> method.
In R, <code>plot.multicomp.adjusted</code> replaces the bounds
calculated by <code>multcomp:::confint.glht</code> with bounds based on
a common standard error for a set of anova tables that are
partitioned for the simple effects on an analysis conditioned on
the levels of one of the factors.
In S-Plus,
<code>plot.multicomp.hh</code> augments the standard <code>plot.multicomp</code> to
give additional user arguments to control the appearance of the plot.
</p>
<p><code>plotMatchMMC</code> uses the <code>plot.multicomp.hh</code> code.
<code>plotMatchMMC</code> must immediately follow a plot of an
<code>mmc.multicomp</code> object and is applied to either the <code>$mca</code>
or <code>$lmat</code> component of the <code>mmc.multicomp</code> object.
<code>plotMatchMMC</code> is used as a tiebreaker plot for the <code>MMC</code>
plot.  <code>plotMatchMMC</code> matches the horizontal scaling of the
<code>MMC</code> plot and displays the individual contrasts in the same
order as the <code>MMC</code> plot.  See <code><a href="#topic+mmc">mmc</a></code> for examples.
</p>
<p>These functions are no longer recommended.  Use <code><a href="#topic+mmcplot">mmcplot</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multicomp'
plot(x, ...) ## R only

## S3 method for class 'multicomp.hh'
plot(x, ylabel = x$ylabel, href = 0, uniform = TRUE,
           plt.in = c(0.2, 0.9, 0.1, 0.9),
           x.label.adj=1,
           xrange.include=href,
           xlim,
           comparisons.per.page=21,
           col.signif=1, col.not.signif=1,
           lty.signif=4, lty.not.signif=4,
           lwd.signif=1, lwd.not.signif=1,
           ...,
           xlabel.print=TRUE, y.axis.side=2, ylabel.inside=FALSE)

plotMatchMMC(x, ...,
             xlabel.print=FALSE,
             cex.axis=par()$cex.axis,
             col.signif='red', main="",
             ylabel.inside=FALSE,
             y.axis.side=4,
             adjusted=FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.multicomp_+3A_x">x</code></td>
<td>
<p>A <code>"multicomp"</code> object.  <code>plotMatchMMC</code> will also
accept a <code>mmc.multicomp</code> object.  It will use the <code>lmat</code>
component if there is one, otherwise it will use the <code>mca</code> component.</p>
</td></tr>
<tr><td><code id="plot.multicomp_+3A_ylabel">ylabel</code></td>
<td>
<p>Y label on graph.</p>
</td></tr>
<tr><td><code id="plot.multicomp_+3A_y.axis.side">y.axis.side</code></td>
<td>
<p>Y labels are on the left by default when plotting a
<code>"multicomp"</code> object.  We move them to the
right when matching the x-axis of an MMC plot.</p>
</td></tr>
<tr><td><code id="plot.multicomp_+3A_...">...</code></td>
<td>
<p>other arguments to <code>plot.multicomp</code>.</p>
</td></tr>
<tr><td><code id="plot.multicomp_+3A_ylabel.inside">ylabel.inside</code></td>
<td>
<p>Logical value, if <code>FALSE</code> (the default), the
<code>plotMatchMMC</code> right-axis labels are in the margin.  If
<code>TRUE</code>, the right-axis labels are in the figure area.
Setting the argument to
<code>TRUE</code> makes sense when plotting the <code>lmat</code> component of an
<code>mmc.multicomp</code> object.</p>
</td></tr>

<tr><td><code id="plot.multicomp_+3A_href">href</code></td>
<td>
<p>reference line for the intervals. The default is 0. S-Plus only.</p>
</td></tr>
<tr><td><code id="plot.multicomp_+3A_xrange.include">xrange.include</code></td>
<td>
<p><code>xlim</code>
will be extended to include these values. S-Plus only.</p>
</td></tr>
<tr><td><code id="plot.multicomp_+3A_uniform">uniform</code></td>
<td>
<p>S-Plus only.  Logical value, if <code>TRUE</code> and the plots fill
more than one page, the scale will be uniform across pages.</p>
</td></tr>
<tr><td><code id="plot.multicomp_+3A_plt.in">plt.in</code></td>
<td>
<p>S-Plus only.  Value for <code>par("plt")</code> to make better
use of the space on the plotting page.</p>
</td></tr>
<tr><td><code id="plot.multicomp_+3A_x.label.adj">x.label.adj</code></td>
<td>
<p>S-Plus only.  This is the <code>par("adj")</code> applied
to the x-location of the y.labels on the <code>multicomp</code> plot.</p>
</td></tr>
<tr><td><code id="plot.multicomp_+3A_xlim">xlim</code></td>
<td>
<p>x-range of the plot.</p>
</td></tr>
<tr><td><code id="plot.multicomp_+3A_comparisons.per.page">comparisons.per.page</code></td>
<td>
<p>The default S-Plus <code>plot.multicomp</code>
hardwires this to 21, which allows
for all pairwise comparisons of 7 levels taken 2 at a time.
The HH <code>plot.multicomp</code> makes it a variable.
Use it together with <code>plt.in</code> to make better use of the space
on the plot.  S-Plus only.</p>
</td></tr>
<tr><td><code id="plot.multicomp_+3A_lty.signif">lty.signif</code>, <code id="plot.multicomp_+3A_lwd.signif">lwd.signif</code></td>
<td>
<p>Line type, and line width for
significant comparisons. S-Plus only.</p>
</td></tr>
<tr><td><code id="plot.multicomp_+3A_col.signif">col.signif</code></td>
<td>
<p>Color for significant comparisons. S-Plus only for
<code>plot.multicomp</code>.  Both R and S-Plus for <code>plotMatchMMC</code>.</p>
</td></tr>
<tr><td><code id="plot.multicomp_+3A_col.not.signif">col.not.signif</code>, <code id="plot.multicomp_+3A_lty.not.signif">lty.not.signif</code>, <code id="plot.multicomp_+3A_lwd.not.signif">lwd.not.signif</code></td>
<td>
<p>Color, line
type, and line width for non-significant comparisons. S-Plus only.</p>
</td></tr>
<tr><td><code id="plot.multicomp_+3A_xlabel.print">xlabel.print</code></td>
<td>
<p>logical.  When <code>TRUE</code>, the caption under the
plot is printed.  When <code>FALSE</code>, the caption under the plot is not
printed.  It is helpful to set this to <code>FALSE</code> when
the <code>multicomp</code>
plot is used as a tiebreaker plot for the MMC plot.  S-Plus only.</p>
</td></tr>
<tr><td><code id="plot.multicomp_+3A_cex.axis">cex.axis</code></td>
<td>
<p><code>cex</code> for axis ticklabels.</p>
</td></tr>
<tr><td><code id="plot.multicomp_+3A_main">main</code></td>
<td>
<p>Main title for plot.</p>
</td></tr>
<tr><td><code id="plot.multicomp_+3A_adjusted">adjusted</code></td>
<td>
<p>Logical. When <code>TRUE</code>,
<code>HH:::plot.multicomp.adjusted</code> is used to replace the standard
confidence bounds
calculated by <code>multcomp:::confint.glht</code>, with bounds
calculated by <code>as.multicomp.glht</code> with a rescaled critical
value based on rescaling the standard error.  This rescaling is
used to construct a common standard error for a set of anova tables that are
partitioned for the simple effects on an analysis conditioned on
the levels of one of the factors.  See the
<code>clover.commonstrMS.clov.mmc</code> example in file <code>hh("scripts/Ch12-tway.r")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plot.multicomp</code> plots a <code>"multicomp"</code> object.  In S-Plus, this
masks the standard <code>plot.multicomp</code> in order to provide additional
arguments for controlling the appearance.  It defaults to the standard
appearance.  In R, it coerces its argument to a <code>"glht"</code> object and plots
that with the appropriate <code>plot</code> method.
</p>


<h3>Note</h3>

<p>The multiple comparisons calculations in R and S-Plus use
completely different packages.
Multiple comparisons in R are based on <code><a href="multcomp.html#topic+glht">glht</a></code>.
Multiple comparisons in S-Plus are based on <code>multicomp</code>.
</p>
<p>The MMC plot in the HH package is the same in both systems.
The details of getting the plot differ.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>
<p>Heiberger, R. M. and Holland, B. (2006).
&quot;Mean&ndash;mean multiple comparison displays for families of linear contrasts.&quot;
<em>Journal of Computational and Graphical Statistics</em>, 15:937&ndash;955.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmc">mmc</a></code> in both languages,
<code><a href="multcomp.html#topic+glht">glht</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data and ANOVA
data(catalystm)

catalystm1.aov &lt;- aov(concent ~ catalyst, data=catalystm)
summary(catalystm1.aov)

catalystm.mca &lt;-
if.R(r=glht(catalystm1.aov, linfct = mcp(catalyst = "Tukey")),
     s=multicomp(catalystm1.aov, plot=FALSE))
if.R(s=plot(catalystm.mca),
     r=plot(confint(catalystm.mca, calpha=qtukey(.95, 4, 12)/sqrt(2))))
       ## calpha is strongly recommended in R with a large number of levels
       ## See ?MMC for details.
</code></pre>

<hr>
<h2 id='position'>Find or assign the implied position for graphing the levels of a
factor.
A new class &quot;positioned&quot;, which inherits from &quot;ordered&quot; and &quot;factor&quot;,
is defined.</h2><span id='topic+position'></span><span id='topic+position+3C-'></span><span id='topic+is.numeric.positioned'></span><span id='topic+as.numeric.positioned'></span><span id='topic+as.position'></span><span id='topic++5B.positioned'></span><span id='topic+as.positioned'></span><span id='topic+is.positioned'></span><span id='topic+is.na.positioned'></span><span id='topic+positioned'></span><span id='topic+print.positioned'></span><span id='topic+unique.positioned'></span><span id='topic+unpositioned'></span>

<h3>Description</h3>

<p>The default values for plotting a factor <code>x</code> are the integers
<code>1:length(levels(x))</code>.  These functions provide a way of
specifying alternate plotting locations for the levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position(x)

position(x) &lt;- value

## S3 method for class 'positioned'
is.numeric(x, ...)
## S3 method for class 'positioned'
as.numeric(x, ...)
## S3 method for class 'positioned'
x[..., drop=FALSE]
## S3 method for class 'positioned'
is.na(x)
as.positioned(x)
as.position(x)
is.positioned(x)
positioned(x, ..., value)
## S3 method for class 'positioned'
print(x, ...)
## S3 method for class 'positioned'
unique(x, incomparables = FALSE, ...)
unpositioned(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_+3A_x">x</code></td>
<td>
<p>numeric vector or factor</p>
</td></tr>
<tr><td><code id="position_+3A_value">value</code></td>
<td>
<p>numerical values to be
associated with <code>levels(x)</code>.
The <code>length(value)</code> must equal <code>length(levels(as.factor(x)))</code>.</p>
</td></tr>
<tr><td><code id="position_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
<tr><td><code id="position_+3A_drop">drop</code></td>
<td>
<p>See
<code><a href="base.html#topic+Extract">Extract</a></code>.
</p>
</td></tr>
<tr><td><code id="position_+3A_incomparables">incomparables</code></td>
<td>
<p>See
<code><a href="base.html#topic+unique">unique</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>position(x) &lt;- value</code> first forces its argument to be an ordered
factor and then assigns the <code>value</code> to the <code>"position"</code>
attribute of the ordered factor.
The result is assigned class <code>"positioned"</code> and returned.
</p>
<p><code>position(x)</code> returns the position values associated with
<code>levels(x)</code>.  If <code>x</code> is a positioned factor, then
the <code>"position"</code> attribute is returned.
If <code>x</code> is a factor, then the integers
<code>1:length(levels(x))</code> are returned.  For anything else,
<code>as.numeric(x)</code> is returned.
</p>
<p><code>as.position(x)</code> returns a numeric vector the length of the
original vector.  If <code>x</code> inherits from <code>"factor"</code>,
then the values in the vector are the values in
<code>position(x)</code> subscripted by the levels of the factor.
If <code>x</code> is numeric, then <code>x</code> itself is returned.
</p>
<p><code>unpositioned(x)</code> removes the <code>"position"</code> attribute and
removes the <code>"positioned"</code> value from the the <code>class</code> of
the object.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+panel.interaction2wt">panel.interaction2wt</a></code>,
<code><a href="base.html#topic+factor">factor</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ordered with character levels defaults to
## integer position of specified levels
tmp &lt;- ordered(c("mm","cm","m","m","mm","cm"),
               levels=c("mm","cm","m")) ## size order
tmp
as.numeric(tmp)
levels(tmp)
position(tmp)
as.position(tmp)
as.positioned(tmp)
positioned(tmp)
unpositioned(tmp)
unique(tmp)

## position is assigned to ordered in specified order
tmp &lt;- ordered(c("cm","mm","m","m","mm","cm"),
               levels=c("mm","cm","m")) ## size order
levels(tmp)
position(tmp) &lt;- c(-3, -2, 0) ## log10 assigned in size order
tmp
as.numeric(tmp)
levels(tmp)
position(tmp)
as.position(tmp)
as.positioned(tmp)
positioned(tmp)
unpositioned(tmp)
unique(tmp)

## numeric stays numeric
tmp &lt;- c(0.010, 0.001, 1.000, 1.000, 0.001, 0.010)
tmp
as.numeric(tmp)
levels(tmp)
position(tmp)
as.position(tmp)
as.positioned(tmp)
positioned(tmp)
unpositioned(tmp)
unique(tmp)

## factor with numeric levels, position is integer position in size order
tmp &lt;- factor(c(0.010, 0.001, 1.000, 1.000, 0.001, 0.010))
tmp
as.numeric(tmp)
levels(tmp)
position(tmp)
as.position(tmp)
as.positioned(tmp)
positioned(tmp)
unpositioned(tmp)
unique(tmp)

## ordered with numeric levels, position is numeric value in size order
tmp &lt;- ordered(c(0.010, 0.001, 1.000, 1.000, 0.001, 0.010))
tmp
as.numeric(tmp)
levels(tmp)
position(tmp)
as.position(tmp)
as.positioned(tmp)
positioned(tmp)
unpositioned(tmp)
unique(tmp)


## factor with numeric levels
## position is assigned in size order
tmp &lt;- factor(c(0.010, 0.001, 1.000, 1.000, 0.001, 0.010))
levels(tmp)
position(tmp) &lt;- c(-3, -2, 0) ## log10 assigned in size order
tmp
as.numeric(tmp)
levels(tmp)
position(tmp)
as.position(tmp)
as.positioned(tmp)
positioned(tmp)
unpositioned(tmp)
unique(tmp)



## boxplots coded by week
tmp &lt;- data.frame(Y=rnorm(40, rep(c(20,25,15,22), 10), 5),
                  week=ordered(rep(1:4, 10)))
position(tmp$week) &lt;- c(1, 2, 4, 8)

bwplot(Y ~ week, horizontal=FALSE,
       scales=list(x=list(limits=c(0,9),
                          at=position(tmp$week),
                          labels=position(tmp$week))),
       data=tmp, panel=panel.bwplot.intermediate.hh)


#### You probably don't want to use the next two examples.
#### You need to be aware of their behavior.
##
## factor with character levels defaults to
## integer position of sorted levels.
## you probably DON'T want to do this!
tmp &lt;- factor(c("cm","mm","m","m","mm","cm")) ## default alphabetic order
tmp
as.numeric(tmp)
levels(tmp)   ## you probably DON'T want to do this!
position(tmp) ## you probably DON'T want to do this!
as.numeric(tmp)
##
## position is assigned to factor in default alphabetic order.
## you probably DON'T want to do this!
tmp &lt;- factor(c("cm","mm","m","m","mm","cm"))
levels(tmp)
position(tmp) &lt;- c(-3, -2, 0) ## assigned in default alphabetic order
tmp
as.numeric(tmp)
levels(tmp)   ## you probably DON'T want to do this!
position(tmp) ## you probably DON'T want to do this!
as.numeric(tmp)

</code></pre>

<hr>
<h2 id='positioned-class'>Class &quot;positioned&quot;, extends &quot;ordered&quot; to specify the position
for graphing the levels of a factor.</h2><span id='topic+positioned-class'></span>

<h3>Description</h3>

<p>The default values for plotting a factor <code>x</code> are the integers
<code>1:length(levels(x))</code>.  This class and its functions provide a way of
specifying alternate plotting locations for the levels.
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class:
No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code>"ordered"</code>, directly.
Class <code>"factor"</code>, by class &quot;ordered&quot;, distance 2.
Class <code>"oldClass"</code>, by class &quot;ordered&quot;, distance 3.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;positioned&quot; in the signature.
S3-type methods are
<code>"[.positioned"</code>,
<code>as.double.positioned</code>,
<code>as.numeric.positioned</code>,
<code>as.positioned</code>,
<code>is.numeric.positioned</code>,
<code>is.positioned</code>,
<code>positioned</code>,
<code>print.positioned</code>,
<code>unique.positioned</code>.<br />
Although <code>interaction.positioned</code> should be a method, it isn't
because <code>interaction</code> is not a generic and can't easily be made one
since the name <code>interaction.plot</code> conflicts.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+position">position</a></code>.</p>

<hr>
<h2 id='print.latticeresids'>
Print a <code>latticeresids</code> object.
</h2><span id='topic+print.latticeresids'></span>

<h3>Description</h3>

<p>Print a <code>latticeresids</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'latticeresids'
print(x, ...,
           A321.left=0, A321.bottom=0.27,
           A4.left=0, A4.top=0.30,
           position=list(
             A321=c(A321.left,     A321.bottom, 1, 1     ),
             A4  =c(A4.left,       0,           1, A4.top)),
           panel.width=NULL,
           which=1:4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.latticeresids_+3A_x">x</code></td>
<td>

<p>A <code>latticeresids</code> object.
</p>
</td></tr>
<tr><td><code id="print.latticeresids_+3A_a321.left">A321.left</code>, <code id="print.latticeresids_+3A_a321.bottom">A321.bottom</code>, <code id="print.latticeresids_+3A_a4.left">A4.left</code>, <code id="print.latticeresids_+3A_a4.top">A4.top</code>, <code id="print.latticeresids_+3A_position">position</code></td>
<td>

<p>The first three rows are on the same <code>x</code> scale (the scales of
the independent variables).  The arguments
with <code>"A321"</code> in their name are used to construct the
<code>position</code> argument to <code><a href="lattice.html#topic+print.trellis">print.trellis</a></code> for
the first three rows.  The fourth row is on a different <code>x</code>
scale (the scales of each independent variable adjusted for all the
other <code>x</code> variables).
The arguments
with <code>"A4"</code> in their name are used to construct the
<code>position</code> argument to <code><a href="lattice.html#topic+print.trellis">print.trellis</a></code> for
the fourth row.  The two sets of rows {1,2,3} and {4} may have
different
widths for their left axis tick labels.  The arguments
<code>A321.left</code> and <code>A4.left</code> along with absolute dimensions
for <code>panel.width</code> (<code>"cm"</code> or <code>"in"</code>, not <code>"npc"</code>)
can be hand-tailored to make the columns line up precisely.  See the example.
</p>
</td></tr>
<tr><td><code id="print.latticeresids_+3A_panel.width">panel.width</code></td>
<td>
<p>the <code>panel.width</code> argument of
<code><a href="lattice.html#topic+print.trellis">print.trellis</a></code>.
</p>
</td></tr>
<tr><td><code id="print.latticeresids_+3A_which">which</code></td>
<td>
<p>Vector of row numbers which are to be printed.  If not
all four printed, consider adjusting the <code>A321.bottom</code> and
<code>A4.top</code> values.
</p>
</td></tr>
<tr><td><code id="print.latticeresids_+3A_...">...</code></td>
<td>

<p>Other arguments for <code>print</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The four trellis objects, one for each type of plot, are printed as
a single four-row lattice object.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+residual.plots.lattice">residual.plots.lattice</a></code>
</p>

<hr>
<h2 id='print.NormalAndTplot'>Print method for Normal and t plots from NTplot.</h2><span id='topic+print.NormalAndTplot'></span>

<h3>Description</h3>

<p>Print method for Normal and t plots from NTplot.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NormalAndTplot'
print(x, tablesOnPlot=TRUE, plot=TRUE,
                scales=FALSE, prob=FALSE, call=FALSE,
                ..., cex.table=.7, digits=attr(x, "call.list")$digits,
                position.2=.17)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.NormalAndTplot_+3A_x">x</code></td>
<td>
<p>A <code>"NormalAndTplot"</code> object.</p>
</td></tr>
<tr><td><code id="print.NormalAndTplot_+3A_tablesonplot">tablesOnPlot</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, display the tables in
the <code>attr(x, "scales")</code> and <code>attr(x, "prob")</code> on the plot.</p>
</td></tr>
<tr><td><code id="print.NormalAndTplot_+3A_plot">plot</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, display the graph on the plot.</p>
</td></tr>
<tr><td><code id="print.NormalAndTplot_+3A_scales">scales</code>, <code id="print.NormalAndTplot_+3A_prob">prob</code></td>
<td>
<p>Logical. If <code>TRUE</code>, display the specified
attribute on the R Console.</p>
</td></tr>
<tr><td><code id="print.NormalAndTplot_+3A_call">call</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, display an R statement on the R console.</p>
</td></tr>
<tr><td><code id="print.NormalAndTplot_+3A_...">...</code></td>
<td>
<p>Other arguments are ignored.</p>
</td></tr>
<tr><td><code id="print.NormalAndTplot_+3A_cex.table">cex.table</code>, <code id="print.NormalAndTplot_+3A_digits">digits</code></td>
<td>
<p><code>cex</code> and <code>digits</code> for the
<code>tablesOnPlot</code>
display of the <code>attr(x, "scales")</code> and <code>attr(x, "prob")</code> tables.</p>
</td></tr>
<tr><td><code id="print.NormalAndTplot_+3A_position.2">position.2</code></td>
<td>
<p>When <code>tablesOnPlot=TRUE</code>, the graph occupies
the top of the device beginning at <code>position.2</code>.  This is the
second value in the <code>position</code> argument of <code><a href="lattice.html#topic+print.trellis">print.trellis</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The argument is returned invisibly.</p>


<h3>Author(s)</h3>

<p>Richard M. Heiberger (rmh@temple.edu)</p>


<h3>See Also</h3>

<p><code><a href="#topic+NTplot">NTplot</a></code>, <code><a href="#topic+NormalAndTplot">NormalAndTplot</a></code>.</p>

<hr>
<h2 id='print.tsdiagplot'>Print a &quot;tsdiagplot&quot; object.</h2><span id='topic+print.tsdiagplot'></span><span id='topic+print1.tsdiagplot'></span><span id='topic+print2.tsdiagplot'></span>

<h3>Description</h3>

<p>Print a <code>"tsdiagplot"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsdiagplot'
print(x, ..., portrait=FALSE)
print1.tsdiagplot(x)
print2.tsdiagplot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.tsdiagplot_+3A_x">x</code></td>
<td>
<p>a <code>"tsdiagplot"</code> object</p>
</td></tr>
<tr><td><code id="print.tsdiagplot_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code>print</code>.
The only ...\ argument that is used is <code>pages</code>.
If <code>pages</code> is not used or <code>pages==1</code>, then use <code>print1.tsdiagplot</code>.
If <code>pages!=1</code>, then use <code>print2.tsdiagplot</code>.
</p>
</td></tr>
<tr><td><code id="print.tsdiagplot_+3A_portrait">portrait</code></td>
<td>
<p>logical.  If <code>FALSE</code>, arrange the panels for a
landscape orientation (pdf with width=12 inches looks good).
If <code>TRUE</code>, arrange the panels for a
portrait orientation (pdf with height=13 inches looks good).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>"tsdiagplot"</code> object is a collection of several
<code>"trellis"</code> objects.  We provide two options for printing them.
</p>


<h3>Author(s)</h3>

<p>Richard M. Heiberger (rmh@temple.edu)</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsdiagplot">tsdiagplot</a></code></p>

<hr>
<h2 id='print.TwoTrellisColumns'>Print two conformable trellis plots in adjacent columns with user
control of widths.</h2><span id='topic+print.TwoTrellisColumns5'></span><span id='topic+as.TwoTrellisColumns5'></span><span id='topic+leftLabels.trellis'></span><span id='topic+rightLabels.trellis'></span><span id='topic+panelOnly.trellis'></span><span id='topic+mainSubLegend.trellis'></span><span id='topic+emptyRightAxis'></span>

<h3>Description</h3>

<p>Print two conformable trellis plots in adjacent columns with user
control of widths.  Left y tick-labels and left.strip are removed from the
right-hand plot.</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.TwoTrellisColumns5(left,  ## left  is the left trellis object
                      right, ## right is the right trellis object
                      ## Both left and right must have identical
                      ## settings for number and size of vertical panels,
                      ## left-axis labels, number of lines in main, sub, legend.
                      ...,
                      pw=c(.3, .30, .01, .30, .09),
                      px=list(
                        LL=c(0, pwc[1]),
                        LP=pwc[1:2],
                        ML=pwc[2:3],
                        RP=pwc[3:4],
                        RL=pwc[4:5]),
                      pwc=cumsum(pw),
                      strip.left=TRUE,
                      y.tck=c(0,0)
                      )

## S3 method for class 'TwoTrellisColumns5'
print(x, px=attr(x, "px"), ...)

leftLabels.trellis(x)
rightLabels.trellis(x)
panelOnly.trellis(x, strip.left=FALSE, y.tck=0)
mainSubLegend.trellis(x)
emptyRightAxis(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.TwoTrellisColumns_+3A_left">left</code>, <code id="print.TwoTrellisColumns_+3A_right">right</code></td>
<td>
<p>Conformable <code>"trellis"</code> objects.
Both must have the identical settings for number and size of
vertical panels, left-axis labels, number of
lines in main, sub, legend.</p>
</td></tr>
<tr><td><code id="print.TwoTrellisColumns_+3A_x">x</code></td>
<td>
<p><code>"trellis"</code> object.</p>
</td></tr>
<tr><td><code id="print.TwoTrellisColumns_+3A_px">px</code></td>
<td>
<p>These are used <code>x</code>-values used in the position argument
of the <code>print.trellis</code> function.  The default (constructed from
the <code>pw</code> argument) makes the Left and Right panels the same
width and the Middle containing the y-axis is given the remainder.
Overlapping is permitted.  The appearance depends on the width of
the graphics device.</p>
</td></tr>
<tr><td><code id="print.TwoTrellisColumns_+3A_pw">pw</code>, <code id="print.TwoTrellisColumns_+3A_pwc">pwc</code></td>
<td>
<p><code>pw</code> vector of five positive numbers that sum to 1.  These
are the relative widths of the five sections of the result: LeftLabels,
LeftPanel, MainSubLegend, RightPanel, RightLabels.  <code>pwc</code> is
the cumulative sum of <code>pw</code>.
<code>pwc</code> is expanded in the <code>px</code> argument to the <code>x</code> values
used in the <code>position</code> argument of the
<code><a href="lattice.html#topic+print.trellis">print.trellis</a></code> function.
</p>
</td></tr>
<tr><td><code id="print.TwoTrellisColumns_+3A_strip.left">strip.left</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">barchart</a></code>.</p>
</td></tr>
<tr><td><code id="print.TwoTrellisColumns_+3A_y.tck">y.tck</code></td>
<td>
<p>A vector of one or two numeric values.
This will be used as the <code>y</code> <code>tck</code> value
for the right column of panels.  See <code>'tck'</code> in
<code><a href="lattice.html#topic+xyplot">barchart</a></code> for details.</p>
</td></tr>
<tr><td><code id="print.TwoTrellisColumns_+3A_...">...</code></td>
<td>
<p>Other arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.TwoTrellisColumns5</code> constructs a <code>"TwoTrellisColumns5"</code>
object, which is a list of five trellis objects named <code>"LL", "LP",
"ML", "RP", "RL"</code>.  <code>LL</code> is the left labels from the <code>left</code>
input object. <code>LP</code> is the panels from the <code>left</code> input object.
<code>ML</code> is the middle labels from the <code>left</code> object; these are
the <code>main</code> title, <code>sub</code> title, and <code>legend</code>.  <code>RP</code>
is the panels from the <code>right</code> input object.  <code>RL</code> is the
right labels from the <code>right</code> input object.
</p>
<p><code>print.TwoTrellisColumns5</code> is a print method for a
<code>"TwoTrellisColumns5"</code> object.  It takes left-to-right positioning
information from the <code>"px"</code> attribute of its argument <code>x</code> or
from an input argument.  The numbers are used as the <code>"x"</code>
information for the <code>position</code> argument to the <code>print.trellis</code>
method.
</p>
<p><code>emptyLeftAxis,
leftLabels.trellis,
rightLabels.trellis,
panelOnly.trellis,</code><br />
<code>mainSubLegend.trellis,
emptyLeftStrip,
emptyRightAxis</code> are functions which blank out the various components of the trellis
argument and retains their vertical spacing.
</p>


<h3>Value</h3>

<p>A <code>"TwoTrellisColumns5"</code> object, consisting of a list
containing the constructed left, middle, and right trellis objects,
and an attribute containing the <code>px</code> value.</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+likert">likert</a></code> for the details on the motivating example.</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## These are based on the Professional Challenges example in ?likert
data(ProfChal)
levels(ProfChal$Subtable)[6] &lt;- "Prof Recog" ## reduce length of label

## initial ordering of Question factor
PCC &lt;- likert(Question ~ . | Subtable, ProfChal, ylab=NULL,
              rightAxis=TRUE,
              layout=c(1,6),
              strip=FALSE,
              strip.left=strip.custom(bg="gray97"),
              par.strip.text=list(cex=.7),
              scales=list(y=list(relation="free")),
              main="Is your job professionally challenging?")

## initial ordering of Question factor
PCP &lt;- likert(Question ~ . | Subtable, ProfChal, ylab=NULL,
              as.percent=TRUE,
              layout=c(1,6),
              strip=FALSE,
              strip.left=strip.custom(bg="gray97"),
              par.strip.text=list(cex=.7),
              scales=list(y=list(relation="free")),
              main="Is your job professionally challenging?")

## Not run: 
## default equal widths of the two panels
as.TwoTrellisColumns5(PCP, PCC)  ## 11in x 7in

## make left panel twice as wide as right panel
as.TwoTrellisColumns5(PCP, PCC, pw=c(.3, .4, .01, .2, .09))  ## 11in x 7in
##                                   --------------------    ## sum to 1.00

## make left panel twice as wide as right panel, and control position of main and legend
as.TwoTrellisColumns5(PCP, PCC,  ## 11in x 7in
                      px=list(
                        LL=c(.00,  .30),
                        LP=c(.30,  .70),
                        ML=c(.60,  .61),  ## arbitrary,
                                          ## visually center the labels and legend
                        RP=c(.71,  .91),
                        RL=c(.91, 1.00)))

## End(Not run)

## Size that works in default 7x7 window.  7x7 is not recommended for
## this example because most of the space is used for labeling and not
## much for the panels containing the data.  Use the px values for the
## 11x7 illustrated above in the dontrun section.

as.TwoTrellisColumns5(PCP, PCC,  ## 7in x 7in
                      px=list(
                        LL=c(.00,  .50),
                        LP=c(.50,  .70),
                        ML=c(.50,  .51),  ## arbitrary,
                                          ## visually center the labels and legend
                        RP=c(.71,  .87),
                        RL=c(.87, 1.00)))

## Ordering the rows by the lengths of the positive bars and also
## put percents and counts on the same plot.
## The easiest way is to use the LikertPercentCountColumns function:

LikertPercentCountColumns(Question ~ . | Subtable, ProfChal,
                          layout=c(1,6), scales=list(y=list(relation="free")),
                          ylab=NULL, between=list(y=0),
                          strip.left=strip.custom(bg="gray97"), strip=FALSE,
                          par.strip.text=list(cex=.7),
                          positive.order=TRUE,
                          main="Is your job professionally challenging?")

## Not run: 

## Ordering the rows by the lengths of the positive bars and also
## putting percents and counts on the same plot requires coordination.
## The easiest way is to order the original tables of counts by the
## order of the percent plot.

percentPlot &lt;- likert(Question ~ . | Subtable, ProfChal,
                      as.percent=TRUE,
                      layout=c(1,6), scales=list(y=list(relation="free")),
                      ylab=NULL, between=list(y=0),
                      strip.left=strip.custom(bg="gray97"), strip=FALSE,
                      par.strip.text=list(cex=.7),
                      positive.order=TRUE,
                      main="Is your job professionally challenging?")
## percentPlot
pct.order &lt;- percentPlot$y.limits[[1]]

ProfChal2 &lt;- ProfChal
ProfChal2$Question &lt;- factor(ProfChal2$Question, levels=rev(pct.order))

countPlot   &lt;- likert(Question ~ . | Subtable, ProfChal2,
                      layout=c(1,6),
                      rightAxis=TRUE,
                      scales=list(y=list(relation="free"),
                                  x=list(at=c(0, 250, 500))),
                      ylab=NULL, between=list(y=0),
                      strip.left=strip.custom(bg="gray97"), strip=FALSE,
                      par.strip.text=list(cex=.7),
                      main="Is your job professionally challenging?")
## countPlot
levels(ProfChal$Subtable)[6] &lt;-
      "Attitude\ntoward\nProfessional\nRecognition" ## Restore original label

## Size that works in default 7x7 window.  7x7 is not recommended for
## this example because most of the space is used for labeling and not
## much for the panels containing the data.  Use the px values for the
## 11x7 illustrated above in the dontrun section.

as.TwoTrellisColumns5(percentPlot, countPlot,  ## 7in x 7in
                      px=list(
                        LL=c(.00,  .50),
                        LP=c(.50,  .70),
                        ML=c(.50,  .51),  ## arbitrary,
                                          ## visually center the labels and legend
                        RP=c(.71,  .87),
                        RL=c(.87, 1.00)))

## End(Not run)
</code></pre>

<hr>
<h2 id='push.vp.hh'>push and pop a grid viewport, turn clipping off, change scale.</h2><span id='topic+push.vp.hh'></span><span id='topic+pop.vp.hh'></span>

<h3>Description</h3>

<p>push and pop a grid viewport, turn clipping off, change scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>push.vp.hh(scale = 100)
pop.vp.hh()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="push.vp.hh_+3A_scale">scale</code></td>
<td>
<p>argument to the <code><a href="grid.html#topic+unit">unit</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used in <code><a href="#topic+panel.cartesian">panel.cartesian</a></code> to ease labeling the rows
and columns of a scatterplot matrix.
</p>


<h3>Value</h3>

<p>An object of class <code>"unit"</code>.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

 <p><code><a href="grid.html#topic+viewport">viewport</a></code>, <code><a href="grid.html#topic+unit">unit</a></code>,
<code><a href="#topic+panel.cartesian">panel.cartesian</a></code></p>

<hr>
<h2 id='pyramidLikert'>Print a Likert plot as a Population Triangle</h2><span id='topic+pyramidLikert'></span><span id='topic+print.pyramidLikert'></span><span id='topic+as.pyramidLikert'></span>

<h3>Description</h3>

<p>Prints a likert plot in the traditional format for a
population pyramid,
with the Left and Right sides in separate panels, with the x-tick
marks on the left side made positive, and with the y-axis in the Middle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pyramidLikert'
print(x, ...,
                     panel.width=.48,
                     px=list(
                       L=c(0, panel.width),
                       R=c(1-panel.width, 1),
                       M=c(panel.width, 1-panel.width)),
                    keepLegend=(length(x$legend$bottom$args$text) &gt; 2),
                    xlab.top=list(
                      L=list(x$legend$bottom$args$text[1]),
                      R=list(x$legend$bottom$args$text[2]),
                      M=list(x$ylab, just=1)))

as.pyramidLikert(x, ...,
                 panel.width=.48,
                 px=list(
                   L=c(0, panel.width),
                   R=c(1-panel.width, 1),
                   M=c(panel.width, 1-panel.width)),
                 keepLegend=(length(x$legend$bottom$args$text) &gt; 2),
                 xlab.top=list(
                   L=list(x$legend$bottom$args$text[1]),
                   R=list(x$legend$bottom$args$text[2]),
                   M=list(x$ylab, just=1)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pyramidLikert_+3A_x">x</code></td>
<td>
<p>a single-panel <code>'trellis'</code> object.</p>
</td></tr>
<tr><td><code id="pyramidLikert_+3A_...">...</code></td>
<td>
<p>Other arguments are ignored.</p>
</td></tr>
<tr><td><code id="pyramidLikert_+3A_panel.width">panel.width</code></td>
<td>
<p>Numeric scalar between 0 and 0.5. Common width of left and right panels. The default
value .48 value works well for the <code>USAge.table</code> example.
This number is expanded in the <code>px</code> argument to the <code>x</code> values
used in the <code>position</code> argument of the <code><a href="lattice.html#topic+print.trellis">print.trellis</a></code> function.</p>
</td></tr>
<tr><td><code id="pyramidLikert_+3A_px">px</code></td>
<td>
<p><code>x</code> values used in the position argument of the
<code>print.trellis</code> function.
The default makes the Left and Right panels the same width and the
Middle containing the y-axis is given the remainder.
</p>
</td></tr>
<tr><td><code id="pyramidLikert_+3A_keeplegend">keepLegend</code></td>
<td>
<p>If <code>TRUE</code> and <code>x</code> contains a bottom legend,
then it is printed along with
the Middle section containing the y-axis.
If <code>FALSE</code> or there is no bottom legend, then the bottom legend is not printed.</p>
</td></tr>
<tr><td><code id="pyramidLikert_+3A_xlab.top">xlab.top</code></td>
<td>
<p>A vector of three labels.  The default is designed for a
population triangle with two levels (usually, Male on one side and Female
on the other).  The Left and Right labels are taken from the first two labels in
the legend.  The Middle value is the variable name for the y-axis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a print method for population triangles.  It is designed for a
likert plot with one left-side level and one right-side level.
It works for any single-panel <code>"trellis"</code> object, in the sense
that it produces a plot.
</p>


<h3>Value</h3>

<p>The input argument <code>x</code>.</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+likert">likert</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(USAge.table)  ## from latticeExtra
USA79 &lt;- USAge.table[75:1, 2:1, "1979"]/1000000
PL &lt;- plot(as.likert(USA79),
                     main="Population of United States 1979 (ages 0-74)",
                     xlab="Count in Millions",
                     ylab="Age",
                     scales=list(
                       y=list(
                         limits=c(0,77),
                         at=seq(1,76,5),
                         labels=seq(0,75,5),
                         tck=.5))
                        )
PL
as.pyramidLikert(PL)

likert(USAge.table[75:1, 2:1, c("1939","1959","1979")]/1000000,
       main="Population of United States 1939,1959,1979 (ages 0-74)",
       sub="Look for the Baby Boom",
       xlab="Count in Millions",
       ylab="Age",
       scales=list(
         y=list(
           limits=c(0,77),
           at=seq(1,76,5),
           labels=seq(0,75,5),
           tck=.5)),
       strip.left=FALSE, strip=TRUE,
       layout=c(3,1), between=list(x=.5))

## Not run: 
  ## run the shiny app
if (interactive())  shiny::runApp(system.file("shiny/PopulationPyramid", package="HH"))

## End(Not run)

## For additional examples, see demo(PoorChildren, package="HH")

</code></pre>

<hr>
<h2 id='rbind.trellis'>
Extend matrix reshaping functions to trellis objects.
</h2><span id='topic+rbind.trellis'></span><span id='topic+transpose.trellis'></span><span id='topic+transpose'></span><span id='topic+transpose.default'></span><span id='topic+aperm.trellis'></span><span id='topic+cbind.trellis'></span>

<h3>Description</h3>

<p>Extend matrix reshaping functions to trellis objects.
See the details section for comparisons with similar functions in the
<span class="pkg">lattice</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transpose(x)
## S3 method for class 'trellis'
transpose(x)
## Default S3 method:
transpose(x)
## S3 method for class 'trellis'
aperm(a, perm, ...)
## S3 method for class 'trellis'
rbind(..., deparse.level=1,
      combineLimits=TRUE, useOuterStrips=TRUE)
## S3 method for class 'trellis'
cbind(..., deparse.level=1,
      combineLimits=TRUE, useOuterStrips=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind.trellis_+3A_...">...</code>, <code id="rbind.trellis_+3A_x">x</code>, <code id="rbind.trellis_+3A_a">a</code></td>
<td>

<p>A set of <code>trellis</code> objects.
</p>
</td></tr>
<tr><td><code id="rbind.trellis_+3A_perm">perm</code></td>
<td>

<p>Permutation vector, see <code><a href="base.html#topic+aperm">aperm</a></code> for details.
</p>
</td></tr>
<tr><td><code id="rbind.trellis_+3A_combinelimits">combineLimits</code>, <code id="rbind.trellis_+3A_useouterstrips">useOuterStrips</code></td>
<td>
<p>logical.  If <code>TRUE</code> (the
default), use the similarly named <span class="pkg">latticeExtra</span> functions before
returning the result.
</p>
</td></tr>
<tr><td><code id="rbind.trellis_+3A_deparse.level">deparse.level</code></td>
<td>

<p>See <code><a href="base.html#topic+cbind">cbind</a></code> for details.  These functions ignore this
argument and always use the <code>names(list(...))</code>, if non-<code>NULL</code>,
for the labels.
If <code>NULL</code>, then the first <code>length(list(...))</code> uppercase
letters are used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>transpose.trellis</code> tries to capture and modify all potentially relevant
trellis components.  <code>transpose.trellis</code> is more comprehensive
than the similar
<code><a href="lattice.html#topic+update.trellis">t.trellis</a></code> which adjusts only the
<code>perm.cond</code> component.
</p>
<p><code>aperm.trellis</code> does not attempt to check all potentially relevant
trellis components.
It does not adjust <code>layout.heights</code>, <code>layout.widths</code>, or
<code>between</code>
It may show strange axis
positions or strip positions for any non-standard arrangement, for example,
for any trellis object that has already been
through <code>latticeExtra::combineLimits</code>.
</p>


<h3>Value</h3>

<p>trellis object constructed from arguments with new dim and layout.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>Examples</h3>

<pre><code class='language-R'>F &lt;- xyplot((1:15) ~ (1:15) | rep(factor(letters[3:5]), each=5))
G &lt;- xyplot((1:18) ~ (1:18) | rep(factor(letters[3:5]), each=6))
rbind(AAA=F, BBB=G)
cbind(AAA=F, BBB=G)

tmp &lt;- data.frame(y=1:24,
                  x=1:24,
                  a=rep(letters[1:2], each=12),
                  b=rep(letters[3:5], each=4, times=2),
                  c=rep(letters[6:9], times=6))

t3 &lt;- xyplot(y ~ x | c*b*a, data=tmp,
             panel=function(x, y, ...) panel.text(x, y, y),
             scales=list(alternating=FALSE))
## t3
t3u &lt;- update(t3, layout=c(4*3, 2), between=list(x=c(0,0,0,1)), main="t3")
useOuterStripsT2L1(t3u)

## Not run: 
## update(t3, layout=c(24, 1))

t3.321 &lt;- aperm(t3, c(3,2,1))
update(t3.321, main="t3.321", layout=c(6,4), between=list(x=c(0,1))) ## 2*3,4

try(transpose(t3))   ## requires a one- or two-dimensional trellis object.

t3.123 &lt;- aperm(t3, c(1,2,3)) ## identity operation
t3.132 &lt;- aperm(t3, c(1,3,2))
t3.213 &lt;- aperm(t3, c(2,1,3))
t3.231 &lt;- aperm(t3, c(2,3,1))
t3.312 &lt;- aperm(t3, c(3,1,2))
t3.321 &lt;- aperm(t3, c(3,2,1))

u3.123 &lt;- update(t3.123, main="t3.123", layout=c(12,2),
                 between=list(x=c(0,0,0,1))) ## 4*3,2
u3.132 &lt;- update(t3.132, main="t3.132", layout=c(8,3),
                 between=list(x=c(0,0,0,1))) ## 4*2,3
u3.213 &lt;- update(t3.213, main="t3.213", layout=c(3,8),
                 between=list(y=c(0,0,0,1)), par.strip.text=list(cex=.8)) ## 3,4*2
u3.231 &lt;- update(t3.231, main="t3.231", layout=c(6,4),
                 between=list(x=c(0,0,1))) ## 2*3,4
u3.312 &lt;- update(t3.312, main="t3.312", layout=c(2,12),
                 between=list(y=c(0,0,0,1)), par.strip.text=list(cex=.6)) ## 2,3*4
u3.321 &lt;- update(t3.321, main="t3.321", layout=c(6,4),
                 between=list(x=c(0,1))) ## 2*3,4

u5 &lt;- tempfile("u5", fileext = ".pdf")
pdf(u5, width=17, height=22)
print(u3.123, split=c(1,1,2,3), more=TRUE)
print(u3.132, split=c(2,1,2,3), more=TRUE)
print(u3.213, split=c(1,2,2,3), more=TRUE)
print(u3.231, split=c(2,2,2,3), more=TRUE)
print(u3.312, split=c(1,3,2,3), more=TRUE)
print(u3.321, split=c(2,3,2,3), more=FALSE)
dev.off()

try(transpose(t3.123)) ## layout is a matrix, but dim is not.

## End(Not run)

## Not run: 
t2 &lt;- xyplot(y ~ x | b*c, data=tmp,
             panel=function(x, y, ...) panel.text(x, y, y),
             scales=list(alternating=FALSE))
t2

## aperm(t2, 1:2) ## identity

transpose(t2)
aperm(t2, 2:1)

t1a &lt;- xyplot(y ~ x | b, data=tmp[tmp$a=="a",])
t1b &lt;- xyplot(y ~ x | b, data=tmp[tmp$a=="b",])
t1a
t1b

rbind(t1a, t1b)
rbind(AAA=t1a, BBB=t1b)

cbind(t1a, t1b)
cbind(AAA=t1a, BBB=t1b)

## End(Not run)
</code></pre>

<hr>
<h2 id='regr1.plot'>plot x and y,
with optional straight line fit and display of squared residuals</h2><span id='topic+regr1.plot'></span>

<h3>Description</h3>

<p>Plot <code>x</code> and <code>y</code>,
with optional fitted line and display of squared residuals.
By default the least squares line is calculated and used.
Any other straight line
can be specified by placing its coefficients in <code>coef.model</code>.
Any other fitted model can be calculated by specifying the <code>model</code>
argument.
Any other function of one variable can be specified in the
<code>alt.function</code> argument.  At most one of the arguments
<code>model</code>, <code>coef.model</code>, <code>alt.function</code> can be specified.</p>


<h3>Usage</h3>

<pre><code class='language-R'>regr1.plot(x, y,
           model=lm(y~x),
           coef.model,
           alt.function,
           main="put a useful title here",
           xlab=deparse(substitute(x)),
           ylab=deparse(substitute(y)),
           jitter.x=FALSE,
           resid.plot=FALSE,
           points.yhat=TRUE,
           pch=16,
           ..., length.x.set=51,
           x.name,
           pch.yhat=16,
           cex.yhat=par()$cex*.7,
           err=-1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regr1.plot_+3A_x">x</code></td>
<td>
<p>x variable</p>
</td></tr>
<tr><td><code id="regr1.plot_+3A_y">y</code></td>
<td>
<p>y variable</p>
</td></tr>
<tr><td><code id="regr1.plot_+3A_model">model</code></td>
<td>
<p>Defaults to the simple linear model <code>lm(y ~ x)</code>.
Any model object with one <code>x</code>
variable, such as the quadratic <code>lm(y ~ x + I(x^2))</code> can be used.</p>
</td></tr>
<tr><td><code id="regr1.plot_+3A_coef.model">coef.model</code></td>
<td>
<p>Defaults to the coefficients of the <code>model</code>
argument.  Other intercept and slope coefficients for a straight
line (for example, <code>c(3,5)</code>) can be entered to illustrate
the sense in which they are not &quot;least squares&quot;.</p>
</td></tr>
<tr><td><code id="regr1.plot_+3A_alt.function">alt.function</code></td>
<td>
<p>Any function of a single argument can be placed
here.<br />
For example, <code>alt.function=function(x) {3 + 2*x + 3*x^2}</code>.<br />
All coefficients must be specified.</p>
</td></tr>
<tr><td><code id="regr1.plot_+3A_main">main</code>, <code id="regr1.plot_+3A_xlab">xlab</code>, <code id="regr1.plot_+3A_ylab">ylab</code></td>
<td>
<p>arguments to <code>plot</code>.</p>
</td></tr>
<tr><td><code id="regr1.plot_+3A_jitter.x">jitter.x</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the x is jittered before
plotting.  Jittering is often helpful when there are multiple
y-values at the same level of x.</p>
</td></tr>
<tr><td><code id="regr1.plot_+3A_resid.plot">resid.plot</code></td>
<td>
<p>If <code>FALSE</code>, then do not plot the residuals.
If <code>"square"</code>, then call <code>resid.squares</code> to plot the
squared residuals.   If <code>TRUE</code> (or anything else),
then call <code>resid.squares</code> to plot
straight lines for the  residuals.</p>
</td></tr>
<tr><td><code id="regr1.plot_+3A_points.yhat">points.yhat</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the predicted values
are plotted.</p>
</td></tr>
<tr><td><code id="regr1.plot_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
<tr><td><code id="regr1.plot_+3A_length.x.set">length.x.set</code></td>
<td>
<p>number of points used to plot the predicted values.</p>
</td></tr>
<tr><td><code id="regr1.plot_+3A_x.name">x.name</code></td>
<td>
<p>If the <code>model</code> argument used a different name for
the independent variable, you might need to specify it.</p>
</td></tr>
<tr><td><code id="regr1.plot_+3A_pch">pch</code></td>
<td>
<p>Plotting character for the observed points.</p>
</td></tr>
<tr><td><code id="regr1.plot_+3A_pch.yhat">pch.yhat</code></td>
<td>
<p>Plotting character for the fitted points.</p>
</td></tr>
<tr><td><code id="regr1.plot_+3A_cex.yhat">cex.yhat</code></td>
<td>
<p><code>cex</code> for the fitted points.</p>
</td></tr>
<tr><td><code id="regr1.plot_+3A_err">err</code></td>
<td>
<p>The default <code>-1</code> suppresses warnings about out of bound
points.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This plot is designed as a pedagogical example for introductory courses.
When <code>resid.plot=="square"</code>, then we actually see the set of squares
for which the sum of their areas is minimized by the method of &quot;least squares&quot;.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>
<p>Smith, W. and Gonick, L. (1993).
<em>The Cartoon Guide to Statistics</em>.
HarperCollins.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+resid.squares">resid.squares</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hardness)

## linear and quadratic regressions
hardness.lin.lm  &lt;- lm(hardness ~ density,                data=hardness)
hardness.quad.lm &lt;- lm(hardness ~ density + I(density^2), data=hardness)

anova(hardness.quad.lm)  ## quadratic term has very low p-value

par(mfrow=c(1,2))

regr1.plot(hardness$density, hardness$hardness,
           resid.plot="square",
           main="squared residuals for linear fit",
           xlab="density", ylab="hardness",
           points.yhat=FALSE,
           xlim=c(20,95), ylim=c(0,3400))

regr1.plot(hardness$density, hardness$hardness,
           model=hardness.quad.lm,
           resid.plot="square",
           main="squared residuals for quadratic fit",
           xlab="density", ylab="hardness",
           points.yhat=FALSE,
           xlim=c(20,95), ylim=c(0,3400))

par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='regr2.plot'>3D plot of z against x and y,
with regression plane fit and display of squared residuals.</h2><span id='topic+regr2.plot'></span>

<h3>Description</h3>

<p>3D plot of z against x and y,
with regression plane fit and display of squared residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regr2.plot(x, y, z,
           main.in="put a useful title here",
           resid.plot=FALSE,
           plot.base.plane=TRUE,
           plot.back.planes=TRUE,
           plot.base.points=FALSE,
           eye=NULL,                   ## S-Plus
           theta=0, phi=15, r=sqrt(3), ticktype="detailed", ## R
           ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regr2.plot_+3A_x">x</code>, <code id="regr2.plot_+3A_y">y</code>, <code id="regr2.plot_+3A_z">z</code></td>
<td>
<p>See
<code><a href="graphics.html#topic+persp">persp</a></code>.
</p>
</td></tr>
<tr><td><code id="regr2.plot_+3A_main.in">main.in</code></td>
<td>
<p><code>main</code> title for plot.</p>
</td></tr>
<tr><td><code id="regr2.plot_+3A_resid.plot">resid.plot</code></td>
<td>
<p>Argument to <code><a href="#topic+resid.squares">resid.squares</a></code>.</p>
</td></tr>
<tr><td><code id="regr2.plot_+3A_plot.base.plane">plot.base.plane</code>, <code id="regr2.plot_+3A_plot.back.planes">plot.back.planes</code>, <code id="regr2.plot_+3A_plot.base.points">plot.base.points</code></td>
<td>
<p>Should
these items be plotted?</p>
</td></tr>
<tr><td><code id="regr2.plot_+3A_eye">eye</code></td>
<td>
<p>S-Plus only.  See
<code>persp</code>.
</p>
</td></tr>
<tr><td><code id="regr2.plot_+3A_theta">theta</code>, <code id="regr2.plot_+3A_phi">phi</code>, <code id="regr2.plot_+3A_r">r</code>, <code id="regr2.plot_+3A_ticktype">ticktype</code></td>
<td>
<p>R only.  See
<code><a href="graphics.html#topic+persp">persp</a></code>.
</p>
</td></tr>
<tr><td><code id="regr2.plot_+3A_...">...</code></td>
<td>
<p>Other arguments to <code>persp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>&quot;Viewing Transformation&quot; for projecting 3D coordinates (x,y,z)
into the 2D plane.  See <code><a href="graphics.html#topic+persp">persp</a></code> for details.
</p>


<h3>Note</h3>

<p>This plot is designed as a pedagogical example for introductory
courses.  When <code>resid.plot=="square"</code>, then we actually see the
set of squares for which the sum of their areas is minimized by the
method of &quot;least squares&quot;.  The demo called in the examples section
shows the geometry of regression coefficients, the change in predicted
y when x1 is changed one unit holding all other x variables constant.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>
<p>Smith, W. and Gonick, L. (1993).
<em>The Cartoon Guide to Statistics</em>.
HarperCollins.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+resid.squares">resid.squares</a></code>, <code><a href="#topic+regr1.plot">regr1.plot</a></code>, <code><a href="graphics.html#topic+persp">persp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fat)
regr2.plot(fat[,"abdomin"], xlab="abdomin",
           fat[,"biceps"],  ylab="biceps",
           fat[,"bodyfat"], zlab="bodyfat",
           resid.plot="square",
           eye=c(335.5, 115.65, 171.9),   ## used only in S-Plus
           theta=140, phi=35, r=sqrt(15), ## used only in R
           box=is.R(),
           plot.back.planes=FALSE,
           main="Least-squares with two X-variables")

## Not run: 
  demo("regr2", package="HH", ask=FALSE)
  ## run the file manually to see the individual steps.

## End(Not run)
</code></pre>

<hr>
<h2 id='regrresidplot'>
Draw a plot of y vs x from a linear model object, with residuals
indicated by lines or squares.
</h2><span id='topic+regrresidplot'></span><span id='topic+panel.residSquare'></span>

<h3>Description</h3>

<p>Draw a plot of response vector y vs predictor variable x from a linear
model object all of whose predictors are a function of x, with residuals
indicated by lines or squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regrresidplot(x, y, resid.plot = FALSE, fit.line=TRUE,
              lm.object = lm(y ~ x), x.name = names(lm.object$model)[2],
              col = trellis.par.get()$plot.symbol$col,
              col.yhat = NULL, col.fit = "gray80", col.resid = "gray40", ...)

panel.residSquare(x, y, yhat, resid.plot = FALSE, col = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regrresidplot_+3A_x">x</code></td>
<td>

<p>Predictor variable.  Must be a vector or a single column.
</p>
</td></tr>
<tr><td><code id="regrresidplot_+3A_y">y</code></td>
<td>

<p>Response variable.  Must be a vector or a single column.
</p>
</td></tr>
<tr><td><code id="regrresidplot_+3A_yhat">yhat</code></td>
<td>

<p>Predicted value of y based on the model in <code>lm.object</code> over the
<code>xlim</code> range of the plot.
</p>
</td></tr>
<tr><td><code id="regrresidplot_+3A_resid.plot">resid.plot</code></td>
<td>

<p>Logical or character.  Should the residuals from <code>lm.object</code> be
plotted, and how?
Default is <code>FALSE</code>.  Alternatives are <code>TRUE</code> for lines and
<code>"square"</code> for squares.
</p>
</td></tr>
<tr><td><code id="regrresidplot_+3A_fit.line">fit.line</code></td>
<td>

<p>Logical.  Should the fitted regression line from <code>lm.object</code> be plotted?
Default <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="regrresidplot_+3A_lm.object">lm.object</code></td>
<td>

<p>Linear model object of y against some function of x.  The default value
is the simple linear regression of <code>lm(y ~ x)</code>.
</p>
</td></tr>
<tr><td><code id="regrresidplot_+3A_x.name">x.name</code></td>
<td>

<p>Name of $x$-variable to be used in the construction of the fitted values.
</p>
</td></tr>
<tr><td><code id="regrresidplot_+3A_col">col</code></td>
<td>

<p>Color of observed points.
</p>
</td></tr>
<tr><td><code id="regrresidplot_+3A_col.yhat">col.yhat</code></td>
<td>

<p>Color of fitted points.  Default is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="regrresidplot_+3A_col.fit">col.fit</code></td>
<td>

<p>Color of fitted line.
</p>
</td></tr>
<tr><td><code id="regrresidplot_+3A_col.resid">col.resid</code></td>
<td>

<p>Color of residuals, either lines or squares depending on the value of
<code>resid.plot</code>.
</p>
</td></tr>
<tr><td><code id="regrresidplot_+3A_...">...</code></td>
<td>

<p>Additional arguments to the panel functions.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>regrresidplot</code> returns a <code>"trellis"</code> object.
<code>panel.residSquare</code> is a panel function with no useful returned value.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fat)
fat.lm &lt;- lm(bodyfat ~ abdomin, data=fat)

AA &lt;- regrresidplot(fat$abdomin, fat$bodyfat, xlim=c(70,185), ylim=c(0,50))
BB &lt;- regrresidplot(fat$abdomin, fat$bodyfat, xlim=c(70,185), ylim=c(0,50),
                    resid.plot="line")
CC &lt;- regrresidplot(fat$abdomin, fat$bodyfat, xlim=c(70,185), ylim=c(0,50),
                    resid.plot="square")

update(between=list(y=1),
       c("Residuals Not Displayed"=AA,
         "Residual Lines"=BB,
         "Residual Squares"=CC, layout=c(1,3)))
</code></pre>

<hr>
<h2 id='resid.squares'>plot squared residuals in inches to match the y-dimension</h2><span id='topic+resid.squares'></span>

<h3>Description</h3>

<p>plot squared residuals in inches to match the y-dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resid.squares(x, y, y.hat, resid.plot = "square", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resid.squares_+3A_x">x</code></td>
<td>
<p>x values</p>
</td></tr>
<tr><td><code id="resid.squares_+3A_y">y</code></td>
<td>
<p>observed y values</p>
</td></tr>
<tr><td><code id="resid.squares_+3A_y.hat">y.hat</code></td>
<td>
<p>predicted y values</p>
</td></tr>
<tr><td><code id="resid.squares_+3A_resid.plot">resid.plot</code></td>
<td>
<p>If <code>"square"</code>, then plot the
squared residuals.   If <code>TRUE</code> (or anything else),
then plot straight lines for the  residuals.</p>
</td></tr>
<tr><td><code id="resid.squares_+3A_...">...</code></td>
<td>
<p>Other graphics arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal is to get real squares on the screen or paper.
The trick is to play games with the aspect ratio.
We find the number of inches that each vertical residual occupies.
We then find the number of x-units that corresponds to, and plot
a rectangle with height=height in the y-data units and with width=the
number of x-units that we just calculated.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regr1.plot">regr1.plot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hardness)

hardness.lin.lm  &lt;- lm(hardness ~ density, data=hardness)

plot(hardness ~ density, data=hardness, xlim=c(22,73), ylim=c(0,3400))
abline(hardness.lin.lm)
resid.squares(hardness$density, hardness$hardness,
              predict(hardness.lin.lm))

plot(hardness ~ density, data=hardness, xlim=c(22,73), ylim=c(0,3400))
abline(hardness.lin.lm)
resid.squares(hardness$density, hardness$hardness,
              predict(hardness.lin.lm), resid.plot = "line")
</code></pre>

<hr>
<h2 id='residual.plots'>Residual plots for a linear model.</h2><span id='topic+residual.plots'></span>

<h3>Description</h3>

<p>Residual plots for a linear model.  Four sets of plots are produced:
(1) response against each of the predictor variables,
(2) residuals against each of the predictor variables,
(3) partial residuals for each predictor against that predictor
(&quot;partial residuals plots&quot;, and
(4) partial residuals against the residuals of each predictor
regressed on the other predictors (&quot;added variable plots&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residual.plots(lm.object, X=dft$x,
               layout=c(dim(X)[2],1),
               par.strip.text=list(cex=.8),
               scales.cex=.6,
               na.action=na.pass,
               y.relation="free",
               ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residual.plots_+3A_lm.object">lm.object</code></td>
<td>
<p>An object inheriting from <code>"lm"</code>.
It may be necessary for the <code>lm.object</code> to be constructed with
arguments <code>x=TRUE, y=TRUE</code>.</p>
</td></tr>
<tr><td><code id="residual.plots_+3A_x">X</code></td>
<td>
<p>The x matrix of predictor variables used in the linear model
<code>lm.object</code>.</p>
</td></tr>
<tr><td><code id="residual.plots_+3A_layout">layout</code>, <code id="residual.plots_+3A_par.strip.text">par.strip.text</code></td>
<td>
<p>trellis or lattice arguments.</p>
</td></tr>
<tr><td><code id="residual.plots_+3A_scales.cex">scales.cex</code></td>
<td>
<p><code>cex</code> argument forwarded to the scales argument
of <code>xyplot</code>.</p>
</td></tr>
<tr><td><code id="residual.plots_+3A_na.action">na.action</code></td>
<td>
<p>A function to filter missing data.  See <code>lm</code>.</p>
</td></tr>
<tr><td><code id="residual.plots_+3A_y.relation">y.relation</code></td>
<td>
<p>See <code>relation</code> in the discussion of the
<code>scales</code> argument in
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="residual.plots_+3A_...">...</code></td>
<td>
<p>Other arguments for <code>xysplom</code> or <code>xyplot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of four trellis objects, one for each of the four sets of
plots.  The objects are named <code>"y.X"</code>, <code>"res.X"</code>
<code>"pres.X"</code>, <code>"pres.Xj"</code>.  The default &quot;printing&quot; of the
result will produce four pages of plots, one set per page.  They are
often easier to read when all four sets appear as separate rows on one
page (this usually requires an oversize device), or two rows are
printed on each of two pages.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residual.plots.lattice">residual.plots.lattice</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if.R(s={
     longley &lt;- data.frame(longley.x, Employed = longley.y)
     },r={
     data(longley)
     })

longley.lm &lt;- lm( Employed ~ . , data=longley, x=TRUE, y=TRUE)
## 'x=TRUE, y=TRUE' are needed to pass the S-Plus CMD check.
## They may be needed if residual.plots() is inside a nested set of
## function calls.

tmp &lt;- residual.plots(longley.lm)

## print two rows per page
print(tmp[[1]], position=c(0, 0.5, 1, 1.0), more=TRUE)
print(tmp[[2]], position=c(0, 0.0, 1, 0.5), more=FALSE)
print(tmp[[3]], position=c(0, 0.5, 1, 1.0), more=TRUE)
print(tmp[[4]], position=c(0, 0.0, 1, 0.5), more=FALSE)

## print as a single trellis object
ABCD &lt;- do.call(rbind, lapply(tmp, as.vector))
dimnames(ABCD)[[1]] &lt;- dimnames(tmp[[1]])[[1]]
ABCD
</code></pre>

<hr>
<h2 id='residual.plots.lattice'>
Construct four sets of regression plots: Y against X, residuals
against X, partial residuals against X, partial residuals against each
X adjusted for all the other X columns.
</h2><span id='topic+residual.plots.lattice'></span>

<h3>Description</h3>

<p>Construct four sets of regression plots.
Response variable $Y$ against each $X_j$, residuals $e$ against each $X_j$,
partial residuals plots of $e^j$ against each $X_j$, added variable plots
of $e^j$ against the residuals of each $X_j$ adjusted for
the other $X$ columns.
The slopes shown in the panels of both bottom rows are equal to the
regression coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residual.plots.lattice(lm.object, X=dft$x, layout=c(dim(X)[2],1),
                       par.strip.text=list(cex=.8),
                       scales.cex=.6,
                       na.action=na.pass,
                       y.relation="same",
                       ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residual.plots.lattice_+3A_lm.object">lm.object</code></td>
<td>

<p><code>lm.object</code>
</p>
</td></tr>
<tr><td><code id="residual.plots.lattice_+3A_x">X</code></td>
<td>

<p>Identify the variables in each of the x, y, group positions in a formula object.
See <code><a href="#topic+do.formula.trellis.xysplom">do.formula.trellis.xysplom</a></code> for more detail.
</p>
</td></tr>
<tr><td><code id="residual.plots.lattice_+3A_layout">layout</code>, <code id="residual.plots.lattice_+3A_par.strip.text">par.strip.text</code>, <code id="residual.plots.lattice_+3A_...">...</code></td>
<td>

<p><span class="pkg">lattice</span> arguments.  See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="residual.plots.lattice_+3A_scales.cex">scales.cex</code></td>
<td>

<p><code>cex</code> for the <code>scales</code> argument in <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="residual.plots.lattice_+3A_na.action">na.action</code></td>
<td>

<p>See <code><a href="stats.html#topic+na.action">na.action</a></code>.
</p>
</td></tr>
<tr><td><code id="residual.plots.lattice_+3A_y.relation">y.relation</code></td>
<td>

<p><code>relation</code> for the <code>y</code> argument to <code>scales</code> argument in <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"trellis"</code> object.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+residual.plots">residual.plots</a></code>, <code><a href="#topic+print.latticeresids">print.latticeresids</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>     data(longley)
     longley.lm &lt;- lm( Employed ~ . , data=longley, x=TRUE, y=TRUE)
     residual.plots.lattice(longley.lm)

     ## Not run: 
       longleyResid &lt;- tempfile("longleyResid", fileext = ".pdf")
       pdf(longleyResid, height=9, width=14)
       print(residual.plots.lattice(longley.lm, pch=19),
             A4.left=.0125, panel.width=list(5,"cm"))
       dev.off()
     
## End(Not run)
     </code></pre>

<hr>
<h2 id='residVSfitted'>
Draw plots of resid ~ y.hat and sqrt(abs(resid)) ~ y.hat
</h2><span id='topic+residVSfitted'></span><span id='topic+scaleLocation'></span>

<h3>Description</h3>

<p>Draw plots of <code>resid ~ y.hat</code> and <code>sqrt(abs(resid)) ~ y.hat</code>.
This is a pair of <span class="pkg">lattice</span> functions that duplicate the first and third
panels of <code>stats:::plot.lm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residVSfitted(linearmodel, groups = (e &gt;= 0), ...)
scaleLocation(linearmodel, groups = (e &gt;= 0), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residVSfitted_+3A_linearmodel">linearmodel</code></td>
<td>

<p><code>"lm"</code> object.
</p>
</td></tr>
<tr><td><code id="residVSfitted_+3A_groups">groups</code></td>
<td>

<p>This is the standard <code>groups</code> argument for
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
The default value is one symbol and color for positive residuals and a
different symbol and color for negative residuals.
</p>
</td></tr>
<tr><td><code id="residVSfitted_+3A_...">...</code></td>
<td>

<p>Additional arguments to <code>xyplot</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"trellis"</code> object.
</p>


<h3>Author(s)</h3>

<p>Richard M. Heiberger &lt;rmh@temple.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fat)
fat.lm &lt;- lm(bodyfat ~ abdomin, data=fat)

A &lt;- residVSfitted(fat.lm, pch=c(25,24),
                   fill=trellis.par.get("superpose.symbol")$col[1:2])
B &lt;- scaleLocation(fat.lm, pch=c(25,24),
                   fill=trellis.par.get("superpose.symbol")$col[1:2])
BA &lt;- c("Scale-Location"=B,
        "Residuals vs Fitted"=update(A, scales=list(y=list(at=-100, alternating=3))),
        layout=c(1,2))
BA

BAu &lt;-
  update(BA,
         ylab=c(B$ylab, A$ylab),
         ylab.right=c(B$ylab.right, A$ylab.right),
         xlab.top=NULL,
         between=list(y=1),
         par.settings=list(layout.widths=list(ylab.right=6))
         )

C &lt;- diagQQ(fat.lm)

D &lt;- diagplot5new(fat.lm)

print(BAu, split=c(1,1,2,1), more=TRUE)

print(update(c("Normal Q-Q"=C), xlab.top=NULL, strip=TRUE),
      ## split=c(2,1,2,2),
      position=c(.5, .54, 1, 1),  ## .54 is function of device and size
      more=TRUE)

print(update(D, xlab.top=NULL,
             strip=strip.custom(factor.levels=D$xlab.top),
             par.strip.text=list(lines=1.3)),
      ## split=c(2,2,2,2),
      position=c(.5, 0, 1, .57),  ## .57 is function of device and size
      more=FALSE)
## the .54 and .57 work nicely with the default quartz window on Mac OS X.
</code></pre>

<hr>
<h2 id='ResizeEtc'>Display multiple independent trellis objects on the same
coordinated scale.</h2><span id='topic+ResizeEtc'></span>

<h3>Description</h3>

<p>This function is a wrapper for several of the functions in the
<code>latticeExtra</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ResizeEtc(c.list,
           condlevelsName,
           x.same, y.same,
           layout,
           strip=TRUE,
           strip.left=TRUE,
           strip.values, strip.left.values,
           strip.par, strip.left.par,  ## only the second is effective
                                       ## when both are specified
           resize.height, resize.width,
           main,
           ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ResizeEtc_+3A_c.list">c.list</code></td>
<td>
<p>combination of two or more trellis objects
from <code><a href="latticeExtra.html#topic+c.trellis">c.trellis</a></code>.  If <code>c.list</code> has
names, the names will appear in the strips.</p>
</td></tr>
<tr><td><code id="ResizeEtc_+3A_condlevelsname">condlevelsName</code></td>
<td>
<p>Name of the dimname of the items in the <code>c.list</code>.</p>
</td></tr>
<tr><td><code id="ResizeEtc_+3A_x.same">x.same</code>, <code id="ResizeEtc_+3A_y.same">y.same</code></td>
<td>
<p>If <code>TRUE</code>, force all panels to have the same
<code>x.limits</code> or <code>y.limits</code>.</p>
</td></tr>
<tr><td><code id="ResizeEtc_+3A_layout">layout</code></td>
<td>
<p>Standard lattice <code>layout</code> argument.</p>
</td></tr>
<tr><td><code id="ResizeEtc_+3A_strip">strip</code>, <code id="ResizeEtc_+3A_strip.left">strip.left</code></td>
<td>
<p>standard lattice arguments described in <code><a href="lattice.html#topic+xyplot">barchart</a>.</code></p>
</td></tr>
<tr><td><code id="ResizeEtc_+3A_strip.values">strip.values</code>, <code id="ResizeEtc_+3A_strip.left.values">strip.left.values</code></td>
<td>
<p>strip names for the panels.
Only the second is effective when both are specified.</p>
</td></tr>
<tr><td><code id="ResizeEtc_+3A_strip.par">strip.par</code>, <code id="ResizeEtc_+3A_strip.left.par">strip.left.par</code></td>
<td>
<p><code>par.strip.text</code>.
Only the second is effective when both are specified.</p>
</td></tr>
<tr><td><code id="ResizeEtc_+3A_resize.height">resize.height</code>, <code id="ResizeEtc_+3A_resize.width">resize.width</code></td>
<td>
<p><code>h</code> and <code>w</code> arguments to
<code><a href="latticeExtra.html#topic+resizePanels">resizePanels</a></code>.</p>
</td></tr>
<tr><td><code id="ResizeEtc_+3A_main">main</code></td>
<td>
<p>Main title for resulting combined plot.</p>
</td></tr>
<tr><td><code id="ResizeEtc_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="lattice.html#topic+xyplot">barchart</a>.</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"trellis"</code> object combining each of the individual plots in the
<code>c.list</code> argument according to the specifications in the other arguments.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="latticeExtra.html#topic+c.trellis">c.trellis</a></code>, <code><a href="#topic+plot.likert">plot.likert</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the examples in ?HH:::plot.likert

require(grid)
require(lattice)
require(latticeExtra)
require(HH)

## This is the same example as in ?HH:::plot.likert
## Here, it is done with explicit use of ResizeEtc.

data(ProfChal)
tmp &lt;- data.matrix(ProfChal[,1:5])
rownames(tmp) &lt;- ProfChal$Question

AA &lt;- likert(tmp[1,], box.width=unit(.4,"cm"), positive.order=TRUE)
BB &lt;- likert(tmp[2:6,], box.width=unit(.4,"cm"), positive.order=TRUE)
CC &lt;- likert(tmp[7:10,], box.width=unit(.4,"cm"), positive.order=TRUE)
DD &lt;- likert(tmp[11:12,], box.width=unit(.4,"cm"), positive.order=TRUE)
EE &lt;- likert(tmp[13:14,], box.width=unit(.4,"cm"), positive.order=TRUE)
FF &lt;- likert(tmp[15:16,], box.width=unit(.4,"cm"), positive.order=TRUE)

BB

## print(AA, more=TRUE,  split=c(1,1,3,2))
## print(BB, more=TRUE,  split=c(2,1,3,2))
## print(CC, more=TRUE,  split=c(3,1,3,2))
## print(DD, more=TRUE,  split=c(1,2,3,2))
## print(EE, more=TRUE,  split=c(2,2,3,2))
## print(FF, more=FALSE, split=c(3,2,3,2))

ResizeEtc(c.list=c(AA,BB,CC,DD,EE,FF),
          layout=c(1,6), main="Not yet good enough")

Group &lt;- levels(ProfChal$Subtable)

ResizeEtc(c.list=c(AA,BB,CC,DD,EE,FF),
          condlevelsName='Group',
          x.same=TRUE,
          layout=c(1,6),
          strip.left.values=Group,
          strip.left.par=list(cex=.7, lines=5),
          resize.height=c(1,5,4,2,2,2)+.5,
          main=list("Is your job professionally challenging?", x=unit(.65, "npc")))


</code></pre>

<hr>
<h2 id='ResizeEtc.likertPlot'>Display multiple independent trellis objects, representing
likert plots, on the same coordinated scale.
</h2><span id='topic+ResizeEtc.likertPlot'></span>

<h3>Description</h3>

<p>This is a method for <code>ResizeEtc</code> intended for use with
<code>"likert"</code> plots that allows positive values on the
negative side of the axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'likertPlot'
ResizeEtc(c.list,
          x,
          x.pl.nonames,
          horizontal,
          ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ResizeEtc.likertPlot_+3A_c.list">c.list</code></td>
<td>
<p>combination of two or more trellis objects
from <code><a href="latticeExtra.html#topic+c.trellis">c.trellis</a></code>.  If <code>c.list</code> has
names, the names will appear in the strips.</p>
</td></tr>
<tr><td><code id="ResizeEtc.likertPlot_+3A_x">x</code></td>
<td>

<p>List of two-dimensional objects with the same columns.  See
<code><a href="#topic+plot.likert.list">plot.likert.list</a></code> for details.
</p>
</td></tr>
<tr><td><code id="ResizeEtc.likertPlot_+3A_x.pl.nonames">x.pl.nonames</code></td>
<td>

<p>List of <code>"likert"</code> objects corresponding to the items in argument
<code>x</code>.  The items in <code>x.pl.nonames</code> are unnamed.
</p>
</td></tr>
<tr><td><code id="ResizeEtc.likertPlot_+3A_horizontal">horizontal</code></td>
<td>

<p>Standard argument for <code><a href="lattice.html#topic+barchart">barchart</a></code>.
</p>
</td></tr>
<tr><td><code id="ResizeEtc.likertPlot_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="#topic+ResizeEtc">ResizeEtc</a>.</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result is a <code>"trellis"</code> object.  It is essentially the same
object
returned by <code>ResizeEtc</code> with possibly adjusted x tick-labels to put
positive labels on the negative axis.  If <code>horizontal==FALSE</code>,
then the possible adjusted labels are the y tick-labels.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+ResizeEtc">ResizeEtc</a></code>, <code><a href="#topic+likert">likert</a></code>.
</p>

<hr>
<h2 id='rowPcts'>
Row and columns percents
</h2><span id='topic+rowPcts'></span><span id='topic+colPcts'></span>

<h3>Description</h3>

<p>Row and columns percents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowPcts(x, ...)
colPcts(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowPcts_+3A_x">x</code></td>
<td>

<p>numerical matrix
</p>
</td></tr>
<tr><td><code id="rowPcts_+3A_...">...</code></td>
<td>

<p>Additional arguments for <code><a href="Matrix.html#topic+rowSums">rowSums</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Calculate percents by row or column.  The <code>rowSums</code> or
<code>colSums</code> are stored in the <code>Sums</code> attribute of the result.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+rowSums">rowSums</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- matrix(1:12, 3, 4,
              dimnames=list(c("A","B","C"),
                            c(letters[4:7])))
tmp
rowPcts(tmp)
colPcts(tmp)
</code></pre>

<hr>
<h2 id='seqplot'>Time series plot.</h2><span id='topic+seqplot'></span><span id='topic+seqplot.default'></span><span id='topic+seqplot.ts'></span>

<h3>Description</h3>

<p>Time series plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqplot(xts, ...)

## Default S3 method:
seqplot(xts,
        pch.seq=letters,
        groups=as.numeric(cycle(xts)),
        a=NULL, b=NULL, h=NULL, v=NULL,
        ylab=deparse(substitute(xts)),
        xlab="Time",
        lwd=1, lty=c(1,3),
        type="b",
        col=trellis.par.get("superpose.symbol")$col,
        col.line="gray60",
        ...)


## S3 method for class 'ts'
seqplot(xts, pch.seq=letters, groups=as.numeric(cycle(xts)),
        x.at=pretty(time(xts)[groups==min(groups)]),
        x.labels,
        ylab=deparse(substitute(xts)),
        ...)



</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqplot_+3A_xts">xts</code></td>
<td>
<p>Time series</p>
</td></tr>
<tr><td><code id="seqplot_+3A_pch.seq">pch.seq</code></td>
<td>
<p>sequence of <code>pch</code> characters for use with the time
series.  The characters repeat over the cycle of the series.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_groups">groups</code></td>
<td>
<p>Numeric vector used to choose the plotting characters
over cycles.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_a">a</code>, <code id="seqplot_+3A_b">b</code>, <code id="seqplot_+3A_h">h</code>, <code id="seqplot_+3A_v">v</code></td>
<td>
<p>Arguments to <code>panel.abline</code>.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_ylab">ylab</code>, <code id="seqplot_+3A_xlab">xlab</code>, <code id="seqplot_+3A_lwd">lwd</code>, <code id="seqplot_+3A_lty">lty</code>, <code id="seqplot_+3A_type">type</code></td>
<td>
<p> standard trellis arguments.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_x.at">x.at</code>, <code id="seqplot_+3A_x.labels">x.labels</code></td>
<td>
<p>shortcut for <code>scales=list(x=list(at=x.at,
      labels=x.labels))</code></p>
</td></tr>
<tr><td><code id="seqplot_+3A_col">col</code></td>
<td>
<p>Color of dots in sequence plot.  The default is to make the
choose a number of colors to match the frequency of the time series <code>xts</code>.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_col.line">col.line</code></td>
<td>
<p>Color of connecting lines.  The default is <code>"gray60"</code>.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>xyplot</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard M. Heiberger (rmh@temple.edu)</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsacfplots">tsacfplots</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>seqplot(co2)
</code></pre>

<hr>
<h2 id='seqplotForecast'>seqplot with confidence bands for the forecast region.</h2><span id='topic+seqplotForecast'></span>

<h3>Description</h3>

<p><code>seqplot</code> with confidence bands for the forecast region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqplotForecast(xts, forecast, multiplier = 1.96,
                series = deparse(substitute(observed)), ylim,
                CI.percent=round((1-2*(1-pnorm(multiplier)))*100,2),
                main = paste(
                series, " with forecast + ",
                CI.percent, "% CI", sep=""),
                xlab=NULL, ylab=NULL,
                ...) ## x.at, xlim
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqplotForecast_+3A_xts">xts</code></td>
<td>
<p>This is the observed series</p>
</td></tr>
<tr><td><code id="seqplotForecast_+3A_forecast">forecast</code></td>
<td>
<p>forecast values based on the model</p>
</td></tr>
<tr><td><code id="seqplotForecast_+3A_multiplier">multiplier</code></td>
<td>
<p>Half-width of confidence interval in standard normal
units.  Defaults to 1.96.</p>
</td></tr>
<tr><td><code id="seqplotForecast_+3A_ci.percent">CI.percent</code></td>
<td>
<p>Width of confidence band.  Defaults to the standard
normal, two-sided value associated with the multiplier (95 percent
for the default <code>multiplier=1.96</code>).</p>
</td></tr>
<tr><td><code id="seqplotForecast_+3A_series">series</code></td>
<td>
<p>Name of time series will be used to construct the main
title for the plot.</p>
</td></tr>
<tr><td><code id="seqplotForecast_+3A_ylim">ylim</code>, <code id="seqplotForecast_+3A_xlab">xlab</code>, <code id="seqplotForecast_+3A_ylab">ylab</code>, <code id="seqplotForecast_+3A_main">main</code></td>
<td>
<p>standard trellis parameters</p>
</td></tr>
<tr><td><code id="seqplotForecast_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>xyplot</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard M. Heiberger (rmh@temple.edu)</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqplot">seqplot</a></code></p>

<hr>
<h2 id='strip.background0'> Turn off the coloring in the trellis strip labels.  Color 0 is the
background color.</h2><span id='topic+strip.background0'></span>

<h3>Description</h3>

<p>Turn off the coloring in the trellis strip labels.  Color 0 is the
background color.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip.background0()
</code></pre>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>

<hr>
<h2 id='strip.useOuterStrips.first'>
Functions based on strip.default for use with the useOuterScales function.
</h2><span id='topic+strip.useOuterStrips.first'></span><span id='topic+strip.useOuterStrips.last'></span><span id='topic+strip.left.useOuterStrips'></span><span id='topic+strip.top2'></span><span id='topic+strip.top1'></span><span id='topic+strip.left2'></span><span id='topic+strip.left1'></span>

<h3>Description</h3>

<p>Functions based on <code>strip.default</code> for use with the
<code><a href="#topic+useOuterScales">useOuterScales</a></code> function.  See <code>useOuterScales</code> for more
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip.useOuterStrips.first(which.given, which.panel, var.name, ...)
strip.useOuterStrips.last(which.given, which.panel, var.name, ...)
strip.left.useOuterStrips(which.given, which.panel, var.name, ...)
strip.top2(which.given, which.panel, var.name, ...)
strip.top1(which.given, which.panel, var.name, ...)
strip.left2(which.given, which.panel, var.name, ...)
strip.left1(which.given, which.panel, var.name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strip.useOuterStrips.first_+3A_which.given">which.given</code>, <code id="strip.useOuterStrips.first_+3A_which.panel">which.panel</code>, <code id="strip.useOuterStrips.first_+3A_var.name">var.name</code>, <code id="strip.useOuterStrips.first_+3A_...">...</code></td>
<td>

<p>See <code><a href="lattice.html#topic+strip.default">strip.default</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The appropriate function is chosen by specifying arguments to
<code><a href="#topic+useOuterScales">useOuterScales</a></code>.
</p>
<p><code>strip.useOuterStrips.first</code> places strip labels at the top of the
first row of lattice panels.  Used when <code>as.table==TRUE</code>.
</p>
<p><code>strip.useOuterStrips.last</code> places strip labels at the top of the
first row of lattice panels.  Used when <code>as.table==FALSE</code>.
</p>
<p><code>strip.left.useOuterStrips</code> places strip labels at the left of the
first column of lattice panels.
</p>
<p><code>strip.top2</code> places row strip labels at the top of each panel.
</p>
<p><code>strip.top1</code> places column strip labels at the top of each panel.
</p>
<p><code>strip.left2</code> places row strip labels at the left of each panel.
</p>
<p><code>strip.left1</code> places column strip labels at the left of each panel.
</p>


<h3>Value</h3>

<p>See <code><a href="lattice.html#topic+strip.default">strip.default</a></code>.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+useOuterScales">useOuterScales</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples in ?useOuterScales
</code></pre>

<hr>
<h2 id='strip.xysplom'>strip function that is able to place the correlation or regression
coefficient into the strip label.</h2><span id='topic+strip.xysplom'></span>

<h3>Description</h3>

<p>strip function that is able to place the correlation and/or regression
coefficient into the strip label.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip.xysplom(which.given, which.panel, var.name, factor.levels,
 shingle.intervals, par.strip.text = trellis.par.get("add.text"),
 strip.names = c(TRUE, TRUE), style = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strip.xysplom_+3A_which.given">which.given</code>, <code id="strip.xysplom_+3A_which.panel">which.panel</code>, <code id="strip.xysplom_+3A_var.name">var.name</code>, <code id="strip.xysplom_+3A_factor.levels">factor.levels</code>, <code id="strip.xysplom_+3A_shingle.intervals">shingle.intervals</code></td>
<td>
<p>arguments to <code>strip.default</code>.</p>
</td></tr>
<tr><td><code id="strip.xysplom_+3A_par.strip.text">par.strip.text</code>, <code id="strip.xysplom_+3A_strip.names">strip.names</code>, <code id="strip.xysplom_+3A_style">style</code>, <code id="strip.xysplom_+3A_...">...</code></td>
<td>
<p>more arguments to
<code>strip.default</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function looks for the specific factor names
<code>c("corr","beta","corr.beta")</code>.  If it finds them, it goes up the
calling sequence to locate the data for the panel.  Then it calculates
the correlation and/of regression coefficient and inserts the
calculated value(s) as the value for the strip label.  
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+xysplom">xysplom</a></code></p>

<hr>
<h2 id='sufficient'> Calculates the mean, standard deviation, and number of
observations in each group of a data.frame that has one continuous
variable and two factors.
</h2><span id='topic+sufficient'></span>

<h3>Description</h3>

<p>Calculates the mean, standard deviation, and number of
observations in each group of a data.frame that has one continuous
variable and two factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sufficient(x,
           yname = dimnames(x)[[2]][[1]],
           factor.names.keep = dimnames(x)[[2]][-c(1, 2)])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sufficient_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> containing a continuous variable and two factors.</p>
</td></tr>
<tr><td><code id="sufficient_+3A_yname">yname</code></td>
<td>
<p>Character name of response variable.</p>
</td></tr>
<tr><td><code id="sufficient_+3A_factor.names.keep">factor.names.keep</code></td>
<td>
<p>Character vector containing the names of two
factors in the <code>x</code> data.frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame containing five columns and as many rows as are implied by
the crossing of the two factors.  Each row contains the mean in a
column with the name <code>yname</code> and its factor values in columns
named with the name in <code>factor.names.keep</code>.  The standard deviation of
the observations in the group are in the column <code>"sd"</code> and the number
of observations in the group is in the column <code>"nobs"</code>.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+intxplot">intxplot</a></code></p>

<hr>
<h2 id='summary.arma.loop'>summary and print and subscript methods for tsdiagplot and related objects.</h2><span id='topic+summary.arma.loop'></span><span id='topic+summary.arma.loop.list'></span><span id='topic+print.arma.loop'></span><span id='topic+print.arma.loop.list'></span><span id='topic+print.tsacfplots'></span><span id='topic++5B.arma.loop'></span><span id='topic++5B.diag.arma.loop'></span>

<h3>Description</h3>

<p>summary and print and subscript methods for tsdiagplot and related objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'arma.loop'
summary(object, ...)
## S3 method for class 'arma.loop.list'
summary(object, ...)
## S3 method for class 'arma.loop'
print(x, ...)
## S3 method for class 'arma.loop.list'
print(x, ...)
## S3 method for class 'tsacfplots'
print(x,
               ts.pos=c(.00, .00,  .70, 1.00),
               acf.pos=c(.65, .10, 1.00,  .90),
               ...,
               portrait=FALSE,
               ts.pos.portrait=c(0, .3, 1, 1),
               acf.pos.portrait=c(.1, 0, .9, .35))
## S3 method for class 'arma.loop'
x[..., drop = TRUE]
## S3 method for class 'diag.arma.loop'
x[..., drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.arma.loop_+3A_x">x</code>, <code id="summary.arma.loop_+3A_object">object</code></td>
<td>
<p>object to be summarized or printed or subscripted.</p>
</td></tr>
<tr><td><code id="summary.arma.loop_+3A_ts.pos">ts.pos</code>, <code id="summary.arma.loop_+3A_acf.pos">acf.pos</code>, <code id="summary.arma.loop_+3A_ts.pos.portrait">ts.pos.portrait</code>, <code id="summary.arma.loop_+3A_acf.pos.portrait">acf.pos.portrait</code></td>
<td>

<p>Default positions for <code><a href="lattice.html#topic+print.trellis">print.trellis</a></code></p>
</td></tr>
<tr><td><code id="summary.arma.loop_+3A_portrait">portrait</code></td>
<td>
<p>logical.  If <code>FALSE</code>, arrange the panels for a
landscape orientation.
If <code>TRUE</code>, arrange the panels for a
portrait orientation.</p>
</td></tr>
<tr><td><code id="summary.arma.loop_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr></table>
<p>a
</p>
<table>
<tr><td><code id="summary.arma.loop_+3A_drop">drop</code></td>
<td>
<p>See
<code><a href="base.html#topic+Extract">Extract</a></code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard M. Heiberger (rmh@temple.edu)</p>


<h3>See Also</h3>

<p><code><a href="#topic+arma.loop">arma.loop</a></code>, <code><a href="#topic+tsacfplots">tsacfplots</a></code>, <code><a href="#topic+tsdiagplot">tsdiagplot</a></code></p>

<hr>
<h2 id='ToBW.likert'>
Change colors in a likert plot to shades of Black and White.
</h2><span id='topic+ToBW.likert'></span>

<h3>Description</h3>

<p>Change colors in a likert plot to shades of Black and White.  This
function is tailored for a <code><a href="#topic+likert">likert</a></code> plot, an example of a
<code>"trellis"</code> object.  <code>likert</code> is based on
<code><a href="lattice.html#topic+panel.bwplot">panel.bwplot</a></code>.  There are other places in the structure of
a more general <code>"trellis"</code> object where colors are stored.
The specifics for this plot is (1) that the colors for negative values in
the plot are in reverse order and (2) the color for a neutral-position panel appears on
both the positive and negative side.  The default values are for
three items on the negative side, two on the positive side, and no
neutral.
See the examples for an example with a neutral.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ToBW.likert(x,
               colLegendOrder=c("gray70", "gray20", "gray60", "gray75", "gray45"),
##                               ^Ask      Refu      ^Imp    | Impt      Essn
##	       
               colBarchartOrder=colLegendOrder[c(3,2,1,4,5)],
##                               ^Imp      Refu      ^Ask    | Impt      Essn
               columns=5)
## negative colors are in reverse order in the BarchartOrder
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ToBW.likert_+3A_x">x</code></td>
<td>

<p><code>"trellis"</code> object, specifically one constructed by the <code><a href="#topic+likert">likert</a></code> function.
</p>
</td></tr>
<tr><td><code id="ToBW.likert_+3A_collegendorder">colLegendOrder</code></td>
<td>

<p>Revised value of <code>x$legend$bottom$args$rect$col</code>
</p>
</td></tr>
<tr><td><code id="ToBW.likert_+3A_colbarchartorder">colBarchartOrder</code></td>
<td>

<p>Revised value of both <code>x$panel.args.common$col</code>
<code>x$panel.args.common$border</code>.
</p>
</td></tr>
<tr><td><code id="ToBW.likert_+3A_columns">columns</code></td>
<td>

<p>Revised value of <code>x$legend$bottom$args$columns</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"trellis"</code> object, identical to the input object except for the colors.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+likert">likert</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- array(1:20, c(4, 5),
             list(letters[1:4],
                  c("NotAsked","VeryNegative","Negative","Positive","VeryPositive")))
tmp

Ltmp &lt;- likert(tmp, ReferenceZero=3.5, col=c("gray85", likertColor(4)), as.percent=TRUE)
Ltmp

ToBW.likert(Ltmp)

## with neutral

tmp2 &lt;- array(1:20, c(4, 5),
             list(letters[1:4],
                  c("VeryNegative","Negative","Neutral","Positive","VeryPositive")))
tmp2

Ltmp2 &lt;- likert(tmp2, ReferenceZero=3, col=likertColor(5),
                as.percent=TRUE, main="Neutral")
Ltmp2

ToBW.likert(Ltmp2, 
            colLegendOrder=c("gray20", "gray60", "gray85", "gray75", "gray45"),
##                                               Neu|tral 
            colBarchartOrder=c("gray85", "gray60", "gray20",  "gray85", "gray75", "gray45")
##                         Neutral left                        Neutral right
)

update(main="Wrong way to handle neutral",
       ToBW.likert(Ltmp2, 
                   colLegendOrder=c("gray20", "gray60", "gray85", "gray75", "gray45"))
      )

</code></pre>

<hr>
<h2 id='toCQxR'>
Reshape a 3-way array to a 2-way data.frame that can can be used with a
trellis conditioning formula to get the three-way behavior.
Used with likertWeighted().
</h2><span id='topic+toCQxR'></span>

<h3>Description</h3>

<p>Reshape a 3-way array to a 2-way data.frame that can can be used with a
trellis conditioning formula to get the three-way behavior.
Used with <code>likertWeighted()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toCQxR(x, C = 1, R = 2, Q = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toCQxR_+3A_x">x</code></td>
<td>

<p>Three-way array, with dimensions &quot;Classification&quot;, &quot;Responses&quot;,
&quot;Questions&quot; in some order.
</p>
</td></tr>
<tr><td><code id="toCQxR_+3A_c">C</code>, <code id="toCQxR_+3A_r">R</code>, <code id="toCQxR_+3A_q">Q</code></td>
<td>

<p>Integers, one each of 1,2,3; positions of the three dimensions.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame with CQ rows and Q + N columns, where N is either 1 or 2 for
the number of condition variables in the formula for <code><a href="#topic+likertWeighted">likertWeighted</a></code>.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+likertWeighted">likertWeighted</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp3 &lt;- array(1:40, c(4,5,2), list(LETTERS[1:4], LETTERS[5:9], LETTERS[10:11]))
tmp3

toCQxR(tmp3)
</code></pre>

<hr>
<h2 id='tsacfplots'>Coordinated time series and ACF and PCF plots.</h2><span id='topic+tsacfplots'></span><span id='topic+acf.pacf.plot'></span>

<h3>Description</h3>

<p>Coordinated time series and ACF and PCF plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsacfplots(x,
           ylab=deparse(substitute(x)),
           x.name=ylab[[1]],
           main=paste("Series:", x.name),
           lag.at=NULL,
           lag.max=NULL,
           lag.units=NULL,
           lag.0=TRUE,
           ...)

acf.pacf.plot(x,
	      ylab=NULL,
	      series=deparse(substitute(x)),
	      main=paste("ACF and PACF:", series),
	      lag.max,
	      lag.units=frequency(x),
	      lag.at=pretty(apacf$lag),
	      lag.labels=lag.at*lag.units,
              lag.0=TRUE,
              strip=TRUE, strip.left=FALSE,
	      ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsacfplots_+3A_x">x</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="tsacfplots_+3A_ylab">ylab</code>, <code id="tsacfplots_+3A_main">main</code></td>
<td>
<p>standard trellis arguments.</p>
</td></tr>
<tr><td><code id="tsacfplots_+3A_x.name">x.name</code>, <code id="tsacfplots_+3A_series">series</code></td>
<td>
<p>Character string, name for the time series.</p>
</td></tr>
<tr><td><code id="tsacfplots_+3A_lag.at">lag.at</code></td>
<td>
<p>Location of ticks for the acf and pacf plots.</p>
</td></tr>
<tr><td><code id="tsacfplots_+3A_lag.labels">lag.labels</code></td>
<td>
<p>Labels for ticks for the acf and pacf plots.</p>
</td></tr>
<tr><td><code id="tsacfplots_+3A_lag.max">lag.max</code></td>
<td>
<p>Maximum lag used in the acf and pacf plots.</p>
</td></tr>
<tr><td><code id="tsacfplots_+3A_lag.units">lag.units</code></td>
<td>
<p>Units for time series, defaults to <code>frequency(x)</code></p>
</td></tr>
<tr><td><code id="tsacfplots_+3A_lag.0">lag.0</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, then plot the correlation (identically 1)
at lag=0.
If <code>FALSE</code>, do not plot the correlation at lag=0.</p>
</td></tr>
<tr><td><code id="tsacfplots_+3A_strip">strip</code>, <code id="tsacfplots_+3A_strip.left">strip.left</code></td>
<td>
<p>Standard lattice arguments described in
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="tsacfplots_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>seqplot</code> for <code>tsacfplots</code>.
Additional arguments to <code>strip.default</code> for <code>acf.pacf.plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The acf and pacf plots are scaled identically.
</p>


<h3>Value</h3>

<p><code>"tsacfplots"</code> object containing two <code>"trellis"</code> objects.
</p>


<h3>Author(s)</h3>

<p>Richard M. Heiberger (rmh@temple.edu)</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqplot">seqplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>tsacfplots(co2)
acf.pacf.plot(co2)
</code></pre>

<hr>
<h2 id='tsdiagplot'>Times series diagnostic plots for a structured set of
ARIMA models.</h2><span id='topic+tsdiagplot'></span><span id='topic+acfplot'></span><span id='topic+aicsigplot'></span><span id='topic+residplot'></span><span id='topic+gofplot'></span>

<h3>Description</h3>

<p>Times series diagnostic plots for a structured set of ARIMA models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsdiagplot(x,
           p.max=2, q.max=p.max,
           model=c(p.max, 0, q.max), ## S-Plus
           order=c(p.max, 0, q.max), ## R
           lag.max=36, gof.lag=lag.max,
           armas=arma.loop(x, order=order,
               series=deparse(substitute(x)), ...),
           diags=diag.arma.loop(armas, x,
                                lag.max=lag.max,
                                gof.lag=gof.lag),
           ts.diag=rearrange.diag.arma.loop(diags),
           lag.units=ts.diag$tspar["frequency"],
           lag.lim=range(pretty(ts.diag$acf$lag))*lag.units,
           lag.x.at=pretty(ts.diag$acf$lag)*lag.units,
           lag.x.labels={tmp &lt;- lag.x.at
                      tmp[as.integer(tmp)!=tmp] &lt;- ""
                      tmp},
           lag.0=TRUE,
           main, lwd=0,
           ...)

acfplot(rdal, type="acf",
        main=paste("ACF of std.resid:", rdal$series,
                   "   model:",         rdal$model),
        lag.units=rdal$tspar["frequency"],
        lag.lim=range(pretty(rdal[[type]]$lag)*lag.units),
        lag.x.at=pretty(rdal[[type]]$lag)*lag.units,
        lag.x.labels={tmp &lt;- lag.x.at
                      tmp[as.integer(tmp)!=tmp] &lt;- ""
                      tmp},
        lag.0=TRUE,
        xlim=xlim.function(lag.lim/lag.units),
        ...)

aicsigplot(z, z.name=deparse(substitute(z)), series.name="ts",
           model=NULL,
           xlab="", ylab=z.name,
           main=paste(z.name,  series.name, model),
           layout=c(1,2), between=list(x=1,y=1), ...)

residplot(rdal,
          main=paste("std.resid:", rdal$series,
                     "   model:",  rdal$model),
          ...)

gofplot(rdal,
        main=paste("P-value for gof:", rdal$series,
                   "   model:",         rdal$model),
       lag.units=rdal$tspar["frequency"],
        lag.lim=range(pretty(rdal$gof$lag)*lag.units),
        lag.x.at=pretty(rdal$gof$lag)*lag.units,
        lag.x.labels={tmp &lt;- lag.x.at
                      tmp[as.integer(tmp)!=tmp] &lt;- ""
                      tmp},
        xlim=xlim.function(lag.lim/lag.units),
        pch=16, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsdiagplot_+3A_x">x</code></td>
<td>
<p>Time series vector.</p>
</td></tr>
<tr><td><code id="tsdiagplot_+3A_p.max">p.max</code>, <code id="tsdiagplot_+3A_q.max">q.max</code></td>
<td>
<p>Maximum number of AR and MA arguments to use in
the series of ARIMA models.</p>
</td></tr>
<tr><td><code id="tsdiagplot_+3A_model">model</code></td>
<td>
<p>A valid S-Plus <code>model</code> for
<code>arima.mle</code>.
</p>
</td></tr>
<tr><td><code id="tsdiagplot_+3A_order">order</code></td>
<td>
<p>A valid R <code>order</code> for
<code><a href="stats.html#topic+arima">arima</a></code>.
</p>
<p>The additional argument <code>seasonal</code> may also be used.</p>
</td></tr>
<tr><td><code id="tsdiagplot_+3A_lag.max">lag.max</code></td>
<td>
<p>Maximum lag for the acf and pacf plots.</p>
</td></tr>
<tr><td><code id="tsdiagplot_+3A_gof.lag">gof.lag</code></td>
<td>
<p>Maximum lag for the gof plots.</p>
</td></tr>
<tr><td><code id="tsdiagplot_+3A_armas">armas</code></td>
<td>
<p>An <code>arma.loop</code> object.</p>
</td></tr>
<tr><td><code id="tsdiagplot_+3A_diags">diags</code></td>
<td>
<p>An <code>diag.arma.loop</code> object.</p>
</td></tr>
<tr><td><code id="tsdiagplot_+3A_ts.diag">ts.diag</code>, <code id="tsdiagplot_+3A_rdal">rdal</code></td>
<td>
<p>A list constructed as a rearranged <code>diag.arma.loop</code> object.</p>
</td></tr>
<tr><td><code id="tsdiagplot_+3A_lag.units">lag.units</code></td>
<td>
<p>Units for time series, defaults to <code>frequency(x)</code></p>
</td></tr>
<tr><td><code id="tsdiagplot_+3A_lag.lim">lag.lim</code></td>
<td>
<p>scaling for <code>xlim</code> in acf and pacf plots.</p>
</td></tr>
<tr><td><code id="tsdiagplot_+3A_lag.x.at">lag.x.at</code>, <code id="tsdiagplot_+3A_lag.x.labels">lag.x.labels</code></td>
<td>
<p>Location of ticks and labels for the acf and pacf plots.</p>
</td></tr>
<tr><td><code id="tsdiagplot_+3A_lag.0">lag.0</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, then plot the correlation (identically 1)
at lag=0.
If <code>FALSE</code>, do not plot the correlation at lag=0.</p>
</td></tr>
<tr><td><code id="tsdiagplot_+3A_type">type</code></td>
<td>
<p><code>"acf"</code> or <code>"pacf"</code></p>
</td></tr>
<tr><td><code id="tsdiagplot_+3A_z">z</code></td>
<td>
<p>A matrix constructed as the <code>aic</code> or <code>sigma2</code> component of the
sumamry of a  <code>arma.loop</code> object.</p>
</td></tr>
<tr><td><code id="tsdiagplot_+3A_z.name">z.name</code></td>
<td>
<p><code>"aic"</code> or <code>"sigma2"</code></p>
</td></tr>
<tr><td><code id="tsdiagplot_+3A_series.name">series.name</code></td>
<td>
<p>Character string describing the time series.</p>
</td></tr>
<tr><td><code id="tsdiagplot_+3A_xlab">xlab</code>, <code id="tsdiagplot_+3A_ylab">ylab</code>, <code id="tsdiagplot_+3A_layout">layout</code>, <code id="tsdiagplot_+3A_between">between</code>, <code id="tsdiagplot_+3A_pch">pch</code>, <code id="tsdiagplot_+3A_xlim">xlim</code>, <code id="tsdiagplot_+3A_main">main</code>, <code id="tsdiagplot_+3A_lwd">lwd</code></td>
<td>
<p>Standard
trellis arguments.</p>
</td></tr>
<tr><td><code id="tsdiagplot_+3A_...">...</code></td>
<td>
<p>Additional arguments.  <code>tsdiagplot</code> sends them to
<code>arima</code> or <code>arima.mle</code>.  <code>acfplot</code>,
<code>aicsigplot</code> <code>residplot</code>, and <code>gofplot</code> send them to <code>xyplot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tsdiagplot</code> returns a <code>"tsdiagplot"</code> object which is
a list of <code>"trellis"</code> objects.  It is printed with its own
print method.
</p>
<p>The other functions return <code>"trellis"</code> objects.
</p>


<h3>Author(s)</h3>

<p>Richard M. Heiberger (rmh@temple.edu)</p>


<h3>References</h3>

<p>&quot;Displays for Direct Comparison of ARIMA Models&quot;
The American Statistician, May 2002, Vol. 56, No. 2, pp. 131-138.
Richard M. Heiberger, Temple University, and
Paulo Teles, Faculdade de Economia do Porto.
</p>
<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsacfplots">tsacfplots</a></code>, <code><a href="#topic+arma.loop">arma.loop</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tser.mystery.X)
X &lt;- tser.mystery.X

X.dataplot &lt;- tsacfplots(X, lwd=1, pch.seq=16, cex=.7)
X.dataplot

X.loop &lt;- if.R(
               s=
               arma.loop(X, model=list(order=c(2,0,2)))
               ,r=
               arma.loop(X, order=c(2,0,2))
               )
X.dal &lt;- diag.arma.loop(X.loop, x=X)
X.diag &lt;- rearrange.diag.arma.loop(X.dal)
X.diagplot &lt;- tsdiagplot(armas=X.loop, ts.diag=X.diag, lwd=1)
X.diagplot

X.loop
X.loop[["1","1"]]
</code></pre>

<hr>
<h2 id='useOuterScales'> Put scales for axes only on the bottom and left panels of a
lattice display, and give fine control over the placement of strips
</h2><span id='topic+useOuterScales'></span>

<h3>Description</h3>

<p>Update a multi-panel &quot;trellis&quot; object so that scales for axes are
displayed only on the bottom and left boundaries when printed, instead
of in every panel as is usual.  This function succeeds even when xlim
across columns and ylim across rows are not identical.  Multiple options
are available for strip labels.  The default for strip labels is similar
to <code><a href="latticeExtra.html#topic+useOuterStrips">useOuterStrips</a></code>.  Additional options
include outerStrips for each panel and interchanged row and column strip
locations.  This is only meaningful when there are exactly two
conditioning variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>useOuterScales(x,
           axis.xlab.padding=4,
           ylab.axis.padding=3,
           strip,
           strip.left,
           layout.widths.strip.left=.5,
           layout.heights.strip=.5,
           x.ticks=is.numeric(x$x.limits),
           y.ticks= is.numeric(x$y.limits) +
             if (!missing(strip.left) &amp;&amp;   ## FALSE
                 is.logical(strip.left) &amp;&amp; ## explicitly stated
                 !strip.left ) 0
             else 2.5,
           inner=FALSE,
           interchangeRC=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="useOuterScales_+3A_x">x</code></td>
<td>

<p>An object of class <code>"trellis"</code>
</p>
</td></tr>
<tr><td><code id="useOuterScales_+3A_ylab.axis.padding">ylab.axis.padding</code>, <code id="useOuterScales_+3A_axis.xlab.padding">axis.xlab.padding</code>, <code id="useOuterScales_+3A_layout.heights.strip">layout.heights.strip</code>, <code id="useOuterScales_+3A_layout.widths.strip.left">layout.widths.strip.left</code></td>
<td>

<p>These values are passed to the <code>par.settings</code>:
</p>
<pre>
    layout.widths=list(ylab.axis.padding=ylab.axis.padding,
                       strip.left=layout.widths.strip.left),
    layout.heights=list(axis.xlab.padding=axis.xlab.padding,
                        strip=layout.heights.strip)
</pre>
<p>See <code><a href="lattice.html#topic+trellis.par.get">trellis.par.get</a></code>, and the <code>par.settings</code> section of
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="useOuterScales_+3A_strip">strip</code>, <code id="useOuterScales_+3A_strip.left">strip.left</code></td>
<td>

<p><code>useOuterScales</code> controls the strip labels by assigning appropriate
functions for these two arguments.  The functions used by
<code>useOuterScales</code> are described in
<code><a href="#topic+strip.useOuterStrips.first">strip.useOuterStrips.first</a></code>.  <code>useOuterScales</code> uses
the values of its <code>strip</code>, <code>strip.left</code>, <code>inner</code>,
<code>interchangeRC</code>, and <code>x$as.table</code> arguments to determine which
functions to assign.  The default values place the columns strip labels
at the top of the top row of panels and the row strip labels at the left
of the left column of panels.  See the Examples section for the full set of
possibilities that are provided.
</p>
</td></tr>
<tr><td><code id="useOuterScales_+3A_x.ticks">x.ticks</code>, <code id="useOuterScales_+3A_y.ticks">y.ticks</code></td>
<td>

<p><code>x.ticks</code> is used as the <code>ticks</code> argument to
<code><a href="lattice.html#topic+panel.axis">panel.axis</a></code> for the <code>"bottom"</code> axis.  <code>y.ticks</code>
is used as the <code>ticks</code> argument to <code><a href="lattice.html#topic+panel.axis">panel.axis</a></code> for the
<code>"left"</code> axis.  <code>y.ticks</code> needs to be larger when the left
strip is present because the tick and label
are partially overwritten by the left strip.  When the
<code>left.strip=FALSE</code>, then we need to make the <code>y.ticks</code> smaller.
</p>
</td></tr>
<tr><td><code id="useOuterScales_+3A_inner">inner</code></td>
<td>

<p>Logical with default <code>FALSE</code>, meaning that the strip labels are
displayed only on the top row and left column of the array of
panels. When <code>TRUE</code>, the strip labels are displayed on the top and
left of every panel.
</p>
</td></tr>
<tr><td><code id="useOuterScales_+3A_interchangerc">interchangeRC</code></td>
<td>

<p>Logical with default <code>FALSE</code>.  When <code>TRUE</code>, the column labels
appear on the left strip of the panels, and the row labels appear on
the top of the panels.  <code>TRUE</code> is only meaningful when <code>inner=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>useOuterScales</code> modifies a <code>"trellis"</code> object with
<code>length(dim(x)) == 2</code> so that when plotted,
scales appear on only the top and left panels of the array of panels.
Strips appear as specified, by default
on the top and left boundaries of the panel layout.
</p>
<p>If the original <code>"trellis"</code> object <code>x</code> includes non-default
<code>strip</code> and <code>strip.left</code> arguments, they will be ignored.  To
provide customized strip behaviour, specify the custom strip
functions directly as arguments to <code>useOuterStrips</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>; essentially the same as <code>x</code>, but
with certain properties modified.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>See Also</h3>

<p><code><a href="latticeExtra.html#topic+useOuterStrips">useOuterStrips</a></code>, <code><a href="lattice.html#topic+strip.default">strip.default</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>OuterScalesData &lt;- data.frame(y=1:16,
                              AA=rep(factor(letters[1:8]), 2),
                              BB=rep(factor(LETTERS[12:13]), each=8),
                              CC=rep(factor(rep(LETTERS[9:11], times=c(3,1,4))), 2))
OuterScalesData

BC0 &lt;- barchart(AA ~ y | BB * CC, data=OuterScalesData,
               origin=0,
               scales=list(x=list(limits=c(0,16.5)),
                           y=list(relation="free")),
               between=list(x=1, y=1),
               main="0. barchart")
## Not run: 
BC0

## End(Not run)
BC1 &lt;- update(
  resizePanels(BC0, h=c(3,1,4)),
  main="1. resizePanels")
BC1

BC2 &lt;- update(
  useOuterStrips(BC1),
  main="2. useOuterStrips") ## package:latticeExtra
BC2

BC3 &lt;- update(
  useOuterScales(BC1),
  main="3. useOuterScales")
BC3

## Not run: 
BC4 &lt;- update(
  useOuterScales(BC1),
  ylab="ABC",
  main="4. useOuterScales, ylab")
BC4

BC5 &lt;- update(
  useOuterScales(update(BC1, as.table=TRUE)),
  main="5. useOuterScales, as.table")
BC5

try(useOuterScales(BC1, interchangeRC=TRUE)) ## incompatible options

## End(Not run)

BC6 &lt;- update(
  useOuterScales(BC1, inner=TRUE),
  main="6. useOuterScales, inner")
BC6

## Not run: 
BC7 &lt;- update(
  useOuterScales(BC1, inner=TRUE, interchangeRC=TRUE),
  main="7. useOuterScales, inner, interchangeRC")
BC7

BC8 &lt;- update(
  useOuterScales(BC1, strip=FALSE),
  xlab.top=c("L","M"),
  main="8. useOuterScales, strip=FALSE, xlab.top")
BC8

BC9 &lt;- update(
  useOuterScales(BC1, strip=strip.default),
  main="9. useOuterScales, strip=strip.default")
BC9

try(print(useOuterScales(BC1, strip=date))) ## date is not a valid strip function

BC10 &lt;- update(
  useOuterScales(BC1, strip.left=FALSE),
  ylab=c("I","J","K"),
  main="10. useOuterScales, strip.left=FALSE, ylab")
BC10

BC11 &lt;- update(
  useOuterScales(BC1, strip.left=strip.default),
  main="11. useOuterScales, strip.left=strip.default")
BC11

try(print(useOuterScales(BC1, strip.left=date))) ## date is not a valid strip function

BC12 &lt;- update(
  useOuterScales(BC1,
                 inner=TRUE, interchangeRC=TRUE, strip.left=FALSE),
  xlab.top=c("L","M"),
  main=
"12. useOuterScales, inner, \n interchangeRC=TRUE, strip.left=FALSE, \n xlab.top, strip.background",
  par.settings=list(strip.background=list(col="gray98")))
BC12

BC13 &lt;- update(
  useOuterScales(update(BC1, as.table=TRUE),
                 inner=TRUE, interchangeRC=TRUE, strip.left=FALSE),
  xlab.top=c("L","M"),
  main="13. useOuterScales, inner, \n interchangeRC=TRUE, strip.left=FALSE, \n xlab.top, as.table")
BC13

BC14 &lt;- update(
  useOuterScales(BC1,
                 inner=TRUE, strip=FALSE, interchangeRC=TRUE),
  ylab=list(c("I","J","K"), rot=0),
  main="14. useOuterScales, inner, \n strip=FALSE, interchangeRC, \n ylab")
BC14

BC15 &lt;- update(
  useOuterScales(BC1,
                 strip=FALSE, strip.left=FALSE),
  xlab.top=c("L","M"), ylab=list(c("I","J","K"), rot=0),
  main="15. useOuterScales, strip=FALSE, strip.left=FALSE, \n xlab, ylab")
BC15

## End(Not run)

## Not run:  ## display 16 options for strip labels with outerScales
useOuterScales16 &lt;- tempfile("useOuterScales16", fileext = ".pdf")
pdf(useOuterScales16, height=16, width=21)
print(BC0,  split=c(1,1,4,4), more=TRUE)
print(BC1,  split=c(2,1,4,4), more=TRUE)
print(BC2,  split=c(3,1,4,4), more=TRUE)
print(BC3,  split=c(4,1,4,4), more=TRUE)
print(BC4,  split=c(1,2,4,4), more=TRUE)
print(BC5,  split=c(2,2,4,4), more=TRUE)
print(BC6,  split=c(3,2,4,4), more=TRUE)
print(BC7,  split=c(4,2,4,4), more=TRUE)
print(BC8,  split=c(1,3,4,4), more=TRUE)
print(BC9,  split=c(2,3,4,4), more=TRUE)
print(BC10, split=c(3,3,4,4), more=TRUE)
print(BC11, split=c(4,3,4,4), more=TRUE)
print(BC12, split=c(1,4,4,4), more=TRUE)
print(BC13, split=c(2,4,4,4), more=TRUE)
print(BC14, split=c(3,4,4,4), more=TRUE)
print(BC15, split=c(4,4,4,4), more=FALSE)
dev.off()

## End(Not run)


## Not run: 
## Verify y.ticks default value depends on
##  is.numeric(x$y.limits).
##  and on whether strip.left=FALSE

CB0 &lt;- barchart(y ~ AA | CC * BB, data=OuterScalesData,
                origin=0,
                scales=list(y=list(limits=c(0,16.5)),
                            x=list(relation="free")),
                between=list(x=1, y=1),
                main="CB0. barchart")
CB0

CB1 &lt;- update(
  resizePanels(CB0, w=c(3,1,4)),
  main="CB1. resizePanels")
CB1

CB2 &lt;- update(
  useOuterStrips(CB1),
  main="CB2. useOuterStrips") ## package:latticeExtra
CB2

CB3 &lt;- update(
  useOuterScales(CB1),
  main="CB3. useOuterScales, y.limits is numeric")
CB3

CB4 &lt;- update(
  useOuterScales(CB1, strip.left=FALSE),
  main="CB4. useOuterScales, y.limits is numeric, strip.left=FALSE")
CB4

BC16 &lt;- update(
  useOuterScales(BC1),
  main="BC16. useOuterScales, y.limits is not numeric")
BC16

BC17 &lt;- update(
  useOuterScales(BC1, strip.left=FALSE),
  main="BC17. useOuterScales, y.limits is not numeric, strip.left=FALSE")
BC17


## End(Not run)

## Not run: 
## Verify x.ticks default value depends on
##  is.numeric(x$x.limits).

update(BC3, main="BC3. useOuterScales, x.limits is numeric")

update(CB3, main="CB3. useOuterScales, x.limits is not numeric")


## End(Not run)

</code></pre>

<hr>
<h2 id='useOuterStripsT2L1'>Three-factor generalization of latticeExtra::useOuterStrips</h2><span id='topic+useOuterStripsT2L1'></span>

<h3>Description</h3>

<p>Three-factor generalization of <code>latticeExtra::useOuterStrips</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>useOuterStripsT2L1(x, ..., strip.height=.4, strip.names=c(TRUE, TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="useOuterStripsT2L1_+3A_x">x</code></td>
<td>
<p>A <code>lattice</code> object with <code>dim(x)==3</code>.</p>
</td></tr>
<tr><td><code id="useOuterStripsT2L1_+3A_...">...</code></td>
<td>
<p>Additional arguments to be forwarded to the
<code><a href="lattice.html#topic+strip.default">strip.default</a></code> function.</p>
</td></tr>
<tr><td><code id="useOuterStripsT2L1_+3A_strip.height">strip.height</code></td>
<td>
<p>Height of each the strip for each factor.  The
number of factors in the top and left strips may not be the same.
This argument is multiplied by the number of factors in each
location
and sent on to the <span class="pkg">lattice</span> <code>par.settings</code> argument for the
<code>layout.widths$strip.left</code> and <code>layout.heights$strip</code>
components.
</p>
</td></tr>
<tr><td><code id="useOuterStripsT2L1_+3A_strip.names">strip.names</code></td>
<td>
<p>See <code><a href="lattice.html#topic+strip.default">strip.default</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>trellis</code> object with two factors in the top <code>strip</code> and 1
factor in the <code>strip.left</code>.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- data.frame(A=rep(factor(letters[1:2]), each=12),
                  B=rep(factor(letters[3:5]), each=4, times=2),
                  C=rep(factor(letters[6:9]), times=6),
                  x=1:24,
                  y=1:24)

F &lt;- xyplot(y ~ x | B*A*C, data=tmp,
            panel=function(x, y, labels, ...) {
              panel.text(x, y, matrix(1:24, 6, 4, byrow=TRUE)[panel.number()], ...)
            },
            layout=c(6, 4), between=list(x=c(.5, .5, 1.5), y=1))
F

useOuterStripsT2L1(F)

</code></pre>

<hr>
<h2 id='vif'> Calculate the Variance Inflation Factor </h2><span id='topic+vif'></span><span id='topic+vif.default'></span><span id='topic+vif.formula'></span><span id='topic+vif.lm'></span>

<h3>Description</h3>

<p>The VIF for predictor <code class="reqn">i</code> is <code class="reqn">1/(1-R_i^2)</code>, where <code class="reqn">R_i^2</code> is the
<code class="reqn">R^2</code> from a regression of predictor <code class="reqn">i</code> against the remaining
predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vif(xx, ...)

## Default S3 method:
vif(xx, y.name, na.action = na.exclude, ...) ## xx is a data.frame

## S3 method for class 'formula'
vif(xx, data, na.action = na.exclude, ...)   ## xx is a formula

## S3 method for class 'lm'
vif(xx, na.action = na.exclude, ...)  ## xx is a "lm" object computed with x=TRUE
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vif_+3A_xx">xx</code></td>
<td>
<p><code>data.frame</code>, or <code>formula</code>, or <code>lm</code> object
computed with <code>x=TRUE</code>.</p>
</td></tr>
<tr><td><code id="vif_+3A_na.action">na.action</code></td>
<td>
<p>See
<code><a href="stats.html#topic+na.action">na.action</a></code>.
</p>
</td></tr>
<tr><td><code id="vif_+3A_...">...</code></td>
<td>
<p>additional arguments. </p>
</td></tr>
<tr><td><code id="vif_+3A_y.name">y.name</code></td>
<td>
<p>Name of Y-variable to be excluded from the computations.</p>
</td></tr>
<tr><td><code id="vif_+3A_data">data</code></td>
<td>
<p>A data frame in which the variables specified in the
formula will be found. If missing, the variables are searched for in
the standard way. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple diagnostic of collinearity is the
<em>variance inflation factor, VIF</em>
one for each regression coefficient (other than the intercept).
Since the condition of collinearity involves the predictors but not
the response, this measure is a function of the <code class="reqn">X</code>'s but not of <code class="reqn">Y</code>.
The VIF for predictor <code class="reqn">i</code> is <code class="reqn">1/(1-R_i^2)</code>, where <code class="reqn">R_i^2</code> is the
<code class="reqn">R^2</code> from a regression of predictor <code class="reqn">i</code> against the remaining
predictors.  If <code class="reqn">R_i^2</code> is close to 1, this means that predictor <code class="reqn">i</code>
is well explained by a linear function of the remaining predictors,
and, therefore, the presence of predictor <code class="reqn">i</code> in the model is
redundant.  Values of VIF exceeding 5 are considered evidence of
collinearity: The information carried by a predictor having such a VIF
is contained in a subset of the remaining predictors.  If, however,
all of a model's regression coefficients differ significantly from 0
(<code class="reqn">p</code>-value <code class="reqn">&lt;</code> .05), a somewhat larger VIF may be tolerable.
</p>


<h3>Value</h3>

<p>Vector of VIF values, one for each X-variable.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(usair)

usair$lnSO2 &lt;- log(usair$SO2)
usair$lnmfg &lt;- log(usair$mfgfirms)
usair$lnpopn &lt;- log(usair$popn)

usair.lm &lt;- lm(lnSO2 ~ temp + lnmfg + wind + precip, data=usair, x=TRUE)

vif(usair.lm)  ## the lm object must be computed with x=TRUE

vif(lnSO2 ~ temp + lnmfg + wind + precip, data=usair)

vif(usair)

vif(usair, y.name="lnSO2")
</code></pre>

<hr>
<h2 id='X.residuals'> Residuals from the regression of each column of a
data.frame against all the other columns.</h2><span id='topic+X.residuals'></span><span id='topic+X.residuals.default'></span><span id='topic+X.residuals.formula'></span><span id='topic+X.residuals.lm'></span>

<h3>Description</h3>

<p>Calculate the residuals from the regression of each column of a
data.frame against all the other columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>X.residuals(x, ...)

## Default S3 method:
X.residuals(x, y.name, na.action = na.exclude, ...) ## x is a data.frame

## S3 method for class 'formula'
X.residuals(x, data, na.action = na.exclude, ...)   ## x is a formula

## S3 method for class 'lm'
X.residuals(x, na.action = na.exclude, ...)  ## x is a "lm" object computed with x=TRUE
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="X.residuals_+3A_x">x</code></td>
<td>
<p><code>data.frame</code>, or <code>formula</code>, or <code>lm</code> object
computed with <code>x=TRUE</code>.</p>
</td></tr>
<tr><td><code id="X.residuals_+3A_na.action">na.action</code></td>
<td>
<p>See
<code><a href="stats.html#topic+na.action">na.action</a></code>.
</p>
</td></tr>
<tr><td><code id="X.residuals_+3A_...">...</code></td>
<td>
<p>additional arguments. </p>
</td></tr>
<tr><td><code id="X.residuals_+3A_y.name">y.name</code></td>
<td>
<p>Name of Y-variable to be excluded from the computations.</p>
</td></tr>
<tr><td><code id="X.residuals_+3A_data">data</code></td>
<td>
<p>A data frame in which the variables specified in the
formula will be found. If missing, the variables are searched for in
the standard way. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame of residuals, one column from each regression.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>,
</p>
<p><code><a href="#topic+vif">vif</a></code>,
<code><a href="#topic+case.lm">case.lm</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(usair)
usair$lnSO2 &lt;- log(usair$SO2)
usair$lnmfg &lt;- log(usair$mfgfirms)
usair$lnpopn &lt;- log(usair$popn)

usair.lm &lt;- lm(lnSO2 ~ temp + lnmfg + wind + precip, data=usair)

X.residuals(usair.lm)

X.residuals(lnSO2 ~ temp + lnmfg + wind + precip, data=usair)

X.residuals(usair)

X.residuals(usair, y.name="lnSO2")
</code></pre>

<hr>
<h2 id='xysplom'>scatterplot matrix with potentially different sets of variables
on the rows and columns.</h2><span id='topic+xysplom'></span><span id='topic+xysplom.formula'></span><span id='topic+xysplom.default'></span>

<h3>Description</h3>

<p>scatterplot matrix with potentially different sets of variables
on the rows and columns.  The slope or regression coefficient for
simple least squares regression can
be displayed in the strip label for each panel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xysplom(x, ...)

## S3 method for class 'formula'
xysplom(x, data=NULL, na.action = na.pass, ...)

## Default S3 method:
xysplom(x, y=x, group, relation="free",
        x.relation=relation, y.relation=relation,
        xlim.in=NULL, ylim.in=NULL,
        corr=FALSE, beta=FALSE, abline=corr||beta, digits=3,
        x.between=NULL, y.between=NULL,
        between.in=list(x=x.between, y=y.between),
        scales.in=list(
          x=list(relation=x.relation, alternating=FALSE),
          y=list(relation=y.relation, alternating=FALSE)),
        strip.in=strip.xysplom,
        pch=16, cex=.75,
        panel.input=panel.xysplom, ...,
        cartesian=TRUE,
        plot=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xysplom_+3A_x">x</code></td>
<td>
<p>In the <code>"formula"</code> method, a formula.  In the
<code>"default"</code> method, a data.frame.
Any variables that are used in a formula with <code>+</code> should be
numeric.  Factors are not rejected, but their levels will be
combined strangely.
</p>
</td></tr>
<tr><td><code id="xysplom_+3A_...">...</code></td>
<td>
<p>other arguments to <code>xyplot</code>.</p>
</td></tr>
</table>
<p>z
</p>
<table>
<tr><td><code id="xysplom_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="xysplom_+3A_na.action">na.action</code></td>
<td>
<p>See

<code><a href="stats.html#topic+na.action">na.action</a></code>.
</p>
<p>Defaults to <code>na.pass</code>
because <code>xyplot</code> does sensible things with missing data.</p>
</td></tr>
<tr><td><code id="xysplom_+3A_y">y</code></td>
<td>
<p>In the <code>"default"</code> method, a data.frame with the
same number of rows as the data.frame in <code>x</code>.</p>
</td></tr>
<tr><td><code id="xysplom_+3A_group">group</code></td>
<td>
<p>In the <code>"default"</code> method, a data.frame with the
same number of rows as the data.frame in <code>x</code>.</p>
</td></tr>
<tr><td><code id="xysplom_+3A_relation">relation</code>, <code id="xysplom_+3A_x.relation">x.relation</code>, <code id="xysplom_+3A_y.relation">y.relation</code>, <code id="xysplom_+3A_scales.in">scales.in</code></td>
<td>
<p>Alternate ways to get to the
<code>scales(relation=)</code> arguments to <code>xyplot</code>.</p>
</td></tr>
<tr><td><code id="xysplom_+3A_xlim.in">xlim.in</code>, <code id="xysplom_+3A_ylim.in">ylim.in</code></td>
<td>
<p>Alternate ways to get to the
<code>scales(limits=)</code> arguments to <code>xyplot</code>.</p>
</td></tr>
<tr><td><code id="xysplom_+3A_corr">corr</code>, <code id="xysplom_+3A_beta">beta</code></td>
<td>
<p>Display the correlation and/or the regression
coefficient for <code>lm(y ~ x)</code> for each panel in an additional
strip label.</p>
</td></tr>
<tr><td><code id="xysplom_+3A_abline">abline</code></td>
<td>
<p>logical.  If <code>TRUE</code>, draw the least squares
regression line within each panel.  By default the abline is <code>FALSE</code>
unless at least one of <code>corr</code> or <code>beta</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="xysplom_+3A_digits">digits</code></td>
<td>
<p>number of significant digits for the correlation coefficient.</p>
</td></tr>
<tr><td><code id="xysplom_+3A_x.between">x.between</code>, <code id="xysplom_+3A_y.between">y.between</code>, <code id="xysplom_+3A_between.in">between.in</code></td>
<td>
<p>Alternate ways to get to the
<code>between=</code> argument to <code>xyplot</code>.</p>
</td></tr>
<tr><td><code id="xysplom_+3A_strip.in">strip.in</code></td>
<td>
<p>strip function that knows how to handle the <code>corr</code> and
<code>beta</code> displays.</p>
</td></tr>
<tr><td><code id="xysplom_+3A_pch">pch</code>, <code id="xysplom_+3A_cex">cex</code></td>
<td>
<p>arguments to <code>xyplot</code></p>
</td></tr>
<tr><td><code id="xysplom_+3A_panel.input">panel.input</code></td>
<td>
<p>panel function used by <code>xyplot</code> within each
panel.  When <code>abline==FALSE</code>, the default panel function calls
<code>panel.xyplot</code>.  When <code>abline==TRUE</code>, the default panel
function calls <code>panel.xyplot</code> and<br />
<code>panel.abline(lm(y~x, na.action=na.exclude))</code>.<br />
Note that we use
<code>na.action=na.exclude</code> inside <code>lm</code>.</p>
</td></tr>
<tr><td><code id="xysplom_+3A_cartesian">cartesian</code></td>
<td>
<p>When <code>cartesian==TRUE</code>, the cartesian product
of the left-hand side number of variables and the right-hand side
number of variables defines the number of panels in the display.
When <code>cartesian==FALSE</code>, each variable in the left-hand side is
paired with the variable in the corresponding position in the right-hand side
and only those pairs are plotted.  Both sides must have the same number of
variables.</p>
</td></tr>
<tr><td><code id="xysplom_+3A_plot">plot</code></td>
<td>
<p>Defaults to <code>TRUE</code>.  See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>plot=TRUE</code> is the normal setting and then the
function returns a <code>"trellis"</code> object.  When the argument
<code>plot=FALSE</code>, the function returns the argument list that would
otherwise be sent to <code>xyplot</code>.  This list is interesting when the
function <code>xysplom</code> was designed because the function works
by restructuring the input data and running <code>xyplot</code> on the
restructured data.
</p>


<h3>Value</h3>

<p>When <code>plot=TRUE</code> (the normal setting),
the <code>"trellis"</code> object containing the graph.<br />
When <code>plot=FALSE</code>, the restructured data that must be sent to the
<code>xyplot</code> function.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>References</h3>

<p>Heiberger, Richard M. and Holland, Burt (2015).
<em>Statistical Analysis and Data Display: An Intermediate Course with Examples in R</em>.
Second Edition.
Springer-Verlag, New York.
<a href="https://link.springer.com/book/10.1007/978-1-4939-2122-5">https://link.springer.com/book/10.1007/978-1-4939-2122-5</a>
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+xyplot">xyplot</a></code>
</p>
<p>in R.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## xysplom syntax options

tmp &lt;- data.frame(y=rnorm(12), x=rnorm(12), z=rnorm(12), w=rnorm(12),
                  g=factor(rep(1:2,c(6,6))))
tmp2 &lt;- tmp[,1:4]

xysplom(y + w ~ x , data=tmp, corr=TRUE, beta=TRUE, cartesian=FALSE, layout=c(1,2))

xysplom(y + x ~ z | g, data=tmp, layout=c(2,2))
xysplom(y + x ~ z | g, data=tmp, cartesian=FALSE)

xysplom(w + y ~ x + z, data=tmp)
xysplom(w + y ~ x + z | g, data=tmp, layout=c(2,4))
xysplom(w + y ~ x + z | g, data=tmp, cartesian=FALSE)

## Not run: 
## xyplot in R has many similar capabilities with xysplom
if.R(r=
       xyplot(w + z ~ x + y, data=tmp, outer=TRUE)
     ,s=
       {}
    )

## End(Not run)

</code></pre>

<hr>
<h2 id='z.test'> Z test for known population standard deviation </h2><span id='topic+z.test'></span>

<h3>Description</h3>

<p>Compute the test of hypothesis and compute confidence interval on the
mean of a population when the standard deviation of the population is known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z.test(x, mu = 0, stdev, alternative = c("two.sided", "less", "greater"),
  sd = stdev, n=length(x), conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="z.test_+3A_x">x</code></td>
<td>
<p> Vector of data values or the mean of the data. </p>
</td></tr>
<tr><td><code id="z.test_+3A_mu">mu</code></td>
<td>
<p> Hypothesized mean of the population. </p>
</td></tr>
<tr><td><code id="z.test_+3A_stdev">stdev</code></td>
<td>
<p> Known standard deviation of the population. </p>
</td></tr>
<tr><td><code id="z.test_+3A_alternative">alternative</code></td>
<td>
<p> Direction of the alternative hypothesis. </p>
</td></tr>
<tr><td><code id="z.test_+3A_sd">sd</code></td>
<td>
<p> Alternative to <code>stdev</code> </p>
</td></tr>
<tr><td><code id="z.test_+3A_n">n</code></td>
<td>
<p> The sample size if <code>x</code> is the sample mean. </p>
</td></tr>
<tr><td><code id="z.test_+3A_conf.level">conf.level</code></td>
<td>
<p> Confidence level for the interval computation. </p>
</td></tr>
<tr><td><code id="z.test_+3A_...">...</code></td>
<td>
<p> Additional arguments are silently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Many introductory statistical texts introduce inference by using the Z
test and Z based confidence intervals based on knowing the population
standard deviation.  Most statistical packages do not include
functions to do Z tests since the T test is usually more appropriate
for real world situations.  This function is meant to be used during
that short period of learning when the student is learning about
inference using Z procedures, but has not learned the T based
procedures yet.  Once the student has learned about the T
distribution the <code>t.test</code> function should be used instead of this
one (but the syntax is very similar, so this function should be an
appropriate introductory step to learning <code>t.test</code>).
</p>


<h3>Value</h3>

<p>An object of class <code>htest</code> containing the results
</p>


<h3>Note</h3>

<p> This function should be used for learning only, real data should
generally use <code>t.test</code>.
These files <code>z.test.R</code> and <code>z.test.Rd</code> are from
the recently orphaned package TeachingDemos_2.12.1
</p>


<h3>Author(s)</h3>

<p> Greg Snow <a href="mailto:538280@gmail.com">538280@gmail.com</a> </p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+t.test">t.test</a></code>, <code><a href="stats.html#topic+print.htest">print.htest</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(25, 100, 5)
z.test(x, 99, 5)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
