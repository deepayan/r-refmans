<!DOCTYPE html><html><head><title>Help for package networktools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {networktools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#networktools-package'><p>networktools: Tools for Identifying Important Nodes in Networks</p></a></li>
<li><a href='#assumptionCheck'><p>Assumption Checking Function</p></a></li>
<li><a href='#bridge'><p>Bridge Centrality</p></a></li>
<li><a href='#coerce_to_adjacency'><p>Coerce to adjacency matrix</p></a></li>
<li><a href='#depression'><p>Simulated Depression Profiles</p></a></li>
<li><a href='#EIGENnet'><p>EIGENnet</p></a></li>
<li><a href='#expectedInf'><p>Expected Influence</p></a></li>
<li><a href='#goldbricker'><p>Goldbricker - Identifying redundant nodes in networks using compared correlations</p></a></li>
<li><a href='#MDSnet'><p>MDSnet</p></a></li>
<li><a href='#net_reduce'><p>net_reduce</p></a></li>
<li><a href='#PCAnet'><p>PCAnet</p></a></li>
<li><a href='#plot.bridge'><p>Plot &quot;bridge&quot; objects</p></a></li>
<li><a href='#plot.expectedInf'><p>Plot &quot;expectedInf&quot; objects</p></a></li>
<li><a href='#PROCRUSTESnet'><p>PROCRUSTESnet</p></a></li>
<li><a href='#social'><p>Simulated Social Engagement Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tools for Identifying Important Nodes in Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-2-23</td>
</tr>
<tr>
<td>Description:</td>
<td>Includes assorted tools for network analysis. Bridge centrality; goldbricker; MDS, PCA, &amp; eigenmodel network plotting.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>qgraph,igraph,reshape2,ggplot2,gridExtra,stats,graphics,utils,cocor,RColorBrewer,R.utils,eigenmodel,psych,smacof,wordcloud</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, testthat</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://CRAN.R-project.org/package=networktools">https://CRAN.R-project.org/package=networktools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/paytonjjones/networktools/issues">https://github.com/paytonjjones/networktools/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-23 17:06:11 UTC; payton-jones</td>
</tr>
<tr>
<td>Author:</td>
<td>Payton Jones [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Payton Jones &lt;paytonjjones@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-23 23:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='networktools-package'>networktools: Tools for Identifying Important Nodes in Networks</h2><span id='topic+networktools'></span><span id='topic+networktools-package'></span>

<h3>Description</h3>

<p>Includes assorted tools for network analysis. Bridge centrality; goldbricker; MDS, PCA, &amp; eigenmodel network plotting.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Payton Jones <a href="mailto:paytonjjones@gmail.com">paytonjjones@gmail.com</a>
</p>


<h3>References</h3>

<p>Cite this package: <a href="https://scholar.google.com/citations?view_op=view_citation&amp;hl=en&amp;user=KRBoSPoAAAAJ&amp;citation_for_view=KRBoSPoAAAAJ:UeHWp8X0CEIC">Google Scholar</a>
</p>
<p>Cite bridge centrality: <a href="https://www.paytonjjones.com/publication/bridge_centrality/jones_ma_mcnally_2019.pdf">PDF</a>
</p>
<p>Cite goldbricker / node redundancy: <a href="https://pubmed.ncbi.nlm.nih.gov/30102777/">PubMed</a>
</p>
<p>Cite plots: <a href="https://www.frontiersin.org/articles/10.3389/fpsyg.2018.01742/full">Frontiers</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://CRAN.R-project.org/package=networktools">https://CRAN.R-project.org/package=networktools</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/paytonjjones/networktools/issues">https://github.com/paytonjjones/networktools/issues</a>
</p>
</li></ul>


<hr>
<h2 id='assumptionCheck'>Assumption Checking Function</h2><span id='topic+assumptionCheck'></span>

<h3>Description</h3>

<p>Checks some basic assumptions about the suitability of network analysis on
your data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assumptionCheck(
  data,
  type = c("network", "impact"),
  percent = 20,
  split = c("median", "mean", "forceEqual", "cutEqual", "quartiles"),
  plot = FALSE,
  binary.data = FALSE,
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assumptionCheck_+3A_data">data</code></td>
<td>
<p>dataframe or matrix of observational data (rows: observations, columns: nodes)</p>
</td></tr>
<tr><td><code id="assumptionCheck_+3A_type">type</code></td>
<td>
<p>which assumptions to check? &quot;network&quot; tests the suitability for
network analysis in general. &quot;impact&quot; tests the suitability for analyzing impact</p>
</td></tr>
<tr><td><code id="assumptionCheck_+3A_percent">percent</code></td>
<td>
<p>percent difference from grand mean that is acceptable when comparing variances.</p>
</td></tr>
<tr><td><code id="assumptionCheck_+3A_split">split</code></td>
<td>
<p>if type=&quot;impact&quot;, specifies the type of split to utilize</p>
</td></tr>
<tr><td><code id="assumptionCheck_+3A_plot">plot</code></td>
<td>
<p>logical. Should histograms each variable be plotted?</p>
</td></tr>
<tr><td><code id="assumptionCheck_+3A_binary.data">binary.data</code></td>
<td>
<p>logical. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="assumptionCheck_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Network analysis rests on several assumptions. Among these:
- Variance of each node is (roughly) equal
- Distributions are (roughly) normal
</p>
<p>Comparing networks in impact rests on additional assumptions including:
- Overall variances are (roughly) equal in each half
</p>
<p>This function checks these assumptions and notifies any violations.
This function is not intended as a substitute for careful data visualization
and independent assumption checks.
</p>
<p>See citations in the references section for further details.
</p>


<h3>References</h3>

<p>Terluin, B., de Boer, M. R., &amp; de Vet, H. C. W. (2016). Differences in Connection Strength between Mental Symptoms Might Be Explained by Differences in Variance: Reanalysis of Network Data Did Not Confirm Staging. PLOS ONE, 11(11), e0155205. Retrieved from https://doi.org/10.1371/journal.pone.0155205
</p>

<hr>
<h2 id='bridge'>Bridge Centrality</h2><span id='topic+bridge'></span>

<h3>Description</h3>

<p>Calculates bridge centrality metrics (bridge strength, bridge betweenness, bridge closeness, and bridge expected influence)
given a network and a prespecified set of communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bridge(
  network,
  communities = NULL,
  useCommunities = "all",
  directed = NULL,
  nodes = NULL,
  normalize = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bridge_+3A_network">network</code></td>
<td>
<p>a network of class &quot;igraph&quot;, &quot;qgraph&quot;, or an adjacency matrix representing
a network</p>
</td></tr>
<tr><td><code id="bridge_+3A_communities">communities</code></td>
<td>
<p>an object of class &quot;communities&quot; (igraph) OR a character vector of
community  assignments for each node (e.g., c(&quot;Comm1&quot;, &quot;Comm1&quot;, &quot;Comm2&quot;, &quot;Comm2)).
The ordering of this vector should correspond to the vector from argument &quot;nodes&quot;.
Can also be in list format (e.g., list(&quot;Comm1&quot;=c(1:10), &quot;Comm2&quot;=c(11:20)))</p>
</td></tr>
<tr><td><code id="bridge_+3A_usecommunities">useCommunities</code></td>
<td>
<p>character vector specifying which communities should be included. Default set to &quot;all&quot;</p>
</td></tr>
<tr><td><code id="bridge_+3A_directed">directed</code></td>
<td>
<p>logical. Directedness is automatically detected if set to &quot;NULL&quot; (the default).
Symmetric adjacency matrices will be undirected, asymmetric matrices will be directed</p>
</td></tr>
<tr><td><code id="bridge_+3A_nodes">nodes</code></td>
<td>
<p>a vector containing the names of the nodes. If set to &quot;NULL&quot;, this vector will
be automatically detected in the order extracted</p>
</td></tr>
<tr><td><code id="bridge_+3A_normalize">normalize</code></td>
<td>
<p>logical. Bridge centralities are divided by their highest possible value (assuming max edge strength=1)
in order to normalize by different community sizes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To plot the results, first save as an object, and then use plot() (see ?plot.bridge)
</p>
<p>Centrality metrics (strength, betweenness, etc.) illuminate how nodes are interconnected
among the entire network. However, sometimes we are interested in the connectivity
<em>between specific communities</em> in a larger network. Nodes that are important in communication
between communities can be conceptualized as bridge nodes.
</p>
<p>Bridge centrality statistics aim to identify bridge nodes. Bridge centralities
can be calculated across all communities, or between a specific subset of communities (as
identified by the <code>useCommunities</code> argument)
</p>
<p>The bridge() function currently returns 5 centrality metrics: 1) bridge strength,
2) bridge betweenness, 3) bridge closeness, 4) bridge expected influence (1-step), and
5) bridge expected influence (2-step)
</p>
<p>See ?plot.bridge for plotting details.
</p>
<p>Bridge strength is defined as the sum of the absolute value of all edges that exist between a
node A and all nodes that are not in the same community as node A. In a directed network, bridge strength can be
separated into bridge in-degree and bridge out-degree.
</p>
<p>Bridge betweenness is defined as the number of times a node B lies on the shortest path between
nodes A and C, where nodes A and C come from different communities.
</p>
<p>Bridge closeness is defined as the inverse of the average length of the path from a node A to all nodes that are
not in the same community as node A.
</p>
<p>Bridge expected influence (1-step) is defined as the sum of the value (+ or -) of all edges that
exist between a node A and all nodes that are not in the same community as node A. In a directed network, expected influence
only considers edges extending from the given node (e.g., out-degree)
</p>
<p>Bridge expected influence (2-step) is similar to 1-step, but also considers the indirect effect that a node A may have
on other communities through other nodes (e.g, an indirect effect on node C as in A -&gt; B -&gt; C).
Indirect effects are weighted by the first edge weight (e.g., A -&gt; B), and then added to the 1-step expected influence.
Indirect effects back on node A's own community (A -&gt; B -&gt; A) are not counted.
</p>
<p>If negative edges exist, bridge expected influence should be used. Bridge closeness and bridge betweenness are only defined
for positive edge weights, thus negative edges, if present, are deleted in the calculation of these metrics. Bridge strength
uses the absolute value of edge weights.
</p>


<h3>Value</h3>

<p><code><a href="#topic+bridge">bridge</a></code> returns a list of class <code>bridge</code> which contains:
</p>
<p><code>$'Bridge Strength'</code>
</p>
<p><code>$'Bridge Betweenness'</code>
</p>
<p><code>$'Bridge Closeness'</code>
</p>
<p><code>$'Bridge Expected Influence (1-step)'</code>
</p>
<p><code>$'Bridge Expected Influence (2-step)'</code>
</p>
<p>Each of these contains a vector of named centrality values
</p>
<p><code>$'communities'</code> is also returned, which returns the communities in vector format. If communities were supplied as a list or igraph object, it is advised that one check the accuracy of this vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
graph1 &lt;- qgraph::qgraph(cor(depression))

b &lt;- bridge(graph1, communities=c('1','1','2','2','2','2','1','2','1'))
b


</code></pre>

<hr>
<h2 id='coerce_to_adjacency'>Coerce to adjacency matrix</h2><span id='topic+coerce_to_adjacency'></span>

<h3>Description</h3>

<p>Takes an object of type &quot;qgraph&quot;, &quot;igraph&quot;, or an adjacency matrix (or data.frame) and outputs an adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coerce_to_adjacency(input, directed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coerce_to_adjacency_+3A_input">input</code></td>
<td>
<p>a network of class &quot;igraph&quot;, &quot;qgraph&quot;, or an adjacency matrix representing
a network</p>
</td></tr>
<tr><td><code id="coerce_to_adjacency_+3A_directed">directed</code></td>
<td>
<p>logical. is the network directed? If set to NULL, auto-detection is used</p>
</td></tr>
</table>

<hr>
<h2 id='depression'>Simulated Depression Profiles</h2><span id='topic+depression'></span>

<h3>Description</h3>

<p>This simulated dataset contains severity ratings for 9 symptoms of major depressive
disorder in 1000 individuals. Symptom ratings are  assumed to be self-reported
on a 100 point sliding scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depression
</code></pre>


<h3>Format</h3>

<p>a dataframe. Columns represent symptoms and rows represent individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(depression)
</code></pre>

<hr>
<h2 id='EIGENnet'>EIGENnet</h2><span id='topic+EIGENnet'></span>

<h3>Description</h3>

<p>Convenience function for converting a qgraph object to an eigenmodel layout
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EIGENnet(
  qgraph_net,
  EIGENadj = NULL,
  S = 1000,
  burn = 200,
  seed = 1,
  repulse = F,
  repulsion = 1,
  eigenmodelArgs = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EIGENnet_+3A_qgraph_net">qgraph_net</code></td>
<td>
<p>an object of type <code>qgraph</code></p>
</td></tr>
<tr><td><code id="EIGENnet_+3A_eigenadj">EIGENadj</code></td>
<td>
<p>to use a base matrix for the eigenmodel other than the adjacency matrix
stored in <code>qgraph_net</code>, provide it in this argument</p>
</td></tr>
<tr><td><code id="EIGENnet_+3A_s">S</code></td>
<td>
<p>number of samples from the Markov chain</p>
</td></tr>
<tr><td><code id="EIGENnet_+3A_burn">burn</code></td>
<td>
<p>number of initial scans of the Markov chain to be dropped</p>
</td></tr>
<tr><td><code id="EIGENnet_+3A_seed">seed</code></td>
<td>
<p>a random seed</p>
</td></tr>
<tr><td><code id="EIGENnet_+3A_repulse">repulse</code></td>
<td>
<p>logical. Add a small repulsion force with wordcloud package to avoid node overlap?</p>
</td></tr>
<tr><td><code id="EIGENnet_+3A_repulsion">repulsion</code></td>
<td>
<p>scalar for the repulsion force (if repulse=T). Larger values add more repulsion</p>
</td></tr>
<tr><td><code id="EIGENnet_+3A_eigenmodelargs">eigenmodelArgs</code></td>
<td>
<p>additional arguments in list format passed to <code>eigenmodel::eigenmodel_mcmc</code></p>
</td></tr>
<tr><td><code id="EIGENnet_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>qgraph</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>An eigenmodel can be interpreted based on coordinate placement
of each node. A node in the top right corner scored high on both the first and second
latent components
</p>


<h3>References</h3>

<p>Jones, P. J., Mair, P., &amp; McNally, R. J. (2018). Visualizing psychological networks: A tutorial in R. Frontiers in Psychology, 9, 1742. https://doi.org/10.3389/fpsyg.2018.01742
</p>

<hr>
<h2 id='expectedInf'>Expected Influence</h2><span id='topic+expectedInf'></span>

<h3>Description</h3>

<p>Calculates the one-step and two-step expected influence of each node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectedInf(network, step = c("both", 1, 2), directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expectedInf_+3A_network">network</code></td>
<td>
<p>an object of type <code>qgraph</code>, <code>igraph</code>, or an adjacency
matrix representing a network. Adjacency matrices should be complete (e.g., not
only upper or lower half)</p>
</td></tr>
<tr><td><code id="expectedInf_+3A_step">step</code></td>
<td>
<p>compute 1-step expected influence, 2-step expected influence,
or both</p>
</td></tr>
<tr><td><code id="expectedInf_+3A_directed">directed</code></td>
<td>
<p>logical. Specifies if edges are directed, defaults to FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a network contains both positive and negative edges, traditional centrality measures
such as strength centrality may not accurately predict node influence on the network.
Robinaugh, Millner, &amp; McNally (2016) showed that in these cases,
expected influence is a more appropriate measure.
</p>
<p>One-step expected influence is defined as the sum of all edges extending
from a given node (where the sign of each edge is maintained).
</p>
<p>Two-step expected influence, as the name implies, measures connectivity up to two edges away from the node.
It is defined as the sum of the (weighted) expected influences of each node connected to the initial node
plus the one-step expected influence of the initial node. Weights are determined by the edge strength between
the initial node and each &quot;second step&quot; node.
</p>
<p>See citations in the references section for further details.
</p>


<h3>References</h3>

<p>Robinaugh, D. J., Millner, A. J., &amp; McNally, R. J. (2016). Identifying highly influential nodes in the complicated grief network. <em>Journal of abnormal psychology</em>, 125, 747.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out1 &lt;- expectedInf(cor(depression[,1:5]))

out1$step1
out1$step2
plot(out1)
plot(out1, order="value", zscore=TRUE)

igraph_obj &lt;- igraph::graph_from_adjacency_matrix(cor(depression))
out_igraph &lt;- expectedInf(igraph_obj)

qgraph_obj &lt;- qgraph::qgraph(cor(depression), DoNotPlot=TRUE)
out_qgraph &lt;- expectedInf(qgraph_obj)


</code></pre>

<hr>
<h2 id='goldbricker'>Goldbricker - Identifying redundant nodes in networks using compared correlations</h2><span id='topic+goldbricker'></span>

<h3>Description</h3>

<p>This function compares correlations in a psychometric network in order to identify nodes
which most likely measure the same underlying construct (i.e., are colinear)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>goldbricker(
  data,
  p = 0.05,
  method = "hittner2003",
  threshold = 0.25,
  corMin = 0.5,
  progressbar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="goldbricker_+3A_data">data</code></td>
<td>
<p>a data frame consisting of n rows (participants) and j columns (variables)</p>
</td></tr>
<tr><td><code id="goldbricker_+3A_p">p</code></td>
<td>
<p>a p-value threshold for determining if correlation pairs are &quot;significantly different&quot;</p>
</td></tr>
<tr><td><code id="goldbricker_+3A_method">method</code></td>
<td>
<p>method for comparing correlations. See ?cocor.dep.groups.overlap for a full list</p>
</td></tr>
<tr><td><code id="goldbricker_+3A_threshold">threshold</code></td>
<td>
<p>variable pairs which have less than the threshold proportion of significantly different
correlations will be considered &quot;bad pairs&quot;</p>
</td></tr>
<tr><td><code id="goldbricker_+3A_cormin">corMin</code></td>
<td>
<p>the minimum zero-order correlation between two items to be considered &quot;bad pairs&quot;. Items
that are uncorrelated are unlikely to represent the same underlying construct</p>
</td></tr>
<tr><td><code id="goldbricker_+3A_progressbar">progressbar</code></td>
<td>
<p>logical. prints a progress bar in the console</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a given psychometric network, two nodes may be redundantly measuring the same underlying construct. If this is the case,
the correlations between those two variables and all other variables should be highly similar. That is, they should correlate
to the same degree with other variables.
</p>
<p>The cocor package uses a p-value threshold to determine whether a pair of correlations to a third variable are
significantly different from each other. Goldbricker wraps the cocor package to compare every possible
combination of correlations in a psychometric network. It calculates the proportion of correlations which are
significantly different for each different pair of nodes.
</p>
<p>Using the threshold argument, one can set the proportion of correlations which is deemed &quot;too low&quot;. All pairs of nodes
which fall below this threshold are returned as defined &quot;bad pairs&quot;.
</p>
<p>Pairs can then be combined using the net_reduce function
</p>
<p>Note: to quickly change the threshold, one may simply enter an object of class &quot;goldbricker&quot; in the data argument, and change the threshold.
The p-value cannot be modified in the same fashion, as re-computation is necessary.
</p>


<h3>Value</h3>

<p><code><a href="#topic+goldbricker">goldbricker</a></code> returns a list of class <code>goldbricker</code> which contains:
</p>
<p><code>$proportion_matrix</code> - a j x j matrix of proportions. Each proportion signifies the amount of significantly
different correlations between the given node pair (j x j)
</p>
<p><code>$suggested_reductions</code> - a vector of &quot;bad pairs&quot; (names) and their proportions (values)
</p>
<p><code>$p</code> - p value from input
</p>
<p><code>$threshold</code> - threshold from input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gb_depression &lt;- goldbricker(depression, threshold=0.5)

reduced_depression &lt;- net_reduce(data=depression, badpairs=gb_depression)

## Set a new threshold quickly
gb_depression_60 &lt;- goldbricker(data=gb_depression, threshold=0.6)


</code></pre>

<hr>
<h2 id='MDSnet'>MDSnet</h2><span id='topic+MDSnet'></span>

<h3>Description</h3>

<p>Convenience function for converting a qgraph object to a layout determined
by multidimensional scaling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MDSnet(
  qgraph_net,
  type = c("ordinal", "interval", "ratio", "mspline"),
  MDSadj = NULL,
  stressTxt = F,
  repulse = F,
  repulsion = 1,
  mdsArgs = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MDSnet_+3A_qgraph_net">qgraph_net</code></td>
<td>
<p>an object of type <code>qgraph</code></p>
</td></tr>
<tr><td><code id="MDSnet_+3A_type">type</code></td>
<td>
<p>transformation function for MDS, defaults to &quot;ordinal&quot;</p>
</td></tr>
<tr><td><code id="MDSnet_+3A_mdsadj">MDSadj</code></td>
<td>
<p>to use a proximities matrix other than the adjacency matrix
stored in <code>qgraph_net</code>, provide it in this argument</p>
</td></tr>
<tr><td><code id="MDSnet_+3A_stresstxt">stressTxt</code></td>
<td>
<p>logical. Print the stress value in the lower left corner of the plot?</p>
</td></tr>
<tr><td><code id="MDSnet_+3A_repulse">repulse</code></td>
<td>
<p>logical. Add a small repulsion force with wordcloud package to avoid node overlap?</p>
</td></tr>
<tr><td><code id="MDSnet_+3A_repulsion">repulsion</code></td>
<td>
<p>scalar for the repulsion force. Larger values add more repulsion</p>
</td></tr>
<tr><td><code id="MDSnet_+3A_mdsargs">mdsArgs</code></td>
<td>
<p>additional arguments in list format passed to <code>smacof::mds</code></p>
</td></tr>
<tr><td><code id="MDSnet_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>qgraph</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A network plotted with multidimensional scaling can be interpreted based on the distances
between nodes. Nodes close together represent closely associated nodes, whereas nodes that are far
apart represent unassociated or negatively associated nodes.
</p>


<h3>References</h3>

<p>Jones, P. J., Mair, P., &amp; McNally, R. J. (2018). Visualizing psychological networks: A tutorial in R. Frontiers in Psychology, 9, 1742. https://doi.org/10.3389/fpsyg.2018.01742
</p>

<hr>
<h2 id='net_reduce'>net_reduce</h2><span id='topic+net_reduce'></span>

<h3>Description</h3>

<p>This function takes predefined pairs of colinear variables in a dataset and a) combines them via PCA or
b) picks the &quot;better&quot; variable and eliminates the other variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net_reduce(data, badpairs, method = c("PCA", "best_goldbricker"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net_reduce_+3A_data">data</code></td>
<td>
<p>a data frame consisting of n rows (participants) and j columns (variables)</p>
</td></tr>
<tr><td><code id="net_reduce_+3A_badpairs">badpairs</code></td>
<td>
<p>pairs of variables to be combined. Input may consist of:
-an object of class &quot;goldbricker&quot; (all bad pairs are combined)
-a vector of item names, each consecutive pair will be considered a bad pair
-a matrix with 2 columns where each bad pair takes up 1 row</p>
</td></tr>
<tr><td><code id="net_reduce_+3A_method">method</code></td>
<td>
<p>method for combining variables. PCA takes the first principal component of the two
variables and defines it as a new variable. best_goldbricker requires that the input of &quot;badpairs&quot; be an object of class
&quot;goldbricker&quot; it selects the more unique variable, and eliminates the other variable in the pair.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a given psychometric network, two nodes may be redundantly measuring the same underlying construct. If this is the case,
both variables should not appear in the same network, or network properties will be inaccurate. These variable pairs can be
reduced by combining them, or by eliminating one of them. net_reduce automates this process when given a list of &quot;bad pairs&quot;
</p>
<p>If the same variable appears in multiple &quot;bad pairs&quot; (e.g., &quot;x&quot; and &quot;y&quot; is a bad pair, and so is &quot;x&quot; and &quot;z&quot;), only the first
of these pairs which appears in the badpairs argument will be reduced by the function.
</p>


<h3>Value</h3>

<p><code><a href="#topic+goldbricker">goldbricker</a></code> returns a dataframe of n rows (participants) and j - x columns,
where j is the number of variables in the original dataframe, and x is the number of bad pairs to reduce.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gb_depression &lt;- goldbricker(depression, threshold=0.5)

reduced_depression_PCA &lt;- net_reduce(data=depression, badpairs=gb_depression)
reduced_depression_best &lt;- net_reduce(data=depression,
                           badpairs=gb_depression, method="best_goldbricker")



</code></pre>

<hr>
<h2 id='PCAnet'>PCAnet</h2><span id='topic+PCAnet'></span>

<h3>Description</h3>

<p>Convenience function for converting a qgraph object to a layout determined
by principal components analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCAnet(
  qgraph_net,
  cormat,
  varTxt = F,
  repulse = F,
  repulsion = 1,
  principalArgs = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCAnet_+3A_qgraph_net">qgraph_net</code></td>
<td>
<p>an object of type <code>qgraph</code></p>
</td></tr>
<tr><td><code id="PCAnet_+3A_cormat">cormat</code></td>
<td>
<p>the correlation matrix of the relevant data. If this argument is missing,
the function will assume that the adjacency matrix from <code>qgraph_net</code> is a correlation matrix</p>
</td></tr>
<tr><td><code id="PCAnet_+3A_vartxt">varTxt</code></td>
<td>
<p>logical. Print the variance accounted for by the PCA in the lower left corner of the plot</p>
</td></tr>
<tr><td><code id="PCAnet_+3A_repulse">repulse</code></td>
<td>
<p>logical. Add a small repulsion force with wordcloud package to avoid node overlap?</p>
</td></tr>
<tr><td><code id="PCAnet_+3A_repulsion">repulsion</code></td>
<td>
<p>scalar for the repulsion force (if repulse=T). Larger values add more repulsion</p>
</td></tr>
<tr><td><code id="PCAnet_+3A_principalargs">principalArgs</code></td>
<td>
<p>additional arguments in list format passed to <code>psych::principal</code></p>
</td></tr>
<tr><td><code id="PCAnet_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>qgraph</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A network plotted with PCA can be interpreted based on coordinate placement
of each node. A node in the top right corner scored high on both the first and second
principal components
</p>


<h3>References</h3>

<p>Jones, P. J., Mair, P., &amp; McNally, R. J. (2018). Visualizing psychological networks: A tutorial in R. Frontiers in Psychology, 9, 1742. https://doi.org/10.3389/fpsyg.2018.01742
</p>

<hr>
<h2 id='plot.bridge'>Plot &quot;bridge&quot; objects</h2><span id='topic+plot.bridge'></span>

<h3>Description</h3>

<p>Convenience function for plotting bridge centrality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bridge'
plot(
  x,
  order = c("given", "alphabetical", "value"),
  zscore = FALSE,
  include,
  color = FALSE,
  colpalette = "Dark2",
  plotNA = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bridge_+3A_x">x</code></td>
<td>
<p>an output object from <code>bridge</code> (class <code>bridge</code>)</p>
</td></tr>
<tr><td><code id="plot.bridge_+3A_order">order</code></td>
<td>
<p>&quot;alphabetical&quot; orders nodes alphabetically, &quot;value&quot; orders nodes from
highest to lowest centrality values</p>
</td></tr>
<tr><td><code id="plot.bridge_+3A_zscore">zscore</code></td>
<td>
<p>logical. Converts raw impact statistics to z-scores for plotting</p>
</td></tr>
<tr><td><code id="plot.bridge_+3A_include">include</code></td>
<td>
<p>a vector of centrality measures to include (&quot;Bridge Strength&quot;, &quot;Bridge Betweenness&quot;, &quot;Bridge Closeness&quot;,
&quot;Bridge Expected Influence (1-step)&quot;, &quot;Bridge Expected Influence (2-step)&quot;),
if missing all available measures will be plotted</p>
</td></tr>
<tr><td><code id="plot.bridge_+3A_color">color</code></td>
<td>
<p>logical. Color each community separately in the plot?</p>
</td></tr>
<tr><td><code id="plot.bridge_+3A_colpalette">colpalette</code></td>
<td>
<p>A palette name from RColorBrewer, for coloring of axis labels</p>
</td></tr>
<tr><td><code id="plot.bridge_+3A_plotna">plotNA</code></td>
<td>
<p>should nodes with NA values be included on the y axis?</p>
</td></tr>
<tr><td><code id="plot.bridge_+3A_...">...</code></td>
<td>
<p>other plotting specifications in ggplot2 (aes)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inputting an object of class <code>bridge</code>
will return a line plot that shows the bridge centrality
values of each node
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
b &lt;- bridge(cor(depression))
plot(b)
plot(b, order="value", zscore=TRUE,include=c("Bridge Strength", "Bridge Betweenness"))

</code></pre>

<hr>
<h2 id='plot.expectedInf'>Plot &quot;expectedInf&quot; objects</h2><span id='topic+plot.expectedInf'></span>

<h3>Description</h3>

<p>Convenience function for plotting expected influence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'expectedInf'
plot(x, order = c("given", "alphabetical", "value"), zscore = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.expectedInf_+3A_x">x</code></td>
<td>
<p>an output object from an <code>expectedInf</code> (class <code>expectedInf</code>)</p>
</td></tr>
<tr><td><code id="plot.expectedInf_+3A_order">order</code></td>
<td>
<p>&quot;alphabetical&quot; orders nodes alphabetically, &quot;value&quot; orders nodes from
highest to lowest impact value</p>
</td></tr>
<tr><td><code id="plot.expectedInf_+3A_zscore">zscore</code></td>
<td>
<p>logical. Converts raw impact statistics to z-scores for plotting</p>
</td></tr>
<tr><td><code id="plot.expectedInf_+3A_...">...</code></td>
<td>
<p>other plotting specifications (ggplot2)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inputting an object of class <code>expectedInf</code>
will return a line plot that shows the relative one-step and/or two-step
expected influence of each node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myNetwork &lt;- cor(depression[,1:5])
out1 &lt;- expectedInf(myNetwork)
plot(out1$step1)

plot(out1, order="value", zscore=TRUE)

</code></pre>

<hr>
<h2 id='PROCRUSTESnet'>PROCRUSTESnet</h2><span id='topic+PROCRUSTESnet'></span>

<h3>Description</h3>

<p>Convenience function for simultaneously plotting two networks containing the same nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PROCRUSTESnet(
  qgraph_net1,
  qgraph_net2,
  type1 = c("ordinal", "interval", "ratio", "mspline"),
  type2 = type1,
  MDSadj1 = NULL,
  MDSadj2 = NULL,
  stressTxt = F,
  congCoef = F,
  repulse = F,
  repulsion = 1,
  mdsArgs = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PROCRUSTESnet_+3A_qgraph_net1">qgraph_net1</code></td>
<td>
<p>an object of type <code>qgraph</code></p>
</td></tr>
<tr><td><code id="PROCRUSTESnet_+3A_qgraph_net2">qgraph_net2</code></td>
<td>
<p>an object of type <code>qgraph</code>. Contains the same nodes as <code>qgraph_net2</code></p>
</td></tr>
<tr><td><code id="PROCRUSTESnet_+3A_type1">type1</code></td>
<td>
<p>transformation function for first MDS, defaults to &quot;ordinal&quot;</p>
</td></tr>
<tr><td><code id="PROCRUSTESnet_+3A_type2">type2</code></td>
<td>
<p>transformation function for second MDS, defaults to the same as <code>type1</code></p>
</td></tr>
<tr><td><code id="PROCRUSTESnet_+3A_mdsadj1">MDSadj1</code></td>
<td>
<p>to use a proximities matrix other than the adjacency matrix
stored in <code>qgraph_net1</code>, provide it in this argument</p>
</td></tr>
<tr><td><code id="PROCRUSTESnet_+3A_mdsadj2">MDSadj2</code></td>
<td>
<p>to use a proximities matrix other than the adjacency matrix
stored in <code>qgraph_net2</code>, provide it in this argument</p>
</td></tr>
<tr><td><code id="PROCRUSTESnet_+3A_stresstxt">stressTxt</code></td>
<td>
<p>logical. Print the stress value in the lower left corner of the plots?</p>
</td></tr>
<tr><td><code id="PROCRUSTESnet_+3A_congcoef">congCoef</code></td>
<td>
<p>logical. Print the congruence coefficient for the two layouts?</p>
</td></tr>
<tr><td><code id="PROCRUSTESnet_+3A_repulse">repulse</code></td>
<td>
<p>logical. Add a small repulsion force with wordcloud package to avoid node overlap?</p>
</td></tr>
<tr><td><code id="PROCRUSTESnet_+3A_repulsion">repulsion</code></td>
<td>
<p>scalar for the repulsion force. Larger values add more repulsion</p>
</td></tr>
<tr><td><code id="PROCRUSTESnet_+3A_mdsargs">mdsArgs</code></td>
<td>
<p>additional arguments in list format passed to <code>smacof::mds</code></p>
</td></tr>
<tr><td><code id="PROCRUSTESnet_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>qgraph</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each network's layout is determined by multidimensional scaling, and then the layouts
are brought into a similar space by using the Procrustes algorithm.
</p>
<p>A network plotted with multidimensional scaling can be interpreted based on the distances
between nodes. Nodes close together represent closely associated nodes, whereas nodes that are far
apart represent unassociated or negatively associated nodes.
</p>
<p>The Procrustes algorithm brings the two layouts into a similar space through rotations and dilations
that do not impact the fit of the MDS solutions. In this implementation, the second network is rotated
and dilated to fit the first.
</p>


<h3>References</h3>

<p>Jones, P. J., Mair, P., &amp; McNally, R. J. (2018). Visualizing psychological networks: A tutorial in R. Frontiers in Psychology, 9, 1742. https://doi.org/10.3389/fpsyg.2018.01742
</p>

<hr>
<h2 id='social'>Simulated Social Engagement Data</h2><span id='topic+social'></span>

<h3>Description</h3>

<p>This simulated dataset contains binary social engagement scores for 16 individuals. For 400 social media posts
on a group forum, individuals were given a score of 1 if they engaged in group conversation regarding the post,
and a score of 0 if they did not engage with the post.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>social
</code></pre>


<h3>Format</h3>

<p>a dataframe. Columns represent individuals (nodes) and rows represent engagement in social media group conversations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(social)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
