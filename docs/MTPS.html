<!DOCTYPE html><html lang="en"><head><title>Help for package MTPS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MTPS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AUC'><p>Area Under Curve</p></a></li>
<li><a href='#cv.MTPS'><p>Evaluation using Cross-Validation</p></a></li>
<li><a href='#HIV'><p>HIV Drug Resistance Database</p></a></li>
<li><a href='#Internal_data'><p>Internal Data Object</p></a></li>
<li><a href='#list.learners'><p>List Available Base Learners</p></a></li>
<li><a href='#modify.parameter'><p>Modify Default Parameters For Base Learner</p></a></li>
<li><a href='#MTPS'><p>Fit Models using Revised Stacking Algorithm</p></a></li>
<li><a href='#MTPS-internal'><p>Internal functions</p></a></li>
<li><a href='#multiFit'><p>Fit models on multiple outcomes</p></a></li>
<li><a href='#predict.MTPS'><p>Make predictions from a &quot;MTPS&quot; model</p></a></li>
<li><a href='#predict.multiFit'><p>Make predictions for multiple outcomes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multi-Task Prediction using Stacking Algorithms</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Simultaneous multiple outcomes prediction based on revised stacking algorithms, which enables the integration of information from predictions of individual models. An implementation of methodologies proposed in our paper: Li Xing, Mary L Lesperance, Xuekui Zhang. (2019)  Bioinformatics, "Simultaneous prediction of multiple outcomes using revised stacking algorithms" &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtz531">doi:10.1093/bioinformatics/btz531</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://doi.org/10.1093/bioinformatics/btz531">https://doi.org/10.1093/bioinformatics/btz531</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), glmnet, rpart, MASS, e1071, class</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, ggplot2, reshape2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-11 09:03:21 UTC; caoxiaowen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Li Xing &lt;sfulxing@gmail.com&gt;</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Li Xing [aut, cre],
  Xiaowen Cao [aut],
  Yuying Huang [aut],
  Peijie Xie [ctb],
  Mary Lesperance [aut],
  Xuekui Zhang [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-14 05:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AUC'>Area Under Curve</h2><span id='topic+AUC'></span>

<h3>Description</h3>

<p>The AUC function calculates the numeric value of area under the ROC curve (AUC) with the trapezoidal rule and optionally plots the  ROC curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AUC(prob, outcome, cutoff = 1, ROC.plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AUC_+3A_prob">prob</code></td>
<td>
<p>A numeric vector of predicted probability</p>
</td></tr>
<tr><td><code id="AUC_+3A_outcome">outcome</code></td>
<td>
<p>A numeric vector of observed binary outcome</p>
</td></tr>
<tr><td><code id="AUC_+3A_cutoff">cutoff</code></td>
<td>
<p>Number between 0 and 1 to specify where threshold of ROC curve should be truncated. The default value is 1 (no truncation)</p>
</td></tr>
<tr><td><code id="AUC_+3A_roc.plot">ROC.plot</code></td>
<td>
<p>Logical. Whether or not to plot ROC curve</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ROC curve is created by plotting the true positive rate (TPR) against the false positive rate (FPR) at different threshold settings.
</p>
<p>By default the total area under the curve is computed, but a truncated AUC statistics can be specified with the cutoff argument. It specifies the bounds of FPR. The common choice of cutoff can be 1 (i.e. no truncate) or 0.2 (i.e. specificity &gt; 0.8)
</p>


<h3>Value</h3>

<p>The value of the area under the curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
# simulate predictors
x1 &lt;- rnorm(200)
x2 &lt;- rnorm(200)
# simulate outcome
pr &lt;- 1/(1+exp(-(3 * x1 + 2 * x2 + 1)))
y &lt;- rbinom(200, 1, pr)
df &lt;- data.frame(y = y,x1 = x1, x2 = x2)
# fit logistic regression model on the first 100 observation
lg.model &lt;- glm(y ~ x1 + x2, data = df[1 : 100, ], family="binomial")
# predict outcome for the last 100 observation
prob &lt;- predict(lg.model, df[101:200, c("x1", "x2")], type = "response")
# calculate AUC and plot thr ROC Curve
AUC(prob, y[101:200], ROC=TRUE)
# calculate AUC and plot thr ROC Curve with cutoff
AUC(prob, y[101:200], cutoff=0.2, ROC=TRUE)
</code></pre>

<hr>
<h2 id='cv.MTPS'>Evaluation using Cross-Validation</h2><span id='topic+cv.MTPS'></span>

<h3>Description</h3>

<p>Use cross-validation to evaluate model performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.MTPS(xmat, ymat, family, nfolds = 5,
                   cv = FALSE, residual = TRUE,
                   cv.stacking.nfold = 5, method.step1, method.step2,
                   resid.type=c("deviance", "pearson", "raw"),
                   resid.std=FALSE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.MTPS_+3A_xmat">xmat</code></td>
<td>
<p>Predictor matrix, each row is an observation vector</p>
</td></tr>
<tr><td><code id="cv.MTPS_+3A_ymat">ymat</code></td>
<td>
<p>Responses matrix. Quantitative for family = &quot;gaussian&quot; and a factor of two levels for family = &quot;binomial&quot;</p>
</td></tr>
<tr><td><code id="cv.MTPS_+3A_family">family</code></td>
<td>
<p>Response type for each response. If all response variable are within the same family it can be &quot;gaussian&quot; or &quot;binomial&quot;, otherwise it is a vector with elements &quot;gaussian&quot; and &quot;binomial&quot; to indicate each response family</p>
</td></tr>
<tr><td><code id="cv.MTPS_+3A_nfolds">nfolds</code></td>
<td>
<p>Integer, number of folds for Cross-Validation to evaluate the performance of stacking algorithms.</p>
</td></tr>
<tr><td><code id="cv.MTPS_+3A_cv">cv</code></td>
<td>
<p>Logical, indicate if use Cross-Validation Stacking algorithm</p>
</td></tr>
<tr><td><code id="cv.MTPS_+3A_residual">residual</code></td>
<td>
<p>Logical, indicate if use Residual Stacking algorithm</p>
</td></tr>
<tr><td><code id="cv.MTPS_+3A_cv.stacking.nfold">cv.stacking.nfold</code></td>
<td>
<p>Integer, number of folds for Cross-Validation Stacking algorithm. The default value is 5</p>
</td></tr>
<tr><td><code id="cv.MTPS_+3A_method.step1">method.step1</code></td>
<td>
<p>Base Learners for fitting models in Step 1 of Stacking Algorithm. It can be one base learner function for all outcomes or a list of base learner functions for each outcome. The list of all base learners can be obtained by <code>list.learners()</code></p>
</td></tr>
<tr><td><code id="cv.MTPS_+3A_method.step2">method.step2</code></td>
<td>
<p>Base Learners for fitting models in Step 2 of Stacking Algorithm. (see above)</p>
</td></tr>
<tr><td><code id="cv.MTPS_+3A_resid.type">resid.type</code></td>
<td>
<p>The residual type for Residual Stacking</p>
</td></tr>
<tr><td><code id="cv.MTPS_+3A_resid.std">resid.std</code></td>
<td>
<p>Logical, whether or not use standardized residual</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns the mean squared error of continuous outcomes. AUC, accuracy, recall and precision for binary outcomes of predictions using cross-validation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("HIV")
cv.MTPS(xmat=XX, ymat=YY, family="gaussian", nfolds=2,
        method.step1=rpart1, method.step2=lm1)
</code></pre>

<hr>
<h2 id='HIV'>HIV Drug Resistance Database</h2><span id='topic+HIV'></span><span id='topic+XX'></span><span id='topic+YY'></span>

<h3>Description</h3>

<p>The data from HIV Drug Resistance Database used for demonstration. After processing, <code>YY</code> contains 5 response variables variable for 1246 observations and <code>XX</code> are 228 predictors of those 1246 obsevations.
</p>


<h3>Format</h3>

<p>Data objects used for demonstration
</p>


<h3>Details</h3>

<p>In the HIV database, the resistance of five Nucleoside RT Inhibitor (NRTI) drugs were used as multivariate outcomes, including Lamivudine (3TC), Abacavir(ABC), Zidovudine (AZT), Stavudine (D4T), Didanosine (DDI). The mutation variables are used as the predictors. Some mutation variables were removed as they do not contain enough variation. The final outcome data is a matrix of size 1246 × 5, and the predictor data is a matrix of 1246 × 228 values, which is provided in the package called &quot;HIV&quot;. In the example data in the package, &quot;YY&quot; refers the outcome data and &quot;XX&quot; refers the predictor data.
</p>


<h3>References</h3>

<p>Rhee SY, Taylor J, Wadhera G, Ben-Hur A, Brutlag DL, Shafer RW. Genotypic predictors of human immunodeficiency virus type 1 drug resistance. Proceedings of the National Academy of Sciences. 2006 Nov 14;103(46):17355-60.
</p>
<p>Rhee SY, Taylor J, Fessel WJ, Kaufman D, Towner W, Troia P, Ruane P, Hellinger J, Shirvani V, Zolopa A, Shafer RW. (2010). HIV-1 protease mutations and protease inhibitor cross-resistance. Antimicrobial Agents and Chemotherapy, 2010 Oct
</p>
<p>Melikian GL, Rhee SY, Taylor J, Fessel WJ, Kaufman D, Towner W, Troia-Cancio PV, Zolopa A, Robbins GK, Kagan R, Israelski D, Shafer RW (2012). Standardized comparison of the relative impacts of HIV-1 reverse transcriptase (RT) mutations on nucleoside RT inhibitor susceptibility. Antimicrobial Agents and Chemother. 2012 May;56(5):2305-13.
</p>
<p>Melikian GL, Rhee SY, Varghese V, Porter D, White K, Taylor J, Towner W, Troia P, Burack J, Dejesus E, Robbins GK, Razzeca K, Kagan R, Liu TF, Fessel WJ, Israelski D, Shafer RW (2013). Non-nucleoside reverse transcriptase inhibitor (NNRTI) cross-resistance: implications for preclinical evaluation of novel NNRTIs and clinical genotypic resistance testing. J Antimicrob Chemother, 2013 Aug 9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HIV)
</code></pre>

<hr>
<h2 id='Internal_data'>Internal Data Object</h2><span id='topic+ctn.plot.data'></span><span id='topic+mix.plot.data'></span><span id='topic+mse.data'></span><span id='topic+pred.mix.rs'></span><span id='topic+pred.prs.std'></span><span id='topic+y.test.bin'></span><span id='topic+y.test.mix'></span>

<h3>Description</h3>

<p>The data is for internal use, and is not meant for users.
</p>


<h3>Format</h3>

<p>Data objects used for demonstration
</p>


<h3>Details</h3>

<p>For speeding up vignette build purpose.
</p>

<hr>
<h2 id='list.learners'>List Available Base Learners</h2><span id='topic+list.learners'></span><span id='topic+KNN1'></span><span id='topic+glm1'></span><span id='topic+glmnet.lasso'></span><span id='topic+glmnet.ridge'></span><span id='topic+glmnet1'></span><span id='topic+lda1'></span><span id='topic+lm1'></span><span id='topic+qda1'></span><span id='topic+rpart1'></span><span id='topic+svm1'></span>

<h3>Description</h3>

<p>This function lists all base learners provided in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.learners()
</code></pre>


<h3>Details</h3>

<p>lm1: linear regression
</p>
<p>glm1: generalized linear models
</p>
<p>glmnet1: Does k-fold cross-validation to chose best alpha and lambda for generalized linear models via penalized maximum likelihood.
</p>
<p>glmnet.lasso: LASSO, lambda is chose by k-fold cross-validation for glmnet
</p>
<p>glmnet.ridge: Ridge regression, lambda is chose by k-fold cross-validation for glmnet
</p>
<p>rpart1: regression tree
</p>
<p>lda1: linear discriminant analysis
</p>
<p>qda1: quadratic discriminant analysis
</p>
<p>KNN1: k-nearest neighbour classification, k is chose by cross-validation
</p>
<p>svm1: support vector machine
</p>


<h3>Value</h3>

<p>The name of all base learners provided in the package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list.learners()
</code></pre>

<hr>
<h2 id='modify.parameter'>Modify Default Parameters For Base Learner</h2><span id='topic+modify.parameter'></span>

<h3>Description</h3>

<p>Modify default parameters for methods provided in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify.parameter(FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modify.parameter_+3A_fun">FUN</code></td>
<td>
<p>Method</p>
</td></tr>
<tr><td><code id="modify.parameter_+3A_...">...</code></td>
<td>
<p>Modified arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a new function with modified parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>glmnet.lasso &lt;- modify.parameter(glmnet1, alpha=1)
glmnet.ridge &lt;- modify.parameter(glmnet1, alpha=0)
</code></pre>

<hr>
<h2 id='MTPS'>Fit Models using Revised Stacking Algorithm</h2><span id='topic+MTPS'></span>

<h3>Description</h3>

<p>Fit a model using standard stacking algorithm or revised stacking algorithms to simultaneous predicte multiple outcomes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MTPS(xmat, ymat, family,
  cv = FALSE, residual = TRUE, nfold = 5,
  method.step1, method.step2,
  resid.type = c("deviance", "pearson", "raw"), resid.std = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MTPS_+3A_xmat">xmat</code></td>
<td>
<p>Predictor matrix, each row is an observation vector</p>
</td></tr>
<tr><td><code id="MTPS_+3A_ymat">ymat</code></td>
<td>
<p>Responses matrix. Quantitative for family = &quot;gaussian&quot; and a factor of two levels for family = &quot;binomial&quot;</p>
</td></tr>
<tr><td><code id="MTPS_+3A_family">family</code></td>
<td>
<p>Response type for each response. If all response variable are within the same family it can be &quot;gaussian&quot; or &quot;binomial&quot;, otherwise it is a vector with elements &quot;gaussian&quot; and &quot;binomial&quot; to indicate each response family</p>
</td></tr>
<tr><td><code id="MTPS_+3A_cv">cv</code></td>
<td>
<p>Logical, indicate if use Cross-Validation Stacking algorithm</p>
</td></tr>
<tr><td><code id="MTPS_+3A_residual">residual</code></td>
<td>
<p>Logical, indicate if use Residual Stacking algorithm</p>
</td></tr>
<tr><td><code id="MTPS_+3A_nfold">nfold</code></td>
<td>
<p>Integer, number of folds for Cross-Validation Stacking algorithm. The default value is 5</p>
</td></tr>
<tr><td><code id="MTPS_+3A_method.step1">method.step1</code></td>
<td>
<p>Base Learners for fitting models in Step 1 of Stacking Algorithm. It can be one base learner function for all outcomes or a list of base learner functions for each outcome. The list of all base learners can be obtained by <code>list.learners()</code></p>
</td></tr>
<tr><td><code id="MTPS_+3A_method.step2">method.step2</code></td>
<td>
<p>Base Learners for fitting models in Step 2 of Stacking Algorithm. (see above)</p>
</td></tr>
<tr><td><code id="MTPS_+3A_resid.type">resid.type</code></td>
<td>
<p>The residual type for Residual Stacking</p>
</td></tr>
<tr><td><code id="MTPS_+3A_resid.std">resid.std</code></td>
<td>
<p>Logical, whether or not use standardized residual</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a MTPS object. It is a list of 4 parameters containing information about step 1 and step 2 models and the revised stacking algorithm method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("HIV")
set.seed(1)
xmat &lt;- as.matrix(XX)
ymat &lt;- as.matrix(YY)
id &lt;- createFolds(rowMeans(XX), k=5, list=FALSE)
training.id &lt;- id != 1
y.train &lt;- ymat[training.id, ]
y.test  &lt;- ymat[!training.id, ]
x.train &lt;- xmat[training.id, ]
x.test  &lt;- xmat[!training.id, ]

# Residual Stacking
fit.rs &lt;- MTPS(xmat = x.train, ymat = y.train,
  family = "gaussian",cv = FALSE, residual = TRUE,
  method.step1 = rpart1, method.step2 = lm1)
predict(fit.rs, x.test)

# using different base learners for different outcomes
 fit.mixOut &lt;- MTPS(xmat=x.train, ymat=y.train,
  family="gaussian",cv = FALSE, residual = TRUE,
  method.step1 = c(rpart1,glmnet.ridge,rpart1,lm1,lm1),
  method.step2 = c(rpart1,lm1,lm1,lm1, glmnet.ridge))
predict(fit.mixOut, x.test)
</code></pre>

<hr>
<h2 id='MTPS-internal'>Internal functions</h2><span id='topic+MTPS-internal'></span><span id='topic+trapezoid'></span><span id='topic+check.match'></span><span id='topic+createFolds'></span><span id='topic+cv.glmnet2'></span><span id='topic+cv.multiFit'></span><span id='topic+max_finite'></span><span id='topic+min_finite'></span><span id='topic+resid.bin'></span><span id='topic+rs.multiFit'></span><span id='topic+predict.cv.multiFit'></span><span id='topic+predict.rs.multiFit'></span>

<h3>Description</h3>

<p>Internal functions for MTPS package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trapezoid(FPR,TPR,cc)

check.match(family, FUN)

createFolds(y, k = 10, list = TRUE, returnTrain = FALSE)

cv.glmnet2(xx, yy, foldid, alpha=seq(0,10,by=2)/10,
lambda=exp(seq(log(10^-8), log(5), length.out=100)),...)

cv.multiFit(xmat, ymat, nfold=5, method, family=family)

max_finite(xx)

min_finite(xx)

resid.bin(ymat, yhat, xmat=NULL, type=c("deviance", "pearson", "raw"), resid.std=F)

rs.multiFit(yhat, ymat, xmat=NULL, family,
            resid.type=c("deviance", "pearson", "raw"), resid.std=F,
            method)
</code></pre>


<h3>Details</h3>

<p>These are not intended for use by users.
<code>check.match</code> check whether a given method matches with the response family.
<code>createFolds</code> the createFolds function is cited from the 'caret' library, which is a large r package for machine learning. To improve the independency of our package we copied this single function instead of loading the whole caret package. It is safely to ignore the warning if you have loaded the caret the package.
<code>cv.multiFit</code> used to fit models in cross-validation stacking
<code>rs.multiFit</code> used to fit models in residual stacking
<code>resid.bin</code> calculate residual of different types
</p>

<hr>
<h2 id='multiFit'>Fit models on multiple outcomes</h2><span id='topic+multiFit'></span>

<h3>Description</h3>

<p>This function fit individual models to predict each outcome separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiFit(xmat, ymat, method, family)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multiFit_+3A_xmat">xmat</code></td>
<td>
<p>Matrix of predictors, each row is an observation vector</p>
</td></tr>
<tr><td><code id="multiFit_+3A_ymat">ymat</code></td>
<td>
<p>Matrix of outcomes. Quantitative for family = &quot;gaussian&quot; and a factor of two levels for family = &quot;binomial&quot;</p>
</td></tr>
<tr><td><code id="multiFit_+3A_method">method</code></td>
<td>
<p>Method for fitting models. It can be one base learner function for all outcomes or a list of base learner functions for each outcome. The list of all base learners can be obtained by <code>list.learners()</code>.</p>
</td></tr>
<tr><td><code id="multiFit_+3A_family">family</code></td>
<td>
<p>Response type for each response. If all response variable are within the same family it can be &quot;gaussian&quot; or &quot;binomial&quot;, otherwise it is a vector of &quot;gaussian&quot; or &quot;binomial&quot; to indicate each response family</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a multiFit object. It is a list of 5 parameters containing information about the fitted models and fitted values for each outcome.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("HIV")
set.seed(1)
xmat &lt;- as.matrix(XX)
ymat &lt;- as.matrix(YY)
id &lt;- createFolds(rowMeans(XX), k=5, list=FALSE)
training.id &lt;- id != 1
y.train &lt;- ymat[training.id, ]
y.test  &lt;- ymat[!training.id, ]
x.train &lt;- xmat[training.id, ]
x.test  &lt;- xmat[!training.id, ]
fit &lt;- multiFit(xmat = x.train, ymat = y.train,
                method = rpart1, family = "gaussian")
predict(fit, x.test)

# using different base learners for different outcomes
fit.mixOut &lt;- multiFit(xmat = x.train, ymat = y.train,
                method = c(rpart1, rpart1, glmnet.ridge,lm1,lm1),
                family = "gaussian")
predict(fit.mixOut, x.test)
</code></pre>

<hr>
<h2 id='predict.MTPS'>Make predictions from a &quot;MTPS&quot; model</h2><span id='topic+predict.MTPS'></span>

<h3>Description</h3>

<p>This function makes predictions from a revised stacking model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MTPS'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.MTPS_+3A_object">object</code></td>
<td>
<p>A fitted object from <code>"MTPS"</code></p>
</td></tr>
<tr><td><code id="predict.MTPS_+3A_newdata">newdata</code></td>
<td>
<p>Matrix of new predictors at which predictions are to be made</p>
</td></tr>
<tr><td><code id="predict.MTPS_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the predictions produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The predicted value from new predictors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("HIV")
set.seed(1)
xmat &lt;- as.matrix(XX)
ymat &lt;- as.matrix(YY)
id &lt;- createFolds(rowMeans(XX), k=5, list=FALSE)
training.id &lt;- id != 1
y.train &lt;- ymat[training.id, ]
y.test  &lt;- ymat[!training.id, ]
x.train &lt;- xmat[training.id, ]
x.test  &lt;- xmat[!training.id, ]
# Cross-Validation Residual Stacking
fit.rs &lt;- MTPS(xmat = x.train, ymat = y.train,
  family = "gaussian",cv = FALSE, residual = TRUE,
  method.step1 = rpart1, method.step2 = lm1)
pred.rs &lt;- predict(fit.rs, x.test)
</code></pre>

<hr>
<h2 id='predict.multiFit'>Make predictions for multiple outcomes</h2><span id='topic+predict.multiFit'></span>

<h3>Description</h3>

<p>This function makes predictions from a multiFit object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiFit'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.multiFit_+3A_object">object</code></td>
<td>
<p>A fitted object from <code>"multiFit"</code></p>
</td></tr>
<tr><td><code id="predict.multiFit_+3A_newdata">newdata</code></td>
<td>
<p>Matrix of new predictors at which predictions are to be made</p>
</td></tr>
<tr><td><code id="predict.multiFit_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the predictions produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The predicted value from new predictors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("HIV")
set.seed(1)
xmat &lt;- as.matrix(XX)
ymat &lt;- as.matrix(YY)
id &lt;- createFolds(rowMeans(XX), k=5, list=FALSE)
training.id &lt;- id != 1
y.train &lt;- ymat[training.id, ]
y.test  &lt;- ymat[!training.id, ]
x.train &lt;- xmat[training.id, ]
x.test  &lt;- xmat[!training.id, ]
fit &lt;- multiFit(xmat = x.train, ymat = y.train,
                method = rpart1, family = "gaussian")
predict(fit, x.test)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
