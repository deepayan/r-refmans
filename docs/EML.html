<!DOCTYPE html><html lang="en-US"><head><title>Help for package EML</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EML}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#build_factors'><p>build factor table</p></a></li>
<li><a href='#build_units_table'><p>build units table</p></a></li>
<li><a href='#detect_delim'><p>Automatically detect line delimiters in a text file</p></a></li>
<li><a href='#eml'><p>eml</p></a></li>
<li><a href='#eml_get'><p>eml_get</p></a></li>
<li><a href='#eml_validate'><p>eml_validate</p></a></li>
<li><a href='#get_attributes'><p>get_attributes</p></a></li>
<li><a href='#get_numberType'><p>Get EML numberType</p></a></li>
<li><a href='#get_unit_id'><p>get_unit_id</p></a></li>
<li><a href='#get_unitList'><p>get_unitList</p></a></li>
<li><a href='#htmlwidgets_attributes'><p>Launch attributes htmlwidget</p></a></li>
<li><a href='#is_standardUnit'><p>is_standardUnit</p></a></li>
<li><a href='#read_eml'><p>read_eml</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#set_attributes'><p>set_attributes</p></a></li>
<li><a href='#set_coverage'><p>set_coverage</p></a></li>
<li><a href='#set_methods'><p>set_methods</p></a></li>
<li><a href='#set_physical'><p>set_physical</p></a></li>
<li><a href='#set_responsibleParty'><p>set_responsibleParty</p></a></li>
<li><a href='#set_software'><p>set_software</p></a></li>
<li><a href='#set_taxonomicCoverage'><p>set_taxonomicCoverage</p></a></li>
<li><a href='#set_TextType'><p>set_TextType</p></a></li>
<li><a href='#set_unitList'><p>set_unitList</p></a></li>
<li><a href='#shiny_attributes'><p>Create/Edit EML attributes</p></a></li>
<li><a href='#table_to_r'><p>handsontable to r</p></a></li>
<li><a href='#write_eml'><p>write_eml</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Read and Write Ecological Metadata Language Files</td>
</tr>
<tr>
<td>Description:</td>
<td>Work with Ecological Metadata Language ('EML') files. 
    'EML' is a widely used metadata standard in the ecological and
    environmental sciences, described in Jones et al. (2006),
    &lt;<a href="https://doi.org/10.1146%2Fannurev.ecolsys.37.091305.110031">doi:10.1146/annurev.ecolsys.37.091305.110031</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.6.1</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/EML/">https://docs.ropensci.org/EML/</a>, <a href="https://github.com/ropensci/EML/">https://github.com/ropensci/EML/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/EML/issues">https://github.com/ropensci/EML/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, taxadb, tibble, testthat, covr, EML, units,
htmlwidgets, shiny, shinyjs, spelling</td>
</tr>
<tr>
<td>Imports:</td>
<td>xml2, methods, digest, emld (&ge; 0.5.0), jqr, jsonlite, uuid,
rmarkdown, utils, dplyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-28 17:05:30 UTC; cboettig</td>
</tr>
<tr>
<td>Author:</td>
<td>Carl Boettiger <a href="https://orcid.org/0000-0002-1642-628X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Matthew B. Jones <a href="https://orcid.org/0000-0003-0077-4738"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Mitchell Maier <a href="https://orcid.org/0000-0001-6955-0535"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Bryce Mecum <a href="https://orcid.org/0000-0002-0381-3766"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  MaÃ«lle Salmon <a href="https://orcid.org/0000-0002-2815-0399"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Jeanette Clark <a href="https://orcid.org/0000-0003-4703-1974"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carl Boettiger &lt;cboettig@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-28 17:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='build_factors'>build factor table</h2><span id='topic+build_factors'></span>

<h3>Description</h3>

<p>builds factor table for shiny app
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_factors(att_table, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_factors_+3A_att_table">att_table</code></td>
<td>
<p>(data.frame) input attributes table</p>
</td></tr>
<tr><td><code id="build_factors_+3A_data">data</code></td>
<td>
<p>(data.frame) input data</p>
</td></tr>
</table>

<hr>
<h2 id='build_units_table'>build units table</h2><span id='topic+build_units_table'></span>

<h3>Description</h3>

<p>builds unit table for shiny app
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_units_table(in_units, eml_units)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_units_table_+3A_in_units">in_units</code></td>
<td>
<p>input units</p>
</td></tr>
<tr><td><code id="build_units_table_+3A_eml_units">eml_units</code></td>
<td>
<p>eml units</p>
</td></tr>
</table>

<hr>
<h2 id='detect_delim'>Automatically detect line delimiters in a text file</h2><span id='topic+detect_delim'></span>

<h3>Description</h3>

<p>This helper function was written expressly for <code><a href="#topic+set_physical">set_physical</a></code> to
be able to automate its <code>recordDelimiter</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_delim(path, nchar = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detect_delim_+3A_path">path</code></td>
<td>
<p>(character) File to search for a delimiter</p>
</td></tr>
<tr><td><code id="detect_delim_+3A_nchar">nchar</code></td>
<td>
<p>(numeric) Maximum number of characters to read from disk when
searching</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(character) If found, the delimiter, it not, \r\n
</p>

<hr>
<h2 id='eml'>eml</h2><span id='topic+eml'></span>

<h3>Description</h3>

<p>eml
</p>


<h3>Format</h3>

<p>A list with constructor functions
</p>

<hr>
<h2 id='eml_get'>eml_get</h2><span id='topic+eml_get'></span>

<h3>Description</h3>

<p>eml_get
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eml_get(x, element, from = "list", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eml_get_+3A_x">x</code></td>
<td>
<p>an EML object or child/descendant object</p>
</td></tr>
<tr><td><code id="eml_get_+3A_element">element</code></td>
<td>
<p>name of the element to be extracted.
If multiple occurrences are found, will extract all</p>
</td></tr>
<tr><td><code id="eml_get_+3A_from">from</code></td>
<td>
<p>explicit type for the input format. Possible values:
&quot;xml&quot;, &quot;json&quot;, &quot;list&quot;, or &quot;guess&quot; with &quot;list&quot; as the default.</p>
</td></tr>
<tr><td><code id="eml_get_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- system.file("tests", emld::eml_version(), "eml-datasetWithUnits.xml", package = "emld")
eml &lt;- read_eml(f)
eml_get(eml, "physical")
eml_get(eml, "attributeList")

## The first argument need not be an "eml" class, it could be a child element; e.g.
eml_get(eml$dataset$dataTable, "physical")

</code></pre>

<hr>
<h2 id='eml_validate'>eml_validate</h2><span id='topic+eml_validate'></span>

<h3>Description</h3>

<p>eml_validate processes an EML document using the XSD schema for the
appropriate version of EML and determines if the document is schema-valid
as defined by the XSD specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eml_validate(eml, encoding = "UTF-8", schema = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eml_validate_+3A_eml">eml</code></td>
<td>
<p>file path, xml_document,</p>
</td></tr>
<tr><td><code id="eml_validate_+3A_encoding">encoding</code></td>
<td>
<p>optional encoding for files, default UTF-8.</p>
</td></tr>
<tr><td><code id="eml_validate_+3A_schema">schema</code></td>
<td>
<p>path to schema</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Whether the document is valid (logical)
</p>


<h3>Note</h3>

<p>this function is simply an alias to 'eml_validate' in 'emld' package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

f &lt;- system.file("extdata", "example.xml", package = "emld")

## validate file directly from disk:
eml_validate(f)

## validate an eml object:
eml &lt;- read_eml(f)
eml_validate(eml)


</code></pre>

<hr>
<h2 id='get_attributes'>get_attributes</h2><span id='topic+get_attributes'></span>

<h3>Description</h3>

<p>get_attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_attributes(x, eml = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_attributes_+3A_x">x</code></td>
<td>
<p>an &quot;attributeList&quot; element from an emld object</p>
</td></tr>
<tr><td><code id="get_attributes_+3A_eml">eml</code></td>
<td>
<p>The full eml document, needed only if &lt;references&gt; outside of attributes must be resolved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>EML metadata can use &quot;references&quot; elements which allow one attribute to use metadata
declared elsewhere in the document.  This function will automatically resolve these references
and thus infer the correct metadata.
</p>


<h3>Value</h3>

<p>a data frame whose rows are the attributes (names of each column in the data file)
and whose columns describe metadata about those attributes.  By default separate tables
are given for each type
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("tests", emld::eml_version(), 
  "eml-datasetWithAttributelevelMethods.xml", package = "emld")
eml &lt;- read_eml(f)
get_attributes(eml$dataset$dataTable$attributeList)
</code></pre>

<hr>
<h2 id='get_numberType'>Get EML numberType</h2><span id='topic+get_numberType'></span>

<h3>Description</h3>

<p>returns the EML numberType (either 'real', 'integer', 'whole', or 'natural') of input values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_numberType(values)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_numberType_+3A_values">values</code></td>
<td>
<p>(numeric/character) a vector of values, if vector is non-numeric will return NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numberType of <code>values</code> (either 'real', 'integer', 'whole', or 'natural').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# To get numberType for each column in a data.frame:

unlist(lapply(df, function(x) get_numberType(x)))

## End(Not run)
</code></pre>

<hr>
<h2 id='get_unit_id'>get_unit_id</h2><span id='topic+get_unit_id'></span>

<h3>Description</h3>

<p>A function to assist with getting valid EML unit ids
(see examples). Warning: ensure returned unit is equivalent to
input unit (for example &quot;pH&quot; will return &quot;picohenry&quot; which may
or may not be equivalent to the input unit &quot;pH&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_unit_id(input_units, eml_version = emld::eml_version())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_unit_id_+3A_input_units">input_units</code></td>
<td>
<p>(character|vector) input units that needs
valid EML unit ids</p>
</td></tr>
<tr><td><code id="get_unit_id_+3A_eml_version">eml_version</code></td>
<td>
<p>(character) the eml schema version desired
(there is a change in the way eml units are named from eml-2.1.1
to eml-2.2.0)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(character) A valid EML unit id. If no valid EML unit id
can be found, the function will output a warning, along with a
preformatted custom unit id.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The following all return the same id
get_unit_id("kilometersPerSquareSecond")
get_unit_id("kilometerPerSecondSquared")
get_unit_id("Kilometers per seconds squared")
get_unit_id("km/s^2")
get_unit_id("km s-2")
get_unit_id("s-2 /     kilometers-1") # this works but is not advised

## End(Not run)
</code></pre>

<hr>
<h2 id='get_unitList'>get_unitList</h2><span id='topic+get_unitList'></span>

<h3>Description</h3>

<p>get_unitList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_unitList(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_unitList_+3A_x">x</code></td>
<td>
<p>an emld object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no unitList is provided, the function reads in the eml-unitDictionary defining all standard
units and unitTypes.  This provides a convenient way to look up standard units and their EML-recognized names
when defining metadata, e.g. in the table passed to 'set_attributes()'.
</p>


<h3>Value</h3>

<p>a list with two data.frames: &quot;units&quot;, a table defining unit names, types, and conversions to SI,
and &quot;unitTypes&quot;, defining the type of unit. For instance, the unit table could define &quot;Hertz&quot; as a unit
of unitType frequency, and the unitType define frequency as a type whose dimension is 1/time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Read in additional units defined in a EML file

f &lt;- system.file("tests", emld::eml_version(),
  "eml-datasetWithUnits.xml",
  package = "emld"
)
eml &lt;- read_eml(f)
unitList &lt;- get_unitList(eml)

## Read in the definitions of standard units:
get_unitList()


</code></pre>

<hr>
<h2 id='htmlwidgets_attributes'>Launch attributes htmlwidget</h2><span id='topic+htmlwidgets_attributes'></span>

<h3>Description</h3>

<p>Used to call handsontable html widget to build attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>htmlwidgets_attributes(df, type = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="htmlwidgets_attributes_+3A_df">df</code></td>
<td>
<p>(data.frame) the data.frame of data that needs an attribute table</p>
</td></tr>
<tr><td><code id="htmlwidgets_attributes_+3A_type">type</code></td>
<td>
<p>(character) either &quot;attributes&quot;, &quot;units&quot;, or &quot;factors&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='is_standardUnit'>is_standardUnit</h2><span id='topic+is_standardUnit'></span>

<h3>Description</h3>

<p>is_standardUnit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_standardUnit(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_standardUnit_+3A_x">x</code></td>
<td>
<p>name of unit to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if unit is exact match to the id of
a unit in the Standard Units Table, FALSE otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_standardUnit("amperePerMeter") # TRUE
is_standardUnit("speciesPerSquareMeter") # FALSE
</code></pre>

<hr>
<h2 id='read_eml'>read_eml</h2><span id='topic+read_eml'></span>

<h3>Description</h3>

<p>Read an EML file into R as an emld object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_eml(x, from = "xml")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_eml_+3A_x">x</code></td>
<td>
<p>path to an EML file</p>
</td></tr>
<tr><td><code id="read_eml_+3A_from">from</code></td>
<td>
<p>explicit type for the input format. Possible values:
&quot;xml&quot;, &quot;json&quot;, &quot;list&quot;, or &quot;guess&quot; with &quot;xml&quot; as the default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an emld object (list / S3 object)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata", "example.xml", package = "emld")
eml &lt;- read_eml(f)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+as_emld'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>emld</dt><dd><p><code><a href="emld.html#topic+as_emld">as_emld</a></code></p>
</dd>
</dl>

<hr>
<h2 id='set_attributes'>set_attributes</h2><span id='topic+set_attributes'></span>

<h3>Description</h3>

<p>set_attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_attributes(
  attributes,
  factors = NULL,
  col_classes = NULL,
  missingValues = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_attributes_+3A_attributes">attributes</code></td>
<td>
<p>a joined table of all attribute metadata</p>
</td></tr>
<tr><td><code id="set_attributes_+3A_factors">factors</code></td>
<td>
<p>a table with factor code-definition pairs; see details</p>
</td></tr>
<tr><td><code id="set_attributes_+3A_col_classes">col_classes</code></td>
<td>
<p>optional, list of R column classes ('ordered', 'numeric', 'factor', 'Date', or 'character', case sensitive)
will let the function infer missing 'domain' and 'measurementScale' values for attributes column.
Should be in same order as attributeNames in the attributes table, or be a named list with names corresponding to attributeNames
in the attributes table.</p>
</td></tr>
<tr><td><code id="set_attributes_+3A_missingvalues">missingValues</code></td>
<td>
<p>optional, a table with missing value code-deinition pairs; see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The attributes data frame must use only the recognized column
headers shown here.  The attributes data frame must contain columns for required metadata.
These are:
</p>
<p><strong>For all data:</strong>
</p>

<ul>
<li><p> attributeName (required, free text field)
</p>
</li>
<li><p> attributeDefinition (required, free text field)
</p>
</li>
<li><p> measurementScale (required, &quot;nominal&quot;, &quot;ordinal&quot;, &quot;ratio&quot;, &quot;interval&quot;, or &quot;dateTime&quot;,
case sensitive) but it can be inferred from col_classes.
</p>
</li>
<li><p> domain (required, &quot;numericDomain&quot;, &quot;textDomain&quot;, &quot;enumeratedDomain&quot;, or &quot;dateTimeDomain&quot;,
case sensitive) but it can be inferred from col_classes.
</p>
</li></ul>

<p><strong>For numeric (ratio or interval) data:</strong>
</p>

<ul>
<li><p> unit (required). Unitless values should use &quot;dimensionless&quot; as the unit.
</p>
</li></ul>

<p><strong>For character (textDomain) data:</strong>
</p>

<ul>
<li><p> definition (required)
</p>
</li></ul>

<p><strong>For dateTime data:</strong>
</p>

<ul>
<li><p> formatString (required)
</p>
</li></ul>

<p>Other optional allowed columns in the attributes table are:
source, pattern, precision, numberType, missingValueCode, missingValueCodeExplanation,
attributeLabel, storageType, minimum, maximum
</p>
<p>The <strong>factors</strong> data frame, required for attributes in an enumerated domain, must use only the
following recognized column headers:
</p>

<ul>
<li><p> attributeName (required)
</p>
</li>
<li><p> code (required)
</p>
</li>
<li><p> definition (required)
</p>
</li></ul>

<p>The <strong>missingValues</strong> data frame, optional, can be used in the case that multiple missing value codes
need to be set for the same attribute. This table must contain the following recognized column
headers.
</p>

<ul>
<li><p> attributeName (required)
</p>
</li>
<li><p> code (required)
</p>
</li>
<li><p> definition (required)
</p>
</li></ul>



<h3>Value</h3>

<p>an eml &quot;attributeList&quot; object
</p>

<hr>
<h2 id='set_coverage'>set_coverage</h2><span id='topic+set_coverage'></span>

<h3>Description</h3>

<p>set_coverage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_coverage(
  beginDate = character(),
  endDate = character(),
  date = character(),
  sci_names = character(),
  geographicDescription = character(),
  westBoundingCoordinate = numeric(),
  eastBoundingCoordinate = numeric(),
  northBoundingCoordinate = numeric(),
  southBoundingCoordinate = numeric(),
  altitudeMinimum = numeric(),
  altitudeMaximum = numeric(),
  altitudeUnits = character()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_coverage_+3A_begindate">beginDate</code></td>
<td>
<p>Starting date for temporal coverage range.</p>
</td></tr>
<tr><td><code id="set_coverage_+3A_enddate">endDate</code></td>
<td>
<p>End date for temporal coverage range</p>
</td></tr>
<tr><td><code id="set_coverage_+3A_date">date</code></td>
<td>
<p>give a single date, or vector of single dates covered (instead of beginDate and endDate)</p>
</td></tr>
<tr><td><code id="set_coverage_+3A_sci_names">sci_names</code></td>
<td>
<p>string (space separated) or list or data frame of scientific names for species covered.  See details</p>
</td></tr>
<tr><td><code id="set_coverage_+3A_geographicdescription">geographicDescription</code></td>
<td>
<p>text string describing the geographic location</p>
</td></tr>
<tr><td><code id="set_coverage_+3A_westboundingcoordinate">westBoundingCoordinate</code></td>
<td>
<p>Decimal longitude for west edge bounding box</p>
</td></tr>
<tr><td><code id="set_coverage_+3A_eastboundingcoordinate">eastBoundingCoordinate</code></td>
<td>
<p>Decimal longitude for east edge bounding box</p>
</td></tr>
<tr><td><code id="set_coverage_+3A_northboundingcoordinate">northBoundingCoordinate</code></td>
<td>
<p>Decimal latitude value for north of bounding box</p>
</td></tr>
<tr><td><code id="set_coverage_+3A_southboundingcoordinate">southBoundingCoordinate</code></td>
<td>
<p>Decimal latitude value for south edge of bounding box</p>
</td></tr>
<tr><td><code id="set_coverage_+3A_altitudeminimum">altitudeMinimum</code></td>
<td>
<p>minimum altitude covered by the data (optional)</p>
</td></tr>
<tr><td><code id="set_coverage_+3A_altitudemaximum">altitudeMaximum</code></td>
<td>
<p>maximum altitude covered by the data (optional)</p>
</td></tr>
<tr><td><code id="set_coverage_+3A_altitudeunits">altitudeUnits</code></td>
<td>
<p>name of the units used to measure altitude, if given</p>
</td></tr>
</table>


<h3>Details</h3>

<p>set_coverage provides a simple and concise way to specify most common temporal,
taxonomic, and geographic coverage metadata. For certain studies this will not be
well suited, and users will need the more flexible but more verbose construction using
&quot;new()&quot; methods; for instance, to specify temporal coverage in geological epoch instead
of calendar dates, or to specify taxonomic coverage in terms of other ranks or identifiers.
</p>


<h3>Value</h3>

<p>a coverage object for EML
</p>


<h3>Note</h3>

<p>If &quot;sci_names&quot; is a data frame, column names of the data frame are rank names.
For user-defined &quot;sci_names&quot;, users must make sure that the order of rank names
they specify is from high to low.
Ex. &quot;Kingdom&quot;,&quot;Phylum&quot;,&quot;Class&quot;,&quot;Order&quot;,&quot;Family&quot;,&quot;Genus&quot;,&quot;Species&quot;,&quot;Common&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coverage &lt;-
  set_coverage(
    begin = "2012-06-01", end = "2013-12-31",
    sci_names = "Sarracenia purpurea",
    geographicDescription = "California coast, down through Baja, Mexico",
    west = -122.44, east = -117.15,
    north = 37.38, south = 30.00
  )
</code></pre>

<hr>
<h2 id='set_methods'>set_methods</h2><span id='topic+set_methods'></span>

<h3>Description</h3>

<p>set_methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_methods(
  methods_file,
  instrumentation = character(),
  software = NULL,
  sampling_file = NULL,
  sampling_coverage = NULL,
  sampling_citation = NULL,
  qualityControl_file = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_methods_+3A_methods_file">methods_file</code></td>
<td>
<p>Path to a file (markdown or .docx) containing a description of the methods used</p>
</td></tr>
<tr><td><code id="set_methods_+3A_instrumentation">instrumentation</code></td>
<td>
<p>optional, text describing instrumentation used in methods</p>
</td></tr>
<tr><td><code id="set_methods_+3A_software">software</code></td>
<td>
<p>optional, an EML software node describing software used in methods</p>
</td></tr>
<tr><td><code id="set_methods_+3A_sampling_file">sampling_file</code></td>
<td>
<p>optional, Path to a file (.md or .docx) describing sampling method</p>
</td></tr>
<tr><td><code id="set_methods_+3A_sampling_coverage">sampling_coverage</code></td>
<td>
<p>optional, coverage node for methods, e.g. set_coverage()</p>
</td></tr>
<tr><td><code id="set_methods_+3A_sampling_citation">sampling_citation</code></td>
<td>
<p>optional, a citation element describing the sampling protocol</p>
</td></tr>
<tr><td><code id="set_methods_+3A_qualitycontrol_file">qualityControl_file</code></td>
<td>
<p>optional, path to a file (.md or .docx) describing quality control methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A methods object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- system.file("examples/hf205-methods.md", package = "EML")
set_methods(methods_file = f)

## Can also import from methods written in a .docx MS Word file.
f &lt;- system.file("examples/hf205-methods.docx", package = "EML")
set_methods(methods_file = f)

</code></pre>

<hr>
<h2 id='set_physical'>set_physical</h2><span id='topic+set_physical'></span>

<h3>Description</h3>

<p>Will calculate the file size, checksum, and checksum authentication method
algorithm automatically if the argument <code>objectName</code> is a file that exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_physical(
  objectName,
  id = character(),
  numHeaderLines = character(),
  numFooterLines = character(),
  recordDelimiter = detect_delim(objectName),
  fieldDelimiter = ",",
  collapseDelimiters = logical(),
  literalCharacter = character(),
  quoteCharacter = character(),
  attributeOrientation = "column",
  size = NULL,
  sizeUnit = "bytes",
  authentication = NULL,
  authMethod = NULL,
  characterEncoding = character(),
  encodingMethod = character(),
  compressionMethod = character(),
  url = character()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_physical_+3A_objectname">objectName</code></td>
<td>
<p>name for the object, usually a filename like &quot;hf205-1.csv&quot;</p>
</td></tr>
<tr><td><code id="set_physical_+3A_id">id</code></td>
<td>
<p>optional, an id value for the &lt;physical&gt; element in EML, for use in referencing</p>
</td></tr>
<tr><td><code id="set_physical_+3A_numheaderlines">numHeaderLines</code></td>
<td>
<p>Number of header lines preceding data. Lines are determined by the physicalLineDelimiter, or if it is absent, by the recordDelimiter. This value indicated the number of header lines that should be skipped before starting to parse the data.</p>
</td></tr>
<tr><td><code id="set_physical_+3A_numfooterlines">numFooterLines</code></td>
<td>
<p>Number of footer lines following data. Lines are determined by the physicalLineDelimiter, or if it is absent, by the recordDelimiter. This value indicated the number of footer lines that should be skipped after parsing the data. If this value is omitted, parsers should assume the data continues to the end of the data stream.</p>
</td></tr>
<tr><td><code id="set_physical_+3A_recorddelimiter">recordDelimiter</code></td>
<td>
<p>This element specifies the record delimiter character when the format is text. The record delimiter is usually a linefeed (\n) on UNIX, a carriage return (\r) on MacOS, or both (\r\n) on Windows/DOS. Multiline records are usually delimited with two line ending characters, for example on UNIX it would be two linefeed characters (\n\n). As record delimiters are often non-printing characters, one can use either the special value &quot;\n&quot; to represent a linefeed (ASCII 0x0a) and &quot;\r&quot; to represent a carriage return (ASCII 0x0d). Alternatively, one can use the hex value to represent character values (e.g., 0x0a).</p>
</td></tr>
<tr><td><code id="set_physical_+3A_fielddelimiter">fieldDelimiter</code></td>
<td>
<p>&quot;,&quot; character by default (for csv files). This element specifies a character to be used in the object for indicating the ending column for an attribute. The delimiter character itself is not part of the attribute value, but rather is present in the column following the last character of the value. Typical delimiter characters include commas, tabs, spaces, and semicolons. The only time the fieldDelimiter character is not interpreted as a delimiter is if it is contained in a quoted string (see quoteCharacter) or is immediately preceded by a literalCharacter. Non-printable quote characters can be provided as their hex values, and for tab characters by its ASCII string &quot;\t&quot;. Processors should assume that the field starts in the column following the previous field if the previous field was fixed, or in the column following the delimiter from the previous field if the previous field was delimited.</p>
</td></tr>
<tr><td><code id="set_physical_+3A_collapsedelimiters">collapseDelimiters</code></td>
<td>
<p>The collapseDelimiters element specifies whether sequential delimiters should be treated as a single delimiter or multiple delimiters. An example is when a space delimiter is used; often there may be several repeated spaces that should be treated as a single delimiter, but not always. The valid values are yes or no. If it is set to yes, then consecutive delimiters will be collapsed to one. If set to no or absent, then consecutive delimiters will be treated as separate delimiters. Default behavior is no; hence, consecutive delimiters will be treated as separate delimiters, by default.</p>
</td></tr>
<tr><td><code id="set_physical_+3A_literalcharacter">literalCharacter</code></td>
<td>
<p>This element specifies a character to be used for escaping special character values so that they are treated as literal values. This allows &quot;escaping&quot; for special characters like quotes, commas, and spaces when they are intended to be used in an attribute value rather than being intended as a delimiter. The literalCharacter is typically a \.</p>
</td></tr>
<tr><td><code id="set_physical_+3A_quotecharacter">quoteCharacter</code></td>
<td>
<p>This element specifies a character to be used in the object for quoting values so that field delimiters can be used within the value. This basically allows delimiter &quot;escaping&quot;. The quoteChacter is typically a &quot; or '. When a processor encounters a quote character, it should not interpret any following characters as a delimiter until a matching quote character has been encountered (i.e., quotes come in pairs). It is an error to not provide a closing quote before the record ends. Non-printable quote characters can be provided as their hex values.</p>
</td></tr>
<tr><td><code id="set_physical_+3A_attributeorientation">attributeOrientation</code></td>
<td>
<p>Specifies whether the attributes described in the physical stream are found in columns or rows. The valid values are column or row. If set to 'column', then the attributes are in columns. If set to 'row', then the attributes are in rows. Row orientation is rare.</p>
</td></tr>
<tr><td><code id="set_physical_+3A_size">size</code></td>
<td>
<p>This element contains information of the physical size of the entity, by default represented in bytes unless the sizeUnit attribute is provided to change the units.</p>
</td></tr>
<tr><td><code id="set_physical_+3A_sizeunit">sizeUnit</code></td>
<td>
<p>the unit in which size is measured; default is 'bytes'</p>
</td></tr>
<tr><td><code id="set_physical_+3A_authentication">authentication</code></td>
<td>
<p>This element describes authentication procedures or techniques, typically by giving a checksum value for the object. The method used to compute the authentication value (e.g., MD5) is listed in the method attribute.</p>
</td></tr>
<tr><td><code id="set_physical_+3A_authmethod">authMethod</code></td>
<td>
<p>the method for authentication checksum, e.g. MD5</p>
</td></tr>
<tr><td><code id="set_physical_+3A_characterencoding">characterEncoding</code></td>
<td>
<p>This element contains the name of the character encoding. This is typically ASCII or UTF-8, or one of the other common encodings.</p>
</td></tr>
<tr><td><code id="set_physical_+3A_encodingmethod">encodingMethod</code></td>
<td>
<p>This element lists a encoding method used to encode the object, such as base64, BinHex.</p>
</td></tr>
<tr><td><code id="set_physical_+3A_compressionmethod">compressionMethod</code></td>
<td>
<p>This element lists a compression method used to compress the object, such as zip, compress, etc. Compression and encoding methods must be listed in the order in which they were applied, so that decompression and decoding should occur in the reverse order of the listing. For example, if a file is compressed using zip and then encoded using MIME base64, the compression method would be listed first and the encoding method second.</p>
</td></tr>
<tr><td><code id="set_physical_+3A_url">url</code></td>
<td>
<p>optional. The complete url from which the data file can be downloaded, if possible.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an EML physical object, such as used in a dataTable element to define the format of the data file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set_physical("hf205-01-TPexp1.csv")
# FIXME set recordDelimiter based on user's system?
# FIXME richer distribution options? use set_distribution at top level?
</code></pre>

<hr>
<h2 id='set_responsibleParty'>set_responsibleParty</h2><span id='topic+set_responsibleParty'></span>

<h3>Description</h3>

<p>set_responsibleParty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_responsibleParty(
  givenName = NULL,
  surName = NULL,
  organizationName = NULL,
  positionName = NULL,
  address = NULL,
  phone = NULL,
  electronicMailAddress = NULL,
  onlineUrl = NULL,
  userId = NULL,
  id = NULL,
  email = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_responsibleParty_+3A_givenname">givenName</code></td>
<td>
<p>individual's given names (list or vector for multiple names).  OR a person object.</p>
</td></tr>
<tr><td><code id="set_responsibleParty_+3A_surname">surName</code></td>
<td>
<p>individual name</p>
</td></tr>
<tr><td><code id="set_responsibleParty_+3A_organizationname">organizationName</code></td>
<td>
<p>if party is an organization instead of an individual, name for the org</p>
</td></tr>
<tr><td><code id="set_responsibleParty_+3A_positionname">positionName</code></td>
<td>
<p>individual's position, i.e. &quot;Researcher&quot;, &quot;Graduate Student&quot;, &quot;Professor&quot;</p>
</td></tr>
<tr><td><code id="set_responsibleParty_+3A_address">address</code></td>
<td>
<p>address object, see 'eml$address' to build an address object</p>
</td></tr>
<tr><td><code id="set_responsibleParty_+3A_phone">phone</code></td>
<td>
<p>individual or organization phone number</p>
</td></tr>
<tr><td><code id="set_responsibleParty_+3A_electronicmailaddress">electronicMailAddress</code></td>
<td>
<p>email address (alternatively, can use 'email' argument)</p>
</td></tr>
<tr><td><code id="set_responsibleParty_+3A_onlineurl">onlineUrl</code></td>
<td>
<p>a URL to the homepage of the individual or organization</p>
</td></tr>
<tr><td><code id="set_responsibleParty_+3A_userid">userId</code></td>
<td>
<p>the user's ID, usually within a particular system (KNB, DataONE)</p>
</td></tr>
<tr><td><code id="set_responsibleParty_+3A_id">id</code></td>
<td>
<p>Identifier for this block, ideally an ORCID id (optional)</p>
</td></tr>
<tr><td><code id="set_responsibleParty_+3A_email">email</code></td>
<td>
<p>alias for electronicMailAddress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A emld object for any responsibleParty (e.g. creator, contact, etc)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>carl &lt;- set_responsibleParty(as.person("Carl Boettiger &lt;cboettig@ropensci.org&gt;"))
matt &lt;- set_responsibleParty("Matthew", "Jones", email = "mbjones@nceas.ucsb.edu")
</code></pre>

<hr>
<h2 id='set_software'>set_software</h2><span id='topic+set_software'></span>

<h3>Description</h3>

<p>set_software
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_software(codemeta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_software_+3A_codemeta">codemeta</code></td>
<td>
<p>codemeta object, see examples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an eml software element
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cm &lt;- jsonlite::read_json(system.file("extdata/codemeta.json", package = "EML"))
software &lt;- set_software(cm)
my_eml &lt;- eml$eml(packageId = "eml-1.2", system = "knb", software = software)

# write_eml(my_eml, "test.xml")
</code></pre>

<hr>
<h2 id='set_taxonomicCoverage'>set_taxonomicCoverage</h2><span id='topic+set_taxonomicCoverage'></span>

<h3>Description</h3>

<p>set_taxonomicCoverage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_taxonomicCoverage(sci_names, expand = FALSE, db = "itis")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_taxonomicCoverage_+3A_sci_names">sci_names</code></td>
<td>
<p>string (space separated) or list or data frame of scientific names for species covered.</p>
</td></tr>
<tr><td><code id="set_taxonomicCoverage_+3A_expand">expand</code></td>
<td>
<p>Set to TRUE to use '[taxadb]' to expand sci_names into full taxonomic classifications</p>
</td></tr>
<tr><td><code id="set_taxonomicCoverage_+3A_db">db</code></td>
<td>
<p>The taxonomic database to query (when expand is set to <code>TRUE</code>). See &lsquo;[taxadb::filter_name]' for valid options. Defaults to &rsquo;itis'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Turn a data.frame or a list of scientific names into a taxonomicCoverage block
sci_names can be a space-separated character string or a data frame with column names as rank name
or a list of user-defined taxonomicClassification
</p>


<h3>Value</h3>

<p>a taxonomicCoverage object for EML
</p>


<h3>Note</h3>

<p>If &quot;sci_names&quot; is a data frame, column names of the data frame are rank names.
For user-defined &quot;sci_names&quot;, users must make sure that the order of rank names
they specify is from high to low.
Ex. &quot;Kingdom&quot;,&quot;Phylum&quot;,&quot;Class&quot;,&quot;Order&quot;,&quot;Family&quot;,&quot;Genus&quot;,&quot;Species&quot;,&quot;Common&quot;
EML permits any rank names provided they go in descending order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
taxon_coverage &lt;- set_taxonomicCoverage("Macrocystis pyrifera")

sci_names &lt;- data.frame(
  Kingdom = "Plantae",
  Phylum = "Phaeophyta",
  Class = "Phaeophyceae",
  Order = "Laminariales",
  Family = "Lessoniaceae",
  Genus = "Macrocystis",
  specificEpithet = "pyrifera"
)
taxon_coverage &lt;- set_taxonomicCoverage(sci_names)

 # Examples that may take &gt; 5s

## use a list of lists for multiple species
sci_names &lt;- list(list(
  Kingdom = "Plantae",
  Phylum = "Phaeophyta",
  Class = "Phaeophyceae",
  Order = "Laminariales",
  Family = "Lessoniaceae",
  Genus = "Macrocystis",
  specificEpithet = "pyrifera"
))
set_taxonomicCoverage(sci_names)


</code></pre>

<hr>
<h2 id='set_TextType'>set_TextType</h2><span id='topic+set_TextType'></span>

<h3>Description</h3>

<p>For any EML element of class TextType, this function can be used to generate
the appropriate EML from a markdown-formatted file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_TextType(file = NULL, text = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_TextType_+3A_file">file</code></td>
<td>
<p>path to a file providing formatted input text, see details.</p>
</td></tr>
<tr><td><code id="set_TextType_+3A_text">text</code></td>
<td>
<p>a plain text character string which will be used directly as the content
of the node if no file is given</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the 'rmarkdown' package is installed, then the input file can
be a Microsoft Word (.docx) file, a markdown file, or other file
recognized by Pandoc (see https://pandoc.org), which will automate the conversion
to a docbook. Otherwise, the input file should already be in docbook format (with
.xml or .dbk extension).  Note that pandoc comes pre-installed in RStudio and is
required for the rmarkdown package.
</p>


<h3>Value</h3>

<p>a TextType object that can be coerced into any element inheriting from TextType, see examples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## using a simple character string
a &lt;- set_TextType(text = "This is the abstract")

## Using an external markdown file
f &lt;- system.file("examples/hf205-abstract.md", package = "EML")
a &lt;- set_TextType(f)

## Can also import from methods written in a .docx MS Word file.
f &lt;- system.file("examples/hf205-abstract.docx", package = "EML")
a &lt;- set_TextType(f)

## Documents with title headings use `section` instead of `para` notation
f &lt;- system.file("examples/hf205-methods.docx", package = "EML")
d &lt;- set_TextType(f)


</code></pre>

<hr>
<h2 id='set_unitList'>set_unitList</h2><span id='topic+set_unitList'></span>

<h3>Description</h3>

<p>Define custom units, including new unitTypes.  Note that it is not necessary to define
most common units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_unitList(units, unitTypes = NULL, as_metadata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_unitList_+3A_units">units</code></td>
<td>
<p>a data.frame describing the custom units, see details.</p>
</td></tr>
<tr><td><code id="set_unitList_+3A_unittypes">unitTypes</code></td>
<td>
<p>optional, a data.frame defining any additional unitTypes not already defined</p>
</td></tr>
<tr><td><code id="set_unitList_+3A_as_metadata">as_metadata</code></td>
<td>
<p>logical, default FALSE. If true, returns an 'additionalMetadata' element, see below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The units data.frame must have the following columns:
- id: the referenced name of unit (singular). e.g. 'meter', 'second'
- unitType: the base type of unit, e.g. 'length'.  If not from a standard type, a new unitType must be provided
- multiplierToSI: the multiplicative constant to convert to the SI unit.
- parentSI: the name of the parent SI unit, e.g. second.
- description: a text string describing the unit of measure.
The following columns are optional:
- name: usually the same as the id of the unit, e.g. second
- abbreviation: common abbreviation, e.g. s
- constantToSI: an additive constant to convert to the equivalent SI unit. If not given, default is &quot;0&quot;
</p>
<p>In practice, researchers may save these tables of custom units they frequently use in an external .csv
or other format and read them in to R for ready re-use.
</p>
<p>The unitType table must have the following columns:
- id: the name by which the unitType is referred to.
- name: optional, default is same as the id
- dimension: name of a base dimension of the unit
- power: the power to which the dimension is raised (NA implies power of 1)
</p>


<h3>Value</h3>

<p>unitList list object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create the "unitType" table for custom unit
id &lt;- c("speed", "speed", "acceleration", "acceleration", "frequency")
dimension &lt;- c("length", "time", "length", "time", "time")
power &lt;- c(NA, "-1", NA, "-2", "-1")
unitTypes &lt;- data.frame(
  id = id, dimension = dimension,
  power = power, stringsAsFactors = FALSE
)

## Create the units table
id &lt;- c("minute", "centimeter")
unitType &lt;- c("time", "length")
parentSI &lt;- c("second", "meter")
multiplierToSI &lt;- c("0.0166", "1")
description &lt;- c("one minute is 60 seconds", "centimeter is a 100th of a meter")
units &lt;- data.frame(
  id = id, unitType = unitType, parentSI = parentSI,
  multiplierToSI = multiplierToSI, description = description,
  stringsAsFactors = FALSE
)

unitList &lt;- set_unitList(units, unitTypes)
</code></pre>

<hr>
<h2 id='shiny_attributes'>Create/Edit EML attributes</h2><span id='topic+shiny_attributes'></span>

<h3>Description</h3>

<p>Create/edit EML attributes, custom units, and factors in a shiny environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shiny_attributes(data = NULL, attributes = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shiny_attributes_+3A_data">data</code></td>
<td>
<p>(data.frame) the data.frame of data that needs an attribute table</p>
</td></tr>
<tr><td><code id="shiny_attributes_+3A_attributes">attributes</code></td>
<td>
<p>(data.frame) an existing attributes table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Attributes can be created from scratch using <code>shiny_attributes()</code>.
Or an existing attribute table can be edited using <code>shiny_attributes(NULL, attributes)</code>.
Or new attributes can be created from a data table using <code>shiny_attributes(data, NULL)</code>.
If attributes are created from a data table, fields such as 'attributeName' and 'numberType' will be automatically
completed based on the attributes within the data table.
If both existing attributes and data table are entered (i.e. <code>shiny_attributes(data, attributes)</code>),
any automatically generated fields based attributes within the data table **will not** override any non-empty fields in the
entered attributes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# from scratch
out &lt;- shiny_attributes(NULL, NULL)

# from data
data &lt;- iris
out &lt;- shiny_attributes(data, NULL)

# from exisiting attributes
file &lt;- system.file("tests", emld::eml_version(),
  "eml-datasetWithAttributelevelMethods.xml",
  package = "emld"
)
eml &lt;- read_eml(file)
x &lt;- eml$dataset$dataTable$attributeList
df &lt;- get_attributes(x, eml)
out &lt;- shiny_attributes(NULL, df$attributes)

# from attributes and data
out &lt;- shiny_attributes(data, df$attributes)

## End(Not run)
</code></pre>

<hr>
<h2 id='table_to_r'>handsontable to r</h2><span id='topic+table_to_r'></span>

<h3>Description</h3>

<p>Takes a handsontable and converts to r data.frame for shiny app
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_to_r(table)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="table_to_r_+3A_table">table</code></td>
<td>
<p>input table</p>
</td></tr>
</table>

<hr>
<h2 id='write_eml'>write_eml</h2><span id='topic+write_eml'></span>

<h3>Description</h3>

<p>write_eml
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_eml(eml, file, namespaces = NULL, ns = "eml", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_eml_+3A_eml">eml</code></td>
<td>
<p>an emld class object</p>
</td></tr>
<tr><td><code id="write_eml_+3A_file">file</code></td>
<td>
<p>file name to write XML.</p>
</td></tr>
<tr><td><code id="write_eml_+3A_namespaces">namespaces</code></td>
<td>
<p>named character vector of additional XML namespaces to use.</p>
</td></tr>
<tr><td><code id="write_eml_+3A_ns">ns</code></td>
<td>
<p>root namespace abbreviation</p>
</td></tr>
<tr><td><code id="write_eml_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>write_xml</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If file is not specified, the result is a character string containing
the resulting XML content. Otherwise return silently.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata", "example.xml", package = "emld")
eml &lt;- read_eml(f)
write_eml(eml, "test.xml")
eml_validate("test.xml")
unlink("test.xml") # clean up
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
