<!DOCTYPE html><html><head><title>Help for package TruncatedNormal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TruncatedNormal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.cholpermGB'><p>Cholesky matrix decomposition with GGE ordering</p></a></li>
<li><a href='#.cholpermGGE'><p>Cholesky matrix decomposition with GGE ordering</p></a></li>
<li><a href='#.dmvnorm_arma'><p>Multivariate normal density function</p></a></li>
<li><a href='#.dmvt_arma'><p>Multivariate Student density function</p></a></li>
<li><a href='#cholperm'><p>Cholesky decomposition for Gaussian distribution function with permutation</p></a></li>
<li><a href='#dtmvnorm'><p>Density function for the truncated multivariate normal distribution</p></a></li>
<li><a href='#dtmvt'><p>Density function for the truncated multivariate Student distribution</p></a></li>
<li><a href='#lnNpr'><p>Calculate log of Gaussian distribution function accurately</p></a></li>
<li><a href='#lupus'><p>Latent membranous Lupus Nephritis dataset</p></a></li>
<li><a href='#mroz'><p>Women wage dataset from Mroz (1987)</p></a></li>
<li><a href='#mvNcdf'><p>Truncated multivariate normal cumulative distribution</p></a></li>
<li><a href='#mvNqmc'><p>Truncated multivariate normal cumulative distribution  (quasi-Monte Carlo)</p></a></li>
<li><a href='#mvrandn'><p>Truncated multivariate normal generator</p></a></li>
<li><a href='#mvrandt'><p>Random number generation from multivariate truncated Student distribution</p></a></li>
<li><a href='#mvTcdf'><p>Truncated multivariate student cumulative distribution</p></a></li>
<li><a href='#mvTqmc'><p>Truncated multivariate student cumulative distribution (QMC version)</p></a></li>
<li><a href='#norminvp'><p>Normal quantile function (high precision)</p></a></li>
<li><a href='#Phinv'><p>Quantile of truncated Gaussian</p></a></li>
<li><a href='#pmvnorm'><p>Distribution function of the multivariate normal distribution for arbitrary limits</p></a></li>
<li><a href='#pmvt'><p>Distribution function of the multivariate Student distribution for arbitrary limits</p></a></li>
<li><a href='#ptmvnorm'><p>Cumulative distribution function of the truncated multivariate normal distribution.</p></a></li>
<li><a href='#ptmvt'><p>Cumulative distribution function of the truncated multivariate Student distribution.</p></a></li>
<li><a href='#qtnorm'><p>Quantile function using the inversion method</p></a></li>
<li><a href='#rtmvnorm'><p>Random number generator for the truncated multivariate normal distribution.</p></a></li>
<li><a href='#rtmvt'><p>Random number generator for the truncated multivariate Student distribution.</p></a></li>
<li><a href='#rtnorm'><p>Vectorized random number generation from the univariate truncated normal distribution</p></a></li>
<li><a href='#tmvnorm'><p>Multivariate truncated normal distribution</p></a></li>
<li><a href='#tmvt'><p>Multivariate truncated Student distribution</p></a></li>
<li><a href='#tnorm'><p>Truncated univariate normal distribution</p></a></li>
<li><a href='#trandn'><p>Fast truncated normal generator</p></a></li>
<li><a href='#tregress'><p>Truncated student generator for Bayesian regression simulation</p></a></li>
<li><a href='#TruncatedNormal-package'>
<p>Truncated Normal Distribution Toolbox</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Truncated Multivariate Normal and Student Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-09-08</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions to deal with the truncated univariate and multivariate normal and Student distributions, described in Botev (2017) &lt;<a href="https://doi.org/10.1111%2Frssb.12162">doi:10.1111/rssb.12162</a>&gt; and Botev and L'Ecuyer (2015) &lt;<a href="https://doi.org/10.1109%2FWSC.2015.7408180">doi:10.1109/WSC.2015.7408180</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lbelzile/TruncatedNormal/issues">https://github.com/lbelzile/TruncatedNormal/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>nleqslv, randtoolbox, alabama, Rcpp (&ge; 0.12.16)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, mvtnorm, testthat, carData</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-07 14:57:49 UTC; lbelzile</td>
</tr>
<tr>
<td>Author:</td>
<td>Zdravko Botev <a href="https://orcid.org/0000-0001-9054-3452"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Leo Belzile <a href="https://orcid.org/0000-0002-9135-014X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Leo Belzile &lt;belzilel@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-08 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.cholpermGB'>Cholesky matrix decomposition with GGE ordering</h2><span id='topic+.cholpermGB'></span>

<h3>Description</h3>

<p>This function computes the Cholesky decomposition of a covariance matrix
<code>Sigma</code> and returns a list containing the permuted bounds for integration. 
The prioritization of the variables follow the rule proposed in Gibson, Glasbey and Elston (1994)
and reorder variables to have outermost variables with smallest expected values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cholpermGB(Sigma, l, u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".cholpermGB_+3A_sigma">Sigma</code></td>
<td>
<p><code>d</code> by <code>d</code> covariance matrix</p>
</td></tr>
<tr><td><code id=".cholpermGB_+3A_l">l</code></td>
<td>
<p><code>d</code> vector of lower bounds</p>
</td></tr>
<tr><td><code id=".cholpermGB_+3A_u">u</code></td>
<td>
<p><code>d</code> vector of upper bounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list contains an integer vector <code>perm</code> with the indices of the permutation, which is such that
<code>Sigma(perm, perm) == L %*% t(L)</code>.
The permutation scheme is described in Genz and Bretz (2009) in Section 4.1.3, p.37.
</p>


<h3>Value</h3>

<p>a list with components
</p>

<ul>
<li><p><code>L</code>: Cholesky root
</p>
</li>
<li><p><code>l</code>: permuted vector of lower bounds
</p>
</li>
<li><p><code>u</code>: permuted vector of upper bounds
</p>
</li>
<li><p><code>perm</code>: vector of integers with ordering of permutation
</p>
</li></ul>



<h3>References</h3>

<p>Genz, A. and Bretz, F. (2009). Computations of Multivariate Normal and t Probabilities, volume 105. Springer, Dordrecht.
</p>
<p>Gibson G.J., Glasbey C.A. and D.A. Elton (1994).  Monte Carlo evaluation of multivariate normal integrals and sensitivity to variate ordering. In: Dimon et al., Advances in Numerical Methods and Applications, WSP, pp. 120-126.
</p>

<hr>
<h2 id='.cholpermGGE'>Cholesky matrix decomposition with GGE ordering</h2><span id='topic+.cholpermGGE'></span>

<h3>Description</h3>

<p>This function computes the Cholesky decomposition of a covariance matrix
<code>Sigma</code> and returns a list containing the permuted bounds for integration. 
The prioritization of the variables follow the rule proposed in Gibson, Glasbey and Elston (1994)
and reorder variables to have outermost variables with smallest expected values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cholpermGGE(Sigma, l, u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".cholpermGGE_+3A_sigma">Sigma</code></td>
<td>
<p><code>d</code> by <code>d</code> covariance matrix</p>
</td></tr>
<tr><td><code id=".cholpermGGE_+3A_l">l</code></td>
<td>
<p><code>d</code> vector of lower bounds</p>
</td></tr>
<tr><td><code id=".cholpermGGE_+3A_u">u</code></td>
<td>
<p><code>d</code> vector of upper bounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list contains an integer vector <code>perm</code> with the indices of the permutation, which is such that
<code>Sigma(perm, perm) == L %*% t(L)</code>.
The permutation scheme is described in Genz and Bretz (2009) in Section 4.1.3, p.37.
</p>


<h3>Value</h3>

<p>a list with components
</p>

<ul>
<li><p><code>L</code>: Cholesky root
</p>
</li>
<li><p><code>l</code>: permuted vector of lower bounds
</p>
</li>
<li><p><code>u</code>: permuted vector of upper bounds
</p>
</li>
<li><p><code>perm</code>: vector of integers with ordering of permutation
</p>
</li></ul>



<h3>References</h3>

<p>Genz, A. and Bretz, F. (2009). Computations of Multivariate Normal and t Probabilities, volume 105. Springer, Dordrecht.
</p>
<p>Gibson G.J., Glasbey C.A. and D.A. Elton (1994).  Monte Carlo evaluation of multivariate normal integrals and sensitivity to variate ordering. In: Dimon et al., Advances in Numerical Methods and Applications, WSP, pp. 120-126.
</p>

<hr>
<h2 id='.dmvnorm_arma'>Multivariate normal density function</h2><span id='topic+.dmvnorm_arma'></span>

<h3>Description</h3>

<p>This function returns the log-density for a multivariate Gaussian distribution.
The data must be imputed as a matrix, using e.g., <code>as.matrix</code>, with each row
representing an observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.dmvnorm_arma(x, mu, sigma, logd = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".dmvnorm_arma_+3A_x">x</code></td>
<td>
<p>matrix of observations</p>
</td></tr>
<tr><td><code id=".dmvnorm_arma_+3A_mu">mu</code></td>
<td>
<p>mean vector</p>
</td></tr>
<tr><td><code id=".dmvnorm_arma_+3A_sigma">sigma</code></td>
<td>
<p>positive definite covariance matrix</p>
</td></tr>
<tr><td><code id=".dmvnorm_arma_+3A_logd">logd</code></td>
<td>
<p>logical; whether log-density should be returned (default to <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>density or log-density of the <code>nrow(x)</code> sample
</p>

<hr>
<h2 id='.dmvt_arma'>Multivariate Student density function</h2><span id='topic+.dmvt_arma'></span>

<h3>Description</h3>

<p>This function returns the log-density for a multivariate Student distribution.
The data must be imputed as a matrix, using e.g., <code>as.matrix</code>, with each row
representing an observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.dmvt_arma(x, mu, sigma, df, logd = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".dmvt_arma_+3A_x">x</code></td>
<td>
<p>matrix of observations</p>
</td></tr>
<tr><td><code id=".dmvt_arma_+3A_mu">mu</code></td>
<td>
<p>location vector</p>
</td></tr>
<tr><td><code id=".dmvt_arma_+3A_sigma">sigma</code></td>
<td>
<p>positive definite scale matrix</p>
</td></tr>
<tr><td><code id=".dmvt_arma_+3A_df">df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code id=".dmvt_arma_+3A_logd">logd</code></td>
<td>
<p>logical; whether log-density should be returned (default to <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>density or log-density of the <code>nrow(x)</code> sample
</p>

<hr>
<h2 id='cholperm'>Cholesky decomposition for Gaussian distribution function with permutation</h2><span id='topic+cholperm'></span>

<h3>Description</h3>

<p>This function computes the Cholesky decomposition of a covariance matrix
<code>Sigma</code> and returns a list containing the permuted bounds for integration. 
The prioritization of the variables follows either the rule proposed in Gibson, Glasbey and Elston (1994),
reorder variables to have outermost variables with smallest expected values. The alternative is the scheme proposed
in Genz and Bretz (2009) that minimizes the variance of the truncated Normal variates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cholperm(Sigma, l, u, method = c("GGE", "GB"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cholperm_+3A_sigma">Sigma</code></td>
<td>
<p><code>d</code> by <code>d</code> covariance matrix</p>
</td></tr>
<tr><td><code id="cholperm_+3A_l">l</code></td>
<td>
<p><code>d</code> vector of lower bounds</p>
</td></tr>
<tr><td><code id="cholperm_+3A_u">u</code></td>
<td>
<p><code>d</code> vector of upper bounds</p>
</td></tr>
<tr><td><code id="cholperm_+3A_method">method</code></td>
<td>
<p>string indicating which method to use. Default to <code>"GGE"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list contains an integer vector <code>perm</code> with the indices of the permutation, which is such that
<code>Sigma(perm, perm) == L %*% t(L)</code>.
The permutation scheme is described in Genz and Bretz (2009) in Section 4.1.3, p.37.
</p>


<h3>Value</h3>

<p>a list with components
</p>

<ul>
<li><p><code>L</code>: Cholesky root
</p>
</li>
<li><p><code>l</code>: permuted vector of lower bounds
</p>
</li>
<li><p><code>u</code>: permuted vector of upper bounds
</p>
</li>
<li><p><code>perm</code>: vector of integers with ordering of permutation
</p>
</li></ul>



<h3>References</h3>

<p>Genz, A. and Bretz, F. (2009). Computations of Multivariate Normal and t Probabilities, volume 105. Springer, Dordrecht.
</p>
<p>Gibson G.J., Glasbey C.A. and D.A. Elton (1994).  Monte Carlo evaluation of multivariate normal integrals and sensitivity to variate ordering. In: Dimon et al., Advances in Numerical Methods and Applications, WSP, pp. 120-126.
</p>

<hr>
<h2 id='dtmvnorm'>Density function for the truncated multivariate normal distribution</h2><span id='topic+dtmvnorm'></span>

<h3>Description</h3>

<p>This function returns the (log)-density of a matrix <code>x</code> of observations lying in the interval [<code>lb</code>, <code>ub</code>].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtmvnorm(x, mu, sigma, lb, ub, log = FALSE, type = c("mc", "qmc"), B = 10000)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+tmvnorm">tmvnorm</a></code>
</p>

<hr>
<h2 id='dtmvt'>Density function for the truncated multivariate Student distribution</h2><span id='topic+dtmvt'></span>

<h3>Description</h3>

<p>This function returns the (log)-density of a matrix <code>x</code> of observations lying in the interval [<code>lb</code>, <code>ub</code>].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtmvt(x, mu, sigma, df, lb, ub, type = c("mc", "qmc"), log = FALSE, B = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtmvt_+3A_x">x</code></td>
<td>
<p>vector or matrix of quantiles</p>
</td></tr>
<tr><td><code id="dtmvt_+3A_mu">mu</code></td>
<td>
<p>vector of location parameters</p>
</td></tr>
<tr><td><code id="dtmvt_+3A_sigma">sigma</code></td>
<td>
<p>scale matrix</p>
</td></tr>
<tr><td><code id="dtmvt_+3A_df">df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code id="dtmvt_+3A_lb">lb</code></td>
<td>
<p>vector of lower truncation limits</p>
</td></tr>
<tr><td><code id="dtmvt_+3A_ub">ub</code></td>
<td>
<p>vector of upper truncation limits</p>
</td></tr>
<tr><td><code id="dtmvt_+3A_type">type</code></td>
<td>
<p>string, either of <code>mc</code> or <code>qmc</code> for Monte Carlo and quasi Monte Carlo, respectively</p>
</td></tr>
<tr><td><code id="dtmvt_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities and density are given on the log scale.</p>
</td></tr>
<tr><td><code id="dtmvt_+3A_b">B</code></td>
<td>
<p>number of replications for the (quasi)-Monte Carlo scheme</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tmvt">tmvt</a></code>
</p>

<hr>
<h2 id='lnNpr'>Calculate log of Gaussian distribution function accurately</h2><span id='topic+lnNpr'></span>

<h3>Description</h3>

<p>This function returns the probability of a standard Gaussian variate between 
the interval <code>a</code> and <code>b</code>, avoiding numerical overflow. The function is vectorized
and is meant to be used only internally by the package <code>TruncatedNormal</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lnNpr(a, b, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lnNpr_+3A_a">a</code></td>
<td>
<p>vector of lower bound</p>
</td></tr>
<tr><td><code id="lnNpr_+3A_b">b</code></td>
<td>
<p>vector of upper bound</p>
</td></tr>
<tr><td><code id="lnNpr_+3A_check">check</code></td>
<td>
<p>logical; should checks be performed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of log probability.
</p>

<hr>
<h2 id='lupus'>Latent membranous Lupus Nephritis dataset</h2><span id='topic+lupus'></span>

<h3>Description</h3>

<p>The data represents two clinical measurements (covariates), which are used to predict the occurrence of latent membranous lupus nephritis. The dataset consists of measurements on 55 patients of which 18 have been diagnosed with latent membranous lupus.
</p>


<h3>Format</h3>

<p>a data frame with columns &quot;response&quot;, &quot;const&quot;, &quot;x1&quot; and &quot;x2&quot;
</p>


<h3>Source</h3>

<p>The data were transcribed from Table 1, page 22, of Dyk and Meng (2001).
</p>


<h3>References</h3>

<p>D. A. van Dyk and X.-L. Meng (2001) <em>The art of data augmentation (with discussion)</em>. Journal of Computational and  Graphical Statistics, volume 10, pages 1-50.
</p>


<h3>See Also</h3>

<p>The dataset is used in the examples of <code><a href="#topic+mvrandn">mvrandn</a></code>
</p>

<hr>
<h2 id='mroz'>Women wage dataset from Mroz (1987)</h2><span id='topic+mroz'></span>

<h3>Description</h3>

<p>The data are from the Panel Study of Income Dynamics (PSID) longitudinal study, 1976 wave.
They give the number of work hours of married women along with socio-economic variables and the number of children.
</p>


<h3>Format</h3>

<p>a data frame containing the following variables:
</p>

<ul>
<li> <p><code>whrs</code>: hours of work
</p>
</li>
<li> <p><code>kidslt6</code>: number of children aged 5 and below years old in household
</p>
</li>
<li> <p><code>kidsge6</code>: number of children between age of 6 and 18 in household
</p>
</li>
<li> <p><code>age</code>: age (in years)
</p>
</li>
<li> <p><code>educ</code>: number of years in school
</p>
</li>
<li> <p><code>hearn</code>: hourly earnings
</p>
</li>
<li> <p><code>exp</code>: years of previous labor market experience
</p>
</li></ul>



<h3>Source</h3>

<p>W. Greene's website, accessed 17.12.2019 at &lt;http://www.stern.nyu.edu/~wgreene/Text/Edition7/TableF5-1.csv&gt;.
</p>


<h3>References</h3>

<p>T. A. Mroz, 1987. <em>The Sensitivity of an Empirical Model of Married Women's Hours of Work to Economic and Statistical Assumptions</em>, Econometrica, <b>55</b>(4), pp. 765-799
</p>


<h3>See Also</h3>

<p><code><a href="carData.html#topic+Mroz">Mroz</a></code>
</p>

<hr>
<h2 id='mvNcdf'>Truncated multivariate normal cumulative distribution</h2><span id='topic+mvNcdf'></span>

<h3>Description</h3>

<p>Computes an estimate and a deterministic upper bound of the probability Pr<code class="reqn">(l&lt;X&lt;u)</code>,
where <code class="reqn">X</code> is a zero-mean multivariate normal vector 
with covariance matrix <code class="reqn">\Sigma</code>, that is, <code class="reqn">X</code> is drawn from <code class="reqn">N(0,\Sigma)</code>.
Infinite values for vectors <code class="reqn">u</code> and <code class="reqn">l</code> are accepted. 
The Monte Carlo method uses sample size <code class="reqn">n</code>; 
the larger <code class="reqn">n</code>, the smaller the relative error of the estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvNcdf(l, u, Sig, n = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvNcdf_+3A_l">l</code></td>
<td>
<p>lower truncation limit</p>
</td></tr>
<tr><td><code id="mvNcdf_+3A_u">u</code></td>
<td>
<p>upper truncation limit</p>
</td></tr>
<tr><td><code id="mvNcdf_+3A_sig">Sig</code></td>
<td>
<p>covariance matrix of <code class="reqn">N(0,\Sigma)</code></p>
</td></tr>
<tr><td><code id="mvNcdf_+3A_n">n</code></td>
<td>
<p>number of Monte Carlo simulations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose you wish to estimate Pr<code class="reqn">(l&lt;AX&lt;u)</code>,
where <code class="reqn">A</code> is a full rank matrix
and <code class="reqn">X</code> is drawn from <code class="reqn">N(\mu,\Sigma)</code>, then you simply compute
Pr<code class="reqn">(l-A\mu&lt;AY&lt;u-A\mu)</code>,
where <code class="reqn">Y</code> is drawn from <code class="reqn">N(0, A\Sigma A^\top)</code>.
</p>


<h3>Value</h3>

<p>a list with components
</p>

<ul>
<li><p><code>prob</code>: estimated value of probability Pr<code class="reqn">(l&lt;X&lt;u)</code>
</p>
</li>
<li><p><code>relErr</code>: estimated relative error of estimator 
</p>
</li>
<li><p><code>upbnd</code>:  theoretical upper bound on true Pr<code class="reqn">(l&lt;X&lt;u)</code> 
</p>
</li></ul>



<h3>Note</h3>

<p>For small dimensions, say <code class="reqn">d&lt;50</code>, better accuracy may be obtained by using 
the (usually slower) quasi-Monte Carlo version  <code><a href="#topic+mvNqmc">mvNqmc</a></code> of this algorithm.
</p>


<h3>Author(s)</h3>

<p>Zdravko I. Botev
</p>


<h3>References</h3>

<p>Z. I. Botev (2017), <em>The Normal Law Under Linear Restrictions:
Simulation and Estimation via Minimax Tilting</em>, Journal of the Royal
Statistical Society, Series B, <b>79</b> (1), pp. 1&ndash;24.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvNqmc">mvNqmc</a></code>, <code><a href="#topic+mvrandn">mvrandn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 15; l &lt;- 1:d; u &lt;- rep(Inf, d);
Sig &lt;- matrix(rnorm(d^2), d, d)*2; Sig=Sig %*% t(Sig)
mvNcdf(l, u, Sig, 1e4) # compute the probability 
</code></pre>

<hr>
<h2 id='mvNqmc'>Truncated multivariate normal cumulative distribution  (quasi-Monte Carlo)</h2><span id='topic+mvNqmc'></span>

<h3>Description</h3>

<p>Computes an estimate and a deterministic upper bound of the probability Pr<code class="reqn">(l&lt;X&lt;u)</code>,
where <code class="reqn">X</code> is a zero-mean multivariate normal vector
with covariance matrix <code class="reqn">\Sigma</code>, that is, <code class="reqn">X</code> is drawn from <code class="reqn">N(0,\Sigma)</code>.
Infinite values for vectors <code class="reqn">u</code> and <code class="reqn">l</code> are accepted.
The Monte Carlo method uses sample size <code class="reqn">n</code>: 
the larger <code class="reqn">n</code>, the smaller the relative error of the estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvNqmc(l, u, Sig, n = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvNqmc_+3A_l">l</code></td>
<td>
<p>lower truncation limit</p>
</td></tr>
<tr><td><code id="mvNqmc_+3A_u">u</code></td>
<td>
<p>upper truncation limit</p>
</td></tr>
<tr><td><code id="mvNqmc_+3A_sig">Sig</code></td>
<td>
<p>covariance matrix of <code class="reqn">N(0,\Sigma)</code></p>
</td></tr>
<tr><td><code id="mvNqmc_+3A_n">n</code></td>
<td>
<p>number of Monte Carlo simulations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose you wish to estimate Pr<code class="reqn">(l&lt;AX&lt;u)</code>,
where <code class="reqn">A</code> is a full rank matrix
and <code class="reqn">X</code> is drawn from <code class="reqn">N(\mu,\Sigma)</code>, then you simply compute
Pr<code class="reqn">(l-A\mu&lt;AY&lt;u-A\mu)</code>,
where <code class="reqn">Y</code> is drawn from <code class="reqn">N(0, A\Sigma A^\top)</code>.
</p>


<h3>Value</h3>

<p>a list with components
</p>

<ul>
<li><p><code>prob</code>: estimated value of probability Pr<code class="reqn">(l&lt;X&lt;u)</code>
</p>
</li>
<li><p><code>relErr</code>: estimated relative error of estimator
</p>
</li>
<li><p><code>upbnd</code>:  theoretical upper bound on true Pr<code class="reqn">(l&lt;X&lt;u)</code>
</p>
</li></ul>



<h3>Note</h3>

<p>This version uses a Quasi Monte Carlo (QMC) pointset
of size <code>ceiling(n/12)</code> and estimates the relative error
using 12 independent randomized QMC estimators. QMC
is slower than ordinary Monte Carlo,
but is also likely to be more accurate when <code class="reqn">d&lt;50</code>.
For high dimensions, say <code class="reqn">d&gt;50</code>, you may obtain the same accuracy using
the (typically faster) <code><a href="#topic+mvNcdf">mvNcdf</a></code>.
</p>


<h3>Author(s)</h3>

<p>Zdravko I. Botev
</p>


<h3>References</h3>

<p>Z. I. Botev (2017), <em>The Normal Law Under Linear Restrictions:
Simulation and Estimation via Minimax Tilting</em>, Journal of the Royal
Statistical Society, Series B, <b>79</b> (1), pp. 1&ndash;24.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvNcdf">mvNcdf</a></code>, <code><a href="#topic+mvrandn">mvrandn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 15 
l &lt;- 1:d
u &lt;- rep(Inf, d)
Sig &lt;- matrix(rnorm(d^2), d, d)*2 
Sig &lt;- Sig %*% t(Sig)
mvNqmc(l, u, Sig, 1e4) # compute the probability
</code></pre>

<hr>
<h2 id='mvrandn'>Truncated multivariate normal generator</h2><span id='topic+mvrandn'></span>

<h3>Description</h3>

<p>Simulate <code class="reqn">n</code>  independent and identically distributed random vectors
from the <code class="reqn">d</code>-dimensional <code class="reqn">N(0,\Sigma)</code> distribution
(zero-mean normal with covariance <code class="reqn">\Sigma</code>) conditional on <code class="reqn">l&lt;X&lt;u</code>.
Infinite values for <code class="reqn">l</code> and <code class="reqn">u</code> are accepted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvrandn(l, u, Sig, n, mu = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvrandn_+3A_l">l</code></td>
<td>
<p>lower truncation limit</p>
</td></tr>
<tr><td><code id="mvrandn_+3A_u">u</code></td>
<td>
<p>upper truncation limit</p>
</td></tr>
<tr><td><code id="mvrandn_+3A_sig">Sig</code></td>
<td>
<p>covariance matrix</p>
</td></tr>
<tr><td><code id="mvrandn_+3A_n">n</code></td>
<td>
<p>number of simulated vectors</p>
</td></tr>
<tr><td><code id="mvrandn_+3A_mu">mu</code></td>
<td>
<p>location parameter</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p>Bivariate normal:
Suppose we wish to simulate a bivariate <code class="reqn">X</code> from <code class="reqn">N(\mu,\Sigma)</code>, conditional on
<code class="reqn">X_1-X_2&lt;-6</code>. We can recast this as the problem of simulation
of <code class="reqn">Y</code> from <code class="reqn">N(0,A\Sigma A^\top)</code> (for an appropriate matrix <code class="reqn">A</code>)
conditional on <code class="reqn">l-A\mu &lt; Y &lt; u-A\mu</code> and then setting <code class="reqn">X=\mu+A^{-1}Y</code>.
See the example code below.
</p>
</li>
<li><p>Exact posterior simulation for Probit regression:Consider the
Bayesian Probit Regression model applied to the <code><a href="#topic+lupus">lupus</a></code> dataset.
Let the prior for the regression coefficients <code class="reqn">\beta</code> be <code class="reqn">N(0,\nu^2 I)</code>. Then, to simulate from the Bayesian
posterior exactly, we first simulate
<code class="reqn">Z</code> from <code class="reqn">N(0,\Sigma)</code>, where  <code class="reqn">\Sigma=I+\nu^2 X X^\top,</code>
conditional on <code class="reqn">Z\ge 0</code>. Then, we simulate the posterior regression coefficients, <code class="reqn">\beta</code>, of the Probit regression
by drawing <code class="reqn">(\beta|Z)</code> from <code class="reqn">N(C X^\top Z,C)</code>, where <code class="reqn">C^{-1}=I/\nu^2+X^\top X</code>.
See the example code below.
</p>
</li></ul>



<h3>Value</h3>

<p>a <code class="reqn">d</code> by <code class="reqn">n</code> matrix storing the random vectors, <code class="reqn">X</code>, drawn from <code class="reqn">N(0,\Sigma)</code>, conditional on <code class="reqn">l&lt;X&lt;u</code>;
</p>


<h3>Note</h3>

<p>The algorithm may not work or be very inefficient if <code class="reqn">\Sigma</code> is close to being rank deficient.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvNqmc">mvNqmc</a></code>, <code><a href="#topic+mvNcdf">mvNcdf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Bivariate example.

 Sig &lt;- matrix(c(1,0.9,0.9,1), 2, 2);
 mu &lt;- c(-3,0); l &lt;- c(-Inf,-Inf); u &lt;- c(-6,Inf);
 A &lt;- matrix(c(1,0,-1,1),2,2);
 n &lt;- 1e3; # number of sampled vectors
 Y &lt;- mvrandn(l - A %*% mu, u - A %*% mu, A %*% Sig %*% t(A), n);
 X &lt;- rep(mu, n) + solve(A, diag(2)) %*% Y;
 # now apply the inverse map as explained above
 plot(X[1,], X[2,]) # provide a scatterplot of exactly simulated points
## Not run: 
# Exact Bayesian Posterior Simulation Example.

data("lupus"); # load lupus data
Y = lupus[,1]; # response data
X = lupus[,-1]  # construct design matrix
m=dim(X)[1]; d=dim(X)[2]; # dimensions of problem
 X=diag(2*Y-1) %*%X; # incorporate response into design matrix
 nu=sqrt(10000); # prior scale parameter
 C=solve(diag(d)/nu^2+t(X)%*%X);
 L=t(chol(t(C))); # lower Cholesky decomposition
 Sig=diag(m)+nu^2*X %*% t(X); # this is covariance of Z given beta
 l=rep(0,m);u=rep(Inf,m);
 est=mvNcdf(l,u,Sig,1e3);
 # estimate acceptance probability of Crude Monte Carlo
 print(est$upbnd/est$prob)
 # estimate the reciprocal of acceptance probability
 n=1e4 # number of iid variables
 z=mvrandn(l,u,Sig,n);
 # sample exactly from auxiliary distribution
 beta=L %*% matrix(rnorm(d*n),d,n)+C %*% t(X) %*% z;
 # simulate beta given Z and plot boxplots of marginals
 boxplot(t(beta))
 # plot the boxplots of the marginal
 # distribution of the coefficients in beta
 print(rowMeans(beta)) # output the posterior means
 
## End(Not run)
</code></pre>

<hr>
<h2 id='mvrandt'>Random number generation from multivariate truncated Student distribution</h2><span id='topic+mvrandt'></span>

<h3>Description</h3>

<p>Random number generation from multivariate truncated Student distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvrandt(l, u, Sig, df, n, mu = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvrandt_+3A_l">l</code></td>
<td>
<p>lower bound for truncation (infinite values allowed)</p>
</td></tr>
<tr><td><code id="mvrandt_+3A_u">u</code></td>
<td>
<p>upper bound for truncation</p>
</td></tr>
<tr><td><code id="mvrandt_+3A_sig">Sig</code></td>
<td>
<p>covariance matrix</p>
</td></tr>
<tr><td><code id="mvrandt_+3A_df">df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code id="mvrandt_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="mvrandt_+3A_mu">mu</code></td>
<td>
<p>location parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>d</code> by <code>n</code> matrix
</p>


<h3>Author(s)</h3>

<p><code>Matlab</code> code by Zdravko Botev, <code>R</code> port by Leo Belzile
</p>


<h3>References</h3>

<p>Z. I. Botev and P. L'Ecuyer (2015), Efficient probability estimation
and simulation of the truncated multivariate Student-t distribution,
Proceedings of the 2015 Winter Simulation Conference, pp. 380-391,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
d &lt;- 60L; n &lt;- 1e3;
Sig &lt;- 0.9 * matrix(1, d, d) + 0.1 * diag(d);
l &lt;- (1:d)/d * 4; u &lt;- l+2; df &lt;- 10;
X &lt;- mvrandt(l,u,Sig,df,n)
stopifnot(all(X&gt;l))
stopifnot(all(X&lt;u))

## End(Not run)
</code></pre>

<hr>
<h2 id='mvTcdf'>Truncated multivariate student cumulative distribution</h2><span id='topic+mvTcdf'></span>

<h3>Description</h3>

<p>Computes an estimator of the probability Pr<code class="reqn">(l&lt;X&lt;u)</code>,
where <code class="reqn">X</code> is a centered multivariate student vector
with scale matrix <code>Sig</code> and degrees of freedom <code>df</code>.
Infinite values for vectors <code>u</code> and <code>l</code> are accepted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvTcdf(l, u, Sig, df, n = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvTcdf_+3A_l">l</code></td>
<td>
<p>lower bound for truncation (infinite values allowed)</p>
</td></tr>
<tr><td><code id="mvTcdf_+3A_u">u</code></td>
<td>
<p>upper bound for truncation</p>
</td></tr>
<tr><td><code id="mvTcdf_+3A_sig">Sig</code></td>
<td>
<p>covariance matrix</p>
</td></tr>
<tr><td><code id="mvTcdf_+3A_df">df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code id="mvTcdf_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Monte Carlo method uses sample size <code>n</code>; the larger
the <code>n</code>, the smaller the relative error of the estimator;
</p>


<h3>Value</h3>

<p>a list with components
</p>

<ul>
<li><p><code>prob</code>: estimated value of probability Pr<code class="reqn">(l&lt;X&lt;u)</code> 
</p>
</li>
<li><p><code>relErr</code>: estimated relative error of estimator
</p>
</li>
<li><p><code>upbnd</code>: theoretical upper bound on true Pr<code class="reqn">(l&lt;X&lt;u)</code> 
</p>
</li></ul>



<h3>Note</h3>

<p>If you want to estimate Pr<code class="reqn">(l&lt;Y&lt;u)</code>,
where <code class="reqn">Y</code> follows a Student distribution with <code>df</code> degrees of freedom,
location vector <code>m</code> and scale matrix <code>Sig</code>,
then use <code>mvTqmc(Sig, l - m, u - m, nu, n)</code>.
</p>


<h3>Author(s)</h3>

<p><code>Matlab</code> code by Zdravko Botev, <code>R</code> port by Leo Belzile
</p>


<h3>References</h3>

<p>Z. I. Botev (2017), <em>The Normal Law Under Linear Restrictions:
Simulation and Estimation via Minimax Tilting</em>, Journal of the Royal
Statistical Society, Series B, <b>79</b> (1), pp. 1&ndash;24
</p>
<p>Z. I. Botev and P. L'Ecuyer (2015), Efficient probability estimation
and simulation of the truncated multivariate Student-t distribution,
Proceedings of the 2015 Winter Simulation Conference, pp. 380-391
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvTqmc">mvTqmc</a></code>, <code><a href="#topic+mvrandt">mvrandt</a></code>, <code><a href="#topic+mvNqmc">mvNqmc</a></code>, <code><a href="#topic+mvrandn">mvrandn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> d &lt;- 15; nu &lt;- 30;
 l &lt;- rep(2, d); u &lt;- rep(Inf, d);
 Sig &lt;- 0.5 * matrix(1, d, d) + 0.5 * diag(1, d);
 est &lt;- mvTcdf(l, u, Sig, nu, n = 1e4)
 # mvtnorm::pmvt(lower = l, upper = u, df = nu, sigma = Sig)
## Not run: 
d &lt;- 5
Sig &lt;- solve(0.5*diag(d)+matrix(0.5, d,d))
# mvtnorm::pmvt(lower = rep(-1,d), upper = rep(Inf, d), df = 10, sigma = Sig)[1]
mvTcdf(rep(-1, d), u = rep(Inf, d), Sig = Sig, df = 10, n=1e4)$prob

## End(Not run)
</code></pre>

<hr>
<h2 id='mvTqmc'>Truncated multivariate student cumulative distribution (QMC version)</h2><span id='topic+mvTqmc'></span>

<h3>Description</h3>

<p>Computes an estimator of the probability Pr<code class="reqn">(l&lt;X&lt;u)</code>,
where <code>X</code> is a zero-mean multivariate student vector
with scale matrix <code>Sig</code> and degrees of freedom <code>df</code>.
Infinite values for vectors <code>u</code> and <code>l</code> are accepted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvTqmc(l, u, Sig, df, n = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvTqmc_+3A_l">l</code></td>
<td>
<p>lower bound for truncation (infinite values allowed)</p>
</td></tr>
<tr><td><code id="mvTqmc_+3A_u">u</code></td>
<td>
<p>upper bound for truncation</p>
</td></tr>
<tr><td><code id="mvTqmc_+3A_sig">Sig</code></td>
<td>
<p>covariance matrix</p>
</td></tr>
<tr><td><code id="mvTqmc_+3A_df">df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code id="mvTqmc_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This version uses a Quasi Monte Carlo (QMC) pointset
of size <code>ceiling(n/12)</code> and estimates the relative error
using 12 independent randomized QMC estimators; QMC
is slower than ordinary Monte Carlo (see <code><a href="#topic+mvTcdf">mvTcdf</a></code>),
but is also likely to be more accurate when <code class="reqn">d&lt;50</code>.
</p>


<h3>Value</h3>

<p>a list with components
</p>

<ul>
<li><p><code>prob</code>: estimated value of probability Pr<code class="reqn">(l&lt;X&lt;u)</code>
</p>
</li>
<li><p><code>relErr</code>: estimated relative error of estimator
</p>
</li>
<li><p><code>upbnd</code>: theoretical upper bound on true Pr<code class="reqn">(l&lt;X&lt;u)</code> 
</p>
</li></ul>



<h3>Note</h3>

<p>If you want to estimate Pr<code class="reqn">(l&lt;Y&lt;u)</code>,
where <code class="reqn">Y</code> follows a Student distribution with <code>df</code> degrees of freedom,
location vector <code>m</code> and scale matrix <code>Sig</code>,
then use <code>mvTqmc(Sig, l - m, u - m, nu, n)</code>.
</p>


<h3>Author(s)</h3>

<p><code>Matlab</code> code by Zdravko I. Botev, <code>R</code> port by Leo Belzile
</p>


<h3>References</h3>

<p>Z. I. Botev (2017), <em>The Normal Law Under Linear Restrictions:
Simulation and Estimation via Minimax Tilting</em>, Journal of the Royal
Statistical Society, Series B, <b>79</b> (1), pp. 1&ndash;24
</p>
<p>Z. I. Botev and P. L'Ecuyer (2015), Efficient probability estimation
and simulation of the truncated multivariate Student-t distribution,
Proceedings of the 2015 Winter Simulation Conference, pp. 380-391
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvTcdf">mvTcdf</a></code>, <code><a href="#topic+mvrandt">mvrandt</a></code>, <code><a href="#topic+mvNqmc">mvNqmc</a></code>, <code><a href="#topic+mvrandn">mvrandn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 25; nu &lt;- 30;
l &lt;- rep(1, d) * 5; u &lt;- rep(Inf, d);
Sig &lt;- 0.5 * matrix(1, d, d) + 0.5 * diag(d);
est &lt;- mvTqmc(l, u, Sig, nu, n = 1e4)
## Not run: 
d &lt;- 5
Sig &lt;- solve(0.5*diag(d)+matrix(0.5, d,d))
## mvtnorm::pmvt(lower = rep(-1,d), upper = rep(Inf, d), df = 10, sigma = Sig)[1]
mvTqmc(rep(-1, d), u = rep(Inf, d), Sig = Sig, df = 10, n=1e4)$prob

## End(Not run)
</code></pre>

<hr>
<h2 id='norminvp'>Normal quantile function (high precision)</h2><span id='topic+norminvp'></span>

<h3>Description</h3>

<p>Computes with tail-precision the quantile function
of the standard normal distribution at <code class="reqn">0\le p\le 1</code>,
and truncated to the interval <code class="reqn">[l,u]</code>.
Infinite values for vectors <code class="reqn">l</code> and <code class="reqn">u</code> are accepted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norminvp(p, l, u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norminvp_+3A_p">p</code></td>
<td>
<p>quantile  at <code class="reqn">0\le p\le 1</code></p>
</td></tr>
<tr><td><code id="norminvp_+3A_l">l</code></td>
<td>
<p>lower truncation limit</p>
</td></tr>
<tr><td><code id="norminvp_+3A_u">u</code></td>
<td>
<p>upper truncation limit</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose we wish to simulate a random variable <code class="reqn">Z</code> drawn from <code class="reqn">N(\mu,\sigma^2)</code> and
conditional on <code class="reqn">l&lt;Z&lt;u</code> using the inverse transform method.
To achieve this, first compute
<code>X=norminvp(runif(1),(l-mu)/sig,(u-mu)/sig)</code> and then set
<code>Z=mu+sig*X</code>
</p>


<h3>Value</h3>

<p>quantile value of the truncated normal distribution.
</p>


<h3>Note</h3>

<p>If you wish to simulate truncated normal variables fast, use <code><a href="#topic+trandn">trandn</a></code>.
Using <code>norminvp</code>  is advisable only when needed, for example,
in quasi-Monte Carlo or antithetic sampling, where the inverse transform method
is unavoidable.
</p>


<h3>Author(s)</h3>

<p>Zdravko I. Botev
</p>


<h3>References</h3>

<p>Z. I. Botev (2017), <em>The Normal Law Under Linear Restrictions:
Simulation and Estimation via Minimax Tilting</em>, Journal of the Royal
Statistical Society, Series B, <b>79</b> (1), pp. 1&ndash;24.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trandn">trandn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> d &lt;- 150 # simulate via inverse transform method
 norminvp(runif(d),l = 1:d, u = rep(Inf, d))
</code></pre>

<hr>
<h2 id='Phinv'>Quantile of truncated Gaussian</h2><span id='topic+Phinv'></span>

<h3>Description</h3>

<p>The function compute the <code>p</code>th quantile associated to the truncated standard Gaussian 
variate on the interval (<code>l</code>,<code>u</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Phinv(p, l, u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Phinv_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Phinv_+3A_l">l</code></td>
<td>
<p><code>d</code> vector of lower bounds</p>
</td></tr>
<tr><td><code id="Phinv_+3A_u">u</code></td>
<td>
<p><code>d</code> vector of upper bounds</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of quantiles
</p>

<hr>
<h2 id='pmvnorm'>Distribution function of the multivariate normal distribution for arbitrary limits</h2><span id='topic+pmvnorm'></span>

<h3>Description</h3>

<p>This function computes the distribution function of a multivariate normal distribution vector for an arbitrary rectangular region [<code>lb</code>, <code>ub</code>].
<code>pmvnorm</code> computes an estimate and the value is returned along with a relative error and a deterministic upper bound of the distribution function of the multivariate normal distribution.
Infinite values for vectors <code class="reqn">u</code> and <code class="reqn">l</code> are accepted. The Monte Carlo method uses sample size <code class="reqn">n</code>: the larger the sample size, the smaller the relative error of the estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmvnorm(mu, sigma, lb = -Inf, ub = Inf, B = 10000, type = c("mc", "qmc"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmvnorm_+3A_mu">mu</code></td>
<td>
<p>vector of location parameters</p>
</td></tr>
<tr><td><code id="pmvnorm_+3A_sigma">sigma</code></td>
<td>
<p>covariance matrix</p>
</td></tr>
<tr><td><code id="pmvnorm_+3A_lb">lb</code></td>
<td>
<p>vector of lower truncation limits</p>
</td></tr>
<tr><td><code id="pmvnorm_+3A_ub">ub</code></td>
<td>
<p>vector of upper truncation limits</p>
</td></tr>
<tr><td><code id="pmvnorm_+3A_b">B</code></td>
<td>
<p>number of replications for the (quasi)-Monte Carlo scheme</p>
</td></tr>
<tr><td><code id="pmvnorm_+3A_type">type</code></td>
<td>
<p>string, either of <code>mc</code> or <code>qmc</code> for Monte Carlo and quasi Monte Carlo, respectively</p>
</td></tr>
<tr><td><code id="pmvnorm_+3A_...">...</code></td>
<td>
<p>additional arguments, currently ignored.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zdravko I. Botev, Leo Belzile (wrappers)
</p>


<h3>References</h3>

<p>Z. I. Botev (2017), <em>The normal law under linear restrictions:
simulation and estimation via minimax tilting</em>, Journal of the Royal
Statistical Society, Series B, <b>79</b> (1), pp. 1&ndash;24.
</p>


<h3>See Also</h3>

<p><code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#From mvtnorm
mean &lt;- rep(0, 5)
lower &lt;- rep(-1, 5)
upper &lt;- rep(3, 5)
corr &lt;- matrix(0.5, 5, 5) + diag(0.5, 5)
prob &lt;- pmvnorm(lb = lower, ub = upper, mu = mean, sigma = corr)
stopifnot(pmvnorm(lb = -Inf, ub = 3, mu = 0, sigma = 1) == pnorm(3))
</code></pre>

<hr>
<h2 id='pmvt'>Distribution function of the multivariate Student distribution for arbitrary limits</h2><span id='topic+pmvt'></span>

<h3>Description</h3>

<p>This function computes the distribution function of a multivariate normal distribution vector for an arbitrary rectangular region [<code>lb</code>, <code>ub</code>].
<code>pmvt</code> computes an estimate and the value is returned along with a relative error and a deterministic upper bound of the distribution function of the multivariate normal distribution.
Infinite values for vectors <code class="reqn">u</code> and <code class="reqn">l</code> are accepted. The Monte Carlo method uses sample size <code class="reqn">n</code>: the larger the sample size, the smaller the relative error of the estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmvt(mu, sigma, df, lb = -Inf, ub = Inf, type = c("mc", "qmc"), B = 10000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmvt_+3A_mu">mu</code></td>
<td>
<p>vector of location parameters</p>
</td></tr>
<tr><td><code id="pmvt_+3A_sigma">sigma</code></td>
<td>
<p>scale matrix</p>
</td></tr>
<tr><td><code id="pmvt_+3A_df">df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code id="pmvt_+3A_lb">lb</code></td>
<td>
<p>vector of lower truncation limits</p>
</td></tr>
<tr><td><code id="pmvt_+3A_ub">ub</code></td>
<td>
<p>vector of upper truncation limits</p>
</td></tr>
<tr><td><code id="pmvt_+3A_type">type</code></td>
<td>
<p>string, either of <code>mc</code> or <code>qmc</code> for Monte Carlo and quasi Monte Carlo, respectively</p>
</td></tr>
<tr><td><code id="pmvt_+3A_b">B</code></td>
<td>
<p>number of replications for the (quasi)-Monte Carlo scheme</p>
</td></tr>
<tr><td><code id="pmvt_+3A_...">...</code></td>
<td>
<p>additional arguments, currently ignored.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p><code>Matlab</code> code by Zdravko I. Botev, <code>R</code> port by Leo Belzile
</p>


<h3>References</h3>

<p>Z. I. Botev and P. L'Ecuyer (2015), Efficient probability estimation
and simulation of the truncated multivariate Student-t distribution,
Proceedings of the 2015 Winter Simulation Conference, pp. 380-391
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 15; nu &lt;- 30;
l &lt;- rep(2, d); u &lt;- rep(Inf, d);
sigma &lt;- 0.5 * matrix(1, d, d) + 0.5 * diag(1, d);
est &lt;- pmvt(lb = l, ub = u, sigma = sigma, df = nu)
# mvtnorm::pmvt(lower = l, upper = u, df = nu, sigma = sigma)
## Not run: 
d &lt;- 5
sigma &lt;- solve(0.5 * diag(d) + matrix(0.5, d, d))
# mvtnorm::pmvt(lower = rep(-1,d), upper = rep(Inf, d), df = 10, sigma = sigma)[1]
pmvt(lb = rep(-1, d), ub = rep(Inf, d), sigma = sigma, df = 10)

## End(Not run)
</code></pre>

<hr>
<h2 id='ptmvnorm'>Cumulative distribution function of the truncated multivariate normal distribution.</h2><span id='topic+ptmvnorm'></span>

<h3>Description</h3>

<p>This function returns the (log)-distribution function of a matrix <code>q</code> of observations lying in the interval [<code>lb</code>, <code>ub</code>].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptmvnorm(q, mu, sigma, lb, ub, log = FALSE, type = c("mc", "qmc"), B = 10000)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+tmvnorm">tmvnorm</a></code>
</p>

<hr>
<h2 id='ptmvt'>Cumulative distribution function of the truncated multivariate Student distribution.</h2><span id='topic+ptmvt'></span>

<h3>Description</h3>

<p>This function returns the (log)-distribution function of a matrix <code>q</code> of observations lying in the interval [<code>lb</code>, <code>ub</code>].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptmvt(q, mu, sigma, df, lb, ub, type = c("mc", "qmc"), log = FALSE, B = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ptmvt_+3A_q">q</code></td>
<td>
<p>vector or matrix of quantiles</p>
</td></tr>
<tr><td><code id="ptmvt_+3A_mu">mu</code></td>
<td>
<p>vector of location parameters</p>
</td></tr>
<tr><td><code id="ptmvt_+3A_sigma">sigma</code></td>
<td>
<p>scale matrix</p>
</td></tr>
<tr><td><code id="ptmvt_+3A_df">df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code id="ptmvt_+3A_lb">lb</code></td>
<td>
<p>vector of lower truncation limits</p>
</td></tr>
<tr><td><code id="ptmvt_+3A_ub">ub</code></td>
<td>
<p>vector of upper truncation limits</p>
</td></tr>
<tr><td><code id="ptmvt_+3A_type">type</code></td>
<td>
<p>string, either of <code>mc</code> or <code>qmc</code> for Monte Carlo and quasi Monte Carlo, respectively</p>
</td></tr>
<tr><td><code id="ptmvt_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities and density are given on the log scale.</p>
</td></tr>
<tr><td><code id="ptmvt_+3A_b">B</code></td>
<td>
<p>number of replications for the (quasi)-Monte Carlo scheme</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tmvt">tmvt</a></code>
</p>

<hr>
<h2 id='qtnorm'>Quantile function using the inversion method</h2><span id='topic+qtnorm'></span>

<h3>Description</h3>

<p>If <code>p</code> is a matrix, the arguments are recycled.  If <code>mu</code> or <code>sd</code> are not specified they assume the default values of 0 and 1, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtnorm(p, mu, sd, lb, ub)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+tnorm">tnorm</a></code>
</p>

<hr>
<h2 id='rtmvnorm'>Random number generator for the truncated multivariate normal distribution.</h2><span id='topic+rtmvnorm'></span>

<h3>Description</h3>

<p>This function returns a matrix of draws from a multivariate normal distribution truncated on the interval [<code>lb</code>, <code>ub</code>].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtmvnorm(n, mu, sigma, lb, ub)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+tmvnorm">tmvnorm</a></code>
</p>

<hr>
<h2 id='rtmvt'>Random number generator for the truncated multivariate Student distribution.</h2><span id='topic+rtmvt'></span>

<h3>Description</h3>

<p>This function returns a matrix of draws from a multivariate Student distribution truncated on the interval [<code>lb</code>, <code>ub</code>].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtmvt(n, mu, sigma, df, lb, ub)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtmvt_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="rtmvt_+3A_mu">mu</code></td>
<td>
<p>vector of location parameters</p>
</td></tr>
<tr><td><code id="rtmvt_+3A_sigma">sigma</code></td>
<td>
<p>scale matrix</p>
</td></tr>
<tr><td><code id="rtmvt_+3A_df">df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code id="rtmvt_+3A_lb">lb</code></td>
<td>
<p>vector of lower truncation limits</p>
</td></tr>
<tr><td><code id="rtmvt_+3A_ub">ub</code></td>
<td>
<p>vector of upper truncation limits</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tmvt">tmvt</a></code>
</p>

<hr>
<h2 id='rtnorm'>Vectorized random number generation from the univariate truncated normal distribution</h2><span id='topic+rtnorm'></span>

<h3>Description</h3>

<p>If <code>n</code> is 1, the function returns a vector rather than a matrix. If <code>mu</code> or <code>sd</code> are not specified they assume the default values of 0 and 1, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtnorm(n, mu, sd, lb, ub, method = c("fast", "invtransfo"))
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+tnorm">tnorm</a></code>
</p>

<hr>
<h2 id='tmvnorm'>Multivariate truncated normal distribution</h2><span id='topic+tmvnorm'></span>

<h3>Description</h3>

<p>Density, distribution function and random generation for the multivariate truncated normal distribution
with mean vector <code>mu</code>, covariance matrix <code>sigma</code>, lower truncation limit <code>lb</code> and upper truncation limit <code>ub</code>. 
The truncation limits can include infinite values. The Monte Carlo (<code>type = "mc"</code>) uses a sample of size <code>B</code>, while the
quasi Monte Carlo (<code>type = "qmc"</code>) uses a pointset of size <code>ceiling(n/12)</code> and estimates the relative error using 12 independent randomized QMC estimators.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmvnorm_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="tmvnorm_+3A_x">x</code>, <code id="tmvnorm_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="tmvnorm_+3A_b">B</code></td>
<td>
<p>number of replications for the (quasi)-Monte Carlo scheme</p>
</td></tr>
<tr><td><code id="tmvnorm_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities and density are given on the log scale.</p>
</td></tr>
<tr><td><code id="tmvnorm_+3A_mu">mu</code></td>
<td>
<p>vector of location parameters</p>
</td></tr>
<tr><td><code id="tmvnorm_+3A_sigma">sigma</code></td>
<td>
<p>covariance matrix</p>
</td></tr>
<tr><td><code id="tmvnorm_+3A_lb">lb</code></td>
<td>
<p>vector of lower truncation limits</p>
</td></tr>
<tr><td><code id="tmvnorm_+3A_ub">ub</code></td>
<td>
<p>vector of upper truncation limits</p>
</td></tr>
<tr><td><code id="tmvnorm_+3A_type">type</code></td>
<td>
<p>string, either of <code>mc</code> or <code>qmc</code> for Monte Carlo and quasi Monte Carlo, respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dtmvnorm</code> gives the density, <code>ptmvnorm</code> and <code>pmvnorm</code> give the distribution function of respectively the truncated and multivariate Gaussian distribution and <code>rtmvnorm</code> generate random deviates.
</p>


<h3>Usage</h3>

<pre>
dtmvnorm(x, mu, sigma, lb, ub, type = c("mc", "qmc"), log = FALSE, B = 1e4)
ptmvnorm(q, mu, sigma, lb, ub, type = c("mc", "qmc"), log = FALSE, B = 1e4)
rtmvnorm(n, mu, sigma, lb, ub)</pre>


<h3>Author(s)</h3>

<p>Zdravko I. Botev, Leo Belzile (wrappers)
</p>


<h3>References</h3>

<p>Z. I. Botev (2017), <em>The normal law under linear restrictions:
simulation and estimation via minimax tilting</em>, Journal of the Royal
Statistical Society, Series B, <b>79</b> (1), pp. 1&ndash;24.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 4; lb &lt;- rep(0, d)
mu &lt;- runif(d)
sigma &lt;- matrix(0.5, d, d) + diag(0.5, d)
samp &lt;- rtmvnorm(n = 10, mu = mu, sigma = sigma, lb = lb)
loglik &lt;- dtmvnorm(samp, mu = mu, sigma = sigma, lb = lb, log = TRUE)
cdf &lt;- ptmvnorm(samp, mu = mu, sigma = sigma, lb = lb, log = TRUE, type = "q")

# Exact Bayesian Posterior Simulation Example
# Vignette, example 5
## Not run: 
data("lupus"); # load lupus data
Y &lt;- lupus[,1]; # response data
X &lt;- as.matrix(lupus[,-1])  # construct design matrix
n &lt;- nrow(X)
d &lt;- ncol(X)
X &lt;- diag(2*Y-1) %*% X; # incorporate response into design matrix
nusq &lt;- 10000; # prior scale parameter
C &lt;- solve(diag(d)/nusq + crossprod(X))
sigma &lt;- diag(n) + nusq*tcrossprod(X) # this is covariance of Z given beta
est &lt;- pmvnorm(sigma = sigma, lb = 0) 
# estimate acceptance probability of crude Monte Carlo
print(attributes(est)$upbnd/est[1])
# reciprocal of acceptance probability
Z &lt;- rtmvnorm(sigma = sigma, n = 1e3, lb = rep(0, n))
# sample exactly from auxiliary distribution
beta &lt;- rtmvnorm(n = nrow(Z), sigma = C) + Z %*% X %*% C
# simulate beta given Z and plot boxplots of marginals
boxplot(beta, ylab = expression(beta))
# output the posterior means
colMeans(beta)

## End(Not run)
</code></pre>

<hr>
<h2 id='tmvt'>Multivariate truncated Student distribution</h2><span id='topic+tmvt'></span>

<h3>Description</h3>

<p>Density, distribution function and random generation for the multivariate truncated Student distribution
with location vector <code>mu</code>, scale matrix <code>sigma</code>, lower truncation limit
<code>lb</code>, upper truncation limit <code>ub</code> and degrees of freedom <code>df</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmvt_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="tmvt_+3A_x">x</code>, <code id="tmvt_+3A_q">q</code></td>
<td>
<p>vector or matrix of quantiles</p>
</td></tr>
<tr><td><code id="tmvt_+3A_b">B</code></td>
<td>
<p>number of replications for the (quasi)-Monte Carlo scheme</p>
</td></tr>
<tr><td><code id="tmvt_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities and density are given on the log scale.</p>
</td></tr>
<tr><td><code id="tmvt_+3A_mu">mu</code></td>
<td>
<p>vector of location parameters</p>
</td></tr>
<tr><td><code id="tmvt_+3A_sigma">sigma</code></td>
<td>
<p>scale matrix</p>
</td></tr>
<tr><td><code id="tmvt_+3A_df">df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code id="tmvt_+3A_lb">lb</code></td>
<td>
<p>vector of lower truncation limits</p>
</td></tr>
<tr><td><code id="tmvt_+3A_ub">ub</code></td>
<td>
<p>vector of upper truncation limits</p>
</td></tr>
<tr><td><code id="tmvt_+3A_type">type</code></td>
<td>
<p>string, either of <code>mc</code> or <code>qmc</code> for Monte Carlo and quasi Monte Carlo, respectively</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The truncation limits can include infinite values. The Monte Carlo (<code>type = "mc"</code>) uses a sample of size <code>B</code>, while the
qausi Monte Carlo (<code>type = "qmc"</code>) uses a pointset of size <code>ceiling(n/12)</code> and estimates the relative error using 12 independent randomized QMC estimators. 
</p>
<p><code>pmvt</code> computes an estimate and a deterministic upper bound of the distribution function of the multivariate normal distribution.
Infinite values for vectors <code class="reqn">u</code> and <code class="reqn">l</code> are accepted. The Monte Carlo method uses sample size <code class="reqn">n</code>: the larger <code class="reqn">n</code>, the smaller the relative error of the estimator.
</p>


<h3>Value</h3>

<p><code>dtmvt</code> gives the density, <code>ptmvt</code> gives the distribution function, <code>rtmvt</code> generate random deviates.
</p>


<h3>Usage</h3>

<pre>
dtmvt(x, mu, sigma, df, lb, ub, type = c("mc", "qmc"), log = FALSE, B = 1e4)
ptmvt(q, mu, sigma, df, lb, ub, type = c("mc", "qmc"), log = FALSE, B = 1e4)
rtmvt(n, mu, sigma, df, lb, ub)
pmvt(mu, sigma, df, lb = -Inf, ub = Inf, type = c("mc", "qmc"), B = 1e4)</pre>


<h3>Author(s)</h3>

<p>Leo Belzile, R port from Matlab code by Z. I. Botev
</p>


<h3>References</h3>

<p>Z. I. Botev and P. L'Ecuyer (2015), Efficient probability estimation
and simulation of the truncated multivariate Student-t distribution,
Proceedings of the 2015 Winter Simulation Conference, pp. 380-391
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 4; lb &lt;- rep(0, d)
mu &lt;- runif(d)
sigma &lt;- matrix(0.5, d, d) + diag(0.5, d)
samp &lt;- rtmvt(n = 10, mu = mu, sigma = sigma, df = 2, lb = lb)
loglik &lt;- dtmvt(samp, mu = mu, sigma = sigma, df = 2, lb = lb, log = TRUE)
cdf &lt;- ptmvt(samp, mu = mu, sigma = sigma, df = 2, lb = lb, log = TRUE, type = "q")
</code></pre>

<hr>
<h2 id='tnorm'>Truncated univariate normal distribution</h2><span id='topic+tnorm'></span>

<h3>Description</h3>

<p>The function provides efficient state-of-the-art random number generation of a vector of truncated univariate distribution
of the same length as the lower bound vector. The function is vectorized and the vector of means <code>mu</code> and 
of standard deviations <code>sd</code> are recycled.
</p>
<p>If <code>mu</code> or <code>sd</code> are not specified they assume the default values of 0 and 1, respectively.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="tnorm_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="tnorm_+3A_p">p</code></td>
<td>
<p>vector or matrix of probabilities</p>
</td></tr>
<tr><td><code id="tnorm_+3A_mu">mu</code></td>
<td>
<p>vector of means</p>
</td></tr>
<tr><td><code id="tnorm_+3A_sd">sd</code></td>
<td>
<p>vector of standard deviations</p>
</td></tr>
<tr><td><code id="tnorm_+3A_lb">lb</code></td>
<td>
<p>vector of lower truncation limits</p>
</td></tr>
<tr><td><code id="tnorm_+3A_ub">ub</code></td>
<td>
<p>vector of upper truncation limits</p>
</td></tr>
<tr><td><code id="tnorm_+3A_method">method</code></td>
<td>
<p>string, either of <code>fast</code> or <code>invtransfo</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector or matrix of random variates (<code>rtnorm</code>) or of quantiles (<code>ptnorm</code>), depending on the input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rtnorm(n = 10, mu = 2, lb = 1:10, ub = 2:11, method = "fast")
qtnorm(runif(10), mu = 2, lb = 1:10, ub = 2:11, sd = 1)
</code></pre>

<hr>
<h2 id='trandn'>Fast truncated normal generator</h2><span id='topic+trandn'></span>

<h3>Description</h3>

<p>Efficient state-of-the-art generator of a vector of <code>length(l)=length(u)</code>
from the standard multivariate normal distribution truncated over the region <code class="reqn">[l,u]</code>.
Infinite values for <code>u</code> and <code>l</code> are accepted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trandn(l, u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trandn_+3A_l">l</code></td>
<td>
<p>lower truncation limit</p>
</td></tr>
<tr><td><code id="trandn_+3A_u">u</code></td>
<td>
<p>upper truncation limit</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose we wish to simulate a random variable <code class="reqn">Z</code> drawn from <code class="reqn">N(\mu,\sigma^2)</code> and
conditional on <code class="reqn">l&lt;Z&lt;u</code> using the inverse transform method.
To achieve this, first compute
<code>X=norminvp(runif(1),(l-mu)/sig,(u-mu)/sig)</code> and then set
<code>Z=mu+sig*X</code>
</p>


<h3>Value</h3>

<p>random variable drawn from the truncated normal distribution
</p>


<h3>Note</h3>

<p>Use <code><a href="#topic+norminvp">norminvp</a></code> for the (slower) inverse transform method of simulating truncated normal variables.
</p>


<h3>Author(s)</h3>

<p>Zdravko I. Botev
</p>


<h3>References</h3>

<p>Z. I. Botev (2017), <em>The Normal Law Under Linear Restrictions:
Simulation and Estimation via Minimax Tilting</em>, Journal of the Royal
Statistical Society, Series B, <b>79</b> (1), pp. 1&ndash;24.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+norminvp">norminvp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trandn(l = 1,u = Inf)
trandn(l = rep(1, 10), u = rep(Inf, 10))
</code></pre>

<hr>
<h2 id='tregress'>Truncated student generator for Bayesian regression simulation</h2><span id='topic+tregress'></span>

<h3>Description</h3>

<p>Simulates <code>n</code> random vectors <code class="reqn">X</code> exactly distributed
from the <code>d</code>-dimensional Student distribution with
<code>df=</code><code class="reqn">\nu</code> degrees of freedom, mean zero and scale matrix
<code>sigma</code>, conditional on <code class="reqn">l&lt;X&lt;u</code>,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tregress(n, lb, ub, sigma, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tregress_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="tregress_+3A_lb">lb</code></td>
<td>
<p>vector of lower truncation limits</p>
</td></tr>
<tr><td><code id="tregress_+3A_ub">ub</code></td>
<td>
<p>vector of upper truncation limits</p>
</td></tr>
<tr><td><code id="tregress_+3A_sigma">sigma</code></td>
<td>
<p>scale matrix</p>
</td></tr>
<tr><td><code id="tregress_+3A_df">df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with components
</p>

<ul>
<li><p><code>R</code>:  <code>n</code> vector of scale
</p>
</li>
<li><p><code>Z</code>:  a <code>d</code> by <code>n</code> matrix
</p>
</li></ul>
<p> so that <code class="reqn">\sqrt(\nu)Z/R</code> follows
a truncated Student distribution
</p>


<h3>Author(s)</h3>

<p><code>Matlab</code> code by Zdravko Botev, <code>R</code> port by Leo Belzile
</p>


<h3>References</h3>

<p>Z. I. Botev and P. L'Ecuyer (2015), Efficient probability estimation
and simulation of the truncated multivariate Student-t distribution,
Proceedings of the 2015 Winter Simulation Conference, pp. 380-391,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 5
tregress(lb =rep(-2, d), ub = rep(2, d), df = 3, n = 10,
  sigma = diag(0.5, d) + matrix(1, d, d))
</code></pre>

<hr>
<h2 id='TruncatedNormal-package'>
Truncated Normal Distribution Toolbox
</h2><span id='topic+TruncatedNormal'></span>

<h3>Description</h3>

<p>The routines include:
</p>

<ul>
<li><p> generator of <b>independent and identically distributed</b> random vectors from the truncated univariate and multivariate distributions;
</p>
</li>
<li><p> (Quasi-) Monte Carlo estimator and a <b>deterministic upper bound</b>  of the cumulative distribution function of the multivariate normal and Student distributions;
</p>
</li>
<li><p> algorithm for the accurate computation of the quantile function of the normal distribution in the extremes of its tails.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Leo Belzile and Z. I. Botev, email: <a href="mailto:botev@unsw.edu.au">botev@unsw.edu.au</a> and web page: <code>https://web.maths.unsw.edu.au/~zdravkobotev/</code>
</p>


<h3>References</h3>


<ul>
<li><p> Z. I. Botev (2017), <em>The Normal Law Under Linear Restrictions:
Simulation and Estimation via Minimax Tilting</em>, Journal of the Royal
Statistical Society, Series B, <b>79</b> (1), pp. 1&ndash;24.
</p>
</li>
<li><p> Z. I. Botev and P. L'Ecuyer (2015), <em>Efficient Estimation
and Simulation of the Truncated Multivariate Student-t Distribution</em>, Proceedings of the 2015 Winter Simulation Conference,
Huntington Beach, CA, USA
</p>
</li>
<li><p> Gibson G. J., Glasbey C. A., Elston D. A. (1994),
<em>Monte Carlo evaluation of multivariate normal integrals and sensitivity to variate ordering</em>,
In: Advances in Numerical Methods and Applications, pages 120&ndash;126
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
