<!DOCTYPE html><html><head><title>Help for package EcoNetGen</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EcoNetGen}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adj_plot'><p>Plot network adjacency matrix</p></a></li>
<li><a href='#netgen'><p>netgen</p></a></li>
<li><a href='#netgen_v1'><p>netgen_v1</p></a></li>
<li><a href='#netsampler'><p>Network Sampling Routine</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulate and Sample from Ecological Interaction Networks</td>
</tr>
<tr>
<td>Description:</td>
<td>Randomly generate a wide range of interaction networks with
             specified size, average degree, modularity, and topological
             structure. Sample nodes and links from within simulated networks
             randomly, by degree, by module, or by abundance. Simulations
             and sampling routines are implemented in 'FORTRAN', providing
             efficient generation times even for large networks. Basic
             visualization methods also included. Algorithms implemented
             here are described in de Aguiar et al. (2017) &lt;<a href="https://doi.org/10.48550/arXiv.1708.01242">doi:10.48550/arXiv.1708.01242</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cboettig/EcoNetGen">https://github.com/cboettig/EcoNetGen</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cboettig/EcoNetGen/issues">https://github.com/cboettig/EcoNetGen/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling, testthat, covr, ggraph</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, ggplot2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-27 04:46:36 UTC; cboettig</td>
</tr>
<tr>
<td>Author:</td>
<td>Marcus de Aguiar <a href="https://orcid.org/0000-0003-1379-7568"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Erica Newman <a href="https://orcid.org/0000-0001-6433-8594"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Mathias Pires <a href="https://orcid.org/0000-0003-2500-4748"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  NIMBioS [fnd],
  Carl Boettiger <a href="https://orcid.org/0000-0003-4580-091X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carl Boettiger &lt;cboettig@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-27 05:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adj_plot'>Plot network adjacency matrix</h2><span id='topic+adj_plot'></span>

<h3>Description</h3>

<p>Plot network adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj_plot(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adj_plot_+3A_graph">graph</code></td>
<td>
<p>an igraph object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(12345)
graph &lt;- netgen()
adj_plot(graph)


</code></pre>

<hr>
<h2 id='netgen'>netgen</h2><span id='topic+netgen'></span>

<h3>Description</h3>

<p>Randomly generate a wide range of interaction networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netgen(net_size = 50, ave_module_size = 10, min_module_size = 6,
  min_submod_size = 1, net_type = c("mixed", "random", "scalefree",
  "nested", "bi-partite nested", "bi-partite random",
  "tri-trophic bipartite nested-random",
  "tri-trophic bipartite nested-bipartite nested", "bn", "br", "tt-bn-r",
  "tt-bn-bn"), ave_degree = 5, rewire_prob_global = 0.2,
  rewire_prob_local = 0, mixing_probs = c(0.2, 0.2, 0.2, 0.2, 0.2, 0,
  0), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netgen_+3A_net_size">net_size</code></td>
<td>
<p>network size (number of nodes)</p>
</td></tr>
<tr><td><code id="netgen_+3A_ave_module_size">ave_module_size</code></td>
<td>
<p>average module size</p>
</td></tr>
<tr><td><code id="netgen_+3A_min_module_size">min_module_size</code></td>
<td>
<p>cutoff for the minimum modules size</p>
</td></tr>
<tr><td><code id="netgen_+3A_min_submod_size">min_submod_size</code></td>
<td>
<p>cutoff for submodules, used only for bipartite and tripartite networks</p>
</td></tr>
<tr><td><code id="netgen_+3A_net_type">net_type</code></td>
<td>
<p>network type, see details</p>
</td></tr>
<tr><td><code id="netgen_+3A_ave_degree">ave_degree</code></td>
<td>
<p>average degree of connection</p>
</td></tr>
<tr><td><code id="netgen_+3A_rewire_prob_global">rewire_prob_global</code></td>
<td>
<p>probability any given edge should be rewired</p>
</td></tr>
<tr><td><code id="netgen_+3A_rewire_prob_local">rewire_prob_local</code></td>
<td>
<p>probability that edges within a module should be rewire locally
(within the module)</p>
</td></tr>
<tr><td><code id="netgen_+3A_mixing_probs">mixing_probs</code></td>
<td>
<p>module probabilities for first 7 types,
used for constructing mixed networks</p>
</td></tr>
<tr><td><code id="netgen_+3A_verbose">verbose</code></td>
<td>
<p>logical, default TRUE. Should a message report summary statistics?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>network type is one of
</p>

<ul>
<li><p> mixed
</p>
</li>
<li><p> random
</p>
</li>
<li><p> scalefree
</p>
</li>
<li><p> nested
</p>
</li>
<li><p> bi-partite nested (or short-hand &quot;bn&quot;)
</p>
</li>
<li><p> bi-partite random (or short-hand &quot;br&quot;)
</p>
</li>
<li><p> tri-trophic bipartite nested-random. (Can use short-hand &quot;ttbnr&quot;)
</p>
</li>
<li><p> tri-trophic bipartite nested-bipartite nested (Can use short-hand &quot;ttbnbn&quot;)
</p>
</li></ul>

<p><strong>Valid Parameter Ranges</strong>
</p>
<p>Please note that not all combinations of parameters will create valid networks.
If an invalid combination is requested, <code>netgen()</code> will error with an informative
message.  A list of these constraints is provided below for reference.
</p>

<ol>
<li> <p><code>net_size &gt;= ave_module_size</code>. If 'net_size = ave_module_size&ldquo; the program
generates a network with a single module.
</p>
</li>
<li> <p><code>ave_module_size &gt; min_module_size</code>
</p>
</li>
<li> <p><code>ave_degree &gt;= 1</code>. Preferably larger than 4, to ensure single component modules.
</p>
</li>
<li> <p><code>rewire_prob_global = 0</code> produces completely uncoupled modules. To ensure a single
component network use <code>rewire_prob_global &gt; 0</code> and sufficiently large.
</p>
</li>
<li> <p><code>rewire_prob_local = 0</code> produces idealized modules.
Use <code>rewire_prob_local &gt; 0</code> to add stochasticity to the modules.
</p>
</li>
<li><p> For tripartite networks <code>min_module_size &gt; min_submod_size</code>.
This also implies <code>min_module_size &gt;= 2</code>.
</p>
</li>
<li><p> For scalefree networks (or mixed networks involving scalefree modules)
<code>ave_degree &lt; min_module_size</code>
</p>
</li>
<li><p> For mixed networks <code>mixing_probs</code> need to sum to <code>1</code>. If the sum is larger
than one, only the first types, corresponding to <code>sum &lt;=1</code>, will be sampled.
</p>
</li></ol>



<h3>Value</h3>

<p>an <code>igraph</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(EcoNetGen)

set.seed(12345)
net &lt;- netgen()
adj_plot(net)

</code></pre>

<hr>
<h2 id='netgen_v1'>netgen_v1</h2><span id='topic+netgen_v1'></span>

<h3>Description</h3>

<p>netgen function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netgen_v1(n_modav = c(50, 10), cutoffs = c(3, 0), net_type = 1,
  net_degree = 10, net_rewire = c(0.3, 0), mod_probs = c(0.2, 0.2,
  0.2, 0.2, 0.2, 0, 0), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netgen_v1_+3A_n_modav">n_modav</code></td>
<td>
<p>network size and average module size (integer vector, length 2)</p>
</td></tr>
<tr><td><code id="netgen_v1_+3A_cutoffs">cutoffs</code></td>
<td>
<p>module and submodule minimum sizes (integer vector, length 2).
(submodules are used only for bipartite and tripartite networks)</p>
</td></tr>
<tr><td><code id="netgen_v1_+3A_net_type">net_type</code></td>
<td>
<p>integer indicating type, see details</p>
</td></tr>
<tr><td><code id="netgen_v1_+3A_net_degree">net_degree</code></td>
<td>
<p>average degree of connection</p>
</td></tr>
<tr><td><code id="netgen_v1_+3A_net_rewire">net_rewire</code></td>
<td>
<p>global and local  network rewiring probabilities</p>
</td></tr>
<tr><td><code id="netgen_v1_+3A_mod_probs">mod_probs</code></td>
<td>
<p>module probabilities for types 1 to 51,
used for constructing mixed networks, net_type = 0</p>
</td></tr>
<tr><td><code id="netgen_v1_+3A_verbose">verbose</code></td>
<td>
<p>logical, default TRUE. Should a message report summary statistics?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>network type
</p>

<ul>
<li><p> 0 = mixed
</p>
</li>
<li><p> 1 = random
</p>
</li>
<li><p> 2 = scalefree
</p>
</li>
<li><p> 3 = nested
</p>
</li>
<li><p> 41 = bi-partite nested
</p>
</li>
<li><p> 42 = bi-partite random
</p>
</li>
<li><p> 51 = tri-trophic bipartite nested-random &quot;ttbnr&quot;
</p>
</li>
<li><p> 52 = tri-trophic bipartite nested-bipartite nested &quot;ttbnbn&quot;
</p>
</li></ul>



<h3>Value</h3>

<p>an <code>igraph</code> object
</p>

<hr>
<h2 id='netsampler'>Network Sampling Routine</h2><span id='topic+netsampler'></span>

<h3>Description</h3>

<p>Network Sampling Routine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netsampler(network_in, key_nodes_sampler = c("random", "lognormal",
  "Fisher log series", "exponential", "degree", "module"),
  neighbors_sampler = c("random", "exponential"), n_key_nodes = 10,
  n_neighbors = 0.5, hidden_modules = NULL, module_sizes = NULL,
  cluster_fn = igraph::cluster_edge_betweenness)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netsampler_+3A_network_in">network_in</code></td>
<td>
<p>input network (as igraph object)</p>
</td></tr>
<tr><td><code id="netsampler_+3A_key_nodes_sampler">key_nodes_sampler</code></td>
<td>
<p>sampling criteria for key nodes. See details.</p>
</td></tr>
<tr><td><code id="netsampler_+3A_neighbors_sampler">neighbors_sampler</code></td>
<td>
<p>sampling criteria for neighbors. see details.</p>
</td></tr>
<tr><td><code id="netsampler_+3A_n_key_nodes">n_key_nodes</code></td>
<td>
<p>number of key nodes to sample.</p>
</td></tr>
<tr><td><code id="netsampler_+3A_n_neighbors">n_neighbors</code></td>
<td>
<p>number of first neighbors or fraction of first neighbors.
See details.</p>
</td></tr>
<tr><td><code id="netsampler_+3A_hidden_modules">hidden_modules</code></td>
<td>
<p>list of the modules to exclude
(max 10 modules; only the first numb_hidden are used)</p>
</td></tr>
<tr><td><code id="netsampler_+3A_module_sizes">module_sizes</code></td>
<td>
<p>integer vector giving the size of each module. see details.</p>
</td></tr>
<tr><td><code id="netsampler_+3A_cluster_fn">cluster_fn</code></td>
<td>
<p>a clustering function, from <code>igraph::cluster_*</code>. Default is
<code>igraph::cluster_edge_betweeness</code>.  Only used to compute module sizes if not
provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Algorithm first samples n_key_nodes according the the requested <code>key_nodes_sampler</code>
criterion.  For each key node, the requested number or fraction of neighbors is
then sampled according to the <code>neighbors_sampler</code> criterion.  Optionally, a list of
modules can be designated as &quot;hidden&quot; and will be excluded from sampling.
</p>
<p>if <code>n_neighbors is greater than 1, assumes this is the number to sample.  If </code>n_neighbors<code>is between 0 and 1, assumes this is the fration of neighbors to sample.  (To sample 1 neighbor, use an explicit integer,</code>1L<code> (or as.</code>integer(1)')
to sample 100
</p>
<p>Provide <code>module_sizes</code> list to improve performance.  If not provided, this will
will be calculated based on <code>igraph::cluster_edge_betweeness</code>.  Be sure to
provide a <code>module_sizes</code> vector whenever calling <code>netsampler</code> repeatedly on the
same network to avoid unnecessary performance hit from recalculating modules every
time.  See examples.
</p>


<h3>Value</h3>

<p>the original input network (as an igraph network object),
with the attribute <code>label</code> added to the edges and vertices indicating
if that edge or vertex was <code>sampled</code> or <code>unsampled</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(12345)
net &lt;- netgen()
sample &lt;- netsampler(net)

## Precompute `module_sizes` for replicate sampling of the same network:
 library(igraph)
 modules &lt;- cluster_edge_betweenness(as.undirected(net))
 module_sizes &lt;- vapply(igraph::groups(modules), length, integer(1))
 sample &lt;- netsampler(net, module_sizes = module_sizes)



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
