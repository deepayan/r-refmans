<!DOCTYPE html><html><head><title>Help for package trip</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {trip}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjust.duplicateTimes'><p>Adjust duplicate DateTime values</p></a></li>
<li><a href='#argos.sigma'><p>Assign numeric values for Argos &quot;class&quot;</p></a></li>
<li><a href='#as.Other'><p>As (&quot;trip&quot;, other-classes)</p></a></li>
<li><a href='#as.trip'><p>Coercion from other classes to <code>trip</code> objects</p></a></li>
<li><a href='#cut.trip'><p>Split trip events into exact time-based boundaries.</p></a></li>
<li><a href='#forceCompliance'><p>Function to ensure dates and times are in order with trip ID</p></a></li>
<li><a href='#homedist'><p>Calculate maximum distance from 'home' for each trip</p></a></li>
<li><a href='#interp_equal'><p>Track intermediate points</p></a></li>
<li><a href='#makeGridTopology'><p>Generate a GridTopology from a Spatial object</p></a></li>
<li><a href='#oc.theme'><p>SeaWiFS ocean colour colours</p></a></li>
<li><a href='#rasterize'><p>Rasterize trip objects based on line-segment attributes.</p></a></li>
<li><a href='#readArgos'><p>Read Argos &quot;DAT&quot; or &quot;DIAG&quot; files</p></a></li>
<li><a href='#reproj'><p>Reprojection</p></a></li>
<li><a href='#sda'><p>Filter track for speed, distance and angle.</p></a></li>
<li><a href='#sepIdGaps'><p>Separate a set of IDs based on gaps</p></a></li>
<li><a href='#speedfilter'><p>Filter track data for speed</p></a></li>
<li><a href='#TimeOrderedRecords'><p>TimeOrderedRecords</p></a></li>
<li><a href='#TimeOrderedRecords-class'><p>A class for the identifiers of DateTime and ID records in spatial data.</p></a></li>
<li><a href='#trackAngle'><p>Determine internal angles along a track</p></a></li>
<li><a href='#trackDistance'><p>Determine distances along a track</p></a></li>
<li><a href='#trip-accessors'><p>Functions to retrieve DateTime and ID data from within (Spatial) data</p>
frames.</a></li>
<li><a href='#trip-class'><p>A class for sets of animal trips (track data).</p></a></li>
<li><a href='#trip-internal'><p>Internal trip Functions</p></a></li>
<li><a href='#trip-methods'><p>Function to handle animal track data, organized as <code>trip</code> objects</p></a></li>
<li><a href='#trip-package'><p>trip.</p></a></li>
<li><a href='#trip.split.exact'><p>Deprecated functions in trip</p></a></li>
<li><a href='#tripGrid'><p>Generate a grid of time spent by line-to-cell gridding</p></a></li>
<li><a href='#tripGrid.interp'><p>Generate a grid of time spent using approximate methods</p></a></li>
<li><a href='#walrus818'><p>Walrus tracking data set.</p></a></li>
<li><a href='#world_north'><p>World north polygons</p></a></li>
<li><a href='#write_track_kml'><p>Create a time-continuous KML file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tracking Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.10.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>geodist, MASS, methods, raster, reproj, sp, spatstat.geom,
spatstat.explore, glue, viridis, traipse (&ge; 0.2.0), crsmeta,
dplyr, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>adehabitatLT, knitr, testthat, covr, rmarkdown, lubridate,
maps, spelling, lattice</td>
</tr>
<tr>
<td>Description:</td>
<td>Access and manipulate spatial tracking data, with straightforward 
 coercion from and to other formats. Filter for speed and create time spent 
 maps from tracking data. There are coercion methods to convert between 'trip'
 and 'ltraj' from 'adehabitatLT', and between 'trip' and 'psp' and 'ppp' from 
 'spatstat'. Trip objects can be created from raw or grouped data frames, and 
 from types in the 'sp', sf', 'amt', 'trackeR', 'mousetrap', and other packages, 
 Sumner, MD (2011) <a href="https://figshare.utas.edu.au/articles/thesis/The_tag_location_problem/23209538">https://figshare.utas.edu.au/articles/thesis/The_tag_location_problem/23209538</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Trackage/trip">https://github.com/Trackage/trip</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Trackage/trip/issues">https://github.com/Trackage/trip/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-28 06:57:27 UTC; mdsumner</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael D. Sumner [aut, cre],
  Sebastian Luque [ctb],
  Anthony Fischbach [ctb],
  Tomislav Hengl [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael D. Sumner &lt;mdsumner@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-29 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjust.duplicateTimes'>Adjust duplicate DateTime values</h2><span id='topic+adjust.duplicateTimes'></span>

<h3>Description</h3>

<p>Duplicated DateTime values within ID are adjusted forward (recursively) by
one second until no duplicates are present. This is considered reasonable
way of avoiding the nonsensical problem of duplicate times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust.duplicateTimes(time, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjust.duplicateTimes_+3A_time">time</code></td>
<td>
<p>vector of DateTime values</p>
</td></tr>
<tr><td><code id="adjust.duplicateTimes_+3A_id">id</code></td>
<td>
<p>vector of ID values, matching DateTimes that are assumed sorted
within ID</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to remove duplicate time records in animal track data,
rather than removing the record completely.
</p>


<h3>Value</h3>

<p>The adjusted DateTime vector is returned.
</p>


<h3>Warning</h3>

<p>I have no idea what goes on at CLS when they output data that are either not
ordered by time or have duplicates. If this problem exists in your data it's
probably worth finding out why.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readArgos">readArgos</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## DateTimes with a duplicate within ID
tms &lt;- Sys.time() + c(1:6, 6, 7:10) *10
id &lt;- rep("a", length(tms))
range(diff(tms))

## duplicate record is now moved one second forward
tms.adj &lt;- adjust.duplicateTimes(tms, id)
range(diff(tms.adj))


</code></pre>

<hr>
<h2 id='argos.sigma'>Assign numeric values for Argos &quot;class&quot;</h2><span id='topic+argos.sigma'></span>

<h3>Description</h3>

<p>Assign numeric values for Argos &quot;class&quot; by matching the levels available to
given numbers. An adjustment is made to allow sigma to be specified in
kilometres, and the values returned are the approximate values for longlat
degrees.  It is assumed that the levels are part of an &quot;ordered&quot; factor from
least precise to most precise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argos.sigma(x, sigma = c(100, 80, 50, 20, 10, 4, 2), adjust = 111.12)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="argos.sigma_+3A_x">x</code></td>
<td>
<p>factor of Argos location quality &quot;classes&quot;</p>
</td></tr>
<tr><td><code id="argos.sigma_+3A_sigma">sigma</code></td>
<td>
<p>numeric values (by default in kilometres)</p>
</td></tr>
<tr><td><code id="argos.sigma_+3A_adjust">adjust</code></td>
<td>
<p>a numeric adjustment to convert from kms to degrees</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The available levels in Argos are <code>levels=c("Z", "B", "A", "0", "1",
"2", "3")</code>.
</p>
<p>The actual sigma values given by default are (as far as can be determined) a
reasonable stab at what Argos believes.
</p>


<h3>Value</h3>

<p>Numeric values for given levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

cls &lt;- ordered(sample(c("Z", "B", "A", "0", "1", "2", "3"), 30,
                      replace=TRUE),
               levels=c("Z", "B", "A", "0", "1", "2", "3"))
argos.sigma(cls)


</code></pre>

<hr>
<h2 id='as.Other'>As (&quot;trip&quot;, other-classes)</h2><span id='topic+as.Other'></span><span id='topic+as.psp.trip'></span><span id='topic+as.track_xyt.trip'></span><span id='topic+as.ppp'></span><span id='topic+as.psp'></span><span id='topic+as.ppp.trip'></span><span id='topic+explode'></span>

<h3>Description</h3>

<p>Coercing <code>trip</code> objects to other classes.
</p>
<p>Function to create a SpatialLinesDataFrame from a trip object, resulting in
a line segment for each implicit segment along the tracks. The object stores
the start and end times, duration and the ID of the segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trip'
as.ppp(X, ..., fatal)

## S3 method for class 'trip'
as.psp(x, ..., from, to)

as.track_xyt.trip(x, ..., from, to)

explode(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.Other_+3A_x">X</code></td>
<td>
<p><code>trip</code> object.</p>
</td></tr>
<tr><td><code id="as.Other_+3A_...">...</code></td>
<td>
<p>reserved for future methods</p>
</td></tr>
<tr><td><code id="as.Other_+3A_fatal">fatal</code></td>
<td>
<p>Logical value, see Details of <code><a href="spatstat.geom.html#topic+as.ppp">as.ppp</a></code></p>
</td></tr>
<tr><td><code id="as.Other_+3A_x">x</code></td>
<td>
<p><code>trip</code> object</p>
</td></tr>
<tr><td><code id="as.Other_+3A_from">from</code></td>
<td>
<p>see <code><a href="spatstat.geom.html#topic+as.psp">as.psp</a></code> for that method.</p>
</td></tr>
<tr><td><code id="as.Other_+3A_to">to</code></td>
<td>
<p>See <code><a href="spatstat.geom.html#topic+as.psp">as.psp</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ppp object
</p>
<p>psp object
</p>
<p>SpatialLinesDataFrame
</p>
<p>SpatialLinesDataFrame object with each individual line segment identified by start/end time and trip ID
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- data.frame(x=1:10, y=rnorm(10), tms=Sys.time() + 1:10, id=gl(2, 5))
sp::coordinates(d) &lt;- ~x+y
tr &lt;- trip(d, c("tms", "id"))

as(tr, "ppp")
d &lt;- data.frame(x=1:10, y=rnorm(10), tms=Sys.time() + 1:10, id=gl(2, 5))
tr &lt;- trip(d, c("tms", "id"))

 as(tr, "psp")
 as.psp(tr)
 d &lt;- data.frame(x=1:10, y=rnorm(10), tms=Sys.time() + 1:10, id=gl(2, 5))
 tr &lt;- trip(d)

spldf &lt;- explode(tr)
summary(tr)
</code></pre>

<hr>
<h2 id='as.trip'>Coercion from other classes to <code>trip</code> objects</h2><span id='topic+as.trip'></span><span id='topic+as.trip-methods'></span><span id='topic+as.trip+2Cltraj-method'></span><span id='topic+ltraj2trip'></span><span id='topic+coerce+2Ctrip+2Cltraj-method'></span><span id='topic+as.trip+2Ctrack_xyt-method'></span>

<h3>Description</h3>

<p>Coercing objects to <code>trip</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.trip(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.trip_+3A_x">x</code></td>
<td>
<p>ltr ltraj object</p>
</td></tr>
<tr><td><code id="as.trip_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods. Ignored for <code>ltraj</code>
method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>S4 trip object
</p>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from="ltraj", to="trip")</code></p>
</dd>
<dt>as.trip</dt><dd><p><code>signature(x="ltraj")</code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'> d &lt;- data.frame(x=1:10, y=rnorm(10), tms=Sys.time() + 1:10, id=gl(2, 5))
tr &lt;- trip(d)
if (require(adehabitatLT)) {
    l &lt;- as(tr, "ltraj")
    ltraj2trip(l)
    as.trip(l)
}
</code></pre>

<hr>
<h2 id='cut.trip'>Split trip events into exact time-based boundaries.</h2><span id='topic+cut.trip'></span>

<h3>Description</h3>

<p>Split trip events within a single object into exact time boundaries, adding
interpolated coordinates as required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trip'
cut(x, breaks, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut.trip_+3A_x">x</code></td>
<td>
<p>A trip object.</p>
</td></tr>
<tr><td><code id="cut.trip_+3A_breaks">breaks</code></td>
<td>
<p>A character string such as the <code>breaks</code> argument
for <code><a href="base.html#topic+cut.POSIXt">cut.POSIXt</a></code>, or alternatively a vector of
date-time boundaries. (If the latter these must encompass all the time range of
the entire trip object.)</p>
</td></tr>
<tr><td><code id="cut.trip_+3A_...">...</code></td>
<td>
<p>Unused arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Motion between boundaries is assumed linear and extra coordinates are added
at the cut points.
</p>
<p>This function was completely rewritten in version 1.1-20.
</p>


<h3>Value</h3>

<p>list of S4 trip objects, each with aligned boundaries in time based on cutting the input into intervals
</p>
<p>A list of trip objects, named by the time boundary in which they lie.
</p>


<h3>Author(s)</h3>

<p>Michael D. Sumner and Sebastian Luque
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+tripGrid">tripGrid</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(66)
d &lt;- data.frame(x=1:100, y=rnorm(100, 1, 10),
                tms= as.POSIXct(as.character(Sys.time()), tz = "GMT") + c(seq(10, 1000, length=50),
                seq(100, 1500, length=50)), id=gl(2, 50))
sp::coordinates(d) &lt;- ~x+y
tr &lt;- trip(d, c("tms", "id"))

cut(tr, "200 sec")

bound.dates &lt;- seq(min(tr$tms) - 1, max(tr$tms) + 1, length=5)
trip.list &lt;- cut(tr, bound.dates)
bb &lt;- sp::bbox(tr)
cn &lt;- c(20, 8)
g &lt;- sp::GridTopology(bb[, 1], apply(bb, 1, diff) / (cn - 1), cn)

tg &lt;- tripGrid(tr, grid=g)
tg &lt;- sp::as.image.SpatialGridDataFrame(tg)
tg$x &lt;- tg$x - diff(tg$x[1:2]) / 2
tg$y &lt;- tg$y - diff(tg$y[1:2]) / 2

op &lt;- par(mfcol=c(4, 1))
for (i in 1:length(trip.list)) {
  plot(sp::coordinates(tr), pch=16, cex=0.7)
  title(names(trip.list)[i], cex.main=0.9)
  lines(trip.list[[i]])
  abline(h=tg$y, v=tg$x, col="grey")
  image(tripGrid(trip.list[[i]], grid=g), interpolate=FALSE,
  col=c("white", grey(seq(0.2, 0.7,  length=256))),add=TRUE)
  abline(h=tg$y, v=tg$x,  col="grey")
  lines(trip.list[[i]])
  points(trip.list[[i]], pch=16, cex=0.7)
}

par(op)
print("you may need to resize the window to see the grid data")

cn &lt;- c(200, 80)
g &lt;- sp::GridTopology(bb[, 1], apply(bb, 1, diff) / (cn - 1), cn)

tg &lt;- tripGrid(tr, grid=g)
tg &lt;- sp::as.image.SpatialGridDataFrame(tg)
tg$x &lt;- tg$x - diff(tg$x[1:2]) / 2
tg$y &lt;- tg$y - diff(tg$y[1:2]) / 2

op &lt;- par(mfcol=c(4, 1))
for (i in 1:length(trip.list)) {
  plot(sp::coordinates(tr), pch=16, cex=0.7)
  title(names(trip.list)[i], cex.main=0.9)
  image(tripGrid(trip.list[[i]], grid=g, method="density", sigma=1),
        interpolate=FALSE,
        col=c("white", grey(seq(0.2, 0.7, length=256))),
        add=TRUE)
  lines(trip.list[[i]])
  points(trip.list[[i]], pch=16, cex=0.7)
}

par(op)
print("you may need to resize the window to see the grid data")



data("walrus818", package = "trip")
library(lubridate)
walrus_list &lt;- cut(walrus818, seq(floor_date(min(walrus818$DataDT), "month"),
ceiling_date(max(walrus818$DataDT), "month"), by = "1 month"))
g &lt;- rasterize(walrus818) * NA_real_
stk &lt;- raster::stack(lapply(walrus_list, rasterize, grid = g))
st &lt;- raster::aggregate(stk, fact = 4, fun = sum, na.rm = TRUE)
st[!st &gt; 0] &lt;- NA_real_

plot(st, col = oc.colors(52))
</code></pre>

<hr>
<h2 id='forceCompliance'>Function to ensure dates and times are in order with trip ID</h2><span id='topic+forceCompliance'></span>

<h3>Description</h3>

<p>A convenience function, that removes duplicate rows, sorts by the date-times
within ID, and removes duplicates from a data frame or
SpatialPointsDataFrame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forceCompliance(x, tor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forceCompliance_+3A_x">x</code></td>
<td>
<p><code><a href="base.html#topic+data.frame">data.frame</a></code> or
<code><a href="sp.html#topic+SpatialPointsDataFrame-class">SpatialPointsDataFrame-class</a></code></p>
</td></tr>
<tr><td><code id="forceCompliance_+3A_tor">tor</code></td>
<td>
<p>character vector of names of date-times and trip ID columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+data.frame">data.frame</a></code> or
<code><a href="sp.html#topic+SpatialPointsDataFrame-class">SpatialPointsDataFrame-class</a></code>.
</p>


<h3>Note</h3>

<p>It's really important that data used are of a given quality, but this
function makes the most common trip problems easy to apply.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trip">trip</a></code>
</p>

<hr>
<h2 id='homedist'>Calculate maximum distance from 'home' for each trip</h2><span id='topic+homedist'></span>

<h3>Description</h3>

<p>This function returns a distance from a given 'home' coordinate for each individual trip.
Use the <code>home</code> argument to provide a single, common 2-element (x,y or lon,lat) coordinate. If <code>home</code>
is <code>NULL</code> (the default), then each individual trip's first location is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homedist(x, home = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homedist_+3A_x">x</code></td>
<td>
<p>trip object</p>
</td></tr>
<tr><td><code id="homedist_+3A_home">home</code></td>
<td>
<p>see details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of distances in km (for longlat), or in the units of the trip's projection
</p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+spDistsN1">spDistsN1</a></code>
</p>

<hr>
<h2 id='interp_equal'>Track intermediate points</h2><span id='topic+interp_equal'></span>

<h3>Description</h3>

<p>Calculate great circle intermediate points on longitude, latitude input vectors. A spherical model is used, from the geosphere package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp_equal(x, distance = NULL, duration = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interp_equal_+3A_x">x</code></td>
<td>
<p>trip object</p>
</td></tr>
<tr><td><code id="interp_equal_+3A_distance">distance</code></td>
<td>
<p>optional minimum distance (metres) between interpolated points</p>
</td></tr>
<tr><td><code id="interp_equal_+3A_duration">duration</code></td>
<td>
<p>optional minimum duration (seconds) between interpolated points</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the result to be sensible, the input must either be in longitude/latitude, or be in a projection and have a valid CRS. Great
circle movement is assumed, there's no way to use this to interpolate equal-distance in the native projection.
</p>
<p>If no input <code>distance</code> or <code>duration</code> is provided a default is used of 15 points between each input point.
</p>
<p>if both <code>distance</code> AND <code>duration</code> is provided, <code>distance</code> is ignored.
</p>
<p>Note, the original implementation of this function was called 'interpequal()', and was used for time spent
calculations. The functionality is now provided by the traipse package.
</p>


<h3>Value</h3>

<p>S4 trip object with interpolated new locations based on distance or duration parameters
</p>

<hr>
<h2 id='makeGridTopology'>Generate a GridTopology from a Spatial object</h2><span id='topic+makeGridTopology'></span>

<h3>Description</h3>

<p>Sensible defaults are assumed, to match the extents of data to a manageable
grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeGridTopology(
  obj,
  cells.dim = c(100, 100),
  xlim = NULL,
  ylim = NULL,
  buffer = 0,
  cellsize = NULL,
  adjust2longlat = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeGridTopology_+3A_obj">obj</code></td>
<td>
<p>any Spatial object, or other object for which <code>bbox</code> will
work</p>
</td></tr>
<tr><td><code id="makeGridTopology_+3A_cells.dim">cells.dim</code></td>
<td>
<p>the number of cells of the grid, x then y</p>
</td></tr>
<tr><td><code id="makeGridTopology_+3A_xlim">xlim</code></td>
<td>
<p>x limits of the grid</p>
</td></tr>
<tr><td><code id="makeGridTopology_+3A_ylim">ylim</code></td>
<td>
<p>y limits of the grid</p>
</td></tr>
<tr><td><code id="makeGridTopology_+3A_buffer">buffer</code></td>
<td>
<p>proportional size of the buffer to add to the grid limits</p>
</td></tr>
<tr><td><code id="makeGridTopology_+3A_cellsize">cellsize</code></td>
<td>
<p>pixel cell size</p>
</td></tr>
<tr><td><code id="makeGridTopology_+3A_adjust2longlat">adjust2longlat</code></td>
<td>
<p>assume cell size is in kilometres and provide simple
adjustment for earth-radius cells at the north-south centre of the grid</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Approximations for kilometres in longlat can be made using <code>cellsize</code>
and <code>adjust2longlat</code>.
</p>


<h3>Value</h3>

<p>S4 class GridTopology with properties set variously from input parameters
</p>

<hr>
<h2 id='oc.theme'>SeaWiFS ocean colour colours</h2><span id='topic+oc.theme'></span><span id='topic+oc.colors'></span>

<h3>Description</h3>

<p>Generate ocean colour colours, using the SeaWiFS scheme
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oc.theme(x = 50)

oc.colors(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oc.theme_+3A_x">x</code></td>
<td>
<p>Number of colours to generate as part of a theme</p>
</td></tr>
<tr><td><code id="oc.theme_+3A_n">n</code></td>
<td>
<p>Number of colours to generate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a high-contrast palette, log-scaled originally for ocean
chlorophyll.
</p>


<h3>Value</h3>

<p>A set of colours or a theme object.
</p>


<h3>See Also</h3>

<p>Similar functions in sp <code><a href="sp.html#topic+spplot">spplot</a></code>,
<code><a href="sp.html#topic+bpy.colors">bpy.colors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> oc.colors(10)
 library(lattice)
 trellis.par.set(oc.theme())
 d &lt;- data.frame(x=1:10, y=rnorm(10), tms=Sys.time() + 1:10, id=gl(2, 5))
tr &lt;- trip(d)

 tg &lt;- tripGrid(tr)
 plot(tg)
</code></pre>

<hr>
<h2 id='rasterize'>Rasterize trip objects based on line-segment attributes.</h2><span id='topic+rasterize'></span><span id='topic+rasterize+2Ctrip+2CRasterLayer-method'></span><span id='topic+rasterize+2Ctrip+2Cmissing-method'></span>

<h3>Description</h3>

<p>Trip rasterize.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterize_+3A_x">x</code></td>
<td>
<p><code>trip</code> object</p>
</td></tr>
<tr><td><code id="rasterize_+3A_y">y</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="rasterize_+3A_field">field</code></td>
<td>
<p>attribute from which differences will be calculated, defaults to the time-stamp between trip locations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RasterLayer
</p>


<h3>Examples</h3>

<pre><code class='language-R'> d &lt;- data.frame(x=1:10, y=rnorm(10), tms=Sys.time() + 1:10, id=gl(2, 5))
tr &lt;- trip(d, c("tms", "id"))

tr$temp &lt;- sort(runif(nrow(tr)))
r &lt;- rasterize(tr)

rasterize(tr, grid = r)

rasterize(tr, r, field = "temp")
rasterize(tr, method = "density")
rasterize(tr, method = "density", grid = r)

rasterize(tr, r, field = "tms")
rasterize(tr, r)



</code></pre>

<hr>
<h2 id='readArgos'>Read Argos &quot;DAT&quot; or &quot;DIAG&quot; files</h2><span id='topic+readArgos'></span><span id='topic+readDiag'></span>

<h3>Description</h3>

<p>Return a (Spatial) data frame of location records from raw Argos files.
Multiple files may be read, and each set of records is appended to the data
frame in turn.  Basic validation of the data is enforced by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readArgos(
  x,
  correct.all = TRUE,
  dtFormat = "%Y-%m-%d %H:%M:%S",
  tz = "GMT",
  duplicateTimes.eps = 0.01,
  p4 = "+proj=longlat +ellps=WGS84",
  verbose = FALSE,
  read_alt = NULL,
  ...
)

readDiag(x, return_trip = FALSE, read_alt = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readArgos_+3A_x">x</code></td>
<td>
<p>vector of file names of Argos &quot;DAT&quot; or &quot;DIAG&quot; files.</p>
</td></tr>
<tr><td><code id="readArgos_+3A_correct.all">correct.all</code></td>
<td>
<p>logical - enforce validity of data as much as possible?
(see Details)</p>
</td></tr>
<tr><td><code id="readArgos_+3A_dtformat">dtFormat</code></td>
<td>
<p>the DateTime format used by the Argos data &quot;date&quot; and &quot;time&quot;
pasted together</p>
</td></tr>
<tr><td><code id="readArgos_+3A_tz">tz</code></td>
<td>
<p>timezone - GMT/UTC is assumed</p>
</td></tr>
<tr><td><code id="readArgos_+3A_duplicatetimes.eps">duplicateTimes.eps</code></td>
<td>
<p>what is the tolerance for times being duplicate?</p>
</td></tr>
<tr><td><code id="readArgos_+3A_p4">p4</code></td>
<td>
<p>PROJ.4 projection string, &quot;+proj=longlat +ellps=WGS84&quot; is assumed</p>
</td></tr>
<tr><td><code id="readArgos_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, details on date-time adjustment is reported</p>
</td></tr>
<tr><td><code id="readArgos_+3A_read_alt">read_alt</code></td>
<td>
<p>is <code>NULL</code> by default, with longitude and latitude read from the PRV message, if <code>1</code> or <code>2</code>
then attempt is made to read the alternative locations (but these are not always present)</p>
</td></tr>
<tr><td><code id="readArgos_+3A_...">...</code></td>
<td>
<p>reserved for future use</p>
</td></tr>
<tr><td><code id="readArgos_+3A_return_trip">return_trip</code></td>
<td>
<p>for <code><a href="#topic+readDiag">readDiag()</a></code> if <code>TRUE</code> will return a trip object, use <code>read_alt</code> to control the location</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>readArgos</code> performs basic validation checks for class <code>trip</code> are
made, and enforced based on <code>correct.all</code>:
</p>
<p>No duplicate records in the data, these are simply removed.  Records are
ordered by DateTime (&quot;date&quot;, &quot;time&quot;, &quot;gmt&quot;) within ID (&quot;ptt&quot;).  No duplicate
DateTime values within ID are allowed: to enforce this the time values are
moved forward by one second - this is done recursively and is not robust.
</p>
<p>If validation fails the function will return a
<code><a href="sp.html#topic+SpatialPointsDataFrame-class">SpatialPointsDataFrame-class</a></code>.  Files that are not obviously of
the required format are skipped.
</p>
<p>Argos location quality data &quot;class&quot; are ordered, assuming that the available
levels is <code>levels=c("Z", "B", "A", "0", "1", "2", "3")</code>.
</p>
<p>A projection string is added to the data, assuming the PROJ.4 longlat - if
any longitudes are greater than 360 the PROJ.4 argument &quot;+over&quot; is added.
</p>
<p><code>readDiag</code> simply builds a <code>data.frame</code>.
</p>
<p>With <code>read_alt</code> the default value <code>NULL</code> returns the PRV location as-is. Some files may have
a standardized location, and a dummy. If <code>read_alt</code> is set to 1 or 2 the corresponding &quot;alternative&quot;
location is returned. 1 is a standardized location corresponding to the original PRV message, and 2 is a
&quot;dummy&quot; location.
</p>


<h3>Value</h3>

<p><code>readArgos</code> returns a <code>trip</code> object, if all goes well, or simply a
<code><a href="sp.html#topic+SpatialPointsDataFrame-class">SpatialPointsDataFrame-class</a></code>.
</p>
<p><code>readDiag</code> returns a <code>data.frame</code> with 8 columns:
</p>

<ul>
<li> <p><code>lon1</code>,<code>lat1</code> first pair of coordinates
</p>
</li>
<li> <p><code>lon1</code>,<code>lat1</code> second pair of coordinates
</p>
</li>
<li> <p>gmt DateTimes as POSIXct
</p>
</li>
<li> <p>id Platform Transmitting Terminal (PTT) ID
</p>
</li>
<li> <p>lq Argos location quality class
</p>
</li>
<li> <p>iq some other thing
</p>
</li></ul>



<h3>Warning </h3>

<p>This works on some Argos files I have seen.
</p>


<h3>References</h3>

<p>The Argos data documentation was (ca. 2003) at
http://www.argos-system.org/manual.  Specific details on the PRV
(&quot;provide data&quot;) format were found in Chapter 4_4_8, originally at
'http://www.cls.fr/manuel/html/chap4/chap4_4_8.htm'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trip">trip</a></code>, <code><a href="sp.html#topic+SpatialPointsDataFrame-class">SpatialPointsDataFrame-class</a></code>,
<code><a href="#topic+adjust.duplicateTimes">adjust.duplicateTimes</a></code>, for manipulating these data, and
<code><a href="#topic+argos.sigma">argos.sigma</a></code> for relating a numeric value to Argos quality
&quot;classes&quot;.
</p>
<p><code><a href="#topic+sepIdGaps">sepIdGaps</a></code> for splitting the IDs in these data on some minimum
gap.
</p>
<p><code><a href="base.html#topic+order">order</a></code>, <code><a href="base.html#topic+duplicated">duplicated</a></code>, , <code><a href="base.html#topic+ordered">ordered</a></code> for
general manipulation of this type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>argosfile &lt;-
  system.file("extdata/argos/98feb.dat", package = "trip", mustWork = TRUE)
argos &lt;- readArgos(argosfile)
</code></pre>

<hr>
<h2 id='reproj'>Reprojection</h2><span id='topic+reproj'></span><span id='topic+reproj.trip'></span>

<h3>Description</h3>

<p>A reproj method for trip objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trip'
reproj(x, target, ..., source = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reproj_+3A_x">x</code></td>
<td>
<p>trip object</p>
</td></tr>
<tr><td><code id="reproj_+3A_target">target</code></td>
<td>
<p>target projection</p>
</td></tr>
<tr><td><code id="reproj_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="reproj_+3A_source">source</code></td>
<td>
<p>projection of source data, usually ignore this for trips</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a trip reprojected to 'target'
</p>

<hr>
<h2 id='sda'>Filter track for speed, distance and angle.</h2><span id='topic+sda'></span>

<h3>Description</h3>

<p>Create a filter index of a track for &quot;bad&quot; points with a
combination of speed, distance and angle tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sda(x, smax, ang = c(15, 25), distlim = c(2.5, 5), pre = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sda_+3A_x">x</code></td>
<td>
<p>trip object</p>
</td></tr>
<tr><td><code id="sda_+3A_smax">smax</code></td>
<td>
<p>maximum speed, in km/h</p>
</td></tr>
<tr><td><code id="sda_+3A_ang">ang</code></td>
<td>
<p>minimum turning angle/s in degrees</p>
</td></tr>
<tr><td><code id="sda_+3A_distlim">distlim</code></td>
<td>
<p>maximum step lengths in km</p>
</td></tr>
<tr><td><code id="sda_+3A_pre">pre</code></td>
<td>
<p>include this filter in the removal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an independent  implementation from that in the
package argosfilter by Freitas 2008.
</p>


<h3>Value</h3>

<p>logical vector, with <code>FALSE</code> values where the tests failed
</p>


<h3>References</h3>

<p>Freitas, C., Lydersen, C., Fedak, M. A. and Kovacs,
K. M. (2008), A simple new algorithm to filter marine mammal Argos
locations. Marine Mammal Science, 24: 315?V325. doi:
10.1111/j.1748-7692.2007.00180.x
</p>

<hr>
<h2 id='sepIdGaps'>Separate a set of IDs based on gaps</h2><span id='topic+sepIdGaps'></span>

<h3>Description</h3>

<p>A new set of ID levels can be created by separating those given based on a
minimum gap in another set of data. This is useful for separating
instruments identified only by their ID into separate events in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sepIdGaps(id, gapdata, minGap = 3600 * 24 * 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sepIdGaps_+3A_id">id</code></td>
<td>
<p>existing ID levels</p>
</td></tr>
<tr><td><code id="sepIdGaps_+3A_gapdata">gapdata</code></td>
<td>
<p>data matching <code>id</code> with gaps to use as separators</p>
</td></tr>
<tr><td><code id="sepIdGaps_+3A_mingap">minGap</code></td>
<td>
<p>the minimum &quot;gap&quot; to use in gapdata to create a new ID level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The assumption is that a week is a long time for a tag not to record
anything.
</p>


<h3>Value</h3>

<p>A new set of ID levels, named following the pattern that &quot;ID&quot; split into 3
would provided &quot;ID&quot;, &quot;ID_2&quot; and &quot;ID_3&quot;.
</p>


<h3>Warning</h3>

<p>It is assumed that each vector provides is sorted by <code>gapdata</code> within
<code>id</code>. No checking is done, and so it is suggested that this only be
used on ID columns within existing, validated <code>trip</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trip">trip</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

id &lt;- gl(2, 8)
gd &lt;- Sys.time() + 1:16
gd[c(4:6, 12:16)] &lt;- gd[c(4:6, 12:16)] + 10000
sepIdGaps(id, gd, 1000)


</code></pre>

<hr>
<h2 id='speedfilter'>Filter track data for speed</h2><span id='topic+speedfilter'></span>

<h3>Description</h3>

<p>Create a filter of a track for &quot;bad&quot; points implying a speed of motion that
is unrealistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>speedfilter(x, max.speed = NULL, test = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="speedfilter_+3A_x">x</code></td>
<td>
<p>trip object</p>
</td></tr>
<tr><td><code id="speedfilter_+3A_max.speed">max.speed</code></td>
<td>
<p>speed in kilometres (or other unit) per hour, the unit is kilometres
if the trip is in longitude latitude coordinates, or in the unit of the
projection projection (usually metres per hour)</p>
</td></tr>
<tr><td><code id="speedfilter_+3A_test">test</code></td>
<td>
<p>cut the algorithm short and just return first pass</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using an algorithm (McConnnell et al., 1992), points are tested for speed
between previous / next and 2nd previous / next points.  Contiguous sections
with an root mean square speed above a given maximum have their highest rms
point removed, then rms is recalculated, until all points are below the
maximum.  By default an (internal) root mean square function is used, this
can be specified by the user.
</p>
<p>If the coordinates of the <code>trip</code> data are not projected, or NA the
distance calculation assumes longlat and kilometres (great circle). For
projected coordinates the speed must match the units of the coordinate
system.  (The PROJ.4 argument &quot;units=km&quot; is suggested).
</p>


<h3>Value</h3>

<p>Logical vector matching positions in the coordinate records that pass the
filter.
</p>


<h3>Warning</h3>

<p>This algorithm is destructive, and provides little information about
location uncertainty.  It is provided because it's commonly used
and provides an illustrative benchmark for further work.
</p>
<p>It is possible for the filter to become stuck in an infinite loop, depending
on the function passed to the filter.  Several minutes is probably too long
for hundreds of points, test on smaller sections if unsure.
</p>


<h3>Note</h3>

<p>This algorithm was originally taken from IDL code by David Watts at the
Australian Antarctic Division, and used in various other environments before
the development of this version.
</p>


<h3>Author(s)</h3>

<p>David Watts and Michael D. Sumner
</p>


<h3>References</h3>

<p>The algorithm comes from McConnell, B. J. and Chambers, C. and Fedak, M. A.
(1992) Foraging ecology of southern elephant seals in relation to the
bathymetry and productivity of the southern ocean.  Antarctic Science
<em>4</em> 393-398
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sda">sda</a></code> for a fast distance angle filter to combine with speed filtering
</p>

<hr>
<h2 id='TimeOrderedRecords'>TimeOrderedRecords</h2><span id='topic+TimeOrderedRecords'></span>

<h3>Description</h3>

<p>Object to identify DateTimes and IDs in a Spatial object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TimeOrderedRecords(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TimeOrderedRecords_+3A_x">x</code></td>
<td>
<p>Character vector of 2 elements specifying the data columns of DateTimes and IDs</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TimeOrderedRecords</code> holds a 2-element character vector, naming the data columns
of DateTimes and IDs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##' tor &lt;- TimeOrderedRecords(c("datetime", "ID"))
</code></pre>

<hr>
<h2 id='TimeOrderedRecords-class'>A class for the identifiers of DateTime and ID records in spatial data.</h2><span id='topic+TimeOrderedRecords-class'></span>

<h3>Description</h3>

<p>The main use of this class and creator function is for
<code><a href="sp.html#topic+SpatialPointsDataFrame-class">SpatialPointsDataFrame-class</a></code>s which are used with
TimeOrderedRecords for the class <code>trip</code>.
</p>


<h3>Value</h3>

<p>S4 object, TimeOrderedRecords (a class to hold the names of the date-time and id columns)
</p>


<h3>Slots</h3>


<dl>
<dt><code>TOR.columns</code>:</dt><dd><p>2-element vector of class <code>"character"</code></p>
</dd>
</dl>



<h3>Note</h3>

<p>Future versions may change significantly, this class is
very basic and could probably be implemented in a better
way. Specifying TOR columns by formula would be a useful addition.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TimeOrderedRecords">TimeOrderedRecords</a></code>, <code><a href="#topic+trip">trip</a></code> for creating trip objects, and <code><a href="#topic+trip-class">trip-class</a></code> for that class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("TimeOrderedRecords")
tor &lt;- new("TimeOrderedRecords", TOR.columns=c("datetime", "ID"))
</code></pre>

<hr>
<h2 id='trackAngle'>Determine internal angles along a track</h2><span id='topic+trackAngle'></span><span id='topic+trackAngle.trip'></span><span id='topic+trackAngle.default'></span>

<h3>Description</h3>

<p>Calculate the angles between subsequent 2-D coordinates using Great Circle
distance (spherical) methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trackAngle(x)

## S3 method for class 'trip'
trackAngle(x)

## Default S3 method:
trackAngle(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trackAngle_+3A_x">x</code></td>
<td>
<p>trip object, or matrix of 2-columns, with x/y coordinates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a trip object, the return result has an extra element for the
start and end point of each individual trip, with value NA.
</p>
<p>This is an optimized hybrid of &quot;raster::bearing&quot; and
&quot;maptools::gzAzimuth&quot;. New code is in the traipse package.
</p>


<h3>Value</h3>

<p>Vector of angles (degrees) between coordinates.
</p>

<hr>
<h2 id='trackDistance'>Determine distances along a track</h2><span id='topic+trackDistance'></span><span id='topic+trackDistance.default'></span><span id='topic+trackDistance.trip'></span>

<h3>Description</h3>

<p>Calculate the distances between subsequent 2-D coordinates using Euclidean
or Great Circle distance (WGS84 ellipsoid) methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trackDistance(x1, y1, x2, y2, longlat = TRUE, prev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trackDistance_+3A_x1">x1</code></td>
<td>
<p>trip object, matrix of 2-columns, with x/y coordinates OR a vector
of x start coordinates</p>
</td></tr>
<tr><td><code id="trackDistance_+3A_y1">y1</code></td>
<td>
<p>vector of y start coordinates, if x1 is not a matrix</p>
</td></tr>
<tr><td><code id="trackDistance_+3A_x2">x2</code></td>
<td>
<p>vector of x end coordinates, if x1 is not a matrix</p>
</td></tr>
<tr><td><code id="trackDistance_+3A_y2">y2</code></td>
<td>
<p>vector of y end coordinates, if x1 is not a matrix</p>
</td></tr>
<tr><td><code id="trackDistance_+3A_longlat">longlat</code></td>
<td>
<p>if FALSE, Euclidean distance, if TRUE Great Circle distance</p>
</td></tr>
<tr><td><code id="trackDistance_+3A_prev">prev</code></td>
<td>
<p>if TRUE and x1 is a trip, the return value has a padded end
value (\&quot;prev\&quot;ious), rather than start (\&quot;next\&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x1</code> is a trip object, arguments <code>x2</code>, <code>x3</code>, <code>y2</code> are
ignored and the return result has an extra element for the start point of
each individual trip, with value 0.0.
</p>
<p>The <code>prev</code> argument is ignore unless x1 is a trip.
</p>
<p>Distance values are in the units of the input coordinate system when longlat
is FALSE, and in kilometres when longlat is TRUE.
</p>
<p>This originally used <code><a href="sp.html#topic+spDistsN1">spDistsN1</a></code>, then implemented the sp
<code>gcdist</code> source directly in R, and now uses <code><a href="geodist.html#topic+geodist">geodist</a></code>.
</p>
<p>Please see the traipse package for a more modern approach.
</p>


<h3>Value</h3>

<p>Vector of distances between coordinates.
</p>


<h3>References</h3>

<p>Original source taken from sp package, but now using Helmert from Karney (2013)
see the geodist package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> d &lt;- data.frame(x=1:10, y=rnorm(10), tms=Sys.time() + 1:10, id=gl(2, 5))
 tr &lt;- trip(d, c("tms", "id"))

 ## the method knows this is a trip, so there is a distance for every
 ## point, including 0s as the start and at transitions between
 ## individual trips
trackDistance(tr)

## the default method does not know about the trips, so this is
##(n-1) distances between all points
trackDistance(coordinates(tr), longlat = FALSE)

## we get NA at the start, end and at transitions between trips

 angles &lt;- trackAngle(tr)
</code></pre>

<hr>
<h2 id='trip-accessors'>Functions to retrieve DateTime and ID data from within (Spatial) data
frames.</h2><span id='topic+trip-accessors'></span><span id='topic+getTORnames'></span><span id='topic+getTimeID'></span><span id='topic+print.summary.TORdata'></span>

<h3>Description</h3>

<p>Functions for retrieving the names of the columns used for DateTime and ID,
as well as the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTORnames(obj)

getTimeID(obj)

## S3 method for class 'summary.TORdata'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trip-accessors_+3A_obj">obj</code></td>
<td>
<p><code>trip</code> object.</p>
</td></tr>
<tr><td><code id="trip-accessors_+3A_x">x</code></td>
<td>
<p>trip object</p>
</td></tr>
<tr><td><code id="trip-accessors_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getTORnames</code> retrieves the column names from an object extending the
class <code>TimeOrderedRecords</code>, and <code>getTimeID</code> returns the data as a
data frame from an object extending the class <code>TimeOrderedRecords</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trip-class">trip-class</a></code>, for the use of this class with
<code><a href="sp.html#topic+SpatialPointsDataFrame-class">SpatialPointsDataFrame-class</a></code>.
</p>
<p><code><a href="#topic+trip">trip</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

tor &lt;- TimeOrderedRecords(c("time", "id"))
getTORnames(tor)

</code></pre>

<hr>
<h2 id='trip-class'>A class for sets of animal trips (track data).</h2><span id='topic+trip-class'></span><span id='topic+lines+2Ctrip-method'></span><span id='topic+plot+2Ctrip+2Cmissing-method'></span><span id='topic+show+2Ctrip-method'></span><span id='topic+show+2Csummary.TORdata-method'></span><span id='topic+summary+2Ctrip-method'></span><span id='topic+subset+2Ctrip-method'></span>

<h3>Description</h3>

<p>An extension of <code><a href="sp.html#topic+SpatialPointsDataFrame-class">SpatialPointsDataFrame-class</a></code> by including
<code>"TimeOrderedRecords"</code>.  The records within the data frame are
explicitly ordered by DateTime data within IDs.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>trip(obj="SpatialPointsDataFrame", TORnames="TimeOrderedRecords")</code>.
The object contains all the slots present within a
<code><a href="sp.html#topic+SpatialPointsDataFrame-class">SpatialPointsDataFrame-class</a></code>, particularly <code>data</code> which
contains columns of at least those specified by <code>TOR.columns</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trip">trip</a></code> for examples of directly using the class.
</p>
<p><code><a href="#topic+trip-accessors">trip-accessors</a></code> describes methods for accessing information on
<code>trip</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

showClass("trip")

d &lt;- data.frame(x=1:10, y=rnorm(10), tms=Sys.time() + 1:10, id=gl(2, 5))
tr &lt;- trip(d)

summary(tr)
plot(tr)
lines(tr)

dim(tr)
names(tr)
subset(tr, id == "2")
as.data.frame(tr)

tr[1:3, ]
tr[, 1]
tr[[1]]



</code></pre>

<hr>
<h2 id='trip-internal'>Internal trip Functions</h2><span id='topic+trip-internal'></span><span id='topic+.validTORdata'></span><span id='topic+.oc.col'></span><span id='topic+.single.trip.split'></span><span id='topic+.g2ow'></span><span id='topic+.gcdist.c'></span><span id='topic+.intpFun'></span><span id='topic+.tripRbind'></span><span id='topic+.distances'></span><span id='topic+.abdali'></span>

<h3>Description</h3>

<p>Internal trip functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.validTORdata(object)

.intpFun(x)

.abdali(p1, p2)

.oc.col

.distances(x)

.g2ow(x)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 256.
</p>


<h3>Details</h3>

<p>These are not to be called by the user (or in some cases are just waiting
for proper documentation to be written).
</p>

<hr>
<h2 id='trip-methods'>Function to handle animal track data, organized as <code>trip</code> objects</h2><span id='topic+trip-methods'></span><span id='topic+trip'></span><span id='topic+trip+2CSpatialPointsDataFrame+2CANY-method'></span><span id='topic+trip+2CSpatialPointsDataFrame+2CTimeOrderedRecords-method'></span><span id='topic+trip+2CANY+2CTimeOrderedRecords-method'></span><span id='topic+trip+2Ctrip+2CANY-method'></span><span id='topic+trip+2Cgrouped_df+2CANY-method'></span><span id='topic+trip+2Cdata.frame+2CANY-method'></span><span id='topic+trip+2Ctrack_xyt+2CANY-method'></span><span id='topic+trip+2CtrackeRdata+2CANY-method'></span><span id='topic+trip+2Cmousetrap+2CANY-method'></span><span id='topic+trip+2Csf+2CANY-method'></span><span id='topic+trip+2Ctelemetry+2CANY-method'></span><span id='topic+trip+2Clist+2CANY-method'></span><span id='topic+trip+2Ctrip+2CTimeOrderedRecords-method'></span><span id='topic+split+2Ctrip+2CANY-method'></span><span id='topic++5B+2Ctrip-method'></span><span id='topic++5B+2Ctrip+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+5B+3C-+2Ctrip+2CANY+2Cmissing-method'></span><span id='topic+trip+3C-+2Cdata.frame+2Ccharacter-method'></span><span id='topic+trip+3C-'></span>

<h3>Description</h3>

<p>Create an object of class <code>trip</code>, extending the basic functionality
of <code><a href="sp.html#topic+SpatialPointsDataFrame-class">SpatialPointsDataFrame-class</a></code> by specifying the data columns
that define the &quot;TimeOrdered&quot; quality of the records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trip(obj, TORnames, correct_all = TRUE)

trip(obj) &lt;- value

## S4 method for signature 'trip,ANY'
split(x, f, drop = FALSE, ...)

## S4 method for signature 'trip,ANY,ANY,ANY'
x[i, j, ..., drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trip-methods_+3A_obj">obj</code></td>
<td>
<p>A data frame, a grouped data frame or a <code><a href="sp.html#topic+SpatialPointsDataFrame-class">SpatialPointsDataFrame-class</a></code>
containing at least two columns with the DateTime and ID data as per <code>TORnames</code>.  See
Details.</p>
</td></tr>
<tr><td><code id="trip-methods_+3A_tornames">TORnames</code></td>
<td>
<p>Either a <code>TimeOrderedRecords</code> object, or a 2-element
character vector specifying the DateTime and ID column of <code>obj</code></p>
</td></tr>
<tr><td><code id="trip-methods_+3A_correct_all">correct_all</code></td>
<td>
<p>logical value, if <code>TRUE</code> the input data is corrected for common problems</p>
</td></tr>
<tr><td><code id="trip-methods_+3A_value">value</code></td>
<td>
<p>A 4-element character vector specifying the X, Y, DateTime coordinates
and ID of <code>obj</code>.</p>
</td></tr>
<tr><td><code id="trip-methods_+3A_x">x</code></td>
<td>
<p>trip object</p>
</td></tr>
<tr><td><code id="trip-methods_+3A_f">f</code></td>
<td>
<p>grouping vector as per <code><a href="base.html#topic+split">split()</a></code></p>
</td></tr>
<tr><td><code id="trip-methods_+3A_drop">drop</code></td>
<td>
<p>unused but necessary for method consistency</p>
</td></tr>
<tr><td><code id="trip-methods_+3A_i">i</code>, <code id="trip-methods_+3A_j">j</code>, <code id="trip-methods_+3A_...">...</code></td>
<td>
<p>indices specifying elements to extract</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The original form of <code>trip()</code> required very strict input as a 'SpatialPointsDataFrame' and
specifying which were the time and ID columns, but the input can be more flexible. If the object is a
grouped data frame ('dplyr-style') then the (first) grouping is assumed to define individual trips and that
columns 1, 2, 3 are the x-, y-, time-coordinates in that order. It can also be a <code>trip</code> object for
redefining <code>TORnames</code>.
</p>
<p>The <code><a href="#topic+trip">trip()</a></code> function can ingest <code>track_xyt</code>, <code>telemetry</code>, <code>SpatialPointsDataFrame</code>, <code>sf</code>,
<code>trackeRdata</code>, <code>grouped_df</code>, <code>data.frame</code>, <code>tbl_df</code>, <code>mousetrap</code>, and in some cases
lists of those objects. Please get in touch if you think something that should work does not.
</p>
<p>Track data often contains problems, with missing values in location or time,
times out of order or with duplicated times. The <code>correct_all</code> argument is
set to <code>TRUE</code> by default and will report any inconsistencies. Data really should
be checked first rather than relying on this auto-cleanup. The following problems are common:
</p>

<ul>
<li><p> duplicated records (every column with the same value in another row)
</p>
</li>
<li><p> duplicated date-time values
</p>
</li>
<li><p> missing date-time values, or missing x or y coordinates
</p>
</li>
<li><p> records out of order within trip ID
</p>
</li></ul>

<p>For some data types there's no formal structure, but a simple convention such as
a set of names in a data frame. For example, the VTrack package has <code>AATAMS1</code> which may be
turned into a trip with
<code style="white-space: pre;">&#8288;trip(AATAMS1 %&gt;% dplyr::select(longitude, latitude, timestamp, tag.ID, everything())&#8288;</code>
In time we can add support for all kinds of variants, detected by the names and contents.
</p>
<p>See <a href="https://figshare.utas.edu.au/articles/thesis/The_tag_location_problem/23209538">Chapter 2 of the trip thesis</a> for more details.
</p>


<h3>Value</h3>

<p>A trip object, with the usual slots of a
<code><a href="sp.html#topic+SpatialPointsDataFrame-class">SpatialPointsDataFrame-class</a></code> and the added
<code>TimeOrderedRecords</code>. For the most part this can be treated as a
<code>data.frame</code> with <code>Spatial</code> coordinates.
</p>


<h3>Methods</h3>

<p>Most of the methods available are by virtue of the sp package.  Some, such
as <code>split.data.frame</code> have been added to SPDF so that trip has the same
functionality.
</p>

<dl>
<dt>trip</dt><dd><p><code>signature(obj="SpatialPointsDataFrame",
TORnames="ANY")</code></p>
</dd></dl>
<p>The main construction.
</p>
<dl>
<dt>trip</dt><dd><p><code>signature(obj="SpatialPointsDataFrame",
TORnames="TimeOrderedRecords")</code></p>
</dd></dl>
<p> Object and TimeOrdered records class
</p>
<dl>
<dt>trip</dt><dd><p><code>signature(obj="ANY", TORnames="TimeOrderedRecords")</code>:
create a <code>trip</code> object from a data frame.</p>
</dd>
<dt>trip</dt><dd><p><code>signature(obj="trip", TORnames="ANY")</code>: (Re)-create a
<code>trip</code> object using a character vector for <code>TORnames</code>.</p>
</dd>
<dt>trip</dt><dd><p><code>signature(obj="trip", TORnames="TimeOrderedRecords")</code>:
(re)-create a trip object using a <code>TimeOrderedRecords</code> object.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+speedfilter">speedfilter</a></code>, and <code><a href="#topic+tripGrid">tripGrid</a></code> for simplistic
speed filtering and spatial time spent gridding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

d &lt;- data.frame(x=1:10, y=rnorm(10), tms=Sys.time() + 1:10, id=gl(2, 5))

## the simplest way to create a trip is by order of columns

trip(d)

tr &lt;- trip(d)
 ## real world data in CSV
mi_dat &lt;- read.csv(system.file("extdata/MI_albatross_sub10.csv", package = "trip"),
            stringsAsFactors = FALSE)
mi_dat$gmt &lt;- as.POSIXct(mi_dat$gmt, tz = "UTC")
mi_dat$sp_id &lt;-  sprintf("%s%s_%s_%s", mi_dat$species,
         substr(mi_dat$breeding_status, 1, 1), mi_dat$band, mi_dat$tag_ID)
sp::coordinates(mi_dat) &lt;- c("lon", "lat")
## there are many warnings, but the outcome is fine
## (sp_id == 'WAi_14030938_2123' has &lt; 3 locations as does LMi_12143650_14257)
mi_dat &lt;- trip(mi_dat, c("gmt", "sp_id") )
plot(mi_dat, pch = ".")
#lines(mi_dat)  ## ugly

mi_dat_polar &lt;- reproj(mi_dat, "+proj=stere +lat_0=-90 +lon_0=154 +datum=WGS84")
plot(mi_dat_polar, pch = ".")
lines(mi_dat_polar)


</code></pre>

<hr>
<h2 id='trip-package'>trip.</h2><span id='topic+trip-package'></span>

<h3>Description</h3>

<p>Functions for accessing and manipulating spatial data for animal
tracking, with straightforward coercion from and to other formats. Filter
for speed and create time spent maps from animal track data. There are
coercion methods to convert between 'trip' and 'ltraj' from 'adehabitatLT',
and between 'trip' and 'psp' and 'ppp' from 'spatstat'. Trip objects
can be created from raw or grouped data frames, and from types in the 'sp',
'sf', 'amt', 'trackeR', and other packages.
</p>

<hr>
<h2 id='trip.split.exact'>Deprecated functions in trip</h2><span id='topic+trip.split.exact'></span><span id='topic+trip-deprecated'></span><span id='topic+as.trip.SpatialLinesDataFrame'></span><span id='topic+tripTransform'></span><span id='topic+as.ltraj.trip'></span><span id='topic+as.SpatialLinesDataFrame.trip'></span>

<h3>Description</h3>

<p>These functions will be declared defunct in a future release.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.SpatialLinesDataFrame.trip(from)

trip.split.exact(x, dates)

as.ltraj.trip(xy)

as.trip.SpatialLinesDataFrame(from)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trip.split.exact_+3A_from">from</code></td>
<td>
<p>trip object</p>
</td></tr>
<tr><td><code id="trip.split.exact_+3A_x">x</code></td>
<td>
<p>see <code><a href="#topic+cut.trip">cut.trip</a></code></p>
</td></tr>
<tr><td><code id="trip.split.exact_+3A_dates">dates</code></td>
<td>
<p>see <code><a href="#topic+cut.trip">cut.trip</a></code></p>
</td></tr>
<tr><td><code id="trip.split.exact_+3A_xy">xy</code></td>
<td>
<p><code>trip</code> object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+cut.trip">cut.trip</a></code>, <code><a href="#topic+as.Other">as.Other</a></code>
</p>

<hr>
<h2 id='tripGrid'>Generate a grid of time spent by line-to-cell gridding</h2><span id='topic+tripGrid'></span>

<h3>Description</h3>

<p>Create a grid of time spent from an object of class <code>trip</code> by exact
cell crossing methods, weighted by the time between locations for separate
trip events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tripGrid(x, grid = NULL, method = "pixellate", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tripGrid_+3A_x">x</code></td>
<td>
<p>object of class <code>trip</code></p>
</td></tr>
<tr><td><code id="tripGrid_+3A_grid">grid</code></td>
<td>
<p>GridTopology - will be generated automatically if NULL</p>
</td></tr>
<tr><td><code id="tripGrid_+3A_method">method</code></td>
<td>
<p>pixellate or density</p>
</td></tr>
<tr><td><code id="tripGrid_+3A_...">...</code></td>
<td>
<p>pass arguments to density.psp if that method is chosen (and
temporary mechanism to direct users of legacy methods to
<code><a href="#topic+tripGrid.interp">tripGrid.interp</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Zero-length lines cannot be summed directly, their time value is summed by
assuming the line is a point. A warning used to be given, but as it achieved
nothing but create confusion it has been removed. The density method returns
proportionate values, not summed time durations.
</p>
<p>See <code>pixellate.psp</code> and <code>pixellate.ppp</code> for the details on the
method used. See <code>density.psp</code> for method=&quot;density&quot;.
</p>
<p>Trip events are assumed to start and end as per the object passed in. To
work with inferred &quot;cutoff&quot; positions see <code>split.trip.exact</code>.
</p>


<h3>Value</h3>

<p><code>tripGrid</code> returns an object of class <code>SpatialGridDataFrame</code>, with
one column &quot;z&quot; containing the time spent in each cell in seconds.
</p>

<hr>
<h2 id='tripGrid.interp'>Generate a grid of time spent using approximate methods</h2><span id='topic+tripGrid.interp'></span><span id='topic+interpequal'></span><span id='topic+countPoints'></span><span id='topic+kdePoints'></span>

<h3>Description</h3>

<p>Create a grid of time spent from an object of class <code>trip</code> by
approximating the time between locations for separate trip events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tripGrid.interp(x, grid = NULL, method = "count", dur = NULL, ...)

kdePoints(x, h = NULL, grid = NULL, resetTime = TRUE, ...)

countPoints(x, dur = 1, grid = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tripGrid.interp_+3A_x">x</code></td>
<td>
<p>object of class trip</p>
</td></tr>
<tr><td><code id="tripGrid.interp_+3A_grid">grid</code></td>
<td>
<p>GridTopology - will be generated automatically if NULL</p>
</td></tr>
<tr><td><code id="tripGrid.interp_+3A_method">method</code></td>
<td>
<p>name of method for quantifying time spent, see Details</p>
</td></tr>
<tr><td><code id="tripGrid.interp_+3A_dur">dur</code></td>
<td>
<p>The \&quot;dur\&quot;ation of time used to interpolate between available
locations (see Details)</p>
</td></tr>
<tr><td><code id="tripGrid.interp_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>interpequal</code> or <code>kdePoints</code></p>
</td></tr>
<tr><td><code id="tripGrid.interp_+3A_h">h</code></td>
<td>
<p>kernel bandwidth</p>
</td></tr>
<tr><td><code id="tripGrid.interp_+3A_resettime">resetTime</code></td>
<td>
<p>rescale result back to the total duration of the input</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This set of functions was the the original tripGrid from prior to version
1.1-6. <code>tripGrid</code> should be used for more exact and fast calculations
assuming linear motion between fixes.
</p>
<p>The intention is for <code>tripGrid.interp</code> to be used for exploring
approximate methods of line-to-cell gridding.
</p>
<p>Trip locations are first interpolated, based on an equal-time spacing
between records. These interpolated points are then &quot;binned&quot; to a grid of
cells.  The time spacing is specified by the <code>dur</code> (duration) argument to
<code>interpequal</code> in seconds (i.e. <code>dur=3600</code> is used for 1 hour).
Shorter time periods will require longer computation with a closer
approximation to the total time spent in the gridded result.
</p>
<p>Currently there are methods &quot;count&quot; and &quot;kde&quot; for quantifying time spent,
corresponding to the functions &quot;countPoints&quot; and &quot;kdePoints&quot;. &quot;kde&quot; uses
kernel density to smooth the locations, &quot;count&quot; simply counts the points
falling in a grid cell.
</p>


<h3>Value</h3>

<p><code>tripGrid</code> returns an object of class <code>SpatialGridDataFrame</code>, with
one column &quot;z&quot; containing the time spent in each cell in seconds. If
kdePoints is used the units are not related to the time values and must be
scaled for further use.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+bandwidth.nrd">bandwidth.nrd</a></code> for the calculation of bandwidth values used internally when not supplied by the user
</p>

<hr>
<h2 id='walrus818'>Walrus tracking data set.</h2><span id='topic+walrus818'></span>

<h3>Description</h3>

<p>Behavior of Pacific Walruses Tracked from the Alaska Coast of the Chukchi Sea.
</p>


<h3>Details</h3>

<p>Data set is provided as a 'trip' object. This is the abstract for the work:
</p>
<p>&quot;We tracked movements and haulout foraging behavior of walruses instrumented with
satellite-linked data loggers from the Alaskan shores of the Chukchi Sea during the
autumn of 2009 (n=13) and 2010 (n=2).&quot;
Jay, C. V. and Fischbach, A.S.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(walrus818)
plot(walrus818)
lines(walrus818)

</code></pre>

<hr>
<h2 id='world_north'>World north polygons</h2><span id='topic+world_north'></span>

<h3>Description</h3>

<p>A spatial polygons object with coastlines of the northern hemisphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>world_north
</code></pre>


<h3>Format</h3>

<p>An object of class <code>SpatialPolygonsDataFrame</code> with 185 rows and 11 columns.
</p>


<h3>Details</h3>

<p>This data set exists purely to avoid requiring reprojection in the
vignette, the data uses the same projection as <a href="#topic+walrus818">walrus818</a>.
</p>

<hr>
<h2 id='write_track_kml'>Create a time-continuous KML file</h2><span id='topic+write_track_kml'></span>

<h3>Description</h3>

<p>Export track data to a KML file, for use in Google Earth the continuous
time slider.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_track_kml(
  id,
  lon,
  lat,
  utc,
  z = NULL,
  kml_file = tempfile(fileext = ".kmz"),
  name = NULL,
  altitude_mode = c("absolute", "clampToGround", "clampToSeaFloor", "relativeToGround",
    "relativeToSeaFloor")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_track_kml_+3A_id">id</code></td>
<td>
<p>vector of grouping IDs (or a trip object)</p>
</td></tr>
<tr><td><code id="write_track_kml_+3A_lon">lon</code></td>
<td>
<p>vector of longitude (ignored if id is a trip)</p>
</td></tr>
<tr><td><code id="write_track_kml_+3A_lat">lat</code></td>
<td>
<p>vector of latitude (ignored if id is a trip)</p>
</td></tr>
<tr><td><code id="write_track_kml_+3A_utc">utc</code></td>
<td>
<p>vector of POSIXct date-times (ignored if id is a trip)</p>
</td></tr>
<tr><td><code id="write_track_kml_+3A_z">z</code></td>
<td>
<p>vector of elevations, this cannot be set if 'id' is a trip</p>
</td></tr>
<tr><td><code id="write_track_kml_+3A_kml_file">kml_file</code></td>
<td>
<p>filename for KML (KML or KMZ) (must end in .kml or .kmz)</p>
</td></tr>
<tr><td><code id="write_track_kml_+3A_name">name</code></td>
<td>
<p>internal name of dat (derived from kml_file if not specified)</p>
</td></tr>
<tr><td><code id="write_track_kml_+3A_altitude_mode">altitude_mode</code></td>
<td>
<p>the altitude mode, 'absolute', 'clampToGround', 'clampToSeaFloor',
'relativeToGround', or 'relativeToSeaFloor', see Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To include altitude set every argument explicitly, by input of separate
'id', 'lon', 'lat', 'utc' and 'z' arguments. If the first argument 'id' is
a trip object there is no facility to include the 'z' altitude values.
</p>
<p>If 'z' is included it is applied as a third coordinate, with 'altitude_mode'
controlling the interpretation, see
<a href="https://developers.google.com/kml/documentation/altitudemode">https://developers.google.com/kml/documentation/altitudemode</a>.
If the 'kml_file' ends with &quot;.kmz&quot; the file is compressed, otherwise it must
end with &quot;.kml&quot; and the compression archive step is not applied.
</p>
<p>Sadly the interactive time slider is only available with the desktop version of
Google Earth, the data loads into the browser version but can't be interactive.
</p>


<h3>Value</h3>

<p>character vector, file name location of file produced
</p>


<h3>Author(s)</h3>

<p>Original implementation by Tomislav Hengl in the 'plotKML' package for 'SpatialLinesDataFrame',
adapted by M. Sumner for use in continuous-time form.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kfile &lt;- write_track_kml(walrus818[seq(1, 1000, by = 5), ])
print(kfile)
unlink(kfile)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
