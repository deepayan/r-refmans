<!DOCTYPE html><html><head><title>Help for package CARRoT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CARRoT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AUC'><p>Area Under the Curve</p></a></li>
<li><a href='#av_out'><p>Averaging out the predictive power</p></a></li>
<li><a href='#comb'><p>Combining in a list</p></a></li>
<li><a href='#compute_max_length'><p>Maximum number of the regressions</p></a></li>
<li><a href='#compute_max_weight'><p>Maximum feasible weight of the predictors</p></a></li>
<li><a href='#compute_weights'><p>Weights of predictors</p></a></li>
<li><a href='#cross_val'><p>Cross-validation run</p></a></li>
<li><a href='#cub'><p>Three-way interactions and squares</p></a></li>
<li><a href='#find_int'><p>Finding the interacting terms based on the index</p></a></li>
<li><a href='#find_sub'><p>Finds certain subsets of predictors</p></a></li>
<li><a href='#get_indices'><p>Best regression</p></a></li>
<li><a href='#get_predictions'><p>Predictions for multinomial regression</p></a></li>
<li><a href='#get_predictions_lin'><p>Predictions for linear regression</p></a></li>
<li><a href='#get_probabilities'><p>Probabilities for multinomial regression</p></a></li>
<li><a href='#make_numeric'><p>Turning a non-numeric variable into a numeric one</p></a></li>
<li><a href='#make_numeric_sets'><p>Transforming the set of predictors into a numeric set</p></a></li>
<li><a href='#quadr'><p>Pairwise interactions and squares</p></a></li>
<li><a href='#regr_ind'><p>Indices of the best regressions</p></a></li>
<li><a href='#sum_weights_sub'><p>Cumulative weights of the predictors' subsets</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Predicting Categorical and Continuous Outcomes Using One in Ten
Rule</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Predicts categorical or continuous outcomes while concentrating on a number of key points. These are Cross-validation, Accuracy, Regression and Rule of Ten or "one in ten rule" (CARRoT), and, in addition to it R-squared statistics, prior knowledge on the dataset etc. It performs the cross-validation specified number of times by partitioning the input into training and test set and fitting linear/multinomial/binary regression models to the training set. All regression models satisfying chosen constraints are fitted and the ones with the best predictive power are given as an output. Best predictive power is understood as highest accuracy in case of binary/multinomial outcomes, smallest absolute and relative errors in case of continuous outcomes. For binary case there is also an option of finding a regression model which gives the highest AUROC (Area Under Receiver Operating Curve) value. The option of parallel toolbox is also available. Methods are described in Peduzzi et al. (1996) &lt;<a href="https://doi.org/10.1016%2FS0895-4356%2896%2900236-3">doi:10.1016/S0895-4356(96)00236-3</a>&gt; , Rhemtulla et al. (2012) &lt;<a href="https://doi.org/10.1037%2Fa0029315">doi:10.1037/a0029315</a>&gt;, Riley et al. (2018) &lt;<a href="https://doi.org/10.1002%2Fsim.7993">doi:10.1002/sim.7993</a>&gt;, Riley et al. (2019) &lt;<a href="https://doi.org/10.1002%2Fsim.7992">doi:10.1002/sim.7992</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats,utils,nnet,doParallel,Rdpack,parallel,foreach</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-13 08:58:24 UTC; alinabazarova</td>
</tr>
<tr>
<td>Author:</td>
<td>Alina Bazarova [aut, cre],
  Marko Raseta [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alina Bazarova &lt;al.bazarova@fz-juelich.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-13 20:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='AUC'>Area Under the Curve</h2><span id='topic+AUC'></span>

<h3>Description</h3>

<p>Function enables efficient computation of area under receiver operating curve (AUC). Source: <a href="https://stat.ethz.ch/pipermail/r-help/2005-September/079872.html">https://stat.ethz.ch/pipermail/r-help/2005-September/079872.html</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AUC(probs, class)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AUC_+3A_probs">probs</code></td>
<td>
<p>probabilities</p>
</td></tr>
<tr><td><code id="AUC_+3A_class">class</code></td>
<td>
<p>outcomes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value for AUC
</p>


<h3>Examples</h3>

<pre><code class='language-R'>AUC(runif(100,0,1),rbinom(100,1,0.3))
</code></pre>

<hr>
<h2 id='av_out'>Averaging out the predictive power</h2><span id='topic+av_out'></span>

<h3>Description</h3>

<p>Function which averages out the predictive power over all cross-validations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>av_out(preds,crv,k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="av_out_+3A_preds">preds</code></td>
<td>
<p>An M x <code>crv</code>N matrix consisting of <code>crv</code> horizontally concatenated M x N matrices. These M x N matrices are the matrices of predictive powers for all feasible regressions (M is maximum feasible number of variables included in a regression, N is the maximum feasible number of regressions of the fixed size; the row index indicates the number of variables included in a regression)</p>
</td></tr>
<tr><td><code id="av_out_+3A_crv">crv</code></td>
<td>
<p>number of cross-validations</p>
</td></tr>
<tr><td><code id="av_out_+3A_k">k</code></td>
<td>
<p>size of the test set for which the predictions are made</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an M x N matrix of average predictive powers where M is maximum feasible number of variables included in a regression, N is the maximum feasible number of regressions of the fixed size; the row index indicates the number of variables included in a regression
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#creating a matrix of predictive powers

preds&lt;-cbind(matrix(runif(40,1,4),ncol=10),matrix(runif(40,1.5,4),ncol=10))
preds&lt;-cbind(preds,matrix(runif(40,1,3.5),ncol=10))

#running the function

av_out(preds,3,5)
</code></pre>

<hr>
<h2 id='comb'>Combining in a list</h2><span id='topic+comb'></span>

<h3>Description</h3>

<p>Function for combining outputs in a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comb_+3A_...">...</code></td>
<td>
<p>an argument of <code>mapply</code> used by this function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Function <code><a href="base.html#topic+mapply">mapply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#array of numbers to be separated in a list

a&lt;-1:4

#running the function

comb(a)
</code></pre>

<hr>
<h2 id='compute_max_length'>Maximum number of the regressions</h2><span id='topic+compute_max_length'></span>

<h3>Description</h3>

<p>Function which computes the maximum number of regressions with fixed number of variables based on the rule of thumb
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_max_length(vari_col,k,c,we,minx,maxx,st)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_max_length_+3A_vari_col">vari_col</code></td>
<td>
<p>number of predictors</p>
</td></tr>
<tr><td><code id="compute_max_length_+3A_k">k</code></td>
<td>
<p>maximum weight of the predictors</p>
</td></tr>
<tr><td><code id="compute_max_length_+3A_c">c</code></td>
<td>
<p>array of all indices of the predictors</p>
</td></tr>
<tr><td><code id="compute_max_length_+3A_we">we</code></td>
<td>
<p>array of weights of the predictors. Continuous or categorical numerical variable with more then 5 categories has weight 1, otherwise it has weight <code>n-1</code> where <code>n</code> is the number of categories</p>
</td></tr>
<tr><td><code id="compute_max_length_+3A_minx">minx</code></td>
<td>
<p>minimum number of predictors, 1 by default</p>
</td></tr>
<tr><td><code id="compute_max_length_+3A_maxx">maxx</code></td>
<td>
<p>maximum number of predictors, total number of variables by default</p>
</td></tr>
<tr><td><code id="compute_max_length_+3A_st">st</code></td>
<td>
<p>a subset of predictors to be always included into a predictive model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer correponding to maximum number of regressions of the same size
</p>


<h3>References</h3>


<p>Peduzzi P, Concato J, Kemper E, Holford TR, Feinstein AR (1996).
&ldquo;A simulation study of the number of events per variable in logistic regression analysis.&rdquo;
<em>Journal of Clinical Epidemiology</em>, <b>49</b>(12), 1373-1379.
ISSN 0895-4356, <a href="https://doi.org/10.1016/S0895-4356%2896%2900236-3">doi:10.1016/S0895-4356(96)00236-3</a>, <a href="http://dx.doi.org/10.1016/S0895-4356(96)00236-3">http://dx.doi.org/10.1016/S0895-4356(96)00236-3</a>.

</p>

<p>Rhemtulla M, Brosseau-Liard PÉ, Savalei V (2012).
&ldquo;When can categorical variables be treated as continuous?: A comparison of robust continuous and categorical SEM estimation methods under suboptimal conditions.&rdquo;
<em>Psychological Methods</em>, <b>17</b>(3), 354-373.
<a href="https://doi.org/10.1037/a0029315">doi:10.1037/a0029315</a>.

</p>


<h3>See Also</h3>

<p>Function uses <code><a href="utils.html#topic+combn">combn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compute_max_length(4,40,1:4,c(1,1,2,1))
</code></pre>

<hr>
<h2 id='compute_max_weight'>Maximum feasible weight of the predictors</h2><span id='topic+compute_max_weight'></span>

<h3>Description</h3>

<p>Function which computes maximal weight (multiplied by the corresponding EPV rule) of a regression according to the rule of thumb applied to the outcome variable. Weight of a regression equals the sum of weights of its predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_max_weight(outi,mode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_max_weight_+3A_outi">outi</code></td>
<td>
<p>set of outcomes</p>
</td></tr>
<tr><td><code id="compute_max_weight_+3A_mode">mode</code></td>
<td>
<p>indicates the mode: 'linear' (linear regression), 'binary' (logistic regression), 'multin' (multinomial regression)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For continuous outcomes it equals sample size divided by 10, for multinomial it equals the size of the smallest category divided by 10
</p>


<h3>Value</h3>

<p>returns an integer value of maximum allowed weight multiplied by 10
</p>


<h3>References</h3>


<p>Peduzzi P, Concato J, Kemper E, Holford TR, Feinstein AR (1996).
&ldquo;A simulation study of the number of events per variable in logistic regression analysis.&rdquo;
<em>Journal of Clinical Epidemiology</em>, <b>49</b>(12), 1373-1379.
ISSN 0895-4356, <a href="https://doi.org/10.1016/S0895-4356%2896%2900236-3">doi:10.1016/S0895-4356(96)00236-3</a>, <a href="http://dx.doi.org/10.1016/S0895-4356(96)00236-3">http://dx.doi.org/10.1016/S0895-4356(96)00236-3</a>.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>#continuous outcomes

compute_max_weight(runif(100,0,1),'linear')

#binary outcomes

compute_max_weight(rbinom(100,1,0.4),'binary')
</code></pre>

<hr>
<h2 id='compute_weights'>Weights of predictors</h2><span id='topic+compute_weights'></span>

<h3>Description</h3>

<p>Function which computes the weight of each predictor according to the rules of thumb and outputs it into corresponding array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_weights(vari_col, vari)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_weights_+3A_vari_col">vari_col</code></td>
<td>
<p>number of predictors</p>
</td></tr>
<tr><td><code id="compute_weights_+3A_vari">vari</code></td>
<td>
<p>set of predictors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Continuous or categorical numerical variable with more then 5 categories has weight 1, otherwise it has weight <code>n-1</code> where <code>n</code> is the number of categories
</p>


<h3>Value</h3>

<p>Returns an array of weights of the size <code>vari_col</code>
</p>


<h3>References</h3>


<p>Peduzzi P, Concato J, Kemper E, Holford TR, Feinstein AR (1996).
&ldquo;A simulation study of the number of events per variable in logistic regression analysis.&rdquo;
<em>Journal of Clinical Epidemiology</em>, <b>49</b>(12), 1373-1379.
ISSN 0895-4356, <a href="https://doi.org/10.1016/S0895-4356%2896%2900236-3">doi:10.1016/S0895-4356(96)00236-3</a>, <a href="http://dx.doi.org/10.1016/S0895-4356(96)00236-3">http://dx.doi.org/10.1016/S0895-4356(96)00236-3</a>.

</p>

<p>Rhemtulla M, Brosseau-Liard PÉ, Savalei V (2012).
&ldquo;When can categorical variables be treated as continuous?: A comparison of robust continuous and categorical SEM estimation methods under suboptimal conditions.&rdquo;
<em>Psychological Methods</em>, <b>17</b>(3), 354-373.
<a href="https://doi.org/10.1037/a0029315">doi:10.1037/a0029315</a>.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>#creating data-set with for variables

a&lt;-matrix(NA,nrow=100,ncol=4)

#binary variable

a[,1]=rbinom(100,1,0.3)

#continuous variable

a[,2]=runif(100,0,1)

#categorical numeric with les than 5 categories

a[,3]=t(rmultinom(100,1,c(0.2,0.3,0.5)))%*%c(1,2,3)

#categorical numeric with 5 categories

a[,4]=t(rmultinom(100,1,c(0.2,0.3,0.3,0.1,0.1)))%*%c(1,2,3,4,5)

#running the function

compute_weights(4,a)
</code></pre>

<hr>
<h2 id='cross_val'>Cross-validation run</h2><span id='topic+cross_val'></span>

<h3>Description</h3>

<p>Function running a single cross-validation by partitioning the data into training and test set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_val(
  vari,
  outi,
  c,
  rule,
  part,
  l,
  we,
  vari_col,
  preds,
  mode,
  cmode,
  predm,
  cutoff,
  objfun,
  minx = 1,
  maxx = NULL,
  nr = NULL,
  maxw = NULL,
  st = NULL,
  corr = 1,
  Rsq = F,
  marg = 0,
  n_tr,
  preds_tr
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_val_+3A_vari">vari</code></td>
<td>
<p>set of predictors</p>
</td></tr>
<tr><td><code id="cross_val_+3A_outi">outi</code></td>
<td>
<p>array of outcomes</p>
</td></tr>
<tr><td><code id="cross_val_+3A_c">c</code></td>
<td>
<p>set of all indices of the predictors</p>
</td></tr>
<tr><td><code id="cross_val_+3A_rule">rule</code></td>
<td>
<p>an Events per Variable (EPV) rule, defaults to 10</p>
</td></tr>
<tr><td><code id="cross_val_+3A_part">part</code></td>
<td>
<p>indicates partition of the original data-set into training and test set in a proportion <code>(part-1):1</code></p>
</td></tr>
<tr><td><code id="cross_val_+3A_l">l</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="cross_val_+3A_we">we</code></td>
<td>
<p>weights of the predictors</p>
</td></tr>
<tr><td><code id="cross_val_+3A_vari_col">vari_col</code></td>
<td>
<p>overall number of predictors</p>
</td></tr>
<tr><td><code id="cross_val_+3A_preds">preds</code></td>
<td>
<p>array to write predictions for the test split into, intially empty</p>
</td></tr>
<tr><td><code id="cross_val_+3A_mode">mode</code></td>
<td>
<p><code>'binary'</code> (logistic regression), <code>'multin'</code> (multinomial regression)</p>
</td></tr>
<tr><td><code id="cross_val_+3A_cmode">cmode</code></td>
<td>
<p><code>'det'</code> or <code>''</code>; <code>'det'</code> always predicts the more likely outcome as determined by the odds ratio; <code>''</code> predicts certain outcome with probability corresponding to its odds ratio (more conservative). Option available for multinomial/logistic regression</p>
</td></tr>
<tr><td><code id="cross_val_+3A_predm">predm</code></td>
<td>
<p><code>'exact'</code> or <code>''</code>; for logistic and multinomial regression; <code>'exact'</code> computes how many times the exact outcome category was predicted, <code>''</code> computes how many times either the exact outcome category or its nearest neighbour was predicted</p>
</td></tr>
<tr><td><code id="cross_val_+3A_cutoff">cutoff</code></td>
<td>
<p>cut-off value for logistic regression</p>
</td></tr>
<tr><td><code id="cross_val_+3A_objfun">objfun</code></td>
<td>
<p><code>'roc'</code> for maximising the predictive power with respect to AUC, <code>'acc'</code> for maximising predictive power with respect to accuracy.</p>
</td></tr>
<tr><td><code id="cross_val_+3A_minx">minx</code></td>
<td>
<p>minimum number of predictors to be included in a regression, defaults to 1</p>
</td></tr>
<tr><td><code id="cross_val_+3A_maxx">maxx</code></td>
<td>
<p>maximum number of predictors to be included in a regression, defaults to maximum feasible number according to one in ten rule</p>
</td></tr>
<tr><td><code id="cross_val_+3A_nr">nr</code></td>
<td>
<p>a subset of the data-set, such that <code>1/part</code> of it lies in the test set and <code>1-1/part</code> is in the training set, defaults to empty set</p>
</td></tr>
<tr><td><code id="cross_val_+3A_maxw">maxw</code></td>
<td>
<p>maximum weight of predictors to be included in a regression, defaults to maximum weight according to one in ten rule</p>
</td></tr>
<tr><td><code id="cross_val_+3A_st">st</code></td>
<td>
<p>a subset of predictors to be always included into a predictive model,defaults to empty set</p>
</td></tr>
<tr><td><code id="cross_val_+3A_corr">corr</code></td>
<td>
<p>maximum correlation between a pair of predictors in a model</p>
</td></tr>
<tr><td><code id="cross_val_+3A_rsq">Rsq</code></td>
<td>
<p>whether R-squared statistics constrained is introduced</p>
</td></tr>
<tr><td><code id="cross_val_+3A_marg">marg</code></td>
<td>
<p>margin of error for R-squared statistics constraint</p>
</td></tr>
<tr><td><code id="cross_val_+3A_n_tr">n_tr</code></td>
<td>
<p>size of the training set</p>
</td></tr>
<tr><td><code id="cross_val_+3A_preds_tr">preds_tr</code></td>
<td>
<p>array to write predictions for the training split into, intially empty</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>regr</code></td>
<td>
<p>An M x N matrix of sums of the absolute errors for each element of the test set for each feasible regression. M is maximum feasible number of variables included in a regression, N is the maximum feasible number of regressions of the fixed size; the row index indicates the number of variables included in a regression. Therefore each row corresponds to results obtained from running regressions with the same number of variables and columns correspond to different subsets of predictors used.</p>
</td></tr>
<tr><td><code>regrr</code></td>
<td>
<p>An M x N matrix of sums of the relative errors for each element of the test set (only for <code>mode = 'linear'</code>) for each feasible regression. M is maximum feasible number of variables included in a regression, N is the maximum feasible number of regressions of the fixed size; the row index indicates the number of variables included in a regression. Therefore each row corresponds to results obtained from running regressions with the same number of variables and columns correspond to different subsets of predictors used.</p>
</td></tr>
<tr><td><code>nvar</code></td>
<td>
<p>Maximum feasible number of variables in the regression</p>
</td></tr>
<tr><td><code>emp</code></td>
<td>
<p>An accuracy of always predicting the more likely outcome as suggested by the training set (only for <code>mode = 'binary'</code> and <code>objfun = 'acc'</code>)</p>
</td></tr>
</table>
<p>In <code>regr</code> and <code>regrr</code> <code>NA</code> values are possible since for some numbers of variables there are fewer feasible regressions than for the others.
</p>


<h3>See Also</h3>

<p>Uses <code><a href="#topic+compute_max_weight">compute_max_weight</a></code>, <code><a href="#topic+sum_weights_sub">sum_weights_sub</a></code>, <code><a href="#topic+make_numeric_sets">make_numeric_sets</a></code>, <code><a href="#topic+get_predictions_lin">get_predictions_lin</a></code>, <code><a href="#topic+get_predictions">get_predictions</a></code>, <code><a href="#topic+get_probabilities">get_probabilities</a></code>, <code><a href="#topic+AUC">AUC</a></code>, <code><a href="utils.html#topic+combn">combn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#creating variables

vari&lt;-matrix(c(1:100,seq(1,300,3)),ncol=2)

#creating outcomes

out&lt;-rbinom(100,1,0.3)

#creating array for predictions

pr&lt;-array(NA,c(2,2))

pr_tr&lt;-array(NA,c(2,2))

#passing set of the inexes of the predictors

c&lt;-c(1:2)

#passing the weights of the predictors

we&lt;-c(1,1)

#setting the mode

m&lt;-'binary'

#running the function

cross_val(vari,out,c,10,10,100,we,2,pr,m,'det','exact',0.5,'acc',nr=c(1,4),n_tr=90,preds_tr=pr_tr)
</code></pre>

<hr>
<h2 id='cub'>Three-way interactions and squares</h2><span id='topic+cub'></span>

<h3>Description</h3>

<p>Function transforms a set of predictors into a set of predictors, their squares, pairwise interactions, cubes and three-way interactions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cub(A, n = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cub_+3A_a">A</code></td>
<td>
<p>set of predictors</p>
</td></tr>
<tr><td><code id="cub_+3A_n">n</code></td>
<td>
<p>first <code>n</code> predictors, whose interactions with the rest should be taken into account, defaults to all of the predictors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the predictors including their squares, pairwise interactions, cubes and three-way interactions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cub(cbind(1:100,rnorm(100),runif(100),rnorm(100,0,2)))


</code></pre>

<hr>
<h2 id='find_int'>Finding the interacting terms based on the index</h2><span id='topic+find_int'></span>

<h3>Description</h3>

<p>Function transforms an index of an array of two- or three-way interactions into two or three indices corresponding to the interacting variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_int(ind,N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_int_+3A_ind">ind</code></td>
<td>
<p>index to transform</p>
</td></tr>
<tr><td><code id="find_int_+3A_n">N</code></td>
<td>
<p>number of interacting variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns two or three indices corredsponding to a combination of variables written under the given index
</p>


<h3>Examples</h3>

<pre><code class='language-R'>find_int(28,9)
</code></pre>

<hr>
<h2 id='find_sub'>Finds certain subsets of predictors</h2><span id='topic+find_sub'></span>

<h3>Description</h3>

<p>Reorders the columns of matrix <code>a</code> according to the ordered elements of array <code>s</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_sub(a,s,j,c,st)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_sub_+3A_a">a</code></td>
<td>
<p>A <code>j</code> x N matrix, containing all possible subsets (N overall) of the size <code>j</code> of predictors' indices.</p>
</td></tr>
<tr><td><code id="find_sub_+3A_s">s</code></td>
<td>
<p>array of numbers of the size N</p>
</td></tr>
<tr><td><code id="find_sub_+3A_j">j</code></td>
<td>
<p>number of rows in <code>a</code></p>
</td></tr>
<tr><td><code id="find_sub_+3A_c">c</code></td>
<td>
<p>array of all indices of the predictors</p>
</td></tr>
<tr><td><code id="find_sub_+3A_st">st</code></td>
<td>
<p>a subset of predictors to be always included into a predictive model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a submatrix of matrix <code>a</code> which consits of columns determined by the input array <code>s</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#all two-element subsets of 1:3

a&lt;-combn(3,2)
s&lt;-c(3,2,3)

find_sub(a,s,2,1:3)
</code></pre>

<hr>
<h2 id='get_indices'>Best regression</h2><span id='topic+get_indices'></span>

<h3>Description</h3>

<p>Function which identifies regressions with the highest predictive power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_indices(predsp,nvar,c,we,st,minx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_indices_+3A_predsp">predsp</code></td>
<td>
<p>An M x N matrix of averaged out predictive power values. M is maximum feasible number of variables included in a regression, N is the maximum feasible number of regressions of the fixed size; the row index indicates the number of variables included in a regression.</p>
</td></tr>
<tr><td><code id="get_indices_+3A_nvar">nvar</code></td>
<td>
<p>array of maximal number of variables for each cross-validation</p>
</td></tr>
<tr><td><code id="get_indices_+3A_c">c</code></td>
<td>
<p>array of all indices of the prediction variables</p>
</td></tr>
<tr><td><code id="get_indices_+3A_we">we</code></td>
<td>
<p>array of all weights of the prediction variables</p>
</td></tr>
<tr><td><code id="get_indices_+3A_st">st</code></td>
<td>
<p>a subset of predictors to be always included into a predictive model</p>
</td></tr>
<tr><td><code id="get_indices_+3A_minx">minx</code></td>
<td>
<p>minimum number of predictors, defaults to 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of arrays which contain indices of the predictors corresponfing to the best regressions
</p>


<h3>See Also</h3>

<p>Uses <code><a href="#topic+sum_weights_sub">sum_weights_sub</a></code>, <code><a href="#topic+find_sub">find_sub</a></code>, <code><a href="utils.html#topic+combn">combn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#creating a set of averaged out predictive powers

predsp&lt;-matrix(NA,ncol=3,nrow=3)

predsp[1,]=runif(3,0.7,0.8)
predsp[2,]=runif(3,0.65,0.85)
predsp[3,1]=runif(1,0.4,0.5)

#running the function

get_indices(predsp,c(3,3,3),1:3,c(1,1,1))
</code></pre>

<hr>
<h2 id='get_predictions'>Predictions for multinomial regression</h2><span id='topic+get_predictions'></span>

<h3>Description</h3>

<p>Function which makes a prediction for multinomial/logistic regression based on the given cut-off value and probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_predictions(p,k,cutoff,cmode,mode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_predictions_+3A_p">p</code></td>
<td>
<p>probabilities of the outcomes for the test set given either by an array (logistic regression) or by a matrix (multinomial regression)</p>
</td></tr>
<tr><td><code id="get_predictions_+3A_k">k</code></td>
<td>
<p>size of the test set</p>
</td></tr>
<tr><td><code id="get_predictions_+3A_cutoff">cutoff</code></td>
<td>
<p>cut-off value of the probability</p>
</td></tr>
<tr><td><code id="get_predictions_+3A_cmode">cmode</code></td>
<td>
<p><code>'det'</code> or <code>''</code>; <code>'det'</code> always predicts the more likely outcome as determined by the odds ratio; <code>''</code> predicts certain outcome with probability corresponding to its odds ratio (more conservative). Option available for multinomial/logistic regression</p>
</td></tr>
<tr><td><code id="get_predictions_+3A_mode">mode</code></td>
<td>
<p><code>'binary'</code> (logistic regression), <code>'multin'</code> (multinomial regression)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs the array of the predictions of the size of <code>p</code>.
</p>


<h3>See Also</h3>

<p>Uses <code><a href="stats.html#topic+rbinom">rbinom</a></code>, <code><a href="stats.html#topic+rmultinom">rmultinom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#binary mode

get_predictions(runif(20,0.4,0.6),20,0.5,'det','binary')

#creating a data-set for multinomial mode

p1&lt;-runif(20,0.4,0.6)
p2&lt;-runif(20,0.1,0.2)
p3&lt;-1-p1-p2

#running the function

get_predictions(matrix(c(p1,p2,p3),ncol=3),20,0.5,'det','multin')
</code></pre>

<hr>
<h2 id='get_predictions_lin'>Predictions for linear regression</h2><span id='topic+get_predictions_lin'></span>

<h3>Description</h3>

<p>Function which runs a linear regression on a training set, computes predictions for the test set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_predictions_lin(trset,testset,outc,k,n_tr,p,Rsq,Rsq_v,marg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_predictions_lin_+3A_trset">trset</code></td>
<td>
<p>values of predictors on the training set</p>
</td></tr>
<tr><td><code id="get_predictions_lin_+3A_testset">testset</code></td>
<td>
<p>values of predictors on the test set</p>
</td></tr>
<tr><td><code id="get_predictions_lin_+3A_outc">outc</code></td>
<td>
<p>values of predictors on the training set</p>
</td></tr>
<tr><td><code id="get_predictions_lin_+3A_k">k</code></td>
<td>
<p>length of the test set</p>
</td></tr>
<tr><td><code id="get_predictions_lin_+3A_n_tr">n_tr</code></td>
<td>
<p>size of the training set</p>
</td></tr>
<tr><td><code id="get_predictions_lin_+3A_p">p</code></td>
<td>
<p>weight of the model</p>
</td></tr>
<tr><td><code id="get_predictions_lin_+3A_rsq">Rsq</code></td>
<td>
<p>whether the R-squared statistics constraint is introduced</p>
</td></tr>
<tr><td><code id="get_predictions_lin_+3A_rsq_v">Rsq_v</code></td>
<td>
<p>value of R-squared statistics on the training spli of the data</p>
</td></tr>
<tr><td><code id="get_predictions_lin_+3A_marg">marg</code></td>
<td>
<p>margin of error for R-squared statistics constraint</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of continous variables of the length equal to the size of a <code>testset</code>
</p>


<h3>See Also</h3>

<p>Function uses function <code><a href="stats.html#topic+lsfit">lsfit</a></code> and <code><a href="stats.html#topic+coef">coef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trset&lt;-matrix(c(rnorm(90,2,4),runif(90,0,0.5),rbinom(90,1,0.5)),ncol=3)

testset&lt;-matrix(c(rnorm(10,2,4),runif(10,0,0.5),rbinom(10,1,0.5)),ncol=3)

get_predictions_lin(trset,testset,runif(90,0,1),10)
</code></pre>

<hr>
<h2 id='get_probabilities'>Probabilities for multinomial regression</h2><span id='topic+get_probabilities'></span>

<h3>Description</h3>

<p>Function which computes probabilities of outcomes on the test set by applying regression parameters inferred by a run on the training set. Works for logistic or multinomial regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_probabilities(trset,testset,outc,mode,Rsq,p,n_tr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_probabilities_+3A_trset">trset</code></td>
<td>
<p>values of predictors on the training set</p>
</td></tr>
<tr><td><code id="get_probabilities_+3A_testset">testset</code></td>
<td>
<p>values of predictors on the test set</p>
</td></tr>
<tr><td><code id="get_probabilities_+3A_outc">outc</code></td>
<td>
<p>values of outcomes on the training set</p>
</td></tr>
<tr><td><code id="get_probabilities_+3A_mode">mode</code></td>
<td>
<p><code>'binary'</code> (logistic regression) or <code>'multin'</code> (multinomial regression)</p>
</td></tr>
<tr><td><code id="get_probabilities_+3A_rsq">Rsq</code></td>
<td>
<p>whether R-squared statistics constrained is introduced</p>
</td></tr>
<tr><td><code id="get_probabilities_+3A_p">p</code></td>
<td>
<p>weight of the model</p>
</td></tr>
<tr><td><code id="get_probabilities_+3A_n_tr">n_tr</code></td>
<td>
<p>size of the training set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In binary mode this function computes the probabilities of the event '0'. In multinomial mode computes the probabilities of the events '0','1',...,'N-1'.
</p>


<h3>Value</h3>

<p>Probabilities of the outcomes. In <code>'binary'</code> mode returns an array of the size of the number of observations in a testset. In <code>'multin'</code> returns an M x N matrix where M is the size of the number of observations in a testset
and N is the number of unique outcomes minus 1.
</p>


<h3>See Also</h3>

<p>Function uses <code><a href="nnet.html#topic+multinom">multinom</a></code>  and <code><a href="stats.html#topic+coef">coef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trset&lt;-matrix(c(rbinom(70,1,0.5),runif(70,0.1)),ncol=2)

testset&lt;-matrix(c(rbinom(10,1,0.5),runif(10,0.1)),ncol=2)

get_probabilities(trset,testset,rbinom(70,1,0.6),'binary')
</code></pre>

<hr>
<h2 id='make_numeric'>Turning a non-numeric variable into a numeric one</h2><span id='topic+make_numeric'></span>

<h3>Description</h3>

<p>Function which turns a single categorical (non-numeric) variable into a numeric one (or several) by introducing dummy '0'/'1' variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_numeric(vari, outcome, ra,mode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_numeric_+3A_vari">vari</code></td>
<td>
<p>array of values to be transformed</p>
</td></tr>
<tr><td><code id="make_numeric_+3A_outcome">outcome</code></td>
<td>
<p>TRUE/FALSE indicates whether the variable <code>vari</code> is an outcome (TRUE) or a predictor (FALSE)</p>
</td></tr>
<tr><td><code id="make_numeric_+3A_ra">ra</code></td>
<td>
<p>indices of the input array <code>vari</code> which indicate which values will be transformed</p>
</td></tr>
<tr><td><code id="make_numeric_+3A_mode">mode</code></td>
<td>
<p><code>'binary'</code> (logistic regression), <code>'multin'</code> (multinomial regression)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is essentially a standard way to turn categorical non-numeric variables into numeric ones in order to run a regression
</p>


<h3>Value</h3>

<p>Returned value is an M x N matrix where M is the length of the input array of indices <code>ra</code> and N is <code>length(vari)-1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#creating a non-numeric set

a&lt;-t(rmultinom(100,1,c(0.2,0.3,0.5)))%*%c(1,2,3)

a[a==1]='red'
a[a==2]='green'
a[a==3]='blue'

#running the function

make_numeric(a,FALSE,sample(1:100,50),"linear")

make_numeric(a,TRUE,sample(1:100,50))
</code></pre>

<hr>
<h2 id='make_numeric_sets'>Transforming the set of predictors into a numeric set</h2><span id='topic+make_numeric_sets'></span>

<h3>Description</h3>

<p>Function which turns a set of predictors containing non-numeric variables into a fully numeric set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_numeric_sets(a,ai,k,vari,ra,l,mode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_numeric_sets_+3A_a">a</code></td>
<td>
<p>An M x N matrix, containing all possible subsets (N overall) of the size M of predictors' indices; therefore each column of <code>a</code> defines a unique subset of the predictors</p>
</td></tr>
<tr><td><code id="make_numeric_sets_+3A_ai">ai</code></td>
<td>
<p>array of indices of the array <code>a</code></p>
</td></tr>
<tr><td><code id="make_numeric_sets_+3A_k">k</code></td>
<td>
<p>index of the array <code>ai</code></p>
</td></tr>
<tr><td><code id="make_numeric_sets_+3A_vari">vari</code></td>
<td>
<p>set of all predictors</p>
</td></tr>
<tr><td><code id="make_numeric_sets_+3A_ra">ra</code></td>
<td>
<p>array of sample indices of <code>vari</code></p>
</td></tr>
<tr><td><code id="make_numeric_sets_+3A_l">l</code></td>
<td>
<p>size of the sample</p>
</td></tr>
<tr><td><code id="make_numeric_sets_+3A_mode">mode</code></td>
<td>
<p><code>'binary'</code> (logistic regression), <code>'multin'</code> (multinomial regression)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function transforms the whole set of predictors into a numeric set by consecutively calling function <code>make_numeric</code> for each predictor
</p>


<h3>Value</h3>

<p>Returns a list containing two objects: <code>tr</code> and <code>test</code><br />
</p>
<table>
<tr><td><code>tr</code></td>
<td>
<p>training set transformed into a numeric one</p>
</td></tr>
<tr><td><code>test</code></td>
<td>
<p>test set transformed into a numeric one</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+make_numeric">make_numeric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#creating a categorical numeric variable

a&lt;-t(rmultinom(100,1,c(0.2,0.3,0.5)))%*%c(1,2,3)

#creating an analogous non-numeric variable

c&lt;-array(NA,100)
c[a==1]='red'
c[a==2]='green'
c[a==3]='blue'

#creating a data-set

b&lt;-data.frame(matrix(c(a,rbinom(100,1,0.3),runif(100,0,1)),ncol=3))

#making the first column of the data-set non-numeric

b[,1]=data.frame(c)

#running the function

make_numeric_sets(combn(3,2),1:3,1,b,sample(1:100,60),100,"binary")
</code></pre>

<hr>
<h2 id='quadr'>Pairwise interactions and squares</h2><span id='topic+quadr'></span>

<h3>Description</h3>

<p>Function transforms a set of predictors into a set of predictors, their squares and pairwise interactions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadr(A, n = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadr_+3A_a">A</code></td>
<td>
<p>set of predictors</p>
</td></tr>
<tr><td><code id="quadr_+3A_n">n</code></td>
<td>
<p>first <code>n</code> predictors, whose interactions with the rest should be taken into account, defaults to all of the predictors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the predictors including their squares and pairwise interactions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>quadr(cbind(1:100,rnorm(100),runif(100),rnorm(100,0,2)))
</code></pre>

<hr>
<h2 id='regr_ind'>Indices of the best regressions</h2><span id='topic+regr_ind'></span>

<h3>Description</h3>

<p>One of the two main functions of the package. Identifies the predictors included into regressions with the highest average predictive power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regr_ind(
  vari,
  outi,
  crv,
  cutoff = NULL,
  part = 10,
  mode,
  cmode = "det",
  predm = "exact",
  objfun = "acc",
  parallel = FALSE,
  cores,
  minx = 1,
  maxx = NULL,
  nr = NULL,
  maxw = NULL,
  st = NULL,
  rule = 10,
  corr = 1,
  Rsq = F,
  marg = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regr_ind_+3A_vari">vari</code></td>
<td>
<p>set of predictors</p>
</td></tr>
<tr><td><code id="regr_ind_+3A_outi">outi</code></td>
<td>
<p>array of outcomes</p>
</td></tr>
<tr><td><code id="regr_ind_+3A_crv">crv</code></td>
<td>
<p>number of cross-validations</p>
</td></tr>
<tr><td><code id="regr_ind_+3A_cutoff">cutoff</code></td>
<td>
<p>cut-off value for mode <code>'binary'</code></p>
</td></tr>
<tr><td><code id="regr_ind_+3A_part">part</code></td>
<td>
<p>for each cross-validation partitions the dataset into training and test set in a proportion <code>(part-1):part</code></p>
</td></tr>
<tr><td><code id="regr_ind_+3A_mode">mode</code></td>
<td>
<p><code>'binary'</code> (logistic regression), <code>'multin'</code> (multinomial regression)</p>
</td></tr>
<tr><td><code id="regr_ind_+3A_cmode">cmode</code></td>
<td>
<p><code>'det'</code> or <code>''</code>; <code>'det'</code> always predicts the more likely outcome as determined by the odds ratio; <code>''</code> predicts certain outcome with probability corresponding to its odds ratio (more conservative). Option available for multinomial/logistic regression</p>
</td></tr>
<tr><td><code id="regr_ind_+3A_predm">predm</code></td>
<td>
<p><code>'exact'</code> or <code>''</code>; for logistic and multinomial regression; <code>'exact'</code> computes how many times the exact outcome category was predicted, <code>''</code> computes how many times either the exact outcome category or its nearest neighbour was predicted</p>
</td></tr>
<tr><td><code id="regr_ind_+3A_objfun">objfun</code></td>
<td>
<p><code>'roc'</code> for maximising the predictive power with respect to AUC, available only for <code>mode='binary'</code>; <code>'acc'</code> for maximising predictive power with respect to accuracy.</p>
</td></tr>
<tr><td><code id="regr_ind_+3A_parallel">parallel</code></td>
<td>
<p>TRUE if using parallel toolbox, FALSE if not. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="regr_ind_+3A_cores">cores</code></td>
<td>
<p>number of cores to use in case of parallel=TRUE</p>
</td></tr>
<tr><td><code id="regr_ind_+3A_minx">minx</code></td>
<td>
<p>minimum number of predictors to be included in a regression, defaults to 1</p>
</td></tr>
<tr><td><code id="regr_ind_+3A_maxx">maxx</code></td>
<td>
<p>maximum number of predictors to be included in a regression, defaults to maximum feasible number according to one in ten rule</p>
</td></tr>
<tr><td><code id="regr_ind_+3A_nr">nr</code></td>
<td>
<p>a subset of the data-set, such that <code>1/part</code> of it lies in the test set and <code>1-1/part</code> is in the training set, defaults to empty set. This is to ensure that elements of this subset are included both in the training and in the test set.</p>
</td></tr>
<tr><td><code id="regr_ind_+3A_maxw">maxw</code></td>
<td>
<p>maximum weight of predictors to be included in a regression, defaults to maximum weight according to one in ten rule</p>
</td></tr>
<tr><td><code id="regr_ind_+3A_st">st</code></td>
<td>
<p>a subset of predictors to be always included into a predictive model,defaults to empty set</p>
</td></tr>
<tr><td><code id="regr_ind_+3A_rule">rule</code></td>
<td>
<p>an Events per Variable (EPV) rule, defaults to 10'</p>
</td></tr>
<tr><td><code id="regr_ind_+3A_corr">corr</code></td>
<td>
<p>maximum correlation between a pair of predictors in a model</p>
</td></tr>
<tr><td><code id="regr_ind_+3A_rsq">Rsq</code></td>
<td>
<p>whether the R-squared statistics constraint is introduced</p>
</td></tr>
<tr><td><code id="regr_ind_+3A_marg">marg</code></td>
<td>
<p>margin of error for R-squared statistics constraint</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints the best predictive power provided by a regression, predictive accuracy of the empirical prediction (value of <code>emp</code> computed by <code>cross_val</code> for logistic and linear regression). Returns indices of the predictors included into regressions with the highest predictive power written in a list. For <code>mode='linear'</code> outputs a list of two lists. First list corresponds to the smallest absolute error, second corresponds to the smallest relative error
</p>


<h3>See Also</h3>

<p>Uses <code><a href="#topic+compute_weights">compute_weights</a></code>, <code><a href="#topic+make_numeric">make_numeric</a></code>, <code><a href="#topic+compute_max_weight">compute_max_weight</a></code>, <code><a href="#topic+compute_weights">compute_weights</a></code>, <code><a href="#topic+compute_max_length">compute_max_length</a></code>, <code><a href="#topic+cross_val">cross_val</a></code>,<code><a href="#topic+av_out">av_out</a></code>, <code><a href="#topic+get_indices">get_indices</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#creating variables for linear regression mode

variables_lin&lt;-matrix(c(rnorm(56,0,1),rnorm(56,1,2)),ncol=2)

#creating outcomes for linear regression mode

outcomes_lin&lt;-rnorm(56,2,1)

#running the function

regr_ind(variables_lin,outcomes_lin,100,mode='linear',parallel=TRUE,cores=2)

#creating variables for binary mode

vari&lt;-matrix(c(1:100,seq(1,300,3)),ncol=2)

#creating outcomes for binary mode

out&lt;-rbinom(100,1,0.3)

#running the function

regr_ind(vari,out,20,cutoff=0.5,part=10,mode='binary',parallel=TRUE,cores=2,nr=c(1,10,20),maxx=1)
</code></pre>

<hr>
<h2 id='sum_weights_sub'>Cumulative weights of the predictors' subsets</h2><span id='topic+sum_weights_sub'></span>

<h3>Description</h3>

<p>Function which computes the sum of predictors' weights for each subset containing a fixed number of predictors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_weights_sub(a,m,we,st)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_weights_sub_+3A_a">a</code></td>
<td>
<p>an <code>m</code> x N matrix, containing all possible subsets (N overall) of the size <code>m</code> of predictors' indices; therefore each column of <code>a</code> defines a unique subset of the predictors</p>
</td></tr>
<tr><td><code id="sum_weights_sub_+3A_m">m</code></td>
<td>
<p>number of elements in each subset of indices</p>
</td></tr>
<tr><td><code id="sum_weights_sub_+3A_we">we</code></td>
<td>
<p>array of weights of the predictors</p>
</td></tr>
<tr><td><code id="sum_weights_sub_+3A_st">st</code></td>
<td>
<p>a subset of predictors to be always included into a predictive model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an array of weights for predictors defined by each colun of the matrix <code>a</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#all two-element subsets of the set 1:3

a&lt;-combn(3,2)

sum_weights_sub(a,2,c(1,2,1))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
