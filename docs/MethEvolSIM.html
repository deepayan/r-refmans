<!DOCTYPE html><html><head><title>Help for package MethEvolSIM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MethEvolSIM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#combiStructureGenerator'><p>combiStructureGenerator</p></a></li>
<li><a href='#get_parameterValues'><p>Get Default Parameter Values</p></a></li>
<li><a href='#simulate_evolData'><p>Simulate Data Evolution along a Tree</p></a></li>
<li><a href='#simulate_initialData'><p>Simulate Initial Data</p></a></li>
<li><a href='#singleStructureGenerator'><p>singleStructureGenerator</p></a></li>
<li><a href='#treeMultiRegionSimulator'><p>treeMultiRegionSimulator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Simulate DNA Methylation Dynamics on Different Genomic
Structures along Genealogies</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Sara Castillo Vicente [aut, cre],
  Dirk Metzler [aut, ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sara Castillo Vicente &lt;castillo@bio.lmu.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>DNA methylation is an epigenetic modification involved in genomic stability,
      gene regulation, development and disease.
      DNA methylation occurs mainly through the addition of a methyl group to cytosines, 
      for example to cytosines in a CpG dinucleotide context (CpG stands for a cytosine followed by a guanine).
      Tissue-specific methylation patterns lead to genomic regions with different characteristic
      methylation levels.
      E.g. in vertebrates CpG islands (regions with high CpG content) that are associated to promoter regions of
      expressed genes tend to be unmethylated.
      'MethEvolSIM' is a model-based simulation software for the generation and modification
      of cytosine methylation patterns along a given tree, which can be a genealogy of
      cells within an organism, a coalescent tree of DNA sequences sampled from a population, or a species tree.
      The simulations are based on an extension of the model of
      Grosser &amp; Metzler (2020) &lt;<a href="https://doi.org/10.1186%2Fs12859-020-3438-5">doi:10.1186/s12859-020-3438-5</a>&gt; and allows for changes of
      the methylation states at single cytosine positions as well as simultaneous changes of methylation
      frequencies in genomic structures like CpG islands.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-24 12:04:39 UTC; sara</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-24 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='combiStructureGenerator'>combiStructureGenerator</h2><span id='topic+combiStructureGenerator'></span>

<h3>Description</h3>

<p>an R6 class representing several genomic structures.
Each genomic structure contained is an object of class singleStructureGenerator.
Note that default clone(deep=TRUE) fails to clone singleStructureGenerator objects contained, use method $copy() instead.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-combiStructureGenerator-new"><code>combiStructureGenerator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_singleStr"><code>combiStructureGenerator$get_singleStr()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_singleStr_number"><code>combiStructureGenerator$get_singleStr_number()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_island_number"><code>combiStructureGenerator$get_island_number()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_island_index"><code>combiStructureGenerator$get_island_index()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-set_IWE_events"><code>combiStructureGenerator$set_IWE_events()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_IWE_events"><code>combiStructureGenerator$get_IWE_events()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-set_name"><code>combiStructureGenerator$set_name()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_name"><code>combiStructureGenerator$get_name()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_own_index"><code>combiStructureGenerator$get_own_index()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-set_own_index"><code>combiStructureGenerator$set_own_index()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_parent_index"><code>combiStructureGenerator$get_parent_index()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-set_parent_index"><code>combiStructureGenerator$set_parent_index()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_offspring_index"><code>combiStructureGenerator$get_offspring_index()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-set_offspring_index"><code>combiStructureGenerator$set_offspring_index()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-add_offspring_index"><code>combiStructureGenerator$add_offspring_index()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_mu"><code>combiStructureGenerator$get_mu()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-set_singleStr"><code>combiStructureGenerator$set_singleStr()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-copy"><code>combiStructureGenerator$copy()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-branch_evol"><code>combiStructureGenerator$branch_evol()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-clone"><code>combiStructureGenerator$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-combiStructureGenerator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new combiStructureGenerator object.
</p>
<p>Note that this object can be generated within a treeMultiRegionSimulator object.
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$new(infoStr, params = NULL, testing = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>infoStr</code></dt><dd><p>A data frame containing columns 'n' for the number of sites, and 'globalState' for the favoured global methylation state.
If initial equilibrium frequencies are given the dataframe must contain 3 additional columns: 'u_eqFreq', 'p_eqFreq' and 'm_eqFreq'</p>
</dd>
<dt><code>params</code></dt><dd><p>Default NULL. When given: data frame containing model parameters.</p>
</dd>
<dt><code>testing</code></dt><dd><p>Default FALSE. TRUE for testing output.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>combiStructureGenerator</code> object.
</p>


<hr>
<a id="method-combiStructureGenerator-get_singleStr"></a>



<h4>Method <code>get_singleStr()</code></h4>

<p>Public method: Get one singleStructureGenerator object in $singleStr
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_singleStr(i)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>index of the singleStructureGenerator object in $singleStr</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the singleStructureGenerator object in $singleStr with index i
</p>


<hr>
<a id="method-combiStructureGenerator-get_singleStr_number"></a>



<h4>Method <code>get_singleStr_number()</code></h4>

<p>Public method: Get number of singleStructureGenerator objects in $singleStr
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_singleStr_number()</pre></div>



<h5>Returns</h5>

<p>number of singleStructureGenerator object contained in $singleStr
</p>


<hr>
<a id="method-combiStructureGenerator-get_island_number"></a>



<h4>Method <code>get_island_number()</code></h4>

<p>Public method: Get number of singleStructureGenerator objects in $singleStr with $globalState &quot;U&quot; (CpG islands)
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_island_number()</pre></div>



<h5>Returns</h5>

<p>number of singleStructureGenerator in $singleStr objects with $globalState &quot;U&quot; (CpG islands)
</p>


<hr>
<a id="method-combiStructureGenerator-get_island_index"></a>



<h4>Method <code>get_island_index()</code></h4>

<p>Public method: Get index of singleStructureGenerator objects in $singleStr with $globalState &quot;U&quot; (CpG islands)
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_island_index()</pre></div>



<h5>Returns</h5>

<p>index of singleStructureGenerator objects in $singleStr with $globalState &quot;U&quot; (CpG islands)
</p>


<hr>
<a id="method-combiStructureGenerator-set_IWE_events"></a>



<h4>Method <code>set_IWE_events()</code></h4>

<p>Public method: Set information of the IWE events sampled in a tree branch
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$set_IWE_events(a)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p>value to which IWE_events should be set</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-combiStructureGenerator-get_IWE_events"></a>



<h4>Method <code>get_IWE_events()</code></h4>

<p>Public method: Get information of the IWE events sampled in a tree branch
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_IWE_events()</pre></div>



<h5>Returns</h5>

<p>information of the IWE events sampled in a tree branch
</p>


<hr>
<a id="method-combiStructureGenerator-set_name"></a>



<h4>Method <code>set_name()</code></h4>

<p>Public method: Set the name of the leaf if evolutionary process
(simulated from class treeMultiRegionSimulator) ends in a tree leaf.
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$set_name(a)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p>value to which name should be set</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-combiStructureGenerator-get_name"></a>



<h4>Method <code>get_name()</code></h4>

<p>Public method: Get the name of the leaf if evolutionary process
(simulated from class treeMultiRegionSimulator) ended in a tree leaf.
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_name()</pre></div>



<h5>Returns</h5>

<p>Name of the leaf if evolutionary process
(simulated from class treeMultiRegionSimulator) ended in a tree leaf.
For iner tree nodes return NULL
</p>


<hr>
<a id="method-combiStructureGenerator-get_own_index"></a>



<h4>Method <code>get_own_index()</code></h4>

<p>Public method: Set own branch index in the tree
along which the evolutionary process is simulated
(from class treeMultiRegionSimulator).
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_own_index()</pre></div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-combiStructureGenerator-set_own_index"></a>



<h4>Method <code>set_own_index()</code></h4>

<p>Public method: Get own branch index in the tree
along which the evolutionary process is simulated
(from class treeMultiRegionSimulator).
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$set_own_index(i)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>index of focal object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Own branch index in the tree
along which the evolutionary process is simulated
(from class treeMultiRegionSimulator).
</p>


<hr>
<a id="method-combiStructureGenerator-get_parent_index"></a>



<h4>Method <code>get_parent_index()</code></h4>

<p>Public method: Get parent branch index in the tree
along which the evolutionary process is simulated
(from class treeMultiRegionSimulator).
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_parent_index()</pre></div>



<h5>Returns</h5>

<p>Parent branch index in the tree
along which the evolutionary process is simulated
(from class treeMultiRegionSimulator).
</p>


<hr>
<a id="method-combiStructureGenerator-set_parent_index"></a>



<h4>Method <code>set_parent_index()</code></h4>

<p>Public method: Set parent branch index in the tree
along which the evolutionary process is simulated
(from class treeMultiRegionSimulator).
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$set_parent_index(i)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>set parent_index to this value</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-combiStructureGenerator-get_offspring_index"></a>



<h4>Method <code>get_offspring_index()</code></h4>

<p>Public method: Get offspring branch index in the tree
along which the evolutionary process is simulated
(from class treeMultiRegionSimulator).
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_offspring_index()</pre></div>



<h5>Returns</h5>

<p>Offspring branch index in the tree
along which the evolutionary process is simulated
(from class treeMultiRegionSimulator).
</p>


<hr>
<a id="method-combiStructureGenerator-set_offspring_index"></a>



<h4>Method <code>set_offspring_index()</code></h4>

<p>Public method: Set offspring branch index in the tree
along which the evolutionary process is simulated
(from class treeMultiRegionSimulator).
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$set_offspring_index(i)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>set offspring_index to this value</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-combiStructureGenerator-add_offspring_index"></a>



<h4>Method <code>add_offspring_index()</code></h4>

<p>Public method: Add offspring branch index in the tree
along which the evolutionary process is simulated
(from class treeMultiRegionSimulator).
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$add_offspring_index(i)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>index to be added</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-combiStructureGenerator-get_mu"></a>



<h4>Method <code>get_mu()</code></h4>

<p>Public method.
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_mu()</pre></div>



<h5>Returns</h5>

<p>Model parameter for the rate of the IWE evolutionary process (per island and branch length).
</p>


<hr>
<a id="method-combiStructureGenerator-set_singleStr"></a>



<h4>Method <code>set_singleStr()</code></h4>

<p>Public method: Clone each singleStructureGenerator object in $singleStr
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$set_singleStr(singStrList)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>singStrList</code></dt><dd><p>object to be cloned</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-combiStructureGenerator-copy"></a>



<h4>Method <code>copy()</code></h4>

<p>Public method: Clone combiStructureGenerator object and all singleStructureGenerator objects in it
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$copy()</pre></div>



<h5>Returns</h5>

<p>cloned combiStructureGenerator object
</p>


<hr>
<a id="method-combiStructureGenerator-branch_evol"></a>



<h4>Method <code>branch_evol()</code></h4>

<p>Simulate CpG dinucleotide methylation state evolution along a tree branch.
The function samples the IWE events on the tree branch and simulates the
evolution through the SSE and IWE processes.
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$branch_evol(branch_length, dt, testing = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>branch_length</code></dt><dd><p>Length of the branch.</p>
</dd>
<dt><code>dt</code></dt><dd><p>Length of SSE time steps.</p>
</dd>
<dt><code>testing</code></dt><dd><p>Default FALSE. TRUE for testing purposes.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>It handles both cases where IWE events are sampled or not sampled within the branch.
</p>



<h5>Returns</h5>

<p>Default NULL. If testing = TRUE it returns information for testing purposes.
</p>


<hr>
<a id="method-combiStructureGenerator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='get_parameterValues'>Get Default Parameter Values</h2><span id='topic+get_parameterValues'></span>

<h3>Description</h3>

<p>This function retrieves parameter values for the DNA methylation simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_parameterValues(rootData = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parameterValues_+3A_rootdata">rootData</code></td>
<td>
<p>NULL to return default parameter values. For data parameter values, provide rootData as the output of simulate_initialData()$data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function called without arguments returns default parameter values.
When rootData (as $data output of simulate_initialData()) is given, it returns data parameter values.
</p>


<h3>Value</h3>

<p>A data frame containing default parameter values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get default parameter values
default_values &lt;- get_parameterValues()

# Get parameter values of simulate_initialData() output
custom_params &lt;- get_parameterValues()
infoStr &lt;- data.frame(n = c(5, 10), globalState = c("M", "U"))
rootData &lt;- simulate_initialData(infoStr = infoStr, params = custom_params)$data
rootData_paramValues &lt;- get_parameterValues(rootData = rootData)

</code></pre>

<hr>
<h2 id='simulate_evolData'>Simulate Data Evolution along a Tree</h2><span id='topic+simulate_evolData'></span>

<h3>Description</h3>

<p>This function simulates methylation data evolution along a tree. Either by simulating data at the root of the provided evolutionary tree
(if infoStr is given) or by using pre-existing data at the root (if rootData is given) and letting it evolve along the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_evolData(
  infoStr = NULL,
  rootData = NULL,
  tree,
  params = NULL,
  dt = 0.01,
  n_rep = 1,
  only_tip = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_evolData_+3A_infostr">infoStr</code></td>
<td>
<p>A data frame containing columns 'n' for the number of sites, and 'globalState' for the favoured global methylation state.
If customized initial equilibrium frequencies are given, it also contains columns 'u_eqFreq', 'p_eqFreq', and 'm_eqFreq'
with the equilibrium frequency values for unmethylated, partially methylated, and methylated.</p>
</td></tr>
<tr><td><code id="simulate_evolData_+3A_rootdata">rootData</code></td>
<td>
<p>The output of the simulate_initialData()$data function. It represents the initial data at the root of the evolutionary tree.</p>
</td></tr>
<tr><td><code id="simulate_evolData_+3A_tree">tree</code></td>
<td>
<p>A string in Newick format representing the evolutionary tree.</p>
</td></tr>
<tr><td><code id="simulate_evolData_+3A_params">params</code></td>
<td>
<p>Optional data frame with specific parameter values.
Structure as in get_parameterValues() output. If not provided, default values will be used.</p>
</td></tr>
<tr><td><code id="simulate_evolData_+3A_dt">dt</code></td>
<td>
<p>Length of time step for Gillespie's Tau-Leap Approximation (default is 0.01).</p>
</td></tr>
<tr><td><code id="simulate_evolData_+3A_n_rep">n_rep</code></td>
<td>
<p>Number of replicates to simulate (default is 1).</p>
</td></tr>
<tr><td><code id="simulate_evolData_+3A_only_tip">only_tip</code></td>
<td>
<p>Logical indicating whether to extract data only for tips (default is TRUE, FALSE to extract the information for all the tree branches).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the parameters used (<code>$params</code>), the length of the time step used for the Gillespie's tau-leap approximation (<code>$dt</code>, default 0.01), the tree used (<code>$tree</code>).
simulated data and the simulated data (<code>$data</code>). In <code>$data</code>, each list element corresponds to a simulation replicate.
</p>

<ul>
<li><p> If only_tip is TRUE: In <code>$data</code>, each list element corresponds to a simulation replicate.
Each replicate includes one list per tree tip, each containing:
</p>

<ul>
<li><p> The name of each tip in the simulated tree (e.g. replicate 2, tip 1: <code>$data[[2]][[1]]$name</code>).
</p>
</li>
<li><p> A list with the sequence of methylation states for each tip-specific structure (e.g. replicate 1, tip 2, 3rd structure: <code>$data[[1]][[2]]$seq[[3]]</code>.
The methylation states are encoded as 0 for unmethylated, 0.5 for partially methylated, and 1 for methylated.
</p>
</li></ul>

</li>
<li><p> If only_tip is FALSE, <code>$data</code> contains 2 lists:
</p>

<ul>
<li> <p><code>$data$branchInTree</code>: a list in which each element contains the information of the relationship with other branches:
</p>

<ul>
<li><p> Index of the parent branch (e.g. branch 2): <code>$data$branchInTree[[2]]$parent_index</code>)
</p>
</li>
<li><p> Index(es) of the offspring branch(es) (e.g. branch 1 (root)): <code>$data$branchInTree[[1]]$offspring_index</code>)
</p>
</li></ul>

</li>
<li> <p><code>$data$sim_data</code>: A list containing simulated data. Each list element corresponds to a simulation replicate.
Each replicate includes one list per tree branch, each containing:
</p>

<ul>
<li><p> The name of each branch in the simulated tree. It's NULL for the tree root and inner nodes, and the name of the tips for the tree tips.
(e.g. replicate 2, branch 1: <code>$data$sim_data[[2]][[1]]$name</code>)
</p>
</li>
<li><p> Information of IWE events on that branch. It's NULL for the tree root and FALSE for the branches in which no IWE event was sampled,
and a list containing <code>$islands</code> with the index(ces) of the island structure(s) that went through the IWE event and <code>$times</code>
for the branch time point(s ) in which the IWE was sampled.
(e.g. replicate 1, branch 3: <code>$data$sim_data[[1]][[3]]$IWE</code>)
</p>
</li>
<li><p> A list with the sequence of methylation states for each structure (the index of the list corresponds to the index
of the structures). The methylation states are encoded as 0 for unmethylated, 0.5 for partially methylated, and 1 for methylated.
(e.g. replicate 3, branch 2, structure 1: <code>$data$sim_data[[3]][[2]]$seq[[1]]</code>)
</p>
</li>
<li><p> A list with the methylation equilibrium frequencies for each structure (the index of the list corresponds to the index
of the structures). Each structure has a vector with 3 values, the first one corresponding to the frequency of unmethylated,
the second one to the frequency of partially methylated, and the third one to the frequency of methylated CpGs.
(e.g. replicate 3, branch 2, structure 1: <code>$data$sim_data[[3]][[2]]$eqFreqs[[1]]</code>)
</p>
</li></ul>

</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example data
infoStr &lt;- data.frame(n = c(10, 100, 10), globalState = c("M", "U", "M"))

# Simulate data evolution along a tree with default parameters
simulate_evolData(infoStr = infoStr, tree = "(A:0.1,B:0.1);")

# Simulate data evolution along a tree with custom parameters
custom_params &lt;- get_parameterValues()
custom_params$iota &lt;- 0.5
simulate_evolData(infoStr = infoStr, tree = "(A:0.1,B:0.1);", params = custom_params)

</code></pre>

<hr>
<h2 id='simulate_initialData'>Simulate Initial Data</h2><span id='topic+simulate_initialData'></span>

<h3>Description</h3>

<p>This function simulates initial data based on the provided information and parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_initialData(infoStr, params = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_initialData_+3A_infostr">infoStr</code></td>
<td>
<p>A data frame containing columns 'n' for the number of sites, and 'globalState' for the favoured global methylation state.
If customized equilibrium frequencies are given, it also contains columns 'u_eqFreq', 'p_eqFreq' and 'm_eqFreq'
with the equilibrium frequency values for unmethylated, partially methylated and methylated.</p>
</td></tr>
<tr><td><code id="simulate_initialData_+3A_params">params</code></td>
<td>
<p>Optional data frame with specific parameter values.
Structure as in get_parameterValues() output. If not provided, default values will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs several checks on the input data and parameters
to ensure they meet the required criteria and simulates DNA methylation data.
</p>


<h3>Value</h3>

<p>A list containing the simulated data ($data) and parameters ($params).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data
infoStr &lt;- data.frame(n = c(10, 100, 10), globalState = c("M", "U", "M"))

# Simulate initial data  with default parameters
simulate_initialData(infoStr = infoStr)

# Simulate data evolution along a tree with custom parameters
custom_params &lt;- get_parameterValues()
custom_params$iota &lt;- 0.5
simulate_initialData(infoStr = infoStr, params = custom_params)

</code></pre>

<hr>
<h2 id='singleStructureGenerator'>singleStructureGenerator</h2><span id='topic+singleStructureGenerator'></span>

<h3>Description</h3>

<p>an R6 class representing a single genomic structure
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-singleStructureGenerator-init_neighbSt"><code>singleStructureGenerator$init_neighbSt()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-initialize_ratetree"><code>singleStructureGenerator$initialize_ratetree()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-new"><code>singleStructureGenerator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_seq"><code>singleStructureGenerator$get_seq()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_seqFirstPos"><code>singleStructureGenerator$get_seqFirstPos()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_seq2ndPos"><code>singleStructureGenerator$get_seq2ndPos()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_seqLastPos"><code>singleStructureGenerator$get_seqLastPos()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_seq2ndButLastPos"><code>singleStructureGenerator$get_seq2ndButLastPos()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_combiStructure_index"><code>singleStructureGenerator$get_combiStructure_index()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-update_interStr_firstNeighbSt"><code>singleStructureGenerator$update_interStr_firstNeighbSt()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-update_interStr_lastNeighbSt"><code>singleStructureGenerator$update_interStr_lastNeighbSt()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_eqFreqs"><code>singleStructureGenerator$get_eqFreqs()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-SSE_evol"><code>singleStructureGenerator$SSE_evol()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-IWE_evol"><code>singleStructureGenerator$IWE_evol()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_alpha_pI"><code>singleStructureGenerator$get_alpha_pI()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_beta_pI"><code>singleStructureGenerator$get_beta_pI()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_alpha_mI"><code>singleStructureGenerator$get_alpha_mI()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_beta_mI"><code>singleStructureGenerator$get_beta_mI()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_alpha_pNI"><code>singleStructureGenerator$get_alpha_pNI()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_beta_pNI"><code>singleStructureGenerator$get_beta_pNI()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_alpha_mNI"><code>singleStructureGenerator$get_alpha_mNI()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_beta_mNI"><code>singleStructureGenerator$get_beta_mNI()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_alpha_Ri"><code>singleStructureGenerator$get_alpha_Ri()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_iota"><code>singleStructureGenerator$get_iota()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_Ri_values"><code>singleStructureGenerator$get_Ri_values()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-clone"><code>singleStructureGenerator$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-singleStructureGenerator-init_neighbSt"></a>



<h4>Method <code>init_neighbSt()</code></h4>

<p>Public method: Initialization of $neighbSt
</p>
<p>This fuction initiates each CpG position $neighbSt as encoded in $mapNeighbSt_matrix
Positions at the edge of the entire simulated sequence use
their only neighbor as both neighbors.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$init_neighbSt()</pre></div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-singleStructureGenerator-initialize_ratetree"></a>



<h4>Method <code>initialize_ratetree()</code></h4>

<p>Public method: Initialization of $ratetree
</p>
<p>This function initializes $ratetree
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$initialize_ratetree()</pre></div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-singleStructureGenerator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new singleStructureGenerator object.
</p>
<p>Note that this object is typically generated withing a combiStructureGenerator object.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$new(
  globalState,
  n,
  eqFreqs = NULL,
  combiStr = NULL,
  combiStr_index = NULL,
  params = NULL,
  testing = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>globalState</code></dt><dd><p>Character. Structure's favored global state: &quot;M&quot; for methylated (island structures) / &quot;U&quot; for unmethylated (non-island structures).</p>
</dd>
<dt><code>n</code></dt><dd><p>Numerical Value. Number of CpG positions</p>
</dd>
<dt><code>eqFreqs</code></dt><dd><p>Default NULL. When given: numerical vector with structure's methylation state equilibrium frequencies (for unmethylated, partially methylated and methylated)</p>
</dd>
<dt><code>combiStr</code></dt><dd><p>Default NULL. When initiated from combiStructureGenerator: object of class combiStructureGenerator containing it</p>
</dd>
<dt><code>combiStr_index</code></dt><dd><p>Default NULL. When initiated from combiStructureGenerator: index in Object of class combiStructureGenerator</p>
</dd>
<dt><code>params</code></dt><dd><p>Default NULL. When given: data frame containing model parameters</p>
</dd>
<dt><code>testing</code></dt><dd><p>Default FALSE. TRUE for testing output</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>singleStructureGenerator</code> object.
</p>


<hr>
<a id="method-singleStructureGenerator-get_seq"></a>



<h4>Method <code>get_seq()</code></h4>

<p>Public method: Get object's methylation state sequence
</p>
<p>Encoded with 1 for unmethylated, 2 for partially methylated and 3 for methylated
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_seq()</pre></div>



<h5>Returns</h5>

<p>vector with equilibrium frequencies of unmethylated, partially methylated and methylated
</p>


<hr>
<a id="method-singleStructureGenerator-get_seqFirstPos"></a>



<h4>Method <code>get_seqFirstPos()</code></h4>

<p>Public method: Get first sequence position methylation state
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_seqFirstPos()</pre></div>



<h5>Returns</h5>

<p>numerical encoding of first position's methylation state
</p>


<hr>
<a id="method-singleStructureGenerator-get_seq2ndPos"></a>



<h4>Method <code>get_seq2ndPos()</code></h4>

<p>Public method: Get second sequence position methylation state
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_seq2ndPos()</pre></div>



<h5>Returns</h5>

<p>numerical encoding of second position's methylation state. NULL if position does not exist
</p>


<hr>
<a id="method-singleStructureGenerator-get_seqLastPos"></a>



<h4>Method <code>get_seqLastPos()</code></h4>

<p>Public method: Get first sequence position methylation state
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_seqLastPos()</pre></div>



<h5>Returns</h5>

<p>numerical encoding of first position's methylation state
</p>


<hr>
<a id="method-singleStructureGenerator-get_seq2ndButLastPos"></a>



<h4>Method <code>get_seq2ndButLastPos()</code></h4>

<p>Public method: Get second but last sequence position methylation state
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_seq2ndButLastPos()</pre></div>



<h5>Returns</h5>

<p>numerical encoding of second but last position's methylation state. NULL if position does not exist
</p>


<hr>
<a id="method-singleStructureGenerator-get_combiStructure_index"></a>



<h4>Method <code>get_combiStructure_index()</code></h4>

<p>Public method: Get index in object of class combiStructureGenerator
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_combiStructure_index()</pre></div>



<h5>Returns</h5>

<p>index in object of class combiStructureGenerator
</p>


<hr>
<a id="method-singleStructureGenerator-update_interStr_firstNeighbSt"></a>



<h4>Method <code>update_interStr_firstNeighbSt()</code></h4>

<p>Public method: Update neighbSt of next singleStructureGenerator object within combiStructureGenerator object
</p>
<p>This function is used when the last $seq position of a singleStructureGenerator object
changes methylation state to update the neighbSt position
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$update_interStr_firstNeighbSt(
  leftNeighbSt,
  rightNeighbSt
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>leftNeighbSt</code></dt><dd><p>$seq state of left neighbor (left neighbor is in previous singleStructureGenerator object)</p>
</dd>
<dt><code>rightNeighbSt</code></dt><dd><p>$seq state of right neighbor</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-singleStructureGenerator-update_interStr_lastNeighbSt"></a>



<h4>Method <code>update_interStr_lastNeighbSt()</code></h4>

<p>Public method: Update neighbSt of previous singleStructureGenerator object within combiStructureGenerator object
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$update_interStr_lastNeighbSt(
  leftNeighbSt,
  rightNeighbSt
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>leftNeighbSt</code></dt><dd><p>$seq state of right neighbor (left neighbor is in next singleStructureGenerator object)</p>
</dd>
<dt><code>rightNeighbSt</code></dt><dd><p>$seq state of right neighbor</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-singleStructureGenerator-get_eqFreqs"></a>



<h4>Method <code>get_eqFreqs()</code></h4>

<p>Public method: Get object's equilibrium Frequencies
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_eqFreqs()</pre></div>



<h5>Returns</h5>

<p>vector with equilibrium frequencies of unmethylated, partially methylated and methylated
</p>


<hr>
<a id="method-singleStructureGenerator-SSE_evol"></a>



<h4>Method <code>SSE_evol()</code></h4>

<p>Public method. Simulate how CpG dinucleotide methylation state changes due to the SSE process
along a time step of length dt
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$SSE_evol(dt, testing = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dt</code></dt><dd><p>time step length.</p>
</dd>
<dt><code>testing</code></dt><dd><p>logical value for testing purposes. Default FALSE.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>default NULL. If testing TRUE it returns a list with the number of events sampled and a
dataframe with the position(s) affected, new state and old methylation state.
</p>


<hr>
<a id="method-singleStructureGenerator-IWE_evol"></a>



<h4>Method <code>IWE_evol()</code></h4>

<p>Public Method. Simulate IWE Events
</p>
<p>Simulates how CpG Islands' methylation state frequencies change and simultaneous sites change methylation state
along a branch of length t according to the SSE-IWE model.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$IWE_evol(testing = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>testing</code></dt><dd><p>logical value for testing purposes. Default FALSE.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The function checks if the methylation equilibrium frequencies (<code>eqFreqs</code>) and sequence observed
frequencies (<code>obsFreqs</code>) change after the IWE event. If there is a change in either
frequencies, the corresponding change flags(<code>eqFreqsChange</code>
in the <code>infoIWE</code> list will be set to <code>TRUE</code>.
</p>



<h5>Returns</h5>

<p>If testing = TRUE it returns a list.
If there was a change in the equilibrium frequencies the list contains the following 7 elements, if not it contains the first 3 elements:
</p>

<dl>
<dt><code>eqFreqsChange</code></dt><dd><p>logical indicating if there was a change in the equilibrium frequencies.</p>
</dd>
<dt><code>old_eqFreqs</code></dt><dd><p>Original equilibrium frequencies before the IWE event.</p>
</dd>
<dt><code>new_eqFreqs</code></dt><dd><p>New equilibrium frequencies after the IWE event.</p>
</dd>
<dt><code>old_obsFreqs</code></dt><dd><p>Original observed frequencies before the IWE event.</p>
</dd>
<dt><code>new_obsFreqs</code></dt><dd><p>New observed frequencies after the IWE event.</p>
</dd>
<dt><code>IWE_case</code></dt><dd><p>Description of the IWE event case.</p>
</dd>
<dt><code>Mk</code></dt><dd><p>Transition matrix used for the IWE event.</p>
</dd>
</dl>



<hr>
<a id="method-singleStructureGenerator-get_alpha_pI"></a>



<h4>Method <code>get_alpha_pI()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_alpha_pI()</pre></div>



<h5>Returns</h5>

<p>Model parameter alpha_pI for sampling island equilibrium frequencies
</p>


<hr>
<a id="method-singleStructureGenerator-get_beta_pI"></a>



<h4>Method <code>get_beta_pI()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_beta_pI()</pre></div>



<h5>Returns</h5>

<p>Model parameter for sampling island equilibrium frequencies
</p>


<hr>
<a id="method-singleStructureGenerator-get_alpha_mI"></a>



<h4>Method <code>get_alpha_mI()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_alpha_mI()</pre></div>



<h5>Returns</h5>

<p>Model parameter for sampling island equilibrium frequencies
</p>


<hr>
<a id="method-singleStructureGenerator-get_beta_mI"></a>



<h4>Method <code>get_beta_mI()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_beta_mI()</pre></div>



<h5>Returns</h5>

<p>Model parameter for sampling island equilibrium frequencies
</p>


<hr>
<a id="method-singleStructureGenerator-get_alpha_pNI"></a>



<h4>Method <code>get_alpha_pNI()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_alpha_pNI()</pre></div>



<h5>Returns</h5>

<p>Model parameter for sampling non-island equilibrium frequencies
</p>


<hr>
<a id="method-singleStructureGenerator-get_beta_pNI"></a>



<h4>Method <code>get_beta_pNI()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_beta_pNI()</pre></div>



<h5>Returns</h5>

<p>Model parameter for sampling non-island equilibrium frequencies
</p>


<hr>
<a id="method-singleStructureGenerator-get_alpha_mNI"></a>



<h4>Method <code>get_alpha_mNI()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_alpha_mNI()</pre></div>



<h5>Returns</h5>

<p>Model parameter for sampling non-island equilibrium frequencies
</p>


<hr>
<a id="method-singleStructureGenerator-get_beta_mNI"></a>



<h4>Method <code>get_beta_mNI()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_beta_mNI()</pre></div>



<h5>Returns</h5>

<p>Model parameter for sampling non-island equilibrium frequencies
</p>


<hr>
<a id="method-singleStructureGenerator-get_alpha_Ri"></a>



<h4>Method <code>get_alpha_Ri()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_alpha_Ri()</pre></div>



<h5>Returns</h5>

<p>Model parameter for gamma distribution shape to initialize the 3 $Ri_values
</p>


<hr>
<a id="method-singleStructureGenerator-get_iota"></a>



<h4>Method <code>get_iota()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_iota()</pre></div>



<h5>Returns</h5>

<p>Model parameter for gamma distribution expected value to initialize the 3 $Ri_values
</p>


<hr>
<a id="method-singleStructureGenerator-get_Ri_values"></a>



<h4>Method <code>get_Ri_values()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_Ri_values()</pre></div>



<h5>Returns</h5>

<p>The 3 $Ri_values
</p>


<hr>
<a id="method-singleStructureGenerator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='treeMultiRegionSimulator'>treeMultiRegionSimulator</h2><span id='topic+treeMultiRegionSimulator'></span>

<h3>Description</h3>

<p>an R6 class representing the methylation state of GpGs in different genomic
structures in the nodes of a tree.
</p>
<p>The whole CpG sequence is an object of class combiStructureGenerator.
Each genomic structure in it is contained in an object of class singleStructureGenerator.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>Branch</code></dt><dd><p>Public attribute: List containing objects of class combiStructureGenerator</p>
</dd>
<dt><code>branchLength</code></dt><dd><p>Public attribute: Vector with the corresponding branch lengths of each $Branch element</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-treeMultiRegionSimulator-treeEvol"><code>treeMultiRegionSimulator$treeEvol()</code></a>
</p>
</li>
<li> <p><a href="#method-treeMultiRegionSimulator-new"><code>treeMultiRegionSimulator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-treeMultiRegionSimulator-clone"><code>treeMultiRegionSimulator$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-treeMultiRegionSimulator-treeEvol"></a>



<h4>Method <code>treeEvol()</code></h4>

<p>Simulate CpG dinucleotide methylation state evolution along a tree.
The function splits a given tree and simulates evolution along its
branches. It recursively simulates evolution in all of the subtrees in the given tree
until the tree leafs
</p>


<h5>Usage</h5>

<div class="r"><pre>treeMultiRegionSimulator$treeEvol(
  Tree,
  dt = 0.01,
  parent_index = 1,
  testing = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Tree</code></dt><dd><p>String. Tree in Newick format. When called recursivelly it is given the corresponding subtree.</p>
</dd>
<dt><code>dt</code></dt><dd><p>Length of SSE time steps.</p>
</dd>
<dt><code>parent_index</code></dt><dd><p>Default 1. When called recursivelly it is given the corresponding parent branch index.</p>
</dd>
<dt><code>testing</code></dt><dd><p>Default FALSE. TRUE for testing purposes.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-treeMultiRegionSimulator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new treeMultiRegionSimulator object.
$Branch is a list for the tree branches, its first element represents the tree root.
</p>
<p>Note that one of either infoStr or rootData needs to be given. Not both, not neither.
</p>


<h5>Usage</h5>

<div class="r"><pre>treeMultiRegionSimulator$new(
  infoStr = NULL,
  rootData = NULL,
  tree,
  params = NULL,
  dt = 0.01,
  testing = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>infoStr</code></dt><dd><p>A data frame containing columns 'n' for the number of sites, and 'globalState' for the favoured global methylation state.
If initial equilibrium frequencies are given the dataframe must contain 3 additional columns: 'u_eqFreq', 'p_eqFreq' and 'm_eqFreq'</p>
</dd>
<dt><code>rootData</code></dt><dd><p>combiStructureGenerator object. When given, the simulation uses its parameter values.</p>
</dd>
<dt><code>tree</code></dt><dd><p>tree</p>
</dd>
<dt><code>params</code></dt><dd><p>Default NULL. When given: data frame containing model parameters. Note that rootData is given, its parameter values are used.</p>
</dd>
<dt><code>dt</code></dt><dd><p>length of the dt time steps for the SSE evolutionary process</p>
</dd>
<dt><code>testing</code></dt><dd><p>Default FALSE. TRUE for testing output.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>treeMultiRegionSimulator</code> object.
</p>


<hr>
<a id="method-treeMultiRegionSimulator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>treeMultiRegionSimulator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
