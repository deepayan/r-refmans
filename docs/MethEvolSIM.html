<!DOCTYPE html><html lang="en"><head><title>Help for package MethEvolSIM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MethEvolSIM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#categorize_islandGlbSt'><p>Categorize Global States of CpG Islands</p></a></li>
<li><a href='#categorize_siteMethSt'><p>Categorize Methylation Frequencies Based on Thresholds</p></a></li>
<li><a href='#cftpStepGenerator'><p>cftpStepGenerator</p></a></li>
<li><a href='#combiStructureGenerator'><p>combiStructureGenerator</p></a></li>
<li><a href='#compare_CherryFreqs'><p>Compare Methylation Frequencies Between Two Tips</p></a></li>
<li><a href='#compute_fitch'><p>Compute Fitch Parsimony for Methylation Categories</p></a></li>
<li><a href='#compute_meanCor_i'><p>Compute the Mean Correlation of Methylation State in Islands</p></a></li>
<li><a href='#compute_meanCor_ni'><p>Compute the Mean Correlation of Methylation State in Non-islands</p></a></li>
<li><a href='#computeFitch_islandGlbSt'><p>Compute Fitch Parsimony for Global Methylation States at CpG Islands</p></a></li>
<li><a href='#count_upm'><p>Count Methylation States</p></a></li>
<li><a href='#countSites_cherryMethDiff'><p>Count Methylation Differences Between Cherry Pairs</p></a></li>
<li><a href='#freqSites_cherryMethDiff'><p>Compute Methylation Frequency Differences Between Cherry Pairs</p></a></li>
<li><a href='#get_cherryDist'><p>Get Cherry Pair Distances from a Phylogenetic Tree</p></a></li>
<li><a href='#get_islandMeanFreqM'><p>Calculate the Mean Frequency of Methylated Sites in Islands</p></a></li>
<li><a href='#get_islandMeanFreqP'><p>Calculate the Mean Frequency of Partially Methylated Sites in Islands</p></a></li>
<li><a href='#get_islandSDFreqM'><p>Calculate the Mean Standard Deviation of Methylated Sites in Islands</p></a></li>
<li><a href='#get_islandSDFreqP'><p>Calculate the Mean Standard Deviation of Partially Methylated Sites in Islands</p></a></li>
<li><a href='#get_meanMeth_islands'><p>Compute the Mean Methylation of CpG Islands</p></a></li>
<li><a href='#get_nonislandMeanFreqM'><p>Calculate the Mean Frequency of Methylated Sites in Non-Islands</p></a></li>
<li><a href='#get_nonislandMeanFreqP'><p>Calculate the Mean Frequency of Partially Methylated Sites in Non-Islands</p></a></li>
<li><a href='#get_nonislandSDFreqM'><p>Calculate the Mean Standard Deviation of Methylated Sites in Non-Islands</p></a></li>
<li><a href='#get_nonislandSDFreqP'><p>Calculate the Mean Standard Deviation of Partially Methylated Sites in Non-Islands</p></a></li>
<li><a href='#get_parameterValues'><p>Get Default Parameter Values</p></a></li>
<li><a href='#get_siteFChange_cherry'><p>Compute Site Frequency of Methylation Changes per Cherry</p></a></li>
<li><a href='#mean_CherryFreqsChange_i'><p>Mean Number of Significant Methylation Frequency Changes per Island in Cherries</p></a></li>
<li><a href='#mean_TreeFreqsChange_i'><p>Mean Number of Significant Frequency Changes per Island Across all Tree Tips</p></a></li>
<li><a href='#MeanSiteFChange_cherry'><p>Compute the Mean Site Frequency of Methylation Changes per Cherry</p></a></li>
<li><a href='#pValue_CherryFreqsChange_i'><p>Compute p-Values for Methylation Frequency Changes in Cherries</p></a></li>
<li><a href='#simulate_evolData'><p>Simulate Data Evolution along a Tree</p></a></li>
<li><a href='#simulate_initialData'><p>Simulate Initial Data</p></a></li>
<li><a href='#singleStructureGenerator'><p>singleStructureGenerator</p></a></li>
<li><a href='#treeMultiRegionSimulator'><p>treeMultiRegionSimulator</p></a></li>
<li><a href='#validate_data_cherryDist'><p>Validate Structure of Input Data for Cherry Distance Computation</p></a></li>
<li><a href='#validate_dataAcrossTips'><p>Validate Data Structure Across Tips</p></a></li>
<li><a href='#validate_structureIndices'><p>Validate Structure Indices for Island and Non-Island Data</p></a></li>
<li><a href='#validate_tree'><p>Validate and Parse a Phylogenetic Tree</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Simulate DNA Methylation Dynamics on Different Genomic
Structures along Genealogies</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Sara Castillo Vicente [aut, cre],
  Dirk Metzler [aut, ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sara Castillo Vicente &lt;castillo@bio.lmu.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>DNA methylation is an epigenetic modification involved in genomic stability,
      gene regulation, development and disease.
      DNA methylation occurs mainly through the addition of a methyl group to cytosines, 
      for example to cytosines in a CpG dinucleotide context (CpG stands for a cytosine followed by a guanine).
      Tissue-specific methylation patterns lead to genomic regions with different characteristic
      methylation levels.
      E.g. in vertebrates CpG islands (regions with high CpG content) that are associated to promoter regions of
      expressed genes tend to be unmethylated.
      'MethEvolSIM' is a model-based simulation software for the generation and modification
      of cytosine methylation patterns along a given tree, which can be a genealogy of
      cells within an organism, a coalescent tree of DNA sequences sampled from a population, or a species tree.
      The simulations are based on an extension of the model of
      Grosser &amp; Metzler (2020) &lt;<a href="https://doi.org/10.1186%2Fs12859-020-3438-5">doi:10.1186/s12859-020-3438-5</a>&gt; and allows for changes of
      the methylation states at single cytosine positions as well as simultaneous changes of methylation
      frequencies in genomic structures like CpG islands.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, ape</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-16 13:37:47 UTC; sara</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-17 07:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='categorize_islandGlbSt'>Categorize Global States of CpG Islands</h2><span id='topic+categorize_islandGlbSt'></span>

<h3>Description</h3>

<p>This function categorizes CpG islands into unmethylated, methylated, or partially methylated states
based on specified thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>categorize_islandGlbSt(meanMeth_islands, u_threshold, m_threshold)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="categorize_islandGlbSt_+3A_meanmeth_islands">meanMeth_islands</code></td>
<td>
<p>A numeric vector containing the mean methylation levels for CpG islands at each tip.</p>
</td></tr>
<tr><td><code id="categorize_islandGlbSt_+3A_u_threshold">u_threshold</code></td>
<td>
<p>A numeric value (0-1) defining the threshold for categorization as unmethylated.</p>
</td></tr>
<tr><td><code id="categorize_islandGlbSt_+3A_m_threshold">m_threshold</code></td>
<td>
<p>A numeric value (0-1) defining the threshold for categorization as methylated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function assigns each island a state:
</p>

<dl>
<dt>&quot;u&quot;</dt><dd><p>if mean methylation lower or equal to <code>u_threshold</code></p>
</dd>
<dt>&quot;m&quot;</dt><dd><p>if mean methylation greater or equal to <code>m_threshold</code></p>
</dd>
<dt>&quot;p&quot;</dt><dd><p>if mean methylation is in between</p>
</dd>
</dl>



<h3>Value</h3>

<p>A character vector of length equal to <code>meanMeth_islands</code>, containing &quot;u&quot;, &quot;p&quot;, or &quot;m&quot; for each island.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>meanMeth_islands &lt;- c(0.1, 0.4, 0.8)

categorize_islandGlbSt(meanMeth_islands, 0.2, 0.8)

</code></pre>

<hr>
<h2 id='categorize_siteMethSt'>Categorize Methylation Frequencies Based on Thresholds</h2><span id='topic+categorize_siteMethSt'></span>

<h3>Description</h3>

<p>This function categorizes the values in <code>data[[tip]][[structure]]</code> into three categories:
</p>

<ul>
<li> <p><code>0</code> for unmethylated sites, where values are smaller or equal to <code>u_threshold</code>.
</p>
</li>
<li> <p><code>0.5</code> for partially methylated sites, where values are between <code>u_threshold</code> and <code>m_threshold</code>.
</p>
</li>
<li> <p><code>1</code> for methylated sites, where values are larger or equal to <code>m_threshold</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>categorize_siteMethSt(data, u_threshold = 0.2, m_threshold = 0.8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="categorize_siteMethSt_+3A_data">data</code></td>
<td>
<p>A list structured as <code>data[[tip]][[structure]]</code>, where <code>tip</code> corresponds to tree tips, and <code>structure</code>
corresponds to each genomic structure (e.g., island/non-island).</p>
</td></tr>
<tr><td><code id="categorize_siteMethSt_+3A_u_threshold">u_threshold</code></td>
<td>
<p>A numeric value representing the upper bound for values to be classified as unmethylated (<code>0</code>). Default 0.2.</p>
</td></tr>
<tr><td><code id="categorize_siteMethSt_+3A_m_threshold">m_threshold</code></td>
<td>
<p>A numeric value representing the lower bound for values to be classified as methylated (<code>1</code>). Default 0.8.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If any value in <code>data[[tip]][[structure]]</code> is outside these categories, it is transformed based on the given thresholds.
</p>


<h3>Value</h3>

<p>A transformed version of <code>data</code> where each value is categorized as <code>0</code> (unmethylated), <code>0.5</code> (partially methylated),
or <code>1</code> (methylated).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- list(
list(c(0.1, 0.2, 0.02), c(0.05, 0.25, 0.15)), # tip 1
list(c(0.01, 0.7, 0.85), c(0.3, 0.1, 0.98)) # tip 2
)

transformed_data &lt;- categorize_siteMethSt(data, u_threshold = 0.2, m_threshold = 0.8)
</code></pre>

<hr>
<h2 id='cftpStepGenerator'>cftpStepGenerator</h2><span id='topic+cftpStepGenerator'></span>

<h3>Description</h3>

<p>an R6 class representing the steps for sampling a sequence of methylation states
from the equilibrium (SSEi and SSEc considered, IWE neglected)
using the CFTP algorithm for a given combiStructureGenerator instance.
</p>
<p>It is stored in the private attribute CFTP_info of combiStructureGenerator instances
when calling the combiStructureGenerator$cftp() method
and can be retrieved with the combiStructureGenerator$get_CFTP_info()
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>singleStr_number</code></dt><dd><p>Public attribute: Number of singleStr instances</p>
</dd>
<dt><code>singleStr_siteNumber</code></dt><dd><p>Public attribute: Number of sites in singleStr instances</p>
</dd>
<dt><code>CFTP_highest_rate</code></dt><dd><p>Public attribute: CFTP highest rate</p>
</dd>
<dt><code>number_steps</code></dt><dd><p>Public attribute: counter of steps alredy generated</p>
</dd>
<dt><code>CFTP_chosen_singleStr</code></dt><dd><p>Public attribute: list with vectors of equal size with chosen singleStr index at each CFTP step</p>
</dd>
<dt><code>CFTP_chosen_site</code></dt><dd><p>Public attribute: list with vectors of equal size with chosen site index at each CFTP step</p>
</dd>
<dt><code>CFTP_event</code></dt><dd><p>Public attribute: list with vectors of equal size with type of CFTP event at each CFTP step.</p>
</dd>
<dt><code>CFTP_random</code></dt><dd><p>Public attribute: list with vectors of equal size with CFTP threshold at each CFTP step</p>
</dd>
<dt><code>steps_perVector</code></dt><dd><p>Public attribute: size of vectors in lists CFTP_chosen_singleStr, CFTP_chosen_site, CFTP_event and CFTP_random</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-cftpStepGenerator-new"><code>cftpStepGenerator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-cftpStepGenerator-generate_events"><code>cftpStepGenerator$generate_events()</code></a>
</p>
</li>
<li> <p><a href="#method-cftpStepGenerator-clone"><code>cftpStepGenerator$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-cftpStepGenerator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new instance of class cftpStepGenerator with the info of the corresponding combiStrucutre instance
</p>


<h5>Usage</h5>

<div class="r"><pre>cftpStepGenerator$new(
  singleStr_number,
  singleStr_siteNumber,
  CFTP_highest_rate
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>singleStr_number</code></dt><dd><p>Number of singleStr instances</p>
</dd>
<dt><code>singleStr_siteNumber</code></dt><dd><p>Number of sites in singleStr instances</p>
</dd>
<dt><code>CFTP_highest_rate</code></dt><dd><p>CFTP highest rate across all singleStr withing combiStr instance</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new instance of class cftpStepGenerator
</p>


<hr>
<a id="method-cftpStepGenerator-generate_events"></a>



<h4>Method <code>generate_events()</code></h4>

<p>1: SSEi to unmethylated, 2: SSEi to partially methylated, 3: SSEi to methylated
4: SSEc copy left state, 5: SSEc copy right state
</p>
<p>Public Method. Generates the events to apply for CFTP.
</p>


<h5>Usage</h5>

<div class="r"><pre>cftpStepGenerator$generate_events(steps = 10000, testing = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>steps</code></dt><dd><p>Integer value &gt;=1</p>
</dd>
<dt><code>testing</code></dt><dd><p>default FALSE. TRUE for testing output</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The function add steps to the existing ones.
If called several times the given steps need to be higher than the sum of steps generated before.
</p>



<h5>Returns</h5>

<p>NULL when testing FALSE. Testing output when testing TRUE.
</p>


<hr>
<a id="method-cftpStepGenerator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>cftpStepGenerator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='combiStructureGenerator'>combiStructureGenerator</h2><span id='topic+combiStructureGenerator'></span>

<h3>Description</h3>

<p>an R6 class representing several genomic structures.
Each genomic structure contained is an object of class singleStructureGenerator.
Note that default clone(deep=TRUE) fails to clone singleStructureGenerator objects contained, use method $copy() instead.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>testing_output</code></dt><dd><p>Public attribute: Testing output for initialize</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-combiStructureGenerator-new"><code>combiStructureGenerator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_singleStr"><code>combiStructureGenerator$get_singleStr()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_singleStr_number"><code>combiStructureGenerator$get_singleStr_number()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_singleStr_siteNumber"><code>combiStructureGenerator$get_singleStr_siteNumber()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_island_number"><code>combiStructureGenerator$get_island_number()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_island_index"><code>combiStructureGenerator$get_island_index()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-set_IWE_events"><code>combiStructureGenerator$set_IWE_events()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_IWE_events"><code>combiStructureGenerator$get_IWE_events()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-set_name"><code>combiStructureGenerator$set_name()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_name"><code>combiStructureGenerator$get_name()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_own_index"><code>combiStructureGenerator$get_own_index()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-set_own_index"><code>combiStructureGenerator$set_own_index()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_parent_index"><code>combiStructureGenerator$get_parent_index()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-set_parent_index"><code>combiStructureGenerator$set_parent_index()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_offspring_index"><code>combiStructureGenerator$get_offspring_index()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-set_offspring_index"><code>combiStructureGenerator$set_offspring_index()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-add_offspring_index"><code>combiStructureGenerator$add_offspring_index()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_mu"><code>combiStructureGenerator$get_mu()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_id"><code>combiStructureGenerator$get_id()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-set_id"><code>combiStructureGenerator$set_id()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_sharedCounter"><code>combiStructureGenerator$get_sharedCounter()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-reset_sharedCounter"><code>combiStructureGenerator$reset_sharedCounter()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-set_singleStr"><code>combiStructureGenerator$set_singleStr()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-copy"><code>combiStructureGenerator$copy()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-branch_evol"><code>combiStructureGenerator$branch_evol()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_highest_rate"><code>combiStructureGenerator$get_highest_rate()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-set_CFTP_info"><code>combiStructureGenerator$set_CFTP_info()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-get_CFTP_info"><code>combiStructureGenerator$get_CFTP_info()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-cftp_apply_events"><code>combiStructureGenerator$cftp_apply_events()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-cftp"><code>combiStructureGenerator$cftp()</code></a>
</p>
</li>
<li> <p><a href="#method-combiStructureGenerator-clone"><code>combiStructureGenerator$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-combiStructureGenerator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new combiStructureGenerator object.
</p>
<p>Note that this object can be generated within a treeMultiRegionSimulator object.
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$new(infoStr, params = NULL, testing = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>infoStr</code></dt><dd><p>A data frame containing columns 'n' for the number of sites, and 'globalState' for the favoured global methylation state.
If initial equilibrium frequencies are given the dataframe must contain 3 additional columns: 'u_eqFreq', 'p_eqFreq' and 'm_eqFreq'</p>
</dd>
<dt><code>params</code></dt><dd><p>Default NULL. When given: data frame containing model parameters.</p>
</dd>
<dt><code>testing</code></dt><dd><p>Default FALSE. TRUE for writing in public field of new instance $testing_output</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>combiStructureGenerator</code> object.
</p>


<hr>
<a id="method-combiStructureGenerator-get_singleStr"></a>



<h4>Method <code>get_singleStr()</code></h4>

<p>Public method: Get one singleStructureGenerator object in $singleStr
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_singleStr(i)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>index of the singleStructureGenerator object in $singleStr</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the singleStructureGenerator object in $singleStr with index i
</p>


<hr>
<a id="method-combiStructureGenerator-get_singleStr_number"></a>



<h4>Method <code>get_singleStr_number()</code></h4>

<p>Public method: Get number of singleStructureGenerator objects in $singleStr
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_singleStr_number()</pre></div>



<h5>Returns</h5>

<p>number of singleStructureGenerator object contained in $singleStr
</p>


<hr>
<a id="method-combiStructureGenerator-get_singleStr_siteNumber"></a>



<h4>Method <code>get_singleStr_siteNumber()</code></h4>

<p>Public method: Get number of sites in all singleStructureGenerator objects
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_singleStr_siteNumber()</pre></div>



<h5>Returns</h5>

<p>number of sites in all singleStructureGenerator objects
</p>


<hr>
<a id="method-combiStructureGenerator-get_island_number"></a>



<h4>Method <code>get_island_number()</code></h4>

<p>Public method: Get number of singleStructureGenerator objects in $singleStr with $globalState &quot;U&quot; (CpG islands)
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_island_number()</pre></div>



<h5>Returns</h5>

<p>number of singleStructureGenerator in $singleStr objects with $globalState &quot;U&quot; (CpG islands)
</p>


<hr>
<a id="method-combiStructureGenerator-get_island_index"></a>



<h4>Method <code>get_island_index()</code></h4>

<p>Public method: Get index of singleStructureGenerator objects in $singleStr with $globalState &quot;U&quot; (CpG islands)
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_island_index()</pre></div>



<h5>Returns</h5>

<p>index of singleStructureGenerator objects in $singleStr with $globalState &quot;U&quot; (CpG islands)
</p>


<hr>
<a id="method-combiStructureGenerator-set_IWE_events"></a>



<h4>Method <code>set_IWE_events()</code></h4>

<p>Public method: Set information of the IWE events sampled in a tree branch
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$set_IWE_events(a)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p>value to which IWE_events should be set</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-combiStructureGenerator-get_IWE_events"></a>



<h4>Method <code>get_IWE_events()</code></h4>

<p>Public method: Get information of the IWE events sampled in a tree branch
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_IWE_events()</pre></div>



<h5>Returns</h5>

<p>information of the IWE events sampled in a tree branch
</p>


<hr>
<a id="method-combiStructureGenerator-set_name"></a>



<h4>Method <code>set_name()</code></h4>

<p>Public method: Set the name of the leaf if evolutionary process
(simulated from class treeMultiRegionSimulator) ends in a tree leaf.
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$set_name(a)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p>value to which name should be set</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-combiStructureGenerator-get_name"></a>



<h4>Method <code>get_name()</code></h4>

<p>Public method: Get the name of the leaf if evolutionary process
(simulated from class treeMultiRegionSimulator) ended in a tree leaf.
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_name()</pre></div>



<h5>Returns</h5>

<p>Name of the leaf if evolutionary process
(simulated from class treeMultiRegionSimulator) ended in a tree leaf.
For iner tree nodes return NULL
</p>


<hr>
<a id="method-combiStructureGenerator-get_own_index"></a>



<h4>Method <code>get_own_index()</code></h4>

<p>Public method: Set own branch index in the tree
along which the evolutionary process is simulated
(from class treeMultiRegionSimulator).
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_own_index()</pre></div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-combiStructureGenerator-set_own_index"></a>



<h4>Method <code>set_own_index()</code></h4>

<p>Public method: Get own branch index in the tree
along which the evolutionary process is simulated
(from class treeMultiRegionSimulator).
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$set_own_index(i)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>index of focal object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Own branch index in the tree
along which the evolutionary process is simulated
(from class treeMultiRegionSimulator).
</p>


<hr>
<a id="method-combiStructureGenerator-get_parent_index"></a>



<h4>Method <code>get_parent_index()</code></h4>

<p>Public method: Get parent branch index in the tree
along which the evolutionary process is simulated
(from class treeMultiRegionSimulator).
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_parent_index()</pre></div>



<h5>Returns</h5>

<p>Parent branch index in the tree
along which the evolutionary process is simulated
(from class treeMultiRegionSimulator).
</p>


<hr>
<a id="method-combiStructureGenerator-set_parent_index"></a>



<h4>Method <code>set_parent_index()</code></h4>

<p>Public method: Set parent branch index in the tree
along which the evolutionary process is simulated
(from class treeMultiRegionSimulator).
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$set_parent_index(i)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>set parent_index to this value</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-combiStructureGenerator-get_offspring_index"></a>



<h4>Method <code>get_offspring_index()</code></h4>

<p>Public method: Get offspring branch index in the tree
along which the evolutionary process is simulated
(from class treeMultiRegionSimulator).
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_offspring_index()</pre></div>



<h5>Returns</h5>

<p>Offspring branch index in the tree
along which the evolutionary process is simulated
(from class treeMultiRegionSimulator).
</p>


<hr>
<a id="method-combiStructureGenerator-set_offspring_index"></a>



<h4>Method <code>set_offspring_index()</code></h4>

<p>Public method: Set offspring branch index in the tree
along which the evolutionary process is simulated
(from class treeMultiRegionSimulator).
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$set_offspring_index(i)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>set offspring_index to this value</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-combiStructureGenerator-add_offspring_index"></a>



<h4>Method <code>add_offspring_index()</code></h4>

<p>Public method: Add offspring branch index in the tree
along which the evolutionary process is simulated
(from class treeMultiRegionSimulator).
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$add_offspring_index(i)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>index to be added</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-combiStructureGenerator-get_mu"></a>



<h4>Method <code>get_mu()</code></h4>

<p>Public method.
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_mu()</pre></div>



<h5>Returns</h5>

<p>Model parameter for the rate of the IWE evolutionary process (per island and branch length).
</p>


<hr>
<a id="method-combiStructureGenerator-get_id"></a>



<h4>Method <code>get_id()</code></h4>

<p>Public method. Get the unique ID of the instance
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_id()</pre></div>



<h5>Returns</h5>

<p>A numeric value representing the unique ID of the instance.
</p>


<hr>
<a id="method-combiStructureGenerator-set_id"></a>



<h4>Method <code>set_id()</code></h4>

<p>Public method. Set the unique ID of the instance
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$set_id(id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>integer value to identificate the combiStructure instance</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric value representing the unique ID of the instance.
</p>


<hr>
<a id="method-combiStructureGenerator-get_sharedCounter"></a>



<h4>Method <code>get_sharedCounter()</code></h4>

<p>Public method. Get the counter value from the shared environment between instances of combiStructureGenerator class
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_sharedCounter()</pre></div>



<h5>Returns</h5>

<p>Numeric counter value.
</p>


<hr>
<a id="method-combiStructureGenerator-reset_sharedCounter"></a>



<h4>Method <code>reset_sharedCounter()</code></h4>

<p>Public method. Reset the counter value of the shared environment between instances of combiStructureGenerator class
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$reset_sharedCounter()</pre></div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-combiStructureGenerator-set_singleStr"></a>



<h4>Method <code>set_singleStr()</code></h4>

<p>Public method: Clone each singleStructureGenerator object in $singleStr
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$set_singleStr(singStrList)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>singStrList</code></dt><dd><p>object to be cloned</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-combiStructureGenerator-copy"></a>



<h4>Method <code>copy()</code></h4>

<p>Public method: Clone combiStructureGenerator object and all singleStructureGenerator objects in it
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$copy()</pre></div>



<h5>Returns</h5>

<p>cloned combiStructureGenerator object
</p>


<hr>
<a id="method-combiStructureGenerator-branch_evol"></a>



<h4>Method <code>branch_evol()</code></h4>

<p>Simulate CpG dinucleotide methylation state evolution along a tree branch.
The function samples the IWE events on the tree branch and simulates the
evolution through the SSE and IWE processes.
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$branch_evol(branch_length, dt, testing = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>branch_length</code></dt><dd><p>Length of the branch.</p>
</dd>
<dt><code>dt</code></dt><dd><p>Length of SSE time steps.</p>
</dd>
<dt><code>testing</code></dt><dd><p>Default FALSE. TRUE for testing purposes.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>It handles both cases where IWE events are sampled or not sampled within the branch.
</p>



<h5>Returns</h5>

<p>Default NULL. If testing = TRUE it returns information for testing purposes.
</p>


<hr>
<a id="method-combiStructureGenerator-get_highest_rate"></a>



<h4>Method <code>get_highest_rate()</code></h4>

<p>Public Method. Gets the highest rate among all singleStructureGenerator objects for CFTP.
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_highest_rate()</pre></div>



<h5>Returns</h5>

<p>Highest rate value.
</p>


<hr>
<a id="method-combiStructureGenerator-set_CFTP_info"></a>



<h4>Method <code>set_CFTP_info()</code></h4>

<p>Public Method. Sets a cftpStepGenerator instance asthe CFTP info.
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$set_CFTP_info(CFTP_instance)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>CFTP_instance</code></dt><dd><p>CFTP info.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-combiStructureGenerator-get_CFTP_info"></a>



<h4>Method <code>get_CFTP_info()</code></h4>

<p>Public Method. Gets the CFTP info.
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$get_CFTP_info()</pre></div>



<h5>Returns</h5>

<p>CFTP info.
</p>


<hr>
<a id="method-combiStructureGenerator-cftp_apply_events"></a>



<h4>Method <code>cftp_apply_events()</code></h4>

<p>Public Method. Applies the CFTP events.
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$cftp_apply_events(testing = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>testing</code></dt><dd><p>default FALSE. TRUE for testing output</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL when testing FALSE. Testing output when testing TRUE.
</p>


<hr>
<a id="method-combiStructureGenerator-cftp"></a>



<h4>Method <code>cftp()</code></h4>

<p>Public Method. Applies the CFTP algorithm to evolve a structure and checks for convergence by comparing methylation states.
</p>
<p>This method generates CFTP steps until the methylation sequences of the current structure and a cloned structure become identical across all singleStr instances or a step limit is reached. If the step limit is exceeded, an approximation method is applied to finalize the sequence.
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$cftp(
  steps = 10000,
  step_limit = 327680000,
  testing = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>steps</code></dt><dd><p>minimum number of steps to apply (default 10000).</p>
</dd>
<dt><code>step_limit</code></dt><dd><p>maximum number of steps before applying an approximation method
(default 327680000 corresponding to size of CFTP info of approx 6.1 GB).
If this limit is reached, the algorithm stops and an approximation is applied.</p>
</dd>
<dt><code>testing</code></dt><dd><p>logical. If TRUE, returns additional testing output including the current structure, the cloned structure, the counter value, total steps, and the chosen site for the CFTP events. Default is FALSE.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL when testing is FALSE. If testing is TRUE, returns a list with:
</p>

<ul>
<li> <p><code>self</code>: the current object after applying the CFTP algorithm.
</p>
</li>
<li> <p><code>combi_m</code>: a deep cloned object with applied CFTP events.
</p>
</li>
<li> <p><code>counter</code>: the number of iterations performed.
</p>
</li>
<li> <p><code>total_steps</code>: the number of steps applied by the CFTP algorithm.
</p>
</li>
<li> <p><code>CFTP_chosen_site</code>: the site selected during the CFTP event application.
</p>
</li></ul>



<hr>
<a id="method-combiStructureGenerator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>combiStructureGenerator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='compare_CherryFreqs'>Compare Methylation Frequencies Between Two Tips</h2><span id='topic+compare_CherryFreqs'></span>

<h3>Description</h3>

<p>Performs a chi-squared test to compare the distribution of methylation states
(unmethylated <code>0</code>, partially-methylated <code>0.5</code>, and methylated <code>1</code>)
between two cherry tips. A cherry is a pair of leaf nodes (also called tips or terminal nodes)
in a phylogenetic tree that share a direct common ancestor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_CherryFreqs(tip1, tip2, testing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_CherryFreqs_+3A_tip1">tip1</code></td>
<td>
<p>A numeric vector representing methylation states (<code>0</code>, <code>0.5</code>, <code>1</code>) at tip 1.</p>
</td></tr>
<tr><td><code id="compare_CherryFreqs_+3A_tip2">tip2</code></td>
<td>
<p>A numeric vector representing methylation states (<code>0</code>, <code>0.5</code>, <code>1</code>) at tip 2.</p>
</td></tr>
<tr><td><code id="compare_CherryFreqs_+3A_testing">testing</code></td>
<td>
<p>Logical; if <code>TRUE</code>, returns additional intermediate data including the contingency table and test result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses <code>simulate.p.value = TRUE</code> in <code><a href="stats.html#topic+chisq.test">chisq.test</a></code>
to compute the p-value via Monte Carlo simulation to improve reliability
regardless of whether the expected frequencies meet the assumptions of the chi-squared test
(i.e., expected counts of at least 5 in each category).
</p>


<h3>Value</h3>

<p>If <code>testing = TRUE</code>, returns a list with the contingency table and chi-squared test results.
Otherwise, returns the p-value of the test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tip1 &lt;- c(0, 0, 1, 0.5, 1, 0.5)
tip2 &lt;- c(0, 1, 1, 0, 0.5, 0.5)
compare_CherryFreqs(tip1, tip2)

</code></pre>

<hr>
<h2 id='compute_fitch'>Compute Fitch Parsimony for Methylation Categories</h2><span id='topic+compute_fitch'></span>

<h3>Description</h3>

<p>This function applies Fitch parsimony to determine the minimum number of changes required for
methylation categories at tree tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_fitch(tree, meth, input_control = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_fitch_+3A_tree">tree</code></td>
<td>
<p>A rooted binary tree in Newick format (character string) or as an <code>ape</code> phylo object.
Must have at least two tips.</p>
</td></tr>
<tr><td><code id="compute_fitch_+3A_meth">meth</code></td>
<td>
<p>A matrix of methylation categories at the tree tips, with rows corresponding to tips
(names matching tree tip labels) and columns corresponding to sites or structures.</p>
</td></tr>
<tr><td><code id="compute_fitch_+3A_input_control">input_control</code></td>
<td>
<p>Logical; if <code>TRUE</code>, validates input consistency.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt><code>optStateSet</code></dt><dd><p>A list of sets of optimal states for the root at each site/structure.</p>
</dd>
<dt><code>minChange_number</code></dt><dd><p>A numeric vector indicating the minimum number of changes for each site.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- "((a:1,b:1):2,(c:2,d:2):1.5);"

meth &lt;- matrix(c("u", "m", "p", "u", "p", "m", "m", "u"), 
               nrow=4, byrow=TRUE, dimnames=list(c("a", "b", "c", "d")))
               
compute_fitch(tree, meth)

</code></pre>

<hr>
<h2 id='compute_meanCor_i'>Compute the Mean Correlation of Methylation State in Islands</h2><span id='topic+compute_meanCor_i'></span>

<h3>Description</h3>

<p>This function calculates the mean correlation of methylation states within
island structures, allowing to exclude the shores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_meanCor_i(
  index_islands,
  minN_CpG,
  shore_length,
  data,
  sample_n,
  categorized_data = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_meanCor_i_+3A_index_islands">index_islands</code></td>
<td>
<p>A vector containing the structural indices for islands.</p>
</td></tr>
<tr><td><code id="compute_meanCor_i_+3A_minn_cpg">minN_CpG</code></td>
<td>
<p>The minimum number of central CpGs required for computation.</p>
</td></tr>
<tr><td><code id="compute_meanCor_i_+3A_shore_length">shore_length</code></td>
<td>
<p>The number of CpGs at each side of an island to exclude (shores).</p>
</td></tr>
<tr><td><code id="compute_meanCor_i_+3A_data">data</code></td>
<td>
<p>A list containing methylation states at tree tips for each genomic structure (island / non-island)
For a single tip: <code>data[[structure]]</code>.
For multiple tips: <code>data[[tip]][[structure]]</code>.
Each element contains the methylation states at the sites in a given tip and structure
represented as 0, 0.5 or 1 (for unmethylated, partially-methylated and methylated).
If methylation states are not represented as 0, 0.5, 1 they are categorized
as 0 when value equal or under 0.2
0.5 when value between 0.2 and 0.8
and 1 when value over 0.8.
For customized categorization thresholds use <code>categorize_siteMethSt</code></p>
</td></tr>
<tr><td><code id="compute_meanCor_i_+3A_sample_n">sample_n</code></td>
<td>
<p>The number of tips (samples) to process.</p>
</td></tr>
<tr><td><code id="compute_meanCor_i_+3A_categorized_data">categorized_data</code></td>
<td>
<p>Logical defaulted to FALSE.
TRUE to skip redundant categorization when methylation states are represented as 0, 0.5, and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function processes only islands with a minimum length equal to <code>2 * shore_length + minN_CpG</code>.
If none has minimum length, returns NA
</p>


<h3>Value</h3>

<p>A numeric value representing the mean correlation of methylation states in the central CpGs of islands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
index_islands &lt;- c(1, 2)
data &lt;- list(
  list(c(0, 1, 0.5, 1, 0.5, 0), c(0.5, 0.5, 1, 1, 0, 0)), # tip 1
  list(c(1, 0, 1, 1, 0.5, 0), c(1, 1, 0.5, 0.5, 0, 1))   # tip 2
)
minN_CpG &lt;- 2
shore_length &lt;- 1
sample_n &lt;- 2
compute_meanCor_i(index_islands, minN_CpG, shore_length, data, sample_n,
                   categorized_data = TRUE)

</code></pre>

<hr>
<h2 id='compute_meanCor_ni'>Compute the Mean Correlation of Methylation State in Non-islands</h2><span id='topic+compute_meanCor_ni'></span>

<h3>Description</h3>

<p>This function calculates the mean correlation of methylation states within
non-island structures, allowing to exclude the shores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_meanCor_ni(
  index_nonislands,
  minN_CpG,
  shore_length,
  data,
  sample_n,
  categorized_data = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_meanCor_ni_+3A_index_nonislands">index_nonislands</code></td>
<td>
<p>A vector containing the structural indices for non-islands.</p>
</td></tr>
<tr><td><code id="compute_meanCor_ni_+3A_minn_cpg">minN_CpG</code></td>
<td>
<p>The minimum number of central CpGs required for computation.</p>
</td></tr>
<tr><td><code id="compute_meanCor_ni_+3A_shore_length">shore_length</code></td>
<td>
<p>The number of CpGs at each side of an non-island to exclude (shores).</p>
</td></tr>
<tr><td><code id="compute_meanCor_ni_+3A_data">data</code></td>
<td>
<p>A list containing methylation states at tree tips for each genomic structure (island / non-island)
For a single tip: <code>data[[structure]]</code>.
For multiple tips: <code>data[[tip]][[structure]]</code>.
Each element contains the methylation states at the sites in a given tip and structure
represented as 0, 0.5 or 1 (for unmethylated, partially-methylated and methylated).
If methylation states are not represented as 0, 0.5, 1 they are categorized
as 0 when value equal or under 0.2
0.5 when value between 0.2 and 0.8
and 1 when value over 0.8.
For customized categorization thresholds use <code>categorize_siteMethSt</code></p>
</td></tr>
<tr><td><code id="compute_meanCor_ni_+3A_sample_n">sample_n</code></td>
<td>
<p>The number of tips (samples) to process.</p>
</td></tr>
<tr><td><code id="compute_meanCor_ni_+3A_categorized_data">categorized_data</code></td>
<td>
<p>Logical defaulted to FALSE.
TRUE to skip redundant categorization when methylation states are represented as 0, 0.5, and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function processes only non-islands with a minimum length equal to <code>2 * shore_length + minN_CpG</code>.
If none has minimum length, returns NA
</p>


<h3>Value</h3>

<p>A numeric value representing the mean correlation of methylation states in the central CpGs of non-islands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
index_nonislands &lt;- c(1, 2)
data &lt;- list(
  list(c(0, 1, 0.5, 1, 0.5, 0), c(0.5, 0.5, 1, 1, 0, 0)), # tip 1
  list(c(1, 0, 1, 1, 0.5, 0), c(1, 1, 0.5, 0.5, 0, 1))   # tip 2
)
minN_CpG &lt;- 2
shore_length &lt;- 1
sample_n &lt;- 2
compute_meanCor_ni(index_nonislands, minN_CpG, shore_length, data, sample_n,
                    categorized_data = TRUE)

</code></pre>

<hr>
<h2 id='computeFitch_islandGlbSt'>Compute Fitch Parsimony for Global Methylation States at CpG Islands</h2><span id='topic+computeFitch_islandGlbSt'></span>

<h3>Description</h3>

<p>This function categorizes CpG islands into methylation states and applies Fitch parsimony
to estimate the minimum number of state changes in a phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeFitch_islandGlbSt(
  index_islands,
  data,
  tree,
  u_threshold,
  m_threshold,
  testing = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeFitch_islandGlbSt_+3A_index_islands">index_islands</code></td>
<td>
<p>A numeric vector specifying the indices of genomic structures corresponding to islands.</p>
</td></tr>
<tr><td><code id="computeFitch_islandGlbSt_+3A_data">data</code></td>
<td>
<p>A list containing methylation states at tree tips, structured as <code>data[[tip]][[structure]]</code>,
where each tip has the same number of structures, and each structure has the same number of sites across tips.</p>
</td></tr>
<tr><td><code id="computeFitch_islandGlbSt_+3A_tree">tree</code></td>
<td>
<p>A rooted binary tree in Newick format (character string) or as an <code>ape</code> phylo object.
Must have at least two tips.</p>
</td></tr>
<tr><td><code id="computeFitch_islandGlbSt_+3A_u_threshold">u_threshold</code></td>
<td>
<p>A numeric threshold value (0-1) defining the unmethylated category.</p>
</td></tr>
<tr><td><code id="computeFitch_islandGlbSt_+3A_m_threshold">m_threshold</code></td>
<td>
<p>A numeric threshold value (0-1) defining the methylated category.</p>
</td></tr>
<tr><td><code id="computeFitch_islandGlbSt_+3A_testing">testing</code></td>
<td>
<p>Logical; if <code>TRUE</code>, returns additional intermediate data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first validates the input data and categorizes CpG islands using <code>categorize_islandGlbSt</code>.
It then structures the data into a matrix matching tree tip labels and applies <code>compute_fitch</code>
to infer the minimum number of changes.
</p>


<h3>Value</h3>

<p>If <code>testing = TRUE</code>, returns a list containing the categorized data matrix; otherwise,
returns a numeric vector of minimum state changes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- "((a:1,b:1):2,(c:2,d:2):1.5);"

data &lt;- list(
  list(rep(1,10), rep(0,5), rep(1,8)),
  list(rep(1,10), rep(0.5,5), rep(0,8))
)

index_islands &lt;- c(1,3)

computeFitch_islandGlbSt(index_islands, data, tree, 0.2, 0.6)

</code></pre>

<hr>
<h2 id='count_upm'>Count Methylation States</h2><span id='topic+count_upm'></span>

<h3>Description</h3>

<p>This internal function counts the number of sites with unmethylated, partially-methylated,
and methylated states in a given vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_upm(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_upm_+3A_data">data</code></td>
<td>
<p>A numeric vector with methylation values: <code>0</code> (unmethylated), <code>0.5</code> (partially-methylated),
and <code>1</code> (methylated).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector of length 3 containing counts of unmethylated, partially-methylated,
and methylated sites, respectively.
</p>

<hr>
<h2 id='countSites_cherryMethDiff'>Count Methylation Differences Between Cherry Pairs</h2><span id='topic+countSites_cherryMethDiff'></span>

<h3>Description</h3>

<p>This function calculates the number of methylation differences between pairs of cherry tips in a phylogenetic tree.
A cherry is a pair of leaf nodes that share a direct common ancestor. The function quantifies full and half methylation
differences for each genomic structure (e.g., island/non-island) across all sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countSites_cherryMethDiff(
  cherryDist,
  data,
  categorized_data = FALSE,
  input_control = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countSites_cherryMethDiff_+3A_cherrydist">cherryDist</code></td>
<td>
<p>A data frame containing pairwise distances between the tips of a phylogenetic tree that form cherries.
This should be as the output of <code>get_cherryDist</code>, and must include the following columns:
</p>

<dl>
<dt>first_tip_name</dt><dd><p>A character string representing the name of the first tip in the cherry.</p>
</dd>
<dt>second_tip_name</dt><dd><p>A character string representing the name of the second tip in the cherry.</p>
</dd>
<dt>first_tip_index</dt><dd><p>An integer representing the index of the first tip in the cherry.</p>
</dd>
<dt>second_tip_index</dt><dd><p>An integer representing the index of the second tip in the cherry.</p>
</dd>
<dt>dist</dt><dd><p>A numeric value representing the sum of the branch lengths between the two tips (i.e., the distance between the cherries).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="countSites_cherryMethDiff_+3A_data">data</code></td>
<td>
<p>A list containing methylation states at tree tips for each genomic structure (e.g., island/non-island).
The data should be structured as <code>data[[tip]][[structure]]</code>, where each structure has the same number of sites across tips.
The input data must be prefiltered to ensure CpG sites are represented consistently across different tips.
Each element contains the methylation states at the sites in a given tip and structure
represented as 0, 0.5 or 1 (for unmethylated, partially-methylated and methylated).
If methylation states are not represented as 0, 0.5, 1 they are categorized
as 0 when value equal or under 0.2
0.5 when value between 0.2 and 0.8
and 1 when value over 0.8.
For customized categorization thresholds use <code>categorize_siteMethSt</code></p>
</td></tr>
<tr><td><code id="countSites_cherryMethDiff_+3A_categorized_data">categorized_data</code></td>
<td>
<p>Logical defaulted to FALSE.
TRUE to skip redundant categorization when methylation states are represented as 0, 0.5, and 1.</p>
</td></tr>
<tr><td><code id="countSites_cherryMethDiff_+3A_input_control">input_control</code></td>
<td>
<p>A logical value indicating whether to validate the input data.
If <code>TRUE</code> (default), the function checks that the data has the required structure.
It ensures that the number of tips is sufficient and that the data structure is consistent across tips and structures.
If <code>FALSE</code>, the function assumes the tree is already valid and skips the validation step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first verifies that <code>cherryDist</code> contains the required columns and has at least one row.
It also ensures that <code>data</code> contains a sufficient number of tips and that all structures have the same number of sites.
The function then iterates over each cherry and genomic structure to compute the number of full and half methylation differences
between the two tips of each cherry.
</p>


<h3>Value</h3>

<p>A data frame with one row per cherry, containing the following columns:
</p>

<dl>
<dt>tip_names</dt><dd><p>A character string representing the names of the two tips in the cherry, concatenated with a hyphen.</p>
</dd>
<dt>tip_indices</dt><dd><p>A character string representing the indices of the two tips in the cherry, concatenated with a hyphen.</p>
</dd>
<dt>dist</dt><dd><p>A numeric value representing the sum of the branch distances between the cherry tips.</p>
</dd>
<dt>One column for each structure named with the structure number followed by _f</dt><dd><p>An integer count of the sites with a full methylation difference (where one tip is methylated and the other is unmethylated) for the given structure.</p>
</dd>
<dt>One column for each structure named with the structure number followed by _h</dt><dd><p>An integer count of the sites with a half methylation difference (where one tip is partially methylated and the other is either fully methylated or unmethylated) for the given structure.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Example data setup

data &lt;- list(
  list(c(0, 1, 0.5, 0), c(1, 1, 0, 0.5)),
  list(c(1, 0, 0.5, 1), c(0, 1, 0.5, 0.5))
)

tree &lt;- "(tip1:0.25, tip2:0.25);"

cherryDist &lt;- get_cherryDist(tree)

countSites_cherryMethDiff(cherryDist, data, categorized_data = TRUE)

</code></pre>

<hr>
<h2 id='freqSites_cherryMethDiff'>Compute Methylation Frequency Differences Between Cherry Pairs</h2><span id='topic+freqSites_cherryMethDiff'></span>

<h3>Description</h3>

<p>This function calculates the frequency of methylation differences between pairs of cherry tips in a phylogenetic tree.
A cherry is a pair of leaf nodes that share a direct common ancestor. The function quantifies full and half methylation
differences for each genomic structure (e.g., island/non-island) across all sites and normalizes these counts by the number
of sites per structure to obtain frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqSites_cherryMethDiff(
  tree,
  data,
  categorized_data = FALSE,
  input_control = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="freqSites_cherryMethDiff_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree object. The function assumes it follows an appropriate format for downstream processing.</p>
</td></tr>
<tr><td><code id="freqSites_cherryMethDiff_+3A_data">data</code></td>
<td>
<p>A list containing methylation states at tree tips for each genomic structure (e.g., island/non-island).
The data should be structured as <code>data[[tip]][[structure]]</code>, where each structure has the same number of sites across tips.
The input data must be prefiltered to ensure CpG sites are represented consistently across different tips.
Each element contains the methylation states at the sites in a given tip and structure
represented as 0, 0.5 or 1 (for unmethylated, partially-methylated and methylated).
If methylation states are not represented as 0, 0.5, 1 they are categorized
as 0 when value equal or under 0.2
0.5 when value between 0.2 and 0.8
and 1 when value over 0.8.
For customized categorization thresholds use <code>categorize_siteMethSt</code></p>
</td></tr>
<tr><td><code id="freqSites_cherryMethDiff_+3A_categorized_data">categorized_data</code></td>
<td>
<p>Logical defaulted to FALSE.
TRUE to skip redundant categorization when methylation states are represented as 0, 0.5, and 1.</p>
</td></tr>
<tr><td><code id="freqSites_cherryMethDiff_+3A_input_control">input_control</code></td>
<td>
<p>A logical value indicating whether to validate the input data.
If <code>TRUE</code> (default), the function checks that the data has the required structure.
It ensures that the number of tips is sufficient and that the data structure is consistent across tips and structures.
If <code>FALSE</code>, the function assumes the tree is already valid and skips the validation step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first validates the tree structure and extracts pairwise distances between cherry tips.
It then counts methylation differences using <code>countSites_cherryMethDiff</code> and normalizes these counts by the number
of sites per structure to compute frequencies. The resulting data frame provides a per-cherry frequency
of methylation differences (half or full difference) across different genomic structures.
</p>


<h3>Value</h3>

<p>A data frame with one row per cherry, containing the following columns:
</p>

<dl>
<dt>tip_names</dt><dd><p>A character string representing the names of the two tips in the cherry, concatenated with a hyphen.</p>
</dd>
<dt>tip_indices</dt><dd><p>A character string representing the indices of the two tips in the cherry, concatenated with a hyphen.</p>
</dd>
<dt>dist</dt><dd><p>A numeric value representing the sum of the branch distances between the cherry tips.</p>
</dd>
<dt>One column for each structure named with the structure number followed by _f</dt><dd><p>A numeric value representing the frequency of sites with a full methylation difference (where one tip is methylated and the other is unmethylated) for the given structure.</p>
</dd>
<dt>One column for each structure named with the structure number followed by _h</dt><dd><p>A numeric value representing the frequency of sites with a half methylation difference (where one tip is partially methylated and the other is either fully methylated or unmethylated) for the given structure.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Example data setup

data &lt;- list(
list(rep(1,10), rep(0,5), rep(1,8)),
list(rep(1,10), rep(0.5,5), rep(0,8)),
list(rep(1,10), rep(0.5,5), rep(0,8)),
list(c(rep(0,5), rep(0.5, 5)), c(0, 0, 1, 1, 1), c(0.5, 1, rep(0, 6))))

tree &lt;- "((a:1.5,b:1.5):2,(c:2,d:2):1.5);"

freqSites_cherryMethDiff(tree, data, categorized_data = TRUE)

</code></pre>

<hr>
<h2 id='get_cherryDist'>Get Cherry Pair Distances from a Phylogenetic Tree</h2><span id='topic+get_cherryDist'></span>

<h3>Description</h3>

<p>This function computes the pairwise distances between the tips of a phylogenetic tree
that are part of cherries. A cherry is a pair of leaf nodes (also called tips or terminal nodes)
in a phylogenetic tree that share a direct common ancestor.
In other words, if two leaves are connected to the same internal node and no other leaves
are connected to that internal node, they form a cherry.
The distance is calculated as the sum of the branch lengths between the two cherry tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cherryDist(tree, input_control = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cherryDist_+3A_tree">tree</code></td>
<td>
<p>A tree in Newick format (as a character string) or an object of class <code>phylo</code> from the <code>ape</code> package.
If the input is a character string, it must follow the Newick or New Hampshire format (e.g. <code>"((tip_1:1,tip_2:1):5,tip_3:6);"</code>).
If an object of class <code>phylo</code> is provided, it should represent a valid phylogenetic tree.</p>
</td></tr>
<tr><td><code id="get_cherryDist_+3A_input_control">input_control</code></td>
<td>
<p>A logical value indicating whether to validate the input tree.
If <code>TRUE</code> (default), the function checks that the tree is in a valid format and has at least two tips.
If <code>FALSE</code>, the function assumes the tree is already valid and skips the validation step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first checks if the input is either a character string in the Newick format or an object of class <code>phylo</code>,
unless <code>input_control</code> is set to <code>FALSE</code>. It then computes the pairwise distances between the tips in the tree and
identifies the sister pairs (cherries). The distance between each cherry is the sum of the branch lengths leading to the sister tips.
</p>
<p>The tips of each cherry are identified by their names and indices.
The tip indices correspond to (a) the index from left to right on the Newick string,
(b) the order of the tip label in the <code>phylo_object$tip.label</code>, and
(c) the index in the methylation data list (<code>data[[tip]][[structure]]</code>) as obtained with the function <code>simulate_evolData()</code> when the given tree has several tips.
</p>
<p>If the tree is provided in Newick format, it will be parsed using the <code>ape::read.tree</code> function.
</p>


<h3>Value</h3>

<p>A data frame with five columns:
</p>
<table role = "presentation">
<tr><td><code>first_tip_name</code></td>
<td>
<p>A character string representing the name of the first tip in the cherry.</p>
</td></tr>
<tr><td><code>second_tip_name</code></td>
<td>
<p>A character string representing the name of the second tip in the cherry.</p>
</td></tr>
<tr><td><code>first_tip_index</code></td>
<td>
<p>An integer representing the index of the first tip in the cherry.</p>
</td></tr>
<tr><td><code>second_tip_index</code></td>
<td>
<p>An integer representing the index of the second tip in the cherry.</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>A numeric value representing the sum of the branch lengths between the two tips (i.e., the distance between the cherries).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Example of a tree in Newick format

newick_tree &lt;- "((a:1,b:2):5,c:6);"

get_cherryDist(newick_tree)

# Example of using a phylo object from ape

library(ape)
tree_phylo &lt;- read.tree(text = "((a:1,b:1):5,c:6);")

get_cherryDist(tree_phylo)

</code></pre>

<hr>
<h2 id='get_islandMeanFreqM'>Calculate the Mean Frequency of Methylated Sites in Islands</h2><span id='topic+get_islandMeanFreqM'></span>

<h3>Description</h3>

<p>This function computes the mean frequency of methylated sites (with methylation state 1)
for a set of structures identified as islands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_islandMeanFreqM(index_islands, data, sample_n, categorized_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_islandMeanFreqM_+3A_index_islands">index_islands</code></td>
<td>
<p>A vector containing the structural indices for islands.</p>
</td></tr>
<tr><td><code id="get_islandMeanFreqM_+3A_data">data</code></td>
<td>
<p>A list containing methylation states at tree tips for each genomic structure (island / non-island)
For a single tip: <code>data[[structure]]</code>.
For multiple tips: <code>data[[tip]][[structure]]</code>.
Each element contains the methylation states at the sites in a given tip and structure
represented as 0, 0.5 or 1 (for unmethylated, partially-methylated and methylated).
If methylation states are not represented as 0, 0.5, 1 they are categorized
as 0 when value equal or under 0.2
0.5 when value between 0.2 and 0.8
and 1 when value over 0.8.
For customized categorization thresholds use <code>categorize_siteMethSt</code></p>
</td></tr>
<tr><td><code id="get_islandMeanFreqM_+3A_sample_n">sample_n</code></td>
<td>
<p>The number of samples (tips) to process.</p>
</td></tr>
<tr><td><code id="get_islandMeanFreqM_+3A_categorized_data">categorized_data</code></td>
<td>
<p>Logical defaulted to FALSE.
TRUE to skip redundant categorization when methylation states are represented as 0, 0.5, and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the mean frequency of methylated sites in the islands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
index_islands &lt;- c(1, 3)
data &lt;- list(
  list(c(0.5, 1, 0.5), c(0, 0.5, 1), c(1, 0, 0.5)), # tip 1
  list(c(0.5, 0.5, 0), c(1, 0.5, 0.5), c(0.5, 0.5, 1)) # tip 2
)
sample_n &lt;- 2
get_islandMeanFreqM(index_islands, data, sample_n, categorized_data = TRUE)

</code></pre>

<hr>
<h2 id='get_islandMeanFreqP'>Calculate the Mean Frequency of Partially Methylated Sites in Islands</h2><span id='topic+get_islandMeanFreqP'></span>

<h3>Description</h3>

<p>This function computes the mean frequency of partially methylated sites (with methylation state 0.5)
for the set of genomic structures identified as islands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_islandMeanFreqP(index_islands, data, sample_n, categorized_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_islandMeanFreqP_+3A_index_islands">index_islands</code></td>
<td>
<p>A vector containing the structural indices for islands.</p>
</td></tr>
<tr><td><code id="get_islandMeanFreqP_+3A_data">data</code></td>
<td>
<p>A list containing methylation states at tree tips for each genomic structure (island / non-island)
For a single tip: <code>data[[structure]]</code>.
For multiple tips: <code>data[[tip]][[structure]]</code>.
Each element contains the methylation states at the sites in a given tip and structure
represented as 0, 0.5 or 1 (for unmethylated, partially-methylated and methylated).
If methylation states are not represented as 0, 0.5, 1 they are categorized
as 0 when value equal or under 0.2
0.5 when value between 0.2 and 0.8
and 1 when value over 0.8.
For customized categorization thresholds use <code>categorize_siteMethSt</code></p>
</td></tr>
<tr><td><code id="get_islandMeanFreqP_+3A_sample_n">sample_n</code></td>
<td>
<p>The number of samples (tips) to process.</p>
</td></tr>
<tr><td><code id="get_islandMeanFreqP_+3A_categorized_data">categorized_data</code></td>
<td>
<p>Logical defaulted to FALSE.
TRUE to skip redundant categorization when methylation states are represented as 0, 0.5, and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the mean frequency of partially methylated sites in the islands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
index_islands &lt;- c(1, 3)
data &lt;- list(
  list(c(0.5, 1, 0.5), c(0, 0.5, 1), c(1, 0, 0.5)), # tip 1
  list(c(0.5, 0.5, 0), c(1, 0.5, 0.5), c(0.5, 0.5, 1)) # tip 2
)
sample_n &lt;- 2
get_islandMeanFreqP(index_islands, data, sample_n, categorized_data = TRUE)

</code></pre>

<hr>
<h2 id='get_islandSDFreqM'>Calculate the Mean Standard Deviation of Methylated Sites in Islands</h2><span id='topic+get_islandSDFreqM'></span>

<h3>Description</h3>

<p>This function computes the mean standard deviation of methylated sites
(with methylation state 1) for a set of genomic structures identified as islands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_islandSDFreqM(index_islands, data, sample_n, categorized_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_islandSDFreqM_+3A_index_islands">index_islands</code></td>
<td>
<p>A vector containing the structural indices for islands.</p>
</td></tr>
<tr><td><code id="get_islandSDFreqM_+3A_data">data</code></td>
<td>
<p>A list containing methylation states at tree tips for each genomic structure (island / non-island)
For a single tip: <code>data[[structure]]</code>.
For multiple tips: <code>data[[tip]][[structure]]</code>.
Each element contains the methylation states at the sites in a given tip and structure
represented as 0, 0.5 or 1 (for unmethylated, partially-methylated and methylated).
If methylation states are not represented as 0, 0.5, 1 they are categorized
as 0 when value equal or under 0.2
0.5 when value between 0.2 and 0.8
and 1 when value over 0.8.
For customized categorization thresholds use <code>categorize_siteMethSt</code></p>
</td></tr>
<tr><td><code id="get_islandSDFreqM_+3A_sample_n">sample_n</code></td>
<td>
<p>The number of tips (samples) to process.</p>
</td></tr>
<tr><td><code id="get_islandSDFreqM_+3A_categorized_data">categorized_data</code></td>
<td>
<p>Logical defaulted to FALSE.
TRUE to skip redundant categorization when methylation states are represented as 0, 0.5, and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the mean standard deviation of methylated sites in the islands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
index_islands &lt;- c(1, 3)
data &lt;- list(
  list(c(0.5, 1, 0.5), c(0, 0.5, 1), c(1, 0, 0.5)), # tip 1
  list(c(0.5, 0.5, 0), c(1, 0.5, 0.5), c(0.5, 0.5, 1)) # tip 2
)
sample_n &lt;- 2
get_islandSDFreqM(index_islands, data, sample_n, categorized_data = TRUE)

</code></pre>

<hr>
<h2 id='get_islandSDFreqP'>Calculate the Mean Standard Deviation of Partially Methylated Sites in Islands</h2><span id='topic+get_islandSDFreqP'></span>

<h3>Description</h3>

<p>This function computes the mean standard deviation of partially methylated sites
(with methylation state 0.5) for a set of genomic structures identified as islands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_islandSDFreqP(index_islands, data, sample_n, categorized_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_islandSDFreqP_+3A_index_islands">index_islands</code></td>
<td>
<p>A vector containing the structural indices for islands.</p>
</td></tr>
<tr><td><code id="get_islandSDFreqP_+3A_data">data</code></td>
<td>
<p>A list containing methylation states at tree tips for each genomic structure (island / non-island)
For a single tip: <code>data[[structure]]</code>.
For multiple tips: <code>data[[tip]][[structure]]</code>.
Each element contains the methylation states at the sites in a given tip and structure
represented as 0, 0.5 or 1 (for unmethylated, partially-methylated and methylated).
If methylation states are not represented as 0, 0.5, 1 they are categorized
as 0 when value equal or under 0.2
0.5 when value between 0.2 and 0.8
and 1 when value over 0.8.
For customized categorization thresholds use <code>categorize_siteMethSt</code></p>
</td></tr>
<tr><td><code id="get_islandSDFreqP_+3A_sample_n">sample_n</code></td>
<td>
<p>The number of samples (tips) to process.</p>
</td></tr>
<tr><td><code id="get_islandSDFreqP_+3A_categorized_data">categorized_data</code></td>
<td>
<p>Logical defaulted to FALSE.
TRUE to skip redundant categorization when methylation states are represented as 0, 0.5, and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the mean standard deviation of partially methylated sites in the islands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
index_islands &lt;- c(1, 3)
data &lt;- list(
  list(c(0.5, 1, 0.5), c(0, 0.5, 1), c(1, 0, 0.5)), # tip 1
  list(c(0.5, 0.5, 0), c(1, 0.5, 0.5), c(0.5, 0.5, 1)) # tip 2
)
sample_n &lt;- 2
get_islandSDFreqP(index_islands, data, sample_n, categorized_data = TRUE)

</code></pre>

<hr>
<h2 id='get_meanMeth_islands'>Compute the Mean Methylation of CpG Islands</h2><span id='topic+get_meanMeth_islands'></span>

<h3>Description</h3>

<p>This function calculates the mean methylation level for CpG islands across all tree tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_meanMeth_islands(index_islands, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_meanMeth_islands_+3A_index_islands">index_islands</code></td>
<td>
<p>A numeric vector specifying the indices of genomic structures corresponding to islands.</p>
</td></tr>
<tr><td><code id="get_meanMeth_islands_+3A_data">data</code></td>
<td>
<p>A list containing methylation states at tree tips for each genomic structure
(e.g., island/non-island). The data should be structured as <code>data[[tip]][[structure]]</code>,
where each tip has the same number of structures, and each structure has the same number of sites across tips.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list where each element corresponds to a tree tip and contains a numeric vector
representing the mean methylation levels for the indexed CpG islands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data setup

data &lt;- list(
  # Tip 1
  list(rep(1,10), rep(0,5), rep(1,8)),
  # Tip 2
  list(rep(1,10), rep(0.5,5), rep(0,8))
)

index_islands &lt;- c(1,3)

get_meanMeth_islands(index_islands, data)

</code></pre>

<hr>
<h2 id='get_nonislandMeanFreqM'>Calculate the Mean Frequency of Methylated Sites in Non-Islands</h2><span id='topic+get_nonislandMeanFreqM'></span>

<h3>Description</h3>

<p>This function computes the mean frequency of methylated sites (with methylation state 1)
for a set of structures identified as non-islands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nonislandMeanFreqM(
  index_nonislands,
  data,
  sample_n,
  categorized_data = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_nonislandMeanFreqM_+3A_index_nonislands">index_nonislands</code></td>
<td>
<p>A vector containing the structural indices for non-islands.</p>
</td></tr>
<tr><td><code id="get_nonislandMeanFreqM_+3A_data">data</code></td>
<td>
<p>A list containing methylation states at tree tips for each genomic structure (island / non-island)
For a single tip: <code>data[[structure]]</code>.
For multiple tips: <code>data[[tip]][[structure]]</code>.
Each element contains the methylation states at the sites in a given tip and structure
represented as 0, 0.5 or 1 (for unmethylated, partially-methylated and methylated).
If methylation states are not represented as 0, 0.5, 1 they are categorized
as 0 when value equal or under 0.2
0.5 when value between 0.2 and 0.8
and 1 when value over 0.8.
For customized categorization thresholds use <code>categorize_siteMethSt</code></p>
</td></tr>
<tr><td><code id="get_nonislandMeanFreqM_+3A_sample_n">sample_n</code></td>
<td>
<p>The number of samples (tips) to process.</p>
</td></tr>
<tr><td><code id="get_nonislandMeanFreqM_+3A_categorized_data">categorized_data</code></td>
<td>
<p>Logical defaulted to FALSE.
TRUE to skip redundant categorization when methylation states are represented as 0, 0.5, and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the mean frequency of methylated sites in the non-islands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
index_nonislands &lt;- c(1, 3)
data &lt;- list(
  list(c(1, 0, 1), c(0.5, 1, 1), c(1, 0, 0.5)), # tip 1
  list(c(1, 0.5, 1), c(0.5, 1, 1), c(1, 0.5, 0.5)) # tip 2
)
sample_n &lt;- 2
get_nonislandMeanFreqM(index_nonislands, data, sample_n, categorized_data = TRUE)

</code></pre>

<hr>
<h2 id='get_nonislandMeanFreqP'>Calculate the Mean Frequency of Partially Methylated Sites in Non-Islands</h2><span id='topic+get_nonislandMeanFreqP'></span>

<h3>Description</h3>

<p>This function computes the mean frequency of partially methylated sites (with methylation state 0.5)
for a set of genomic structures identified as non-islands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nonislandMeanFreqP(
  index_nonislands,
  data,
  sample_n,
  categorized_data = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_nonislandMeanFreqP_+3A_index_nonislands">index_nonislands</code></td>
<td>
<p>A vector containing the structural indices for non-islands.</p>
</td></tr>
<tr><td><code id="get_nonislandMeanFreqP_+3A_data">data</code></td>
<td>
<p>A list containing methylation states at tree tips for each genomic structure (island / non-island)
For a single tip: <code>data[[structure]]</code>.
For multiple tips: <code>data[[tip]][[structure]]</code>.
Each element contains the methylation states at the sites in a given tip and structure
represented as 0, 0.5 or 1 (for unmethylated, partially-methylated and methylated).
If methylation states are not represented as 0, 0.5, 1 they are categorized
as 0 when value equal or under 0.2
0.5 when value between 0.2 and 0.8
and 1 when value over 0.8.
For customized categorization thresholds use <code>categorize_siteMethSt</code></p>
</td></tr>
<tr><td><code id="get_nonislandMeanFreqP_+3A_sample_n">sample_n</code></td>
<td>
<p>The number of samples (tips) to process.</p>
</td></tr>
<tr><td><code id="get_nonislandMeanFreqP_+3A_categorized_data">categorized_data</code></td>
<td>
<p>Logical defaulted to FALSE.
TRUE to skip redundant categorization when methylation states are represented as 0, 0.5, and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the mean frequency of partially methylated sites in the non-islands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
index_nonislands &lt;- c(1, 3)
data &lt;- list(
  list(c(0.5, 1, 0.5), c(0, 0.5, 1), c(1, 0, 0.5)), # tip 1
  list(c(0.5, 0.5, 0), c(1, 0.5, 0.5), c(0.5, 0.5, 1)) # tip 2
)
sample_n &lt;- 2
get_nonislandMeanFreqP(index_nonislands, data, sample_n, categorized_data = TRUE)

</code></pre>

<hr>
<h2 id='get_nonislandSDFreqM'>Calculate the Mean Standard Deviation of Methylated Sites in Non-Islands</h2><span id='topic+get_nonislandSDFreqM'></span>

<h3>Description</h3>

<p>This function computes the mean standard deviation of methylated sites
(with methylation state 1) for a set of genomic structures identified as non-islands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nonislandSDFreqM(
  index_nonislands,
  data,
  sample_n,
  categorized_data = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_nonislandSDFreqM_+3A_index_nonislands">index_nonislands</code></td>
<td>
<p>A vector containing the structural indices for non-islands.</p>
</td></tr>
<tr><td><code id="get_nonislandSDFreqM_+3A_data">data</code></td>
<td>
<p>A list containing methylation states at tree tips for each genomic structure (island / non-island)
For a single tip: <code>data[[structure]]</code>.
For multiple tips: <code>data[[tip]][[structure]]</code>.
Each element contains the methylation states at the sites in a given tip and structure
represented as 0, 0.5 or 1 (for unmethylated, partially-methylated and methylated).
If methylation states are not represented as 0, 0.5, 1 they are categorized
as 0 when value equal or under 0.2
0.5 when value between 0.2 and 0.8
and 1 when value over 0.8.
For customized categorization thresholds use <code>categorize_siteMethSt</code></p>
</td></tr>
<tr><td><code id="get_nonislandSDFreqM_+3A_sample_n">sample_n</code></td>
<td>
<p>The number of tips (samples) to process.</p>
</td></tr>
<tr><td><code id="get_nonislandSDFreqM_+3A_categorized_data">categorized_data</code></td>
<td>
<p>Logical defaulted to FALSE.
TRUE to skip redundant categorization when methylation states are represented as 0, 0.5, and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the mean standard deviation of methylated sites in the non-islands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
index_nonislands &lt;- c(1, 3)
data &lt;- list(
  list(c(1, 1, 1), c(0, 1, 0.5), c(1, 0, 1)), # tip 1
  list(c(1, 0.5, 0), c(1, 1, 0.5), c(1, 1, 1)) # tip 2
)
sample_n &lt;- 2
get_nonislandSDFreqM(index_nonislands, data, sample_n, categorized_data = TRUE)

</code></pre>

<hr>
<h2 id='get_nonislandSDFreqP'>Calculate the Mean Standard Deviation of Partially Methylated Sites in Non-Islands</h2><span id='topic+get_nonislandSDFreqP'></span>

<h3>Description</h3>

<p>This function computes the mean standard deviation of partially methylated sites
(with methylation state 0.5) for a set of genomic structures identified as non-islands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nonislandSDFreqP(
  index_nonislands,
  data,
  sample_n,
  categorized_data = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_nonislandSDFreqP_+3A_index_nonislands">index_nonislands</code></td>
<td>
<p>A vector containing the structural indices for non-islands.</p>
</td></tr>
<tr><td><code id="get_nonislandSDFreqP_+3A_data">data</code></td>
<td>
<p>A list containing methylation states at tree tips for each genomic structure (island / non-island)
For a single tip: <code>data[[structure]]</code>.
For multiple tips: <code>data[[tip]][[structure]]</code>.
Each element contains the methylation states at the sites in a given tip and structure
represented as 0, 0.5 or 1 (for unmethylated, partially-methylated and methylated).
If methylation states are not represented as 0, 0.5, 1 they are categorized
as 0 when value equal or under 0.2
0.5 when value between 0.2 and 0.8
and 1 when value over 0.8.
For customized categorization thresholds use <code>categorize_siteMethSt</code></p>
</td></tr>
<tr><td><code id="get_nonislandSDFreqP_+3A_sample_n">sample_n</code></td>
<td>
<p>The number of samples (tips) to process.</p>
</td></tr>
<tr><td><code id="get_nonislandSDFreqP_+3A_categorized_data">categorized_data</code></td>
<td>
<p>Logical defaulted to FALSE.
TRUE to skip redundant categorization when methylation states are represented as 0, 0.5, and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the mean standard deviation of partially methylated sites in the non-islands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
index_nonislands &lt;- c(1, 3)
data &lt;- list(
  list(c(0.5, 1, 0.5), c(0, 0.5, 1), c(1, 0, 0.5)), # tip 1
  list(c(0.5, 0.5, 0), c(1, 0.5, 0.5), c(0.5, 0.5, 1)) # tip 2
)
sample_n &lt;- 2
get_nonislandSDFreqP(index_nonislands, data, sample_n, categorized_data = TRUE)

</code></pre>

<hr>
<h2 id='get_parameterValues'>Get Default Parameter Values</h2><span id='topic+get_parameterValues'></span>

<h3>Description</h3>

<p>This function retrieves parameter values for the DNA methylation simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_parameterValues(rootData = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_parameterValues_+3A_rootdata">rootData</code></td>
<td>
<p>NULL to return default parameter values. For data parameter values, provide rootData as the output of simulate_initialData()$data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function called without arguments returns default parameter values.
When rootData (as $data output of simulate_initialData()) is given, it returns data parameter values.
</p>


<h3>Value</h3>

<p>A data frame containing default parameter values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get default parameter values
default_values &lt;- get_parameterValues()

# Get parameter values of simulate_initialData() output
custom_params &lt;- get_parameterValues()
infoStr &lt;- data.frame(n = c(5, 10), globalState = c("M", "U"))
rootData &lt;- simulate_initialData(infoStr = infoStr, params = custom_params)$data
rootData_paramValues &lt;- get_parameterValues(rootData = rootData)

</code></pre>

<hr>
<h2 id='get_siteFChange_cherry'>Compute Site Frequency of Methylation Changes per Cherry</h2><span id='topic+get_siteFChange_cherry'></span>

<h3>Description</h3>

<p>This function calculates the total frequency of methylation differences (both full and half changes)
for each genomic structure for each cherry in a phylogenetic tree.
A cherry is a pair of leaf nodes (also called tips or terminal nodes)
in a phylogenetic tree that share a direct common ancestor.
In other words, if two leaves are connected to the same internal node and no other leaves
are connected to that internal node, they form a cherry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_siteFChange_cherry(tree, data, categorized_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_siteFChange_cherry_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree in Newick format or a phylo object from the ape package. The function ensures
the tree has a valid structure and at least two tips.</p>
</td></tr>
<tr><td><code id="get_siteFChange_cherry_+3A_data">data</code></td>
<td>
<p>A list containing methylation states at tree tips for each genomic structure (e.g., island/non-island).
The data should be structured as <code>data[[tip]][[structure]]</code>, where each structure has the same number of sites across tips.
The input data must be prefiltered to ensure CpG sites are represented consistently across different tips.
Each element contains the methylation states at the sites in a given tip and structure
represented as 0, 0.5 or 1 (for unmethylated, partially-methylated and methylated).
If methylation states are not represented as 0, 0.5, 1 they are categorized
as 0 when value equal or under 0.2
0.5 when value between 0.2 and 0.8
and 1 when value over 0.8.
For customized categorization thresholds use <code>categorize_siteMethSt</code></p>
</td></tr>
<tr><td><code id="get_siteFChange_cherry_+3A_categorized_data">categorized_data</code></td>
<td>
<p>Logical defaulted to FALSE.
TRUE to skip redundant categorization when methylation states are represented as 0, 0.5, and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first verifies that <code>tree</code> and <code>data</code> have valid structures and the minimum number of tips.
It then extracts per-cherry methylation differences using <code>freqSites_cherryMethDiff</code>, handling potential errors.
Finally, it aggregates the full and half methylation differences for each genomic structure at each cherry.
</p>


<h3>Value</h3>

<p>A data frame with one row per cherry, containing the following columns:
</p>

<dl>
<dt>tip_names</dt><dd><p>A character string representing the names of the two tips in the cherry, concatenated with a hyphen.</p>
</dd>
<dt>tip_indices</dt><dd><p>A character string representing the indices of the two tips in the cherry, concatenated with a hyphen.</p>
</dd>
<dt>dist</dt><dd><p>A numeric value representing the sum of the branch distances between the cherry tips.</p>
</dd>
<dt>One column for each structure named with the structure number</dt><dd><p>A numeric value representing the total frequency of methylation changes (both full and half) for the given structure.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Example data setup

data &lt;- list(
list(rep(1,10), rep(0,5), rep(1,8)),
list(rep(1,10), rep(0.5,5), rep(0,8)),
list(rep(1,10), rep(0.5,5), rep(0,8)),
list(c(rep(0,5), rep(0.5, 5)), c(0, 0, 1, 1, 1), c(0.5, 1, rep(0, 6))))

tree &lt;- "((a:1.5,b:1.5):2,(c:2,d:2):1.5);"

get_siteFChange_cherry(tree, data, categorized_data = TRUE)

</code></pre>

<hr>
<h2 id='mean_CherryFreqsChange_i'>Mean Number of Significant Methylation Frequency Changes per Island in Cherries</h2><span id='topic+mean_CherryFreqsChange_i'></span>

<h3>Description</h3>

<p>Computes the mean number of significant changes per island in phylogenetic tree cherries,
based on a specified p-value threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_CherryFreqsChange_i(
  data,
  categorized_data = FALSE,
  index_islands,
  tree,
  pValue_threshold
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean_CherryFreqsChange_i_+3A_data">data</code></td>
<td>
<p>A list containing methylation states at tree tips for each genomic structure (e.g., island/non-island).
The data should be structured as <code>data[[tip]][[structure]]</code>, where each structure has the same number of sites across tips.
The input data must be prefiltered to ensure CpG sites are represented consistently across different tips.
Each element contains the methylation states at the sites in a given tip and structure
represented as 0, 0.5 or 1 (for unmethylated, partially-methylated and methylated).
If methylation states are not represented as 0, 0.5, 1 they are categorized
as 0 when value equal or under 0.2
0.5 when value between 0.2 and 0.8
and 1 when value over 0.8.
For customized categorization thresholds use <code>categorize_siteMethSt</code></p>
</td></tr>
<tr><td><code id="mean_CherryFreqsChange_i_+3A_categorized_data">categorized_data</code></td>
<td>
<p>Logical defaulted to FALSE.
TRUE to skip redundant categorization when methylation states are represented as 0, 0.5, and 1.</p>
</td></tr>
<tr><td><code id="mean_CherryFreqsChange_i_+3A_index_islands">index_islands</code></td>
<td>
<p>A numeric vector specifying the indices of islands to analyze.</p>
</td></tr>
<tr><td><code id="mean_CherryFreqsChange_i_+3A_tree">tree</code></td>
<td>
<p>A rooted binary tree in Newick format (character string) or as an <code>ape</code> phylo object.</p>
</td></tr>
<tr><td><code id="mean_CherryFreqsChange_i_+3A_pvalue_threshold">pValue_threshold</code></td>
<td>
<p>A numeric value between 0 and 1 that serves as the threshold for statistical significance in
the chi-squared test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses <code>simulate.p.value = TRUE</code> in <code><a href="stats.html#topic+chisq.test">chisq.test</a></code>
to compute the p-value via Monte Carlo simulation to improve reliability
regardless of whether the expected frequencies meet the assumptions of the chi-squared test
(i.e., expected counts of at least 5 in each category).
</p>


<h3>Value</h3>

<p>A data frame containing the same information as <code>pValue_CherryFreqsChange_i</code>,
but with additional columns indicating whether p-values are below the threshold (significant changes)
and the mean frequency of significant changes per island.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- "((d:1,e:1):2,a:2);"
data &lt;- list(
  #Tip 1
  list(c(rep(1,9), rep(0,1)), 
       c(rep(0,9), 1), 
       c(rep(0,9), rep(0.5,1))), 
  #Tip 2
  list(c(rep(0,9), rep(0.5,1)), 
       c(rep(0.5,9), 1), 
       c(rep(1,9), rep(0,1))), 
  #Tip 3
  list(c(rep(1,9), rep(0.5,1)), 
       c(rep(0.5,9), 1), 
       c(rep(0,9), rep(0.5,1)))) 

index_islands &lt;- c(1,3)
mean_CherryFreqsChange_i(data, categorized_data = TRUE,
                          index_islands, tree, pValue_threshold = 0.05)

</code></pre>

<hr>
<h2 id='mean_TreeFreqsChange_i'>Mean Number of Significant Frequency Changes per Island Across all Tree Tips</h2><span id='topic+mean_TreeFreqsChange_i'></span>

<h3>Description</h3>

<p>This function analyzes the frequency changes of methylation states (unmethylated, partially methylated, methylated)
across tree tips for a given set of islands. It performs a chi-squared test for each island to check for significant
changes in frequencies across tips and returns the proportion of islands showing significant changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_TreeFreqsChange_i(
  tree,
  data,
  categorized_data = FALSE,
  index_islands,
  pValue_threshold,
  testing = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean_TreeFreqsChange_i_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree object, typically of class <code>phylo</code>, containing tip labels.</p>
</td></tr>
<tr><td><code id="mean_TreeFreqsChange_i_+3A_data">data</code></td>
<td>
<p>A list containing methylation states at tree tips for each genomic structure (e.g., island/non-island).
The data should be structured as <code>data[[tip]][[structure]]</code>, where each structure has the same number of sites across tips.
The input data must be prefiltered to ensure CpG sites are represented consistently across different tips.
Each element contains the methylation states at the sites in a given tip and structure
represented as 0, 0.5 or 1 (for unmethylated, partially-methylated and methylated).
If methylation states are not represented as 0, 0.5, 1 they are categorized
as 0 when value equal or under 0.2
0.5 when value between 0.2 and 0.8
and 1 when value over 0.8.
For customized categorization thresholds use <code>categorize_siteMethSt</code></p>
</td></tr>
<tr><td><code id="mean_TreeFreqsChange_i_+3A_categorized_data">categorized_data</code></td>
<td>
<p>Logical defaulted to FALSE.
TRUE to skip redundant categorization when methylation states are represented as 0, 0.5, and 1.</p>
</td></tr>
<tr><td><code id="mean_TreeFreqsChange_i_+3A_index_islands">index_islands</code></td>
<td>
<p>A vector of indices of genomic structures corresponding to islands in data.</p>
</td></tr>
<tr><td><code id="mean_TreeFreqsChange_i_+3A_pvalue_threshold">pValue_threshold</code></td>
<td>
<p>A numeric value between 0 and 1 that serves as the threshold for statistical significance in
the chi-squared test.</p>
</td></tr>
<tr><td><code id="mean_TreeFreqsChange_i_+3A_testing">testing</code></td>
<td>
<p>Logical defaulted to FALSE. TRUE for testing output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses <code>simulate.p.value = TRUE</code> in <code><a href="stats.html#topic+chisq.test">chisq.test</a></code>
to compute the p-value via Monte Carlo simulation to improve reliability
regardless of whether the expected frequencies meet the assumptions of the chi-squared test
(i.e., expected counts of at least 5 in each category).
</p>
<p>Throws errors if:
</p>

<ul>
<li><p> The <code>tree</code> is not valid.
</p>
</li>
<li> <p><code>data</code> is not structured correctly across tips.
</p>
</li>
<li> <p><code>index_islands</code> is empty.
</p>
</li>
<li> <p><code>pValue_threshold</code> is not between 0 and 1.
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric value representing the mean proportion of islands with significant frequency changes across tips.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example of usage:

tree &lt;- "((d:1,e:1):2,a:2);"

data &lt;- list(
  #Tip 1
  list(c(rep(1,9), rep(0,1)), 
       c(rep(0,9), 1), 
       c(rep(0,9), rep(0.5,1))), 
  #Tip 2
  list(c(rep(1,9), rep(0.5,1)), 
       c(rep(0.5,9), 1), 
       c(rep(1,9), rep(0,1))), 
  #Tip 3
  list(c(rep(1,9), rep(0.5,1)), 
       c(rep(0.5,9), 1), 
       c(rep(0,9), rep(0.5,1)))) 
       
index_islands &lt;- c(1,3)


mean_TreeFreqsChange_i(tree, 
                       data, categorized_data = TRUE,
                       index_islands, 
                       pValue_threshold = 0.05)

</code></pre>

<hr>
<h2 id='MeanSiteFChange_cherry'>Compute the Mean Site Frequency of Methylation Changes per Cherry</h2><span id='topic+MeanSiteFChange_cherry'></span>

<h3>Description</h3>

<p>This function calculates the weighted mean frequency of methylation changes at island and non-island genomic structures
for each cherry in a phylogenetic tree. A cherry is a pair of leaf nodes (also called tips or terminal nodes)
in a phylogenetic tree that share a direct common ancestor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MeanSiteFChange_cherry(
  data,
  categorized_data = FALSE,
  tree,
  index_islands,
  index_nonislands
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MeanSiteFChange_cherry_+3A_data">data</code></td>
<td>
<p>A list containing methylation states at tree tips for each genomic structure (e.g., island/non-island).
The data should be structured as <code>data[[tip]][[structure]]</code>, where each structure has the same number of sites across tips.
The input data must be prefiltered to ensure CpG sites are represented consistently across different tips.
Each element contains the methylation states at the sites in a given tip and structure
represented as 0, 0.5 or 1 (for unmethylated, partially-methylated and methylated).
If methylation states are not represented as 0, 0.5, 1 they are categorized
as 0 when value equal or under 0.2
0.5 when value between 0.2 and 0.8
and 1 when value over 0.8.
For customized categorization thresholds use <code>categorize_siteMethSt</code></p>
</td></tr>
<tr><td><code id="MeanSiteFChange_cherry_+3A_categorized_data">categorized_data</code></td>
<td>
<p>Logical defaulted to FALSE.
TRUE to skip redundant categorization when methylation states are represented as 0, 0.5, and 1.</p>
</td></tr>
<tr><td><code id="MeanSiteFChange_cherry_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree in Newick format or a <code>phylo</code> object from the <code>ape</code> package.
The function ensures the tree has a valid structure and at least two tips.</p>
</td></tr>
<tr><td><code id="MeanSiteFChange_cherry_+3A_index_islands">index_islands</code></td>
<td>
<p>A numeric vector specifying the indices of genomic structures corresponding to islands.</p>
</td></tr>
<tr><td><code id="MeanSiteFChange_cherry_+3A_index_nonislands">index_nonislands</code></td>
<td>
<p>A numeric vector specifying the indices of genomic structures corresponding to non-islands.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first validates the tree and the input data structure. It then computes the
per-cherry frequency of sites with different methylation states using <code>get_siteFChange_cherry</code>.
The indices provided for islands and non-islands are checked for validity using <code>validate_structureIndices</code>.
Finally, the function calculates the weighted mean site frequency of methylation changes for each cherry,
separately for islands and non-islands.
</p>


<h3>Value</h3>

<p>A data frame with one row per cherry, containing the following columns:
</p>

<dl>
<dt>tip_names</dt><dd><p>A character string representing the names of the two tips in the cherry, concatenated with a hyphen.</p>
</dd>
<dt>tip_indices</dt><dd><p>A character string representing the indices of the two tips in the cherry, concatenated with a hyphen.</p>
</dd>
<dt>dist</dt><dd><p>A numeric value representing the sum of the branch distances between the cherry tips.</p>
</dd>
<dt>nonisland_meanFChange</dt><dd><p>A numeric value representing the weighted mean frequency of methylation changes in non-island structures.</p>
</dd>
<dt>island_meanFChange</dt><dd><p>A numeric value representing the weighted mean frequency of methylation changes in island structures.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Example data setup
data &lt;- list(
list(rep(1,10), rep(0,5), rep(1,8)), # Tip a
list(rep(1,10), rep(0.5,5), rep(0,8)), # Tip b
list(rep(1,10), rep(0.5,5), rep(0,8)), # Tip c
list(c(rep(0,5), rep(0.5, 5)), c(0, 0, 1, 1, 1), c(0.5, 1, rep(0, 6)))) # Tip d

tree &lt;- "((a:1.5,b:1.5):2,(c:2,d:2):1.5);"

index_islands &lt;- c(1,3)
index_nonislands &lt;- c(2)

MeanSiteFChange_cherry(data = data, 
                       categorized_data = TRUE, 
                       tree = tree, 
                       index_islands = index_islands,
                       index_nonislands = index_nonislands)

</code></pre>

<hr>
<h2 id='pValue_CherryFreqsChange_i'>Compute p-Values for Methylation Frequency Changes in Cherries</h2><span id='topic+pValue_CherryFreqsChange_i'></span>

<h3>Description</h3>

<p>Calculates p-values for changes in methylation frequency between pairs of cherry tips in a phylogenetic tree.
A cherry is a pair of leaf nodes (also called tips or terminal nodes)
in a phylogenetic tree that share a direct common ancestor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pValue_CherryFreqsChange_i(
  data,
  categorized_data = FALSE,
  index_islands,
  tree,
  input_control = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pValue_CherryFreqsChange_i_+3A_data">data</code></td>
<td>
<p>A list containing methylation states at tree tips for each genomic structure (e.g., island/non-island).
The data should be structured as <code>data[[tip]][[structure]]</code>, where each structure has the same number of sites across tips.
The input data must be prefiltered to ensure CpG sites are represented consistently across different tips.
Each element contains the methylation states at the sites in a given tip and structure
represented as 0, 0.5 or 1 (for unmethylated, partially-methylated and methylated).
If methylation states are not represented as 0, 0.5, 1 they are categorized
as 0 when value equal or under 0.2
0.5 when value between 0.2 and 0.8
and 1 when value over 0.8.
For customized categorization thresholds use <code>categorize_siteMethSt</code></p>
</td></tr>
<tr><td><code id="pValue_CherryFreqsChange_i_+3A_categorized_data">categorized_data</code></td>
<td>
<p>Logical defaulted to FALSE.
TRUE to skip redundant categorization when methylation states are represented as 0, 0.5, and 1.</p>
</td></tr>
<tr><td><code id="pValue_CherryFreqsChange_i_+3A_index_islands">index_islands</code></td>
<td>
<p>A numeric vector specifying the indices of islands to analyze.</p>
</td></tr>
<tr><td><code id="pValue_CherryFreqsChange_i_+3A_tree">tree</code></td>
<td>
<p>A rooted binary tree in Newick format (character string) or as an <code>ape</code> phylo object with minimum 2 tips.</p>
</td></tr>
<tr><td><code id="pValue_CherryFreqsChange_i_+3A_input_control">input_control</code></td>
<td>
<p>Logical; if <code>TRUE</code>, validates input.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses <code>simulate.p.value = TRUE</code> in <code><a href="stats.html#topic+chisq.test">chisq.test</a></code>
to compute the p-value via Monte Carlo simulation to improve reliability
regardless of whether the expected frequencies meet the assumptions of the chi-squared test
(i.e., expected counts of at least 5 in each category).
</p>


<h3>Value</h3>

<p>A data frame containing tip pair information (first tip name, second tip name, first tip index, second tip index, distance)
and one column per island with the p-values from the chi-squared tests.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example with hypothetical tree and data structure

tree &lt;- "((d:1,e:1):2,a:2);"
data &lt;- list(
  #Tip 1
  list(c(rep(1,9), rep(0,1)), 
       c(rep(0,9), 1), 
       c(rep(0,9), rep(0.5,1))), 
  #Tip 2
  list(c(rep(0,9), rep(0.5,1)), 
       c(rep(0.5,9), 1), 
       c(rep(1,9), rep(0,1))), 
  #Tip 3
  list(c(rep(1,9), rep(0.5,1)), 
       c(rep(0.5,9), 1), 
       c(rep(0,9), rep(0.5,1)))) 

index_islands &lt;- c(1,3)

pValue_CherryFreqsChange_i(data, categorized_data = TRUE, index_islands, tree)

</code></pre>

<hr>
<h2 id='simulate_evolData'>Simulate Data Evolution along a Tree</h2><span id='topic+simulate_evolData'></span>

<h3>Description</h3>

<p>This function simulates methylation data evolution along a tree. Either by simulating data at the root of the provided evolutionary tree
(if infoStr is given) or by using pre-existing data at the root (if rootData is given) and letting it evolve along the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_evolData(
  infoStr = NULL,
  rootData = NULL,
  tree = NULL,
  params = NULL,
  dt = 0.01,
  CFTP = FALSE,
  CFTP_step_limit = 327680000,
  n_rep = 1,
  only_tip = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_evolData_+3A_infostr">infoStr</code></td>
<td>
<p>A data frame containing columns 'n' for the number of sites, and 'globalState' for the favoured global methylation state.
If customized initial equilibrium frequencies are given, it also contains columns 'u_eqFreq', 'p_eqFreq', and 'm_eqFreq'
with the equilibrium frequency values for unmethylated, partially methylated, and methylated.</p>
</td></tr>
<tr><td><code id="simulate_evolData_+3A_rootdata">rootData</code></td>
<td>
<p>The output of the simulate_initialData()$data function. It represents the initial data at the root of the evolutionary tree.</p>
</td></tr>
<tr><td><code id="simulate_evolData_+3A_tree">tree</code></td>
<td>
<p>A string in Newick format representing the evolutionary tree.</p>
</td></tr>
<tr><td><code id="simulate_evolData_+3A_params">params</code></td>
<td>
<p>Optional data frame with specific parameter values.
Structure as in get_parameterValues() output. If not provided, default values will be used.</p>
</td></tr>
<tr><td><code id="simulate_evolData_+3A_dt">dt</code></td>
<td>
<p>Length of time step for Gillespie's Tau-Leap Approximation (default is 0.01).</p>
</td></tr>
<tr><td><code id="simulate_evolData_+3A_cftp">CFTP</code></td>
<td>
<p>Default FALSE. TRUE for calling cftp algorithm to set root state according to model equilibrium (Note that current implementation neglects IWE process).</p>
</td></tr>
<tr><td><code id="simulate_evolData_+3A_cftp_step_limit">CFTP_step_limit</code></td>
<td>
<p>when CFTP = TRUE, maximum number of steps before applying an approximation method
(default 327680000 corresponding to size of CFTP info of approx 6.1 GB).</p>
</td></tr>
<tr><td><code id="simulate_evolData_+3A_n_rep">n_rep</code></td>
<td>
<p>Number of replicates to simulate (default is 1).</p>
</td></tr>
<tr><td><code id="simulate_evolData_+3A_only_tip">only_tip</code></td>
<td>
<p>Logical indicating whether to extract data only for tips (default is TRUE, FALSE to extract the information for all the tree branches).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the parameters used (<code>$params</code>), the length of the time step used for the Gillespie's tau-leap approximation (<code>$dt</code>, default 0.01), the tree used (<code>$tree</code>).
simulated data and the simulated data (<code>$data</code>). In <code>$data</code>, each list element corresponds to a simulation replicate.
</p>

<ul>
<li><p> If only_tip is TRUE: In <code>$data</code>, each list element corresponds to a simulation replicate.
Each replicate includes one list per tree tip, each containing:
</p>

<ul>
<li><p> The name of each tip in the simulated tree (e.g. replicate 2, tip 1: <code>$data[[2]][[1]]$name</code>).
</p>
</li>
<li><p> A list with the sequence of methylation states for each tip-specific structure (e.g. replicate 1, tip 2, 3rd structure: <code>$data[[1]][[2]]$seq[[3]]</code>.
The methylation states are encoded as 0 for unmethylated, 0.5 for partially methylated, and 1 for methylated.
</p>
</li></ul>

</li>
<li><p> If only_tip is FALSE, <code>$data</code> contains 2 lists:
</p>

<ul>
<li> <p><code>$data$branchInTree</code>: a list in which each element contains the information of the relationship with other branches:
</p>

<ul>
<li><p> Index of the parent branch (e.g. branch 2): <code>$data$branchInTree[[2]]$parent_index</code>)
</p>
</li>
<li><p> Index(es) of the offspring branch(es) (e.g. branch 1 (root)): <code>$data$branchInTree[[1]]$offspring_index</code>)
</p>
</li></ul>

</li>
<li> <p><code>$data$sim_data</code>: A list containing simulated data. Each list element corresponds to a simulation replicate.
Each replicate includes one list per tree branch, each containing:
</p>

<ul>
<li><p> The name of each branch in the simulated tree. It's NULL for the tree root and inner nodes, and the name of the tips for the tree tips.
(e.g. replicate 2, branch 1: <code>$data$sim_data[[2]][[1]]$name</code>)
</p>
</li>
<li><p> Information of IWE events on that branch. It's NULL for the tree root and FALSE for the branches in which no IWE event was sampled,
and a list containing <code>$islands</code> with the index(ces) of the island structure(s) that went through the IWE event and <code>$times</code>
for the branch time point(s ) in which the IWE was sampled.
(e.g. replicate 1, branch 3: <code>$data$sim_data[[1]][[3]]$IWE</code>)
</p>
</li>
<li><p> A list with the sequence of methylation states for each structure (the index of the list corresponds to the index
of the structures). The methylation states are encoded as 0 for unmethylated, 0.5 for partially methylated, and 1 for methylated.
(e.g. replicate 3, branch 2, structure 1: <code>$data$sim_data[[3]][[2]]$seq[[1]]</code>)
</p>
</li>
<li><p> A list with the methylation equilibrium frequencies for each structure (the index of the list corresponds to the index
of the structures). Each structure has a vector with 3 values, the first one corresponding to the frequency of unmethylated,
the second one to the frequency of partially methylated, and the third one to the frequency of methylated CpGs.
(e.g. replicate 3, branch 2, structure 1: <code>$data$sim_data[[3]][[2]]$eqFreqs[[1]]</code>)
</p>
</li></ul>

</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example data
infoStr &lt;- data.frame(n = c(10, 100, 10), globalState = c("M", "U", "M"))

# Simulate data evolution along a tree with default parameters
simulate_evolData(infoStr = infoStr, tree = "(A:0.1,B:0.1);")

# Simulate data evolution along a tree with custom parameters
custom_params &lt;- get_parameterValues()
custom_params$iota &lt;- 0.5
simulate_evolData(infoStr = infoStr, tree = "(A:0.1,B:0.1);", params = custom_params)

</code></pre>

<hr>
<h2 id='simulate_initialData'>Simulate Initial Data</h2><span id='topic+simulate_initialData'></span>

<h3>Description</h3>

<p>This function simulates initial data based on the provided information and parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_initialData(
  infoStr,
  params = NULL,
  CFTP = FALSE,
  CFTP_step_limit = 327680000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_initialData_+3A_infostr">infoStr</code></td>
<td>
<p>A data frame containing columns 'n' for the number of sites, and 'globalState' for the favoured global methylation state.
If customized equilibrium frequencies are given, it also contains columns 'u_eqFreq', 'p_eqFreq' and 'm_eqFreq'
with the equilibrium frequency values for unmethylated, partially methylated and methylated.</p>
</td></tr>
<tr><td><code id="simulate_initialData_+3A_params">params</code></td>
<td>
<p>Optional data frame with specific parameter values.</p>
</td></tr>
<tr><td><code id="simulate_initialData_+3A_cftp">CFTP</code></td>
<td>
<p>Default FALSE. TRUE for calling cftp algorithm to set root state according to model equilibrium (Note that current implementation neglects IWE process).
Structure as in get_parameterValues() output. If not provided, default values will be used.</p>
</td></tr>
<tr><td><code id="simulate_initialData_+3A_cftp_step_limit">CFTP_step_limit</code></td>
<td>
<p>when CFTP = TRUE, maximum number of steps before applying an approximation method
(default 327680000 corresponding to size of CFTP info of approx 6.1 GB).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs several checks on the input data and parameters
to ensure they meet the required criteria and simulates DNA methylation data.
</p>


<h3>Value</h3>

<p>A list containing the simulated data ($data) and parameters ($params).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data
infoStr &lt;- data.frame(n = c(10, 100, 10), globalState = c("M", "U", "M"))

# Simulate initial data  with default parameters
simulate_initialData(infoStr = infoStr)

# Simulate data evolution along a tree with custom parameters
custom_params &lt;- get_parameterValues()
custom_params$iota &lt;- 0.5
simulate_initialData(infoStr = infoStr, params = custom_params)

</code></pre>

<hr>
<h2 id='singleStructureGenerator'>singleStructureGenerator</h2><span id='topic+singleStructureGenerator'></span>

<h3>Description</h3>

<p>an R6 class representing a single genomic structure
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>testing_output</code></dt><dd><p>Public attribute: Testing output for initialize</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-singleStructureGenerator-init_neighbSt"><code>singleStructureGenerator$init_neighbSt()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-initialize_ratetree"><code>singleStructureGenerator$initialize_ratetree()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-new"><code>singleStructureGenerator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-set_myCombiStructure"><code>singleStructureGenerator$set_myCombiStructure()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_seq"><code>singleStructureGenerator$get_seq()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_seqFirstPos"><code>singleStructureGenerator$get_seqFirstPos()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_seq2ndPos"><code>singleStructureGenerator$get_seq2ndPos()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_seqLastPos"><code>singleStructureGenerator$get_seqLastPos()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_seq2ndButLastPos"><code>singleStructureGenerator$get_seq2ndButLastPos()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_combiStructure_index"><code>singleStructureGenerator$get_combiStructure_index()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-update_interStr_firstNeighbSt"><code>singleStructureGenerator$update_interStr_firstNeighbSt()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-update_interStr_lastNeighbSt"><code>singleStructureGenerator$update_interStr_lastNeighbSt()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_eqFreqs"><code>singleStructureGenerator$get_eqFreqs()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-SSE_evol"><code>singleStructureGenerator$SSE_evol()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_transMat"><code>singleStructureGenerator$get_transMat()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-IWE_evol"><code>singleStructureGenerator$IWE_evol()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_alpha_pI"><code>singleStructureGenerator$get_alpha_pI()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_beta_pI"><code>singleStructureGenerator$get_beta_pI()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_alpha_mI"><code>singleStructureGenerator$get_alpha_mI()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_beta_mI"><code>singleStructureGenerator$get_beta_mI()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_alpha_pNI"><code>singleStructureGenerator$get_alpha_pNI()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_beta_pNI"><code>singleStructureGenerator$get_beta_pNI()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_alpha_mNI"><code>singleStructureGenerator$get_alpha_mNI()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_beta_mNI"><code>singleStructureGenerator$get_beta_mNI()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_alpha_Ri"><code>singleStructureGenerator$get_alpha_Ri()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_iota"><code>singleStructureGenerator$get_iota()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_Ri_values"><code>singleStructureGenerator$get_Ri_values()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_Q"><code>singleStructureGenerator$get_Q()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_siteR"><code>singleStructureGenerator$get_siteR()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_neighbSt"><code>singleStructureGenerator$get_neighbSt()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-update_ratetree_otherStr"><code>singleStructureGenerator$update_ratetree_otherStr()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_Qi"><code>singleStructureGenerator$get_Qi()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_seqSt_leftneighb"><code>singleStructureGenerator$get_seqSt_leftneighb()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-get_seqSt_rightneighb"><code>singleStructureGenerator$get_seqSt_rightneighb()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-cftp_all_equal"><code>singleStructureGenerator$cftp_all_equal()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-set_seqSt_update_neighbSt"><code>singleStructureGenerator$set_seqSt_update_neighbSt()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-reset_seq"><code>singleStructureGenerator$reset_seq()</code></a>
</p>
</li>
<li> <p><a href="#method-singleStructureGenerator-clone"><code>singleStructureGenerator$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-singleStructureGenerator-init_neighbSt"></a>



<h4>Method <code>init_neighbSt()</code></h4>

<p>Public method: Initialization of $neighbSt
</p>
<p>This fuction initiates each CpG position $neighbSt as encoded in $mapNeighbSt_matrix
</p>
<p>It uses $update_neighbSt which updates for each sequence index, the neighbSt of left and right neighbors
This means that it updates position 2, then 1 and 3, then 2 and 4..
Therefore, if the combiStructure instance has several singleStr instances within and the first has length 1,
the $neighbSt of that position of the first singleStr instance is initialized when the method is called from the second singleStr instance
</p>
<p>Positions at the edge of the entire simulated sequence use
their only neighbor as both neighbors.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$init_neighbSt()</pre></div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-singleStructureGenerator-initialize_ratetree"></a>



<h4>Method <code>initialize_ratetree()</code></h4>

<p>Public method: Initialization of $ratetree
</p>
<p>This function initializes $ratetree
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$initialize_ratetree()</pre></div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-singleStructureGenerator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new singleStructureGenerator object.
</p>
<p>Note that this object is typically generated withing a combiStructureGenerator object.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$new(
  globalState,
  n,
  eqFreqs = NULL,
  combiStr = NULL,
  combiStr_index = NULL,
  params = NULL,
  testing = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>globalState</code></dt><dd><p>Character. Structure's favored global state: &quot;M&quot; for methylated (island structures) / &quot;U&quot; for unmethylated (non-island structures).</p>
</dd>
<dt><code>n</code></dt><dd><p>Numerical Value. Number of CpG positions</p>
</dd>
<dt><code>eqFreqs</code></dt><dd><p>Default NULL. When given: numerical vector with structure's methylation state equilibrium frequencies (for unmethylated, partially methylated and methylated)</p>
</dd>
<dt><code>combiStr</code></dt><dd><p>Default NULL. When initiated from combiStructureGenerator: object of class combiStructureGenerator containing it</p>
</dd>
<dt><code>combiStr_index</code></dt><dd><p>Default NULL. When initiated from combiStructureGenerator: index in Object of class combiStructureGenerator</p>
</dd>
<dt><code>params</code></dt><dd><p>Default NULL. When given: data frame containing model parameters</p>
</dd>
<dt><code>testing</code></dt><dd><p>Default FALSE. TRUE for writing in public field of new instance $testing_output</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>singleStructureGenerator</code> object.
</p>


<hr>
<a id="method-singleStructureGenerator-set_myCombiStructure"></a>



<h4>Method <code>set_myCombiStructure()</code></h4>

<p>Public method: Set my_combiStructure. Assigns given combi instance to private field my_combiStructure
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$set_myCombiStructure(combi)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>combi</code></dt><dd><p>instance of combiStructureGenerator</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-singleStructureGenerator-get_seq"></a>



<h4>Method <code>get_seq()</code></h4>

<p>Public method: Get object's methylation state sequence
</p>
<p>Encoded with 1 for unmethylated, 2 for partially methylated and 3 for methylated
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_seq()</pre></div>



<h5>Returns</h5>

<p>vector with equilibrium frequencies of unmethylated, partially methylated and methylated
</p>


<hr>
<a id="method-singleStructureGenerator-get_seqFirstPos"></a>



<h4>Method <code>get_seqFirstPos()</code></h4>

<p>Public method: Get first sequence position methylation state
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_seqFirstPos()</pre></div>



<h5>Returns</h5>

<p>numerical encoding of first position's methylation state
</p>


<hr>
<a id="method-singleStructureGenerator-get_seq2ndPos"></a>



<h4>Method <code>get_seq2ndPos()</code></h4>

<p>Public method: Get second sequence position methylation state
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_seq2ndPos()</pre></div>



<h5>Returns</h5>

<p>numerical encoding of second position's methylation state. NULL if position does not exist
</p>


<hr>
<a id="method-singleStructureGenerator-get_seqLastPos"></a>



<h4>Method <code>get_seqLastPos()</code></h4>

<p>Public method: Get first sequence position methylation state
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_seqLastPos()</pre></div>



<h5>Returns</h5>

<p>numerical encoding of first position's methylation state
</p>


<hr>
<a id="method-singleStructureGenerator-get_seq2ndButLastPos"></a>



<h4>Method <code>get_seq2ndButLastPos()</code></h4>

<p>Public method: Get second but last sequence position methylation state
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_seq2ndButLastPos()</pre></div>



<h5>Returns</h5>

<p>numerical encoding of second but last position's methylation state. NULL if position does not exist
</p>


<hr>
<a id="method-singleStructureGenerator-get_combiStructure_index"></a>



<h4>Method <code>get_combiStructure_index()</code></h4>

<p>Public method: Get index in object of class combiStructureGenerator
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_combiStructure_index()</pre></div>



<h5>Returns</h5>

<p>index in object of class combiStructureGenerator
</p>


<hr>
<a id="method-singleStructureGenerator-update_interStr_firstNeighbSt"></a>



<h4>Method <code>update_interStr_firstNeighbSt()</code></h4>

<p>Public method: Update neighbSt of next singleStructureGenerator object within combiStructureGenerator object
</p>
<p>This function is used when the last $seq position of a singleStructureGenerator object
changes methylation state to update the neighbSt position
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$update_interStr_firstNeighbSt(
  leftNeighb_seqSt,
  rightNeighb_seqSt
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>leftNeighb_seqSt</code></dt><dd><p>$seq state of left neighbor (left neighbor is in previous singleStructureGenerator object)</p>
</dd>
<dt><code>rightNeighb_seqSt</code></dt><dd><p>$seq state of right neighbor</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-singleStructureGenerator-update_interStr_lastNeighbSt"></a>



<h4>Method <code>update_interStr_lastNeighbSt()</code></h4>

<p>Public method: Update neighbSt of previous singleStructureGenerator object within combiStructureGenerator object
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$update_interStr_lastNeighbSt(
  leftNeighb_seqSt,
  rightNeighb_seqSt
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>leftNeighb_seqSt</code></dt><dd><p>$seq state of right neighbor (left neighbor is in next singleStructureGenerator object)</p>
</dd>
<dt><code>rightNeighb_seqSt</code></dt><dd><p>$seq state of right neighbor</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-singleStructureGenerator-get_eqFreqs"></a>



<h4>Method <code>get_eqFreqs()</code></h4>

<p>Public method: Get object's equilibrium Frequencies
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_eqFreqs()</pre></div>



<h5>Returns</h5>

<p>vector with equilibrium frequencies of unmethylated, partially methylated and methylated
</p>


<hr>
<a id="method-singleStructureGenerator-SSE_evol"></a>



<h4>Method <code>SSE_evol()</code></h4>

<p>Public method. Simulate how CpG dinucleotide methylation state changes due to the SSE process
along a time step of length dt
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$SSE_evol(dt, testing = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dt</code></dt><dd><p>time step length.</p>
</dd>
<dt><code>testing</code></dt><dd><p>logical value for testing purposes. Default FALSE.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>default NULL. If testing TRUE it returns a list with the debugNov3.outnumber of events sampled and a
dataframe with the position(s) affected, new state and old methylation state.
</p>


<hr>
<a id="method-singleStructureGenerator-get_transMat"></a>



<h4>Method <code>get_transMat()</code></h4>

<p>Public Method. Get a transition matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_transMat(
  old_eqFreqs,
  new_eqFreqs,
  info,
  testing = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>old_eqFreqs</code></dt><dd><p>numeric vector with 3 frequency values (for old u, p and m)</p>
</dd>
<dt><code>new_eqFreqs</code></dt><dd><p>numeric vector with 3 frequency values (for new u, p and m)</p>
</dd>
<dt><code>info</code></dt><dd><p>character string to indicate where the method is being called</p>
</dd>
<dt><code>testing</code></dt><dd><p>logical value for testing purposes. Default FALSE.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Given a tripple of old equilibrium frequencies and new equilibrium frequencies, generates the corresponding transition matrix.
</p>



<h5>Returns</h5>

<p>transMat. The transition matrix. If testing = TRUE it returns a list.
If there was a change in the equilibrium frequencies the list contains the following 7 elements, if not it contains the first 3 elements:
</p>

<dl>
<dt><code>transMat</code></dt><dd><p>transition matrix</p>
</dd>
<dt><code>case</code></dt><dd><p>The applied case.</p>
</dd>
</dl>



<hr>
<a id="method-singleStructureGenerator-IWE_evol"></a>



<h4>Method <code>IWE_evol()</code></h4>

<p>Public Method. Simulate IWE Events
</p>
<p>Simulates how CpG Islands' methylation state frequencies change and simultaneous sites change methylation state
along a branch of length t according to the SSE-IWE model.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$IWE_evol(testing = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>testing</code></dt><dd><p>logical value for testing purposes. Default FALSE.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The function checks if the methylation equilibrium frequencies (<code>eqFreqs</code>) and sequence observed
frequencies (<code>obsFreqs</code>) change after the IWE event. If there is a change in either
frequencies, the corresponding change flag <code>eqFreqsChange</code>
in the <code>infoIWE</code> list will be set to <code>TRUE</code>.
</p>



<h5>Returns</h5>

<p>If testing = TRUE it returns a list.
If there was a change in the equilibrium frequencies the list contains the following 7 elements, if not it contains the first 3 elements:
</p>

<dl>
<dt><code>eqFreqsChange</code></dt><dd><p>logical indicating if there was a change in the equilibrium frequencies.</p>
</dd>
<dt><code>old_eqFreqs</code></dt><dd><p>Original equilibrium frequencies before the IWE event.</p>
</dd>
<dt><code>new_eqFreqs</code></dt><dd><p>New equilibrium frequencies after the IWE event.</p>
</dd>
<dt><code>old_obsFreqs</code></dt><dd><p>Original observed frequencies before the IWE event.</p>
</dd>
<dt><code>new_obsFreqs</code></dt><dd><p>New observed frequencies after the IWE event.</p>
</dd>
<dt><code>IWE_case</code></dt><dd><p>Description of the IWE event case.</p>
</dd>
<dt><code>Mk</code></dt><dd><p>Transition matrix used for the IWE event.</p>
</dd>
</dl>



<hr>
<a id="method-singleStructureGenerator-get_alpha_pI"></a>



<h4>Method <code>get_alpha_pI()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_alpha_pI()</pre></div>



<h5>Returns</h5>

<p>Model parameter alpha_pI for sampling island equilibrium frequencies
</p>


<hr>
<a id="method-singleStructureGenerator-get_beta_pI"></a>



<h4>Method <code>get_beta_pI()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_beta_pI()</pre></div>



<h5>Returns</h5>

<p>Model parameter for sampling island equilibrium frequencies
</p>


<hr>
<a id="method-singleStructureGenerator-get_alpha_mI"></a>



<h4>Method <code>get_alpha_mI()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_alpha_mI()</pre></div>



<h5>Returns</h5>

<p>Model parameter for sampling island equilibrium frequencies
</p>


<hr>
<a id="method-singleStructureGenerator-get_beta_mI"></a>



<h4>Method <code>get_beta_mI()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_beta_mI()</pre></div>



<h5>Returns</h5>

<p>Model parameter for sampling island equilibrium frequencies
</p>


<hr>
<a id="method-singleStructureGenerator-get_alpha_pNI"></a>



<h4>Method <code>get_alpha_pNI()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_alpha_pNI()</pre></div>



<h5>Returns</h5>

<p>Model parameter for sampling non-island equilibrium frequencies
</p>


<hr>
<a id="method-singleStructureGenerator-get_beta_pNI"></a>



<h4>Method <code>get_beta_pNI()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_beta_pNI()</pre></div>



<h5>Returns</h5>

<p>Model parameter for sampling non-island equilibrium frequencies
</p>


<hr>
<a id="method-singleStructureGenerator-get_alpha_mNI"></a>



<h4>Method <code>get_alpha_mNI()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_alpha_mNI()</pre></div>



<h5>Returns</h5>

<p>Model parameter for sampling non-island equilibrium frequencies
</p>


<hr>
<a id="method-singleStructureGenerator-get_beta_mNI"></a>



<h4>Method <code>get_beta_mNI()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_beta_mNI()</pre></div>



<h5>Returns</h5>

<p>Model parameter for sampling non-island equilibrium frequencies
</p>


<hr>
<a id="method-singleStructureGenerator-get_alpha_Ri"></a>



<h4>Method <code>get_alpha_Ri()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_alpha_Ri()</pre></div>



<h5>Returns</h5>

<p>Model parameter for gamma distribution shape to initialize the 3 $Ri_values
</p>


<hr>
<a id="method-singleStructureGenerator-get_iota"></a>



<h4>Method <code>get_iota()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_iota()</pre></div>



<h5>Returns</h5>

<p>Model parameter for gamma distribution expected value to initialize the 3 $Ri_values
</p>


<hr>
<a id="method-singleStructureGenerator-get_Ri_values"></a>



<h4>Method <code>get_Ri_values()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_Ri_values()</pre></div>



<h5>Returns</h5>

<p>The 3 $Ri_values
</p>


<hr>
<a id="method-singleStructureGenerator-get_Q"></a>



<h4>Method <code>get_Q()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_Q(
  siteR = NULL,
  neighbSt = NULL,
  oldSt = NULL,
  newSt = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>siteR</code></dt><dd><p>default NULL. Numerical value encoding for the sites rate of independent SSE (1, 2 or 3)</p>
</dd>
<dt><code>neighbSt</code></dt><dd><p>default NULL. Numerical value encoding for the sites neighbouring state (as in mapNeighbSt_matrix)</p>
</dd>
<dt><code>oldSt</code></dt><dd><p>default NULL. Numerical value encoding for the sites old methylation state (1, 2 or 3)</p>
</dd>
<dt><code>newSt</code></dt><dd><p>default NULL. Numerical value encoding for the sites new methylation state (1, 2 or 3)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>With NULL arguments, the list of rate matrices. With non NULL arguments, the corresponding rate of change.
</p>


<hr>
<a id="method-singleStructureGenerator-get_siteR"></a>



<h4>Method <code>get_siteR()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_siteR(index = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>default NULL. Numerical value for the index of the CpG position within the singleStr instance</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>with NULL arguments, siteR vector. non NULL arguments, the corresponding siteR
</p>


<hr>
<a id="method-singleStructureGenerator-get_neighbSt"></a>



<h4>Method <code>get_neighbSt()</code></h4>

<p>Public Method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_neighbSt(index = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>default NULL. Numerical value for the index of the CpG position within the singleStr instance</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>with NULL arguments, neighbSt vector. non NULL arguments, the corresponding neighbSt
</p>


<hr>
<a id="method-singleStructureGenerator-update_ratetree_otherStr"></a>



<h4>Method <code>update_ratetree_otherStr()</code></h4>

<p>Public Method. Update ratetree from another singleStructure instance
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$update_ratetree_otherStr(position, rate)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>position</code></dt><dd><p>Numerical value for the index of the CpG position within the singleStr instance</p>
</dd>
<dt><code>rate</code></dt><dd><p>Rate of change to asign to that position</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-singleStructureGenerator-get_Qi"></a>



<h4>Method <code>get_Qi()</code></h4>

<p>Public Method. Get list of matrices for SSE process
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_Qi(siteR = NULL, oldSt = NULL, newSt = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>siteR</code></dt><dd><p>default NULL. Numerical value encoding for the sites rate of independent SSE (1, 2 or 3)</p>
</dd>
<dt><code>oldSt</code></dt><dd><p>default NULL. Numerical value encoding for the sites old methylation state (1, 2 or 3)</p>
</dd>
<dt><code>newSt</code></dt><dd><p>default NULL. Numerical value encoding for the sites new methylation state (1, 2 or 3)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>With NULL arguments, the list of SSEi rate matrices. With non NULL arguments, the corresponding rate of change.
</p>


<hr>
<a id="method-singleStructureGenerator-get_seqSt_leftneighb"></a>



<h4>Method <code>get_seqSt_leftneighb()</code></h4>

<p>Public Method. Decode methylation state of left neighbor form owns neighbSt
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_seqSt_leftneighb(index)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>Integer index value for the CpG position within the singleStr instance</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>decoded methylation state ($seq) of left neighbor (1, 2 or 3 for unmethylated, partially methylated or methylated)
</p>


<hr>
<a id="method-singleStructureGenerator-get_seqSt_rightneighb"></a>



<h4>Method <code>get_seqSt_rightneighb()</code></h4>

<p>Public Method. Decode methylation state of left neighbor form owns neighbSt
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$get_seqSt_rightneighb(index)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>Integer index value for the CpG position within the singleStr instance</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>decoded methylation state ($seq) of right neighbor (1, 2 or 3 for unmethylated, partially methylated or methylated)
</p>


<hr>
<a id="method-singleStructureGenerator-cftp_all_equal"></a>



<h4>Method <code>cftp_all_equal()</code></h4>

<p>Public Method. Make a singleStructure with the same segment lengths and parameters
as the focal one but where all states are m or u
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$cftp_all_equal(state, testing = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>state</code></dt><dd><p>Character value &quot;U&quot; or &quot;M&quot;</p>
</dd>
<dt><code>testing</code></dt><dd><p>default FALSE. TRUE for testing output</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>right neighbSt
</p>


<hr>
<a id="method-singleStructureGenerator-set_seqSt_update_neighbSt"></a>



<h4>Method <code>set_seqSt_update_neighbSt()</code></h4>

<p>Public Method. Set the methylation state of a sequence position and update the neighbor's neighbSt. It does NOT update RATETREE
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$set_seqSt_update_neighbSt(
  index,
  newSt,
  testing = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>Numerical value for the index of the CpG position within the singleStr instance</p>
</dd>
<dt><code>newSt</code></dt><dd><p>Numerical value encoding for the sites new methylation state (1, 2 or 3)</p>
</dd>
<dt><code>testing</code></dt><dd><p>default FALSE. TRUE for testing output</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL when testing FALSE. Testing output when testing TRUE.
</p>


<hr>
<a id="method-singleStructureGenerator-reset_seq"></a>



<h4>Method <code>reset_seq()</code></h4>

<p>Public Method. Resets the sequence states by resampling according to the instance's equilibrium frequencies.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$reset_seq()</pre></div>



<h5>Returns</h5>

<p>NULL. The sequence is updated in place.
</p>


<hr>
<a id="method-singleStructureGenerator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>singleStructureGenerator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='treeMultiRegionSimulator'>treeMultiRegionSimulator</h2><span id='topic+treeMultiRegionSimulator'></span>

<h3>Description</h3>

<p>an R6 class representing the methylation state of GpGs in different genomic
structures in the nodes of a tree.
</p>
<p>The whole CpG sequence is an object of class combiStructureGenerator.
Each genomic structure in it is contained in an object of class singleStructureGenerator.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>testing_output</code></dt><dd><p>Public attribute: Testing output for initialize</p>
</dd>
<dt><code>Branch</code></dt><dd><p>Public attribute: List containing objects of class combiStructureGenerator</p>
</dd>
<dt><code>branchLength</code></dt><dd><p>Public attribute: Vector with the corresponding branch lengths of each $Branch element</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-treeMultiRegionSimulator-treeEvol"><code>treeMultiRegionSimulator$treeEvol()</code></a>
</p>
</li>
<li> <p><a href="#method-treeMultiRegionSimulator-new"><code>treeMultiRegionSimulator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-treeMultiRegionSimulator-clone"><code>treeMultiRegionSimulator$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-treeMultiRegionSimulator-treeEvol"></a>



<h4>Method <code>treeEvol()</code></h4>

<p>Simulate CpG dinucleotide methylation state evolution along a tree.
The function splits a given tree and simulates evolution along its
branches. It recursively simulates evolution in all of the subtrees in the given tree
until the tree leafs
</p>


<h5>Usage</h5>

<div class="r"><pre>treeMultiRegionSimulator$treeEvol(
  Tree,
  dt = 0.01,
  parent_index = 1,
  testing = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Tree</code></dt><dd><p>String. Tree in Newick format. When called recursivelly it is given the corresponding subtree.</p>
</dd>
<dt><code>dt</code></dt><dd><p>Length of SSE time steps.</p>
</dd>
<dt><code>parent_index</code></dt><dd><p>Default 1. When called recursivelly it is given the corresponding parent branch index.</p>
</dd>
<dt><code>testing</code></dt><dd><p>Default FALSE. TRUE for testing purposes.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-treeMultiRegionSimulator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new treeMultiRegionSimulator object.
$Branch is a list for the tree branches, its first element represents the tree root.
</p>
<p>Note that one of either infoStr or rootData needs to be given. Not both, not neither.
</p>


<h5>Usage</h5>

<div class="r"><pre>treeMultiRegionSimulator$new(
  infoStr = NULL,
  rootData = NULL,
  tree = NULL,
  params = NULL,
  dt = 0.01,
  CFTP = FALSE,
  CFTP_step_limit = 327680000,
  testing = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>infoStr</code></dt><dd><p>A data frame containing columns 'n' for the number of sites, and 'globalState' for the favoured global methylation state.
If initial equilibrium frequencies are given the dataframe must contain 3 additional columns: 'u_eqFreq', 'p_eqFreq' and 'm_eqFreq'</p>
</dd>
<dt><code>rootData</code></dt><dd><p>combiStructureGenerator object. When given, the simulation uses its parameter values.</p>
</dd>
<dt><code>tree</code></dt><dd><p>tree</p>
</dd>
<dt><code>params</code></dt><dd><p>Default NULL. When given: data frame containing model parameters. Note that if rootData is not null, its parameter values are used.</p>
</dd>
<dt><code>dt</code></dt><dd><p>length of the dt time steps for the SSE evolutionary process</p>
</dd>
<dt><code>CFTP</code></dt><dd><p>Default FALSE. TRUE for calling cftp algorithm to set root state according to model equilibrium (Note that current implementation neglects IWE process).</p>
</dd>
<dt><code>CFTP_step_limit</code></dt><dd><p>when CFTP = TRUE, maximum number of steps before applying an approximation method
(default 327680000 corresponding to size of CFTP info of approx 6.1 GB).</p>
</dd>
<dt><code>testing</code></dt><dd><p>Default FALSE. TRUE for testing output.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>treeMultiRegionSimulator</code> object.
</p>


<hr>
<a id="method-treeMultiRegionSimulator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>treeMultiRegionSimulator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='validate_data_cherryDist'>Validate Structure of Input Data for Cherry Distance Computation</h2><span id='topic+validate_data_cherryDist'></span>

<h3>Description</h3>

<p>This function checks whether the provided input data has the required structure.
It ensures that the number of tips is sufficient and that the data structure is consistent across tips and structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_data_cherryDist(cherryDist, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_data_cherryDist_+3A_cherrydist">cherryDist</code></td>
<td>
<p>A data frame containing cherry pair distances, including tip indices (output from <code>get_cherryDist</code>)</p>
</td></tr>
<tr><td><code id="validate_data_cherryDist_+3A_data">data</code></td>
<td>
<p>A nested list representing structured data for each tip, following the format <code>data[[tip]][[structure]]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs several validation steps:
</p>

<ul>
<li><p> Ensures that the number of tips in <code>data</code> is at least as large as the highest tip index in <code>cherryDist</code>.
</p>
</li>
<li><p> Checks that all tips contain at least one structure and that the number of structures is consistent across tips.
</p>
</li>
<li><p> Verifies that within each structure, all tips have the same number of sites and no zero-length structures.
</p>
</li></ul>

<p>If any of these conditions fail, the function throws an error with a descriptive message.
</p>

<hr>
<h2 id='validate_dataAcrossTips'>Validate Data Structure Across Tips</h2><span id='topic+validate_dataAcrossTips'></span>

<h3>Description</h3>

<p>This function ensures that <code>data</code> follows the required nested structure
<code>data[[tip]][[structure]]</code>, where:
</p>

<ul>
<li> <p><code>data</code> is a list of at least two <code>tip</code> elements.
</p>
</li>
<li><p> Each <code>tip</code> is a list of <code>structure</code> elements.
</p>
</li>
<li><p> Each <code>structure</code> contains a numeric vector of equal length across all tips.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>validate_dataAcrossTips(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_dataAcrossTips_+3A_data">data</code></td>
<td>
<p>A list structured as <code>data[[tip]][[structure]]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Throws errors if:
</p>

<ul>
<li> <p><code>data</code> is not a list.
</p>
</li>
<li><p> It has fewer than two tips.
</p>
</li>
<li><p> Any tip is not a list.
</p>
</li>
<li><p> The number of structures is inconsistent across tips.
</p>
</li>
<li><p> Any structure has zero-length data at any tip.
</p>
</li>
<li><p> Structures have different site lengths across tips.
</p>
</li></ul>


<hr>
<h2 id='validate_structureIndices'>Validate Structure Indices for Island and Non-Island Data</h2><span id='topic+validate_structureIndices'></span>

<h3>Description</h3>

<p>This function checks whether the provided indices for islands and non-islands
are within the valid range of structures in the dataset. It also warns if
any indices are present in both <code>index_islands</code> and <code>index_nonislands</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_structureIndices(data, index_islands, index_nonislands)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_structureIndices_+3A_data">data</code></td>
<td>
<p>A nested list <code>data[[tip]][[structure]]</code>.
Assumes that the number of structures is consistent across tips and that
within each structure, all tips have the same number of sites.
The number of structures is inferred from <code>length(data[[1]])</code>.</p>
</td></tr>
<tr><td><code id="validate_structureIndices_+3A_index_islands">index_islands</code></td>
<td>
<p>An integer vector specifying indices that correspond to island structures.</p>
</td></tr>
<tr><td><code id="validate_structureIndices_+3A_index_nonislands">index_nonislands</code></td>
<td>
<p>An integer vector specifying indices that correspond to non-island structures.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The funct@exportion performs the following checks:
</p>

<ul>
<li><p> Ensures that all indices in <code>index_islands</code> and <code>index_nonislands</code> are within
the range of available structures.
</p>
</li>
<li><p> Throws an error if any index is out of bounds.
</p>
</li>
<li><p> Issues a warning if the same index appears in both <code>index_islands</code> and <code>index_nonislands</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>No return value. The function stops execution if invalid indices are detected.
</p>

<hr>
<h2 id='validate_tree'>Validate and Parse a Phylogenetic Tree</h2><span id='topic+validate_tree'></span>

<h3>Description</h3>

<p>This function checks whether the input is a valid phylogenetic tree, either as a character string in Newick format
or as an object of class <code>phylo</code> from the <code>ape</code> package. If the input is a Newick string, it is parsed into
a <code>phylo</code> object. The function also ensures that the tree contains at least two tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_tree(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_tree_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree in Newick format (as a character string) or an object of class <code>phylo</code> from the <code>ape</code> package.
</p>

<ul>
<li><p> If the input is a character string, it must follow the Newick format (e.g., <code>"((tip_1:1,tip_2:1):5,tip_3:6);"</code>).
</p>
</li>
<li><p> If an object of class <code>phylo</code> is provided, it should be a valid phylogenetic tree.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> The function first verifies that the input is either a valid <code>phylo</code> object or a character string.
</p>
</li>
<li><p> If the input is a Newick string, it attempts to parse it into a <code>phylo</code> object using <code>ape::read.tree()</code>.
</p>
</li>
<li><p> If parsing fails, an informative error message is returned.
</p>
</li>
<li><p> The function also checks that the tree contains at least two tips, as a valid phylogenetic tree should have at least one split.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>phylo</code> object representing the validated and parsed tree.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
