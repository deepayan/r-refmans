<!DOCTYPE html><html lang="en"><head><title>Help for package pamr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pamr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pamr-package'><p>Prediction Analysis of Microarrays</p></a></li>
<li><a href='#khan'><p>Khan microarray data</p></a></li>
<li><a href='#pamr.adaptthresh'><p>A function to adaptive choose threshold scales, for use in pamr.train</p></a></li>
<li><a href='#pamr.batchadjust'><p>A function to mean-adjust microarray data by batches</p></a></li>
<li><a href='#pamr.confusion'><p>A function giving a table of true versus predicted values, from a nearest</p>
shrunken centroid fit.</a></li>
<li><a href='#pamr.confusion.survival'><p>Compute confusin matrix from pamr survival fit</p></a></li>
<li><a href='#pamr.cv'><p>A function to cross-validate the nearest shrunken centroid classifier</p></a></li>
<li><a href='#pamr.decorrelate'><p>A function to decorrelate (adjust) the feature matrix with respect to some</p>
additional predictors</a></li>
<li><a href='#pamr.fdr'><p>A function to estimate false discovery rates for the nearest shrunken</p>
centroid classifier</a></li>
<li><a href='#pamr.geneplot'><p>A function to plot the genes that surive the thresholding from the nearest</p>
shrunken centroid classifier</a></li>
<li><a href='#pamr.indeterminate'><p>A function that takes estimate class probabilities and produces a class</p>
prediction or indeterminate prediction</a></li>
<li><a href='#pamr.listgenes'><p>A function to list the genes that survive the thresholding, from the nearest</p>
shrunken centroid classifier</a></li>
<li><a href='#pamr.makeclasses'><p>A function to interactively define classes from a clustering tree</p></a></li>
<li><a href='#pamr.menu'><p>A function that interactively leads the user through a PAM analysis</p></a></li>
<li><a href='#pamr.plotcen'><p>A function to plot the shrunken class centroids, from the nearest shrunken</p>
centroid classifier</a></li>
<li><a href='#pamr.plotcv'><p>A function to plot the cross-validated error curves from the nearest</p>
shrunken centroid classifier</a></li>
<li><a href='#pamr.plotcvprob'><p>A function to plot the cross-validated sample probabilities from the nearest</p>
shrunken centroid classifier</a></li>
<li><a href='#pamr.plotfdr'><p>A function to plot the FDR curve from the nearest shrunken centroid</p>
classifier</a></li>
<li><a href='#pamr.plotstrata'><p>A function to plot the survival curves in each Kaplan Meier stratum</p></a></li>
<li><a href='#pamr.plotsurvival'><p>A function to plots Kaplan-Meier curves stratified by a group variable</p></a></li>
<li><a href='#pamr.predict'><p>A function giving prediction information, from a nearest shrunken centroid</p>
fit.</a></li>
<li><a href='#pamr.predictmany'><p>A function giving prediction information for many threshold values, from a</p>
nearest shrunken centroid fit.</a></li>
<li><a href='#pamr.surv.to.class2'><p>A function to assign observations to categories, based on their survival</p>
times.</a></li>
<li><a href='#pamr.test.errors.surv.compute'><p>A function giving a table of true versus predicted values, from a nearest</p>
shrunken centroid fit from survival data.</a></li>
<li><a href='#pamr.train'><p>A function to train a nearest shrunken centroid classifier</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Pam: Prediction Analysis for Microarrays</td>
</tr>
<tr>
<td>Version:</td>
<td>1.57</td>
</tr>
<tr>
<td>Description:</td>
<td>Some functions for sample classification in microarrays.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-28</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>cluster, survival</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-30 23:41:08 UTC; naras</td>
</tr>
<tr>
<td>Author:</td>
<td>Trevor Hastie [aut],
  Rob Tibshirani [aut],
  Balasubramanian Narasimhan [aut, cre],
  Gilbert Chu [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Balasubramanian Narasimhan &lt;naras@stanford.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-01 06:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='pamr-package'>Prediction Analysis of Microarrays</h2><span id='topic+pamr'></span><span id='topic+pamr-package'></span><span id='topic+pamr.cube.root'></span><span id='topic+pamr.pairscore'></span><span id='topic+pamr.pvalue.survival'></span><span id='topic+pamr.score.to.class1'></span><span id='topic+pamr.score.to.class2'></span><span id='topic+print.nsc'></span><span id='topic+print.nsccv'></span><span id='topic+print.pamrcved'></span><span id='topic+print.pamrtrained'></span>

<h3>Description</h3>

<p>Functions for training and predicting using shrunken
centroids. While originally developed in the context of
microarray data analysis (<a href="doi:10.1073/pnas.082099299">doi:10.1073/pnas.082099299</a>), the
method is broadly applicable.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Balasubramanian Narasimhan <a href="mailto:naras@stanford.edu">naras@stanford.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Trevor Hastie <a href="mailto:hastie@stanford.edu">hastie@stanford.edu</a>
</p>
</li>
<li><p> Rob Tibshirani <a href="mailto:tibs@stanford.edu">tibs@stanford.edu</a>
</p>
</li>
<li><p> Gilbert Chu
</p>
</li></ul>


<hr>
<h2 id='khan'>Khan microarray data</h2><span id='topic+khan'></span>

<h3>Description</h3>

<p>The <code>khan</code> data frame has 2308 rows and 65 columns. These are one of
the datasets data used in the Tibshirani et al paper in PNAS on nearest
shrunken centroids.
</p>


<h3>Details</h3>

<p>The first two columns of gene ids and names and the remaining
columns are gene expression values for 63 samples. An attribute
<code>cancer_type</code> contains the cancer type for each sample.
</p>

<hr>
<h2 id='pamr.adaptthresh'>A function to adaptive choose threshold scales, for use in pamr.train</h2><span id='topic+pamr.adaptthresh'></span>

<h3>Description</h3>

<p>A function to adaptive choose threshold scales, for use in pamr.train
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.adaptthresh(object, ntries = 10, reduction.factor = 0.9, full.out = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.adaptthresh_+3A_object">object</code></td>
<td>
<p>The result of a call to pamr.train</p>
</td></tr>
<tr><td><code id="pamr.adaptthresh_+3A_ntries">ntries</code></td>
<td>
<p>Number of iterations to use in algorithm</p>
</td></tr>
<tr><td><code id="pamr.adaptthresh_+3A_reduction.factor">reduction.factor</code></td>
<td>
<p>Amount by which a scaling is reduced in one step of
the algorithm</p>
</td></tr>
<tr><td><code id="pamr.adaptthresh_+3A_full.out">full.out</code></td>
<td>
<p>Should full output be returned? Default FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pamr.adaptthresh</code> Adaptively searches for set of good threshold
scales.  The baseline (default) scale is 1 for each class. The idea is that
for easy to classify classes, the threshold scale can be increased without
increasing the error rate for that class, and resulting in fewer genes
needed for the classification rule. The scalings from pamr.adaptthresh are
then used in pamr.train, and pamr.cv. The results may be better than those
obtained with the default values of threshold.scale.
</p>


<h3>Author(s)</h3>

<p>Trevor Hastie, Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>References</h3>

<p>Robert Tibshirani, Trevor Hastie, Balasubramanian Narasimhan, and Gilbert
Chu. &quot;Diagnosis of multiple cancer types by shrunken centroids of gene
expression&quot; PNAS 2002 99:6567-6572 (May 14).
</p>
<p>Robert Tibshirani, Trevor Hastie, Balasubramanian Narasimhan, and Gilbert
Chu (2002).  Class prediction by nearest shrunken centroids,with
applications to DNA microarrays. Stanford tech report.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
suppressWarnings(RNGversion("3.5.0"))
set.seed(120)
x &lt;- matrix(rnorm(1000*20),ncol=20)
y &lt;- sample(c(1:4),size=20,replace=TRUE)
mydata &lt;- list(x=x,y=y)
mytrain &lt;-   pamr.train(mydata)
new.scales &lt;- pamr.adaptthresh(mytrain)

 
mytrain2 &lt;- pamr.train(mydata, threshold.scale=new.scales)

myresults2 &lt;- pamr.cv(mytrain2, mydata)


</code></pre>

<hr>
<h2 id='pamr.batchadjust'>A function to mean-adjust microarray data by batches</h2><span id='topic+pamr.batchadjust'></span>

<h3>Description</h3>

<p>A function to mean-adjust microarray data by batches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.batchadjust(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.batchadjust_+3A_data">data</code></td>
<td>
<p>The input data. A list with components: x- an expression genes
in the rows, samples in the columns, and y- a vector of the class labels for
each sample, and batchlabels- a vector of batch labels for each sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pamr.batchadjust</code> does a genewise one-way ANOVA adjustment for
expression values.  Let <code class="reqn">x(i,j)</code> be the expression for gene <code class="reqn">i</code> in sample <code class="reqn">j</code>.
Suppose sample <code class="reqn">j</code> in in batch <code class="reqn">b</code>, and let <code class="reqn">B</code> be the set of all samples in batch
<code class="reqn">b</code>. Then <code>pamr.batchadjust</code> adjusts <code class="reqn">x(i,j)</code> to <code class="reqn">x(i,j) - mean[x(i,j)]</code>
where the mean is taken over all samples <code class="reqn">j</code> in <code class="reqn">B</code>.
</p>


<h3>Value</h3>

<p>A data object of the same form as the input data, with x replaced by
the adjusted x
</p>


<h3>Author(s)</h3>

<p>Trevor Hastie,Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
suppressWarnings(RNGversion("3.5.0"))
set.seed(120)
#generate some data
x &lt;- matrix(rnorm(1000*20),ncol=20)
y &lt;- sample(c(1:4),size=20,replace=TRUE)
batchlabels &lt;- sample(c(1:5),size=20,replace=TRUE)
mydata &lt;- list(x=x,y=factor(y),batchlabels=factor(batchlabels))

mydata2 &lt;- pamr.batchadjust(mydata)

</code></pre>

<hr>
<h2 id='pamr.confusion'>A function giving a table of true versus predicted values, from a nearest
shrunken centroid fit.</h2><span id='topic+pamr.confusion'></span>

<h3>Description</h3>

<p>A function giving a table of true versus predicted values, from a nearest
shrunken centroid fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.confusion(fit, threshold, extra = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.confusion_+3A_fit">fit</code></td>
<td>
<p>The result of a call to pamr.train or pamr.cv</p>
</td></tr>
<tr><td><code id="pamr.confusion_+3A_threshold">threshold</code></td>
<td>
<p>The desired threshold value</p>
</td></tr>
<tr><td><code id="pamr.confusion_+3A_extra">extra</code></td>
<td>
<p>Should the classwise and overall error rates be returned?
Default TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pamr.confusion</code> Gives a cross-tabulation of true versus predicted
classes for the fit returned by pamr.train or pamr.cv, at the specified
threshold.
</p>


<h3>Author(s)</h3>

<p>Trevor Hastie, Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
suppressWarnings(RNGversion("3.5.0"))
set.seed(120)
x &lt;- matrix(rnorm(1000*20),ncol=20)
y &lt;- sample(c(1:4),size=20,replace=TRUE)
mydata &lt;- list(x=x,y=y)
mytrain &lt;-   pamr.train(mydata)
mycv &lt;- pamr.cv(mytrain,mydata)
pamr.confusion(mytrain,  threshold=2)
pamr.confusion(mycv,  threshold=2)
 

</code></pre>

<hr>
<h2 id='pamr.confusion.survival'>Compute confusin matrix from pamr survival fit</h2><span id='topic+pamr.confusion.survival'></span>

<h3>Description</h3>

<p>computes confusion matrix for (survival.time,censoring) outcome based on fit
object &quot;fit&quot; and class predictions &quot;yhat&quot; soft response probabilities for
(survival.time,censoring) are first estimated using Kaplan-Meier method
applied to training data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.confusion.survival(fit, survival.time, censoring.status, yhat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.confusion.survival_+3A_fit">fit</code></td>
<td>
<p>The result of a call to pamr.train or pamr.cv</p>
</td></tr>
<tr><td><code id="pamr.confusion.survival_+3A_survival.time">survival.time</code></td>
<td>
<p>Survival time</p>
</td></tr>
<tr><td><code id="pamr.confusion.survival_+3A_censoring.status">censoring.status</code></td>
<td>
<p>censoring status</p>
</td></tr>
<tr><td><code id="pamr.confusion.survival_+3A_yhat">yhat</code></td>
<td>
<p>class predictions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Trevor Hastie, Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>

<hr>
<h2 id='pamr.cv'>A function to cross-validate the nearest shrunken centroid classifier</h2><span id='topic+pamr.cv'></span>

<h3>Description</h3>

<p>A function to cross-validate the nearest shrunken centroid classifier
produced by pamr.train
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.cv(fit, data, nfold = NULL, folds = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.cv_+3A_fit">fit</code></td>
<td>
<p>The result of a call to pamr.train</p>
</td></tr>
<tr><td><code id="pamr.cv_+3A_data">data</code></td>
<td>
<p>A list with at least two components: x- an expression genes in
the rows, samples in the columns), and y- a vector of the class labels for
each sample. Same form as data object used by pamr.train.</p>
</td></tr>
<tr><td><code id="pamr.cv_+3A_nfold">nfold</code></td>
<td>
<p>Number of cross-validation folds. Default is the smallest class
size</p>
</td></tr>
<tr><td><code id="pamr.cv_+3A_folds">folds</code></td>
<td>
<p>A list with nfold components, each component a vector of
indices of the samples in that fold. By default a (random) balanced
cross-validation is used</p>
</td></tr>
<tr><td><code id="pamr.cv_+3A_...">...</code></td>
<td>
<p>Any additional arguments that are to be passed to pamr.train</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pamr.cv</code> carries out cross-validation for a nearest shrunken centroid
classifier.
</p>


<h3>Value</h3>

<p>A list with components </p>
<table role = "presentation">
<tr><td><code>threshold</code></td>
<td>
<p>A vector of the thresholds
tried in the shrinkage</p>
</td></tr> <tr><td><code>errors</code></td>
<td>
<p>The number of cross-validation errors
for each threshold value</p>
</td></tr> <tr><td><code>loglik</code></td>
<td>
<p>The cross-validated multinomial
log-likelihood value for each threshold value</p>
</td></tr> <tr><td><code>size</code></td>
<td>
<p>A vector of the
number of genes that survived the thresholding, for each threshold value
tried.</p>
</td></tr></table>
<p>.  </p>
<table role = "presentation">
<tr><td><code>yhat</code></td>
<td>
<p>A matrix of size n by nthreshold, containing the
cross-validated class predictions for each threshold value, in each column</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>A matrix of size n by nthreshold, containing the cross-validated
class probabilities for each threshold value, in each column</p>
</td></tr> <tr><td><code>folds</code></td>
<td>

<p>The cross-validation folds used</p>
</td></tr> <tr><td><code>cv.objects</code></td>
<td>
<p>Train objects (output of
pamr.train), from each of the CV folds</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>The calling sequence
used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Trevor Hastie,Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
suppressWarnings(RNGversion("3.5.0"))
set.seed(120)
x &lt;- matrix(rnorm(1000*20),ncol=20)
y &lt;- sample(c(1:4),size=20,replace=TRUE)

mydata &lt;- list(x=x,y=factor(y), geneid=as.character(1:nrow(x)),
 genenames=paste("g",as.character(1:nrow(x)),sep=""))

mytrain &lt;-   pamr.train(mydata)
mycv &lt;- pamr.cv(mytrain,mydata)

</code></pre>

<hr>
<h2 id='pamr.decorrelate'>A function to decorrelate (adjust) the feature matrix with respect to some
additional predictors</h2><span id='topic+pamr.decorrelate'></span>

<h3>Description</h3>

<p>A function to decorrelate (adjust) the feature matrix with respect to some
additional predictors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.decorrelate(
  x,
  adjusting.predictors,
  xtest = NULL,
  adjusting.predictors.test = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.decorrelate_+3A_x">x</code></td>
<td>
<p>Matrix of training set feature values, with genes in the rows,
samples in the columns</p>
</td></tr>
<tr><td><code id="pamr.decorrelate_+3A_adjusting.predictors">adjusting.predictors</code></td>
<td>
<p>List of training set predictors to be used for
adjustment</p>
</td></tr>
<tr><td><code id="pamr.decorrelate_+3A_xtest">xtest</code></td>
<td>
<p>Optional matrix of test set feature values, to be adjusted in
the same way as the training set</p>
</td></tr>
<tr><td><code id="pamr.decorrelate_+3A_adjusting.predictors.test">adjusting.predictors.test</code></td>
<td>
<p>Optional list of test set predictors to be
used for adjustment</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pamr.decorrelate</code> Does a least squares regression of each row of x on
the adjusting predictors, and returns the residuals. If xtest is provided,
it also returns the adjusted version of xtest, using the training set least
squares regression model for adjustment
</p>


<h3>Value</h3>

<p>A list with components </p>
<table role = "presentation">
<tr><td><code>x.adj</code></td>
<td>
<p>Adjusted x matrix</p>
</td></tr>
<tr><td><code>xtest.adj</code></td>
<td>
<p>Adjusted xtest matrix, if xtest we provided</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Trevor Hastie,Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>References</h3>

<p>Robert Tibshirani, Trevor Hastie, Balasubramanian Narasimhan,
and Gilbert Chu Diagnosis of multiple cancer types by shrunken centroids of
gene expression PNAS 99: 6567-6572.  Available at www.pnas.org
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#generate some data
suppressWarnings(RNGversion("3.5.0"))
set.seed(120)

x&lt;-matrix(rnorm(1000*20),ncol=20)
y&lt;-c(rep(1,10),rep(2,10))
adjusting.predictors=list(pred1=rnorm(20), pred2=as.factor(sample(c(1,2),replace
=TRUE,size=20)))
xtest=matrix(rnorm(1000*10),ncol=10)
adjusting.predictors.test=list(pred1=rnorm(10), pred2=as.factor(sample(c(1,2),replace
=TRUE,size=10)))

# decorrelate training x wrt adjusting predictors

x.adj=pamr.decorrelate(x,adjusting.predictors)$x.adj
# train classifier with adjusted x

d=list(x=x.adj,y=y)
a&lt;-pamr.train(d)

# decorrelate training and test x wrt adjusting predictors, then make
#predictions for test set

temp &lt;- pamr.decorrelate(x,adjusting.predictors, xtest=xtest,
                         adjusting.predictors.test=adjusting.predictors.test)

d=list(x=temp$x.adj,y=y)
a&lt;-pamr.train(d)
aa&lt;-pamr.predict(a,temp$xtest.adj, threshold=.5)

</code></pre>

<hr>
<h2 id='pamr.fdr'>A function to estimate false discovery rates for the nearest shrunken
centroid classifier</h2><span id='topic+pamr.fdr'></span>

<h3>Description</h3>

<p>A function to estimate false discovery rates for the nearest shrunken
centroid classifier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.fdr(
  trained.obj,
  data,
  nperms = 100,
  xl.mode = c("regular", "firsttime", "onetime", "lasttime"),
  xl.time = NULL,
  xl.prevfit = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.fdr_+3A_trained.obj">trained.obj</code></td>
<td>
<p>The result of a call to pamr.train</p>
</td></tr>
<tr><td><code id="pamr.fdr_+3A_data">data</code></td>
<td>
<p>Data object; same as the one passed to pamr.train</p>
</td></tr>
<tr><td><code id="pamr.fdr_+3A_nperms">nperms</code></td>
<td>
<p>Number of permutations for estimation of FDRs.  Default is 100</p>
</td></tr>
<tr><td><code id="pamr.fdr_+3A_xl.mode">xl.mode</code></td>
<td>
<p>Used by Excel interface</p>
</td></tr>
<tr><td><code id="pamr.fdr_+3A_xl.time">xl.time</code></td>
<td>
<p>Used by Excel interface</p>
</td></tr>
<tr><td><code id="pamr.fdr_+3A_xl.prevfit">xl.prevfit</code></td>
<td>
<p>Used by Excel interface</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pamr.fdr</code> estimates false discovery rates for a nearest shrunken
centroid classifier
</p>


<h3>Value</h3>

<p>A list with components: </p>
<table role = "presentation">
<tr><td><code>results</code></td>
<td>
<p>Matrix of estimates FDRs for
various various threshold values. Reported are both the median and 90th
percentile of the FDR over permutations</p>
</td></tr> <tr><td><code>pi0</code></td>
<td>
<p>The estimated proportion
of genes that are null, i.e. not significantly different</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Trevor Hastie,Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
suppressWarnings(RNGversion("3.5.0"))
set.seed(120)
x &lt;- matrix(rnorm(1000*20),ncol=20)
y &lt;- sample(c(1:4),size=20,replace=TRUE)

mydata &lt;- list(x=x,y=factor(y), geneid=as.character(1:nrow(x)),
               genenames=paste("g",as.character(1:nrow(x)),sep=""))

mytrain &lt;-   pamr.train(mydata)
myfdr &lt;- pamr.fdr(mytrain, mydata)

</code></pre>

<hr>
<h2 id='pamr.geneplot'>A function to plot the genes that surive the thresholding from the nearest
shrunken centroid classifier</h2><span id='topic+pamr.geneplot'></span>

<h3>Description</h3>

<p>A function to plot the genes that survive the thresholding, from the nearest
shrunken centroid classifier produced by pamr.train
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.geneplot(fit, data, threshold)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.geneplot_+3A_fit">fit</code></td>
<td>
<p>The result of a call to pamr.train</p>
</td></tr>
<tr><td><code id="pamr.geneplot_+3A_data">data</code></td>
<td>
<p>The input data.  In the same format as the input data for
pamr.train</p>
</td></tr>
<tr><td><code id="pamr.geneplot_+3A_threshold">threshold</code></td>
<td>
<p>The desired threshold value</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pamr.geneplot</code> Plots the raw gene expression for genes that survive
the specified threshold. Plot is stratified by class.  Plot is set up to
display only up to about 20 or 25 genes, otherwise it gets too crowded.
Hence threshold should be chosen to yield at most about 20 or 25 genes.
</p>


<h3>Author(s)</h3>

<p>Trevor Hastie, Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
suppressWarnings(RNGversion("3.5.0"))
set.seed(120)
x &lt;- matrix(rnorm(1000*20),ncol=20)
y &lt;- sample(c(1:4),size=20,replace=TRUE)
mydata &lt;- list(x=x,y=y)
mytrain &lt;-   pamr.train(mydata)
pamr.geneplot(mytrain, mydata, threshold=1.6)
 

</code></pre>

<hr>
<h2 id='pamr.indeterminate'>A function that takes estimate class probabilities and produces a class
prediction or indeterminate prediction</h2><span id='topic+pamr.indeterminate'></span>

<h3>Description</h3>

<p>A function that takes estimate class probabilities and produces a class
prediction or indeterminate prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.indeterminate(prob, mingap = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.indeterminate_+3A_prob">prob</code></td>
<td>
<p>Estimated class probabilities, from pamr.predict with
type=&quot;posterior&quot;)</p>
</td></tr>
<tr><td><code id="pamr.indeterminate_+3A_mingap">mingap</code></td>
<td>
<p>Minimum difference between highest and second highest
probability. If difference is &lt; mingap, prediction is set to indeterminate
(NA)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Trevor Hastie, Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
suppressWarnings(RNGversion("3.5.0"))
set.seed(120)
x &lt;- matrix(rnorm(1000*20),ncol=20)
y &lt;- sample(c(1:4),size=20,replace=TRUE)
mydata &lt;- list(x=x,y=y)
mytrain &lt;-   pamr.train(mydata)
prob&lt;- pamr.predict(mytrain, mydata$x , threshold=1, type="posterior")
pamr.indeterminate(prob,mingap=.75)

</code></pre>

<hr>
<h2 id='pamr.listgenes'>A function to list the genes that survive the thresholding, from the nearest
shrunken centroid classifier</h2><span id='topic+pamr.listgenes'></span>

<h3>Description</h3>

<p>A function to list the genes that survive the thresholding, from the nearest
shrunken centroid classifier produced by pamr.train
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.listgenes(fit, data, threshold, fitcv = NULL, genenames = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.listgenes_+3A_fit">fit</code></td>
<td>
<p>The result of a call to pamr.train</p>
</td></tr>
<tr><td><code id="pamr.listgenes_+3A_data">data</code></td>
<td>
<p>The input data.  In the same format as the input data for
pamr.train</p>
</td></tr>
<tr><td><code id="pamr.listgenes_+3A_threshold">threshold</code></td>
<td>
<p>The desired threshold value</p>
</td></tr>
<tr><td><code id="pamr.listgenes_+3A_fitcv">fitcv</code></td>
<td>
<p>Optional object, result of a call to pamr.cv</p>
</td></tr>
<tr><td><code id="pamr.listgenes_+3A_genenames">genenames</code></td>
<td>
<p>Include genenames in the list? If yes, they are taken from
&quot;data&quot;. Default is false (geneid is always included in the list).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pamr.listgenes</code> List the geneids, and standardized centroids for each
class, for genes surviving at the given threshold. If fitcv is provided, the
function also reports the average rank of the gene in the cross-validation
folds, and the proportion of times that the gene is chosen (at the given
threshold) in the cross-validation folds.
</p>


<h3>Author(s)</h3>

<p>Trevor Hastie, Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#generate some data
suppressWarnings(RNGversion("3.5.0"))
set.seed(120)
x &lt;- matrix(rnorm(1000*20),ncol=20)
y &lt;- sample(c(1:4),size=20,replace=TRUE)

mydata &lt;- list(x=x,y=factor(y), geneid=as.character(1:nrow(x)),
               genenames=paste("g",as.character(1:nrow(x)),sep=""))


#train classifier
mytrain&lt;-   pamr.train(mydata)

pamr.listgenes(mytrain, mydata, threshold=1.6)
 

</code></pre>

<hr>
<h2 id='pamr.makeclasses'>A function to interactively define classes from a clustering tree</h2><span id='topic+pamr.makeclasses'></span>

<h3>Description</h3>

<p>function to interactively define classes from a clustering tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.makeclasses(data, sort.by.class = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.makeclasses_+3A_data">data</code></td>
<td>
<p>The input data. A list with components: x- an expression genes
in the rows, samples in the columns, and y- a vector of the class labels for
each sample, and batchlabels- a vector of batch labels for each sample.
This object if the same form as that produced by pamr.from.excel.</p>
</td></tr>
<tr><td><code id="pamr.makeclasses_+3A_sort.by.class">sort.by.class</code></td>
<td>
<p>Optional argument. If true, the clustering tree is
forced to put all samples in the same class (as defined by the class labels
y in &lsquo;data&rsquo;) together in the tree. This is useful if a regrouping of classes
is desired. Eg: given classes 1,2,3,4 you want to define new classes (1,3)
vs (2,4) or 2 vs (1,3)</p>
</td></tr>
<tr><td><code id="pamr.makeclasses_+3A_...">...</code></td>
<td>
<p>Any additional arguments to be passed to hclust</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pamr.makeclasses</code> Using this function the user interactively defines a
new set of classes, to be used in pamr.train, pamr.cv etc.  After invoking
pamr.makeclasses, a clustering tree is drawn.  This callss the R function
<code>hclust</code>, and any arguments for <code>hclust</code> can be passed to it.
Using the left button, the user clicks at the junction point defining the
subgroup 1. More groups can be added to class 1 by clicking on further
junction points. The user ends the definition of class 1 by clicking on the
rightmost button (in Windows, an additional menu appears and he chooses
Stop). This process is continued for classes 2,3 etc.  Note that some
sample may be left out of the new classes.  Two consecutive clicks of the
right button ends the definition for all classes.
</p>
<p>At the end, the clustering is redrawn, with the new class labels shown.
</p>
<p>Note: this function is &quot;fragile&quot;. The user must click close to the junction
point, to avoid confusion with other junction points. Classes 1,2,3..
cannot have samples in common (if they do, an Error message will appear).
If the function is confused about the desired choices, it will complain and
ask the user to rerun pamr.makeclasses. The user should also check that the
labels on the final redrawn cluster tree agrees with the desired classes.
</p>


<h3>Value</h3>

<p>A vector of class labels 1,2,3...  If a component is NA (missing),
then the sample is not assigned to any class.  This vector should be
assigned to the newy component of data, for use in pamr.train etc.  Note
that pamr.train uses the class labels in the component <code style="white-space: pre;">&#8288;newy'' if it is present. Otherwise it uses the data labels &#8288;</code>y&rdquo;.
</p>


<h3>Author(s)</h3>

<p>Trevor Hastie, Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
suppressWarnings(RNGversion("3.5.0"))
set.seed(120)
#generate some data
x &lt;- matrix(rnorm(1000*40),ncol=40)
y &lt;- sample(c(1:4),size=40,replace=TRUE)
batchlabels &lt;- sample(c(1:5),size=40,replace=TRUE)

mydata &lt;- list(x=x,y=factor(y),batchlabels=factor(batchlabels),
               geneid=as.character(1:nrow(x)),
               genenames=paste("g",as.character(1:nrow(x)),sep=""))

# mydata$newy &lt;- pamr.makeclasses(mydata) Run this and define some new classes

train &lt;- pamr.train(mydata)

</code></pre>

<hr>
<h2 id='pamr.menu'>A function that interactively leads the user through a PAM analysis</h2><span id='topic+pamr.menu'></span>

<h3>Description</h3>

<p>A function that interactively leads the user through a PAM analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.menu(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.menu_+3A_data">data</code></td>
<td>
<p>A list with at least two components: x- an expression genes in
the rows, samples in the columns), and y- a vector of the class labels for
each sample. Same form as data object used by pamr.train.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pamr.menu</code> provides a menu for training, cross-validating and plotting
a nearest shrunken centroid analysis.
</p>


<h3>Author(s)</h3>

<p>Trevor Hastie, Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
suppressWarnings(RNGversion("3.5.0"))
set.seed(120)
x &lt;- matrix(rnorm(1000*20),ncol=20)
y &lt;- sample(c(1:4),size=20,replace=TRUE)
mydata &lt;- list(x=x,y=y)
#  pamr.menu(mydata)

</code></pre>

<hr>
<h2 id='pamr.plotcen'>A function to plot the shrunken class centroids, from the nearest shrunken
centroid classifier</h2><span id='topic+pamr.plotcen'></span>

<h3>Description</h3>

<p>A function to plot the shrunken class centroids, from the nearest shrunken
centroid classifier produced by pamr.train
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.plotcen(fit, data, threshold)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.plotcen_+3A_fit">fit</code></td>
<td>
<p>The result of a call to pamr.train</p>
</td></tr>
<tr><td><code id="pamr.plotcen_+3A_data">data</code></td>
<td>
<p>The input data, in the same form as that used by pamr.train</p>
</td></tr>
<tr><td><code id="pamr.plotcen_+3A_threshold">threshold</code></td>
<td>
<p>The desired threshold value</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pamr.plotcen</code> plots the shrunken class centroids for each class, for
genes surviving the threshold for at least once class. If genenames are
included in &quot;data&quot;, they are added to the plot. Note: for many classes and
long gene names, this plot may need some manual prettying.
</p>


<h3>Author(s)</h3>

<p>Trevor Hastie, Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
suppressWarnings(RNGversion("3.5.0"))
set.seed(120)
x &lt;- matrix(rnorm(1000*20),ncol=20)
y &lt;- sample(c(1:4),size=20,replace=TRUE)
mydata &lt;- list(x=x,y=y,genenames=as.character(1:1000))
mytrain &lt;-   pamr.train(mydata)
mycv &lt;- pamr.cv(mytrain,mydata)
pamr.plotcen(mytrain, mydata,threshold=1.6)
 

</code></pre>

<hr>
<h2 id='pamr.plotcv'>A function to plot the cross-validated error curves from the nearest
shrunken centroid classifier</h2><span id='topic+pamr.plotcv'></span>

<h3>Description</h3>

<p>A function to plot the cross-validated error curves the nearest shrunken
centroid classifier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.plotcv(fit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.plotcv_+3A_fit">fit</code></td>
<td>
<p>The result of a call to pamr.cv</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pamr.plotcv</code> plots the cross-validated misclassification error curves,
from nearest shrunken centroid classifier. An overall plot, and a plot by
class, are produced.
</p>


<h3>Author(s)</h3>

<p>Trevor Hastie,Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
suppressWarnings(RNGversion("3.5.0"))
set.seed(120)
x &lt;- matrix(rnorm(1000*20),ncol=20)
y &lt;- sample(c(1:4),size=20,replace=TRUE)
mydata &lt;- list(x=x,y=y)
mytrain &lt;-   pamr.train(mydata)
mycv &lt;-  pamr.cv(mytrain, mydata)
pamr.plotcv(mycv)

</code></pre>

<hr>
<h2 id='pamr.plotcvprob'>A function to plot the cross-validated sample probabilities from the nearest
shrunken centroid classifier</h2><span id='topic+pamr.plotcvprob'></span>

<h3>Description</h3>

<p>A function to plot the cross-validated sample probabilities from the nearest
shrunken centroid classifier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.plotcvprob(fit, data, threshold)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.plotcvprob_+3A_fit">fit</code></td>
<td>
<p>The result of a call to pamr.cv</p>
</td></tr>
<tr><td><code id="pamr.plotcvprob_+3A_data">data</code></td>
<td>
<p>A list with at least two components: x- an expression genes in
the rows, samples in the columns), and y- a vector of the class labels for
each sample. Same form as data object used by pamr.train.</p>
</td></tr>
<tr><td><code id="pamr.plotcvprob_+3A_threshold">threshold</code></td>
<td>
<p>Threshold value to be used</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pamr.plotcvprob</code> plots the cross-validated sample probabilities the
from nearest shrunken centroid classifier, stratified by the true classses.
</p>


<h3>Author(s)</h3>

<p>Trevor Hastie,Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
suppressWarnings(RNGversion("3.5.0"))
set.seed(120)
x &lt;- matrix(rnorm(1000*20),ncol=20)
y &lt;- sample(c(1:4),size=20,replace=TRUE)
mydata &lt;- list(x=x,y=y)
mytrain &lt;-   pamr.train(mydata)
mycv &lt;-  pamr.cv(mytrain,mydata)
pamr.plotcvprob(mycv,mydata,threshold=1.6)




</code></pre>

<hr>
<h2 id='pamr.plotfdr'>A function to plot the FDR curve from the nearest shrunken centroid
classifier</h2><span id='topic+pamr.plotfdr'></span>

<h3>Description</h3>

<p>A function to plot the FDR curve the nearest shrunken centroid classifier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.plotfdr(fdrfit, call.win.metafile = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.plotfdr_+3A_fdrfit">fdrfit</code></td>
<td>
<p>The result of a call to pamr.fdr</p>
</td></tr>
<tr><td><code id="pamr.plotfdr_+3A_call.win.metafile">call.win.metafile</code></td>
<td>
<p>Used by Excel interface</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pamr.plotfdr</code> plots the FDR curves from nearest shrunken centroid
classifier. The median FDR (solid line) and upper 90 percentile (broken
line) are shown
</p>


<h3>Author(s)</h3>

<p>Trevor Hastie,Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
suppressWarnings(RNGversion("3.5.0"))
set.seed(120)
x &lt;- matrix(rnorm(1000*20),ncol=20)
y &lt;- sample(c(1:2),size=20,replace=TRUE)
x[1:50,y==2]=x[1:50,y==2]+3
mydata &lt;- list(x=x,y=y)
mytrain &lt;-   pamr.train(mydata)
myfdr &lt;-  pamr.fdr(mytrain, mydata)
pamr.plotfdr(myfdr)

</code></pre>

<hr>
<h2 id='pamr.plotstrata'>A function to plot the survival curves in each Kaplan Meier stratum</h2><span id='topic+pamr.plotstrata'></span>

<h3>Description</h3>

<p>A function to plot the survival curves in each Kaplan Meier stratum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.plotstrata(fit, survival.time, censoring.status)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.plotstrata_+3A_fit">fit</code></td>
<td>
<p>The result of a call to pamr.train</p>
</td></tr>
<tr><td><code id="pamr.plotstrata_+3A_survival.time">survival.time</code></td>
<td>
<p>Vector of survival times</p>
</td></tr>
<tr><td><code id="pamr.plotstrata_+3A_censoring.status">censoring.status</code></td>
<td>
<p>Vector of censoring status values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Trevor Hastie,Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gendata&lt;-function(n=100, p=2000){
  tim &lt;- 3*abs(rnorm(n))
  u&lt;-runif(n,min(tim),max(tim))
  y&lt;-pmin(tim,u)
   ic&lt;-1*(tim&lt;u)
m &lt;- median(tim)
x&lt;-matrix(rnorm(p*n),ncol=n)
  x[1:100, tim&gt;m] &lt;-  x[1:100, tim&gt;m]+3
  return(list(x=x,y=y,ic=ic))
}

# generate training data; 2000 genes, 100 samples

junk&lt;-gendata(n=100)
y&lt;-junk$y
ic&lt;-junk$ic
x&lt;-junk$x
d &lt;- list(x=x,survival.time=y, censoring.status=ic,
geneid=as.character(1:nrow(x)), genenames=paste("g",as.character(1:nrow(x)),sep=
""))

# train model
a3&lt;- pamr.train(d, ngroup.survival=2)


pamr.plotstrata(a3, d$survival.time, d$censoring.status)

</code></pre>

<hr>
<h2 id='pamr.plotsurvival'>A function to plots Kaplan-Meier curves stratified by a group variable</h2><span id='topic+pamr.plotsurvival'></span>

<h3>Description</h3>

<p>A function to plots Kaplan-Meier curves stratified by a group variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.plotsurvival(group, survival.time, censoring.status)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.plotsurvival_+3A_group">group</code></td>
<td>
<p>A grouping factor</p>
</td></tr>
<tr><td><code id="pamr.plotsurvival_+3A_survival.time">survival.time</code></td>
<td>
<p>Vector of survival times</p>
</td></tr>
<tr><td><code id="pamr.plotsurvival_+3A_censoring.status">censoring.status</code></td>
<td>
<p>Vector of censoring status values: 1=died,
0=censored</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Trevor Hastie,Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gendata&lt;-function(n=100, p=2000){
  tim &lt;- 3*abs(rnorm(n))
  u&lt;-runif(n,min(tim),max(tim))
  y&lt;-pmin(tim,u)
   ic&lt;-1*(tim&lt;u)
m &lt;- median(tim)
x&lt;-matrix(rnorm(p*n),ncol=n)
  x[1:100, tim&gt;m] &lt;-  x[1:100, tim&gt;m]+3
  return(list(x=x,y=y,ic=ic))
}

# generate training data; 2000 genes, 100 samples

junk&lt;-gendata(n=100)
y&lt;-junk$y
ic&lt;-junk$ic
x&lt;-junk$x
d &lt;- list(x=x,survival.time=y, censoring.status=ic,
geneid=as.character(1:nrow(x)), genenames=paste("g",as.character(1:nrow(x)),sep=
""))

# train model
a3&lt;- pamr.train(d, ngroup.survival=2)

#make class predictions

yhat &lt;- pamr.predict(a3,d$x, threshold=1.0)

pamr.plotsurvival(yhat, d$survival.time, d$censoring.status)


</code></pre>

<hr>
<h2 id='pamr.predict'>A function giving prediction information, from a nearest shrunken centroid
fit.</h2><span id='topic+pamr.predict'></span>

<h3>Description</h3>

<p>A function giving prediction information, from a nearest shrunken centroid
fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.predict(
  fit,
  newx,
  threshold,
  type = c("class", "posterior", "centroid", "nonzero"),
  prior = fit$prior,
  threshold.scale = fit$threshold.scale
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.predict_+3A_fit">fit</code></td>
<td>
<p>The result of a call to pamr.train</p>
</td></tr>
<tr><td><code id="pamr.predict_+3A_newx">newx</code></td>
<td>
<p>Matrix of features at which predictions are to be made</p>
</td></tr>
<tr><td><code id="pamr.predict_+3A_threshold">threshold</code></td>
<td>
<p>The desired threshold value</p>
</td></tr>
<tr><td><code id="pamr.predict_+3A_type">type</code></td>
<td>
<p>Type of prediction desired: class predictions, posterior
probabilities, (unshrunken) class centroids, vector of genes surviving the
threshold</p>
</td></tr>
<tr><td><code id="pamr.predict_+3A_prior">prior</code></td>
<td>
<p>Prior probabilities for each class. Default is that specified
in &quot;fit&quot;</p>
</td></tr>
<tr><td><code id="pamr.predict_+3A_threshold.scale">threshold.scale</code></td>
<td>
<p>Additional scaling factors to be applied to the
thresholds. Vector of length equal to the number of classes.  Default is
that specified in &quot;fit&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pamr.predict</code> Give a cross-tabulation of true versus predicted classes
for the fit returned by pamr.train or pamr.cv, at the specified threshold
</p>


<h3>Author(s)</h3>

<p>Trevor Hastie, Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
suppressWarnings(RNGversion("3.5.0"))
set.seed(120)
x &lt;- matrix(rnorm(1000*20),ncol=20)
y &lt;- sample(c(1:4),size=20,replace=TRUE)
mydata &lt;- list(x=x,y=y)
mytrain &lt;-   pamr.train(mydata)
mycv &lt;- pamr.cv(mytrain,mydata)
pamr.predict(mytrain, mydata$x , threshold=1)
 

</code></pre>

<hr>
<h2 id='pamr.predictmany'>A function giving prediction information for many threshold values, from a
nearest shrunken centroid fit.</h2><span id='topic+pamr.predictmany'></span>

<h3>Description</h3>

<p>A function giving prediction information for many threshold values, from a
nearest shrunken centroid fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.predictmany(
  fit,
  newx,
  threshold = fit$threshold,
  prior = fit$prior,
  threshold.scale = fit$threshold.scale,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.predictmany_+3A_fit">fit</code></td>
<td>
<p>The result of a call to pamr.train</p>
</td></tr>
<tr><td><code id="pamr.predictmany_+3A_newx">newx</code></td>
<td>
<p>Matrix of features at which predictions are to be made</p>
</td></tr>
<tr><td><code id="pamr.predictmany_+3A_threshold">threshold</code></td>
<td>
<p>The desired threshold values</p>
</td></tr>
<tr><td><code id="pamr.predictmany_+3A_prior">prior</code></td>
<td>
<p>Prior probabilities for each class. Default is that specified
in &quot;fit&quot;</p>
</td></tr>
<tr><td><code id="pamr.predictmany_+3A_threshold.scale">threshold.scale</code></td>
<td>
<p>Additional scaling factors to be applied to the
thresholds. Vector of length equal to the number of classes.  Default is
that specified in &quot;fit&quot;.</p>
</td></tr>
<tr><td><code id="pamr.predictmany_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to pamr.predict</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Trevor Hastie, Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
suppressWarnings(RNGversion("3.5.0"))
set.seed(120)
x &lt;- matrix(rnorm(1000*20),ncol=20)
y &lt;- sample(c(1:4),size=20,replace=TRUE)
mydata &lt;- list(x=x,y=y)
mytrain &lt;-   pamr.train(mydata)

pamr.predictmany(mytrain, mydata$x)
 

</code></pre>

<hr>
<h2 id='pamr.surv.to.class2'>A function to assign observations to categories, based on their survival
times.</h2><span id='topic+pamr.surv.to.class2'></span>

<h3>Description</h3>

<p>A function to assign observations to categories, based on their survival
times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.surv.to.class2(
  y,
  icens,
  cutoffs = NULL,
  n.class = NULL,
  class.names = NULL,
  newy = y,
  newic = icens
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.surv.to.class2_+3A_y">y</code></td>
<td>
<p>vector of survival times</p>
</td></tr>
<tr><td><code id="pamr.surv.to.class2_+3A_icens">icens</code></td>
<td>
<p>Vector of censorng status values: 1=died, 0=censored</p>
</td></tr>
<tr><td><code id="pamr.surv.to.class2_+3A_cutoffs">cutoffs</code></td>
<td>
<p>Survival time cutoffs for categories. Default NULL</p>
</td></tr>
<tr><td><code id="pamr.surv.to.class2_+3A_n.class">n.class</code></td>
<td>
<p>Number of classes to create: if cutoffs is NULL, n.class
equal classes are created.</p>
</td></tr>
<tr><td><code id="pamr.surv.to.class2_+3A_class.names">class.names</code></td>
<td>
<p>Character names for classes</p>
</td></tr>
<tr><td><code id="pamr.surv.to.class2_+3A_newy">newy</code></td>
<td>
<p>New set of survival times, for which probabilities are computed
(see below). Default is y</p>
</td></tr>
<tr><td><code id="pamr.surv.to.class2_+3A_newic">newic</code></td>
<td>
<p>New set of censoring statuses, for which probabilities are
computed (see below). Default is icens</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pamr.pamr.surv.to.class2</code> splits observations into categories based on
their survival times and the Kaplan-Meier estimates. For example if
n.class=2, it makes two categories, one below the median survival, the other
above. For each observation (newy, ic), it then computes the probability of
that observation falling in each category. For an uncensored observation
that probability is just 1 or 0 depending on when the death occurred. For a
censored observation, the probabilities are based on the Kaplan Meier and
are typically between 0 and 1.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>class</code></td>
<td>
<p>The category labels</p>
</td></tr> <tr><td><code>prob</code></td>
<td>
<p>The estimates class
probabilities</p>
</td></tr> <tr><td><code>cutoffs</code></td>
<td>
<p>The cutoffs used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Trevor Hastie, Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gendata&lt;-function(n=100, p=2000){
  tim &lt;- 3*abs(rnorm(n))
  u&lt;-runif(n,min(tim),max(tim))
  y&lt;-pmin(tim,u)
   ic&lt;-1*(tim&lt;u)
m &lt;- median(tim)
x&lt;-matrix(rnorm(p*n),ncol=n)
  x[1:100, tim&gt;m] &lt;-  x[1:100, tim&gt;m]+3
  return(list(x=x,y=y,ic=ic))
}

# generate training data; 2000 genes, 100 samples

junk&lt;-gendata(n=100)
y&lt;-junk$y
ic&lt;-junk$ic
x&lt;-junk$x
d &lt;- list(x=x,survival.time=y, censoring.status=ic,
geneid=as.character(1:nrow(x)), genenames=paste("g",as.character(1:nrow(x)),sep=
""))

# train model
a3&lt;- pamr.train(d, ngroup.survival=2)

# generate test data
junkk&lt;- gendata(n=500)

dd &lt;- list(x=junkk$x, survival.time=junkk$y, censoring.status=junkk$ic)

# compute soft labels
proby &lt;-  pamr.surv.to.class2(dd$survival.time, dd$censoring.status,
             n.class=a3$ngroup.survival)$prob


</code></pre>

<hr>
<h2 id='pamr.test.errors.surv.compute'>A function giving a table of true versus predicted values, from a nearest
shrunken centroid fit from survival data.</h2><span id='topic+pamr.test.errors.surv.compute'></span>

<h3>Description</h3>

<p>A function giving a table of true versus predicted values, from a nearest
shrunken centroid fit from survival data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.test.errors.surv.compute(proby, yhat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.test.errors.surv.compute_+3A_proby">proby</code></td>
<td>
<p>Survival class probabilities, from pamr.surv.to.class2</p>
</td></tr>
<tr><td><code id="pamr.test.errors.surv.compute_+3A_yhat">yhat</code></td>
<td>
<p>Estimated class labels, from pamr.predict</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pamr.test.errors.surv.compute</code> computes the erros between the true
'soft&quot; class labels proby and the estimated ones &quot;yhat&quot;
</p>


<h3>Author(s)</h3>

<p>Trevor Hastie, Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 
gendata&lt;-function(n=100, p=2000){
  tim &lt;- 3*abs(rnorm(n))
  u&lt;-runif(n,min(tim),max(tim))
  y&lt;-pmin(tim,u)
   ic&lt;-1*(tim&lt;u)
m &lt;- median(tim)
x&lt;-matrix(rnorm(p*n),ncol=n)
  x[1:100, tim&gt;m] &lt;-  x[1:100, tim&gt;m]+3
  return(list(x=x,y=y,ic=ic))
}

# generate training data; 2000 genes, 100 samples

junk&lt;-gendata(n=100)
y&lt;-junk$y
ic&lt;-junk$ic
x&lt;-junk$x
d &lt;- list(x=x,survival.time=y, censoring.status=ic, 
geneid=as.character(1:nrow(x)), genenames=paste("g",as.character(1:nrow(x)),sep=
""))

# train model
a3&lt;- pamr.train(d, ngroup.survival=2)

# generate test data
junkk&lt;- gendata(n=500)

dd &lt;- list(x=junkk$x, survival.time=junkk$y, censoring.status=junkk$ic)

# compute soft labels
proby &lt;-  pamr.surv.to.class2(dd$survival.time, dd$censoring.status,
             n.class=a3$ngroup.survival)$prob


# make class predictions for test data
yhat &lt;- pamr.predict(a3,dd$x, threshold=1.0)

# compute test errors

pamr.test.errors.surv.compute(proby, yhat)


</code></pre>

<hr>
<h2 id='pamr.train'>A function to train a nearest shrunken centroid classifier</h2><span id='topic+pamr.train'></span>

<h3>Description</h3>

<p>A function that computes a nearest shrunken centroid for gene expression
(microarray) data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamr.train(
  data,
  gene.subset = NULL,
  sample.subset = NULL,
  threshold = NULL,
  n.threshold = 30,
  scale.sd = TRUE,
  threshold.scale = NULL,
  se.scale = NULL,
  offset.percent = 50,
  hetero = NULL,
  prior = NULL,
  remove.zeros = TRUE,
  sign.contrast = "both",
  ngroup.survival = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pamr.train_+3A_data">data</code></td>
<td>
<p>The input data. A list with components: x- an expression genes
in the rows, samples in the columns), and y- a vector of the class labels
for each sample.  Optional components- genenames, a vector of gene names,
and geneid- a vector of gene identifiers.</p>
</td></tr>
<tr><td><code id="pamr.train_+3A_gene.subset">gene.subset</code></td>
<td>
<p>Subset of genes to be used.  Can be either a logical
vector of length total number of genes, or a list of integers of the row
numbers of the genes to be used</p>
</td></tr>
<tr><td><code id="pamr.train_+3A_sample.subset">sample.subset</code></td>
<td>
<p>Subset of samples to be used.  Can be either a logical
vector of length total number of samples, or a list of integers of the
column numbers of the samples to be used.</p>
</td></tr>
<tr><td><code id="pamr.train_+3A_threshold">threshold</code></td>
<td>
<p>A vector of threshold values for the centroid
shrinkage.Default is a set of 30 values chosen by the software</p>
</td></tr>
<tr><td><code id="pamr.train_+3A_n.threshold">n.threshold</code></td>
<td>
<p>Number of threshold values desired (default 30)</p>
</td></tr>
<tr><td><code id="pamr.train_+3A_scale.sd">scale.sd</code></td>
<td>
<p>Scale each threshold by the wthin class standard deviations?
Default: true</p>
</td></tr>
<tr><td><code id="pamr.train_+3A_threshold.scale">threshold.scale</code></td>
<td>
<p>Additional scaling factors to be applied to the
thresholds. Vector of length equal to the number of classes.  Default- a
vectors of ones.</p>
</td></tr>
<tr><td><code id="pamr.train_+3A_se.scale">se.scale</code></td>
<td>
<p>Vector of scaling factors for the within class standard
errors. Default is sqrt(1/n.class-1/n), where n is the overall sample size
and n.class is the sample sizes in each class. This default adjusts for
different class sizes.</p>
</td></tr>
<tr><td><code id="pamr.train_+3A_offset.percent">offset.percent</code></td>
<td>
<p>Fudge factor added to the denominator of each
t-statistic, expressed as a percentile of the gene standard deviation
values.  This is a small positive quantity to penalize genes with expression
values near zero, which can result in very large ratios. This factor is
expecially impotant for Affy data. Default is the median of the standard
deviations of each gene.</p>
</td></tr>
<tr><td><code id="pamr.train_+3A_hetero">hetero</code></td>
<td>
<p>Should a heterogeneity transformation be done?  If yes, hetero
must be set to one of the class labels (see Details below).  Default is no
(hetero=NULL)</p>
</td></tr>
<tr><td><code id="pamr.train_+3A_prior">prior</code></td>
<td>
<p>Vector of length the number of classes, representing prior
probabilities for each of the classes. The prior is used in Bayes rule for
making class prediction. Default is NULL, and prior is then taken to be
n.class/n, where n is the overall sample size and n.class is the sample
sizes in each class.</p>
</td></tr>
<tr><td><code id="pamr.train_+3A_remove.zeros">remove.zeros</code></td>
<td>
<p>Remove threshold values yielding zero genes? Default
TRUE</p>
</td></tr>
<tr><td><code id="pamr.train_+3A_sign.contrast">sign.contrast</code></td>
<td>
<p>Directions of allowed deviations of class-wise average
gene expression from the overall average gene expression. Default is
<code style="white-space: pre;">&#8288;both'' (positive or negative).  Can also be set to &#8288;</code>positive&rdquo; or
&ldquo;negative&rdquo;.</p>
</td></tr>
<tr><td><code id="pamr.train_+3A_ngroup.survival">ngroup.survival</code></td>
<td>
<p>Number of groups formed for survival data. Default 2</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pamr.train</code> fits a nearest shrunken centroid classifier to gene
expression data. Details may be found in the PNAS paper referenced below.
One feature not described there is &quot;heterogeneity analysis&quot;.  Suppose there
are two classes labelled &quot;A&quot; and &quot;B&quot;.  CLass &quot;A&quot; is considered a normal
class, and &quot;B&quot; an abnormal class.  Setting hetero=&quot;A&quot; transforms expression
values <code class="reqn">x[i,j]</code> to <code class="reqn">|x[i,j]- mean(x[i,j])|</code> where the mean is taken only over
samples in class &quot;A&quot;. The transformed feature values are then used in Pam.
This is useful when the abnormal class &quot;B&quot; is heterogeneous, i.e.  a given
gene might have higher expresion than normal for some class &quot;B&quot; samples, and
lower for others.  With more than 2 classes, each class is centered on the
class specified by hetero.
</p>


<h3>Value</h3>

<p>A list with components </p>
<table role = "presentation">
<tr><td><code>y</code></td>
<td>
<p>The outcome classes.</p>
</td></tr> <tr><td><code>yhat</code></td>
<td>
<p>A
matrix of predicted classes, each column representing the results from one
threshold.</p>
</td></tr></table>
<p>.  </p>
<table role = "presentation">
<tr><td><code>prob</code></td>
<td>
<p>A array of predicted class probabilities. of
dimension n by nclass by n.threshold. n is the number samples, nclass is the
number of classes, n.threshold is the number of thresholds tried</p>
</td></tr>
<tr><td><code>centroids</code></td>
<td>
<p>A matrix of (unshrunken) class centroids, n by nclass</p>
</td></tr>
<tr><td><code>hetero</code></td>
<td>
<p>Value of hetero used in call to pamr.train</p>
</td></tr>
<tr><td><code>norm.cent</code></td>
<td>
<p>Centroid of &quot;normal&quot; group, if hetero was specified</p>
</td></tr>
<tr><td><code>centroid.overall</code></td>
<td>
<p>A vector containing the (unshrunken) overall
centroid (all classes together)</p>
</td></tr> <tr><td><code>sd</code></td>
<td>
<p>A vector of the standard
deviations for each gene</p>
</td></tr> <tr><td><code>threshold</code></td>
<td>
<p>A vector of the threshold tried
in the shrinkage</p>
</td></tr> <tr><td><code>nonzero</code></td>
<td>
<p>A vector of the number of genes that
survived the thresholding, for each threshold value tried</p>
</td></tr>
<tr><td><code>threshold.scale</code></td>
<td>
<p>A vector of threshold scale factors that were used</p>
</td></tr>
<tr><td><code>se.scale</code></td>
<td>
<p>A vector of standard error scale factors that were used</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The calling sequence used</p>
</td></tr> <tr><td><code>prior</code></td>
<td>
<p>The prior probabilities
used</p>
</td></tr> <tr><td><code>errors</code></td>
<td>
<p>The number of trainin errors for each threshold value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Trevor Hastie,Robert Tibshirani, Balasubramanian Narasimhan, and
Gilbert Chu
</p>


<h3>References</h3>

<p>Robert Tibshirani, Trevor Hastie, Balasubramanian Narasimhan,
and Gilbert Chu Diagnosis of multiple cancer types by shrunken centroids of
gene expression PNAS 99: 6567-6572.  Available at www.pnas.org
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#generate some data
suppressWarnings(RNGversion("3.5.0"))
set.seed(120)
x &lt;- matrix(rnorm(1000*20),ncol=20)
y &lt;- sample(c(1:4),size=20,replace=TRUE)
mydata &lt;- list(x=x,y=factor(y))

#train classifier
results&lt;-   pamr.train(mydata)

# train classifier on all  data except class 4
results2 &lt;- pamr.train(mydata,sample.subset=(mydata$y!=4))
 
# train classifier on  only the first 500 genes
results3 &lt;- pamr.train(mydata,gene.subset=1:500)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
