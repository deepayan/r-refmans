<!DOCTYPE html><html><head><title>Help for package stringb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stringb}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%..%'><p>concatenating strings</p></a></li>
<li><a href='#%.%'><p>concatenating strings operator</p></a></li>
<li><a href='#as.data.frame'><p>a stringsAsFactors=FALSE as.data.frame</p></a></li>
<li><a href='#cuts_to_spans'><p>helper function that turns cut points into spans</p></a></li>
<li><a href='#data.frame'><p>a stringsAsFactors=FALSE data.frame</p></a></li>
<li><a href='#de_sequenize'><p>helper function to transforms sequences into spans</p></a></li>
<li><a href='#drop_non_group_matches'><p>helper for usage of regmatches</p></a></li>
<li><a href='#dummy_func'><p>imports</p></a></li>
<li><a href='#get_groups'><p>helper function for text_extract_group</p></a></li>
<li><a href='#invert_spans'><p>function to invert spans to those numbers not covered</p></a></li>
<li><a href='#plot.character'><p>function for plotting text</p></a></li>
<li><a href='#regmatches2'><p>helper function to standardize regexpr results</p></a></li>
<li><a href='#sequenize'><p>helper function to spans into sequences</p></a></li>
<li><a href='#stringb_arrange'><p>function to sort df by variables</p></a></li>
<li><a href='#test_file'><p>text function: wrapper for system.file() to access test files</p></a></li>
<li><a href='#text_c'><p>generic for concatonating strings</p></a></li>
<li><a href='#text_collapse'><p>function for collapsing text vectors</p></a></li>
<li><a href='#text_count'><p>generic for counting pattern occurences</p></a></li>
<li><a href='#text_delete'><p>deleting patterns in string</p></a></li>
<li><a href='#text_detect'><p>generic function to test if a regex can be found within a string</p></a></li>
<li><a href='#text_eval'><p>wrapper function of eval() and parse() to evaluate character vector</p></a></li>
<li><a href='#text_extract'><p>extract regex matches</p></a></li>
<li><a href='#text_extract_all'><p>extract regex matches</p></a></li>
<li><a href='#text_extract_group'><p>generic for getting regex group matches</p></a></li>
<li><a href='#text_extract_group_all'><p>generic for getting all regex group matches</p></a></li>
<li><a href='#text_filter'><p>generic for subsetting/filtering vectors</p></a></li>
<li><a href='#text_length'><p>wrapper around nchar to return text length</p></a></li>
<li><a href='#text_locate'><p>function to get start, end, length form pattern match</p></a></li>
<li><a href='#text_locate_all'><p>function to get start, end, length form pattern match for all matches</p></a></li>
<li><a href='#text_locate_all_worker'><p>helper function to get start, end, length form pattern match</p></a></li>
<li><a href='#text_locate_group'><p>generic for getting positions regex groups</p></a></li>
<li><a href='#text_locate_worker'><p>helper function to get start, end, length form pattern match</p></a></li>
<li><a href='#text_nchar'><p>wrapper around nchar to return text length</p></a></li>
<li><a href='#text_pad'><p>padding text to specified width</p></a></li>
<li><a href='#text_read'><p>read in text</p></a></li>
<li><a href='#text_rep'><p>generic repeating text</p></a></li>
<li><a href='#text_replace'><p>replacing patterns in string</p></a></li>
<li><a href='#text_replace_all'><p>replacing patterns in string</p></a></li>
<li><a href='#text_replace_group'><p>function for replacing regex group matches</p>
generic for getting regex group matches</a></li>
<li><a href='#text_replace_locates'><p>text_replace_locates default</p></a></li>
<li><a href='#text_show'><p>showing text</p></a></li>
<li><a href='#text_snippet'><p>retrieving text snippet</p></a></li>
<li><a href='#text_split'><p>generic splitting strings</p></a></li>
<li><a href='#text_split_n'><p>generic splitting strings into pieces of length n</p></a></li>
<li><a href='#text_sub'><p>generic for extracting characters sequences by position</p></a></li>
<li><a href='#text_subset'><p>generic for subsetting/filtering vectors</p></a></li>
<li><a href='#text_to_lower'><p>function for make text lower case</p></a></li>
<li><a href='#text_to_title_case'><p>function for make text lower case</p></a></li>
<li><a href='#text_to_upper'><p>function for make text lower case</p></a></li>
<li><a href='#text_tokenize'><p>generic for gregexpr wrappers to tokenize text</p></a></li>
<li><a href='#text_tokenize_lines'><p>generic to tokenize text into lines</p></a></li>
<li><a href='#text_tokenize_sentences'><p>generic to tokenize text into sentences</p></a></li>
<li><a href='#text_tokenize_words'><p>generic to tokenize text into words</p></a></li>
<li><a href='#text_trim'><p>trim spaces</p></a></li>
<li><a href='#text_which'><p>generic function to know in which elements a pattern can be found</p></a></li>
<li><a href='#text_which_value'><p>generic function to get whole elements in which pattern was found</p></a></li>
<li><a href='#text_wrap'><p>wraping text to specified width</p></a></li>
<li><a href='#text_write'><p>write text to file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Convenient Base R String Handling</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-01-25</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.17</td>
</tr>
<tr>
<td>Description:</td>
<td>Base R already ships with string handling capabilities 'out-
    of-the-box' but lacks streamlined function names and workflow. The
    'stringi' ('stringr') package on the other hand has well named functions,
    extensive Unicode support and allows for a streamlined workflow. On the other
    hand it adds dependencies and regular expression interpretation between base R
    functions and 'stringi' functions might differ. This packages aims at providing
    a solution to the use case of unwanted dependencies on the one hand but the need
    for streamlined text processing on the other. The packages' functions are solely
    based on wrapping base R functions into 'stringr'/'stringi' like function names.
    Along the way it adds one or two extra functions and last but not least provides
    all functions as generics, therefore allowing for adding methods for other text
    structures besides plain character vectors.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, tools, backports</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, covr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/petermeissner/stringb/issues">https://github.com/petermeissner/stringb/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/petermeissner/stringb">https://github.com/petermeissner/stringb</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-25 21:36:48 UTC; peter</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Meissner [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Meissner &lt;retep.meissner@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-25 22:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25..+25'>concatenating strings</h2><span id='topic++25..+25'></span>

<h3>Description</h3>

<p>concatenating strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a %..% b
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25..+2B25_+3A_a">a</code></td>
<td>
<p>first text</p>
</td></tr>
<tr><td><code id="+2B25..+2B25_+3A_b">b</code></td>
<td>
<p>first text</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+text_c">text_c</a> (and <a href="base.html#topic+paste">paste</a>)
</p>

<hr>
<h2 id='+25.+25'>concatenating strings operator</h2><span id='topic++25.+25'></span>

<h3>Description</h3>

<p>concatenating strings operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a %.% b
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25.+2B25_+3A_a">a</code></td>
<td>
<p>first text</p>
</td></tr>
<tr><td><code id="+2B25.+2B25_+3A_b">b</code></td>
<td>
<p>second text</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+text_c">text_c</a> (and <a href="base.html#topic+paste">paste</a>)
</p>

<hr>
<h2 id='as.data.frame'>a stringsAsFactors=FALSE as.data.frame</h2><span id='topic+as.data.frame'></span>

<h3>Description</h3>

<p>a stringsAsFactors=FALSE as.data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.data.frame(..., stringsAsFactors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame_+3A_...">...</code></td>
<td>
<p>passed through to data.frame</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>set to false by default</p>
</td></tr>
</table>

<hr>
<h2 id='cuts_to_spans'>helper function that turns cut points into spans</h2><span id='topic+cuts_to_spans'></span>

<h3>Description</h3>

<p>helper function that turns cut points into spans
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cuts_to_spans(cuts, start = 1, end = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cuts_to_spans_+3A_cuts">cuts</code></td>
<td>
<p>where after to cut into pieces</p>
</td></tr>
<tr><td><code id="cuts_to_spans_+3A_end">end</code></td>
<td>
<p>where does it all end</p>
</td></tr>
</table>

<hr>
<h2 id='data.frame'>a stringsAsFactors=FALSE data.frame</h2><span id='topic+data.frame'></span>

<h3>Description</h3>

<p>a stringsAsFactors=FALSE data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.frame(..., stringsAsFactors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.frame_+3A_...">...</code></td>
<td>
<p>passed through to data.frame</p>
</td></tr>
<tr><td><code id="data.frame_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>set to false by default</p>
</td></tr>
</table>

<hr>
<h2 id='de_sequenize'>helper function to transforms sequences into spans</h2><span id='topic+de_sequenize'></span>

<h3>Description</h3>

<p>helper function to transforms sequences into spans
</p>


<h3>Usage</h3>

<pre><code class='language-R'>de_sequenize(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="de_sequenize_+3A_x">x</code></td>
<td>
<p>a bunch of numbers to urn into sequences</p>
</td></tr>
</table>

<hr>
<h2 id='drop_non_group_matches'>helper for usage of regmatches</h2><span id='topic+drop_non_group_matches'></span>

<h3>Description</h3>

<p>helper for usage of regmatches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_non_group_matches(tmp, group = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_non_group_matches_+3A_tmp">tmp</code></td>
<td>
<p>result from regexec or gregexpr or regexpr</p>
</td></tr>
</table>

<hr>
<h2 id='dummy_func'>imports</h2><span id='topic+dummy_func'></span>

<h3>Description</h3>

<p>imports
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummy_func()
</code></pre>

<hr>
<h2 id='get_groups'>helper function for text_extract_group</h2><span id='topic+get_groups'></span>

<h3>Description</h3>

<p>helper function for text_extract_group
</p>
<p>helper function for text_replace_group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_groups(x, group)

get_groups(x, group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_groups_+3A_x">x</code></td>
<td>
<p>text_replace_group result</p>
</td></tr>
<tr><td><code id="get_groups_+3A_groups">groups</code></td>
<td>
<p>groups to extract</p>
</td></tr>
</table>

<hr>
<h2 id='invert_spans'>function to invert spans to those numbers not covered</h2><span id='topic+invert_spans'></span>

<h3>Description</h3>

<p>function to invert spans to those numbers not covered
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invert_spans(from, to = NULL, start = 1, end = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invert_spans_+3A_from">from</code></td>
<td>
<p>vector of span starts</p>
</td></tr>
<tr><td><code id="invert_spans_+3A_to">to</code></td>
<td>
<p>vector of span ends</p>
</td></tr>
<tr><td><code id="invert_spans_+3A_start">start</code></td>
<td>
<p>minimum</p>
</td></tr>
<tr><td><code id="invert_spans_+3A_end">end</code></td>
<td>
<p>maximum value</p>
</td></tr>
</table>

<hr>
<h2 id='plot.character'>function for plotting text</h2><span id='topic+plot.character'></span>

<h3>Description</h3>

<p>function for plotting text
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'character'
plot(
  x,
  y = NULL,
  col = "grey",
  border = "grey",
  pattern = NULL,
  pattern_col = "#ED4C4C",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.character_+3A_x">x</code></td>
<td>
<p>object of class rtext</p>
</td></tr>
<tr><td><code id="plot.character_+3A_y">y</code></td>
<td>
<p>either NULL or a data.frame with columns &quot;start&quot;, &quot;end&quot;, &quot;line&quot;</p>
</td></tr>
<tr><td><code id="plot.character_+3A_col">col</code></td>
<td>
<p>color for text</p>
</td></tr>
<tr><td><code id="plot.character_+3A_border">border</code></td>
<td>
<p>border color for text</p>
</td></tr>
<tr><td><code id="plot.character_+3A_pattern">pattern</code></td>
<td>
<p>regular expression to be searched in text and marked up in plot</p>
</td></tr>
<tr><td><code id="plot.character_+3A_pattern_col">pattern_col</code></td>
<td>
<p>color for text to be marked up via pattern or y option</p>
</td></tr>
<tr><td><code id="plot.character_+3A_...">...</code></td>
<td>
<p>further parameters passed through to text_locate</p>
</td></tr>
</table>

<hr>
<h2 id='regmatches2'>helper function to standardize regexpr results</h2><span id='topic+regmatches2'></span>

<h3>Description</h3>

<p>helper function to standardize regexpr results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regmatches2(tmp, group = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regmatches2_+3A_tmp">tmp</code></td>
<td>
<p>regexpr or gregexpr result</p>
</td></tr>
</table>

<hr>
<h2 id='sequenize'>helper function to spans into sequences</h2><span id='topic+sequenize'></span>

<h3>Description</h3>

<p>helper function to spans into sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequenize(start, end = NULL, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sequenize_+3A_start">start</code></td>
<td>
<p>first number of sequence</p>
</td></tr>
<tr><td><code id="sequenize_+3A_end">end</code></td>
<td>
<p>last number of sequence</p>
</td></tr>
<tr><td><code id="sequenize_+3A_simplify">simplify</code></td>
<td>
<p>discard order, duplicaes etc?</p>
</td></tr>
</table>

<hr>
<h2 id='stringb_arrange'>function to sort df by variables</h2><span id='topic+stringb_arrange'></span>

<h3>Description</h3>

<p>function to sort df by variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stringb_arrange(df, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stringb_arrange_+3A_df">df</code></td>
<td>
<p>data.frame to be sorted</p>
</td></tr>
<tr><td><code id="stringb_arrange_+3A_...">...</code></td>
<td>
<p>column names to use for sorting</p>
</td></tr>
</table>

<hr>
<h2 id='test_file'>text function: wrapper for system.file() to access test files</h2><span id='topic+test_file'></span>

<h3>Description</h3>

<p>text function: wrapper for system.file() to access test files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_file(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_file_+3A_x">x</code></td>
<td>
<p>name of the file</p>
</td></tr>
</table>

<hr>
<h2 id='text_c'>generic for concatonating strings</h2><span id='topic+text_c'></span><span id='topic+text_c.default'></span>

<h3>Description</h3>

<p>generic for concatonating strings
</p>
<p>text_c default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_c(..., sep = "", coll = NULL)

## Default S3 method:
text_c(..., sep = "", coll = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_c_+3A_...">...</code></td>
<td>
<p>one or more texts to be concatonated (see also <a href="base.html#topic+paste">paste</a>)</p>
</td></tr>
<tr><td><code id="text_c_+3A_sep">sep</code></td>
<td>
<p>separator between concatonated elements (see also <a href="base.html#topic+paste">paste</a>)</p>
</td></tr>
<tr><td><code id="text_c_+3A_coll">coll</code></td>
<td>
<p>if texts (not only there elements) are to be collapsed as well,
how should the be separated (see also <a href="base.html#topic+paste">paste</a>)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+grapes-..-grapes">%..%</a> and <a href="#topic+grapes-.-grapes">%.%</a>
</p>

<hr>
<h2 id='text_collapse'>function for collapsing text vectors</h2><span id='topic+text_collapse'></span><span id='topic+text_collapse.default'></span><span id='topic+text_collapse.list'></span><span id='topic+text_collapse.data.frame'></span><span id='topic+text_collapse.matrix'></span>

<h3>Description</h3>

<p>function for collapsing text vectors
</p>
<p>default method for text_collapse()
</p>
<p>text_collapse() mehtod for list
</p>
<p>text_collapse() method for data.frames
</p>
<p>text_collapse() method for matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_collapse(x, coll = "")

## Default S3 method:
text_collapse(x, coll = "")

## S3 method for class 'list'
text_collapse(x, coll = "")

## S3 method for class 'data.frame'
text_collapse(x, coll = "")

## S3 method for class 'matrix'
text_collapse(x, coll = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_collapse_+3A_x">x</code></td>
<td>
<p>object to be collapsed</p>
</td></tr>
<tr><td><code id="text_collapse_+3A_coll">coll</code></td>
<td>
<p>separator between collapsed text parts</p>
</td></tr>
</table>

<hr>
<h2 id='text_count'>generic for counting pattern occurences</h2><span id='topic+text_count'></span><span id='topic+text_count.default'></span>

<h3>Description</h3>

<p>generic for counting pattern occurences
</p>
<p>text_count default method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_count(string, pattern, sum = FALSE, vectorize = FALSE, ...)

## Default S3 method:
text_count(string, pattern, sum = FALSE, vectorize = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_count_+3A_string">string</code></td>
<td>
<p>text to search through</p>
</td></tr>
<tr><td><code id="text_count_+3A_pattern">pattern</code></td>
<td>
<p>regex to search for</p>
</td></tr>
<tr><td><code id="text_count_+3A_sum">sum</code></td>
<td>
<p>if true all element-wise counts will be summed up</p>
</td></tr>
<tr><td><code id="text_count_+3A_vectorize">vectorize</code></td>
<td>
<p>should function be used in vectorized mode, i.e. should a
pattern with length larger than 1 be allowed and if so, should it be
matched to lines (with recycling if needed) instead of using on element on
all lines</p>
</td></tr>
<tr><td><code id="text_count_+3A_...">...</code></td>
<td>
<p>further arguments passed through to <a href="base.html#topic+grep">grep</a></p>
</td></tr>
</table>

<hr>
<h2 id='text_delete'>deleting patterns in string</h2><span id='topic+text_delete'></span><span id='topic+text_delete.default'></span>

<h3>Description</h3>

<p>deleting patterns in string
</p>
<p>deleting patterns in string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_delete(string, pattern = NULL, ...)

## Default S3 method:
text_delete(string, pattern = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_delete_+3A_string">string</code></td>
<td>
<p>text to be replaced</p>
</td></tr>
<tr><td><code id="text_delete_+3A_pattern">pattern</code></td>
<td>
<p>regex to look for and delete</p>
</td></tr>
<tr><td><code id="text_delete_+3A_...">...</code></td>
<td>
<p>further parameter passed through to sub</p>
</td></tr>
</table>

<hr>
<h2 id='text_detect'>generic function to test if a regex can be found within a string</h2><span id='topic+text_detect'></span><span id='topic+text_detect.default'></span><span id='topic+text_grepl'></span>

<h3>Description</h3>

<p>generic function to test if a regex can be found within a string
</p>
<p>text_detect default method
</p>
<p>generic function to test if a regex can be found within a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_detect(string, pattern, ...)

## Default S3 method:
text_detect(string, pattern, ...)

text_grepl(string, pattern, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_detect_+3A_string">string</code></td>
<td>
<p>text to be searched through</p>
</td></tr>
<tr><td><code id="text_detect_+3A_pattern">pattern</code></td>
<td>
<p>regex to look for</p>
</td></tr>
<tr><td><code id="text_detect_+3A_...">...</code></td>
<td>
<p>further arguments passed through to <a href="base.html#topic+grep">grep</a></p>
</td></tr>
</table>

<hr>
<h2 id='text_eval'>wrapper function of eval() and parse() to evaluate character vector</h2><span id='topic+text_eval'></span>

<h3>Description</h3>

<p>wrapper function of eval() and parse() to evaluate character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_eval(x, envir = parent.frame(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_eval_+3A_x">x</code></td>
<td>
<p>character vector to be parsed and evaluated</p>
</td></tr>
<tr><td><code id="text_eval_+3A_envir">envir</code></td>
<td>
<p>where to evaluate character vector</p>
</td></tr>
<tr><td><code id="text_eval_+3A_...">...</code></td>
<td>
<p>arguments passed through to eval()</p>
</td></tr>
</table>

<hr>
<h2 id='text_extract'>extract regex matches</h2><span id='topic+text_extract'></span>

<h3>Description</h3>

<p>wrapper function around regexec and regmatches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_extract(
  x,
  pattern,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE,
  invert = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_extract_+3A_x">x</code></td>
<td>
<p>text from which to extract</p>
</td></tr>
<tr><td><code id="text_extract_+3A_pattern">pattern</code></td>
<td>
<p>see <a href="base.html#topic+grep">grep</a></p>
</td></tr>
<tr><td><code id="text_extract_+3A_ignore.case">ignore.case</code></td>
<td>
<p>see <a href="base.html#topic+grep">grep</a></p>
</td></tr>
<tr><td><code id="text_extract_+3A_perl">perl</code></td>
<td>
<p>see <a href="base.html#topic+grep">grep</a></p>
</td></tr>
<tr><td><code id="text_extract_+3A_fixed">fixed</code></td>
<td>
<p>see <a href="base.html#topic+grep">grep</a></p>
</td></tr>
<tr><td><code id="text_extract_+3A_usebytes">useBytes</code></td>
<td>
<p>see <a href="base.html#topic+grep">grep</a></p>
</td></tr>
<tr><td><code id="text_extract_+3A_invert">invert</code></td>
<td>
<p>if TRUE non-regex-matches are extracted instead</p>
</td></tr>
</table>

<hr>
<h2 id='text_extract_all'>extract regex matches</h2><span id='topic+text_extract_all'></span>

<h3>Description</h3>

<p>wrapper function around gregexec and regmatches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_extract_all(
  x,
  pattern,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE,
  invert = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_extract_all_+3A_x">x</code></td>
<td>
<p>text from which to extract</p>
</td></tr>
<tr><td><code id="text_extract_all_+3A_pattern">pattern</code></td>
<td>
<p>see <a href="base.html#topic+grep">grep</a></p>
</td></tr>
<tr><td><code id="text_extract_all_+3A_ignore.case">ignore.case</code></td>
<td>
<p>see <a href="base.html#topic+grep">grep</a></p>
</td></tr>
<tr><td><code id="text_extract_all_+3A_perl">perl</code></td>
<td>
<p>see <a href="base.html#topic+grep">grep</a></p>
</td></tr>
<tr><td><code id="text_extract_all_+3A_fixed">fixed</code></td>
<td>
<p>see <a href="base.html#topic+grep">grep</a></p>
</td></tr>
<tr><td><code id="text_extract_all_+3A_usebytes">useBytes</code></td>
<td>
<p>see <a href="base.html#topic+grep">grep</a></p>
</td></tr>
<tr><td><code id="text_extract_all_+3A_invert">invert</code></td>
<td>
<p>if TRUE non-regex-matches are extracted instead</p>
</td></tr>
</table>

<hr>
<h2 id='text_extract_group'>generic for getting regex group matches</h2><span id='topic+text_extract_group'></span><span id='topic+text_extract_group.default'></span>

<h3>Description</h3>

<p>generic for getting regex group matches
</p>
<p>text default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_extract_group(string, pattern, group, invert = FALSE, ...)

## Default S3 method:
text_extract_group(string, pattern, group = NULL, invert = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_extract_group_+3A_string">string</code></td>
<td>
<p>text from which to extract character sequence</p>
</td></tr>
<tr><td><code id="text_extract_group_+3A_pattern">pattern</code></td>
<td>
<p>regex to be searched for</p>
</td></tr>
<tr><td><code id="text_extract_group_+3A_group">group</code></td>
<td>
<p>integer vector to indicate those regex group matches to extract</p>
</td></tr>
<tr><td><code id="text_extract_group_+3A_invert">invert</code></td>
<td>
<p>whether or no matches or non-matches should be extracted</p>
</td></tr>
<tr><td><code id="text_extract_group_+3A_...">...</code></td>
<td>
<p>further parameter passed through to <a href="base.html#topic+grep">grep</a></p>
</td></tr>
</table>

<hr>
<h2 id='text_extract_group_all'>generic for getting all regex group matches</h2><span id='topic+text_extract_group_all'></span><span id='topic+text_extract_group_all.default'></span>

<h3>Description</h3>

<p>generic for getting all regex group matches
</p>
<p>text default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_extract_group_all(string, pattern, group = NULL, invert = FALSE, ...)

## Default S3 method:
text_extract_group_all(string, pattern, group = NULL, invert = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_extract_group_all_+3A_string">string</code></td>
<td>
<p>text from which to extract character sequence</p>
</td></tr>
<tr><td><code id="text_extract_group_all_+3A_pattern">pattern</code></td>
<td>
<p>regex to be searched for</p>
</td></tr>
<tr><td><code id="text_extract_group_all_+3A_group">group</code></td>
<td>
<p>integer vector to indicate those regex group matches to extract</p>
</td></tr>
<tr><td><code id="text_extract_group_all_+3A_invert">invert</code></td>
<td>
<p>whether or no matches or non-matches should be extracted</p>
</td></tr>
<tr><td><code id="text_extract_group_all_+3A_...">...</code></td>
<td>
<p>further parameter passed through to <a href="base.html#topic+grep">grep</a></p>
</td></tr>
</table>

<hr>
<h2 id='text_filter'>generic for subsetting/filtering vectors</h2><span id='topic+text_filter'></span>

<h3>Description</h3>

<p>generic for subsetting/filtering vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_filter(string, pattern, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_filter_+3A_string">string</code></td>
<td>
<p>text to be subsetted</p>
</td></tr>
<tr><td><code id="text_filter_+3A_pattern">pattern</code></td>
<td>
<p>regular expression to subset by</p>
</td></tr>
<tr><td><code id="text_filter_+3A_...">...</code></td>
<td>
<p>further arguments passed through to <a href="base.html#topic+grep">grep</a></p>
</td></tr>
</table>

<hr>
<h2 id='text_length'>wrapper around nchar to return text length</h2><span id='topic+text_length'></span>

<h3>Description</h3>

<p>wrapper around nchar to return text length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_length(x, type = "chars", allowNA = FALSE, keepNA = TRUE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_length_+3A_x">x</code></td>
<td>
<p>see <a href="base.html#topic+nchar">nchar</a></p>
</td></tr>
<tr><td><code id="text_length_+3A_type">type</code></td>
<td>
<p>see <a href="base.html#topic+nchar">nchar</a></p>
</td></tr>
<tr><td><code id="text_length_+3A_allowna">allowNA</code></td>
<td>
<p>see <a href="base.html#topic+nchar">nchar</a></p>
</td></tr>
<tr><td><code id="text_length_+3A_keepna">keepNA</code></td>
<td>
<p>see <a href="base.html#topic+nchar">nchar</a></p>
</td></tr>
<tr><td><code id="text_length_+3A_na.rm">na.rm</code></td>
<td>
<p>see <a href="base.html#topic+nchar">nchar</a></p>
</td></tr>
</table>

<hr>
<h2 id='text_locate'>function to get start, end, length form pattern match</h2><span id='topic+text_locate'></span><span id='topic+text_locate.default'></span>

<h3>Description</h3>

<p>function to get start, end, length form pattern match
</p>
<p>text_locate default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_locate(string, pattern, vectorize = FALSE, ...)

## Default S3 method:
text_locate(string, pattern, vectorize = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_locate_+3A_string">string</code></td>
<td>
<p>text to be searched through</p>
</td></tr>
<tr><td><code id="text_locate_+3A_pattern">pattern</code></td>
<td>
<p>regex to look for</p>
</td></tr>
<tr><td><code id="text_locate_+3A_vectorize">vectorize</code></td>
<td>
<p>should function be used in vectorized mode, i.e. should a
pattern with length larger than 1 be allowed and if so, should it be
matched to lines (with recycling if needed) instead of using on element on
all lines</p>
</td></tr>
<tr><td><code id="text_locate_+3A_...">...</code></td>
<td>
<p>further options passed through to <a href="base.html#topic+grep">grep</a></p>
</td></tr>
</table>

<hr>
<h2 id='text_locate_all'>function to get start, end, length form pattern match for all matches</h2><span id='topic+text_locate_all'></span><span id='topic+text_locate_all.default'></span>

<h3>Description</h3>

<p>function to get start, end, length form pattern match for all matches
</p>
<p>text_locate_all default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_locate_all(string, pattern, vectorize = FALSE, simplify = FALSE, ...)

## Default S3 method:
text_locate_all(string, pattern, vectorize = FALSE, simplify = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_locate_all_+3A_string">string</code></td>
<td>
<p>text to search through</p>
</td></tr>
<tr><td><code id="text_locate_all_+3A_pattern">pattern</code></td>
<td>
<p>regex to search for</p>
</td></tr>
<tr><td><code id="text_locate_all_+3A_vectorize">vectorize</code></td>
<td>
<p>should function be used in vectorized mode, i.e. should a
pattern with length larger than 1 be allowed and if so, should it be
matched to lines (with recycling if needed) instead of using on element on
all lines</p>
</td></tr>
<tr><td><code id="text_locate_all_+3A_simplify">simplify</code></td>
<td>
<p>either getting back a list of results or all list elements
merged into a data.frame with columns identifying original line (i) and
pattern (p) number</p>
</td></tr>
<tr><td><code id="text_locate_all_+3A_...">...</code></td>
<td>
<p>further arguments passed through to <a href="base.html#topic+grep">grep</a></p>
</td></tr>
</table>

<hr>
<h2 id='text_locate_all_worker'>helper function to get start, end, length form pattern match</h2><span id='topic+text_locate_all_worker'></span>

<h3>Description</h3>

<p>helper function to get start, end, length form pattern match
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_locate_all_worker(string, pattern, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_locate_all_worker_+3A_string">string</code></td>
<td>
<p>text to be searched through</p>
</td></tr>
<tr><td><code id="text_locate_all_worker_+3A_pattern">pattern</code></td>
<td>
<p>regex to look for</p>
</td></tr>
<tr><td><code id="text_locate_all_worker_+3A_...">...</code></td>
<td>
<p>further options passed through to <a href="base.html#topic+grep">grep</a></p>
</td></tr>
</table>

<hr>
<h2 id='text_locate_group'>generic for getting positions regex groups</h2><span id='topic+text_locate_group'></span><span id='topic+text_locate_group.default'></span>

<h3>Description</h3>

<p>generic for getting positions regex groups
</p>
<p>text_locate_group default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_locate_group(string, pattern, group, ...)

## Default S3 method:
text_locate_group(string, pattern, group, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_locate_group_+3A_string">string</code></td>
<td>
<p>text to be searched through</p>
</td></tr>
<tr><td><code id="text_locate_group_+3A_pattern">pattern</code></td>
<td>
<p>regex to look for</p>
</td></tr>
<tr><td><code id="text_locate_group_+3A_group">group</code></td>
<td>
<p>integer vector specifying groups to return</p>
</td></tr>
<tr><td><code id="text_locate_group_+3A_...">...</code></td>
<td>
<p>further options passed through to <a href="base.html#topic+grep">grep</a></p>
</td></tr>
</table>

<hr>
<h2 id='text_locate_worker'>helper function to get start, end, length form pattern match</h2><span id='topic+text_locate_worker'></span>

<h3>Description</h3>

<p>helper function to get start, end, length form pattern match
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_locate_worker(string, pattern, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_locate_worker_+3A_string">string</code></td>
<td>
<p>text to be searched through</p>
</td></tr>
<tr><td><code id="text_locate_worker_+3A_pattern">pattern</code></td>
<td>
<p>regex to look for</p>
</td></tr>
<tr><td><code id="text_locate_worker_+3A_...">...</code></td>
<td>
<p>further options passed through to <a href="base.html#topic+grep">grep</a></p>
</td></tr>
</table>

<hr>
<h2 id='text_nchar'>wrapper around nchar to return text length</h2><span id='topic+text_nchar'></span>

<h3>Description</h3>

<p>wrapper around nchar to return text length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_nchar(x, type = "chars", allowNA = FALSE, keepNA = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_nchar_+3A_x">x</code></td>
<td>
<p>see <a href="base.html#topic+nchar">nchar</a></p>
</td></tr>
<tr><td><code id="text_nchar_+3A_type">type</code></td>
<td>
<p>see <a href="base.html#topic+nchar">nchar</a></p>
</td></tr>
<tr><td><code id="text_nchar_+3A_allowna">allowNA</code></td>
<td>
<p>see <a href="base.html#topic+nchar">nchar</a></p>
</td></tr>
<tr><td><code id="text_nchar_+3A_keepna">keepNA</code></td>
<td>
<p>see <a href="base.html#topic+nchar">nchar</a></p>
</td></tr>
</table>

<hr>
<h2 id='text_pad'>padding text to specified width</h2><span id='topic+text_pad'></span><span id='topic+text_pad.default'></span>

<h3>Description</h3>

<p>padding text to specified width
</p>
<p>text_wrap default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_pad(
  string,
  width = max(nchar(string)),
  pad = " ",
  side = c("left", "right", "both", "l", "r", "b", 1, 2, 3)
)

## Default S3 method:
text_pad(
  string,
  width = max(nchar(string)),
  pad = " ",
  side = c("left", "right", "both", "l", "r", "b", 1, 2, 3)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_pad_+3A_string">string</code></td>
<td>
<p>text to be wrapped</p>
</td></tr>
<tr><td><code id="text_pad_+3A_width">width</code></td>
<td>
<p>width text should have after padding; defaults to: max(nchar(string))</p>
</td></tr>
<tr><td><code id="text_pad_+3A_pad">pad</code></td>
<td>
<p>the character or character sequence to use for padding</p>
</td></tr>
<tr><td><code id="text_pad_+3A_side">side</code></td>
<td>
<p>one of: c(&quot;left&quot;, &quot;right&quot;, &quot;both&quot;, &quot;l&quot;, &quot;r&quot;, &quot;b&quot;, 1, 2, 3)</p>
</td></tr>
</table>

<hr>
<h2 id='text_read'>read in text</h2><span id='topic+text_read'></span>

<h3>Description</h3>

<p>A wrapper to readLines() to make things more ordered and convenient. In
comparison to the wrapped up readLines() function text_read() does some
things differently: (1) If no encoding is given, it will always assume files
are stored in UTF-8 instead of the system locale. (2) it will always converts
text to UTF-8 instead of transforming it to the system locale. (3) in
addition to loading, it offers to tokenize the text using a regular expression
or NULL for no tokenization at all.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_read(file, tokenize = "\n", encoding = "UTF-8", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_read_+3A_file">file</code></td>
<td>
<p>name or path to the file to be read in or a <a href="base.html#topic+connections">connections</a> object (see <a href="base.html#topic+readLines">readLines</a>)</p>
</td></tr>
<tr><td><code id="text_read_+3A_tokenize">tokenize</code></td>
<td>
<p>either
NULL so that no splitting is done;
a regular expression to use to split text into parts;
or a function that does the splitting (or whatever other transformation)</p>
</td></tr>
<tr><td><code id="text_read_+3A_encoding">encoding</code></td>
<td>
<p>character encoding of file passed throught to <a href="base.html#topic+readLines">readLines</a></p>
</td></tr>
<tr><td><code id="text_read_+3A_...">...</code></td>
<td>
<p>further arguments passed through to <a href="base.html#topic+readLines">readLines</a> like:
n, ok, warn, skipNul</p>
</td></tr>
</table>

<hr>
<h2 id='text_rep'>generic repeating text</h2><span id='topic+text_rep'></span><span id='topic+text_dup'></span><span id='topic+text_rep.default'></span>

<h3>Description</h3>

<p>generic repeating text
</p>
<p>text_rep defaul method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_rep(string, times, vectorize = FALSE, ...)

text_dup(string, times, vectorize = FALSE, ...)

## Default S3 method:
text_rep(string, times, vectorize = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_rep_+3A_string">string</code></td>
<td>
<p>text to be repeated</p>
</td></tr>
<tr><td><code id="text_rep_+3A_times">times</code></td>
<td>
<p>how many times shal string be repeated</p>
</td></tr>
<tr><td><code id="text_rep_+3A_vectorize">vectorize</code></td>
<td>
<p>should function be used in vectorized mode, i.e. should a
pattern with length larger than 1 be allowed and if so, should it be
matched to lines (with recycling if needed) instead of using on element on
all lines</p>
</td></tr>
<tr><td><code id="text_rep_+3A_...">...</code></td>
<td>
<p>further arguments passed through</p>
</td></tr>
</table>

<hr>
<h2 id='text_replace'>replacing patterns in string</h2><span id='topic+text_replace'></span><span id='topic+text_replace.default'></span>

<h3>Description</h3>

<p>replacing patterns in string
</p>
<p>replacing patterns default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_replace(string, pattern = NULL, replacement = NULL, ...)

## Default S3 method:
text_replace(string, pattern = NULL, replacement = NULL, recycle = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_replace_+3A_string">string</code></td>
<td>
<p>text to be replaced</p>
</td></tr>
<tr><td><code id="text_replace_+3A_pattern">pattern</code></td>
<td>
<p>regex to look for</p>
</td></tr>
<tr><td><code id="text_replace_+3A_replacement">replacement</code></td>
<td>
<p>replacement for pattern found</p>
</td></tr>
<tr><td><code id="text_replace_+3A_...">...</code></td>
<td>
<p>further parameter passed through to sub</p>
</td></tr>
<tr><td><code id="text_replace_+3A_recycle">recycle</code></td>
<td>
<p>should arguments be recycled if lengths do not match?</p>
</td></tr>
</table>

<hr>
<h2 id='text_replace_all'>replacing patterns in string</h2><span id='topic+text_replace_all'></span><span id='topic+text_replace_all.default'></span>

<h3>Description</h3>

<p>replacing patterns in string
</p>
<p>replacing patterns default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_replace_all(string, pattern = NULL, replacement = NULL, ...)

## Default S3 method:
text_replace_all(
  string,
  pattern = NULL,
  replacement = NULL,
  recycle = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_replace_all_+3A_string">string</code></td>
<td>
<p>text to be replaced</p>
</td></tr>
<tr><td><code id="text_replace_all_+3A_pattern">pattern</code></td>
<td>
<p>regex to look for</p>
</td></tr>
<tr><td><code id="text_replace_all_+3A_replacement">replacement</code></td>
<td>
<p>replacement for pattern found</p>
</td></tr>
<tr><td><code id="text_replace_all_+3A_...">...</code></td>
<td>
<p>further parameter passed through to gsub</p>
</td></tr>
<tr><td><code id="text_replace_all_+3A_recycle">recycle</code></td>
<td>
<p>should arguments be recycled if lengths do not match?</p>
</td></tr>
</table>

<hr>
<h2 id='text_replace_group'>function for replacing regex group matches
generic for getting regex group matches</h2><span id='topic+text_replace_group'></span><span id='topic+text_replace_group.default'></span>

<h3>Description</h3>

<p>function for replacing regex group matches
generic for getting regex group matches
</p>
<p>text_replace_group default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_replace_group(
  string,
  pattern,
  replacement,
  group = seq_along(replacement),
  invert = FALSE,
  ...
)

## Default S3 method:
text_replace_group(
  string,
  pattern,
  replacement,
  group = TRUE,
  invert = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_replace_group_+3A_string">string</code></td>
<td>
<p>text from which to extract character sequence</p>
</td></tr>
<tr><td><code id="text_replace_group_+3A_pattern">pattern</code></td>
<td>
<p>regex to be searched for</p>
</td></tr>
<tr><td><code id="text_replace_group_+3A_replacement">replacement</code></td>
<td>
<p>character vector of replacements of length 1 or
length(group) to replace regex group matches (marked character spans
provided by the found parameter)</p>
</td></tr>
<tr><td><code id="text_replace_group_+3A_group">group</code></td>
<td>
<p>vector of integers identifying thos regex groups to be replaced</p>
</td></tr>
<tr><td><code id="text_replace_group_+3A_invert">invert</code></td>
<td>
<p>should character spans provided by found or their counterparts
be replaced</p>
</td></tr>
<tr><td><code id="text_replace_group_+3A_...">...</code></td>
<td>
<p>further parameter passed through to <a href="base.html#topic+grep">grep</a></p>
</td></tr>
</table>

<hr>
<h2 id='text_replace_locates'>text_replace_locates default</h2><span id='topic+text_replace_locates'></span><span id='topic+text_replace_locates.default'></span>

<h3>Description</h3>

<p>text_replace_locates default
</p>
<p>text_replace_locates default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_replace_locates(string, found, replacement, group, invert)

## Default S3 method:
text_replace_locates(string, found, replacement, group, invert)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_replace_locates_+3A_string">string</code></td>
<td>
<p>text for which to replace parts</p>
</td></tr>
<tr><td><code id="text_replace_locates_+3A_found">found</code></td>
<td>
<p>result of an call to text_locate_group or text_locate
- i.e. a list of data.frames
with two columns named 'start' and 'end' that mark character spans
to be replaced within the text elements</p>
</td></tr>
<tr><td><code id="text_replace_locates_+3A_replacement">replacement</code></td>
<td>
<p>character vector of replacements of length 1 or
length(group) to replace regex group matches (marked character spans
provided by the found parameter)</p>
</td></tr>
<tr><td><code id="text_replace_locates_+3A_group">group</code></td>
<td>
<p>vector of integers identifying thos regex groups to be replaced</p>
</td></tr>
<tr><td><code id="text_replace_locates_+3A_invert">invert</code></td>
<td>
<p>should character spans provided by found or their counterparts
be replaced</p>
</td></tr>
</table>

<hr>
<h2 id='text_show'>showing text</h2><span id='topic+text_show'></span><span id='topic+text_show.default'></span>

<h3>Description</h3>

<p>shows text or portions of the text via cat and the usage of text_snippet()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_show(
  x,
  length = 500,
  from = NULL,
  to = NULL,
  coll = FALSE,
  wrap = FALSE,
  ...
)

## Default S3 method:
text_show(
  x,
  length = 500,
  from = NULL,
  to = NULL,
  coll = FALSE,
  wrap = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_show_+3A_x">x</code></td>
<td>
<p>text to be shown</p>
</td></tr>
<tr><td><code id="text_show_+3A_length">length</code></td>
<td>
<p>number of characters to be shown</p>
</td></tr>
<tr><td><code id="text_show_+3A_from">from</code></td>
<td>
<p>show from ith character</p>
</td></tr>
<tr><td><code id="text_show_+3A_to">to</code></td>
<td>
<p>show up to ith character</p>
</td></tr>
<tr><td><code id="text_show_+3A_coll">coll</code></td>
<td>
<p>should x be collapsed using newline character as binding?</p>
</td></tr>
<tr><td><code id="text_show_+3A_wrap">wrap</code></td>
<td>
<p>should text be wrapped, or wrapped to certain width, or wrapped
by certain function</p>
</td></tr>
<tr><td><code id="text_show_+3A_...">...</code></td>
<td>
<p>further arguments passed through to <a href="base.html#topic+cat">cat</a></p>
</td></tr>
</table>

<hr>
<h2 id='text_snippet'>retrieving text snippet</h2><span id='topic+text_snippet'></span>

<h3>Description</h3>

<p>function will give back snippets of text via using length,
length and from, length and to, or from and to to specify the snippet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_snippet(x, length = max(nchar(x)), from = NULL, to = NULL, coll = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_snippet_+3A_x">x</code></td>
<td>
<p>character vector to be snipped</p>
</td></tr>
<tr><td><code id="text_snippet_+3A_length">length</code></td>
<td>
<p>length of snippet</p>
</td></tr>
<tr><td><code id="text_snippet_+3A_from">from</code></td>
<td>
<p>starting character</p>
</td></tr>
<tr><td><code id="text_snippet_+3A_to">to</code></td>
<td>
<p>last character</p>
</td></tr>
<tr><td><code id="text_snippet_+3A_coll">coll</code></td>
<td>
<p>should a possible vector x with length &gt; 1 collapsed with newline
character as separator?</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>text_snippet</code>: retrieving text snippet
</p>
</li></ul>

<hr>
<h2 id='text_split'>generic splitting strings</h2><span id='topic+text_split'></span><span id='topic+text_split.default'></span>

<h3>Description</h3>

<p>generic splitting strings
</p>
<p>text_split defaul method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_split(string, pattern, vectorize = FALSE, ...)

## Default S3 method:
text_split(string, pattern, vectorize = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_split_+3A_string">string</code></td>
<td>
<p>text to search through</p>
</td></tr>
<tr><td><code id="text_split_+3A_pattern">pattern</code></td>
<td>
<p>regex to search for</p>
</td></tr>
<tr><td><code id="text_split_+3A_vectorize">vectorize</code></td>
<td>
<p>should function be used in vectorized mode, i.e. should a
pattern with length larger than 1 be allowed and if so, should it be
matched to lines (with recycling if needed) instead of using on element on
all lines</p>
</td></tr>
<tr><td><code id="text_split_+3A_...">...</code></td>
<td>
<p>further arguments passed through to <a href="base.html#topic+grep">grep</a></p>
</td></tr>
</table>

<hr>
<h2 id='text_split_n'>generic splitting strings into pieces of length n</h2><span id='topic+text_split_n'></span><span id='topic+text_split_n.default'></span>

<h3>Description</h3>

<p>generic splitting strings into pieces of length n
</p>
<p>text_split_n defaul method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_split_n(string, n, vectorize = FALSE)

## Default S3 method:
text_split_n(string, n, vectorize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_split_n_+3A_string">string</code></td>
<td>
<p>text to search through</p>
</td></tr>
<tr><td><code id="text_split_n_+3A_n">n</code></td>
<td>
<p>length of pieces</p>
</td></tr>
<tr><td><code id="text_split_n_+3A_vectorize">vectorize</code></td>
<td>
<p>should function be used in vectorized mode, i.e. should a
pattern with length larger than 1 be allowed and if so, should it be
matched to lines (with recycling if needed) instead of using on element on
all lines</p>
</td></tr>
</table>

<hr>
<h2 id='text_sub'>generic for extracting characters sequences by position</h2><span id='topic+text_sub'></span><span id='topic+text_sub.default'></span>

<h3>Description</h3>

<p>generic for extracting characters sequences by position
</p>
<p>text_sub default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_sub(string, start = NULL, end = NULL)

## Default S3 method:
text_sub(string, start = NULL, end = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_sub_+3A_string">string</code></td>
<td>
<p>text from which to extract character sequence</p>
</td></tr>
<tr><td><code id="text_sub_+3A_start">start</code></td>
<td>
<p>first character position</p>
</td></tr>
<tr><td><code id="text_sub_+3A_end">end</code></td>
<td>
<p>last character position</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+text_snippet">text_snippet</a>
</p>

<hr>
<h2 id='text_subset'>generic for subsetting/filtering vectors</h2><span id='topic+text_subset'></span>

<h3>Description</h3>

<p>generic for subsetting/filtering vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_subset(string, pattern, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_subset_+3A_string">string</code></td>
<td>
<p>text to be subsetted</p>
</td></tr>
<tr><td><code id="text_subset_+3A_pattern">pattern</code></td>
<td>
<p>regular expression to subset by</p>
</td></tr>
<tr><td><code id="text_subset_+3A_...">...</code></td>
<td>
<p>further arguments passed through to <a href="base.html#topic+grep">grep</a></p>
</td></tr>
</table>

<hr>
<h2 id='text_to_lower'>function for make text lower case</h2><span id='topic+text_to_lower'></span><span id='topic+text_to_lower.default'></span>

<h3>Description</h3>

<p>function for make text lower case
</p>
<p>default method for text_tolower()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_to_lower(x)

## Default S3 method:
text_to_lower(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_to_lower_+3A_x">x</code></td>
<td>
<p>text to be processed</p>
</td></tr>
</table>

<hr>
<h2 id='text_to_title_case'>function for make text lower case</h2><span id='topic+text_to_title_case'></span><span id='topic+text_to_title_case.default'></span>

<h3>Description</h3>

<p>function for make text lower case
</p>
<p>default method for text_to_title_case.()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_to_title_case(x)

## Default S3 method:
text_to_title_case(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_to_title_case_+3A_x">x</code></td>
<td>
<p>text to be processed</p>
</td></tr>
</table>

<hr>
<h2 id='text_to_upper'>function for make text lower case</h2><span id='topic+text_to_upper'></span><span id='topic+text_to_upper.default'></span>

<h3>Description</h3>

<p>function for make text lower case
</p>
<p>default method for text_to_upper()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_to_upper(x)

## Default S3 method:
text_to_upper(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_to_upper_+3A_x">x</code></td>
<td>
<p>text to be processed</p>
</td></tr>
</table>

<hr>
<h2 id='text_tokenize'>generic for gregexpr wrappers to tokenize text</h2><span id='topic+text_tokenize'></span><span id='topic+text_tokenize.default'></span>

<h3>Description</h3>

<p>generic for gregexpr wrappers to tokenize text
</p>
<p>default method for text_tokenize generic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_tokenize(
  string,
  regex = NULL,
  ignore.case = FALSE,
  fixed = FALSE,
  perl = FALSE,
  useBytes = FALSE,
  non_token = FALSE
)

## Default S3 method:
text_tokenize(
  string,
  regex = NULL,
  ignore.case = FALSE,
  fixed = FALSE,
  perl = FALSE,
  useBytes = FALSE,
  non_token = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_tokenize_+3A_string">string</code></td>
<td>
<p>text to be tokenized</p>
</td></tr>
<tr><td><code id="text_tokenize_+3A_regex">regex</code></td>
<td>
<p>regex expressing where to cut see (see <a href="base.html#topic+grep">grep</a>)</p>
</td></tr>
<tr><td><code id="text_tokenize_+3A_ignore.case">ignore.case</code></td>
<td>
<p>whether or not reges should be case sensitive
(see <a href="base.html#topic+grep">grep</a>)</p>
</td></tr>
<tr><td><code id="text_tokenize_+3A_fixed">fixed</code></td>
<td>
<p>whether or not regex should be interpreted as is or as regular
expression (see <a href="base.html#topic+grep">grep</a>)</p>
</td></tr>
<tr><td><code id="text_tokenize_+3A_perl">perl</code></td>
<td>
<p>whether or not Perl compatible regex should be used
(see <a href="base.html#topic+grep">grep</a>)</p>
</td></tr>
<tr><td><code id="text_tokenize_+3A_usebytes">useBytes</code></td>
<td>
<p>byte-by-byte matching of regex or character-by-character
(see <a href="base.html#topic+grep">grep</a>)</p>
</td></tr>
<tr><td><code id="text_tokenize_+3A_non_token">non_token</code></td>
<td>
<p>should information for non-token, i.e. those patterns by
which the text was splitted, be returned as well</p>
</td></tr>
</table>

<hr>
<h2 id='text_tokenize_lines'>generic to tokenize text into lines</h2><span id='topic+text_tokenize_lines'></span><span id='topic+text_tokenize_lines.default'></span>

<h3>Description</h3>

<p>generic to tokenize text into lines
</p>
<p>text_tokenize default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_tokenize_lines(string, non_token = FALSE)

## Default S3 method:
text_tokenize_lines(string, non_token = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_tokenize_lines_+3A_string">string</code></td>
<td>
<p>the text to be tokenized</p>
</td></tr>
<tr><td><code id="text_tokenize_lines_+3A_non_token">non_token</code></td>
<td>
<p>whether or not token as well as non tokens shall be returned.</p>
</td></tr>
</table>

<hr>
<h2 id='text_tokenize_sentences'>generic to tokenize text into sentences</h2><span id='topic+text_tokenize_sentences'></span><span id='topic+text_tokenize_sentences.default'></span>

<h3>Description</h3>

<p>generic to tokenize text into sentences
</p>
<p>text_tokenize default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_tokenize_sentences(string, non_token = FALSE)

## Default S3 method:
text_tokenize_sentences(string, non_token = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_tokenize_sentences_+3A_string">string</code></td>
<td>
<p>the text to be tokenized</p>
</td></tr>
<tr><td><code id="text_tokenize_sentences_+3A_non_token">non_token</code></td>
<td>
<p>whether or not token as well as non tokens shall be returned.</p>
</td></tr>
</table>

<hr>
<h2 id='text_tokenize_words'>generic to tokenize text into words</h2><span id='topic+text_tokenize_words'></span><span id='topic+text_tokenize_words.default'></span>

<h3>Description</h3>

<p>A wrapper to text_tokenize that tokenizes text into words.
Since using text_tokenize()'s option non_token might slow things
down considerably this one purpose wrapper is a little more clever
than the general implementation and hence much faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_tokenize_words(string, non_token = FALSE)

## Default S3 method:
text_tokenize_words(string, non_token = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_tokenize_words_+3A_string">string</code></td>
<td>
<p>the text to be tokenized</p>
</td></tr>
<tr><td><code id="text_tokenize_words_+3A_non_token">non_token</code></td>
<td>
<p>whether or not token as well as non tokens shall be returned.</p>
</td></tr>
</table>

<hr>
<h2 id='text_trim'>trim spaces</h2><span id='topic+text_trim'></span><span id='topic+text_trim.default'></span><span id='topic+text_trim.list'></span><span id='topic+text_trim.numeric'></span>

<h3>Description</h3>

<p>trim spaces
</p>
<p>trim spaces default
</p>
<p>trim spaces list
</p>
<p>trim spaces numeric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_trim(string, side = c("both", "left", "right"), pattern = " ", ...)

## Default S3 method:
text_trim(string, side = c("both", "left", "right"), pattern = " ", ...)

## S3 method for class 'list'
text_trim(string, side = c("both", "left", "right"), pattern = " ", ...)

## S3 method for class 'numeric'
text_trim(string, side = c("both", "left", "right"), pattern = " ", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_trim_+3A_string">string</code></td>
<td>
<p>text to be trimmed</p>
</td></tr>
<tr><td><code id="text_trim_+3A_side">side</code></td>
<td>
<p>defaults to both might also be left, right, both or b, r, l to
express where to trim pattern away</p>
</td></tr>
<tr><td><code id="text_trim_+3A_pattern">pattern</code></td>
<td>
<p>regex to look for</p>
</td></tr>
<tr><td><code id="text_trim_+3A_...">...</code></td>
<td>
<p>further arguments passed through to text_replace()</p>
</td></tr>
</table>

<hr>
<h2 id='text_which'>generic function to know in which elements a pattern can be found</h2><span id='topic+text_which'></span><span id='topic+text_which.default'></span><span id='topic+text_grep'></span>

<h3>Description</h3>

<p>generic function to know in which elements a pattern can be found
</p>
<p>text_which default method
</p>
<p>generic function to know in which elements a pattern can be found
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_which(string, pattern, ...)

## Default S3 method:
text_which(string, pattern, ...)

text_grep(string, pattern, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_which_+3A_string">string</code></td>
<td>
<p>the text to be searched through</p>
</td></tr>
<tr><td><code id="text_which_+3A_pattern">pattern</code></td>
<td>
<p>regex to look for</p>
</td></tr>
<tr><td><code id="text_which_+3A_...">...</code></td>
<td>
<p>further arguments passed through to <a href="base.html#topic+grep">grep</a></p>
</td></tr>
</table>

<hr>
<h2 id='text_which_value'>generic function to get whole elements in which pattern was found</h2><span id='topic+text_which_value'></span><span id='topic+text_grepv'></span><span id='topic+text_which_value.default'></span>

<h3>Description</h3>

<p>generic function to get whole elements in which pattern was found
</p>
<p>generic function to get whole elements in which pattern was found
</p>
<p>text_which_value default method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_which_value(string, pattern, ...)

text_grepv(string, pattern, ...)

## Default S3 method:
text_which_value(string, pattern, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_which_value_+3A_string">string</code></td>
<td>
<p>the character vector to be searched through</p>
</td></tr>
<tr><td><code id="text_which_value_+3A_pattern">pattern</code></td>
<td>
<p>regex to look for</p>
</td></tr>
<tr><td><code id="text_which_value_+3A_...">...</code></td>
<td>
<p>further arguments passed through to <a href="base.html#topic+grep">grep</a></p>
</td></tr>
</table>

<hr>
<h2 id='text_wrap'>wraping text to specified width</h2><span id='topic+text_wrap'></span><span id='topic+text_wrap.default'></span>

<h3>Description</h3>

<p>wraping text to specified width
</p>
<p>text_wrap default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_wrap(string, ...)

## Default S3 method:
text_wrap(string, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_wrap_+3A_string">string</code></td>
<td>
<p>text to be wrapped</p>
</td></tr>
<tr><td><code id="text_wrap_+3A_...">...</code></td>
<td>
<p>further arguments passed through to <a href="base.html#topic+strwrap">strwrap</a></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="base.html#topic+strwrap">strwrap</a>
</p>

<hr>
<h2 id='text_write'>write text to file</h2><span id='topic+text_write'></span><span id='topic+text_write.default'></span>

<h3>Description</h3>

<p>A generic function to write text to file (or a <a href="base.html#topic+connections">connections</a>) and
accompanying methods that wrap <a href="base.html#topic+writeLines">writeLines</a> to do so. In contrast
to vanilla writeLines() text_write() (1) is  a generic so methods, handling
something else than character vectors, can be implemented (2) in contrast to
writeLines()' default to transform to write text in the system locale
text_write() will default to UTF-8 no matter the locale (3) furthermore this
encoding can be changed to any encoding supported by <a href="base.html#topic+iconv">iconv</a>
(see also inconvlist <a href="base.html#topic+iconv">iconv</a>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_write(string, file, sep = "\n", encoding = "UTF-8", ...)

## Default S3 method:
text_write(string, file, sep = "\n", encoding = "UTF-8", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_write_+3A_string">string</code></td>
<td>
<p>text to be written</p>
</td></tr>
<tr><td><code id="text_write_+3A_file">file</code></td>
<td>
<p>file name or file path or an <a href="base.html#topic+connections">connections</a> object -
passed through to writeLines()'s con argument</p>
</td></tr>
<tr><td><code id="text_write_+3A_sep">sep</code></td>
<td>
<p>character to separate lines (i.e. vector elements) from each other
- passed through to writeLines()'s con argument</p>
</td></tr>
<tr><td><code id="text_write_+3A_encoding">encoding</code></td>
<td>
<p>encoding in which to write text to disk</p>
</td></tr>
<tr><td><code id="text_write_+3A_...">...</code></td>
<td>
<p>further arguments that might be passed to methods
(not used at the moment)</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
