<!DOCTYPE html><html><head><title>Help for package islasso</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {islasso}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aic.islasso'>
<p>Optimization for the selection of the tuning parameter</p></a></li>
<li><a href='#anova.islasso'><p>General Linear Combination method for <code>islasso</code> objects</p></a></li>
<li><a href='#breast'>
<p>Breast Cancer microarray experiment</p></a></li>
<li><a href='#confint.islasso'><p>confint method for <code>islasso</code> objects</p></a></li>
<li><a href='#diabetes'><p>Blood and other measurements in diabetics</p></a></li>
<li><a href='#GoF.islasso.path'>
<p>Optimization for the selection of the tuning parameter</p></a></li>
<li><a href='#is.control'><p>Auxiliary for controlling islasso model fitting</p></a></li>
<li><a href='#islasso'>
<p>The Induced Smoothed lasso</p></a></li>
<li><a href='#islasso-internal'><p>Internal Functions</p></a></li>
<li><a href='#islasso-package'>
<p>The Induced Smoothed lasso: A practical framework for hypothesis testing in high dimensional regression</p></a></li>
<li><a href='#islasso.path'>
<p>The Induced Smoothed lasso path</p></a></li>
<li><a href='#plot.islasso'><p>Diagnostics plots for Induced Smoothing Lasso Model</p></a></li>
<li><a href='#plot.islasso.path'><p>plot coefficient profile from a fitted &quot;islasso.path&quot; object.</p></a></li>
<li><a href='#predict.islasso'><p>Prediction method for islasso fitted objects</p></a></li>
<li><a href='#predict.islasso.path'><p>Prediction method for islasso.path fitted objects</p></a></li>
<li><a href='#Prostate'><p>Prostate Cancer Data</p></a></li>
<li><a href='#simulXy'><p>Simulate model matrix and response</p></a></li>
<li><a href='#summary.islasso'><p>summary method for islasso fitted objects</p></a></li>
<li><a href='#summary.islasso.path'><p>summary method for islasso.path fitted objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The Induced Smoothed Lasso</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-22</td>
</tr>
<tr>
<td>Depends:</td>
<td>glmnet (&ge; 4.0), Matrix (&ge; 1.0-6), R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, lars, xfun, rmarkdown</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the induced smoothing (IS) idea to lasso regularization models to allow estimation and inference on the model coefficients (currently hypothesis testing only). Linear, logistic, Poisson and gamma regressions with several link functions are implemented. The algorithm is described in the original paper; see &lt;<a href="https://doi.org/10.1177%2F0962280219842890">doi:10.1177/0962280219842890</a>&gt; and discussed in a tutorial &lt;<a href="https://doi.org/10.13140%2FRG.2.2.16360.11521">doi:10.13140/RG.2.2.16360.11521</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-23 09:00:46 UTC; gianlucasottile</td>
</tr>
<tr>
<td>Author:</td>
<td>Gianluca Sottile [aut, cre],
  Giovanna Cilluffo [aut, ctb],
  Vito MR Muggeo [aut, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-23 15:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='aic.islasso'>
Optimization for the selection of the tuning parameter
</h2><span id='topic+aic.islasso'></span>

<h3>Description</h3>

<p>This function performs a minimization of the AIC/BIC criterion for selecting the tuning parameter in &ldquo;<code>islasso</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aic.islasso(object, method = c("AIC", "BIC", "AICc", "GCV", "GIC"), 
  interval, g = 0, y, X, 
  intercept = FALSE, family = gaussian(), alpha = 1, offset, 
  weights, unpenalized, control = is.control(), trace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aic.islasso_+3A_object">object</code></td>
<td>
<p>a fitted model object of class &quot;islasso&quot;.</p>
</td></tr>
<tr><td><code id="aic.islasso_+3A_method">method</code></td>
<td>
<p>the criterion to optimize, AIC, BIC, AICc, GCV, GIC.</p>
</td></tr>
<tr><td><code id="aic.islasso_+3A_interval">interval</code></td>
<td>
<p>the  lower and upper limits of <code class="reqn">\lambda</code> wherein the AIC/BIC criterion should be optimized. Can be missing, if <code>object</code> has been obtained via cross-validation (and therefore includes the range of lambdas)  </p>
</td></tr>
<tr><td><code id="aic.islasso_+3A_g">g</code></td>
<td>
<p>a value belonging to the interval [0, 1]. Classical BIC is returned by letting g = 0 (default value), whereas extended BIC corresponds to the case g = 0.5.</p>
</td></tr>
<tr><td><code id="aic.islasso_+3A_y">y</code></td>
<td>
<p>if <code>object</code> is missing, the response vector of length n.</p>
</td></tr>
<tr><td><code id="aic.islasso_+3A_x">X</code></td>
<td>
<p>if <code>object</code> is missing, the design matrix of dimension n * p.</p>
</td></tr>
<tr><td><code id="aic.islasso_+3A_intercept">intercept</code></td>
<td>
<p>if <code>object</code> is missing, if TRUE the intercept is added to the model matrix.</p>
</td></tr>
<tr><td><code id="aic.islasso_+3A_family">family</code></td>
<td>
<p>if <code>object</code> is missing, a description of the error distribution, <code>family=gaussian</code>, <code>family=binomial</code> and <code>family=poisson</code> are implemented with canonical link.</p>
</td></tr>
<tr><td><code id="aic.islasso_+3A_alpha">alpha</code></td>
<td>
<p>The elasticnet mixing parameter, with <code class="reqn">0\le\alpha\le 1</code>. The penalty is defined
as </p>
<p style="text-align: center;"><code class="reqn">(1-\alpha)/2||\beta||_2^2+\alpha||\beta||_1.</code>
</p>
 <p><code>alpha=1</code>
is the lasso penalty, and <code>alpha=0</code> the ridge penalty.</p>
</td></tr>
<tr><td><code id="aic.islasso_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases.</p>
</td></tr>
<tr><td><code id="aic.islasso_+3A_weights">weights</code></td>
<td>
<p>observation weights. Default is 1 for each observation.</p>
</td></tr>
<tr><td><code id="aic.islasso_+3A_unpenalized">unpenalized</code></td>
<td>
<p>a vector used to specify the unpenalized estimators; unpenalized has to be a vector of logicals.</p>
</td></tr>
<tr><td><code id="aic.islasso_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the fitting process (see <code>islasso.control</code> for more details).</p>
</td></tr>
<tr><td><code id="aic.islasso_+3A_trace">trace</code></td>
<td>
<p>Should the iterative procedure be printed? TRUE is the default value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Minimization of the Akaike Information Criterion (AIC), or Bayesian Information Criterion (BIC) or several other criteria are sometimes employed to select the tuning parameter as an alternative to the cross validation. The model degrees of freedom (not necessarly integers as in the plain lasso) used in all methods are computed as trace of the hat matrix at convergence. 
</p>


<h3>Value</h3>

<p>the optimal lambda value is returned
</p>


<h3>Author(s)</h3>

<p>Maintainer: Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+islasso.fit">islasso.fit</a></code>, <code><a href="#topic+summary.islasso">summary.islasso</a></code>, <code><a href="#topic+residuals.islasso">residuals.islasso</a></code>, <code><a href="#topic+logLik.islasso">logLik.islasso</a></code>, <code><a href="#topic+predict.islasso">predict.islasso</a></code> and <code><a href="#topic+deviance.islasso">deviance.islasso</a></code> methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 100
p &lt;- 100
p1 &lt;- 20  #number of nonzero coefficients
coef.veri &lt;- sort(round(c(seq(.5, 3, l=p1/2), seq(-1, -2, l=p1/2)), 2))
sigma &lt;- 1

coef &lt;- c(coef.veri, rep(0, p-p1))

X &lt;- matrix(rnorm(n*p), n, p)
mu &lt;- drop(X%*%coef)
y &lt;- mu + rnorm(n, 0, sigma)

o &lt;- islasso(y ~ ., data = data.frame(y = y, X))

## Not run: 
#use the evaluation interval of the fit
lambda_aic &lt;- aic.islasso(o, method = "AIC") 

#overwrites the evaluation interval for lambda
lambda_bic &lt;- aic.islasso(o, interval = c(.1, 30), method = "BIC") 

#overwrites the evaluation interval for lambda using eBIC criterion
lambda_ebic &lt;- aic.islasso(o, interval = c(.1, 30), method = "BIC", g = .5) 

## End(Not run)
</code></pre>

<hr>
<h2 id='anova.islasso'>General Linear Combination method for <code>islasso</code> objects</h2><span id='topic+anova.islasso'></span><span id='topic+print.anova.islasso'></span>

<h3>Description</h3>

<p>General linear hypotheses and confidence intervals estimation for linear combinantions of the regression coefficients in  <code>islasso</code> fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'islasso'
anova(object, A, b = NULL, ci, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.islasso_+3A_object">object</code></td>
<td>
<p>a fitted model object of class &quot;islasso&quot;.</p>
</td></tr>
<tr><td><code id="anova.islasso_+3A_a">A</code></td>
<td>
<p>matrix (or vector) giving linear combinations of coefficients by rows, or a character vector giving the hypothesis in symbolic form (see Details). </p>
</td></tr>
<tr><td><code id="anova.islasso_+3A_b">b</code></td>
<td>
<p>right-hand-side vector for hypothesis, with as many entries as rows in the hypothesis matrix A; can be omitted, in which case it defaults to a vector of zeroes.</p>
</td></tr>
<tr><td><code id="anova.islasso_+3A_ci">ci</code></td>
<td>
<p>optionally, a two columns matrix of estimated confidence intervals for the estimated coefficients.</p>
</td></tr>
<tr><td><code id="anova.islasso_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the islasso regression model with coefficients <code class="reqn">\beta</code>, the null hypothesis is </p>
<p style="text-align: center;"><code class="reqn">H_0:A\beta=b</code>
</p>
<p> where A and b are known matrix and vector. 
</p>
<p>The hypothesis matrix A can be supplied as a numeric matrix (or vector), the rows of which specify linear combinations of the model coefficients, which are tested equal to the corresponding entries in the right-hand-side vector b, which defaults to a vector of zeroes.
</p>
<p>Alternatively, the hypothesis can be specified symbolically as a character vector with one or more elements, each of which gives either a linear combination of coefficients, or a linear equation in the coefficients (i.e., with both a left and right side separated by an equals sign). Components of a linear expression or linear equation can consist of numeric constants, or numeric constants multiplying coefficient names (in which case the number precedes the coefficient, and may be separated from it by spaces or an asterisk); constants of 1 or -1 may be omitted. Spaces are always optional. Components are separated by plus or minus signs. Newlines or tabs in hypotheses will be treated as spaces. See the examples below.
</p>


<h3>Value</h3>

<p>An object of class &quot;anova.islasso&quot; which contains the estimates, the standard errors, the Wald statistics and corresponding p value of each linear combination and of the restriced model.
</p>


<h3>Author(s)</h3>

<p>The main function of the same name was inspired by the R function previously implemented by Vito MR Muggeo.
</p>
<p>Maintainer: Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 100
p &lt;- 100
p1 &lt;- 10  #number of nonzero coefficients
coef.true &lt;- sort(round(c(seq(.5, 3, l=p1/2), seq(-1, -2, l=p1/2)), 2))
sigma &lt;- 1

coef &lt;- c(coef.true, rep(0, p-p1))

X &lt;- matrix(rnorm(n*p), n, p)
eta &lt;- drop(X %*% coef)
mu &lt;- eta
y &lt;- mu + rnorm(n, 0, sigma)

o &lt;- islasso(y ~ . - 1, data = data.frame(y = y, X), 
             family = gaussian())
anova(o, A = diag(p), b = coef)
anova(o, A = c("X1 + X2 + X3 + X4 + X5 = -7.5"))
anova(o, A = c("X1 + X2 + X3 + X4 + X5 = 0"))
anova(o, A = c("X6 + X7 + X8 + X9 + X10"), b = 8.75)
anova(o, A = c("X6 + X7 + X8 + X9 + X10"), b = 0)
anova(o, A = c("X1 + X2 + X3 + X4 + X5 = -7.5",
               "X6 + X7 + X8 + X9 + X10 = 8.75"))
anova(o, A = c("X1 + X2 + X3 + X4 + X5",
               "X6 + X7 + X8 + X9 + X10"), b = c(-7.5, 8.75))
anova(o, A = c("X1 + X2 + X3 + X4 + X5",
               "X6 + X7 + X8 + X9 + X10"))

</code></pre>

<hr>
<h2 id='breast'>
Breast Cancer microarray experiment
</h2><span id='topic+breast'></span>

<h3>Description</h3>

<p>This data set details microarray experiment for 52 breast cancer patients. The binary variable <code>status</code> is used to indicate whether or not the patient has died of breast cancer (<code>status = 0</code> = did not die of breast cancer, <code>status = 1</code> = died of breast cancer). The other variables contain the amplification or deletion of the considered genes.
</p>
<p>Rather than measuring gene expression, this experiment aims to measure gene amplification or deletion, which refers to the number of copies of a particular DNA sequence within the genome. The aim of the experiment is to find out the key genomic factors involved in agressive and non-agressive forms of breast cancer.
</p>
<p>The experiment was conducted by the Dr.\ John Bartlett and Dr.\ Caroline Witton in the Division of Cancer Sciences and Molecular Pathology of the University of Glasgow at the city's Royal Infirmary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(breast)</code></pre>


<h3>Source</h3>

<p>Dr. John Bartlett and Dr. Caroline Witton, Division of Cancer Sciences and Molecular Pathology, University of Glasgow, Glasgow Royal Infirmary.
</p>


<h3>References</h3>

<p>Augugliaro L., Mineo A.M. and Wit E.C. (2013)
<em>dgLARS: a differential geometric approach to sparse generalized linear models</em>, <em>Journal of the Royal Statistical Society. Series B.</em>, Vol 75(3), 471-498.
</p>
<p>Wit E.C. and McClure J. (2004) &quot;Statistics for Microarrays: Design, Analysis and Inference&quot; Chichester: Wiley.
</p>

<hr>
<h2 id='confint.islasso'>confint method for <code>islasso</code> objects</h2><span id='topic+confint.islasso'></span><span id='topic+print.confint.islasso'></span><span id='topic+plot.confint.islasso'></span>

<h3>Description</h3>

<p>confint method for <code>islasso</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'islasso'
confint(object, parm, level = 0.95,
  type.ci = "wald", trace = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.islasso_+3A_object">object</code></td>
<td>
<p>a fitted model object of class &quot;islasso&quot;.</p>
</td></tr>
<tr><td><code id="confint.islasso_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given confidence intervals, either a vector of numbers or a vector of names.
If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.islasso_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="confint.islasso_+3A_type.ci">type.ci</code></td>
<td>
<p>Only Wald-type confidence intervals are implemented yet! type.ci = &quot;wald&quot; estimates and standard errors are used to build confidence interval</p>
</td></tr>
<tr><td><code id="confint.islasso_+3A_trace">trace</code></td>
<td>
<p>if TRUE (default) a bar shows the iterations status.</p>
</td></tr>
<tr><td><code id="confint.islasso_+3A_...">...</code></td>
<td>
<p>additional argument(s) for methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maintainer: Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+islasso.fit">islasso.fit</a></code>, <code><a href="#topic+summary.islasso">summary.islasso</a></code>, <code><a href="#topic+residuals.islasso">residuals.islasso</a></code>, <code><a href="#topic+logLik.islasso">logLik.islasso</a></code>, <code><a href="#topic+predict.islasso">predict.islasso</a></code> and <code><a href="#topic+deviance.islasso">deviance.islasso</a></code> methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 100
p1 &lt;- 10  #number of nonzero coefficients
coef.veri &lt;- sort(round(c(seq(.5, 3, l=p1/2), seq(-1, -2, l=p1/2)), 2))
sigma &lt;- 1

coef &lt;- c(coef.veri, rep(0, p-p1))

X &lt;- matrix(rnorm(n*p), n, p)
eta &lt;- drop(X%*%coef)

##### gaussian ######
mu &lt;- eta
y &lt;- mu + rnorm(n, 0, sigma)

o &lt;- islasso(y ~ ., data = data.frame(y = y, X), 
             family = gaussian())

ci &lt;- confint(o, type.ci = "wald", parm = 1:10)
ci
plot(ci)

</code></pre>

<hr>
<h2 id='diabetes'>Blood and other measurements in diabetics</h2><span id='topic+diabetes'></span>

<h3>Description</h3>

<p>The <code>diabetes</code> data frame has 442 rows and 3 columns.
These are the data used in the Efron et al &quot;Least Angle Regression&quot; paper.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>x</dt><dd><p>a matrix with 10 columns</p>
</dd>
<dt>y</dt><dd><p>a numeric vector</p>
</dd>
<dt>x2</dt><dd><p>a matrix with 64 columns</p>
</dd>
</dl>



<h3>Details</h3>

<p>The x matrix has been standardized to have unit L2 norm in each column
and zero mean. The matrix x2 consists of x plus certain interactions.
</p>


<h3>Source</h3>

<p><a href="https://web.stanford.edu/~hastie/Papers/LARS/LeastAngle_2002.ps">https://web.stanford.edu/~hastie/Papers/LARS/LeastAngle_2002.ps</a>
</p>


<h3>References</h3>

<p>Efron, Hastie, Johnstone and Tibshirani (2003) &quot;Least Angle Regression&quot;
(with discussion) <em>Annals of Statistics</em>
</p>

<hr>
<h2 id='GoF.islasso.path'>
Optimization for the selection of the tuning parameter
</h2><span id='topic+GoF.islasso.path'></span>

<h3>Description</h3>

<p>This function extracts the value of the tuning parameter which minimizes the AIC/BIC/AICc/eBIC/GCV/GIC criterion in &ldquo;<code>islasso.path</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GoF.islasso.path(object, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GoF.islasso.path_+3A_object">object</code></td>
<td>
<p>a fitted model object of class <code>"islasso.path".</code></p>
</td></tr>
<tr><td><code id="GoF.islasso.path_+3A_plot">plot</code></td>
<td>
<p>a logical flag indicating if each criterion have to be plotted</p>
</td></tr>
<tr><td><code id="GoF.islasso.path_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Minimization of the Akaike Information Criterion (AIC), or Bayesian Information Criterion (BIC) or several other criteria are sometimes employed to select the tuning parameter as an alternative to the cross validation. The model degrees of freedom (not necessarly integers as in the plain lasso) used in all methods are computed as trace of the hat matrix at convergence. 
</p>


<h3>Value</h3>

<p>A list of
</p>
<table>
<tr><td><code>gof</code></td>
<td>
<p>the goodness of fit measures</p>
</td></tr>
<tr><td><code>minimum</code></td>
<td>
<p>the position of the optimal lambda values</p>
</td></tr>
<tr><td><code>lambda.min</code></td>
<td>
<p>the optimal lambda values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maintainer: Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+islasso.path">islasso.path</a></code>, <code><a href="#topic+islasso.path.fit">islasso.path.fit</a></code>, <code><a href="#topic+coef.islasso.path">coef.islasso.path</a></code>, <code><a href="#topic+residuals.islasso.path">residuals.islasso.path</a></code>, <code><a href="#topic+summary.islasso.path">summary.islasso.path</a></code>, <code><a href="#topic+logLik.islasso.path">logLik.islasso.path</a></code>, <code><a href="#topic+fitted.islasso.path">fitted.islasso.path</a></code>, <code><a href="#topic+predict.islasso.path">predict.islasso.path</a></code> and <code><a href="#topic+deviance.islasso.path">deviance.islasso.path</a></code> methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 100
p &lt;- 30
p1 &lt;- 10  #number of nonzero coefficients
coef.veri &lt;- sort(round(c(seq(.5, 3, l=p1/2), seq(-1, -2, l=p1/2)), 2))
sigma &lt;- 1

coef &lt;- c(coef.veri, rep(0, p-p1))

X &lt;- matrix(rnorm(n*p), n, p)
mu &lt;- drop(X%*%coef)
y &lt;- mu + rnorm(n, 0, sigma)

o &lt;- islasso.path(y ~ ., data = data.frame(y = y, X))
GoF.islasso.path(o)
</code></pre>

<hr>
<h2 id='is.control'>Auxiliary for controlling islasso model fitting</h2><span id='topic+is.control'></span>

<h3>Description</h3>

<p>Auxiliary function for controlling the islasso model fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.control(sigma2 = -1, tol = 1E-05, itmax = 1E+3, stand = TRUE,
  trace = 0, nfolds = 5, seed = NULL, adaptive = FALSE, g = .5,
  b0 = NULL, V0 = NULL, c = .5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.control_+3A_sigma2">sigma2</code></td>
<td>
<p>optional. The fixed value of dispersion parameter. If -1 (default) it is estimated from the data</p>
</td></tr>
<tr><td><code id="is.control_+3A_tol">tol</code></td>
<td>
<p>tollerance value to declare convergence, dafault to 1e-5</p>
</td></tr>
<tr><td><code id="is.control_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations, default to 1000</p>
</td></tr>
<tr><td><code id="is.control_+3A_stand">stand</code></td>
<td>
<p>if TRUE (default), the covariates are standardized prior to fitting the model. However the coefficients are always returned on the original scale.</p>
</td></tr>
<tr><td><code id="is.control_+3A_trace">trace</code></td>
<td>
<p>Should the iterative procedure be printed? 0: no printing, 1 = compact printing, 2 = enlarged printing, 3 = compact printing including Fisher scoring information (only used in glm family). </p>
</td></tr>
<tr><td><code id="is.control_+3A_nfolds">nfolds</code></td>
<td>
<p>if <code>lambda</code> is unspecified in <code>islasso</code>, the number of folds to be used to perform cross valdation. Default to 5, and <code>nfolds&gt;2</code> is allowed. Although nfolds can be as large as the sample size (leave-one-out CV), it is not recommended for large datasets. <code>nfolds</code> is ignored if <code>lambda</code> is supplied.</p>
</td></tr>
<tr><td><code id="is.control_+3A_seed">seed</code></td>
<td>
<p>optional, the seed to be used to split the dataframe and to perform cross validation. Useful to make reproducible the results. </p>
</td></tr>
<tr><td><code id="is.control_+3A_adaptive">adaptive</code></td>
<td>
<p>experimental, if TRUE the adaptive LASSO is implemented.</p>
</td></tr>
<tr><td><code id="is.control_+3A_g">g</code></td>
<td>
<p>a value belonging to the interval [0, 1]. Classical BIC is returned by letting g = 0 (default value), whereas extended BIC corresponds to the case g = 0.5.</p>
</td></tr>
<tr><td><code id="is.control_+3A_b0">b0</code></td>
<td>
<p>optional, starting values for the regression coefficients. If NULL, the point estimates from <code>glmnet</code> are used.</p>
</td></tr>
<tr><td><code id="is.control_+3A_v0">V0</code></td>
<td>
<p>optional, starting value for the estimates covariance matrix, If NULL, the identity matrix is used.</p>
</td></tr>
<tr><td><code id="is.control_+3A_c">c</code></td>
<td>
<p>the weight of the mixture in the induced smoothed lasso, the default is <code>c = .5</code>. <code>c = -1</code> means to compute it at each step of the iterative algorithm. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maintainer: Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
</p>

<hr>
<h2 id='islasso'>
The Induced Smoothed lasso
</h2><span id='topic+islasso'></span><span id='topic+print.islasso'></span><span id='topic+islasso.fit'></span><span id='topic+vcov.islasso'></span><span id='topic+deviance.islasso'></span><span id='topic+residuals.islasso'></span><span id='topic+logLik.islasso'></span><span id='topic+model.matrix.islasso'></span><span id='topic+cooks.distance.islasso'></span><span id='topic+extractAIC.islasso'></span><span id='topic+family.islasso'></span><span id='topic+formula.islasso'></span><span id='topic+influence.islasso'></span><span id='topic+model.frame.islasso'></span><span id='topic+nobs.islasso'></span><span id='topic+rstandard.islasso'></span><span id='topic+rstudent.islasso'></span><span id='topic+variable.names.islasso'></span><span id='topic+weights.islasso'></span>

<h3>Description</h3>

<p><code>islasso</code> is used to fit lasso regression models wherein the nonsmooth <code class="reqn">L_1</code> norm penalty is replaced by a smooth approximation justified under the induced smoothing paradigm. Simple lasso-type or elastic-net penalties are permitted and Linear, Logistic, Poisson and Gamma responses are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>islasso(formula, family = gaussian, lambda, alpha = 1, data, weights, subset,
        offset, unpenalized, contrasts = NULL, control = is.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="islasso_+3A_formula">formula</code></td>
<td>

<p>an object of class &ldquo;formula&rdquo; (or one that can be coerced to that class): the &lsquo;usual&rsquo;  symbolic description of the model to be fitted.
</p>
</td></tr>
<tr><td><code id="islasso_+3A_family">family</code></td>
<td>

<p>the assumed response distribution. Gaussian, (quasi) Binomial, (quasi) Poisson, and Gamma are allowed. <code>family=gaussian</code> is implemented with <code>identity</code> link, <code>family=binomial</code> is implemented with <code>logit</code> or <code>probit</code> links, <code>family=poisson</code> is implemented with <code>log</code> link, and <code>family=Gamma</code> is implemented with <code>inverse</code>, <code>log</code> and <code>identity</code> links.
</p>
</td></tr>
<tr><td><code id="islasso_+3A_lambda">lambda</code></td>
<td>

<p>Value of the tuning parameter in the objective. If missing, the optimal lambda is computed using <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>.
</p>
</td></tr>
<tr><td><code id="islasso_+3A_alpha">alpha</code></td>
<td>

<p>The elastic-net mixing parameter, with <code class="reqn">0\le\alpha\le 1</code>. The penalty is defined
as </p>
<p style="text-align: center;"><code class="reqn">(1-\alpha)/2||\beta||_2^2+\alpha||\beta||_1.</code>
</p>
 <p><code>alpha=1</code>
is the lasso penalty, and <code>alpha=0</code> the ridge penalty.
</p>
</td></tr>
<tr><td><code id="islasso_+3A_data">data</code></td>
<td>

<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which <code>islasso</code> is called.
</p>
</td></tr>
<tr><td><code id="islasso_+3A_weights">weights</code></td>
<td>

<p>observation weights. Default is 1 for each observation.
</p>
</td></tr>
<tr><td><code id="islasso_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="islasso_+3A_offset">offset</code></td>
<td>

<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases.
</p>
</td></tr>
<tr><td><code id="islasso_+3A_unpenalized">unpenalized</code></td>
<td>

<p>optional. A vector of integers or characters indicating any covariate (in the formula) with coefficients not to be penalized. The intercept, if included in the model, is <em>always</em> unpenalized.
</p>
</td></tr>
<tr><td><code id="islasso_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the contrasts.arg of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="islasso_+3A_control">control</code></td>
<td>

<p>a list of parameters for controlling the fitting process (see <code>islasso.control</code> for more details).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>islasso</code> estimates regression models by imposing a lasso-type penalty on some or all regression coefficients. However the nonsmooth <code class="reqn">L_1</code> norm penalty is replaced by a smooth approximation justified under the induced smoothing paradigm. The advantage is that reliable standard errors are returned as model output and hypothesis testing on linear combinantions of the regression parameters can be carried out straightforwardly via the Wald statistic. Simulation studies provide evidence that the proposed approach   controls type-I errors and exhibits good power in different scenarios.</p>


<h3>Value</h3>


<p>A list of
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>a named vector of standard errors</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the working residuals</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted values</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>the estimated degrees of freedom</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the family object used</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>the linear predictors</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the family deviance</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>the Akaike Information Criterion</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>the family null deviance</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations of IWLS used</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the working weights, that is the weights in the final iteration of the IWLS fit</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the residual degrees of freedom</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>the degrees of freedom of a null model</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical. Was the IWLS algorithm judged to have converged?</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if requested (the default), the model frame used.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the formula supplied</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the terms object used</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>he data argument.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>the offset vector used.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the value of the control argument used</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>(where relevant) a record of the levels of the factors used in fitting.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the lambda value used in the islasso algorithm</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the elasticnet mixing parameter</p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p>the estimated dispersion parameter</p>
</td></tr>
<tr><td><code>internal</code></td>
<td>
<p>internal elements</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>(only where relevant) the contrasts used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The main function of the same name was inspired by the R function previously implemented by Vito MR Muggeo.
</p>
<p>Maintainer: Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
</p>


<h3>References</h3>

<p>Cilluffo, G, Sottile, G, S, La Grutta, S and Muggeo, VMR (2019). <em>The Induced Smoothed lasso: A practical framework for hypothesis testing in high dimensional regression</em>.
Statistical Methods in Medical Research, DOI: 10.1177/0962280219842890.
</p>
<p>Sottile, G, Cilluffo, G, Muggeo, VMR (2019). <em>The R package islasso: estimation and
hypothesis testing in lasso regression</em>. Technical Report on ResearchGate.
doi:10.13140/RG.2.2.16360.11521.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+islasso.fit">islasso.fit</a></code>, <code><a href="#topic+summary.islasso">summary.islasso</a></code>, <code><a href="#topic+residuals.islasso">residuals.islasso</a></code>, <code><a href="#topic+logLik.islasso">logLik.islasso</a></code>, <code><a href="#topic+predict.islasso">predict.islasso</a></code> and <code><a href="#topic+deviance.islasso">deviance.islasso</a></code> methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 100
p1 &lt;- 10  #number of nonzero coefficients
coef.veri &lt;- sort(round(c(seq(.5, 3, l=p1/2), seq(-1, -2, l=p1/2)), 2))
sigma &lt;- 1

coef &lt;- c(coef.veri, rep(0, p-p1))

X &lt;- matrix(rnorm(n*p), n, p)
eta &lt;- drop(X%*%coef)

##### gaussian ######
mu &lt;- eta
y &lt;- mu + rnorm(n, 0, sigma)

o &lt;- islasso(y ~ ., data = data.frame(y = y, X), 
             family = gaussian())
o
summary(o)
coef(o)
fitted(o)
predict(o, type="response")
plot(o)
residuals(o)
deviance(o)
AIC(o)
logLik(o)

## Not run: 
# for the interaction
o &lt;- islasso(y ~ X1 * X2, data = data.frame(y = y, X), 
             family = gaussian())

##### binomial ######
coef &lt;- c(c(1,1,1), rep(0, p-3))
X &lt;- matrix(rnorm(n*p), n, p)
eta &lt;- drop(cbind(1, X)%*%c(-1, coef))
mu &lt;- binomial()$linkinv(eta)
y &lt;- rbinom(n, 100, mu)
y &lt;- cbind(y, 100-y)

o &lt;- islasso(cbind(y1, y2) ~ ., 
             data = data.frame(y1 = y[,1], y2 = y[,2], X), 
             family = binomial())
summary(o, pval = .05)

##### poisson ######
coef &lt;- c(c(1,1,1), rep(0, p-3))
X &lt;- matrix(rnorm(n*p), n, p)
eta &lt;- drop(cbind(1, X)%*%c(1, coef))
mu &lt;- poisson()$linkinv(eta)
y &lt;- rpois(n, mu)

o &lt;- islasso(y ~ ., data = data.frame(y = y, X), 
             family = poisson())
summary(o, pval = .05)

##### Gamma ######
coef &lt;- c(c(1,1,1), rep(0, p-3))
X &lt;- matrix(rnorm(n*p), n, p)
eta &lt;- drop(cbind(1, X)%*%c(-1, coef))
mu &lt;- Gamma(link="log")$linkinv(eta)
shape &lt;- 10
phi &lt;- 1 / shape
y &lt;- rgamma(n, scale = mu / shape, shape = shape)

o &lt;- islasso(y ~ ., data = data.frame(y = y, X), 
             family = Gamma(link = "log"))
summary(o, pval = .05)

## End(Not run)
</code></pre>

<hr>
<h2 id='islasso-internal'>Internal Functions</h2><span id='topic+fmt.perc'></span><span id='topic+qqNorm'></span><span id='topic+ginv2'></span><span id='topic+modelX'></span><span id='topic+printCoefmat2'></span><span id='topic+.checkinput'></span><span id='topic+.startpoint'></span><span id='topic+.islasso'></span><span id='topic+checkinput.islasso.path'></span><span id='topic+startpoint.islasso.path'></span><span id='topic+islasso.path.fit.glm'></span><span id='topic+islasso.path.fitter2'></span><span id='topic+interpolate'></span><span id='topic+makeHyp'></span><span id='topic+printHyp'></span><span id='topic+cislasso'></span><span id='topic+ci.fitted.islasso'></span><span id='topic+grad.islasso'></span><span id='topic+hess.islasso'></span><span id='topic+is.influence'></span><span id='topic+islasso.diag'></span><span id='topic+islasso.diag.plots'></span><span id='topic+predislasso'></span>

<h3>Description</h3>

<p>Internal islasso functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmt.perc(probs, digits)
qqNorm(x, probs=seq(.005, .995, l=200), centre=FALSE, scale=FALSE, 
  leg=TRUE, mean=0, sd=1, add=FALSE, p.col=1, dF=FALSE, ylab, ...)
ginv2(X, tol = sqrt(.Machine$double.eps))
modelX(n, p, rho=.5, scale=TRUE)
printCoefmat2(x, digits = max(3L, getOption("digits") - 2L), 
  signif.stars = getOption("show.signif.stars"), 
  signif.legend = signif.stars, dig.tst = max(1L, min(5L, digits - 1L)), 
  cs.ind = 1:k, tst.ind = k + 1, zap.ind = integer(), P.values = NULL, 
  has.Pvalue = nc &gt;= 4L &amp;&amp; length(cn &lt;- colnames(x)) &amp;&amp; 
    substr(cn[nc], 1L, 3L) %in% c("Pr(", "p-v"), 
  eps.Pvalue = .Machine$double.eps, na.print = "NA", quote = FALSE, 
  right = TRUE, ...)
.checkinput(X, y, family, alpha, intercept, weights, offset, 
  unpenalized, control)
.startpoint(X, y, lambda, alpha, weights, offset, mustart, 
  family, intercept, setting)
.islasso(prep, start, Lambda, fam, link)

checkinput.islasso.path(X, y, family, lambda, nlambda, lambda.min.ratio, 
  alpha, intercept, weights, offset, unpenalized, control)
startpoint.islasso.path(X, y, lambda, alpha, weights, offset, mustart, 
  family, intercept, setting)
islasso.path.fit.glm(prep, start, lambda, fam, link)
islasso.path.fitter2(b, se, c, fix.c, l, alpha, x, y, weights, sigma2, 
  cov.unscaled, n, intercept, tol, unpenalized, offset, family, maxIter)
interpolate(y1, y2, x1, x2, x.new)

makeHyp(cnames, hypothesis, rhs = NULL) 
printHyp(L, b, nms)

cislasso(object, a, ci)
ci.fitted.islasso(object, newx, ci = NULL, type.ci = "wald", 
  conf.level=.95, only.ci = FALSE)
  
grad.islasso(object, ...)
hess.islasso(object, ...)
is.influence(model, do.coef = TRUE)
islasso.diag(glmfit)
islasso.diag.plots(glmfit, glmdiag = islasso.diag(glmfit), 
  subset = NULL, iden = FALSE, labels = NULL, ret = FALSE)
predislasso(object, newdata, type = c("response", "terms"), 
  terms = NULL, na.action = na.pass, ...)
</code></pre>


<h3>Details</h3>

<p>These functions are not intended for users.</p>


<h3>Author(s)</h3>

<p>Gianluca Sottile (<a href="mailto:gianluca.sottile@unipa.it">gianluca.sottile@unipa.it</a>)</p>

<hr>
<h2 id='islasso-package'>
The Induced Smoothed lasso: A practical framework for hypothesis testing in high dimensional regression
</h2><span id='topic+islasso-package'></span>

<h3>Description</h3>

<p>This package implements an induced smoothed approach for hypothesis testing in lasso regression.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> islasso</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.5.w</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-01-22</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code><a href="#topic+islasso">islasso</a></code> is used to fit generalized linear models with a L1-penalty on (some) regression coefficients. Along with point estimates, the main advantage is to return the full covariance matrix of estimate. The resulting standard errors can be used to make inference in the lasso framework. The main function is <code><a href="#topic+islasso">islasso</a></code> and the correspoinding fitter function <code><a href="#topic+islasso.fit">islasso.fit</a></code>, and many auxiliary functions are implemented to summarize and visualize results: <code><a href="#topic+summary.islasso">summary.islasso</a></code>,  <code><a href="#topic+predict.islasso">predict.islasso</a></code>,  <code><a href="#topic+logLik.islasso">logLik.islasso</a></code>, <code><a href="#topic+deviance.islasso">deviance.islasso</a></code>,  <code><a href="#topic+residuals.islasso">residuals.islasso</a></code>.
</p>
<p><code><a href="#topic+islasso.path">islasso.path</a></code> is used to fit Fit a generalized linear model via the Induced Smoothed Lasso. The regularization path is computed for the lasso or elasticnet penalty at a grid of values for the regularization parameter lambda. Along with coefficients profile, the main advantage is to return also the standard errors profile. The resulting standard errors can be used to make inference in the lasso framework. The main function is <code><a href="#topic+islasso.path">islasso.path</a></code> and the correspoinding fitter function <code><a href="#topic+islasso.path.fit">islasso.path.fit</a></code>, and many auxiliary functions are implemented to summarize and visualize results: <code><a href="#topic+summary.islasso.path">summary.islasso.path</a></code>,  <code><a href="#topic+predict.islasso.path">predict.islasso.path</a></code>,  <code><a href="#topic+logLik.islasso.path">logLik.islasso.path</a></code>, <code><a href="#topic+deviance.islasso.path">deviance.islasso.path</a></code>,  <code><a href="#topic+residuals.islasso.path">residuals.islasso.path</a></code>, <code><a href="#topic+coef.islasso.path">coef.islasso.path</a></code>, <code><a href="#topic+fitted.islasso.path">fitted.islasso.path</a></code>.
</p>


<h3>Author(s)</h3>

<p>Gianluca Sottile based on some preliminary functions by Vito Muggeo.
</p>
<p>Maintainer: Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
</p>


<h3>References</h3>

<p>Cilluffo, G, Sottile, G, S, La Grutta, S and Muggeo, VMR (2019). <em>The Induced Smoothed lasso: A practical framework for hypothesis testing in high dimensional regression</em>.
Statistical Methods in Medical Research, DOI: 10.1177/0962280219842890.
</p>
<p>Sottile, G, Cilluffo, G, Muggeo, VMR (2019). <em>The R package islasso: estimation and
hypothesis testing in lasso regression</em>. Technical Report on ResearchGate.
doi:10.13140/RG.2.2.16360.11521.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 30
p1 &lt;- 10  #number of nonzero coefficients
coef.veri &lt;- sort(round(c(seq(.5, 3, l=p1/2), seq(-1, -2, l=p1/2)), 2))
sigma &lt;- 1

coef &lt;- c(coef.veri, rep(0, p-p1))

X &lt;- matrix(rnorm(n*p), n, p)
mu &lt;- drop(X%*%coef)
y &lt;- mu + rnorm(n, 0,sigma)

o &lt;- islasso.path(y ~ ., data = data.frame(y = y, X), 
                  family = gaussian())
temp &lt;- GoF.islasso.path(o) 

lambda &lt;- temp$lambda.min["BIC"]
o &lt;- islasso(y ~ ., data = data.frame(y = y, X), 
             family = gaussian(), lambda = lambda)
o
summary(o, pval = .05)

</code></pre>

<hr>
<h2 id='islasso.path'>
The Induced Smoothed lasso path
</h2><span id='topic+islasso.path'></span><span id='topic+print.islasso.path'></span><span id='topic+islasso.path.fit'></span><span id='topic+coef.islasso.path'></span><span id='topic+deviance.islasso.path'></span><span id='topic+fitted.islasso.path'></span><span id='topic+residuals.islasso.path'></span><span id='topic+logLik.islasso.path'></span><span id='topic+print.logLik.islasso.path'></span><span id='topic+model.matrix.islasso.path'></span>

<h3>Description</h3>

<p><code>islasso.path</code> is used to fit a generalized linear model via induced smoothed lasso method. The regularization path is computed for the lasso or elasticnet penalty at a grid of values for the regularization parameter lambda. Fits linear, logistic, poisson and gamma regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>islasso.path(formula, family = gaussian(), lambda = NULL, nlambda = 100, 
        lambda.min.ratio = ifelse(nobs &lt; nvars, 1E-2, 1E-03), alpha = 1, data, 
        weights, subset, offset, contrasts = NULL, unpenalized, control = is.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="islasso.path_+3A_formula">formula</code></td>
<td>

<p>an object of class &ldquo;formula&rdquo; (or one that can be coerced to that class): the &lsquo;usual&rsquo;  symbolic description of the model to be fitted.
</p>
</td></tr>
<tr><td><code id="islasso.path_+3A_family">family</code></td>
<td>

<p>the assumed response distribution. Gaussian, (quasi) Binomial, (quasi) Poisson, and Gamma are allowed. <code>family=gaussian</code> is implemented with <code>identity</code> link, <code>family=binomial</code> is implemented with <code>logit</code> or <code>probit</code> links, <code>family=poisson</code> is implemented with <code>log</code> link, and <code>family=Gamma</code> is implemented with <code>inverse</code>, <code>log</code> and <code>identity</code> links.
</p>
</td></tr>
<tr><td><code id="islasso.path_+3A_lambda">lambda</code></td>
<td>

<p>A user supplied lambda sequence. Typical usage is to have the program compute its own lambda sequence based on nlambda and lambda.min.ratio. Supplying a value of lambda overrides this.
</p>
</td></tr>
<tr><td><code id="islasso.path_+3A_nlambda">nlambda</code></td>
<td>

<p>The number of lambda values - default is 100.
</p>
</td></tr>
<tr><td><code id="islasso.path_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>

<p>Smallest value for lambda, as a fraction of lambda.max, the (data derived) entry value (i.e. the smallest value for which all coefficients are zero). The default depends on the sample size <code>nobs</code> relative to the number of variables <code>nvars</code>. If <code>nobs &gt; nvars</code>, the default is 0.00001, close to zero. If <code>nobs &lt; nvars</code>, the default is 0.001. A very small value of lambda.min.ratio will lead to a saturated fit in the <code>nobs &lt; nvars</code> case. 
</p>
</td></tr>
<tr><td><code id="islasso.path_+3A_alpha">alpha</code></td>
<td>

<p>The elastic-net mixing parameter, with <code class="reqn">0\le\alpha\le 1</code>. The penalty is defined
as </p>
<p style="text-align: center;"><code class="reqn">(1-\alpha)/2||\beta||_2^2+\alpha||\beta||_1.</code>
</p>
 <p><code>alpha=1</code>
is the lasso penalty, and <code>alpha=0</code> the ridge penalty.
</p>
</td></tr>
<tr><td><code id="islasso.path_+3A_data">data</code></td>
<td>

<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which <code>islasso</code> is called.
</p>
</td></tr>
<tr><td><code id="islasso.path_+3A_weights">weights</code></td>
<td>

<p>observation weights. Default is 1 for each observation.
</p>
</td></tr>
<tr><td><code id="islasso.path_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="islasso.path_+3A_offset">offset</code></td>
<td>

<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases.
</p>
</td></tr>
<tr><td><code id="islasso.path_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the contrasts.arg of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="islasso.path_+3A_control">control</code></td>
<td>

<p>a list of parameters for controlling the fitting process (see <code>islasso.control</code> for more details).
</p>
</td></tr>
<tr><td><code id="islasso.path_+3A_unpenalized">unpenalized</code></td>
<td>

<p>optional. A vector of integers or characters indicating any covariate (in the formula) with coefficients not to be penalized. The intercept, if included in the model, is <em>always</em> unpenalized.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sequence of models implied by lambda is fit the islasso method. <code>islasso</code> estimates regression models by imposing a lasso-type penalty on some or all regression coefficients. However the nonsmooth <code class="reqn">L_1</code> norm penalty is replaced by a smooth approximation justified under the induced smoothing paradigm. The advantage is that reliable standard errors are returned as model output and hypothesis testing on linear combinantions of the regression parameters can be carried out straightforwardly via the Wald statistic. Simulation studies provide evidence that the proposed approach   controls type-I errors and exhibits good power in different scenarios.</p>


<h3>Value</h3>


<p>A list of
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>Info</code></td>
<td>
<p>a named matrix containing information about lambda values, estimated degrees of freedom, estimated dispersion parameters, deviance, loglikelhood, number of iterations and convergence criteria.</p>
</td></tr>
<tr><td><code>GoF</code></td>
<td>
<p>a named matrix containing information criteria, i.e., AIC, BIC, AICc, eBIC, GCV, GIC.</p>
</td></tr>
<tr><td><code>Coef</code></td>
<td>
<p>a <code>length(lambda) x nvars</code> matrix of coefficients.</p>
</td></tr>
<tr><td><code>SE</code></td>
<td>
<p>a <code>length(lambda) x nvars</code> matrix of standard errors.</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>a <code>length(lambda) x nvars</code> matrix of the weight of the mixture in the induced smoothed lasso.</p>
</td></tr>
<tr><td><code>Linear.predictors</code></td>
<td>
<p>a <code>length(lambda) x nvars</code> matrix of linear predictors</p>
</td></tr>
<tr><td><code>Fitted.values</code></td>
<td>
<p>a <code>length(lambda) x nvars</code> matrix of fitted values</p>
</td></tr>
<tr><td><code>Residuals</code></td>
<td>
<p>a <code>length(lambda) x nvars</code> matrix of working residuals</p>
</td></tr>
<tr><td><code>Input</code></td>
<td>
<p>a named list containing several input arguments, i.e., the numbers of observations and predictors, if an intercept ha to be estimated, the model matrix and the response vector, the observation weights, the offset, the family object used, The elasticnet mixing parameter and the vector used to specify the unpenalized estimators.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the value of the control argument used.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the formula supplied.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if requested (the default), the model frame used.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the terms object used.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>he data argument.</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>(where relevant) a record of the levels of the factors used in fitting.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>(only where relevant) the contrasts used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maintainer: Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
</p>


<h3>References</h3>

<p>Cilluffo, G, Sottile, G, S, La Grutta, S and Muggeo, VMR (2019). <em>The Induced Smoothed lasso: A practical framework for hypothesis testing in high dimensional regression</em>.
Statistical Methods in Medical Research, DOI: 10.1177/0962280219842890.
</p>
<p>Sottile, G, Cilluffo, G, Muggeo, VMR (2019). <em>The R package islasso: estimation and
hypothesis testing in lasso regression</em>. Technical Report on ResearchGate.
doi:10.13140/RG.2.2.16360.11521.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+islasso.path.fit">islasso.path.fit</a></code>, <code><a href="#topic+coef.islasso.path">coef.islasso.path</a></code>, <code><a href="#topic+summary.islasso.path">summary.islasso.path</a></code>, <code><a href="#topic+residuals.islasso.path">residuals.islasso.path</a></code>, <code><a href="#topic+GoF.islasso.path">GoF.islasso.path</a></code>, <code><a href="#topic+logLik.islasso.path">logLik.islasso.path</a></code>, <code><a href="#topic+fitted.islasso.path">fitted.islasso.path</a></code>, <code><a href="#topic+predict.islasso.path">predict.islasso.path</a></code> and <code><a href="#topic+deviance.islasso.path">deviance.islasso.path</a></code> methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 30
p1 &lt;- 10  #number of nonzero coefficients
coef.veri &lt;- sort(round(c(seq(.5, 3, l=p1/2), seq(-1, -2, l=p1/2)), 2))
sigma &lt;- 1

coef &lt;- c(coef.veri, rep(0, p-p1))

X &lt;- matrix(rnorm(n*p), n, p)
eta &lt;- drop(X%*%coef)

##### gaussian ######
mu &lt;- eta
y &lt;- mu + rnorm(n, 0, sigma)

o &lt;- islasso.path(y ~ ., data = data.frame(y = y, X), 
             family = gaussian(), nlambda = 30L)
o
summary(o, lambda = 10)
coef(o, lambda = 10)
fitted(o, lambda = 10)
predict(o, type="response", lambda = 10)
plot(o, xvar = "coef")
residuals(o, lambda = 10)
deviance(o, lambda = 10)
logLik(o, lambda = 10)
GoF.islasso.path(o)

## Not run: 
##### binomial ######
coef &lt;- c(c(1,1,1), rep(0, p-3))
X &lt;- matrix(rnorm(n*p), n, p)
eta &lt;- drop(cbind(1, X)%*%c(-1, coef))
mu &lt;- binomial()$linkinv(eta)
y &lt;- rbinom(n, 100, mu)
y &lt;- cbind(y, 100-y)

o &lt;- islasso.path(cbind(y1, y2) ~ ., 
             data = data.frame(y1 = y[,1], y2 = y[,2], X), 
             family = binomial(), nlambda = 30L)
temp &lt;- GoF.islasso.path(o)
summary(o, pval = .05, lambda = temp$lambda.min["BIC"])

##### poisson ######
coef &lt;- c(c(1,1,1), rep(0, p-3))
X &lt;- matrix(rnorm(n*p), n, p)
eta &lt;- drop(cbind(1, X)%*%c(1, coef))
mu &lt;- poisson()$linkinv(eta)
y &lt;- rpois(n, mu)

o &lt;- islasso.path(y ~ ., data = data.frame(y = y, X), 
             family = poisson(), nlambda = 30L)
temp &lt;- GoF.islasso.path(o)
summary(o, pval = .05, lambda = temp$lambda.min["BIC"])

##### Gamma ######
coef &lt;- c(c(1,1,1), rep(0, p-3))
X &lt;- matrix(rnorm(n*p), n, p)
eta &lt;- drop(cbind(1, X)%*%c(-1, coef))
mu &lt;- Gamma(link="log")$linkinv(eta)
shape &lt;- 10
phi &lt;- 1 / shape
y &lt;- rgamma(n, scale = mu / shape, shape = shape)

o &lt;- islasso.path(y ~ ., data = data.frame(y = y, X), 
             family = Gamma(link = "log"), nlambda = 30L)
temp &lt;- GoF.islasso.path(o)
summary(o, pval = .05, lambda = temp$lambda.min["BIC"])

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.islasso'>Diagnostics plots for Induced Smoothing Lasso Model</h2><span id='topic+plot.islasso'></span>

<h3>Description</h3>

<p>Diagnostics plots for Induced Smoothing Lasso Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'islasso'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.islasso_+3A_x">x</code></td>
<td>
<p>an object of class <code>islasso</code>, usually, a result of a call to <code><a href="#topic+islasso">islasso</a></code>.</p>
</td></tr>
<tr><td><code id="plot.islasso_+3A_...">...</code></td>
<td>
<p>other graphical parameters for the plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot on the top left is a plot of the standard deviance residuals against the fitted values.
The plot on the top right is a normal QQ plot of the standardized deviance residuals.
The red line is the expected line if the standardized residuals are normally distributed, i.e. it is the line with intercept 0 and slope 1.
The bottom two panels are plots of link and variance functions. On the left is squared standardized Pearson residuals against the fitted values.
On the right working vector against the linear predictor.
</p>


<h3>Author(s)</h3>

<p>Maintainer: Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+islasso.fit">islasso.fit</a></code>, <code><a href="#topic+summary.islasso">summary.islasso</a></code>, <code><a href="#topic+residuals.islasso">residuals.islasso</a></code>, <code><a href="#topic+logLik.islasso">logLik.islasso</a></code>, <code><a href="#topic+predict.islasso">predict.islasso</a></code> and <code><a href="#topic+deviance.islasso">deviance.islasso</a></code> methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  set.seed(1)
  n &lt;- 100
  p &lt;- 100
  p1 &lt;- 20  #number of nonzero coefficients
  coef.veri &lt;- sort(round(c(seq(.5, 3, l=p1/2), seq(-1, -2, l=p1/2)), 2))
  sigma &lt;- 1

  coef &lt;- c(coef.veri, rep(0, p-p1))

  X &lt;- matrix(rnorm(n*p), n, p)
  mu &lt;- drop(X%*%coef)
  y &lt;- mu + rnorm(n, 0,sigma)

  lambda &lt;- 2
  o &lt;- islasso(y ~ ., data = data.frame(y = y, X), 
               family = gaussian(), lambda = lambda)
  plot(o)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.islasso.path'>plot coefficient profile from a fitted &quot;islasso.path&quot; object.</h2><span id='topic+plot.islasso.path'></span>

<h3>Description</h3>

<p>Produces a coefficient profile plot of the coefficient paths for a fitted &quot;islasso.path&quot; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'islasso.path'
plot(x, 
  yvar = c("coefficients", "se", "gradient", "weight", "gof"), 
  gof = c("none", "AIC", "BIC", "AICc", "eBIC", "GCV", "GIC"), 
  label = FALSE, legend = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.islasso.path_+3A_x">x</code></td>
<td>
<p>an object of class <code>islasso</code>, usually, a result of a call to <code><a href="#topic+islasso.path">islasso.path</a></code>.</p>
</td></tr>
<tr><td><code id="plot.islasso.path_+3A_yvar">yvar</code></td>
<td>
<p>What is on the Y-axis. &quot;coef&quot; plot the log-lambda sequence against the coefficients; &quot;se&quot; plot the log-lambda sequence against the standard deviations; &quot;gradient&quot; plot the log-lambda sequence against the gradient; &quot;weight&quot; plot the log-lambda sequence against the mixture weight of the islasso method; &quot;gof&quot; plot the log-lambda sequence against the chosen criterion.</p>
</td></tr>
<tr><td><code id="plot.islasso.path_+3A_gof">gof</code></td>
<td>
<p>the chosen criterion to highlight the active variables. &quot;none&quot; doesn't highlight active variables.</p>
</td></tr>
<tr><td><code id="plot.islasso.path_+3A_label">label</code></td>
<td>
<p>a logical flag indicating if some labels have to be added.</p>
</td></tr>
<tr><td><code id="plot.islasso.path_+3A_legend">legend</code></td>
<td>
<p>a logical flag indicating if legend has to be shown.</p>
</td></tr>
<tr><td><code id="plot.islasso.path_+3A_...">...</code></td>
<td>
<p>other graphical parameters for the plot, i.e., main, xlab, ylab, xlim, ylim, lty, col, lwd, cex.axis, cex.lab, cex.main, gof_lty, gof_col and gof_lwd. The last three parameters are used to modify aspects of the legend, and of the goodness of fit measure used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A coefficient profile plot is produced for Induced Smoothing Lasso Model path.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  set.seed(1)
  n &lt;- 100
  p &lt;- 30
  p1 &lt;- 10  #number of nonzero coefficients
  coef.veri &lt;- sort(round(c(seq(.5, 3, l=p1/2), seq(-1, -2, l=p1/2)), 2))
  sigma &lt;- 1

  coef &lt;- c(coef.veri, rep(0, p-p1))

  X &lt;- matrix(rnorm(n*p), n, p)
  mu &lt;- drop(X%*%coef)
  y &lt;- mu + rnorm(n, 0,sigma)

  o &lt;- islasso.path(y ~ ., data = data.frame(y = y, X), 
                    family = gaussian())
  par(mfrow = c(2, 2))
  plot(o, yvar = "coefficients", gof = "AICc", label = TRUE)
  plot(o, yvar = "se", gof = "AICc")
  plot(o, yvar = "gradient", gof = "AICc")
  plot(o, yvar = "gof", gof = "AICc")

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.islasso'>Prediction method for islasso fitted objects</h2><span id='topic+predict.islasso'></span>

<h3>Description</h3>

<p>Prediction method for islasso fitted objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'islasso'
predict(object, newdata = NULL, 
  type = c("link", "response", "coefficients", "class", "terms"), 
  se.fit = FALSE, ci = NULL, type.ci = "wald", 
  level = .95, terms = NULL, na.action = na.pass, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.islasso_+3A_object">object</code></td>
<td>
<p>a fitted object of class &quot;islasso&quot;.</p>
</td></tr>
<tr><td><code id="predict.islasso_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame in which to look for variables with which to predict. If omitted, the fitted linear predictors are used.</p>
</td></tr>
<tr><td><code id="predict.islasso_+3A_type">type</code></td>
<td>
<p>the type of prediction required. The default is on the scale of the linear predictors; the alternative &quot;response&quot; is on the scale of the response variable.
Thus for a default binomial model the default predictions are of log-odds (probabilities on logit scale) and type = &quot;response&quot; gives the predicted probabilities. The <code>coefficients</code> option returns coefficients. Type &quot;class&quot; applies only to &quot;binomial&quot; models, and produces the class label. The &quot;terms&quot; option returns a matrix giving the fitted values of each term in the model formula on the linear predictor scale.</p>
</td></tr>
<tr><td><code id="predict.islasso_+3A_se.fit">se.fit</code></td>
<td>
<p>logical switch indicating if confidence intervals are required.</p>
</td></tr>
<tr><td><code id="predict.islasso_+3A_ci">ci</code></td>
<td>
<p>optionally, a two columns matrix of estimated confidence intervals for the estimated coefficients.</p>
</td></tr>
<tr><td><code id="predict.islasso_+3A_type.ci">type.ci</code></td>
<td>
<p>Only Wald-type confidence intervals are implemented yet! type.ci = &quot;wald&quot; estimates and standard errors are used to build confidence interval</p>
</td></tr>
<tr><td><code id="predict.islasso_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="predict.islasso_+3A_terms">terms</code></td>
<td>
<p>with type = &quot;terms&quot; by default all terms are returned. A character vector specifies which terms are to be returned.</p>
</td></tr>
<tr><td><code id="predict.islasso_+3A_na.action">na.action</code></td>
<td>
<p>function determining what should be done with missing values in newdata. The default is to predict NA.</p>
</td></tr>
<tr><td><code id="predict.islasso_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object depending on the type argument
</p>


<h3>Author(s)</h3>

<p>Maintainer: Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+islasso.fit">islasso.fit</a></code>, <code><a href="#topic+summary.islasso">summary.islasso</a></code>, <code><a href="#topic+residuals.islasso">residuals.islasso</a></code>, <code><a href="#topic+logLik.islasso">logLik.islasso</a></code>, <code><a href="#topic+predict.islasso">predict.islasso</a></code> and <code><a href="#topic+deviance.islasso">deviance.islasso</a></code> methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> set.seed(1)
 n &lt;- 100
 p &lt;- 100
 p1 &lt;- 20  #number of nonzero coefficients
 coef.veri &lt;- sort(round(c(seq(.5, 3, l=p1/2), seq(-1, -2, l=p1/2)), 2))
 sigma &lt;- 1

 coef &lt;- c(coef.veri, rep(0, p-p1))

 X &lt;- matrix(rnorm(n*p), n, p)
 mu &lt;- drop(X%*%coef)
 y &lt;- mu + rnorm(n, 0,sigma)
 lambda &lt;- 2
 o &lt;- islasso(y ~ ., data = data.frame(y = y, X), lambda = lambda)
 predict(o, type = "response")
</code></pre>

<hr>
<h2 id='predict.islasso.path'>Prediction method for islasso.path fitted objects</h2><span id='topic+predict.islasso.path'></span>

<h3>Description</h3>

<p>Prediction method for islasso fitted objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'islasso.path'
predict(object, newdata, type = c("link", "response",
  "coefficients", "class"), lambda, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.islasso.path_+3A_object">object</code></td>
<td>
<p>a fitted object of class <code>"islasso.path"</code>.</p>
</td></tr>
<tr><td><code id="predict.islasso.path_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame in which to look for variables with which to predict. If omitted, the fitted linear predictors are used.</p>
</td></tr>
<tr><td><code id="predict.islasso.path_+3A_type">type</code></td>
<td>
<p>the type of prediction required. The default is on the scale of the linear predictors; the alternative &quot;response&quot; is on the scale of the response variable.
Thus for a default binomial model the default predictions are of log-odds (probabilities on logit scale) and type = &quot;response&quot; gives the predicted probabilities. The <code>coefficients</code> option returns coefficients. Type &quot;class&quot; applies only to &quot;binomial&quot; models, and produces the class label.</p>
</td></tr>
<tr><td><code id="predict.islasso.path_+3A_lambda">lambda</code></td>
<td>
<p>Value(s) of the penalty parameter lambda at which predictions are required. Default is the entire sequence used to create the model.</p>
</td></tr>
<tr><td><code id="predict.islasso.path_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object depending on the type argument
</p>


<h3>Author(s)</h3>

<p>Maintainer: Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+islasso.path">islasso.path</a></code>, <code><a href="#topic+islasso.path.fit">islasso.path.fit</a></code>, <code><a href="#topic+coef.islasso.path">coef.islasso.path</a></code>, <code><a href="#topic+residuals.islasso.path">residuals.islasso.path</a></code>, <code><a href="#topic+GoF.islasso.path">GoF.islasso.path</a></code>, <code><a href="#topic+logLik.islasso.path">logLik.islasso.path</a></code>, <code><a href="#topic+fitted.islasso.path">fitted.islasso.path</a></code>, <code><a href="#topic+summary.islasso.path">summary.islasso.path</a></code> and <code><a href="#topic+deviance.islasso.path">deviance.islasso.path</a></code> methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 set.seed(1)
 n &lt;- 100
 p &lt;- 30
 p1 &lt;- 10  #number of nonzero coefficients
 coef.veri &lt;- sort(round(c(seq(.5, 3, l=p1/2), seq(-1, -2, l=p1/2)), 2))
 sigma &lt;- 1

 coef &lt;- c(coef.veri, rep(0, p-p1))

 X &lt;- matrix(rnorm(n*p), n, p)
 mu &lt;- drop(X%*%coef)
 y &lt;- mu + rnorm(n, 0,sigma)

 o &lt;- islasso.path(y ~ ., data = data.frame(y = y, X), 
                   family = gaussian())
 temp &lt;- GoF.islasso.path(o)
 predict(o, type = "response", lambda = temp$lambda.min)

## End(Not run)
</code></pre>

<hr>
<h2 id='Prostate'>Prostate Cancer Data</h2><span id='topic+Prostate'></span>

<h3>Description</h3>

<p>These data come from a study that examined the correlation between the
level of prostate specific antigen and a number of clinical measures
in men who were about to receive a radical prostatectomy. It is data
frame with 97 rows and 9 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Prostate)
</code></pre>


<h3>Format</h3>

<p>The data frame has the following components:
</p>

<dl>
<dt><code>lcavol</code></dt><dd><p>log(cancer volume)</p>
</dd>
<dt><code>lweight</code></dt><dd><p>log(prostate weight)</p>
</dd>
<dt><code>age</code></dt><dd><p>age</p>
</dd>
<dt><code>lbph</code></dt><dd><p>log(benign prostatic hyperplasia amount)</p>
</dd>
<dt><code>svi</code></dt><dd><p>seminal vesicle invasion</p>
</dd>
<dt><code>lcp</code></dt><dd><p>log(capsular penetration)</p>
</dd>
<dt><code>gleason</code></dt><dd><p>Gleason score</p>
</dd>
<dt><code>pgg45</code></dt><dd><p>percentage Gleason scores 4 or 5</p>
</dd>
<dt><code>lpsa</code></dt><dd><p>log(prostate specific antigen)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Stamey, T.A., Kabalin, J.N., McNeal, J.E., Johnstone, I.M., Freiha,
F., Redwine, E.A. and Yang, N. (1989)<br />
Prostate specific antigen in the diagnosis and treatment of
adenocarcinoma of the prostate: II. radical prostatectomy treated
patients,
<em>Journal of Urology</em> <b>141</b>(5), 1076&ndash;1083.
</p>

<hr>
<h2 id='simulXy'>Simulate model matrix and response</h2><span id='topic+simulXy'></span>

<h3>Description</h3>

<p>Simulate model matrix and response from a specified distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulXy(n, p, interc = 0, beta, family = gaussian(), prop =
  0.1, lim.b = c(-3, 3), sigma = 1, size = 1, rho = 0,
  scale = TRUE, seed, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulXy_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="simulXy_+3A_p">p</code></td>
<td>
<p>total number of covariates in the model matrix.</p>
</td></tr>
<tr><td><code id="simulXy_+3A_interc">interc</code></td>
<td>
<p>the model intercept.</p>
</td></tr>
<tr><td><code id="simulXy_+3A_beta">beta</code></td>
<td>
<p>the vector of p coefficients in the linear predictor.</p>
</td></tr>
<tr><td><code id="simulXy_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to be used in the model. This can be a character string naming a family function, a family function or the result of a call to a family function. Only gaussian, binomial or poisson are allowed.</p>
</td></tr>
<tr><td><code id="simulXy_+3A_prop">prop</code></td>
<td>
<p>if <code>beta</code> is missing, <code>prop</code> represent the quote of non-null coefficients out of <code>p</code>. The default is <code>0.10 p</code>.</p>
</td></tr>
<tr><td><code id="simulXy_+3A_lim.b">lim.b</code></td>
<td>
<p>if <code>beta</code> is missing, the coefficients come from uniform variates in <code>lim.b</code>. The default is (-3,3).</p>
</td></tr>
<tr><td><code id="simulXy_+3A_sigma">sigma</code></td>
<td>
<p>if family is 'gaussian', the standard deviation of the response. The default is 1.</p>
</td></tr>
<tr><td><code id="simulXy_+3A_size">size</code></td>
<td>
<p>if family is 'binomial', the number of trials to build the response vector. The default is 1.</p>
</td></tr>
<tr><td><code id="simulXy_+3A_rho">rho</code></td>
<td>
<p>correlation value to define the variance covariance matrix to build the model matrix, i.e., rho^|i-j| i,j = 1,...,p and i different from j. The default is 0.</p>
</td></tr>
<tr><td><code id="simulXy_+3A_scale">scale</code></td>
<td>
<p>Should the columns of the mdoel matrix be scaled? The default is TRUE</p>
</td></tr>
<tr><td><code id="simulXy_+3A_seed">seed</code></td>
<td>
<p>optional, the seed to generate the data.</p>
</td></tr>
<tr><td><code id="simulXy_+3A_x">X</code></td>
<td>
<p>optional, the model matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 100
p &lt;- 100
beta &lt;- c(runif(10, -3, 3), rep(0, p-10))
dat &lt;- simulXy(n, p,  beta = beta, seed=1234)
</code></pre>

<hr>
<h2 id='summary.islasso'>summary method for islasso fitted objects</h2><span id='topic+summary.islasso'></span><span id='topic+print.summary.islasso'></span>

<h3>Description</h3>

<p>summary method for islasso fitted objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'islasso'
summary(object, pval = 1, which, use.t = FALSE,
  type.pval = "wald", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.islasso_+3A_object">object</code></td>
<td>
<p>fitted <code>"islasso"</code> object</p>
</td></tr>
<tr><td><code id="summary.islasso_+3A_pval">pval</code></td>
<td>
<p>a threshold p-value value indicating which coefficients should be printed. If <code>pval = 0.10</code>, say, only the variables/coefficients with <code class="reqn">p-value\le 0.10</code> are printed. Possible unpenalized coefficients (including the intercept if in the model) are always printed, regardless of their p-value.</p>
</td></tr>
<tr><td><code id="summary.islasso_+3A_which">which</code></td>
<td>
<p>a specification of which parameters are to be given p-values. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="summary.islasso_+3A_use.t">use.t</code></td>
<td>
<p>if <code>TRUE</code>, the p-values are computed using the t-distribution with residual model degrees of freedom</p>
</td></tr>
<tr><td><code id="summary.islasso_+3A_type.pval">type.pval</code></td>
<td>
<p>Only Wald-type confidence intervals are implemented yet! type.pval = &quot;wald&quot; (default) estimates and standard errors are used to build confidence interval</p>
</td></tr>
<tr><td><code id="summary.islasso_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maintainer: Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+islasso.fit">islasso.fit</a></code>, <code><a href="#topic+summary.islasso">summary.islasso</a></code>, <code><a href="#topic+residuals.islasso">residuals.islasso</a></code>, <code><a href="#topic+logLik.islasso">logLik.islasso</a></code>, <code><a href="#topic+predict.islasso">predict.islasso</a></code> and <code><a href="#topic+deviance.islasso">deviance.islasso</a></code> methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#continues example from ?islasso
summary(o, pval = .1) #print just the "borderline" significant coefficients

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.islasso.path'>summary method for islasso.path fitted objects</h2><span id='topic+summary.islasso.path'></span><span id='topic+print.summary.islasso.path'></span>

<h3>Description</h3>

<p>summary method for islasso.path fitted objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'islasso.path'
summary(object, pval = 1, use.t = FALSE, lambda, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.islasso.path_+3A_object">object</code></td>
<td>
<p>fitted <code>"islasso.path"</code> object</p>
</td></tr>
<tr><td><code id="summary.islasso.path_+3A_pval">pval</code></td>
<td>
<p>a threshold p-value value indicating which coefficients should be printed. If <code>pval = 0.10</code>, say, only the variables/coefficients with <code class="reqn">p-value\le 0.10</code> are printed. Possible unpenalized coefficients (including the intercept if in the model) are always printed, regardless of their p-value.</p>
</td></tr>
<tr><td><code id="summary.islasso.path_+3A_use.t">use.t</code></td>
<td>
<p>if <code>TRUE</code>, the p-values are computed using the t-distribution with residual model degrees of freedom</p>
</td></tr>
<tr><td><code id="summary.islasso.path_+3A_lambda">lambda</code></td>
<td>
<p>Value of the penalty parameter lambda at which summary are required.</p>
</td></tr>
<tr><td><code id="summary.islasso.path_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maintainer: Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+islasso.path">islasso.path</a></code>, <code><a href="#topic+islasso.path.fit">islasso.path.fit</a></code>, <code><a href="#topic+coef.islasso.path">coef.islasso.path</a></code>, <code><a href="#topic+residuals.islasso.path">residuals.islasso.path</a></code>, <code><a href="#topic+GoF.islasso.path">GoF.islasso.path</a></code>, <code><a href="#topic+logLik.islasso.path">logLik.islasso.path</a></code>, <code><a href="#topic+fitted.islasso.path">fitted.islasso.path</a></code>, <code><a href="#topic+predict.islasso.path">predict.islasso.path</a></code> and <code><a href="#topic+deviance.islasso.path">deviance.islasso.path</a></code> methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#continues example from ?islasso.path
summary(o, pval = .1, lambda = 5) #print just the "borderline" significant coefficients

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
