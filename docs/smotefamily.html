<!DOCTYPE html><html lang="en"><head><title>Help for package smotefamily</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {smotefamily}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ADASYN'>
<p>Adaptive Synthetic Sampling Approach for Imbalanced Learning</p></a></li>
<li><a href='#ANS'>
<p>Adaptive Neighbor Synthetic Majority Oversampling TEchnique</p></a></li>
<li><a href='#Borderline-SMOTE'>
<p>Borderline-SMOTE</p></a></li>
<li><a href='#DBSMOTE'>
<p>Density-based SMOTE</p></a></li>
<li><a href='#gap'>
<p>The function to provide a random number which is used as a location of synthetic instance</p></a></li>
<li><a href='#kncount'>
<p>Counting the number of each class in K nearest neighbor</p></a></li>
<li><a href='#knearest'>
<p>The function to find n_clust nearest neighbors of each instance, always removing the index of that instance if it is reported.</p></a></li>
<li><a href='#n_dup_max'>
<p>The function to calculate the maximum round each sampling is repeated</p></a></li>
<li><a href='#RSLS'>
<p>Relocating Safe-level SMOTE</p></a></li>
<li><a href='#sample_generator'>
<p>The function to generate 2-dimensional dataset</p></a></li>
<li><a href='#SLS'>
<p>Safe-level SMOTE</p></a></li>
<li><a href='#SMOTE'>
<p>Synthetic Minority Oversampling TEchnique</p></a></li>
<li><a href='#SMOTEfamily'>
<p>SMOTE family package for Data Generation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A Collection of Oversampling Techniques for Class Imbalance
Problem Based on SMOTE</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-14</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wacharasak Siriseriwan &lt;wacharasak.s@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of various oversampling techniques developed from SMOTE is provided. SMOTE is a oversampling technique which synthesizes a new minority instance between a pair of one minority instance and one of its K nearest neighbor.  Other techniques adopt this concept with other criteria in order to generate balanced dataset for class imbalance problem.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>FNN, dbscan,igraph</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-14 06:03:33 UTC; Dew</td>
</tr>
<tr>
<td>Author:</td>
<td>Wacharasak Siriseriwan [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-14 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ADASYN'>
Adaptive Synthetic Sampling Approach for Imbalanced Learning
</h2><span id='topic+ADAS'></span>

<h3>Description</h3>

<p>Generate synthetic positive instances using ADASYN algorithm. The number of majority neighbors of each minority instance determines the number of synthetic instances generated from the minority instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ADAS(X,target,K=5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ADASYN_+3A_x">X</code></td>
<td>

<p>A data frame or matrix of numeric-attributed dataset
</p>
</td></tr>
<tr><td><code id="ADASYN_+3A_target">target</code></td>
<td>

<p>A vector of a target class attribute corresponding to a dataset X.
</p>
</td></tr>
<tr><td><code id="ADASYN_+3A_k">K</code></td>
<td>

<p>The number of nearest neighbors during sampling process
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>A resulting dataset consists of original minority instances, synthetic minority instances and original majority instances with a vector of their respective target class appended at the last column</p>
</td></tr>
<tr><td><code>syn_data</code></td>
<td>
<p>A set of synthetic minority instances with a vector of minority target class appended at the last column</p>
</td></tr>
<tr><td><code>orig_N</code></td>
<td>
<p>A set of original instances whose class is not oversampled with a vector of their target class appended at the last column</p>
</td></tr>
<tr><td><code>orig_P</code></td>
<td>
<p>A set of original instances whose class is oversampled with a vector of their target class appended at the last column</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>The value of parameter K for nearest neighbor process used for generating data</p>
</td></tr>
<tr><td><code>K_all</code></td>
<td>
<p>Unavailable for this method</p>
</td></tr>
<tr><td><code>dup_size</code></td>
<td>
<p>A vector of times of synthetic minority instances over original majority instances in the oversampling in each instances</p>
</td></tr>
<tr><td><code>outcast</code></td>
<td>
<p>Unavailable for this method</p>
</td></tr>
<tr><td><code>eps</code></td>
<td>
<p>Unavailable for this method</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The name of oversampling method used for this generated dataset (ADASYN)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wacharasak Siriseriwan &lt;wacharasak.s@gmail.com&gt;
</p>


<h3>References</h3>

<p>He, H., Bai, Y., Garcia, E. and Li, S. 2008. ADASYN: Adaptive synthetic sampling approach for imbalanced learning. Proceedings of IJCNN 2008. (IEEE World Congress on Computational Intelligence). IEEE International Joint Conference. pp.1322-1328.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_example = sample_generator(10000,ratio = 0.80)
genData = ADAS(data_example[,-3],data_example[,3])
genData_2 = ADAS(data_example[,-3],data_example[,3],K=7)

</code></pre>

<hr>
<h2 id='ANS'>
Adaptive Neighbor Synthetic Majority Oversampling TEchnique
</h2><span id='topic+ANS'></span>

<h3>Description</h3>

<p>Generate a oversampling dataset from imbalanced dataset using Adaptive Neighbor SMOTE which provides the parameter K to each minority instance automatically
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ANS(X, target, dupSize = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ANS_+3A_x">X</code></td>
<td>

<p>A data frame or matrix of numeric-attributed dataset
</p>
</td></tr>
<tr><td><code id="ANS_+3A_target">target</code></td>
<td>

<p>A vector of a target class attribute corresponding to a dataset X.
</p>
</td></tr>
<tr><td><code id="ANS_+3A_dupsize">dupSize</code></td>
<td>

<p>A number of vector representing the desired times of synthetic minority instances over the original number of majority instances, 0 for balanced dataset.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>A resulting dataset consists of original minority instances, synthetic minority instances and original majority instances with a vector of their respective target class appended at the last column</p>
</td></tr>
<tr><td><code>syn_data</code></td>
<td>
<p>A set of synthetic minority instances with a vector of minority target class appended at the last column</p>
</td></tr>
<tr><td><code>orig_N</code></td>
<td>
<p>A set of original instances whose class is not oversampled with a vector of their target class appended at the last column</p>
</td></tr>
<tr><td><code>orig_P</code></td>
<td>
<p>A set of original instances whose class is oversampled with a vector of their target class appended at the last column</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>A vector of parameter K for each minority instance </p>
</td></tr>
<tr><td><code>K_all</code></td>
<td>
<p>The value of parameter C for nearest neighbor process used for identifying outcasts</p>
</td></tr>
<tr><td><code>dup_size</code></td>
<td>
<p>The maximum times of synthetic minority instances over original majority instances in the oversampling</p>
</td></tr>
<tr><td><code>outcast</code></td>
<td>
<p>A set of original minority instances which is defined as minority outcast</p>
</td></tr>
<tr><td><code>eps</code></td>
<td>
<p>The value of eps which determines automatic K</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The name of oversampling method used for this generated dataset (ANS)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wacharasak Siriseriwan &lt;wacharasak.s@gmail.com&gt;
</p>


<h3>References</h3>

<p>Siriseriwan, W. and Sinapiromsaran, K. Adaptive neighbor Synthetic Minority Oversampling TEchnique under 1NN outcast handling.Songklanakarin Journal of Science and Technology.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data_example = sample_generator(5000,ratio = 0.80)
	genData = ANS(data_example[,-3],data_example[,3])

</code></pre>

<hr>
<h2 id='Borderline-SMOTE'>
Borderline-SMOTE
</h2><span id='topic+BLSMOTE'></span>

<h3>Description</h3>

<p>Generate synthetic positive instances using Borderline-SMOTE algorithm. The number of majority neighbor of each minority instance is used to divide minority instances into 3 groups; SAFE/DANGER/NOISE, only the DANGER are used to generate synthetic instances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BLSMOTE(X,target,K=5,C=5,dupSize=0,method =c("type1","type2"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Borderline-SMOTE_+3A_x">X</code></td>
<td>

<p>A data frame or matrix of numeric-attributed dataset
</p>
</td></tr>
<tr><td><code id="Borderline-SMOTE_+3A_target">target</code></td>
<td>

<p>A vector of a target class attribute corresponding to a dataset X.
</p>
</td></tr>
<tr><td><code id="Borderline-SMOTE_+3A_k">K</code></td>
<td>

<p>The number of nearest neighbors during sampling process
</p>
</td></tr>
<tr><td><code id="Borderline-SMOTE_+3A_c">C</code></td>
<td>

<p>The number of nearest neighbors during calculating safe-level process
</p>
</td></tr>
<tr><td><code id="Borderline-SMOTE_+3A_dupsize">dupSize</code></td>
<td>

<p>The number or vector representing the desired times of synthetic minority instances over the original number of majority instances, 0 for duplicating until balanced
</p>
</td></tr>
<tr><td><code id="Borderline-SMOTE_+3A_method">method</code></td>
<td>

<p>A parameter to indicate which type of Borderline-SMOTE presented in the paper is used
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>A resulting dataset consists of original minority instances, synthetic minority instances and original majority instances with a vector of their respective target class appended at the last column</p>
</td></tr>
<tr><td><code>syn_data</code></td>
<td>
<p>A set of synthetic minority instances with a vector of minority target class appended at the last column</p>
</td></tr>
<tr><td><code>orig_N</code></td>
<td>
<p>A set of original instances whose class is not oversampled with a vector of their target class appended at the last column</p>
</td></tr>
<tr><td><code>orig_P</code></td>
<td>
<p>A set of original instances whose class is oversampled with a vector of their target class appended at the last column</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>The value of parameter K for nearest neighbor process used for generating data</p>
</td></tr>
<tr><td><code>K_all</code></td>
<td>
<p>The value of parameter C for nearest neighbor process used for determining SAFE/DANGER/NOISE</p>
</td></tr>
<tr><td><code>dup_size</code></td>
<td>
<p>The maximum times of synthetic minority instances over original majority instances in the oversampling</p>
</td></tr>
<tr><td><code>outcast</code></td>
<td>
<p>Unavailable for this method</p>
</td></tr>
<tr><td><code>eps</code></td>
<td>
<p>Unavailable for this method</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The name of oversampling method and type used for this generated dataset (BLSMOTE type1/2)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wacharasak Siriseriwan &lt;wacharasak.s@gmail.com&gt;
</p>


<h3>References</h3>

<p>Han, H., Wang, W.Y. and Mao, B.H.  Borderline-SMOTE: a new over-sampling method in imbalanced data sets learning. In Proceedings of the 2005 international conference on Advances in Intelligent Computing - Volume Part I (ICIC'05), De-Shuang Huang, Xiao-Ping Zhang, and Guang-Bin Huang (Eds.), Vol. Part I. Springer-Verlag, Berlin, Heidelberg, 2005. 878-887.  DOI=http://dx.doi.org/10.1007/11538059_91
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data_example = sample_generator(5000,ratio = 0.80)
	genData = BLSMOTE(data_example[,-3],data_example[,3])
	genData_2 = BLSMOTE(data_example[,-3],data_example[,3],K=7, C=5, method = "type2")
</code></pre>

<hr>
<h2 id='DBSMOTE'>
Density-based SMOTE
</h2><span id='topic+DBSMOTE'></span>

<h3>Description</h3>

<p>Generate a oversampling dataset from imbalance dataset using Density-based SMOTE. Using density reachability concept to cluster minority instances and generate synthetic instances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DBSMOTE(X, target, dupSize = 0, MinPts = NULL, eps = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DBSMOTE_+3A_x">X</code></td>
<td>

<p>A data frame or matrix of numeric-attributed dataset
</p>
</td></tr>
<tr><td><code id="DBSMOTE_+3A_target">target</code></td>
<td>

<p>A vector of a target class attribute
</p>
</td></tr>
<tr><td><code id="DBSMOTE_+3A_dupsize">dupSize</code></td>
<td>

<p>A number of vector representing the desired times of synthetic minority instances over the original number of majority instances
</p>
</td></tr>
<tr><td><code id="DBSMOTE_+3A_minpts">MinPts</code></td>
<td>

<p>The minimum instance parameter to decide whether each instance inside eps is reachable, the automatic algorithm is used to find the value instead if there is no positive integer value given for it.
</p>
</td></tr>
<tr><td><code id="DBSMOTE_+3A_eps">eps</code></td>
<td>

<p>The radius to consider neighbor.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>A resulting dataset consists of original minority instances, synthetic minority instances and original majority instances with a vector of their respective target class appended at the last column</p>
</td></tr>
<tr><td><code>syn_data</code></td>
<td>
<p>A set of synthetic minority instances with a vector of minority target class appended at the last column</p>
</td></tr>
<tr><td><code>orig_N</code></td>
<td>
<p>A set of original instances whose class is not oversampled with a vector of their target class appended at the last column</p>
</td></tr>
<tr><td><code>orig_P</code></td>
<td>
<p>A set of original instances whose class is oversampled with a vector of their target class appended at the last column</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Unavailable for this method</p>
</td></tr>
<tr><td><code>K_all</code></td>
<td>
<p>Unavailable for this method</p>
</td></tr>
<tr><td><code>dup_size</code></td>
<td>
<p>The maximum times of synthetic minority instances over original majority instances in the oversampling</p>
</td></tr>
<tr><td><code>outcast</code></td>
<td>
<p>A set of original minority instances which is defined as NOISE/minority outcast</p>
</td></tr>
<tr><td><code>eps</code></td>
<td>
<p>The value of parameter eps</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The name of oversampling method used for this generated dataset</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wacharasak Siriseriwan &lt;wacharasak.s@gmail.com&gt;
</p>


<h3>References</h3>

<p>Bunkhumpornpat, C., Sinapiromsaran, K. and Lursinsap, C. 2012. DBSMOTE: Density-based synthetic minority oversampling technique. Applied Intelligence. 36, 664-684.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_example = sample_generator(5000,ratio = 0.90)
genData = DBSMOTE(data_example[,-3],data_example[,3])
</code></pre>

<hr>
<h2 id='gap'>
The function to provide a random number which is used as a location of synthetic instance
</h2><span id='topic+gap'></span>

<h3>Description</h3>

<p>The function to provide a random number which uses to identify the location of each synthetic instance. The interval of possible values depends from safe-level values of instances in a pair.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gap(sl_p = 1, sl_n = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gap_+3A_sl_p">sl_p</code></td>
<td>

<p>The safe-level value of the first instance
</p>
</td></tr>
<tr><td><code id="gap_+3A_sl_n">sl_n</code></td>
<td>

<p>The safe-level value of the second instance
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value between 0 to 1 which is used to identify the location of synthetic instance
If sl_p &gt;= sl_n, it gives the random number between 0 to sl_n/sl_p
If sl_p &lt; sl_n, it gives the random number between 1-sl_p/sl_n to 1
</p>


<h3>Author(s)</h3>

<p>Wacharasak Siriseriwan &lt;wacharasak.s@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	r_num = gap()
	r_num_2 = gap(sl_p = 4, sl_n = 2)

</code></pre>

<hr>
<h2 id='kncount'>
Counting the number of each class in K nearest neighbor
</h2><span id='topic+kncount'></span>

<h3>Description</h3>

<p>The function to count how many neighbor of each instance belong to each class. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kncount(knidex, classArray)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kncount_+3A_knidex">knidex</code></td>
<td>

<p>The matrix of K nearest neighbor of dataset
</p>
</td></tr>
<tr><td><code id="kncount_+3A_classarray">classArray</code></td>
<td>

<p>The index of last instance of the first class in the dataset or the vector containing indices of last instances of each class.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dataset is expected to be sorted as all m1 instances in the first class are in the first m1 instances of the dataset following with all m2 instances in the next m2 instances etc. before performing k-nearest neighbor with the knearest function. 
</p>


<h3>Value</h3>

<p>The matrix with the number of columns equal to the number of classes. Each a[i][j] represents the number of K-nearest neighbors of i th instance belonging to the class j th
</p>


<h3>Author(s)</h3>

<p>Wacharasak Siriseriwan &lt;wacharasak.s@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	 D = sample_generator(1000,ratio = 0.8)
	 P = D[D[,3]=="p",]
	 N = D[D[,3]=="n",]
	 D_arr=rbind(P,N)
     knear=knearest(D_arr[,-3],P[,-3],5)
	 kncount_result = kncount(knear,nrow(P))
</code></pre>

<hr>
<h2 id='knearest'>
The function to find n_clust nearest neighbors of each instance, always removing the index of that instance if it is reported.
</h2><span id='topic+knearest'></span>

<h3>Description</h3>

<p>The function will find n_clust nearest neighbors of each instance using Fast nearest neighbors (through KD-tree method) but will correct the result if it reports the index of that instance as its neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knearest(D, P, n_clust)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="knearest_+3A_d">D</code></td>
<td>

<p>a query data matrix.
</p>
</td></tr>
<tr><td><code id="knearest_+3A_p">P</code></td>
<td>

<p>an input data matrix
</p>
</td></tr>
<tr><td><code id="knearest_+3A_n_clust">n_clust</code></td>
<td>

<p>the maximum number of nearest neighbors to search
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will perform K-nearest neighbor of instances in P on instances in P based on FNN. Then, it will verify if one of neighbors of each instance is itself then removes if it is.
</p>


<h3>Value</h3>

<p>The index matrix of K nearest neighbour of each instance
</p>


<h3>Author(s)</h3>

<p>Wacharasak Siriseriwan &lt;wacharasak.s@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data_example = sample_generator(10000,ratio = 0.80)
	P = data_example[data_example[,3]=="p",-3]
	N = data_example[data_example[,3]=="n",-3]
	D = rbind(P,N)
	knear = knearest(D,P,n_clust = 5)

</code></pre>

<hr>
<h2 id='n_dup_max'>
The function to calculate the maximum round each sampling is repeated
</h2><span id='topic+n_dup_max'></span>

<h3>Description</h3>

<p>The function to calculate the maximum round each sampling is repeated, if dup_size is given as 0 then, it calculates the maximum round the number of positive instances to be duplicated to nearly match the number of negative instances 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_dup_max(size_input, size_P, size_N, dup_size = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_dup_max_+3A_size_input">size_input</code></td>
<td>

<p>The size of overall dataset
</p>
</td></tr>
<tr><td><code id="n_dup_max_+3A_size_p">size_P</code></td>
<td>

<p>The number of positive instances
</p>
</td></tr>
<tr><td><code id="n_dup_max_+3A_size_n">size_N</code></td>
<td>

<p>The number of negative instances
</p>
</td></tr>
<tr><td><code id="n_dup_max_+3A_dup_size">dup_size</code></td>
<td>

<p>A number or vector of the number of times to be duplicated. The default is zero which means duplicating until nearly balanced.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If dup_size is zero or contains zero, the number of rounds to duplicate positive to nearly equal to the number of negative instances
If dup_size is not zero or contains no zero, the maximum value in dup_size
</p>


<h3>Author(s)</h3>

<p>Wacharasak Siriseriwan &lt;wacharasak.s@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data_example = sample_generator(10000,ratio = 0.80)
	P = data_example[data_example[,3]=="p",-3]
	N = data_example[data_example[,3]=="n",-3]
	D = rbind(P,N)
	max_round =n_dup_max(nrow(D),nrow(P),nrow(N),dup_size= 0)

</code></pre>

<hr>
<h2 id='RSLS'>
Relocating Safe-level SMOTE
</h2><span id='topic+RSLS'></span>

<h3>Description</h3>

<p>Generate synthetic positive instances using Relocating Safe-level SMOTE algorithm. Using the parameter &quot;Safe-Level&quot; to determine the possible location and relocating synthetic instances if there is too close to majority instances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RSLS(X, target, K = 5, C = 5, dupSize = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RSLS_+3A_x">X</code></td>
<td>

<p>A data frame or matrix of numeric-attributed dataset
</p>
</td></tr>
<tr><td><code id="RSLS_+3A_target">target</code></td>
<td>

<p>A vector of a target class attribute corresponding to a dataset X.
</p>
</td></tr>
<tr><td><code id="RSLS_+3A_k">K</code></td>
<td>

<p>The number of nearest neighbors during sampling process
</p>
</td></tr>
<tr><td><code id="RSLS_+3A_c">C</code></td>
<td>

<p>The number of nearest neighbors during calculating safe-level process
</p>
</td></tr>
<tr><td><code id="RSLS_+3A_dupsize">dupSize</code></td>
<td>

<p>The number or vector representing the desired times of synthetic minority instances over the original number of majority instances
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>A resulting dataset consists of original minority instances, synthetic minority instances and original majority instances with a vector of their respective target class appended at the last column</p>
</td></tr>
<tr><td><code>syn_data</code></td>
<td>
<p>A set of synthetic minority instances with a vector of minority target class appended at the last column</p>
</td></tr>
<tr><td><code>orig_N</code></td>
<td>
<p>A set of original instances whose class is not oversampled with a vector of their target class appended at the last column</p>
</td></tr>
<tr><td><code>orig_P</code></td>
<td>
<p>A set of original instances whose class is oversampled with a vector of their target class appended at the last column</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>The value of parameter K for nearest neighbor process used for generating data</p>
</td></tr>
<tr><td><code>K_all</code></td>
<td>
<p>The value of parameter C for nearest neighbor process used for calculating safe-level</p>
</td></tr>
<tr><td><code>dup_size</code></td>
<td>
<p>The maximum times of synthetic minority instances over original majority instances in the oversampling</p>
</td></tr>
<tr><td><code>outcast</code></td>
<td>
<p>A set of original minority instances which has safe-level equal to zero and is defined as the minority outcast</p>
</td></tr>
<tr><td><code>eps</code></td>
<td>
<p>Unavailable for this method</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The name of oversampling method used for this generated dataset (RSLS)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wacharasak Siriseriwan &lt;wacharasak.s@gmail.com&gt;
</p>


<h3>References</h3>

<p>Siriseriwan, W. and Sinapiromsaran, K. The Effective Redistribution for Imbalance Dataset : Relocating Safe-Level SMOTE with Minority Outcast Handling. Chiang Mai Journal of Science. 43(1), 234 - 246.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	library(smotefamily)
	data_example = sample_generator(5000,ratio = 0.80)
    genData = RSLS(data_example[,-3],data_example[,3])
	genData_2 = RSLS(data_example[,-3],data_example[,3],K=7, C=5)


</code></pre>

<hr>
<h2 id='sample_generator'>
The function to generate 2-dimensional dataset
</h2><span id='topic+sample_generator'></span>

<h3>Description</h3>

<p>The function to generate 2-dimensional dataset given the number of instances and the ratio between the number of negative instances to total instances. The positive instances will be distributed uniformly as the circle in the center while negative instances are around over the domain. The random positive outcasts are also generated. The dataset is used to show the difference between datasets generated by each sampling technique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_generator(n, ratio = 0.8, xlim = c(0, 1), ylim = c(0, 1),
   radius = 0.25, overlap = -0.05, outcast_ratio = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_generator_+3A_n">n</code></td>
<td>

<p>The number of instances in the dataset
</p>
</td></tr>
<tr><td><code id="sample_generator_+3A_ratio">ratio</code></td>
<td>

<p>The ratio of negative instances to the total number of instances
</p>
</td></tr>
<tr><td><code id="sample_generator_+3A_xlim">xlim</code></td>
<td>

<p>The range of values in the first dimension
</p>
</td></tr>
<tr><td><code id="sample_generator_+3A_ylim">ylim</code></td>
<td>

<p>The range of values in the second dimension
</p>
</td></tr>
<tr><td><code id="sample_generator_+3A_radius">radius</code></td>
<td>

<p>The radius of the circle of positive instances
</p>
</td></tr>
<tr><td><code id="sample_generator_+3A_overlap">overlap</code></td>
<td>

<p>The gap between the set of positive and negative instances
</p>
</td></tr>
<tr><td><code id="sample_generator_+3A_outcast_ratio">outcast_ratio</code></td>
<td>

<p>The ratio of outcast to be generate in this dataset.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-dimensional dataset with the 3rd column as its target class vector. 
</p>


<h3>Author(s)</h3>

<p>Wacharasak Siriseriwan &lt;wacharasak.s@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data_example = sample_generator(5000,ratio = 0.80)
	plot(data_example[data_example[,3]=="n",1],
	data_example[data_example[,3]=="n",2],col="yellow")
	points(data_example[data_example[,3]=="p",1],
	data_example[data_example[,3]=="p",2],col="red",pch=14)
</code></pre>

<hr>
<h2 id='SLS'>
Safe-level SMOTE
</h2><span id='topic+SLS'></span>

<h3>Description</h3>

<p>Generate synthetic positive instances using Safe-level SMOTE algorithm. Using the parameter &quot;Safe-level&quot; to determine the possible location of synthetic instances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SLS(X, target, K = 5, C = 5, dupSize = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SLS_+3A_x">X</code></td>
<td>

<p>A data frame or matrix of numeric-attributed dataset
</p>
</td></tr>
<tr><td><code id="SLS_+3A_target">target</code></td>
<td>

<p>A vector of a target class attribute corresponding to a dataset X.
</p>
</td></tr>
<tr><td><code id="SLS_+3A_k">K</code></td>
<td>

<p>The number of nearest neighbors during sampling process
</p>
</td></tr>
<tr><td><code id="SLS_+3A_c">C</code></td>
<td>

<p>The number of nearest neighbors during calculating safe-level process
</p>
</td></tr>
<tr><td><code id="SLS_+3A_dupsize">dupSize</code></td>
<td>

<p>The number or vector representing the desired times of synthetic minority instances over the original number of majority instances
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>A resulting dataset consists of original minority instances, synthetic minority instances and original majority instances with a vector of their respective target class appended at the last column</p>
</td></tr>
<tr><td><code>syn_data</code></td>
<td>
<p>A set of synthetic minority instances with a vector of minority target class appended at the last column</p>
</td></tr>
<tr><td><code>orig_N</code></td>
<td>
<p>A set of original instances whose class is not oversampled with a vector of their target class appended at the last column</p>
</td></tr>
<tr><td><code>orig_P</code></td>
<td>
<p>A set of original instances whose class is oversampled with a vector of their target class appended at the last column</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>The value of parameter K for nearest neighbor process used for generating data</p>
</td></tr>
<tr><td><code>K_all</code></td>
<td>
<p>The value of parameter C for nearest neighbor process used for calculating safe-level</p>
</td></tr>
<tr><td><code>dup_size</code></td>
<td>
<p>The maximum times of synthetic minority instances over original majority instances in the oversampling</p>
</td></tr>
<tr><td><code>outcast</code></td>
<td>
<p>A set of original minority instances which has safe-level equal to zero and is defined as the minority outcast</p>
</td></tr>
<tr><td><code>eps</code></td>
<td>
<p>Unavailable for this method</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The name of oversampling method used for this generated dataset (SLS)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wacharasak Siriseriwan &lt;wacharasak.s@gmail.com&gt;
</p>


<h3>References</h3>

<p>Bunkhumpornpat, C., Sinapiromsaran, K. and Lursinsap, C. 2009. Safe-level-SMOTE: Safe-level-synthetic minority oversampling technique for handling the class imbalanced problem. Proceedings of the 13th Pacific-Asia Conference on Advances in Knowledge Discovery and Data Mining. 2009, 475-482.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data_example = sample_generator(5000,ratio = 0.80)
	genData = SLS(data_example[,-3],data_example[,3])
	genData_2 = SLS(data_example[,-3],data_example[,3],K=7, C=5)
</code></pre>

<hr>
<h2 id='SMOTE'>
Synthetic Minority Oversampling TEchnique
</h2><span id='topic+SMOTE'></span>

<h3>Description</h3>

<p>Generate synthetic positive instances using SMOTE algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SMOTE(X, target, K = 5, dup_size = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SMOTE_+3A_x">X</code></td>
<td>

<p>A data frame or matrix of numeric-attributed dataset
</p>
</td></tr>
<tr><td><code id="SMOTE_+3A_target">target</code></td>
<td>

<p>A vector of a target class attribute corresponding to a dataset X.
</p>
</td></tr>
<tr><td><code id="SMOTE_+3A_k">K</code></td>
<td>

<p>The number of nearest neighbors during sampling process
</p>
</td></tr>
<tr><td><code id="SMOTE_+3A_dup_size">dup_size</code></td>
<td>

<p>The number or vector representing the desired times of synthetic minority instances over the original number of majority instances
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>A resulting dataset consists of original minority instances, synthetic minority instances and original majority instances with a vector of their respective target class appended at the last column</p>
</td></tr>
<tr><td><code>syn_data</code></td>
<td>
<p>A set of synthetic minority instances with a vector of minority target class appended at the last column</p>
</td></tr>
<tr><td><code>orig_N</code></td>
<td>
<p>A set of original instances whose class is not oversampled with a vector of their target class appended at the last column</p>
</td></tr>
<tr><td><code>orig_P</code></td>
<td>
<p>A set of original instances whose class is oversampled with a vector of their target class appended at the last column</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>The value of parameter K for nearest neighbor process used for generating data</p>
</td></tr>
<tr><td><code>K_all</code></td>
<td>
<p>Unavailable for this method</p>
</td></tr>
<tr><td><code>dup_size</code></td>
<td>
<p>The maximum times of synthetic minority instances over original majority instances in the oversampling</p>
</td></tr>
<tr><td><code>outcast</code></td>
<td>
<p>Unavailable for this method</p>
</td></tr>
<tr><td><code>eps</code></td>
<td>
<p>Unavailable for this method</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The name of oversampling method used for this generated dataset (SMOTE)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wacharasak Siriseriwan &lt;wacharasak.s@gmail.com&gt;
</p>


<h3>References</h3>

<p>Chawla, N., Bowyer, K., Hall, L. and Kegelmeyer, W. 2002. SMOTE: Synthetic minority oversampling technique. Journal of Artificial Intelligence Research. 16, 321-357.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data_example = sample_generator(10000,ratio = 0.80)
	genData = SMOTE(data_example[,-3],data_example[,3])
	genData_2 = SMOTE(data_example[,-3],data_example[,3],K=7)

</code></pre>

<hr>
<h2 id='SMOTEfamily'>
SMOTE family package for Data Generation
</h2><span id='topic+SMOTEfamily'></span>

<h3>Description</h3>

<p>The collection of SMOTE algorithm and some of its variants for oversampling numeric data 
</p>


<h3>Details</h3>

<p>This package is built to collect several oversampling techniques for Imbalanced data which are parts of my doctorate research. Data to be used with these techniques in this package must be all numeric with one nominal attribute worked as the target class. 
</p>


<h3>Author(s)</h3>

<p>Wacharasak Siriseriwan &lt;wacharasak.s@gmail.com&gt;
</p>


<h3>References</h3>

<p>'Chawla, N., Bowyer, K., Hall, L. and Kegelmeyer, W. 2002. SMOTE: Synthetic minority oversampling technique. Journal of Artificial Intelligence Research. 16, 321-357.'
'Bunkhumpornpat, C., Sinapiromsaran, K. and Lursinsap, C. 2009. Safe-level-SMOTE: Safe-level-synthetic minority oversampling technique for handling the class imbalanced problem. Proceedings of the 13th Pacific-Asia Conference on Advances in Knowledge Discovery and Data Mining. 2009, 475-482.'
'Bunkhumpornpat, C., Sinapiromsaran, K. and Lursinsap, C. 2012. DBSMOTE: Density-based synthetic minority oversampling technique. Applied Intelligence. 36, 664-684.'
'Siriseriwan, W. and Sinapiromsaran, K. The Effective Redistribution for Imbalance Dataset : Relocating Safe-Level SMOTE with Minority Outcast Handling. Chiang Mai Journal of Science. 43(1), 234 - 246.'
'Siriseriwan, W. and Sinapiromsaran, K. Adaptive neighbor Synthetic Minority Oversampling TEchnique under 1NN outcast handling.Songklanakarin Journal of Science and Technology.'
'Han, H., Wang, W.Y. and Mao, B.H.  Borderline-SMOTE: a new over-sampling method in imbalanced data sets learning. In Proceedings of the 2005 international conference on Advances in Intelligent Computing - Volume Part I (ICIC'05), De-Shuang Huang, Xiao-Ping Zhang, and Guang-Bin Huang (Eds.), Vol. Part I. Springer-Verlag, Berlin, Heidelberg, 2005. 878-887.  DOI=http://dx.doi.org/10.1007/11538059_91'
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+SMOTE">SMOTE</a></code>
<code><a href="#topic+SLS">SLS</a></code>
<code><a href="#topic+DBSMOTE">DBSMOTE</a></code>
<code><a href="#topic+RSLS">RSLS</a></code>
<code><a href="#topic+ANS">ANS</a></code>
<code><a href="#topic+BLSMOTE">BLSMOTE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	## Not run: 
    	data_example = sample_generator(10000,ratio = 0.80)
	genData = SMOTE(data_example[,-3],data_example[,3])
	genData_2 = SMOTE(data_example[,-3],data_example[,3],K=7)
	
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
