<!DOCTYPE html><html lang="en"><head><title>Help for package fitlandr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fitlandr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fitlandr-package'><p>fitlandr: Fit Vector Fields and Potential Landscapes from Intensive Longitudinal Data</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#add_interp_grid'><p>Add a grid to a <code>vectorfield</code> object to enable linear interpolation</p></a></li>
<li><a href='#align_pot_B'><p>Align potential values</p></a></li>
<li><a href='#fast_bilinear'><p>A fast bilinear interpolation function</p></a></li>
<li><a href='#find_eqs'><p>Find equilibrium points for a vector field</p></a></li>
<li><a href='#fit_2d_vf'><p>Estimate a 2D vector field</p></a></li>
<li><a href='#fit_3d_vfld'><p>Estimate a 3D potential landscape from a vector field</p></a></li>
<li><a href='#MVKE'><p>Multivariate vector field kernel estimator</p></a></li>
<li><a href='#normalize_predict_f'><p>Return a normalized prediction function</p></a></li>
<li><a href='#path_integral_B'><p>Bhattacharya method for path integration</p></a></li>
<li><a href='#pathB_options'><p>Options controlling the path-integral algorithm</p></a></li>
<li><a href='#plot.vectorfield'><p>Plot a 2D vector field</p></a></li>
<li><a href='#predict.vectorfield'><p>Calculate the vector value at a given position</p></a></li>
<li><a href='#reorder_output'><p>Reorder a simulation output in time order</p></a></li>
<li><a href='#sim_vf'><p>Simulation from vector fields</p></a></li>
<li><a href='#sim_vf_options'><p>Options controlling the vector field simulation</p></a></li>
<li><a href='#simlandr_options'><p>Options controlling the landscape construction</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fit Vector Fields and Potential Landscapes from Intensive
Longitudinal Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolbox for estimating vector fields from intensive
    longitudinal data, and construct potential landscapes thereafter. The
    vector fields can be estimated with two nonparametric methods: the
    Multivariate Vector Field Kernel Estimator (MVKE) by Bandi &amp; Moloche
    (2018) &lt;<a href="https://doi.org/10.1017%2FS0266466617000305">doi:10.1017/S0266466617000305</a>&gt; and the Sparse Vector Field
    Consensus (SparseVFC) algorithm by Ma et al.  (2013)
    &lt;<a href="https://doi.org/10.1016%2Fj.patcog.2013.05.017">doi:10.1016/j.patcog.2013.05.017</a>&gt;. The potential landscapes can be
    constructed with a simulation-based approach with the 'simlandr'
    package (Cui et al., 2021) &lt;<a href="https://doi.org/10.31234%2Fosf.io%2Fpzva3">doi:10.31234/osf.io/pzva3</a>&gt;, or the
    Bhattacharya et al. (2011) method for path integration
    &lt;<a href="https://doi.org/10.1186%2F1752-0509-5-85">doi:10.1186/1752-0509-5-85</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sciurus365.github.io/fitlandr/">https://sciurus365.github.io/fitlandr/</a>,
<a href="https://github.com/Sciurus365/fitlandr">https://github.com/Sciurus365/fitlandr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Sciurus365/fitlandr/issues">https://github.com/Sciurus365/fitlandr/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dplyr, furrr, future.apply, ggplot2, glue, grDevices,
grid, magrittr, MASS, numDeriv, plotly, R.utils, Rfast, rlang,
rootSolve, simlandr (&ge; 0.3.0), SparseVFC, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>akima, colorRamps, future</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-09 10:01:08 UTC; jingm</td>
</tr>
<tr>
<td>Author:</td>
<td>Jingmeng Cui <a href="https://orcid.org/0000-0003-3421-8457"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jingmeng Cui &lt;jingmeng.cui@outlook.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-10 10:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fitlandr-package'>fitlandr: Fit Vector Fields and Potential Landscapes from Intensive Longitudinal Data</h2><span id='topic+fitlandr'></span><span id='topic+fitlandr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A toolbox for estimating vector fields from intensive longitudinal data, and construct potential landscapes thereafter. The vector fields can be estimated with two nonparametric methods: the Multivariate Vector Field Kernel Estimator (MVKE) by Bandi &amp; Moloche (2018) <a href="https://doi.org/10.1017/S0266466617000305">doi:10.1017/S0266466617000305</a> and the Sparse Vector Field Consensus (SparseVFC) algorithm by Ma et al. (2013) <a href="https://doi.org/10.1016/j.patcog.2013.05.017">doi:10.1016/j.patcog.2013.05.017</a>. The potential landscapes can be constructed with a simulation-based approach with the 'simlandr' package (Cui et al., 2021) <a href="https://doi.org/10.31234/osf.io/pzva3">doi:10.31234/osf.io/pzva3</a>, or the Bhattacharya et al. (2011) method for path integration <a href="https://doi.org/10.1186/1752-0509-5-85">doi:10.1186/1752-0509-5-85</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jingmeng Cui <a href="mailto:jingmeng.cui@outlook.com">jingmeng.cui@outlook.com</a> (<a href="https://orcid.org/0000-0003-3421-8457">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://sciurus365.github.io/fitlandr/">https://sciurus365.github.io/fitlandr/</a>
</p>
</li>
<li> <p><a href="https://github.com/Sciurus365/fitlandr">https://github.com/Sciurus365/fitlandr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Sciurus365/fitlandr/issues">https://github.com/Sciurus365/fitlandr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='add_interp_grid'>Add a grid to a <code>vectorfield</code> object to enable linear interpolation</h2><span id='topic+add_interp_grid'></span>

<h3>Description</h3>

<p>Add a grid to a <code>vectorfield</code> object to enable linear interpolation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_interp_grid(vf, lims = vf$lims, n = vf$n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_interp_grid_+3A_vf">vf</code></td>
<td>
<p>A <code>vectorfield</code> object estimated by <code><a href="#topic+fit_2d_vf">fit_2d_vf()</a></code>.</p>
</td></tr>
<tr><td><code id="add_interp_grid_+3A_lims">lims</code></td>
<td>
<p>The limits of the range for the vector field estimation as <code style="white-space: pre;">&#8288;c(&lt;xl&gt;, &lt;xu&gt;, &lt;yl&gt;, &lt;yu&gt;)&#8288;</code>. If missing, the range of the data extended by 10% for both sides will be used.</p>
</td></tr>
<tr><td><code id="add_interp_grid_+3A_n">n</code></td>
<td>
<p>The number of equally spaced points in each axis, at which the vectors are to be estimated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vectorfield</code> project with an <code>interp_grid</code> field.
</p>

<hr>
<h2 id='align_pot_B'>Align potential values</h2><span id='topic+align_pot_B'></span>

<h3>Description</h3>

<p>So that all path-potentials end up at same global min and then generate potential surface with interpolation on a grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align_pot_B(resultB, n = 200, digits = 2, linear = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="align_pot_B_+3A_resultb">resultB</code></td>
<td>
<p>Result from <code><a href="#topic+path_integral_B">path_integral_B()</a></code>.</p>
</td></tr>
<tr><td><code id="align_pot_B_+3A_n">n</code></td>
<td>
<p>The number of equally spaced points in each axis, at which the landscape is to be estimated.</p>
</td></tr>
<tr><td><code id="align_pot_B_+3A_digits">digits</code></td>
<td>
<p>Currently, the raw sample points in some regions are too dense that may crashes interpolation. To avoid this problem, only one point of all with the  same first several digits. is kept. Use this parameter to indicate how many digits are considered. Note that this is a temporary solution and might be changed in the near future.</p>
</td></tr>
<tr><td><code id="align_pot_B_+3A_linear">linear</code></td>
<td>
<p>logical – indicating whether linear or spline interpolation should be used.</p>
</td></tr>
<tr><td><code id="align_pot_B_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code><a href="akima.html#topic+interp">akima::interp()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with 3 components:
</p>
<table role = "presentation">
<tr><td><code>x</code>, <code>y</code></td>
<td>

<p>vectors of x- and y- coordinates of output grid, the same as the input
argument <code>xo</code>, or <code>yo</code>, if present.  Otherwise, their
default, a vector 40 points evenly spaced over the range of the
input <code>x</code>.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>

<p>matrix of fitted z-values.  The value <code>z[i,j]</code> is computed
at the x,y point <code>xo[i], yo[j]</code>. <code>z</code> has
dimensions <code>length(xo)</code> times <code>length(yo)</code>.</p>
</td></tr>
</table>
<p>If input is a <code>SpatialPointsDataFrame</code> a
<code>SpatialPixelssDataFrame</code> is returned.
</p>

<hr>
<h2 id='fast_bilinear'>A fast bilinear interpolation function</h2><span id='topic+fast_bilinear'></span>

<h3>Description</h3>

<p>It assumes equal grid intervals, thus can find the correct position in <code class="reqn">O(1)</code> time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_bilinear(x, y, z, x0, y0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast_bilinear_+3A_x">x</code></td>
<td>

<p>a vector containing the <code>x</code> coordinates of the rectangular data grid.
</p>
</td></tr>
<tr><td><code id="fast_bilinear_+3A_y">y</code></td>
<td>

<p>a vector containing the <code>y</code> coordinates of the rectangular data grid.
</p>
</td></tr>
<tr><td><code id="fast_bilinear_+3A_z">z</code></td>
<td>

<p>a matrix containing the <code>z[i,j]</code> data values for the grid points (<code>x[i]</code>,<code>y[j]</code>).
</p>
</td></tr>
<tr><td><code id="fast_bilinear_+3A_x0">x0</code></td>
<td>
<p><code>x</code> value used to interpolate at.</p>
</td></tr>
<tr><td><code id="fast_bilinear_+3A_y0">y0</code></td>
<td>
<p><code>y</code> value used to interpolate at.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following is from the documentation of <code><a href="akima.html#topic+bilinear">akima::bilinear()</a></code>.
</p>
<p>This is an implementation of a bilinear interpolating function.
For a point (x0,y0) contained in a rectangle (x1,y1),(x2,y1), (x2,y2),(x1,y2) and x1&lt;x2, y1&lt;y2, the first step is to get z() at locations (x0,y1) and (x0,y2) as convex linear combinations z(x0,y*)=a<em>z(x1,y</em>)+(1-a)<em>z(x2,y</em>) where a=(x2-x1)/(x0-x1) for y*=y1,y2. In a second step z(x0,y0) is calculated as convex linear combination between z(x0,y1) and z(x0,y2) as z(x0,y1)=b*z(x0,y1)+(1-b)*z(x0,y2) where b=(y2-y1)/(y0-y1).
</p>
<p>Finally, z(x0,y0) is a convex linear combination of the z values at the corners of the containing rectangle with weights according to the distance from (x0,y0) to these corners.
</p>


<h3>Value</h3>

<p>A list which contains only one element, <code>z</code>.
</p>

<hr>
<h2 id='find_eqs'>Find equilibrium points for a vector field</h2><span id='topic+find_eqs'></span>

<h3>Description</h3>

<p>Find equilibrium points for a vector field
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_eqs(vf, starts, jacobian_params = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_eqs_+3A_vf">vf</code></td>
<td>
<p>A <code>vectorfield</code> object estimated by <code><a href="#topic+fit_2d_vf">fit_2d_vf()</a></code>.</p>
</td></tr>
<tr><td><code id="find_eqs_+3A_starts">starts</code></td>
<td>
<p>A vector indicating the starting value for solving the equilibrium point, or a list of vectors providing multiple starting values together.</p>
</td></tr>
<tr><td><code id="find_eqs_+3A_jacobian_params">jacobian_params</code></td>
<td>
<p>Parameters passed to <code><a href="numDeriv.html#topic+jacobian">numDeriv::jacobian()</a></code>.</p>
</td></tr>
<tr><td><code id="find_eqs_+3A_...">...</code></td>
<td>
<p>Parameters passed to <code><a href="rootSolve.html#topic+multiroot">rootSolve::multiroot()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of equilibrium points and their details. Use <code>print.vectorfield_eqs()</code> to inspect it.
</p>

<hr>
<h2 id='fit_2d_vf'>Estimate a 2D vector field</h2><span id='topic+fit_2d_vf'></span>

<h3>Description</h3>

<p>Estimate a 2D vector field from intensive longitudinal data. Two methods can be used: Multivariate Vector Field Kernel Estimator (MVKE, using <code><a href="#topic+MVKE">MVKE()</a></code>), or Sparse Vector Field Consensus (SparseVFC, using <code><a href="SparseVFC.html#topic+SparseVFC">SparseVFC::SparseVFC()</a></code>). Note that the input data are automatically normalized before being sent to the estimation engines to make sure the default parameter settings are close to the optimal. Therefore, you do not need to scale up or down the parameters of <code><a href="#topic+MVKE">MVKE()</a></code> or <code><a href="SparseVFC.html#topic+SparseVFC">SparseVFC::SparseVFC()</a></code>. We suggest the MVKE method to be used for psychological data because it has more realistic assumptions and produces more reasonable output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_2d_vf(
  data,
  x,
  y,
  lims,
  n = 20,
  vector_position = "start",
  na_action = "omit_data_points",
  method = c("MVKE", "MVKE"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_2d_vf_+3A_data">data</code></td>
<td>
<p>The data set used for estimating the vector field.
Should be a data frame or a matrix.</p>
</td></tr>
<tr><td><code id="fit_2d_vf_+3A_x">x</code>, <code id="fit_2d_vf_+3A_y">y</code></td>
<td>
<p>Characters to indicate the name of the two variables.</p>
</td></tr>
<tr><td><code id="fit_2d_vf_+3A_lims">lims</code></td>
<td>
<p>The limits of the range for the vector field estimation as <code style="white-space: pre;">&#8288;c(&lt;xl&gt;, &lt;xu&gt;, &lt;yl&gt;, &lt;yu&gt;)&#8288;</code>. If missing, the range of the data extended by 10% for both sides will be used.</p>
</td></tr>
<tr><td><code id="fit_2d_vf_+3A_n">n</code></td>
<td>
<p>The number of equally spaced points in each axis, at which the vectors are to be estimated.</p>
</td></tr>
<tr><td><code id="fit_2d_vf_+3A_vector_position">vector_position</code></td>
<td>
<p>Only useful if <code>method == "VFC"</code>. One of &quot;start&quot;, &quot;middle&quot;, or &quot;end&quot;, representing the position of the vectors. If &quot;start&quot;, for example, the starting point of a vector is regarded as the position of the vector.</p>
</td></tr>
<tr><td><code id="fit_2d_vf_+3A_na_action">na_action</code></td>
<td>
<p>One of &quot;omit_data_points&quot; or &quot;omit_vectors&quot;. If using &quot;omit_data_points&quot;, then only the <code>NA</code> points are omitted, and the points before and after an <code>NA</code> will form a vector. If using &quot;omit_vectors&quot;, then the vectors will be omitted if either of its points is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="fit_2d_vf_+3A_method">method</code></td>
<td>
<p>One of &quot;MVKE&quot; or &quot;VFC&quot;.</p>
</td></tr>
<tr><td><code id="fit_2d_vf_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed to <code><a href="#topic+MVKE">MVKE()</a></code> or <code><a href="SparseVFC.html#topic+SparseVFC">SparseVFC::SparseVFC()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vectorfield</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.vectorfield">plot.vectorfield()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate data
single_output_grad &lt;- simlandr::sim_fun_grad(length = 200, seed = 1614)
# fit the vector field
v2 &lt;- fit_2d_vf(single_output_grad, x = "x", y = "y", method = "MVKE")
plot(v2)
</code></pre>

<hr>
<h2 id='fit_3d_vfld'>Estimate a 3D potential landscape from a vector field</h2><span id='topic+fit_3d_vfld'></span>

<h3>Description</h3>

<p>Two methods are available: <code>method = "pathB"</code> and <code>method = "simlandr"</code>. See <em>Details</em> section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_3d_vfld(
  vf,
  method = c("simlandr", "pathB"),
  .pathB_options = pathB_options(vf),
  .sim_vf_options = sim_vf_options(vf),
  .simlandr_options = simlandr_options(vf),
  linear_interp = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_3d_vfld_+3A_vf">vf</code></td>
<td>
<p>A <code>vectorfield</code> object estimated by <code><a href="#topic+fit_2d_vf">fit_2d_vf()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_3d_vfld_+3A_method">method</code></td>
<td>
<p>The method used for landscape construction. Can be <code>pathB</code> or <code>simlandr</code>.</p>
</td></tr>
<tr><td><code id="fit_3d_vfld_+3A_.pathb_options">.pathB_options</code></td>
<td>
<p>Only for <code>method = "pathB"</code>. Options controlling the path-integral algorithm. Should be generated by <code><a href="#topic+sim_vf_options">sim_vf_options()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_3d_vfld_+3A_.sim_vf_options">.sim_vf_options</code></td>
<td>
<p>Only for <code>method = "simlandr"</code>. Options controlling the vector field simulation. Should be generated by <code><a href="#topic+sim_vf_options">sim_vf_options()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_3d_vfld_+3A_.simlandr_options">.simlandr_options</code></td>
<td>
<p>Only for <code>method = "simlandr"</code>. Options controlling the landscape construction. Should be generated by <code><a href="#topic+simlandr_options">simlandr_options()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_3d_vfld_+3A_linear_interp">linear_interp</code></td>
<td>
<p>Use linear interpolation method to estimate the drift vector (and the diffusion matrix). This can speed up the calculation. If <code>TRUE</code>, be sure that a linear grid was calculated for the vector field using <code style="white-space: pre;">&#8288;&lt;vf&gt; &lt;- add_interp_grid(&lt;vf&gt;)&#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>method = "simlandr"</code>, the landscape is constructed based on the generalized potential landscape by Wang et al. (2008), implemented by the <code>simlandr</code> package. This function is a wrapper of <code><a href="#topic+sim_vf">sim_vf()</a></code> and <code><a href="simlandr.html#topic+make_3d_static">simlandr::make_3d_static()</a></code>. Use those two functions separately for more customization.
</p>
<p>For <code>method = "pathB"</code>, the landscape is constructed based on the deterministic path-integral quasi-potential defined by Bhattacharya et al. (2011).
</p>
<p>We recommend the <code>simlandr</code> method for psychological data because it is more stable.
</p>
<p>Parallel computing based on <code>future</code> is supported for both methods. Use <code>future::plan("multisession")</code> to enable this and speed up computation.
</p>


<h3>Value</h3>

<p>A <code>landscape</code> object as described in <code><a href="simlandr.html#topic+make_3d_static">simlandr::make_3d_static()</a></code>, or a <code style="white-space: pre;">&#8288;3d_static_landscape_B&#8288;</code> object, which inherits from the <code>landscape</code> class and contains the following elements: <code>dist</code>, the distribution estimation for landscapes; <code>plot</code>, a 3D plot using <code>plotly</code>; plot_2, a 2D plot using <code>ggplot2</code>; x, y, from <code>vf</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate data
single_output_grad &lt;- simlandr::sim_fun_grad(length = 200, seed = 1614)
# fit the vector field
v2 &lt;- fit_2d_vf(single_output_grad, x = "x", y = "y", method = "MVKE")
plot(v2)
# fit the landscape
future::plan("multisession")
set.seed(1614)
l2 &lt;- fit_3d_vfld(v2,
.sim_vf_options = sim_vf_options(chains = 16, stepsize = 1, forbid_overflow = TRUE),
.simlandr_options = simlandr_options(adjust = 5, Umax = 4))
plot(l2, 2)
future::plan("sequential")

</code></pre>

<hr>
<h2 id='MVKE'>Multivariate vector field kernel estimator</h2><span id='topic+MVKE'></span>

<h3>Description</h3>

<p>See references for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MVKE(d, h = 0.2, kernel = c("exp", "Gaussian"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MVKE_+3A_d">d</code></td>
<td>
<p>The dataset. Should be a matrix or a data frame, with each row representing a random vector.</p>
</td></tr>
<tr><td><code id="MVKE_+3A_h">h</code></td>
<td>
<p>The bandwidth for the kernel estimator.</p>
</td></tr>
<tr><td><code id="MVKE_+3A_kernel">kernel</code></td>
<td>
<p>The type of kernel estimator used. &quot;exp&quot; by default (<code><a href="base.html#topic+exp">exp()</a></code>), and if &quot;Gaussian&quot; then <code><a href="stats.html#topic+Normal">stats::dnorm()</a></code> will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function(x), which then returns the <code class="reqn">\mu</code> and <code class="reqn">a</code> estimators at the position <code class="reqn">x</code>.
</p>


<h3>References</h3>

<p>Bandi, F. M., &amp; Moloche, G. (2018). On the functional estimation of multivariate diffusion processes. Econometric Theory, 34(4), 896-946. https://doi.org/10.1017/S0266466617000305
</p>

<hr>
<h2 id='normalize_predict_f'>Return a normalized prediction function</h2><span id='topic+normalize_predict_f'></span>

<h3>Description</h3>

<p>Return a normalized prediction function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_predict_f(vf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_predict_f_+3A_vf">vf</code></td>
<td>
<p>A <code>vectorfield</code> object estimated by <code><a href="#topic+fit_2d_vf">fit_2d_vf()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that takes a vector <code>x</code> and returns a list of <code>v</code>, the drift part, and <code>a</code>, the diffusion part.
</p>

<hr>
<h2 id='path_integral_B'>Bhattacharya method for path integration</h2><span id='topic+path_integral_B'></span>

<h3>Description</h3>

<p>A method to construct potential landscapes using path integration. See references for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_integral_B(
  f,
  lims,
  n_path_int = 20,
  stepsize = 0.01,
  tol = 0.01,
  numTimeSteps = 1400,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="path_integral_B_+3A_f">f</code></td>
<td>
<p>The vector field function. It should return <code style="white-space: pre;">&#8288;c(&lt;dx/dt&gt;, &lt;dy/dt&gt;)&#8288;</code></p>
</td></tr>
<tr><td><code id="path_integral_B_+3A_lims">lims</code></td>
<td>
<p>The limits of the range for the estimation as <code style="white-space: pre;">&#8288;c(&lt;xl&gt;, &lt;xu&gt;, &lt;yl&gt;, &lt;yu&gt;)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="path_integral_B_+3A_n_path_int">n_path_int</code></td>
<td>
<p>The number of equally spaced points in each axis, at which the path integrals is to be calculated.</p>
</td></tr>
<tr><td><code id="path_integral_B_+3A_stepsize">stepsize</code></td>
<td>
<p>The time step used in each iteration.</p>
</td></tr>
<tr><td><code id="path_integral_B_+3A_tol">tol</code></td>
<td>
<p>The tolerance to test convergence.</p>
</td></tr>
<tr><td><code id="path_integral_B_+3A_numtimesteps">numTimeSteps</code></td>
<td>
<p>Number of time steps for integrating along each path (to ensure uniform arrays). Choose high-enough number for convergence with given stepsize.</p>
</td></tr>
<tr><td><code id="path_integral_B_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>numPaths</code> Integer. Total Number of paths for defined grid spacing.
</p>
</li>
<li> <p><code>pot_path</code> Matrix. Potential along the paths.
</p>
</li>
<li> <p><code>path_tag</code> Vector. Tag for given paths.
</p>
</li>
<li> <p><code>attractors_pot</code> Vector. Potential value of each identified attractor by the path integral approach.
</p>
</li>
<li> <p><code>x_path</code> Vector. x-coord. along path.
</p>
</li>
<li> <p><code>y_path</code> Vector. y-coord. along path.
</p>
</li></ul>



<h3>References</h3>

<p>Bhattacharya, S., Zhang, Q., &amp; Andersen, M. E. (2011). A deterministic map of Waddington’s epigenetic landscape for cell fate specification. BMC Systems Biology, 5(1), 85. https://doi.org/10.1186/1752-0509-5-85.
The functions in this file were translated from the Matlab code provided with the reference above, and its Python translation at https://dynamo-release.readthedocs.io/en/v0.95.2/_modules/dynamo/vectorfield/Bhattacharya.html
</p>

<hr>
<h2 id='pathB_options'>Options controlling the path-integral algorithm</h2><span id='topic+pathB_options'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+path_integral_B">path_integral_B()</a></code>, <code><a href="#topic+align_pot_B">align_pot_B()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pathB_options(
  vf,
  lims = rlang::expr(vf$lims),
  n_path_int = 20,
  stepsize = 0.01,
  tol = 0.01,
  numTimeSteps = 1400,
  n = 200,
  digits = 2,
  linear = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pathB_options_+3A_vf">vf</code></td>
<td>
<p>A <code>vectorfield</code> object estimated by <code><a href="#topic+fit_2d_vf">fit_2d_vf()</a></code>.</p>
</td></tr>
<tr><td><code id="pathB_options_+3A_lims">lims</code></td>
<td>
<p>The limits of the range for the estimation as <code style="white-space: pre;">&#8288;c(&lt;xl&gt;, &lt;xu&gt;, &lt;yl&gt;, &lt;yu&gt;)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="pathB_options_+3A_n_path_int">n_path_int</code></td>
<td>
<p>The number of equally spaced points in each axis, at which the path integrals is to be calculated.</p>
</td></tr>
<tr><td><code id="pathB_options_+3A_stepsize">stepsize</code></td>
<td>
<p>The stepsize for Euler–Maruyama simulation of the system.</p>
</td></tr>
<tr><td><code id="pathB_options_+3A_tol">tol</code></td>
<td>
<p>The tolerance to test convergence.</p>
</td></tr>
<tr><td><code id="pathB_options_+3A_numtimesteps">numTimeSteps</code></td>
<td>
<p>Number of time steps for integrating along each path (to ensure uniform arrays). Choose high-enough number for convergence with given stepsize.</p>
</td></tr>
<tr><td><code id="pathB_options_+3A_n">n</code></td>
<td>
<p>The number of equally spaced points in each axis, at which the landscape is to be estimated.</p>
</td></tr>
<tr><td><code id="pathB_options_+3A_digits">digits</code></td>
<td>
<p>Currently, the raw sample points in some regions are too dense that may crashes interpolation. To avoid this problem, only one point of all with the  same first several digits. is kept. Use this parameter to indicate how many digits are considered. Note that this is a temporary solution and might be changed in the near future.</p>
</td></tr>
<tr><td><code id="pathB_options_+3A_linear">linear</code></td>
<td>
<p>logical – indicating whether linear or spline interpolation should be used.</p>
</td></tr>
<tr><td><code id="pathB_options_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the parameters of the corresponding function. Only intended to be used within <code><a href="#topic+fit_3d_vfld">fit_3d_vfld()</a></code>
</p>

<hr>
<h2 id='plot.vectorfield'>Plot a 2D vector field</h2><span id='topic+plot.vectorfield'></span>

<h3>Description</h3>

<p>Plot a 2D vector field estimated by <code><a href="#topic+fit_2d_vf">fit_2d_vf()</a></code>. Powered by <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vectorfield'
plot(
  x,
  arrow = grid::arrow(length = grid::unit(0.1, "cm")),
  show_estimated_vector = TRUE,
  estimated_vector_enlarge = 1,
  estimated_vector_options = list(),
  show_point = TRUE,
  point_options = list(size = 0.5),
  show_original_vector = FALSE,
  original_vector_enlarge = 1,
  original_vector_options = list(),
  show_used_vector = FALSE,
  used_vector_options = list(color = "red"),
  show_v_norm = FALSE,
  v_norm_options = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.vectorfield_+3A_x">x</code></td>
<td>
<p>A <code>vectorfield</code> object estimated by <code><a href="#topic+fit_2d_vf">fit_2d_vf()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.vectorfield_+3A_arrow">arrow</code></td>
<td>
<p>The description of the arrow heads of the vectors on the plot (representing the vector field). Generated by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>. Also see the <code>arrow</code> parameter of <code><a href="ggplot2.html#topic+geom_segment">ggplot2::geom_segment()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.vectorfield_+3A_show_estimated_vector">show_estimated_vector</code></td>
<td>
<p>Show the vectors from the estimated model? <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="plot.vectorfield_+3A_estimated_vector_enlarge">estimated_vector_enlarge</code></td>
<td>
<p>A number. How many times should the vectors (representing the estimated vector field) be enlarged on the plot? This can be useful when the estimated vector field is too strong or too weak.</p>
</td></tr>
<tr><td><code id="plot.vectorfield_+3A_estimated_vector_options">estimated_vector_options</code></td>
<td>
<p>A list passing other customized parameters to <code><a href="ggplot2.html#topic+geom_segment">ggplot2::geom_segment()</a></code> to control the vectors representing the estimated vector field.</p>
</td></tr>
<tr><td><code id="plot.vectorfield_+3A_show_point">show_point</code></td>
<td>
<p>Show the original data points? <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="plot.vectorfield_+3A_point_options">point_options</code></td>
<td>
<p>A list passing other customized parameters to <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code> to control the points representing the original data point.</p>
</td></tr>
<tr><td><code id="plot.vectorfield_+3A_show_original_vector">show_original_vector</code></td>
<td>
<p>Show the original vectors (i.e., the vectors between data points)? <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="plot.vectorfield_+3A_original_vector_enlarge">original_vector_enlarge</code></td>
<td>
<p>A number. How many times should the original vectors be enlarged on the plot?</p>
</td></tr>
<tr><td><code id="plot.vectorfield_+3A_original_vector_options">original_vector_options</code></td>
<td>
<p>A list passing other customized parameters to <code><a href="ggplot2.html#topic+geom_segment">ggplot2::geom_segment()</a></code> to control the vectors representing the original data.</p>
</td></tr>
<tr><td><code id="plot.vectorfield_+3A_show_used_vector">show_used_vector</code></td>
<td>
<p>Only for vector fields estimated by the &quot;VFC&quot; method. Should the vectors from the original data that are considered inliers be specially marked? <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="plot.vectorfield_+3A_used_vector_options">used_vector_options</code></td>
<td>
<p>Only for vector fields estimated by the &quot;VFC&quot; method. A list passing other customized parameters to <code><a href="ggplot2.html#topic+geom_segment">ggplot2::geom_segment()</a></code> to control the vectors representing the inliers. Red by default.</p>
</td></tr>
<tr><td><code id="plot.vectorfield_+3A_show_v_norm">show_v_norm</code></td>
<td>
<p>Show the norm of the estimated vectors (the strength of the vector field)? <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="plot.vectorfield_+3A_v_norm_options">v_norm_options</code></td>
<td>
<p>A list passing other customized parameters to <code><a href="ggplot2.html#topic+geom_tile">ggplot2::geom_raster()</a></code> to control the layer representing the norm of the estimated vectors.</p>
</td></tr>
<tr><td><code id="plot.vectorfield_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot.
</p>

<hr>
<h2 id='predict.vectorfield'>Calculate the vector value at a given position</h2><span id='topic+predict.vectorfield'></span>

<h3>Description</h3>

<p>Calculate the vector value at a given position
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vectorfield'
predict(object, pos, linear_interp = FALSE, calculate_a = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.vectorfield_+3A_object">object</code></td>
<td>
<p>A <code>vectorfield</code> project generated by <code><a href="#topic+fit_2d_vf">fit_2d_vf()</a></code>.</p>
</td></tr>
<tr><td><code id="predict.vectorfield_+3A_pos">pos</code></td>
<td>
<p>A vector, the position of the vector.</p>
</td></tr>
<tr><td><code id="predict.vectorfield_+3A_linear_interp">linear_interp</code></td>
<td>
<p>Use linear interpolation method to estimate the drift vector (and the diffusion matrix). This can speed up the calculation. If <code>TRUE</code>, be sure that a linear grid was calculated for the vector field using <code style="white-space: pre;">&#8288;&lt;vf&gt; &lt;- add_interp_grid(&lt;vf&gt;)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="predict.vectorfield_+3A_calculate_a">calculate_a</code></td>
<td>
<p>Effective when <code>linear_interp == TRUE</code>. Do you want to calculate the diffusion matrix? Use <code>FALSE</code> can save some time.</p>
</td></tr>
<tr><td><code id="predict.vectorfield_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>v</code>, the drift part that is used for vector fields, and <code>a</code> (when <code>calculate_a == TRUE</code>), the diffusion part at a given position.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_interp_grid">add_interp_grid()</a></code>
</p>

<hr>
<h2 id='reorder_output'>Reorder a simulation output in time order</h2><span id='topic+reorder_output'></span>

<h3>Description</h3>

<p>Then <code><a href="simlandr.html#topic+check_conv">simlandr::check_conv()</a></code> can be used meaningfully.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reorder_output(s, chains)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reorder_output_+3A_s">s</code></td>
<td>
<p>A simulation output, possibly generated by <code><a href="#topic+sim_vf">sim_vf()</a></code></p>
</td></tr>
<tr><td><code id="reorder_output_+3A_chains">chains</code></td>
<td>
<p>How many chains simulations should be performed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A reordered matrix of the simulation output.
</p>

<hr>
<h2 id='sim_vf'>Simulation from vector fields</h2><span id='topic+sim_vf'></span>

<h3>Description</h3>

<p>Parallel computing based on <code>future</code> is supported. Use <code>future::plan("multisession")</code> to enable this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_vf(
  vf,
  noise = 1,
  noise_warmup = noise,
  chains = 10,
  length = 10000,
  discard = 0.3,
  stepsize = 0.01,
  sparse = 1,
  forbid_overflow = FALSE,
  linear_interp = FALSE,
  inits = matrix(c(stats::runif(chains, min = vf$lims[1], max = vf$lims[2]),
    stats::runif(chains, min = vf$lims[3], max = vf$lims[4])), ncol = 2)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_vf_+3A_vf">vf</code></td>
<td>
<p>A <code>vectorfield</code> object estimated by <code><a href="#topic+fit_2d_vf">fit_2d_vf()</a></code>.</p>
</td></tr>
<tr><td><code id="sim_vf_+3A_noise">noise</code></td>
<td>
<p>Relative noise of the simulation. Set this smaller when the simulation is unstable (e.g., when the elements in the diffusion matrix are not finite), and set this larger when the simulation converges too slowly.</p>
</td></tr>
<tr><td><code id="sim_vf_+3A_noise_warmup">noise_warmup</code></td>
<td>
<p>The noise used for the warming-up period.</p>
</td></tr>
<tr><td><code id="sim_vf_+3A_chains">chains</code></td>
<td>
<p>How many chains simulations should be performed?</p>
</td></tr>
<tr><td><code id="sim_vf_+3A_length">length</code></td>
<td>
<p>The simulation length for each chain.</p>
</td></tr>
<tr><td><code id="sim_vf_+3A_discard">discard</code></td>
<td>
<p>How much of the starting part of each chain should be discarded? (Warming-up period.)</p>
</td></tr>
<tr><td><code id="sim_vf_+3A_stepsize">stepsize</code></td>
<td>
<p>The stepsize for Euler–Maruyama simulation of the system.</p>
</td></tr>
<tr><td><code id="sim_vf_+3A_sparse">sparse</code></td>
<td>
<p>A number. How much do you want to sparse the output? When the noise is small, sparse the output may make the density estimation more efficient.</p>
</td></tr>
<tr><td><code id="sim_vf_+3A_forbid_overflow">forbid_overflow</code></td>
<td>
<p>If <code>TRUE</code>, when the simulated system runs out of the margins specified in <code>vf</code>, the system will be moved back to the previous value. This can help to stabilize the simulation. <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="sim_vf_+3A_linear_interp">linear_interp</code></td>
<td>
<p>Use linear interpolation method to estimate the drift vector (and the diffusion matrix). This can speed up the calculation. If <code>TRUE</code>, be sure that a linear grid was calculated for the vector field using <code style="white-space: pre;">&#8288;&lt;vf&gt; &lt;- add_interp_grid(&lt;vf&gt;)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="sim_vf_+3A_inits">inits</code></td>
<td>
<p>The initial values of each chain.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the simulated data.
</p>

<hr>
<h2 id='sim_vf_options'>Options controlling the vector field simulation</h2><span id='topic+sim_vf_options'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+sim_vf">sim_vf()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_vf_options(
  vf,
  noise = 1,
  noise_warmup = noise,
  chains = 10,
  length = 10000,
  discard = 0.3,
  stepsize = 0.01,
  sparse = 1,
  forbid_overflow = FALSE,
  inits = rlang::expr(matrix(c(stats::runif(chains, min = vf$lims[1], max = vf$lims[2]),
    stats::runif(chains, min = vf$lims[3], max = vf$lims[4])), ncol = 2))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_vf_options_+3A_vf">vf</code></td>
<td>
<p>A <code>vectorfield</code> object estimated by <code><a href="#topic+fit_2d_vf">fit_2d_vf()</a></code>.</p>
</td></tr>
<tr><td><code id="sim_vf_options_+3A_noise">noise</code></td>
<td>
<p>Relative noise of the simulation. Set this smaller when the simulation is unstable (e.g., when the elements in the diffusion matrix are not finite), and set this larger when the simulation converges too slowly.</p>
</td></tr>
<tr><td><code id="sim_vf_options_+3A_noise_warmup">noise_warmup</code></td>
<td>
<p>The noise used for the warming-up period.</p>
</td></tr>
<tr><td><code id="sim_vf_options_+3A_chains">chains</code></td>
<td>
<p>How many chains simulations should be performed?</p>
</td></tr>
<tr><td><code id="sim_vf_options_+3A_length">length</code></td>
<td>
<p>The simulation length for each chain.</p>
</td></tr>
<tr><td><code id="sim_vf_options_+3A_discard">discard</code></td>
<td>
<p>How much of the starting part of each chain should be discarded? (Warming-up period.)</p>
</td></tr>
<tr><td><code id="sim_vf_options_+3A_stepsize">stepsize</code></td>
<td>
<p>The stepsize for Euler–Maruyama simulation of the system.</p>
</td></tr>
<tr><td><code id="sim_vf_options_+3A_sparse">sparse</code></td>
<td>
<p>A number. How much do you want to sparse the output? When the noise is small, sparse the output may make the density estimation more efficient.</p>
</td></tr>
<tr><td><code id="sim_vf_options_+3A_forbid_overflow">forbid_overflow</code></td>
<td>
<p>If <code>TRUE</code>, when the simulated system runs out of the margins specified in <code>vf</code>, the system will be moved back to the previous value. This can help to stabilize the simulation. <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="sim_vf_options_+3A_inits">inits</code></td>
<td>
<p>The initial values of each chain.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the parameters of the corresponding function. Only intended to be used within <code><a href="#topic+fit_3d_vfld">fit_3d_vfld()</a></code>
</p>

<hr>
<h2 id='simlandr_options'>Options controlling the landscape construction</h2><span id='topic+simlandr_options'></span>

<h3>Description</h3>

<p>To control the behavior of <code><a href="simlandr.html#topic+make_3d_static">simlandr::make_3d_static()</a></code>, but with default values accommodated for <code>fitlandr</code>. See <code><a href="simlandr.html#topic+make_3d_static">simlandr::make_3d_static()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simlandr_options(
  vf,
  x = rlang::expr(vf$x),
  y = rlang::expr(vf$y),
  lims = rlang::expr(vf$lims),
  kde_fun = c("ks", "MASS"),
  n = 200,
  adjust = 1,
  h,
  Umax = 5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simlandr_options_+3A_vf">vf</code></td>
<td>
<p>A <code>vectorfield</code> object estimated by <code><a href="#topic+fit_2d_vf">fit_2d_vf()</a></code>.</p>
</td></tr>
<tr><td><code id="simlandr_options_+3A_x">x</code>, <code id="simlandr_options_+3A_y">y</code></td>
<td>
<p>The names of the target variables.</p>
</td></tr>
<tr><td><code id="simlandr_options_+3A_lims">lims</code></td>
<td>
<p>The limits of the range for the density estimator as <code>c(xl, xu)</code> for 2D landscapes, <code>c(xl, xu, yl, yu)</code> for 3D landscapes, <code>c(xl, xu, yl, yu, zl, zu)</code> for 4D landscapes. If missing, the range of the data extended by 10% for both sides will be used. For landscapes based on multiple simulations, the largest range of all simulations (which means the lowest lower limit and the highest upper limit) will be used by default.</p>
</td></tr>
<tr><td><code id="simlandr_options_+3A_kde_fun">kde_fun</code></td>
<td>
<p>Which kernel estimator to use? Choices: &quot;ks&quot; <code><a href="ks.html#topic+kde">ks::kde()</a></code> (default; faster and using less memory); &quot;base&quot; <code>base::density()</code> (only for 2D landscapes); &quot;MASS&quot; <code><a href="MASS.html#topic+kde2d">MASS::kde2d()</a></code> (only for 3D landscapes).</p>
</td></tr>
<tr><td><code id="simlandr_options_+3A_n">n</code></td>
<td>
<p>The number of equally spaced points in each axis, at which the density is to be estimated.</p>
</td></tr>
<tr><td><code id="simlandr_options_+3A_adjust">adjust</code></td>
<td>
<p>The multiplier to the bandwidth. The bandwidth used is actually <code>adjust * h</code>. This makes it easy to specify values like &quot;half the default&quot; bandwidth.</p>
</td></tr>
<tr><td><code id="simlandr_options_+3A_h">h</code></td>
<td>
<p>A number, or possibly a vector for 3D and 4D landscapes, specifying the smoothing bandwidth to be used. If missing, the default value of the kernel estimator will be used (but <code>bw = "SJ"</code> for <code>base::density()</code>). Note that the definition of bandwidth might be different for different kernel estimators. For landscapes based on multiple simulations, the largest <code>h</code> of all simulations will be used by default.</p>
</td></tr>
<tr><td><code id="simlandr_options_+3A_umax">Umax</code></td>
<td>
<p>The maximum displayed value of potential.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the parameters of the corresponding function. Only intended to be used within <code><a href="#topic+fit_3d_vfld">fit_3d_vfld()</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
