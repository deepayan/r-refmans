<!DOCTYPE html><html><head><title>Help for package bisque</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bisque}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#createLocScaleGrid'><p>Create a centered and scaled sparse integration grid</p></a></li>
<li><a href='#dmix'><p>Evaluate a mixture density</p></a></li>
<li><a href='#emix'><p>Compute expectations via weighted mixtures</p></a></li>
<li><a href='#furseals'><p>Data from a capture-recapture study of fur seal pups</p></a></li>
<li><a href='#itx'><p>Named inverse transformation functions</p></a></li>
<li><a href='#jac.exp'><p>Jacobian for exponential transform</p></a></li>
<li><a href='#jac.invlogit'><p>Jacobian for logit transform</p></a></li>
<li><a href='#jac.log'><p>Jacobian for log transform</p></a></li>
<li><a href='#jac.logit'><p>Jacobian for logit transform</p></a></li>
<li><a href='#kCompute'><p>Use sparse grid quadrature techniques to integrate (unnormalized) densities</p></a></li>
<li><a href='#logjac'><p>Wrapper to abstractly evaluate log-Jacobian functions for transforms</p></a></li>
<li><a href='#mergePars'><p>Merge pre-computed components of f(theta1 | theta2, X)</p></a></li>
<li><a href='#sFit'><p>Fit a spatially mean-zero spatial Gaussian process model</p></a></li>
<li><a href='#sKrig'><p>Draw posterior predictive samples from a spatial Gaussian process model</p></a></li>
<li><a href='#tx'><p>Named transformation functions</p></a></li>
<li><a href='#wBuild'><p>Derive parameters for building integration grids</p></a></li>
<li><a href='#wMix'><p>Construct a weighted mixture object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Approximate Bayesian Inference via Sparse Grid Quadrature
Evaluation (BISQuE) for Hierarchical Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-02-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Joshua Hewitt</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua Hewitt &lt;joshua.hewitt@duke.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of the 'bisque' strategy for approximate Bayesian posterior inference.  See Hewitt and Hoeting (2019) &lt;<a href="https://doi.org/10.48550/arXiv.1904.07270">doi:10.48550/arXiv.1904.07270</a>&gt; for complete details.  'bisque' combines conditioning with sparse grid quadrature rules to approximate marginal posterior quantities of hierarchical Bayesian models.  The resulting approximations are computationally efficient for many hierarchical Bayesian models.  The 'bisque' package allows approximate posterior inference for custom models; users only need to specify the conditional densities required for the approximation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, fields</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvQuad, Rcpp, foreach, itertools</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.12.4), RcppArmadillo, RcppEigen (&ge; 0.3.3.3.1)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>A system with a recent-enough C++11 compiler (such
as g++-4.8 or later).</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-04 21:19:26 UTC; pointdex</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-06 00:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='createLocScaleGrid'>Create a centered and scaled sparse integration grid</h2><span id='topic+createLocScaleGrid'></span>

<h3>Description</h3>

<p>Enhances mvQuad::createNIGrid by shifting and scaling a sparse integration
grid, and evaluating the weight function at each of the grid nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createLocScaleGrid(
  mu = 0,
  prec = 1,
  level = 2,
  quadError = FALSE,
  prec.chol = chol(prec)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createLocScaleGrid_+3A_mu">mu</code></td>
<td>
<p>location at which grid should be centered</p>
</td></tr>
<tr><td><code id="createLocScaleGrid_+3A_prec">prec</code></td>
<td>
<p>&quot;precision matrix&quot; associated with the integration grid.  When 
building a sparse integration grid for a density, <code>prec</code> is often 
the negative of the hessian at the mode.</p>
</td></tr>
<tr><td><code id="createLocScaleGrid_+3A_level">level</code></td>
<td>
<p>accuracy level.  This is typically number of grid points for the 
underlying 1D quadrature rule.  [description from mvQuad::createNIGrid]</p>
</td></tr>
<tr><td><code id="createLocScaleGrid_+3A_quaderror">quadError</code></td>
<td>
<p>provide additional information about the grid points and 
integration weights for the quadrature rule with <code>level-1</code>.  This 
information can facilitate approximating the quadrature error.</p>
</td></tr>
<tr><td><code id="createLocScaleGrid_+3A_prec.chol">prec.chol</code></td>
<td>
<p>Upper-triangular Cholesky decomposition of precision matrix.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>mvQuad::createNIGrid</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g = createLocScaleGrid(mu = c(1,0), prec = diag(c(1,.5)), level = 2 )

</code></pre>

<hr>
<h2 id='dmix'>Evaluate a mixture density</h2><span id='topic+dmix'></span>

<h3>Description</h3>

<p>Evaluates mixture densities of the form
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \sum_{j=1}^k f(x|\theta^{(k)}) w_k</code>
</p>

<p>where the <code class="reqn">w_k</code> are (possibly negative) weights that sum to 1 and 
<code class="reqn">f(x|\theta^{(k)})</code> are densities that are specified via parameters
<code class="reqn">\theta^{(k)}</code>, which are passed in the function argument 
<code>params</code>.
A unique feature of this function is that it is able to evaluate mixture
densities in which some of the mixture weights <code class="reqn">w_k</code> are negative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmix(x, f, params, wts, log = FALSE, errorNodesWts = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmix_+3A_x">x</code></td>
<td>
<p>Points at which the mixture should be evaluated.  If the density 
is multivariate, then each row of <code>x</code> should contain one set of 
points at which the mixture should be evaluated.</p>
</td></tr>
<tr><td><code id="dmix_+3A_f">f</code></td>
<td>
<p>Density used in the mixture. The function should be defined so it 
is can be called via <code>f(x, params, log, ...)</code>.  The density <code class="reqn">f</code>
is evaluated at the points in <code>x</code> using one set of parameters 
<code>params</code>, i.e., for some specific <code class="reqn">\theta^{(k)}</code>.
if <code>log==TRUE</code>, then <code class="reqn">ln(f)</code> is returned.  Additional parameters
may be passed to <code class="reqn">f</code> via <code>...</code>.</p>
</td></tr>
<tr><td><code id="dmix_+3A_params">params</code></td>
<td>
<p>Matrix in which each row contains parameters that define
<code class="reqn">f</code>.  The number of rows in <code>params</code> should match the number of 
mixture components <code class="reqn">k</code>.</p>
</td></tr>
<tr><td><code id="dmix_+3A_wts">wts</code></td>
<td>
<p>vector of weights for each mixture component</p>
</td></tr>
<tr><td><code id="dmix_+3A_log">log</code></td>
<td>
<p>TRUE to return the log of the mixture density</p>
</td></tr>
<tr><td><code id="dmix_+3A_errornodeswts">errorNodesWts</code></td>
<td>
<p>list with elements <code>inds</code> and <code>weights</code> that 
point out which <code>params</code> get used to compute an approximation of the 
quadrature error.</p>
</td></tr>
<tr><td><code id="dmix_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>f</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># evaluate mixture density at these locations
x = seq(0, 1, length.out = 100)

# density will be a mixture of beta distributions
f = function(x, theta, log = FALSE) {
  dbeta(x, shape1 = theta[1], shape2 = theta[2], log = log)
}

# beta parameters are randomly assigned
params = matrix(exp(2*runif(10)), ncol=2)

# mixture components are equally weighted
wts = rep(1/nrow(params), nrow(params))

# evaluate mixture density
fmix = dmix(x = x, f = f, params = params, wts = wts)

# plot mixture density
plot(x, fmix, type='l', ylab = expression(f(x)), 
     ylim = c(0, 4))

# plot component densities
for(i in 1:length(wts)){
  curve(f(x, params[i,]), col = 2, add = TRUE)
}
</code></pre>

<hr>
<h2 id='emix'>Compute expectations via weighted mixtures</h2><span id='topic+emix'></span>

<h3>Description</h3>

<p>Approximates expectations of the form
</p>
<p style="text-align: center;"><code class="reqn">E[h(\theta)] = \int h(\theta) f(\theta) d\theta</code>
</p>

<p>using a weighted mixture
</p>
<p style="text-align: center;"><code class="reqn">E[h(\theta)] \approx \sum_{j=1}^k h(\theta^{(k)}) w_k</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>emix(h, params, wts, ncores = 1, errorNodesWts = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emix_+3A_h">h</code></td>
<td>
<p>Function for which the expectation should be taken.  The function 
should be defined so it is can be called via <code>f(params, ...)</code>.
Additional parameters may be passed to <code class="reqn">h</code> via <code>...</code>.</p>
</td></tr>
<tr><td><code id="emix_+3A_params">params</code></td>
<td>
<p>Matrix in which each row contains parameters at which
<code class="reqn">h</code> should be evaluated.  The number of rows in <code>params</code> should 
match the number of mixture components <code class="reqn">k</code>.</p>
</td></tr>
<tr><td><code id="emix_+3A_wts">wts</code></td>
<td>
<p>vector of weights for each mixture component</p>
</td></tr>
<tr><td><code id="emix_+3A_ncores">ncores</code></td>
<td>
<p>number of cores over which to evaluate mixture.  this function
assumes a parallel backend is already registered.</p>
</td></tr>
<tr><td><code id="emix_+3A_errornodeswts">errorNodesWts</code></td>
<td>
<p>list with elements <code>inds</code> and <code>weights</code> that 
point out which <code>params</code> get used to compute an approximation of the 
quadrature error.</p>
</td></tr>
<tr><td><code id="emix_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>h</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># density will be a mixture of betas
params = matrix(exp(2*runif(10)), ncol=2)

# mixture components are equally weighted
wts = rep(1/nrow(params), nrow(params))

# compute mean of distribution by cycling over each mixture component
h = function(p) { p[1] / sum(p) }

# compute mixture mean
mean.mix = emix(h, params, wts)

# (comparison) Monte Carlo estimate of mixture mean
nsamples = 1e4
component = sample(x = 1:length(wts), size = nsamples, prob = wts, 
                   replace = TRUE)
x = sapply(component, function(cmp) {
  rbeta(n = 1, shape1 = params[cmp, 1], shape2 = params[cmp, 2])
})
mean.mix.mc = mean(x)

# compare estimates
c(emix = mean.mix, MC = mean.mix.mc)
</code></pre>

<hr>
<h2 id='furseals'>Data from a capture-recapture study of fur seal pups</h2><span id='topic+furseals'></span>

<h3>Description</h3>

<p>These data are used in the book &quot;Computational Statistics&quot; 
by G.H. Givens and J.A. Hoeting (2013).  They are discussed in Chapter 7, 
Examples 7.2,7.3,7.8, and Exercise 7.2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(furseals)
</code></pre>


<h3>Format</h3>

<p>A data.frame with variables:
</p>

<dl>
<dt>i</dt><dd><p>The census attempt</p>
</dd>
<dt>c</dt><dd><p>Number of pups captured in census attempt</p>
</dd>
<dt>m</dt><dd><p>Number of newly captured pups</p>
</dd>
</dl>


<h3>Details</h3>

<p>As described by the authors:
</p>
<p>Source: Richard Barker, University of Otago, New Zealand
</p>
<p>Description: Data from a capture-recapture study conducted on the
Otago Penninsula, South Island, New Zealand.  Fur seal pups were
marked and released during 7 census attempts in one season.  The
population is assumed closed.  For each census attempt, the number of
pups captured and the number of these captures corresponding to pups
never previously caught are recorded.
</p>


<h3>Source</h3>

<p><a href="https://www.stat.colostate.edu/computationalstatistics/">https://www.stat.colostate.edu/computationalstatistics/</a>
</p>
<p><a href="https://www.stat.colostate.edu/computationalstatistics/datasets.zip">https://www.stat.colostate.edu/computationalstatistics/datasets.zip</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("furseals")
str(furseals)

</code></pre>

<hr>
<h2 id='itx'>Named inverse transformation functions</h2><span id='topic+itx'></span>

<h3>Description</h3>

<p>Evaluates the inverse of the named link function at the locations
<code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itx(x, link, linkparams)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itx_+3A_x">x</code></td>
<td>
<p>Values at which to evaluate the inverse link function</p>
</td></tr>
<tr><td><code id="itx_+3A_link">link</code></td>
<td>
<p>Character vector specifying link function for which the 
inverse link function should be evaluated.  Supports <code>'identity'</code>,
<code>'log'</code>, and <code>'logit'</code>.</p>
</td></tr>
<tr><td><code id="itx_+3A_linkparams">linkparams</code></td>
<td>
<p>Optional list of additional parameters  for link functions.
For example, the logit function can be extended to allow mappings to any 
closed interval.  There should be one list entry for each link function.  
Specify NA if defaults should be used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>bisque:::itx(0, 'logit', list(NA))

</code></pre>

<hr>
<h2 id='jac.exp'>Jacobian for exponential transform</h2><span id='topic+jac.exp'></span>

<h3>Description</h3>

<p>Let <code class="reqn">X=exp(Y)</code> be a transformation of a random variable <code class="reqn">Y</code>.  
This function computes the jacobian <code class="reqn">J(x)</code> when using the density of 
<code class="reqn">Y</code> to evaluate the density of <code class="reqn">X</code> via
</p>
<p style="text-align: center;"><code class="reqn">f(x) = f_y(ln(x)) J(x)</code>
</p>

<p>where 
</p>
<p style="text-align: center;"><code class="reqn">J(x) = d/dx ln(x).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>jac.exp(x, log = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jac.exp_+3A_x">x</code></td>
<td>
<p>value at which to evaluate <code class="reqn">J(x)</code></p>
</td></tr>
<tr><td><code id="jac.exp_+3A_log">log</code></td>
<td>
<p>TRUE to return <code class="reqn">log(J(x))</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>jac.exp(1)

</code></pre>

<hr>
<h2 id='jac.invlogit'>Jacobian for logit transform</h2><span id='topic+jac.invlogit'></span>

<h3>Description</h3>

<p>Let <code class="reqn">X=logit^{-1}(Y)</code> be a transformation of a random variable <code class="reqn">Y</code>.  
This function computes the jacobian <code class="reqn">J(x)</code> when using the density of 
<code class="reqn">Y</code> to evaluate the density of <code class="reqn">X</code> via
</p>
<p style="text-align: center;"><code class="reqn">f(x) = f_y(logit(x)) J(x)</code>
</p>

<p>where 
</p>
<p style="text-align: center;"><code class="reqn">J(x) = d/dx logit(x).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>jac.invlogit(x, log = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jac.invlogit_+3A_x">x</code></td>
<td>
<p>value at which to evaluate <code class="reqn">J(x)</code></p>
</td></tr>
<tr><td><code id="jac.invlogit_+3A_log">log</code></td>
<td>
<p>TRUE to return <code class="reqn">log(J(x))</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>jac.invlogit(1)

</code></pre>

<hr>
<h2 id='jac.log'>Jacobian for log transform</h2><span id='topic+jac.log'></span>

<h3>Description</h3>

<p>Let <code class="reqn">X=log(Y)</code> be a transformation of a random variable <code class="reqn">Y</code>.  
This function computes the jacobian <code class="reqn">J(x)</code> when using the density of 
<code class="reqn">Y</code> to evaluate the density of <code class="reqn">X</code> via
</p>
<p style="text-align: center;"><code class="reqn">f(x) = f_y(exp(x)) J(x)</code>
</p>

<p>where 
</p>
<p style="text-align: center;"><code class="reqn">J(x) = d/dx exp(x).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>jac.log(x, log = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jac.log_+3A_x">x</code></td>
<td>
<p>value at which to evaluate <code class="reqn">J(x)</code></p>
</td></tr>
<tr><td><code id="jac.log_+3A_log">log</code></td>
<td>
<p>TRUE to return <code class="reqn">log(J(x))</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>jac.log(1)

</code></pre>

<hr>
<h2 id='jac.logit'>Jacobian for logit transform</h2><span id='topic+jac.logit'></span>

<h3>Description</h3>

<p>Let <code class="reqn">X=logit(Y)</code> be a transformation of a random variable <code class="reqn">Y</code> that 
lies in the closed interval (L,U).  
This function computes the jacobian <code class="reqn">J(x)</code> when using the density of 
<code class="reqn">Y</code> to evaluate the density of <code class="reqn">X</code> via
</p>
<p style="text-align: center;"><code class="reqn">f(x) = f_y(logit^{-1}(x) * (U-L) + L) J(x)</code>
</p>

<p>where 
</p>
<p style="text-align: center;"><code class="reqn">J(x) = (U-L) d/dx logit^{-1}(x).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>jac.logit(x, log = TRUE, range = c(0, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jac.logit_+3A_x">x</code></td>
<td>
<p>value at which to evaluate <code class="reqn">J(x)</code></p>
</td></tr>
<tr><td><code id="jac.logit_+3A_log">log</code></td>
<td>
<p>TRUE to return <code class="reqn">log(J(x))</code></p>
</td></tr>
<tr><td><code id="jac.logit_+3A_range">range</code></td>
<td>
<p>vector specifying min and max range of the closed interval for 
the logit.  While the logit is defined for real numbers in the unit 
interval, we extend it to real numbers in arbitrary closed intervals (L,U).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>jac.logit(1)

</code></pre>

<hr>
<h2 id='kCompute'>Use sparse grid quadrature techniques to integrate (unnormalized) densities</h2><span id='topic+kCompute'></span>

<h3>Description</h3>

<p>This function integrates (unnormalized) densities and may be used to compute
integration constants for unnormalized densities, or to marginalize a 
joint density, for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kCompute(
  f,
  init,
  method = "BFGS",
  maxit = 10000,
  level = 2,
  log = FALSE,
  link = NULL,
  linkparams = NULL,
  quadError = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kCompute_+3A_f">f</code></td>
<td>
<p>(Unnormalized) density to integrate.
the function <code class="reqn">f</code> should include an argument <code>log</code>, 
which returns <code class="reqn">log(f(x))</code>.</p>
</td></tr>
<tr><td><code id="kCompute_+3A_init">init</code></td>
<td>
<p>Initial guess for the density's mode</p>
</td></tr>
<tr><td><code id="kCompute_+3A_method">method</code></td>
<td>
<p>method to be used to search for the density's mode</p>
</td></tr>
<tr><td><code id="kCompute_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations <code>optim</code> should use in 
searching for the density's mode</p>
</td></tr>
<tr><td><code id="kCompute_+3A_level">level</code></td>
<td>
<p>accuracy level (typically number of grid points for the 
underlying 1D quadrature rule) [description from mvQuad::createNIGrid]</p>
</td></tr>
<tr><td><code id="kCompute_+3A_log">log</code></td>
<td>
<p>TRUE to return log of integration constant</p>
</td></tr>
<tr><td><code id="kCompute_+3A_link">link</code></td>
<td>
<p>character vector that specifies transformations used during 
optimization and integration of f(theta2 | X).  while theta2 may be 
defined on arbitrary support, <code>wtdMix</code> performs optimization and 
integration of theta2 on an unconstrained support.  the <code>link</code> 
vector describes the transformations that must be applied to each 
element of theta2.  Jacobian functions for the transformations will 
automatically be added to the optimization and integration routines.
currently supported link functions are 'log', 'logit', and 'identity'.</p>
</td></tr>
<tr><td><code id="kCompute_+3A_linkparams">linkparams</code></td>
<td>
<p>Optional list of additional parameters  for link functions.
For example, the logit function can be extended to allow mappings to any 
closed interval.  There should be one list entry for each link function.  
Specify NA if no additional arguments are passed.</p>
</td></tr>
<tr><td><code id="kCompute_+3A_quaderror">quadError</code></td>
<td>
<p>TRUE if integration nodes and weight should be computed for
the <code>level-1</code> integration grid, so that quadrature approximation
error can be estimated.</p>
</td></tr>
<tr><td><code id="kCompute_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code>f</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>kCompute(dgamma, init = 1, shape=2, link='log', level = 5)

</code></pre>

<hr>
<h2 id='logjac'>Wrapper to abstractly evaluate log-Jacobian functions for transforms</h2><span id='topic+logjac'></span>

<h3>Description</h3>

<p>Wrapper to abstractly evaluate log-Jacobian functions for transforms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logjac(x, link, linkparams)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logjac_+3A_x">x</code></td>
<td>
<p>values at which to evaluate <code class="reqn">J(x)</code></p>
</td></tr>
<tr><td><code id="logjac_+3A_link">link</code></td>
<td>
<p>Character vector specifying link function for which the 
inverse link function should be evaluated.  Supports <code>'identity'</code>,
<code>'log'</code>, and <code>'logit'</code>.</p>
</td></tr>
<tr><td><code id="logjac_+3A_linkparams">linkparams</code></td>
<td>
<p>Optional list of additional parameters  for link functions.
For example, the logit function can be extended to allow mappings to any 
closed interval.  There should be one list entry for each link function.  
Specify NA if defaults should be used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+jac.log">jac.log</a></code>, <code><a href="#topic+jac.logit">jac.logit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bisque:::logjac(1, 'logit', list(NA))

</code></pre>

<hr>
<h2 id='mergePars'>Merge pre-computed components of f(theta1 | theta2, X)</h2><span id='topic+mergePars'></span>

<h3>Description</h3>

<p>For use in the parallel call in wtdMix()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergePars(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergePars_+3A_x">x</code></td>
<td>
<p>Output from one of the parallel calls in wtdMix()</p>
</td></tr>
<tr><td><code id="mergePars_+3A_y">y</code></td>
<td>
<p>Another output from one of the parallel calls in wtdMix()</p>
</td></tr>
</table>

<hr>
<h2 id='sFit'>Fit a spatially mean-zero spatial Gaussian process model</h2><span id='topic+sFit'></span>

<h3>Description</h3>

<p>Uses a Gibbs sampler to estimate the parameters of a Matern covariance 
function used to model observations from a Gaussian process with mean 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sFit(
  x,
  coords,
  nSamples,
  thin = 1,
  rw.initsd = 0.1,
  inits = list(),
  C = 1,
  alpha = 0.44,
  priors = list(sigmasq = list(a = 2, b = 1), rho = list(L = 0, U = 1), nu = list(L = 0,
    U = 1))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sFit_+3A_x">x</code></td>
<td>
<p>Observation of a spatial Gaussian random field, passed as a vector</p>
</td></tr>
<tr><td><code id="sFit_+3A_coords">coords</code></td>
<td>
<p>Spatial coordinates of the observation</p>
</td></tr>
<tr><td><code id="sFit_+3A_nsamples">nSamples</code></td>
<td>
<p>(thinned) number of MCMC samples to generate</p>
</td></tr>
<tr><td><code id="sFit_+3A_thin">thin</code></td>
<td>
<p>thinning to be used within the returned MCMC samples</p>
</td></tr>
<tr><td><code id="sFit_+3A_rw.initsd">rw.initsd</code></td>
<td>
<p>initial standard devaition for random walk proposals.  this 
parameter will be adaptively tuned during sampling</p>
</td></tr>
<tr><td><code id="sFit_+3A_inits">inits</code></td>
<td>
<p>list of initial parameters for the MCMC chain</p>
</td></tr>
<tr><td><code id="sFit_+3A_c">C</code></td>
<td>
<p>scale factor used during tuning of the random walk proposal s.d.</p>
</td></tr>
<tr><td><code id="sFit_+3A_alpha">alpha</code></td>
<td>
<p>target acceptance rate for which the random walk proposals 
should optimize</p>
</td></tr>
<tr><td><code id="sFit_+3A_priors">priors</code></td>
<td>
<p>parameters to specify the prior distributions for the model</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(fields)

simulate.field = function(n = 100, range = .3, smoothness = .5, phi = 1){
  # Simulates a mean-zero spatial field on the unit square
  #
  # Parameters:
  #  n - number of spatial locations
  #  range, smoothness, phi - parameters for Matern covariance function
  
  coords = matrix(runif(2*n), ncol=2)
  
  Sigma = Matern(d = as.matrix(dist(coords)), 
                 range = range, smoothness = smoothness, phi = phi)
  
  list(coords = coords,
       params = list(n=n, range=range, smoothness=smoothness, phi=phi),
       x = t(chol(Sigma)) %*%  rnorm(n))
}

# simulate data
x = simulate.field()

# configure gibbs sampler  
it = 100

# run sampler using default posteriors
post.samples = sFit(x = x$x, coords = x$coords, nSamples = it)

# build kriging grid
cseq = seq(0, 1, length.out = 10)
coords.krig = expand.grid(x = cseq, y = cseq)

# sample from posterior predictive distribution
burn = 75
samples.krig = sKrig(x$x, post.samples, coords.krig = coords.krig, burn = burn)
</code></pre>

<hr>
<h2 id='sKrig'>Draw posterior predictive samples from a spatial Gaussian process model</h2><span id='topic+sKrig'></span>

<h3>Description</h3>

<p>Draw posterior predictive samples from a spatial Gaussian process model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sKrig(x, sFit, coords.krig, coords = sFit$coords, burn = 0, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sKrig_+3A_x">x</code></td>
<td>
<p>Observation of a spatial Gaussian random field, passed as a vector</p>
</td></tr>
<tr><td><code id="sKrig_+3A_sfit">sFit</code></td>
<td>
<p>posterior samples of model parameters; output from 
bisque::sFit</p>
</td></tr>
<tr><td><code id="sKrig_+3A_coords.krig">coords.krig</code></td>
<td>
<p>Spatial coordinates at which the field should be 
interpolated</p>
</td></tr>
<tr><td><code id="sKrig_+3A_coords">coords</code></td>
<td>
<p>Spatial coordinates at which observations are available</p>
</td></tr>
<tr><td><code id="sKrig_+3A_burn">burn</code></td>
<td>
<p>number of posterior samples to discard from sFit before sampling</p>
</td></tr>
<tr><td><code id="sKrig_+3A_ncores">ncores</code></td>
<td>
<p>Kriging is done via composition sampling, which may be done in
parallel.  <code>ncores</code> specifies the number of cores over which sampling 
is done.  If <code>ncores&gt;1</code>, bisque::sKrig assumes that a parallel 
backend suitable for use with the foreach package is already registered.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(fields)

simulate.field = function(n = 100, range = .3, smoothness = .5, phi = 1){
  # Simulates a mean-zero spatial field on the unit square
  #
  # Parameters:
  #  n - number of spatial locations
  #  range, smoothness, phi - parameters for Matern covariance function
  
  coords = matrix(runif(2*n), ncol=2)
  
  Sigma = Matern(d = as.matrix(dist(coords)), 
                 range = range, smoothness = smoothness, phi = phi)
  
  list(coords = coords,
       params = list(n=n, range=range, smoothness=smoothness, phi=phi),
       x = t(chol(Sigma)) %*%  rnorm(n))
}

# simulate data
x = simulate.field()

# configure gibbs sampler  
it = 100

# run sampler using default posteriors
post.samples = sFit(x = x$x, coords = x$coords, nSamples = it)

# build kriging grid
cseq = seq(0, 1, length.out = 10)
coords.krig = expand.grid(x = cseq, y = cseq)

# sample from posterior predictive distribution
burn = 75
samples.krig = sKrig(x$x, post.samples, coords.krig = coords.krig, burn = burn)
</code></pre>

<hr>
<h2 id='tx'>Named transformation functions</h2><span id='topic+tx'></span>

<h3>Description</h3>

<p>Evaluates the named link function at the locations <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tx(x, link, linkparams)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tx_+3A_x">x</code></td>
<td>
<p>Values at which to evaluate the link function</p>
</td></tr>
<tr><td><code id="tx_+3A_link">link</code></td>
<td>
<p>Character vector specifying link function to evaluate.  Supports 
<code>'identity'</code>, <code>'log'</code>, and <code>'logit'</code>.</p>
</td></tr>
<tr><td><code id="tx_+3A_linkparams">linkparams</code></td>
<td>
<p>Optional list of additional parameters  for link functions.
For example, the logit function can be extended to allow mappings to any 
closed interval.  There should be one list entry for each link function.  
Specify NA if defaults should be used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>bisque:::tx(0.5, 'logit', list(NA))

</code></pre>

<hr>
<h2 id='wBuild'>Derive parameters for building integration grids</h2><span id='topic+wBuild'></span>

<h3>Description</h3>

<p>Note: <code class="reqn">w</code> is defined on the transformed scale, but for convenience 
<code>f</code> is defined on the original scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wBuild(
  f,
  init,
  dim.theta2 = length(init),
  approx = "gaussian",
  link = rep("identity", length(init)),
  link.params = rep(list(NA), length(init)),
  optim.control = list(maxit = 5000, method = "BFGS"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wBuild_+3A_f">f</code></td>
<td>
<p>function used to derive the weight function <code class="reqn">w</code>.
<code>f</code> must be able to be called via <code>f(par, log, ...)</code></p>
</td></tr>
<tr><td><code id="wBuild_+3A_init">init</code></td>
<td>
<p>initial guess for mode of <code>f</code>.</p>
</td></tr>
<tr><td><code id="wBuild_+3A_dim.theta2">dim.theta2</code></td>
<td>
<p><code>wBuild</code> assumes <code>par</code> is partitioned such that 
<code>par=c(theta1,theta2)</code>.  <code>dim.theta2</code> specifies the size of the 
partition.  The default is to assume that <code>f</code> is defined without a 
<code>theta1</code> component.</p>
</td></tr>
<tr><td><code id="wBuild_+3A_approx">approx</code></td>
<td>
<p>Style of approximation (i.e., <code class="reqn">w</code>) to be created from mode 
of <code>f</code>.
</p>

<dl>
<dt><code>'gaussian'</code></dt><dd><p>Gaussian approximation for <code>theta2</code> at 
the mode of <code>f</code>. Assumes <code>f</code> is proportional to the marginal 
posterior density for <code>theta2</code>.</p>
</dd>
<dt><code>'condgauss'</code></dt><dd><p>Gaussian approximation for <code>theta2</code> at 
the mode of <code>f</code>.  The approximation is conditioned on the value of
the mode for <code>theta1</code>. Assumes <code>f</code> is proportional to the 
joint posterior density for <code>theta1,theta2.</code></p>
</dd>
<dt><code>'condgauss-laplace'</code></dt><dd><p>Gaussian approximation for 
<code>theta2</code> at the mode of <code>f</code>.  The approximation is 
conditioned on a separate laplace approximation of the marginal 
posterior mode for <code>theta1</code>.  Assumes <code>f</code> is proportional to 
the joint posterior density for <code>theta1,theta2.</code></p>
</dd>
<dt><code>'margauss'</code></dt><dd><p>Gaussian approximation for 
<code>theta2</code> at the mode of <code>f</code>.  Assumes <code>f</code> is 
proportional to the joint posterior density for <code>theta1,theta2.</code>, 
then uses the marginal mean and covariance from the posterior's 
gaussian approximation.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="wBuild_+3A_link">link</code></td>
<td>
<p>character vector that specifies transformations used during
optimization and integration of <code class="reqn">f(\theta_2 | X)</code>.  While
<code class="reqn">\theta_2</code> may be defined on arbitrary support, <code>wtdMix</code> performs
optimization and integration of <code class="reqn">\theta_2</code> on an unconstrained support.
The <code>link</code> vector describes the transformations that must be applied
to each element of <code class="reqn">\theta_2</code>.  Jacobian functions for the
transformations will automatically be added to the optimization and
integration routines. Currently supported link functions are <code>'log'</code>,
<code>'logit'</code>, and <code>'identity'</code>.</p>
</td></tr>
<tr><td><code id="wBuild_+3A_link.params">link.params</code></td>
<td>
<p>Optional list of additional parameters for link
functions.  For example, the logit function can be extended to allow
mappings to any closed interval.   There should be one list entry for each
link function.  Specify NA if no additional arguments are passed.</p>
</td></tr>
<tr><td><code id="wBuild_+3A_optim.control">optim.control</code></td>
<td>
<p>List of arguments to pass to <code>stat::optim</code>
when used to find mode of <code>f</code>.
</p>

<dl>
<dt><code>maxit</code></dt><dd><p>Maximum number of iterations to run <code>optim</code> 
for.</p>
</dd>
<dt><code>method</code></dt><dd><p>Optimization routine to use with <code>optim</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="wBuild_+3A_...">...</code></td>
<td>
<p>additional arguments needed for function evaluation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Use BISQuE to approximate the marginal posterior distribution for unknown
# population f(N|c, r) for the fur seals capture-recapture data example in 
# Givens and Hoeting (2013), example 7.10.

data('furseals')

# define theta transformation and jacobian
tx.theta = function(theta) { 
  c(log(theta[1]/theta[2]), log(sum(theta[1:2]))) 
}
itx.theta = function(u) { 
  c(exp(sum(u[1:2])), exp(u[2])) / (1 + exp(u[1])) 
}
lJ.tx.theta = function(u) {
  log(exp(u[1] + 2*u[2]) + exp(2*sum(u[1:2]))) - 3 * log(1 + exp(u[1]))
}

# compute constants
r = sum(furseals$m)
nC = nrow(furseals)

# set basic initialization for parameters
init = list(U = c(-.7, 5.5))
init = c(init, list(
  alpha = rep(.5, nC),
  theta = itx.theta(init$U),
  N = r + 1
))


post.alpha_theta = function(theta2, log = TRUE, ...) {
  # Function proportional to f(alpha, U1, U2 | c, r) 
  
  alpha = theta2[1:nC]
  u = theta2[-(1:nC)]
  theta = itx.theta(u)
  p = 1 - prod(1-alpha)
  
  res = - sum(theta)/1e3 - r * log(p) + lJ.tx.theta(u) - 
    nC * lbeta(theta[1], theta[2])
  for(i in 1:nC) {
    res = res + (theta[1] + furseals$c[i] - 1)*log(alpha[i]) + 
      (theta[2] + r - furseals$c[i] - 1)*log(1-alpha[i])
  }
  
  if(log) { res } else { exp(res) }
}

post.N.mixtures = function(N, params, log = TRUE, ...) {
  # The mixture component of the weighted mixtures for f(N | c, r)
  dnbinom(x = N-r, size = r, prob = params, log = log)
}

mixparams.N = function(theta2, ...) {
  # compute parameters for post.N.mixtures
  1 - prod(1 - theta2[1:nC])
}


w.N = wBuild(f = post.alpha_theta, init = c(init$alpha, init$U), 
             approx = 'gauss', link = c(rep('logit', nC), rep('identity', 2)))

m.N = wMix(f1 = post.N.mixtures, f1.precompute = mixparams.N, 
           f2 = post.alpha_theta, w = w.N)



# compute posterior mean
m.N$expectation$Eh.precompute(h = function(p) ((1-p)*r/p + r), 
                                   quadError = TRUE)

# compute posterior density
post.N.dens = data.frame(N = r:105)
post.N.dens$d = m.N$f(post.N.dens$N)

# plot posterior density
plot(d~N, post.N.dens, ylab = expression(f(N~'|'~bold(c),r)))

</code></pre>

<hr>
<h2 id='wMix'>Construct a weighted mixture object</h2><span id='topic+wMix'></span>

<h3>Description</h3>

<p>For a Bayesian model
</p>
<p style="text-align: center;"><code class="reqn"> X ~ f(X | \theta_1, \theta_2)</code>
</p>

<p style="text-align: center;"><code class="reqn"> (\theta_1, \theta_2) ~ f(\theta_1, \theta_2),</code>
</p>

<p>the marginal  posterior <code class="reqn">f(\theta_1 | X)</code> distribution can be
approximated via weighted mixtures via
</p>
<p style="text-align: center;"><code class="reqn"> f(\theta_1 | X) \approx \sum_{j=1}^K f(\theta_1 | X, \theta_2) w_j </code>
</p>

<p>where <code class="reqn">w_j</code> is based on <code class="reqn">f(\theta_2^{(j)} | X)</code> and weights
<code class="reqn">\tilde w_j</code>, where <code class="reqn">\theta_2^{(j)}</code> and <code class="reqn">\tilde w_j</code> are
nodes and weights for a sparse-grid quadrature integration scheme.
The quadrature rule is developed by finding the posterior mode of
<code class="reqn">f(\theta_2|X)</code>, after transforming <code class="reqn">\theta_2</code> to an unconstrained
support.  For best results, <code class="reqn">\theta_2</code> should be a continuous random
variable, or be able to be approximated by one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wMix(
  f1,
  f2,
  w,
  f1.precompute = function(x, ...) {     x },
  spec = "ff",
  level = 2,
  c.int = NULL,
  c.level = 2,
  c.init = NULL,
  c.link = rep("identity", length(c.init)),
  c.link.params = rep(list(NA), length(c.init)),
  c.optim.control = list(maxit = 5000, method = "BFGS"),
  ncores = 1,
  quadError = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wMix_+3A_f1">f1</code></td>
<td>
<p>evaluates <code class="reqn">f(\theta_1 | X, \theta_2)</code>.  <code>f1</code> must be able
to be called via <code>f1(theta1, params, log, ...)</code>.
</p>

<dl>
<dt><code>theta1</code></dt><dd><p>a matrix of parameters at which to evaluate
<code class="reqn">f(\theta_1 | X, \theta_2)</code>. each row should be one set of values
at which the density should be evaluated</p>
</dd>
<dt>params</dt><dd><p>a vector of parameters needed to evaluate
<code class="reqn">f(\theta_1 | X, \theta_2)</code>.  In most cases <code>params</code> will
equal <code class="reqn">theta_2</code>, but in some cases, <code class="reqn">f(\theta_1 | X, \theta_2)</code>
depends on functions of <code class="reqn">\theta_2</code>, which can be pre-evaluated
as the weighted mixture approximation is constructed.</p>
</dd>
<dt>log</dt><dd><p>TRUE to return <code class="reqn">ln(f(\theta_1 | X, \theta_2))</code></p>
</dd>
<dt>...</dt><dd><p>additional arguments needed for function evaluation</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="wMix_+3A_f2">f2</code></td>
<td>
<p>evaluates <code class="reqn">f(theta_2 | X)</code>.  <code>f2</code> must be able to be
called via <code>f2(theta2, log, ...)</code>.</p>
</td></tr>
<tr><td><code id="wMix_+3A_w">w</code></td>
<td>
<p><code>wBuild</code> object created by <code>wBuild</code> function.  <code>w</code> 
contains posterior mode of <code class="reqn">f(\theta_2| X)</code> and wrapper functions to 
generate quadrature grid.</p>
</td></tr>
<tr><td><code id="wMix_+3A_f1.precompute">f1.precompute</code></td>
<td>
<p>function that pre-computes parameters for evaluating
<code class="reqn">f(\theta_1 | X, \theta_2)</code>.  <code>f1.precompute</code> must be able to
be called via <code>f1.precompute(theta2, ...)</code> and return the argument
<code>params</code> for the function <code>f1</code>.</p>
</td></tr>
<tr><td><code id="wMix_+3A_spec">spec</code></td>
<td>
<p>Specification of whether <code>f1</code> and <code>f2</code> are known 
exactly, or need numerical approximation to determine integration constants.
<code>'ff'</code> if both functions are known, <code>'gg'</code> if <code>f1</code> is 
proportional to the full conditional distribution 
<code class="reqn">f(\theta_1|\theta_2,X)</code>, but needs the integration constant computed,
and if the marginal posterior <code class="reqn">f(theta_2|X)</code> is equal to <code>f2</code> times
the integration constant that needs to be numerically approximated.</p>
</td></tr>
<tr><td><code id="wMix_+3A_level">level</code></td>
<td>
<p>accuracy level of the numerical approximation
(typically number of grid points for the
underlying 1D quadrature rule) [description from mvQuad::createNIGrid]</p>
</td></tr>
<tr><td><code id="wMix_+3A_c.int">c.int</code></td>
<td>
<p>If <code>spec=='gg'</code>, then <code>c.int</code> specifies the function
that can be integrated in order to yield the missing integration constant.</p>
</td></tr>
<tr><td><code id="wMix_+3A_c.level">c.level</code></td>
<td>
<p>accuracy level of the numerical approximation for <code>c.int</code> 
(typically number of grid points for the
underlying 1D quadrature rule) [description from mvQuad::createNIGrid]</p>
</td></tr>
<tr><td><code id="wMix_+3A_c.init">c.init</code></td>
<td>
<p>initial guess for mode of <code>c.int</code>.</p>
</td></tr>
<tr><td><code id="wMix_+3A_c.link">c.link</code></td>
<td>
<p>character vector that specifies transformations used during
optimization and integration of <code>c.int</code>.  See corresponding 
documentation in <code>wBuild</code> function for more details.</p>
</td></tr>
<tr><td><code id="wMix_+3A_c.link.params">c.link.params</code></td>
<td>
<p>Optional list of additional parameters for link
functions used with <code>c.int</code>.   See corresponding 
documentation in <code>wBuild</code> function for more details.</p>
</td></tr>
<tr><td><code id="wMix_+3A_c.optim.control">c.optim.control</code></td>
<td>
<p>Arguments used to find mode of <code>c.int</code>.   See 
corresponding  documentation in <code>wBuild</code> function for more details.</p>
</td></tr>
<tr><td><code id="wMix_+3A_ncores">ncores</code></td>
<td>
<p>number of cores used to parallelize computation of parameters
for <code class="reqn">f(\theta_1 | \theta_2, X)</code>.</p>
</td></tr>
<tr><td><code id="wMix_+3A_quaderror">quadError</code></td>
<td>
<p>TRUE if integration nodes and weight should be computed for
the <code>level-1</code> integration grid, so that quadrature approximation
error can be estimated.</p>
</td></tr>
<tr><td><code id="wMix_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>f1</code>, <code>f1.precompute</code>,
<code>f12</code>, and <code>f2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>wMix</code>, which contains the following items.
</p>

<dl>
<dt><code>f</code></dt><dd><p>Function for evaluating the posterior density
<code class="reqn">f(\theta_1|X)</code>.  <code>f</code> is callable  via
<code>f(theta1, log, ...)</code>.</p>
</dd>
<dt><code>mix</code></dt><dd><p>A matrix containing the pre-computed parameters for
evaluating the mixture components <code class="reqn">f(\theta_1 | \theta_2, X)</code>.
Each row of the matrix contains parameters for one of the <code class="reqn">K</code>
mixture components.</p>
</dd>
<dt><code>wts</code></dt><dd><p>Integration weights for each of the mixture components.
Some of the weights may be negative.</p>
</dd>
<dt><code>expectation</code></dt><dd><p>List containing additional tools for computing
posterior expectations of <code class="reqn">f(\theta_2|X)</code>.  However, posterior
expectations of <code class="reqn">f(\theta_1|X)</code> can also be computed when
expectations of <code class="reqn">f(\theta_1|\theta_2, X)</code> are known.  The elements
of <code>expectation</code> are
</p>

<dl>
<dt><code>Eh</code></dt><dd><p>Function to compute <code class="reqn">E[h(\theta_2)|X]</code>.
<code>Eh</code> is callable via <code>Eh(h, ...)</code>, where <code>h</code> is a
function callable via <code>h(theta2, ...)</code> and <code>...</code> are
additional arguments to the function.  The function <code>h</code> is
evaluated at the quadrature nodes <code class="reqn">\theta_2^{(j)}</code>.</p>
</dd>
<dt><code>Eh.precompute</code></dt><dd><p>Exactly the same idea as <code>Eh</code>, but
the function <code>h</code> is evalauted at the quadrature nodes after
being passed through the function <code>f1.precompute</code>.</p>
</dd>
<dt><code>grid</code></dt><dd><p>The sparse-quadrature integration grid used.
Helpful for seeing the quadrature nodes <code class="reqn">\theta_2^{(j)}</code>.</p>
</dd>
<dt><code>wts</code></dt><dd><p>The integration weights for approximating the
expectation <code class="reqn">E[h]</code>.  Note that these integration weights may
differ from the main integration weights for evaluating the
posterior density <code class="reqn">f(\theta_1|X)</code>.</p>
</dd>
</dl>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Use BISQuE to approximate the marginal posterior distribution for unknown
# population f(N|c, r) for the fur seals capture-recapture data example in 
# Givens and Hoeting (2013), example 7.10.

data('furseals')

# define theta transformation and jacobian
tx.theta = function(theta) { 
  c(log(theta[1]/theta[2]), log(sum(theta[1:2]))) 
}
itx.theta = function(u) { 
  c(exp(sum(u[1:2])), exp(u[2])) / (1 + exp(u[1])) 
}
lJ.tx.theta = function(u) {
  log(exp(u[1] + 2*u[2]) + exp(2*sum(u[1:2]))) - 3 * log(1 + exp(u[1]))
}

# compute constants
r = sum(furseals$m)
nC = nrow(furseals)

# set basic initialization for parameters
init = list(U = c(-.7, 5.5))
init = c(init, list(
  alpha = rep(.5, nC),
  theta = itx.theta(init$U),
  N = r + 1
))


post.alpha_theta = function(theta2, log = TRUE, ...) {
  # Function proportional to f(alpha, U1, U2 | c, r) 
  
  alpha = theta2[1:nC]
  u = theta2[-(1:nC)]
  theta = itx.theta(u)
  p = 1 - prod(1-alpha)
  
  res = - sum(theta)/1e3 - r * log(p) + lJ.tx.theta(u) - 
    nC * lbeta(theta[1], theta[2])
  for(i in 1:nC) {
    res = res + (theta[1] + furseals$c[i] - 1)*log(alpha[i]) + 
      (theta[2] + r - furseals$c[i] - 1)*log(1-alpha[i])
  }
  
  if(log) { res } else { exp(res) }
}

post.N.mixtures = function(N, params, log = TRUE, ...) {
  # The mixture component of the weighted mixtures for f(N | c, r)
  dnbinom(x = N-r, size = r, prob = params, log = log)
}

mixparams.N = function(theta2, ...) {
  # compute parameters for post.N.mixtures
  1 - prod(1 - theta2[1:nC])
}


w.N = wBuild(f = post.alpha_theta, init = c(init$alpha, init$U), 
             approx = 'gauss', link = c(rep('logit', nC), rep('identity', 2)))

m.N = wMix(f1 = post.N.mixtures, f1.precompute = mixparams.N, 
           f2 = post.alpha_theta, w = w.N)



# compute posterior mean
m.N$expectation$Eh.precompute(h = function(p) ((1-p)*r/p + r), 
                                   quadError = TRUE)

# compute posterior density
post.N.dens = data.frame(N = r:105)
post.N.dens$d = m.N$f(post.N.dens$N)

# plot posterior density
plot(d~N, post.N.dens, ylab = expression(f(N~'|'~bold(c),r)))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
