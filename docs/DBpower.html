<!DOCTYPE html><html><head><title>Help for package DBpower</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DBpower}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BJ_func'><p>Internal function - the BJ objective function minus the observed value, put it into uniroot to find the</p>
test statistic magnitude bound at order statistic k of d that will give the observed BJ value.</a></li>
<li><a href='#calc_exact_power'><p>calc_exact_power.R</p></a></li>
<li><a href='#calcb1'><p>calc_b1.R</p></a></li>
<li><a href='#calcb2'><p>calc_b2.R</p></a></li>
<li><a href='#checkBoundsCross'><p>Internal function to check if bounds are violated.</p>
Bounds should be smallest to largest.</a></li>
<li><a href='#checkBoundsLower1'><p>Internal function to check if test statistics fall within the region</p>
used for b1 lower bound, 1 minus the result of this is the lower bound on the power..</a></li>
<li><a href='#checkBoundsLower2'><p>Internal function to check if test statistics fall within the region</p>
used for b2 lower bound, 1 minus the result of this is the lower bound on the power.</a></li>
<li><a href='#checkBoundsUpper1'><p>Internal function to check if test statistics fall within the region</p>
used for b1 uupper bound, 1 minus the result of this is the upper bound on the power.</a></li>
<li><a href='#checkBoundsUpper2'><p>Internal function to check if test statistics fall within the region</p>
used for b2 upper bound, 1 minus the result of this is the upper bound on the power.</a></li>
<li><a href='#createMj'><p>Create the matrix that linearly transforms the vector of test statistics</p>
into a quantity amenable for pmvnorm.</a></li>
<li><a href='#createMjk'><p>Create the matrix that linearly transforms the vector of test statistics</p>
into a quantity amenable for pmvnorm.</a></li>
<li><a href='#GBJ_bound1_root'><p>Internal function - put this function into uniroot to find the magnitude of the largest test statistic that will</p>
give a p-value of alpha.</a></li>
<li><a href='#performIntegralLower1'><p>Apply this function over 1:J to calculate each portion of the integral</p>
we need for the lower bound.</a></li>
<li><a href='#performIntegralLower2'><p>Apply this function over all m, j not equal (order matters) to calculate each portion of the integral</p>
we need for the lower bound for calc_b2.</a></li>
<li><a href='#performIntegralUpper1'><p>Apply this function over 1:J to calculate each portion of the integral</p>
we need for the upper bound.</a></li>
<li><a href='#performIntegralUpper2'><p>Apply this function over all m, j not equal (order matters) to calculate each portion of the integral</p>
we need for the lower bound for calc_b2.</a></li>
<li><a href='#set_BJ_bounds'><p>set_BJ_bounds.R</p></a></li>
<li><a href='#set_GBJ_bounds'><p>set_GBJ_bounds.R</p></a></li>
<li><a href='#sim_b1'><p>sim_R1.R</p></a></li>
<li><a href='#sim_b2'><p>sim_b2.R</p></a></li>
<li><a href='#sim_power_mvn'><p>sim_power_mvn.R</p></a></li>
<li><a href='#sim_stats_mef'><p>sim_power_indiv.R</p></a></li>
<li><a href='#sim_stats_mo'><p>Simulate power starting from individual-level data for multiple</p>
outcomes setting.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Finite Sample Power Calculations for Detection Boundary Tests</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates lower bound on power, upper bound on power, and exact power (small sets only) for detection boundary tests (e.g. Berk-Jones, Generalized Berk-Jones, innovated Berk-Jones) used in set-based inference studies. These detection boundary tests are described in Sun et al., (2019) &lt;<a href="https://doi.org/10.1080%2F01621459.2019.1660170">doi:10.1080/01621459.2019.1660170</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, magrittr, stats, mvtnorm, combinat, GBJ, kit,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, bindata, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-09 17:30:51 UTC; rsun3</td>
</tr>
<tr>
<td>Author:</td>
<td>Ryan Sun [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ryan Sun &lt;ryansun.work@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-10 19:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='BJ_func'>Internal function - the BJ objective function minus the observed value, put it into uniroot to find the
test statistic magnitude bound at order statistic k of d that will give the observed BJ value.</h2><span id='topic+BJ_func'></span>

<h3>Description</h3>

<p>Internal function - the BJ objective function minus the observed value, put it into uniroot to find the
test statistic magnitude bound at order statistic k of d that will give the observed BJ value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BJ_func(x, k, d, b)
</code></pre>

<hr>
<h2 id='calc_exact_power'>calc_exact_power.R</h2><span id='topic+calc_exact_power'></span>

<h3>Description</h3>

<p>For detection boundary type tests, find the power given the rejection region bounds and
specification of alternative. Do not use for sets larger than 5 elements, will be too slow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_exact_power(bounds, sig_mat, muVec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_exact_power_+3A_bounds">bounds</code></td>
<td>
<p>A d=J*1 vector of bounds on the magnitudes of the test statistics, where
the first element is the bound for |Z|_(1) and the last element is the bound for |Z|_(J).</p>
</td></tr>
<tr><td><code id="calc_exact_power_+3A_sig_mat">sig_mat</code></td>
<td>
<p>The covariance matrix of the test statistics under the alternative (assume multivariate normal).</p>
</td></tr>
<tr><td><code id="calc_exact_power_+3A_muvec">muVec</code></td>
<td>
<p>The mean vector of the test statistics under the alternative (assume multivariate normal).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>power</code></td>
<td>
<p>Power under the given alternative.</p>
</td></tr>
<tr><td><code>errsum</code></td>
<td>
<p>Largest possible error from integration.</p>
</td></tr>
<tr><td><code>naSum</code></td>
<td>
<p>Number of NAs in calculating all integrals.</p>
</td></tr>
<tr><td><code>sumOverA</code></td>
<td>
<p>Matrix with power, errsum, naSum for each partition of the rejection region.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
myCov &lt;- matrix(data=0.3, nrow=5, ncol=5)
diag(myCov) &lt;- 1
myBounds &lt;- set_GBJ_bounds(alpha = 0.01, J=5, sig_vec = myCov[lower.tri(myCov)])
calc_exact_power(bounds = myBounds, sig_mat = myCov, muVec = c(1, 0, 0, 0, 0))

</code></pre>

<hr>
<h2 id='calcb1'>calc_b1.R</h2><span id='topic+calcb1'></span>

<h3>Description</h3>

<p>Calculate lower bound or upper bound on power when considering only the largest
test statistic in magnitude, i.e. only |Z|_(J) and not |Z|_(J-1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcb1(lower = TRUE, upper = FALSE, muVec, sigMat, bounds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcb1_+3A_lower">lower</code></td>
<td>
<p>Boolean, whether to calculate lower bound.</p>
</td></tr>
<tr><td><code id="calcb1_+3A_upper">upper</code></td>
<td>
<p>Boolean, whether to calculate upper bound.</p>
</td></tr>
<tr><td><code id="calcb1_+3A_muvec">muVec</code></td>
<td>
<p>Mean vector of test statistics under the alternative (assuming it's MVN).</p>
</td></tr>
<tr><td><code id="calcb1_+3A_sigmat">sigMat</code></td>
<td>
<p>Covariance matrix of test statistics under the alternative (assuming it's MVN).</p>
</td></tr>
<tr><td><code id="calcb1_+3A_bounds">bounds</code></td>
<td>
<p>A J*1 vector of bounds on the magnitudes of the test statistics, where
the first element is the bound for |Z|_(1) and the last element is the bound for |Z|_(J).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>allProbsLower</code></td>
<td>
<p>J*1 vector of all components summed to calculate lower bound.</p>
</td></tr>
<tr><td><code>lowerProb</code></td>
<td>
<p>Lower bound.</p>
</td></tr>
<tr><td><code>allProbsUpper</code></td>
<td>
<p>J*1 vector of all components summed to calculate upper bound.</p>
</td></tr>
<tr><td><code>upperProb</code></td>
<td>
<p>Upper bound.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>myCov &lt;- matrix(data=0.3, nrow=5, ncol=5)
diag(myCov) &lt;- 1
myBounds &lt;- set_GBJ_bounds(alpha = 0.01, J=5, sig_vec = myCov[lower.tri(myCov)])
calcb1(muVec = c(1, 0, 0, 0, 0), sigMat = myCov, bounds=myBounds)

</code></pre>

<hr>
<h2 id='calcb2'>calc_b2.R</h2><span id='topic+calcb2'></span>

<h3>Description</h3>

<p>Calculate lower bound or upper bound on power when considering only the two largest
test statistic in magnitude, i.e. only |Z|_(J) and |Z|_(J-1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcb2(lower = TRUE, upper = FALSE, muVec, sigMat, bounds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcb2_+3A_lower">lower</code></td>
<td>
<p>Boolean, whether to calculate lower bound.</p>
</td></tr>
<tr><td><code id="calcb2_+3A_upper">upper</code></td>
<td>
<p>Boolean, whether to calculate upper bound.</p>
</td></tr>
<tr><td><code id="calcb2_+3A_muvec">muVec</code></td>
<td>
<p>Mean vector of test statistics under the alternative (assuming it's MVN).</p>
</td></tr>
<tr><td><code id="calcb2_+3A_sigmat">sigMat</code></td>
<td>
<p>Covariance matrix of test statistics under the alternative (assuming it's MVN).</p>
</td></tr>
<tr><td><code id="calcb2_+3A_bounds">bounds</code></td>
<td>
<p>A J*1 vector of bounds on the magnitudes of the test statistics, where
the first element is the bound for |Z|_(1) and the last element is the bound for |Z|_(J).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>allProbsLower</code></td>
<td>
<p>J*1 vector of all components summed to calculate lower bound.</p>
</td></tr>
<tr><td><code>lowerProb</code></td>
<td>
<p>Lower bound.</p>
</td></tr>
<tr><td><code>allProbsUpper</code></td>
<td>
<p>J*1 vector of all components summed to calculate upper bound.</p>
</td></tr>
<tr><td><code>upperProb</code></td>
<td>
<p>Upper bound.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>myCov &lt;- matrix(data=0.3, nrow=5, ncol=5)
diag(myCov) &lt;- 1
myBounds &lt;- set_GBJ_bounds(alpha = 0.01, J=5, sig_vec = myCov[lower.tri(myCov)])
calcb2(muVec = c(1, 0, 0, 0, 0), sigMat = myCov, bounds=myBounds)

</code></pre>

<hr>
<h2 id='checkBoundsCross'>Internal function to check if bounds are violated.
Bounds should be smallest to largest.</h2><span id='topic+checkBoundsCross'></span>

<h3>Description</h3>

<p>Internal function to check if bounds are violated.
Bounds should be smallest to largest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkBoundsCross(x, bounds)
</code></pre>

<hr>
<h2 id='checkBoundsLower1'>Internal function to check if test statistics fall within the region
used for b1 lower bound, 1 minus the result of this is the lower bound on the power..</h2><span id='topic+checkBoundsLower1'></span>

<h3>Description</h3>

<p>Internal function to check if test statistics fall within the region
used for b1 lower bound, 1 minus the result of this is the lower bound on the power..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkBoundsLower1(x, bounds)
</code></pre>

<hr>
<h2 id='checkBoundsLower2'>Internal function to check if test statistics fall within the region
used for b2 lower bound, 1 minus the result of this is the lower bound on the power.</h2><span id='topic+checkBoundsLower2'></span>

<h3>Description</h3>

<p>Internal function to check if test statistics fall within the region
used for b2 lower bound, 1 minus the result of this is the lower bound on the power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkBoundsLower2(x, J, bounds)
</code></pre>

<hr>
<h2 id='checkBoundsUpper1'>Internal function to check if test statistics fall within the region
used for b1 uupper bound, 1 minus the result of this is the upper bound on the power.</h2><span id='topic+checkBoundsUpper1'></span>

<h3>Description</h3>

<p>Internal function to check if test statistics fall within the region
used for b1 uupper bound, 1 minus the result of this is the upper bound on the power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkBoundsUpper1(x, J, bounds)
</code></pre>

<hr>
<h2 id='checkBoundsUpper2'>Internal function to check if test statistics fall within the region
used for b2 upper bound, 1 minus the result of this is the upper bound on the power.</h2><span id='topic+checkBoundsUpper2'></span>

<h3>Description</h3>

<p>Internal function to check if test statistics fall within the region
used for b2 upper bound, 1 minus the result of this is the upper bound on the power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkBoundsUpper2(x, J, bounds)
</code></pre>

<hr>
<h2 id='createMj'>Create the matrix that linearly transforms the vector of test statistics
into a quantity amenable for pmvnorm.</h2><span id='topic+createMj'></span>

<h3>Description</h3>

<p>Create the matrix that linearly transforms the vector of test statistics
into a quantity amenable for pmvnorm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createMj(j, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createMj_+3A_j">j</code></td>
<td>
<p>The element of the vector that is the largest.</p>
</td></tr>
<tr><td><code id="createMj_+3A_size">size</code></td>
<td>
<p>The length of the set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The transformation matrix of dimension (2J-1)*(2J-1)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>createMj(j=3, size=5)
</code></pre>

<hr>
<h2 id='createMjk'>Create the matrix that linearly transforms the vector of test statistics
into a quantity amenable for pmvnorm.</h2><span id='topic+createMjk'></span>

<h3>Description</h3>

<p>Create the matrix that linearly transforms the vector of test statistics
into a quantity amenable for pmvnorm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createMjk(j, k, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createMjk_+3A_j">j</code></td>
<td>
<p>The element of the vector that is the largest.</p>
</td></tr>
<tr><td><code id="createMjk_+3A_k">k</code></td>
<td>
<p>The element of the vector that is the second largest.</p>
</td></tr>
<tr><td><code id="createMjk_+3A_size">size</code></td>
<td>
<p>The length of the set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The transformation matrix of dimension (2J-1)*(2J-1)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>createMjk(j=3, k=4, size=5)
</code></pre>

<hr>
<h2 id='GBJ_bound1_root'>Internal function - put this function into uniroot to find the magnitude of the largest test statistic that will
give a p-value of alpha.</h2><span id='topic+GBJ_bound1_root'></span>

<h3>Description</h3>

<p>Internal function - put this function into uniroot to find the magnitude of the largest test statistic that will
give a p-value of alpha.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GBJ_bound1_root(x, alpha, d, sig_vec)
</code></pre>

<hr>
<h2 id='performIntegralLower1'>Apply this function over 1:J to calculate each portion of the integral
we need for the lower bound.</h2><span id='topic+performIntegralLower1'></span>

<h3>Description</h3>

<p>Apply this function over 1:J to calculate each portion of the integral
we need for the lower bound.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>performIntegralLower1(j, muVec, sigMat, lBounds1, uBounds1, lBounds2, uBounds2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="performIntegralLower1_+3A_j">j</code></td>
<td>
<p>Apply over this integer, the element that will be the largest in magnitude.</p>
</td></tr>
<tr><td><code id="performIntegralLower1_+3A_muvec">muVec</code></td>
<td>
<p>Mean vector of test statistics under the alternative (assuming it's MVN).</p>
</td></tr>
<tr><td><code id="performIntegralLower1_+3A_sigmat">sigMat</code></td>
<td>
<p>Covariance matrix of test statistics under the alternative (assuming it's MVN).</p>
</td></tr>
<tr><td><code id="performIntegralLower1_+3A_lbounds1">lBounds1</code></td>
<td>
<p>A 2J-1 vector of lower bounds for the first integral (see paper).</p>
</td></tr>
<tr><td><code id="performIntegralLower1_+3A_ubounds1">uBounds1</code></td>
<td>
<p>A 2J-1 vector of upper bounds for the second integral (see paper).</p>
</td></tr>
<tr><td><code id="performIntegralLower1_+3A_lbounds2">lBounds2</code></td>
<td>
<p>A 2J-1 vector of lower bounds for the first integral (see paper).</p>
</td></tr>
<tr><td><code id="performIntegralLower1_+3A_ubounds2">uBounds2</code></td>
<td>
<p>A 2J-1 vector of upper bounds for the second integral (see paper).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the integration.
</p>

<hr>
<h2 id='performIntegralLower2'>Apply this function over all m, j not equal (order matters) to calculate each portion of the integral
we need for the lower bound for calc_b2.</h2><span id='topic+performIntegralLower2'></span>

<h3>Description</h3>

<p>Apply this function over all m, j not equal (order matters) to calculate each portion of the integral
we need for the lower bound for calc_b2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>performIntegralLower2(
  x,
  muVec,
  sigMat,
  lBounds1,
  uBounds1,
  lBounds2,
  uBounds2,
  lBounds3,
  uBounds3,
  lBounds4,
  uBounds4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="performIntegralLower2_+3A_x">x</code></td>
<td>
<p>Apply over this 2*1 vector, the element that will be the largest in magnitude.</p>
</td></tr>
<tr><td><code id="performIntegralLower2_+3A_muvec">muVec</code></td>
<td>
<p>Mean vector of test statistics under the alternative (assuming it's MVN).</p>
</td></tr>
<tr><td><code id="performIntegralLower2_+3A_sigmat">sigMat</code></td>
<td>
<p>Covariance matrix of test statistics under the alternative (assuming it's MVN).</p>
</td></tr>
<tr><td><code id="performIntegralLower2_+3A_lbounds1">lBounds1</code></td>
<td>
<p>A 2J-1 vector of lower bounds for the first integral (see paper).</p>
</td></tr>
<tr><td><code id="performIntegralLower2_+3A_ubounds1">uBounds1</code></td>
<td>
<p>A 2J-1 vector of upper bounds for the second integral (see paper).</p>
</td></tr>
<tr><td><code id="performIntegralLower2_+3A_lbounds2">lBounds2</code></td>
<td>
<p>A 2J-1 vector of lower bounds for the first integral (see paper).</p>
</td></tr>
<tr><td><code id="performIntegralLower2_+3A_ubounds2">uBounds2</code></td>
<td>
<p>A 2J-1 vector of upper bounds for the second integral (see paper).</p>
</td></tr>
<tr><td><code id="performIntegralLower2_+3A_lbounds3">lBounds3</code></td>
<td>
<p>A 2J-1 vector of lower bounds for the third integral (see paper).</p>
</td></tr>
<tr><td><code id="performIntegralLower2_+3A_ubounds3">uBounds3</code></td>
<td>
<p>A 2J-1 vector of upper bounds for the third integral (see paper).</p>
</td></tr>
<tr><td><code id="performIntegralLower2_+3A_lbounds4">lBounds4</code></td>
<td>
<p>A 2J-1 vector of lower bounds for the fourth integral (see paper).</p>
</td></tr>
<tr><td><code id="performIntegralLower2_+3A_ubounds4">uBounds4</code></td>
<td>
<p>A 2J-1 vector of upper bounds for the fourth integral (see paper).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the integration.
</p>

<hr>
<h2 id='performIntegralUpper1'>Apply this function over 1:J to calculate each portion of the integral
we need for the upper bound.</h2><span id='topic+performIntegralUpper1'></span>

<h3>Description</h3>

<p>Apply this function over 1:J to calculate each portion of the integral
we need for the upper bound.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>performIntegralUpper1(j, muVec, sigMat, lBounds1, uBounds1, lBounds2, uBounds2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="performIntegralUpper1_+3A_j">j</code></td>
<td>
<p>Apply over this integer, the element that will be the largest in magnitude.</p>
</td></tr>
<tr><td><code id="performIntegralUpper1_+3A_muvec">muVec</code></td>
<td>
<p>Mean vector of test statistics under the alternative (assuming it's MVN).</p>
</td></tr>
<tr><td><code id="performIntegralUpper1_+3A_sigmat">sigMat</code></td>
<td>
<p>Covariance matrix of test statistics under the alternative (assuming it's MVN).</p>
</td></tr>
<tr><td><code id="performIntegralUpper1_+3A_lbounds1">lBounds1</code></td>
<td>
<p>A 3J-2 vector of lower bounds for the first integral (see paper), bounds will be longer than for performIntegralLower1.</p>
</td></tr>
<tr><td><code id="performIntegralUpper1_+3A_ubounds1">uBounds1</code></td>
<td>
<p>A 3J-2 vector of upper bounds for the second integral (see paper).</p>
</td></tr>
<tr><td><code id="performIntegralUpper1_+3A_lbounds2">lBounds2</code></td>
<td>
<p>A 3J-2 vector of lower bounds for the first integral (see paper).</p>
</td></tr>
<tr><td><code id="performIntegralUpper1_+3A_ubounds2">uBounds2</code></td>
<td>
<p>A 3J-2 vector of upper bounds for the second integral (see paper).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the integration.
</p>

<hr>
<h2 id='performIntegralUpper2'>Apply this function over all m, j not equal (order matters) to calculate each portion of the integral
we need for the lower bound for calc_b2.</h2><span id='topic+performIntegralUpper2'></span>

<h3>Description</h3>

<p>Apply this function over all m, j not equal (order matters) to calculate each portion of the integral
we need for the lower bound for calc_b2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>performIntegralUpper2(
  x,
  muVec,
  sigMat,
  lBounds1,
  uBounds1,
  lBounds2,
  uBounds2,
  lBounds3,
  uBounds3,
  lBounds4,
  uBounds4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="performIntegralUpper2_+3A_x">x</code></td>
<td>
<p>Apply over this 2*1 vector, the elements that will be the largest and second largest in magnitude.</p>
</td></tr>
<tr><td><code id="performIntegralUpper2_+3A_muvec">muVec</code></td>
<td>
<p>Mean vector of test statistics under the alternative (assuming it's MVN).</p>
</td></tr>
<tr><td><code id="performIntegralUpper2_+3A_sigmat">sigMat</code></td>
<td>
<p>Covariance matrix of test statistics under the alternative (assuming it's MVN).</p>
</td></tr>
<tr><td><code id="performIntegralUpper2_+3A_lbounds1">lBounds1</code></td>
<td>
<p>A 3J-2 vector of lower bounds for the first integral (see paper).</p>
</td></tr>
<tr><td><code id="performIntegralUpper2_+3A_ubounds1">uBounds1</code></td>
<td>
<p>A 3J-2 vector of upper bounds for the second integral (see paper).</p>
</td></tr>
<tr><td><code id="performIntegralUpper2_+3A_lbounds2">lBounds2</code></td>
<td>
<p>A 3J-2 vector of lower bounds for the first integral (see paper).</p>
</td></tr>
<tr><td><code id="performIntegralUpper2_+3A_ubounds2">uBounds2</code></td>
<td>
<p>A J3J-2 vector of upper bounds for the second integral (see paper).</p>
</td></tr>
<tr><td><code id="performIntegralUpper2_+3A_lbounds3">lBounds3</code></td>
<td>
<p>A 3J-2 vector of lower bounds for the third integral (see paper).</p>
</td></tr>
<tr><td><code id="performIntegralUpper2_+3A_ubounds3">uBounds3</code></td>
<td>
<p>A 3J-2 vector of upper bounds for the third integral (see paper).</p>
</td></tr>
<tr><td><code id="performIntegralUpper2_+3A_lbounds4">lBounds4</code></td>
<td>
<p>A 3J-2 vector of lower bounds for the fourth integral (see paper).</p>
</td></tr>
<tr><td><code id="performIntegralUpper2_+3A_ubounds4">uBounds4</code></td>
<td>
<p>A 3J-2 vector of upper bounds for the fourth integral (see paper).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the integration.
</p>

<hr>
<h2 id='set_BJ_bounds'>set_BJ_bounds.R</h2><span id='topic+set_BJ_bounds'></span>

<h3>Description</h3>

<p>Finds the boundary points of the rejection region for the BJ statistic when
all elements in a set are independent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_BJ_bounds(alpha, J)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_BJ_bounds_+3A_alpha">alpha</code></td>
<td>
<p>Type I error of test.</p>
</td></tr>
<tr><td><code id="set_BJ_bounds_+3A_j">J</code></td>
<td>
<p>Number of elements in set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A J*1 vector of bounds on the magnitudes of the test statistics, where
the first element is the bound for |Z|_(1) and the last element is the bound for |Z|_(J).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set_BJ_bounds(alpha = 0.01, J=5)

</code></pre>

<hr>
<h2 id='set_GBJ_bounds'>set_GBJ_bounds.R</h2><span id='topic+set_GBJ_bounds'></span>

<h3>Description</h3>

<p>Finds the boundary points of the rejection region for the GBJ statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_GBJ_bounds(alpha, J, sig_vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_GBJ_bounds_+3A_alpha">alpha</code></td>
<td>
<p>Type I error of test.</p>
</td></tr>
<tr><td><code id="set_GBJ_bounds_+3A_j">J</code></td>
<td>
<p>Number of elements in set.</p>
</td></tr>
<tr><td><code id="set_GBJ_bounds_+3A_sig_vec">sig_vec</code></td>
<td>
<p>A vector generated from sigma[lower.tri(sigma)] where sigma is the
correlation matrix of the test statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A J*1 vector of bounds on the magnitudes of the test statistics, where
the first element is the bound for |Z|_(1) and the last element is the bound for |Z|_(J).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myCov &lt;- matrix(data=0.3, nrow=5, ncol=5)
diag(myCov) &lt;- 1
set_GBJ_bounds(alpha = 0.01, J=5, sig_vec = myCov[lower.tri(myCov)])

</code></pre>

<hr>
<h2 id='sim_b1'>sim_R1.R</h2><span id='topic+sim_b1'></span>

<h3>Description</h3>

<p>Simulate the probability of falling in the region used for the b1 lower
bound or the b1 upper bound.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_b1(lower = TRUE, upper = TRUE, n, muVec, sigMat, bounds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_b1_+3A_lower">lower</code></td>
<td>
<p>Boolean, if true sim lower bound.</p>
</td></tr>
<tr><td><code id="sim_b1_+3A_upper">upper</code></td>
<td>
<p>Boolean, if true sim upper bound.</p>
</td></tr>
<tr><td><code id="sim_b1_+3A_n">n</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
<tr><td><code id="sim_b1_+3A_muvec">muVec</code></td>
<td>
<p>Mean vector of test statistics under the alternative (assuming it's MVN).</p>
</td></tr>
<tr><td><code id="sim_b1_+3A_sigmat">sigMat</code></td>
<td>
<p>Covariance matrix of test statistics under the alternative (assuming it's MVN).</p>
</td></tr>
<tr><td><code id="sim_b1_+3A_bounds">bounds</code></td>
<td>
<p>A J*1 vector of bounds on the magnitudes of the test statistics, where
the first element is the bound for |Z|_(1) and the last element is the bound for |Z|_(J).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>lowerBound</code></td>
<td>
<p>Lower bound on power.</p>
</td></tr>
<tr><td><code>upperBound</code></td>
<td>
<p>Upper bound on power.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>myCov &lt;- matrix(data=0.3, nrow=5, ncol=5)
diag(myCov) &lt;- 1
myBounds &lt;- set_GBJ_bounds(alpha = 0.01, J=5, sig_vec = myCov[lower.tri(myCov)])
sim_b1(n=5000, muVec = c(1, 0, 0, 0, 0), sigMat = myCov, bounds=myBounds)

</code></pre>

<hr>
<h2 id='sim_b2'>sim_b2.R</h2><span id='topic+sim_b2'></span>

<h3>Description</h3>

<p>Simulate the probability of falling in the region used for the b2 lower
bound or the b2 upper bound.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_b2(lower = TRUE, upper = FALSE, n, muVec, sigMat, bounds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_b2_+3A_lower">lower</code></td>
<td>
<p>Boolean, if true sim lower bound.</p>
</td></tr>
<tr><td><code id="sim_b2_+3A_upper">upper</code></td>
<td>
<p>Boolean, if true sim upper bound.</p>
</td></tr>
<tr><td><code id="sim_b2_+3A_n">n</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
<tr><td><code id="sim_b2_+3A_muvec">muVec</code></td>
<td>
<p>Mean vector of test statistics under the alternative (assuming it's MVN).</p>
</td></tr>
<tr><td><code id="sim_b2_+3A_sigmat">sigMat</code></td>
<td>
<p>Covariance matrix of test statistics under the alternative (assuming it's MVN).</p>
</td></tr>
<tr><td><code id="sim_b2_+3A_bounds">bounds</code></td>
<td>
<p>A J*1 vector of bounds on the magnitudes of the test statistics, where
the first element is the bound for |Z|_(1) and the last element is the bound for |Z|_(J).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>lowerBound</code></td>
<td>
<p>Lower bound on power.</p>
</td></tr>
<tr><td><code>upperBound</code></td>
<td>
<p>Upper bound on power.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>myCov &lt;- matrix(data=0.3, nrow=5, ncol=5)
diag(myCov) &lt;- 1
myBounds &lt;- set_GBJ_bounds(alpha = 0.01, J=5, sig_vec = myCov[lower.tri(myCov)])
sim_b2(n=5000, muVec = c(1, 0, 0, 0, 0), sigMat = myCov, bounds=myBounds)

</code></pre>

<hr>
<h2 id='sim_power_mvn'>sim_power_mvn.R</h2><span id='topic+sim_power_mvn'></span>

<h3>Description</h3>

<p>Simulate power of detection boundary tests starting from multivariate normal test statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_power_mvn(
  n,
  muVec,
  sigMat,
  nullSigMat = NULL,
  bounds = NULL,
  test = NULL,
  alpha
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_power_mvn_+3A_n">n</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
<tr><td><code id="sim_power_mvn_+3A_muvec">muVec</code></td>
<td>
<p>Mean vector of test statistics under the alternative (assuming it's MVN).</p>
</td></tr>
<tr><td><code id="sim_power_mvn_+3A_sigmat">sigMat</code></td>
<td>
<p>Covariance matrix of test statistics under the alternative (assuming it's MVN).</p>
</td></tr>
<tr><td><code id="sim_power_mvn_+3A_nullsigmat">nullSigMat</code></td>
<td>
<p>Assumed correlation matrix of MVN under the null. Only need to specify if specifying test.</p>
</td></tr>
<tr><td><code id="sim_power_mvn_+3A_bounds">bounds</code></td>
<td>
<p>A J*1 vector of bounds on the magnitudes of the test statistics, where
the first element is the bound for |Z|_(1) and the last element is the bound for |Z|_(J).</p>
</td></tr>
<tr><td><code id="sim_power_mvn_+3A_test">test</code></td>
<td>
<p>Either &quot;GHC&quot;, &quot;HC&quot;, &quot;GBJ&quot;, or &quot;BJ&quot; or NULL. If provided, will calculate
the p-value using the specified test and calculate power this way.</p>
</td></tr>
<tr><td><code id="sim_power_mvn_+3A_alpha">alpha</code></td>
<td>
<p>Level of the test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>boundsPower</code></td>
<td>
<p>Power from using bounds approach.</p>
</td></tr>
<tr><td><code>testPower</code></td>
<td>
<p>Power from using specific test p-value approach.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>myCov &lt;- matrix(data=0.3, nrow=5, ncol=5)
diag(myCov) &lt;- 1
myBounds &lt;- set_GBJ_bounds(alpha = 0.01, J=5, sig_vec = myCov[lower.tri(myCov)])
sim_power_mvn(n=1000, muVec = c(1, 0, 0, 0, 0), sigMat = myCov, alpha=0.01)

</code></pre>

<hr>
<h2 id='sim_stats_mef'>sim_power_indiv.R</h2><span id='topic+sim_stats_mef'></span>

<h3>Description</h3>

<p>Simulate power starting from individual-level data for multiple
explanatory factor setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_stats_mef(
  B,
  sigSq,
  xMat,
  gMat,
  alphaVec,
  betaVec,
  decompTrue = NULL,
  checkpoint = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_stats_mef_+3A_b">B</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
<tr><td><code id="sim_stats_mef_+3A_sigsq">sigSq</code></td>
<td>
<p>Variance of outcome.</p>
</td></tr>
<tr><td><code id="sim_stats_mef_+3A_xmat">xMat</code></td>
<td>
<p>Design matrix of non-genetic covariates, n*p.</p>
</td></tr>
<tr><td><code id="sim_stats_mef_+3A_gmat">gMat</code></td>
<td>
<p>Matrix of genotypes, n*J.</p>
</td></tr>
<tr><td><code id="sim_stats_mef_+3A_alphavec">alphaVec</code></td>
<td>
<p>p*1 vector of regression coefficients for xMat.</p>
</td></tr>
<tr><td><code id="sim_stats_mef_+3A_betavec">betaVec</code></td>
<td>
<p>J*1 vector of regression coefficients for gMat.</p>
</td></tr>
<tr><td><code id="sim_stats_mef_+3A_decomptrue">decompTrue</code></td>
<td>
<p>The return value of a call to eigen() on the true covariance matrix. Can be null,
in which case estimated covariance will be used.</p>
</td></tr>
<tr><td><code id="sim_stats_mef_+3A_checkpoint">checkpoint</code></td>
<td>
<p>Boolean, if true then print message every 50 simulations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>zMat</code></td>
<td>
<p>B*J matrix of test statistics Z.</p>
</td></tr>
<tr><td><code>zVecGBJ</code></td>
<td>
<p>Check on Z statistics, vector should match first row of zMat.</p>
</td></tr>
<tr><td><code>iMat</code></td>
<td>
<p>Innovated statistics matrix also of dimension B*J.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
xMat &lt;- cbind(1, rnorm(n = 1000), rbinom(n = 1000, size=1, prob=0.5))
gMat &lt;- matrix(data = rbinom(n=10000, size=2, prob=0.3), nrow=1000)
alphaVec &lt;- c(1, 1, 1)
betaVec &lt;- rep(0, 10)
sim_stats_mef(B=10000, sigSq = 1, xMat = xMat, gMat = gMat, alphaVec = alphaVec, betaVec = betaVec)

</code></pre>

<hr>
<h2 id='sim_stats_mo'>Simulate power starting from individual-level data for multiple
outcomes setting.</h2><span id='topic+sim_stats_mo'></span>

<h3>Description</h3>

<p>Simulate power starting from individual-level data for multiple
outcomes setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_stats_mo(B, covY, xMat, gVec, alphaMat, gammaVec, checkpoint = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_stats_mo_+3A_b">B</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
<tr><td><code id="sim_stats_mo_+3A_covy">covY</code></td>
<td>
<p>Covariance matrix of outcomes.</p>
</td></tr>
<tr><td><code id="sim_stats_mo_+3A_xmat">xMat</code></td>
<td>
<p>Design matrix of non-genetic covariates, n*p.</p>
</td></tr>
<tr><td><code id="sim_stats_mo_+3A_gvec">gVec</code></td>
<td>
<p>n*1 vector of genotypes.</p>
</td></tr>
<tr><td><code id="sim_stats_mo_+3A_alphamat">alphaMat</code></td>
<td>
<p>p*K vector of regression coefficients for xMat.</p>
</td></tr>
<tr><td><code id="sim_stats_mo_+3A_gammavec">gammaVec</code></td>
<td>
<p>K*1 vector of regression coefficients for each outcome.</p>
</td></tr>
<tr><td><code id="sim_stats_mo_+3A_checkpoint">checkpoint</code></td>
<td>
<p>Boolean, if true then print message every 50 simulations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>zMat</code></td>
<td>
<p>Matrix of test statistics Z.</p>
</td></tr>
<tr><td><code>zVecGBJ</code></td>
<td>
<p>Check on Z statistics, vector should match first row of zMat.</p>
</td></tr>
<tr><td><code>iMat</code></td>
<td>
<p>Innovated statistics using correlation matrix under the null.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
covY &lt;- matrix(data=0.3, nrow=10, ncol=10); diag(covY) &lt;- 1
xMat &lt;- cbind(1, rnorm(n = 1000), rbinom(n = 1000, size=1, prob=0.5))
gVec &lt;- rbinom(n= 1000, size = 2, prob=0.3)
alphaMat &lt;-matrix(data = 1, nrow=3, ncol=10)
gammaVec &lt;- rep(0, 10)
sim_stats_mo(B=10000, covY = covY, xMat = xMat, gVec = gVec,
alphaMat = alphaMat, gammaVec = gammaVec)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
